# macOS Gatekeeper / Quarentena / XProtect

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Gostaria de ver sua **empresa anunciada no HackTricks**? ou gostaria de ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud)
*
* .

</details>

## Gatekeeper

**Gatekeeper** √© um recurso de seguran√ßa desenvolvido para sistemas operacionais Mac, projetado para garantir que os usu√°rios **executem apenas software confi√°vel** em seus sistemas. Ele funciona **validando o software** que um usu√°rio baixa e tenta abrir de **fontes fora da App Store**, como um aplicativo, um plug-in ou um pacote de instala√ß√£o.

O mecanismo chave do Gatekeeper reside em seu processo de **verifica√ß√£o**. Ele verifica se o software baixado est√° **assinado por um desenvolvedor reconhecido**, garantindo a autenticidade do software. Al√©m disso, ele verifica se o software est√° **notarizado pela Apple**, confirmando que est√° livre de conte√∫do malicioso conhecido e n√£o foi adulterado ap√≥s a notariza√ß√£o.

Al√©m disso, o Gatekeeper refor√ßa o controle e a seguran√ßa do usu√°rio ao **solicitar a aprova√ß√£o da abertura** do software baixado pela primeira vez. Essa salvaguarda ajuda a evitar que os usu√°rios executem inadvertidamente c√≥digo execut√°vel potencialmente prejudicial que possam ter confundido com um arquivo de dados inofensivo.

### Assinaturas de Aplicativos

As assinaturas de aplicativos, tamb√©m conhecidas como assinaturas de c√≥digo, s√£o um componente cr√≠tico da infraestrutura de seguran√ßa da Apple. Elas s√£o usadas para **verificar a identidade do autor do software** (o desenvolvedor) e garantir que o c√≥digo n√£o tenha sido adulterado desde a √∫ltima assinatura.

Veja como funciona:

1. **Assinando o Aplicativo:** Quando um desenvolvedor est√° pronto para distribuir seu aplicativo, ele **assina o aplicativo usando uma chave privada**. Essa chave privada est√° associada a um **certificado que a Apple emite para o desenvolvedor** quando ele se inscreve no Programa de Desenvolvedor da Apple. O processo de assinatura envolve a cria√ß√£o de um hash criptogr√°fico de todas as partes do aplicativo e a criptografia desse hash com a chave privada do desenvolvedor.
2. **Distribuindo o Aplicativo:** O aplicativo assinado √© ent√£o distribu√≠do aos usu√°rios juntamente com o certificado do desenvolvedor, que cont√©m a chave p√∫blica correspondente.
3. **Verificando o Aplicativo:** Quando um usu√°rio baixa e tenta executar o aplicativo, seu sistema operacional Mac usa a chave p√∫blica do certificado do desenvolvedor para descriptografar o hash. Em seguida, recalcula o hash com base no estado atual do aplicativo e compara isso com o hash descriptografado. Se coincidirem, significa que **o aplicativo n√£o foi modificado** desde que o desenvolvedor o assinou, e o sistema permite a execu√ß√£o do aplicativo.

As assinaturas de aplicativos s√£o uma parte essencial da tecnologia Gatekeeper da Apple. Quando um usu√°rio tenta **abrir um aplicativo baixado da internet**, o Gatekeeper verifica a assinatura do aplicativo. Se estiver assinado com um certificado emitido pela Apple para um desenvolvedor conhecido e o c√≥digo n√£o foi adulterado, o Gatekeeper permite a execu√ß√£o do aplicativo. Caso contr√°rio, bloqueia o aplicativo e alerta o usu√°rio.

A partir do macOS Catalina, **o Gatekeeper tamb√©m verifica se o aplicativo foi notarizado** pela Apple, adicionando uma camada extra de seguran√ßa. O processo de notariza√ß√£o verifica o aplicativo em busca de problemas de seguran√ßa conhecidos e c√≥digo malicioso, e se essas verifica√ß√µes forem aprovadas, a Apple adiciona um ticket ao aplicativo que o Gatekeeper pode verificar.

#### Verificar Assinaturas

Ao verificar algum **exemplo de malware**, voc√™ sempre deve **verificar a assinatura** do bin√°rio, pois o **desenvolvedor** que o assinou pode estar **relacionado** a **malware**.
```bash
# Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

# Check if the app‚Äôs contents have been modified
codesign --verify --verbose /Applications/Safari.app

# Get entitlements from the binary
codesign -d --entitlements :- /System/Applications/Automator.app # Check the TCC perms

# Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app

# Sign a binary
codesign -s <cert-name-keychain> toolsdemo
```
### Notariza√ß√£o

O processo de notariza√ß√£o da Apple serve como uma salvaguarda adicional para proteger os usu√°rios de software potencialmente prejudicial. Envolve o **desenvolvedor submeter sua aplica√ß√£o para exame** pelo **Servi√ßo de Notariza√ß√£o da Apple**, que n√£o deve ser confundido com a Revis√£o de Aplicativos. Este servi√ßo √© um **sistema automatizado** que examina o software enviado em busca de **conte√∫do malicioso** e poss√≠veis problemas com a assinatura de c√≥digo.

Se o software **passar** por essa inspe√ß√£o sem levantar preocupa√ß√µes, o Servi√ßo de Notariza√ß√£o gera um ticket de notariza√ß√£o. O desenvolvedor √© ent√£o obrigado a **anexar este ticket ao seu software**, um processo conhecido como 'grampeamento'. Al√©m disso, o ticket de notariza√ß√£o tamb√©m √© publicado online, onde o Gatekeeper, a tecnologia de seguran√ßa da Apple, pode acess√°-lo.

Na primeira instala√ß√£o ou execu√ß√£o do software pelo usu√°rio, a exist√™ncia do ticket de notariza√ß√£o - seja grampeado ao execut√°vel ou encontrado online - **informa ao Gatekeeper que o software foi notarizado pela Apple**. Como resultado, o Gatekeeper exibe uma mensagem descritiva no di√°logo de lan√ßamento inicial, indicando que o software passou por verifica√ß√µes de conte√∫do malicioso pela Apple. Esse processo, portanto, aumenta a confian√ßa do usu√°rio na seguran√ßa do software que eles instalam ou executam em seus sistemas.

### Enumerando o Gatekeeper

O Gatekeeper √© tanto **v√°rios componentes de seguran√ßa** que impedem a execu√ß√£o de aplicativos n√£o confi√°veis quanto **um dos componentes**.

√â poss√≠vel ver o **status** do Gatekeeper com:
```bash
# Check the status
spctl --status
```
{% hint style="danger" %}
Note que as verifica√ß√µes de assinatura do GateKeeper s√£o realizadas apenas em **arquivos com o atributo de Quarentena**, e n√£o em todos os arquivos.
{% endhint %}

O GateKeeper verificar√° se, de acordo com as **prefer√™ncias e a assinatura**, um bin√°rio pode ser executado:

<figure><img src="../../../.gitbook/assets/image (678).png" alt=""><figcaption></figcaption></figure>

O banco de dados que mant√©m essa configura√ß√£o est√° localizado em **`/var/db/SystemPolicy`**. Voc√™ pode verificar este banco de dados como root com:
```bash
# Open database
sqlite3 /var/db/SystemPolicy

# Get allowed rules
SELECT requirement,allow,disabled,label from authority where label != 'GKE' and disabled=0;
requirement|allow|disabled|label
anchor apple generic and certificate 1[subject.CN] = "Apple Software Update Certification Authority"|1|0|Apple Installer
anchor apple|1|0|Apple System
anchor apple generic and certificate leaf[field.1.2.840.113635.100.6.1.9] exists|1|0|Mac App Store
anchor apple generic and certificate 1[field.1.2.840.113635.100.6.2.6] exists and (certificate leaf[field.1.2.840.113635.100.6.1.14] or certificate leaf[field.1.2.840.113635.100.6.1.13]) and notarized|1|0|Notarized Developer ID
[...]
```
Observe como a primeira regra terminou em "**App Store**" e a segunda em "**Developer ID**" e que na imagem anterior estava **habilitado para executar aplicativos da App Store e desenvolvedores identificados**. Se voc√™ **modificar** essa configura√ß√£o para App Store, as regras de "**Notarized Developer ID" desaparecer√£o**.

Tamb√©m existem milhares de regras do **tipo GKE**:
```bash
SELECT requirement,allow,disabled,label from authority where label = 'GKE' limit 5;
cdhash H"b40281d347dc574ae0850682f0fd1173aa2d0a39"|1|0|GKE
cdhash H"5fd63f5342ac0c7c0774ebcbecaf8787367c480f"|1|0|GKE
cdhash H"4317047eefac8125ce4d44cab0eb7b1dff29d19a"|1|0|GKE
cdhash H"0a71962e7a32f0c2b41ddb1fb8403f3420e1d861"|1|0|GKE
cdhash H"8d0d90ff23c3071211646c4c9c607cdb601cb18f"|1|0|GKE
```
Estes s√£o hashes que v√™m de **`/var/db/SystemPolicyConfiguration/gke.bundle/Contents/Resources/gke.auth`, `/var/db/gke.bundle/Contents/Resources/gk.db`** e **`/var/db/gkopaque.bundle/Contents/Resources/gkopaque.db`**

Ou voc√™ poderia listar as informa√ß√µes anteriores com:
```bash
sudo spctl --list
```
As op√ß√µes **`--master-disable`** e **`--global-disable`** do **`spctl`** ir√£o **desativar completamente** essas verifica√ß√µes de assinatura:
```bash
# Disable GateKeeper
spctl --global-disable
spctl --master-disable

# Enable it
spctl --global-enable
spctl --master-enable
```
Quando totalmente habilitado, uma nova op√ß√£o aparecer√°:

<figure><img src="../../../.gitbook/assets/image (679).png" alt=""><figcaption></figcaption></figure>

√â poss√≠vel **verificar se um aplicativo ser√° permitido pelo GateKeeper** com:
```bash
spctl --assess -v /Applications/App.app
```
√â poss√≠vel adicionar novas regras no GateKeeper para permitir a execu√ß√£o de determinados aplicativos com:
```bash
# Check if allowed - nop
spctl --assess -v /Applications/App.app
/Applications/App.app: rejected
source=no usable signature

# Add a label and allow this label in GateKeeper
sudo spctl --add --label "whitelist" /Applications/App.app
sudo spctl --enable --label "whitelist"

# Check again - yep
spctl --assess -v /Applications/App.app
/Applications/App.app: accepted
```
### Arquivos em Quarentena

Ap√≥s **baixar** um aplicativo ou arquivo, **aplicativos espec√≠ficos do macOS** como navegadores da web ou clientes de e-mail **anexam um atributo de arquivo estendido**, comumente conhecido como "**flag de quarentena**," ao arquivo baixado. Este atributo atua como uma medida de seguran√ßa para **marcar o arquivo** como proveniente de uma fonte n√£o confi√°vel (a internet) e potencialmente portando riscos. No entanto, nem todos os aplicativos anexam esse atributo, por exemplo, softwares comuns de cliente BitTorrent geralmente ignoram esse processo.

**A presen√ßa de uma flag de quarentena sinaliza o recurso de seguran√ßa Gatekeeper do macOS quando um usu√°rio tenta executar o arquivo**.

No caso em que a **flag de quarentena n√£o est√° presente** (como nos arquivos baixados por alguns clientes BitTorrent), as **verifica√ß√µes do Gatekeeper podem n√£o ser realizadas**. Portanto, os usu√°rios devem ter cautela ao abrir arquivos baixados de fontes menos seguras ou desconhecidas.

{% hint style="info" %}
**Verificar** a **validade** das assinaturas de c√≥digo √© um processo **intensivo em recursos** que inclui a gera√ß√£o de **hashes** criptogr√°ficos do c√≥digo e de todos os seus recursos agrupados. Al√©m disso, verificar a validade do certificado envolve fazer uma **verifica√ß√£o online** nos servidores da Apple para ver se ele foi revogado ap√≥s ter sido emitido. Por esses motivos, uma verifica√ß√£o completa de assinatura de c√≥digo e notariza√ß√£o √© **impratic√°vel de ser executada toda vez que um aplicativo √© lan√ßado**.

Portanto, essas verifica√ß√µes s√£o **executadas apenas ao executar aplicativos com o atributo de quarentena**.
{% endhint %}

{% hint style="warning" %}
Este atributo deve ser **definido pelo aplicativo que cria/baixa** o arquivo.

No entanto, arquivos que est√£o isolados ter√£o esse atributo definido para cada arquivo que criam. E aplicativos n√£o isolados podem defini-lo por si pr√≥prios, ou especificar a chave [**LSFileQuarantineEnabled**](https://developer.apple.com/documentation/bundleresources/information\_property\_list/lsfilequarantineenabled?language=objc) no **Info.plist** que far√° o sistema definir o atributo estendido `com.apple.quarantine` nos arquivos criados.
{% endhint %}

√â poss√≠vel **verificar seu status e habilitar/desabilitar** (necess√°rio acesso de root) com:
```bash
spctl --status
assessments enabled

spctl --enable
spctl --disable
#You can also allow nee identifies to execute code using the binary "spctl"
```
Voc√™ tamb√©m pode **verificar se um arquivo possui o atributo de quarentena estendida** com:
```bash
xattr file.png
com.apple.macl
com.apple.quarantine
```
Verifique o **valor** dos **atributos** **estendidos** e descubra o aplicativo que escreveu o atributo de quarentena com:
```bash
xattr -l portada.png
com.apple.macl:
00000000  03 00 53 DA 55 1B AE 4C 4E 88 9D CA B7 5C 50 F3  |..S.U..LN.....P.|
00000010  16 94 03 00 27 63 64 97 98 FB 4F 02 84 F3 D0 DB  |....'cd...O.....|
00000020  89 53 C3 FC 03 00 27 63 64 97 98 FB 4F 02 84 F3  |.S....'cd...O...|
00000030  D0 DB 89 53 C3 FC 00 00 00 00 00 00 00 00 00 00  |...S............|
00000040  00 00 00 00 00 00 00 00                          |........|
00000048
com.apple.quarantine: 00C1;607842eb;Brave;F643CD5F-6071-46AB-83AB-390BA944DEC5
# 00c1 -- It has been allowed to eexcute this file (QTN_FLAG_USER_APPROVED = 0x0040)
# 607842eb -- Timestamp
# Brave -- App
# F643CD5F-6071-46AB-83AB-390BA944DEC5 -- UID assigned to the file downloaded
```
Na verdade, um processo "poderia definir flags de quarentena para os arquivos que cria" (tentei aplicar a flag USER\_APPROVED em um arquivo criado, mas n√£o a aplicou):

<details>

<summary>C√≥digo Fonte aplicar flags de quarentena</summary>
```c
#include <stdio.h>
#include <stdlib.h>

enum qtn_flags {
QTN_FLAG_DOWNLOAD = 0x0001,
QTN_FLAG_SANDBOX = 0x0002,
QTN_FLAG_HARD = 0x0004,
QTN_FLAG_USER_APPROVED = 0x0040,
};

#define qtn_proc_alloc _qtn_proc_alloc
#define qtn_proc_apply_to_self _qtn_proc_apply_to_self
#define qtn_proc_free _qtn_proc_free
#define qtn_proc_init _qtn_proc_init
#define qtn_proc_init_with_self _qtn_proc_init_with_self
#define qtn_proc_set_flags _qtn_proc_set_flags
#define qtn_file_alloc _qtn_file_alloc
#define qtn_file_init_with_path _qtn_file_init_with_path
#define qtn_file_free _qtn_file_free
#define qtn_file_apply_to_path _qtn_file_apply_to_path
#define qtn_file_set_flags _qtn_file_set_flags
#define qtn_file_get_flags _qtn_file_get_flags
#define qtn_proc_set_identifier _qtn_proc_set_identifier

typedef struct _qtn_proc *qtn_proc_t;
typedef struct _qtn_file *qtn_file_t;

int qtn_proc_apply_to_self(qtn_proc_t);
void qtn_proc_init(qtn_proc_t);
int qtn_proc_init_with_self(qtn_proc_t);
int qtn_proc_set_flags(qtn_proc_t, uint32_t flags);
qtn_proc_t qtn_proc_alloc();
void qtn_proc_free(qtn_proc_t);
qtn_file_t qtn_file_alloc(void);
void qtn_file_free(qtn_file_t qf);
int qtn_file_set_flags(qtn_file_t qf, uint32_t flags);
uint32_t qtn_file_get_flags(qtn_file_t qf);
int qtn_file_apply_to_path(qtn_file_t qf, const char *path);
int qtn_file_init_with_path(qtn_file_t qf, const char *path);
int qtn_proc_set_identifier(qtn_proc_t qp, const char* bundleid);

int main() {

qtn_proc_t qp = qtn_proc_alloc();
qtn_proc_set_identifier(qp, "xyz.hacktricks.qa");
qtn_proc_set_flags(qp, QTN_FLAG_DOWNLOAD | QTN_FLAG_USER_APPROVED);
qtn_proc_apply_to_self(qp);
qtn_proc_free(qp);

FILE *fp;
fp = fopen("thisisquarantined.txt", "w+");
fprintf(fp, "Hello Quarantine\n");
fclose(fp);

return 0;

}
```
</details>

E **remova** esse atributo com:
```bash
xattr -d com.apple.quarantine portada.png
#You can also remove this attribute from every file with
find . -iname '*' -print0 | xargs -0 xattr -d com.apple.quarantine
```
E encontre todos os arquivos em quarentena com:

{% code overflow="wrap" %}
```bash
find / -exec ls -ld {} \; 2>/dev/null | grep -E "[x\-]@ " | awk '{printf $9; printf "\n"}' | xargs -I {} xattr -lv {} | grep "com.apple.quarantine"
```
{% endcode %}

As informa√ß√µes de quarentena tamb√©m s√£o armazenadas em um banco de dados central gerenciado pelo LaunchServices em **`~/Library/Preferences/com.apple.LaunchServices.QuarantineEventsV2`**.

#### **Quarantine.kext**

A extens√£o do kernel est√° dispon√≠vel apenas por meio do **cache do kernel no sistema**; no entanto, voc√™ _pode_ baixar o **Kernel Debug Kit em https://developer.apple.com/**, que conter√° uma vers√£o simbolizada da extens√£o.

### XProtect

XProtect √© um recurso integrado de **anti-malware** no macOS. XProtect **verifica qualquer aplicativo quando √© lan√ßado ou modificado pela primeira vez em rela√ß√£o ao seu banco de dados** de malware conhecido e tipos de arquivo inseguros. Quando voc√™ baixa um arquivo por meio de aplicativos espec√≠ficos, como Safari, Mail ou Mensagens, o XProtect verifica automaticamente o arquivo. Se corresponder a algum malware conhecido em seu banco de dados, o XProtect ir√° **impedir que o arquivo seja executado** e alert√°-lo sobre a amea√ßa.

O banco de dados do XProtect √© **atualizado regularmente** pela Apple com novas defini√ß√µes de malware, e essas atualiza√ß√µes s√£o baixadas e instaladas automaticamente em seu Mac. Isso garante que o XProtect esteja sempre atualizado com as √∫ltimas amea√ßas conhecidas.

No entanto, vale ressaltar que o **XProtect n√£o √© uma solu√ß√£o antiv√≠rus completa**. Ele verifica apenas uma lista espec√≠fica de amea√ßas conhecidas e n√£o realiza varreduras de acesso como a maioria dos softwares antiv√≠rus.

Voc√™ pode obter informa√ß√µes sobre a √∫ltima atualiza√ß√£o do XProtect executando:

{% code overflow="wrap" %}
```bash
system_profiler SPInstallHistoryDataType 2>/dev/null | grep -A 4 "XProtectPlistConfigData" | tail -n 5
```
{% endcode %}

XProtect est√° localizado em uma localiza√ß√£o protegida pelo SIP em **/Library/Apple/System/Library/CoreServices/XProtect.bundle** e dentro do bundle voc√™ pode encontrar as informa√ß√µes que o XProtect utiliza:

- **`XProtect.bundle/Contents/Resources/LegacyEntitlementAllowlist.plist`**: Permite que o c√≥digo com esses cdhashes utilize as permiss√µes legadas.
- **`XProtect.bundle/Contents/Resources/XProtect.meta.plist`**: Lista de plugins e extens√µes que s√£o proibidos de carregar via BundleID e TeamID ou indicando uma vers√£o m√≠nima.
- **`XProtect.bundle/Contents/Resources/XProtect.yara`**: Regras Yara para detectar malware.
- **`XProtect.bundle/Contents/Resources/gk.db`**: Banco de dados SQLite3 com hashes de aplicativos bloqueados e TeamIDs.

Note que h√° outro aplicativo em **`/Library/Apple/System/Library/CoreServices/XProtect.app`** relacionado ao XProtect que n√£o est√° envolvido no processo do Gatekeeper.

### N√£o √© o Gatekeeper

{% hint style="danger" %}
Observe que o Gatekeeper **n√£o √© executado toda vez** que voc√™ executa um aplicativo, apenas o _**AppleMobileFileIntegrity**_ (AMFI) ir√° apenas **verificar as assinaturas de c√≥digo execut√°vel** quando voc√™ executar um aplicativo que j√° foi executado e verificado pelo Gatekeeper.
{% endhint %}

Portanto, anteriormente era poss√≠vel executar um aplicativo para armazen√°-lo em cache com o Gatekeeper, ent√£o **modificar arquivos n√£o execut√°veis do aplicativo** (como arquivos Electron asar ou NIB) e se nenhuma outra prote√ß√£o estivesse em vigor, o aplicativo era **executado** com as **adi√ß√µes maliciosas**.

No entanto, agora isso n√£o √© mais poss√≠vel porque o macOS **impede a modifica√ß√£o de arquivos** dentro dos bundles de aplicativos. Portanto, se voc√™ tentar o ataque [Dirty NIB](../macos-proces-abuse/macos-dirty-nib.md), voc√™ ver√° que n√£o √© mais poss√≠vel abusar disso porque depois de executar o aplicativo para armazen√°-lo em cache com o Gatekeeper, voc√™ n√£o poder√° modificar o bundle. E se voc√™ alterar, por exemplo, o nome do diret√≥rio Contents para NotCon (como indicado no exploit) e ent√£o executar o bin√°rio principal do aplicativo para armazen√°-lo em cache com o Gatekeeper, ele ir√° disparar um erro e n√£o ser√° executado.

## Bypasses do Gatekeeper

Qualquer forma de burlar o Gatekeeper (conseguir fazer o usu√°rio baixar algo e execut√°-lo quando o Gatekeeper deveria proibi-lo) √© considerado uma vulnerabilidade no macOS. Abaixo est√£o alguns CVEs atribu√≠dos a t√©cnicas que permitiram burlar o Gatekeeper no passado:

### [CVE-2021-1810](https://labs.withsecure.com/publications/the-discovery-of-cve-2021-1810)

Foi observado que se o **Utilit√°rio de Arquivo** for usado para extra√ß√£o, arquivos com **caminhos superiores a 886 caracteres** n√£o recebem o atributo estendido com.apple.quarantine. Essa situa√ß√£o inadvertidamente permite que esses arquivos **contornem as verifica√ß√µes de seguran√ßa do Gatekeeper**.

Confira o [**relat√≥rio original**](https://labs.withsecure.com/publications/the-discovery-of-cve-2021-1810) para mais informa√ß√µes.

### [CVE-2021-30990](https://ronmasas.com/posts/bypass-macos-gatekeeper)

Quando um aplicativo √© criado com o **Automator**, as informa√ß√µes sobre o que ele precisa para ser executado est√£o dentro de `application.app/Contents/document.wflow` e n√£o no execut√°vel. O execut√°vel √© apenas um bin√°rio gen√©rico do Automator chamado **Automator Application Stub**.

Portanto, voc√™ poderia fazer com que `application.app/Contents/MacOS/Automator\ Application\ Stub` **apontasse com um link simb√≥lico para outro Automator Application Stub dentro do sistema** e ele executaria o que est√° dentro de `document.wflow` (seu script) **sem acionar o Gatekeeper** porque o execut√°vel real n√£o possui o atributo de quarentena.

Exemplo da localiza√ß√£o esperada: `/System/Library/CoreServices/Automator\ Application\ Stub.app/Contents/MacOS/Automator\ Application\ Stub`

Confira o [**relat√≥rio original**](https://ronmasas.com/posts/bypass-macos-gatekeeper) para mais informa√ß√µes.

### [CVE-2022-22616](https://www.jamf.com/blog/jamf-threat-labs-safari-vuln-gatekeeper-bypass/)

Neste bypass, um arquivo zip foi criado com um aplicativo come√ßando a ser comprimido a partir de `application.app/Contents` em vez de `application.app`. Portanto, o **atributo de quarentena** foi aplicado a todos os **arquivos de `application.app/Contents`** mas **n√£o a `application.app`**, que era o que o Gatekeeper estava verificando, ent√£o o Gatekeeper foi burlado porque quando `application.app` foi acionado, ele **n√£o tinha o atributo de quarentena**.
```bash
zip -r test.app/Contents test.zip
```
Verifique o [**relat√≥rio original**](https://www.jamf.com/blog/jamf-threat-labs-safari-vuln-gatekeeper-bypass/) para mais informa√ß√µes.

### [CVE-2022-32910](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-32910)

Mesmo que os componentes sejam diferentes, a explora√ß√£o dessa vulnerabilidade √© muito semelhante √† anterior. Neste caso, iremos gerar um Arquivo Apple a partir de **`application.app/Contents`** para que **`application.app` n√£o receba o atributo de quarentena** ao ser descompactado pelo **Archive Utility**.
```bash
aa archive -d test.app/Contents -o test.app.aar
```
Verifique o [**relat√≥rio original**](https://www.jamf.com/blog/jamf-threat-labs-macos-archive-utility-vulnerability/) para mais informa√ß√µes.

### [CVE-2022-42821](https://www.microsoft.com/en-us/security/blog/2022/12/19/gatekeepers-achilles-heel-unearthing-a-macos-vulnerability/)

O ACL **`writeextattr`** pode ser usado para impedir que algu√©m escreva um atributo em um arquivo:
```bash
touch /tmp/no-attr
chmod +a "everyone deny writeextattr" /tmp/no-attr
xattr -w attrname vale /tmp/no-attr
xattr: [Errno 13] Permission denied: '/tmp/no-attr'
```
Al√©m disso, o formato de arquivo **AppleDouble** copia um arquivo incluindo suas ACEs.

No [**c√≥digo-fonte**](https://opensource.apple.com/source/Libc/Libc-391/darwin/copyfile.c.auto.html) √© poss√≠vel ver que a representa√ß√£o de texto do ACL armazenada dentro do xattr chamado **`com.apple.acl.text`** ser√° definida como ACL no arquivo descompactado. Portanto, se voc√™ comprimiu um aplicativo em um arquivo zip com o formato de arquivo **AppleDouble** com um ACL que impede que outros xattrs sejam gravados nele... o xattr de quarentena n√£o foi definido no aplicativo:
```bash
chmod +a "everyone deny write,writeattr,writeextattr" /tmp/test
ditto -c -k test test.zip
python3 -m http.server
# Download the zip from the browser and decompress it, the file should be without a quarantine xattr
```
{% endcode %}

Verifique o [**relat√≥rio original**](https://www.microsoft.com/en-us/security/blog/2022/12/19/gatekeepers-achilles-heel-unearthing-a-macos-vulnerability/) para mais informa√ß√µes.

Note que isso tamb√©m poderia ser explorado com o AppleArchives:
```bash
mkdir app
touch app/test
chmod +a "everyone deny write,writeattr,writeextattr" app/test
aa archive -d app -o test.aar
```
### [CVE-2023-27943](https://blog.f-secure.com/discovery-of-gatekeeper-bypass-cve-2023-27943/)

Foi descoberto que o **Google Chrome n√£o estava definindo o atributo de quarentena** para arquivos baixados devido a alguns problemas internos do macOS.

### [CVE-2023-27951](https://redcanary.com/blog/gatekeeper-bypass-vulnerabilities/)

Os formatos de arquivo AppleDouble armazenam os atributos de um arquivo em um arquivo separado come√ßando por `._`, isso ajuda a copiar atributos de arquivos **entre m√°quinas macOS**. No entanto, foi observado que ap√≥s descompactar um arquivo AppleDouble, o arquivo come√ßando com `._` **n√£o recebia o atributo de quarentena**.

{% code overflow="wrap" %}
```bash
mkdir test
echo a > test/a
echo b > test/b
echo ._a > test/._a
aa archive -d test/ -o test.aar

# If you downloaded the resulting test.aar and decompress it, the file test/._a won't have a quarantitne attribute
```
{% endcode %}

Ser capaz de criar um arquivo que n√£o ter√° o atributo de quarentena definido, era **poss√≠vel contornar o Gatekeeper.** O truque era **criar um aplicativo de arquivo DMG** usando a conven√ß√£o de nome AppleDouble (iniciando com `._`) e criar um **arquivo vis√≠vel como um link simb√≥lico para este arquivo oculto** sem o atributo de quarentena.\
Quando o **arquivo dmg √© executado**, como n√£o possui um atributo de quarentena, ele **contornar√° o Gatekeeper**.
```bash
# Create an app bundle with the backdoor an call it app.app

echo "[+] creating disk image with app"
hdiutil create -srcfolder app.app app.dmg

echo "[+] creating directory and files"
mkdir
mkdir -p s/app
cp app.dmg s/app/._app.dmg
ln -s ._app.dmg s/app/app.dmg

echo "[+] compressing files"
aa archive -d s/ -o app.aar
```
### Prevenir a xattr de quarentena

Em um pacote ".app", se a xattr de quarentena n√£o for adicionada a ele, ao execut√°-lo **o Gatekeeper n√£o ser√° acionado**.
