# macOS Εισαγωγή Νήματος μέσω της Θύρας Task

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Κώδικας

* [https://github.com/bazad/threadexec](https://github.com/bazad/threadexec)
* [https://gist.github.com/knightsc/bd6dfeccb02b77eb6409db5601dcef36](https://gist.github.com/knightsc/bd6dfeccb02b77eb6409db5601dcef36)


## 1. Απαγωγή Νήματος

Αρχικά, η συνάρτηση **`task_threads()`** καλείται στη θύρα task για να λάβει μια λίστα νημάτων από το απομακρυσμένο task. Ένα νήμα επιλέγεται για απαγωγή. Αυτή η προσέγγιση αποκλίνει από τις συμβατικές μεθόδους εισαγωγής κώδικα, καθώς η δημιουργία ενός νέου απομακρυσμένου νήματος απαγορεύεται λόγω της νέας αντιμετώπισης που αποκλείει την `thread_create_running()`.

Για να ελέγξετε το νήμα, καλείται η **`thread_suspend()`**, διακόπτοντας την εκτέλεσή του.

Οι μόνες επιτρεπόμενες λειτουργίες στο απομακρυσμένο νήμα περιλαμβάνουν την **παύση** και την **εκκίνησή** του, την **ανάκτηση** και την **τροποποίηση** των τιμών των καταχωρητών του. Οι απομακρυσμένες κλήσεις συναρτήσεων ξεκινούν τοποθετώντας τις τιμές των καταχωρητών `x0` έως `x7` στα **ορίσματα**, ρυθμίζοντας το **`pc`** για να στοχεύει την επιθυμητή συνάρτηση και ενεργοποιώντας το νήμα. Για να διασφαλιστεί ότι το νήμα δεν θα καταρρεύσει μετά την επιστροφή, απαιτείται η ανίχνευση της επιστροφής.

Μια στρατηγική περιλαμβάνει την **εγγραφή ενός χειριστή εξαιρέσεων** για το απομακρυσμένο νήμα χρησιμοποιώντας την `thread_set_exception_ports()`, ρυθμίζοντας τον καταχωρητή `lr` σε μια μη έγκυρη διεύθυνση πριν από την κλήση της συνάρτησης. Αυτό προκαλεί μια εξαίρεση μετά την εκτέλεση της συνάρτησης, αποστέλλοντας ένα μήνυμα στη θύρα εξαίρεσης, επιτρέποντας την επιθεώρηση της κατάστασης του νήματος για την ανάκτηση της τιμής επιστροφής. Εναλλακτικά, όπως υιοθετήθηκε από την εκμετάλλευση triple\_fetch του Ian Beer, ο `lr` ρυθμίζεται να επαναλαμβάνεται απεριόριστα. Οι καταχωρητές του νήματος παρακολουθούνται συνεχώς μέχρι ο **`pc` να δείχνει σε αυτήν την εντολή**.

## 2. Mach θύρες για επικοινωνία

Η επόμενη φάση περιλαμβάνει τη δημιουργία Mach θυρών για τη διευκόλυνση της επικοινωνίας με το απομακρυσμένο νήμα. Αυτές οι θύρες είναι ουσιώδεις για τη μεταφορά αυθαίρετων δικαιωμάτων αποστολής και λήψης μεταξύ των tasks.

Για διπλής κατεύθυνσης επικοινωνία, δημιουργούνται δύο Mach δικαιώματα λήψης: ένα στο τοπικό και ένα στο απομακρυσμένο task. Στη συνέχεια, ένα δικαίωμα αποστολής για κάθε θύρα μεταφέρεται στο αντίστοιχο task, επιτρέποντας την ανταλλαγή μηνυμάτων.

Επικεντρώνοντας στην τοπική θύρα, το δικαίωμα λήψης κατέχεται από το τοπικό task. Η θύρα δημιουργείται με τη χρήση της `mach_port_allocate()`. Η πρόκληση έγκειται στη μεταφορά ενός δικαιώματος αποστολής σε αυτήν τη θύρα στο απομακρυσμένο task.

Μια στρατηγική περιλαμβάνει την αξιοποίηση της `thread_set_special_port()` για να τοποθε
```c
uint64_t read_func(uint64_t *address) {
return *address;
}
```
Και για την εγγραφή στη μνήμη, χρησιμοποιούνται συναρτήσεις παρόμοιες με αυτήν τη δομή:
```c
void write_func(uint64_t *address, uint64_t value) {
*address = value;
}
```
Αυτές οι συναρτήσεις αντιστοιχούν στις δοθείσες εντολές συναρμολόγησης:
```
_read_func:
ldr x0, [x0]
ret
_write_func:
str x1, [x0]
ret
```
### Αναγνώριση Κατάλληλων Συναρτήσεων

Μια σάρωση των κοινών βιβλιοθηκών αποκάλυψε κατάλληλους υποψήφιους για αυτές τις λειτουργίες:

1. **Ανάγνωση Μνήμης:**
Η συνάρτηση `property_getName()` από τη [βιβλιοθήκη Objective-C runtime](https://opensource.apple.com/source/objc4/objc4-723/runtime/objc-runtime-new.mm.auto.html) αναγνωρίζεται ως μια κατάλληλη συνάρτηση για την ανάγνωση μνήμης. Η συνάρτηση παρουσιάζεται παρακάτω:
```c
const char *property_getName(objc_property_t prop) {
return prop->name;
}
```
Αυτή η συνάρτηση λειτουργεί αποτελεσματικά όπως η `read_func` επιστρέφοντας το πρώτο πεδίο του `objc_property_t`.

2. **Εγγραφή Μνήμης:**
Η εύρεση μιας προκατασκευασμένης συνάρτησης για την εγγραφή μνήμης είναι πιο προκλητική. Ωστόσο, η συνάρτηση `_xpc_int64_set_value()` από την libxpc είναι ένας κατάλληλος υποψήφιος με την ακόλουθη αποσυναρμολόγηση:
```c
__xpc_int64_set_value:
str x1, [x0, #0x18]
ret
```
Για να πραγματοποιήσετε μια εγγραφή 64-bit σε μια συγκεκριμένη διεύθυνση, η απομακρυσμένη κλήση δομείται ως εξής:
```c
_xpc_int64_set_value(address - 0x18, value)
```
Με αυτά τα πρωτογενή στοιχεία έχει δημιουργηθεί το πλαίσιο για τη δημιουργία κοινής μνήμης, σημαντική πρόοδος στον έλεγχο της απομακρυσμένης διεργασίας.

## 4. Δημιουργία Κοινής Μνήμης

Ο στόχος είναι να δημιουργηθεί κοινή μνήμη μεταξύ τοπικών και απομακρυσμένων εργασιών, απλοποιώντας τη μεταφορά δεδομένων και διευκολύνοντας την κλήση συναρτήσεων με πολλαπλά ορίσματα. Η προσέγγιση περιλαμβάνει την αξιοποίηση του `libxpc` και του αντικειμένου του `OS_xpc_shmem`, το οποίο βασίζεται σε καταχωρήσεις μνήμης Mach.

### Επισκόπηση Διεργασίας:

1. **Δέσμευση Μνήμης**:
- Δεσμεύστε τη μνήμη για κοινή χρήση χρησιμοποιώντας το `mach_vm_allocate()`.
- Χρησιμοποιήστε το `xpc_shmem_create()` για να δημιουργήσετε ένα αντικείμενο `OS_xpc_shmem` για την δεσμευμένη περιοχή μνήμης. Αυτή η συνάρτηση θα διαχειριστεί τη δημιουργία της καταχώρησης μνήμης Mach και θα αποθηκεύσει το δικαίωμα αποστολής Mach στη θέση `0x18` του αντικειμένου `OS_xpc_shmem`.

2. **Δημιουργία Κοινής Μνήμης στην Απομακρυσμένη Διεργασία**:
- Δεσμεύστε μνήμη για το αντικείμενο `OS_xpc_shmem` στην απομακρυσμένη διεργασία με απομακρυσμένη κλήση στο `malloc()`.
- Αντιγράψτε το περιεχόμενο του τοπικού αντικειμένου `OS_xpc_shmem` στην απομακρυσμένη διεργασία. Ωστόσο, αυτή η αρχική αντιγραφή θα έχει εσφαλμένα ονόματα καταχώρησης μνήμης Mach στη θέση `0x18`.

3. **Διόρθωση της Καταχώρησης Μνήμης Mach**:
- Χρησιμοποιήστε τη μέθοδο `thread_set_special_port()` για να εισαγάγετε ένα δικαίωμα αποστολής για την καταχώρηση μνήμης Mach στην απομακρυσμένη εργασία.
- Διορθώστε το πεδίο της καταχώρησης μνήμης Mach στη θέση `0x18` αντικαθιστώντας το με το όνομα της απομακρυσμένης καταχώρησης μνήμης.

4. **Ολοκλήρωση Δημιουργίας Κοινής Μνήμης**:
- Επαληθεύστε το αντικείμενο `OS_xpc_shmem` στην απομακρυσμένη διεργασία.
- Καθιερώστε την κοινή αντιστοίχιση μνήμης με απομακρυσμένη κλήση στο `xpc_shmem_remote()`.

Ακολουθώντας αυτά τα βήματα, η κοινή μνήμη μεταξύ των τοπικών και απομακρυσμένων εργασιών θα δημιουργηθεί αποτελεσματικά, επιτρέποντας απλή μεταφορά δεδομένων και εκτέλεση συναρτήσεων που απαιτούν πολλά ορίσματα. 

## Πρόσθετα Αποσπάσματα Κώδικα

Για τη δέσμευση μνήμης και τη δημιουργία αντικειμένου κοινής μνήμης:
```c
mach_vm_allocate();
xpc_shmem_create();
```
Για τη δημιουργία και τη διόρθωση του κοινόχρηστου αντικειμένου μνήμης στην απομακρυσμένη διεργασία:
```c
malloc(); // for allocating memory remotely
thread_set_special_port(); // for inserting send right
```
Θυμηθείτε να χειριστείτε σωστά τις λεπτομέρειες των θυρίδων Mach και των ονομάτων εισόδου μνήμης για να εξασφαλίσετε ότι η ρύθμιση κοινής μνήμης λειτουργεί σωστά.


## 5. Επίτευξη Πλήρους Ελέγχου

Αφού επιτύχουμε την εγκαθίδρυση κοινής μνήμης και αποκτήσουμε αυθαίρετες δυνατότητες εκτέλεσης, ουσιαστικά έχουμε αποκτήσει πλήρη έλεγχο επί της διεργασίας στόχου. Οι βασικές λειτουργίες που επιτρέπουν αυτόν τον έλεγχο είναι οι εξής:

1. **Αυθαίρετες Λειτουργίες Μνήμης**:
- Εκτέλεση αυθαίρετων αναγνώσεων μνήμης καλώντας τη συνάρτηση `memcpy()` για την αντιγραφή δεδομένων από την κοινή περιοχή.
- Εκτέλεση αυθαίρετων εγγραφών μνήμης χρησιμοποιώντας τη συνάρτηση `memcpy()` για τη μεταφορά δεδομένων στην κοινή περιοχή.

2. **Χειρισμός Κλήσεων Συναρτήσεων με Πολλαπλά Ορίσματα**:
- Για συναρτήσεις που απαιτούν περισσότερα από 8 ορίσματα, ταξινομήστε τα επιπλέον ορίσματα στη στοίβα σύμφωνα με τον κανόνα κλήσης.

3. **Μεταφορά Θυρίδων Mach**:
- Μεταφορά θυρίδων Mach μεταξύ εργασιών μέσω μηνυμάτων Mach μέσω προηγουμένως εγκαθιδρυμένων θυρίδων.

4. **Μεταφορά Περιγραφέων Αρχείων**:
- Μεταφορά περιγραφέων αρχείων μεταξύ διεργασιών χρησιμοποιώντας fileports, μια τεχνική που επισημαίνεται από τον Ian Beer στο `triple_fetch`.

Αυτός ο πλήρης έλεγχος ενσωματώνεται στη βιβλιοθήκη [threadexec](https://github.com/bazad/threadexec), παρέχοντας μια λεπτομερή υλοποίηση και μια φιλική προς τον χρήστη διεπαφή προγραμματισμού για την αλληλεπίδραση με τη διεργασία-θύμα.

## Σημαντικές Προσοχές:

- Βεβαιωθείτε ότι χρησιμοποιείτε σωστά τη συνάρτηση `memcpy()` για τις λειτουργίες ανάγνωσης/εγγραφής μνήμης προκειμένου να διατηρηθεί η σταθερότητα του συστήματος και η ακεραιότητα των δεδομένων.
- Όταν μεταφέρετε θυρίδες Mach ή περιγραφείς αρχείων, ακολουθήστε τους κατάλληλους πρωτόκολλους και χειριστείτε τους πόρους με ευθύνη προκειμένου να αποφευχθούν διαρροές ή μη επιθυμητή πρόσβαση.

Ακολουθώντας αυτές τις οδηγίες και χρησιμοποιώντας τη βιβλιοθήκη `threadexec`, μπορεί κανείς να διαχειριστεί και να αλληλεπιδράσει με διεργασίες σε λεπτομερές επίπεδο, επιτυγχάνοντας πλήρη έλεγχο επί της διεργασίας-στόχου.

## Αναφορές
* [https://bazad.github.io/2018/10/bypassing-platform-binary-task-threads/](https://bazad.github.io/2018/10/bypassing-platform-binary-task-threads/)

<details>

<summary><strong>Μάθετε το hacking στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετάσχετε** 💬 στην [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα κόλπα σας στο hacking υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) στο GitHub.

</details>
