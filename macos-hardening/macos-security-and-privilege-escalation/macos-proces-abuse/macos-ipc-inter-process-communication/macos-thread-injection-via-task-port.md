# Inyecci√≥n de hilos en macOS a trav√©s del puerto de tarea

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Este post fue copiado de [https://bazad.github.io/2018/10/bypassing-platform-binary-task-threads/](https://bazad.github.io/2018/10/bypassing-platform-binary-task-threads/) (que contiene m√°s informaci√≥n)

### C√≥digo

* [https://github.com/bazad/threadexec](https://github.com/bazad/threadexec)
* [https://gist.github.com/knightsc/bd6dfeccb02b77eb6409db5601dcef36](https://gist.github.com/knightsc/bd6dfeccb02b77eb6409db5601dcef36)

### 1. Secuestro de hilos

Lo primero que hacemos es llamar a **`task_threads()`** en el puerto de tarea para obtener una lista de hilos en la tarea remota y luego elegir uno de ellos para secuestrarlo. A diferencia de los marcos de inyecci√≥n de c√≥digo tradicionales, **no podemos crear un nuevo hilo remoto** porque `thread_create_running()` ser√° bloqueado por la nueva mitigaci√≥n.

Luego, podemos llamar a **`thread_suspend()`** para detener la ejecuci√≥n del hilo.

En este punto, el √∫nico control √∫til que tenemos sobre el hilo remoto es **detenerlo**, **iniciarlo**, **obtener** sus **valores de registro** y **establecer** sus **valores de registro**. Por lo tanto, podemos **iniciar una llamada de funci√≥n remota** estableciendo los registros `x0` a `x7` en el hilo remoto a los **argumentos**, **estableciendo** **`pc`** en la funci√≥n que queremos ejecutar y comenzando el hilo. En este punto, necesitamos detectar el retorno y asegurarnos de que el hilo no se bloquee.

Hay varias formas de hacer esto. Una forma ser√≠a **registrar un controlador de excepciones** para el hilo remoto usando `thread_set_exception_ports()` y establecer el registro de direcci√≥n de retorno, `lr`, en una direcci√≥n no v√°lida antes de llamar a la funci√≥n; de esta manera, despu√©s de que se ejecute la funci√≥n se generar√° una excepci√≥n y se enviar√° un mensaje a nuestro puerto de excepci√≥n, momento en el que podemos inspeccionar el estado del hilo para recuperar el valor de retorno. Sin embargo, por simplicidad, copi√© la estrategia utilizada en el exploit triple\_fetch de Ian Beer, que consist√≠a en **establecer `lr` en la direcci√≥n de una instrucci√≥n que entrar√≠a en un bucle infinito** y luego verificar repetidamente los registros del hilo hasta que **`pc` apuntara a esa instrucci√≥n**.

### 2. Puertos Mach para la comunicaci√≥n

El siguiente paso es **crear puertos Mach a trav√©s de los cuales podemos comunicarnos con el hilo remoto**. Estos puertos Mach ser√°n √∫tiles m√°s adelante para ayudar a transferir derechos de env√≠o y recepci√≥n arbitrarios entre las tareas.

Para establecer una comunicaci√≥n bidireccional, necesitaremos crear dos derechos de recepci√≥n Mach: uno en la **tarea local y otro en la tarea remota**. Luego, necesitaremos **transferir un derecho de env√≠o** a cada puerto **a la otra tarea**. Esto le dar√° a cada tarea una forma de enviar un mensaje que puede ser recibido por la otra.

Primero nos enfocaremos en configurar el puerto local, es decir, el puerto al que la tarea local tiene el derecho de recepci√≥n. Podemos crear el puerto Mach como cualquier otro, llamando a `mach_port_allocate()`. El truco est√° en obtener un derecho de env√≠o a ese puerto en la tarea remota.

Un truco conveniente que podemos usar para copiar un derecho de env√≠o desde la tarea actual hacia una tarea remota utilizando solo una primitiva de ejecuci√≥n b√°sica es guardar un **derecho de env√≠o a nuestro puerto local en el puerto especial `THREAD_KERNEL_PORT` del hilo remoto** utilizando `thread_set_special_port()`; luego, podemos hacer que el hilo remoto llame a `mach_thread_self()` para recuperar el derecho de env√≠o.

A continuaci√≥n, configuraremos el puerto remoto, que es pr√°cticamente lo contrario de lo que acabamos de hacer. Podemos hacer que el **hilo remoto asigne un puerto Mach llamando a `mach_reply_port()`**; no podemos usar `mach_port_allocate()` porque este √∫ltimo devuelve el nombre del puerto asignado en la memoria y a√∫n no tenemos una primitiva de lectura. Una vez que tenemos un puerto, podemos crear un derecho de env√≠o llamando a `mach_port_insert_right()` en el hilo remoto. Luego, podemos guardar el puerto en el kernel llamando a `thread_set_special_port()`. Finalmente, de vuelta en la tarea local, podemos recuperar el puerto llamando a `thread_get_special_port()` en el hilo remoto, **d√°ndonos un derecho de env√≠o al puerto Mach reci√©n asignado en la tarea remota**.

En este punto, hemos creado los puertos Mach que utilizaremos para la comunicaci√≥n bidireccional.
### 3. Lectura/escritura b√°sica de memoria <a href="#paso-3-lecturaescritura-b√°sica-de-memoria" id="paso-3-lecturaescritura-b√°sica-de-memoria"></a>

Ahora utilizaremos la primitiva de ejecuci√≥n para crear primitivas b√°sicas de lectura y escritura de memoria. Estas primitivas no se utilizar√°n mucho (pronto actualizaremos a primitivas mucho m√°s poderosas), pero son un paso clave para ayudarnos a expandir nuestro control sobre el proceso remoto.

Para leer y escribir memoria utilizando nuestra primitiva de ejecuci√≥n, buscaremos funciones como estas:
```c
uint64_t read_func(uint64_t *address) {
return *address;
}
void write_func(uint64_t *address, uint64_t value) {
*address = value;
}
```
Podr√≠an corresponder a lo siguiente en ensamblador:
```
_read_func:
ldr     x0, [x0]
ret
_write_func:
str     x1, [x0]
ret
```
Un escaneo r√°pido de algunas bibliotecas comunes revel√≥ algunos candidatos prometedores. Para leer la memoria, podemos utilizar la funci√≥n `property_getName()` de la [biblioteca de tiempo de ejecuci√≥n Objective-C](https://opensource.apple.com/source/objc4/objc4-723/runtime/objc-runtime-new.mm.auto.html):
```c
const char *property_getName(objc_property_t prop)
{
return prop->name;
}
```
Resulta que `prop` es el primer campo de `objc_property_t`, por lo que esto corresponde directamente a la hipot√©tica funci√≥n `read_func` anterior. Solo necesitamos realizar una llamada de funci√≥n remota con el primer argumento siendo la direcci√≥n que queremos leer, y el valor de retorno ser√° los datos en esa direcci√≥n.

Encontrar una funci√≥n predefinida para escribir en memoria es un poco m√°s dif√≠cil, pero a√∫n hay excelentes opciones sin efectos secundarios no deseados. En libxpc, la funci√≥n `_xpc_int64_set_value()` tiene el siguiente desensamblado:
```
__xpc_int64_set_value:
str     x1, [x0, #0x18]
ret
```
Por lo tanto, para realizar una escritura de 64 bits en la direcci√≥n `address`, podemos realizar la llamada remota:
```c
_xpc_int64_set_value(address - 0x18, value)
```
Con estas primitivas en mano, estamos listos para crear memoria compartida.

### 4. Memoria compartida

Nuestro siguiente paso es crear memoria compartida entre la tarea remota y local. Esto nos permitir√° transferir datos entre los procesos de manera m√°s f√°cil: con una regi√≥n de memoria compartida, la lectura y escritura arbitraria de memoria es tan simple como una llamada remota a `memcpy()`. Adem√°s, tener una regi√≥n de memoria compartida nos permitir√° configurar f√°cilmente una pila para llamar a funciones con m√°s de 8 argumentos.

Para facilitar las cosas, podemos reutilizar las caracter√≠sticas de memoria compartida de libxpc. Libxpc proporciona un tipo de objeto XPC, `OS_xpc_shmem`, que permite establecer regiones de memoria compartida a trav√©s de XPC. Al revertir libxpc, determinamos que `OS_xpc_shmem` se basa en entradas de memoria Mach, que son puertos Mach que representan una regi√≥n de memoria virtual. Y dado que ya hemos mostrado c√≥mo enviar puertos Mach a la tarea remota, podemos usar esto para configurar f√°cilmente nuestra propia memoria compartida.

Lo primero es lo primero, necesitamos asignar la memoria que compartiremos usando `mach_vm_allocate()`. Necesitamos usar `mach_vm_allocate()` para que podamos usar `xpc_shmem_create()` para crear un objeto `OS_xpc_shmem` para la regi√≥n. `xpc_shmem_create()` se encargar√° de crear la entrada de memoria Mach por nosotros y almacenar√° el derecho de env√≠o Mach a la entrada de memoria en el objeto `OS_xpc_shmem` opaco en el desplazamiento `0x18`.

Una vez que tenemos el puerto de entrada de memoria, crearemos un objeto `OS_xpc_shmem` en el proceso remoto que representa la misma regi√≥n de memoria, lo que nos permitir√° llamar a `xpc_shmem_map()` para establecer el mapeo de memoria compartida. Primero, realizamos una llamada remota a `malloc()` para asignar memoria para el `OS_xpc_shmem` y usamos nuestra primitiva de escritura b√°sica para copiar el contenido del objeto `OS_xpc_shmem` local. Desafortunadamente, el objeto resultante no es del todo correcto: su campo de entrada de memoria Mach en el desplazamiento `0x18` contiene el nombre de la tarea local para la entrada de memoria, no el nombre de la tarea remota. Para solucionar esto, usamos el truco `thread_set_special_port()` para insertar un derecho de env√≠o a la entrada de memoria Mach en la tarea remota y luego sobrescribimos el campo `0x18` con el nombre de la entrada de memoria remota. En este punto, el objeto remoto `OS_xpc_shmem` es v√°lido y se puede establecer el mapeo de memoria con una llamada remota a `xpc_shmem_remote()`.

### 5. Control total <a href="#step-5-full-control" id="step-5-full-control"></a>

Con memoria compartida en una direcci√≥n conocida y una primitiva de ejecuci√≥n arbitraria, b√°sicamente hemos terminado. Las lecturas y escrituras arbitrarias de memoria se implementan llamando a `memcpy()` desde y hacia la regi√≥n compartida, respectivamente. Las llamadas a funciones con m√°s de 8 argumentos se realizan colocando argumentos adicionales m√°s all√° de los primeros 8 en la pila seg√∫n la convenci√≥n de llamada. La transferencia de puertos Mach arbitrarios entre las tareas se puede hacer enviando mensajes Mach a trav√©s de los puertos establecidos anteriormente. Incluso podemos transferir descriptores de archivos entre los procesos utilizando fileports (¬°un agradecimiento especial a Ian Beer por demostrar esta t√©cnica en triple\_fetch!).

En resumen, ahora tenemos un control total y f√°cil sobre el proceso v√≠ctima. Puedes ver la implementaci√≥n completa y la API expuesta en la biblioteca [threadexec](https://github.com/bazad/threadexec).

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos.
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com).
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
