# macOS xpc\_connection\_get\_audit\_token Angriff

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks in PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

**F√ºr weitere Informationen √ºberpr√ºfen Sie den Originalbeitrag:** [**https://sector7.computest.nl/post/2023-10-xpc-audit-token-spoofing/**](https://sector7.computest.nl/post/2023-10-xpc-audit-token-spoofing/). Dies ist eine Zusammenfassung:

## Grundlegende Informationen zu Mach-Nachrichten

Wenn Sie nicht wissen, was Mach-Nachrichten sind, beginnen Sie mit der √úberpr√ºfung dieser Seite:

{% content-ref url="../../" %}
[..](../../)
{% endcontent-ref %}

Denken Sie vorerst daran, dass ([Definition von hier](https://sector7.computest.nl/post/2023-10-xpc-audit-token-spoofing)):\
Mach-Nachrichten werden √ºber einen _Mach-Port_ gesendet, der ein **Kommunikationskanal mit einem einzelnen Empf√§nger und mehreren Sendern** ist, der in den Mach-Kernel integriert ist. **Mehrere Prozesse k√∂nnen Nachrichten** an einen Mach-Port senden, aber zu jedem Zeitpunkt kann **nur ein einzelner Prozess daraus lesen**. Genau wie Dateideskriptoren und Sockets werden Mach-Ports vom Kernel zugewiesen und verwaltet, und Prozesse sehen nur eine Ganzzahl, die sie verwenden k√∂nnen, um dem Kernel anzuzeigen, welchen ihrer Mach-Ports sie verwenden m√∂chten.

## XPC-Verbindung

Wenn Sie nicht wissen, wie eine XPC-Verbindung hergestellt wird, √ºberpr√ºfen Sie:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Schwachstellenzusammenfassung

Was f√ºr Sie interessant zu wissen ist, dass die Abstraktion von **XPC eine Eins-zu-Eins-Verbindung** ist, aber sie basiert auf einer Technologie, die **mehrere Sender haben kann, also:**

* Mach-Ports sind einzelne Empf√§nger, **mehrere Sender**.
* Das Audit-Token einer XPC-Verbindung ist das Audit-Token, das **aus der zuletzt empfangenen Nachricht kopiert wurde**.
* Das Erlangen des **Audit-Tokens** einer XPC-Verbindung ist f√ºr viele **Sicherheits√ºberpr√ºfungen** entscheidend.

Obwohl die vorherige Situation vielversprechend klingt, gibt es Szenarien, in denen dies keine Probleme verursachen wird ([von hier](https://sector7.computest.nl/post/2023-10-xpc-audit-token-spoofing)):

* Audit-Token werden h√§ufig f√ºr eine Autorisierungspr√ºfung verwendet, um zu entscheiden, ob eine Verbindung akzeptiert werden soll. Da dies √ºber eine Nachricht an den Dienstport erfolgt, ist **noch keine Verbindung hergestellt**. Weitere Nachrichten an diesem Port werden einfach als zus√§tzliche Verbindungsanfragen behandelt. Daher sind **√úberpr√ºfungen vor der Annahme einer Verbindung nicht gef√§hrdet** (das bedeutet auch, dass das Audit-Token innerhalb von `-listener:shouldAcceptNewConnection:` sicher ist). Wir suchen daher nach XPC-Verbindungen, die spezifische Aktionen √ºberpr√ºfen.
* XPC-Ereignishandler werden synchron behandelt. Das bedeutet, dass der Ereignishandler f√ºr eine Nachricht abgeschlossen sein muss, bevor er f√ºr die n√§chste aufgerufen wird, auch auf gleichzeitigen Dispatch-Warteschlangen. Daher kann das Audit-Token innerhalb eines **XPC-Ereignishandlers nicht von anderen normalen (nicht-Antwort-)Nachrichten √ºberschrieben werden**.

Zwei verschiedene Methoden, wie dies ausgenutzt werden k√∂nnte:

1. Variante 1:
* Der **Exploit** **verbindet** sich mit Dienst **A** und Dienst **B**.
* Dienst **B** kann eine **privilegierte Funktionalit√§t** in Dienst **A** aufrufen, die der Benutzer nicht kann.
* Dienst **A** ruft **`xpc_connection_get_audit_token`** auf, w√§hrend es sich _**nicht**_ im **Ereignishandler** f√ºr eine Verbindung in einem **`dispatch_async`** befindet.
* Daher k√∂nnte eine **andere** Nachricht das **Audit-Token √ºberschreiben**, da sie au√üerhalb des Ereignishandlers asynchron an den Kernel √ºbermittelt wird.
* Der Exploit √ºbergibt **Dienst B das SEND-Recht an Dienst A**.
* Daher wird svc **B tats√§chlich die Nachrichten** an Dienst **A senden**.
* Der **Exploit** versucht, die **privilegierte Aktion aufzurufen**. In einem RC √ºberpr√ºft svc **A** die Autorisierung dieser **Aktion**, w√§hrend **svc B das Audit-Token √ºberschrieben hat** (was dem Exploit den Zugriff auf das Aufrufen der privilegierten Aktion erm√∂glicht).
2. Variante 2:
* Dienst **B** kann eine **privilegierte Funktionalit√§t** in Dienst **A** aufrufen, die der Benutzer nicht kann.
* Der Exploit verbindet sich mit **Dienst A**, der dem Exploit eine **Nachricht erwartet, die eine Antwort** in einem bestimmten **Antwort-Port** sendet.
* Der Exploit sendet **Dienst B eine Nachricht**, die **diesen Antwort-Port** √ºbergibt.
* Wenn Dienst **B antwortet**, **sendet er die Nachricht an Dienst A**, **w√§hrend** der **Exploit** eine andere **Nachricht an Dienst A sendet**, um zu versuchen, eine privilegierte Funktionalit√§t zu erreichen und zu erwarten, dass die Antwort von Dienst B das Audit-Token im perfekten Moment √ºberschreibt (Race Condition).

## Variante 1: Aufruf von xpc\_connection\_get\_audit\_token au√üerhalb eines Ereignishandlers <a href="#variante-1-aufruf-von-xpc_connection_get_audit_token-outside-of-an-event-handler" id="variante-1-aufruf-von-xpc_connection_get_audit_token-outside-of-an-event-handler"></a>

Szenario:

* Zwei Mach-Dienste **`A`** und **`B`**, zu denen wir beide eine Verbindung herstellen k√∂nnen (basierend auf dem Sandbox-Profil und den Autorisierungspr√ºfungen vor der Annahme der Verbindung).
* _**A**_ muss eine **Autorisierungspr√ºfung** f√ºr eine spezifische Aktion haben, die **`B`** bestehen kann (aber unsere App nicht).
* Wenn B z.B. einige **Berechtigungen** hat oder als **root** ausgef√ºhrt wird, k√∂nnte es ihm erlauben, A aufzufordern, eine privilegierte Aktion auszuf√ºhren.
* F√ºr diese Autorisierungspr√ºfung erh√§lt **`A`** das Audit-Token asynchron, z.B. durch Aufruf von `xpc_connection_get_audit_token` aus **`dispatch_async`**.

{% hint style="danger" %}
In diesem Fall k√∂nnte ein Angreifer eine **Race Condition** ausl√∂sen, indem er einen **Exploit erstellt, der A auffordert, eine Aktion auszuf√ºhren**, w√§hrend **B Nachrichten an `A` sendet**. Wenn die RC **erfolgreich** ist, wird das **Audit-Token** von **B** im Speicher **kopiert, w√§hrend** die Anfrage unseres **Exploits** von A **bearbeitet** wird, was ihm **Zugriff auf die privilegierte Aktion erm√∂glicht, die nur B anfordern konnte**.
{% endhint %}

Dies geschah mit **`A`** als `smd` und **`B`** als `diagnosticd`. Die Funktion [`SMJobBless`](https://developer.apple.com/documentation/servicemanagement/1431078-smjobbless?language=objc) von smb kann verwendet werden, um ein neues privilegiertes Hilfsprogramm zu installieren (als **root**). Wenn ein **Prozess als root ausgef√ºhrt wird**, wird **smd** kontaktiert, und es werden keine weiteren √úberpr√ºfungen durchgef√ºhrt.

Daher ist der Dienst **B** **`diagnosticd`**, weil er als **root** ausgef√ºhrt wird und dazu verwendet werden kann, einen Prozess zu **√ºberwachen**, sodass, sobald die √úberwachung begonnen hat, **mehrere Nachrichten pro Sekunde gesendet werden**.

Um den Angriff durchzuf√ºhren:

1. Eine **Verbindung** zum Dienst mit dem Namen `smd` unter Verwendung des Standard-XPC-Protokolls herstellen.
2. Eine sekund√§re **Verbindung** zu `diagnosticd` herstellen. Anstatt zwei neue Mach-Ports zu erstellen und zu senden, wird das Client-Port-Senderecht durch eine Kopie des **Senderechts** ersetzt, das mit der Verbindung zu `smd` verbunden ist.
3. Als Ergebnis k√∂nnen XPC-Nachrichten an `diagnosticd` gesendet werden, aber Antworten von `diagnosticd` werden an `smd` umgeleitet. F√ºr `smd` sieht es so aus, als ob die Nachrichten sowohl vom Benutzer als auch von `diagnosticd` von derselben Verbindung stammen.

![Bild, das den Exploit-Prozess darstellt](https://sector7.computest.nl/post/2023-10-xpc-audit-token-spoofing/exploit.png)

4. Der n√§chste Schritt besteht darin, `diagnosticd` anzuweisen, die √úberwachung eines ausgew√§hlten Prozesses zu starten (m√∂glicherweise des Benutzers). Gleichzeitig werden eine Flut von Routine-1004-Nachrichten an `smd` gesendet. Der Zweck hierbei ist die Installation eines Tools mit erh√∂hten Berechtigungen.
5. Diese Aktion l√∂st eine Race Condition innerhalb der `handle_bless` Funktion aus. Das Timing ist entscheidend: Der Aufruf der Funktion `xpc_connection_get_pid` muss die PID des Benutzerprozesses zur√ºckgeben (da das privilegierte Tool im App-Bundle des Benutzers liegt). Jedoch muss die Funktion `xpc_connection_get_audit_token`, speziell innerhalb der `connection_is_authorized` Unterfunktion, auf das Audit-Token von `diagnosticd` verweisen.

## Variante 2: Antwortweiterleitung

In einer XPC (Cross-Process Communication) Umgebung, obwohl Ereignisbehandler nicht gleichzeitig ausgef√ºhrt werden, hat die Verarbeitung von Antwortnachrichten ein einzigartiges Verhalten. Es existieren speziell zwei unterschiedliche Methoden zum Senden von Nachrichten, die eine Antwort erwarten:

1. **`xpc_connection_send_message_with_reply`**: Hier wird die XPC-Nachricht auf einer bestimmten Warteschlange empfangen und verarbeitet.
2. **`xpc_connection_send_message_with_reply_sync`**: Im Gegensatz dazu wird die XPC-Nachricht in dieser Methode auf der aktuellen Dispatch-Warteschlange empfangen und verarbeitet.

Diese Unterscheidung ist entscheidend, da sie die M√∂glichkeit bietet, dass **Antwortpakete gleichzeitig mit der Ausf√ºhrung eines XPC-Ereignisbehandlers analysiert werden**. Insbesondere implementiert `_xpc_connection_set_creds` zwar eine Sperrung, um gegen die teilweise √úberschreibung des Audit-Tokens abzusichern, erstreckt diesen Schutz jedoch nicht auf das gesamte Verbindungsobjekt. Folglich entsteht eine Schwachstelle, bei der das Audit-Token w√§hrend des Intervalls zwischen dem Parsen eines Pakets und der Ausf√ºhrung seines Ereignisbehandlers ersetzt werden kann.

Um diese Schwachstelle auszunutzen, ist folgendes Setup erforderlich:

* Zwei Mach-Services, bezeichnet als **`A`** und **`B`**, die beide eine Verbindung herstellen k√∂nnen.
* Service **`A`** sollte eine Autorisierungspr√ºfung f√ºr eine spezifische Aktion enthalten, die nur **`B`** ausf√ºhren kann (die Anwendung des Benutzers nicht).
* Service **`A`** sollte eine Nachricht senden, die eine Antwort erwartet.
* Der Benutzer kann eine Nachricht an **`B`** senden, auf die es antworten wird.

Der Ausbeutungsprozess umfasst die folgenden Schritte:

1. Warten, bis Service **`A`** eine Nachricht sendet, die eine Antwort erwartet.
2. Anstatt direkt an **`A`** zu antworten, wird der Antwort-Port √ºbernommen und verwendet, um eine Nachricht an Service **`B`** zu senden.
3. Anschlie√üend wird eine Nachricht mit der verbotenen Aktion versandt, in der Erwartung, dass sie gleichzeitig mit der Antwort von **`B`** verarbeitet wird.

Nachfolgend ist eine visuelle Darstellung des beschriebenen Angriffsszenarios:

![https://sector7.computest.nl/post/2023-10-xpc-audit-token-spoofing/variant2.png](../../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1).png)

<figure><img src="../../../../../../.gitbook/assets/image (33).png" alt="https://sector7.computest.nl/post/2023-10-xpc-audit-token-spoofing/variant2.png" width="563"><figcaption></figcaption></figure>

## Probleme bei der Entdeckung

* **Schwierigkeiten bei der Lokalisierung von Instanzen**: Die Suche nach Instanzen der Verwendung von `xpc_connection_get_audit_token` war sowohl statisch als auch dynamisch herausfordernd.
* **Methodik**: Frida wurde verwendet, um die Funktion `xpc_connection_get_audit_token` zu hooken und Anrufe zu filtern, die nicht aus Ereignisbehandlern stammen. Diese Methode war jedoch auf den gehookten Prozess beschr√§nkt und erforderte aktive Nutzung.
* **Analysetools**: Tools wie IDA/Ghidra wurden verwendet, um erreichbare Mach-Services zu untersuchen, was zeitaufw√§ndig war und durch Aufrufe, die den dyld Shared Cache involvieren, kompliziert wurde.
* **Skripting-Einschr√§nkungen**: Versuche, die Analyse f√ºr Anrufe von `xpc_connection_get_audit_token` aus `dispatch_async`-Bl√∂cken zu skripten, wurden durch Komplexit√§ten beim Parsen von Bl√∂cken und Interaktionen mit dem dyld Shared Cache behindert.

## Die L√∂sung <a href="#the-fix" id="the-fix"></a>

* **Gemeldete Probleme**: Ein Bericht wurde an Apple eingereicht, der die allgemeinen und spezifischen Probleme in `smd` beschreibt.
* **Antwort von Apple**: Apple hat das Problem in `smd` behoben, indem `xpc_connection_get_audit_token` durch `xpc_dictionary_get_audit_token` ersetzt wurde.
* **Art der L√∂sung**: Die Funktion `xpc_dictionary_get_audit_token` gilt als sicher, da sie das Audit-Token direkt aus der Mach-Nachricht abruft, die mit der empfangenen XPC-Nachricht verbunden ist. Allerdings ist sie nicht Teil der √∂ffentlichen API, √§hnlich wie `xpc_connection_get_audit_token`.
* **Fehlen einer umfassenderen L√∂sung**: Es bleibt unklar, warum Apple keine umfassendere L√∂sung implementiert hat, wie beispielsweise das Verwerfen von Nachrichten, die nicht mit dem gespeicherten Audit-Token der Verbindung √ºbereinstimmen. Die M√∂glichkeit legitimer √Ñnderungen des Audit-Tokens in bestimmten Szenarien (z.B. `setuid`-Verwendung) k√∂nnte ein Faktor sein.
* **Aktueller Status**: Das Problem besteht weiterhin in iOS 17 und macOS 14 und stellt eine Herausforderung f√ºr diejenigen dar, die es identifizieren und verstehen m√∂chten.
