# macOS xpc\_connection\_get\_audit\_token 攻撃

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でゼロからヒーローまでのAWSハッキングを学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください。
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>

## Machメッセージの基本情報

Machメッセージについて知らない場合は、このページをチェックしてください:

{% content-ref url="../../../../mac-os-architecture/macos-ipc-inter-process-communication/" %}
[macos-ipc-inter-process-communication](../../../../mac-os-architecture/macos-ipc-inter-process-communication/)
{% endcontent-ref %}

覚えておくべきことは:
Machメッセージは_machポート_を介して送信され、これはmachカーネルに組み込まれた**シングルレシーバー、マルチプルセンダーの通信チャネル**です。**複数のプロセスが**メッセージをmachポートに送信できますが、任意の時点で**単一のプロセスのみがそれから読み取ることができます**。ファイルディスクリプターやソケットと同様に、machポートはカーネルによって割り当てられ管理され、プロセスは整数を見ることができます。これを使用して、どのmachポートを使用したいかをカーネルに指示できます。

## XPC接続

XPC接続がどのように確立されるかわからない場合は、チェックしてください:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## 脆弱性の概要

あなたが知っておくべき興味深い点は、**XPCの抽象化は一対一の接続ですが**、これは**複数の送信者を持つことができる技術の上に構築されている**ということです。

* Machポートはシングルレシーバー、**マルチプルセンダー**です。
* XPC接続の監査トークンは、**最も最近に受信したメッセージからコピーされた**監査トークンです。
* XPC接続の**監査トークン**を取得することは、多くの**セキュリティチェック**にとって重要です。

前述の状況は有望に聞こえますが、問題を引き起こさないシナリオもあります:

* 監査トークンは、接続を受け入れるかどうかを決定するための認証チェックによく使用されます。これはサービスポートへのメッセージを使用して行われるため、**まだ接続が確立されていません**。このポートでのさらなるメッセージは、追加の接続要求として処理されるだけです。したがって、接続を受け入れる前の**チェックは脆弱ではありません**（これはまた、`-listener:shouldAcceptNewConnection:`内の監査トークンが安全であることを意味します）。したがって、私たちは**特定のアクションを検証するXPC接続を探しています**。
* XPCイベントハンドラーは同期的に処理されます。これは、イベントハンドラーが次のメッセージに対して呼び出される前に、1つのメッセージのイベントハンドラーが完了しなければならないことを意味します。たとえ並行ディスパッチキュー上であっても、**XPCイベントハンドラー内では監査トークンが他の通常の（返信以外の！）メッセージによって上書きされることはありません**。

これにより、可能性がある2つの異なる方法が考えられました:

1. Variant1:
* **エクスプロイト**はサービス**A**とサービス**B**に**接続します**
* サービス**B**は、ユーザーができないサービスAで**特権機能を呼び出す**ことができます
* サービス**A**は、接続の**イベントハンドラー**内で_**ない**_場合に**`dispatch_async`**を使用して**`xpc_connection_get_audit_token`**を呼び出します。
* したがって、異なるメッセージが**監査トークンを上書き**する可能性があります。なぜなら、それはイベントハンドラーの外で非同期にディスパッチされているからです。
* エクスプロイトは、サービスAへのSEND権限を**サービスBに渡します**。
* したがって、svc **B**は実際に**メッセージを**サービス**A**に**送信します**。
* **エクスプロイト**は**特権アクションを呼び出そうとします**。RC svc **A**は、**svc Bが監査トークンを上書きした**間にこの**アクション**の認証を**チェック**します（エクスプロイトが特権アクションを呼び出すアクセスを与えます）。
2. Variant 2:
* サービス**B**は、ユーザーができないサービスAで**特権機能を呼び出す**ことができます
* エクスプロイトは**サービスA**に接続し、特定の**返信** **ポート**で応答を期待する**メッセージをエクスプロイトに送信します**。
* エクスプロイトは、**その返信ポートを**持つメッセージを**サービスB**に送信します。
* サービス**Bが返信するとき**、それはメッセージをサービスAに**送信します**。**一方で**、**エクスプロイト**は異なる**メッセージをサービスAに送信し**、特権機能に**到達しようとします**。そして、サービスBからの返信が完璧な瞬間に監査トークンを上書きすることを期待します（Race Condition）。

## Variant 1: イベントハンドラーの外でxpc\_connection\_get\_audit\_tokenを呼び出す <a href="#variant-1-calling-xpc_connection_get_audit_token-outside-of-an-event-handler" id="variant-1-calling-xpc_connection_get_audit_token-outside-of-an-event-handler"></a>

シナリオ:

* 二つのmach **サービス**`A`**と**`B`**に接続できます（サンドボックスプロファイルと接続を受け入れる前の認証チェックに基づいて）。
* _**A**_は、**`B`**が合格できる（しかし私たちのアプリではできない）特定のアクションのための**認証チェック**を持っていなければなりません。
* 例えば、Bがいくつかの**権限**を持っていたり、**root**として実行されている場合、それは彼にAに特権アクションを実行させることを許可するかもしれません。
* この認証チェックのために、**`A`**は監査トークンを非同期で取得します。例えば、**`dispatch_async`**から`xpc_connection_get_audit_token`を呼び出すことによって。

{% hint style="danger" %}
この場合、攻撃者は**エクスプロイト**をトリガーして、**Aにアクションを実行するように何度も依頼し**、同時に**Bが`A`にメッセージを送信する**ことができます。RCが**成功する**と、**Bの監査トークン**がメモリにコピーされ、Aが私たちの**エクスプロイト**のリクエストを**処理**している間に、それはBだけが要求できる**特権アクションへのアクセスを与えます**。
{% endhint %}

これは**`A`**が`smd`であり、**`B`**が`diagnosticd`であった場合に発生しました。関数[`SMJobBless`](https://developer.apple.com/documentation/servicemanagement/1431078-smjobbless?language=objc)は、新しい特権ヘルパーツールをインストールするためにsmbで使用できます（**root**として）。**rootとして実行されるプロセスが**smd**に連絡する**場合、他のチェックは実行されません。

したがって、サービス**B**は**`diagnosticd`**です。なぜなら、それは**root**として実行され、プロセスを**監視**するために使用できるからです。監視が開始されると、それは**秒間に複数のメッセージを送信します**。

攻撃を実行するには:

1. 通常のXPCプロトコルに従って**`smd`**への**接続**を確立します。
2. 次に、**`diagnosticd`**への**接続**を確立しますが、新しいmachポートを二つ生成して送信する代わりに、クライアントポートの送信権を**`smd`**への接続のために持っている送信権のコピーに置き換えます。
3. これは、私たちが`diagnosticd`にXPCメッセージを送信できることを意味しますが、**`diagnosticd`が送信するメッセージは`smd`に行きます**。
* `smd`にとって、私たちのメッセージと`diagnosticd`のメッセージは同じ接続で到着するように見えます。

<figure><img src="../../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1).png" alt="" width="563"><figcaption></figcaption></figure>

4. **`diagnosticd`**に私たちの（または任意のアクティブな）プロセスの**監視を開始するように依頼し**、**`smd`**に特権ツールをインストールするためのルーチン1004メッセージを**スパムします**。
5. これにより、`handle_bless`で非常に特定のウィンドウをヒットする必要があるレースコンディションが作成されます。私たちのアプリバンドルに特権ヘルパーツールがあるため、`xpc_connection_get_pid`の呼び出しが私たち自身のプロセスのPIDを返す必要があります。しかし、`connection_is_authorized`関数内の`xpc_connection_get_audit_token`の呼び出しは、`diganosticd`の監査トークンを使用しなければなりません。

## Variant 2: 返信転送

前述のように、XPC接続のイベントに対するハンドラーは、同時に複数回実行されることはありません。しかし、**XPC返信****メッセージは異なる方法で処理されます。返信を期待するメッセージを送信するための2つの関数があります:

* `void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)`、この場合、XPCメッセージは指定されたキューで受信および解析されます。
* `xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)`、この場合、XPCメッセージは現在のディスパッチキューで受信および解析されます。

したがって、**XPC返信パケットは、XPCイベントハンドラーが実行されている間に解析される可能性があります**。`_xpc_connection_set_creds`はロックを使用していますが、これは監査トークンの部分的な上書きを防ぐだけであり、接続オブジェクト全体をロックするわけではありません。これにより、パケットの解析とそのイベントハンドラーの実行の間に**監査トークンを置き換える**ことが可能になります。

このシナリオには以下が必要です:

* 前と同様に、接続できる二つのmachサービス**`A`**と**`B`**。
* 再び、**`A`**は、**`B`**が合格できる（しかし私たちのアプリではできない）特定のアクションのための認証チェックを持っていな
