# Applications macOS - Inspection, d√©bogage et Fuzzing

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

### [WhiteIntel](https://whiteintel.io)

<figure><img src="../../../.gitbook/assets/image (1227).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) est un moteur de recherche aliment√© par le **dark web** qui offre des fonctionnalit√©s **gratuites** pour v√©rifier si une entreprise ou ses clients ont √©t√© **compromis** par des **logiciels malveillants voleurs**.

Le but principal de WhiteIntel est de lutter contre les prises de contr√¥le de compte et les attaques de ransomware r√©sultant de logiciels malveillants volant des informations.

Vous pouvez consulter leur site Web et essayer leur moteur **gratuitement** sur :

{% embed url="https://whiteintel.io" %}

***

## Analyse statique

### otool
```bash
otool -L /bin/ls #List dynamically linked libraries
otool -tv /bin/ps #Decompile application
```
### objdump

{% code overflow="wrap" %}
```bash
objdump -m --dylibs-used /bin/ls #List dynamically linked libraries
objdump -m -h /bin/ls # Get headers information
objdump -m --syms /bin/ls # Check if the symbol table exists to get function names
objdump -m --full-contents /bin/ls # Dump every section
objdump -d /bin/ls # Dissasemble the binary
objdump --disassemble-symbols=_hello --x86-asm-syntax=intel toolsdemo #Disassemble a function using intel flavour
```
{% endcode %}

### jtool2

L'outil peut √™tre utilis√© comme un **remplacement** pour **codesign**, **otool**, et **objdump**, et offre quelques fonctionnalit√©s suppl√©mentaires. [**T√©l√©chargez-le ici**](http://www.newosxbook.com/tools/jtool.html) ou installez-le avec `brew`.
```bash
# Install
brew install --cask jtool2

jtool2 -l /bin/ls # Get commands (headers)
jtool2 -L /bin/ls # Get libraries
jtool2 -S /bin/ls # Get symbol info
jtool2 -d /bin/ls # Dump binary
jtool2 -D /bin/ls # Decompile binary

# Get signature information
ARCH=x86_64 jtool2 --sig /System/Applications/Automator.app/Contents/MacOS/Automator

# Get MIG information
jtool2 -d __DATA.__const myipc_server | grep MIG
```
### Codesign / ldid

{% hint style="danger" %}
**`Codesign`** peut √™tre trouv√© dans **macOS** tandis que **`ldid`** peut √™tre trouv√© dans **iOS**
{% endhint %}
```bash
# Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

# Check if the app‚Äôs contents have been modified
codesign --verify --verbose /Applications/Safari.app

# Get entitlements from the binary
codesign -d --entitlements :- /System/Applications/Automator.app # Check the TCC perms

# Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app

# Sign a binary
codesign -s <cert-name-keychain> toolsdemo

# Get signature info
ldid -h <binary>

# Get entitlements
ldid -e <binary>

# Change entilements
## /tmp/entl.xml is a XML file with the new entitlements to add
ldid -S/tmp/entl.xml <binary>
```
### SuspiciousPackage

[**SuspiciousPackage**](https://mothersruin.com/software/SuspiciousPackage/get.html) est un outil utile pour inspecter les fichiers **.pkg** (installateurs) et voir ce qu'ils contiennent avant de les installer.\
Ces installateurs ont des scripts bash `preinstall` et `postinstall` que les auteurs de logiciels malveillants utilisent g√©n√©ralement pour **persister** **le** **logiciel malveillant**.

### hdiutil

Cet outil permet de **monter** des images disque Apple (**.dmg**) pour les inspecter avant d'ex√©cuter quoi que ce soit:
```bash
hdiutil attach ~/Downloads/Firefox\ 58.0.2.dmg
```
Il sera mont√© dans `/Volumes`

### Objective-C

#### M√©tadonn√©es

{% hint style="danger" %}
Notez que les programmes √©crits en Objective-C **conservent** leurs d√©clarations de classe **lorsqu'ils sont** **compil√©s** en [binaires Mach-O](../macos-files-folders-and-binaries/universal-binaries-and-mach-o-format.md). Ces d√©clarations de classe **incluent** le nom et le type de :
{% endhint %}

* La classe
* Les m√©thodes de classe
* Les variables d'instance de classe

Vous pouvez obtenir ces informations en utilisant [**class-dump**](https://github.com/nygard/class-dump) :
```bash
class-dump Kindle.app
```
#### Appel de fonction

Lorsqu'une fonction est appel√©e dans un binaire qui utilise Objective-C, le code compil√© au lieu d'appeler cette fonction, appellera **`objc_msgSend`**. Qui appellera la fonction finale :

![](<../../../.gitbook/assets/image (305).png>)

Les param√®tres que cette fonction attend sont :

- Le premier param√®tre (**self**) est "un pointeur qui pointe vers l'**instance de la classe qui doit recevoir le message**". Ou plus simplement, c'est l'objet sur lequel la m√©thode est invoqu√©e. Si la m√©thode est une m√©thode de classe, il s'agira d'une instance de l'objet de la classe (dans son ensemble), tandis que pour une m√©thode d'instance, self pointera vers une instance instanci√©e de la classe en tant qu'objet.
- Le deuxi√®me param√®tre, (**op**), est "le s√©lecteur de la m√©thode qui g√®re le message". Encore une fois, plus simplement, il s'agit simplement du **nom de la m√©thode**.
- Les param√®tres restants sont toutes les **valeurs requises par la m√©thode** (op).

Voyez comment **obtenir ces informations facilement avec `lldb` en ARM64** sur cette page :

{% content-ref url="arm64-basic-assembly.md" %}
[arm64-basic-assembly.md](arm64-basic-assembly.md)
{% endcontent-ref %}

x64 :

| **Argument**      | **Registre**                                                   | **(pour) objc\_msgSend**                                |
| ----------------- | -------------------------------------------------------------- | ------------------------------------------------------ |
| **1er argument**  | **rdi**                                                        | **self : objet sur lequel la m√©thode est invoqu√©e**    |
| **2e argument**   | **rsi**                                                        | **op : nom de la m√©thode**                             |
| **3e argument**   | **rdx**                                                        | **1er argument de la m√©thode**                         |
| **4e argument**   | **rcx**                                                        | **2e argument de la m√©thode**                          |
| **5e argument**   | **r8**                                                         | **3e argument de la m√©thode**                          |
| **6e argument**   | **r9**                                                         | **4e argument de la m√©thode**                          |
| **7e+ argument**  | <p><strong>rsp+</strong><br><strong>(sur la pile)</strong></p> | **5e+ argument de la m√©thode**                         |

### Dynadump

[**Dynadump**](https://github.com/DerekSelander/dynadump) est un outil pour obtenir des Objc-Classes √† partir de dylibs.

### Swift

Avec les binaires Swift, √©tant donn√© qu'il y a une compatibilit√© Objective-C, parfois vous pouvez extraire des d√©clarations en utilisant [class-dump](https://github.com/nygard/class-dump/) mais pas toujours.

Avec les lignes de commande **`jtool -l`** ou **`otool -l`** il est possible de trouver plusieurs sections qui commencent par le pr√©fixe **`__swift5`** :
```bash
jtool2 -l /Applications/Stocks.app/Contents/MacOS/Stocks
LC 00: LC_SEGMENT_64              Mem: 0x000000000-0x100000000    __PAGEZERO
LC 01: LC_SEGMENT_64              Mem: 0x100000000-0x100028000    __TEXT
[...]
Mem: 0x100026630-0x100026d54        __TEXT.__swift5_typeref
Mem: 0x100026d60-0x100027061        __TEXT.__swift5_reflstr
Mem: 0x100027064-0x1000274cc        __TEXT.__swift5_fieldmd
Mem: 0x1000274cc-0x100027608        __TEXT.__swift5_capture
[...]
```
Vous pouvez trouver plus d'informations sur les [**informations stock√©es dans cette section dans cet article de blog**](https://knight.sc/reverse%20engineering/2019/07/17/swift-metadata.html).

De plus, **les binaires Swift peuvent avoir des symboles** (par exemple, les biblioth√®ques doivent stocker des symboles pour que leurs fonctions puissent √™tre appel√©es). Les **symboles ont g√©n√©ralement des informations sur le nom de la fonction** et les attributs de mani√®re peu lisible, donc ils sont tr√®s utiles et il existe des "**d√©sassembleurs**" qui peuvent obtenir le nom original:
```bash
# Ghidra plugin
https://github.com/ghidraninja/ghidra_scripts/blob/master/swift_demangler.py

# Swift cli
swift demangle
```
### Binaires packag√©s

* V√©rifiez l'entropie √©lev√©e
* V√©rifiez les cha√Ænes (s'il n'y a presque aucune cha√Æne compr√©hensible, c'est empaquet√©)
* Le packer UPX pour MacOS g√©n√®re une section appel√©e "\_\_XHDR"

## Analyse dynamique

{% hint style="warning" %}
Notez que pour d√©boguer les binaires, **SIP doit √™tre d√©sactiv√©** (`csrutil disable` ou `csrutil enable --without debug`) ou copier les binaires dans un dossier temporaire et **supprimer la signature** avec `codesign --remove-signature <chemin-binaire>` ou autoriser le d√©bogage du binaire (vous pouvez utiliser [ce script](https://gist.github.com/carlospolop/a66b8d72bb8f43913c4b5ae45672578b))
{% endhint %}

{% hint style="warning" %}
Notez que pour **instrumenter les binaires syst√®me**, (comme `cloudconfigurationd`) sur macOS, **SIP doit √™tre d√©sactiv√©** (simplement supprimer la signature ne fonctionnera pas).
{% endhint %}

### APIs

macOS expose quelques APIs int√©ressantes qui fournissent des informations sur les processus :

* `proc_info` : C'est le principal qui donne beaucoup d'informations sur chaque processus. Vous devez √™tre root pour obtenir des informations sur d'autres processus mais vous n'avez pas besoin d'entitlements sp√©ciaux ou de ports mach.
* `libsysmon.dylib` : Il permet d'obtenir des informations sur les processus via des fonctions expos√©es par XPC, cependant, il est n√©cessaire d'avoir l'entitlement `com.apple.sysmond.client`.

### Stackshot & microstackshots

**Stackshotting** est une technique utilis√©e pour capturer l'√©tat des processus, y compris les piles d'appels de tous les threads en cours d'ex√©cution. Cela est particuli√®rement utile pour le d√©bogage, l'analyse des performances et la compr√©hension du comportement du syst√®me √† un moment donn√©. Sur iOS et macOS, le stackshotting peut √™tre effectu√© √† l'aide de plusieurs outils et m√©thodes comme les outils **`sample`** et **`spindump`**.

### Sysdiagnose

Cet outil (`/usr/bini/ysdiagnose`) collecte essentiellement de nombreuses informations de votre ordinateur en ex√©cutant des dizaines de commandes diff√©rentes telles que `ps`, `zprint`...

Il doit √™tre ex√©cut√© en tant que **root** et le d√©mon `/usr/libexec/sysdiagnosed` a des entitlements tr√®s int√©ressants tels que `com.apple.system-task-ports` et `get-task-allow`.

Son plist est situ√© dans `/System/Library/LaunchDaemons/com.apple.sysdiagnose.plist` qui d√©clare 3 MachServices :

* `com.apple.sysdiagnose.CacheDelete` : Supprime les anciennes archives dans /var/rmp
* `com.apple.sysdiagnose.kernel.ipc` : Port sp√©cial 23 (noyau)
* `com.apple.sysdiagnose.service.xpc` : Interface en mode utilisateur via la classe `Libsysdiagnose` Obj-C. Trois arguments dans un dictionnaire peuvent √™tre pass√©s (`compress`, `display`, `run`)

### Journaux unifi√©s

MacOS g√©n√®re de nombreux journaux qui peuvent √™tre tr√®s utiles lors de l'ex√©cution d'une application pour comprendre **ce qu'elle fait**.

De plus, il existe des journaux qui contiendront la balise `<private>` pour **masquer** certaines informations **identifiables par l'utilisateur** ou **l'ordinateur**. Cependant, il est possible d'**installer un certificat pour divulguer ces informations**. Suivez les explications √† partir de [**ici**](https://superuser.com/questions/1532031/how-to-show-private-data-in-macos-unified-log).

### Hopper

#### Panneau de gauche

Dans le panneau de gauche de Hopper, il est possible de voir les symboles (**Labels**) du binaire, la liste des proc√©dures et fonctions (**Proc**) et les cha√Ænes (**Str**). Ce ne sont pas toutes les cha√Ænes mais celles d√©finies dans plusieurs parties du fichier Mac-O (comme _cstring ou_ `objc_methname`).

#### Panneau central

Dans le panneau central, vous pouvez voir le **code d√©sassembl√©**. Et vous pouvez le voir en d√©sassemblage **brut**, en **graphique**, en **d√©compil√©** et en **binaire** en cliquant sur l'ic√¥ne respective :

<figure><img src="../../../.gitbook/assets/image (343).png" alt=""><figcaption></figcaption></figure>

En cliquant avec le bouton droit sur un objet de code, vous pouvez voir les **r√©f√©rences vers/depuis cet objet** ou m√™me changer son nom (cela ne fonctionne pas dans le pseudocode d√©compil√©) :

<figure><img src="../../../.gitbook/assets/image (1117).png" alt=""><figcaption></figcaption></figure>

De plus, dans le **milieu en bas, vous pouvez √©crire des commandes python**.

#### Panneau de droite

Dans le panneau de droite, vous pouvez voir des informations int√©ressantes telles que l'**historique de navigation** (pour savoir comment vous √™tes arriv√© √† la situation actuelle), le **graphique d'appel** o√π vous pouvez voir toutes les **fonctions qui appellent cette fonction** et toutes les fonctions que **cette fonction appelle**, et des informations sur les **variables locales**.

### dtrace

Il permet aux utilisateurs d'acc√©der aux applications √† un niveau extr√™mement **bas** et offre un moyen aux utilisateurs de **tracer** les **programmes** et m√™me de modifier leur flux d'ex√©cution. Dtrace utilise des **sondes** qui sont **plac√©es dans tout le noyau** et se trouvent √† des emplacements tels que le d√©but et la fin des appels syst√®me.

DTrace utilise la fonction **`dtrace_probe_create`** pour cr√©er une sonde pour chaque appel syst√®me. Ces sondes peuvent √™tre d√©clench√©es au **point d'entr√©e et de sortie de chaque appel syst√®me**. L'interaction avec DTrace se fait via /dev/dtrace qui n'est disponible que pour l'utilisateur root.

{% hint style="success" %}
Pour activer Dtrace sans d√©sactiver compl√®tement la protection SIP, vous pouvez ex√©cuter en mode de r√©cup√©ration : `csrutil enable --without dtrace`

Vous pouvez √©galement **`dtrace`** ou **`dtruss`** des binaires que **vous avez compil√©s**.
{% endhint %}

Les sondes disponibles de dtrace peuvent √™tre obtenues avec :
```bash
dtrace -l | head
ID   PROVIDER            MODULE                          FUNCTION NAME
1     dtrace                                                     BEGIN
2     dtrace                                                     END
3     dtrace                                                     ERROR
43    profile                                                     profile-97
44    profile                                                     profile-199
```
Le nom de la sonde se compose de quatre parties : le fournisseur, le module, la fonction et le nom (`fbt:mach_kernel:ptrace:entry`). Si vous ne sp√©cifiez pas une partie du nom, Dtrace appliquera cette partie comme un joker.

Pour configurer DTrace afin d'activer les sondes et de sp√©cifier les actions √† effectuer lorsqu'elles se d√©clenchent, nous devrons utiliser le langage D.

Une explication plus d√©taill√©e et plus d'exemples peuvent √™tre trouv√©s dans [https://illumos.org/books/dtrace/chp-intro.html](https://illumos.org/books/dtrace/chp-intro.html)

#### Exemples

Ex√©cutez `man -k dtrace` pour lister les **scripts DTrace disponibles**. Exemple : `sudo dtruss -n binary`

* En ligne
```bash
#Count the number of syscalls of each running process
sudo dtrace -n 'syscall:::entry {@[execname] = count()}'
```
* script
```bash
syscall:::entry
/pid == $1/
{
}

#Log every syscall of a PID
sudo dtrace -s script.d 1234
```

```bash
syscall::open:entry
{
printf("%s(%s)", probefunc, copyinstr(arg0));
}
syscall::close:entry
{
printf("%s(%d)\n", probefunc, arg0);
}

#Log files opened and closed by a process
sudo dtrace -s b.d -c "cat /etc/hosts"
```

```bash
syscall:::entry
{
;
}
syscall:::return
{
printf("=%d\n", arg1);
}

#Log sys calls with values
sudo dtrace -s syscalls_info.d -c "cat /etc/hosts"
```
### dtruss
```bash
dtruss -c ls #Get syscalls of ls
dtruss -c -p 1000 #get syscalls of PID 1000
```
### kdebug

Il s'agit d'une facilit√© de tra√ßage du noyau. Les codes document√©s peuvent √™tre trouv√©s dans **`/usr/share/misc/trace.codes`**.

Des outils comme `latency`, `sc_usage`, `fs_usage` et `trace` l'utilisent en interne.

Pour interagir avec `kdebug`, `sysctl` est utilis√© sur l'espace de noms `kern.kdebug` et les MIB √† utiliser peuvent √™tre trouv√©s dans `sys/sysctl.h` ayant les fonctions impl√©ment√©es dans `bsd/kern/kdebug.c`.

Pour interagir avec kdebug avec un client personnalis√©, voici g√©n√©ralement les √©tapes √† suivre :

* Supprimer les param√®tres existants avec KERN\_KDSETREMOVE
* D√©finir la trace avec KERN\_KDSETBUF et KERN\_KDSETUP
* Utiliser KERN\_KDGETBUF pour obtenir le nombre d'entr√©es de tampon
* R√©cup√©rer son propre client de la trace avec KERN\_KDPINDEX
* Activer le tra√ßage avec KERN\_KDENABLE
* Lire le tampon en appelant KERN\_KDREADTR
* Pour faire correspondre chaque thread avec son processus, appeler KERN\_KDTHRMAP.

Pour obtenir ces informations, il est possible d'utiliser l'outil Apple **`trace`** ou l'outil personnalis√© [kDebugView (kdv)](https://newosxbook.com/tools/kdv.html)**.**

**Notez que Kdebug n'est disponible que pour un client √† la fois.** Ainsi, un seul outil aliment√© par k-debug peut √™tre ex√©cut√© √† la fois.

### ktrace

Les API `ktrace_*` proviennent de `libktrace.dylib` qui enveloppent celles de `Kdebug`. Ensuite, un client peut simplement appeler `ktrace_session_create` et `ktrace_events_[single/class]` pour d√©finir des rappels sur des codes sp√©cifiques, puis le d√©marrer avec `ktrace_start`.

Vous pouvez utiliser celui-ci m√™me avec **SIP activ√©**

Vous pouvez utiliser en tant que clients l'utilitaire `ktrace`:
```bash
ktrace trace -s -S -t c -c ls | grep "ls("
```
Ou `tailspin`.

### kperf

Cela est utilis√© pour effectuer un profilage au niveau du noyau et est construit en utilisant des appels `Kdebug`.

En gros, la variable globale `kernel_debug_active` est v√©rifi√©e et si elle est d√©finie, elle appelle `kperf_kdebug_handler` avec le code `Kdebug` et l'adresse du cadre du noyau appelant. Si le code `Kdebug` correspond √† l'un s√©lectionn√©, il obtient les "actions" configur√©es sous forme de bitmap (v√©rifiez `osfmk/kperf/action.h` pour les options).

Kperf dispose √©galement d'une table MIB sysctl : (en tant que root) `sysctl kperf`. Ces codes peuvent √™tre trouv√©s dans `osfmk/kperf/kperfbsd.c`.

De plus, un sous-ensemble de la fonctionnalit√© de Kperf r√©side dans `kpc`, qui fournit des informations sur les compteurs de performance de la machine.

### ProcessMonitor

[**ProcessMonitor**](https://objective-see.com/products/utilities.html#ProcessMonitor) est un outil tr√®s utile pour v√©rifier les actions li√©es aux processus qu'un processus effectue (par exemple, surveiller les nouveaux processus qu'un processus cr√©e).

### SpriteTree

[**SpriteTree**](https://themittenmac.com/tools/) est un outil qui affiche les relations entre les processus.\
Vous devez surveiller votre Mac avec une commande comme **`sudo eslogger fork exec rename create > cap.json`** (le terminal lan√ßant cela n√©cessite FDA). Ensuite, vous pouvez charger le json dans cet outil pour visualiser toutes les relations :

<figure><img src="../../../.gitbook/assets/image (1182).png" alt="" width="375"><figcaption></figcaption></figure>

### FileMonitor

[**FileMonitor**](https://objective-see.com/products/utilities.html#FileMonitor) permet de surveiller les √©v√©nements de fichiers (comme les cr√©ations, modifications et suppressions) en fournissant des informations d√©taill√©es sur ces √©v√©nements.

### Crescendo

[**Crescendo**](https://github.com/SuprHackerSteve/Crescendo) est un outil GUI avec l'apparence que les utilisateurs de Windows peuvent conna√Ætre de _Procmon_ de Microsoft Sysinternal. Cet outil permet de d√©marrer et d'arr√™ter l'enregistrement de diff√©rents types d'√©v√©nements, de filtrer ces √©v√©nements par cat√©gories telles que fichier, processus, r√©seau, etc., et offre la fonctionnalit√© de sauvegarder les √©v√©nements enregistr√©s au format json.

### Apple Instruments

[**Apple Instruments**](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CellularBestPractices/Appendix/Appendix.html) font partie des outils de d√©veloppement Xcode - utilis√©s pour surveiller les performances des applications, identifier les fuites de m√©moire et suivre l'activit√© du syst√®me de fichiers.

![](<../../../.gitbook/assets/image (1138).png>)

### fs\_usage

Permet de suivre les actions effectu√©es par les processus :
```bash
fs_usage -w -f filesys ls #This tracks filesystem actions of proccess names containing ls
fs_usage -w -f network curl #This tracks network actions
```
### TaskExplorer

[**Taskexplorer**](https://objective-see.com/products/taskexplorer.html) est utile pour voir les **biblioth√®ques** utilis√©es par un binaire, les **fichiers** qu'il utilise et les **connexions r√©seau**.\
Il v√©rifie √©galement les processus binaires avec **virustotal** et affiche des informations sur le binaire.

## PT\_DENY\_ATTACH <a href="#page-title" id="page-title"></a>

Dans [**cet article de blog**](https://knight.sc/debugging/2019/06/03/debugging-apple-binaries-that-use-pt-deny-attach.html), vous pouvez trouver un exemple sur la fa√ßon de **d√©boguer un d√©mon en cours d'ex√©cution** qui utilise **`PT_DENY_ATTACH`** pour emp√™cher le d√©bogage m√™me si SIP √©tait d√©sactiv√©.

### lldb

**lldb** est l'outil de **d√©bogage** binaire **macOS** de facto.
```bash
lldb ./malware.bin
lldb -p 1122
lldb -n malware.bin
lldb -n malware.bin --waitfor
```
Vous pouvez d√©finir le style Intel lors de l'utilisation de lldb en cr√©ant un fichier appel√© **`.lldbinit`** dans votre dossier personnel avec la ligne suivante :
```bash
settings set target.x86-disassembly-flavor intel
```
{% hint style="warning" %}
√Ä l'int√©rieur de lldb, dump un processus avec `process save-core`
{% endhint %}

<table data-header-hidden><thead><tr><th width="225"></th><th></th></tr></thead><tbody><tr><td><strong>(lldb) Commande</strong></td><td><strong>Description</strong></td></tr><tr><td><strong>run (r)</strong></td><td>D√©marrer l'ex√©cution, qui se poursuivra jusqu'√† ce qu'un point d'arr√™t soit atteint ou que le processus se termine.</td></tr><tr><td><strong>continue (c)</strong></td><td>Continuer l'ex√©cution du processus en cours de d√©bogage.</td></tr><tr><td><strong>nexti (n / ni)</strong></td><td>Ex√©cuter l'instruction suivante. Cette commande sautera les appels de fonction.</td></tr><tr><td><strong>stepi (s / si)</strong></td><td>Ex√©cuter l'instruction suivante. Contrairement √† la commande nexti, cette commande entrera dans les appels de fonction.</td></tr><tr><td><strong>finish (f)</strong></td><td>Ex√©cuter le reste des instructions dans la fonction actuelle ("frame") et s'arr√™ter.</td></tr><tr><td><strong>control + c</strong></td><td>Mettre en pause l'ex√©cution. Si le processus a √©t√© ex√©cut√© (r) ou continu√© (c), cela provoquera l'arr√™t du processus ... o√π qu'il soit en train d'ex√©cuter.</td></tr><tr><td><strong>breakpoint (b)</strong></td><td><p>b main #Toute fonction appel√©e main</p><p>b &#x3C;nom_du_binaire>`main #Fonction principale du binaire</p><p>b set -n main --shlib &#x3C;nom_lib> #Fonction principale du binaire indiqu√©</p><p>b -[NSDictionary objectForKey:]</p><p>b -a 0x0000000100004bd9</p><p>br l #Liste des points d'arr√™t</p><p>br e/dis &#x3C;num> #Activer/D√©sactiver le point d'arr√™t</p><p>breakpoint delete &#x3C;num></p></td></tr><tr><td><strong>help</strong></td><td><p>help breakpoint #Obtenir de l'aide sur la commande de point d'arr√™t</p><p>help memory write #Obtenir de l'aide pour √©crire dans la m√©moire</p></td></tr><tr><td><strong>reg</strong></td><td><p>reg read</p><p>reg read $rax</p><p>reg read $rax --format &#x3C;<a href="https://lldb.llvm.org/use/variable.html#type-format">format</a>></p><p>reg write $rip 0x100035cc0</p></td></tr><tr><td><strong>x/s &#x3C;adresse_reg/m√©moire></strong></td><td>Afficher la m√©moire sous forme de cha√Æne termin√©e par un caract√®re nul.</td></tr><tr><td><strong>x/i &#x3C;adresse_reg/m√©moire></strong></td><td>Afficher la m√©moire sous forme d'instruction d'assemblage.</td></tr><tr><td><strong>x/b &#x3C;adresse_reg/m√©moire></strong></td><td>Afficher la m√©moire sous forme d'octet.</td></tr><tr><td><strong>print object (po)</strong></td><td><p>Cela affichera l'objet r√©f√©renc√© par le param√®tre</p><p>po $raw</p><p><code>{</code></p><p><code>dnsChanger = {</code></p><p><code>"affiliate" = "";</code></p><p><code>"blacklist_dns" = ();</code></p><p>Remarquez que la plupart des API ou m√©thodes Objective-C d'Apple renvoient des objets et doivent donc √™tre affich√©es via la commande "print object" (po). Si po ne produit pas de sortie significative, utilisez <code>x/b</code></p></td></tr><tr><td><strong>memory</strong></td><td>memory read 0x000....<br>memory read $x0+0xf2a<br>memory write 0x100600000 -s 4 0x41414141 #√âcrire AAAA √† cette adresse<br>memory write -f s $rip+0x11f+7 "AAAA" #√âcrire AAAA √† l'adresse</td></tr><tr><td><strong>disassembly</strong></td><td><p>dis #D√©sassembler la fonction actuelle</p><p>dis -n &#x3C;nom_de_la_fonction> #D√©sassembler la fonction</p><p>dis -n &#x3C;nom_de_la_fonction> -b &#x3C;nom_de_base> #D√©sassembler la fonction<br>dis -c 6 #D√©sassembler 6 lignes<br>dis -c 0x100003764 -e 0x100003768 # De une adresse √† l'autre<br>dis -p -c 4 # Commencer √† l'adresse actuelle √† d√©sassembler</p></td></tr><tr><td><strong>parray</strong></td><td>parray 3 (char **)$x1 # V√©rifier le tableau de 3 composants dans le registre x1</td></tr></tbody></table>

{% hint style="info" %}
Lors de l'appel de la fonction **`objc_sendMsg`**, le registre **rsi** contient le **nom de la m√©thode** sous forme de cha√Æne termin√©e par un caract√®re nul ("C"). Pour afficher le nom via lldb, faites :

`(lldb) x/s $rsi: 0x1000f1576: "startMiningWithPort:password:coreCount:slowMemory:currency:"`

`(lldb) print (char*)$rsi:`\
`(char *) $1 = 0x00000001000f1576 "startMiningWithPort:password:coreCount:slowMemory:currency:"`

`(lldb) reg read $rsi: rsi = 0x00000001000f1576 "startMiningWithPort:password:coreCount:slowMemory:currency:"`
{% endhint %}

### Analyse dynamique anti

#### D√©tection de VM

* La commande **`sysctl hw.model`** renvoie "Mac" lorsque l'**h√¥te est un MacOS** mais quelque chose de diff√©rent lorsqu'il s'agit d'une VM.
* En jouant avec les valeurs de **`hw.logicalcpu`** et **`hw.physicalcpu`**, certains malwares tentent de d√©tecter s'il s'agit d'une VM.
* Certains malwares peuvent √©galement **d√©tecter** si la machine est bas√©e sur **VMware** en fonction de l'adresse MAC (00:50:56).
* Il est √©galement possible de savoir si un processus est en cours de d√©bogage avec un code simple tel que :
* `if(P_TRACED == (info.kp_proc.p_flag & P_TRACED)){ //processus en cours de d√©bogage }`
* Il est √©galement possible d'invoquer l'appel syst√®me **`ptrace`** avec le drapeau **`PT_DENY_ATTACH`**. Cela **emp√™che** un d√©b**u**ggeur de s'attacher et de tracer.
* Vous pouvez v√©rifier si la fonction **`sysctl`** ou **`ptrace`** est **import√©e** (mais le malware pourrait l'importer dynamiquement)
* Comme indiqu√© dans cet article, ‚Äú[D√©jouer les techniques anti-debug : variantes de ptrace sur macOS](https://alexomara.com/blog/defeating-anti-debug-techniques-macos-ptrace-variants/)‚Äù :\
"_Le message Processus # a quitt√© avec un **statut = 45 (0x0000002d)** est g√©n√©ralement un signe r√©v√©lateur que la cible de d√©bogage utilise **PT\_DENY\_ATTACH**_"
## Vidages m√©moire

Les vidages m√©moire sont cr√©√©s si :

- `kern.coredump` sysctl est d√©fini sur 1 (par d√©faut)
- Si le processus n'√©tait pas suid/sgid ou si `kern.sugid_coredump` est √† 1 (par d√©faut, c'est 0)
- La limite `AS_CORE` autorise l'op√©ration. Il est possible de supprimer la cr√©ation de vidages m√©moire en appelant `ulimit -c 0` et de les r√©activer avec `ulimit -c unlimited`.

Dans ces cas, les vidages m√©moire sont g√©n√©r√©s selon `kern.corefile` sysctl et sont g√©n√©ralement stock√©s dans `/cores/core/.%P`.

## Fuzzing

### [ReportCrash](https://ss64.com/osx/reportcrash.html)

ReportCrash **analyse les processus qui plantent et enregistre un rapport de plantage sur le disque**. Un rapport de plantage contient des informations qui peuvent **aider un d√©veloppeur √† diagnostiquer** la cause d'un plantage.\
Pour les applications et autres processus **fonctionnant dans le contexte de lancement par utilisateur**, ReportCrash s'ex√©cute en tant que LaunchAgent et enregistre les rapports de plantage dans `~/Library/Logs/DiagnosticReports/` de l'utilisateur.\
Pour les d√©mons, les autres processus **fonctionnant dans le contexte de lancement syst√®me** et les autres processus privil√©gi√©s, ReportCrash s'ex√©cute en tant que LaunchDaemon et enregistre les rapports de plantage dans `/Library/Logs/DiagnosticReports` du syst√®me.

Si vous √™tes pr√©occup√© par les rapports de plantage **envoy√©s √† Apple**, vous pouvez les d√©sactiver. Sinon, les rapports de plantage peuvent √™tre utiles pour **d√©terminer comment un serveur a plant√©**.
```bash
#To disable crash reporting:
launchctl unload -w /System/Library/LaunchAgents/com.apple.ReportCrash.plist
sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist

#To re-enable crash reporting:
launchctl load -w /System/Library/LaunchAgents/com.apple.ReportCrash.plist
sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist
```
### Sommeil

Lors du fuzzing dans un MacOS, il est important de ne pas permettre au Mac de se mettre en veille :

* systemsetup -setsleep Never
* pmset, Pr√©f√©rences Syst√®me
* [KeepingYouAwake](https://github.com/newmarcel/KeepingYouAwake)

#### D√©connexion SSH

Si vous effectuez du fuzzing via une connexion SSH, il est important de s'assurer que la session ne se termine pas. Modifiez donc le fichier sshd\_config avec :

* TCPKeepAlive Yes
* ClientAliveInterval 0
* ClientAliveCountMax 0
```bash
sudo launchctl unload /System/Library/LaunchDaemons/ssh.plist
sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist
```
### Gestionnaires internes

**Consultez la page suivante** pour d√©couvrir comment vous pouvez trouver quelle application est responsable de **la gestion du sch√©ma ou du protocole sp√©cifi√© :**

{% content-ref url="../macos-file-extension-apps.md" %}
[macos-file-extension-apps.md](../macos-file-extension-apps.md)
{% endcontent-ref %}

### √ânum√©ration des processus r√©seau
```bash
dtrace -n 'syscall::recv*:entry { printf("-> %s (pid=%d)", execname, pid); }' >> recv.log
#wait some time
sort -u recv.log > procs.txt
cat procs.txt
```
Ou utilisez `netstat` ou `lsof`

### Libgmalloc

<figure><img src="../../../.gitbook/assets/Pasted Graphic 14.png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
lldb -o "target create `which some-binary`" -o "settings set target.env-vars DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib" -o "run arg1 arg2" -o "bt" -o "reg read" -o "dis -s \$pc-32 -c 24 -m -F intel" -o "quit"
```
{% endcode %}

### Fuzzers

#### [AFL++](https://github.com/AFLplusplus/AFLplusplus)

Fonctionne pour les outils en ligne de commande

#### [Litefuzz](https://github.com/sec-tools/litefuzz)

Il "**fonctionne simplement"** avec les outils GUI macOS. Notez que certaines applications macOS ont des exigences sp√©cifiques comme des noms de fichiers uniques, la bonne extension, la n√©cessit√© de lire les fichiers √† partir du bac √† sable (`~/Library/Containers/com.apple.Safari/Data`)...

Quelques exemples:

{% code overflow="wrap" %}
```bash
# iBooks
litefuzz -l -c "/System/Applications/Books.app/Contents/MacOS/Books FUZZ" -i files/epub -o crashes/ibooks -t /Users/test/Library/Containers/com.apple.iBooksX/Data/tmp -x 10 -n 100000 -ez

# -l : Local
# -c : cmdline with FUZZ word (if not stdin is used)
# -i : input directory or file
# -o : Dir to output crashes
# -t : Dir to output runtime fuzzing artifacts
# -x : Tmeout for the run (default is 1)
# -n : Num of fuzzing iterations (default is 1)
# -e : enable second round fuzzing where any crashes found are reused as inputs
# -z : enable malloc debug helpers

# Font Book
litefuzz -l -c "/System/Applications/Font Book.app/Contents/MacOS/Font Book FUZZ" -i input/fonts -o crashes/font-book -x 2 -n 500000 -ez

# smbutil (using pcap capture)
litefuzz -lk -c "smbutil view smb://localhost:4455" -a tcp://localhost:4455 -i input/mac-smb-resp -p -n 100000 -z

# screensharingd (using pcap capture)
litefuzz -s -a tcp://localhost:5900 -i input/screenshared-session --reportcrash screensharingd -p -n 100000
```
{% endcode %}

### Plus d'informations sur le fuzzing MacOS

* [https://www.youtube.com/watch?v=T5xfL9tEg44](https://www.youtube.com/watch?v=T5xfL9tEg44)
* [https://github.com/bnagy/slides/blob/master/OSXScale.pdf](https://github.com/bnagy/slides/blob/master/OSXScale.pdf)
* [https://github.com/bnagy/francis/tree/master/exploitaben](https://github.com/bnagy/francis/tree/master/exploitaben)
* [https://github.com/ant4g0nist/crashwrangler](https://github.com/ant4g0nist/crashwrangler)

## R√©f√©rences

* [**OS X Incident Response: Scripting and Analysis**](https://www.amazon.com/OS-Incident-Response-Scripting-Analysis-ebook/dp/B01FHOHHVS)
* [**https://www.youtube.com/watch?v=T5xfL9tEg44**](https://www.youtube.com/watch?v=T5xfL9tEg44)
* [**https://taomm.org/vol1/analysis.html**](https://taomm.org/vol1/analysis.html)
* [**The Art of Mac Malware: The Guide to Analyzing Malicious Software**](https://taomm.org/)

### [WhiteIntel](https://whiteintel.io)

<figure><img src="../../../.gitbook/assets/image (1227).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) est un moteur de recherche aliment√© par le **dark web** qui offre des fonctionnalit√©s **gratuites** pour v√©rifier si une entreprise ou ses clients ont √©t√© **compromis** par des **logiciels malveillants voleurs**.

Le but principal de WhiteIntel est de lutter contre les prises de contr√¥le de compte et les attaques de ransomware r√©sultant de logiciels malveillants volant des informations.

Vous pouvez consulter leur site Web et essayer leur moteur **gratuitement** sur :

{% embed url="https://whiteintel.io" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
