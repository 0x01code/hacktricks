# macOS Apps - Inspecci√≥n, depuraci√≥n y Fuzzing

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## An√°lisis est√°tico

### otool
```bash
otool -L /bin/ls #List dynamically linked libraries
otool -tv /bin/ps #Decompile application
```
### objdump

El comando `objdump` es una herramienta de l√≠nea de comandos que se utiliza para inspeccionar archivos binarios y objetos en sistemas operativos macOS. Proporciona informaci√≥n detallada sobre el contenido y la estructura interna de los archivos, como los s√≠mbolos, las secciones y las instrucciones de ensamblador.

#### Uso b√°sico

El siguiente comando muestra el contenido de un archivo binario:

```bash
objdump -d archivo_binario
```

Esto mostrar√° el c√≥digo ensamblador del archivo, junto con informaci√≥n sobre los s√≠mbolos y las secciones.

#### Inspecci√≥n de s√≠mbolos

El comando `objdump` tambi√©n se puede utilizar para inspeccionar los s√≠mbolos presentes en un archivo binario. Puede mostrar una lista de todos los s√≠mbolos definidos en el archivo utilizando el siguiente comando:

```bash
objdump -t archivo_binario
```

Esto mostrar√° una lista de s√≠mbolos junto con su direcci√≥n y tipo.

#### Depuraci√≥n de archivos binarios

`objdump` tambi√©n se puede utilizar para depurar archivos binarios. Puede mostrar informaci√≥n de depuraci√≥n, como los puntos de interrupci√≥n y los registros de depuraci√≥n, utilizando el siguiente comando:

```bash
objdump -g archivo_binario
```

Esto mostrar√° informaci√≥n detallada sobre los puntos de interrupci√≥n y los registros de depuraci√≥n presentes en el archivo.

#### Fuzzing de archivos binarios

El comando `objdump` tambi√©n se puede utilizar para realizar fuzzing en archivos binarios. Puede generar archivos de entrada aleatorios y utilizarlos como entrada para el archivo binario utilizando el siguiente comando:

```bash
objdump -f archivo_binario
```

Esto generar√° archivos de entrada aleatorios y los utilizar√° como entrada para el archivo binario, lo que puede ayudar a identificar vulnerabilidades y errores en el archivo.

En resumen, `objdump` es una herramienta √∫til para inspeccionar, depurar y realizar fuzzing en archivos binarios en sistemas operativos macOS. Proporciona informaci√≥n detallada sobre los s√≠mbolos, las secciones y las instrucciones de ensamblador, lo que puede ser √∫til para identificar vulnerabilidades y errores en los archivos.
```bash
objdump -m --dylibs-used /bin/ls #List dynamically linked libraries
objdump -m -h /bin/ls # Get headers information
objdump -m --syms /bin/ls # Check if the symbol table exists to get function names
objdump -m --full-contents /bin/ls # Dump every section
objdump -d /bin/ls # Dissasemble the binary
```
### jtool2

Esta herramienta se puede utilizar como un **reemplazo** para **codesign**, **otool** y **objdump**, y ofrece algunas caracter√≠sticas adicionales.
```bash
# Install
brew install --cask jtool2

jtool2 -l /bin/ls # Get commands (headers)
jtool2 -L /bin/ls # Get libraries
jtool2 -S /bin/ls # Get symbol info
jtool2 -d /bin/ls # Dump binary
jtool2 -D /bin/ls # Decompile binary

# Get signature information
ARCH=x86_64 jtool2 --sig /System/Applications/Automator.app/Contents/MacOS/Automator

```
### Firma de c√≥digo

La firma de c√≥digo es un proceso utilizado en macOS para verificar la autenticidad e integridad de una aplicaci√≥n. Cada aplicaci√≥n en macOS debe estar firmada con un certificado v√°lido para garantizar que no ha sido alterada o comprometida. La firma de c√≥digo utiliza criptograf√≠a asim√©trica para crear una firma digital √∫nica que se adjunta a la aplicaci√≥n.

La firma de c√≥digo se puede verificar utilizando la herramienta `codesign` en la l√≠nea de comandos. Esta herramienta permite inspeccionar y verificar la firma de una aplicaci√≥n, as√≠ como tambi√©n identificar cualquier problema de seguridad o manipulaci√≥n.

Al inspeccionar una aplicaci√≥n con `codesign`, se pueden obtener detalles sobre el certificado utilizado para firmarla, la identidad del desarrollador y cualquier recurso adicional que se haya firmado junto con la aplicaci√≥n.

La verificaci√≥n de la firma de c√≥digo es esencial para garantizar la seguridad de las aplicaciones en macOS. Si una aplicaci√≥n no est√° firmada correctamente o si su firma ha sido manipulada, puede representar un riesgo para la seguridad del sistema.

Es importante tener en cuenta que la firma de c√≥digo no garantiza la ausencia de vulnerabilidades en una aplicaci√≥n, pero ayuda a garantizar su autenticidad y que no ha sido alterada desde su firma original.
```bash
# Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

# Check if the app‚Äôs contents have been modified
codesign --verify --verbose /Applications/Safari.app

# Get entitlements from the binary
codesign -d --entitlements :- /System/Applications/Automator.app # Check the TCC perms

# Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app

# Sign a binary
codesign -s <cert-name-keychain> toolsdemo
```
### SuspiciousPackage

[**SuspiciousPackage**](https://mothersruin.com/software/SuspiciousPackage/get.html) es una herramienta √∫til para inspeccionar archivos **.pkg** (instaladores) y ver qu√© hay dentro antes de instalarlo.\
Estos instaladores tienen scripts bash `preinstall` y `postinstall` que los autores de malware suelen abusar para **persistir** el **malware**.

### hdiutil

Esta herramienta permite **montar** im√°genes de disco de Apple (**.dmg**) para inspeccionarlas antes de ejecutar cualquier cosa:
```bash
hdiutil attach ~/Downloads/Firefox\ 58.0.2.dmg
```
Se montar√° en `/Volumes`

### Objective-C

#### Metadatos

{% hint style="danger" %}
Ten en cuenta que los programas escritos en Objective-C **mantienen** sus declaraciones de clase **cuando** se compilan en [binarios Mach-O](../macos-files-folders-and-binaries/universal-binaries-and-mach-o-format.md). Estas declaraciones de clase **incluyen** el nombre y tipo de:
{% endhint %}

* La clase
* Los m√©todos de clase
* Las variables de instancia de clase

Puedes obtener esta informaci√≥n utilizando [**class-dump**](https://github.com/nygard/class-dump):
```bash
class-dump Kindle.app
```
#### Llamada a funciones

Cuando se llama a una funci√≥n en un binario que utiliza Objective-C, en lugar de llamar directamente a esa funci√≥n, el c√≥digo compilado llamar√° a **`objc_msgSend`**. Esta funci√≥n llamar√° a la funci√≥n final:

![](<../../../.gitbook/assets/image (560).png>)

Los par√°metros que esta funci√≥n espera son:

* El primer par√°metro (**self**) es "un puntero que apunta a la **instancia de la clase que recibir√° el mensaje**". En otras palabras, es el objeto sobre el cual se invoca el m√©todo. Si el m√©todo es un m√©todo de clase, esto ser√° una instancia del objeto de la clase (en su totalidad), mientras que para un m√©todo de instancia, self apuntar√° a una instancia instanciada de la clase como objeto.
* El segundo par√°metro (**op**) es "el selector del m√©todo que maneja el mensaje". Nuevamente, de manera m√°s simple, este es simplemente el **nombre del m√©todo**.
* Los par√°metros restantes son cualquier **valor que sea requerido por el m√©todo** (op).

| **Argumento**      | **Registro**                                                    | **(para) objc\_msgSend**                                |
| ----------------- | --------------------------------------------------------------- | ------------------------------------------------------ |
| **1er argumento** | **rdi**                                                         | **self: objeto sobre el cual se invoca el m√©todo**      |
| **2do argumento** | **rsi**                                                         | **op: nombre del m√©todo**                              |
| **3er argumento** | **rdx**                                                         | **1er argumento para el m√©todo**                        |
| **4to argumento** | **rcx**                                                         | **2do argumento para el m√©todo**                        |
| **5to argumento** | **r8**                                                          | **3er argumento para el m√©todo**                        |
| **6to argumento** | **r9**                                                          | **4to argumento para el m√©todo**                        |
| **7mo+ argumento**| <p><strong>rsp+</strong><br><strong>(en la pila)</strong></p>  | **5to+ argumento para el m√©todo**                       |

### Swift

Con binarios de Swift, dado que hay compatibilidad con Objective-C, a veces se pueden extraer declaraciones utilizando [class-dump](https://github.com/nygard/class-dump/), pero no siempre.

Con los comandos de l√≠nea **`jtool -l`** o **`otool -l`** es posible encontrar varias secciones que comienzan con el prefijo **`__swift5`**:
```bash
jtool2 -l /Applications/Stocks.app/Contents/MacOS/Stocks
LC 00: LC_SEGMENT_64              Mem: 0x000000000-0x100000000    __PAGEZERO
LC 01: LC_SEGMENT_64              Mem: 0x100000000-0x100028000    __TEXT
[...]
Mem: 0x100026630-0x100026d54        __TEXT.__swift5_typeref
Mem: 0x100026d60-0x100027061        __TEXT.__swift5_reflstr
Mem: 0x100027064-0x1000274cc        __TEXT.__swift5_fieldmd
Mem: 0x1000274cc-0x100027608        __TEXT.__swift5_capture
[...]
```
Puedes encontrar m√°s informaci√≥n sobre la [**informaci√≥n almacenada en estas secciones en esta publicaci√≥n de blog**](https://knight.sc/reverse%20engineering/2019/07/17/swift-metadata.html).

### Binarios comprimidos

* Verificar la entrop√≠a alta
* Verificar las cadenas (si hay casi ninguna cadena comprensible, est√° comprimido)
* El empaquetador UPX para MacOS genera una secci√≥n llamada "\_\_XHDR"

## An√°lisis din√°mico

{% hint style="warning" %}
Ten en cuenta que para depurar binarios, **SIP debe estar desactivado** (`csrutil disable` o `csrutil enable --without debug`) o copiar los binarios a una carpeta temporal y **eliminar la firma** con `codesign --remove-signature <ruta-del-binario>` o permitir la depuraci√≥n del binario (puedes usar [este script](https://gist.github.com/carlospolop/a66b8d72bb8f43913c4b5ae45672578b)).
{% endhint %}

{% hint style="warning" %}
Ten en cuenta que para **instrumentar binarios del sistema** (como `cloudconfigurationd`) en macOS, **SIP debe estar desactivado** (simplemente eliminar la firma no funcionar√°).
{% endhint %}

### Registros unificados

MacOS genera muchos registros que pueden ser muy √∫tiles al ejecutar una aplicaci√≥n para tratar de entender **qu√© est√° haciendo**.

Adem√°s, hay algunos registros que contendr√°n la etiqueta `<private>` para **ocultar** cierta informaci√≥n **identificable** del **usuario** o de la **computadora**. Sin embargo, es posible **instalar un certificado para revelar esta informaci√≥n**. Sigue las explicaciones de [**aqu√≠**](https://superuser.com/questions/1532031/how-to-show-private-data-in-macos-unified-log).

### Hopper

#### Panel izquierdo

En el panel izquierdo de Hopper es posible ver los s√≠mbolos (**Etiquetas**) del binario, la lista de procedimientos y funciones (**Proc**) y las cadenas (**Str**). Estas no son todas las cadenas, sino las definidas en varias partes del archivo Mac-O (como _cstring o_ `objc_methname`).

#### Panel central

En el panel central puedes ver el **c√≥digo desensamblado**. Y puedes verlo como un desensamblado **en bruto**, como **gr√°fico**, como **descompilado** y como **binario** haciendo clic en el icono correspondiente:

<figure><img src="../../../.gitbook/assets/image (2) (6).png" alt=""><figcaption></figcaption></figure>

Al hacer clic derecho en un objeto de c√≥digo, puedes ver las **referencias hacia/desde ese objeto** o incluso cambiar su nombre (esto no funciona en el pseudoc√≥digo descompilado):

<figure><img src="../../../.gitbook/assets/image (1) (1) (2).png" alt=""><figcaption></figcaption></figure>

Adem√°s, en la **parte inferior central puedes escribir comandos de Python**.

#### Panel derecho

En el panel derecho puedes ver informaci√≥n interesante como el **historial de navegaci√≥n** (para saber c√≥mo llegaste a la situaci√≥n actual), el **gr√°fico de llamadas** donde puedes ver todas las **funciones que llaman a esta funci√≥n** y todas las funciones que **esta funci√≥n llama**, e informaci√≥n sobre las **variables locales**.

### dtruss
```bash
dtruss -c ls #Get syscalls of ls
dtruss -c -p 1000 #get syscalls of PID 1000
```
### ktrace

Puedes usar este incluso con **SIP activado**.
```bash
ktrace trace -s -S -t c -c ls | grep "ls("
```
### dtrace

Permite a los usuarios acceder a las aplicaciones a un nivel extremadamente **bajo** y proporciona una forma de **rastrear** los **programas** e incluso cambiar su flujo de ejecuci√≥n. Dtrace utiliza **sondas** que se **colocan en todo el kernel** y se encuentran en ubicaciones como el inicio y el final de las llamadas al sistema.

DTrace utiliza la funci√≥n **`dtrace_probe_create`** para crear una sonda para cada llamada al sistema. Estas sondas se pueden activar en el **punto de entrada y salida de cada llamada al sistema**. La interacci√≥n con DTrace se realiza a trav√©s de /dev/dtrace, que solo est√° disponible para el usuario root.

Las sondas disponibles de dtrace se pueden obtener con:
```bash
dtrace -l | head
ID   PROVIDER            MODULE                          FUNCTION NAME
1     dtrace                                                     BEGIN
2     dtrace                                                     END
3     dtrace                                                     ERROR
43    profile                                                     profile-97
44    profile                                                     profile-199
```
El nombre de la sonda consta de cuatro partes: el proveedor, el m√≥dulo, la funci√≥n y el nombre (`fbt:mach_kernel:ptrace:entry`). Si no se especifica alguna parte del nombre, Dtrace la considerar√° como un comod√≠n.

Para configurar DTrace y activar sondas, as√≠ como especificar las acciones a realizar cuando se activan, necesitaremos utilizar el lenguaje D.

Se puede encontrar una explicaci√≥n m√°s detallada y m√°s ejemplos en [https://illumos.org/books/dtrace/chp-intro.html](https://illumos.org/books/dtrace/chp-intro.html)

#### Ejemplos

Ejecuta `man -k dtrace` para listar los **scripts de DTrace disponibles**. Ejemplo: `sudo dtruss -n binary`

* En la l√≠nea
```bash
#Count the number of syscalls of each running process
sudo dtrace -n 'syscall:::entry {@[execname] = count()}'
```
# Inspeccionando, depurando y fuzzing de aplicaciones en macOS

En este directorio, encontrar√°s herramientas y t√©cnicas para inspeccionar, depurar y realizar fuzzing en aplicaciones en macOS. Estas t√©cnicas te permitir√°n analizar el comportamiento de las aplicaciones, identificar vulnerabilidades y encontrar posibles puntos de escalada de privilegios.

## Contenido

- [Introducci√≥n](#introducci√≥n)
- [Inspeccionando aplicaciones](#inspeccionando-aplicaciones)
- [Depurando aplicaciones](#depurando-aplicaciones)
- [Fuzzing de aplicaciones](#fuzzing-de-aplicaciones)

## Introducci√≥n

Antes de comenzar a inspeccionar, depurar o realizar fuzzing en aplicaciones en macOS, es importante comprender los conceptos b√°sicos de estas t√©cnicas y c√≥mo se aplican en el contexto de macOS. Aseg√∫rate de tener un conocimiento s√≥lido de los lenguajes de programaci√≥n utilizados en las aplicaciones que deseas analizar, as√≠ como de las herramientas y entornos de desarrollo disponibles en macOS.

## Inspeccionando aplicaciones

La inspecci√≥n de aplicaciones implica examinar el c√≥digo fuente y los recursos de una aplicaci√≥n para comprender su funcionamiento interno. Esto puede incluir la revisi√≥n de archivos binarios, bibliotecas compartidas, archivos de configuraci√≥n y otros componentes relevantes. Al inspeccionar una aplicaci√≥n, puedes identificar posibles vulnerabilidades, como contrase√±as en texto plano, claves de API expuestas o errores de programaci√≥n que podr√≠an ser explotados.

Algunas herramientas √∫tiles para la inspecci√≥n de aplicaciones en macOS incluyen:

- [Hopper Disassembler](https://www.hopperapp.com/) - Un desensamblador interactivo para macOS que te permite analizar y comprender el c√≥digo de la aplicaci√≥n.
- [class-dump](https://github.com/nygard/class-dump) - Una herramienta de l√≠nea de comandos que extrae la declaraci√≥n de clases Objective-C de un archivo binario.
- [strings](https://ss64.com/osx/strings.html) - Un comando de terminal que busca y muestra cadenas de texto legibles en archivos binarios.

## Depurando aplicaciones

La depuraci√≥n de aplicaciones implica rastrear y solucionar problemas en el c√≥digo de una aplicaci√≥n. Esto puede incluir la identificaci√≥n y correcci√≥n de errores, la optimizaci√≥n del rendimiento y la comprensi√≥n del flujo de ejecuci√≥n de la aplicaci√≥n. Al depurar una aplicaci√≥n, puedes descubrir vulnerabilidades y puntos d√©biles que podr√≠an ser explotados.

Algunas herramientas √∫tiles para la depuraci√≥n de aplicaciones en macOS incluyen:

- [LLDB](https://lldb.llvm.org/) - Un depurador de c√≥digo abierto que se utiliza com√∫nmente en macOS para depurar aplicaciones.
- [Xcode](https://developer.apple.com/xcode/) - Un entorno de desarrollo integrado (IDE) que incluye herramientas de depuraci√≥n y an√°lisis de rendimiento para aplicaciones macOS.

## Fuzzing de aplicaciones

El fuzzing de aplicaciones implica enviar entradas aleatorias o maliciosas a una aplicaci√≥n para encontrar vulnerabilidades y errores de programaci√≥n. Al realizar fuzzing en una aplicaci√≥n, puedes descubrir posibles puntos de escalada de privilegios o vulnerabilidades que podr√≠an ser explotadas por un atacante.

Algunas herramientas √∫tiles para el fuzzing de aplicaciones en macOS incluyen:

- [AFL](https://github.com/google/AFL) - Un marco de fuzzing de c√≥digo abierto que se utiliza para encontrar vulnerabilidades en aplicaciones.
- [Peach Fuzzer](https://peachfuzzer.com/) - Una plataforma de fuzzing que te permite generar casos de prueba personalizados y automatizar el proceso de fuzzing.

Recuerda que al realizar inspecci√≥n, depuraci√≥n o fuzzing de aplicaciones en macOS, debes asegurarte de tener los permisos y autorizaciones adecuados para acceder y analizar las aplicaciones. Adem√°s, siempre debes seguir las leyes y regulaciones aplicables y obtener el consentimiento adecuado antes de realizar cualquier actividad de an√°lisis o pruebas.
```bash
syscall:::entry
/pid == $1/
{
}

#Log every syscall of a PID
sudo dtrace -s script.d 1234
```

```bash
syscall::open:entry
{
printf("%s(%s)", probefunc, copyinstr(arg0));
}
syscall::close:entry
{
printf("%s(%d)\n", probefunc, arg0);
}

#Log files opened and closed by a process
sudo dtrace -s b.d -c "cat /etc/hosts"
```

```bash
syscall:::entry
{
;
}
syscall:::return
{
printf("=%d\n", arg1);
}

#Log sys calls with values
sudo dtrace -s syscalls_info.d -c "cat /etc/hosts"
```
### ProcessMonitor

[**ProcessMonitor**](https://objective-see.com/products/utilities.html#ProcessMonitor) es una herramienta muy √∫til para verificar las acciones relacionadas con los procesos que un proceso est√° realizando (por ejemplo, monitorear qu√© nuevos procesos est√° creando un proceso).

### FileMonitor

[**FileMonitor**](https://objective-see.com/products/utilities.html#FileMonitor) permite monitorear eventos de archivos (como creaci√≥n, modificaciones y eliminaciones) proporcionando informaci√≥n detallada sobre dichos eventos.

### Apple Instruments

[**Apple Instruments**](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CellularBestPractices/Appendix/Appendix.html) son parte de las herramientas de desarrollo de Xcode, utilizadas para monitorear el rendimiento de las aplicaciones, identificar fugas de memoria y rastrear la actividad del sistema de archivos.

![](<../../../.gitbook/assets/image (15).png>)

### fs\_usage

Permite seguir las acciones realizadas por los procesos:
```bash
fs_usage -w -f filesys ls #This tracks filesystem actions of proccess names containing ls
fs_usage -w -f network curl #This tracks network actions
```
### TaskExplorer

[**Taskexplorer**](https://objective-see.com/products/taskexplorer.html) es √∫til para ver las **bibliotecas** utilizadas por un binario, los **archivos** que est√° utilizando y las conexiones de **red**.\
Tambi√©n verifica los procesos binarios en **virustotal** y muestra informaci√≥n sobre el binario.

## PT\_DENY\_ATTACH <a href="#page-title" id="page-title"></a>

En [**esta publicaci√≥n de blog**](https://knight.sc/debugging/2019/06/03/debugging-apple-binaries-that-use-pt-deny-attach.html) puedes encontrar un ejemplo sobre c√≥mo **depurar un daemon en ejecuci√≥n** que utiliza **`PT_DENY_ATTACH`** para evitar la depuraci√≥n incluso si SIP est√° desactivado.

### lldb

**lldb** es la herramienta de **hecho** para la **depuraci√≥n** de binarios en **macOS**.
```bash
lldb ./malware.bin
lldb -p 1122
lldb -n malware.bin
lldb -n malware.bin --waitfor
```
{% hint style="warning" %}
Dentro de lldb, volcar un proceso con `process save-core`
{% endhint %}

| **Comando (lldb)**            | **Descripci√≥n**                                                                                                                                                                                                                                                                                                                                                                                                           |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **run (r)**                   | Iniciar la ejecuci√≥n, que continuar√° sin interrupciones hasta que se alcance un punto de interrupci√≥n o el proceso se termine.                                                                                                                                                                                                                                                                                                                     |
| **continue (c)**              | Continuar la ejecuci√≥n del proceso depurado.                                                                                                                                                                                                                                                                                                                                                                               |
| **nexti (n / ni)**            | Ejecutar la siguiente instrucci√≥n. Este comando omitir√° las llamadas a funciones.                                                                                                                                                                                                                                                                                                                                                 |
| **stepi (s / si)**            | Ejecutar la siguiente instrucci√≥n. A diferencia del comando nexti, este comando entrar√° en las llamadas a funciones.                                                                                                                                                                                                                                                                                                                       |
| **finish (f)**                | Ejecutar el resto de las instrucciones en la funci√≥n actual ("frame") y detenerse.                                                                                                                                                                                                                                                                                                                                   |
| **control + c**               | Pausar la ejecuci√≥n. Si el proceso se ha ejecutado (r) o continuado (c), esto har√° que el proceso se detenga ...donde sea que se est√© ejecutando actualmente.                                                                                                                                                                                                                                                                             |
| **breakpoint (b)**            | <p>b main</p><p>b -[NSDictionary objectForKey:]</p><p>b 0x0000000100004bd9</p><p>br l #Lista de puntos de interrupci√≥n</p><p>br e/dis &#x3C;num> #Habilitar/Deshabilitar punto de interrupci√≥n</p><p>breakpoint delete &#x3C;num><br>b set -n main --shlib &#x3C;lib_name></p>                                                                                                                                                                               |
| **help**                      | <p>help breakpoint #Obtener ayuda del comando breakpoint</p><p>help memory write #Obtener ayuda para escribir en la memoria</p>                                                                                                                                                                                                                                                                                                         |
| **reg**                       | <p>reg read</p><p>reg read $rax</p><p>reg write $rip 0x100035cc0</p>                                                                                                                                                                                                                                                                                                                                                      |
| **x/s \<reg/memory address>** | Mostrar la memoria como una cadena terminada en nulo.                                                                                                                                                                                                                                                                                                                                                                           |
| **x/i \<reg/memory address>** | Mostrar la memoria como instrucci√≥n de ensamblador.                                                                                                                                                                                                                                                                                                                                                                               |
| **x/b \<reg/memory address>** | Mostrar la memoria como byte.                                                                                                                                                                                                                                                                                                                                                                                               |
| **print object (po)**         | <p>Esto imprimir√° el objeto referenciado por el par√°metro</p><p>po $raw</p><p><code>{</code></p><p><code>dnsChanger = {</code></p><p><code>"affiliate" = "";</code></p><p><code>"blacklist_dns" = ();</code></p><p>Tenga en cuenta que la mayor√≠a de las API o m√©todos Objective-C de Apple devuelven objetos y, por lo tanto, deben mostrarse mediante el comando "print object" (po). Si po no produce una salida significativa, use <code>x/b</code></p> |
| **memory**                    | <p>memory read 0x000....<br>memory read $x0+0xf2a<br>memory write 0x100600000 -s 4 0x41414141 #Escribir AAAA en esa direcci√≥n<br>memory write -f s $rip+0x11f+7 "AAAA" #Escribir AAAA en la direcci√≥n</p>                                                                                                                                                                                                                            |
| **disassembly**               | <p>dis #Desensamblar la funci√≥n actual<br>dis -c 6 #Desensamblar 6 l√≠neas<br>dis -c 0x100003764 -e 0x100003768 #Desde una direcci√≥n hasta la otra<br>dis -p -c 4 #Comenzar en la direcci√≥n actual desensamblando</p>                                                                                                                                                                                                                                 |
| **parray**                    | parray 3 (char \*\*)$x1 #Comprobar el array de 3 componentes en el registro x1                                                                                                                                                                                                                                                                                                                                                           |

{% hint style="info" %}
Cuando se llama a la funci√≥n **`objc_sendMsg`**, el registro **rsi** contiene el **nombre del m√©todo** como una cadena terminada en nulo ("C"). Para imprimir el nombre a trav√©s de lldb, haga lo siguiente:

`(lldb) x/s $rsi: 0x1000f1576: "startMiningWithPort:password:coreCount:slowMemory:currency:"`

`(lldb) print (char*)$rsi:`\
`(char *) $1 = 0x00000001000f1576 "startMiningWithPort:password:coreCount:slowMemory:currency:"`

`(lldb) reg read $rsi: rsi = 0x00000001000f1576 "startMiningWithPort:password:coreCount:slowMemory:currency:"`
{% endhint %}

### Anti-An√°lisis Din√°mico

#### Detecci√≥n de VM

* El comando **`sysctl hw.model`** devuelve "Mac" cuando el **host es un MacOS**, pero algo diferente cuando es una VM.
* Jugando con los valores de **`hw.logicalcpu`** y **`hw.physicalcpu`**, algunos malwares intentan detectar si es una VM.
* Algunos malwares tambi√©n pueden **detectar** si la m√°quina es **VMware** bas√°ndose en la direcci√≥n MAC (00:50:56).
* Tambi√©n es posible encontrar si un proceso est√° siendo depurado con un c√≥digo simple como:
* `if(P_TRACED == (info.kp_proc.p_flag & P_TRACED)){ //proceso siendo depurado }`
* Tambi√©n puede invocar la llamada al sistema **`ptrace`** con la bandera **`PT_DENY_ATTACH`**. Esto **impide** que un depurador se adjunte y rastree.
* Puede verificar si la funci√≥n **`sysctl`** o **`ptrace`** est√° siendo **importada** (pero el malware podr√≠a importarla din√°micamente)
* Como se se√±ala en este art√≠culo, "[Defeating Anti-Debug Techniques: macOS ptrace variants](https://alexomara.com/blog/defeating-anti-debug-techniques-macos-ptrace-variants/)":\
"_El mensaje Process # exited with **status = 45 (0x0000002d)** generalmente es una se√±al reveladora de que el objetivo de depuraci√≥n est√° utilizando **PT\_DENY\_ATTACH**_"

## Fuzzing

### [ReportCrash](https://ss64.com/osx/reportcrash.html)

ReportCrash **analiza los procesos que se bloquean y guarda un informe de bloqueo en el disco**. Un informe de bloqueo contiene informaci√≥n que puede **ayudar a un desarrollador a diagnosticar** la causa de un bloqueo.\
Para aplicaciones y otros procesos **que se ejecutan en el contexto de lanzamiento por usuario**, ReportCrash se ejecuta como un LaunchAgent y guarda los informes de bloqueo en `~/Library/Logs/DiagnosticReports/` del usuario.\
Para demonios, otros procesos **que se ejecutan en el contexto de lanzamiento del sistema** y otros procesos privilegiados, ReportCrash se ejecuta como un LaunchDaemon y guarda los informes de bloqueo en `/Library/Logs/DiagnosticReports` del sistema.

Si te preocupa que los informes de bloqueo **se env√≠en a Apple**, puedes desactivarlos. Si no, los informes de bloqueo pueden ser √∫tiles para **descubrir c√≥mo se bloque√≥ un servidor**.
```bash
#To disable crash reporting:
launchctl unload -w /System/Library/LaunchAgents/com.apple.ReportCrash.plist
sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist

#To re-enable crash reporting:
launchctl load -w /System/Library/LaunchAgents/com.apple.ReportCrash.plist
sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist
```
### Dormir

Cuando se realiza fuzzing en un MacOS, es importante evitar que la Mac se duerma:

* systemsetup -setsleep Never
* pmset, Preferencias del Sistema
* [KeepingYouAwake](https://github.com/newmarcel/KeepingYouAwake)

#### Desconexi√≥n SSH

Si est√°s realizando fuzzing a trav√©s de una conexi√≥n SSH, es importante asegurarse de que la sesi√≥n no se cierre. Para ello, cambia el archivo sshd\_config con:

* TCPKeepAlive Yes
* ClientAliveInterval 0
* ClientAliveCountMax 0
```bash
sudo launchctl unload /System/Library/LaunchDaemons/ssh.plist
sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist
```
### Controladores internos

**Consulta la siguiente p√°gina** para descubrir c√≥mo puedes encontrar qu√© aplicaci√≥n es responsable de **manejar el esquema o protocolo especificado:**

{% content-ref url="../macos-file-extension-apps.md" %}
[macos-file-extension-apps.md](../macos-file-extension-apps.md)
{% endcontent-ref %}

### Enumeraci√≥n de procesos de red

Esto es interesante para encontrar procesos que est√°n gestionando datos de red:
```bash
dtrace -n 'syscall::recv*:entry { printf("-> %s (pid=%d)", execname, pid); }' >> recv.log
#wait some time
sort -u recv.log > procs.txt
cat procs.txt
```
O utiliza `netstat` o `lsof`

### Libgmalloc

<figure><img src="../../../.gitbook/assets/Pasted Graphic 14.png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```bash
lldb -o "target create `which some-binary`" -o "settings set target.env-vars DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib" -o "run arg1 arg2" -o "bt" -o "reg read" -o "dis -s \$pc-32 -c 24 -m -F intel" -o "quit"
```
{% endcode %}

### Fuzzers

#### [AFL++](https://github.com/AFLplusplus/AFLplusplus)

Funciona para herramientas de l√≠nea de comandos.

#### [Litefuzz](https://github.com/sec-tools/litefuzz)

Funciona con herramientas de GUI de macOS. Ten en cuenta que algunas aplicaciones de macOS tienen requisitos espec√≠ficos como nombres de archivo √∫nicos, la extensi√≥n correcta, necesitan leer los archivos desde el sandbox (`~/Library/Containers/com.apple.Safari/Data`)...

Algunos ejemplos:

{% code overflow="wrap" %}
```bash
# iBooks
litefuzz -l -c "/System/Applications/Books.app/Contents/MacOS/Books FUZZ" -i files/epub -o crashes/ibooks -t /Users/test/Library/Containers/com.apple.iBooksX/Data/tmp -x 10 -n 100000 -ez

# -l : Local
# -c : cmdline with FUZZ word (if not stdin is used)
# -i : input directory or file
# -o : Dir to output crashes
# -t : Dir to output runtime fuzzing artifacts
# -x : Tmeout for the run (default is 1)
# -n : Num of fuzzing iterations (default is 1)
# -e : enable second round fuzzing where any crashes found are reused as inputs
# -z : enable malloc debug helpers

# Font Book
litefuzz -l -c "/System/Applications/Font Book.app/Contents/MacOS/Font Book FUZZ" -i input/fonts -o crashes/font-book -x 2 -n 500000 -ez

# smbutil (using pcap capture)
litefuzz -lk -c "smbutil view smb://localhost:4455" -a tcp://localhost:4455 -i input/mac-smb-resp -p -n 100000 -z

# screensharingd (using pcap capture)
litefuzz -s -a tcp://localhost:5900 -i input/screenshared-session --reportcrash screensharingd -p -n 100000
```
{% endcode %}

### M√°s informaci√≥n sobre Fuzzing en MacOS

* [https://www.youtube.com/watch?v=T5xfL9tEg44](https://www.youtube.com/watch?v=T5xfL9tEg44)
* [https://github.com/bnagy/slides/blob/master/OSXScale.pdf](https://github.com/bnagy/slides/blob/master/OSXScale.pdf)
* [https://github.com/bnagy/francis/tree/master/exploitaben](https://github.com/bnagy/francis/tree/master/exploitaben)
* [https://github.com/ant4g0nist/crashwrangler](https://github.com/ant4g0nist/crashwrangler)

## Referencias

* [**OS X Incident Response: Scripting and Analysis**](https://www.amazon.com/OS-Incident-Response-Scripting-Analysis-ebook/dp/B01FHOHHVS)
* [**https://www.youtube.com/watch?v=T5xfL9tEg44**](https://www.youtube.com/watch?v=T5xfL9tEg44)
* [**https://taomm.org/vol1/analysis.html**](https://taomm.org/vol1/analysis.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
