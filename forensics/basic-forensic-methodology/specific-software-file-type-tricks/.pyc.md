# 反编译编译过的Python二进制文件（exe, elf）- 从.pyc中检索

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 如果你在一家**网络安全公司**工作，想在**HackTricks**上看到你的**公司广告**，或者想要获取**PEASS的最新版本或下载HackTricks的PDF**？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)系列。
* 获取[**官方的PEASS & HackTricks商品**](https://peass.creator-spring.com)。
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**telegram群组**](https://t.me/peass)或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

<img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" data-size="original">

如果你对**黑客职业**感兴趣，并且想要黑入不可黑的系统 - **我们正在招聘！**（_需要流利的波兰语书写和口语_）。

{% embed url="https://www.stmcyber.com/careers" %}

## 从编译过的二进制文件到.pyc

从一个**ELF**编译过的二进制文件，你可以用以下方法**获取.pyc**：
```bash
pyi-archive_viewer <binary>
# The list of python modules will be given here:
[(0, 230, 311, 1, 'm', 'struct'),
(230, 1061, 1792, 1, 'm', 'pyimod01_os_path'),
(1291, 4071, 8907, 1, 'm', 'pyimod02_archive'),
(5362, 5609, 13152, 1, 'm', 'pyimod03_importers'),
(10971, 1473, 3468, 1, 'm', 'pyimod04_ctypes'),
(12444, 816, 1372, 1, 's', 'pyiboot01_bootstrap'),
(13260, 696, 1053, 1, 's', 'pyi_rth_pkgutil'),
(13956, 1134, 2075, 1, 's', 'pyi_rth_multiprocessing'),
(15090, 445, 672, 1, 's', 'pyi_rth_inspect'),
(15535, 2514, 4421, 1, 's', 'binary_name'),
...

? X binary_name
to filename? /tmp/binary.pyc
```
在一个**python exe二进制文件**中，你可以通过运行以下命令来**获取.pyc文件**：
```bash
python pyinstxtractor.py executable.exe
```
## 从 .pyc 到 python 代码

对于 **.pyc** 数据（“编译过的” python），你应该开始尝试**提取** **原始的** **python** **代码**：
```bash
uncompyle6 binary.pyc  > decompiled.py
```
**确保** 二进制文件的**扩展名**为 "**.pyc**"（如果不是，uncompyle6 将无法工作）

在执行 **uncompyle6** 时，你可能会遇到**以下错误**：

### 错误：未知魔数 227
```bash
/kali/.local/bin/uncompyle6 /tmp/binary.pyc
Unknown magic number 227 in /tmp/binary.pyc
```
要解决这个问题，你需要在生成的文件开头**添加正确的魔数**。

**魔数随 Python 版本而变化**，要获取 **Python 3.8** 的魔数，你需要**打开一个 Python 3.8** 终端并执行：
```
>> import imp
>> imp.get_magic().hex()
'550d0d0a'
```
**魔数**在这个案例中对于python3.8是**`0x550d0d0a`**，然后，为了修复这个错误，你需要在**.pyc文件**的**开头** **添加**以下字节：`0x0d550a0d000000000000000000000000`

**一旦**你**添加**了那个魔数头部，**错误应该会被修复。**

这是一个正确添加的**python3.8 .pyc魔数头部**应该看起来的样子：
```bash
hexdump 'binary.pyc' | head
0000000 0d55 0a0d 0000 0000 0000 0000 0000 0000
0000010 00e3 0000 0000 0000 0000 0000 0000 0000
0000020 0700 0000 4000 0000 7300 0132 0000 0064
0000030 0164 006c 005a 0064 0164 016c 015a 0064
```
### 错误：反编译通用错误

**其他错误** 如：`class 'AssertionError'>; co_code 应该是以下类型之一 (<class 'str'>, <class 'bytes'>, <class 'list'>, <class 'tuple'>); 现在是 <class 'NoneType'>` 可能会出现。

这可能意味着你**没有正确添加**魔术数字，或者你没有**使用**正确的魔术数字，所以请**确保你使用了正确的魔术数字**（或尝试一个新的）。

检查之前的错误文档。

## 自动工具

工具 [https://github.com/countercept/python-exe-unpacker](https://github.com/countercept/python-exe-unpacker) 将社区可用的几个工具结合起来，**帮助研究人员解包和反编译**用python编写的可执行文件（py2exe 和 pyinstaller）。

有几个YARA规则可用于确定可执行文件是否用python编写（此脚本还确认可执行文件是否用py2exe或pyinstaller创建）。

### ImportError：文件名：'unpacked/malware\_3.exe/**pycache**/archive.cpython-35.pyc' 不存在

目前，使用unpy2exe或pyinstxtractor时，我们得到的Python字节码文件可能不完整，因此它**无法被uncompyle6识别以获取纯Python源代码**。这是由于缺少Python**字节码版本号**造成的。因此，我们加入了一个prepend选项；这将在其中包含一个Python字节码版本号，并帮助简化反编译过程。当我们尝试使用uncompyle6来反编译.pyc文件时，它返回一个错误。然而，**一旦我们使用了prepend选项，我们可以看到Python源代码已经成功地被反编译**。
```
test@test: uncompyle6 unpacked/malware_3.exe/archive.py
Traceback (most recent call last):
……………………….
ImportError: File name: 'unpacked/malware_3.exe/__pycache__/archive.cpython-35.pyc' doesn't exist
```

```
test@test:python python_exe_unpack.py -p unpacked/malware_3.exe/archive
[*] On Python 2.7
[+] Magic bytes are already appended.

# Successfully decompiled file
[+] Successfully decompiled.
```
## 分析Python汇编

如果您按照前面的步骤未能提取Python的“原始”代码，那么您可以尝试**提取** **汇编**代码（但是**它不是很描述性**，所以**尝试**再次提取原始代码）。在[这里](https://bits.theorem.co/protecting-a-python-codebase/)，我找到了一个非常简单的代码来**反汇编** _.pyc_ 二进制文件（祝您好运理解代码流程）。如果_.pyc_是来自python2，请使用python2：
```bash
>>> import dis
>>> import marshal
>>> import struct
>>> import imp
>>>
>>> with open('hello.pyc', 'r') as f:  # Read the binary file
...     magic = f.read(4)
...     timestamp = f.read(4)
...     code = f.read()
...
>>>
>>> # Unpack the structured content and un-marshal the code
>>> magic = struct.unpack('<H', magic[:2])
>>> timestamp = struct.unpack('<I', timestamp)
>>> code = marshal.loads(code)
>>> magic, timestamp, code
((62211,), (1425911959,), <code object <module> at 0x7fd54f90d5b0, file "hello.py", line 1>)
>>>
>>> # Verify if the magic number corresponds with the current python version
>>> struct.unpack('<H', imp.get_magic()[:2]) == magic
True
>>>
>>> # Disassemble the code object
>>> dis.disassemble(code)
1           0 LOAD_CONST               0 (<code object hello_world at 0x7f31b7240eb0, file "hello.py", line 1>)
3 MAKE_FUNCTION            0
6 STORE_NAME               0 (hello_world)
9 LOAD_CONST               1 (None)
12 RETURN_VALUE
>>>
>>> # Also disassemble that const being loaded (our function)
>>> dis.disassemble(code.co_consts[0])
2           0 LOAD_CONST               1 ('Hello  {0}')
3 LOAD_ATTR                0 (format)
6 LOAD_FAST                0 (name)
9 CALL_FUNCTION            1
12 PRINT_ITEM
13 PRINT_NEWLINE
14 LOAD_CONST               0 (None)
17 RETURN_VALUE
```
## Python 转 Executable

首先，我们将展示如何使用 py2exe 和 PyInstaller 编译有效载荷。

### 使用 py2exe 创建有效载荷：

1. 从 [http://www.py2exe.org/](http://www.py2exe.org) 安装 py2exe 包。
2. 对于有效载荷（在此例中，我们将其命名为 hello.py），使用类似图 1 中的脚本。选项 “bundle_files” 的值为 1 会将包括 Python 解释器在内的所有内容打包进一个 exe 文件。
3. 脚本准备好后，我们将执行命令 “python setup.py py2exe”。这将创建可执行文件，就像图 2 中展示的那样。
```
from distutils.core import setup
import py2exe, sys, os

sys.argv.append('py2exe')

setup(
options = {'py2exe': {'bundle_files': 1}},
#windows = [{'script': "hello.py"}],
console = [{'script': "hello.py"}],
zipfile = None,
)
```

```
C:\Users\test\Desktop\test>python setup.py py2exe
running py2exe
*** searching for required modules ***
*** parsing results ***
*** finding dlls needed ***
*** create binaries ***
*** byte compile python files ***
*** copy extensions ***
*** copy dlls ***
copying C:\Python27\lib\site-packages\py2exe\run.exe -> C:\Users\test\Desktop\test\dist\hello.exe
Adding python27.dll as resource to C:\Users\test\Desktop\test\dist\hello.exe
```
### 使用 PyInstaller 创建有效载荷：

1. 使用 pip 安装 PyInstaller（pip install pyinstaller）。
2. 安装后，我们将执行命令 “pyinstaller --onefile hello.py”（提醒一下，‘hello.py’ 是我们的有效载荷）。这将把所有内容打包成一个可执行文件。
```
C:\Users\test\Desktop\test>pyinstaller --onefile hello.py
108 INFO: PyInstaller: 3.3.1
108 INFO: Python: 2.7.14
108 INFO: Platform: Windows-10-10.0.16299
………………………………
5967 INFO: checking EXE
5967 INFO: Building EXE because out00-EXE.toc is non existent
5982 INFO: Building EXE from out00-EXE.toc
5982 INFO: Appending archive to EXE C:\Users\test\Desktop\test\dist\hello.exe
6325 INFO: Building EXE from out00-EXE.toc completed successfully.
```
## 参考资料

* [https://blog.f-secure.com/how-to-decompile-any-python-binary/](https://blog.f-secure.com/how-to-decompile-any-python-binary/)

<img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" data-size="original">

如果你对**黑客职业**感兴趣，并且想要黑掉那些不可黑的东西 - **我们正在招聘！**（_需要流利的波兰语书写和口语_）。

{% embed url="https://www.stmcyber.com/careers" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在**网络安全公司**工作吗？你想在**HackTricks**中看到你的**公司广告**吗？或者你想要获得**PEASS最新版本或下载HackTricks的PDF**吗？查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)收藏
* 获取[**官方的PEASS & HackTricks周边商品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**telegram群组**](https://t.me/peass)或在**Twitter**上**关注**我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
