# スタックオーバーフロー

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じてゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローする**。
* **ハッキングトリックを共有するために、** [**HackTricks**](https://github.com/carlospolop/hacktricks)と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリにPRを提出する。

</details>

## スタックオーバーフローとは

**スタックオーバーフロー**は、プログラムがスタックに割り当てられたデータよりも多くのデータを書き込むと発生する脆弱性です。この余分なデータは、隣接するメモリ空間を**上書き**し、有効なデータの破損、制御フローの混乱、および悪意のあるコードの実行を引き起こす可能性があります。この問題は、入力に対して境界チェックを実行しない安全でない関数の使用によってしばしば発生します。

この上書きの主な問題は、**EIP**および**EBP**ポインターが**スタックに格納**されて前の関数に戻るためのポインターであることです。したがって、攻撃者はこれらを上書きして**プログラムの実行フローを制御**できます。

この脆弱性は通常、関数が**割り当てられた量よりも多くのバイトをスタックにコピー**するために発生し、その結果、スタックの他の部分を上書きできるようになります。\
このような脆弱性のある一般的な関数には、`strcpy`、`strcat`、`sprintf`、`gets`、`fgets`などがあります...

たとえば、次の関数が脆弱性の対象となる可能性があります:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### スタックオーバーフローの見つけ方

スタックオーバーフローを見つける最も一般的な方法は、非常に大きな`A`の入力を与えることです（例：`python3 -c 'print("A"*1000)'`）そして、**アドレス`0x41414141`にアクセスしようとしました**と示す`Segmentation Fault`が予想されます。

さらに、スタックオーバーフローの脆弱性が見つかったら、**EIPポインタを上書きできるまでのオフセットを見つける必要があります**。これには通常、**De Bruijn sequence**が使用されます。これは、サイズが_k_で長さが_n_のサブシーケンスを持つ与えられたアルファベットに対して、**すべての可能な長さ**_**n**_**のサブシーケンスがちょうど一度だけ現れる**巡回シーケンスです。

これにより、EIPを上書きしているオフセットを手動で特定する必要がなくなり、これらのシーケンスの1つをパディングとして使用し、それを上書きしたバイトのオフセットを見つけることができます。

これには**pwntools**を使用することができます：
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
または **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## スタックオーバーフローの悪用

オーバーフロー中（オーバーフローサイズが十分に大きいと仮定する）、スタック内の他の変数の値を上書きできるようになり、EBPとEIP（またはそれ以上）に到達するまで続けることができます。\
この種の脆弱性を悪用する最も一般的な方法は、**EIPポインタを変更**して、関数が終了するときに**ユーザーが指定した場所に制御フローがリダイレクト**されるようにすることです。

ただし、他のシナリオでは、単に**スタック内の変数の値を上書き**するだけで十分な場合もあります（簡単なCTFチャレンジなど）。

### Ret2win

この種のCTFチャレンジでは、バイナリ内に**呼び出されない関数**があり、**それを呼び出して勝利する必要がある**場合があります。これらのチャレンジでは、**EIPを上書きするオフセットを見つけ**、呼び出す関数のアドレスを見つける必要があります（通常、[**ASLR**](../common-binary-protections/aslr.md)は無効になっている可能性があります）。脆弱な関数が戻ると、隠された関数が呼び出されます。

{% content-ref url="ret2win.md" %}
[ret2win.md](ret2win.md)
{% endcontent-ref %}

### スタックシェルコード

このシナリオでは、攻撃者はスタックにシェルコードを配置し、制御可能なEIPを悪用してシェルコードに移動し、攻撃者のコードを実行できます。

{% content-ref url="stack-shellcode.md" %}
[stack-shellcode.md](stack-shellcode.md)
{% endcontent-ref %}

## ROP

この技術は、前述の技術に対する主要な保護をバイパスするための基本的なフレームワークです：**実行可能なスタックがない**。これにより、バイナリ内の既存の命令を悪用して任意のコマンドを実行するための他の技術（ret2lib、ret2syscallなど）を実行できます。

{% content-ref url="rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](rop-return-oriented-programing.md)
{% endcontent-ref %}

## 保護の種類

脆弱性の悪用を防ぐためにいくつかの保護が導入されています。これについては以下を確認してください：

{% content-ref url="../common-binary-protections/" %}
[common-binary-protections](../common-binary-protections/)
{% endcontent-ref %}
