# Stack Overflow

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Cos'√® uno Stack Overflow

Uno **stack overflow** √® una vulnerabilit√† che si verifica quando un programma scrive pi√π dati nello stack di quanto sia allocato per contenerli. Questi dati in eccesso sovrascriveranno lo spazio di memoria adiacente, portando alla corruzione dei dati validi, alla interruzione del flusso di controllo e potenzialmente all'esecuzione di codice dannoso. Questo problema spesso si verifica a causa dell'uso di funzioni non sicure che non eseguono il controllo dei limiti sull'input.

Il problema principale di questa sovrascrittura √® che i puntatori **EIP** e **EBP** per tornare alla funzione precedente sono **memorizzati nello stack**. Pertanto, un attaccante sar√† in grado di sovrascrivere quelli e **controllare il flusso di esecuzione del programma**.

La vulnerabilit√† di solito si verifica perch√© una funzione **copia all'interno dello stack pi√π byte rispetto alla quantit√† allocata per essa**, quindi √® in grado di sovrascrivere altre parti dello stack.\
Alcune funzioni comuni vulnerabili a questo sono: `strcpy`, `strcat`, `sprintf`, `gets`, `fgets`...

Ad esempio, le seguenti funzioni potrebbero essere vulnerabili:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Trovare gli stack overflows

Il modo pi√π comune per trovare gli stack overflows √® inserire un input molto grande di `A` (ad esempio `python3 -c 'print("A"*1000)'`) e aspettarsi un `Segmentation Fault` che indica che l'**indirizzo `0x41414141` √® stato tentato di essere accesso**.

Inoltre, una volta che hai individuato che c'√® una vulnerabilit√† di Stack Overflow, dovrai trovare l'offset fino a quando √® possibile **sovrascrivere il puntatore EIP**, per questo di solito si utilizza una **sequenza De Bruijn**. Che per un dato alfabeto di dimensione _k_ e sottosequenze di lunghezza _n_ √® una **sequenza ciclica in cui ogni possibile sottosequenza di lunghezza **_**n**_** appare esattamente una volta** come sottosequenza contigua.

In questo modo, anzich√© dover capire manualmente quale offset sta sovrascrivendo l'EIP, √® possibile utilizzare come padding una di queste sequenze e quindi trovare l'offset dei byte che hanno finito per sovrascriverlo.

√à possibile utilizzare **pwntools** per questo:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
o **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Sfruttare gli stack overflow

Durante un overflow (supponendo che la dimensione dell'overflow sia abbastanza grande) sarai in grado di sovrascrivere i valori di altre variabili all'interno dello stack fino a raggiungere EBP ed EIP (o anche di pi√π).\
Il modo pi√π comune per sfruttare questo tipo di vulnerabilit√† √® **modificare il puntatore EIP** in modo che quando la funzione termina il **controllo del flusso sar√† reindirizzato ovunque l'utente abbia specificato** in questo puntatore.

Tuttavia, in altri scenari forse **sovrascrivere alcuni valori delle variabili nello stack** potrebbe essere sufficiente per lo sfruttamento (come nelle sfide CTF facili).

### Ret2win

In questo tipo di sfide CTF, c'√® una **funzione** **all'interno** del binario che **non viene mai chiamata** e che **devi chiamare per vincere**. Per queste sfide devi solo trovare l'**offset per sovrascrivere l'EIP** e **trovare l'indirizzo della funzione** da chiamare (di solito [**ASLR**](../common-binary-protections/aslr.md) sarebbe disabilitato) in modo che quando la funzione vulnerabile ritorna, la funzione nascosta verr√† chiamata:

{% content-ref url="ret2win.md" %}
[ret2win.md](ret2win.md)
{% endcontent-ref %}

### Shellcode nello stack

In questo scenario l'attaccante potrebbe inserire uno shellcode nello stack e sfruttare l'EIP controllato per andare allo shellcode ed eseguire il codice dell'attaccante:

{% content-ref url="stack-shellcode.md" %}
[stack-shellcode.md](stack-shellcode.md)
{% endcontent-ref %}

## ROP

Questa tecnica √® il framework fondamentale per aggirare la principale protezione della tecnica precedente: **Nessuno stack eseguibile**. E consente di eseguire diverse altre tecniche (ret2lib, ret2syscall...) che finiranno per eseguire comandi arbitrari sfruttando istruzioni esistenti nel binario:

{% content-ref url="rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](rop-return-oriented-programing.md)
{% endcontent-ref %}

## Tipi di protezioni

Ci sono diverse protezioni che cercano di prevenire lo sfruttamento delle vulnerabilit√†, controllale in:

{% content-ref url="../common-binary-protections/" %}
[common-binary-protections](../common-binary-protections/)
{% endcontent-ref %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
