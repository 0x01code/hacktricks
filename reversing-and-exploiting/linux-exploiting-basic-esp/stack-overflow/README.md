# Stack Overflow

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Stack Overflow Nedir

Bir **stack overflow** (yığın taşması), bir programın yığına ayrılan kapasiteden daha fazla veri yazdığında meydana gelen bir güvenlik açığıdır. Bu fazla veri, **bitişik bellek alanını üzerine yazacak**, geçerli verilerin bozulmasına, kontrol akışının bozulmasına ve potansiyel olarak kötü amaçlı kodun yürütülmesine neden olacaktır. Bu sorun genellikle girişlerde sınırların kontrol edilmediği güvensiz işlevlerin kullanılmasından kaynaklanır.

Bu üzerine yazma sorununun ana nedeni, **EIP** ve **EBP** işaretçilerinin önceki işleve geri dönmesi için **yığında saklanmasıdır**. Bu nedenle, bir saldırgan bunları üzerine yazabilir ve programın **yürütme akışını kontrol edebilir**.

Bu zafiyet genellikle bir işlevin **yığına ayrılan miktarından daha fazla bayt kopyaladığı** için ortaya çıkar, bu nedenle yığının diğer kısımlarını üzerine yazabilir.\
Buna duyarlı olan bazı yaygın işlevler: `strcpy`, `strcat`, `sprintf`, `gets`, `fgets`...

Örneğin, aşağıdaki işlevler duyarlı olabilir:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Stack Taşmalarını Bulma

Stack taşmalarını bulmanın en yaygın yolu, çok büyük bir `A` girdisi vermek (örneğin `python3 -c 'print("A"*1000)'`) ve **`0x41414141` adresine erişilmeye çalışıldığını gösteren bir `Segmentation Fault`** beklemektir.

Dahası, Stack Overflow zafiyetini bulduktan sonra genellikle **EIP işaretçisini üzerine yazabileceğiniz ofseti bulmanız gerekecektir**, bunun için genellikle bir **De Bruijn dizisi** kullanılır. Bu, _k_ boyutunda bir alfabeye ve _n_ uzunluğundaki alt dizilere sahip bir dizi olup, **her olası _n_ uzunluğundaki alt dizinin tam olarak bir kez göründüğü döngüsel bir dizidir**.

Bu şekilde, EIP'nin elle hangi ofsetin üzerine yazıldığını bulmak yerine, bu dizilerden birini dolgu olarak kullanmak ve ardından üzerine yazmayı bitiren baytların ofsetini bulmak mümkündür.

Bunun için genellikle **pwntools** kullanılabilir:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
veya **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Stack Overflow Sömürme

Taşma sırasında (taşma boyutu yeterince büyükse) yığın içindeki diğer değişkenlerin değerlerini EBP ve EIP'ye (veya daha fazlasına) ulaşana kadar üzerine yazabilirsiniz.\
Bu tür bir zafiyeti istismar etmenin en yaygın yolu, **EIP işaretçisini değiştirerek** işlev sona erdiğinde **kontrol akışının kullanıcının belirttiği yere yönlendirilmesini sağlamaktır**.

Ancak, diğer senaryolarda belki sadece **yığında bazı değişken değerlerini üzerine yazmak** zafiyetin istismarı için yeterli olabilir (kolay CTF zorluklarında olduğu gibi).

### Ret2win

Bu tür CTF zorluklarında, **asla çağrılmayan** ve **kazanmak için çağrılması gereken** bir **işlev** **binary içinde** bulunur. Bu zorluklarda sadece **EIP'yi üzerine yazmak için ofseti bulmanız** ve **çağrılacak işlevin adresini bulmanız** yeterlidir (genellikle [**ASLR**](../common-binary-protections/aslr.md) devre dışı bırakılmış olacaktır), bu sayede zafiyetli işlev döndüğünde gizli işlev çağrılacaktır:

{% content-ref url="ret2win.md" %}
[ret2win.md](ret2win.md)
{% endcontent-ref %}

### Ret2Shellcode

## Koruma Türleri

{% content-ref url="../common-binary-protections/" %}
[common-binary-protections](../common-binary-protections/)
{% endcontent-ref %}
