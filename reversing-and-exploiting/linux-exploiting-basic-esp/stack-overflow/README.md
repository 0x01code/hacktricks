# Kujaa Kwa Stak

<details>

<summary><strong>Jifunze kuhusu kuhack AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) za kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kuhack kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Ni Nini Kujaa Kwa Stak

**Kujaa kwa stak** ni udhaifu unapotokea programu inapoandika data zaidi kwenye stak kuliko ilivyotengewa kuhifadhi. Data hii ya ziada ita **futa nafasi ya kumbukumbu inayopakana**, ikisababisha uharibifu wa data halali, kuvuruga mtiririko wa udhibiti, na kwa uwezekano utekelezaji wa msimbo wa kudhuru. Tatizo hili mara nyingi hutokea kutokana na matumizi ya kazi zisizo salama ambazo hazifanyi ukaguzi wa mipaka kwenye data zinazoingia.

Tatizo kuu la kufuta huku ni kwamba viashiria vya **EIP** na **EBP** vya kurudi kwenye kazi iliyotangulia **huhifadhiwa kwenye stak**. Hivyo, mshambuliaji ataweza kufuta viashiria hivyo na **kudhibiti mtiririko wa utekelezaji wa programu**.

Udhaifu huu kawaida hutokea kwa sababu kazi **inafanya nakala ndani ya stak ya herufi zaidi kuliko kiasi kilichotengwa kwa hiyo**, hivyo kuweza kufuta sehemu nyingine za stak.\
Baadhi ya kazi za kawaida zinazoweza kuwa na udhaifu huu ni: `strcpy`, `strcat`, `sprintf`, `gets`, `fgets`...

Kwa mfano, kazi zifuatazo zinaweza kuwa na udhaifu:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Kupata Mafuriko ya Stack

Njia ya kawaida ya kupata mafuriko ya stack ni kutoa kuingia kubwa sana ya `A`s (k.m. `python3 -c 'print("A"*1000)'`) na kutarajia `Segmentation Fault` inayoashiria kwamba **anwani `0x41414141` ilijaribiwa kupatikana**.

Zaidi ya hayo, mara baada ya kugundua kuwepo kwa udhaifu wa Mafuriko ya Stack, utahitaji kupata ofseti mpaka iwezekane **kubadilisha kidude cha EIP**, kwa hili kawaida hutumika **De Bruijn sequence.** Ambayo kwa alfabeti iliyopewa ya ukubwa _k_ na subsekwensi za urefu _n_ ni **mfululizo wa mzunguko ambapo kila subsekwensi inayowezekana ya urefu **_**n**_** inaonekana mara moja tu** kama subsekwensi inayofuatana.

Hivyo, badala ya kuhitaji kufikiria ni ofseti ipi inayobadilisha EIP kwa mkono, ni rahisi kutumia mfuatano mmoja wa hizi na kisha kupata ofseti ya byte ambayo mwishowe ilibadilisha hiyo.

Inawezekana kutumia **pwntools** kwa hili:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
au **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Kudukua Mabaki ya Stack

Wakati wa kudukua (ukiwa na ukubwa wa kutosha), utaweza kubadilisha thamani za mengine variables ndani ya stack hadi kufikia EBP na EIP (au zaidi).\
Njia ya kawaida ya kutumia udhaifu huu ni kwa **kubadilisha kiongozi cha EIP** hivyo wakati wa kumaliza kazi, **mtiririko wa udhibiti utaelekezwa popote mtumiaji alipoamua** kwenye kiongozi huu.

Hata hivyo, katika mazingira mengine labda **kubadilisha thamani za baadhi ya variables kwenye stack** inaweza kuwa ya kutosha kwa udanganyifu (kama katika changamoto rahisi za CTF).

### Ret2win

Katika aina hii ya changamoto za CTF, kuna **kazi** **ndani** ya binary ambayo **haitaitwa kamwe** na **unahitaji kuita ili ushinde**. Kwa changamoto hizi unahitaji tu kupata **kielezo cha kubadilisha EIP** na **kupata anwani ya kazi** ya kuita (kawaida [**ASLR**](../common-binary-protections/aslr.md) itakuwa imelemazwa) hivyo wakati kazi yenye udhaifu inaporudi, kazi iliyofichwa itaitwa:

{% content-ref url="ret2win.md" %}
[ret2win.md](ret2win.md)
{% endcontent-ref %}

### Ret2Shellcode

## Aina za ulinzi

{% content-ref url="../common-binary-protections/" %}
[common-binary-protections](../common-binary-protections/)
{% endcontent-ref %}
