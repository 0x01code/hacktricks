# Estouro de Pilha

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## O que √© um Estouro de Pilha

Um **estouro de pilha** √© uma vulnerabilidade que ocorre quando um programa escreve mais dados na pilha do que √© alocado para segurar. Esses dados em excesso ir√£o **sobrescrever o espa√ßo de mem√≥ria adjacente**, levando √† corrup√ß√£o de dados v√°lidos, interrup√ß√£o do fluxo de controle e potencialmente √† execu√ß√£o de c√≥digo malicioso. Esse problema frequentemente surge devido ao uso de fun√ß√µes inseguras que n√£o realizam verifica√ß√£o de limites na entrada.

O principal problema dessa sobrescrita √© que os ponteiros **EIP** e **EBP** para retornar √† fun√ß√£o anterior s√£o **armazenados na pilha**. Portanto, um atacante poder√° sobrescrev√™-los e **controlar o fluxo de execu√ß√£o do programa**.

A vulnerabilidade geralmente surge porque uma fun√ß√£o **copia mais bytes para dentro da pilha do que a quantidade alocada para ela**, sendo capaz de sobrescrever outras partes da pilha.\
Algumas fun√ß√µes comuns vulner√°veis a isso s√£o: `strcpy`, `strcat`, `sprintf`, `gets`, `fgets`...

Por exemplo, as seguintes fun√ß√µes poderiam ser vulner√°veis:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Encontrando Estouros de Pilha

A maneira mais comum de encontrar estouros de pilha √© fornecer uma entrada muito grande de `A`s (por exemplo, `python3 -c 'print("A"*1000)'`) e esperar um `Segmentation Fault` indicando que o **endere√ßo `0x41414141` foi tentado ser acessado**.

Al√©m disso, uma vez que voc√™ descobrir que h√° uma vulnerabilidade de Estouro de Pilha, ser√° necess√°rio encontrar o deslocamento at√© ser poss√≠vel **sobrescrever o ponteiro EIP**, para isso geralmente √© usado uma **sequ√™ncia de De Bruijn**. Que para um dado alfabeto de tamanho _k_ e subsequ√™ncias de comprimento _n_ √© uma **sequ√™ncia c√≠clica na qual toda subsequ√™ncia poss√≠vel de comprimento **_**n**_** aparece exatamente uma vez** como uma subsequ√™ncia cont√≠gua.

Dessa forma, em vez de precisar descobrir manualmente qual deslocamento est√° sobrescrevendo o EIP, √© poss√≠vel usar uma dessas sequ√™ncias como preenchimento e depois encontrar o deslocamento dos bytes que acabaram sobrescrevendo-o.

√â poss√≠vel usar o **pwntools** para isso:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
ou **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Explorando Estouros de Pilha

Durante um estouro de pilha (supondo que o tamanho do estouro seja grande o suficiente), voc√™ poder√° sobrescrever valores de outras vari√°veis dentro da pilha at√© atingir o EBP e EIP (ou at√© mais).\
A maneira mais comum de abusar desse tipo de vulnerabilidade √© **modificando o ponteiro EIP** para que, quando a fun√ß√£o terminar, o **fluxo de controle seja redirecionado para onde o usu√°rio especificou** nesse ponteiro.

No entanto, em outros cen√°rios, talvez apenas **sobrescrever alguns valores de vari√°veis na pilha** seja suficiente para a explora√ß√£o (como em desafios CTF f√°ceis).

### Ret2win

Nesse tipo de desafios CTF, h√° uma **fun√ß√£o** **dentro** do bin√°rio que **nunca √© chamada** e que **voc√™ precisa chamar para vencer**. Para esses desafios, voc√™ s√≥ precisa encontrar o **deslocamento para sobrescrever o EIP** e **encontrar o endere√ßo da fun√ß√£o** a ser chamada (geralmente [**ASLR**](../common-binary-protections/aslr.md) estaria desativado) para que, quando a fun√ß√£o vulner√°vel retornar, a fun√ß√£o oculta ser√° chamada:

{% content-ref url="ret2win.md" %}
[ret2win.md](ret2win.md)
{% endcontent-ref %}

### Shellcode na Pilha

Nesse cen√°rio, o atacante poderia colocar um shellcode na pilha e abusar do EIP controlado para ir para o shellcode e executar o c√≥digo do atacante:

{% content-ref url="stack-shellcode.md" %}
[stack-shellcode.md](stack-shellcode.md)
{% endcontent-ref %}

## ROP

Essa t√©cnica √© o framework fundamental para contornar a principal prote√ß√£o da t√©cnica anterior: **Pilha n√£o execut√°vel**. E permite realizar v√°rias outras t√©cnicas (ret2lib, ret2syscall...) que acabar√£o executando comandos arbitr√°rios abusando de instru√ß√µes existentes no bin√°rio:

{% content-ref url="rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](rop-return-oriented-programing.md)
{% endcontent-ref %}

## Tipos de prote√ß√µes

Existem v√°rias prote√ß√µes que tentam evitar a explora√ß√£o de vulnerabilidades, verifique-as em:

{% content-ref url="../common-binary-protections/" %}
[common-binary-protections](../common-binary-protections/)
{% endcontent-ref %}

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
