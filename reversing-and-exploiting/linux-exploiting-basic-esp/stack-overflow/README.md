# 스택 오버플로우

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로부터 영웅까지 AWS 해킹 배우기**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **해킹 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) 깃허브 저장소에 제출하세요.

</details>

## 스택 오버플로우란

**스택 오버플로우**는 프로그램이 할당된 스택에 저장할 수 있는 데이터보다 더 많은 데이터를 쓸 때 발생하는 취약점입니다. 이러한 초과 데이터는 **인접한 메모리 공간을 덮어쓰게** 하여 유효한 데이터의 손상, 제어 흐름의 중단 및 악의적 코드 실행으로 이어질 수 있습니다. 이 문제는 종종 입력에 대한 경계 확인을 수행하지 않는 안전하지 않은 함수의 사용으로 인해 발생합니다.

이 덮어쓰기의 주요 문제는 **EIP** 및 **EBP** 포인터가 **스택에 저장**되어 이전 함수로 돌아가는 것을 제어할 수 있게 되기 때문입니다. 따라서 공격자는 이를 덮어쓰고 **프로그램의 실행 흐름을 제어**할 수 있습니다.

이 취약점은 일반적으로 함수가 **할당된 양보다 더 많은 바이트를 스택에 복사**하여 발생하므로 스택의 다른 부분을 덮어쓸 수 있습니다.\
이에 취약한 일부 함수는 `strcpy`, `strcat`, `sprintf`, `gets`, `fgets` 등이 있습니다...

예를 들어, 다음 함수들이 취약할 수 있습니다:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### 스택 오버플로우 찾기

스택 오버플로우를 찾는 가장 일반적인 방법은 매우 큰 `A` 입력을 제공하는 것입니다 (예: `python3 -c 'print("A"*1000)'`) 그리고 **주소 `0x41414141`에 액세스를 시도했다는** `Segmentation Fault`가 발생하는 것을 기대하는 것입니다.

또한, 스택 오버플로우 취약점을 발견한 후에는 **EIP 포인터를 덮어쓸 수 있는 오프셋을 찾아야** 합니다. 이를 위해 일반적으로 **De Bruijn sequence**가 사용됩니다. 이는 크기가 _k_인 알파벳과 길이가 _n_인 부분 시퀀스에 대해 **모든 가능한 길이가 **_**n**_**인 부분 시퀀스가 정확히 한 번씩 나타나는 순환 시퀀스**입니다.

이렇게 하면 EIP를 덮어쓰는 오프셋을 수동으로 찾아야 하는 대신, 이러한 시퀀스 중 하나를 패딩으로 사용하고 그것을 덮어쓰는 바이트의 오프셋을 찾을 수 있습니다.

이를 위해 **pwntools**를 사용할 수 있습니다:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
또는 **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## 스택 오버플로우 공격

오버플로우 발생 시 (오버플로우 크기가 충분히 큰 경우) 스택 내 다른 변수들의 값을 덮어쓸 수 있습니다. EBP 및 EIP에 도달할 때까지 (또는 그 이상) 다른 변수들의 값을 덮어쓸 수 있습니다.\
이 유형의 취약점을 악용하는 가장 일반적인 방법은 **EIP 포인터를 수정**하여 함수가 종료될 때 **사용자가 지정한 위치로 제어 흐름이 리디렉션**되도록 하는 것입니다.

그러나 다른 시나리오에서는 also **스택 내 일부 변수 값만 덮어쓰는 것**이 취약점 악용에 충분할 수도 있습니다 (예: 쉬운 CTF 도전 과제).

### Ret2win

이 유형의 CTF 도전 과제에서는 **바이너리 내부에 호출되지 않는 함수**가 있으며, **이 함수를 호출하여 이기기 위해 호출해야 합니다**. 이러한 도전 과제에서는 **EIP를 덮어쓸 오프셋을 찾고** 호출할 함수의 주소를 찾아야 합니다 (보통 [**ASLR**](../common-binary-protections/aslr.md)이 비활성화될 것입니다). 따라서 취약한 함수가 반환될 때 숨겨진 함수가 호출됩니다:

{% content-ref url="ret2win.md" %}
[ret2win.md](ret2win.md)
{% endcontent-ref %}

### 스택 쉘코드

이 시나리오에서 공격자는 스택에 쉘코드를 배치하고 제어 가능한 EIP를 이용하여 쉘코드로 이동하고 공격자의 코드를 실행할 수 있습니다:

{% content-ref url="stack-shellcode.md" %}
[stack-shellcode.md](stack-shellcode.md)
{% endcontent-ref %}

## ROP

이 기술은 이전 기술의 주요 보호 기능인 **실행 불가능한 스택**을 우회하는 기본 프레임워크입니다. 이를 통해 바이너리 내 기존 명령어를 악용하여 임의의 명령을 실행하는 여러 기술 (ret2lib, ret2syscall 등)을 수행할 수 있습니다:

{% content-ref url="rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](rop-return-oriented-programing.md)
{% endcontent-ref %}

## 보호 기능 유형

취약점 악용을 방지하려는 여러 보호 기능이 있습니다. 이를 확인하려면 다음을 참조하십시오:

{% content-ref url="../common-binary-protections/" %}
[common-binary-protections](../common-binary-protections/)
{% endcontent-ref %}
