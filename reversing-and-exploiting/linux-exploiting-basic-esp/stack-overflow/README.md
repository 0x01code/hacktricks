# Stack Overflow

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Stack Overflow Nedir

Bir **yığın taşması (stack overflow)**, bir programın yığına ayrılan kapasiteden daha fazla veri yazdığında meydana gelen bir güvenlik açığıdır. Bu fazla veri, **bitişik bellek alanını üzerine yazacak**, geçerli verilerin bozulmasına, kontrol akışının bozulmasına ve potansiyel olarak kötü amaçlı kodun yürütülmesine neden olacaktır. Bu sorun genellikle, giriş üzerinde sınırların kontrolünü yapmayan güvensiz işlevlerin kullanılmasından kaynaklanır.

Bu üzerine yazma sorununun ana nedeni, **EIP** ve **EBP** işaretçilerinin önceki işleve geri dönmesi için **yığında depolanmasıdır**. Bu nedenle, bir saldırgan bunları üzerine yazabilir ve programın **yürütme akışını kontrol edebilir**.

Bu zafiyet genellikle bir işlevin **yığına ayrılan miktarın üzerinde bayt kopyaladığı** durumlarda ortaya çıkar, bu nedenle yığının diğer kısımlarını üzerine yazabilir.\
Buna duyarlı olan bazı yaygın işlevler: `strcpy`, `strcat`, `sprintf`, `gets`, `fgets`...

Örneğin, aşağıdaki işlevler duyarlı olabilir:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Stack Taşmalarını Bulma

Stack taşmalarını bulmanın en yaygın yolu, çok büyük bir `A` girdisi vermek (örneğin `python3 -c 'print("A"*1000)'`) ve **`0x41414141` adresine erişilmeye çalışıldığını gösteren bir `Segmentation Fault`** beklemektir.

Dahası, Stack Overflow zafiyetini bulduktan sonra genellikle **EIP işaretçisini üzerine yazabileceğiniz ofseti bulmanız gerekecektir**, bunun için genellikle bir **De Bruijn dizisi** kullanılır. Bu, _k_ boyutunda bir alfabeye ve _n_ uzunluğundaki alt dizilere sahip bir dizi olup, **her olası _n_ uzunluğundaki alt dizinin tam olarak bir kez göründüğü döngüsel bir dizidir**.

Bu şekilde, EIP'nin elle hangi ofsetin üzerine yazıldığını bulmak yerine, bu dizilerden birini dolgu olarak kullanmak ve ardından üzerine yazmayı bitiren baytların ofsetini bulmak mümkündür.

Bunun için genellikle **pwntools** kullanılabilir:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
veya **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Stack Overflow Sömürme

Taşma sırasında (taşma boyutu yeterince büyükse) EBP ve EIP'ye (hatta daha fazlasına) ulaşana kadar yığın içindeki diğer değişkenlerin değerlerini üzerine yazabilirsiniz.\
Bu tür bir zafiyeti istismar etmenin en yaygın yolu, **EIP işaretçisini değiştirerek** işlev sona erdiğinde **kontrol akışının kullanıcının belirttiği yere yönlendirilmesidir**.

Ancak, diğer senaryolarda belki sadece yığında bazı değişken değerlerini üzerine yazmak, sömürü için yeterli olabilir (kolay CTF zorluklarında olduğu gibi).

### Ret2win

Bu tür CTF zorluklarında, **asla çağrılmayan** bir **işlev** **içinde** bulunan ve **kazanmak için çağrılması gereken bir işlev** bulunmaktadır. Bu zorluklarda sadece **EIP'yi üzerine yazmak için ofseti bulmanız** ve çağrılacak işlevin adresini bulmanız yeterlidir (genellikle [**ASLR**](../common-binary-protections-and-bypasses/aslr/) devre dışı bırakılmış olacaktır), bu sayede zafiyetli işlev döndüğünde gizli işlev çağrılacaktır:

{% content-ref url="ret2win.md" %}
[ret2win.md](ret2win.md)
{% endcontent-ref %}

### Yığın Kabuk Kodu

Bu senaryoda saldırgan, yığına bir kabuk kodu yerleştirebilir ve kontrol edilen EIP'yi kabuk koduna gitmek ve saldırganın kodunu yürütmek için kötüye kullanabilir:

{% content-ref url="stack-shellcode.md" %}
[stack-shellcode.md](stack-shellcode.md)
{% endcontent-ref %}

## ROP

Bu teknik, önceki tekniğe başlıca koruma olan **Yürütülebilir Yığın Yok**'u atlatmak için temel çerçevedir. Ve ikili dosyadaki mevcut talimatları kötüye kullanarak keyfi komutları yürütmeyi sağlayan diğer teknikleri gerçekleştirmenize olanak tanır (ret2lib, ret2syscall...):

{% content-ref url="rop-return-oriented-programing.md" %}
[rop-return-oriented-programing.md](rop-return-oriented-programing.md)
{% endcontent-ref %}

## Koruma Türleri

Zafiyetlerin istismarını önlemeye çalışan çeşitli korumalar bulunmaktadır, bunları kontrol edin:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}
