# スタックオーバーフロー

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じてゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つけてください
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングトリックを共有するために、** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

## スタックオーバーフローとは

**スタックオーバーフロー**は、プログラムがスタックに割り当てられたデータよりも多くのデータを書き込むと発生する脆弱性です。この余分なデータは、**隣接するメモリ領域を上書き**し、有効なデータの破損、制御フローの混乱、および悪意のあるコードの実行を引き起こす可能性があります。この問題は、入力に対して境界チェックを実行しない安全でない関数の使用によってしばしば発生します。

この上書きの主な問題は、**EIP**および**EBP**ポインターが前の関数に戻るために**スタックに格納されている**ことです。したがって、攻撃者はこれらを上書きして**プログラムの実行フローを制御**できます。

この脆弱性は通常、関数が**割り当てられた量よりも多くのバイトをスタックにコピー**するために発生します。そのため、スタックの他の部分を上書きできます。\
この問題に対して脆弱な一般的な関数には、`strcpy`、`strcat`、`sprintf`、`gets`、`fgets`などがあります...

たとえば、次の関数は脆弱性の可能性があります:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### スタックオーバーフローの見つけ方

スタックオーバーフローを見つける最も一般的な方法は、非常に大きな`A`の入力を与えることです（例：`python3 -c 'print("A"*1000)'`）そして、**アドレス`0x41414141`にアクセスしようとしました**と示す`Segmentation Fault`が予想されます。

さらに、スタックオーバーフローの脆弱性が見つかったら、**EIPポインタを上書きできるまでのオフセットを見つける必要があります**。これには通常、**De Bruijn sequence**が使用されます。これは、サイズが_k_で長さが_n_のサブシーケンスを持つアルファベットが与えられた場合、**すべての可能な長さが**_**n**_**のサブシーケンスがちょうど一度だけ現れる**巡回シーケンスです。

これにより、EIPを上書きしているオフセットを手動で特定する必要がなくなり、これらのシーケンスの1つをパディングとして使用し、それを上書きしたバイトのオフセットを見つけることができます。

これには**pwntools**を使用することができます：
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
または **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## スタックオーバーフローの悪用

オーバーフロー中（オーバーフローサイズが十分に大きいと仮定）、スタック内の他の変数の値を上書きできるようになり、EBPとEIP（またはそれ以上）に到達するまで上書きできます。\
この種の脆弱性を悪用する最も一般的な方法は、**EIPポインタを変更**して、関数が終了するときに**ユーザーが指定した場所に制御フローがリダイレクト**されるようにすることです。

ただし、他のシナリオでは、**スタック内のいくつかの変数の値を上書き**するだけで、（簡単なCTFチャレンジのように）悪用に十分な場合もあります。

### Ret2win

この種のCTFチャレンジでは、バイナリ内に**呼び出されない関数**があり、**それを呼び出して勝利する必要がある**。これらのチャレンジでは、**EIPを上書きするオフセットを見つけ**、呼び出す関数のアドレスを見つけるだけで十分です（通常、[**ASLR**](../common-binary-protections/aslr.md)は無効になっている可能性があります）。脆弱な関数が戻ると、隠された関数が呼び出されます：

{% content-ref url="ret2win.md" %}
[ret2win.md](ret2win.md)
{% endcontent-ref %}

### Ret2Shellcode

## 保護の種類

{% content-ref url="../common-binary-protections/" %}
[common-binary-protections](../common-binary-protections/)
{% endcontent-ref %}
