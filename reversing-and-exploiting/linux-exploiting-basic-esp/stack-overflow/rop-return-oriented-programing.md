# ROP - Return Oriented Programing

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Podstawowe informacje**

**Return-Oriented Programming (ROP)** to zaawansowana technika eksploatacji używana do obejścia zabezpieczeń takich jak **No-Execute (NX)** lub **Data Execution Prevention (DEP)**. Zamiast wstrzykiwać i wykonywać kod powłoki, atakujący wykorzystuje fragmenty kodu już obecne w binarnym pliku lub w załadowanych bibliotekach, znanych jako **"gadżety"**. Każdy gadżet zazwyczaj kończy się instrukcją `ret` i wykonuje małą operację, taką jak przenoszenie danych między rejestrami lub wykonywanie operacji arytmetycznych. Łącząc te gadżety, atakujący może skonstruować ładunek w celu wykonania dowolnych operacji, skutecznie omijając zabezpieczenia NX/DEP.

### Konwencje wywoływania

Zrozumienie **konwencji wywoływania** jest kluczowe dla skutecznego tworzenia łańcuchów ROP, zwłaszcza podczas wywoływania funkcji lub manipulowania danymi:

**x86 (32-bit)**

* **cdecl**: Wywołujący czyści stos. Argumenty funkcji są przekazywane na stosie w odwrotnej kolejności (od prawej do lewej). **Argumenty są przekazywane na stosie od prawej do lewej.**
* **stdcall**: Podobnie jak cdecl, ale wywoływany jest odpowiedzialny za czyszczenie stosu.

**x64 (64-bit)**

* Używa konwencji wywoływania **System V AMD64 ABI** w systemach przypominających Unix, gdzie **pierwsze sześć argumentów całkowitych lub wskaźników jest przekazywane w rejestrach `RDI`, `RSI`, `RDX`, `RCX`, `R8` i `R9`**. Dodatkowe argumenty są przekazywane na stosie. Wartość zwracana jest umieszczana w `RAX`.
* Konwencja wywoływania **Windows x64** używa `RCX`, `RDX`, `R8` i `R9` dla pierwszych czterech argumentów całkowitych lub wskaźników, z dodatkowymi argumentami przekazywanymi na stosie. Wartość zwracana jest umieszczana w `RAX`.
* **Rejestry**: 64-bitowe rejestry obejmują `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` oraz `R8` do `R15`.

{% hint style="danger" %}
Z tych konwencji wywoływania można zauważyć, że w **32 bitach argumenty** funkcji są **przekazywane przez stos**, podczas gdy w **x64** są **umieszczane w określonych rejestrach**.
{% endhint %}

### Jak działa ROP

1. **Przechwycenie przepływu sterowania**: Najpierw atakujący musi przejąć kontrolę nad przepływem programu, zazwyczaj wykorzystując przepełnienie bufora, aby nadpisać zapisany adres powrotu na stosie.
2. **Łańcuchowanie gadżetów**: Atakujący następnie ostrożnie wybiera i łączy gadżety, aby wykonać pożądane akcje. Może to obejmować ustawienie argumentów dla wywołania funkcji, wywołanie funkcji (np. `system("/bin/sh")`) i obsługę koniecznego sprzątania lub dodatkowych operacji.
3. **Wykonanie ładunku**: Gdy podatna funkcja zwraca, zamiast powrócić do prawidłowej lokalizacji, zaczyna wykonywać łańcuch gadżetów.

### Łańcuch ROP w x86

Rozważmy hipotetyczny scenariusz, w którym chcemy wywołać `system("/bin/sh")` przy użyciu ROP w 32-bitowym binarnym pliku:

1. **Znajdź Gadżety**: Załóżmy, że znaleźliśmy następujące gadżety w binarnym pliku lub załadowanych bibliotekach:
* `pop eax; ret`: Zdejmuje wartość ze stosu do `EAX` i zwraca.
* `pop ebx; ret`: Zdejmuje wartość ze stosu do `EAX` i zwraca.
* `mov [ebx], eax; ret`: Przenosi wartość z `EAX` do lokalizacji wskazywanej przez `EBX`.
* Adres `system`.
2. **Przygotuj Łańcuch**: Musimy przygotować stos, który wygląda następująco:
* Adres gadżetu ustawiającego `EBX`.
* Adres gadżetu `pop eax; ret`.
* Adres łańcucha `"/bin/sh"` w pamięci (lub gdzie planujemy go zapisać).
* Adres gadżetu `mov [ebx], eax; ret`, aby przenieść `"/bin/sh"` do lokalizacji wskazywanej przez `EBX`.
* Adres funkcji `system`, gdzie `EBX` wskazuje na nasz łańcuch.
3. **Wykonanie**: Gdy podatna funkcja zwraca, zaczyna wykonywać nasz łańcuch gadżetów, w końcu wywołując `system("/bin/sh")` i otwierając powłokę.

### ROP w x64

Rozważmy hipotetyczny scenariusz, w którym chcesz wywołać `execve("/bin/sh", NULL, NULL)` na systemie x64, korzystając z konwencji wywoływania System V AMD64 ABI:

1. **Znajdowanie Gadżetów**: Najpierw musisz znaleźć gadżety, które umożliwią kontrolę nad rejestrami `RDI`, `RSI` i `RDX`, ponieważ będą one przechowywać argumenty dla `execve`.
2. **Konstrukcja Łańcucha**:
* **Ustaw `RDI`, aby wskazywał na łańcuch `"/bin/sh"`**: Zazwyczaj jest to wykonywane za pomocą gadżetu `pop RDI; ret`, a następnie adresu łańcucha (który może być umieszczony w ładunku lub znaleziony w pamięci).
* **Wyzeruj `RSI` i `RDX`**: Ponieważ drugi i trzeci argument dla `execve` to `NULL`, potrzebujesz gadżetów do wyzerowania tych rejestrów, takich jak `xor RSI, RSI; ret` i `xor RDX, RDX; ret`.
* **Wywołaj `execve`**: W końcu potrzebny jest gadżet, który przeskakuje do `execve` (lub pośrednio ją wywołuje).
3. **Wykonanie Ładunku**: Po skonstruowaniu i wysłaniu tego ładunku do podatnej aplikacji, łańcuch ROP wykonuje się, uruchamiając powłokę.

Ponieważ x64 używa rejestrów dla kilku pierwszych argumentów, często wymaga mniej gadżetów niż x86 do prostych wywołań funkcji, ale znalezienie i łączenie odpowiednich gadżetów może być bardziej skomplikowane ze względu na zwiększoną liczbę rejestrów i większą przestrzeń adresową. Zwiększona liczba rejestrów i większa przestrzeń adresowa w architekturze **x64** stanowią zarówno szanse, jak i wyzwania dla rozwoju eksploatacji, zwłaszcza w kontekście Return-Oriented Programming (ROP).

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
