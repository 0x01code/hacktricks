# ROP - Programación Orientada a Retornos

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Red Team de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Información Básica**

**La Programación Orientada a Retornos (ROP)** es una técnica avanzada de explotación utilizada para evadir medidas de seguridad como **No Ejecutar (NX)** o **Prevención de Ejecución de Datos (DEP)**. En lugar de inyectar y ejecutar shellcode, un atacante aprovecha fragmentos de código ya presentes en el binario o en bibliotecas cargadas, conocidos como **"gadgets"**. Cada gadget generalmente termina con una instrucción `ret` y realiza una pequeña operación, como mover datos entre registros o realizar operaciones aritméticas. Al encadenar estos gadgets, un atacante puede construir una carga útil para realizar operaciones arbitrarias, evitando efectivamente las protecciones NX/DEP.

### Convenciones de Llamada

Comprender las **convenciones de llamada** es crucial para construir cadenas ROP efectivas, especialmente al llamar funciones o manipular datos:

**x86 (32 bits)**

* **cdecl**: El llamador limpia la pila. Los argumentos de la función se empujan a la pila en orden inverso (de derecha a izquierda). **Los argumentos se empujan a la pila de derecha a izquierda**.
* **stdcall**: Similar a cdecl, pero el llamado es responsable de limpiar la pila.

**x64 (64 bits)**

* Utiliza la convención de llamada **System V AMD64 ABI** en sistemas tipo Unix, donde los **primeros seis argumentos enteros o de puntero se pasan en los registros `RDI`, `RSI`, `RDX`, `RCX`, `R8` y `R9`**. Los argumentos adicionales se pasan en la pila. El valor de retorno se coloca en `RAX`.
* La convención de llamada **Windows x64** utiliza `RCX`, `RDX`, `R8` y `R9` para los primeros cuatro argumentos enteros o de puntero, con argumentos adicionales pasados en la pila. El valor de retorno se coloca en `RAX`.
* **Registros**: Los registros de 64 bits incluyen `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` y `R8` a `R15`.

{% hint style="danger" %}
A partir de estas convenciones de llamada, es posible observar que en **32 bits los argumentos** de las funciones se **pasan a través de la pila** mientras que en **x64** se **colocan en registros específicos**.
{% endhint %}

### Cómo Funciona ROP

1. **Secuestro de Flujo de Control**: Primero, un atacante necesita secuestrar el flujo de control de un programa, típicamente explotando un desbordamiento de búfer para sobrescribir una dirección de retorno guardada en la pila.
2. **Encadenamiento de Gadgets**: Luego, el atacante selecciona cuidadosamente y encadena gadgets para realizar las acciones deseadas. Esto podría implicar configurar argumentos para una llamada de función, llamar a la función (por ejemplo, `system("/bin/sh")`), y manejar cualquier limpieza necesaria u operaciones adicionales.
3. **Ejecución de la Carga Útil**: Cuando la función vulnerable retorna, en lugar de regresar a una ubicación legítima, comienza a ejecutar la cadena de gadgets.

### Cadena ROP en x86

Consideremos un escenario hipotético donde queremos llamar a `system("/bin/sh")` usando ROP en un binario de 32 bits:

1. **Encontrar Gadgets**: Supongamos que hemos encontrado los siguientes gadgets en el binario o en bibliotecas cargadas:
* `pop eax; ret`: Desapila la parte superior de la pila en `EAX` y retorna.
* `pop ebx; ret`: Desapila la parte superior de la pila en `EAX` y retorna.
* `mov [ebx], eax; ret`: Mueve el valor en `EAX` a la ubicación apuntada por `EBX`.
* La dirección de `system`.
2. **Preparar la Cadena**: Necesitamos preparar una pila que se vea así:
* La dirección del gadget que establece `EBX`.
* La dirección del gadget `pop eax; ret`.
* La dirección de la cadena `"/bin/sh"` en memoria (o donde planeamos escribirla).
* La dirección del gadget `mov [ebx], eax; ret`, para mover `"/bin/sh"` a la ubicación apuntada por `EBX`.
* La dirección de la función `system`, con `EBX` apuntando a nuestra cadena.
3. **Ejecución**: Cuando la función vulnerable retorna, comienza a ejecutar nuestra cadena de gadgets, eventualmente llamando a `system("/bin/sh")` y abriendo una shell.

### ROP en x64

Considera un escenario hipotético donde deseas llamar a `execve("/bin/sh", NULL, NULL)` en un sistema x64 utilizando la convención de llamada System V AMD64 ABI:

1. **Encontrar Gadgets**: Primero necesitarías encontrar gadgets que te permitan controlar los registros `RDI`, `RSI` y `RDX`, ya que estos contendrán los argumentos para `execve`.
2. **Construcción de la Cadena**:
* **Establecer `RDI` para que apunte a la cadena `"/bin/sh"`**: Esto se hace típicamente con un gadget `pop RDI; ret` seguido por la dirección de la cadena (que puede necesitar ser colocada en la carga útil o encontrada en memoria).
* **Anular `RSI` y `RDX`**: Dado que los segundos y terceros argumentos para `execve` son `NULL`, necesitas gadgets para anular estos registros, como `xor RSI, RSI; ret` y `xor RDX, RDX; ret`.
* **Llamar a `execve`**: Finalmente, se requiere un gadget que salte a `execve` (o lo llame indirectamente).
3. **Ejecución de la Carga Útil**: Después de construir y enviar esta carga útil a una aplicación vulnerable, la cadena ROP se ejecuta, generando una shell.

Dado que x64 utiliza registros para los primeros argumentos, a menudo requiere menos gadgets que x86 para llamadas de función simples, pero encontrar y encadenar los gadgets correctos puede ser más complejo debido al mayor número de registros y al espacio de direcciones más grande. El mayor número de registros y el espacio de direcciones más grande en la arquitectura **x64** ofrecen tanto oportunidades como desafíos para el desarrollo de exploits, especialmente en el contexto de la Programación Orientada a Retornos (ROP).

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Red Team de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
