# ROP - Return Oriented Programing

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα αποθετήρια [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Βασικές Πληροφορίες**

**Η Προγραμματισμένη Επιστροφή (ROP)** είναι μια προηγμένη τεχνική εκμετάλλευσης που χρησιμοποιείται για να παρακάμψει μέτρα ασφαλείας όπως το **No-Execute (NX)** ή το **Data Execution Prevention (DEP)**. Αντί να εισάγει και να εκτελεί κώδικα κέλυφους, ένας επιτιθέμενος εκμεταλλεύεται κομμάτια κώδικα που υπάρχουν ήδη στο δυαδικό αρχείο ή στις φορτωμένες βιβλιοθήκες, γνωστά ως **"gadgets"**. Κάθε gadget τελειώνει συνήθως με μια εντολή `ret` και εκτελεί μια μικρή λειτουργία, όπως μεταφορά δεδομένων μεταξύ καταχωρητών ή εκτέλεση αριθμητικών πράξεων. Συνδέοντας αυτά τα gadgets μαζί, ένας επιτιθέμενος μπορεί να κατασκευάσει ένα φορτίο για να εκτελέσει αυθαίρετες λειτουργίες, παρακάμπτοντας αποτελεσματικά τις προστασίες NX/DEP.

### Συμβάσεις Κλήσης

Η κατανόηση των **συμβάσεων κλήσης** είναι κρίσιμη για την κατασκευή αποτελεσματικών αλυσιδωτών ROP, ειδικά όταν καλούνται συναρτήσεις ή όταν χειρίζονται δεδομένα:

**x86 (32-bit)**

* **cdecl**: Ο καλούντας καθαρίζει τη στοίβα. Τα ορίσματα συνάρτησης πιέζονται στη στοίβα με αντίστροφη σειρά (δεξιά προς αριστερά). **Τα ορίσματα πιέζονται στη στοίβα από δεξιά προς αριστερά.**
* **stdcall**: Παρόμοιο με το cdecl, αλλά ο καλούμενος είναι υπεύθυνος για τον καθαρισμό της στοίβας.

**x64 (64-bit)**

* Χρησιμοποιεί τη **σύμβαση κλήσης System V AMD64 ABI** σε συστήματα παρόμοια με Unix, όπου τα **πρώτα έξι ακέραια ή δείκτες ορίσματα περνούν στους καταχωρητές `RDI`, `RSI`, `RDX`, `RCX`, `R8` και `R9`**. Επιπλέον ορίσματα περνούν στη στοίβα. Η τιμή επιστροφής τοποθετείται στο `RAX`.
* Η σύμβαση κλήσης **Windows x64** χρησιμοποιεί τους `RCX`, `RDX`, `R8` και `R9` για τα πρώτα τέσσερα ακέραια ή δείκτες ορίσματα, με επιπλέον ορίσματα που περνούν στη στοίβα. Η τιμή επιστροφής τοποθετείται στο `RAX`.
* **Καταχωρητές**: Οι 64-bit καταχωρητές περιλαμβάνουν τους `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, και `R8` έως `R15`.

{% hint style="danger" %}
Από αυτές τις συμβάσεις κλήσης είναι δυνατόν να παρατηρήσουμε ότι στα **32 bits τα ορίσματα** στις συναρτήσεις **περνούν μέσω της στοίβας** ενώ στο **x64** τοποθετούνται **σε συγκεκριμένους καταχωρητές**.
{% endhint %}

### Πώς Λειτουργεί το ROP

1. **Απάτηση Ροής Ελέγχου**: Αρχικά, ένας επιτιθέμενος χρειάζεται να απατήσει τη ροή ελέγχου ενός προγράμματος, συνήθως εκμεταλλευόμενος ένα υπερχείλισμα buffer για να αντικαταστήσει μια αποθηκευμένη διεύθυνση επιστροφής στη στοίβα.
2. **Αλυσιδωτής Gadgets**: Έπειτα, ο επιτιθέμενος επιλέγει προσεκτικά και αλυσιδώνει gadgets για να εκτελέσει τις επιθυμητές ενέργειες. Αυτό θα μπορούσε να περιλαμβάνει την ρύθμιση ορισμάτων για μια κλήση συνάρτησης, την κλήση της συνάρτησης (π.χ., `system("/bin/sh")`), και τη χειρισμό οποιασδήποτε απαραίτητης καθαριότητας ή επιπλέον λειτουργιών.
3. **Εκτέλεση Φορτίου**: Όταν η ευάλωτη συνάρτηση επιστρέφει, αντί να επιστρέψει σε μια νόμιμη τοποθεσία, αρχίζει να εκτελεί την αλυσίδα gadgets.

### Αλυσίδα ROP σε x86

Ας υποθέσουμε ένα υποθετικό σενάριο όπου θέλουμε να καλέσουμε την `system("/bin/sh")` χρησιμοποιώντας ROP σε ένα 32-bit δυαδικό:

1. **Εύρεση Gadgets**: Υποθέτουμε ότι έχουμε βρει τα ακόλουθα gadgets στο δυαδικό αρχείο ή στις φορτωμένες βιβλιοθήκες:
* `pop eax; ret`: Αποσπά την κορυφή της στοίβας στο `EAX` και επιστρέφει.
* `pop ebx; ret`: Αποσπά την κορυφή της στοίβας στο `EAX` και επιστρέφει.
* `mov [ebx], eax; ret`: Μετακινεί την τιμή στο `EAX` στη θέση που δείχνει το `EBX`.
* Η διεύθυνση της `system`.
2. **Προετοιμασία της Αλυσίδας**: Χρειάζεται να προετοιμάσουμε μια στοίβα που να μοιάζει με αυτή:
* Η διεύθυνση του gadget που ορίζει το `EBX`.
* Η διεύθυνση του gadget `pop eax; ret`.
* Η διεύθυνση του string `"/bin/sh"` στη μνήμη (ή όπου προτείνουμε να το γράψουμε).
* Η διεύθυνση του gadget `mov [ebx], eax; ret`, για να μετακινήσει το `"/bin/sh"` στη θέση που δείχνει το `EBX`.
* Η διεύθυνση της συνάρτησης `system`, με το `EBX` να δείχνει στο string μας.
3. **Εκτέλεση**: Όταν η ευάλωτη συνάρτηση επιστρέφει, αρχίζει να εκτελεί την αλυσίδα gadgets μας, καλώντας τελικά την `system("/bin/sh")` και εμφανίζοντας ένα κέλυφος.

### ROP σε x64

Ας υποθέσουμε ένα υποθετικό σενάριο όπου θέλετε να καλέσετε την `execve("/bin/sh", NULL, NULL)` σε ένα σύστημα x64 χρησιμοποιώντας τη σύμβαση κλήσης System V AMD64 ABI:

1. **Εύρεση Gadgets**: Αρχικά θα πρέπει να βρείτε gadgets που σάς επιτρέπουν να ελέγξετε τους καταχωρητές `RDI`, `RSI`, και `RDX`, καθώς αυτοί θα κρατήσουν τα ορίσματα της `execve
