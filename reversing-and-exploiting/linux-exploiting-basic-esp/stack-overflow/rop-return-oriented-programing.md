# ROP - Return Oriented Programing

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS＆HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## **基本信息**

**返回导向编程（ROP）**是一种高级利用技术，用于规避诸如**不可执行（NX）**或**数据执行防护（DEP）**之类的安全措施。攻击者不是注入和执行shellcode，而是利用二进制文件或加载的库中已经存在的代码片段，称为**“gadgets”**。每个gadget通常以`ret`指令结尾，并执行小操作，例如在寄存器之间移动数据或执行算术运算。通过链接这些gadgets，攻击者可以构建有效绕过NX/DEP保护执行任意操作的有效载荷。

### 调用约定

了解**调用约定**对于构建有效的ROP链至关重要，特别是在调用函数或操作数据时：

**x86（32位）**

* **cdecl**：调用者清理堆栈。函数参数以相反顺序（从右到左）推送到堆栈上。**参数从右到左推送到堆栈上**。
* **stdcall**：类似于cdecl，但被调用者负责清理堆栈。

**x64（64位）**

* 在类Unix系统上使用**System V AMD64 ABI**调用约定，其中**前六个整数或指针参数传递到寄存器`RDI`、`RSI`、`RDX`、`RCX`、`R8`和`R9`**。额外的参数传递到堆栈上。返回值放在`RAX`中。
* **Windows x64**调用约定使用`RCX`、`RDX`、`R8`和`R9`作为前四个整数或指针参数，额外的参数传递到堆栈上。返回值放在`RAX`中。
* **寄存器**：64位寄存器包括`RAX`、`RBX`、`RCX`、`RDX`、`RSI`、`RDI`、`RBP`、`RSP`和`R8`到`R15`。

{% hint style="danger" %}
从这些调用约定中可以看出，在**32位**中，函数的参数是**通过堆栈传递**的，而在**x64**中，它们是**放在特定寄存器中**的。
{% endhint %}

### ROP的工作原理

1. **控制流劫持**：首先，攻击者需要劫持程序的控制流，通常是通过利用缓冲区溢出来覆盖堆栈上保存的返回地址。
2. **Gadget链接**：然后，攻击者仔细选择并链接gadgets以执行所需的操作。这可能涉及设置函数调用的参数，调用函数（例如`system("/bin/sh")`），以及处理任何必要的清理或附加操作。
3. **有效载荷执行**：当易受攻击的函数返回时，它开始执行gadget链，而不是返回到合法位置。

### x86中的ROP链

假设我们想在32位二进制文件中使用ROP调用`system("/bin/sh")`的假设场景：

1. **查找Gadgets**：假设我们在二进制文件或加载的库中找到了以下gadgets：
* `pop eax; ret`：将堆栈顶部弹出到`EAX`并返回。
* `pop ebx; ret`：将堆栈顶部弹出到`EAX`并返回。
* `mov [ebx], eax; ret`：将`EAX`中的值移动到由`EBX`指向的位置。
* `system`函数的地址。
2. **准备链**：我们需要准备一个堆栈，看起来像这样：
* 设置`EBX`的gadget地址。
* `pop eax; ret` gadget的地址。
* 内存中字符串`"/bin/sh"`的地址（或我们计划写入的位置）的地址。
* `mov [ebx], eax; ret` gadget的地址，将`"/bin/sh"`移动到由`EBX`指向的位置。
* `system`函数的地址，其中`EBX`指向我们的字符串。
3. **执行**：当易受攻击的函数返回时，它开始执行我们的gadget链，最终调用`system("/bin/sh")`并弹出一个shell。

### x64中的ROP

考虑一个假设场景，您想在System V AMD64 ABI上的x64系统上调用`execve("/bin/sh", NULL, NULL)`：

1. **查找Gadgets**：首先需要找到允许控制`RDI`、`RSI`和`RDX`寄存器的gadgets，因为这些寄存器将保存`execve`的参数。
2. **链构建**：
* **设置`RDI`指向字符串`"/bin/sh"`**：通常使用`pop RDI; ret` gadget，后跟字符串的地址（可能需要放在有效载荷中或在内存中找到）。
* **将`RSI`和`RDX`清零**：由于`execve`的第二和第三个参数是`NULL`，您需要像`xor RSI, RSI; ret`和`xor RDX, RDX; ret`这样的gadgets将这些寄存器清零。
* **调用`execve`**：最后，需要一个跳转到`execve`（或间接调用它）的gadget。
3. **有效载荷执行**：构建并发送此有效载荷到易受攻击的应用程序后，ROP链执行，生成一个shell。

由于x64使用寄存器传递前几个参数，因此对于简单的函数调用，通常需要的gadgets比x86少，但由于寄存器数量增加和地址空间更大，找到并链接正确的gadgets可能更复杂。**x64**架构中寄存器数量增加和地址空间更大为利用开发提供了机会和挑战，特别是在返回导向编程（ROP）的背景下。


<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS＆HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
