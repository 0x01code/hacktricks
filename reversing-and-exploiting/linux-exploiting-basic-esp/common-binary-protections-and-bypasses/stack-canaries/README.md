# Zaštitni mehanizmi steka

**StackGuard** ubacuje posebnu vrednost poznatu kao **kanarinka** pre **EIP (Prošireni Pokazivač Instrukcija)**, specifično `0x000aff0d` (predstavlja null, novi red, EOF, povratak karijete) kako bi se zaštitili od preplavljivanja bafera. Međutim, funkcije poput `recv()`, `memcpy()`, `read()` i `bcopy()` ostaju ranjive, i ne štiti **EBP (Bazni Pokazivač)**.

**StackShield** pristupa problemu na sofisticiraniji način od StackGuard-a održavajući **Globalni Stek Povratka**, koji čuva sve adrese povratka (**EIP-ove**). Ovaj setup osigurava da bilo koje preplavljivanje ne uzrokuje štetu, jer omogućava upoređivanje sačuvanih i stvarnih adresa povratka kako bi se otkrili slučajevi preplavljivanja. Dodatno, StackShield može proveriti adresu povratka u odnosu na granicnu vrednost kako bi otkrio da li **EIP** pokazuje van očekivanog prostora podataka. Međutim, ova zaštita može biti zaobiđena tehnikama poput Return-to-libc, ROP (Return-Oriented Programming) ili ret2ret, što ukazuje da StackShield takođe ne štiti lokalne promenljive.

## **Zaštitnik steka od preplavljivanja (ProPolice) `-fstack-protector`:**

Ovaj mehanizam postavlja **kanarinku** pre **EBP-a**, i reorganizuje lokalne promenljive tako da postavlja baufere na više memorijske adrese, sprečavajući ih da prepišu druge promenljive. Takođe bezbedno kopira argumente prosleđene na stek iznad lokalnih promenljivih i koristi ove kopije kao argumente. Međutim, ne štiti nizove sa manje od 8 elemenata ili baufere unutar strukture korisnika.

**Kanarinka** je slučajan broj dobijen iz `/dev/urandom` ili podrazumevana vrednost `0xff0a0000`. Čuva se u **TLS (Lokalnom Prostoru Niti)**, omogućavajući deljenje memorijskih prostora između niti sa niti-specifičnim globalnim ili statičkim promenljivima. Ove promenljive se prvobitno kopiraju iz roditeljskog procesa, a dečiji procesi mogu menjati svoje podatke bez uticaja na roditelja ili srodne procese. Ipak, ako se koristi **`fork()` bez kreiranja nove kanarinke, svi procesi (roditelj i deca) dele istu kanarinu**, čineći je ranjivom. Na arhitekturi **i386**, kanarinka se čuva na `gs:0x14`, a na **x86\_64**, na `fs:0x28`.

Ova lokalna zaštita identifikuje funkcije sa baferima ranjivim na napade i ubacuje kod na početak ovih funkcija kako bi postavila kanarinu, i na kraju kako bi proverila njenu celovitost.

Kada veb server koristi `fork()`, omogućava napad brute-force metodom da se pogađa kanarinka po bajtovima. Međutim, korišćenje `execve()` nakon `fork()` prebrisava memorijski prostor, poništavajući napad. `vfork()` omogućava dečijem procesu da izvršava bez dupliranja dok ne pokuša da piše, u tom trenutku se kreira duplikat, nudeći drugačiji pristup kreiranju procesa i upravljanju memorijom.

## Zaobiđavanje

**Procurenje kanarinke** a zatim prepisivanje njenom vrednošću (npr. preplavljivanje bafera).

* Ako se **kanarinka forkuje u dečijim procesima**, možda je moguće **brute-force**-ovati je po jedan bajt:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Ako postoji neka interesantna ranjivost procurivanja u binarnom fajlu, možda je moguće procuriti je:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}
