# 栈保护

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## **StackGuard和StackShield**

**StackGuard**在**EIP（扩展指令指针）**之前插入一个特殊值，称为**canary**，具体为`0x000aff0d`（表示空值、换行符、EOF、回车），以防止缓冲区溢出。然而，像`recv()`、`memcpy()`、`read()`和`bcopy()`这样的函数仍然容易受到攻击，而且它不保护**EBP（基指针）**。

**StackShield**采用比StackGuard更复杂的方法，通过维护一个**全局返回堆栈**来存储所有返回地址（**EIPs**）。这种设置确保任何溢出都不会造成伤害，因为它允许对存储的和实际的返回地址进行比较，以检测溢出事件。此外，StackShield可以将返回地址与边界值进行比较，以检测**EIP**是否指向预期数据空间之外。然而，这种保护可以通过Return-to-libc、ROP（Return-Oriented Programming）或ret2ret等技术来规避，这表明StackShield也不保护本地变量。

## **栈破坏保护器（ProPolice）`-fstack-protector`：**

此机制在**EBP**之前放置一个**canary**，并重新组织本地变量以将缓冲区定位在更高的内存地址，防止它们覆盖其他变量。它还安全地复制传递在本地变量上方堆栈上传递的参数，并使用这些副本作为参数。然而，它不保护包含少于8个元素的数组或用户结构中的缓冲区。

**canary**是从`/dev/urandom`派生的随机数，或者默认值为`0xff0a0000`。它存储在**TLS（线程本地存储）**中，允许跨线程共享内存空间具有线程特定的全局或静态变量。这些变量最初从父进程复制，子进程可以修改它们的数据而不影响父进程或同级进程。然而，如果在不创建新canary的情况下使用**`fork()`**，所有进程（父进程和子进程）共享相同的canary，使其容易受到攻击。在**i386**架构上，canary存储在`gs:0x14`，在**x86\_64**上存储在`fs:0x28`。

此本地保护识别容易受攻击的缓冲区的函数，并在这些函数的开头注入代码以放置canary，并在结尾验证其完整性。

当Web服务器使用`fork()`时，可以通过一次一个字节地**猜测canary**来进行暴力攻击。然而，在`fork()`后使用`execve()`会覆盖内存空间，从而抵消攻击。`vfork()`允许子进程执行而不复制，直到尝试写入时创建副本，提供了一种不同的进程创建和内存处理方法。

### 长度

在`x64`二进制文件中，canary cookie是一个**`0x8`**字节的qword。**前七个字节是随机的**，最后一个字节是**空字节**。

在`x86`二进制文件中，canary cookie是一个**`0x4`**字节的dword。**前三个字节是随机的**，最后一个字节是**空字节**。

{% hint style="danger" %}
这两个canary的最低有效字节是空字节，因为它将是来自较低地址的栈中的第一个字节，因此**读取字符串的函数将在读取它之前停止**。
{% endhint %}

## 绕过

**泄露canary**，然后用其自身的值覆盖它（例如缓冲区溢出）。

* 如果**canary在子进程中被fork**，可能可以**逐字节地进行暴力破解**：

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* 如果二进制文件中存在一些有趣的**泄漏或任意读取漏洞**，可能可以泄漏它：

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **覆盖栈中存储的指针**

栈易受栈溢出攻击的情况下，**可能包含可被覆盖的字符串或函数地址**，以便利用漏洞而无需达到栈canary。请查看：

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

## 参考

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
