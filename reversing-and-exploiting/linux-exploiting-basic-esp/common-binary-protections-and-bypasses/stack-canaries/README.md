# Stack Canaries

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di Github.

</details>

## **StackGuard e StackShield**

**StackGuard** inserisce un valore speciale noto come **canary** prima dell'**EIP (Extended Instruction Pointer)**, specificamente `0x000aff0d` (rappresentante null, newline, EOF, carriage return) per proteggersi dagli overflow di buffer. Tuttavia, funzioni come `recv()`, `memcpy()`, `read()`, e `bcopy()` rimangono vulnerabili, e non protegge l'**EBP (Base Pointer)**.

**StackShield** adotta un approccio pi√π sofisticato rispetto a StackGuard mantenendo uno **Stack di Ritorno Globale**, che memorizza tutti gli indirizzi di ritorno (**EIP**). Questa configurazione garantisce che eventuali overflow non causino danni, poich√© consente di confrontare gli indirizzi di ritorno memorizzati con quelli effettivi per rilevare eventuali occorrenze di overflow. Inoltre, StackShield pu√≤ controllare l'indirizzo di ritorno rispetto a un valore di confine per rilevare se l'**EIP** punta al di fuori dello spazio dati previsto. Tuttavia, questa protezione pu√≤ essere aggirata attraverso tecniche come Return-to-libc, ROP (Return-Oriented Programming), o ret2ret, indicando che StackShield non protegge nemmeno le variabili locali.

## **Stack Smash Protector (ProPolice) `-fstack-protector`:**

Questo meccanismo posiziona un **canary** prima dell'**EBP**, e riorganizza le variabili locali posizionando i buffer a indirizzi di memoria pi√π alti, impedendo loro di sovrascrivere altre variabili. Copia in modo sicuro gli argomenti passati nello stack sopra le variabili locali e utilizza queste copie come argomenti. Tuttavia, non protegge gli array con meno di 8 elementi o i buffer all'interno di una struttura dell'utente.

Il **canary** √® un numero casuale derivato da `/dev/urandom` o un valore predefinito di `0xff0a0000`. Viene memorizzato in **TLS (Thread Local Storage)**, consentendo a spazi di memoria condivisi tra thread di avere variabili globali o statiche specifiche del thread. Queste variabili vengono inizialmente copiate dal processo genitore, e i processi figlio possono modificare i loro dati senza influenzare il genitore o i fratelli. Tuttavia, se viene utilizzato un **`fork()` senza creare un nuovo canary, tutti i processi (genitore e figli) condivideranno lo stesso canary**, rendendolo vulnerabile. Sull'architettura **i386**, il canary √® memorizzato a `gs:0x14`, e su **x86\_64**, a `fs:0x28`.

Questa protezione locale identifica le funzioni con buffer vulnerabili agli attacchi e inietta codice all'inizio di queste funzioni per posizionare il canary, e alla fine per verificare la sua integrit√†.

Quando un server web utilizza `fork()`, consente un attacco di forza bruta per indovinare il byte del canary uno alla volta. Tuttavia, utilizzando `execve()` dopo `fork()` sovrascrive lo spazio di memoria, annullando l'attacco. `vfork()` consente al processo figlio di eseguire senza duplicazione fino a quando tenta di scrivere, momento in cui viene creata una duplicazione, offrendo un approccio diverso alla creazione di processi e alla gestione della memoria.

### Lunghezze

Nei binari `x64`, il cookie del canary √® un qword di **`0x8`** byte. I **primi sette byte sono casuali** e l'ultimo byte √® un **byte nullo**.

Nei binari `x86`, il cookie del canary √® un dword di **`0x4`** byte. I **primi tre byte sono casuali** e l'ultimo byte √® un **byte nullo**.

{% hint style="danger" %}
Il byte meno significativo di entrambi i canary √® un byte nullo perch√© sar√† il primo nello stack proveniente da indirizzi inferiori e quindi le **funzioni che leggono stringhe si fermeranno prima di leggerlo**.
{% endhint %}

## Bypass

**Leak del canary** e successiva sovrascrittura (ad es. overflow del buffer) con il proprio valore.

* Se il **canary √® forked nei processi figlio** potrebbe essere possibile **forzarlo** un byte alla volta:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Se c'√® qualche **leak interessante o vulnerabilit√† di lettura arbitraria** nel binario potrebbe essere possibile effettuare un leak:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Sovrascrittura dei puntatori memorizzati nello stack**

Lo stack vulnerabile a un overflow dello stack potrebbe **contenere indirizzi a stringhe o funzioni che possono essere sovrascritti** per sfruttare la vulnerabilit√† senza dover raggiungere il canary dello stack. Controlla:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

## Riferimenti

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di Github.

</details>
