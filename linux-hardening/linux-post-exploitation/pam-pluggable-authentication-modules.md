<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)をフォローする**
* **ハッキングトリックを共有するためにPRを提出して** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリに

</details>


PAMは、システム上のサービスとそのユーザーの間に障壁を形成するモジュールのコレクションです。これらのモジュールには、特定のUNIXグループ（またはネットグループ、サブネットなど）からのユーザーのログインを許可しないようにする、あるいは'研究'グループがシステムリソースを独占できないようにリソース制限を実装するなど、さまざまな目的があります。

# 設定ファイル

Solarisや他の商用UNIXシステムは、**`/etc/pam.conf`** という単一のファイルを中心にしたわずかに異なる構成モデルを持っています。ほとんどのLinuxシステムでは、これらの設定ファイルは **`/etc/pam.d`** にあり、サービスに基づいて名前が付けられています。たとえば、'login'の設定ファイルは **`/etc/pam.d/login`** と呼ばれています。そのファイルのバージョンを簡単に見てみましょう：
```text
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
## **PAM管理領域**

左端の列には、PAM管理の4つの領域を表す4つのユニークな単語が含まれています: **auth**、**account**、**password**、**session**。多くのモジュールがこれらの領域の複数をサポートしています（実際、pam_unixはすべてをサポートしています）、一方、pam_cracklibのような他のモジュールは1つにしか適していません（pam_cracklibの場合は「password」機能）。

* **auth**: ‘auth’領域（私はそれを領域と呼びます - ドキュメントでは「管理グループ」または「機能」と言及されています）は、ユーザーが自分自身であることを確認する責任があります。この領域にリストされるモジュールは、**パスワードの入力を促す**ことを**一般的に**サポートしています。
* **account**: この領域は、さまざまな**アカウント検証機能**に責任を持ちます。この機能には多くのモジュールが利用可能です。**グループメンバーシップの確認**、時間帯、ユーザーアカウントがローカルかリモートかなどに基づくサービスの利用に制約を課すことは、一般的にこの機能をサポートするモジュールによって強制されます。
* **password**: この領域のモジュールは、特定のサービスの**パスワードの更新**に必要な機能を担当します。ほとんどの場合、このセクションは非常に単調で、単に**現在のパスワードの入力を促し**、それが成功した場合は新しいパスワードの入力を促します。他のモジュールは、pam_cracklibやpam_pwcheckモジュールによって実行されるような**パスワードの複雑さ**や辞書チェックを実行するために追加できます。
* **session**: この領域のモジュールは、特定のユーザーのサービスの**セットアップやクリーンアップ中に発生する**さまざまな作業を実行します。これには、システム全体の初期化スクリプトの起動、特別なログ記録の実行、**ユーザーのホームディレクトリのマウント**、リソース制限の設定などが含まれる場合があります。

## **PAMモジュールコントロール**

**中央の列**には、モジュールが成功または失敗した場合に**PAMが何をすべきかを実質的に決定する**キーワードが含まれています。これらのキーワードはPAM用語では「**コントロール**」と呼ばれます。90%の場合、一般的なキーワード（**requisite**、**required**、**sufficient**、**optional**）のいずれかを使用できます。ただし、これはPAMの柔軟性とパワーを解放するための氷山の一角に過ぎません。

* **required**: ‘required’モジュールが**‘success’でないステータス**を返すと、**操作は常に失敗します**が、**その下のモジュールが呼び出された後**にのみ失敗します。これは初めて見ると無意味に思えるかもしれませんが、**サービスを利用しようとするユーザーの視点からは常に同じ方法で動作する**ことを目的としています。その結果、潜在的なクラッカーが**どの** **モジュール**が**失敗**の原因であるかを**特定**するのが**不可能**になります。
* **requisite**: ‘requisite’モジュールが失敗すると、**操作は失敗するだけでなく**、他のモジュールを呼び出さずに**即座に** **失敗**で終了します。
* **sufficient**: **sufficient**モジュールが**成功**すると、その領域の**十分なモジュールの要件を満たす**のに十分であり、**その下にある‘sufficient’としてリストされたモジュールは呼び出されません**。**失敗すると、その後に呼び出されるモジュールが成功しない限り、操作は失敗します**。
* **optional**: ''optional’モジュールは、pam\(8\)マニュアルによると、その機能のスタック内で**唯一のモジュール**である場合にのみ、操作を失敗させます。

## 例

例のファイルでは、auth領域にスタックされた4つのモジュールがあります:
```text
auth       required     /lib/security/pam_securetty.so
auth       required     /lib/security/pam_env.so
auth       sufficient   /lib/security/pam_ldap.so
auth       required     /lib/security/pam_unix.so try_first_pass
```
1. **pam\_securetty**モジュールは、その設定ファイルである**`/etc/securetty`**をチェックし、このログインに使用されている端末がファイルにリストされているかどうかを確認します。もしリストされていない場合、**rootログインは許可されません**。'bad'端末でrootとしてログインしようとすると、このモジュールは失敗します。'required'であるため、スタック内のすべてのモジュールを呼び出します。しかし、それらがすべて成功しても、ログインは失敗します。興味深いのは、もしモジュールが'requisite'としてリストされていた場合、操作はすぐに失敗して他のモジュールを呼び出さずに終了します。
2. **pam\_env**モジュールは、管理者が**`/etc/security/pam_env.conf`**で設定した内容に基づいて**環境変数を設定**します。Redhat 9、Fedora Core 1、Mandrake 9.2のデフォルトセットアップでは、このモジュールの構成ファイルは実際には変数を設定しません。SSH経由でログインするユーザーのためにDISPLAY環境変数を自動的に設定するなど、良い使い道があります（ただし、OpenSSHが自動的に処理することもできます）。
3. **pam\_ldap**モジュールは、ユーザーに**パスワードを要求**し、次に**`/etc/ldap.conf`**で指定されたldapディレクトリをチェックしてユーザーを認証します。これが失敗した場合、'pam\_unix'がユーザーを認証するのに成功しても操作は成功する可能性があります。pam\_ldapが成功した場合、'pam\_unix'は呼び出されません。
4. この場合の**pam\_unix**モジュールは、ユーザーにパスワードを要求しません。'try_first_pass'引数は、モジュールに**直前のモジュール（この場合はpam\_ldap）から与えられたパスワードを使用**するよう指示します。標準のgetpw\*システムコールを使用してユーザーを認証しようとします。pam\_unixが失敗し、pam\_ldapも失敗した場合、操作は失敗します。pam\_ldapが失敗した場合でも、pam\_unixが成功した場合、操作は成功します（これは、rootがldapディレクトリに含まれていないが、ローカルの/etc/passwdファイルにはまだ存在する場合に非常に役立ちます！）。
