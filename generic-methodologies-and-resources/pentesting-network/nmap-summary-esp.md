# Nmapの要約 (ESP)

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**PEASSファミリー**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加する、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有する。

</details>
```
nmap -sV -sC -O -n -oA nmapscan 192.168.0.1/24
```
## パラメータ

### スキャンするIP

* **`<ip>,<net/mask>`:** 直接IPを指定
* **`-iL <ips_file>`:** list\_IPs
* **`-iR <number>`**: ランダムなIPの数、`--exclude <Ips>` または `--excludefile <file>` で除外可能なIPを指定。

### 機器の発見

デフォルトでは、Nmapは次の発見フェーズを実行します: `-PA80 -PS443 -PE -PP`

* **`-sL`**: 侵入しない、**DNS**リクエストを行いターゲットをリストアップ。例えばwww.prueba.es/24の全IPがターゲットかどうか知るのに役立つ。
* **`-Pn`**: **No ping**。全てがアクティブであることが分かっている場合に有用（そうでなければ時間がかかるが、アクティブでないと誤って報告することもある）。発見フェーズを防ぐ。
* **`-sn`** : **ポートスキャンなし**。偵察フェーズ完了後、ポートをスキャンしない。比較的ステルスであり、小規模なネットワークスキャンを可能にする。権限がある場合は80にACK(-PA)、443にSYN(-PS)、エコーリクエストとタイムスタンプリクエストを送信し、権限がない場合は常に接続を完了する。ターゲットがネットワークの場合はARP(-PR)のみ使用。他のオプションと併用すると、そのオプションのパケットのみがドロップされる。
* **`-PR`**: **Ping ARP**。自分たちのネットワーク内のコンピュータを分析する際にデフォルトで使用され、pingを使うよりも速い。ARPパケットを使用したくない場合は `--send-ip` を使用。
* **`-PS <ports>`**: SYNパケットを送信し、SYN/ACKで応答があればオープン（RSTで応答して接続を終了しない）、RSTで応答があればクローズ、応答がなければ到達不能。権限がない場合は自動的に完全な接続が使用される。ポートが指定されていない場合は80に対して実行される。
* **`-PA <ports>`**: 上記と同様だがACKを使用、両方を組み合わせるとより良い結果が得られる。
* **`-PU <ports>`**: 目的は逆で、閉じていると予想されるポートに送信される。一部のファイアウォールはTCP接続のみをチェックする。閉じていればポート到達不能で応答し、他のicmpで応答されるか応答がなければ目的地到達不能として残される。
* **`-PE, -PP, -PM`** : ICMP PINGS: エコーリプレイ、タイムスタンプ、アドレスマスク。ターゲットがアクティブかどうかを知るために実行される。
* **`-PY<ports>`**: デフォルトで80にSCTP INITプローブを送信し、INIT-ACK(オープン)またはABORT(クローズ)、何もなし、またはICMP到達不能(非アクティブ)が返信される可能性がある。
* **`-PO <protocols>`**: ヘッダーにプロトコルを指定し、デフォルトでは1(ICMP)、2(IGMP)、4(Encap IP)。ICMP、IGMP、TCP (6)、UDP (17)プロトコルの場合はプロトコルヘッダーが送信され、それ以外の場合はIPヘッダーのみが送信される。これは、ヘッダーの不正形成により、プロトコル到達不能または同じプロトコルの応答が返され、アクティブかどうかを知るためである。
* **`-n`**: DNSなし
* **`-R`**: 常にDNS

### ポートスキャン技術

* **`-sS`**: 接続を完了しないため、痕跡を残さない。使用可能であれば非常に良い。(権限が必要) デフォルトで使用される。
* **`-sT`**: 接続を完了するため、痕跡を残すが、確実に使用できる。権限がない場合のデフォルト。
* **`-sU`**: UDP用で、遅い。主にDNS(53)、SNMP(161,162)、DHCP(67と68)、(-sU53,161,162,67,68): オープン(応答あり)、クローズ(ポート到達不能)、フィルタリング(他のICMP)、オープン/フィルタリング(何もなし)。オープン/フィルタリングの場合、-sVはnmapがサポートし検出可能なバージョンのリクエストを多数送信し、真の状態を検出する。時間が大幅に増加する。
* **`-sY`**: SCTPプロトコルは接続を確立できず、ログが残らないため、-PYのように機能する。
* **`-sN,-sX,-sF`:** Null、Fin、Xmas。一部のファイアウォールを突破し、情報を抽出することができる。SYN、RST、ACKフラグが立っていない全てのリクエストに対して標準準拠のマシンはRSTで応答するべきであるという事実に基づいている: オープン/フィルタリング(何もなし)、クローズ(RST)、フィルタリング(ICMP到達不能)。Windows、Cisco、BSDI、OS/400では信頼性が低い。Unixでははい。
* **`-sM`**: Maimonスキャン: FINとACKフラグを送信し、BSD用に使用されるが、現在は全てクローズとして返される。
* **`-sA, sW`**: ACKとWindow、ファイアウォールを検出するために使用される。ポートがフィルタリングされているかどうかを知るために使用される。-sWはオープンとクローズを区別するが、オープンなものは異なるウィンドウ値で応答する: オープン(RSTでウィンドウが0以外)、クローズ(RSTウィンドウ=0)、フィルタリング(ICMP到達不能または何もなし)。全てのコンピュータがこのように動作するわけではないため、全てがクローズの場合は機能していない、少数がオープンの場合はうまく機能している、多数がオープンで少数がクローズの場合は逆に機能している。
* **`-sI`:** Idleスキャン。アクティブなファイアウォールがあるが、特定のIPに対してフィルタリングされていないことがわかっている場合（または単に匿名性を望む場合）、ゾンビスキャナーを使用できる（全ポートに対して機能する）。可能なゾンビを探すためには、スクリプトipidseqまたはエクスプロイトauxiliary/scanner/ip/ipidseqを使用できる。このスキャナーはIPパケットのIPID番号に基づいている。
* **`--badsum`:** 合計が間違っているため、コンピュータはパケットを破棄するが、ファイアウォールは何かを応答する可能性がある。ファイアウォールを検出するために使用される。
* **`-sZ`:** "奇妙な" SCTPスキャナー、cookie echoフラグメントを持つプローブを送信すると、オープンの場合は破棄されるか、クローズの場合はABORTで応答される。initが通過しないファイアウォールを通過することができるが、フィルタリングされたものとオープンを区別することはできない。
* **`-sO`:** IPプロトコルスキャン。悪いヘッダーと空のヘッダーを送信し、時にはプロトコルさえ区別できない。ICMP到達不能プロトコルが到着すればクローズ、到達不能ポートが到着すればオープン、他のエラーが到着すればフィルタリング、何も到着しなければオープン|フィルタリング。
* **`-b <server>`:** FTPhost--> 別のホストからホストをスキャンするために使用される。これは、別のマシンのftpに接続し、別のマシンからスキャンしたいポートにファイルを送信するように依頼することで行われる。応答によって、オープンかどうかがわかる。 \[\<user>:\<password>@]\<server>\[:\<port>] ほとんどのftpサーバーはこれを許可しなくなったため、実用的な価値はほとんどない。

### **分析の中心化**

**-p:** スキャンするポートを指定するために使用される。65335を選択するには **-p-** または **-p all**。Nmapには内部的な人気度に基づく分類がある。デフォルトでは上位1000を使用。 **-F** (高速スキャン) では上位100を分析する。 **--top-ports \<number>** でその数の上位ポートを分析する（1から65335まで）。ポートをランダムな順序でチェックするが、それを避けるには **-r** を使用する。また、ポートを選択することもできる: 20-30,80,443,1024- これは1024以降をチェックすることを意味する。プロトコルごとにポートをグループ化することもできる: U:53,T:21-25,80,139,S:9。また、nmap-servicesに含まれる人気のポートの範囲内で選択することもできる: -p \[-1024] はnmap-servicesに含まれる1024までを分析する。 **--port-ratio \<ratio>** は0から1の間の比率で最も一般的なポートを分析する。

**-sV** バージョンスキャン、0から9までの強度を調整可能、デフォルトは7。

**--version-intensity \<number>** 強度を調整し、低いほど可能性の高いプローブのみを実行し、全ては実行しない。これによりUDPスキャン時間を大幅に短縮できる。

**-O** OS検出

**--osscan-limit** ホストをうまくスキャンするには、少なくとも1つのポートがオープンで、もう1つがクローズしている必要がある。この条件が満たされず、これを設定している場合は、OS予測を試みない（時間節約）。

**--osscan-guess** OS検出が完璧でない場合、これによりより努力する。

**スクリプト**

\--script _\<filename>_|_\<category>_|_\<directory>_|_\<expression>_\[,...]

デフォルトのスクリプトを使用するには、-sCまたは--script=defaultで十分。

種類は次の通り: auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, vuln

* **Auth:** 認証に関する全ての利用可能なスクリプトを実行
* **Default:** ツールのデフォルトの基本スクリプトを実行
* **Discovery:** ターゲットまたは被害者から情報を取得
* **External:** 外部リソースを使用するスクリプト
* **Intrusive:** 被害者またはターゲットに対して侵入的と見なされるスクリプトを使用
* **Malware:** 悪意のあるコードやバックドアによって開かれた接続をチェック
* **Safe:** 侵入的でないスクリプトを実行
* **Vuln:** 最もよく知られた脆弱性を発見
* **All:** 利用可能な全てのNSE拡張スクリプトを実行

スクリプトを検索するには:

**nmap --script-help="http-\*" -> http-で始まるもの**

**nmap --script-help="not intrusive" -> それ以外の全て**

**nmap --script-help="default or safe" -> どちらか一方または両方にあるもの**

**nmap --script-help="default and safe" --> 両方にあるもの**

**nmap --script-help="(default or safe or intrusive) and not http-\*"**

\--script-args _\<n1>_=_\<v1>_,_\<n2>_={_\<n3>_=_\<v3>_},_\<n4>_={_\<v4>_,_\<v5>_}

\--script-args-file _\<filename>_

\--script-help _\<filename>_|_\<category>_|_\<directory>_|_\<expression>_|all\[,...]

\--script-trace ---> スクリプトの進行情報を提供

\--script-updatedb

**スクリプトを使用するには、次のように入力する: namp --script スクリプト名 ターゲット** --> スクリプトを指定すると、スクリプトとスキャナーの両方が実行されるため、スキャナーのオプションも指
