# ラジオ

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じて、ゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter**で**@carlospolopm**をフォローする🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
- **ハッキングトリックを共有するには、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>

## SigDigger

[**SigDigger** ](https://github.com/BatchDrake/SigDigger)は、GNU/LinuxとmacOS用の無料デジタル信号アナライザーであり、未知の無線信号から情報を抽出するために設計されています。SoapySDRを介してさまざまなSDRデバイスをサポートし、FSK、PSK、ASK信号の調整可能な復調、アナログビデオのデコード、バースト信号の分析、アナログ音声チャネルのリアルタイムリスニングを可能にします。

### 基本設定

インストール後、構成を考慮すべきいくつかのことがあります。\
設定（2番目のタブボタン）では、**SDRデバイス**を選択したり、読み取る**ファイルを選択**したり、シントニスする周波数とサンプルレート（PCがサポートしている場合は2.56Mspsまで推奨）を選択できます。

![](<../../.gitbook/assets/image (245).png>)

GUI動作では、PCがサポートしている場合は、いくつかの機能を有効にすることをお勧めします。

![](<../../.gitbook/assets/image (472).png>)

{% hint style="info" %}
PCが何もキャプチャしていないことに気づいた場合は、OpenGLを無効にしてサンプルレートを下げてみてください。
{% endhint %}

### 使用法

* **信号の一部をキャプチャして分析する**だけであれば、「キャプチャを押す」ボタンを必要な時間だけ押し続けます。

![](<../../.gitbook/assets/image (960).png>)

* SigDiggerの**チューナー**は、**信号をよりよくキャプチャする**のに役立ちます（ただし、信号を劣化させることもあります）。理想的には、0から始めて、**ノイズが増加し始める前のレベルまで**徐々に**大きくしていきます**。

![](<../../.gitbook/assets/image (1099).png>)

### ラジオチャンネルとの同期

[**SigDigger** ](https://github.com/BatchDrake/SigDigger)を使用して、聞きたいチャンネルと同期し、「Basebandオーディオプレビュー」オプションを構成し、送信されているすべての情報を取得するための帯域幅を構成し、次にノイズが本当に増加し始めるレベルまでチューナーを設定します。

![](<../../.gitbook/assets/image (585).png>)

## 興味深いトリック

* デバイスが情報のバーストを送信している場合、通常**最初の部分は前置部**になるので、**そこに情報が見つからない**場合や**エラーがある**場合は**心配しない**でください。
* 情報フレームでは、通常、**異なるフレームがきちんと整列しているはず**です：

![](<../../.gitbook/assets/image (1076).png>)

![](<../../.gitbook/assets/image (597).png>)

* **ビットを回復した後は、何らかの方法でそれらを処理する必要がある**かもしれません。たとえば、マンチェスター符号化では、上+下が1または0であり、下+上がもう一方です。つまり、1と0のペア（上と下）は実際の1または実際の0になります。
* マンチェスター符号化を使用している信号でも（連続して2つ以上の0または1を見つけることは不可能です）、**前置部で複数の1または0が見つかる**ことがあります！

### IQで変調タイプを特定する

信号に情報を格納する方法には、**振幅**、**周波数**、**位相**を変調する3つの方法があります。\
信号をチェックしている場合、情報が格納されている方法を特定しようとするさまざまな方法があります（以下にさらに多くの方法があります）、しかし、IQグラフをチェックするのは良い方法の1つです。

![](<../../.gitbook/assets/image (788).png>)

* **AMを検出する**：IQグラフにたとえば**2つの円**が表示される場合（おそらく1つは0で、もう1つは異なる振幅である）、これはAM信号である可能性があります。IQグラフでは、0と円の間の距離が信号の振幅であるため、異なる振幅が使用されているのが視覚的にわかりやすいです。
* **PMを検出する**：前の画像のように、関連性のない小さな円を見つけた場合、位相変調が使用されている可能性があります。IQグラフでは、点と0,0の間の角度が信号の位相であるため、4つの異なる位相が使用されていることを意味します。
* 情報が位相自体ではなく位相が変化していることに隠されている場合、異なる位相が明確に区別されないことに注意してください。
* **FMを検出する**：IQには周波数を識別するためのフィールドがありません（中心までの距離は振幅であり、角度は位相です）。\
したがって、FMを識別するには、このグラフに**基本的に円だけが表示**されるはずです。\
さらに、異なる周波数は、このグラフで**円を加速させることによって**表現されます（したがって、SysDiggerで信号を選択するとIQグラフが作成され、作成された円で加速や方向の変更を見つけると、これがFMである可能性があります）：

## AMの例

{% file src="../../.gitbook/assets/sigdigger_20220308_165547Z_2560000_433500000_float32_iq.raw" %}

### AMの特定

#### エンベロープをチェックする

[**SigDigger** ](https://github.com/BatchDrake/SigDigger)を使用してAM情報をチェックし、**エンベロープ**を見るだけで、異なる明確な振幅レベルが見えます。使用されている信号はAMで情報を送信しており、これが1つのパルスの見た目です：

![](<../../.gitbook/assets/image (590).png>)

およびこのシンボルの一部が波形でどのように見えるか：

![](<../../.gitbook/assets/image (734).png>)

#### ヒストグラムをチェックする

情報がある場所で**信号全体**を選択し、**振幅**モードを選択し、**選択**をクリックして**ヒストグラム**をクリックします。2つの明確なレベルだけが見つかることがわかります

![](<../../.gitbook/assets/image (264).png>)

たとえば、このAM信号では、振幅の代わりに周波数を選択すると、1つの周波数だけが見つかります（周波数で情報が変調されている方法は1つの周波数だけを使用している可能性があります）。

![](<../../.gitbook/assets/image (732).png>)

多くの周波数が見つかる場合、これはFMではなく、おそらく信号周波数がチャンネルの影響で変更された可能性があることを意味します。
#### IQを使用した場合

この例では、**大きな円**と**中心にたくさんの点**があるのがわかります。

![](<../../.gitbook/assets/image (222).png>)

### シンボルレートを取得

#### 1つのシンボルで

最も小さいシンボルを選択して（1であることを確認するため）、"Selection freq"をチェックします。この場合、1.013kHz（つまり1kHz）になります。

![](<../../.gitbook/assets/image (78).png>)

#### シンボルのグループで

選択するシンボルの数を指定することもでき、SigDiggerは1つのシンボルの周波数を計算します（選択されたシンボルが多いほど良いでしょう）。このシナリオでは、10個のシンボルを選択し、"Selection freq"は1.004 kHzです：

![](<../../.gitbook/assets/image (1008).png>)

### ビットを取得

この信号が**AM変調**された信号であり、**シンボルレート**を見つけた後（この場合、上が1を意味し、下が0を意味することを知っている）、信号にエンコードされた**ビットを取得**するのは非常に簡単です。したがって、情報を持つ信号を選択し、サンプリングと決定を構成してサンプルを取ります（**Amplitude**が選択されていること、発見された**シンボルレート**が構成されていること、および**Gadnerクロック回復**が選択されていることを確認してください）：

![](<../../.gitbook/assets/image (965).png>)

* **選択間隔に同期**すると、以前にシンボルレートを見つけるために間隔を選択した場合、そのシンボルレートが使用されます。
* **手動**は、指定されたシンボルレートが使用されることを意味します
* **固定間隔選択**では、選択するべき間隔の数を指定し、それからシンボルレートを計算します
* **Gadnerクロック回復**が通常最良のオプションですが、まだおおよそのシンボルレートを指定する必要があります。

サンプルを取ると、次のように表示されます：

![](<../../.gitbook/assets/image (644).png>)

今、SigDiggerに**情報を運ぶレベルの範囲がどこにあるか**を理解させるために、**下のレベル**をクリックして最大のレベルまでクリックしたままにしておきます：

![](<../../.gitbook/assets/image (439).png>)

たとえば**振幅の異なる4つのレベル**がある場合、**シンボルごとのビットを2に設定**し、最小から最大まで選択する必要があります。

最後に、**ズームを増やし**、**行のサイズを変更**するとビットが表示されます（すべてを選択してコピーしてすべてのビットを取得できます）：

![](<../../.gitbook/assets/image (276).png>)

シンボルごとに1ビット以上（たとえば2ビット）の信号の場合、SigDiggerは**00、01、10、11のどのシンボルかを知る方法がありません**ので、それぞれを表すために異なる**グレースケール**を使用します（ビットをコピーすると、**0から3までの数字**が使用され、これらを処理する必要があります）。

また、**Manchester**などの**符号化**を使用する場合、**up+down**が1または0であることがあり、down+upが1または0であることがあります。その場合、取得したup（1）とdown（0）を処理して、01または10のペアを0または1に置き換える必要があります。

## FMの例

{% file src="../../.gitbook/assets/sigdigger_20220308_170858Z_2560000_433500000_float32_iq.raw" %}

### FMの解明

#### 周波数と波形の確認

FMで変調された情報を送信する信号の例：

![](<../../.gitbook/assets/image (725).png>)

前の画像では、**2つの周波数が使用されている**のがよくわかりますが、**波形**を**観察**しても、**2つの異なる周波数を正しく識別できない**かもしれません：

![](<../../.gitbook/assets/image (717).png>)

これは、私が信号を両方の周波数でキャプチャしたためであり、したがって、片方が他方のほぼ反対になります：

![](<../../.gitbook/assets/image (942).png>)

同期周波数が**1つの周波数よりも他の周波数に近い**場合、2つの異なる周波数を簡単に見ることができます：

![](<../../.gitbook/assets/image (422).png>)

![](<../../.gitbook/assets/image (488).png>)

#### ヒストグラムの確認

情報を持つ信号の周波数ヒストグラムを確認すると、2つの異なる信号が簡単に見えます：

![](<../../.gitbook/assets/image (871).png>)

この場合、**振幅ヒストグラム**を確認すると、**1つの振幅しか見つからない**ため、これは**AMではない**可能性があります（多くの振幅が見つかる場合は、信号がチャネルを通過する間に電力を失っている可能性があるためです）：

![](<../../.gitbook/assets/image (817).png>)

そして、これが位相ヒストグラムになります（信号が位相で変調されていないことが非常に明確になります）：

![](<../../.gitbook/assets/image (996).png>)

#### IQを使用した場合

IQには周波数を識別するためのフィールドがありません（中心からの距離が振幅であり、角度が位相です）。\
したがって、FMを識別するには、このグラフで**基本的に円**しか見えないはずです。\
さらに、異なる周波数は、IQグラフで**円を加速**することで「表現」されます（したがって、SysDiggerで信号を選択するとIQグラフが生成され、作成された円で加速や方向の変更を見つけると、これがFMである可能性があります）：

![](<../../.gitbook/assets/image (81).png>)

### シンボルレートを取得

周波数を運ぶシンボルを見つけたら、AMの例で使用した**同じ手法**を使用してシンボルレートを取得できます。

### ビットを取得

周波数で変調されている信号と**シンボルレート**を見つけたら、AMの例で使用した**同じ手法**を使用してビットを取得できます。
