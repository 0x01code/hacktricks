# 11211 - Pentesting Memcache

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks的衣物**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

## 协议信息

**Memcached**（发音：mem-cashed，mem-cash-dee）是一个通用的分布式[内存缓存](https://en.wikipedia.org/wiki/Memory\_caching)系统。它经常被用于通过将数据和对象缓存在RAM中来加速动态数据库驱动的网站，以减少读取外部数据源（如数据库或API）的次数。（来自[wikipedia](https://en.wikipedia.org/wiki/Memcached)）\
尽管Memcached支持SASL，但大多数实例都**没有身份验证**。

**默认端口：**11211
```
PORT      STATE SERVICE
11211/tcp open  unknown
```
## 枚举

### 手动

要从memcache实例中提取保存的所有信息，您需要执行以下操作：

1. 找到具有**活动项目**的**slabs**
2. 获取之前检测到的slabs的**键名**
3. 通过**获取键名**来提取**保存的数据**

请记住，此服务只是一个**缓存**，因此**数据可能会出现和消失**。
```bash
echo "version" | nc -vn -w 1 <IP> 11211      #Get version
echo "stats" | nc -vn -w 1 <IP> 11211        #Get status
echo "stats slabs" | nc -vn -w 1 <IP> 11211  #Get slabs
echo "stats items" | nc -vn -w 1 <IP> 11211  #Get items of slabs with info
echo "stats cachedump <number> 0" | nc -vn -w 1 <IP> 11211  #Get key names (the 0 is for unlimited output size)
echo "get <item_name>" | nc -vn -w 1 <IP> 11211  #Get saved info

#This php will just dump the keys, you need to use "get <item_name> later"
sudo apt-get install php-memcached
php -r '$c = new Memcached(); $c->addServer("localhost", 11211); var_dump( $c->getAllKeys() );'
```
### 手动2

Memcached是一个高性能的分布式内存对象缓存系统，常用于加速动态Web应用程序。它使用键值对存储数据，并将数据存储在内存中，以提供快速的读取和写入操作。

#### Memcached的安全性问题

尽管Memcached是一个强大的工具，但它也存在一些安全性问题，可能会被黑客利用。以下是一些常见的安全漏洞和攻击技术：

1. 未授权访问：默认情况下，Memcached没有身份验证机制，这意味着任何人都可以访问和修改存储在其中的数据。黑客可以利用这一点来读取、修改或删除敏感数据。

2. 反射放大攻击：Memcached可以被用作反射放大攻击的工具。黑客可以发送一个小的请求，但由于Memcached的特性，它会返回一个大量的数据，从而导致目标服务器的带宽消耗过大，甚至可能导致服务不可用。

3. 缓存投毒：黑客可以通过向Memcached中注入恶意数据来破坏缓存的完整性。这可能导致应用程序返回错误的数据或执行不安全的操作。

#### Memcached的安全加固措施

为了保护Memcached免受黑客攻击，以下是一些安全加固措施：

1. 访问控制：通过配置防火墙或网络访问控制列表（ACL）来限制Memcached的访问。只允许受信任的IP地址访问Memcached服务器。

2. 身份验证和授权：使用身份验证和授权机制来限制对Memcached的访问。可以使用插件或代理服务器来实现这些功能。

3. 定期更新：及时更新Memcached的版本和补丁，以修复已知的安全漏洞。

4. 监控和日志记录：实施监控和日志记录机制，以便及时检测和响应任何异常活动。

5. 安全配置：配置Memcached以最小化安全风险。禁用不必要的功能和命令，并限制内存使用。

6. 安全审计：定期进行安全审计，以评估Memcached的安全性，并采取必要的措施来修复发现的漏洞。

#### 结论

Memcached是一个强大的工具，但在使用时需要注意安全性。通过实施适当的安全措施，可以减少黑客攻击的风险，并保护存储在Memcached中的敏感数据。
```bash
sudo apt install libmemcached-tools
memcstat --servers=127.0.0.1 #Get stats
memcdump --servers=127.0.0.1 #Get all items
memccat  --servers=127.0.0.1 <item1> <item2> <item3> #Get info inside the item(s)
```
### 自动化

Memcached是一种常见的分布式内存对象缓存系统，常用于加速动态Web应用程序。Memcached服务器使用基于键值对的存储模型，可以存储任意类型的数据。在渗透测试中，我们可以利用Memcached服务器的一些自动化工具来发现和利用潜在的安全漏洞。

#### Memcached自动化工具

以下是一些常用的Memcached自动化工具：

- **Memcrashed**：一款基于Python的Memcached DDoS攻击工具，可以利用Memcached服务器的UDP协议进行放大攻击。
- **Memcached-Stats**：一款用于收集和分析Memcached服务器统计信息的工具。
- **Memcached-Top**：一款用于监视和显示Memcached服务器性能指标的工具。
- **Memcached-Scanner**：一款用于扫描网络中的Memcached服务器的工具，可以发现未经授权的服务器。
- **Memcached-Injector**：一款用于向Memcached服务器注入数据的工具，可以测试服务器的性能和稳定性。

#### Memcached漏洞利用

以下是一些常见的Memcached漏洞利用技术：

- **未经授权访问**：通过扫描网络中的Memcached服务器，发现未经授权访问的服务器，并利用其存储和检索数据的功能。
- **DDoS攻击**：利用Memcached服务器的UDP协议进行放大攻击，向目标服务器发送大量的请求，导致目标服务器资源耗尽。
- **信息泄露**：通过访问Memcached服务器的统计信息，获取敏感信息，如缓存的数据、密钥等。
- **缓存投毒**：通过向Memcached服务器注入恶意数据，使其返回恶意响应，从而影响应用程序的正常运行。

#### 防御措施

以下是一些保护Memcached服务器的措施：

- **访问控制**：限制Memcached服务器的访问权限，只允许授权的用户或IP地址访问。
- **防火墙配置**：使用防火墙配置来限制对Memcached服务器的访问，只允许来自可信来源的请求。
- **更新和补丁**：及时更新Memcached服务器的软件版本，并应用安全补丁以修复已知的漏洞。
- **安全配置**：配置Memcached服务器以限制其资源使用和响应大小，以防止DDoS攻击。
- **监控和日志**：监控Memcached服务器的活动，并记录日志以便检测和响应潜在的安全事件。

#### 参考资料

- [Memcached官方网站](https://memcached.org/)
- [Memcached-Wikipedia](https://en.wikipedia.org/wiki/Memcached)
```bash
nmap -n -sV --script memcached-info -p 11211 <IP>   #Just gather info
msf > use auxiliary/gather/memcached_extractor      #Extracts saved data
msf > use auxiliary/scanner/memcached/memcached_amp #Check is UDP DDoS amplification attack is possible
```
## 转储Memcache键 <a href="#dumping-memcache-keys" id="dumping-memcache-keys"></a>

**如果您的memcached版本高于1.4.31，请阅读下一节以了解转储键的高级方法。**

Memcache协议提供了[命令](https://lzone.de/articles/memcached.htm)来查看按照slab（给定大小范围的数据类别）组织的数据。然而，存在一些重要的限制：

1. 您只能按照slab类别（具有大致相同内容大小的键）转储键。
2. 您只能转储每个slab类别的一页（1MB的数据）。
3. 这是一个非官方功能，[随时可能被删除。](https://groups.google.com/forum/?fromgroups=#!topic/memcached/1-T8I-RVGKM)

第二个限制可能是最困难的，因为几个GB的1MB几乎没有什么。但是，观察您使用的一部分键可能是有用的。但这可能取决于您的用例。如果您不关心技术细节，只需跳转到[工具部分](https://lzone.de/cheat-sheet/memcached#tools)了解哪些工具可以让您轻松转储所有内容。或者按照以下指南尝试使用[telnet](https://lzone.de/articles/memcached.htm)命令与您的memcached设置进行交互。 **工作原理** 首先，您需要了解memcache如何组织其内存。如果您使用“-vv”选项启动memcache，您将看到它创建的slab类别。例如
```
$ memcached -vv
slab class   1: chunk size        96 perslab   10922
slab class   2: chunk size       120 perslab    8738
slab class   3: chunk size       152 perslab    6898
slab class   4: chunk size       192 perslab    5461
[...]
```
在上面打印的配置中，memcache将在1MB大小的单个slab中保留6898个大小在121到152字节之间的数据块（6898\*152）。所有的slab默认大小都是1MB。使用以下命令打印当前存在的所有slab：
```
stats slabs
```
如果您在空的memcached 1.4.13中添加了一个键
```
set mykey 0 60 1
1
STORED
```
您现在将看到“stats slabs”命令的以下结果：
```
stats slabs
STAT 1:chunk_size 96
STAT 1:chunks_per_page 10922
STAT 1:total_pages 1
STAT 1:total_chunks 10922
STAT 1:used_chunks 1
STAT 1:free_chunks 0
STAT 1:free_chunks_end 10921
STAT 1:mem_requested 71
STAT 1:get_hits 0
STAT 1:cmd_set 2
STAT 1:delete_hits 0
STAT 1:incr_hits 0
STAT 1:decr_hits 0
STAT 1:cas_hits 0
STAT 1:cas_badval 0
STAT 1:touch_hits 0
STAT active_slabs 1
STAT total_malloced 1048512
END
```
该示例显示我们只有一个活动的slab类型＃1。我们的键只有一个字节大小，适合作为最小可能的块大小。slab统计信息显示当前只有一个slab类的页面存在，并且只使用了一个块。**最重要的是，它显示了每个写操作（set，incr，decr，cas，touch）和一个get操作的计数器。使用这些计数器，您可以确定命中率！**您还可以使用“stats items”获取另一组信息，其中包含有关驱逐和内存不足计数器的有趣计数器。
```
stats items
STAT items:1:number 1
STAT items:1:age 4
STAT items:1:evicted 0
STAT items:1:evicted_nonzero 0
STAT items:1:evicted_time 0
STAT items:1:outofmemory 0
STAT items:1:tailrepairs 0
STAT items:1:reclaimed 0
STAT items:1:expired_unfetched 0
STAT items:1:evicted_unfetched 0
END
```
**我们已经可以猜到的一些事情...** 根据每个slabs类别的统计信息，我们已经可以猜到关于应用程序行为的很多事情：

1. 不同内容大小的缓存比率是多少？
* 大型HTML块的缓存效果如何？
2. 不同内容大小的内存消耗有多少？
* 简单数字计数器的内存消耗有多少？
* 会话数据的内存消耗有多少？
* 大型HTML块的内存消耗有多少？
3. 我们能缓存多少个大型对象？

当然，要回答这些问题，您需要了解应用程序的缓存对象。**现在：如何转储密钥？** 可以使用“stats cachedump”命令按slabs类别转储密钥。
```
stats cachedump <slab class> <number of items to dump>
```
要在类别#1中转储我们的单个键，请运行以下命令：
```
stats cachedump 1 1000
ITEM mykey [1 b; 1350677968 s]
END
```
“cachedump” 每行返回一个项目。花括号中的第一个数字表示字节大小，第二个数字表示创建的时间戳。现在，根据键名，您还可以使用“cachedump”来转储其值。
```
get mykey
VALUE mykey 0 1
1
END
```
这就是它：遍历所有你想要的slab类，提取键名，如果需要，转储其内容。

### **转储MEMCACHE键（版本1.4.31+）**

在memcache版本1.4.31及以上版本中，有一种新的命令可以以非阻塞模式转储内存键（请阅读https://github.com/memcached/memcached/wiki/ReleaseNotes1431）。这种方法在生产环境中运行是安全的。输出不一致，但足够好以找到键、它们的确切过期时间（EXP）和最后访问时间（LA）。由于生成的输出非常庞大，建议使用'nc'命令。示例：
```
echo 'lru_crawler metadump all' | nc 127.0.0.1 11211 | head -1
key=0dLLX%253Amemcache_test_key exp=1590718787 la=1590718487 cas=2238881166 fetch=yes

echo 'lru_crawler metadump all' | nc 127.0.0.1 11211 | grep ee6ba58566e234ccbbce13f9a24f9a28
key=VQRFX%253Aee6ba58566e234ccbbce13f9a24f9a28 exp=-1 la=1590386157 cas=1776204003 fetch=yes
key=0dLLX%253Aee6ba58566e234ccbbce13f9a24f9a28 exp=-1 la=1590712292 cas=2225524871 fetch=yes
```
EXP=-1 表示该项永不过期 EXP=1590718787 (Fri May 29 02:19:47 GMT 2020) 保留了该项应该过期的Unix时间戳 LA=1590712292 (Mon May 25 05:55:57 GMT 2020) 保留了上次访问该项的Unix时间戳

### **转储工具**

有一些不同的转储工具或脚本可以帮助你打印memcache的键：

| 编程语言 | 工具                                                                                                                              | 功能                                                                                                                                                                   |                                                                             |         |
| -------- | --------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------- | ------- |
| PHP      | [简单脚本](http://snipt.org/xtP)                                                                                              | 打印键名                                                                                                                                                               |                                                                             |         |
| Perl     | [简单脚本](https://wiki.jasig.org/download/attachments/13572172/memcached-clean.pl?version=1\&modificationDate=1229693957401) | 打印键和值                                                                                                                                                             |                                                                             |         |
| Ruby     | [简单脚本](https://gist.github.com/1365005)                                                                                   | 打印键名                                                                                                                                                               |                                                                             |         |
| Perl     | [memdump](https://search.cpan.org/\~dmaki/Memcached-libmemcached-0.4202/src/libmemcached/docs/memdump.pod)                         | CPAN模块中的工具                                                                                                                                                        | [Memcached-libmemcached](https://search.cpan.org/\~dmaki/Memcached-libmemc) | ached/) |
| PHP      | [memcache.php](http://livebookmark.net/journal/2008/05/21/memcachephp-stats-like-apcphp/)                                          | Memcache监控GUI，还允许转储键                                                                                                                                         |                                                                             |         |
| libmemcached          | [peep](http://blog.evanweaver.com/2009/04/20/peeping-into-memcached/)                                                              | **会冻结你的memcached进程！！！** 在生产环境中使用时要小心。尽管如此，你仍然可以绕过1MB的限制，真正转储**所有**的键。 |                                                                             |         |

## 故障排除 <a href="#troubleshooting" id="troubleshooting"></a>

### 1MB数据限制 <a href="#1mb-data-limit" id="1mb-data-limit"></a>

请注意，在memcached 1.4之前，由于默认的最大slab大小，您无法存储大于1MB的对象。

### 永不设置超时 > 30天！ <a href="#never-set-a-timeout--30-days" id="never-set-a-timeout--30-days"></a>

如果您尝试使用超过允许的最大超时时间来“set”或“add”一个键，您可能得不到您期望的结果，因为memcached会将该值视为Unix时间戳。此外，如果时间戳在过去，它将不会执行任何操作。您的命令将悄无声息地失败。

因此，如果您想使用最大的生存时间，请指定2592000。示例：
```
set my_key 0 2592000 1
1
```
### 溢出时键值消失 <a href="#disappearing-keys-on-overflow" id="disappearing-keys-on-overflow"></a>

尽管文档中提到64位溢出时使用“incr”会导致值消失，但需要使用“add”/“set”重新创建。

### 复制 <a href="#replication" id="replication"></a>

memcached本身不支持复制。如果确实需要，需要使用第三方解决方案：

* [repcached](http://repcached.lab.klab.org/)：多主异步复制（memcached 1.2补丁集）
* [Couchbase memcached接口](http://www.couchbase.com/memcached)：将CouchBase用作memcached替代品
* [yrmcds](https://cybozu.github.io/yrmcds/)：与memcached兼容的主从键值存储
* [twemproxy](https://github.com/twitter/twemproxy)（又名nutcracker）：带有memcached支持的代理

### 命令速查表

{% content-ref url="memcache-commands.md" %}
[memcache-commands.md](memcache-commands.md)
{% endcontent-ref %}

### **Shodan**

* `port:11211 "STAT pid"`
* `"STAT pid"`

## 参考资料

* [https://lzone.de/cheat-sheet/memcached](https://lzone.de/cheat-sheet/memcached)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 您在**网络安全公司**工作吗？您想在HackTricks中看到您的**公司广告**吗？或者您想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享您的黑客技巧。**

</details>
