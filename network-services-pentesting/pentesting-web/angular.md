# एंगुलर

## चेकलिस्ट

सत्यापित करें कि:

* [ ] एंगुलर को क्लाइंट-साइड फ्रेमवर्क माना जाता है और सर्वर-साइड सुरक्षा प्रदान करने की उम्मीद नहीं होती है
* [ ] प्रोजेक्ट कॉन्फ़िगरेशन में स्क्रिप्ट के लिए स्रोतमानचित्र अक्षम है
* [ ] अविश्वसनीय उपयोगकर्ता इनपुट हमेशा टेम्पलेट में उपयोग किए जाने से पहले इंटरपोलेटेड या सैनिटाइज़ किया जाता है
* [ ] उपयोगकर्ता को सर्वर-साइड या क्लाइंट-साइड टेम्पलेट पर कोई नियंत्रण नहीं होता है
* [ ] अविश्वसनीय उपयोगकर्ता इनपुट को अनुपयुक्त सुरक्षा संदर्भ का उपयोग करके सैनिटाइज़ किया जाता है जो एप्लिकेशन द्वारा विश्वसनीय माना जाता है
* [ ] `BypassSecurity*` विधियों का अनुवाद अविश्वसनीय इनपुट के साथ नहीं किया जाता है
* [ ] अविश्वसनीय उपयोगकर्ता इनपुट को एंगुलर क्लासेज़ जैसे `ElementRef`, `Renderer2` और `Document`, या अन्य JQuery/DOM सिंक्स में नहीं पास किया जाता है

## एंगुलर क्या है

एंगुलर एक शक्तिशाली फ्रंट-एंड फ्रेमवर्क है जो डायनामिक वेब ऐप्लिकेशन बनाने के लिए व्यापक रूप से उपयोग किया जाता है। यह ओपन-सोर्स है और गूगल द्वारा रखरखाव किया जाता है। एंगुलर की एक मुख्य विशेषता है कि यह टाइपस्क्रिप्ट का उपयोग करता है, जो जावास्क्रिप्ट का एक टाइप्ड सुपरसेट है जो कोड को पढ़ने, रखने और बग सुधारने में सुविधा प्रदान करता है।

एंगुलर की सुरक्षा यातायात को रोकने के लिए डिज़ाइन की गई है, जिसमें क्रॉस-साइट स्क्रिप्टिंग (XSS) और खुले रीडायरेक्ट्स जैसी सामान्य क्लाइंट-साइड सुरक्षा खतरों को रोका जाता है। हालांकि, एंगुलर को स्टेटिक पेज उत्पन्न करने के लिए सर्वर-साइड पर भी उपयोग किया जा सकता है। इसलिए, एंगुलर की सुरक्षा को दोनों दिशाओं से विचार किया जाना चाहिए।

## फ्रेमवर्क आर्किटेक्चर

एंगुलर की मूल अवधारणाओं को बेहतर समझने के लिए, चलो इसके महत्वपूर्ण अवधारणाओं के माध्यम से जाएं।

सामान्य एंगुलर प्रोजेक्ट आमतौर पर इस तरह दिखता है:
```bash
my-workspace/
├── ... #workspace-wide configuration files
├── src
│   ├── app
│   │   ├── app.module.ts #defines the root module, that tells Angular how to assemble the application
│   │   ├── app.component.ts #defines the logic for the application's root component
│   │   ├── app.component.html #defines the HTML template associated with the root component
│   │   ├── app.component.css #defines the base CSS stylesheet for the root component
│   │   ├── app.component.spec.ts #defines a unit test for the root component
│   │   └── app-routing.module.ts #provides routing capability for the application
│   ├── lib
│   │   └── src #library-specific configuration files
│   ├── index.html #main HTML page, where the component will be rendered in
│   └── ... #application-specific configuration files
├── angular.json #provides workspace-wide and project-specific configuration defaults
└── tsconfig.json #provides the base TypeScript configuration for projects in the workspace
```
संदर्भ के अनुसार, हर Angular एप्लिकेशन में कम से कम एक कंपोनेंट होता है, जो एक कंपोनेंट हायरार्की को DOM के साथ जोड़ता है। प्रत्येक कंपोनेंट एक कक्षा को परिभाषित करता है जिसमें एप्लिकेशन डेटा और तर्क होता है, और इसके साथ एक HTML टेम्पलेट जुड़ा होता है जो एक टारगेट परिवेश में प्रदर्शित करने के लिए एक दृश्य को परिभाषित करता है। `@Component()` डेकोरेटर उस कक्षा को एक कंपोनेंट के रूप में पहचानता है, और टेम्पलेट और संबंधित कंपोनेंट-विशिष्ट मेटाडेटा प्रदान करता है। `AppComponent` को `app.component.ts` फ़ाइल में परिभाषित किया जाता है।

Angular NgModules एक संग्रह के लिए एक संकलन संदर्भ प्रदान करते हैं जो एक एप्लिकेशन डोमेन, एक कार्यप्रवाह या एक संबंधित क्षमता सेट के लिए समर्पित होता है। हर Angular एप्लिकेशन में एक रूट मॉड्यूल होता है, जिसे सामान्यतः `AppModule` नामित किया जाता है, जो एप्लिकेशन को लॉन्च करने के लिए बूटस्ट्रैप मेकेनिज़्म प्रदान करता है। एक एप्लिकेशन में सामान्यतः कई कार्यात्मक मॉड्यूल होते हैं। `AppModule` को `app.module.ts` फ़ाइल में परिभाषित किया जाता है।

Angular `Router` NgModule एक सेवा प्रदान करता है जिसके माध्यम से आप अपने एप्लिकेशन में विभिन्न स्थितियों और दृश्य हायरार्कीयों के बीच नेविगेशन पथ परिभाषित कर सकते हैं। `RouterModule` को `app-routing.module.ts` फ़ाइल में परिभाषित किया जाता है।

एक व्यू से जुड़े नहीं होने वाले डेटा या तर्क के लिए, और जिसे आप कंपोनेंट के बीच साझा करना चाहते हैं, आप एक सेवा कक्षा बनाते हैं। एक सेवा कक्षा परिभाषा के तत्काल पहले `@Injectable()` डेकोरेटर के द्वारा प्राप्त होती है। डेकोरेटर उन मेटाडेटा प्रदान करता है जो अन्य प्रदाताओं को आपकी कक्षा में निर्भरता के रूप में इंजेक्शन करने की अनुमति देता है। डिपेंडेंसी इंजेक्शन (DI) आपको अपनी कंपोनेंट कक्षाओं को पतला और कुशल रखने की अनुमति देता है। वे सर्वर से डेटा नहीं लाते, उपयोगकर्ता इनपुट को मान्यता प्रदान नहीं करते, या सीधे कंसोल में लॉग नहीं करते हैं; वे ऐसे कार्यों को सेवाओं को सौंपते हैं।

## सोर्समैप कॉन्फ़िगरेशन

Angular फ़्रेमवर्क `tsconfig.json` विकल्पों का पालन करके TypeScript फ़ाइलों को JavaScript कोड में अनुवादित करता है और फिर `angular.json` कॉन्फ़िगरेशन के साथ एक परियोजना बनाता है। `angular.json` फ़ाइल को देखते हुए, हमने एक सोर्समैप को सक्षम या अक्षम करने का विकल्प देखा है। Angular दस्तावेज़ीकरण के अनुसार, डिफ़ॉल्ट कॉन्फ़िगरेशन में स्क्रिप्ट के लिए एक सोर्समैप फ़ाइल सक्षम होती है और डिफ़ॉल्ट रूप से छिपी हुई नहीं होती है:
```json
"sourceMap": {
"scripts": true,
"styles": true,
"vendor": false,
"hidden": false
}
```
सामान्यतः, स्रोतमानचित्र फ़ाइलें डिबगिंग के उद्देश्यों के लिए उपयोग की जाती हैं क्योंकि वे उत्पन्न फ़ाइलों को उनकी मूल फ़ाइलों से मैप करती हैं। इसलिए, इन्हें उत्पादन वातावरण में उपयोग करना सिफारिश नहीं की जाती है। यदि स्रोतमानचित्र सक्षम हैं, तो यह अंगुलर परियोजना की मूल स्थिति की प्रतिलिपि बनाकर पठनीयता में सुधार करता है और फ़ाइल विश्लेषण में मदद करता है। हालांकि, यदि वे अक्षम हैं, तो समीक्षक एंटी-सुरक्षा पैटर्न की खोज करके कंपाइल किए गए जावास्क्रिप्ट फ़ाइल का मैन्युअल विश्लेषण कर सकता है।

इसके अलावा, एंगुलर परियोजना के साथ एक कंपाइल किए गए जावास्क्रिप्ट फ़ाइल को ब्राउज़र डेवलपर टूल → स्रोत (या डीबगर और स्रोत) → \[id].main.js में पाया जा सकता है। सक्षम विकल्पों पर निर्भर करता है, इस फ़ाइल में निम्नलिखित पंक्ति हो सकती है `//# sourceMappingURL=[id].main.js.map` या यदि **छिपा हुआ** विकल्प को **सत्य** में सेट किया गया है तो नहीं। फिर भी, यदि **स्क्रिप्ट** के लिए स्रोतमानचित्र अक्षम हैं, तो परीक्षण अधिक जटिल हो जाता है और हम फ़ाइल प्राप्त नहीं कर सकते हैं। इसके अलावा, परियोजना निर्माण के दौरान स्रोतमानचित्र को सक्षम किया जा सकता है जैसे `ng build --source-map`।

## डेटा बाइंडिंग

बाइंडिंग संबंधित एक कॉम्पोनेंट और उसके संबंधित दृश्य के बीच संचार की प्रक्रिया को संदर्भित करता है। इसका उपयोग अंगुलर फ़्रेमवर्क के साथ डेटा को भेजने और प्राप्त करने के लिए किया जाता है। डेटा को विभिन्न तरीकों से पारित किया जा सकता है, जैसे कि इवेंट्स, इंटरपोलेशन, प्रॉपर्टीज़, या दो-तरफ़ा बाइंडिंग मेकेनिज़म के माध्यम से। इसके अलावा, डेटा को सेवा फ़ीचर का उपयोग करके संबंधित कॉम्पोनेंट (माता-पुत्र संबंध) और दो असंबंधित कॉम्पोनेंटों के बीच साझा किया जा सकता है।

हम डेटा बाइंडिंग को डेटा प्रवाह द्वारा वर्गीकृत कर सकते हैं:

* डेटा स्रोत से दृश्य लक्ष्य (इंटरपोलेशन, प्रॉपर्टीज़, गुण, और शैलियाँ); टेम्पलेट में `[]` या `{{}}` का उपयोग करके लागू किया जा सकता है;
* दृश्य लक्ष्य से डेटा स्रोत (इवेंट्स); टेम्पलेट में `()` का उपयोग करके लागू किया जा सकता है;
* दो-तरफ़ा; टेम्पलेट में `[()]` का उपयोग करके लागू किया जा सकता है।

बाइंडिंग को प्रॉपर्टीज़, इवेंट्स, और गुणों पर, साथ ही स्रोत निर्देशिका के किसी भी सार्वजनिक सदस्य पर लागू किया जा सकता है:

| प्रकार     | लक्ष्य                                                   | उदाहरण                                                              |
| --------- | -------------------------------------------------------- | -------------------------------------------------------------------- |
| प्रॉपर्टी  | तत्व प्रॉपर्टी, कॉम्पोनेंट प्रॉपर्टी, निर्देशिका प्रॉपर्टी | \<img \[alt]="hero.name" \[src]="heroImageUrl">                      |
| इवेंट     | तत्व इवेंट, कॉम्पोनेंट इवेंट, निर्देशिका इवेंट          | \<button type="button" (click)="onSave()">Save                       |
| दो-तरफ़   | इवेंट और प्रॉपर्टी                                       | \<input \[(ngModel)]="name">                                         |
| गुण       | गुण प्रॉपर्टी                                           | \<div \[class.special]="isSpecial">Special                           |
| शैली     | शैली प्रॉपर्टी                                           | \<button type="button" \[style.color]="isSpecial ? 'red' : 'green'"> |

## अंगु
### HTML इंजेक्शन

यह सुरक्षा कमजोरी उत्पन्न होती है जब उपयोगकर्ता इनपुट को तीन गुणों में से किसी भी गुण: `innerHTML`, `outerHTML`, या `iframe` `srcdoc` से बांधता है। जबकि इन गुणों को बांधने से HTML को वैसे ही अनुवादित किया जाता है, इनपुट `SecurityContext.HTML` का उपयोग करके सेनेटाइज किया जाता है। इस प्रकार, HTML इंजेक्शन संभव होता है, लेकिन क्रॉस-साइट स्क्रिप्टिंग (XSS) नहीं होती है।

`innerHTML` का उपयोग करने का उदाहरण:
```jsx
//app.component.ts
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html'
})
export class AppComponent{
//define a variable with user input
test = "<script>alert(1)</script><h1>test</h1>";
}

//app.component.html
<div [innerHTML]="test"></div>
```
परिणाम `<div><h1>test</h1></div>` है।

### टेम्पलेट इंजेक्शन

#### क्लाइंट-साइड रेंडरिंग (CSR)

एंगुलर टेम्पलेट का उपयोग पृष्ठों को गतिशील रूप से निर्माण करने के लिए करता है। इस दृष्टिकोण में, एंगुलर को मूल्यांकन के लिए टेम्पलेट व्यक्तियों को दोहरी कर्वी ब्रैकेट (`{{}}`) में बंद करना होता है। इस तरीके से, फ्रेमवर्क अतिरिक्त कार्यक्षमता प्रदान करता है। उदाहरण के लिए, एक टेम्पलेट जैसे `{{1+1}}` 2 के रूप में प्रदर्शित होगा।

सामान्यतः, एंगुलर उपयोगकर्ता इनपुट को टेम्पलेट व्यक्तियों के साथ गलतफहमी कर सकता है (जैसे कि \`< > ' " \`\` इत्यादि वर्ण।) इसका मतलब है कि इस प्रतिबंध को दूर करने के लिए अतिरिक्त कदम आवश्यक होते हैं, जैसे कि काले सूचीबद्ध वर्णों का उपयोग न करने के लिए जावास्क्रिप्ट स्ट्रिंग ऑब्जेक्ट उत्पन्न करने वाले फ़ंक्शनों का उपयोग करना। हालांकि, इसे प्राप्त करने के लिए, हमें एंगुलर संदर्भ, इसकी गुणधर्मों और चरों को ध्यान में रखना चाहिए। इसलिए, टेम्पलेट इंजेक्शन हमला निम्नलिखित रूप में दिखाई दे सकता है:
```jsx
//app.component.ts
const _userInput = '{{constructor.constructor(\'alert(1)\'()}}'
@Component({
selector: 'app-root',
template: '<h1>title</h1>' + _userInput
})
```
ऊपर दिखाए गए तरीके से: `constructor` वस्तु के `constructor` संपत्ति के दायरे को संदर्भित करता है, जिससे हम स्ट्रिंग कंस्ट्रक्टर को आह्वान कर सकते हैं और एक अनियमित कोड को निष्पादित कर सकते हैं।

#### सर्वर-साइड रेंडरिंग (SSR)

CSR के विपरीत, जो ब्राउज़र के DOM में होता है, एंगुलर यूनिवर्सल टेम्पलेट फ़ाइलों के SSR के लिए जिम्मेदार होता है। ये फ़ाइलें फिर उपयोगकर्ता को डिलीवर की जाती हैं। इस अंतर के बावजूद, एंगुलर यूनिवर्सल CSR में उपयोग की जाने वाली स्वच्छीकरण युक्तियों का उपयोग करता है ताकि SSR सुरक्षा को बढ़ावा मिल सके। SSR में टेम्पलेट इंजेक्शन संबंधी एक सुरक्षा संकट को CSR में जैसे ही पहचाना जा सकता है, क्योंकि इस्तेमाल की जाने वाली टेम्पलेट भाषा एक ही होती है।

बेशक, तीसरे पक्ष के टेम्पलेट इंजन जैसे Pug और Handlebars का उपयोग करते समय नए टेम्पलेट इंजेक्शन संकट को प्रवेश कराने की संभावना भी होती है।

### XSS

#### DOM इंटरफ़ेस

पहले ही कहा गया है कि हम डॉम का सीधा उपयोग करके _डॉक्यूमेंट_ इंटरफ़ेस का उपयोग कर सकते हैं। यदि उपयोगकर्ता इनपुट पहले सत्यापित नहीं किया जाता है, तो यह क्रॉस-साइट स्क्रिप्टिंग (XSS) संकट का कारण बन सकता है।

हमने नीचे दिए गए उदाहरणों में `document.write()` और `document.createElement()` विधियों का उपयोग किया है:
```jsx
//app.component.ts 1
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
template: ''
})
export class AppComponent{
constructor () {
document.open();
document.write("<script>alert(document.domain)</script>");
document.close();
}
}

//app.component.ts 2
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
template: ''
})
export class AppComponent{
constructor () {
var d = document.createElement('script');
var y = document.createTextNode("alert(1)");
d.appendChild(y);
document.body.appendChild(d);
}
}

//app.component.ts 3
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
template: ''
})
export class AppComponent{
constructor () {
var a = document.createElement('img');
a.src='1';
a.setAttribute('onerror','alert(1)');
document.body.appendChild(a);
}
}
```
#### Angular कक्षाएं

Angular में DOM तत्वों के साथ काम करने के लिए कुछ कक्षाएं होती हैं: `ElementRef`, `Renderer2`, `Location` और `Document`. आखिरी दो कक्षों का विस्तृत वर्णन **ओपन रीडायरेक्ट्स** अनुभाग में दिया गया है। पहले दो कक्षों के बीच मुख्य अंतर है कि `Renderer2` API DOM तत्व और कंपोनेंट कोड के बीच एक अवस्था का अवसर प्रदान करता है, जबकि `ElementRef` केवल तत्व के संदर्भ को रखता है। इसलिए, Angular दस्तावेज़ीकरण के अनुसार, `ElementRef` API का उपयोग केवल तब ही करना चाहिए जब DOM का सीधा पहुंच आवश्यक हो।

*   `ElementRef` में `nativeElement` गुण होता है, जिसका उपयोग DOM तत्वों को प्रबंधित करने के लिए किया जा सकता है। हालांकि, `nativeElement` का गलत उपयोग XSS अंश में एक संक्रमण सुरक्षा कमजोरी का परिणाम दे सकता है, जैसा कि नीचे दिखाया गया है:

```tsx
//app.component.ts
import { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {
...
constructor(private elementRef: ElementRef) {
const s = document.createElement('script');
s.type = 'text/javascript';
s.textContent = 'alert("Hello World")';
this.elementRef.nativeElement.appendChild(s);
}
}
```
*   `Renderer2` अपेक्षाकृत उन DOM तत्वों पर विशेषताओं को सेट करने के लिए `setAttribute()` विधि का उपयोग करके किया जा सकता है, जिनमें XSS रोकने के योजना नहीं होती है।

```tsx
//app.component.ts
import {Component, Renderer2, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {

public constructor (
private renderer2: Renderer2
){}
@ViewChild("img") img!: ElementRef;

addAttribute(){
this.renderer2.setAttribute(this.img.nativeElement, 'src', '1');
this.renderer2.setAttribute(this.img.nativeElement, 'onerror', 'alert(1)');
}
}

//app.component.html
<img #img>
<button (click)="setAttribute()">Click me!</button>
```
*   DOM तत्व की संपत्ति सेट करने के लिए, आप `Renderer2.setProperty()` विधि का उपयोग कर सकते हैं और XSS हमला ट्रिगर कर सकते हैं:

```tsx
//app.component.ts
import {Component, Renderer2, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {

public constructor (
private renderer2: Renderer2
){}
@ViewChild("img") img!: ElementRef;

setProperty(){
this.renderer2.setProperty(this.img.nativeElement, 'innerHTML', '<img src=1 onerror=alert(1)>');
}
}

//app.component.html
<a #a></a>
<button (click)="setProperty()">Click me!</button>
```

हमारे अनुसंधान के दौरान, हमने अन्य `Renderer2` विधियों के व्यवहार का भी परीक्षण किया, जैसे `setStyle()`, `createComment()`, और `setValue()`, XSS और CSS संक्रमणों के संबंध में। हालांकि, हमें इन विधियों के लिए कोई वैध हमला वेक्टर नहीं मिला क्योंकि उनकी कार्यात्मक सीमाओं के कारण।

#### jQuery

jQuery एक तेज, छोटा और सुविधाजनक JavaScript पुस्तकालय है जिसका उपयोग Angular परियोजना में HTML DOM ऑब्जेक्ट को मानिपुरेट करने में मदद करने के लिए किया जा सकता है। हालांकि, जैसा कि ज्ञात है, इस पुस्तकालय की विधियों का उपयोग XSS संक्रमण प्राप्त करने के लिए किया जा सकता है। कुछ संक्रमणशील jQuery विधियों को Angular परियोजनाओं में कैसे उपयोग किया जा सकता है, इसे चर्चा करने के लिए हमने इस उपअनुच्छेद को जोड़ा।

*   `html()` विधि संबंधित तत्वों के सेट के प्रत्येक मिले हुए तत्व के HTML सामग्री को प्राप्त करती है या सेट करती है। हालांकि, डिज़ाइन के अनुसार, किसी भी jQuery निर्माणकर्ता या विधि को जो HTML स्ट्रिंग स्वीकार करता है, संभावित रूप से कोड को क्रियान्वित कर सकता है। यह `<script>` टैग के संक्रमण द्वारा या कोड को क्रियान्वित करने वाले HTML गुणों के उपयोग द्वारा हो सकता है, जैसा कि नीचे दिखाया गया है।

```tsx
//app.component.ts
import { Component, OnInit } from '@angular/core';
import * as $ from 'jquery';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit
{
ngOnInit()
{
$("button").on("click", function()
{
$("p").html("<script>alert(1)</script>");
});
}
}

//app.component.html
<button>Click me</button>
<p>some text here</p>
```
*   `jQuery.parseHTML()` विधि निम्नलिखित प्रकार से स्ट्रिंग को DOM नोड के सेट में बदलने के
#### Angular क्लासेस

*   Angular दस्तावेज़ीकरण के अनुसार, Angular `Document` DOM दस्तावेज़ के समान है, जिसका मतलब है कि Angular में क्लाइंट-साइड सुरक्षा की कमजोरियों को शोधने के लिए DOM दस्तावेज़ के लिए सामान्य वेक्टर का उपयोग किया जा सकता है। `Document.location` गुण और विधियाँ सफल ओपन रीडायरेक्ट हमलों के लिए सिंक्स हो सकती हैं, जैसा कि निम्न उदाहरण में दिखाया गया है:

```tsx
//app.component.ts
import { Component, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {
constructor(@Inject(DOCUMENT) private document: Document) { }

goToUrl(): void {
this.document.location.href = 'https://google.com/about';
}
}

//app.component.html
<button type="button" (click)="goToUrl()">Click me!</button>
```
*   अनुसंधान चरण के दौरान, हमने ओपन रीडायरेक्ट सुरक्षा के लिए Angular `Location` क्लास की भी समीक्षा की, लेकिन कोई वैध वेक्टर नहीं मिला। `Location` एक Angular सेवा है जिसका उपयोग एक ब्राउज़र के मौजूदा URL के साथ संवाद करने के लिए एप्लिकेशन कर सकता है। इस सेवा में कई विधियाँ हैं जो दिए गए URL को संशोधित करने के लिए उपयोग कर सकती हैं - `go()` , `replaceState()`, और `prepareExternalUrl()`। हालांकि, हम उन्हें बाहरी डोमेन पर पुनर्निर्देशित करने के लिए उपयोग नहीं कर सकते। उदाहरण के लिए:

```tsx
//app.component.ts
import { Component, Inject } from '@angular/core';
import {Location, LocationStrategy, PathLocationStrategy} from '@angular/common';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css'],
providers: [Location, {provide: LocationStrategy, useClass: PathLocationStrategy}],
})
export class AppComponent {
location: Location;
constructor(location: Location) {
this.location = location;
}
goToUrl(): void {
console.log(this.location.go("http://google.com/about"));
}
}
```

परिणाम: `http://localhost:4200/http://google.com/about`
*   Angular `Router` क्लास प्राथमिक रूप से एक ही डोमेन के भीतर नेविगेट करने के लिए उपयोग किया जाता है और एप्लिकेशन में कोई अतिरिक्त सुरक्षा कमजोरी प्रविष्ट नहीं करता है:

```jsx
//app-routing.module.ts
const routes: Routes = [
{ path: '', redirectTo: 'https://google.com', pathMatch: 'full' }]
```

परिणाम: `http://localhost:4200/https:`

निम्नलिखित विधियाँ भी डोमेन की सीमा के भीतर नेविगेट करती हैं:

```jsx
const routes: Routes = [ { path: '', redirectTo: 'ROUTE', pathMatch: 'prefix' } ]
this.router.navigate(['PATH'])
this.router.navigateByUrl('URL')
```

## संदर्भ

* [Angular](https://angular.io/)
* [Angular सुरक्षा: निर्दिष्ट गाइड (भाग 1)](https://lsgeurope.com/post/angular-security-the-definitive-guide-part-1)
* [Angular सुरक्षा: निर्दिष्ट गाइड (भाग 2)](https://lsgeurope.com/post/angular-security-the-definitive-guide-part-2)
* [Angular सुरक्षा: निर्दिष्ट गाइड (भाग 3)](https://lsgeurope.com/post/angular-security-the-definitive-guide-part-3)
* [Angular सुरक्षा: चेकलिस्ट](https://lsgeurope.com/post/angular-security-checklist)
* [Workspace और परियोजना फ़ाइल संरचना](https://angular.io/guide/file-structure)
* [Components और Templates का परिचय](https://angular.io/guide/architecture-components)
* [स्रोत मानचित्र समाकृति](https://angular.io/guide/workspace-config#source-map-configuration)
* [बाइंडिंग वाक्यांश](https://angular.io/guide/binding-syntax)
* [Angular संदर्भ: नेस्टेड कंपोनेंट ट्रीज़ और राउटर आउटलेट के लिए आसान डेटा-बाइंडिंग](https://medium.com/angular-in-depth/angular-context-easy-data-binding-for-nested-component-trees-and-the-router-outlet-a977efacd48)
* [सैनिटाइज़ेशन और सुरक्षा संदर्भ](https://angular.io/guide/security#sanitization-and-security-contexts)
* [GitHub - angular/dom\_security\_schema.ts](https://github.com/angular/angular/blob/main/packages/compiler/src/schema/dom\_security\_schema.ts)
* [Angular और AngularJS में XSS](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/XSS%20in%20Angular.md)
* [Angular Universal](https://angular.io/guide/universal)
* [DOM XSS](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-xss)
* [Angular ElementRef](https://angular.io/api/core/ElementRef)
* [Angular Renderer2](https://angular.io/api/core/Renderer2)
* [Renderer2 उदाहरण: Angular में DOM को संशोधित करना - TekTutorialsHub](https://www.tektutorialshub.com/angular/renderer2-angular/)
* [jQuery API दस्तावेज़ीकरण](http://api.jquery.com/)
* [Angular के साथ jQuery का उपयोग कैसे करें (जब आपको बिलकुल करना हो)](https://blog.bitsrc.io/how-to-use-jquery-with-angular-when-you-absolutely-have-to-42c8b6a37ff9)
* [Angular दस्तावेज़](https://angular.io/api/common/DOCUMENT)
* [Angular स्थान](https://angular.io/api/common/Location)
* [Angular राउटर](https://angular.io/api/router/Router)
