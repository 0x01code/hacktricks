# Flask

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[NFTs](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

<figure><img src="../../.gitbook/assets/image (9) (1) (2).png" alt=""><figcaption></figcaption></figure>

使用[**Trickest**](https://trickest.io/)可以轻松构建和**自动化工作流程**，使用世界上**最先进的**社区工具。\
立即获取访问权限：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

**如果你在玩CTF，Flask应用可能与**[**SSTI**](../../pentesting-web/ssti-server-side-template-injection/)**相关。**

## Cookies

默认的cookie会话名称是**`session`**。

### 解码器

在线Flask cookie解码器：[https://www.kirsle.net/wizards/flask-session.cgi](https://www.kirsle.net/wizards/flask-session.cgi)

#### 手动

获取cookie的第一部分，直到第一个点，并对其进行Base64解码>
```bash
echo "ImhlbGxvIg" | base64 -d
```
cookie也使用密码进行签名

### **Flask-Unsign**

命令行工具，通过猜测秘钥，获取、解码、暴力破解和构造Flask应用程序的会话cookie。

{% embed url="https://pypi.org/project/flask-unsign/" %}
```bash
pip3 install flask-unsign
```
#### **解码 Cookie**

To decode a Flask session cookie, you can use the `itsdangerous` library. This library provides a `URLSafeTimedSerializer` class that can be used to decode and encode cookies.

Here is an example of how to decode a Flask session cookie:

```python
from itsdangerous import URLSafeTimedSerializer

def decode_cookie(cookie_value, secret_key):
    serializer = URLSafeTimedSerializer(secret_key)
    try:
        decoded_data = serializer.loads(cookie_value)
        return decoded_data
    except Exception as e:
        print(f"Error decoding cookie: {e}")
        return None
```

In the above code, the `decode_cookie` function takes the cookie value and the secret key as parameters. It creates an instance of the `URLSafeTimedSerializer` class with the secret key. Then, it tries to decode the cookie using the `loads` method of the serializer. If decoding is successful, it returns the decoded data. If an error occurs during decoding, it prints an error message and returns `None`.

Remember to replace `secret_key` with the actual secret key used in your Flask application.

#### **解码 Cookie**

要解码 Flask 会话 cookie，可以使用 `itsdangerous` 库。该库提供了一个 `URLSafeTimedSerializer` 类，可用于解码和编码 cookie。

以下是解码 Flask 会话 cookie 的示例：

```python
from itsdangerous import URLSafeTimedSerializer

def decode_cookie(cookie_value, secret_key):
    serializer = URLSafeTimedSerializer(secret_key)
    try:
        decoded_data = serializer.loads(cookie_value)
        return decoded_data
    except Exception as e:
        print(f"解码 cookie 出错：{e}")
        return None
```

在上述代码中，`decode_cookie` 函数接受 cookie 值和密钥作为参数。它使用密钥创建 `URLSafeTimedSerializer` 类的实例。然后，它尝试使用序列化器的 `loads` 方法解码 cookie。如果解码成功，它返回解码后的数据。如果在解码过程中发生错误，它会打印错误消息并返回 `None`。

记得将 `secret_key` 替换为实际在 Flask 应用中使用的密钥。
```bash
flask-unsign --decode --cookie 'eyJsb2dnZWRfaW4iOmZhbHNlfQ.XDuWxQ.E2Pyb6x3w-NODuflHoGnZOEpbH8'
```
#### **暴力破解**

Brute force is a common technique used in hacking to gain unauthorized access to a system or account by systematically trying all possible combinations of passwords until the correct one is found. It is a time-consuming method but can be effective if the password is weak or easily guessable. 

暴力破解是一种常见的黑客技术，通过系统地尝试所有可能的密码组合，直到找到正确的密码，从而获取未经授权的系统或账户访问权限。这是一种耗时的方法，但如果密码弱或容易猜测，它可以取得效果。
```bash
flask-unsign --wordlist /usr/share/wordlists/rockyou.txt --unsign --cookie '<cookie>' --no-literal-eval
```
#### **签名**

Signing is a process used to verify the integrity and authenticity of data. In the context of web applications, signing is often used to ensure that data sent between the client and the server has not been tampered with.

签名是一种用于验证数据完整性和真实性的过程。在Web应用程序的上下文中，签名通常用于确保在客户端和服务器之间发送的数据没有被篡改。

When signing data, a cryptographic algorithm is used to generate a unique signature for the data. This signature is then attached to the data and sent along with it. On the receiving end, the signature is verified using the same algorithm and a secret key. If the signature matches the data, it means that the data has not been modified since it was signed and that it originated from a trusted source.

在签名数据时，使用加密算法为数据生成一个唯一的签名。然后，将此签名附加到数据并与其一起发送。在接收端，使用相同的算法和秘密密钥验证签名。如果签名与数据匹配，则意味着数据自签名以来没有被修改，并且源自可信任的来源。

Flask provides a built-in mechanism for signing data using the `itsdangerous` library. This library allows you to generate secure signatures that can be used to verify the integrity of data.

Flask提供了使用`itsdangerous`库对数据进行签名的内置机制。该库允许您生成安全的签名，用于验证数据的完整性。

To sign data in Flask, you first need to create a `Signer` object using a secret key. This secret key should be kept confidential, as it is used to generate and verify the signatures.

在Flask中对数据进行签名，首先需要使用秘密密钥创建一个`Signer`对象。这个秘密密钥应该保密，因为它用于生成和验证签名。

Once you have a `Signer` object, you can use its `sign()` method to generate a signature for your data. This method takes the data as input and returns the signature as a string.

一旦有了`Signer`对象，就可以使用其`sign()`方法为数据生成签名。此方法以数据作为输入，并将签名作为字符串返回。

To verify a signature, you can use the `Signer` object's `unsign()` method. This method takes the data and the signature as input and returns the original data if the signature is valid. If the signature is invalid or has been tampered with, an exception will be raised.

要验证签名，可以使用`Signer`对象的`unsign()`方法。此方法以数据和签名作为输入，并在签名有效时返回原始数据。如果签名无效或被篡改，将引发异常。

Signing is a useful technique for ensuring the integrity and authenticity of data in web applications. By using signatures, you can detect if data has been modified during transit and verify that it came from a trusted source.

签名是Web应用程序中确保数据完整性和真实性的有用技术。通过使用签名，您可以检测数据在传输过程中是否被修改，并验证其来自可信任的来源。
```bash
flask-unsign --sign --cookie "{'logged_in': True}" --secret 'CHANGEME'
```
#### 使用传统方式进行签名（旧版本）

In older versions of Flask, the `signing` module was used to sign data. This module provides a way to ensure the integrity and authenticity of data by appending a cryptographic signature to it.

To sign data using the legacy method, you can follow these steps:

1. Import the `signing` module from the `itsdangerous` package:

```python
from itsdangerous import signing
```

2. Create an instance of the `signing.Signer` class, passing a secret key as a parameter:

```python
signer = signing.Signer('your_secret_key')
```

3. Use the `signer.sign()` method to sign the data:

```python
signed_data = signer.sign('your_data')
```

4. To verify the signature, you can use the `signer.unsign()` method:

```python
original_data = signer.unsign(signed_data)
```

Note that this method of signing data is considered legacy and is not recommended for use in newer versions of Flask. It is recommended to use the `itsdangerous` module's `URLSafeTimedSerializer` class for signing data in the latest versions of Flask.
```bash
flask-unsign --sign --cookie "{'logged_in': True}" --secret 'CHANGEME' --legacy
```
### **RIPsession**

命令行工具，使用使用flask-unsign生成的cookie对网站进行暴力破解。

{% embed url="https://github.com/Tagvi/ripsession" %}
```bash
ripsession -u 10.10.11.100 -c "{'logged_in': True, 'username': 'changeMe'}" -s password123 -f "user doesn't exist" -w wordlist.txt
```
### 使用SQLmap在Flask会话cookie中进行SQLi攻击

[**这个示例**](../../pentesting-web/sql-injection/sqlmap/#eval) 使用sqlmap的`eval`选项来使用已知的密钥自动签名flask的sqlmap负载。

<figure><img src="../../.gitbook/assets/image (9) (1) (2).png" alt=""><figcaption></figcaption></figure>

使用[**Trickest**](https://trickest.io/)轻松构建和自动化由全球**最先进**的社区工具提供支持的工作流程。\
立即获取访问权限：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中看到你的**公司广告**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
