# 80,443 - Metodologia testowania penetracyjnego aplikacji internetowych

<details>

<summary><strong>Zacznij od zera i stań się ekspertem od hakowania AWS dzięki</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną na HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Jeśli interesuje Cię **kariera hakerska** i hakowanie niemożliwego do zhakowania - **rekrutujemy!** (_wymagana biegła znajomość języka polskiego, zarówno pisanego, jak i mówionego_).

{% embed url="https://www.stmcyber.com/careers" %}

## Podstawowe informacje

Usługa internetowa to najbardziej **powszechna i rozległa usługa**, w której istnieje wiele **różnych rodzajów podatności**.

**Port domyślny:** 80 (HTTP), 443(HTTPS)
```bash
PORT    STATE SERVICE
80/tcp  open  http
443/tcp open  ssl/https
```

```bash
nc -v domain.com 80 # GET / HTTP/1.0
openssl s_client -connect domain.com:443 # GET / HTTP/1.0
```
### Wskazówki dotyczące interfejsu API sieciowego

{% content-ref url="web-api-pentesting.md" %}
[web-api-pentesting.md](web-api-pentesting.md)
{% endcontent-ref %}

## Podsumowanie metodologii

> W tej metodologii zakładamy, że atakujesz domenę (lub subdomenę) i tylko nią. Dlatego powinieneś zastosować tę metodologię do każdej odkrytej domeny, subdomeny lub IP z nieokreślonym serwerem WWW w zakresie.

* [ ] Zacznij od **identyfikacji** używanych przez serwer WWW **technologii**. Szukaj **sztuczek**, które warto zapamiętać podczas reszty testu, jeśli uda ci się pomyślnie zidentyfikować technologię.
* [ ] Czy istnieje **znana podatność** wersji tej technologii?
* [ ] Czy używana jest **jakakolwiek znana technologia**? Czy istnieje **przydatna sztuczka** do pozyskania dodatkowych informacji?
* [ ] Czy istnieje **specjalistyczne narzędzie skanujące** do uruchomienia (np. wpscan)?
* [ ] Uruchom **skanery ogólnego przeznaczenia**. Nigdy nie wiesz, czy znajdą coś interesującego.
* [ ] Rozpocznij od **początkowych sprawdzeń**: **robots.txt**, **mapa witryny (sitemap)**, błąd **404** i skan **SSL/TLS** (jeśli HTTPS).
* [ ] Rozpocznij **przeglądanie strony**: Czas znaleźć wszystkie możliwe **pliki, foldery** i **parametry** używane. Sprawdź również **specjalne znaleziska**.
* [ ] _Zauważ, że za każdym razem, gdy podczas prób siłowych lub przeglądania odkryjesz nowy katalog, powinieneś go przeglądać._
* [ ] **Siłowe przeglądanie katalogów**: Spróbuj siłowo przeglądać wszystkie odkryte foldery w poszukiwaniu nowych **plików** i **katalogów**.
* [ ] _Zauważ, że za każdym razem, gdy podczas prób siłowych lub przeglądania odkryjesz nowy katalog, powinieneś go siłowo przeglądać._
* [ ] **Sprawdzanie kopii zapasowych**: Sprawdź, czy można znaleźć **kopie zapasowe** odkrytych plików, dodając popularne rozszerzenia kopii zapasowych.
* [ ] **Siłowe przeglądanie parametrów**: Spróbuj znaleźć **ukryte parametry**.
* [ ] Gdy zidentyfikujesz wszystkie możliwe **punkty końcowe** akceptujące **dane użytkownika**, sprawdź wszelkie rodzaje związanych z nimi **podatności**.
* [ ] [Postępuj zgodnie z tą listą kontrolną](../../pentesting-web/web-vulnerabilities-methodology/)

## Wersja serwera (Podatny?)

### Identyfikacja

Sprawdź, czy istnieją **znane podatności** dla wersji serwera, która jest używana.\
**Nagłówki HTTP i ciasteczka odpowiedzi** mogą być bardzo przydatne do **identyfikacji** używanych **technologii** i/lub **wersji**. **Skan Nmap** może zidentyfikować wersję serwera, ale również przydatne mogą być narzędzia [**whatweb**](https://github.com/urbanadventurer/WhatWeb)**,** [**webtech** ](https://github.com/ShielderSec/webtech)lub [**https://builtwith.com/**](https://builtwith.com)**:**
```bash
whatweb -a 1 <URL> #Stealthy
whatweb -a 3 <URL> #Aggresive
webtech -u <URL>
webanalyze -host https://google.com -crawl 2
```
Szukaj **podatności aplikacji internetowej** **w wersji**](../../generic-methodologies-and-resources/search-exploits.md)

### **Sprawdź, czy istnieje WAF**

* [**https://github.com/EnableSecurity/wafw00f**](https://github.com/EnableSecurity/wafw00f)
* [**https://github.com/Ekultek/WhatWaf.git**](https://github.com/Ekultek/WhatWaf.git)
* [**https://nmap.org/nsedoc/scripts/http-waf-detect.html**](https://nmap.org/nsedoc/scripts/http-waf-detect.html)

### Triki technologii internetowych

Kilka **trików** do **znajdowania podatności** w różnych znanych **technologiach** używanych:

* [**AEM - Adobe Experience Cloud**](aem-adobe-experience-cloud.md)
* [**Apache**](apache.md)
* [**Artifactory**](artifactory-hacking-guide.md)
* [**Buckets**](buckets/)
* [**CGI**](cgi.md)
* [**Drupal**](drupal.md)
* [**Flask**](flask.md)
* [**Git**](git.md)
* [**Golang**](golang.md)
* [**GraphQL**](graphql.md)
* [**H2 - Java SQL database**](h2-java-sql-database.md)
* [**IIS tricks**](iis-internet-information-services.md)
* [**JBOSS**](jboss.md)
* [**Jenkins**](broken-reference/)
* [**Jira**](jira.md)
* [**Joomla**](joomla.md)
* [**JSP**](jsp.md)
* [**Laravel**](laravel.md)
* [**Moodle**](moodle.md)
* [**Nginx**](nginx.md)
* [**PHP (php has a lot of interesting tricks that could be exploited)**](php-tricks-esp/)
* [**Python**](python.md)
* [**Spring Actuators**](spring-actuators.md)
* [**Symphony**](symphony.md)
* [**Tomcat**](tomcat.md)
* [**VMWare**](vmware-esx-vcenter....md)
* [**Web API Pentesting**](web-api-pentesting.md)
* [**WebDav**](put-method-webdav.md)
* [**Werkzeug**](werkzeug.md)
* [**Wordpress**](wordpress.md)
* [**Electron Desktop (XSS to RCE)**](electron-desktop-apps/)

_Miej na uwadze, że **ta sama domena** może używać **różnych technologii** na różnych **portach**, **folderach** i **subdomenach**._\
Jeśli aplikacja internetowa używa **jakiejkolwiek znanej technologii/platformy wymienionej wcześniej** lub **innej**, nie zapomnij **szukać w Internecie** nowych trików (i daj mi znać!).

### Przegląd kodu źródłowego

Jeśli **kod źródłowy** aplikacji jest dostępny w **githubie**, oprócz przeprowadzenia **testu White box** aplikacji na własną rękę, istnieje **kilka informacji**, które mogą być **przydatne** dla obecnego **testu Black-Box**:

* Czy istnieje **dziennik zmian lub plik Readme lub informacje o wersji** dostępne przez sieć?
* Jak i gdzie są przechowywane **dane uwierzytelniające**? Czy istnieje (dostępny?) **plik** z danymi uwierzytelniającymi (nazwy użytkowników lub hasła)?
* Czy **hasła** są w **czystym tekście**, **zaszyfrowane** lub jaki **algorytm haszowania** jest używany?
* Czy jest używany **klucz główny** do szyfrowania czegoś? Jaki **algorytm** jest używany?
* Czy możesz **uzyskać dostęp do któregokolwiek z tych plików** wykorzystując jakąś podatność?
* Czy w githubie znajdują się jakieś **interesujące informacje** (rozwiązane i nierozwiązane) w **problemach**? Lub w **historii commitów** (może jakieś **hasło wprowadzone w starym commicie**)?

{% content-ref url="code-review-tools.md" %}
[code-review-tools.md](code-review-tools.md)
{% endcontent-ref %}

### Automatyczne skanery

#### Automatyczne skanery ogólnego przeznaczenia
```bash
nikto -h <URL>
whatweb -a 4 <URL>
wapiti -u <URL>
W3af
zaproxy #You can use an API
nuclei -ut && nuclei -target <URL>

# https://github.com/ignis-sec/puff (client side vulns fuzzer)
node puff.js -w ./wordlist-examples/xss.txt -u "http://www.xssgame.com/f/m4KKGHi2rVUN/?query=FUZZ"
```
#### Skanery CMS

Jeśli jest używany CMS, nie zapomnij **uruchomić skanera**, być może znajdziesz coś interesującego:

[**Clusterd**](https://github.com/hatRiot/clusterd)**:** [**JBoss**](jboss.md)**, ColdFusion, WebLogic,** [**Tomcat**](tomcat.md)**, Railo, Axis2, Glassfish**\
[**CMSScan**](https://github.com/ajinabraham/CMSScan): Strony internetowe [**WordPress**](wordpress.md), [**Drupal**](drupal.md), **Joomla**, **vBulletin** w poszukiwaniu problemów zabezpieczeń. (GUI)\
[**VulnX**](https://github.com/anouarbensaad/vulnx)**:** [**Joomla**](joomla.md)**,** [**Wordpress**](wordpress.md)**,** [**Drupal**](drupal.md)**, PrestaShop, Opencart**\
**CMSMap**: [**(W)ordpress**](wordpress.md)**,** [**(J)oomla**](joomla.md)**,** [**(D)rupal**](drupal.md) **lub** [**(M)oodle**](moodle.md)\
[**droopscan**](https://github.com/droope/droopescan)**:** [**Drupal**](drupal.md)**,** [**Joomla**](joomla.md)**,** [**Moodle**](moodle.md)**, Silverstripe,** [**Wordpress**](wordpress.md)
```bash
cmsmap [-f W] -F -d <URL>
wpscan --force update -e --url <URL>
joomscan --ec -u <URL>
joomlavs.rb #https://github.com/rastating/joomlavs
```
> W tym momencie powinieneś już mieć pewne informacje na temat serwera WWW używanego przez klienta (jeśli jakiekolwiek dane zostały podane) oraz kilka sztuczek, które warto mieć na uwadze podczas testu. Jeśli masz szczęście, możesz nawet znaleźć system zarządzania treścią (CMS) i uruchomić skaner.

## Odkrywanie aplikacji internetowej krok po kroku

> Od tego momentu zaczniemy interakcję z aplikacją internetową.

### Sprawdzenia początkowe

**Domyślne strony z ciekawymi informacjami:**

* /robots.txt
* /sitemap.xml
* /crossdomain.xml
* /clientaccesspolicy.xml
* /.well-known/
* Sprawdź również komentarze na głównej i pomocniczych stronach.

**Wymuszanie błędów**

Serwery WWW mogą **zachowywać się niespodziewanie**, gdy do nich wysyłane są dziwne dane. Może to otworzyć **luki w zabezpieczeniach** lub **ujawnić poufne informacje**.

* Dostęp do **fałszywych stron** takich jak /cokolwiek\_fake.php (.aspx,.html,.itp)
* Dodaj "\[]", "]]" i "\[\[" w **wartościach ciasteczka** i **wartościach parametrów** aby wywołać błędy
* Wygeneruj błąd, podając dane wejściowe jako **`/~randomthing/%s`** na **końcu** **URL**
* Spróbuj użyć **różnych czasowników HTTP** jak PATCH, DEBUG lub błędny jak FAKE

#### **Sprawdź, czy możesz przesyłać pliki (**[**metoda PUT, WebDav**](put-method-webdav.md)**)**

Jeśli odkryjesz, że **WebDav** jest **włączony**, ale nie masz wystarczających uprawnień do **przesyłania plików** w folderze głównym, spróbuj:

* **Brute Force** hasła
* **Prześlij pliki** za pomocą WebDav do **pozostałych znalezionych folderów** na stronie internetowej. Możesz mieć uprawnienia do przesyłania plików do innych folderów.

### **Luki w SSL/TLS**

* Jeśli aplikacja **nie wymusza użycia HTTPS** w żadnej części, to jest **podatna na ataki typu MitM**
* Jeśli aplikacja **wysyła poufne dane (hasła) za pomocą HTTP**. To jest wysokie ryzyko.

Użyj [**testssl.sh**](https://github.com/drwetter/testssl.sh) do sprawdzania **luk w zabezpieczeniach** (W programach Bug Bounty prawdopodobnie tego rodzaju luki nie będą akceptowane) i użyj [**a2sv** ](https://github.com/hahwul/a2sv) do ponownego sprawdzenia luk w zabezpieczeniach:
```bash
./testssl.sh [--htmlfile] 10.10.10.10:443
#Use the --htmlfile to save the output inside an htmlfile also

# You can also use other tools, by testssl.sh at this momment is the best one (I think)
sslscan <host:port>
sslyze --regular <ip:port>
```
Informacje o podatnościach SSL/TLS:

* [https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/](https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/)
* [https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/](https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/)

### Przeglądanie stron

Uruchom jakiś rodzaj **pająka** w sieci. Celem pająka jest **znalezienie jak największej liczby ścieżek** w testowanej aplikacji. Dlatego należy wykorzystać przeglądanie stron internetowych i zewnętrzne źródła, aby znaleźć jak najwięcej prawidłowych ścieżek.

* [**gospider**](https://github.com/jaeles-project/gospider) (go): Pająk HTML, LinkFinder w plikach JS i zewnętrzne źródła (Archive.org, CommonCrawl.org, VirusTotal.com, AlienVault.com).
* [**hakrawler**](https://github.com/hakluke/hakrawler) (go): Pająk HML, z LinkFiderem dla plików JS i Archive.org jako źródło zewnętrzne.
* [**dirhunt**](https://github.com/Nekmo/dirhunt) (python): Pająk HTML, wskazuje również "soczyste pliki".
* [**evine** ](https://github.com/saeeddhqan/evine)(go): Interaktywny pająk HTML w wierszu poleceń. Szuka także w Archive.org.
* [**meg**](https://github.com/tomnomnom/meg) (go): To narzędzie nie jest pająkiem, ale może być przydatne. Możesz wskazać plik z hostami i plik z ścieżkami, a meg pobierze każdą ścieżkę na każdym hoście i zapisze odpowiedź.
* [**urlgrab**](https://github.com/IAmStoxe/urlgrab) (go): Pająk HTML z możliwościami renderowania JS. Jednak wygląda na to, że nie jest rozwijany, skompilowana wersja jest stara, a obecny kod nie kompiluje się.
* [**gau**](https://github.com/lc/gau) (go): Pająk HTML korzystający z zewnętrznych dostawców (wayback, otx, commoncrawl)
* [**ParamSpider**](https://github.com/devanshbatham/ParamSpider): Ten skrypt znajdzie adresy URL z parametrami i je wymieni.
* [**galer**](https://github.com/dwisiswant0/galer) (go): Pająk HTML z możliwościami renderowania JS.
* [**LinkFinder**](https://github.com/GerbenJavado/LinkFinder) (python): Pająk HTML, z możliwościami upiększania JS zdolny do wyszukiwania nowych ścieżek w plikach JS. Warto również spojrzeć na [JSScanner](https://github.com/dark-warlord14/JSScanner), który jest nakładką na LinkFinder.
* [**goLinkFinder**](https://github.com/0xsha/GoLinkFinder) (go): Do wyodrębniania punktów końcowych zarówno w źródle HTML, jak i osadzonych plikach javascript. Przydatne dla łowców błędów, drużyn czerwonych i ninja bezpieczeństwa informacji.
* [**JSParser**](https://github.com/nahamsec/JSParser) (python2.7): Skrypt python 2.7 używający Tornado i JSBeautifier do analizowania względnych adresów URL z plików JavaScript. Przydatne do łatwego odkrywania żądań AJAX. Wygląda na to, że nie jest rozwijany.
* [**relative-url-extractor**](https://github.com/jobertabma/relative-url-extractor) (ruby): Dla danego pliku (HTML) wyodrębni adresy URL z niego, używając sprytnego wyrażenia regularnego do znalezienia i wyodrębnienia względnych adresów URL z brzydkich (zmniejszonych) plików.
* [**JSFScan**](https://github.com/KathanP19/JSFScan.sh) (bash, kilka narzędzi): Zbiera interesujące informacje z plików JS za pomocą kilku narzędzi.
* [**subjs**](https://github.com/lc/subjs) (go): Znajdź pliki JS.
* [**page-fetch**](https://github.com/detectify/page-fetch) (go): Ładuje stronę w przeglądarce bez wyświetlania i drukuje wszystkie załadowane adresy URL, aby załadować stronę.
* [**Feroxbuster**](https://github.com/epi052/feroxbuster) (rust): Narzędzie do odkrywania treści łączące kilka opcji poprzednich narzędzi
* [**Javascript Parsing**](https://github.com/xnl-h4ck3r/burp-extensions): Rozszerzenie Burp do znajdowania ścieżek i parametrów w plikach JS.
* [**Sourcemapper**](https://github.com/denandz/sourcemapper): Narzędzie, które po podaniu adresu URL .js.map uzyska uporządkowany kod JS
* [**xnLinkFinder**](https://github.com/xnl-h4ck3r/xnLinkFinder): Jest to narzędzie używane do odkrywania punktów końcowych dla określonego celu.
* [**waymore**](https://github.com/xnl-h4ck3r/waymore)**:** Odkryj linki z maszyny wayback (pobierając również odpowiedzi w wayback i szukając więcej linków
* [**HTTPLoot**](https://github.com/redhuntlabs/HTTPLoot) (go): Przeglądaj (nawet poprzez wypełnianie formularzy) i znajduj również informacje poufne, korzystając z określonych wyrażeń regularnych.
* [**SpiderSuite**](https://github.com/3nock/SpiderSuite): Spider Suite to zaawansowany wielofunkcyjny GUI Crawler/Spider do bezpieczeństwa sieciowego, przeznaczony dla profesjonalistów zajmujących się cyberbezpieczeństwem.
* [**jsluice**](https://github.com/BishopFox/jsluice) (go): Jest to pakiet Go i [narzędzie wiersza poleceń](https://github.com/BishopFox/jsluice/blob/main/cmd/jsluice) do wyodrębniania adresów URL, ścieżek, sekretów i innych ciekawych danych z kodu źródłowego JavaScript.
* [**ParaForge**](https://github.com/Anof-cyber/ParaForge): ParaForge to proste rozszerzenie **Burp Suite** do **wyodrębniania parametrów i punktów końcowych** z żądania w celu utworzenia niestandardowej listy słów do fuzzowania i wyliczania.

### Przemierzanie katalogów i plików metodą brutalnej siły

Zacznij **przemierzać** od katalogu głównego i upewnij się, że **przemierzasz wszystkie znalezione katalogi** za pomocą **tej metody** oraz wszystkie katalogi **odkryte** podczas **przeglądania stron** (możesz to zrobić **rekurencyjnie** i dodając na początku używanej listy słów nazwy znalezionych katalogów).\
Narzędzia:

* **Dirb** / **Dirbuster** - Zawarte w Kali, **stare** (i **wolne**), ale funkcjonalne. Pozwalają na automatyczne podpisywanie certyfikatów i rekurencyjne wyszukiwanie. Zbyt wolne w porównaniu z innymi opcjami.
* [**Dirsearch**](https://github.com/maurosoria/dirsearch) (python)**: Nie pozwala na automatyczne podpisywanie certyfikatów, ale** umożliwia rekurencyjne wyszukiwanie.
* [**Gobuster**](https://github.com/OJ/gobuster) (go): Pozwala na automatyczne podpisywanie certyfikatów, **nie ma** rekurencyjnego wyszukiwania.
* [**Feroxbuster**](https://github.com/epi052/feroxbuster) **- Szybki, obsługuje rekurencyjne wyszukiwanie.**
* [**wfuzz**](https://github.com/xmendez/wfuzz) `wfuzz -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt https://domain.com/api/FUZZ`
* [**ffuf** ](https://github.com/ffuf/ffuf)- Szybki: `ffuf -c -w /usr/share/wordlists/dirb/big.txt -u http://10.10.10.10/FUZZ`
* [**uro**](https://github.com/s0md3v/uro) (python): To nie jest pająk, ale narzędzie, które po podaniu listy znalezionych adresów URL usunie "zduplikowane" adresy URL.
* [**Scavenger**](https://github.com/0xDexter0us/Scavenger): Rozszerzenie Burp do tworzenia listy katalogów z historii burp różnych stron
* [**TrashCompactor**](https://github.com/michael1026/trashcompactor): Usuń adresy URL z zduplikowanymi funkcjonalnościami (oparte na importach js)
* [**Chamaleon**](https://github.com/iustin24/chameleon): Wykorzystuje wapalyzer do wykrywania używanych technologii i wybiera listy słów do użycia.

**Polecane słowniki:**

* [https://github.com/carlospolop/Auto\_Wordlists/blob/main/wordlists/bf\_directories.txt](https://github.com/carlospolop/Auto\_Wordlists/blob/main/wordlists/bf\_directories.txt)
* Słownik dołączony do **Dirsearch**
* [http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10](http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10)
* Wordlisty Assetnote
* [https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content](https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content)
* raft-large-directories-lowercase.txt
* directory-list-2.3-medium.txt
* RobotsDisallowed/top10000.txt
* [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
* [https://github.com/google/fuzzing/tree/master/dictionaries](https://github.com/google/fuzzing/tree/master/dictionaries)
* [https://github.com/six2dez/OneListForAll](https://github.com/six2dez/OneListForAll)
* [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
* _/usr/share/wordlists/dirb/common.txt_
* _/usr/share/wordlists/dirb/big.txt_
* _/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt_

_Zauważ, że za każdym razem, gdy odkryjesz nowy katalog podczas ataku brutalnej siły lub przeszukiwania, należy go poddać atakowi brutalnej siły._

### Co sprawdzić w każdym znalezionym pliku

* [**Sprawdzacz uszkodzonych linków**](https://github.com/stevenvachon/broken-link-checker): Znajdź uszkodzone linki wewnątrz plików HTML, które mogą być podatne na przejęcia.
* **Kopie zapasowe plików**: Gdy znajdziesz wszystkie pliki, poszukaj kopii zapasowych wszystkich plików wykonywalnych ("_.php_", "_.aspx_"...). Powszechne warianty nazewnictwa kopii zapasowych to: _file.ext\~, #file.ext#, \~file.ext, file.ext.bak, file.ext.tmp, file.ext.old, file.bak, file.tmp i file.old._ Możesz również skorzystać z narzędzi [**bfac**](https://github.com/mazen160/bfac) **lub** [**backup-gen**](https://github.com/Nishantbhagat57/backup-gen)**.**
* **Odkryj nowe parametry**: Możesz użyć narzędzi takich jak [**Arjun**](https://github.com/s0md3v/Arjun)**,** [**parameth**](https://github.com/maK-/parameth)**,** [**x8**](https://github.com/sh1yo/x8) **i** [**Param Miner**](https://github.com/PortSwigger/param-miner) **do odkrywania ukrytych parametrów. Jeśli możesz, spróbuj wyszukać** ukryte parametry w każdym pliku wykonywalnym na stronie internetowej.
* _Wszystkie domyślne listy słów Arjuna:_ [https://github.com/s0md3v/Arjun/tree/master/arjun/db](https://github.com/s0md3v/Arjun/tree/master/arjun/db)
* _Param-miner „params” :_ [https://github.com/PortSwigger/param-miner/blob/master/resources/params](https://github.com/PortSwigger/param-miner/blob/master/resources/params)
* _Assetnote „parameters\_top\_1m”:_ [https://wordlists.assetnote.io/](https://wordlists.assetnote.io)
* _nullenc0de „params.txt”:_ [https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773](https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773)
* **Komentarze:** Sprawdź komentarze we wszystkich plikach, możesz znaleźć **dane uwierzytelniające** lub **ukrytą funkcjonalność**.
* Jeśli bawisz się w **CTF**, „powszechnym” trikiem jest **ukrycie informacji** wewnątrz komentarzy na **prawej** **stronie** **strony** (używając **setek** **spacji**, aby nie widzieć danych podczas otwierania kodu źródłowego w przeglądarce). Inna możliwość to użycie **kilku nowych linii** i **ukrycie informacji** w komentarzu na **dole** strony internetowej.
* **Klucze API**: Jeśli **znajdziesz jakikolwiek klucz API**, istnieje przewodnik wskazujący, jak korzystać z kluczy API różnych platform: [**keyhacks**](https://github.com/streaak/keyhacks)**,** [**zile**](https://github.com/xyele/zile.git)**,** [**truffleHog**](https://github.com/trufflesecurity/truffleHog)**,** [**SecretFinder**](https://github.com/m4ll0k/SecretFinder)**,** [**RegHex**](https://github.com/l4yton/RegHex\)/)**,** [**DumpsterDive**](https://github.com/securing/DumpsterDiver)**,** [**EarlyBird**](https://github.com/americanexpress/earlybird)
* Klucze API Google: Jeśli znajdziesz jakiś klucz API wyglądający jak **AIza**SyA-qLheq6xjDiEIRisP\_ujUseYLQCHUjik, możesz użyć projektu [**gmapapiscanner**](https://github.com/ozguralp/gmapsapiscanner), aby sprawdzić, do których interfejsów API ma dostęp klucz.
* **Kubełki S3**: Podczas przeszukiwania zwróć uwagę, czy jakikolwiek **poddomena** lub jakikolwiek **link** jest powiązany z kubełkiem S3. W takim przypadku [**sprawdź** **uprawnienia** kubełka](buckets/).

### Specjalne znaleziska

Podczas **przeszukiwania** i **ataku brutalnej siły** możesz natrafić na **interesujące** **rzeczy**, na które musisz **zwrócić uwagę**.

**Interesujące pliki**

* Szukaj **linków** do innych plików wewnątrz plików **CSS**.
* [Jeśli znajdziesz plik _**.git**_, można z niego wyciągnąć pewne informacje](git.md)
* Jeśli znajdziesz plik _**.env**_, można w nim znaleźć informacje takie jak klucze API, hasła do baz danych i inne informacje.
* Jeśli znajdziesz **punkty końcowe API**, [również powinieneś je przetestować](web-api-pentesting.md). Nie są to pliki, ale prawdopodobnie będą na nie podobne.
* **Pliki JS**: W sekcji przeszukiwania wspomniano o kilku narzędziach, które mogą wydobywać ścieżki z plików JS. Również interesujące będzie **monitorowanie każdego znalezionego pliku JS**, ponieważ w niektórych przypadkach zmiana może wskazywać na potencjalną podatność wprowadzoną w kodzie. Możesz użyć na przykład [**JSMon**](https://github.com/robre/jsmon)**.**
* Sprawdź znalezione pliki JS za pomocą [**RetireJS**](https://github.com/retirejs/retire.js/) lub [**JSHole**](https://github.com/callforpapers-source/jshole), aby sprawdzić, czy są podatne.
* **Deobfuskator i dekoder JavaScript:** [https://lelinhtinh.github.io/de4js/](https://lelinhtinh.github.io/de4js/), [https://www.dcode.fr/javascript-unobfuscator](https://www.dcode.fr/javascript-unobfuscator)
* **Uporządkowujący JavaScript:** [http://jsbeautifier.org/](https://beautifier.io), [http://jsnice.org/](http://jsnice.org)
* **Deobfuskacja JsFuck** (javascript z znakami:"\[]!+" [https://ooze.ninja/javascript/poisonjs/](https://ooze.ninja/javascript/poisonjs/))
* [**TrainFuck**](https://github.com/taco-c/trainfuck)**:** `+72.+29.+7..+3.-67.-12.+55.+24.+3.-6.-8.-67.-23.`
* W kilku przypadkach będziesz musiał **zrozumieć wyrażenia regularne** używane, co będzie przydatne: [https://regex101.com/](https://regex101.com)
* Możesz również **monitorować pliki, w których wykryto formularze**, ponieważ zmiana w parametrze lub pojawienie się nowego formularza może wskazywać na potencjalną nową podatną funkcjonalność.

**403 Forbidden/Basic Authentication/401 Unauthorized (omijanie)**

{% content-ref url="403-and-401-bypasses.md" %}
[403-and-401-bypasses.md](403-and-401-bypasses.md)
{% endcontent-ref %}

**502 Proxy Error**

Jeśli jakakolwiek strona **odpowiada** tym **kodem**, prawdopodobnie jest to **źle skonfigurowany serwer proxy**. **Jeśli wyślesz żądanie HTTP takie jak: `GET https://google.com HTTP/1.1`** (z nagłówkiem hosta i innymi standardowymi nagłówkami), **proxy** spróbuje **uzyskać dostęp do _google.com_** i odkryjesz **SSRF**.

**Autoryzacja NTLM - Ujawnienie informacji**

Jeśli działający serwer wymaga autoryzacji **Windows** lub znajdziesz logowanie proszące o **dane uwierzytelniające** (i proszące o **nazwę domeny**), możesz spowodować **ujawnienie informacji**.\
**Wyślij** **nagłówek**: `“Authorization: NTLM TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=”` i ze względu na sposób działania autoryzacji **NTLM**, serwer odpowie wewnętrznymi informacjami (wersja IIS, wersja Windows...) w nagłówku "WWW-Authenticate".\
Możesz to **zautomatyzować** za pomocą **wtyczki nmap** "_http-ntlm-info.nse_".

**Przekierowanie HTTP (CTF)**

Możliwe jest **umieszczenie treści** wewnątrz **przekierowania**. Ta treść **nie będzie widoczna dla użytkownika** (ponieważ przeglądarka wykonuje przekierowanie), ale coś może być **ukryte** wewnątrz.
### Sprawdzanie podatności sieci Web

Po przeprowadzeniu kompleksowego wyliczenia aplikacji sieci Web nadszedł czas, aby sprawdzić wiele możliwych podatności. Możesz znaleźć listę kontrolną tutaj:

{% content-ref url="../../pentesting-web/web-vulnerabilities-methodology/" %}
[web-vulnerabilities-methodology](../../pentesting-web/web-vulnerabilities-methodology/)
{% endcontent-ref %}

Dowiedz się więcej o podatnościach sieci Web:

* [https://six2dez.gitbook.io/pentest-book/others/web-checklist](https://six2dez.gitbook.io/pentest-book/others/web-checklist)
* [https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web\_application\_security\_testing/configuration\_and\_deployment\_management\_testing.html](https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web\_application\_security\_testing/configuration\_and\_deployment\_management\_testing.html)
* [https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection](https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection)

### Monitorowanie stron pod kątem zmian

Możesz użyć narzędzi takich jak [https://github.com/dgtlmoon/changedetection.io](https://github.com/dgtlmoon/changedetection.io) do monitorowania stron pod kątem modyfikacji, które mogą wprowadzić podatności.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Jeśli interesuje Cię **kariera hakera** i chcesz hakować nie do złamania - **rekrutujemy!** (_wymagana biegła znajomość języka polskiego w mowie i piśmie_).

{% embed url="https://www.stmcyber.com/careers" %}

### Automatyczne polecenia HackTricks
```
Protocol_Name: Web    #Protocol Abbreviation if there is one.
Port_Number:  80,443     #Comma separated if there is more than one.
Protocol_Description: Web         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for Web
Note: |
https://book.hacktricks.xyz/pentesting/pentesting-web

Entry_2:
Name: Quick Web Scan
Description: Nikto and GoBuster
Command: nikto -host {Web_Proto}://{IP}:{Web_Port} &&&& gobuster dir -w {Small_Dirlist} -u {Web_Proto}://{IP}:{Web_Port} && gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_3:
Name: Nikto
Description: Basic Site Info via Nikto
Command: nikto -host {Web_Proto}://{IP}:{Web_Port}

Entry_4:
Name: WhatWeb
Description: General purpose auto scanner
Command: whatweb -a 4 {IP}

Entry_5:
Name: Directory Brute Force Non-Recursive
Description:  Non-Recursive Directory Brute Force
Command: gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_6:
Name: Directory Brute Force Recursive
Description: Recursive Directory Brute Force
Command: python3 {Tool_Dir}dirsearch/dirsearch.py -w {Small_Dirlist} -e php,exe,sh,py,html,pl -f -t 20 -u {Web_Proto}://{IP}:{Web_Port} -r 10

Entry_7:
Name: Directory Brute Force CGI
Description: Common Gateway Interface Brute Force
Command: gobuster dir -u {Web_Proto}://{IP}:{Web_Port}/ -w /usr/share/seclists/Discovery/Web-Content/CGIs.txt -s 200

Entry_8:
Name: Nmap Web Vuln Scan
Description: Tailored Nmap Scan for web Vulnerabilities
Command: nmap -vv --reason -Pn -sV -p {Web_Port} --script=`banner,(http* or ssl*) and not (brute or broadcast or dos or external or http-slowloris* or fuzzer)` {IP}

Entry_9:
Name: Drupal
Description: Drupal Enumeration Notes
Note: |
git clone https://github.com/immunIT/drupwn.git for low hanging fruit and git clone https://github.com/droope/droopescan.git for deeper enumeration

Entry_10:
Name: WordPress
Description: WordPress Enumeration with WPScan
Command: |
?What is the location of the wp-login.php? Example: /Yeet/cannon/wp-login.php
wpscan --url {Web_Proto}://{IP}{1} --enumerate ap,at,cb,dbe && wpscan --url {Web_Proto}://{IP}{1} --enumerate u,tt,t,vp --passwords {Big_Passwordlist} -e

Entry_11:
Name: WordPress Hydra Brute Force
Description: Need User (admin is default)
Command: hydra -l admin -P {Big_Passwordlist} {IP} -V http-form-post '/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log In&testcookie=1:S=Location'

Entry_12:
Name: Ffuf Vhost
Description: Simple Scan with Ffuf for discovering additional vhosts
Command: ffuf -w {Subdomain_List}:FUZZ -u {Web_Proto}://{Domain_Name} -H "Host:FUZZ.{Domain_Name}" -c -mc all {Ffuf_Filters}
```
<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF** sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na githubie.

</details>
