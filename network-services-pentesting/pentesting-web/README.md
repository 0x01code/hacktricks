# 80,443 - Metodologia testowania penetracyjnego aplikacji internetowych

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">

**Wskazówka dotycząca bug bounty**: **zarejestruj się** na platformie **Intigriti**, premium **platformie bug bounty stworzonej przez hakerów, dla hakerów**! Dołącz do nas na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) już dziś i zacznij zarabiać nagrody do **100 000 USD**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Podstawowe informacje

Usługa internetowa jest najbardziej **popularną i rozległą usługą**, a istnieje wiele **różnych typów podatności**.

**Domyślny port:** 80 (HTTP), 443 (HTTPS)
```bash
PORT    STATE SERVICE
80/tcp  open  http
443/tcp open  ssl/https
```

```bash
nc -v domain.com 80 # GET / HTTP/1.0
openssl s_client -connect domain.com:443 # GET / HTTP/1.0
```
### Wskazówki dotyczące Web API

{% content-ref url="web-api-pentesting.md" %}
[web-api-pentesting.md](web-api-pentesting.md)
{% endcontent-ref %}

## Podsumowanie metodologii

> W tej metodologii zakładamy, że zamierzasz zaatakować domenę (lub subdomenę) i tylko to. Dlatego powinieneś zastosować tę metodologię do każdej odkrytej domeny, subdomeny lub adresu IP z nieokreślonym serwerem WWW w zakresie.

* [ ] Zacznij od **identyfikacji** **technologii** używanych przez serwer WWW. Szukaj **trików**, które warto mieć na uwadze podczas reszty testu, jeśli uda ci się zidentyfikować technologię.
* [ ] Czy istnieje **znana podatność** wersji tej technologii?
* [ ] Czy używana jest **znana technologia**? Czy jest **użyteczny trik**, aby uzyskać więcej informacji?
* [ ] Czy jest **specjalistyczne narzędzie skanujące** do uruchomienia (np. wpscan)?
* [ ] Uruchom **skanery ogólnego zastosowania**. Nigdy nie wiesz, czy znajdą coś interesującego.
* [ ] Zacznij od **początkowych sprawdzeń**: **robots**, **sitemap**, błąd **404** i skan **SSL/TLS** (jeśli HTTPS).
* [ ] Zacznij **przeszukiwać** stronę internetową: Czas znaleźć wszystkie możliwe **pliki, foldery** i **parametry używane**. Sprawdź również **specjalne znaleziska**.
* [ ] _Zauważ, że za każdym razem, gdy odkryjesz nowy katalog podczas ataku brute-force lub przeszukiwania, powinieneś go przeszukać._
* [ ] **Atak brute-force na katalogi**: Spróbuj przeprowadzić atak brute-force na wszystkie odkryte foldery, szukając nowych **plików** i **katalogów**.
* [ ] _Zauważ, że za każdym razem, gdy odkryjesz nowy katalog podczas ataku brute-force lub przeszukiwania, powinieneś go przetestować pod kątem ataku brute-force._
* [ ] **Sprawdzanie kopii zapasowych**: Sprawdź, czy można znaleźć **kopie zapasowe** odkrytych plików, dodając popularne rozszerzenia kopii zapasowych.
* [ ] **Atak brute-force na parametry**: Spróbuj znaleźć ukryte parametry.
* [ ] Po **zidentyfikowaniu** wszystkich możliwych **punktów końcowych** akceptujących **dane użytkownika**, sprawdź wszystkie rodzaje związanych z nimi **podatności**.
* [ ] [Postępuj zgodnie z tą listą kontrolną](../../pentesting-web/web-vulnerabilities-methodology/)

## Wersja serwera (podatna?)

### Identyfikacja

Sprawdź, czy istnieją **znane podatności** dla wersji serwera, która jest używana.\
**Nagłówki HTTP i ciasteczka odpowiedzi** mogą być bardzo przydatne do **identyfikacji** używanych **technologii** i/lub **wersji**. Skan **Nmap** może zidentyfikować wersję serwera, ale również przydatne mogą być narzędzia [**whatweb**](https://github.com/urbanadventurer/WhatWeb)**,** [**webtech** ](https://github.com/ShielderSec/webtech)lub [**https://builtwith.com/**](https://builtwith.com)**:**
```bash
whatweb -a 1 <URL> #Stealthy
whatweb -a 3 <URL> #Aggresive
webtech -u <URL>
webanalyze -host https://google.com -crawl 2
```
Szukaj podatności wersji aplikacji internetowej.

### Sprawdź, czy jest zastosowany WAF

* [https://github.com/EnableSecurity/wafw00f](https://github.com/EnableSecurity/wafw00f)
* [https://github.com/Ekultek/WhatWaf.git](https://github.com/Ekultek/WhatWaf.git)
* [https://nmap.org/nsedoc/scripts/http-waf-detect.html](https://nmap.org/nsedoc/scripts/http-waf-detect.html)

### Triki dotyczące technologii internetowych

Oto kilka trików do znalezienia podatności w różnych znanych technologiach:

* [AEM - Adobe Experience Cloud](aem-adobe-experience-cloud.md)
* [Apache](apache.md)
* [Artifactory](artifactory-hacking-guide.md)
* [Buckets](buckets/)
* [CGI](cgi.md)
* [Drupal](drupal.md)
* [Flask](flask.md)
* [Git](git.md)
* [Golang](golang.md)
* [GraphQL](graphql.md)
* [H2 - baza danych Java SQL](h2-java-sql-database.md)
* [IIS tricks](iis-internet-information-services.md)
* [JBOSS](jboss.md)
* [Jenkins](broken-reference/)
* [Jira](jira.md)
* [Joomla](joomla.md)
* [JSP](jsp.md)
* [Laravel](laravel.md)
* [Moodle](moodle.md)
* [Nginx](nginx.md)
* [PHP (php ma wiele interesujących trików, które mogą być wykorzystane)](php-tricks-esp/)
* [Python](python.md)
* [Spring Actuators](spring-actuators.md)
* [Symphony](symphony.md)
* [Tomcat](tomcat.md)
* [VMWare](vmware-esx-vcenter....md)
* [Web API Pentesting](web-api-pentesting.md)
* [WebDav](put-method-webdav.md)
* [Werkzeug](werkzeug.md)
* [Wordpress](wordpress.md)
* [Electron Desktop (XSS to RCE)](electron-desktop-apps/)

Należy pamiętać, że ta sama domena może używać różnych technologii na różnych portach, folderach i subdomenach. Jeśli aplikacja internetowa korzysta z jakiejkolwiek znanej technologii/platformy wymienionej wcześniej lub jakiejkolwiek innej, nie zapomnij wyszukać w Internecie nowych trików (i daj mi znać!).

### Przegląd kodu źródłowego

Jeśli kod źródłowy aplikacji jest dostępny na GitHubie, oprócz przeprowadzenia własnego testu White box aplikacji, istnieje kilka informacji, które mogą być przydatne w obecnym teście Black-Box:

* Czy istnieje plik Change-log, Readme lub Version lub cokolwiek z informacjami o wersji dostępnymi przez sieć?
* Jak i gdzie są przechowywane dane uwierzytelniające? Czy istnieje (dostępny?) plik z danymi uwierzytelniającymi (nazwy użytkowników lub hasła)?
* Czy hasła są w postaci tekstowej, zaszyfrowanej czy jakiego algorytmu haszowania używano?
* Czy jest używany jakiś klucz główny do szyfrowania czegoś? Jakiego algorytmu użyto?
* Czy można uzyskać dostęp do któregoś z tych plików, wykorzystując jakąś podatność?
* Czy w GitHubie znajdują się jakieś interesujące informacje (rozwiązane i nierozwiązane) w postaci problemów (issues)? Czy w historii commitów (może jakieś hasło wprowadzone w starym commicie)? 

{% content-ref url="code-review-tools.md" %}
[code-review-tools.md](code-review-tools.md)
{% endcontent-ref %}

### Automatyczne skanery

#### Ogólnego zastosowania automatyczne skanery
```bash
nikto -h <URL>
whatweb -a 4 <URL>
wapiti -u <URL>
W3af
zaproxy #You can use an API
nuclei -ut && nuclei -target <URL>

# https://github.com/ignis-sec/puff (client side vulns fuzzer)
node puff.js -w ./wordlist-examples/xss.txt -u "http://www.xssgame.com/f/m4KKGHi2rVUN/?query=FUZZ"
```
#### Skanery CMS

Jeśli używany jest CMS, nie zapomnij **uruchomić skanera**, być może znajdziesz coś interesującego:

[**Clusterd**](https://github.com/hatRiot/clusterd)**:** [**JBoss**](jboss.md)**, ColdFusion, WebLogic,** [**Tomcat**](tomcat.md)**, Railo, Axis2, Glassfish**\
[**CMSScan**](https://github.com/ajinabraham/CMSScan): [**WordPress**](wordpress.md), [**Drupal**](drupal.md), **Joomla**, **vBulletin** - strony internetowe w celu wykrycia problemów zabezpieczeń. (GUI)\
[**VulnX**](https://github.com/anouarbensaad/vulnx)**:** [**Joomla**](joomla.md)**,** [**Wordpress**](wordpress.md)**,** [**Drupal**](drupal.md)**, PrestaShop, Opencart**\
**CMSMap**: [**(W)ordpress**](wordpress.md)**,** [**(J)oomla**](joomla.md)**,** [**(D)rupal**](drupal.md) **lub** [**(M)oodle**](moodle.md)\
[**droopscan**](https://github.com/droope/droopescan)**:** [**Drupal**](drupal.md)**,** [**Joomla**](joomla.md)**,** [**Moodle**](moodle.md)**, Silverstripe,** [**Wordpress**](wordpress.md)
```bash
cmsmap [-f W] -F -d <URL>
wpscan --force update -e --url <URL>
joomscan --ec -u <URL>
joomlavs.rb #https://github.com/rastating/joomlavs
```
> W tym momencie powinieneś już mieć pewne informacje na temat serwera WWW używanego przez klienta (jeśli jakiekolwiek dane zostały podane) oraz kilka sztuczek, które warto mieć na uwadze podczas testu. Jeśli masz szczęście, możesz nawet znaleźć CMS i uruchomić skaner.

## Krok po kroku odkrywanie aplikacji internetowej

> Od tego momentu zaczynamy interakcję z aplikacją internetową.

### Początkowe sprawdzenia

**Domyślne strony z ciekawymi informacjami:**

* /robots.txt
* /sitemap.xml
* /crossdomain.xml
* /clientaccesspolicy.xml
* /.well-known/
* Sprawdź również komentarze na głównej i pomocniczych stronach.

**Wymuszanie błędów**

Serwery WWW mogą **zachowywać się nieprzewidywalnie**, gdy do nich wysyłane są dziwne dane. Może to otworzyć **luki w zabezpieczeniach** lub **ujawnić wrażliwe informacje**.

* Otwórz **fałszywe strony** takie jak /cokolwiek\_fake.php (.aspx,.html,.etc)
* Dodaj "\[]", "]]" i "\[\[" w **wartościach ciasteczek** i **parametrach** aby wywołać błędy
* Wygeneruj błąd, wprowadzając dane wejściowe jako **`/~randomthing/%s`** na **końcu** URL
* Spróbuj użyć **różnych metod HTTP**, takich jak PATCH, DEBUG lub nieprawidłowych, np. FAKE

#### **Sprawdź, czy można przesyłać pliki (**[**metoda PUT, WebDav**](put-method-webdav.md)**)**

Jeśli odkryjesz, że **WebDav** jest **włączony**, ale nie masz wystarczających uprawnień do **przesyłania plików** w folderze głównym, spróbuj:

* **Brute Force** hasła
* **Prześlij pliki** za pomocą WebDav do **znalezionych folderów** na stronie internetowej. Możesz mieć uprawnienia do przesyłania plików do innych folderów.

### **Podatności SSL/TLS**

* Jeśli aplikacja **nie wymusza użycia protokołu HTTPS** w żadnej części, to jest **podatna na ataki typu MitM**
* Jeśli aplikacja **wysyła wrażliwe dane (hasła) za pomocą protokołu HTTP**. To jest wysokie ryzyko.

Użyj narzędzia [**testssl.sh**](https://github.com/drwetter/testssl.sh) do sprawdzania **podatności** (w programach Bug Bounty tego rodzaju podatności prawdopodobnie nie będą akceptowane) i użyj narzędzia [**a2sv**](https://github.com/hahwul/a2sv) do ponownego sprawdzenia podatności:
```bash
./testssl.sh [--htmlfile] 10.10.10.10:443
#Use the --htmlfile to save the output inside an htmlfile also

# You can also use other tools, by testssl.sh at this momment is the best one (I think)
sslscan <host:port>
sslyze --regular <ip:port>
```
Informacje dotyczące podatności SSL/TLS:

* [https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/](https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/)
* [https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/](https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/)

### Spidering

Uruchom pewnego rodzaju **spidera** wewnątrz sieci. Celem spidera jest **znalezienie jak największej liczby ścieżek** w testowanej aplikacji. Dlatego należy używać przeszukiwania sieci i źródeł zewnętrznych, aby znaleźć jak najwięcej prawidłowych ścieżek.

* [**gospider**](https://github.com/jaeles-project/gospider) (go): Spider HTML, LinkFinder w plikach JS i źródła zewnętrzne (Archive.org, CommonCrawl.org, VirusTotal.com, AlienVault.com).
* [**hakrawler**](https://github.com/hakluke/hakrawler) (go): Spider HTML, z LinkFinderem dla plików JS i źródłem zewnętrznym Archive.org.
* [**dirhunt**](https://github.com/Nekmo/dirhunt) (python): Spider HTML, wskazuje również "ważne pliki".
* [**evine** ](https://github.com/saeeddhqan/evine)(go): Interaktywny CLI spider HTML. Szuka również w Archive.org.
* [**meg**](https://github.com/tomnomnom/meg) (go): To narzędzie nie jest spiderem, ale może być przydatne. Wystarczy wskazać plik z hostami i plik z ścieżkami, a meg pobierze każdą ścieżkę na każdym hoście i zapisze odpowiedź.
* [**urlgrab**](https://github.com/IAmStoxe/urlgrab) (go): Spider HTML z możliwościami renderowania JS. Wygląda jednak na to, że nie jest rozwijane, wersja skompilowana jest stara, a obecny kod nie kompiluje się.
* [**gau**](https://github.com/lc/gau) (go): Spider HTML, który korzysta z dostawców zewnętrznych (wayback, otx, commoncrawl).
* [**ParamSpider**](https://github.com/devanshbatham/ParamSpider): Ten skrypt znajdzie adresy URL z parametrami i je wymieni.
* [**galer**](https://github.com/dwisiswant0/galer) (go): Spider HTML z możliwościami renderowania JS.
* [**LinkFinder**](https://github.com/GerbenJavado/LinkFinder) (python): Spider HTML, z możliwościami pięknego formatowania JS, zdolny do wyszukiwania nowych ścieżek w plikach JS. Warto również spojrzeć na [JSScanner](https://github.com/dark-warlord14/JSScanner), który jest opakowaniem LinkFinder.
* [**goLinkFinder**](https://github.com/0xsha/GoLinkFinder) (go): Do wyodrębniania punktów końcowych zarówno z kodu źródłowego HTML, jak i osadzonych plików JavaScript. Przydatne dla łowców błędów, zespołów czerwonych i ninja bezpieczeństwa informacji.
* [**JSParser**](https://github.com/nahamsec/JSParser) (python2.7): Skrypt python 2.7, który za pomocą Tornado i JSBeautifier analizuje względne adresy URL z plików JavaScript. Przydatne do łatwego odkrywania żądań AJAX. Wygląda na to, że nie jest rozwijane.
* [**relative-url-extractor**](https://github.com/jobertabma/relative-url-extractor) (ruby): Na podstawie pliku (HTML) wyodrębnia z niego adresy URL za pomocą sprytnego wyrażenia regularnego, aby znaleźć i wyodrębnić względne adresy URL z brzydkich (skompresowanych) plików.
* [**JSFScan**](https://github.com/KathanP19/JSFScan.sh) (bash, kilka narzędzi): Zbiera interesujące informacje z plików JS, korzystając z kilku narzędzi.
* [**subjs**](https://github.com/lc/subjs) (go): Znajduje pliki JS.
* [**page-fetch**](https://github.com/detectify/page-fetch) (go): Ładuje stronę w przeglądarce bez interfejsu i drukuje wszystkie załadowane adresy URL, aby załadować stronę.
* [**Feroxbuster**](https://github.com/epi052/feroxbuster) (rust): Narzędzie do odkrywania treści, łączące kilka opcji poprzednich narzędzi.
* [**Javascript Parsing**](https://github.com/xnl-h4ck3r/burp-extensions): Rozszerzenie Burp do wyszukiwania ścieżek i parametrów w plikach JS.
* [**Sourcemapper**](https://github.com/denandz/sourcemapper): Narzędzie, które na podstawie adresu URL .js.map pobierze piękny kod JS.
* [**xnLinkFinder**](https://github.com/xnl-h4ck3r/xnLinkFinder): Narzędzie służące do odkrywania punktów końcowych dla określonego celu.
* [**waymore**](https://github.com/xnl-h4ck3r/waymore)**:** Odkrywa linki z maszyny wayback (pobierając również odpowiedzi z maszyny wayback i szukając więcej linków).
* [**HTTPLoot**](https://github.com/redhuntlabs/HTTPLoot) (go): Przeszukuje (nawet wypełniając formularze) i znajduje również poufne informacje, korzystając z określonych wyrażeń regularnych.
* [**SpiderSuite**](https://github.com/3nock/SpiderSuite): Spider Suite to zaawansowany wielofunkcyjny GUI Crawler/Spider do bezpieczeństwa sieciowego, przeznaczony dla profesjonalistów ds. cyberbezpieczeństwa.
* [**jsluice**](https://github.com/BishopFox/jsluice) (go): Jest to pakiet Go i [narzędzie wiersza poleceń](https://github.com/BishopFox/jsluice/blob/main/cmd/jsluice) do wyodrębniania adresów URL, ścieżek, sekretów i innych interesujących danych z kodu źródłowego JavaScript.
* [**ParaForge**](https://github.com/Anof-cyber/ParaForge): ParaForge to proste rozszerzenie **Burp Suite**, które wyodrębnia parametry i punkty końcowe z żądania w celu utworzenia niestandardowej listy słów do fuzzowania i wyliczania.

### Brute Force katalogów i plików

Rozpocznij **brute-forcing** od folderu głównego i upewnij się, że brute-force jest stosowany dla **wszystkich znalezionych katalogów** za pomocą **tej metody** oraz dla wszystkich katalogów **odkrytych** przez **Spidering** (można to zrobić brute-force'em **rekurencyjnie** i dodając na początku używanej listy słów nazwy znalezionych katalogów).\
Narzędzia:

* **Dirb** / **Dirbuster** - Zawarte w Kali, **stare** (i **wolne**), ale funkcjonalne. Pozwalają na używanie samopod
* [https://github.com/google/fuzzing/tree/master/dictionaries](https://github.com/google/fuzzing/tree/master/dictionaries)
* [https://github.com/six2dez/OneListForAll](https://github.com/six2dez/OneListForAll)
* [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
* _/usr/share/wordlists/dirb/common.txt_
* _/usr/share/wordlists/dirb/big.txt_
* _/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt_

_Zauważ, że za każdym razem, gdy odkryjesz nowy katalog podczas ataku brute-force lub przeszukiwania, powinieneś go poddać atakowi brute-force._

### Co sprawdzić w każdym znalezionym pliku

* [**Sprawdzacz uszkodzonych linków**](https://github.com/stevenvachon/broken-link-checker): Znajdź uszkodzone linki wewnątrz plików HTML, które mogą być podatne na przejęcie
* **Kopie zapasowe plików**: Gdy już znajdziesz wszystkie pliki, poszukaj kopii zapasowych wszystkich plików wykonywalnych ("_.php_", "_.aspx_"...). Powszechne warianty nazw kopii zapasowych to: _file.ext\~, #file.ext#, \~file.ext, file.ext.bak, file.ext.tmp, file.ext.old, file.bak, file.tmp i file.old._ Możesz również użyć narzędzi [**bfac**](https://github.com/mazen160/bfac) **lub** [**backup-gen**](https://github.com/Nishantbhagat57/backup-gen)**.**
* **Odkrywanie nowych parametrów**: Możesz użyć narzędzi takich jak [**Arjun**](https://github.com/s0md3v/Arjun)**,** [**parameth**](https://github.com/maK-/parameth)**,** [**x8**](https://github.com/sh1yo/x8) **i** [**Param Miner**](https://github.com/PortSwigger/param-miner) **do odkrywania ukrytych parametrów. Jeśli możesz, spróbuj wyszukać** ukryte parametry w każdym wykonywalnym pliku internetowym.
* _Arjun wszystkie domyślne listy słów:_ [https://github.com/s0md3v/Arjun/tree/master/arjun/db](https://github.com/s0md3v/Arjun/tree/master/arjun/db)
* _Param-miner "params":_ [https://github.com/PortSwigger/param-miner/blob/master/resources/params](https://github.com/PortSwigger/param-miner/blob/master/resources/params)
* _Assetnote "parameters\_top\_1m":_ [https://wordlists.assetnote.io/](https://wordlists.assetnote.io)
* _nullenc0de "params.txt":_ [https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773](https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773)
* **Komentarze:** Sprawdź komentarze we wszystkich plikach, możesz znaleźć **dane uwierzytelniające** lub **ukrytą funkcjonalność**.
* Jeśli grasz w **CTF**, "powszechnym" trikiem jest **ukrycie informacji** wewnątrz komentarzy na **prawej** stronie **strony** (używając **setek** spacji, aby nie widzieć danych, jeśli otworzysz kod źródłowy w przeglądarce). Inna możliwość to użycie **kilku nowych linii** i **ukrycie informacji** w komentarzu na **dole** strony internetowej.
* **Klucze API**: Jeśli **znajdziesz jakikolwiek klucz API**, istnieje przewodnik, który wskazuje, jak używać kluczy API różnych platform: [**keyhacks**](https://github.com/streaak/keyhacks)**,** [**zile**](https://github.com/xyele/zile.git)**,** [**truffleHog**](https://github.com/trufflesecurity/truffleHog)**,** [**SecretFinder**](https://github.com/m4ll0k/SecretFinder)**,** [**RegHex**](https://github.com/l4yton/RegHex\)/)**,** [**DumpsterDive**](https://github.com/securing/DumpsterDiver)**,** [**EarlyBird**](https://github.com/americanexpress/earlybird)
* Klucze API Google: Jeśli znajdziesz jakikolwiek klucz API wyglądający jak **AIza**SyA-qLheq6xjDiEIRisP\_ujUseYLQCHUjik, możesz użyć projektu [**gmapapiscanner**](https://github.com/ozguralp/gmapsapiscanner), aby sprawdzić, do których interfejsów API klucz ma dostęp.
* **Kosze S3**: Podczas przeszukiwania zwróć uwagę, czy jakikolwiek **poddomena** lub **link** jest powiązany z jakimś **koszem S3**. W takim przypadku [**sprawdź uprawnienia** kosza](buckets/).

### Specjalne znaleziska

Podczas **przeszukiwania** i **ataku brute-force** możesz natrafić na **ciekawe rzeczy**, na które musisz zwrócić uwagę.

**Ciekawe pliki**

* Szukaj **linków** do innych plików wewnątrz plików **CSS**.
* [Jeśli znajdziesz plik _**.git**_, można z niego wyciągnąć pewne informacje](git.md)
* Jeśli znajdziesz plik _**.env**_, można w nim znaleźć informacje takie jak klucze API, hasła do baz danych i inne informacje.
* Jeśli znajdziesz **punkty końcowe API**, [również powinieneś je przetestować](web-api-pentesting.md). Nie są to pliki, ale prawdopodobnie będą na nie wyglądać.
* **Pliki JS**: W sekcji przeszukiwania wspomniano o kilku narzędziach, które mogą wyodrębnić ścieżki z plików JS. Ponadto, interesujące byłoby **monitorowanie każdego znalezionego pliku JS**, ponieważ w niektórych przypadkach zmiana może wskazywać na potencjalną podatność wprowadzoną w kodzie. Możesz na przykład użyć [**JSMon**](https://github.com/robre/jsmon)**.**
* Powinieneś również sprawdzić znalezione pliki JS za pomocą [**RetireJS**](https://github.com/retirejs/retire.js/) lub [**JSHole**](https://github.com/callforpapers-source/jshole), aby sprawdzić, czy są podatne.
* **Deobfuskator i rozpakowywacz JavaScript**: [https://lelinhtinh.github.io/de4js/](https://lelinhtinh.github.io/de4js/), [https://www.dcode.fr/javascript-unobfuscator](https://www.dcode.fr/javascript-unobfuscator)
* **Upiększacz JavaScript**: [http://jsbeautifier.org/](https://beautifier.io), [http://jsnice.org/](http://jsnice.org)
* **Deobfuskacja JsFuck** (javascript z znakami: "\[]!+" [https://ooze.ninja/javascript/poisonjs/](https://ooze.ninja/javascript/poisonjs/))
* [**TrainFuck**](https://github.com/taco-c/trainfuck)**:** `+72.+29.+7..+3.-67.-12.+55.+24.+3.-6.-8.-67.-23.`
* W wielu przypadkach będziesz musiał **zrozumieć wyrażenia regularne**, które są używane, to będzie przydatne: [https://regex101.com/](https://regex101.com)
* Możesz również **monitorować pliki, w których wykryto formularze**, ponieważ zmiana w parametrze
### Sprawdzanie podatności na stronach internetowych

Po przeprowadzeniu kompleksowego wyliczenia aplikacji internetowej nadszedł czas, aby sprawdzić wiele możliwych podatności. Możesz znaleźć listę kontrolną tutaj:

{% content-ref url="../../pentesting-web/web-vulnerabilities-methodology/" %}
[web-vulnerabilities-methodology](../../pentesting-web/web-vulnerabilities-methodology/)
{% endcontent-ref %}

Dowiedz się więcej o podatnościach na stronach internetowych tutaj:

* [https://six2dez.gitbook.io/pentest-book/others/web-checklist](https://six2dez.gitbook.io/pentest-book/others/web-checklist)
* [https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web\_application\_security\_testing/configuration\_and\_deployment\_management\_testing.html](https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web\_application\_security\_testing/configuration\_and\_deployment\_management\_testing.html)
* [https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection](https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection)

### Monitorowanie stron pod kątem zmian

Możesz użyć narzędzi takich jak [https://github.com/dgtlmoon/changedetection.io](https://github.com/dgtlmoon/changedetection.io), aby monitorować strony pod kątem modyfikacji, które mogą wprowadzać podatności.

### Automatyczne polecenia HackTricks
```
Protocol_Name: Web    #Protocol Abbreviation if there is one.
Port_Number:  80,443     #Comma separated if there is more than one.
Protocol_Description: Web         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for Web
Note: |
https://book.hacktricks.xyz/pentesting/pentesting-web

Entry_2:
Name: Quick Web Scan
Description: Nikto and GoBuster
Command: nikto -host {Web_Proto}://{IP}:{Web_Port} &&&& gobuster dir -w {Small_Dirlist} -u {Web_Proto}://{IP}:{Web_Port} && gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_3:
Name: Nikto
Description: Basic Site Info via Nikto
Command: nikto -host {Web_Proto}://{IP}:{Web_Port}

Entry_4:
Name: WhatWeb
Description: General purpose auto scanner
Command: whatweb -a 4 {IP}

Entry_5:
Name: Directory Brute Force Non-Recursive
Description:  Non-Recursive Directory Brute Force
Command: gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_6:
Name: Directory Brute Force Recursive
Description: Recursive Directory Brute Force
Command: python3 {Tool_Dir}dirsearch/dirsearch.py -w {Small_Dirlist} -e php,exe,sh,py,html,pl -f -t 20 -u {Web_Proto}://{IP}:{Web_Port} -r 10

Entry_7:
Name: Directory Brute Force CGI
Description: Common Gateway Interface Brute Force
Command: gobuster dir -u {Web_Proto}://{IP}:{Web_Port}/ -w /usr/share/seclists/Discovery/Web-Content/CGIs.txt -s 200

Entry_8:
Name: Nmap Web Vuln Scan
Description: Tailored Nmap Scan for web Vulnerabilities
Command: nmap -vv --reason -Pn -sV -p {Web_Port} --script=`banner,(http* or ssl*) and not (brute or broadcast or dos or external or http-slowloris* or fuzzer)` {IP}

Entry_9:
Name: Drupal
Description: Drupal Enumeration Notes
Note: |
git clone https://github.com/immunIT/drupwn.git for low hanging fruit and git clone https://github.com/droope/droopescan.git for deeper enumeration

Entry_10:
Name: WordPress
Description: WordPress Enumeration with WPScan
Command: |
?What is the location of the wp-login.php? Example: /Yeet/cannon/wp-login.php
wpscan --url {Web_Proto}://{IP}{1} --enumerate ap,at,cb,dbe && wpscan --url {Web_Proto}://{IP}{1} --enumerate u,tt,t,vp --passwords {Big_Passwordlist} -e

Entry_11:
Name: WordPress Hydra Brute Force
Description: Need User (admin is default)
Command: hydra -l admin -P {Big_Passwordlist} {IP} -V http-form-post '/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log In&testcookie=1:S=Location'

Entry_12:
Name: Ffuf Vhost
Description: Simple Scan with Ffuf for discovering additional vhosts
Command: ffuf -w {Subdomain_List}:FUZZ -u {Web_Proto}://{Domain_Name} -H "Host:FUZZ.{Domain_Name}" -c -mc all {Ffuf_Filters}
```
<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Wskazówka dotycząca nagrody za błąd**: **Zarejestruj się** na platformie **Intigriti**, premium platforma do nagradzania za błędy stworzona przez hakerów, dla hakerów! Dołącz do nas na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) już dziś i zacznij zarabiać nagrody do **100 000 USD**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
