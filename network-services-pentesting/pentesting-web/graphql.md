# GraphQL

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## Einf√ºhrung

GraphQL wird als **effiziente Alternative** zu REST-APIs hervorgehoben und bietet einen vereinfachten Ansatz zum Abfragen von Daten vom Backend. Im Gegensatz zu REST, bei dem oft zahlreiche Anfragen an verschiedene Endpunkte gestellt werden m√ºssen, um Daten zu sammeln, erm√∂glicht GraphQL das Abrufen aller erforderlichen Informationen durch eine **einzige Anfrage**. Diese Vereinfachung kommt den Entwicklern erheblich zugute, da sie die Komplexit√§t ihrer Datenabrufprozesse verringert.

## GraphQL und Sicherheit

Mit dem Aufkommen neuer Technologien, einschlie√ülich GraphQL, entstehen auch neue Sicherheitsl√ºcken. Ein wichtiger Punkt ist, dass **GraphQL standardm√§√üig keine Authentifizierungsmechanismen enth√§lt**. Es liegt in der Verantwortung der Entwickler, solche Sicherheitsma√ünahmen zu implementieren. Ohne ordnungsgem√§√üe Authentifizierung k√∂nnen GraphQL-Endpunkte sensible Informationen f√ºr nicht authentifizierte Benutzer freigeben und somit ein erhebliches Sicherheitsrisiko darstellen.

### Verzeichnis-Brute-Force-Angriffe und GraphQL

Zur Identifizierung von freiliegenden GraphQL-Instanzen wird die Einbeziehung spezifischer Pfade in Verzeichnis-Brute-Force-Angriffen empfohlen. Diese Pfade sind:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Die Identifizierung offener GraphQL-Instanzen erm√∂glicht die Untersuchung unterst√ºtzter Abfragen. Dies ist entscheidend, um die √ºber den Endpunkt zug√§nglichen Daten zu verstehen. Das Introspektionssystem von GraphQL erleichtert dies, indem es die Abfragen detailliert auflistet, die ein Schema unterst√ºtzt. F√ºr weitere Informationen hierzu siehe die GraphQL-Dokumentation zur Introspektion: [**GraphQL: Eine Abfragesprache f√ºr APIs.**](https://graphql.org/learn/introspection/)

### Fingerabdruck

Das Tool [**graphw00f**](https://github.com/dolevf/graphw00f) ist in der Lage zu erkennen, welcher GraphQL-Engine auf einem Server verwendet wird, und liefert dann einige hilfreiche Informationen f√ºr den Sicherheitspr√ºfer.

#### Universelle Abfragen <a href="#universal-queries" id="universal-queries"></a>

Um zu √ºberpr√ºfen, ob eine URL ein GraphQL-Dienst ist, kann eine **universelle Abfrage**, `query{__typename}`, gesendet werden. Wenn die Antwort `{"data": {"__typename": "Query"}}` enth√§lt, best√§tigt dies, dass die URL einen GraphQL-Endpunkt hostet. Diese Methode basiert auf dem Feld `__typename` von GraphQL, das den Typ des abgefragten Objekts offenbart.
```javascript
query{__typename}
```
### Grundlegende Aufz√§hlung

Graphql unterst√ºtzt in der Regel **GET**, **POST** (x-www-form-urlencoded) und **POST**(json). Obwohl es aus Sicherheitsgr√ºnden empfohlen wird, nur json zuzulassen, um CSRF-Angriffe zu verhindern.

#### Introspektion

Um die Schema-Informationen mithilfe der Introspektion zu entdecken, abfragen Sie das `__schema`-Feld. Dieses Feld ist auf dem Wurzeltyp aller Abfragen verf√ºgbar.
```bash
query={__schema{types{name,fields{name}}}}
```
Mit dieser Abfrage finden Sie den Namen aller verwendeten Typen:

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Mit dieser Abfrage k√∂nnen Sie alle Typen, deren Felder und Argumente (und den Typ der Argumente) extrahieren. Dies ist sehr n√ºtzlich, um zu wissen, wie die Datenbank abgefragt werden kann.

![](<../../.gitbook/assets/image (207) (3).png>)

**Fehler**

Es ist interessant zu wissen, ob die **Fehler** angezeigt werden, da sie n√ºtzliche **Informationen** liefern werden.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**Datenbank-Schema √ºber Introspektion aufz√§hlen**

{% hint style="info" %}
Wenn die Introspektion aktiviert ist, aber die obige Abfrage nicht ausgef√ºhrt wird, versuchen Sie, die Direktiven `onOperation`, `onFragment` und `onField` aus der Abfragestruktur zu entfernen.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Inline Inspektionsabfrage:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Die letzte Codezeile ist eine GraphQL-Abfrage, die alle Metainformationen aus dem GraphQL (Objektnamen, Parameter, Typen...) ausgibt.

![](<../../.gitbook/assets/image (206).png>)

Wenn die Introspektion aktiviert ist, k√∂nnen Sie [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) verwenden, um in einer GUI alle Optionen anzuzeigen.

### Abfragen

Nun, da wir wissen, welche Art von Informationen in der Datenbank gespeichert sind, versuchen wir, **einige Werte abzurufen**.

In der Introspektion k√∂nnen Sie herausfinden, **welches Objekt Sie direkt abfragen k√∂nnen** (weil Sie ein Objekt nicht einfach abfragen k√∂nnen, nur weil es existiert). Im folgenden Bild sehen Sie, dass der "_queryType_" "_Query_" genannt wird und dass eines der Felder des "_Query_"-Objekts "_flags_" ist, das auch ein Objekttyp ist. Daher k√∂nnen Sie das Flag-Objekt abfragen.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Beachten Sie, dass der Typ der Abfrage "_flags_" "_Flags_" ist, und dieses Objekt wie folgt definiert ist:

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

Sie sehen, dass die "_Flags_"-Objekte aus **Name** und **Wert** bestehen. Dann k√∂nnen Sie alle Namen und Werte der Flags mit der Abfrage erhalten:
```javascript
query={flags{name, value}}
```
Beachten Sie, dass im Falle des **abzufragenden Objekts** ein **primitiver Typ** wie **String** ist, wie im folgenden Beispiel

![](<../../.gitbook/assets/image (441).png>)

Sie k√∂nnen es einfach abfragen mit:
```javascript
query={hiddenFlags}
```
In einem anderen Beispiel, in dem sich 2 Objekte innerhalb des "_Query_"-Typobjekts befanden: "_user_" und "_users_".\
Wenn diese Objekte keine Argumente zum Suchen ben√∂tigen, k√∂nnten Sie **alle Informationen von ihnen abrufen**, indem Sie einfach nach den Daten fragen, die Sie m√∂chten. In diesem Beispiel aus dem Internet k√∂nnten Sie Benutzernamen und Passw√∂rter extrahieren:

![](<../../.gitbook/assets/image (208).png>)

Jedoch erhalten Sie in diesem Beispiel bei dem Versuch, dies zu tun, diesen **Fehler**:

![](<../../.gitbook/assets/image (210).png>)

Es scheint, dass auf irgendeine Weise nach dem "_**uid**_"-Argument vom Typ _**Int**_ gesucht wird.\
Wie auch immer, wir wussten bereits, dass in der [Grundlegenden Aufz√§hlung](graphql.md#basic-enumeration) ein Abfrage vorgeschlagen wurde, die uns alle ben√∂tigten Informationen zeigte: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Wenn Sie das bereitgestellte Bild lesen, sehen Sie, dass "_**user**_" das **Arg** "_**uid**_" vom Typ _Int_ hatte.

Daher habe ich durch Ausf√ºhren eines leichten _**uid**_-Bruteforces herausgefunden, dass bei _**uid**=**1**_ ein Benutzername und ein Passwort abgerufen wurden:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Beachten Sie, dass ich **herausgefunden** habe, dass ich nach den **Parametern** "_**user**_" und "_**password**_" fragen konnte, denn wenn ich nach etwas suche, das nicht existiert (`query={user(uid:1){noExists}}`), erhalte ich diesen Fehler:

![](<../../.gitbook/assets/image (213).png>)

Und w√§hrend der **Aufz√§hlungsphase** habe ich herausgefunden, dass das "_**dbuser**_"-Objekt die Felder "_**user**_" und "_**password**_ hatte.

**Abfragezeichenfolgen-Dump-Trick (Dank an @BinaryShadow\_)**

Wenn Sie nach einem String-Typ suchen k√∂nnen, wie z. B.: `query={theusers(description: ""){username,password}}` und Sie nach einem leeren String suchen, werden alle Daten **ausgegeben**. (_Beachten Sie, dass dieses Beispiel nicht mit dem Beispiel der Tutorials zusammenh√§ngt. Nehmen Sie f√ºr dieses Beispiel an, dass Sie mit "**theusers**" nach einem String-Feld namens "**description**" suchen k√∂nnen"_).

### Suche

In dieser Konfiguration enth√§lt eine **Datenbank** **Personen** und **Filme**. **Personen** werden anhand ihrer **E-Mail** und ihres **Namens** identifiziert; **Filme** anhand ihres **Namens** und ihrer **Bewertung**. **Personen** k√∂nnen miteinander befreundet sein und haben auch Filme, was auf Beziehungen innerhalb der Datenbank hinweist.

Sie k√∂nnen Personen **nach** dem **Namen** suchen und ihre E-Mails erhalten:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Sie k√∂nnen Personen **nach** dem **Namen** suchen und ihre **abonnierten** **Filme** erhalten:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Beachten Sie, wie angegeben ist, den `name` der `subscribedMovies` der Person abzurufen.

Sie k√∂nnen auch **mehrere Objekte gleichzeitig suchen**. In diesem Fall wird eine Suche nach 2 Filmen durchgef√ºhrt:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Oder sogar **Beziehungen mehrerer verschiedener Objekte unter Verwendung von Aliassen**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutationen

**Mutationen werden verwendet, um √Ñnderungen auf der Serverseite vorzunehmen.**

In der **Introspektion** k√∂nnen die **deklarierten Mutationen** gefunden werden. Im folgenden Bild wird der "_MutationType_" als "_Mutation_" bezeichnet und das "_Mutation_"-Objekt enth√§lt die Namen der Mutationen (wie "_addPerson_" in diesem Fall):

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

In diesem Setup enth√§lt eine **Datenbank** **Personen** und **Filme**. **Personen** werden anhand ihrer **E-Mail** und ihres **Namens** identifiziert; **Filme** anhand ihres **Namens** und ihrer **Bewertung**. **Personen** k√∂nnen miteinander befreundet sein und auch Filme haben, was Beziehungen innerhalb der Datenbank anzeigt.

Eine Mutation zum **Erstellen neuer** Filme in der Datenbank k√∂nnte wie folgt aussehen (in diesem Beispiel wird die Mutation `addMovie` genannt):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Beachten Sie, wie sowohl die Werte als auch der Datentyp in der Abfrage angegeben sind.**

Zus√§tzlich unterst√ºtzt die Datenbank eine **Mutation**-Operation namens `addPerson`, die die Erstellung von **Personen** zusammen mit ihren Verkn√ºpfungen zu vorhandenen **Freunden** und **Filmen** erm√∂glicht. Es ist entscheidend zu beachten, dass die Freunde und Filme vor dem Verkn√ºpfen mit der neu erstellten Person bereits in der Datenbank vorhanden sein m√ºssen.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Direktiven√ºberlastung

Wie in [**einer der Schwachstellen, die in diesem Bericht beschrieben sind**](https://www.landh.tech/blog/20240304-google-hack-50000/) erkl√§rt, bedeutet eine Direktiven√ºberlastung, eine Direktive sogar Millionen Mal aufzurufen, um den Server dazu zu bringen, Operationen zu verschwenden, bis es m√∂glich ist, ihn zu DoS-en.

### Batch-Brute-Force in 1 API-Anfrage

Diese Information stammt von [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Authentifizierung √ºber GraphQL-API durch **gleichzeitiges Senden vieler Abfragen mit verschiedenen Anmeldeinformationen** zur √úberpr√ºfung. Es handelt sich um einen klassischen Brute-Force-Angriff, aber jetzt ist es m√∂glich, mehr als ein Login/Passwort-Paar pro HTTP-Anfrage zu senden, aufgrund der GraphQL-Batch-Funktion. Dieser Ansatz w√ºrde externe Rate-Monitoring-Anwendungen dazu bringen, zu glauben, dass alles in Ordnung ist und es keinen Brute-Force-Bot gibt, der versucht, Passw√∂rter zu erraten.

Im Folgenden finden Sie die einfachste Demonstration einer Authentifizierungsanfrage der Anwendung, mit **3 verschiedenen E-Mail/Passwort-Paaren gleichzeitig**. Offensichtlich ist es m√∂glich, auf die gleiche Weise Tausende in einer einzigen Anfrage zu senden:

![](<../../.gitbook/assets/image (182) (1).png>)

Wie aus dem Antwort-Screenshot ersichtlich ist, haben die ersten und dritten Anfragen _null_ zur√ºckgegeben und die entsprechenden Informationen im _error_-Abschnitt reflektiert. Die **zweite Mutation enthielt die korrekten Authentifizierungsdaten** und die Antwort enthielt das korrekte Authentifizierungssitzungstoken.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Ohne Introspektion

Immer mehr **GraphQL-Endpunkte deaktivieren die Introspektion**. Die Fehler, die GraphQL wirft, wenn eine unerwartete Anfrage empfangen wird, reichen jedoch aus, damit Tools wie [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) den Gro√üteil des Schemas rekonstruieren k√∂nnen.

Dar√ºber hinaus beobachtet die Burp Suite-Erweiterung [**GraphQuail**](https://github.com/forcesunseen/graphquail) **GraphQL-API-Anfragen, die durch Burp gehen** und **erstellt** ein internes GraphQL-**Schema** mit jeder neuen Abfrage, die es sieht. Es kann auch das Schema f√ºr GraphiQL und Voyager freigeben. Die Erweiterung gibt eine gef√§lschte Antwort zur√ºck, wenn sie eine Introspektionsabfrage erh√§lt. Als Ergebnis zeigt GraphQuail alle Abfragen, Argumente und Felder, die innerhalb der API verwendet werden k√∂nnen. F√ºr weitere Informationen [**√ºberpr√ºfen Sie dies**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Eine sch√∂ne **Wortliste** zur Entdeckung von [**GraphQL-Entit√§ten finden Sie hier**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Umgehung von GraphQL-Introspektionsabwehr <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **Umgehung von GraphQL-Introspektionsabwehr**

Um Beschr√§nkungen bei Introspektionsabfragen in APIs zu umgehen, erweist sich das Einf√ºgen eines **Sonderzeichens nach dem `__schema`-Schl√ºsselwort** als wirksam. Diese Methode nutzt h√§ufige Entwicklerfehler in Regex-Mustern aus, die darauf abzielen, die Introspektion durch Fokussierung auf das `__schema`-Schl√ºsselwort zu blockieren. Durch das Hinzuf√ºgen von Zeichen wie **Leerzeichen, Zeilenumbr√ºche und Kommas**, die von GraphQL ignoriert werden, aber m√∂glicherweise nicht in Regex ber√ºcksichtigt werden, k√∂nnen Beschr√§nkungen umgangen werden. Beispielsweise kann eine Introspektionsabfrage mit einem Zeilenumbruch nach `__schema` solche Abwehrmechanismen umgehen:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Wenn dies nicht erfolgreich ist, sollten alternative Anfragemethoden in Betracht gezogen werden, wie z. B. **GET-Anfragen** oder **POST mit `x-www-form-urlencoded`**, da Einschr√§nkungen m√∂glicherweise nur f√ºr POST-Anfragen gelten.

### **Aufdecken von freigelegten GraphQL-Strukturen**

Wenn die Introspektion deaktiviert ist, ist die Untersuchung des Quellcodes der Website nach vorab geladenen Abfragen in JavaScript-Bibliotheken eine n√ºtzliche Strategie. Diese Abfragen k√∂nnen mithilfe des `Quellen`-Tabs in den Entwicklertools gefunden werden und Einblicke in das API-Schema bieten sowie potenziell **sensible freigelegte Abfragen** aufdecken. Die Befehle zum Suchen in den Entwicklertools sind:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF in GraphQL

Wenn Sie nicht wissen, was CSRF ist, lesen Sie die folgende Seite:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Drau√üen werden Sie mehrere GraphQL-Endpunkte finden, die **ohne CSRF-Token konfiguriert sind.**

Beachten Sie, dass GraphQL-Anfragen normalerweise √ºber POST-Anfragen mit dem Content-Type **`application/json`** gesendet werden.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Jedoch unterst√ºtzen die meisten GraphQL-Endpunkte auch **`form-urlencoded` POST-Anfragen:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Daher ist es m√∂glich, √Ñnderungen im GraphQL vorzunehmen, indem CSRF-Anfragen wie die vorherigen **ohne Vorabpr√ºfungsanfragen** gesendet werden.

Beachten Sie jedoch, dass der neue Standard-Cookie-Wert des `samesite`-Flags von Chrome `Lax` ist. Dies bedeutet, dass das Cookie nur von einer Drittanbieter-Website in GET-Anfragen gesendet wird.

Es ist in der Regel m√∂glich, die **Abfrageanfrage** auch als **GET**-Anfrage zu senden, und das CSRF-Token wird m√∂glicherweise nicht in einer GET-Anfrage validiert.

Durch die Ausnutzung eines [**XS-Search**](../../pentesting-web/xs-search.md)-**Angriffs** k√∂nnte es m√∂glich sein, Inhalte aus dem GraphQL-Endpunkt unter Ausnutzung der Anmeldeinformationen des Benutzers zu exfiltrieren.

F√ºr weitere Informationen **√ºberpr√ºfen Sie den** [**Originalbeitrag hier**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autorisierung in GraphQL

Viele in dem Endpunkt definierte GraphQL-Funktionen √ºberpr√ºfen m√∂glicherweise nur die Authentifizierung des Anfragenden, jedoch nicht die Autorisierung.

Das √Ñndern von Abfrageeingabevariablen k√∂nnte zu sensiblen Kontodetails f√ºhren, die [offengelegt](https://hackerone.com/reports/792927) werden.

Mutationen k√∂nnten sogar zu Account-√úbernahmen f√ºhren, wenn versucht wird, Daten eines anderen Kontos zu √§ndern.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Umgehung der Autorisierung in GraphQL

Das Verketten von Abfragen kann ein schwaches Authentifizierungssystem umgehen.

Im folgenden Beispiel sehen Sie, dass die Operation "forgotPassword" ist und dass nur die damit verbundene forgotPassword-Abfrage ausgef√ºhrt werden sollte. Dies kann umgangen werden, indem am Ende eine weitere Abfrage hinzugef√ºgt wird. In diesem Fall f√ºgen wir "register" hinzu und eine Benutzervariable, damit sich das System als neuer Benutzer registriert.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Umgehung von Rate Limits unter Verwendung von Aliassen in GraphQL

In GraphQL sind Aliasse ein leistungsstarkes Feature, das es erm√∂glicht, **Eigenschaften explizit zu benennen**, wenn eine API-Anfrage gestellt wird. Diese Funktion ist besonders n√ºtzlich, um **mehrere Instanzen desselben Objekttyps** innerhalb einer einzigen Anfrage abzurufen. Aliasse k√∂nnen eingesetzt werden, um die Einschr√§nkung zu √ºberwinden, die verhindert, dass GraphQL-Objekte mehrere Eigenschaften mit demselben Namen haben.

F√ºr ein detailliertes Verst√§ndnis von GraphQL-Aliassen wird die folgende Ressource empfohlen: [Aliasse](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

W√§hrend der Hauptzweck von Aliassen darin besteht, die Notwendigkeit f√ºr zahlreiche API-Aufrufe zu reduzieren, wurde ein unbeabsichtigter Anwendungsfall identifiziert, bei dem Aliasse genutzt werden k√∂nnen, um Brute-Force-Angriffe auf einen GraphQL-Endpunkt auszuf√ºhren. Dies ist m√∂glich, da einige Endpunkte durch Rate-Limiter gesch√ºtzt sind, die darauf ausgelegt sind, Brute-Force-Angriffe zu vereiteln, indem sie die **Anzahl der HTTP-Anfragen** beschr√§nken. Diese Rate-Limiter ber√ºcksichtigen m√∂glicherweise jedoch nicht die Anzahl der Operationen innerhalb jeder Anfrage. Da Aliasse das Einbeziehen mehrerer Abfragen in einer einzigen HTTP-Anfrage erm√∂glichen, k√∂nnen sie solche Rate-Limiting-Ma√ünahmen umgehen.

Betrachten Sie das untenstehende Beispiel, das veranschaulicht, wie aliased Abfragen verwendet werden k√∂nnen, um die G√ºltigkeit von Rabattcodes im Gesch√§ft zu √ºberpr√ºfen. Diese Methode k√∂nnte das Rate Limiting umgehen, da sie mehrere Abfragen in einer HTTP-Anfrage zusammenfasst und somit die √úberpr√ºfung zahlreicher Rabattcodes gleichzeitig erm√∂glicht.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Werkzeuge

### Schwachstellen-Scanner

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit, das verwendet werden kann, um Schemas abzurufen und nach sensiblen Daten zu suchen, Autorisierung zu testen, Schemas per Bruteforce anzugreifen und Pfade zu einem bestimmten Typ zu finden.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Kann eigenst√§ndig oder als [Burp-Erweiterung](https://github.com/doyensec/inql) verwendet werden.
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Kann auch als CLI-Client verwendet werden, um Angriffe zu automatisieren.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Tool, das die verschiedenen M√∂glichkeiten auflistet, einen bestimmten Typ in einem GraphQL-Schema zu erreichen.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp-Erweiterung f√ºr fortgeschrittenes GraphQL-Testing. Der _**Scanner**_ ist der Kern von InQL v5.0, mit dem Sie einen GraphQL-Endpunkt oder eine lokale Introspektions-Schema-Datei analysieren k√∂nnen. Es generiert automatisch alle m√∂glichen Abfragen und Mutationen und organisiert sie in einer strukturierten Ansicht f√ºr Ihre Analyse. Die _**Attacker**_-Komponente erm√∂glicht das Ausf√ºhren von Stapel-GraphQL-Angriffen, was n√ºtzlich sein kann, um schlecht implementierte Rate-Limits zu umgehen.

### Clients

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI-Client
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI-Client

### Automatische Tests

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video, das AutoGraphQL erkl√§rt: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Referenzen

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
