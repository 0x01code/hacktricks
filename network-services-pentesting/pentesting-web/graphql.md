# GraphQL

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Uvod

GraphQL je **istican** kao **efikasna alternativa** REST API-ju, nudeći pojednostavljen pristup za upitivanje podataka sa backend-a. Za razliku od REST-a, koji često zahteva brojne zahteve na različitim endpoint-ima kako bi se prikupili podaci, GraphQL omogućava dobijanje svih potrebnih informacija putem **jednog zahteva**. Ovo pojednostavljenje značajno **pomaže developerima** smanjujući složenost njihovih procesa prikupljanja podataka.

## GraphQL i bezbednost

Sa pojavom novih tehnologija, uključujući GraphQL, pojavljuju se i nove bezbednosne ranjivosti. Važno je napomenuti da **GraphQL ne uključuje mehanizme za autentifikaciju po default-u**. Odgovornost je developera da implementiraju takve bezbednosne mere. Bez odgovarajuće autentifikacije, GraphQL endpoint-i mogu otkriti osetljive informacije neautentifikovanim korisnicima, predstavljajući značajan bezbednosni rizik.

### Napadi brute force na direktorijume i GraphQL

Da bi se identifikovali izloženi GraphQL instanci, preporučuje se uključivanje određenih putanja u napade brute force na direktorijume. Ove putanje su:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

Identifikacija otvorenih GraphQL instanci omogućava pregled podržanih upita. Ovo je ključno za razumevanje podataka koji su dostupni putem endpoint-a. GraphQL-ov sistem introspekcije olakšava ovo detaljisanjem upita koje šema podržava. Za više informacija o tome, pogledajte GraphQL dokumentaciju o introspekciji: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Fingerprint

Alat [**graphw00f**](https://github.com/dolevf/graphw00f) je sposoban da otkrije koji GraphQL engine se koristi na serveru, a zatim ispisuje neke korisne informacije za bezbednosnog auditora.

#### Univerzalni upiti <a href="#universal-queries" id="universal-queries"></a>

Da biste proverili da li je URL GraphQL servis, može se poslati **univerzalni upit**, `query{__typename}`. Ako odgovor sadrži `{"data": {"__typename": "Query"}}`, potvrđuje da URL hostuje GraphQL endpoint. Ova metoda se oslanja na GraphQL-ovu `__typename` polje, koje otkriva tip objekta koji je upitan.
```javascript
query{__typename}
```
### Osnovno prebrojavanje

Graphql obično podržava **GET**, **POST** (x-www-form-urlencoded) i **POST**(json). Iako je iz sigurnosnih razloga preporučljivo dozvoliti samo json kako bi se sprečili CSRF napadi.

#### Introspekcija

Da biste koristili introspekciju za otkrivanje informacija o šemi, upitajte polje `__schema`. Ovo polje je dostupno na korenskom tipu svih upita.
```bash
query={__schema{types{name,fields{name}}}}
```
Sa ovim upitom ćete pronaći ime svih tipova koji se koriste:

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Sa ovim upitom možete izvući sve tipove, polja i argumente (i tip argumenata). Ovo će biti veoma korisno da biste znali kako da upitate bazu podataka.

![](<../../.gitbook/assets/image (207) (3).png>)

**Greške**

Interesantno je znati da li će **greške** biti **prikazane**, jer će pružiti korisne **informacije**.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (205) (1).png>)

**Enumeriraj šemu baze podataka putem introspekcije**

{% hint style="info" %}
Ako je omogućena introspekcija, ali gornji upit ne radi, pokušajte ukloniti direktive `onOperation`, `onFragment` i `onField` iz strukture upita.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Inline inspekcijski upit:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Poslednja linija koda je GraphQL upit koji će izlistati sve meta-informacije iz GraphQL-a (imena objekata, parametri, tipovi...)

![](<../../.gitbook/assets/image (206).png>)

Ako je omogućena introspekcija, možete koristiti [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) da biste u GUI-ju videli sve opcije.

### Upiti

Sada kada znamo kakve informacije su sačuvane u bazi podataka, pokušajmo **izvući neke vrednosti**.

U introspekciji možete pronaći **koji objekat možete direktno upitati** (jer ne možete upitati objekat samo zato što postoji). Na sledećoj slici možete videti da se "_queryType_" zove "_Query_" i da je jedno od polja objekta "_Query_" "_flags_", koji je takođe tip objekta. Stoga možete upitati objekat flag.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Primetite da je tip upita "_flags_" "_Flags_", a ovaj objekat je definisan kao što je prikazano ispod:

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

Možete videti da su objekti "_Flags_" sastavljeni od **imena** i **vrednosti**. Zatim možete dobiti sva imena i vrednosti zastava upitom:
```javascript
query={flags{name, value}}
```
Imajte na umu da u slučaju da je **objekat za upit** **primitivni tip** kao što je **string** kao u sledećem primeru

![](<../../.gitbook/assets/image (441).png>)

Možete ga jednostavno upitati sa:
```javascript
query={hiddenFlags}
```
U drugom primeru gde su postojala 2 objekta unutar "_Query_" tipa objekta: "_user_" i "_users_".\
Ako ovi objekti ne zahtevaju nikakav argument za pretragu, možete **dobiti sve informacije iz njih** tako što ćete samo **tražiti** podatke koje želite. U ovom primeru sa interneta možete izvući sačuvane korisničke imene i lozinke:

![](<../../.gitbook/assets/image (208).png>)

Međutim, u ovom primeru, ako pokušate to da uradite, dobićete ovu **grešku**:

![](<../../.gitbook/assets/image (210).png>)

Izgleda da će pretraga biti izvršena koristeći "_**uid**_" argument tipa _**Int**_.\
U svakom slučaju, već smo znali da je u odeljku [Osnovna enumeracija](graphql.md#basic-enumeration) predložen upit koji nam je prikazivao sve potrebne informacije: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Ako pročitate priloženu sliku kada pokrenem taj upit, videćete da je "_**user**_" imao **arg** "_**uid**_" tipa _Int_.

Dakle, izvršavajući neki lagani _**uid**_ bruteforce, otkrio sam da se u _**uid**=**1**_ dobijaju korisničko ime i lozinka:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Primetite da sam **otkrio** da mogu da tražim **parametre** "_**user**_" i "_**password**_" jer ako pokušam da pronađem nešto što ne postoji (`query={user(uid:1){noExists}}`) dobijam ovu grešku:

![](<../../.gitbook/assets/image (213).png>)

I tokom faze **enumeracije** otkrio sam da objekat "_**dbuser**_" ima polja "_**user**_" i "_**password**_.

**Triks sa ispisom upita u string formatu (hvala @BinaryShadow\_)**

Ako možete pretraživati po polju tipa string, kao što je: `query={theusers(description: ""){username,password}}` i **tražite prazan string**, to će **ispisati sve podatke**. (_Napomena: ovaj primer nije povezan sa primerom iz tutorijala, za ovaj primer pretpostavite da možete pretraživati koristeći "**theusers**" preko polja tipa String koje se zove "**description**"_).

### Pretraga

U ovom okruženju, **baza podataka** sadrži **osobe** i **filmove**. **Osobe** se identifikuju preko svoje **e-pošte** i **imena**; **filmovi** preko svog **imena** i **ocene**. **Osobe** mogu biti prijatelji jedni sa drugima i takođe imaju filmove, što ukazuje na odnose unutar baze podataka.

Možete **pretraživati** osobe **po** imenu i dobiti njihove e-pošte:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Možete **pretraživati** osobe **po** imenu i dobiti informacije o njihovim **pretplaćenim** **filmovima**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Obratite pažnju kako je naznačeno da se dobije `name` od `subscribedMovies` osobe.

Takođe možete **pretraživati više objekata istovremeno**. U ovom slučaju, vrši se pretraga 2 filma:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ili čak **odnosi nekoliko različitih objekata koristeći alias-e**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutacije

**Mutacije se koriste za pravljenje promena na serverskoj strani.**

U **introspekciji** možete pronaći **deklarisane** **mutacije**. Na sledećoj slici "_MutationType_" se naziva "_Mutation_" i objekat "_Mutation_" sadrži imena mutacija (kao što je "_addPerson_" u ovom slučaju):

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

U ovom okruženju, **baza podataka** sadrži **osobe** i **filmove**. **Osobe** se identifikuju preko svog **emaila** i **imena**; **filmovi** preko svog **imena** i **ocene**. **Osobe** mogu biti prijatelji jedni sa drugima i takođe imati filmove, što ukazuje na odnose unutar baze podataka.

Mutacija za **kreiranje novih** filmova u bazi podataka može izgledati ovako (u ovom primeru mutacija se naziva `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Primetite kako su i vrednosti i tipovi podataka naznačeni u upitu.**

Dodatno, baza podržava **mutaciju** operacije, nazvanu `addPerson`, koja omogućava kreiranje **osoba** zajedno sa njihovim povezivanjem sa postojećim **prijateljima** i **filmovima**. Važno je napomenuti da prijatelji i filmovi moraju već postojati u bazi podataka pre nego što se povežu sa novokreiranom osobom.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Grupisanje brute-force napada u jednom API zahtevu

Ove informacije su preuzete sa [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autentifikacija putem GraphQL API-ja sa **istovremenim slanjem mnogo upita sa različitim akreditacijama** radi provere. To je klasičan brute force napad, ali sada je moguće poslati više od jednog para korisničkog imena/lozinke u jednom HTTP zahtevu zbog mogućnosti grupisanja u GraphQL-u. Ovaj pristup bi prevario aplikacije za spoljno praćenje stope i učinio da izgleda kao da je sve u redu i da nema botova koji pokušavaju da pogode lozinke.

U nastavku možete videti najjednostavniji prikaz zahteva za autentifikaciju aplikacije, sa **3 različita para email/lozinka odjednom**. Očigledno je moguće poslati hiljade u jednom zahtevu na isti način:

![](<../../.gitbook/assets/image (182) (1).png>)

Kao što možemo videti sa slike odgovora, prvi i treći zahtev vratili su _null_ i prikazali odgovarajuće informacije u odeljku _error_. **Druga mutacija je imala ispravne autentifikacione** podatke i odgovor je imao ispravan token za autentifikaciju sesije.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL bez introspekcije

Sve više **graphql endpointa onemogućava introspekciju**. Međutim, greške koje graphql baca kada primi neočekivan zahtev su dovoljne za alate poput [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) da rekonstruišu veći deo šeme.

Osim toga, Burp Suite ekstenzija [**GraphQuail**](https://github.com/forcesunseen/graphquail) **prati GraphQL API zahteve koji prolaze kroz Burp** i **gradi** internu GraphQL **šemu** sa svakim novim upitom koji vidi. Takođe može prikazati šemu za GraphiQL i Voyager. Ekstenzija vraća lažni odgovor kada primi introspekcioni upit. Kao rezultat, GraphQuail prikazuje sve upite, argumente i polja koja su dostupna za upotrebu u okviru API-ja. Za više informacija [**proverite ovo**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Lepa **wordlist** za otkrivanje [**GraphQL entiteta može se pronaći ovde**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Zaobilaženje odbrana GraphQL introspekcije <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **Zaobilaženje odbrana GraphQL introspekcije**

Da bi se zaobišle restrikcije na introspekcijske upite u API-ima, efikasno je ubaciti **specijalni karakter nakon ključne reči `__schema`**. Ova metoda iskorišćava uobičajene propuste programera u regex obrascima koji imaju za cilj blokiranje introspekcije fokusiranjem na ključnu reč `__schema`. Dodavanjem karaktera poput **razmaka, novih linija i zareza**, koje GraphQL ignoriše, ali možda nisu uzeti u obzir u regex-u, restrikcije mogu biti zaobiđene. Na primer, introspekcijski upit sa novom linijom nakon `__schema` može zaobići takve odbrane:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Ako ne uspete, razmotrite alternativne metode zahteva, kao što su **GET zahtevi** ili **POST sa `x-www-form-urlencoded`**, jer se ograničenja mogu odnositi samo na POST zahteve.

### **Otkrivanje izloženih GraphQL struktura**

Kada je introspekcija onemogućena, pregledanje izvornog koda veb sajta radi pronalaženja unapred učitanih upita u JavaScript bibliotekama je korisna strategija. Ovi upiti se mogu pronaći koristeći karticu `Sources` u alatima za razvoj, pružajući uvid u šemu API-ja i otkrivajući potencijalno **izložene osetljive upite**. Komande za pretragu unutar alata za razvoj su:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF u GraphQL-u

Ako ne znate šta je CSRF, pročitajte sledeću stranicu:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Tamo ćete moći da pronađete nekoliko GraphQL endpointa **konfigurisanih bez CSRF tokena**.

Imajte na umu da se GraphQL zahtevi obično šalju putem POST zahteva koristeći Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Međutim, većina GraphQL krajnjih tačaka takođe podržava **`form-urlencoded` POST zahteve:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Stoga, pošto se CSRF zahtevi poput prethodnih šalju **bez prethodnih zahteva**, moguće je **izvršiti** **promene** u GraphQL-u zloupotrebom CSRF-a.

Međutim, imajte na umu da je nova podrazumevana vrednost kolačića za `samesite` zastavicu u Chrome-u `Lax`. To znači da će kolačić biti poslat samo sa veb stranice treće strane u GET zahtevima.

Imajte na umu da je obično moguće poslati **upit** **zahtev** i kao **GET** **zahtev, a CSRF token možda neće biti validiran u GET zahtevu.**

Takođe, zloupotrebom [**XS-Search**](../../pentesting-web/xs-search.md) **napada** može biti moguće izvući sadržaj sa GraphQL endpointa zloupotrebom korisničkih akreditacija.

Za više informacija **proverite** [**originalni post ovde**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autorizacija u GraphQL-u

Mnoge GraphQL funkcije definisane na endpointu mogu proveravati samo autentifikaciju zahtevaoca, ali ne i autorizaciju.

Izmena ulaznih promenljivih upita može dovesti do **procurivanja** osetljivih detalja o nalogu [leaked](https://hackerone.com/reports/792927).

Mutacija može čak dovesti do preuzimanja naloga pokušavajući da izmeni podatke drugih naloga.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Zaobilaženje autorizacije u GraphQL-u

[Povezivanje upita](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) može zaobići slab sistem autentifikacije.

U donjem primeru možete videti da je operacija "forgotPassword" i da bi trebalo da izvrši samo pripadajući upit forgotPassword. Ovo se može zaobići dodavanjem upita na kraju, u ovom slučaju dodajemo "register" i promenljivu korisnika kako bi sistem registrovao novog korisnika.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Zaobilaženje ograničenja brzine korišćenjem aliasa u GraphQL-u

U GraphQL-u, aliasi su moćna funkcionalnost koja omogućava **eksplicitno imenovanje svojstava** prilikom slanja API zahteva. Ova mogućnost je posebno korisna za dobijanje **više instanci istog tipa** objekta u jednom zahtevu. Aliasi se mogu koristiti kako bi se prevazišla ograničenja koja sprečavaju GraphQL objekte da imaju više svojstava sa istim imenom.

Za detaljnije razumevanje aliasa u GraphQL-u, preporučuje se sledeći resurs: [Aliasi](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Iako je primarni cilj aliasa smanjenje potrebe za brojnim API pozivima, identifikovan je i neplanirani slučaj upotrebe gde se aliasi mogu iskoristiti za izvršavanje napada brute force na GraphQL endpoint. Ovo je moguće jer su neki endpointi zaštićeni ograničivačima brzine dizajniranim da spreče napade brute force ograničavanjem **broja HTTP zahteva**. Međutim, ovi ograničivači brzine možda ne uzimaju u obzir broj operacija u svakom zahtevu. S obzirom da aliasi omogućavaju uključivanje više upita u jedan HTTP zahtev, oni mogu zaobići takva ograničenja brzine.

Razmotrite donji primer koji ilustruje kako se mogu koristiti aliasirani upiti za proveru validnosti kodova za popust u prodavnici. Ovaj metod može zaobići ograničenje brzine jer kompilira nekoliko upita u jedan HTTP zahtev, što potencijalno omogućava proveru brojnih kodova za popust istovremeno.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Alati

### Skeneri ranjivosti

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Alat koji se može koristiti za preuzimanje šema i pretragu osetljivih podataka, testiranje autorizacije, brute force šema i pronalaženje putanja do određenog tipa.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Može se koristiti samostalno ili kao [Burp ekstenzija](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Može se koristiti kao CLI klijent i za automatizaciju napada.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Alat koji navodi različite načine dostizanja određenog tipa u GraphQL šemi.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp ekstenzija za napredno testiranje GraphQL-a. _**Scanner**_ je jezgro InQL v5.0, gde možete analizirati GraphQL endpoint ili lokalni introspekcioni fajl šeme. Automatski generiše sve moguće upite i mutacije, organizujući ih u strukturiran prikaz za analizu. Komponenta _**Attacker**_ omogućava pokretanje grupnih GraphQL napada, što može biti korisno za zaobilaženje loše implementiranih ograničenja brzine.

### Klijenti

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Grafički klijent
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Grafički klijent

### Automatski testovi

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video koji objašnjava AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Reference

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
