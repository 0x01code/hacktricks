# GraphQL

<details>

<summary><strong>AWS hackleme becerilerinizi sıfırdan kahraman seviyesine çıkarın</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>ile</strong>!</summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'ı takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>

## Giriş

GraphQL, backend'den veri sorgulamak için REST API'ye **verimli bir alternatif** olarak öne çıkar ve geliştiricilerin veri alım süreçlerinin karmaşıklığını azaltarak tüm gereken bilgileri **tek bir istekte** almayı mümkün kılar. REST'in aksine, verileri toplamak için çeşitli uç noktalara yapılan çok sayıda istek gerektiren durumlarda, GraphQL tüm gereken bilgileri tek bir istekte almayı sağlar. Bu basitleştirme, veri alım süreçlerinin karmaşıklığını azaltarak geliştiricilere önemli ölçüde fayda sağlar.

## GraphQL ve Güvenlik

GraphQL gibi yeni teknolojilerin ortaya çıkmasıyla birlikte yeni güvenlik açıkları da ortaya çıkar. Dikkate alınması gereken önemli bir nokta, **GraphQL'ın varsayılan olarak kimlik doğrulama mekanizmalarını içermemesidir**. Bu tür güvenlik önlemlerini uygulamak geliştiricilerin sorumluluğundadır. Doğru kimlik doğrulama olmadan, GraphQL uç noktaları kimlik doğrulaması yapılmamış kullanıcılara hassas bilgileri açıklayabilir ve ciddi bir güvenlik riski oluşturabilir.

### Dizin Brute Force Saldırıları ve GraphQL

Açığa çıkarılmış GraphQL örneklerini belirlemek için dizin brute force saldırılarına belirli yolların dahil edilmesi önerilir. Bu yollar şunlardır:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

Açık GraphQL örneklerini belirlemek, desteklenen sorguların incelenmesine olanak tanır. Bu, uç noktadan erişilebilen verileri anlamak için önemlidir. GraphQL'in introspeksiyon sistemi, bir şemanın desteklediği sorguları detaylandırarak bu işlemi kolaylaştırır. Bu konuda daha fazla bilgi için GraphQL introspeksiyonu hakkında belgelere başvurun: [**GraphQL: API'ler için bir sorgu dili.**](https://graphql.org/learn/introspection/)

### Parmak İzi

[**graphw00f**](https://github.com/dolevf/graphw00f) aracı, bir sunucuda kullanılan GraphQL motorunu tespit edebilir ve güvenlik denetçisi için bazı yardımcı bilgileri yazdırabilir.

#### Evrensel sorgular <a href="#universal-queries" id="universal-queries"></a>

Bir URL'nin bir GraphQL servisi olup olmadığını kontrol etmek için **evrensel bir sorgu**, `query{__typename}`, gönderilebilir. Yanıtta `{"data": {"__typename": "Query"}}` yer alıyorsa, URL'nin bir GraphQL uç noktası barındırdığı onaylanır. Bu yöntem, GraphQL'in sorgulanan nesnenin türünü ortaya çıkaran `__typename` alanına dayanır.
```javascript
query{__typename}
```
### Temel Saptama

Graphql genellikle **GET**, **POST** (x-www-form-urlencoded) ve **POST**(json) destekler. Ancak güvenlik için yalnızca json'a izin vermek, CSRF saldırılarını önlemek için önerilir.

#### İçgörü

Şema bilgilerini keşfetmek için içgörüyü kullanmak için `__schema` alanını sorgulayın. Bu alan, tüm sorguların kök türünde mevcuttur.
```bash
query={__schema{types{name,fields{name}}}}
```
Bu sorgu ile kullanılan tüm tiplerin adını bulabilirsiniz:

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Bu sorgu ile tüm tipleri, alanları ve argümanları (ve argümanların türünü) çıkarabilirsiniz. Bu, veritabanını sorgulamak için nasıl kullanılacağınızı bilmek için çok faydalı olacaktır.

![](<../../.gitbook/assets/image (207) (3).png>)

**Hatalar**

**Hataların** gösterilip gösterilmeyeceğini bilmek ilginç olacaktır çünkü bunlar faydalı **bilgiler** sağlayacaktır.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (205) (1).png>)

**İntrospeksiyon Yoluyla Veritabanı Şemasını Sıralama**

{% hint style="info" %}
Eğer introspeksiyon etkinleştirilmişse ancak yukarıdaki sorgu çalışmıyorsa, sorgu yapısından `onOperation`, `onFragment` ve `onField` direktiflerini kaldırmayı deneyin.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Tek satır içi sorgu:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Son kod satırı, graphql'den tüm meta bilgileri (nesne adları, parametreler, tipler...) dökecek bir graphql sorgusudur.

![](<../../.gitbook/assets/image (206).png>)

Eğer introspection etkinse, [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) kullanarak tüm seçenekleri bir GUI'de görüntüleyebilirsiniz.

### Sorgulama

Veritabanında hangi tür bilgilerin kaydedildiğini bildiğimize göre, bazı değerleri **çıkarmayı deneyelim**.

Introspection'da **doğrudan sorgulayabileceğiniz nesneyi** bulabilirsiniz (çünkü bir nesneyi sadece var olduğu için sorgulayamazsınız). Aşağıdaki resimde "_queryType_"'ın "_Query_" olarak adlandırıldığını ve "_Query_" nesnesinin bir alanının "_flags_" olduğunu görebilirsiniz, bu alan da bir nesne türüdür. Bu nedenle flag nesnesini sorgulayabilirsiniz.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Sorgu "_flags_"'ın türünün "_Flags_" olduğuna dikkat edin ve bu nesnenin aşağıdaki gibi tanımlandığını görebilirsiniz:

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

"_Flags_" nesnelerinin **ad** ve **değer** ile oluşturulduğunu görebilirsiniz. Ardından, tüm bayrakların adlarını ve değerlerini aşağıdaki sorgu ile alabilirsiniz:
```javascript
query={flags{name, value}}
```
Not: **Sorgulanacak nesne**, aşağıdaki örnekte olduğu gibi **string** gibi **ilkel bir tür** ise, sadece sorgulayabilirsiniz:
```javascript
query={hiddenFlags}
```
Başka bir örnekte, "_Query_" türü nesnesi içinde "_user_" ve "_users_" adında 2 nesne vardı. Bu nesnelerin arama için herhangi bir argümana ihtiyacı olmadığında, istediğiniz verileri sormak suretiyle **tüm bilgileri alabilirsiniz**. Bu örnekte, İnternet'ten kaydedilmiş kullanıcı adlarını ve şifreleri çıkarabilirsiniz:

![](<../../.gitbook/assets/image (208).png>)

Ancak, bu örnekte bunu yapmaya çalışırsanız, şu **hata**yı alırsınız:

![](<../../.gitbook/assets/image (210).png>)

Görünüşe göre, "_**uid**_" türünde bir "_**uid**_" argümanı kullanarak arama yapacak gibi görünüyor. Neyse ki, zaten bunu biliyorduk, [Temel Numaralandırma](graphql.md#basic-enumeration) bölümünde bize gerekli tüm bilgileri gösteren bir sorgu önerilmişti: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Bu sorguyu çalıştırdığımda sağlanan görüntüyü okursanız, "_**user**_"'ın _Int_ türünde "_**uid**_" adında bir **arg**'ye sahip olduğunu göreceksiniz.

Bu nedenle, hafif bir _**uid**_ brute force yaparak _**uid**=**1**_ için bir kullanıcı adı ve şifre elde ettim:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Dikkat edin, "_**user**_" ve "_**password**_" parametrelerini sormak için **keşfettiğimi** fark ettim, çünkü mevcut olmayan bir şeyi aramaya çalışırsam (`query={user(uid:1){noExists}}`), bu hatayı alırım:

![](<../../.gitbook/assets/image (213).png>)

Ve **numaralandırma aşaması** sırasında "_**dbuser**_" nesnesinin "_**user**_" ve "_**password**_" alanlarına sahip olduğunu keşfettim.

**Sorgu dizesi döküm hilesi (teşekkürler @BinaryShadow\_)**

Eğer bir dize türüyle arama yapabilirseniz, örneğin: `query={theusers(description: ""){username,password}}` ve **boş bir dize** ararsanız, tüm verileri **dökümleyecektir**. (_Bu örnek, öğreticilerin örneğiyle ilgili değildir, bu örnekte "**theusers**" kullanarak bir String alan olan "**description**" ile arama yapabileceğinizi varsayalım_).

### Arama

Bu yapılandırmada, bir **veritabanı** kişileri ve filmleri içerir. **Kişiler** e-posta ve isimleriyle tanımlanır; **filmler** ise adları ve derecelendirmeleriyle tanımlanır. **Kişiler**, birbirleriyle arkadaş olabilir ve ayrıca veritabanı içindeki ilişkileri gösteren filmlere sahip olabilir.

Kişileri **isimlerine göre arayabilir** ve e-postalarını alabilirsiniz:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Kişileri **isim** ile **arama** yapabilir ve **abone oldukları** **filmleri** alabilirsiniz:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Not: Kişinin `aboneFilmler`inin `adını` almak için nasıl belirtildiğine dikkat edin.

Aynı zamanda **birkaç nesneyi aynı anda arayabilirsiniz**. Bu durumda, 2 film araması yapılır:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ya da hatta **çeşitli farklı nesnelerin ilişkilerini takma adlar kullanarak**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutasyonlar

**Mutasyonlar, sunucu tarafında değişiklik yapmak için kullanılır.**

**İnceleme** içinde **tanımlanan** **mutasyonları** bulabilirsiniz. Aşağıdaki resimde "_MutationType_" "_Mutation_" olarak adlandırılır ve "_Mutation_" nesnesi, mutasyonların adlarını içerir (bu durumda "_addPerson_" gibi):

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

Bu yapıda, bir **veritabanı** kişileri ve filmleri içerir. **Kişiler** e-posta ve isimleriyle tanımlanır; **filmler** ise adları ve derecelendirmeleriyle tanımlanır. **Kişiler**, birbirleriyle arkadaş olabilir ve aynı zamanda veritabanındaki ilişkileri gösteren filmlere sahip olabilir.

Veritabanına yeni filmler eklemek için bir mutasyon aşağıdaki gibi olabilir (bu örnekte mutasyon `addMovie` olarak adlandırılmıştır):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Not: Hem değerlerin hem de veri türünün sorguda belirtildiğine dikkat edin.**

Ayrıca, veritabanı mevcut **arkadaşlar** ve **filmler** ile birlikte **kişilerin** oluşturulmasına izin veren `addPerson` adında bir **mutasyon** işlemi desteklemektedir. Yeni oluşturulan kişiye bağlantı yapmadan önce arkadaşlar ve filmlerin veritabanında önceden var olması gerektiğini unutmak önemlidir.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### 1 API isteğinde toplu kaba kuvvet saldırısı

Bu bilgi [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/) adresinden alınmıştır.\
**Farklı kimlik bilgileriyle birlikte birçok sorguyu aynı anda göndererek** GraphQL API üzerinden kimlik doğrulama yapılır ve kontrol edilir. Bu klasik bir kaba kuvvet saldırısıdır, ancak GraphQL toplu işleme özelliği sayesinde bir HTTP isteğiyle birden fazla giriş/şifre çifti göndermek mümkündür. Bu yaklaşım, harici hız izleme uygulamalarını yanıltarak her şeyin yolunda olduğunu ve şifreleri tahmin etmeye çalışan bir kaba kuvvet saldırısı botunun olmadığını düşündürebilir.

Aşağıda, **aynı anda 3 farklı e-posta/şifre çiftiyle** uygulama kimlik doğrulama isteğinin en basit gösterimi bulunmaktadır. Aynı şekilde tek bir istekte binlerce göndermek mümkündür:

![](<../../.gitbook/assets/image (182) (1).png>)

Yanıt ekran görüntüsünden görebileceğimiz gibi, ilk ve üçüncü istekler _null_ döndürdü ve ilgili bilgileri _error_ bölümünde yansıttı. **İkinci mutasyon doğru kimlik doğrulama** verilerine sahipti ve yanıtta doğru kimlik doğrulama oturum belirteci bulunmaktadır.

![](<../../.gitbook/assets/image (119) (1).png>)

## Introspection Olmadan GraphQL

Daha fazla **graphql uç noktası introspection'ı devre dışı bırakıyor**. Bununla birlikte, graphql'in beklenmeyen bir istek aldığında attığı hatalar, [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) gibi araçların çoğu şemayı yeniden oluşturmak için yeterlidir.

Ayrıca, Burp Suite uzantısı [**GraphQuail**](https://github.com/forcesunseen/graphquail) GraphQL API isteklerini izler ve her yeni sorguyu gördüğünde dahili bir GraphQL şeması **oluşturur**. Ayrıca, GraphiQL ve Voyager için şemayı açığa çıkarabilir. Uzantı, bir introspection sorgusu aldığında sahte bir yanıt döndürür. Sonuç olarak, GraphQuail API içinde kullanılabilecek tüm sorguları, argümanları ve alanları gösterir. Daha fazla bilgi için [**burayı kontrol edin**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

[**GraphQL varlıklarını keşfetmek için güzel bir kelime listesi burada bulunabilir**](https://github.com/Escape-Technologies/graphql-wordlist?).

### GraphQL introspection savunmalarını aşma <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **GraphQL Introspection Savunmalarını Aşma**

API'lerde introspection sorgularına getirilen kısıtlamaları aşmak için, `__schema` anahtarından sonra **özel bir karakter eklemek** etkilidir. Bu yöntem, introspection'ı engellemek için `__schema` anahtarına odaklanan regex desenlerinde yaygın olarak görülen geliştirici hatalarını sömürür. GraphQL'in görmezden geldiği ancak regex'te hesaba katılmamış olabilecek karakterler olan **boşluklar, yeni satırlar ve virgüller** ekleyerek kısıtlamaları atlayabilirsiniz. Örneğin, `__schema`'dan sonra bir satır sonu ekleyen bir introspection sorgusu, bu tür savunmaları atlayabilir:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Başarısız olursanız, yalnızca POST isteklerine uygulanan kısıtlamalar nedeniyle **GET istekleri** veya **`x-www-form-urlencoded` ile POST** gibi alternatif istek yöntemlerini düşünün.

### **Açığa Çıkmış GraphQL Yapılarını Keşfetme**

Introspection devre dışı bırakıldığında, JavaScript kütüphanelerinde önceden yüklenmiş sorguları incelemek, web sitesinin kaynak kodunu incelemek için kullanışlı bir stratejidir. Bu sorgular, geliştirici araçlarındaki `Kaynaklar` sekmesi kullanılarak bulunabilir ve API'nin şeması hakkında bilgi sağlayabilir, potansiyel olarak **açığa çıkmış hassas sorguları** ortaya çıkarabilir. Geliştirici araçları içinde arama yapmak için kullanılan komutlar:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## GraphQL'de CSRF

CSRF'nin ne olduğunu bilmiyorsanız, aşağıdaki sayfayı okuyun:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Orada, **CSRF belirteçleri olmadan yapılandırılmış** birçok GraphQL uç noktası bulabileceksiniz.

GraphQL istekleri genellikle **`application/json`** içerik türünü kullanarak POST istekleri aracılığıyla gönderilir.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Ancak, çoğu GraphQL uç noktası ayrıca **`form-urlencoded` POST isteklerini** destekler:
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Bu nedenle, önceki gibi CSRF istekleri **önişlem istekleri olmadan** gönderildiğinden, bir CSRF'yi istismar ederek GraphQL'de **değişiklikler yapmak mümkündür**.

Ancak, Chrome'un `samesite` bayrağının yeni varsayılan çerez değeri `Lax` olduğunu unutmayın. Bu, çerezin yalnızca GET isteklerinde üçüncü taraf bir web sitesinden gönderileceği anlamına gelir.

Ayrıca, **sorgu isteğini** **GET** **isteği** olarak da göndermek genellikle mümkündür ve CSRF belirteci GET isteğinde doğrulanmayabilir.

Ayrıca, kullanıcının kimlik bilgilerini istismar ederek GraphQL uç noktasından içerik sızdırmak için [**XS-Search**](../../pentesting-web/xs-search.md) **saldırısını** kullanmak da mümkün olabilir.

Daha fazla bilgi için [**buradaki orijinal yazıya**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html) bakın.

## GraphQL'de Yetkilendirme

Uç noktada tanımlanan birçok GraphQL işlevi, yalnızca istemcinin kimlik doğrulamasını kontrol edebilir, ancak yetkilendirmeyi kontrol etmeyebilir.

Sorgu giriş değişkenlerini değiştirmek, hassas hesap ayrıntılarının [sızdırılmasına](https://hackerone.com/reports/792927) neden olabilir.

Mutasyon, başka bir hesap verisini değiştirmeye çalışarak hesap ele geçirmeye bile yol açabilir.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### GraphQL'de yetkilendirme atlamak

[Query'leri zincirleme](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) zayıf bir yetkilendirme sistemi atlayabilir.

Aşağıdaki örnekte, işlemin "forgotPassword" olduğunu ve yalnızca onunla ilişkili forgotPassword sorgusunun çalıştırılması gerektiğini görebilirsiniz. Bu, sona bir sorgu ekleyerek atlatılabilir, bu durumda "register" ve sistem tarafından yeni bir kullanıcı olarak kaydedilmek üzere bir kullanıcı değişkeni ekliyoruz.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## GraphQL'de Takma Adları Kullanarak Hız Sınırlarını Atlatma

GraphQL'de, takma adlar, bir API isteği yapılırken özelliklerin **açıkça adlandırılmasına** olanak sağlayan güçlü bir özelliktir. Bu yetenek, tek bir istek içinde aynı türden **çoklu örneği** almak için özellikle kullanışlıdır. Takma adlar, GraphQL nesnelerinin aynı isme sahip birden fazla özelliğe sahip olmasını engelleyen sınırlamayı aşmak için kullanılabilir.

GraphQL takma adları hakkında ayrıntılı bir anlayış için aşağıdaki kaynak önerilir: [Takma Adlar](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Takma adların temel amacı, çok sayıda API çağrısına gerek duymadan yapılmasını sağlamaktır, ancak takma adların kullanılabileceği istenmeyen bir kullanım durumu tespit edilmiştir. Takma adlar, GraphQL uç noktasında brute force saldırılarını gerçekleştirmek için kullanılabilir. Bu, bazı uç noktaların, HTTP isteklerinin sayısını sınırlayarak brute force saldırılarını engellemek için tasarlanmış hız sınırlayıcılarla korunduğu anlamına gelir. Bununla birlikte, bu hız sınırlayıcılar her istekteki işlemlerin sayısını hesaba katmayabilir. Takma adlar, birden fazla sorguyu tek bir HTTP isteğine dahil etme olanağı sağladığından, bu tür hız sınırlama önlemlerini atlayabilir.

Aşağıdaki örnek, takma adlı sorguların mağaza indirim kodlarının geçerliliğini doğrulamak için nasıl kullanılabileceğini göstermektedir. Bu yöntem, bir HTTP isteğine birden çok sorgu derleyerek hız sınırlamasını atlamaya olanak sağladığından, potansiyel olarak birçok indirim kodunun aynı anda doğrulanmasına izin verebilir.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Araçlar

### Zayıflık tarama araçları

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Şemaları almak ve hassas verileri aramak, yetkilendirme testi yapmak, şemaları brute force etmek ve belirli bir türe giden yolları bulmak için kullanılabilen bir araç takımı.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Bağımsız olarak veya [Burp eklentisi](https://github.com/doyensec/inql) olarak kullanılabilir.
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Saldırıları otomatikleştirmek için CLI istemcisi olarak da kullanılabilir.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Bir GraphQL şemasında belirli bir türe ulaşmanın farklı yollarını listeleyen bir araç.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Gelişmiş GraphQL testleri için Burp eklentisi. InQL v5.0'ın çekirdeği olan _**Scanner**_ ile bir GraphQL uç noktasını veya yerel bir tanıtım şema dosyasını analiz edebilirsiniz. Tüm olası sorguları ve mutasyonları otomatik olarak oluşturur ve analiz için yapılandırılmış bir görünümde düzenler. _**Attacker**_ bileşeni, kötü bir şekilde uygulanmış hız sınırlarını atlamak için kullanışlı olabilecek toplu GraphQL saldırıları çalıştırmanıza olanak tanır.

### İstemciler

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Grafiksel kullanıcı arayüzü (GUI) istemcisi
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Grafiksel kullanıcı arayüzü (GUI) istemcisi

### Otomatik Testler

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* AutoGraphQL'i açıklayan video: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Referanslar

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>ile sıfırdan kahraman olmak için AWS hackleme öğrenin</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **tanıtmak veya HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da takip edin 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live).
* Hacking hilelerinizi göndererek HackTricks ve HackTricks Cloud github depolarına PR göndererek **hacking hilelerinizi paylaşın**.

</details>
