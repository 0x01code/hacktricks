# Nginx

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repositories** senden.

</details>

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Sofort verf√ºgbare Einrichtung f√ºr Schwachstellenbewertung und Penetrationstests**. F√ºhren Sie einen vollst√§ndigen Pentest von √ºberall aus mit 20+ Tools und Funktionen durch, die von der Aufkl√§rung bis zum Bericht reichen. Wir ersetzen keine Pentester - wir entwickeln benutzerdefinierte Tools, Erkennungs- und Exploit-Module, um ihnen etwas Zeit zu geben, um tiefer zu graben, Shells zu √∂ffnen und Spa√ü zu haben.

{% embed url="https://pentest-tools.com/" %}

## Fehlender Root-Standort <a href="#missing-root-location" id="missing-root-location"></a>

## **Grundlagen der Konfiguration des Nginx-Stammverzeichnisses**

Bei der Konfiguration des Nginx-Servers spielt die **root-Direktive** eine entscheidende Rolle, indem sie das Basisverzeichnis definiert, von dem aus Dateien bereitgestellt werden. Betrachten Sie das folgende Beispiel:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In dieser Konfiguration wird `/etc/nginx` als Stammverzeichnis festgelegt. Diese Einrichtung erm√∂glicht den Zugriff auf Dateien innerhalb des angegebenen Stammverzeichnisses, wie z.B. `/hello.txt`. Es ist jedoch wichtig zu beachten, dass nur ein bestimmter Ort (`/hello.txt`) definiert ist. Es gibt keine Konfiguration f√ºr den Stammort (`location / {...}`). Durch dieses Weglassen gilt die Stamm-Anweisung global, sodass Anfragen an den Stamm-Pfad `/` auf Dateien unter `/etc/nginx` zugreifen k√∂nnen.

Aus dieser Konfiguration ergibt sich eine kritische Sicherheits√ºberlegung. Eine einfache `GET`-Anfrage wie `GET /nginx.conf` k√∂nnte sensible Informationen preisgeben, indem die Nginx-Konfigurationsdatei unter `/etc/nginx/nginx.conf` bereitgestellt wird. Das Festlegen des Stammverzeichnisses auf ein weniger sensibles Verzeichnis wie `/etc` k√∂nnte dieses Risiko mindern, k√∂nnte jedoch immer noch unbeabsichtigten Zugriff auf andere wichtige Dateien erm√∂glichen, einschlie√ülich anderer Konfigurationsdateien, Zugriffsprotokolle und sogar verschl√ºsselter Anmeldeinformationen, die f√ºr die HTTP-Basisauthentifizierung verwendet werden.

## Alias LFI Fehlkonfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In den Konfigurationsdateien von Nginx ist eine genaue √úberpr√ºfung der "location"-Anweisungen erforderlich. Durch eine Konfiguration, die der folgenden √§hnelt, kann unabsichtlich eine Sicherheitsl√ºcke namens Local File Inclusion (LFI) eingef√ºhrt werden:
```
location /imgs {
alias /path/images/;
}
```
Diese Konfiguration ist anf√§llig f√ºr LFI-Angriffe, da der Server Anfragen wie `/imgs../flag.txt` als Versuch interpretiert, auf Dateien au√üerhalb des beabsichtigten Verzeichnisses zuzugreifen, was effektiv zu `/path/images/../flag.txt` f√ºhrt. Diese Schwachstelle erm√∂glicht es Angreifern, Dateien aus dem Dateisystem des Servers abzurufen, die √ºber das Web nicht zug√§nglich sein sollten.

Um diese Sicherheitsl√ºcke zu beheben, sollte die Konfiguration angepasst werden:
```
location /imgs/ {
alias /path/images/;
}
```
Weitere Informationen: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix-Tests:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Unsichere Pfadbeschr√§nkung <a href="#unsichere-variablenverwendung" id="unsichere-variablenverwendung"></a>

√úberpr√ºfen Sie die folgende Seite, um zu erfahren, wie Sie Direktiven wie umgehen k√∂nnen:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{% content-ref url="../../pentesting-web/proxy-waf-protections-bypass.md" %}
[proxy-waf-protections-bypass.md](../../pentesting-web/proxy-waf-protections-bypass.md)
{% endcontent-ref %}

## Unsicherer Variablengebrauch <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Eine Schwachstelle in der Nginx-Konfiguration wird am folgenden Beispiel demonstriert:
```
location / {
return 302 https://example.com$uri;
}
```
Die Zeichen \r (Wagenr√ºcklauf) und \n (Zeilenumbruch) stehen f√ºr Zeilenumbruchzeichen in HTTP-Anfragen, und ihre URL-codierten Formen werden als `%0d%0a` dargestellt. Wenn diese Zeichen in einer Anfrage enthalten sind (z. B. `http://localhost/%0d%0aDetectify:%20clrf`) an einen fehlerhaft konfigurierten Server, f√ºhrt dies dazu, dass der Server einen neuen Header mit dem Namen `Detectify` ausgibt. Dies geschieht, weil die Variable $uri die URL-codierten Zeilenumbruchzeichen decodiert, was zu einem unerwarteten Header in der Antwort f√ºhrt:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Erfahren Sie mehr √ºber die Risiken von CRLF-Injection und Response-Splitting unter [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

### Jede Variable

Es wurde festgestellt, dass **benutzerdefinierte Daten** unter bestimmten Umst√§nden als **Nginx-Variable** behandelt werden k√∂nnen. Die Ursache f√ºr dieses Verhalten bleibt etwas r√§tselhaft, ist jedoch weder selten noch einfach zu √ºberpr√ºfen. Diese Anomalie wurde in einem Sicherheitsbericht auf HackerOne hervorgehoben, der [hier](https://hackerone.com/reports/370094) eingesehen werden kann. Eine weitere Untersuchung der Fehlermeldung f√ºhrte zur Identifizierung ihres Auftretens im [SSI-Filtermodul des Nginx-Codebases](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wobei Server Side Includes (SSI) als eigentliche Ursache identifiziert wurden.

Um diese Fehlkonfiguration zu **erkennen**, kann der folgende Befehl ausgef√ºhrt werden, der das Setzen eines Referer-Headers beinhaltet, um die Ausgabe der Variablen zu testen:
```bash
$ curl -H ‚ÄòReferer: bar‚Äô http://localhost/foo$http_referer | grep ‚Äòfoobar‚Äô
```
Scans f√ºr diese Konfigurationsfehler auf verschiedenen Systemen haben mehrere F√§lle aufgedeckt, in denen Nginx-Variablen von einem Benutzer angezeigt werden konnten. Allerdings deutet eine Abnahme der anf√§lligen F√§lle darauf hin, dass die Bem√ºhungen zur Behebung dieses Problems teilweise erfolgreich waren.

## Lesen der Rohantwort des Backends


Nginx bietet eine Funktion √ºber `proxy_pass`, die es erm√∂glicht, Fehler und HTTP-Header, die vom Backend erzeugt werden, abzufangen, um interne Fehlermeldungen und Header zu verbergen. Dies wird erreicht, indem Nginx benutzerdefinierte Fehlerseiten als Antwort auf Backend-Fehler bereitstellt. Herausforderungen ergeben sich jedoch, wenn Nginx eine ung√ºltige HTTP-Anfrage erh√§lt. Eine solche Anfrage wird unver√§ndert an das Backend weitergeleitet und die Rohantwort des Backends wird direkt an den Client gesendet, ohne dass Nginx eingreift.

Betrachten wir ein Beispiel-Szenario mit einer uWSGI-Anwendung:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Um dies zu verwalten, werden spezifische Anweisungen in der Nginx-Konfiguration verwendet:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- **[proxy_intercept_errors](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors)**: Diese Anweisung erm√∂glicht es Nginx, eine benutzerdefinierte Antwort f√ºr Backend-Antworten mit einem Statuscode gr√∂√üer als 300 zu senden. Dadurch wird sichergestellt, dass bei unserer Beispiel-uWSGI-Anwendung eine `500 Error`-Antwort von Nginx abgefangen und behandelt wird.
- **[proxy_hide_header](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header)**: Wie der Name schon sagt, verbirgt diese Anweisung bestimmte HTTP-Header vor dem Client und erh√∂ht so die Privatsph√§re und Sicherheit.

Wenn eine g√ºltige `GET`-Anfrage gestellt wird, verarbeitet Nginx sie normal und gibt eine Standardfehlerantwort zur√ºck, ohne geheime Header preiszugeben. Eine ung√ºltige HTTP-Anfrage umgeht jedoch diesen Mechanismus und f√ºhrt zur Offenlegung von Rohdaten der Backend-Antworten, einschlie√ülich geheimer Header und Fehlermeldungen.


## merge\_slashes auf off gesetzt

Standardm√§√üig ist die **`merge_slashes`-Anweisung** von Nginx auf **`on`** gesetzt, was mehrere Schr√§gstriche in einer URL zu einem einzigen Schr√§gstrich komprimiert. Diese Funktion kann jedoch versehentlich Schwachstellen in Anwendungen hinter Nginx verbergen, insbesondere solche, die anf√§llig f√ºr Local File Inclusion (LFI)-Angriffe sind. Die Sicherheitsexperten **Danny Robinson und Rotem Bar** haben auf die potenziellen Risiken dieses Standardverhaltens hingewiesen, insbesondere wenn Nginx als Reverse-Proxy fungiert.

Um solche Risiken zu minimieren, wird empfohlen, die **`merge_slashes`-Anweisung f√ºr anf√§llige Anwendungen auszuschalten**. Dadurch wird sichergestellt, dass Nginx Anfragen an die Anwendung weiterleitet, ohne die URL-Struktur zu ver√§ndern und somit keine zugrunde liegenden Sicherheitsprobleme zu verbergen.

Weitere Informationen finden Sie unter [Danny Robinson und Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Standardwert in der Map-Anweisung**

In der **Nginx-Konfiguration** spielt die `map`-Anweisung oft eine Rolle bei der **Autorisierungssteuerung**. Ein h√§ufiger Fehler besteht darin, keinen **Standardwert** anzugeben, was zu unberechtigtem Zugriff f√ºhren kann. Zum Beispiel:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Ohne `default` kann ein **b√∂sartiger Benutzer** die Sicherheit umgehen, indem er auf eine **undefinierte URI** innerhalb von `/map-poc` zugreift. [Das Nginx-Handbuch](https://nginx.org/en/docs/http/ngx_http_map_module.html) empfiehlt, einen **Standardwert** festzulegen, um solche Probleme zu vermeiden.

### **DNS-Spoofing-Schwachstelle**

DNS-Spoofing gegen Nginx ist unter bestimmten Bedingungen m√∂glich. Wenn ein Angreifer den von Nginx verwendeten **DNS-Server** kennt und seine DNS-Anfragen abfangen kann, kann er DNS-Eintr√§ge f√§lschen. Diese Methode ist jedoch unwirksam, wenn Nginx so konfiguriert ist, dass es zur DNS-Aufl√∂sung **localhost (127.0.0.1)** verwendet. Nginx erm√∂glicht die Angabe eines DNS-Servers wie folgt:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` und `internal` Direktiven**

Die **`proxy_pass`**-Direktive wird verwendet, um Anfragen an andere Server umzuleiten, entweder intern oder extern. Die **`internal`**-Direktive stellt sicher, dass bestimmte Standorte nur innerhalb von Nginx erreichbar sind. Obwohl diese Direktiven an sich keine Sicherheitsl√ºcken darstellen, erfordert ihre Konfiguration eine sorgf√§ltige Pr√ºfung, um Sicherheitsl√ºcken zu vermeiden.

## proxy\_set\_header Upgrade & Connection

Wenn der Nginx-Server so konfiguriert ist, dass die Upgrade- und Connection-Header weitergeleitet werden, kann ein [**h2c-Smuggling-Angriff**](../../pentesting-web/h2c-smuggling.md) durchgef√ºhrt werden, um auf gesch√ºtzte/interne Endpunkte zuzugreifen.

{% hint style="danger" %}
Diese Sicherheitsl√ºcke w√ºrde einem Angreifer erm√∂glichen, eine direkte Verbindung mit dem `proxy_pass`-Endpunkt (`http://backend:9999` in diesem Fall) herzustellen, dessen Inhalt nicht von Nginx √ºberpr√ºft wird.
{% endhint %}

Beispiel f√ºr eine verwundbare Konfiguration zum Stehlen von `/flag` von [hier](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
Beachten Sie, dass selbst wenn `proxy_pass` auf einen bestimmten **Pfad** wie `http://backend:9999/socket.io` zeigt, die Verbindung mit `http://backend:9999` hergestellt wird. Sie k√∂nnen also **jeden anderen Pfad innerhalb dieses internen Endpunkts kontaktieren. Es spielt also keine Rolle, ob ein Pfad in der URL von proxy\_pass angegeben ist.**
{% endhint %}

## Probieren Sie es selbst aus

Detectify hat ein GitHub-Repository erstellt, in dem Sie Docker verwenden k√∂nnen, um Ihren eigenen verwundbaren Nginx-Testserver mit einigen der in diesem Artikel behandelten Fehlkonfigurationen einzurichten und selbst nach ihnen zu suchen!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statische Analysetools

### [GIXY](https://github.com/yandex/gixy)

Gixy ist ein Tool zur Analyse der Nginx-Konfiguration. Das Hauptziel von Gixy ist es, Sicherheitsfehler zu verhindern und die automatische Erkennung von Schwachstellen zu erm√∂glichen.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ist ein einfaches Tool, um nach g√§ngigen Nginx-Fehlkonfigurationen und Schwachstellen zu suchen.

## Referenzen

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Sofort einsatzbereite Einrichtung f√ºr Schwachstellenbewertung und Penetrationstests**. F√ºhren Sie einen vollst√§ndigen Penetrationstest von √ºberall aus mit √ºber 20 Tools und Funktionen durch, die von der Aufkl√§rung bis zum Bericht reichen. Wir ersetzen keine Penetrationstester - wir entwickeln benutzerdefinierte Tools, Erkennungs- und Exploit-Module, um ihnen etwas Zeit zu geben, um tiefer zu graben, Shells zu √∂ffnen und Spa√ü zu haben.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
