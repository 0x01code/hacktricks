# Nginx

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 **Discord grubuna** katılın](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'u takip edin.
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Hemen kullanıma hazır zafiyet değerlendirme ve penetrasyon testi kurulumu**. 20'den fazla araç ve özellikle her yerden tam bir pentest çalıştırın, keşiften raporlamaya kadar uzanan. Pentester'ları değiştirmiyoruz - özel araçlar, tespit ve istismar modülleri geliştiriyoruz, böylece daha derine inmek, kabukları patlatmak ve eğlenmek için zaman kazanıyorlar.

{% embed url="https://pentest-tools.com/" %}

## Eksik kök konumu <a href="#missing-root-location" id="missing-root-location"></a>

## **Nginx Kök Dizini Yapılandırmanın Temelleri**

Nginx sunucusunu yapılandırırken, **root direktifi** dosyaların sunulduğu temel dizini tanımlayarak kritik bir rol oynar. Aşağıdaki örneği göz önünde bulundurun:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Bu yapılandırmada, `/etc/nginx` kök dizini olarak belirlenmiştir. Bu kurulum, `/hello.txt` gibi belirtilen kök dizinindeki dosyalara erişime izin verir. Ancak, yalnızca belirli bir konum (`/hello.txt`) tanımlanmıştır. Kök konum için (`location / {...}`) herhangi bir yapılandırma bulunmamaktadır. Bu ihmal, kök yönergesinin genel olarak uygulanmasını sağlar ve `/etc/nginx` altındaki dosyalara erişim sağlar.

Bu yapılandırmadan kaynaklanan kritik bir güvenlik düşüncesi ortaya çıkar. Basit bir `GET` isteği, örneğin `GET /nginx.conf`, `/etc/nginx/nginx.conf` konumundaki Nginx yapılandırma dosyasını sunarak hassas bilgilerin ifşa edilmesine neden olabilir. Kökü daha az hassas bir dizine, örneğin `/etc` olarak ayarlamak, bu riski azaltabilir, ancak yine de diğer hassas dosyalara, diğer yapılandırma dosyalarına, erişim günlüklerine ve hatta HTTP temel kimlik doğrulaması için kullanılan şifrelenmiş kimlik bilgilerine istenmeyen erişime izin verebilir.

## Alias LFI Yan Yapılandırması <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx'in yapılandırma dosyalarında, "location" yönergeleri için dikkatli bir inceleme gereklidir. Bir Local File Inclusion (LFI) olarak bilinen bir zafiyet, aşağıdakine benzer bir yapılandırma ile yanlışlıkla tanıtılabilir:
```
location /imgs {
alias /path/images/;
}
```
Bu yapılandırma, sunucunun `/imgs../flag.txt` gibi istekleri yorumlayarak, dosyaların amaçlanan dizinin dışındaki dosyalara erişme girişimi olarak algılanmasına neden olabilecek LFI saldırılarına duyarlıdır ve etkili bir şekilde `/path/images/../flag.txt`'ye çözülür. Bu zayıflık, saldırganların sunucunun dosya sisteminden web aracılığıyla erişilememesi gereken dosyaları almasına olanak tanır.

Bu zafiyeti hafifletmek için yapılandırma şu şekilde ayarlanmalıdır:
```
location /imgs/ {
alias /path/images/;
}
```
Daha fazla bilgi: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testleri:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Güvensiz yol kısıtlaması <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Aşağıdaki sayfayı kontrol edin:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
## Güvensiz değişken kullanımı / HTTP İsteği Bölme <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

{% hint style="danger" %}
`$uri` ve `$document_uri` gibi güvenlik açıklı değişkenler bulunmaktadır ve bunlar `$request_uri` ile değiştirilerek düzeltilebilir.

Ayrıca regex de şu şekilde güvenlik açıklı olabilir:

`location ~ /docs/([^/])? { … $1 … }` - Güvenlik açıklı&#x20;

`location ~ /docs/([^/\s])? { … $1 … }` - Güvenlik açıklı değil (boşlukları kontrol eder)

`location ~ /docs/(.*)? { … $1 … }`  - Güvenlik açıklı değil
{% endhint %}

Nginx yapılandırmasındaki bir güvenlik açığı aşağıdaki örnekle gösterilmektedir:
```
location / {
return 302 https://example.com$uri;
}
```
HTTP isteklerinde \r (Taşıma İşareti) ve \n (Satır Beslemesi) karakterleri yeni satır karakterlerini belirtir ve URL kodlanmış formları `%0d%0a` olarak temsil edilir. Bu karakterleri bir istekte (örneğin, `http://localhost/%0d%0aDetectify:%20clrf`) içerdiğinde yanlış yapılandırılmış bir sunucunun yeni bir başlık olan `Detectify` çıkarması sonucu oluşur. Bu durum, $uri değişkeninin URL kodlanmış yeni satır karakterlerini çözmesi nedeniyle yanıtta beklenmeyen bir başlık oluşturur:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Risks of CRLF injection and response splitting için [buraya](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/) bakabilirsiniz.

Bu teknik [**bu sunumda**](https://www.youtube.com/watch?v=gWQyWdZbdoY\&list=PL0xCSYnG\_iTtJe2V6PQqamBF73n7-f1Nr\&index=77) bazı zayıf örnekler ve tespit mekanizmaları ile açıklanmıştır. Örneğin, Bu yanlış yapılandırmayı siyah kutu bakış açısından tespit etmek için şu istekleri yapabilirsiniz:

* `https://example.com/%20X` - Herhangi bir HTTP kodu
* `https://example.com/%20H` - 400 Bad Request

Eğer zayıfsa, ilk istek "X" herhangi bir HTTP yöntemi olarak dönecek ve ikinci istek H geçerli bir yöntem olmadığı için bir hata dönecektir. Bu nedenle sunucu şuna benzer bir şey alacak: `GET / H HTTP/1.1` ve bu hata oluşturacaktır.

Diğer tespit örnekleri şunlar olabilir:

* `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Herhangi bir HTTP kodu
* `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Bu sunumda bulunan bazı zayıf yapılandırmalar şunlardır:

* **`$uri`**'nin URL'de olduğu gibi ayarlandığına dikkat edin.
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
* Yine **`$uri`** URL'de (bu sefer bir parametrenin içinde) bulunmaktadır.
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
* Şimdi AWS S3'te
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Herhangi bir değişken

Belirli durumlarda, **kullanıcı tarafından sağlanan verilerin** belirli koşullar altında bir **Nginx değişkeni** olarak işleme tabi tutulabileceği keşfedildi. Bu davranışın nedeni oldukça belirsiz olsa da, nadir değil ve doğrulaması da kolay değil. Bu anormallik, HackerOne'da bir güvenlik raporunda vurgulandı ve [buradan](https://hackerone.com/reports/370094) görülebilir. Hata mesajına yönelik daha fazla inceleme, bunun Nginx'in kod tabanındaki [SSI filtre modülünde](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx\_http\_ssi\_filter\_module.c#L365) meydana geldiğinin belirlenmesine yol açtı, Server Side Includes (SSI)nin temel nedeni olarak belirlendi.

Bu yanlış yapılandırmayı **tespit etmek** için aşağıdaki komut çalıştırılabilir, bu komut, bir referer başlığını ayarlayarak değişken yazdırma testi yapmayı içerir:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Sistemler üzerinde yapılan taramalar, bir kullanıcı tarafından Nginx değişkenlerinin yazdırılabileceği birden fazla örneği ortaya çıkardı. Ancak, savunmasız örneklerin sayısındaki azalma, bu sorunu düzeltme çabalarının bir dereceye kadar başarılı olduğunu göstermektedir.

## Ham arka uç yanıtı okuma

Nginx, `proxy_pass` aracılığıyla sunucu hatalarını ve HTTP başlıklarını yakalamayı sağlayan bir özellik sunar, bu da iç hata mesajlarını ve başlıklarını gizlemeyi amaçlar. Bu, Nginx'in, arka uç hatalarına yanıt olarak özel hata sayfaları sunarak başarılı bir şekilde gerçekleştirilir. Ancak, Nginx'in geçersiz bir HTTP isteğiyle karşılaştığında zorluklar ortaya çıkar. Böyle bir istek, alındığı gibi arka uca iletilir ve ardından arka uçun ham yanıtı doğrudan Nginx'in müdahalesi olmadan istemciye gönderilir. 

Bir uWSGI uygulamasını içeren bir örnek senaryoyu düşünün:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Bu yönetmek için, Nginx yapılandırmasında belirli direktifler kullanılır:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
* [**proxy\_intercept\_errors**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_intercept\_errors): Bu yönerge, Nginx'in durum kodu 300'den büyük olan arka uç yanıtları için özel bir yanıt sunmasını sağlar. Örneğimizde uWSGI uygulaması için, bir `500 Hata` yanıtının Nginx tarafından engellenip işlenmesini sağlar.
* [**proxy\_hide\_header**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_hide\_header): Adından da anlaşılacağı gibi, bu yönerge belirli HTTP başlıklarını istemciden gizler, gizliliği ve güvenliği artırır.

Geçerli bir `GET` isteği yapıldığında, Nginx bunu normal şekilde işler, herhangi gizli başlıkları açığa çıkarmadan standart bir hata yanıtı döndürür. Ancak geçersiz bir HTTP isteği, bu mekanizmayı atlar ve ham arka uç yanıtlarını, gizli başlıkları ve hata mesajlarını da içerecek şekilde ortaya çıkarır.

## merge\_slashes off olarak ayarlandı

Varsayılan olarak, Nginx'in **`merge_slashes` yönergesi** **`on`** olarak ayarlanmıştır, bu da bir URL'deki birden fazla ileri eğik çizgiyi tek bir çizgiye sıkıştırır. Bu özellik, URL işleme sürecini basitleştirirken, Nginx'in arkasındaki uygulamalardaki zafiyetleri yanlışlıkla gizleyebilir, özellikle de yerel dosya dahil etme (LFI) saldırılarına duyarlı olanlar. Güvenlik uzmanları **Danny Robinson ve Rotem Bar**, özellikle Nginx'in ters proxy olarak hareket ettiğinde, bu varsayılan davranışla ilişkili potansiyel riskleri vurgulamışlardır.

Bu tür riskleri azaltmak için, bu zafiyetlere duyarlı uygulamalar için **`merge_slashes` yönergesini kapatmanız** önerilir. Bu, Nginx'in URL yapısını değiştirmeden istekleri uygulamaya ilettiğinden, altta yatan güvenlik sorunlarını gizlemez.

Daha fazla bilgi için [Danny Robinson ve Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Map Yönergesindeki Varsayılan Değer**

**Nginx yapılandırmasında**, `map` yönergesi genellikle **yetkilendirme kontrolünde** rol oynar. Yaygın bir hata, **varsayılan** bir değer belirtmemektir, bu da yetkisiz erişime yol açabilir. Örneğin:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
`default` olmadan, bir **kötü niyetli kullanıcı**, `/map-poc` içinde tanımsız bir URI'ye erişerek güvenlik önlemlerini atlayabilir. [Nginx kılavuzu](https://nginx.org/en/docs/http/ngx_http_map_module.html), bu tür sorunları önlemek için bir **varsayılan değer** belirlemenizi önerir.

### **DNS Sahtecilik Açığı**

Belirli koşullar altında Nginx'e karşı DNS sahteciliği mümkündür. Bir saldırgan, Nginx'in kullandığı **DNS sunucusunu** bildiğinde ve DNS sorgularını onaylayabildiğinde DNS kayıtlarını sahtecilik yapabilir. Ancak bu yöntem, Nginx'in DNS çözümlemesi için **localhost (127.0.0.1)**'i kullanacak şekilde yapılandırılmışsa etkisizdir. Nginx, bir DNS sunucusunu aşağıdaki gibi belirtmeye izin verir:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` ve `internal` Komutları**

**`proxy_pass`** komutu, istekleri başka sunuculara yönlendirmek için kullanılır, ya içsel ya da harici olarak. **`internal`** komutu ise belirli konumlara sadece Nginx içinden erişilebilir olduğunu sağlar. Bu komutlar başlı başına güvenlik açıkları değildir, ancak yapılandırmaları güvenlik açıklarını önlemek için dikkatli bir şekilde incelenmelidir.

## proxy\_set\_header Upgrade & Connection

Eğer nginx sunucusu Upgrade ve Connection başlıklarını geçmek için yapılandırılmışsa, bir [**h2c Smuggling saldırısı**](../../pentesting-web/h2c-smuggling.md) gerçekleştirilebilir ve korumalı/içsel uç noktalara erişilebilir.

{% hint style="danger" %}
Bu güvenlik açığı, bir saldırganın **`proxy_pass` uç noktasıyla doğrudan bir bağlantı kurmasına** izin verecektir (`http://backend:9999` bu durumda) ve bu içerik Nginx tarafından kontrol edilmeyecektir.
{% endhint %}

Örnek olarak, [buradan](https://bishopfox.com/blog/h2c-smuggling-request) `/flag`'i çalmak için savunmasız yapılandırma:
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
`proxy_pass`'in belirli bir **yol** a gösterdiği durumda bile, bağlantı `http://backend:9999` ile kurulacaktır, bu nedenle **içsel uç noktadaki herhangi başka bir yola ulaşabilirsiniz. Bu nedenle, proxy_pass URL'sinde bir yol belirtilmiş olup olmadığı önemli değildir.**
{% endhint %}

## Kendiniz Deneyin

Detectify, bu makalede tartışılan bazı yanlış yapılandırmalarla kendi zayıf Nginx test sunucusunu kurmanızı ve bunları kendiniz bulmanızı deneyebileceğiniz bir GitHub deposu oluşturdu!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statik Analiz Araçları

### [GIXY](https://github.com/yandex/gixy)

Gixy, Nginx yapılandırmasını analiz etmek için bir araçtır. Gixy'nin ana amacı güvenlik yanlı yapılandırmalarını önlemek ve hata tespitini otomatikleştirmektir.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner, yaygın Nginx yanlı yapılandırmalarını ve güvenlik açıklarını aramak için basit bir araçtır.

## Referanslar

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Hemen kullanılabilir zayıflık değerlendirme ve penetrasyon testi kurulumu**. Keşiften raporlamaya kadar 20'den fazla araç ve özellikle tam bir pentest çalıştırın. Pentester'ları değiştirmiyoruz - onlara daha derinlemesine kazma, kabukları patlatma ve eğlenme zamanı vermek için özel araçlar, tespit ve istismar modülleri geliştiriyoruz.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud** github depolarına PR'lar göndererek paylaşın.

</details>
