# Nginx

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini edinin**](https://peass.creator-spring.com)
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

**Hemen kullanıma hazır zafiyet değerlendirme ve penetrasyon testi kurulumu**. 20'den fazla araç ve özellikle tam bir pentest çalıştırın, keşiften raporlamaya kadar uzanan. Pentester'ları değiştirmiyoruz - özel araçlar, tespit ve istismar modülleri geliştiriyoruz, böylece daha derine inmek, kabukları patlatmak ve eğlenmek için zaman kazanıyorlar.

{% embed url="https://pentest-tools.com/" %}

## Eksik kök konumu <a href="#missing-root-location" id="missing-root-location"></a>

Nginx sunucusunu yapılandırırken, **root direktifi** dosyaların sunulduğu temel dizini tanımlayarak kritik bir rol oynar. Aşağıdaki örneği göz önünde bulundurun:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Bu yapılandırmada, `/etc/nginx` kök dizini olarak belirlenmiştir. Bu kurulum, belirtilen kök dizini içindeki dosyalara erişime izin verir, örneğin `/hello.txt`. Ancak, yalnızca belirli bir konum (`/hello.txt`) tanımlanmıştır. Kök konum (`location / {...}`) için herhangi bir yapılandırma bulunmamaktadır. Bu ihmal, kök direktifinin genel olarak uygulanmasını sağlar ve kök dizini yoluna (`/`) yapılan isteklerin `/etc/nginx` altındaki dosyalara erişmesine olanak tanır.

Bu yapılandırmadan kaynaklanan önemli bir güvenlik endişesi ortaya çıkar. Basit bir `GET` isteği, örneğin `GET /nginx.conf`, `/etc/nginx/nginx.conf` konumunda bulunan Nginx yapılandırma dosyasını sunarak hassas bilgilerin ifşa edilmesine neden olabilir. Kökü daha az hassas bir dizine, örneğin `/etc` olarak ayarlamak, bu riski azaltabilir, ancak yine de diğer hassas dosyalara, diğer yapılandırma dosyalarına, erişim günlüklerine ve hatta HTTP temel kimlik doğrulaması için kullanılan şifrelenmiş kimlik bilgilerine istenmeyen erişime izin verebilir.

## Alias LFI Yanlış Yapılandırması <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx'in yapılandırma dosyalarında, "location" direktifleri için dikkatli bir inceleme gereklidir. Local File Inclusion (LFI) olarak bilinen bir zayıflık, aşağıdakine benzer bir yapılandırma aracılığıyla yanlışlıkla tanıtılabilir:
```
location /imgs {
alias /path/images/;
}
```
Bu yapılandırma, sunucunun `/imgs../flag.txt` gibi istekleri yorumlayarak, dosyaların amaçlanan dizinin dışındaki dosyalara erişme girişimi olarak algılanmasına neden olan LFI saldırılarına duyarlıdır ve etkili bir şekilde `/path/images/../flag.txt`'ye çözülür. Bu zayıflık, saldırganların sunucunun dosya sisteminden web aracılığıyla erişilememesi gereken dosyaları almasına olanak tanır.

Bu zafiyeti hafifletmek için yapılandırma şu şekilde ayarlanmalıdır:
```
location /imgs/ {
alias /path/images/;
}
```
Daha fazla bilgi: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testleri:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Güvensiz yol kısıtlaması <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Aşağıdaki sayfayı kontrol edin:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{% content-ref url="../../pentesting-web/proxy-waf-protections-bypass.md" %}
[proxy-waf-protections-bypass.md](../../pentesting-web/proxy-waf-protections-bypass.md)
{% endcontent-ref %}

## Güvensiz değişken kullanımı / HTTP İstek Bölme <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

{% hint style="danger" %}
`$uri` ve `$document_uri` gibi güvenlik açıklı değişkenler bulunmaktadır ve bunlar `$request_uri` ile değiştirilerek düzeltilebilir.

Ayrıca regex de şu şekilde güvenlik açığına neden olabilir:

`location ~ /docs/([^/])? { … $1 … }` - Güvenlik açığı bulunmaktadır

`location ~ /docs/([^/\s])? { … $1 … }` - Güvenlik açığı bulunmamaktadır (boşlukları kontrol eder)

`location ~ /docs/(.*)? { … $1 … }`  - Güvenlik açığı bulunmamaktadır
{% endhint %}

Nginx yapılandırmasındaki bir güvenlik açığı aşağıdaki örnekle gösterilmektedir:
```
location / {
return 302 https://example.com$uri;
}
```
HTTP isteklerinde \r (Taşıma İşareti) ve \n (Satır Beslemesi) karakterleri yeni satır karakterlerini belirtir ve URL kodlanmış formları `%0d%0a` olarak temsil edilir. Bu karakterleri bir istekte (örneğin, `http://localhost/%0d%0aDetectify:%20clrf`) içerdiğinde yanlış yapılandırılmış bir sunucuya yeni bir başlık olan `Detectify` çıkar. Bu, $uri değişkeninin URL kodlanmış yeni satır karakterlerini çözmesi nedeniyle yanıtta beklenmeyen bir başlık oluşmasına neden olur:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF enjeksiyonu ve yanıt bölme riskleri hakkında daha fazla bilgi için [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/) adresini ziyaret edebilirsiniz.

Bu tekniğin ayrıca [**bu sunumda**](https://www.youtube.com/watch?v=gWQyWdZbdoY\&list=PL0xCSYnG\_iTtJe2V6PQqamBF73n7-f1Nr\&index=77) bazı zayıf örnekler ve tespit mekanizmaları ile açıklandığını öğrenebilirsiniz. Örneğin, bu yanlış yapılandırmayı siyah kutu bakış açısından tespit etmek için şu istekleri kullanabilirsiniz:

- `https://example.com/%20X` - Herhangi bir HTTP kodu
- `https://example.com/%20H` - 400 Kötü İstek

Zayıf ise, ilk istek "X" herhangi bir HTTP yöntemi olduğu için geri dönecek ve ikincisi H geçerli bir yöntem olmadığı için bir hata dönecektir. Bu nedenle sunucu şuna benzer bir şey alacaktır: `GET / H HTTP/1.1` ve bu hata tetiklenecektir.

Başka tespit örnekleri şunlar olabilir:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Herhangi bir HTTP kodu
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Kötü İstek

Bu sunumda bulunan bazı zayıf yapılandırmalar şunlardır:

- **`$uri`**'nin nihai URL'de olduğu gibi ayarlandığına dikkat edin.
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
* Yine **`$uri`** URL'de (bu sefer bir parametre içinde) bulunmaktadır.
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
* Şimdi AWS S3'te
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Herhangi bir değişken

Belirli durumlarda, **kullanıcı tarafından sağlanan verilerin** belirli koşullar altında bir **Nginx değişkeni** olarak işleme tabi tutulabileceği keşfedildi. Bu davranışın nedeni oldukça belirsiz olsa da, nadir değil ve doğrulaması da kolay değil. Bu anormallik, HackerOne'da bir güvenlik raporunda vurgulandı ve [buradan](https://hackerone.com/reports/370094) görülebilir. Hatanın incelenmesi, [Nginx'in kod tabanındaki SSI filtre modülünde](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx\_http\_ssi\_filter\_module.c#L365) meydana gelen tespit edilmesine yol açtı ve Server Side Includes (SSI)'ı kök neden olarak belirledi.

Bu yan yapılandırmayı **tespit etmek** için aşağıdaki komut çalıştırılabilir, bu işlem değişken yazdırma testi için bir referer başlığı ayarlamayı içerir:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Sistemler üzerinde bu yan yapılandırma için yapılan taramalar, Nginx değişkenlerinin bir kullanıcı tarafından yazdırılabileceği birden fazla örneği ortaya çıkardı. Ancak, savunmasız örneklerin sayısındaki azalma, bu sorunu düzeltme çabalarının bir dereceye kadar başarılı olduğunu göstermektedir.

## Ham arka uç yanıt okuma

Nginx, `proxy_pass` aracılığıyla sunucu hatalarını ve arka uç tarafından üretilen HTTP başlıklarını yakalamaya olanak tanıyan bir özellik sunar, iç hata mesajlarını ve başlıklarını gizlemeyi amaçlar. Bu, Nginx'in arka uç hatalarına yanıt olarak özel hata sayfaları sunarak gerçekleştirilir. Bununla birlikte, Nginx'in geçersiz bir HTTP isteğiyle karşılaştığında zorluklar ortaya çıkar. Böyle bir istek, alındığı gibi arka uca iletilir ve ardından arka ucun ham yanıtı doğrudan Nginx'in müdahalesi olmadan istemciye gönderilir. 

Bir uWSGI uygulamasını içeren bir örnek senaryoyu düşünün:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Bu yönetmek için, Nginx yapılandırmasında belirli direktifler kullanılır:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
* [**proxy\_intercept\_errors**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_intercept\_errors): Bu direktif, Nginx'in durumu 300'den büyük olan backend yanıtları için özel bir yanıt sunmasını sağlar. Örneğimizdeki uWSGI uygulaması için, bir `500 Hata` yanıtının Nginx tarafından engellenip işlenmesini sağlar.
* [**proxy\_hide\_header**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_hide\_header): Adından da anlaşılacağı gibi, bu direktif belirli HTTP başlıklarını istemciden gizler, gizliliği ve güvenliği artırır.

Geçerli bir `GET` isteği yapıldığında, Nginx bunu normal şekilde işler, hiçbir gizli başlığı ortaya çıkarmadan standart bir hata yanıtı döndürür. Ancak, geçersiz bir HTTP isteği bu mekanizmayı atlar ve gizli başlıkları ve hata mesajlarını içeren ham backend yanıtlarının ortaya çıkmasına neden olur.

## merge\_slashes off olarak ayarlandı

Varsayılan olarak, Nginx'in **`merge_slashes` direktifi** **`on`** olarak ayarlanmıştır, bu da bir URL'deki birden fazla ileri eğik çizgiyi tek bir çizgiye sıkıştırır. Bu özellik, URL işleme sürecini basitleştirirken, özellikle Nginx'in arkasındaki uygulamalardaki (özellikle yerel dosya dahil etme (LFI) saldırılarına duyarlı olanlar) zayıflıkları yanlışlıkla gizleyebilir. Güvenlik uzmanları **Danny Robinson ve Rotem Bar**, özellikle Nginx'in ters proxy olarak hareket ettiğinde, bu varsayılan davranışla ilişkili potansiyel riskleri vurgulamışlardır.

Bu tür riskleri azaltmak için, bu zayıflıklara duyarlı uygulamalar için **`merge_slashes` direktifini kapatmanız** önerilir. Bu, Nginx'in URL yapısını değiştirmeden istekleri uygulamaya ilettiğinden, altta yatan güvenlik sorunlarını gizlemeden işlem yapmasını sağlar.

Daha fazla bilgi için [Danny Robinson ve Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d)'ı kontrol edin.

### **Zararlı Yanıt Başlıkları**

[**Bu yazıda**](https://mizu.re/post/cors-playground) gösterildiği gibi, web sunucusundan gelen belirli başlıklar, Nginx proxy'nin davranışını değiştirecektir. Bunları [**belgelerde**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) kontrol edebilirsiniz:

* `X-Accel-Redirect`: Nginx'e bir isteği belirtilen bir konuma yönlendirmesi için işaret eder.
* `X-Accel-Buffering`: Nginx'in yanıtı önbelleğe alıp almayacağını kontrol eder.
* `X-Accel-Charset`: X-Accel-Redirect kullanılırken yanıt için karakter setini ayarlar.
* `X-Accel-Expires`: X-Accel-Redirect kullanılırken yanıtın son kullanma zamanını ayarlar.
* `X-Accel-Limit-Rate`: X-Accel-Redirect kullanılırken yanıtın transfer hızını sınırlar.

Örneğin, **`X-Accel-Redirect`** başlığı nginx'de içsel bir **yönlendirme** yapacaktır. Bu nedenle, **`root /`** gibi bir nginx yapılandırmasına ve web sunucusundan gelen **`X-Accel-Redirect: .env`** gibi bir yanıta sahip olmak, nginx'in **`/.env`** içeriğini göndermesine neden olacaktır (Yol Geçişi).

### **Map Direktifindeki Varsayılan Değer**

**Nginx yapılandırmasında**, `map` direktifi genellikle **yetkilendirme kontrolünde** rol oynar. Yaygın bir hata, bir **varsayılan** değer belirtmemektir, bu da yetkisiz erişime yol açabilir. Örneğin:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bir `varsayılan` olmadan, bir **kötü niyetli kullanıcı**, `/map-poc` içindeki **tanımsız URI'ye** erişerek güvenlik önlemlerini atlayabilir. [Nginx kılavuzu](https://nginx.org/en/docs/http/ngx_http_map_module.html), bu tür sorunları önlemek için bir **varsayılan değer** belirlemenizi önerir.

### **DNS Sahteciliği Zafiyeti**

Belirli koşullar altında Nginx'e karşı DNS sahteciliği mümkündür. Bir saldırgan, Nginx'in kullandığı **DNS sunucusunu** bildiğinde ve DNS sorgularını onaylayabildiğinde DNS kayıtlarını sahtecilik yapabilir. Ancak, Nginx'in DNS çözümlemesi için **localhost (127.0.0.1)**'i kullanacak şekilde yapılandırıldıysa bu yöntem etkisizdir. Nginx, bir DNS sunucusunu aşağıdaki gibi belirtmeye izin verir:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` ve `internal` Komutları**

**`proxy_pass`** komutu, istekleri başka sunuculara yönlendirmek için kullanılır, ya içsel ya da harici olarak. **`internal`** komutu ise belirli konumlara sadece Nginx içinden erişilebilir olmasını sağlar. Bu komutlar başlı başına güvenlik açıkları değildir, ancak bunların yapılandırılması güvenlik zaafiyetlerini önlemek için dikkatli bir şekilde incelenmelidir.

## proxy\_set\_header Upgrade & Connection

Eğer nginx sunucusu, Upgrade ve Connection başlıklarını iletmek için yapılandırılmışsa, bir [**h2c Smuggling saldırısı**](../../pentesting-web/h2c-smuggling.md) gerçekleştirilebilir ve korumalı/içsel uç noktalara erişilebilir.

{% hint style="danger" %}
Bu güvenlik açığı, bir saldırganın **`proxy_pass` uç noktasıyla doğrudan bir bağlantı kurmasına izin verecektir** (`http://backend:9999` bu durumda) ve bu içerik Nginx tarafından kontrol edilmeyecektir.
{% endhint %}

`/flag`'i çalmak için savunmasız yapılandırma örneği [burada](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
`proxy_pass`'in belirli bir **yol**a işaret ettiği durumda bile, örneğin `http://backend:9999/socket.io`, bağlantı `http://backend:9999` ile kurulacaktır, bu nedenle **iç uç noktadaki herhangi başka bir yola ulaşabilirsiniz. Dolayısıyla, proxy_pass URL'sinde bir yol belirtilmiş olup olmadığı önemli değildir.**
{% endhint %}

## Kendiniz deneyin

Detectify, bu makalede tartışılan bazı yanlış yapılandırmalarla kendi zayıf Nginx test sunucusunu kurmanızı ve bunları kendiniz bulmanızı deneyebileceğiniz bir GitHub deposu oluşturdu!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statik Analiz Araçları

### [GIXY](https://github.com/yandex/gixy)

Gixy, Nginx yapılandırmasını analiz etmek için bir araçtır. Gixy'nin ana amacı güvenlik yanlı yapılandırmalarını önlemek ve hata tespitini otomatikleştirmektir.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner, yaygın Nginx yanlı yapılandırmalarını ve güvenlik açıklarını aramak için basit bir araçtır.

## Referanslar

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

**Anında kullanılabilir zayıflık değerlendirme ve penetrasyon testi kurulumu**. Keşiften raporlamaya kadar 20'den fazla araç ve özellikle tam bir pentest çalıştırın. Pentester'ları değiştirmiyoruz - onlara daha derinlemesine kazma, kabuklar açma ve eğlenme zamanı vermek için özel araçlar, tespit ve istismar modülleri geliştiriyoruz.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud** github depolarına PR'lar göndererek paylaşın.

</details>
