# Nginx

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)で**フォロー**する。
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

**どこからでも利用可能な脆弱性評価＆ペネトレーションテストのための即時セットアップ**。レコンからレポート作成まで、20以上のツールと機能を備えた完全なペンテストを実行します。私たちはペンテスターを置き換えるのではなく、彼らに時間を戻してより深く掘り下げたり、シェルをポップしたり、楽しんだりするためのカスタムツール、検出、およびエクスプロイトモジュールを開発しています。

{% embed url="https://pentest-tools.com/" %}

## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

## **Nginxルートディレクトリの設定の基本**

Nginxサーバーを構成する際、**rootディレクティブ**は、ファイルが提供されるベースディレクトリを定義する重要な役割を果たします。以下は例をご覧ください：
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
この設定では、`/etc/nginx` がルートディレクトリとして指定されています。このセットアップにより、`/hello.txt` のような指定されたルートディレクトリ内のファイルにアクセスできます。ただし、特定の場所（`/hello.txt`）のみが定義されています。ルートの場所（`location / {...}`）に関する設定がないことに注意することが重要です。この省略は、ルートディレクティブがグローバルに適用されることを意味し、ルートパス `/` へのリクエストが `/etc/nginx` の下のファイルにアクセスできるようになります。

この設定から生じる重要なセキュリティ上の考慮事項があります。`GET /nginx.conf` のような単純な `GET` リクエストは、`/etc/nginx/nginx.conf` にある Nginx 設定ファイルを提供することで機密情報を公開する可能性があります。ルートを `/etc` のようなより機密性の低いディレクトリに設定することで、このリスクを軽減できますが、他の重要なファイルへの意図しないアクセスを許可する可能性があります。これには、他の設定ファイル、アクセスログ、さらにはHTTP基本認証に使用される暗号化された資格情報などが含まれます。

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginxの設定ファイルでは、「location」ディレクティブを注意深く検査する必要があります。次のような構成を通じて、ローカルファイルインクルージョン（LFI）として知られる脆弱性が誤って導入される可能性があります。
```
location /imgs {
alias /path/images/;
}
```
この設定は、`/imgs../flag.txt`のようなリクエストをサーバーが解釈し、意図されたディレクトリの外のファイルにアクセスしようとしていると見なすため、LFI攻撃に対して脆弱です。これにより、`/path/images/../flag.txt`に解決され、攻撃者はウェブ経由でアクセスすべきでないサーバーのファイルを取得できます。

この脆弱性を緩和するために、設定を以下のように調整する必要があります：
```
location /imgs/ {
alias /path/images/;
}
```
詳細: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix テスト:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## 安全でないパス制限 <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

以下のページをチェックして、次のようなディレクティブをバイパスする方法を学んでください：
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
## 安全でない変数の使用 / HTTPリクエストの分割 <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

{% hint style="danger" %}
脆弱な変数 `$uri` と `$document_uri` は、`$request_uri` に置き換えることで修正できます。

正規表現も脆弱になる可能性があります:

`location ~ /docs/([^/])? { … $1 … }` - 脆弱

`location ~ /docs/([^/\s])? { … $1 … }` - 脆弱ではない（スペースをチェック）

`location ~ /docs/(.*)? { … $1 … }`  - 脆弱ではない
{% endhint %}

以下の例で、Nginx構成の脆弱性が示されています:
```
location / {
return 302 https://example.com$uri;
}
```
HTTPリクエスト内の改行文字を示す\r（キャリッジリターン）と\n（ラインフィード）文字は、そのURLエンコード形式として`%0d%0a`と表されます。これらの文字をリクエスト内に含める（例：`http://localhost/%0d%0aDetectify:%20clrf`）ことは、設定ミスのサーバーに対してリクエストを送信すると、サーバーが`Detectify`という新しいヘッダーを発行する結果となります。これは、$uri変数がURLエンコードされた改行文字をデコードするため、レスポンス内に予期しないヘッダーが現れるからです。
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLFインジェクションとレスポンス分割のリスクについては、[https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/)で詳細を確認してください。

また、この技術は[**このトーク**](https://www.youtube.com/watch?v=gWQyWdZbdoY\&list=PL0xCSYnG\_iTtJe2V6PQqamBF73n7-f1Nr\&index=77)で脆弱な例と検出メカニズムが説明されています。たとえば、このミス構成をブラックボックスの観点から検出するために、次のリクエストを使用できます：

- `https://example.com/%20X` - 任意のHTTPコード
- `https://example.com/%20H` - 400 Bad Request

脆弱な場合、最初のリクエストは「X」が任意のHTTPメソッドであるため返され、2番目のリクエストはHが有効なメソッドでないためエラーが返されます。したがって、サーバーは次のようなものを受信します：`GET / H HTTP/1.1` これによりエラーが発生します。

別の検出例は次のとおりです：

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - 任意のHTTPコード
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

そのトークで発見された脆弱な構成の一部は次のとおりです：

- **`$uri`** が最終URLにそのまま設定されていることに注目してください
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
* 再度、URL内に **`$uri`** があることに注目してください（今回はパラメータ内）。
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
* 今、AWS S3 にいます
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### 任意の変数

特定の状況下で、**ユーザー提供データ** が **Nginx変数** として扱われる可能性があることが発見されました。この振る舞いの原因はやや理解しづらいですが、珍しいわけではなく、簡単に検証できるわけでもありません。この異常は、HackerOneのセキュリティレポートで強調されており、[こちら](https://hackerone.com/reports/370094)で閲覧できます。エラーメッセージのさらなる調査により、Nginxのコードベース内の[SSIフィルターモジュール](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx\_http\_ssi\_filter\_module.c#L365)での発生が特定され、サーバーサイドインクルード（SSI）がその原因であることが明らかになりました。

この設定ミスを**検出する**ために、次のコマンドを実行できます。これには、refererヘッダーを設定して変数の印刷をテストする必要があります。
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
複数のシステムでこのミス構成のスキャンを実行すると、ユーザーによってNginx変数が表示される可能性があることが明らかになりました。ただし、脆弱なインスタンスの数の減少から、この問題に対するパッチ適用の取り組みがある程度成功していることが示唆されています。

## バックエンドの生の応答の読み取り

Nginxは、`proxy_pass`を介してバックエンドによって生成されたエラーやHTTPヘッダーを傍受する機能を提供しており、内部エラーメッセージやヘッダーを隠すことを目的としています。これは、Nginxがバックエンドエラーに応答してカスタムエラーページを提供することで実現されます。ただし、Nginxが無効なHTTPリクエストに遭遇した場合に課題が発生します。そのようなリクエストは受信されたままバックエンドに転送され、バックエンドの生の応答がNginxの介入なしにクライアントに直接送信されます。

uWSGIアプリケーションを使用した例のシナリオを考えてみましょう：
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
以下のように、Nginx構成内で特定のディレクティブを使用して管理します:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
* [**proxy\_intercept\_errors**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_intercept\_errors): このディレクティブは、Nginxがステータスコードが300を超えるバックエンドのレスポンスに対してカスタムレスポンスを提供するようにします。例えば、uWSGIアプリケーションの場合、`500エラー`レスポンスがNginxによってインターセプトされて処理されることを保証します。
* [**proxy\_hide\_header**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_hide\_header): その名前が示すように、このディレクティブは特定のHTTPヘッダーをクライアントから非表示にし、プライバシーとセキュリティを向上させます。

有効な`GET`リクエストが行われると、Nginxは通常通り処理し、秘密のヘッダーを明らかにせずに標準のエラーレスポンスを返します。しかし、無効なHTTPリクエストはこのメカニズムをバイパスし、秘密のヘッダーやエラーメッセージを含む生のバックエンドレスポンスが公開されます。

## merge\_slashesをoffに設定

デフォルトでは、Nginxの**`merge_slashes`ディレクティブ**は**`on`**に設定されており、URL内の複数のスラッシュを単一のスラッシュに圧縮します。この機能は、URL処理を効率化する一方で、特にNginxの背後にあるアプリケーションに存在するローカルファイルインクルージョン（LFI）攻撃に対して脆弱なアプリケーションの脆弱性を誤って隠す可能性があります。セキュリティ専門家の**Danny Robinson**と**Rotem Bar**は、特にNginxがリバースプロキシとして機能する場合に、このデフォルトの動作に関連する潜在的なリスクを強調しています。

このようなリスクを軽減するために、これらの脆弱性に対して感染しやすいアプリケーションでは、**`merge_slashes`ディレクティブをoffに設定**することが推奨されています。これにより、NginxがURL構造を変更せずにリクエストをアプリケーションに転送し、基礎となるセキュリティの問題を隠さないようにします。

詳細については、[Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d)を参照してください。

### **Mapディレクティブのデフォルト値**

**Nginxの設定**では、`map`ディレクティブはしばしば**認可制御**に役立ちます。一般的な間違いは、**デフォルト**値を指定しないことで、認可されていないアクセスにつながる可能性があります。例えば：
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
`default`がないと、**悪意のあるユーザー**が`/map-poc`内の**未定義のURI**にアクセスしてセキュリティをバイパスできる可能性があります。[Nginxマニュアル](https://nginx.org/en/docs/http/ngx\_http\_map\_module.html)では、このような問題を回避するために**デフォルト値**を設定することが推奨されています。

### **DNSスプーフィング脆弱性**

特定の条件下では、Nginxに対するDNSスプーフィングが可能です。攻撃者がNginxが使用する**DNSサーバー**を知り、そのDNSクエリを傍受できる場合、DNSレコードをスプーフィングできます。ただし、NginxがDNS解決に**localhost (127.0.0.1)**を使用するように構成されている場合、この方法は効果がありません。Nginxでは、次のようにDNSサーバーを指定することができます：
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass`および`internal`ディレクティブ**

**`proxy_pass`**ディレクティブは、リクエストを他のサーバーに内部的または外部的にリダイレクトするために使用されます。**`internal`**ディレクティブは、特定の場所がNginx内でのみアクセス可能であることを保証します。これらのディレクティブ自体には脆弱性はありませんが、セキュリティの問題を防ぐために慎重な構成が必要です。

## proxy\_set\_header Upgrade＆Connection

NginxサーバーがUpgradeおよびConnectionヘッダーを渡すように構成されている場合、[**h2cスマグリング攻撃**](../../pentesting-web/h2c-smuggling.md)が実行され、保護された/内部エンドポイントにアクセスできる可能性があります。

{% hint style="danger" %}
この脆弱性により、攻撃者は`proxy_pass`エンドポイント（この場合は`http://backend:9999`）との**直接接続を確立**することができ、そのコンテンツはNginxによってチェックされない可能性があります。
{% endhint %}

[こちら](https://bishopfox.com/blog/h2c-smuggling-request)から`/flag`を盗むための脆弱な構成の例：
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
`proxy_pass`が特定の**パス**を指していたとしても、例えば`http://backend:9999/socket.io`のような場合でも、接続は`http://backend:9999`と確立されるため、その内部エンドポイント内の他のパスにアクセスできます。つまり、proxy\_passのURLにパスが指定されていても問題ありません。
{% endhint %}

## 自分で試してみる

Detectifyは、この記事で議論されているいくつかのミス構成を持つ脆弱なNginxテストサーバーをDockerを使用して設定し、それらを自分で見つけてみることができるGitHubリポジトリを作成しました！

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## 静的解析ツール

### [GIXY](https://github.com/yandex/gixy)

GixyはNginx構成を分析するツールです。Gixyの主な目標はセキュリティミス構成を防止し、欠陥検出を自動化することです。

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwnerは一般的なNginxミス構成と脆弱性を探すためのシンプルなツールです。

## 参考文献

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

**脆弱性評価およびペネトレーションテストのための即座に利用可能なセットアップ**。20以上のツールと機能を備えた完全なペンテストをどこからでも実行します。私たちはペンテスターを置き換えるのではなく、彼らがより深く掘り下げ、シェルをポップし、楽しむためのカスタムツール、検出、およびエクスプロイトモジュールを開発しています。

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[NFTs](https://opensea.io/collection/the-peass-family)コレクションを見つけます
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**または[telegramグループ](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**および**HackTricks Cloud**のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>
