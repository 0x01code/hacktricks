# Nginx

<details>

<summary><strong>Impara l'hacking AWS da zero a ero con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

**Configurazione istantanea disponibile per valutazione delle vulnerabilit√† e test di penetrazione**. Esegui un pentest completo da qualsiasi luogo con oltre 20 strumenti e funzionalit√† che vanno dalla ricognizione alla segnalazione. Non sostituiamo i pentester - sviluppiamo strumenti personalizzati, moduli di rilevamento ed exploit per restituire loro del tempo per approfondire, aprire shell e divertirsi.

{% embed url="https://pentest-tools.com/" %}

## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

Quando si configura il server Nginx, la **direttiva root** svolge un ruolo critico definendo la directory di base da cui vengono serviti i file. Considera l'esempio qui sotto:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In questa configurazione, `/etc/nginx` √® designato come directory principale. Questo setup permette l'accesso ai file all'interno della directory principale specificata, come `/hello.txt`. Tuttavia, √® fondamentale notare che √® definita solo una specifica posizione (`/hello.txt`). Non c'√® una configurazione per la posizione principale (`location / {...}`). Questa omissione significa che la direttiva principale si applica globalmente, consentendo alle richieste del percorso principale `/` di accedere ai file sotto `/etc/nginx`.

Da questa configurazione sorge una considerazione critica per la sicurezza. Una semplice richiesta `GET`, come `GET /nginx.conf`, potrebbe esporre informazioni sensibili servendo il file di configurazione di Nginx situato in `/etc/nginx/nginx.conf`. Impostare la directory principale su una directory meno sensibile, come `/etc`, potrebbe ridurre questo rischio, ma potrebbe comunque consentire l'accesso non intenzionale ad altri file critici, inclusi altri file di configurazione, log di accesso e persino credenziali crittografate utilizzate per l'autenticazione di base HTTP.

## Configurazione Errata di Alias LFI <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nei file di configurazione di Nginx, √® necessaria un'ispezione attenta delle direttive "location". Una vulnerabilit√† nota come Inclusione di File Locale (LFI) pu√≤ essere introdotta involontariamente attraverso una configurazione che assomiglia a quanto segue:
```
location /imgs {
alias /path/images/;
}
```
Questo tipo di configurazione √® vulnerabile agli attacchi LFI poich√© il server interpreta le richieste come `/imgs../flag.txt` come un tentativo di accedere a file al di fuori della directory prevista, risolvendo effettivamente in `/percorso/immagini/../flag.txt`. Questa falla consente agli attaccanti di recuperare file dal filesystem del server che non dovrebbero essere accessibili tramite il web.

Per mitigare questa vulnerabilit√†, la configurazione dovrebbe essere regolata in:
```
location /imgs/ {
alias /path/images/;
}
```
Ulteriori informazioni: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Test di Acunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Restrizione del percorso non sicura <a href="#uso-di-variabili-non-sicure" id="uso-di-variabili-non-sicure"></a>

Controlla la pagina seguente per imparare come aggirare direttive come:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{% content-ref url="../../pentesting-web/proxy-waf-protections-bypass.md" %}
[proxy-waf-protections-bypass.md](../../pentesting-web/proxy-waf-protections-bypass.md)
{% endcontent-ref %}

## Uso non sicuro delle variabili / Divisione della richiesta HTTP <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

{% hint style="danger" %}
Le variabili vulnerabili `$uri` e `$document_uri` possono essere risolte sostituendole con `$request_uri`.

Una regex pu√≤ essere vulnerabile come:

`location ~ /docs/([^/])? { ‚Ä¶ $1 ‚Ä¶ }` - Vulnerabile

`location ~ /docs/([^/\s])? { ‚Ä¶ $1 ‚Ä¶ }` - Non vulnerabile (controllo degli spazi)

`location ~ /docs/(.*)? { ‚Ä¶ $1 ‚Ä¶ }`  - Non vulnerabile
{% endhint %}

Una vulnerabilit√† nella configurazione di Nginx √® dimostrata dall'esempio seguente:
```
location / {
return 302 https://example.com$uri;
}
```
I caratteri \r (Carriage Return) e \n (Line Feed) indicano i caratteri di nuova riga nelle richieste HTTP, e le loro forme URL-encoded sono rappresentate come `%0d%0a`. Includere questi caratteri in una richiesta (ad esempio, `http://localhost/%0d%0aDetectify:%20clrf`) a un server configurato in modo errato porta il server a emettere un nuovo header chiamato `Detectify`. Questo avviene perch√© la variabile $uri decodifica i caratteri di nuova riga URL-encoded, portando a un header inaspettato nella risposta:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Scopri di pi√π sui rischi dell'iniezione di CRLF e della divisione delle risposte a [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Inoltre questa tecnica √® **spiegata in questa presentazione** con alcuni esempi vulnerabili e meccanismi di rilevamento. Ad esempio, per rilevare questa errata configurazione da una prospettiva blackbox potresti utilizzare queste richieste:

- `https://example.com/%20X` - Qualsiasi codice HTTP
- `https://example.com/%20H` - 400 Bad Request

Se vulnerabile, il primo restituir√† "X" poich√© √® un qualsiasi metodo HTTP e il secondo restituir√† un errore poich√© H non √® un metodo valido. Quindi il server ricever√† qualcosa del genere: `GET / H HTTP/1.1` e questo attiver√† l'errore.

Altri esempi di rilevamento sarebbero:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Qualsiasi codice HTTP
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Alcune configurazioni vulnerabili trovate presentate in quella presentazione erano:

- Nota come **`$uri`** sia impostato cos√¨ com'√® nell'URL finale
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
* Notare come di nuovo **`$uri`** sia presente nell'URL (questa volta all'interno di un parametro)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
* Ora in AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Qualsiasi variabile

√à stato scoperto che i **dati forniti dall'utente** potrebbero essere trattati come una **variabile Nginx** in determinate circostanze. La causa di questo comportamento rimane in parte sfuggente, ma non √® n√© rara n√© semplice da verificare. Questa anomalia √® stata evidenziata in un rapporto di sicurezza su HackerOne, che pu√≤ essere visualizzato [qui](https://hackerone.com/reports/370094). Ulteriori indagini sul messaggio di errore hanno portato all'identificazione della sua presenza all'interno del [modulo filtro SSI del codice di Nginx](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx\_http\_ssi\_filter\_module.c#L365), individuando gli Include lato server (SSI) come causa principale.

Per **rilevare questa errata configurazione**, pu√≤ essere eseguito il seguente comando, che implica impostare un'intestazione referer per testare la stampa della variabile:
```bash
$ curl -H ‚ÄòReferer: bar‚Äô http://localhost/foo$http_referer | grep ‚Äòfoobar‚Äô
```
Scansioni per questa errata configurazione su vari sistemi hanno rivelato molteplici istanze in cui le variabili di Nginx potevano essere stampate da un utente. Tuttavia, una diminuzione del numero di istanze vulnerabili suggerisce che gli sforzi per correggere questo problema siano stati in parte efficaci.

## Lettura grezza della risposta del backend

Nginx offre una funzionalit√† tramite `proxy_pass` che consente l'intercettazione degli errori e degli header HTTP prodotti dal backend, mirando a nascondere i messaggi di errore interni e gli header. Ci√≤ viene realizzato da Nginx servendo pagine di errore personalizzate in risposta agli errori del backend. Tuttavia, sorgono sfide quando Nginx si trova di fronte a una richiesta HTTP non valida. Una tale richiesta viene inoltrata al backend cos√¨ come ricevuta, e la risposta grezza del backend viene quindi inviata direttamente al client senza l'intervento di Nginx.

Considera uno scenario di esempio che coinvolge un'applicazione uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Per gestire ci√≤, vengono utilizzate direttive specifiche nella configurazione di Nginx:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
* [**proxy\_intercept\_errors**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_intercept\_errors): Questa direttiva abilita Nginx a servire una risposta personalizzata per le risposte del backend con un codice di stato maggiore di 300. Assicura che, per il nostro esempio di applicazione uWSGI, una risposta `Errore 500` venga intercettata e gestita da Nginx.
* [**proxy\_hide\_header**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_hide\_header): Come suggerisce il nome, questa direttiva nasconde gli header HTTP specificati dal client, migliorando la privacy e la sicurezza.

Quando viene effettuata una richiesta `GET` valida, Nginx la elabora normalmente, restituendo una risposta di errore standard senza rivelare eventuali header segreti. Tuttavia, una richiesta HTTP non valida aggira questo meccanismo, con conseguente esposizione delle risposte grezze del backend, inclusi gli header segreti e i messaggi di errore.

## merge\_slashes impostato su off

Per impostazione predefinita, la direttiva **`merge_slashes` di Nginx** √® impostata su **`on`**, che comprime pi√π barre oblique in un URL in una singola barra. Questa funzionalit√†, pur semplificando l'elaborazione degli URL, pu√≤ involontariamente nascondere vulnerabilit√† nelle applicazioni dietro Nginx, in particolare quelle soggette ad attacchi di inclusione di file locali (LFI). Gli esperti di sicurezza **Danny Robinson e Rotem Bar** hanno evidenziato i rischi potenziali associati a questo comportamento predefinito, specialmente quando Nginx agisce come reverse-proxy.

Per mitigare tali rischi, si consiglia di **disattivare la direttiva `merge_slashes`** per le applicazioni suscettibili a queste vulnerabilit√†. Ci√≤ garantisce che Nginx inoltri le richieste all'applicazione senza alterare la struttura dell'URL, non mascherando eventuali problemi di sicurezza sottostanti.

Per ulteriori informazioni consulta [Danny Robinson e Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Intestazioni di Risposta Maliziose**

Come mostrato in [**questo articolo**](https://mizu.re/post/cors-playground), ci sono determinati header che, se presenti nella risposta dal server web, cambieranno il comportamento del proxy Nginx. Puoi controllarli [**nella documentazione**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

* `X-Accel-Redirect`: Indica a Nginx di reindirizzare internamente una richiesta a una posizione specificata.
* `X-Accel-Buffering`: Controlla se Nginx deve bufferizzare la risposta o meno.
* `X-Accel-Charset`: Imposta il set di caratteri per la risposta quando si utilizza X-Accel-Redirect.
* `X-Accel-Expires`: Imposta il tempo di scadenza per la risposta quando si utilizza X-Accel-Redirect.
* `X-Accel-Limit-Rate`: Limita il tasso di trasferimento per le risposte quando si utilizza X-Accel-Redirect.

Ad esempio, l'intestazione **`X-Accel-Redirect`** causer√† un **reindirizzamento interno** in Nginx. Quindi, avere una configurazione nginx con qualcosa come **`root /`** e una risposta dal server web con **`X-Accel-Redirect: .env`** far√† s√¨ che nginx invii il contenuto di **`/.env`** (Trasversamento di Percorso).

### **Valore Predefinito nella Direttiva Map**

Nella **configurazione di Nginx**, la direttiva `map` spesso svolge un ruolo nel **controllo dell'autorizzazione**. Un errore comune √® non specificare un **valore predefinito**, il che potrebbe portare a un accesso non autorizzato. Ad esempio:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Senza un `default`, un **utente malintenzionato** pu√≤ eludere la sicurezza accedendo a un **URI non definito** all'interno di `/map-poc`. [Il manuale di Nginx](https://nginx.org/en/docs/http/ngx\_http\_map\_module.html) consiglia di impostare un **valore predefinito** per evitare tali problemi.

### **Vulnerabilit√† di Spoofing DNS**

Lo spoofing DNS contro Nginx √® fattibile in determinate condizioni. Se un attaccante conosce il **server DNS** utilizzato da Nginx e pu√≤ intercettare le sue query DNS, pu√≤ falsificare i record DNS. Tuttavia, questo metodo √® inefficace se Nginx √® configurato per utilizzare **localhost (127.0.0.1)** per la risoluzione DNS. Nginx consente di specificare un server DNS nel seguente modo:
```yaml
resolver 8.8.8.8;
```
### **Direttive `proxy_pass` e `internal`**

La direttiva **`proxy_pass`** viene utilizzata per reindirizzare le richieste verso altri server, sia internamente che esternamente. La direttiva **`internal`** garantisce che determinate posizioni siano accessibili solo all'interno di Nginx. Anche se queste direttive non costituiscono vulnerabilit√† di per s√©, la loro configurazione richiede un'esame attento per evitare falle di sicurezza.

## proxy\_set\_header Upgrade & Connection

Se il server nginx √® configurato per passare gli header Upgrade e Connection, potrebbe essere eseguito un [**attacco di Smuggling h2c**](../../pentesting-web/h2c-smuggling.md) per accedere a endpoint protetti/interni.

{% hint style="danger" %}
Questa vulnerabilit√† consentirebbe a un attaccante di **stabilire una connessione diretta con l'endpoint `proxy_pass`** (`http://backend:9999` in questo caso) il cui contenuto non verr√† verificato da nginx.
{% endhint %}

Esempio di configurazione vulnerabile per rubare `/flag` da [qui](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
Nota che anche se `proxy_pass` puntava a un **percorso** specifico come `http://backend:9999/socket.io` la connessione verr√† stabilita con `http://backend:9999` quindi puoi **contattare qualsiasi altro percorso all'interno di quel punto finale interno. Quindi non importa se un percorso √® specificato nell'URL di proxy\_pass.**
{% endhint %}

## Provalo tu stesso

Detectify ha creato un repository su GitHub dove puoi utilizzare Docker per configurare il tuo server di test Nginx vulnerabile con alcune delle misconfigurazioni discusse in questo articolo e provare a trovarle da solo!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Strumenti di Analisi Statica

### [GIXY](https://github.com/yandex/gixy)

Gixy √® uno strumento per analizzare la configurazione di Nginx. L'obiettivo principale di Gixy √® prevenire le misconfigurazioni di sicurezza e automatizzare il rilevamento delle vulnerabilit√†.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner √® uno strumento semplice per cercare le comuni misconfigurazioni e vulnerabilit√† di Nginx.

## Riferimenti

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

**Configurazione immediatamente disponibile per valutazione delle vulnerabilit√† e test di penetrazione**. Esegui un pentest completo da qualsiasi luogo con oltre 20 strumenti e funzionalit√† che vanno dalla ricognizione alla segnalazione. Non sostituiamo i pentester - sviluppiamo strumenti personalizzati, moduli di rilevamento ed exploit per restituire loro del tempo per approfondire, aprire shell e divertirsi.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Impara l'hacking su AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
