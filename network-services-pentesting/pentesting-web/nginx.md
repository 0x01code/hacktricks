# Nginx

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをご覧ください
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローしてください。**
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**脆弱性評価とペネトレーションテストのための即時利用可能なセットアップ**。どこからでも完全なペネトレーションテストを実行できます。リコンからレポーティングまで、20以上のツールと機能が含まれています。私たちはペネトレーターを置き換えるものではありません - 私たちはカスタムツール、検出・エクスプロイトモジュールを開発して、彼らがより深く掘り下げ、シェルをポップし、楽しむための時間を取り戻すためのものです。

{% embed url="https://pentest-tools.com/" %}

## ルートロケーションがない <a href="#missing-root-location" id="missing-root-location"></a>
```
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
`root` ディレクティブは、Nginxのルートフォルダを指定します。上記の例では、ルートフォルダは `/etc/nginx` であり、そのフォルダ内のファイルにアクセスできることを意味します。上記の設定には `/ (location / {...})` の場所がなく、`/hello.txt` のみがあります。このため、`root` ディレクティブはグローバルに設定され、`/` へのリクエストはローカルパス `/etc/nginx` に移動します。

`GET /nginx.conf` のような単純なリクエストは、`/etc/nginx/nginx.conf` に保存されているNginx設定ファイルの内容を明らかにします。ルートが `/etc` に設定されている場合、`GET` リクエストを `/nginx/nginx.conf` にすると、設定ファイルが表示されます。場合によっては、他の設定ファイル、アクセスログ、さらにはHTTP基本認証のための暗号化された資格情報にアクセスできることもあります。

## Alias LFI 誤設定 <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx設定内で "location" ステートメントを探し、もし以下のようなものがあれば：
```
location /imgs {
alias /path/images/;
}
```
LFIの脆弱性が存在します。なぜなら：
```
/imgs../flag.txt
```
```markdown
# NGINX ペネトレーションテスト

## 概要

NGINXは、高性能なWebサーバー、リバースプロキシ、およびメールプロキシサーバーとして広く使用されています。セキュリティの脆弱性を特定するために、ペネトレーションテスターはNGINXの設定と実装を慎重に調査する必要があります。

## 情報収集

### バージョン検出

バージョン情報は、既知の脆弱性を特定するために重要です。以下のコマンドを使用してNGINXのバージョンを確認できます。

```bash
nginx -v
```

### 設定ファイル

設定ファイルは、セキュリティ上の問題を発見するための重要な情報源です。デフォルトでは、NGINXの設定ファイルは `/etc/nginx/nginx.conf` にあります。

## 脆弱性スキャン

### nikto

niktoは、Webサーバーの脆弱性をスキャンするためのオープンソースツールです。以下のコマンドでNGINXサーバーをスキャンできます。

```bash
nikto -h <target>
```

### Nmap

Nmapは、ネットワークのセキュリティスキャンに使用されるツールです。以下のNmapスクリプトを使用して、NGINXの脆弱性を探すことができます。

```bash
nmap --script http-nginx-* <target>
```

## ミスコンフィギュレーションの検出

NGINXの設定ミスは、セキュリティ上のリスクを引き起こす可能性があります。以下の項目を確認してください。

- ディレクトリリスティング
- 不適切なファイルアクセス制御
- SSL/TLS設定の弱点

## セキュリティヘッダー

セキュリティヘッダーは、Webアプリケーションのセキュリティを強化するために重要です。以下のヘッダーを確認してください。

- Strict-Transport-Security
- Content-Security-Policy
- X-Content-Type-Options
- X-Frame-Options
- X-XSS-Protection

## ログ分析

ログは、不正アクセスやシステムの異常を検出するための貴重な情報源です。NGINXのアクセスログとエラーログを定期的に確認してください。

## まとめ

NGINXのペネトレーションテストは、セキュリティの脆弱性を特定し、攻撃からシステムを保護するために不可欠です。上記の手順に従って、NGINXのセキュリティを強化してください。
```
```
/path/images/../flag.txt
```
正しい設定は以下の通りです:
```
location /imgs/ {
alias /path/images/;
}
```
**Nginxサーバーを見つけたら、この脆弱性をチェックする必要があります。また、ファイル/ディレクトリのブルートフォースがおかしな挙動を示している場合にも、この脆弱性を発見できるかもしれません。**

詳細情報: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetixのテスト：
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## 不適切なパス制限 <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

以下のページを参照して、次のようなディレクティブをバイパスする方法を学びましょう：
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{% content-ref url="../../pentesting-web/proxy-waf-protections-bypass.md" %}
[proxy-waf-protections-bypass.md](../../pentesting-web/proxy-waf-protections-bypass.md)
{% endcontent-ref %}

## 安全でない変数の使用 <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

脆弱なNginx設定の例は以下の通りです：
```
location / {
return 302 https://example.com$uri;
}
```
HTTPリクエストの改行文字は`\r`（キャリッジリターン）と`\n`（ラインフィード）です。改行文字をURLエンコードすると、文字は`%0d%0a`という表現になります。これらの文字が`http://localhost/%0d%0aDetectify:%20clrf`のようなリクエストに含まれている場合、誤設定されたサーバーは`Detectify`という新しいヘッダーで応答します。なぜなら$uri変数がURLデコードされた改行文字を含んでいるからです。
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLFインジェクションとレスポンス分割のリスクについて詳しくは、[https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/)をご覧ください。

### 任意の変数

場合によっては、ユーザーが提供したデータがNginx変数として扱われることがあります。これがなぜ起こるのかは不明ですが、[H1レポート](https://hackerone.com/reports/370094)で見られるように、それほど珍しいことではなく、テストも簡単ではありません。エラーメッセージを検索すると、[SSIフィルターモジュール](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365)で見つかることから、これがSSIによるものであることが明らかになります。

これをテストする一つの方法は、refererヘッダーの値を設定することです：
```
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
私たちはこの誤設定をスキャンし、ユーザーがNginx変数の値を印刷できるいくつかのインスタンスを見つけました。見つかった脆弱なインスタンスの数が減少していることから、これがパッチされた可能性が示唆されます。

## Raw backend response reading

Nginxの`proxy_pass`を使用すると、バックエンドによって作成されたエラーやHTTPヘッダーを傍受する可能性があります。これは、内部エラーメッセージやヘッダーを隠して、代わりにNginxによって処理されるようにする場合に非常に便利です。バックエンドがエラーページで応答すると、Nginxは自動的にカスタムエラーページを提供します。しかし、NginxがそれがHTTPレスポンスであると理解しない場合はどうでしょうか？

クライアントが無効なHTTPリクエストをNginxに送信すると、そのリクエストはそのままバックエンドに転送され、バックエンドはその生のコンテンツで応答します。その後、Nginxは無効なHTTPレスポンスを理解せず、単にクライアントに転送します。このようなuWSGIアプリケーションを想像してみてください：
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type',
'text/html'),('Secret-Header','secret-info')])
return [b"Secret info, should not be visible!"]
```
以下のNginxディレクティブを使用して：
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
```markdown
[proxy\_intercept\_errors](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_intercept\_errors) は、バックエンドが300以上のレスポンスステータスを持つ場合にカスタムレスポンスを提供します。上記のuWSGIアプリケーションでは、`500 Error` を送信し、Nginxによってインターセプトされます。

[proxy\_hide\_header](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_hide\_header) はその名の通りです。指定されたHTTPヘッダーをクライアントから隠します。

通常の `GET` リクエストを送信すると、Nginxは以下を返します：
```
```
HTTP/1.1 500 Internal Server Error
Server: nginx/1.10.3
Content-Type: text/html
Content-Length: 34
Connection: close
```
しかし、無効なHTTPリクエストを送信すると、例えば：
```
GET /? XTTP/1.1
Host: 127.0.0.1
Connection: close
```
以下の応答が得られます：
```
XTTP/1.1 500 Error
Content-Type: text/html
Secret-Header: secret-info

Secret info, should not be visible!
```
## merge\_slashesがoffに設定されている

デフォルトでは "on" に設定されている[merge\_slashes](http://nginx.org/en/docs/http/ngx\_http\_core\_module.html#merge\_slashes)ディレクティブは、2つ以上のスラッシュを1つに圧縮するメカニズムです。つまり、`///`は`/`になります。Nginxがリバースプロキシとして使用され、プロキシされているアプリケーションがローカルファイルインクルージョンに脆弱である場合、リクエストに余分なスラッシュを使用すると、それを悪用する余地が生じる可能性があります。これについては、[Danny RobinsonとRotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d)が詳しく説明しています。

33個のNginx設定ファイルで`merge_slashes`が“off”に設定されていることがわかりました。

## mapディレクティブにdefaultが指定されていない

**`map`が何らかの認証制御に使用される**場合の一般的なケースのようです。簡略化した例は以下のようになります：
```
http {
...
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
...
}
```

```
server {
...
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
...
}
```
[マニュアルによると](https://nginx.org/en/docs/http/ngx_http_map_module.html)：

> default value\
> ソース値が指定されたバリアントのいずれとも一致しない場合に設定される結果の値です。defaultが指定されていない場合、\
> 結果のデフォルト値は空の文字列になります。

`default` 値を忘れがちです。そのため、**悪意のある者はこの「認証コントロール」を簡単にバイパスできます**。`/map-poc` 内の**存在しないケースに単純にアクセスすることで**、例えば `https://targethost.com/map-poc/another-private-area` のように。

## DNS Spoofing Nginx

この投稿によると：[http://blog.zorinaq.com/nginx-resolver-vulns/](http://blog.zorinaq.com/nginx-resolver-vulns/) **DNSレコードをNginxにスプーフすることが可能かもしれません**。もし**Nginxが使用しているDNSサーバーを知っていて**（そして何らかの方法で通信を傍受できる場合、127.0.0.1を使用している場合は**無効です**)、**問い合わせているドメインがわかれば**。

Nginxは、次のようにDNSサーバーを指定して使用することができます：
```
resolver     8.8.8.8;
```
## `proxy_pass` と `internal` ディレクティブ

**`proxy_pass`** ディレクティブは、内部または外部の他のサーバーへのリクエストを**内部的にリダイレクトするために使用されます**。\
**`internal`** ディレクティブは、**ロケーションが内部からのみアクセス可能であることをNginxに明確にするために使用されます**。

これらのディレクティブの使用は脆弱性ではありませんが、**どのように設定されているかを確認する必要があります**。

## proxy\_set\_header Upgrade & Connection

nginxサーバーがUpgradeヘッダーとConnectionヘッダーを渡すように設定されている場合、保護された/内部のエンドポイントにアクセスするために[**h2c Smuggling攻撃**](../../pentesting-web/h2c-smuggling.md)が実行される可能性があります。

{% hint style="danger" %}
この脆弱性により、攻撃者はnginxによって内容がチェックされない`proxy_pass`エンドポイント（この場合は`http://backend:9999`）と**直接接続を確立することができます**。
{% endhint %}

[こちら](https://bishopfox.com/blog/h2c-smuggling-request)から`/flag`を盗むための脆弱な設定の例：
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
`proxy_pass`が特定の**パス**、例えば`http://backend:9999/socket.io`を指していたとしても、接続は`http://backend:9999`で確立されるため、その内部エンドポイント内の他のパスに**接触することができます。従って、proxy_passのURLにパスが指定されていても関係ありません。**
{% endhint %}

## 自分で試してみる

DetectifyはDockerを使用して、この記事で議論されているいくつかの誤った設定を持つ脆弱なNginxテストサーバーを自分で設定し、それらを自分で見つけるためのGitHubリポジトリを作成しました！

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## 静的解析ツール

### [GIXY](https://github.com/yandex/gixy)

GixyはNginx設定を分析するためのツールです。Gixyの主な目的は、セキュリティの誤設定を防ぎ、欠陥の検出を自動化することです。

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwnerは、一般的なNginxの誤設定と脆弱性を探すためのシンプルなツールです。

## 参考文献

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**脆弱性評価とペネトレーションテストのための即時利用可能なセットアップ**。どこからでも完全なペネトレーションテストを実行し、リコンからレポーティングまでの20以上のツールと機能を使用します。私たちはペネトレーターを置き換えるものではありません - 私たちは彼らにもっと深く掘り下げ、シェルをポップし、楽しむための時間を与えるためにカスタムツール、検出およびエクスプロイトモジュールを開発します。

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手してください。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションをチェックしてください。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローしてください。**
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>
