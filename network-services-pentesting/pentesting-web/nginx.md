# Nginx

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

**Sofort verf√ºgbare Einrichtung f√ºr Schwachstellenbewertung & Penetrationstests**. F√ºhren Sie einen vollst√§ndigen Pentest von √ºberall aus mit 20+ Tools & Funktionen durch, die von der Aufkl√§rung bis zum Bericht reichen. Wir ersetzen keine Pentester - wir entwickeln benutzerdefinierte Tools, Erkennungs- & Exploit-Module, um ihnen etwas Zeit zur√ºckzugeben, um tiefer zu graben, Shells zu √∂ffnen und Spa√ü zu haben.

{% embed url="https://pentest-tools.com/" %}

## Fehlender Root-Standort <a href="#missing-root-location" id="missing-root-location"></a>

## **Grundlagen der Konfiguration des Nginx-Root-Verzeichnisses**

Bei der Konfiguration des Nginx-Servers spielt die **root-Direktive** eine entscheidende Rolle, indem sie das Basisverzeichnis definiert, aus dem Dateien bereitgestellt werden. Betrachten Sie das folgende Beispiel:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In dieser Konfiguration wird `/etc/nginx` als Stammverzeichnis festgelegt. Dieses Setup erm√∂glicht den Zugriff auf Dateien innerhalb des angegebenen Stammverzeichnisses, wie z.B. `/hello.txt`. Es ist jedoch wichtig zu beachten, dass nur ein bestimmter Ort (`/hello.txt`) definiert ist. Es gibt keine Konfiguration f√ºr den Stammort (`location / {...}`). Dieses Weglassen bedeutet, dass die Stammrichtlinie global gilt und Anfragen an den Stamm-Pfad `/` erm√∂glicht, auf Dateien unter `/etc/nginx` zuzugreifen.

Aus dieser Konfiguration ergibt sich eine kritische Sicherheits√ºberlegung. Eine einfache `GET`-Anfrage, wie z.B. `GET /nginx.conf`, k√∂nnte sensible Informationen preisgeben, indem die Nginx-Konfigurationsdatei unter `/etc/nginx/nginx.conf` bereitgestellt wird. Das Festlegen des Stammverzeichnisses auf ein weniger sensibles Verzeichnis, wie z.B. `/etc`, k√∂nnte dieses Risiko mindern, k√∂nnte jedoch immer noch unbeabsichtigten Zugriff auf andere wichtige Dateien erm√∂glichen, einschlie√ülich anderer Konfigurationsdateien, Zugriffsprotokolle und sogar verschl√ºsselte Anmeldeinformationen, die f√ºr die HTTP-Basisauthentifizierung verwendet werden.

## Alias LFI Fehlkonfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In den Konfigurationsdateien von Nginx ist eine genaue Pr√ºfung der "location"-Direktiven erforderlich. Eine Sicherheitsl√ºcke namens Local File Inclusion (LFI) kann unbeabsichtigt durch eine Konfiguration eingef√ºhrt werden, die der folgenden √§hnelt:
```
location /imgs {
alias /path/images/;
}
```
Diese Konfiguration ist anf√§llig f√ºr LFI-Angriffe, da der Server Anfragen wie `/imgs../flag.txt` interpretiert, um auf Dateien au√üerhalb des beabsichtigten Verzeichnisses zuzugreifen, was effektiv zu `/path/images/../flag.txt` aufl√∂st. Diese Schwachstelle erm√∂glicht es Angreifern, Dateien aus dem Dateisystem des Servers abzurufen, auf die √ºber das Web nicht zugegriffen werden sollte.

Um diese Schwachstelle zu mildern, sollte die Konfiguration angepasst werden:
```
location /imgs/ {
alias /path/images/;
}
```
Weitere Informationen: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix-Tests:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Unsichere Pfadbeschr√§nkung <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

√úberpr√ºfen Sie die folgende Seite, um zu erfahren, wie Sie Direktiven wie umgehen k√∂nnen:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
## Unsicherer Variablengebrauch / HTTP-Anforderungsaufteilung <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

{% hint style="danger" %}
Verwundbare Variablen `$uri` und `$document_uri` und dies kann durch Ersetzen durch `$request_uri` behoben werden.

Ein Regex kann auch verwundbar sein wie:

`location ~ /docs/([^/])? { ‚Ä¶ $1 ‚Ä¶ }` - Verwundbar

`location ~ /docs/([^/\s])? { ‚Ä¶ $1 ‚Ä¶ }` - Nicht verwundbar (√úberpr√ºfung von Leerzeichen)

`location ~ /docs/(.*)? { ‚Ä¶ $1 ‚Ä¶ }`  - Nicht verwundbar
{% endhint %}

Eine Schwachstelle in der Nginx-Konfiguration wird am folgenden Beispiel demonstriert:
```
location / {
return 302 https://example.com$uri;
}
```
Die Zeichen \r (Wagenr√ºcklauf) und \n (Zeilenumbruch) bedeuten neue Zeichen in HTTP-Anfragen, und ihre URL-codierten Formen werden als `%0d%0a` dargestellt. Wenn Sie diese Zeichen in einer Anfrage (z. B. `http://localhost/%0d%0aDetectify:%20clrf`) an einen falsch konfigurierten Server einschlie√üen, f√ºhrt dies dazu, dass der Server einen neuen Header namens `Detectify` ausgibt. Dies geschieht, weil die $uri-Variable die URL-codierten Zeilenumbruchszeichen decodiert, was zu einem unerwarteten Header in der Antwort f√ºhrt:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Erfahren Sie mehr √ºber die Risiken von CRLF-Injektion und Response Splitting unter [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Diese Technik wird auch in diesem Vortrag [**erkl√§rt**](https://www.youtube.com/watch?v=gWQyWdZbdoY\&list=PL0xCSYnG\_iTtJe2V6PQqamBF73n7-f1Nr\&index=77) mit einigen anf√§lligen Beispielen und Erkennungsmechanismen. Zum Beispiel, um diese Fehlkonfiguration aus einer Blackbox-Perspektive zu erkennen, k√∂nnten Sie diese Anfragen verwenden:

- `https://example.com/%20X` - Jeder HTTP-Code
- `https://example.com/%20H` - 400 Bad Request

Wenn anf√§llig, wird das erste als "X" zur√ºckgegeben, da "X" eine beliebige HTTP-Methode ist, und das zweite wird einen Fehler zur√ºckgeben, da "H" keine g√ºltige Methode ist. Der Server erh√§lt also etwas wie: `GET / H HTTP/1.1` und dies wird den Fehler ausl√∂sen.

Weitere Beispiele zur Erkennung w√§ren:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Jeder HTTP-Code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Einige gefundene anf√§llige Konfigurationen, die in diesem Vortrag pr√§sentiert wurden, waren:

- Beachten Sie, wie **`$uri`** wie in der endg√ºltigen URL festgelegt ist.
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
* Beachten Sie erneut, wie **`$uri`** diesmal in der URL (diesmal innerhalb eines Parameters) enthalten ist
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
* Jetzt in AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Jede Variable

Es wurde festgestellt, dass **vom Benutzer bereitgestellte Daten** unter bestimmten Umst√§nden als **Nginx-Variable** behandelt werden k√∂nnten. Die Ursache dieses Verhaltens bleibt etwas r√§tselhaft, ist jedoch weder selten noch einfach zu √ºberpr√ºfen. Diese Anomalie wurde in einem Sicherheitsbericht auf HackerOne hervorgehoben, der [hier](https://hackerone.com/reports/370094) eingesehen werden kann. Eine weitere Untersuchung der Fehlermeldung f√ºhrte zur Identifizierung ihres Auftretens innerhalb des [SSI-Filtermoduls des Nginx-Codebasis](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx\_http\_ssi\_filter\_module.c#L365), wobei Server-seitige Includes (SSI) als Wurzelursache identifiziert wurden.

Um **diese Fehlkonfiguration zu erkennen**, kann der folgende Befehl ausgef√ºhrt werden, der das Setzen eines Referer-Headers zur √úberpr√ºfung des Variablendrucks beinhaltet:
```bash
$ curl -H ‚ÄòReferer: bar‚Äô http://localhost/foo$http_referer | grep ‚Äòfoobar‚Äô
```
Scans f√ºr diese Fehlkonfigurationen auf verschiedenen Systemen haben mehrere F√§lle aufgedeckt, in denen Nginx-Variablen von einem Benutzer ausgegeben werden k√∂nnten. Ein R√ºckgang der anf√§lligen F√§lle deutet jedoch darauf hin, dass Bem√ºhungen zur Behebung dieses Problems teilweise erfolgreich waren.

## Lesen der Rohantwort des Back-Ends

Nginx bietet eine Funktion √ºber `proxy_pass`, die es erm√∂glicht, Fehler und HTTP-Header, die vom Backend erzeugt werden, abzufangen, um interne Fehlermeldungen und Header zu verbergen. Dies wird erreicht, indem Nginx benutzerdefinierte Fehlerseiten als Antwort auf Backend-Fehler bereitstellt. Herausforderungen entstehen jedoch, wenn Nginx eine ung√ºltige HTTP-Anfrage erh√§lt. Eine solche Anfrage wird wie empfangen an das Backend weitergeleitet, und die Rohantwort des Backends wird dann direkt an den Client gesendet, ohne das Eingreifen von Nginx. 

Betrachten Sie ein Beispiel-Szenario mit einer uWSGI-Anwendung:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Um dies zu verwalten, werden spezifische Direktiven in der Nginx-Konfiguration verwendet:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
* [**proxy\_intercept\_errors**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_intercept\_errors): Diese Direktive erm√∂glicht es Nginx, eine benutzerdefinierte Antwort f√ºr Backend-Antworten mit einem Statuscode gr√∂√üer als 300 zu senden. Sie stellt sicher, dass f√ºr unsere Beispiel-uWSGI-Anwendung eine `500 Error`-Antwort von Nginx abgefangen und behandelt wird.
* [**proxy\_hide\_header**](http://nginx.org/en/docs/http/ngx\_http\_proxy\_module.html#proxy\_hide\_header): Wie der Name schon sagt, verbirgt diese Direktive bestimmte HTTP-Header vor dem Client, um die Privatsph√§re und Sicherheit zu erh√∂hen.

Wenn eine g√ºltige `GET`-Anfrage gestellt wird, verarbeitet Nginx sie normal und gibt eine Standardfehlerantwort zur√ºck, ohne geheime Header preiszugeben. Eine ung√ºltige HTTP-Anfrage umgeht jedoch diesen Mechanismus und f√ºhrt zur Offenlegung von Rohdaten-Backend-Antworten, einschlie√ülich geheimer Header und Fehlermeldungen.

## merge\_slashes auf off gesetzt

Standardm√§√üig ist die **`merge_slashes`-Direktive** von Nginx auf **`on`** gesetzt, was mehrere Schr√§gstriche in einer URL in einen einzelnen Schr√§gstrich komprimiert. Diese Funktion kann jedoch Sicherheitsl√ºcken in Anwendungen hinter Nginx verbergen, insbesondere solche, die anf√§llig f√ºr lokale Dateieinschluss (LFI)-Angriffe sind. Die Sicherheitsexperten **Danny Robinson und Rotem Bar** haben auf die potenziellen Risiken dieses Standardverhaltens hingewiesen, insbesondere wenn Nginx als Reverse-Proxy fungiert.

Um solche Risiken zu minimieren, wird empfohlen, die **`merge_slashes`-Direktive f√ºr anf√§llige Anwendungen auszuschalten**. Dadurch wird sichergestellt, dass Nginx Anfragen an die Anwendung weiterleitet, ohne die URL-Struktur zu √§ndern und somit keine zugrunde liegenden Sicherheitsprobleme zu maskieren.

F√ºr weitere Informationen siehe [Danny Robinson und Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Standardwert in Map-Direktive**

In der **Nginx-Konfiguration** spielt die `map`-Direktive oft eine Rolle bei der **Autorisierungssteuerung**. Ein h√§ufiger Fehler besteht darin, keinen **Standard**wert anzugeben, was zu unbefugtem Zugriff f√ºhren k√∂nnte. Zum Beispiel:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Ohne einen `default` kann ein **b√∂sartiger Benutzer** die Sicherheit umgehen, indem er auf eine **undefinierte URI** innerhalb von `/map-poc` zugreift. [Das Nginx-Handbuch](https://nginx.org/en/docs/http/ngx\_http\_map\_module.html) empfiehlt, einen **Standardwert** festzulegen, um solche Probleme zu vermeiden.

### **DNS-Spoofing-Schwachstelle**

DNS-Spoofing gegen Nginx ist unter bestimmten Bedingungen m√∂glich. Wenn ein Angreifer den **DNS-Server** kennt, der von Nginx verwendet wird, und seine DNS-Anfragen abfangen kann, kann er DNS-Eintr√§ge f√§lschen. Diese Methode ist jedoch unwirksam, wenn Nginx so konfiguriert ist, dass es **localhost (127.0.0.1)** f√ºr die DNS-Aufl√∂sung verwendet. Nginx erm√∂glicht die Angabe eines DNS-Servers wie folgt:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` und `internal` Direktiven**

Die **`proxy_pass`** Direktive wird verwendet, um Anfragen an andere Server umzuleiten, entweder intern oder extern. Die **`internal`** Direktive stellt sicher, dass bestimmte Standorte nur innerhalb von Nginx erreichbar sind. Obwohl diese Direktiven an sich keine Sicherheitsl√ºcken darstellen, erfordert ihre Konfiguration eine sorgf√§ltige Pr√ºfung, um Sicherheitsl√ºcken zu vermeiden.

## proxy\_set\_header Upgrade & Connection

Wenn der Nginx-Server so konfiguriert ist, dass die Upgrade- und Connection-Header weitergeleitet werden, k√∂nnte ein [**h2c Smuggling-Angriff**](../../pentesting-web/h2c-smuggling.md) durchgef√ºhrt werden, um auf gesch√ºtzte/interne Endpunkte zuzugreifen.

{% hint style="danger" %}
Diese Sicherheitsl√ºcke w√ºrde einem Angreifer erm√∂glichen, **eine direkte Verbindung mit dem `proxy_pass`-Endpunkt** (`http://backend:9999` in diesem Fall) herzustellen, dessen Inhalt nicht von nginx √ºberpr√ºft wird.
{% endhint %}

Beispiel einer anf√§lligen Konfiguration zum Stehlen von `/flag` von [hier](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
{% hint style="warning" %}
Beachten Sie, dass selbst wenn `proxy_pass` auf einen bestimmten **Pfad** wie `http://backend:9999/socket.io` zeigt, die Verbindung mit `http://backend:9999` hergestellt wird, sodass Sie **jeden anderen Pfad innerhalb dieses internen Endpunkts kontaktieren k√∂nnen. Es spielt also keine Rolle, ob ein Pfad in der URL von proxy\_pass angegeben ist.**
{% endhint %}

## Probieren Sie es selbst aus

Detectify hat ein GitHub-Repository erstellt, in dem Sie Docker verwenden k√∂nnen, um Ihren eigenen anf√§lligen Nginx-Testserver mit einigen der in diesem Artikel diskutierten Fehlkonfigurationen einzurichten und selbst nach ihnen zu suchen!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Tools f√ºr statische Analyse

### [GIXY](https://github.com/yandex/gixy)

Gixy ist ein Tool zur Analyse der Nginx-Konfiguration. Das Hauptziel von Gixy ist es, Sicherheitsfehler zu verhindern und die Fehlererkennung zu automatisieren.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ist ein einfaches Tool, um nach g√§ngigen Nginx-Fehlkonfigurationen und -Schwachstellen zu suchen.

## Referenzen

* [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
* [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
* [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

**Sofort verf√ºgbare Einrichtung f√ºr Schwachstellenbewertung & Penetrationstests**. F√ºhren Sie einen vollst√§ndigen Pentest von √ºberall aus mit 20+ Tools & Funktionen durch, die von der Aufkl√§rung bis zum Bericht reichen. Wir ersetzen keine Pentester - wir entwickeln benutzerdefinierte Tools, Erkennungs- & Exploit-Module, um ihnen Zeit zu geben, tiefer zu graben, Shells zu √∂ffnen und Spa√ü zu haben.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
