# Objection教程

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

<img src="../../../.gitbook/assets/i3.png" alt="" data-size="original">

**赏金猎人提示**：**注册**Intigriti，一个由黑客创建的高级**赏金猎人平台**！立即加入我们的[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达**$100,000**的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

## **介绍**

[![objection](https://github.com/sensepost/objection/raw/master/images/objection.png)](https://github.com/sensepost/objection)

**objection - 运行时移动应用探索**

`objection`是一个运行时移动应用探索工具包，由[Frida](https://www.frida.re)提供支持。它的目标是帮助评估移动应用及其安全状况，而无需越狱或获取root权限的移动设备。

**注意：**这不是某种越狱/获取root权限的绕过方式。使用`objection`时，您仍然受到所面临的适用沙箱所施加的所有限制。

### 简介

**objection**的目标是让用户调用**Frida提供的主要操作**。否则，用户将需要为每个要测试的应用程序创建一个**单独的脚本**。

## 教程

在本教程中，我将使用可以在此处下载的APK：

{% file src="../../../.gitbook/assets/app-release.zip" %}

或从其[原始存储库](https://github.com/asvid/FridaApp)下载app-release.apk

### 安装
```bash
pip3 install objection
```
### 连接

建立一个**常规的ADB连接**并在设备上**启动**frida服务器（并检查frida在客户端和服务器上是否正常工作）。

如果您使用的是**已root的设备**，则需要在_**--gadget**_选项中选择要测试的应用程序。在这种情况下：
```bash
frida-ps -Uai
objection --gadget asvid.github.io.fridaapp explore
```
### 基本操作

本教程不会列出所有可能的objection命令，只会列出我发现最有用的命令。

#### 环境

一些有趣的信息（如密码或路径）可能会在环境中找到。
```bash
env
```
![](<../../../.gitbook/assets/image (64).png>)

#### Frida 信息

Frida is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers. It allows you to inject JavaScript code into native apps on Windows, macOS, Linux, iOS, and Android. With Frida, you can dynamically modify the behavior of an app, intercept function calls, manipulate data, and much more.

Frida provides a high-level API that simplifies the process of injecting code into apps. It also comes with a command-line tool called `frida-cli` that allows you to interact with Frida from the terminal.

Frida can be used for various purposes, including:

- Dynamic analysis: Frida allows you to inspect and modify the runtime behavior of an app, making it useful for analyzing and understanding how an app works.
- Reverse engineering: Frida can be used to reverse engineer apps by hooking into their functions and inspecting their behavior at runtime.
- Exploit development: Frida can be used to aid in the development of exploits by providing a way to inject code into vulnerable apps and manipulate their behavior.
- Security testing: Frida can be used for security testing, including vulnerability assessment and penetration testing of mobile apps.

Frida supports both iOS and Android platforms. In this tutorial, we will focus on using Frida for Android app pentesting.
```bash
frida
```
![](<../../../.gitbook/assets/image (65).png>)

#### 上传/下载
```bash
file download <remote path> [<local path>]
file upload <local path> [<remote path>]
```
#### 导入 Frida 脚本

```javascript
const { spawn } = require('child_process');
const frida = require('frida');

async function runFridaScript() {
  try {
    // Attach to the target process
    const session = await frida.attach('com.example.app');

    // Load the script
    const script = await session.createScript(`
      // Your Frida script code here
    `);

    // Load the script into the target process
    await script.load();

    // Resume the target process
    await session.resume();

    console.log('Frida script loaded successfully');
  } catch (error) {
    console.error('Failed to load Frida script:', error);
  }
}

runFridaScript();
```

#### 导入 Frida 脚本

```javascript
const { spawn } = require('child_process');
const frida = require('frida');

async function runFridaScript() {
  try {
    // 附加到目标进程
    const session = await frida.attach('com.example.app');

    // 加载脚本
    const script = await session.createScript(`
      // 在这里编写你的 Frida 脚本代码
    `);

    // 将脚本加载到目标进程中
    await script.load();

    // 恢复目标进程
    await session.resume();

    console.log('Frida 脚本加载成功');
  } catch (error) {
    console.error('加载 Frida 脚本失败：', error);
  }
}

runFridaScript();
```
```bash
import <local path frida-script>
```
#### SSLPinning

SSLPinning是一种用于保护移动应用程序通信安全的技术。它通过验证服务器的SSL证书，防止中间人攻击和窃听。在移动应用程序中，SSL证书通常用于建立与服务器之间的安全连接。然而，攻击者可以通过劫持应用程序的网络流量并替换证书来进行攻击。

SSLPinning的原理是在移动应用程序中固定（或绑定）服务器的SSL证书。这意味着应用程序将只信任特定的证书，而不是系统默认的证书颁发机构（CA）。这样，即使攻击者替换了证书，应用程序也会发现并拒绝连接。

在移动应用程序渗透测试中，我们可以使用Frida和Objection来绕过SSLPinning。Objection是一个基于Frida的工具，用于动态分析和修改移动应用程序。通过使用Objection，我们可以绕过SSL证书验证，从而劫持和修改应用程序的网络流量。

要绕过SSLPinning，我们可以使用Objection的`sslpinning disable`命令。这将禁用应用程序中的SSLPinning机制，使我们能够查看和修改网络流量。但是，请注意，绕过SSLPinning可能会导致应用程序的安全性降低，因此在进行渗透测试时应谨慎使用。

以下是使用Objection绕过SSLPinning的示例命令：

```plaintext
$ objection -g com.example.app explore
[tab]$ sslpinning disable
```

通过执行上述命令，我们可以成功绕过应用程序中的SSLPinning，并对网络流量进行分析和修改。
```bash
android sslpinning disable #Attempts to disable SSL Pinning on Android devices.
```
#### Root检测

Root检测是一种用于检测Android设备是否已经获取了root权限的技术。在移动应用程序渗透测试中，了解应用程序是否能够检测到设备是否已经被root是非常重要的。如果应用程序能够检测到设备已经被root，可能会采取一些安全措施，例如禁止访问某些功能或限制应用程序的使用。

在进行Root检测时，我们可以使用Frida和Objection工具来绕过应用程序的检测机制。Frida是一款功能强大的动态插桩工具，可以用于修改应用程序的行为。Objection是基于Frida的一个插件，专门用于移动应用程序渗透测试。

以下是使用Objection绕过Root检测的步骤：

1. 首先，我们需要安装Frida和Objection工具。可以通过以下命令来安装：

   ```
   pip install objection
   ```

2. 安装完成后，我们可以使用以下命令来启动Objection：

   ```
   objection
   ```

3. 连接到目标设备。可以使用以下命令来连接到设备：

   ```
   device connect
   ```

4. 在连接到设备后，我们可以使用以下命令来绕过Root检测：

   ```
   android root disable
   ```

   这将禁用应用程序中的Root检测机制，使其无法检测到设备是否已经被root。

通过使用Objection工具，我们可以轻松地绕过应用程序中的Root检测机制，从而获得更多的权限和功能。这对于移动应用程序渗透测试非常有用，因为它允许我们模拟已经获取了root权限的设备，以便测试应用程序的安全性。
```bash
android root disable  #Attempts to disable root detection on Android devices.
android root simulate #Attempts to simulate a rooted Android environment.
```
#### 执行命令

The `exec` command in objection allows you to execute shell commands on the target Android device. This can be useful for various purposes, such as exploring the device's file system, running scripts, or interacting with other installed applications.

To use the `exec` command, you need to specify the command you want to execute as an argument. For example, to list the files in the current directory, you can use the following command:

```
objection> exec ls
```

The output of the command will be displayed in the console. You can also capture the output and save it to a file by using the `-o` or `--output` option followed by the file path. For example:

```
objection> exec ls -o /sdcard/files.txt
```

This will save the output of the `ls` command to a file named `files.txt` in the `/sdcard` directory of the target device.

Keep in mind that the `exec` command runs the specified command as the user running the target application. Therefore, the available commands and their outputs may vary depending on the permissions and privileges of the application.

It's important to use the `exec` command responsibly and avoid executing malicious or harmful commands on the target device. Always ensure that you have proper authorization and legal permission before performing any actions that may impact the security or privacy of the device or its users.
```bash
android shell_exec whoami
```
#### 截图

```html
<img src="screenshots/objection-tutorial-01.png" alt="Screenshot 1" width="400"/>
<img src="screenshots/objection-tutorial-02.png" alt="Screenshot 2" width="400"/>
<img src="screenshots/objection-tutorial-03.png" alt="Screenshot 3" width="400"/>
<img src="screenshots/objection-tutorial-04.png" alt="Screenshot 4" width="400"/>
```

#### 截图

```html
<img src="screenshots/objection-tutorial-01.png" alt="截图 1" width="400"/>
<img src="screenshots/objection-tutorial-02.png" alt="截图 2" width="400"/>
<img src="screenshots/objection-tutorial-03.png" alt="截图 3" width="400"/>
<img src="screenshots/objection-tutorial-04.png" alt="截图 4" width="400"/>
```
```bash
android ui screenshot /tmp/screenshot
android ui FLAG_SECURE false  #This may enable you to take screenshots using the hardware keys
```
### 静态分析变为动态分析

在使用objection之前，我们应该通过**静态分析**了解本部分发现的所有信息。无论如何，通过这种方式，您可能会发现**一些新的东西**，因为您将获得一个完整的类、方法和导出对象列表。

如果您无法获取应用程序的可读源代码，这也是有用的。

#### 列出活动、接收器和服务
```
android hooking list activities
```
![](<../../../.gitbook/assets/image (78).png>)
```
android hooking list services
android hooking list receivers
```
如果找不到Frida，它将会报错

#### 获取当前活动
```
android hooking get current_activity
```
#### 搜索类

让我们开始在我们的应用程序中查找类
```
android hooking search classes asvid.github.io.fridaapp
```
![](<../../../.gitbook/assets/image (69).png>)

#### 搜索类的方法

现在让我们提取_MainActivity_类中的方法：
```
android hooking search methods asvid.github.io.fridaapp MainActivity
```
![](<../../../.gitbook/assets/image (70) (1).png>)

#### 列出类的声明方法及其参数

让我们找出类的方法需要哪些参数：
```
android hooking list class_methods asvid.github.io.fridaapp.MainActivity
```
![](<../../../.gitbook/assets/image (79).png>)

#### 列出类

您还可以列出当前应用程序中加载的所有类：
```
android hooking list classes #List all loaded classes, As the target application gets usedmore, this command will return more classes.
```
这对于想要**钩取一个类的方法，但只知道类名**的情况非常有用。您可以使用此函数来**搜索拥有该类的模块**，然后钩取其方法。

### 钩取非常简单

#### 钩取（监视）一个方法

从应用程序的[源代码](https://github.com/asvid/FridaApp/blob/master/app/src/main/java/asvid/github/io/fridaapp/MainActivity.kt)中，我们知道**MainActivity**中的**函数**_**sum()**_**每秒都在运行**。让我们尝试在每次调用该函数时**转储所有可能的信息**（参数、返回值和回溯）：
```
android hooking watch class_method asvid.github.io.fridaapp.MainActivity.sum --dump-args --dump-backtrace --dump-return
```
![](<../../../.gitbook/assets/image (71).png>)

#### 钩住（监视）整个类

实际上，我发现MainActivity类的所有方法都非常有趣，让我们**钩住它们**。请注意，这可能会导致应用程序**崩溃**。
```
android hooking watch class asvid.github.io.fridaapp.MainActivity --dump-args --dump-return
```
如果您在类被挂钩的情况下操作应用程序，您将会看到每个函数被调用时的参数和返回值。

![](<../../../.gitbook/assets/image (72).png>)

#### 更改函数的布尔返回值

从源代码中可以看到，函数_checkPin_接收一个_String_作为参数，并返回一个_boolean_。让我们让这个函数**始终返回true**：

![](<../../../.gitbook/assets/image (74).png>)

现在，如果您在PIN码的文本框中输入任何内容，您将看到任何内容都是有效的：

![](<../../../.gitbook/assets/image (77).png>)

### 类实例

搜索并打印指定的Java类的**活动实例**，由完全限定的类名指定。输出是尝试获取发现的反对意见的字符串值的结果，该字符串值通常**包含对象的属性值**。
```
android heap print_instances <class>
```
![](<../../../.gitbook/assets/image (80).png>)

### Keystore/Intents

您可以使用以下方法来操作密钥库和意图：
```
android keystore list
android intents launch_activity
android intent launch_service
```
#### 内存

##### 转储

在移动应用程序渗透测试中，我们经常需要获取应用程序的内存转储。内存转储是应用程序在运行时的快照，其中包含了应用程序的代码、数据和状态信息。通过分析内存转储，我们可以发现应用程序中的漏洞、敏感数据以及其他有价值的信息。

Frida 是一个功能强大的工具，可以帮助我们获取应用程序的内存转储。Objection 是 Frida 的一个插件，它提供了一些方便的命令和功能，用于在移动应用程序渗透测试中进行内存转储。

要使用 Objection 进行内存转储，我们需要先连接到目标设备上的应用程序。可以使用以下命令连接到设备上的应用程序：

```
objection -N -g com.example.app explore
```

这将启动 Objection 并连接到指定的应用程序。一旦连接成功，我们可以使用以下命令来获取内存转储：

```
memory dump
```

这将在当前工作目录中创建一个名为 `memory_dump.bin` 的文件，其中包含了应用程序的内存转储。

获取内存转储后，我们可以使用其他工具来分析和提取其中的信息。例如，我们可以使用 `volatility` 工具来分析内存转储中的进程、线程、文件句柄等信息。

通过获取应用程序的内存转储，我们可以深入了解应用程序的内部运行机制，并发现潜在的漏洞和敏感数据。这对于移动应用程序渗透测试非常重要，因为它可以帮助我们更好地理解和评估目标应用程序的安全性。
```bash
memory dump all <local destination> #Dump all memory
memory dump from_base <base_address> <size_to_dump> <local_destination> #Dump a part
```
#### 列表

---

#### Introduction

#### 介绍

In this tutorial, we will learn how to use Objection, a runtime mobile exploration toolkit, to perform various tasks during Android application penetration testing.

在本教程中，我们将学习如何使用 Objection，一个运行时移动探索工具包，在 Android 应用程序渗透测试期间执行各种任务。

---

#### Prerequisites

#### 先决条件

Before we begin, make sure you have the following:

在开始之前，请确保您具备以下条件：

- A rooted Android device or an emulator with Frida Server installed.

- 安装了 Frida Server 的已 root 的 Android 设备或模拟器。

- Frida CLI installed on your machine.

- 在您的计算机上安装了 Frida CLI。

- Basic knowledge of Android application security and penetration testing.

- 对 Android 应用程序安全和渗透测试有基本的了解。

---

#### Setting Up the Environment

#### 设置环境

1. Install Frida Server on your rooted Android device or emulator.

1. 在已 root 的 Android 设备或模拟器上安装 Frida Server。

2. Connect your device or emulator to your machine using USB.

2. 使用 USB 将您的设备或模拟器连接到计算机。

3. Open a terminal and run the following command to check if your device is connected:

3. 打开终端并运行以下命令以检查设备是否已连接：

   ```bash
   adb devices
   ```

   You should see your device listed.

   您应该看到您的设备已列出。

4. Install Frida CLI by running the following command:

4. 运行以下命令安装 Frida CLI：

   ```bash
   pip install frida-tools
   ```

---

#### Starting Objection

#### 启动 Objection

1. Open a terminal and run the following command to start Objection:

1. 打开终端并运行以下命令以启动 Objection：

   ```bash
   objection
   ```

2. Objection will start and display the prompt `objection>`. You are now ready to use Objection commands.

2. Objection 将启动并显示提示符 `objection>`。现在您可以使用 Objection 命令了。

---

#### Conclusion

#### 结论

In this tutorial, we learned how to set up the environment for using Objection and how to start Objection. In the next tutorials, we will explore various Objection commands and techniques for Android application penetration testing.

在本教程中，我们学习了如何设置使用 Objection 的环境以及如何启动 Objection。在接下来的教程中，我们将探索各种 Objection 命令和技术，用于 Android 应用程序渗透测试。
```
memory list modules
```
![](<../../../.gitbook/assets/image (66).png>)

在列表底部，你可以看到Frida：

![](<../../../.gitbook/assets/image (67).png>)

让我们来看看Frida导出了什么：

![](<../../../.gitbook/assets/image (68).png>)

#### 搜索/写入

你也可以使用Objection在内存中进行搜索和写入操作：
```
memory search "<pattern eg: 41 41 41 ?? 41>" (--string) (--offsets-only)
memory write "<address>" "<pattern eg: 41 41 41 41>" (--string)
```
### SQLite

您可以使用命令`sqlite`与SQLite数据库进行交互。

### 退出
```
exit
```
## 我在Objection中所缺少的功能

* 钩子方法有时会导致应用程序崩溃（这也是由于Frida）。
* 无法使用类的实例来调用实例的函数。也无法创建新的类实例并使用它们来调用函数。
* 没有快捷方式（类似于sslpinning）来钩住应用程序使用的所有常见加密方法，以查看加密文本、明文、密钥、IV和算法。

<img src="../../../.gitbook/assets/i3.png" alt="" data-size="original">

**Bug赏金提示**：**注册**Intigriti，一个由黑客创建的高级**Bug赏金平台**！立即加入我们的[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达**$100,000**的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取最新版本的PEASS或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[NFT收藏品](https://opensea.io/collection/the-peass-family)——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
