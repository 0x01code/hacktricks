# Objection 튜토리얼

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

<img src="../../../.gitbook/assets/i3.png" alt="" data-size="original">

**버그 바운티 팁**: **해커들이 만든 프리미엄 버그 바운티 플랫폼인 Intigriti에 가입**하세요! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 가입하고 최대 **$100,000**의 바운티를 받으세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

## **소개**

**objection - 런타임 모바일 탐색**

**[Objection](https://github.com/sensepost/objection)**은 [Frida](https://www.frida.re)를 기반으로 한 런타임 모바일 탐색 도구입니다. 이 도구는 탈옥 또는 루팅된 모바일 장치가 필요하지 않고 모바일 애플리케이션과 그 보안 상태를 평가하는 데 도움을 주기 위해 만들어졌습니다.

**참고:** 이것은 일종의 탈옥/루팅 우회가 아닙니다. `objection`을 사용하면 여전히 해당하는 샌드박스가 적용한 모든 제한 사항에 제한됩니다.

### 요약

**objection**의 **목표**는 사용자가 **Frida가 제공하는 주요 작업을 호출**할 수 있도록 하는 것입니다. 그렇지 않으면 사용자는 테스트하려는 각 애플리케이션마다 **단일 스크립트를 작성**해야 합니다.

## 튜토리얼

이 튜토리얼에서는 다음에서 다운로드할 수 있는 APK를 사용합니다:

{% file src="../../../.gitbook/assets/app-release.zip" %}

또는 [원본 저장소](https://github.com/asvid/FridaApp)에서 다운로드하세요 (app-release.apk 다운로드)

### 설치
```bash
pip3 install objection
```
### 연결

일반적인 ADB 연결을 만들고 기기에서 frida 서버를 시작하십시오 (클라이언트와 서버 모두에서 frida가 작동하는지 확인하십시오).

루팅된 기기를 사용하는 경우 _**--gadget**_ 옵션 내에서 테스트하려는 애플리케이션을 선택해야 합니다. 이 경우:
```bash
frida-ps -Uai
objection --gadget asvid.github.io.fridaapp explore
```
### 기본 동작

이 튜토리얼에서는 objection의 모든 가능한 명령을 나열하지 않습니다. 대신, 가장 유용한 명령만을 소개합니다.

#### 환경

환경 내에는 비밀번호나 경로와 같은 흥미로운 정보가 포함될 수 있습니다.
```bash
env
```
![](<../../../.gitbook/assets/image (64).png>)

#### Frida 정보
```bash
frida
```
![](<../../../.gitbook/assets/image (65).png>)

#### 업로드/다운로드
```bash
file download <remote path> [<local path>]
file upload <local path> [<remote path>]
```
#### frida 스크립트 가져오기

```javascript
const script = await Session.createScript(`
// Your frida script code here
`);
await script.load();
```

#### frida 스크립트를 가져오기 위해 다음 코드를 사용합니다.

```javascript
const script = await Session.createScript(`
// 여기에 frida 스크립트 코드를 작성하세요
`);
await script.load();
```
```bash
import <local path frida-script>
```
#### SSL 핀닝

SSLPinning은 안드로이드 앱에서 사용되는 보안 기술 중 하나입니다. SSL 핀닝은 앱이 서버와의 통신 중에 SSL 인증서의 유효성을 검증하는 과정을 강화합니다. 이를 통해 중간자 공격과 같은 보안 위협으로부터 앱을 보호할 수 있습니다.

SSLPinning은 앱이 서버로부터 받은 SSL 인증서의 공개 키를 하드코딩하여 저장하는 방식으로 구현됩니다. 이렇게 하면 앱이 항상 동일한 공개 키를 사용하여 서버의 신원을 확인할 수 있습니다. 따라서 악의적인 공격자가 중간자 공격을 시도하더라도 앱은 유효한 SSL 인증서를 갖지 않은 서버와의 통신을 거부할 수 있습니다.

SSLPinning은 앱의 보안을 강화하는 데 중요한 역할을 합니다. 그러나 해킹자로서는 SSL 핀닝을 우회하여 앱의 통신을 감시하고 조작하는 것이 필요할 수 있습니다. 이를 위해 프레임워크인 Frida와 Objection을 사용하여 SSL 핀닝을 우회하는 기법을 사용할 수 있습니다. 이러한 기법은 앱의 취약점을 식별하고 보안 강화를 위한 조치를 취하는 데 도움이 됩니다.
```bash
android sslpinning disable #Attempts to disable SSL Pinning on Android devices.
```
#### 루트 감지

Rooting은 Android 기기에서 시스템 레벨의 권한을 얻는 것을 의미합니다. 앱이 루트된 기기에서 실행되는 것을 방지하기 위해 앱은 종종 루트 감지 메커니즘을 구현합니다. 이러한 메커니즘은 앱이 루트된 기기에서 실행되는 것을 탐지하고 이에 대한 조치를 취할 수 있도록 도와줍니다.

루트 감지는 다양한 방법으로 수행될 수 있습니다. 일반적인 방법 중 하나는 시스템 파일 또는 디렉토리의 존재를 확인하는 것입니다. 예를 들어, 루트된 기기에서는 일반적으로 `/system/bin/su` 또는 `/system/xbin/su`와 같은 su 바이너리 파일이 존재합니다. 앱은 이러한 파일의 존재 여부를 확인하여 루트된 기기에서 실행되는지 여부를 판단할 수 있습니다.

또 다른 방법은 루트된 기기에서 실행되는 앱이 특정 시스템 속성을 사용하는 것을 감지하는 것입니다. 예를 들어, `Build.TAGS` 속성은 루트된 기기에서는 "test-keys"로 설정되어 있을 수 있습니다. 앱은 이 속성을 확인하여 루트된 기기에서 실행되는지 여부를 판단할 수 있습니다.

루트 감지를 우회하기 위해 다양한 기술이 사용될 수 있습니다. 예를 들어, 앱은 루트 감지를 우회하기 위해 다른 파일 이름을 사용하거나, 시스템 속성을 조작하여 루트 감지를 회피할 수 있습니다. 또한, 프레임워크 또는 라이브러리를 사용하여 루트 감지를 우회할 수도 있습니다.

루트 감지는 앱의 보안을 강화하기 위해 중요한 요소입니다. 그러나 루트 감지 메커니즘은 완벽하지 않을 수 있으며, 루트 감지 우회 기술이 발전함에 따라 새로운 우회 기법이 등장할 수 있습니다. 따라서 앱 개발자는 루트 감지를 우회하는 기술에 대해 항상 최신 정보를 유지하고, 추가적인 보안 메커니즘을 구현하여 앱의 보안을 강화해야 합니다.
```bash
android root disable  #Attempts to disable root detection on Android devices.
android root simulate #Attempts to simulate a rooted Android environment.
```
#### Exec 명령어

The `exec` command in Objection allows you to execute arbitrary commands on the target Android device. This can be useful for performing various actions during a penetration test.

To use the `exec` command, you need to have a Frida session established with the target application. Once you have a session, you can run the `exec` command followed by the command you want to execute.

Here is the syntax for the `exec` command:

```
objection> exec <command>
```

For example, if you want to execute the `ls` command to list the files in the current directory, you can use the following command:

```
objection> exec ls
```

The output of the command will be displayed in the Objection console.

It's important to note that the `exec` command runs the command on the target device, not on your local machine. This means that you can execute commands that are available on the target device, but not necessarily on your local machine.

Be cautious when using the `exec` command, as executing arbitrary commands on the target device can have unintended consequences. Always ensure that you have the necessary permissions and understand the potential impact of the command you are executing.
```bash
android shell_exec whoami
```
#### 스크린샷

```html
<img src="https://example.com/screenshot1.png" alt="Screenshot 1">
<img src="https://example.com/screenshot2.png" alt="Screenshot 2">
```

#### 스크린샷

```html
<img src="https://example.com/screenshot1.png" alt="스크린샷 1">
<img src="https://example.com/screenshot2.png" alt="스크린샷 2">
```
```bash
android ui screenshot /tmp/screenshot
android ui FLAG_SECURE false  #This may enable you to take screenshots using the hardware keys
```
### 정적 분석을 동적으로 수행하기

실제 애플리케이션에서는 objection을 사용하기 전에 이 부분에서 발견된 모든 정보를 알아야 합니다. 그래도 여기에서는 클래스, 메서드 및 내보낸 객체의 완전한 목록만 제공되므로 **새로운 것을 볼 수도 있습니다**.

또한, 앱의 가독성 있는 소스 코드를 어떤 이유로든 **얻을 수 없는 경우에도 유용합니다**.

#### 활동, 리시버 및 서비스 목록 나열
```bash
android hooking list activities
```
![](<../../../.gitbook/assets/image (78).png>)
```bash
android hooking list services
android hooking list receivers
```
만약 Frida가 찾지 못하면 오류가 발생합니다.

#### 현재 활동 가져오기
```bash
android hooking get current_activity
```
#### 클래스 검색

우리 애플리케이션 내에서 클래스를 찾아봅시다.
```bash
android hooking search classes asvid.github.io.fridaapp
```
![](<../../../.gitbook/assets/image (69).png>)

#### 클래스의 검색 방법

이제 _MainActivity_ 클래스 내부의 메소드를 추출해 봅시다.
```bash
android hooking search methods asvid.github.io.fridaapp MainActivity
```
![](<../../../.gitbook/assets/image (70) (1).png>)

#### 클래스의 선언된 메소드와 해당 메소드의 매개변수 목록

클래스의 메소드가 어떤 매개변수를 필요로 하는지 알아보겠습니다:
```bash
android hooking list class_methods asvid.github.io.fridaapp.MainActivity
```
![](<../../../.gitbook/assets/image (79).png>)

#### 클래스 목록

현재 애플리케이션에 로드된 모든 클래스를 나열할 수도 있습니다:
```bash
android hooking list classes #List all loaded classes, As the target application gets usedmore, this command will return more classes.
```
이것은 클래스의 메소드를 후킹하고 클래스의 이름만 알고 있는 경우에 매우 유용합니다. 이 함수를 사용하여 클래스를 소유하는 모듈을 찾고 그 메소드를 후킹할 수 있습니다.

### 후킹은 쉽습니다

#### 메소드 후킹 (감시)

애플리케이션의 [소스 코드](https://github.com/asvid/FridaApp/blob/master/app/src/main/java/asvid/github/io/fridaapp/MainActivity.kt)에서 우리는 _MainActivity_의 **함수** _**sum()**_이 **매 초마다** 실행되고 있음을 알고 있습니다. 함수가 호출될 때마다 (인수, 반환 값 및 백트레이스) 모든 가능한 정보를 덤프해 보겠습니다.
```bash
android hooking watch class_method asvid.github.io.fridaapp.MainActivity.sum --dump-args --dump-backtrace --dump-return
```
![](<../../../.gitbook/assets/image (71).png>)

#### 클래스 훅 (감시)

실제로 MainActivity 클래스의 모든 메서드를 훅하는 것이 흥미로워 보입니다. 모두 훅하려고 합니다. 주의하세요, 이는 애플리케이션을 충돌시킬 수 있습니다.
```bash
android hooking watch class asvid.github.io.fridaapp.MainActivity --dump-args --dump-return
```
만약 클래스가 후킹된 상태에서 애플리케이션을 실행하면 각 함수가 호출될 때마다 그 함수의 인자와 반환값을 볼 수 있습니다.

![](<../../../.gitbook/assets/image (72).png>)

#### 함수의 boolean 반환값 변경하기

소스 코드에서 함수 _checkPin_은 _String_을 인자로 받고 _boolean_을 반환합니다. 이제 함수가 항상 true를 반환하도록 만들어 보겠습니다:

![](<../../../.gitbook/assets/image (74).png>)

이제 PIN 코드 텍스트 상자에 아무 문자나 입력하면 어떤 값이든 유효하다는 것을 볼 수 있습니다:

![](<../../../.gitbook/assets/image (77).png>)

### 클래스 인스턴스

특정 Java 클래스의 **실시간 인스턴스**를 검색하고 출력합니다. 이는 일반적으로 객체의 속성 값을 포함하는 발견된 이의 문자열 값을 가져오려는 시도의 결과입니다.
```
android heap print_instances <class>
```
![](<../../../.gitbook/assets/image (80).png>)

### Keystore/Intents

키스토어와 인텐트를 사용하여 다음과 같이 작업할 수 있습니다:
```bash
android keystore list
android intents launch_activity
android intent launch_service
```
#### 덤프

메모리 덤프는 앱의 메모리 상태를 스냅샷으로 캡처하는 기능입니다. 이를 통해 앱의 실행 중인 코드, 변수, 객체 등을 분석할 수 있습니다. objection은 메모리 덤프를 생성하고 분석하는 데 사용할 수 있는 다양한 명령을 제공합니다.

##### 명령어

- `memory dump classes`: 앱의 클래스 정보를 덤프합니다.
- `memory dump classes <class_name>`: 특정 클래스의 정보를 덤프합니다.
- `memory dump instances <class_name>`: 특정 클래스의 인스턴스 정보를 덤프합니다.
- `memory dump heap`: 힙 메모리의 정보를 덤프합니다.
- `memory dump heap <address>`: 특정 주소의 힙 메모리 정보를 덤프합니다.

덤프된 메모리는 파일로 저장되며, 분석을 위해 다른 도구에서 사용할 수 있습니다.
```bash
memory dump all <local destination> #Dump all memory
memory dump from_base <base_address> <size_to_dump> <local_destination> #Dump a part
```
#### 목록
```bash
memory list modules
```
![](<../../../.gitbook/assets/image (66).png>)

리스트의 맨 아래에는 frida가 있습니다:

![](<../../../.gitbook/assets/image (67).png>)

frida가 무엇을 내보내는지 확인해 봅시다:

![](<../../../.gitbook/assets/image (68).png>)

#### 검색/쓰기

objection을 사용하여 메모리 내에서 검색하고 쓸 수도 있습니다:
```bash
memory search "<pattern eg: 41 41 41 ?? 41>" (--string) (--offsets-only)
memory write "<address>" "<pattern eg: 41 41 41 41>" (--string)
```
### SQLite

SQLite 데이터베이스와 상호 작용하기 위해 `sqlite` 명령을 사용할 수 있습니다.

### 종료
```bash
exit
```
## Objection에서 놓친 것들

* 후킹 메소드는 때때로 애플리케이션을 충돌시킵니다 (이는 Frida 때문일 수도 있습니다).
* 클래스의 인스턴스를 사용하여 인스턴스의 함수를 호출할 수 없습니다. 또한 클래스의 새로운 인스턴스를 생성하고 이를 사용하여 함수를 호출할 수도 없습니다.
* 애플리케이션이 사용하는 일반적인 암호화 메소드를 후킹하여 암호화된 텍스트, 평문 텍스트, 키, IV 및 사용된 알고리즘을 확인하기 위한 단축키 (sslpinnin과 같은)가 없습니다.

<img src="../../../.gitbook/assets/i3.png" alt="" data-size="original">

**버그 바운티 팁**: 해커들에 의해 만들어진 프리미엄 버그 바운티 플랫폼인 **Intigriti**에 **가입**하세요! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 가입하고 최대 **$100,000**의 바운티를 받으세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** 팔로우하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
