# Sakinisha Cheti cha Burp

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako inatangazwa kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PR kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Kwenye Mashine ya Virtual

Kwanza kabisa, unahitaji kupakua cheti cha Der kutoka kwa Burp. Unaweza kufanya hivi kwenye _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../.gitbook/assets/image (367).png>)

**Pakua cheti kwa muundo wa Der** na **litransform** ili **Android** iweze **kulielewa.** Kumbuka kwamba **ili kuweza kusanidi cheti cha burp kwenye mashine ya Android katika AVD** unahitaji **kuendesha** mashine hii **na** chaguo la **`-writable-system`**.\
Kwa mfano, unaweza kuendesha kama ifuatavyo:

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

Kisha, **configure cheti cha burp** kwa kufuata hatua zifuatazo:

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

Baada ya **mashine kukamilisha kuanza tena**, cheti cha burp kitatumika na hiyo!

## Kutumia Magisc

Ikiwa umefanya **root kifaa chako na Magisc** (labda emulator), na huwezi kufuata **hatua** za awali za kusakinisha cheti cha Burp kwa sababu **mfumo wa faili ni wa kusoma tu** na huwezi kuibadilisha kuwa wa kuandika, kuna njia nyingine.

Iliyoelezwa katika [**video hii**](https://www.youtube.com/watch?v=qQicUW0svB8) unahitaji:

1. **Sakinisha cheti cha CA**: Tu **vuta na achia** cheti cha DER cha Burp **ukiubadilisha kwa kuongeza** `.crt` kwenye simu ili iwekwe kwenye folda ya Upakuaji na nenda kwa `Sakinisha cheti` -> `Cheti cha CA`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* Angalia kwamba cheti kimehifadhiwa kwa usahihi kwa kwenda kwa `Imaniwa` -> `MTUMIAJI`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Fanya iwe ya kuaminika kwa mfumo**: Pakua moduli ya Magisc [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (faili ya .zip), **vuta na achia** kwenye simu, nenda kwenye programu ya **Magics** kwenye simu kwenye sehemu ya **`Moduli`**, bonyeza **`Sakinisha kutoka kwenye uhifadhi`**, chagua moduli ya `.zip` na baada ya kusakinisha **anzisha upya** simu:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* Baada ya kuanza upya, nenda kwa `Imaniwa` -> `MFUMO` na angalia cheti cha Postswigger kiko hapo

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## Baada ya Android 14

Katika toleo jipya la Android 14, kumekuwa na mabadiliko makubwa katika kushughulikia cheti cha Mamlaka ya Cheti (CA) kinachotegemewa na mfumo. Awali, vyeti hivi vilikuwa vimehifadhiwa katika **`/system/etc/security/cacerts/`**, vinavyoweza kufikiwa na kubadilishwa na watumiaji wenye mamlaka ya mizizi, ambayo iliruhusu matumizi mara moja katika mfumo. Walakini, na Android 14, eneo la uhifadhi limehamishiwa kwenye **`/apex/com.android.conscrypt/cacerts`**, saraka ndani ya njia ya **`/apex`**, ambayo ni isiyo na uwezo wa kubadilika kwa asili.

Jaribio la kubadilisha njia ya **APEX cacerts** kuwa ya kuandika hukutana na kushindwa, kwani mfumo haikubali shughuli kama hizo. Hata majaribio ya kufuta au kufunika saraka na mfumo wa faili wa muda (tmpfs) hayazidi kizuizi cha kusoma tu; programu zinaendelea kufikia data ya cheti ya asili bila kujali mabadiliko kwenye kiwango cha mfumo wa faili. Uimara huu unatokana na mlima wa **`/apex`** uliowekwa na usambazaji wa KIBINAFSI, ikihakikisha kuwa mabadiliko yoyote ndani ya saraka ya **`/apex`** hayawaathiri michakato mingine.

Uanzishaji wa Android unahusisha mchakato wa `init`, ambao, baada ya kuanza kwa mfumo wa uendeshaji, pia huanzisha mchakato wa Zygote. Mchakato huu unawajibika kwa kuzindua michakato ya programu na kubeba nafasi mpya ya mlima ambayo inajumuisha mlima wa kibinafsi wa **`/apex`**, hivyo kuisolate mabadiliko kwenye saraka hii kutoka kwa michakato mingine.

Walakini, njia mbadala ipo kwa wale wanaohitaji kubadilisha vyeti vya CA vilivyotegemewa na mfumo ndani ya saraka ya **`/apex`**. Hii inahusisha kubadilisha mlima wa **`/apex`** kwa kuondoa usambazaji wa KIBINAFSI, hivyo kuifanya iwe ya kuandika. Mchakato huu ni pamoja na kunakili yaliyomo kwenye saraka ya **`/apex/com.android.conscrypt`** kwenda eneo lingine, kufuta saraka ya **`/apex/com.android.conscrypt`** ili kuondoa kizuizi cha kusoma tu, na kisha kurejesha yaliyomo kwenye eneo lao la asili ndani ya **`/apex`**. Njia hii inahitaji hatua za haraka ili kuepuka kushindwa kwa mfumo. Ili kuhakikisha mabadiliko haya yanatumika kwa mfumo mzima, inashauriwa kuanzisha tena `system_server`, ambayo inazindua upya programu zote na kuleta mfumo katika hali thabiti.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Kufunga kupitia NSEnter

1. **Kuanzisha Folda Inayoweza Kuandikwa**: Kwanza, folda inayoweza kuandikwa inawekwa kwa kufunga `tmpfs` juu ya folda ya cheti ya mfumo isiyo ya APEX iliyopo. Hii inafanikiwa kwa kutumia amri ifuatayo:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Kujiandaa na Vyeti vya CA**: Baada ya kuandaa saraka inayoweza kuandikwa, vyeti vya CA ambavyo unakusudia kutumia vinapaswa kunakiliwa katika saraka hii. Hii inaweza kuhusisha kunakili vyeti vya msingi kutoka `/apex/com.android.conscrypt/cacerts/`. Ni muhimu kurekebisha ruhusa na lebo za SELinux za vyeti hivi kulingana na hali inayofaa.

3. **Bind Mounting kwa Zygote**: Kwa kutumia `nsenter`, unajiingiza katika nafasi ya uunganishaji wa Zygote. Zygote, ikiwa ni mchakato unaohusika na kuzindua programu za Android, inahitaji hatua hii ili kuhakikisha kuwa programu zote zinazoanzishwa baadaye zinatumia vyeti vya CA vilivyowekwa hivi karibuni. Amri inayotumiwa ni:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Hii inahakikisha kuwa kila programu mpya iliyozinduliwa itazingatia usanidi wa vyeti vya CA ulioboreshwa.

4. **Kuomba Mabadiliko kwa Programu Zinazoendelea**: Ili kuomba mabadiliko kwa programu zinazoendelea, `nsenter` inatumika tena kuingia kwenye kila nafasi ya programu kwa kujitegemea na kufanya bind mount sawa. Amri inayohitajika ni:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Njia Mbadala - Kuanzisha Upya Kwa Njia ya Programu**: Njia mbadala inahusisha kufanya bind mount kwenye mchakato wa `init` (PID 1) kisha kuanzisha upya laini wa mfumo wa uendeshaji kwa kutumia amri za `stop && start`. Njia hii itasambaza mabadiliko kwenye vifungu vyote, ikiepuka haja ya kushughulikia kila programu inayotumika kwa kujitegemea. Hata hivyo, njia hii kwa ujumla haipendelewi kutokana na usumbufu wa kuanzisha upya. 

## Marejeo
* [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi wa PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) za kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwenye** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
