# Burp証明書のインストール

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社**で働いていますか？**HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセス**したり、**HackTricksをPDFでダウンロード**したいですか？[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを手に入れましょう。
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手しましょう。
* **[**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのコツを共有するために、**[**hacktricksリポジトリ**](https://github.com/carlospolop/hacktricks)と[**hacktricks-cloudリポジトリ**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出してください。**

</details>

## 仮想マシン上で

まず最初に、BurpからDer証明書をダウンロードする必要があります。これは _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ で行うことができます。

![](<../../.gitbook/assets/image (367).png>)

**Der形式で証明書をエクスポートし**、**Android**が**理解できる形式に変換**しましょう。**AVDのAndroidマシンにburp証明書を設定するためには**、**`-writable-system`** オプションを付けてこのマシンを**実行**する必要があることに注意してください。\
例えば、次のように実行できます：

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

次に、**burps証明書を設定するには**：

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

**マシンが再起動を完了すると**、Burp証明書が使用されます！

## Magiscを使用する

もし**Magiscでデバイスをルート化**していて（エミュレーターの場合もあります）、ファイルシステムが**読み取り専用**で書き込み可能にリマウントできないために、Burp証明書のインストールに先述の**手順**を**たどれない**場合、別の方法があります。

[**このビデオ**](https://www.youtube.com/watch?v=qQicUW0svB8)で説明されているように、以下の手順を実行します：

1. **CA証明書をインストールする**：DER形式のBurp証明書を`.crt`に**拡張子を変更して**モバイルに**ドラッグ＆ドロップ**し、ダウンロードフォルダに保存します。そして`Install a certificate` -> `CA certificate`に進みます。

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* `Trusted credentials` -> `USER`に進んで、証明書が正しく保存されたことを確認します。

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. **システムで信頼されるようにする**：Magiscモジュール[MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts)（.zipファイル）をダウンロードし、電話に**ドラッグ＆ドロップ**して、電話の**Magicsアプリ**で**`Modules`**セクションに進み、**`Install from storage`**をクリックし、`.zip`モジュールを選択してインストールした後、電話を**再起動**します：

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* 再起動後、`Trusted credentials` -> `SYSTEM`に進み、Postswigger証明書がそこにあることを確認します。

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## Android 14以降

変更点：

* これまで、システムで信頼されるCA証明書は**`/system/etc/security/cacerts/`**にありました。標準のAOSPエミュレーターでは、最小限のセットアップで**ルートアクセスを使って直接変更**でき、**すぐに全体に影響**を与えました。
* Android 14では、システムで信頼されるCA証明書は一般的に**`/apex/com.android.conscrypt/cacerts`**にあり、**`/apex`全体が不変**です。
* **APEX cacertsパスは書き込み可能としてリマウントできません** - リマウントは単に失敗します。実際、ルートシェルから完全にパスをアンマウントしても、アプリは引き続き証明書を問題なく読み取ることができます。
* tmpfsディレクトリを上にマウントする代替技術も**機能しません** - これは`ls /apex/com.android.conscrypt/cacerts`が何も返さない（または好きなものを返す）かもしれませんが、アプリは依然として元のデータを見ることができます。
* `/apex`マウントは、プロセス間で`/apex`パス内のマウントの変更が共有されないように、[明示的に](https://cs.android.com/android/platform/superproject/main/+/main:system/core/init/mount\_namespace.cpp;l=97;drc=566c65239f1cf3fcb0d8745715e5ef1083d4bd3a) **PRIVATE伝播でマウントされています**。

これはOSを起動する`init`プロセスによって行われ、その後、[Zygoteプロセス](https://en.wikipedia.org/wiki/Booting\_process\_of\_Android\_devices#Zygote)（親からコピーされた新しいマウント名前空間を含むため、**自身のプライベートな`/apex`マウント**を含む）を起動し、その後、デバイス上でアプリが起動されるたびに**各アプリプロセスを開始します**（それぞれが同じプライベートな`/apex`マウントを**コピーします**）。

### マウントポイントを再帰的にリマウントする

* `/apex`を手動でリマウントし、PRIVATE伝播を削除して書き込み可能にすることができます（皮肉なことに、プライベート伝播を完全に削除すると、どこにでも_伝播する_ようです）
* `/apex/com.android.conscrypt`の全内容を別の場所にコピーします
* その後、`/apex/com.android.conscrypt`を完全にアンマウントします - このモジュールを不変で提供する読み取り専用マウントを削除します
* その後、内容を戻して、`/apex`マウントに直接生きるようにします。そこでは変更が可能です（[どうやら](https://infosec.exchange/@g1a55er/111069489513139531)クラッシュが発生する可能性があるため、迅速に行う必要があります）
* これはすぐに効果があるはずですが、`system_server`を終了する（すべてのアプリを再起動する）ことで、すべてを一貫した状態に戻すことを推奨します
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### NSEnterを使用したバインドマウント

* 最初に、どこかに書き込み可能なディレクトリを設定する必要があります。既存のアプローチとの互換性を容易にするために、私は非APEXシステム証明書ディレクトリ（まだ存在している）上に`tmpfs`マウントを使用してこれを行っています：

```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
* 次に、興味のあるCA証明書をこのディレクトリに配置します（例えば、既存の`/apex/com.android.conscrypt/cacerts/` CA証明書ディレクトリからすべてのデフォルトをコピーするかもしれません）そして、適切な権限とSELinuxラベルを設定します。
* その後、`nsenter`を使用してZygoteのマウント名前空間に入り、このディレクトリをAPEXディレクトリにバインドマウントします：

```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```

Zygoteプロセスは各アプリを生成し、その際にマウント名前空間をコピーするため、これにより新しく起動されるすべてのアプリ（これから開始されるすべてのもの）がこれを使用することになります。
* その後、`nsenter`を使用して既に実行中の各アプリの名前空間に入り、同じことを行います：

```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```

代わりに、UXが少し不便でも構わない場合は、`init`自体（PID 1）でバインドマウントを行い、その後`stop && start`を実行してOSをソフトリブートし、すべての名前空間を再作成して変更を至る所に伝播させることができるはずです（ただし、私は不便なリブートを気にするので、その方法は完全に無視しています）。

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社**で働いていますか？ **HackTricksにあなたの会社を広告したいですか？** または、**最新版のPEASSを入手**したり、**HackTricksをPDFでダウンロード**したいですか？ [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションをご覧ください。
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* **[**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**に**フォローしてください。**
* **ハッキングのトリックを共有するために、**[**hacktricksリポジトリ**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloudリポジトリ**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出してください。**

</details>
