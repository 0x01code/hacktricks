# Εγκατάσταση Πιστοποιητικού Burp

<details>

<summary><strong>Μάθετε το hacking στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF**, ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs** στα αποθετήρια [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) στο github.

</details>

## Σε έναν εικονικό υπολογιστή

Καταρχήν, πρέπει να κατεβάσετε το πιστοποιητικό Der από το Burp. Μπορείτε να το κάνετε αυτό στο _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../.gitbook/assets/image (367).png>)

**Εξαγάγετε το πιστοποιητικό σε μορφή Der** και ας το **μετατρέψουμε** σε μια μορφή που θα μπορεί να **κατανοήσει το Android**. Σημειώστε ότι **για να ρυθμίσετε το πιστοποιητικό burp στη μηχανή Android στο AVD**, πρέπει να **εκτελέσετε** αυτήν τη μηχανή **με** την επιλογή **`-writable-system`**.\
Για παράδειγμα, μπορείτε να το εκτελέσετε ως εξής:

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

Στη συνέχεια, για να **διαμορφώσετε το πιστοποιητικό του burp**, ακολουθήστε τα παρακάτω βήματα:

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

Μόλις ο υπολογιστής ολοκληρώσει την επανεκκίνηση, το πιστοποιητικό του Burp θα χρησιμοποιείται από αυτόν!

## Χρήση του Magisc

Εάν έχετε ρουτάρει τη συσκευή σας με το Magisc (ίσως έναν εξομοιωτή) και δεν μπορείτε να ακολουθήσετε τα προηγούμενα βήματα για να εγκαταστήσετε το πιστοποιητικό Burp επειδή το σύστημα αρχείων είναι μόνο για ανάγνωση και δεν μπορείτε να το αναμοντάρετε εγγράψιμο, υπάρχει κι άλλος τρόπος.

Όπως εξηγείται σε [αυτό το βίντεο](https://www.youtube.com/watch?v=qQicUW0svB8), πρέπει να:

1. Εγκαταστήσετε ένα πιστοποιητικό CA: Απλά σύρετε και αποθέστε το πιστοποιητικό Burp DER, αλλάζοντας την επέκταση σε `.crt`, στο κινητό σας, έτσι ώστε να αποθηκευτεί στον φάκελο Λήψεις και πηγαίνετε στην επιλογή `Εγκατάσταση πιστοποιητικού` -> `Πιστοποιητικό CA`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* Ελέγξτε ότι το πιστοποιητικό αποθηκεύτηκε σωστά πηγαίνοντας στην επιλογή `Αξιόπιστα διαπιστευτήρια` -> `ΧΡΗΣΤΗΣ`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. Καταστήστε το σύστημα αξιόπιστο: Κατεβάστε το πρόσθετο Magisc [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (ένα αρχείο .zip), σύρετέ το στο τηλέφωνο, πηγαίνετε στην εφαρμογή Magics στο τηλέφωνο στην ενότητα **`Ενότητες`**, κάντε κλικ στην επιλογή **`Εγκατάσταση από αποθήκευση`**, επιλέξτε το αρχείο .zip και μόλις εγκατασταθεί κάντε **επανεκκίνηση** του τηλεφώνου:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* Μετά την επανεκκίνηση, πηγαίνετε στην επιλογή `Αξιόπιστα διαπιστευτήρια` -> `ΣΥΣΤΗΜΑ` και ελέγξτε αν το πιστοποιητικό Postswigger είναι εκεί

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## Μετά το Android 14

Στην τελευταία έκδοση του Android 14, παρατηρήθηκε μια σημαντική αλλαγή στην χειρισμό των πιστοποιητικών αρχής (CA) που είναι αξιόπιστα από το σύστημα. Προηγουμένως, αυτά τα πιστοποιητικά βρίσκονταν στο **`/system/etc/security/cacerts/`**, προσβάσιμα και τροποποιήσιμα από χρήστες με δικαιώματα ρίζας, που επέτρεπε την άμεση εφαρμογή σε όλο το σύστημα. Ωστόσο, με το Android 14, η τοποθεσία αποθήκευσης μετακινήθηκε στο **`/apex/com.android.conscrypt/cacerts`**, έναν κατάλογο εντός της διαδρομής **`/apex`**, ο οποίος είναι αναπόσπαστος από φύσης.

Οι προσπάθειες να αναμοντάρετε τη διαδρομή **APEX cacerts** ως εγγράψιμη αποτυγχάνουν, καθώς το σύστημα δεν επιτρέπει τέτοιες λειτουργίες. Ακόμη και οι προσπάθειες να αποσυναρμολογήσετε ή να επικαλύψετε τον κατάλογο με ένα προσωρινό σύστημα αρχείων (tmpfs) δεν παρακάμπτουν την αναποτελεσματικότητα. Οι εφαρμογές συνεχίζουν να έχουν πρόσβαση στα αρχικά δεδομένα του πιστοποιητικού ανεξάρτητα από τις αλλαγές στο επίπεδο του συστήματος αρχείων. Αυτή η ανθεκτικότητα οφείλεται στη διαμόρφωση της προσάρτησης **`/apex`** με ιδιωτική διάδοση, εξασφαλίζοντας ότι οποιεσδήποτε τροποποιήσεις εντός του καταλόγου **`/apex`** δεν επηρεάζουν άλλες διεργασίες.

Η αρχικοποίηση του Android περιλαμβάνει τη διαδικασία `init`, η οποία, κατά την έναρξη του λειτουργικού συστήματος, εκκινεί επίσης τη διαδικασία Zygote. Αυτή η διαδικασία είναι υπεύθυνη για την εκκίνηση των διεργασιών εφαρμογών με ένα νέο περιβάλλον προσάρτησης που περιλαμβάνει μια ιδιωτική προσάρτηση **`/apex`**, απομονώνοντας έτσι τις αλλαγές σε αυτόν τον κατάλογο από άλλες διεργασίες.

Ωστόσο, υπάρχει ένας τρόπος για όσους χρειάζονται να τροποποιήσουν τα πιστοποιητικά CA που είναι αξιόπιστα από το σύστημα μέσα στον κατάλογο **`/apex`**. Αυτό περιλαμβάνει τη χειροκίνητη ανασύνδεση του **`/apex`** για να αφαιρέσετε την ιδιωτική διάδοση, κ
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Σύνδεση μέσω NSEnter

1. **Δημιουργία ενός εγγράψιμου φακέλου**: Αρχικά, δημιουργείται ένας εγγράψιμος φάκελος με τη σύνδεση ενός `tmpfs` πάνω από τον υπάρχοντα φάκελο μη-ΑΡΕΧ του συστήματος πιστοποιητικών. Αυτό επιτυγχάνεται με την παρακάτω εντολή:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Προετοιμασία πιστοποιητικών CA**: Ακολουθώντας τη ρύθμιση του εγγράψιμου καταλόγου, τα πιστοποιητικά CA που προτίθεται να χρησιμοποιήσει κανείς πρέπει να αντιγραφούν σε αυτόν τον κατάλογο. Αυτό μπορεί να περιλαμβάνει την αντιγραφή των προεπιλεγμένων πιστοποιητικών από `/apex/com.android.conscrypt/cacerts/`. Είναι απαραίτητο να προσαρμοστούν οι άδειες και οι ετικέτες SELinux αυτών των πιστοποιητικών αναλόγως.

3. **Σύνδεση τοποθέτησης για το Zygote**: Χρησιμοποιώντας το `nsenter`, μπαίνουμε στο χώρο ονομάτων τοποθέτησης του Zygote. Το Zygote, που είναι η διεργασία υπεύθυνη για την εκκίνηση των εφαρμογών Android, απαιτεί αυτό το βήμα για να διασφαλιστεί ότι όλες οι εφαρμογές που θα εκκινηθούν στη συνέχεια θα χρησιμοποιούν τα νεοδιαμορφωμένα πιστοποιητικά CA. Η εντολή που χρησιμοποιείται είναι:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Αυτό εξασφαλίζει ότι κάθε νέα εφαρμογή που ξεκινά θα τηρεί την ενημερωμένη ρύθμιση των πιστοποιητικών CA.

4. **Εφαρμογή αλλαγών σε εκτελούμενες εφαρμογές**: Για να εφαρμόσετε τις αλλαγές σε ήδη εκτελούμενες εφαρμογές, χρησιμοποιείται ξανά το `nsenter` για να εισέλθετε ατομικά στο namespace κάθε εφαρμογής και να πραγματοποιήσετε μια παρόμοια bind mount. Η απαραίτητη εντολή είναι:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Εναλλακτική Προσέγγιση - Μαλακή Επανεκκίνηση**: Μια εναλλακτική μέθοδος περιλαμβάνει την εκτέλεση της bind mount στη διεργασία `init` (PID 1), ακολουθούμενη από μια μαλακή επανεκκίνηση του λειτουργικού συστήματος με τις εντολές `stop && start`. Αυτή η προσέγγιση θα επεκτείνει τις αλλαγές σε όλα τα namespaces, αποφεύγοντας την ανάγκη να αντιμετωπίζονται ξεχωριστά όλες οι εκτελούμενες εφαρμογές. Ωστόσο, αυτή η μέθοδος συνήθως προτιμάται λιγότερο λόγω της ενόχλησης της επανεκκίνησης.

## Αναφορές
* [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)

<details>

<summary><strong>Μάθετε το hacking στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετάσχετε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα κόλπα σας για το hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
