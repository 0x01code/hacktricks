# Burp Sertifikasını Yükle

<details>

<summary><strong>Sıfırdan ileri seviye AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Sanal Makinede

İlk olarak, Burp'tan Der sertifikasını indirmeniz gerekmektedir. Bunun için _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ adımlarını takip edebilirsiniz.

![](<../../.gitbook/assets/image (367).png>)

Sertifikayı **Der formatında dışa aktarın** ve **Android'in anlayabileceği bir forma dönüştürelim**. **Android makinesinde burp sertifikasını yapılandırmak için AVD'de** bu makineyi **`-writable-system`** seçeneğiyle **çalıştırmanız gerektiğini unutmayın.**\
Örneğin şu şekilde çalıştırabilirsiniz:

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

Ardından, **burp sertifikasını yapılandırmak için şunları yapın**:

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

**Makine yeniden başlatıldığında**, burp sertifikası tarafından kullanılacaktır!

## Magisc Kullanımı

Eğer cihazınızı Magisc ile rootladıysanız (belki bir emülatör), ve **dosya sistemi salt okunur olduğu için yazılabilir olarak yeniden bağlayamıyorsanız**, Burp sertifikasını yüklemek için önceki adımları takip edemiyorsanız, başka bir yol var.

[**Bu video**](https://www.youtube.com/watch?v=qQicUW0svB8)da açıklandığı gibi yapmanız gerekenler:

1. **Bir CA sertifikası yükleyin**: DER Burp sertifikasını `.crt` uzantısına değiştirerek mobil cihaza indirin ve `İndirilenler` klasörüne kaydedin, ardından `Sertifika yükle` -> `CA sertifikası` seçeneğine gidin

<figure><img src="../../.gitbook/assets/image (50).png" alt="" width="164"><figcaption></figcaption></figure>

* Sertifikanın doğru şekilde kaydedildiğini kontrol edin, `Güvenilir kimlik bilgileri` -> `KULLANICI` bölümüne gidin

<figure><img src="../../.gitbook/assets/image (51).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Sistemde güvenilir hale getirin**: Magisc modülünü [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (bir .zip dosyası) indirin, telefonunuza sürükleyip bırakın, telefonunuzdaki Magics uygulamasına gidin, `Modüller` bölümüne gidin, `Depodan yükle` seçeneğine tıklayın, `.zip` modülünü seçin ve kurulum tamamlandıktan sonra telefonu **yeniden başlatın**:

<figure><img src="../../.gitbook/assets/image (52).png" alt="" width="345"><figcaption></figcaption></figure>

* Yeniden başlatıldıktan sonra, `Güvenilir kimlik bilgileri` -> `SİSTEM` bölümüne gidin ve Postswigger sertifikasının orada olduğunu kontrol edin

<figure><img src="../../.gitbook/assets/image (53).png" alt="" width="314"><figcaption></figcaption></figure>

## Android 14 Sonrası

En son Android 14 sürümünde, sistem-güvenilir Sertifika Yetkilisi (CA) sertifikalarının işlenmesinde önemli bir değişiklik gözlemlenmiştir. Önceden, bu sertifikalar **`/system/etc/security/cacerts/`** dizininde bulunur ve kök ayrıcalıklarına sahip kullanıcılar tarafından erişilebilir ve değiştirilebilirdi, bu da sisteme hemen uygulanmasına olanak tanırdı. Ancak, Android 14 ile, depolama yeri **`/apex/com.android.conscrypt/cacerts`** dizinine taşındı, bu da doğası gereği değiştirilemez olan **`/apex`** yolundaki bir dizindir.

**APEX cacerts yolunu** yazılabilir olarak yeniden bağlamaya yönelik girişimler başarısızlıkla karşılaşır, çünkü sistem böyle işlemlere izin vermez. Dizin üzerine geçici bir dosya sistemi (tmpfs) ile aşma veya kaldırma girişimleri bile, dizinin değiştirilemezliğini atlatmaz; uygulamalar, dosya sistemi seviyesinde yapılan değişikliklere rağmen orijinal sertifika verilerine erişmeye devam eder. Bu direnç, **`/apex`** bağının ÖZEL yayılma ile yapılandırılmış olmasından kaynaklanır, bu da **`/apex`** dizinindeki değişikliklerin diğer işlemleri etkilememesini sağlar.

Android'in başlatılması, işletim sistemini başlatırken aynı zamanda Zygote işlemini başlatan `init` işlemiyle gerçekleşir. Bu işlem, bu dizinden izole edilmiş bir yeni bağlama ad alanı içeren uygulama işlemlerini başlatmakla sorumludur.

Yine de, **`/apex`** dizinindeki sistem-güvenilir CA sertifikalarını değiştirmek isteyenler için bir çözüm bulunmaktadır. Bu, **`/apex`**'i yeniden bağlayarak ÖZEL yayılmayı kaldırmayı içerir, böylece yazılabilir hale getirilir. Bu süreç, **`/apex/com.android.conscrypt`** içeriğini başka bir konuma kopyalamayı, **`/apex/com.android.conscrypt`** dizinini salt okunur kısıtlamasını kaldırmak için bağlamamayı ve ardından içeriği orijinal konumlarına **`/apex`** içinde geri yüklemeyi içerir. Bu yaklaşım, sistem çökmelerini önlemek için hızlı bir şekilde hareket etmeyi gerektirir. Bu değişikliklerin sistem genelinde uygulanmasını sağlamak için, `system_server`'ı yeniden başlatmanız önerilir, bu da tüm uygulamaları yeniden başlatır ve sistemi tutarlı bir duruma getirir.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### NSEnter üzerinden Bind-mounting

1. **Yazılabilir Bir Dizin Oluşturma**: İlk olarak, mevcut olmayan APEX olmayan sistem sertifika dizininin üzerine bir `tmpfs` bağlanarak yazılabilir bir dizin oluşturulur. Bu, aşağıdaki komutla gerçekleştirilir:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **CA Sertifikalarını Hazırlama**: Yazılabilir dizinin kurulumunu takiben, kullanmayı amaçladığınız CA sertifikaları bu dizine kopyalanmalıdır. Bu, varsayılan sertifikaların `/apex/com.android.conscrypt/cacerts/` dizininden kopyalanmasını gerektirebilir. Bu sertifikaların izinleri ve SELinux etiketleri uygun şekilde ayarlanmalıdır.
3. **Zygote İçin Bağlama Bağlama**: `nsenter` kullanılarak, Zygote'un bağlama ad alanına girilir. Android uygulamalarını başlatmakla sorumlu olan Zygote, bundan sonra başlatılan tüm uygulamaların yeni yapılandırılmış CA sertifikalarını kullanmasını sağlamak için bu adımı gerektirir. Kullanılan komut şudur:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Bu, her yeni uygulamanın güncellenmiş CA sertifikaları kurulumuna uyacağından emin olur.

4. **Çalışan Uygulamalara Değişiklikler Uygulama**: Zaten çalışan uygulamalara değişiklikleri uygulamak için, `nsenter` tekrar kullanılarak her uygulamanın ad alanına bireysel olarak girilir ve benzer bir bağ montajı gerçekleştirilir. Gerekli komut şudur:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternatif Yaklaşım - Yumuşak Yeniden Başlatma**: Alternatif bir yöntem, `init` işlemine (PID 1) bağlama işlemini gerçekleştirmeyi ve işletim sistemini `stop && start` komutlarıyla yumuşak bir şekilde yeniden başlatmayı içerir. Bu yaklaşım, değişikliklerin tüm ad alanlarına yayılmasını sağlayacak ve her çalışan uygulamayı tek tek ele almaya gerek kalmayacaktır. Bununla birlikte, bu yöntem genellikle yeniden başlatmanın rahatsızlığı nedeniyle tercih edilmez.

## Referanslar

* [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
