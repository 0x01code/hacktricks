# Burp Sertifikası Yükleme

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>

## Sanal Makine Üzerinde

İlk olarak, Burp'tan Der sertifikasını indirmeniz gerekmektedir. Bunun için _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ yolunu izleyebilirsiniz.

![](<../../.gitbook/assets/image (367).png>)

Sertifikayı **Der formatında dışa aktarın** ve **Android'in anlayabileceği bir formata dönüştürelim**. **AVD'deki Android makinesinde burp sertifikasını yapılandırmak için** bu makineyi **`-writable-system`** seçeneğiyle **çalıştırmanız gerekmektedir**. Örneğin, şu şekilde çalıştırabilirsiniz:

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

Ardından, **burp sertifikasını yapılandırmak için** şunları yapın:

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

Makine yeniden başlatıldığında burp sertifikası kullanımda olacak!

## Magisc Kullanma

Eğer cihazınızı Magisc ile rootladıysanız (belki bir emülatör), ve önceki adımları takip edemiyorsanız çünkü dosya sistemi salt okunurdur ve yazılabilir olarak yeniden bağlanamaz, başka bir yol vardır.

[**Bu videoda**](https://www.youtube.com/watch?v=qQicUW0svB8) açıklandığı gibi yapmanız gerekenler:

1. **Bir CA sertifikası yükleyin**: DER Burp sertifikasını `.crt` uzantısına dönüştürerek mobil cihaza **sürükleyip bırakın**, böylece indirilenler klasöründe saklanır ve `Bir sertifika yükle` -> `CA sertifikası`'na gidin.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* Sertifikanın doğru bir şekilde saklandığını kontrol edin, `Güvenilen kimlik bilgileri` -> `KULLANICI`'ya gidin.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Sistem güvenilir yapın**: Magisc modülünü [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (bir .zip dosyası) indirin, telefonunuza **sürükleyip bırakın**, telefondaki **Magics uygulamasına** gidin, **`Modüller`** bölümüne gidin, **`Depodan yükle`**'yi tıklayın, `.zip` modülünü seçin ve kurulum tamamlandıktan sonra telefonu **yeniden başlatın**:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* Yeniden başlattıktan sonra, `Güvenilen kimlik bilgileri` -> `SİSTEM`'e gidin ve Postswigger sertifikasının orada olduğunu kontrol edin.

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## Android 14 Sonrası

En son Android 14 sürümünde, sistem tarafından güvenilen Sertifika Yetkilisi (CA) sertifikalarının işlenmesinde önemli bir değişiklik gözlemlenmiştir. Önceden, bu sertifikalar **`/system/etc/security/cacerts/`** dizininde bulunur ve kök ayrıcalıklarına sahip kullanıcılar tarafından erişilebilir ve değiştirilebilirlerdi, bu da sisteme hemen uygulanmasına olanak sağlardı. Ancak, Android 14 ile birlikte depolama konumu **`/apex/com.android.conscrypt/cacerts`** olarak değiştirilmiştir, bu da doğası gereği değiştirilemez olan **`/apex`** yolunun içindeki bir dizindir.

**APEX cacerts yolunu** yazılabilir olarak yeniden bağlama girişimleri başarısızlıkla karşılanır, çünkü sistem böyle işlemlere izin vermez. Hatta geçici bir dosya sistemi (tmpfs) ile dizini ayrı bağlamaya veya üzerine bindirmeye yönelik girişimler bile değiştirilemezliği atlatmaz; uygulamalar, dosya sistemi düzeyinde yapılan değişikliklere bakılmaksızın orijinal sertifika verilerine erişmeye devam eder. Bu direnç, **`/apex`** bağının ÖZEL yayılım ile yapılandırılmış olmasından kaynaklanır, bu da **`/apex`** dizini içindeki değişikliklerin diğer işlemleri etkilemediğini sağlar.

Android'in başlatılması, işletim sistemini başlatan `init` işlemiyle başlar ve aynı zamanda Zygote işlemini başlatır. Bu işlem, bu dizinin diğer işlemlerden izole edilmesini sağlayan yeni bir bağlama ad alanıyla uygulama işlemlerini başlatma sorumluluğunu üstlenir.

Yine de, **`/apex`** dizini içindeki sistem tarafından güvenilen CA sertifikalarını değiştirmek isteyenler için bir çözüm bulunmaktadır. Bu, **`/apex`**'i özel yayılımı kaldırmak için manuel olarak yeniden bağlamayı içerir, böylece yazılabilir hale getirilir. Bu süreç, **`/apex/com.android.conscrypt`** içeriğini başka bir konuma kopyalamayı, **`/apex/com.android.conscrypt`** dizinini salt okunur kısıtlamasını kaldırmak için bağlantısını kesmeyi ve ardından içeriği **`/apex`** içindeki orijinal konumuna geri yüklemeyi içerir. Bu yaklaşım, sistem çökmelerini önlemek için hızlı hareket gerektirir. Bu değişikliklerin sistem genelinde uygulanmasını sağlamak için `system_server`'ı yeniden başlatmanız önerilir, bu da tüm uygulamaları yeniden başlatır ve sistemi tutarlı bir duruma getirir.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### NSEnter ile Bind-mounting

1. **Yazılabilir Bir Dizin Oluşturma**: İlk olarak, mevcut olmayan APEX olmayan sistem sertifika dizini üzerine bir `tmpfs` bağlanarak yazılabilir bir dizin oluşturulur. Bu, aşağıdaki komutla gerçekleştirilir:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **CA Sertifikalarını Hazırlama**: Yazılabilir dizinin kurulumundan sonra, kullanmayı planladığınız CA sertifikalarını bu dizine kopyalamalısınız. Bu, `/apex/com.android.conscrypt/cacerts/` dizininden varsayılan sertifikaların kopyalanmasını gerektirebilir. Bu sertifikaların izinlerini ve SELinux etiketlerini uygun şekilde ayarlamak önemlidir.

3. **Zygote için Bağlama Montajı**: `nsenter` kullanarak, Zygote'nin montaj ad alanına girilir. Android uygulamalarını başlatan süreç olan Zygote, bundan sonra başlatılan tüm uygulamaların yeni yapılandırılmış CA sertifikalarını kullanmasını sağlamak için bu adımı gerektirir. Kullanılan komut:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Bu, her yeni başlatılan uygulamanın güncellenmiş CA sertifikaları kurulumuna uymasını sağlar.

4. **Çalışan Uygulamalara Değişiklikleri Uygulama**: Zaten çalışan uygulamalara değişiklikleri uygulamak için, `nsenter` tekrar kullanılır ve her uygulamanın ad alanına bireysel olarak girilir ve benzer bir bağlama noktası bağlama işlemi gerçekleştirilir. Gerekli komut:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Alternatif Yaklaşım - Yumuşak Yeniden Başlatma**: Alternatif bir yöntem, `init` işlemine (PID 1) bind mount işlemini gerçekleştirmek ve ardından işletim sistemini `stop && start` komutlarıyla yumuşak bir şekilde yeniden başlatmaktır. Bu yaklaşım, değişiklikleri tüm ad alanlarına yayarak her bir çalışan uygulamayı ayrı ayrı ele almaya gerek olmamasını sağlar. Bununla birlikte, bu yöntem genellikle yeniden başlatmanın zahmetli olması nedeniyle tercih edilmemektedir.

## Referanslar
* [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramanla öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya HackTricks'i **PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'i keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>
