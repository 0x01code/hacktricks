# Burp証明書のインストール

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でAWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**か**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksのスウェグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)で**フォロー**する。
- **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks)のGitHubリポジトリにPRを提出して、あなたのハッキングテクニックを共有してください。

</details>

## 仮想マシン上で

まず、BurpからDer証明書をダウンロードする必要があります。これは _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ で行うことができます。

![](<../../.gitbook/assets/image (367).png>)

**Der形式で証明書をエクスポート**し、**Androidが理解できる形式に変換**します。AndroidマシンのAVDでBurp証明書を構成するには、このマシンを**`-writable-system`**オプションで**実行する必要があります。**
例えば、次のように実行できます：

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

次に、**Burpの証明書を設定するには**：

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

**マシンが再起動を完了すると**、burp証明書がそれによって使用されます！

## Magiscを使用する

Magiscでデバイスをroot化した場合（おそらくエミュレータ）、**ファイルシステムが読み取り専用**でリマウントできないため、以前の手順に従うことができない場合は、別の方法があります。

[**このビデオ**](https://www.youtube.com/watch?v=qQicUW0svB8)で説明されているように、次の手順を実行する必要があります：

1. **CA証明書をインストール**：DER Burp証明書を`.crt`に変更してモバイルにドラッグ＆ドロップし、ダウンロードフォルダに保存し、「証明書のインストール」->「CA証明書」に移動します

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* 証明書が正しく保存されたことを確認するには、「信頼された証明書」->「ユーザー」に移動します

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. **システムで信頼されるようにする**：Magiscモジュール[MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts)（.zipファイル）をダウンロードし、それを電話にドラッグ＆ドロップし、電話のMagicsアプリに移動して、「モジュール」セクションに移動し、「ストレージからインストール」をクリックし、`.zip`モジュールを選択してインストールしたら、電話を**再起動**します：

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* 再起動後、「信頼された証明書」->「システム」に移動し、Postswigger証明書がそこにあるかどうかを確認します

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## Android 14以降

最新のAndroid 14リリースでは、システムで信頼される証明機関（CA）証明書の取り扱いに重要な変更が観察されています。以前は、これらの証明書は**`/system/etc/security/cacerts/`**に格納され、root権限を持つユーザーがアクセスして変更でき、システム全体に即座に適用できました。しかし、Android 14では、ストレージ場所が**`/apex/com.android.conscrypt/cacerts`**に移動されました。これは**`/apex`**パス内のディレクトリであり、その性質上変更できません。

**APEX cacertsパス**を書き込み可能にリマウントしようとする試みは失敗します。システムはこのような操作を許可しません。**`/apex`**ディレクトリを書き込み可能にするためにリマウントする試みや、一時ファイルシステム（tmpfs）でディレクトリをアンマウントまたはオーバーレイする試みも、不変性を回避しません。ファイルシステムレベルでの変更に関わらず、アプリケーションは引き続き元の証明書データにアクセスします。これは、**`/apex`**マウントがPRIVATE伝播で構成されているためです。これにより、**`/apex`**ディレクトリ内の変更が他のプロセスに影響を与えないようになっています。

Androidの初期化には`init`プロセスが関与し、オペレーティングシステムの起動時にZygoteプロセスも開始されます。このプロセスは、新しいマウント名前空間を持つZygoteプロセスを起動し、このディレクトリへの変更を他のプロセスから分離します。

ただし、**`/apex`**ディレクトリ内のシステムで信頼されるCA証明書を変更する必要がある場合の回避策が存在します。これには、**`/apex`**を手動でリマウントしてPRIVATE伝播を削除し、書き込み可能にする必要があります。このプロセスには、**`/apex/com.android.conscrypt`**の内容を別の場所にコピーし、**`/apex/com.android.conscrypt`**ディレクトリをアンマウントして読み取り専用制約を解除し、その後、**`/apex`**内の元の場所に内容を復元する必要があります。このアプローチはシステムクラッシュを回避するために迅速な対応が必要です。これらの変更がシステム全体に適用されるようにするためには、`system_server`を再起動することをお勧めします。これにより、すべてのアプリケーションが再起動され、システムが一貫した状態になります。
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### NSEnterを介したバインドマウント

1. **書き込み可能ディレクトリの設定**: 最初に、既存の非-APEXシステム証明書ディレクトリに`tmpfs`をマウントして書き込み可能ディレクトリを確立します。次のコマンドを使用してこれを実現します:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **CA証明書の準備**: 書き込み可能ディレクトリのセットアップに続いて、使用するCA証明書をこのディレクトリにコピーする必要があります。これには、デフォルトの証明書を`/apex/com.android.conscrypt/cacerts/`からコピーすることが含まれる場合があります。これらの証明書の権限とSELinuxラベルを適切に調整することが重要です。
3. **Zygote用のバインドマウント**: `nsenter`を利用して、Zygoteのマウント名前空間に入ります。 Androidアプリケーションを起動する責任があるプロセスであるZygoteは、今後起動されるすべてのアプリケーションが新しく構成されたCA証明書を利用するようにするために、この手順が必要です。使用されるコマンドは次のとおりです:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
これにより、新しいアプリが開始されるたびに、更新されたCA証明書の設定に従うようになります。

4. **実行中のアプリに変更を適用する**: 既に実行中のアプリに変更を適用するには、`nsenter`を再度使用して各アプリの名前空間に個別に入り、同様のバインドマウントを行います。必要なコマンドは次のとおりです:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **代替手法 - ソフト再起動**: 代替手法は、`init` プロセス（PID 1）での bind マウントを実行し、`stop && start` コマンドでオペレーティングシステムをソフト再起動する方法です。この手法は、変更をすべてのネームスペースに伝播させ、実行中の各アプリを個別に対処する必要がないため、一般的に好まれません。ただし、再起動の手間がかかるため、一般的にはあまり好まれません。

## 参考文献

* [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
