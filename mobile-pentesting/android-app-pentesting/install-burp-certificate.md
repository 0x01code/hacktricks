# 安装 Burp 证书

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 如果您在**网络安全公司**工作？您想在**HackTricks**中看到您的**公司广告**吗？或者您想要访问**PEASS的最新版本或下载HackTricks的PDF**？查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)系列
* 获取[**官方PEASS & HackTricks周边商品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**telegram群组**](https://t.me/peass)或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享您的黑客技巧。**

</details>

## 在虚拟机上

首先，您需要从Burp下载Der证书。您可以在 _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_ 中进行下载。

![](<../../.gitbook/assets/image (367).png>)

**以Der格式导出证书**，然后将其**转换**为**Android**能够**理解**的格式。请注意，**为了在AVD中的Android机器上配置burp证书**，您需要使用**`-writable-system`**选项**运行**此机器。\
例如，您可以这样运行它：

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

然后，要**配置 burp 证书，请执行**：

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

一旦**机器完成重启**，burp证书将被其使用！

## 使用Magisc

如果您**使用Magisc对设备进行了root**（可能是模拟器），并且您**无法按照**前面的**步骤**安装Burp证书，因为**文件系统是只读的**并且您无法重新挂载为可写，还有另一种方法。

如[**此视频**](https://www.youtube.com/watch?v=qQicUW0svB8)所解释，您需要：

1. **安装CA证书**：只需将DER Burp证书**拖放**并**更改扩展名**为`.crt`到手机中，这样它就存储在下载文件夹中，然后转到`安装证书` -> `CA证书`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* 检查证书是否已正确存储，转到`受信任的凭据` -> `USER`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. **使其成为系统信任**：下载Magisc模块[MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts)（一个.zip文件），**拖放**到手机中，转到手机中的**Magics应用**的**`Modules`**部分，点击**`从存储安装`**，选择`.zip`模块并安装后**重启**手机：

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* 重启后，转到`受信任的凭据` -> `SYSTEM`并检查Postswigger证书是否在那里

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## Android 14之后

变化：

* 目前为止，系统信任的CA证书位于**`/system/etc/security/cacerts/`**。在标准的AOSP模拟器上，这些可以通过最小设置**直接通过root访问进行修改**，立即在**所有地方生效**。
* 在Android 14中，系统信任的CA证书通常位于**`/apex/com.android.conscrypt/cacerts`**，并且所有的**`/apex`都是不可变的**。
* **APEX cacerts路径无法重新挂载为可写** - 重新挂载简单地失败。实际上，即使您从root shell卸载整个路径，应用程序仍然可以很好地读取您的证书。
* **在顶部挂载tmpfs目录的替代技术也不起作用** - 即使这意味着`ls /apex/com.android.conscrypt/cacerts`可能什么都不返回（或者您喜欢的任何其他内容），应用程序仍然会看到相同的原始数据。
* 因为`/apex`挂载是[明确挂载](https://cs.android.com/android/platform/superproject/main/+/main:system/core/init/mount\_namespace.cpp;l=97;drc=566c65239f1cf3fcb0d8745715e5ef1083d4bd3a) **具有PRIVATE传播**，以便在`/apex`路径内的所有挂载更改都不会在进程之间共享。

这是由启动操作系统的`init`进程完成的，然后它启动[Zygote进程](https://en.wikipedia.org/wiki/Booting\_process\_of\_Android\_devices#Zygote)（从父进程复制了一个新的挂载命名空间，因此包括其**自己的私有`/apex`挂载**），然后反过来**启动每个应用进程**，每当设备上启动应用时（他们每个人反过来又**复制了同样的私有`/apex`挂载**）。

### 递归重新挂载挂载点

* 您可以手动重新挂载`/apex`，移除PRIVATE传播并使其可写（讽刺的是，完全移除私有传播似乎_确实_到处传播）
* 您将`/apex/com.android.conscrypt`的全部内容复制到其他地方
* 然后您完全卸载`/apex/com.android.conscrypt` - 移除不可变地提供此模块的只读挂载
* 然后您将内容复制回来，使其直接生活在`/apex`挂载中，可以进行修改（您需要快速完成此操作，因为[显然](https://infosec.exchange/@g1a55er/111069489513139531)您可以看到崩溃）
* 这应该立即生效，但他们建议杀死`system_server`（重新启动所有应用程序）以使一切恢复到一致状态
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### 通过 NSEnter 绑定挂载

*   首先，我们需要在某处设置一个可写目录。为了与现有方法兼容，我使用 `tmpfs` 挂载覆盖了（仍然存在的）非 APEX 系统证书目录：

```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
* 然后将您感兴趣的 CA 证书放入此目录中（例如，您可能想从现有的 `/apex/com.android.conscrypt/cacerts/` CA 证书目录中复制所有默认值），并适当设置权限和 SELinux 标签。
*   接着，使用 `nsenter` 进入 Zygote 的挂载命名空间，并将此目录绑定挂载到 APEX 目录上：

```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```

Zygote 进程生成每个应用程序，复制其挂载命名空间以此进行，因此这确保了所有新启动的应用程序（从现在开始启动的所有应用程序）都将使用这个。
*   然后，使用 `nsenter` 进入每个已经运行的应用程序的命名空间，并执行相同的操作：

```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```

或者，如果您不介意笨拙的用户体验，您应该能够在 `init` 本身（PID 1）上进行绑定挂载，然后运行 `stop && start` 来软重启操作系统，重新创建所有命名空间并传播您的更改到处（但我个人确实介意笨拙的重启，所以我完全忽略了那条路线）。

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 您在**网络安全公司**工作吗？您想在 **HackTricks** 中看到您的**公司广告**吗？或者您想要访问**最新版本的 PEASS 或下载 HackTricks 的 PDF**？查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)系列
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 上**关注**我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* 通过向 [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) 和 [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) 提交 PR 来**分享您的黑客技巧**。

</details>
