# Installazione del certificato Burp

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF**, controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) **e** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **su GitHub.**

</details>

## Su una macchina virtuale

Innanzitutto, √® necessario scaricare il certificato Der da Burp. Puoi farlo in _**Proxy**_ --> _**Opzioni**_ --> _**Importa/Esporta certificato CA**_

![](<../../.gitbook/assets/image (367).png>)

**Esporta il certificato in formato Der** e **trasformalo** in una forma che **Android** sar√† in grado di **comprendere**. Nota che **per configurare il certificato Burp sulla macchina Android in AVD**, √® necessario **eseguire** questa macchina **con l'opzione** **`-writable-system`**.\
Ad esempio, puoi eseguirlo in questo modo:

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

Successivamente, per **configurare il certificato di Burp**, eseguire i seguenti passaggi:

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

Una volta che la **macchina ha finito di riavviarsi**, il certificato di Burp sar√† in uso da essa!

## Utilizzando Magisc

Se hai **ottenuto i privilegi di root sul tuo dispositivo con Magisc** (forse un emulatore) e **non puoi seguire** i passaggi precedenti per installare il certificato di Burp perch√© il **filesystem √® in sola lettura** e non puoi rimontarlo in modalit√† scrittura, c'√® un altro modo.

Come spiegato in [**questo video**](https://www.youtube.com/watch?v=qQicUW0svB8), devi:

1. **Installare un certificato CA**: Basta **trascinare e rilasciare** il certificato Burp DER **cambiando l'estensione** in `.crt` sul dispositivo mobile in modo che venga memorizzato nella cartella Download e vai su `Installa un certificato` -> `Certificato CA`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* Verifica che il certificato sia stato memorizzato correttamente andando su `Credenziali attendibili` -> `UTENTE`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Rendilo attendibile dal sistema**: Scarica il modulo Magisc [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (un file .zip), **trascinalo e rilascialo** sul telefono, vai all'app Magics sul telefono nella sezione **`Moduli`**, clicca su **`Installa da archivio`**, seleziona il modulo `.zip` e una volta installato **riavvia** il telefono:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* Dopo il riavvio, vai su `Credenziali attendibili` -> `SISTEMA` e verifica che il certificato di Postswigger sia presente

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## Post Android 14

Nell'ultima versione di Android 14, si √® osservato un cambiamento significativo nella gestione dei certificati di autorit√† di certificazione (CA) attendibili dal sistema. In precedenza, questi certificati erano ospitati in **`/system/etc/security/cacerts/`**, accessibili e modificabili dagli utenti con privilegi di root, il che consentiva un'applicazione immediata su tutto il sistema. Tuttavia, con Android 14, la posizione di archiviazione √® stata spostata in **`/apex/com.android.conscrypt/cacerts`**, una directory all'interno del percorso **`/apex`**, che √® immutabile per natura.

I tentativi di rimontare il percorso **APEX cacerts** come scrivibile falliscono, poich√© il sistema non consente tali operazioni. Anche i tentativi di smontare o sovrapporre la directory con un sistema di file temporaneo (tmpfs) non aggirano l'immutabilit√†; le applicazioni continuano ad accedere ai dati del certificato originale indipendentemente dalle modifiche a livello di sistema di file. Questa resilienza √® dovuta al fatto che il mount **`/apex`** √® configurato con la propagazione PRIVATE, garantendo che le modifiche all'interno della directory **`/apex`** non influiscano su altri processi.

L'inizializzazione di Android coinvolge il processo `init`, che, all'avvio del sistema operativo, avvia anche il processo Zygote. Questo processo √® responsabile del lancio dei processi delle applicazioni con un nuovo namespace di mount che include un mount privato **`/apex`**, isolando cos√¨ le modifiche a questa directory dagli altri processi.

Tuttavia, esiste una soluzione alternativa per coloro che hanno bisogno di modificare i certificati CA attendibili dal sistema all'interno della directory **`/apex`**. Questo comporta il rimontaggio manuale di **`/apex`** per rimuovere la propagazione PRIVATE, rendendolo scrivibile. Il processo include la copia dei contenuti di **`/apex/com.android.conscrypt`** in un'altra posizione, lo smontaggio della directory **`/apex/com.android.conscrypt`** per eliminare il vincolo di sola lettura e quindi il ripristino dei contenuti nella loro posizione originale all'interno di **`/apex`**. Questo approccio richiede un'azione rapida per evitare crash di sistema. Per garantire l'applicazione di queste modifiche a livello di sistema, si consiglia di riavviare il `system_server`, che riavvia efficacemente tutte le applicazioni e porta il sistema a uno stato coerente.
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting tramite NSEnter

1. **Configurazione di una directory scrivibile**: Inizialmente, viene creata una directory scrivibile montando un `tmpfs` sulla directory esistente dei certificati di sistema non-APEX. Questo viene ottenuto con il seguente comando:
```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
2. **Preparazione dei certificati CA**: Dopo aver configurato la directory scrivibile, i certificati CA che si intende utilizzare devono essere copiati in questa directory. Ci√≤ potrebbe comportare la copia dei certificati predefiniti da `/apex/com.android.conscrypt/cacerts/`. √à essenziale regolare i permessi e le etichette SELinux di questi certificati di conseguenza.

3. **Bind Mounting per Zygote**: Utilizzando `nsenter`, si accede allo spazio dei nomi di montaggio di Zygote. Zygote, essendo il processo responsabile del lancio delle applicazioni Android, richiede questo passaggio per garantire che tutte le applicazioni avviate successivamente utilizzino i nuovi certificati CA configurati. Il comando utilizzato √®:
```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
Ci√≤ assicura che ogni nuova app avviata si attenga alla configurazione aggiornata dei certificati CA.

4. **Applicazione delle modifiche alle app in esecuzione**: Per applicare le modifiche alle applicazioni gi√† in esecuzione, viene nuovamente utilizzato `nsenter` per accedere individualmente allo spazio dei nomi di ogni app e eseguire un bind mount simile. Il comando necessario √®:
```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- /bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```
5. **Approccio Alternativo - Soft Reboot**: Un metodo alternativo prevede di eseguire il bind mount sul processo `init` (PID 1), seguito da un soft reboot del sistema operativo con i comandi `stop && start`. Questo approccio propagherebbe le modifiche su tutti i namespace, evitando la necessit√† di affrontare singolarmente ogni app in esecuzione. Tuttavia, questo metodo √® generalmente meno preferito a causa dell'inconveniente del riavvio.

## Riferimenti
* [https://httptoolkit.com/blog/android-14-install-system-ca-certificate/](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
