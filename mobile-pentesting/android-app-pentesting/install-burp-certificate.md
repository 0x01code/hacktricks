# Instalar Certificado Burp

<details>

<summary><strong>Aprenda hacking em AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Em uma M√°quina Virtual

Primeiramente, voc√™ precisa baixar o certificado Der do Burp. Voc√™ pode fazer isso em _**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_

![](<../../.gitbook/assets/image (367).png>)

**Exporte o certificado no formato Der** e vamos **transform√°-lo** em um formato que o **Android** possa **entender.** Note que **para configurar o certificado do burp na m√°quina Android no AVD**, voc√™ precisa **executar** esta m√°quina com a op√ß√£o **`-writable-system`**.\
Por exemplo, voc√™ pode execut√°-la assim:

{% code overflow="wrap" %}
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
{% endcode %}

Em seguida, para **configurar o certificado do Burp, fa√ßa**:

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

Uma vez que a **m√°quina terminar de reiniciar**, o certificado Burp estar√° em uso por ela!

## Usando Magisc

Se voc√™ **rootou seu dispositivo com Magisc** (talvez um emulador), e voc√™ **n√£o consegue seguir** os **passos** anteriores para instalar o certificado Burp porque o **sistema de arquivos √© somente leitura** e voc√™ n√£o pode remont√°-lo para escrita, existe outra maneira.

Explicado [**neste v√≠deo**](https://www.youtube.com/watch?v=qQicUW0svB8), voc√™ precisa:

1. **Instalar um certificado CA**: Simplesmente **arraste e solte** o certificado Burp DER **mudando a extens√£o** para `.crt` no celular para que seja armazenado na pasta Downloads e v√° para `Instalar um certificado` -> `Certificado CA`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* Verifique se o certificado foi armazenado corretamente indo para `Credenciais confi√°veis` -> `USU√ÅRIO`

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. **Torn√°-lo confi√°vel pelo Sistema**: Baixe o m√≥dulo Magisc [MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts) (um arquivo .zip), **arraste e solte** no telefone, v√° para o **aplicativo Magics** no telefone na se√ß√£o **`M√≥dulos`**, clique em **`Instalar do armazenamento`**, selecione o m√≥dulo `.zip` e uma vez instalado **reinicie** o telefone:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* Ap√≥s reiniciar, v√° para `Credenciais confi√°veis` -> `SISTEMA` e verifique se o certificado Postswigger est√° l√°

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## P√≥s Android 14

Mudan√ßas:

* At√© agora, os certificados CA confi√°veis pelo sistema estavam em **`/system/etc/security/cacerts/`**. Em um emulador AOSP padr√£o, eles podiam ser **modificados diretamente com acesso root** com configura√ß√£o m√≠nima, tendo **efeito imediato em todo lugar**.
* No Android 14, os certificados CA confi√°veis pelo sistema geralmente estar√£o em **`/apex/com.android.conscrypt/cacerts`**, e todo o **`/apex` √© imut√°vel**.
* O caminho **APEX cacerts n√£o pode ser remontado como regrav√°vel** - remontagens simplesmente falham. De fato, mesmo que voc√™ desmonte todo o caminho de um shell root, os aplicativos ainda podem ler seus certificados sem problemas.
* A t√©cnica alternativa de **montar um diret√≥rio tmpfs por cima tamb√©m n√£o funciona** - mesmo que isso signifique que `ls /apex/com.android.conscrypt/cacerts` possa n√£o retornar nada (ou qualquer outra coisa que voc√™ queira), os aplicativos ainda ver√£o os mesmos dados originais.
* Porque a montagem `/apex` √© [explicitamente montada](https://cs.android.com/android/platform/superproject/main/+/main:system/core/init/mount\_namespace.cpp;l=97;drc=566c65239f1cf3fcb0d8745715e5ef1083d4bd3a) **com propaga√ß√£o PRIVADA**, de modo que todas as altera√ß√µes nas montagens dentro do caminho `/apex` nunca s√£o compartilhadas entre processos.

Isso √© feito pelo processo `init` que inicia o SO, que ent√£o lan√ßa o processo [Zygote](https://en.wikipedia.org/wiki/Booting\_process\_of\_Android\_devices#Zygote) (com um novo namespace de montagem copiado do pai, incluindo sua **pr√≥pria montagem `/apex` privada**), que por sua vez **inicia cada processo de aplicativo** sempre que um aplicativo √© lan√ßado no dispositivo (que cada um por sua vez ent√£o **copia essa mesma montagem `/apex` privada**).

### Remontando pontos de montagem recursivamente

* Voc√™ pode remontar `/apex` manualmente, removendo a propaga√ß√£o PRIVADA e tornando-o grav√°vel (ironicamente, parece que remover completamente a propaga√ß√£o privada _propaga_ em todo lugar)
* Voc√™ copia todo o conte√∫do de `/apex/com.android.conscrypt` para outro lugar
* Ent√£o voc√™ desmonta `/apex/com.android.conscrypt` completamente - removendo a montagem somente leitura que fornece imutavelmente este m√≥dulo
* Ent√£o voc√™ copia o conte√∫do de volta, para que ele viva diretamente na montagem `/apex`, onde ele pode ser modificado (voc√™ precisa fazer isso rapidamente, pois [aparentemente](https://infosec.exchange/@g1a55er/111069489513139531) voc√™ pode ver falhas de outra forma)
* Isso deve ter efeito imediato, mas eles recomendam matar `system_server` (reiniciando todos os aplicativos) para que tudo volte a um estado consistente
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### Bind-mounting atrav√©s do NSEnter

*   Primeiro, precisamos configurar um diret√≥rio grav√°vel em algum lugar. Para f√°cil compatibilidade com a abordagem existente, estou fazendo isso com um `tmpfs` montado sobre o diret√≥rio de certificados do sistema n√£o-APEX (ainda presente):

```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
* Em seguida, voc√™ coloca os certificados CA de seu interesse neste diret√≥rio (por exemplo, voc√™ pode querer copiar todos os padr√µes existentes no diret√≥rio de certificados CA `/apex/com.android.conscrypt/cacerts/`) e definir as permiss√µes e r√≥tulos SELinux apropriadamente.
*   Ent√£o, use `nsenter` para entrar no namespace de montagem do Zygote e montar este diret√≥rio sobre o diret√≥rio APEX:

```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```

O processo Zygote gera cada aplicativo, copiando seu namespace de montagem para fazer isso, ent√£o isso garante que todos os aplicativos rec√©m-lan√ßados (tudo que for iniciado a partir de agora) usar√£o isso.
*   Em seguida, use `nsenter` para entrar no namespace de cada aplicativo j√° em execu√ß√£o e fa√ßa o mesmo:

```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```

Alternativamente, se voc√™ n√£o se importar com a UX desajeitada, voc√™ deve ser capaz de fazer a montagem bind no `init` em si (PID 1) e depois executar `stop && start` para reiniciar suavemente o OS, recriando todos os namespaces e propagando suas mudan√ßas em todos os lugares (mas pessoalmente eu me importo com a reinicializa√ß√£o desajeitada, ent√£o estou ignorando completamente esse caminho).

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Obtenha o [**merchandising oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
