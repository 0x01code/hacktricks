# 安装Burp证书

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

## 在虚拟机上

首先，你需要从Burp中下载Der证书。你可以在_**Proxy**_ --> _**Options**_ --> _**Import / Export CA certificate**_中完成此操作。

![](<../../.gitbook/assets/image (367).png>)

**以Der格式导出证书**，然后将其转换为**Android**能够**理解的形式**。请注意，**为了在AVD中配置Burp证书**，你需要**使用**`-writable-system`**选项运行此虚拟机。\
例如，你可以这样运行它：
```bash
C:\Users\<UserName>\AppData\Local\Android\Sdk\tools\emulator.exe -avd "AVD9" -http-proxy 192.168.1.12:8080 -writable-system
```
然后，要**配置Burp的证书**，请执行以下操作：

{% code overflow="wrap" %}
```bash
openssl x509 -inform DER -in burp_cacert.der -out burp_cacert.pem
CERTHASHNAME="`openssl x509 -inform PEM -subject_hash_old -in burp_cacert.pem | head -1`.0"
mv burp_cacert.pem $CERTHASHNAME #Correct name
adb root && sleep 2 && adb remount #Allow to write on /syste
adb push $CERTHASHNAME /sdcard/ #Upload certificate
adb shell mv /sdcard/$CERTHASHNAME /system/etc/security/cacerts/ #Move to correct location
adb shell chmod 644 /system/etc/security/cacerts/$CERTHASHNAME #Assign privileges
adb reboot #Now, reboot the machine
```
{% endcode %}

一旦机器重新启动，Burp证书将被使用！

## 使用Magisc

如果您使用Magisc（可能是模拟器）对设备进行了root，而且由于文件系统是只读的，您无法按照之前的步骤安装Burp证书，也无法将其重新挂载为可写，请使用另一种方法。

在[**此视频**](https://www.youtube.com/watch?v=qQicUW0svB8)中解释了您需要：

1. **安装CA证书**：只需将DER Burp证书拖放到移动设备上，将扩展名更改为`.crt`，以便将其存储在下载文件夹中，然后转到“安装证书”->“CA证书”

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1).png" alt="" width="164"><figcaption></figcaption></figure>

* 检查证书是否正确存储，转到“受信任的凭据”->“用户”

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="334"><figcaption></figcaption></figure>

2. **使其成为系统信任的**：下载Magisc模块[MagiskTrustUserCerts](https://github.com/NVISOsecurity/MagiskTrustUserCerts)（一个.zip文件），将其拖放到手机上，转到手机上的Magics应用程序，转到“模块”部分，点击“从存储安装”，选择`.zip`模块，安装后**重新启动**手机：

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1).png" alt="" width="345"><figcaption></figcaption></figure>

* 重新启动后，转到“受信任的凭据”->“系统”，检查Postswigger证书是否存在

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1).png" alt="" width="314"><figcaption></figcaption></figure>

## Android 14之后

变更：

* 到目前为止，系统信任的CA证书位于**`/system/etc/security/cacerts/`**。在标准的AOSP模拟器上，可以使用根访问直接修改这些证书，立即在所有地方生效。
* 在Android 14中，系统信任的CA证书通常位于**`/apex/com.android.conscrypt/cacerts`**，而**`/apex`的所有内容都是不可变的**。
* 无法将**APEX cacerts路径重新挂载为可写** - 重新挂载会失败。实际上，即使您从根shell中卸载整个路径，应用程序仍然可以正常读取您的证书。
* 将tmpfs目录挂载到顶部的替代技术也无法工作 - 即使这意味着`ls /apex/com.android.conscrypt/cacerts`可能返回空（或任何其他您喜欢的内容），应用程序仍然会看到相同的原始数据。
* 因为`/apex`挂载是[显式挂载](https://cs.android.com/android/platform/superproject/main/+/main:system/core/init/mount\_namespace.cpp;l=97;drc=566c65239f1cf3fcb0d8745715e5ef1083d4bd3a)，使用私有传播，因此`/apex`路径内的挂载更改永远不会在进程之间共享。

这是由启动操作系统的`init`进程完成的，然后启动[Zygote进程](https://en.wikipedia.org/wiki/Booting\_process\_of\_Android\_devices#Zygote)（使用从父进程复制的新挂载命名空间，因此包括其自己的私有`/apex`挂载），然后依次启动每个应用程序进程，每当在设备上启动应用程序时（每个应用程序进程然后复制相同的私有`/apex`挂载）。

### 递归重新挂载挂载点

* 您可以手动重新挂载`/apex`，删除私有传播并使其可写（具有讽刺意味的是，似乎完全删除私有传播确实在所有地方传播）
* 您将整个`/apex/com.android.conscrypt`的内容复制到其他位置
* 然后完全卸载`/apex/com.android.conscrypt` - 删除不可变地提供此模块的只读挂载
* 然后将内容复制回来，使其直接位于`/apex`挂载中，可以进行修改（您需要快速执行此操作，因为[显然](https://infosec.exchange/@g1a55er/111069489513139531)否则可能会导致崩溃）
* 这应该立即生效，但他们建议杀死`system_server`（重新启动所有应用程序）以使一切恢复到一致的状态
```bash
# Create a separate temp directory, to hold the current certificates
# Otherwise, when we add the mount we can't read the current certs anymore.
mkdir -p -m 700 /data/local/tmp/tmp-ca-copy

# Copy out the existing certificates
cp /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/

# Create the in-memory mount on top of the system certs folder
mount -t tmpfs tmpfs /system/etc/security/cacerts

# Copy the existing certs back into the tmpfs, so we keep trusting them
mv /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/

# Copy our new cert in, so we trust that too
mv $CERTIFICATE_PATH /system/etc/security/cacerts/

# Update the perms & selinux context labels
chown root:root /system/etc/security/cacerts/*
chmod 644 /system/etc/security/cacerts/*
chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*

# Deal with the APEX overrides, which need injecting into each namespace:

# First we get the Zygote process(es), which launch each app
ZYGOTE_PID=$(pidof zygote || true)
ZYGOTE64_PID=$(pidof zygote64 || true)
# N.b. some devices appear to have both!

# Apps inherit the Zygote's mounts at startup, so we inject here to ensure
# all newly started apps will see these certs straight away:
for Z_PID in "$ZYGOTE_PID" "$ZYGOTE64_PID"; do
if [ -n "$Z_PID" ]; then
nsenter --mount=/proc/$Z_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
fi
done

# Then we inject the mount into all already running apps, so they
# too see these CA certs immediately:

# Get the PID of every process whose parent is one of the Zygotes:
APP_PIDS=$(
echo "$ZYGOTE_PID $ZYGOTE64_PID" | \
xargs -n1 ps -o 'PID' -P | \
grep -v PID
)

# Inject into the mount namespace of each of those apps:
for PID in $APP_PIDS; do
nsenter --mount=/proc/$PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &
done
wait # Launched in parallel - wait for completion here

echo "System certificate injected"
```
### 通过 NSEnter 进行绑定挂载

*   首先，我们需要在某个地方设置一个可写目录。为了与现有方法轻松兼容，我使用 `tmpfs` 挂载在（仍然存在的）非 APEX 系统证书目录上：

```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
```
* 然后，将你感兴趣的 CA 证书放入此目录中（例如，你可能想从现有的 `/apex/com.android.conscrypt/cacerts/` CA 证书目录中复制所有默认证书），并适当设置权限和 SELinux 标签。
*   然后，使用 `nsenter` 进入 Zygote 的挂载命名空间，并将此目录绑定到 APEX 目录上：

```bash
nsenter --mount=/proc/$ZYGOTE_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```

Zygote 进程会生成每个应用程序，复制其挂载命名空间以完成此操作，因此这确保了所有新启动的应用程序（从现在开始的所有内容）都将使用此目录。
*   然后，使用 `nsenter` 进入每个已运行应用程序的命名空间，并执行相同的操作：

```bash
nsenter --mount=/proc/$APP_PID/ns/mnt -- \
/bin/mount --bind /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts
```

或者，如果你不介意笨拙的用户体验，你应该能够在 `init` 本身（PID 1）上进行绑定挂载，然后运行 `stop && start` 来软重启操作系统，重新创建所有命名空间并传播你的更改（但个人上我不介意笨拙的重启，所以我完全忽略了这条路线）。

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家 **网络安全公司** 工作吗？想要在 HackTricks 中 **为你的公司做广告** 吗？或者想要访问 **PEASS 的最新版本或下载 PDF 格式的 HackTricks** 吗？请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family) 集合 - [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass)，或在 **Twitter** 上 **关注** 我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>
