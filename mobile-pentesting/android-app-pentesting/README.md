# Testowanie penetracyjne aplikacji Android

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Dołącz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hakerami i łowcami nagród za błędy!

**Wgląd w hakerstwo**\
Zajmuj się treściami, które zagłębiają się w emocje i wyzwania hakerstwa

**Aktualności na żywo z hakerstwa**\
Bądź na bieżąco z szybkim tempem świata hakerstwa dzięki aktualnym wiadomościom i wglądom

**Najnowsze ogłoszenia**\
Bądź na bieżąco z najnowszymi programami nagród za błędy i ważnymi aktualizacjami platformy

**Dołącz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hakerami już dziś!

## Podstawy aplikacji Android

Zaleca się zapoznanie się z tą stroną, aby dowiedzieć się o **najważniejszych częściach związanych z bezpieczeństwem Androida i najbardziej niebezpiecznych komponentach w aplikacji Android**:

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB (Android Debug Bridge)

To jest główne narzędzie, które potrzebujesz do połączenia się z urządzeniem Android (emulowanym lub fizycznym).\
**ADB** umożliwia kontrolowanie urządzeń zarówno przez **USB**, jak i przez **sieć** z komputera. Narzędzie to umożliwia **kopiowanie** plików w obie strony, **instalowanie** i **odinstalowywanie** aplikacji, **wykonywanie** poleceń powłoki, **tworzenie kopii zapasowych** danych, **odczytywanie** logów i wiele innych funkcji.

Zajrzyj do poniższej listy [**Polecenia ADB**](adb-commands.md), aby dowiedzieć się, jak korzystać z adb.

## Smali

Czasami interesujące jest **modyfikowanie kodu aplikacji**, aby uzyskać dostęp do **ukrytych informacji** (może to być dobrze zaszyfrowane hasła lub flagi). W takim przypadku warto zdekompilować plik apk, zmodyfikować kod i ponownie go skompilować.\
[**W tym samouczku** możesz **nauczyć się, jak zdekompilować APK, zmodyfikować kod Smali i ponownie skompilować APK** z nową funkcjonalnością](smali-changes.md). Może to być bardzo przydatne jako **alternatywa dla kilku testów podczas analizy dynamicznej**, które zostaną przedstawione. Pamiętaj zawsze o tej możliwości.

## Inne interesujące sztuczki

* [Podrabianie lokalizacji w Sklepie Play](spoofing-your-location-in-play-store.md)
* **Pobierz APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* Wyodrębnij APK z urządzenia:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
## Analiza statyczna

Po pierwsze, do analizy pliku APK powinieneś **przejrzeć kod Java** za pomocą dekompilatora.\
Proszę, [**przeczytaj tutaj, aby znaleźć informacje o dostępnych dekompilatorach**](apk-decompilers.md).

### Szukanie interesujących informacji

Po prostu przeglądając **ciągi znaków** w pliku APK, możesz szukać **haseł**, **adresów URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **kluczy API**, **szyfrowania**, **identyfikatorów UUID Bluetooth**, **tokenów** i wszystkiego, co może być interesujące... poszukaj nawet **tylnych drzwi** do wykonania kodu lub tylnych drzwi uwierzytelniania (domyślne dane uwierzytelniania dla aplikacji).

**Firebase**

Zwróć szczególną uwagę na **adresy URL Firebase** i sprawdź, czy są źle skonfigurowane. [Więcej informacji na temat tego, czym jest Firebase i jak go wykorzystać, znajdziesz tutaj.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Podstawowe zrozumienie aplikacji - Manifest.xml, strings.xml

**Badanie plików _Manifest.xml_ i _strings.xml_ aplikacji może ujawnić potencjalne podatności bezpieczeństwa**. Te pliki można uzyskać za pomocą dekompilatorów lub zmieniając rozszerzenie pliku APK na .zip, a następnie rozpakowując go.

**Podatności** zidentyfikowane w pliku **Manifest.xml** obejmują:

* **Aplikacje debugowalne**: Aplikacje oznaczone jako debugowalne (`debuggable="true"`) w pliku _Manifest.xml_ stanowią ryzyko, ponieważ pozwalają na połączenia, które mogą prowadzić do wykorzystania. Aby lepiej zrozumieć, jak wykorzystać aplikacje debugowalne, zapoznaj się z samouczkiem dotyczącym wyszukiwania i wykorzystywania aplikacji debugowalnych na urządzeniu.

* **Ustawienia kopii zapasowych**: Atrybut `android:allowBackup="false"` powinien być jawnie ustawiony dla aplikacji zajmujących się wrażliwymi informacjami, aby zapobiec nieautoryzowanym kopiom zapasowym danych za pomocą adb, zwłaszcza gdy włączone jest debugowanie USB.

* **Bezpieczeństwo sieci**: Niestandardowe konfiguracje bezpieczeństwa sieciowego (`android:networkSecurityConfig="@xml/network_security_config"`) w _res/xml/_ mogą określać szczegóły dotyczące zabezpieczeń, takie jak piny certyfikatów i ustawienia ruchu HTTP. Przykładem jest zezwolenie na ruch HTTP dla określonych domen.

* **Eksportowane aktywności i usługi**: Identyfikacja eksportowanych aktywności i usług w manifeście może wskazać na komponenty, które mogą być nadużywane. Dalsza analiza podczas testów dynamicznych może ujawnić, jak wykorzystać te komponenty.

* **Dostawcy treści i dostawcy plików**: Ujawnione dostawcy treści mogą umożliwiać nieautoryzowany dostęp lub modyfikację danych. Konfiguracja dostawców plików powinna również być dokładnie przeanalizowana.

* **Odbiorniki rozgłoszeniowe i schematy URL**: Te komponenty mogą być wykorzystane do wykorzystania, szczególną uwagę należy zwrócić na zarządzanie schematami URL w celu wykrycia podatności wejściowych.

* **Wersje SDK**: Atrybuty `minSdkVersion`, `targetSDKVersion` i `maxSdkVersion` wskazują obsługiwane wersje Androida, podkreślając ważność nieobsługiwania przestarzałych, podatnych wersji Androida ze względów bezpieczeństwa.

Z pliku **strings.xml** można odkryć wrażliwe informacje, takie jak klucze API, niestandardowe schematy i inne notatki dla programistów, co podkreśla konieczność dokładnego przeglądu tych zasobów.


### Tapjacking

**Tapjacking** to atak, w którym **złośliwa aplikacja** jest uruchamiana i **umieszcza się na wierzchu aplikacji ofiary**. Gdy zasłania ona widocznie aplikację ofiary, jej interfejs użytkownika jest zaprojektowany w taki sposób, aby oszukać użytkownika do interakcji z nią, podczas gdy przekazuje interakcję do aplikacji ofiary.\
W efekcie, **ślepi użytkownika, aby nie wiedział, że faktycznie wykonuje czynności na aplikacji ofiary**.

Dowiedz się więcej:

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### Przechwytywanie zadań

Aktywność z ustawionym **`launchMode`** na **`singleTask` bez zdefiniowanego `taskAffinity`** jest podatna na przechwytywanie zadań. Oznacza to, że **aplikacja** może zostać zainstalowana i jeśli zostanie uruchomiona przed prawdziwą aplikacją, może **przechwycić zadanie prawdziwej aplikacji** (użytkownik będzie więc korzystał z **złośliwej aplikacji, myśląc, że korzysta z prawdziwej**).

Więcej informacji:

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### Niewłaściwe przechowywanie danych

**Wewnętrzne przechowywanie**

W systemie Android pliki **przechowywane** w **wewnętrznym** przechowywaniu są **przeznaczone** do **dostępu** wyłącznie przez **aplikację**, która je **utworzyła**. Ta środek bezpieczeństwa jest **egzekwowany** przez system operacyjny Android i jest zazwyczaj wystarczający dla większości aplikacji. Jednak programiści czasami korzystają z trybów takich jak `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE`, aby **umożliwić** udostępnianie plików między różnymi aplikacjami. Niemniej jednak te tryby **nie ograniczają dostępu** do tych plików przez inne aplikacje, w tym potencjalnie złośliwe.

1. **Analiza statyczna:**
- **Upewnij się**, że korzystanie z `MODE_WORLD_READABLE` i `MODE_WORLD_WRITABLE` jest **dokładnie sprawdzane**. Te tryby **mogą potencjalnie ujawnić** pliki **niezamierzonego lub nieautoryzowanego dostępu**.

2. **Analiza dynamiczna:**
- **Zweryfikuj** uprawnienia ustawione dla plików utworzonych przez aplikację. W szczególności **sprawdź**, czy jakiekolwiek pliki są **ustawione jako czytelne lub zapisywalne dla wszystkich**. Może to stanowić poważne ryzyko bezpieczeństwa, ponieważ pozwoliłoby to **dowolnej aplikacji** zainstalowanej na urządzeniu, niezależnie od jej pochodzenia lub intencji, na **odczytanie lub modyfikację** tych plików.

**Zewnętrzne przechowywanie**

Przy pracy z plikami na **zewnętrznym przechowywaniu**, takim jak karty SD, należy podjąć pewne środki ostrożności:

1. **Dostępność**:
- Pliki na zewnętrznym przechowywaniu są **globalnie czytelne i zapisywalne**. Oznacza to, że dowolna aplikacja lub użytkownik może uzyskać do nich dostęp.

2. **Kwestie bezpieczeństwa**:
- Ze względu na łatwość dostępu, zaleca się **nie przechowywać wrażliwych informacji** na zewnętrznym przechowywaniu.
- Zewnętrzne przechowywanie można usunąć lub uzyskać do niego dostęp przez dowolną aplikację, co czyni je mniej bezpiecznym.

3. **Obsługa danych z zewnętrznego przechowywania**:
- Zawsze **przeprowadzaj walidację danych** pobranych z zewnętrznego przechowywania. Jest to istotne, ponieważ dane pochodzą z niewiarygodnego źródła.
- Silnie odradza się przechowywanie plików wykonywalnych lub plików klas na zewnę
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Dobrym sposobem na przetestowanie tego jest próba przechwycenia ruchu za pomocą takiego proxy jak Burp, bez autoryzacji certyfikatu CA Burp w urządzeniu. Można również wygenerować za pomocą Burp certyfikat dla innego hosta i go użyć.

### Słabe szyfrowanie

**Niewłaściwe procesy zarządzania kluczami**

Niektórzy programiści zapisują wrażliwe dane w lokalnym magazynie i szyfrują je kluczem wpisanym/wykrywalnym w kodzie. Nie powinno się tego robić, ponieważ odwrócenie tego może umożliwić atakującym wydobycie poufnych informacji.

**Użycie niebezpiecznych i/lub przestarzałych algorytmów**

Programiści nie powinni używać **przestarzałych algorytmów** do wykonywania **sprawdzeń** autoryzacji, **przechowywania** lub **wysyłania** danych. Niektóre z tych algorytmów to: RC4, MD4, MD5, SHA1... Jeśli używane są **skróty** do przechowywania haseł na przykład, powinny być używane odporne na ataki brute-force skróty z solą.

### Inne sprawdzenia

* Zaleca się **zaciemnienie APK**, aby utrudnić odwrócenie inżynierii przez atakujących.
* Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna sprawdzać, czy urządzenie mobilne jest zrootowane i działać odpowiednio.
* Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna sprawdzać, czy używany jest emulator.
* Jeśli aplikacja jest wrażliwa (np. aplikacje bankowe), powinna **sprawdzać swoją integralność przed wykonaniem**, aby sprawdzić, czy nie została zmodyfikowana.
* Użyj [**APKiD**](https://github.com/rednaga/APKiD), aby sprawdzić, jakiego kompilatora/pakera/zaciemniacza użyto do budowy APK.

### Aplikacja React Native

Przeczytaj następującą stronę, aby dowiedzieć się, jak łatwo uzyskać dostęp do kodu JavaScript aplikacji React:

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Aplikacje Xamarin

Przeczytaj następującą stronę, aby dowiedzieć się, jak łatwo uzyskać dostęp do kodu C# aplikacji Xamarin:

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### Superpacked Applications

Według tego [**postu na blogu**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked to metaalgorytm, który kompresuje zawartość aplikacji do jednego pliku. Blog omawia możliwość stworzenia aplikacji, która dekompresuje tego rodzaju aplikacje... oraz szybszy sposób, który polega na **wykonaniu aplikacji i zebraniu zdekompresowanych plików z systemu plików**.

### Automatyczna statyczna analiza kodu

Narzędzie [**mariana-trench**](https://github.com/facebook/mariana-trench) jest zdolne do znajdowania **podatności** poprzez **skanowanie** kodu aplikacji. Narzędzie to zawiera szereg **znanych źródeł** (które wskazują narzędziu **miejsca**, w których **wejście** jest **kontrolowane przez użytkownika**), **ujść** (które wskazują narzędziu **niebezpieczne miejsca**, w których złośliwe wejście użytkownika może spowodować szkody) i **reguł**. Te reguły wskazują **kombinację źródeł-ujść**, która wskazuje na podatność.

Dzięki tej wiedzy **mariana-trench przejrzy kod i znajdzie w nim możliwe podatności**.

### Wycieki poufnych informacji

Aplikacja może zawierać poufne informacje (klucze API, hasła, ukryte adresy URL, subdomeny...), które można odkryć. Można użyć narzędzia takiego jak [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Ominięcie uwierzytelniania biometrycznego

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### Inne interesujące funkcje

* **Wykonanie kodu**: `Runtime.exec(), ProcessBuilder(), native code:system()`
* **Wysyłanie SMS-ów**: `sendTextMessage, sendMultipartTestMessage`
* **Funkcje natywne** zadeklarowane jako `native`: `public native, System.loadLibrary, System.load`
* [Przeczytaj to, aby dowiedzieć się, **jak odwrócić funkcje natywne**](reversing-native-libraries.md)

### **Inne sztuczki**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Dołącz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hakerami i łowcami błędów!

**Wgląd w hakerstwo**\
Zajmuj się treściami, które zagłębiają się w emocje i wyzwania hakerstwa

**Aktualności na żywo z hakerstwa**\
Bądź na bieżąco z szybkim tempem świata hakerstwa dzięki aktualnym wiadomościom i wglądom

**Najnowsze ogłoszenia**\
Bądź na bieżąco z najnowszymi programami bug bounty i ważnymi aktualizacjami platformy

**Dołącz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hakerami już dziś!

***

## Analiza dynamiczna

> Przede wszystkim potrzebujesz środowiska, w którym możesz zainstalować aplikację i całe środowisko (certyfikat CA Burp, Drozer i Frida przede wszystkim). Dlatego też zaleca się korzystanie z zrootowanego urządzenia (emulowanego lub nie).

### Analiza dynamiczna online

Możesz założyć **darmowe konto** na stronie: [https://appetize.io/](https://appetize.io). Ta platforma pozwala na **przesyłanie** i **wykonywanie** APK, więc jest przydatna do sprawdzania zachowania aplikacji.

Możesz nawet **obejrzeć dzienniki swojej aplikacji** w sieci i połączyć się za pomocą **adb**.

![](<../../.gitbook/assets/image (60).png>)

Dzięki połączeniu ADB możesz używać narzędzi **Drozer** i **Frida** w emulatorach.

### Lokalna analiza dynamiczna

#### Używanie emulatora

* [**Android Studio**](https://developer.android.com/studio) (Możesz tworzyć urządzenia **x86** i **arm**, a według [**tego** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**najnowsze wersje x86** **obsługują biblioteki ARM** bez potrzeby wolnego emulatora arm).
* Dowiedz się, jak go skonfigurować na tej stronie:

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Wersja darmowa:** Personal Edition, musisz założyć konto. _Zaleca się **pobranie** wersji **Z**_ _**VirtualBoxem**_, aby uniknąć potencjalnych błędów._)
* [**Nox**](https://es.bignox.com) (Darmowy, ale nie obsługuje Fridy ani Drozera).

{% hint style="info" %}
Tworząc nowy emulator na dowolnej platformie, pamiętaj, że im większy jest ekran, tym wolniej będzie działał emulator. Wybieraj więc małe ekrany, jeśli to możliwe.
{% endhint %}

Aby **zainstalować usługi Google** (takie jak AppStore) w Genymotion, musisz kliknąć na oznaczony na czerwono przycisk na poniższym obrazie:

![](<../../.gitbook/assets/image (200) (1).png>)

Zauważ również, że w **konfiguracji maszyny wirtualnej
#### Użyj fizycznego urządzenia

Musisz aktywować opcje **debugowania**, a jeśli możesz, to **zrootować** urządzenie:

1. **Ustawienia**.
2. (Od Androida 8.0) Wybierz **System**.
3. Wybierz **Informacje o telefonie**.
4. Naciśnij **Numer kompilacji** 7 razy.
5. Wróć i znajdź **Opcje programistyczne**.

> Po zainstalowaniu aplikacji, pierwszą rzeczą, którą powinieneś zrobić, to przetestować ją i zbadać, co robi, jak działa i zapoznać się z nią.\
> Sugeruję **wykonać tę początkową analizę dynamiczną za pomocą analizy dynamicznej MobSF + pidcat**, dzięki czemu będziemy mogli **zrozumieć, jak działa aplikacja**, podczas gdy MobSF **przechwytuje** wiele **ciekawych** **danych**, które można później przejrzeć.

### Niewłaściwe wycieki danych

**Logowanie**

Deweloperzy powinni być ostrożni przy publicznym ujawnianiu informacji **debugowania**, ponieważ może to prowadzić do wycieku poufnych danych. Zaleca się korzystanie z narzędzi [**pidcat**](https://github.com/JakeWharton/pidcat) i `adb logcat` do monitorowania logów aplikacji w celu identyfikacji i ochrony poufnych informacji. **Pidcat** jest preferowany ze względu na łatwość użycia i czytelność.

{% hint style="warning" %}
Zauważ, że od **nowszych wersji Androida niż 4.0**, **aplikacje mogą uzyskać dostęp tylko do swoich własnych logów**. Aplikacje nie mogą uzyskać dostępu do logów innych aplikacji.\
W każdym przypadku zaleca się **nie logować poufnych informacji**.
{% endhint %}

**Bufor schowka**

Androidowa struktura oparta na **schowku** umożliwia funkcję kopiuj-wklej w aplikacjach, ale stanowi ryzyko, ponieważ **inne aplikacje** mogą **uzyskać dostęp** do schowka, co może prowadzić do ujawnienia poufnych danych. Ważne jest **wyłączenie funkcji kopiuj-wklej** dla wrażliwych sekcji aplikacji, takich jak dane karty kredytowej, aby zapobiec wyciekom danych.

**Logi awarii**

Jeśli aplikacja **zawiesi się** i **zapisze logi**, te logi mogą pomóc atakującym, zwłaszcza gdy aplikacja nie może być zreversowana. Aby zmniejszyć to ryzyko, unikaj logowania podczas awarii, a jeśli logi muszą być przesyłane przez sieć, upewnij się, że są wysyłane za pomocą kanału SSL w celu zapewnienia bezpieczeństwa.

Jako pentester, **spróbuj przejrzeć te logi**.

**Wysyłanie danych analitycznych do stron trzecich**

Aplikacje często integrują usługi takie jak Google Adsense, które nieumyślnie mogą **wyciekać poufne dane** z powodu niewłaściwej implementacji przez deweloperów. Aby zidentyfikować potencjalne wycieki danych, zaleca się **przechwycenie ruchu aplikacji** i sprawdzenie, czy wysyłane są jakiekolwiek poufne informacje do usług stron trzecich.

### Bazy danych SQLite

Większość aplikacji korzysta z **wewnętrznych baz danych SQLite** do przechowywania informacji. Podczas pentestu **sprawdź** utworzone **bazy danych**, nazwy **tabel** i **kolumny** oraz wszystkie **dane**, ponieważ możesz znaleźć **wrażliwe informacje** (co stanowiłoby podatność).\
Bazy danych powinny znajdować się w lokalizacji `/data/data/nazwa.pakietu/bazydanych`, na przykład `/data/data/com.mwr.example.sieve/bazydanych`

Jeśli baza danych przechowuje poufne informacje i jest **zaszyfrowana**, ale możesz **znaleźć** hasło **wewnątrz aplikacji**, to wciąż jest to **podatność**.

Wylicz tabele za pomocą `.tables` i wylicz kolumny tabel za pomocą `.schema <nazwa_tabeli>`

### Drozer (Wykorzystywanie działań, dostawców treści i usług)

Z [Dokumentacji Drozer](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** pozwala ci **przyjąć rolę aplikacji Androidowej** i współdziałać z innymi aplikacjami. Może robić **wszystko, co może zrobić zainstalowana aplikacja**, takie jak korzystanie z mechanizmu komunikacji międzyprocesowej (IPC) Androida i współdziałanie z podstawowym systemem operacyjnym.\
Drozer jest przydatnym narzędziem do **wykorzystywania działań, dostawców treści i usług eksportowanych**, o czym dowiesz się w kolejnych sekcjach.

### Wykorzystywanie działań eksportowanych

[**Przeczytaj to, jeśli chcesz odświeżyć sobie, czym jest Android Activity.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Pamiętaj również, że kod aktywności zaczyna się w metodzie **`onCreate`**.

**Ominięcie autoryzacji**

Gdy aktywność jest eksportowana, można ją wywołać z zewnętrznej aplikacji. Dlatego jeśli aktywność zawiera **wrażliwe informacje** i jest **eksportowana**, można **ominąć** mechanizmy **uwierzytelniania**, aby uzyskać do niej dostęp.

[**Dowiedz się, jak wykorzystać eksportowane aktywności za pomocą Drozera.**](drozer-tutorial/#activities)

Możesz również uruchomić eksportowaną aktywność z poziomu adb:

* Nazwa pakietu to com.example.demo
* Nazwa eksportowanej aktywności to com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**UWAGA**: MobSF wykryje jako złośliwe użycie _**singleTask/singleInstance**_ jako `android:launchMode` w aktywności, ale ze względu na [to](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), wydaje się, że jest to niebezpieczne tylko w starych wersjach (wersje API < 21).

{% hint style="info" %}
Należy pamiętać, że bypass autoryzacji nie zawsze jest podatnością, zależy to od tego, jak działa bypass i jakie informacje są ujawniane.
{% endhint %}

**Wyciek wrażliwych informacji**

**Aktywności mogą również zwracać wyniki**. Jeśli uda ci się znaleźć eksportowaną i niechronioną aktywność, która wywołuje metodę **`setResult`** i **zwraca wrażliwe informacje**, mamy do czynienia z wyciekiem wrażliwych informacji.

#### Tapjacking

Jeśli nie jest zapobiegane tapjackingowi, możesz wykorzystać eksportowaną aktywność, aby **użytkownik wykonał nieoczekiwane czynności**. Aby uzyskać więcej informacji na temat [**czym jest Tapjacking, kliknij tutaj**](./#tapjacking).

### Wykorzystywanie dostawców treści - dostęp i manipulacja wrażliwymi informacjami

[**Przeczytaj to, jeśli chcesz odświeżyć sobie, czym jest dostawca treści.**](android-applications-basics.md#content-provider)\
Dostawcy treści są używani do **udostępniania danych**. Jeśli aplikacja udostępnia dostawców treści, możesz próbować **wydobyć wrażliwe** dane z nich. Warto również przetestować możliwe **wstrzyknięcia SQL** i **przechodzenie ścieżek**, ponieważ mogą być podatne na ataki.

[**Dowiedz się, jak wykorzystać dostawców treści za pomocą Drozera.**](drozer-tutorial/#content-providers)

### **Wykorzystywanie usług**

[**Przeczytaj to, jeśli chcesz odświeżyć sobie, czym jest usługa.**](android-applications-basics.md#services)\
Pamiętaj, że działania usługi rozpoczynają się w metodzie `onStartCommand`.

Usługa to podstawowo coś, co **może otrzymywać dane**, **przetwarzać** je i **zwracać** (lub nie) odpowiedź. Jeśli aplikacja eksportuje jakieś usługi, powinieneś **sprawdzić** kod, aby zrozumieć, co robi, i **testować** go **dynamicznie**, aby wydobywać poufne informacje, omijać środki autoryzacji...\
[**Dowiedz się, jak wykorzystać usługi za pomocą Drozera.**](drozer-tutorial/#services)

### **Wykorzystywanie odbiorników rozgłoszeń**

[**Przeczytaj to, jeśli chcesz odświeżyć sobie, czym jest odbiornik rozgłoszeń.**](android-applications-basics.md#broadcast-receivers)\
Pamiętaj, że działania odbiornika rozgłoszeń rozpoczynają się w metodzie `onReceive`.

Odbiornik rozgłoszeń będzie oczekiwał na określony typ wiadomości. W zależności od tego, jak odbiornik obsługuje wiadomość, może być podatny na ataki.\
[**Dowiedz się, jak wykorzystać odbiorniki rozgłoszeń za pomocą Drozera.**](./#exploiting-broadcast-receivers)

### **Wykorzystywanie schematów / głębokich linków**

Możesz ręcznie szukać głębokich linków, używając narzędzi takich jak MobSF lub skryptów, na przykład [ten](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Możesz **otworzyć** deklarowany **schemat** za pomocą **adb** lub **przeglądarki**:

{% code overflow="wrap" %}
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_Zauważ, że możesz **pominąć nazwę pakietu** i telefon automatycznie wywoła aplikację, która powinna otworzyć ten link._

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**Wykonany kod**

Aby znaleźć **kod, który zostanie wykonany w aplikacji**, przejdź do aktywności wywołanej przez deep link i wyszukaj funkcję **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**Czułe informacje**

Zawsze, gdy znajdziesz deep link, sprawdź, czy **nie otrzymuje on wrażliwych danych (takich jak hasła) za pomocą parametrów URL**, ponieważ inna aplikacja może **udawać deep link i kraść te dane!**

**Parametry w ścieżce**

Musisz również sprawdzić, czy jakikolwiek deep link używa parametru wewnątrz ścieżki URL, na przykład: `https://api.example.com/v1/users/{username}`, w takim przypadku możesz wymusić przechodzenie ścieżki, uzyskując dostęp do czegoś takiego jak: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Zauważ, że jeśli znajdziesz poprawne punkty końcowe w aplikacji, możesz spowodować **przekierowanie otwarte** (jeśli część ścieżki jest używana jako nazwa domeny), **przejęcie konta** (jeśli możesz modyfikować dane użytkowników bez tokenu CSRF i podatny punkt końcowy używał poprawnej metody) i inne podatności. Więcej [informacji na ten temat tutaj](http://dphoeniixx.com/2020/12/13-2/).

**Więcej przykładów**

[Interesujący raport o nagrodach za błędy](https://hackerone.com/reports/855618) dotyczący linków (_/.well-known/assetlinks.json_).

### Błędy weryfikacji i inspekcji warstwy transportowej

- **Certyfikaty nie są zawsze odpowiednio sprawdzane** przez aplikacje Android. Często te aplikacje pomijają ostrzeżenia i akceptują samopodpisane certyfikaty lub, w niektórych przypadkach, wracają do korzystania z połączeń HTTP.
- **Negocjacje podczas ustanawiania połączenia SSL/TLS są czasami słabe**, korzystając z niebezpiecznych zestawów szyfrów. Ta podatność sprawia, że połączenie jest podatne na ataki typu man-in-the-middle (MITM), umożliwiając atakującym odszyfrowanie danych.
- **Wyciek prywatnych informacji** stanowi ryzyko, gdy aplikacje uwierzytelniają się za pomocą bezpiecznych kanałów, a następnie komunikują się za pomocą niezabezpieczonych kanałów w przypadku innych transakcji. Taki sposób postępowania nie chroni wrażliwych danych, takich jak ciasteczka sesji lub dane użytkownika, przed przechwyceniem przez złośliwe podmioty.

#### Weryfikacja certyfikatu

Skupimy się na **weryfikacji certyfikatu**. Aby zwiększyć bezpieczeństwo, konieczne jest sprawdzenie integralności certyfikatu serwera. Jest to istotne, ponieważ niebezpieczne konfiguracje TLS i przesyłanie wrażliwych danych przez niezaszyfrowane kanały może stanowić znaczne ryzyko. Szczegółowe kroki dotyczące weryfikacji certyfikatów serwera i usuwania podatności znajdziesz w **[tym źródle](https://manifestsecurity.com/android-application-security-part-10/)**.

#### SSL Pinning

SSL Pinning to środek bezpieczeństwa, w którym aplikacja weryfikuje certyfikat serwera w stosunku do znanego egzemplarza przechowywanego w samej aplikacji. Ta metoda jest niezbędna do zapobiegania atakom typu man-in-the-middle (MITM). Zaleca się zdecydowanie implementację SSL Pinning w aplikacjach obsługujących wrażliwe informacje.

#### Inspekcja ruchu

Aby inspirować ruch HTTP, konieczne jest **zainstalowanie certyfikatu narzędzia proxy** (np. Burp). Bez zainstalowania tego certyfikatu, zaszyfrowany ruch może nie być widoczny przez proxy. Przewodnik dotyczący instalacji niestandardowego certyfikatu CA znajdziesz **[tutaj](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)**.

Aplikacje docelowe **API Level 24 i wyższe** wymagają modyfikacji konfiguracji zabezpieczeń sieciowych w celu zaakceptowania certyfikatu CA proxy. Ten krok jest kluczowy dla inspekcji zaszyfrowanego ruchu. Instrukcje dotyczące modyfikacji konfiguracji zabezpieczeń sieciowych znajdziesz **[w tym samouczku](make-apk-accept-ca-certificate.md)**.

#### Omijanie SSL Pinning

Kiedy jest wdrożone SSL Pinning, konieczne jest jego ominięcie w celu inspekcji ruchu HTTPS. Dostępne są różne metody w tym celu:

* Automatyczne **modyfikowanie** **apk** w celu **ominięcia** SSL Pinning za pomocą [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Największą zaletą tej opcji jest to, że nie będziesz potrzebować uprawnień root do ominięcia SSL Pinning, ale będziesz musiał usunąć aplikację i zainstalować nową, a to nie zawsze zadziała.
* Możesz użyć **Frida** (omówione poniżej), aby ominąć tę ochronę. Oto przewodnik dotyczący korzystania z Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
* Możesz również spróbować **automatycznego omijania SSL Pinning** za pomocą [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* Możesz również spróbować **automatycznego omijania SSL Pinning** za pomocą **analizy dynamicznej MobSF** (wyjaśnionej poniżej)
* Jeśli nadal uważasz, że istnieje jakiś ruch, którego nie przechwytujesz, możesz spróbować **przekierować ruch do burp za pomocą iptables**. Przeczytaj ten blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Wyszukiwanie powszechnych podatności sieciowych

Ważne jest również wyszukiwanie powszechnych podatności sieciowych w aplikacji. Szczegółowe informacje dotyczące identyfikacji i łagodzenia tych podatności wykraczają poza zakres tego podsumowania, ale są szeroko omówione w innych miejscach.

### Frida

[Frida](https://www.frida.re) to dynamiczne narzędzie do instrumentacji dla programistów, inżynierów odwracających i badaczy zabezpieczeń.\
**Możesz uzyskać dostęp do działającej aplikacji i podłączyć się do metod w czasie rzeczywistym, aby zmienić zachowanie, zmienić wartości, wyodrębnić wartości, uruchomić inny kod...**\
Jeśli chcesz przeprowadzać testy penetracyjne aplikacji Android, musisz wiedzieć, jak korzystać z Fridy.

* Dowiedz się, jak korzystać z Fridy: [**Samouczek Frida**](frida-tutorial/)
* Kilka "GUI" do działań z Fridą: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
* Ojection jest świetne do automatyzacji korzystania z Fridy: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
* Kilka niesamowitych skryptów Frida znajdziesz tutaj: [**https://codeshare.frida.re/**](https://codeshare.frida.re)

### **Dumpowanie pamięci - Fridump**

Sprawdź, czy aplikacja przechowuje wrażliwe informacje w pamięci, których nie powinna przechowywać, takie jak hasła lub mnemoniki.

Za pomocą [**Fridump3**](https://github.com/rootbsd/fridump3) możesz zrzucić pamięć aplikacji za pomocą:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
To spowoduje zrzut pamięci do folderu ./dump, a następnie możesz użyć polecenia grep, na przykład: 

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Wrażliwe dane w Keystore**

W systemie Android Keystore jest najlepszym miejscem do przechowywania wrażliwych danych, jednakże, przy odpowiednich uprawnieniach wciąż jest **możliwe uzyskanie do nich dostępu**. Ponieważ aplikacje mają tendencję do przechowywania tutaj **wrażliwych danych w postaci tekstu jawnego**, testy penetracyjne powinny to sprawdzić, ponieważ użytkownik z uprawnieniami root lub osoba mająca fizyczny dostęp do urządzenia może je ukraść.

Nawet jeśli aplikacja przechowuje dane w keystore, dane te powinny być zaszyfrowane.

Aby uzyskać dostęp do danych wewnątrz keystore, można użyć tego skryptu Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Ominięcie odcisku palca/biometrii**

Za pomocą poniższego skryptu Frida można próbować **ominąć uwierzytelnianie odciskiem palca** wykonywane przez aplikacje Android w celu **ochrony określonych obszarów o dużej wrażliwości:**

{% code overflow="wrap" %}
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **Obrazy tła**

Gdy przenosisz aplikację do tła, Android przechowuje **zdjęcie aplikacji**, więc gdy zostanie przywrócona do pierwszego planu, zaczyna ładować obraz przed aplikacją, dzięki czemu wydaje się, że aplikacja została wczytana szybciej.

Jednak jeśli to zdjęcie zawiera **wrażliwe informacje**, osoba mająca dostęp do tego zdjęcia może je **ukraść** (zauważ, że potrzebujesz uprawnień roota, aby uzyskać do niego dostęp).

Zdjęcia są zazwyczaj przechowywane w okolicy: **`/data/system_ce/0/snapshots`**

Android umożliwia **zapobieganie przechwytywaniu zrzutów ekranu poprzez ustawienie parametru układu FLAG\_SECURE**. Korzystając z tej flagi, zawartość okna jest traktowana jako bezpieczna, co uniemożliwia jej pojawienie się na zrzutach ekranu lub wyświetlanie na niezabezpieczonych ekranach.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizator aplikacji Android**

To narzędzie może pomóc w zarządzaniu różnymi narzędziami podczas analizy dynamicznej: [https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### Wstrzykiwanie Intencji

Programiści często tworzą komponenty pośredniczące, takie jak aktywności, usługi i odbiorniki nadawcze, które obsługują te Intencje i przekazują je do metod takich jak `startActivity(...)` lub `sendBroadcast(...)`, co może być ryzykowne.

Niebezpieczeństwo polega na umożliwieniu atakującym wywołania nieeksportowanych komponentów aplikacji lub dostępu do wrażliwych dostawców treści poprzez przekierowanie tych Intencji. Znaczącym przykładem jest komponent `WebView`, który konwertuje adresy URL na obiekty `Intent` za pomocą `Intent.parseUri(...)` i następnie je wykonuje, co potencjalnie prowadzi do złośliwego wstrzykiwania Intencji.

### Podstawowe wnioski
- **Wstrzykiwanie Intencji** jest podobne do problemu przekierowania otwartego w sieci web.
- Ataki polegają na przekazywaniu obiektów `Intent` jako dodatków, które mogą być przekierowane do wykonania niebezpiecznych operacji.
- Może ujawnić nieeksportowane komponenty i dostawców treści atakującym.
- Konwersja adresu URL do `Intent` w `WebView` może ułatwić niezamierzone działania.

### Wstrzykiwanie po stronie klienta Androida i inne

Prawdopodobnie znasz tego rodzaju podatności z sieci web. Musisz być szczególnie ostrożny w przypadku tych podatności w aplikacji Android:

* **Wstrzykiwanie SQL:** Podczas pracy z dynamicznymi zapytaniami lub dostawcami treści upewnij się, że używasz zapytań z parametrami.
* **Wstrzykiwanie JavaScript (XSS):** Sprawdź, czy obsługa JavaScriptu i wtyczek jest wyłączona dla wszystkich WebView (domyślnie wyłączone). [Więcej informacji tutaj](webview-attacks.md#javascript-enabled).
* **Lokalne włączenie plików:** WebView powinien mieć wyłączony dostęp do systemu plików (domyślnie włączony) - `(webview.getSettings().setAllowFileAccess(false);)`. [Więcej informacji tutaj](webview-attacks.md#javascript-enabled).
* **Wieczne ciasteczka**: W wielu przypadkach, gdy aplikacja Android kończy sesję, ciasteczko nie jest unieważniane lub może być nawet zapisane na dysku.
* [**Flaga bezpieczeństwa** w ciasteczkach](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Dołącz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hakerami i łowcami błędów!

**Wnioski z Hackingu**\
Zajmuj się treściami, które zagłębiają się w emocje i wyzwania związane z hakerstwem

**Aktualności na żywo z Hackingu**\
Bądź na bieżąco z szybkim tempem świata hakerstwa dzięki aktualnym wiadomościom i spostrzeżeniom

**Najnowsze ogłoszenia**\
Bądź na bieżąco z najnowszymi programami bug bounty i ważnymi aktualizacjami platformy

**Dołącz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hakerami już dziś!

## Automatyczna analiza

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analiza statyczna**

![](<../../.gitbook/assets/image (61).png>)

**Ocena podatności aplikacji** za pomocą przyjaznego interfejsu internetowego. Możesz również przeprowadzić analizę dynamiczną (ale musisz przygotować środowisko).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Zauważ, że MobSF może analizować aplikacje **Android** (apk), **IOS** (ipa) i **Windows** (apx) (_aplikacje Windows muszą być analizowane z zainstalowanym MobSF na hoście z systemem Windows_).\
Dodatkowo, jeśli utworzysz plik **ZIP** z kodem źródłowym aplikacji **Android** lub **IOS** (przejdź do głównego folderu aplikacji, zaznacz wszystko i utwórz plik ZIP), będzie można go również zanalizować.

MobSF umożliwia również **porównywanie** analizy i integrację z **VirusTotal** (musisz ustawić swój klucz API w _MobSF/settings.py_ i włączyć go: `VT_ENABLED = TRUE` `VT_API_KEY = <Twój klucz API>` `VT_UPLOAD = TRUE`). Możesz również ustawić `VT_UPLOAD` na `False`, wtedy **skrót** zostanie **przesłany**, a nie plik.

### Wspomagana analiza dynamiczna z użyciem MobSF

MobSF może być również bardzo pomocny przy **analizie dynamicznej** w systemie **Android**, ale w tym przypadku musisz zainstalować MobSF i **genymotion** na swoim hoście (maszyna wirtualna lub Docker nie będą działać). _Uwaga: Najpierw musisz **uruchomić maszynę wirtualną w genymotion**, a następnie MobSF._\
Analizator dynamiczny MobSF może:

* **Zrzucić dane aplikacji** (adresy URL, logi, schowek, zrzuty ekranu wykonane przez Ciebie, zrzuty ekranu wykonane przez "**Exported Activity Tester**", e-maile, bazy danych SQLite, pliki XML i inne utworzone pliki). Wszystko to odbywa się automatycznie, z wyjątkiem zrzutów ekranu, musisz nacisnąć, gdy chcesz zrobić zrzut ekranu, lub musisz nacisnąć "**Exported Activity Tester**", aby uzyskać zrzuty ekranu wszystkich wyeksportowanych aktywności.
* Przechwytywać **ruch HTTPS**
* Używać **Frida** do uzyskiwania **informacji o działaniu w czasie rzeczywistym**

Od wersji **Android > 5**, automatycznie uruchomi Fridę i ustawia globalne ustawienia **proxy** do przechwytywania ruchu. Będzie przechwytywać tylko ruch z testowanej aplikacji.

**Frida**

Domyślnie używa również niektórych skryptów Fridy do **omijania weryfikacji SSL**, **wykrywania roota** i **wykrywania debugera**, a także do **monitorowania interesujących interfejsów API**.\
MobSF może również **wywoływać wyeksportowane aktywności**, przechwytywać **zrzuty ekranu** z nich i **zapisywać** je do raportu.

Aby **rozpocząć** testowanie dynamiczne, naciśnij zielony przycisk: "**Start Instrumentation**". Naciśnij "**Frida Live Logs**", aby zobaczyć logi generowane przez skrypty Fridy, a "**Live API Monitor**", aby zobaczyć wszystkie wywołania podłączonych metod, przekazane argumenty i zwracane wartości (to pojawi się po naciśnięciu "Start Instrumentation").\
MobSF umożliwia również ładowanie własnych **skryptów Fridy** (aby przesłać wyniki swoich skryptów Fridy do MobSF, użyj funkcji `send()`). Posiada również **kilka gotowych skryptów**, które można załadować (można dodać więcej w `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), po prostu **wybierz je**, naciśnij "**Load**" i naciśnij "**Start Instrumentation**" (będziesz mógł zobaczyć logi tych skryptów wewnątrz "**Frida Live Logs**").

![](<../../.gitbook/assets/image (215).png>)

Ponadto, masz kilka pomocniczych funkcji Fridy:

* **Wypisz załadowane klasy**: Wyświetli wszystkie załadowane klasy
* **Przechwyć ciągi**: Wyświetli wszystkie przechwycone ciągi podczas korzystania z aplikacji (bardzo głośne)
* **Przechwyć porównania ciągów**: Może być bardzo przydatne. Pokaże **dwa porównywane ciągi** i wynik True lub False.
* **Wypisz metody klasy**: Wprowadź nazwę klasy (np. "java.io.File") i wyświetli wszystkie metody klasy.
* **Wyszukaj wzorzec klasy**: Wyszukaj klasy według wzorca
* **Śledź metody klasy**: **Śledź** całą **klasę** (zobacz wejścia i wyjścia wszystkich metod klasy). Pamiętaj, że domyślnie MobSF śledzi kilka interesujących metod Android Api.

Po wybraniu modułu pomocniczego, którego chcesz użyć, musisz nacisnąć "**Start Intrumentation**", a wszystkie wyniki zostaną wyświetlone w "**Frida Live Logs**".

**Shell**

Mobsf oferuje również powłokę z niektórymi poleceniami **adb**, **poleceniami MobSF** i powszechnymi **poleceniami powłoki** na dole strony analizy dynamicznej. Kilka interesujących poleceń:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Narzędzia HTTP**

Gdy przechwytujesz ruch HTTP, możesz zobaczyć nieestetyczne widoki przechwyconego ruchu na dole "**Ruch HTTP(S)**" lub ładniejszy widok w zielonym przycisku "**Uruchom narzędzia HTTP**". Z drugiej opcji możesz **wysyłać** przechwycone **żądania** do **proxy** takich jak Burp lub Owasp ZAP.\
Aby to zrobić, _włącz Burp -->_ _wyłącz Intercept --> w MobSB HTTPTools wybierz żądanie_ --> naciśnij "**Wyślij do Fuzzer**" --> _wybierz adres proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Po zakończeniu analizy dynamicznej z MobSF możesz nacisnąć "**Uruchom Fuzzer interfejsu API sieciowego**" aby **fuzzować żądania HTTP** i szukać podatności.

{% hint style="info" %}
Po wykonaniu analizy dynamicznej z MobSF ustawienia proxy mogą być źle skonfigurowane i nie będziesz w stanie ich naprawić z poziomu interfejsu graficznego. Możesz naprawić ustawienia proxy wykonując:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Asystowana analiza dynamiczna za pomocą Inspeckage

Możesz pobrać narzędzie z [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
To narzędzie używa pewnych **Hooków**, abyś wiedział, **co dzieje się w aplikacji** podczas wykonywania **analizy dynamicznej**.


### [Yaazhini](https://www.vegabird.com/yaazhini/)

To świetne narzędzie do przeprowadzania analizy statycznej z interfejsem graficznym (GUI).

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

To narzędzie zostało zaprojektowane w celu wyszukiwania kilku **związanych z bezpieczeństwem podatności aplikacji Android**, zarówno w **kodzie źródłowym**, jak i w **pakietowanych APK**. Narzędzie to jest również **zdolne do tworzenia "Proof-of-Concept" APK** i **komend ADB**, aby wykorzystać niektóre z odnalezionych podatności (narażone aktywności, intencje, tapjacking...). Podobnie jak w przypadku Drozera, nie ma potrzeby rootowania urządzenia testowego.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* Wyświetla wszystkie wyodrębnione pliki dla łatwego odniesienia
* Automatycznie dekompiluje pliki APK do formatu Java i Smali
* Analizuje AndroidManifest.xml pod kątem powszechnych podatności i zachowań
* Statyczna analiza kodu źródłowego pod kątem powszechnych podatności i zachowań
* Informacje o urządzeniu
* i wiele więcej
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER to aplikacja wiersza poleceń, która może być używana w systemach Windows, MacOS X i Linux do analizy plików _.apk_ w poszukiwaniu podatności. Robi to poprzez dekompresję plików APK i zastosowanie serii reguł w celu wykrycia tych podatności.

Wszystkie reguły są zawarte w pliku `rules.json`, a każda firma lub tester może stworzyć swoje własne reguły, aby analizować to, czego potrzebują.

Pobierz najnowsze binaria ze [strony pobierania](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAn to **platformowo-niezależne** narzędzie, które pomaga programistom, łowcom błędów i etycznym hackerom w przeprowadzaniu [statycznej analizy kodu](https://en.wikipedia.org/wiki/Static\_program\_analysis) aplikacji mobilnych.

Idea polega na przeciągnięciu i upuszczeniu pliku aplikacji mobilnej (plik .apk lub .ipa) na aplikację StaCoAn, która wygeneruje dla Ciebie raport wizualny i przenośny. Możesz dostosować ustawienia i listy słów, aby uzyskać spersonalizowane doświadczenie.

Pobierz [najnowsze wydanie](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Framework to system analizy podatności Androida, który pomaga programistom lub hakerom znaleźć potencjalne luki w zabezpieczeniach aplikacji Androidowych.\
[Wersje dla systemu Windows](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** to narzędzie, którego głównym celem jest wykrywanie i ostrzeganie użytkownika o potencjalnie szkodliwym zachowaniu aplikacji Android.

Wykrywanie odbywa się poprzez **statyczną analizę** kodu bajtowego Dalvik aplikacji, reprezentowanego jako **Smali**, przy użyciu biblioteki [`androguard`](https://github.com/androguard/androguard).

To narzędzie szuka **typowych zachowań "złych" aplikacji**, takich jak: wyciek identyfikatorów telefonicznych, przechwytywanie strumieni audio/wideo, modyfikacja danych PIM, wykonanie dowolnego kodu...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [Framework MARA](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA** to narzędzie do **odwracania inżynierii i analizy aplikacji mobilnych**. Jest to narzędzie, które łączy popularne narzędzia do odwracania inżynierii i analizy aplikacji mobilnych, aby pomóc w testowaniu aplikacji mobilnych pod kątem zagrożeń związanych z bezpieczeństwem OWASP. Jego celem jest ułatwienie i przyjazne dla programistów aplikacji mobilnych oraz specjalistów ds. bezpieczeństwa.

Narzędzie to umożliwia:

* Wyodrębnianie kodu Java i Smali za pomocą różnych narzędzi
* Analizowanie plików APK za pomocą: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
* Wyodrębnianie prywatnych informacji z plików APK za pomocą wyrażeń regularnych.
* Analizowanie manifestu.
* Analizowanie znalezionych domen za pomocą: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) i [whatweb](https://github.com/urbanadventurer/WhatWeb)
* Deobfuskacja plików APK za pomocą [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Przydatne narzędzie do wykrywania złośliwego oprogramowania: [https://koodous.com/](https://koodous.com)

## Obfuskacja/Deobfuskacja kodu

Należy pamiętać, że w zależności od usługi i konfiguracji użytej do obfuskacji kodu, tajemnice mogą być lub nie być obfuskowane.

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

Z [Wikipedia](https://en.wikipedia.org/wiki/ProGuard\_\(software\)): **ProGuard** to narzędzie wiersza poleceń o otwartym kodzie źródłowym, które zmniejsza, optymalizuje i obfuskuje kod Java. Potrafi optymalizować kod bajtowy oraz wykrywać i usuwać nieużywane instrukcje. ProGuard jest oprogramowaniem darmowym i jest dystrybuowany na licencji GNU General Public License, wersja 2.

ProGuard jest dystrybuowany jako część Android SDK i uruchamiany podczas budowania aplikacji w trybie wydania.

### [DexGuard](https://www.guardsquare.com/dexguard)

Znajdź przewodnik krok po kroku, jak deobfuskować plik APK na stronie [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Z tego przewodnika) Ostatnio sprawdziliśmy, że tryb działania Dexguard to:

* załaduj zasób jako InputStream;
* przekaż wynik do klasy dziedziczącej po FilterInputStream, aby go zaszyfrować;
* wykonaj niepotrzebną obfuskację, aby stracić kilka minut czasu od odwracacza;
* przekaż zdeszyfrowany wynik do ZipInputStream, aby uzyskać plik DEX;
* w końcu załaduj wynikowy DEX jako zasób za pomocą metody `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard odwraca proces obfuskacji wykonywanej przez narzędzia do obfuskacji Androida. Umożliwia to wiele analiz związanych z bezpieczeństwem, w tym inspekcję kodu i przewidywanie bibliotek.**

Możesz przesłać zobfuskowany plik APK na ich platformę.

### [Simplify](https://github.com/CalebFenton/simplify)

Jest to **ogólny deobfuskator Androida**. Simplify **wirtualnie wykonuje aplikację**, aby zrozumieć jej zachowanie, a następnie **stara się zoptymalizować kod**, aby zachowywał się identycznie, ale był łatwiejszy do zrozumienia dla człowieka. Każdy rodzaj optymalizacji jest prosty i ogólny, więc nie ma znaczenia, jaki konkretny rodzaj obfuskacji jest używany.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD dostarcza informacje na temat **sposobu tworzenia pliku APK**. Rozpoznaje wiele **kompilatorów**, **pakowaczy**, **obfuskatorów** i innych dziwnych rzeczy. To jest [_PEiD_](https://www.aldeid.com/wiki/PEiD) dla Androida.

### Manual

[Przeczytaj ten samouczek, aby nauczyć się kilku sztuczek dotyczących **odwracania niestandardowej obfuskacji**](manual-deobfuscation.md)

## Laboratoria

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b to wirtualna maszyna z systemem Android oparta na ubuntu-mate, zawierająca najnowsze frameworki, samouczki i laboratoria od różnych ekspertów ds. bezpieczeństwa i badaczy do odwracania inżynierii i analizy złośliwego oprogramowania.

## Odnośniki

* [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) To świetna lista zasobów
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Szybki kurs Androida
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
* [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## Jeszcze do wypróbowania

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Dołącz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hakerami i łowcami błędów!

**Wnioski z hakerstwa**\
Zajmuj się treściami, które zagłębiają się w emocje i wyzwania hakerstwa

**Aktualne wiadomości o hakerstwie**\
Bądź na bieżąco z szybkim tempem świata hakerstwa dzięki aktualnym wiadomościom i spostrzeżeniom

**Najnowsze ogłoszenia**\
Bądź na bieżąco z najnowszymi programami bug bounty i ważnymi aktualizacjami platformy

**Dołącz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hakerami już dziś!

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć **reklamę swojej firmy w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/c
