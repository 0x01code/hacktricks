# Android 애플리케이션 펜테스팅

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

경험있는 해커와 버그 바운티 헌터와 소통하기 위해 [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 참여하세요!

**해킹 인사이트**\
해킹의 스릴과 도전에 대해 깊이 파고드는 콘텐츠와 상호 작용하세요.

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰력을 통해 빠르게 변화하는 해킹 세계를 따라가세요.

**최신 공지사항**\
새로운 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대한 정보를 받아보세요.

**[Discord](https://discord.com/invite/N3FrSbmwdy)에 참여하여 최고의 해커들과 협업을 시작하세요!**

## Android 애플리케이션 기본 사항

**Android 보안과 Android 애플리케이션에서 가장 위험한 구성 요소에 관련된 가장 중요한 부분을 알아보기 위해 이 페이지를 읽는 것이 매우 권장됩니다**:

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB (Android Debug Bridge)

이것은 안드로이드 장치 (에뮬레이션 또는 실제 장치)에 연결하는 데 필요한 주요 도구입니다.\
**ADB**는 컴퓨터에서 장치를 **USB** 또는 **네트워크**를 통해 제어할 수 있습니다. 이 유틸리티를 사용하면 양방향으로 파일을 **복사**하고 앱을 **설치** 및 **제거**하며 셸 명령을 **실행**하고 데이터를 **백업**하고 로그를 **읽는** 등의 기능을 수행할 수 있습니다.

adb를 사용하는 방법을 알아보려면 다음 [**ADB 명령어 목록**](adb-commands.md)을 확인하세요.

## Smali

가끔은 **애플리케이션 코드를 수정**하여 **숨겨진 정보**에 액세스하는 것이 흥미로울 수 있습니다 (아마도 잘 난독화된 비밀번호나 플래그). 그런 다음 apk를 디컴파일하고 코드를 수정한 다음 다시 컴파일하는 것이 흥미로울 수 있습니다.\
[**이 튜토리얼**에서는 **APK를 디컴파일하고 Smali 코드를 수정하고 APK를 다시 컴파일**하는 방법을 배울 수 있습니다](smali-changes.md). 이는 동적 분석 중에 수행될 여러 테스트의 **대체로서 매우 유용**할 수 있습니다. 그러므로 **언제나 이 가능성을 염두에 두세요**.

## 다른 흥미로운 트릭

* [Play 스토어에서 위치를 위장하는 방법](spoofing-your-location-in-play-store.md)
* **APK 다운로드**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* 장치에서 APK 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
## 정적 분석

먼저, APK를 분석하기 위해 디컴파일러를 사용하여 Java 코드를 확인해야 합니다. [여기에서 다양한 디컴파일러에 대한 정보를 찾아보세요.](apk-decompilers.md)

### 흥미로운 정보 찾기

APK의 문자열을 확인함으로써 **비밀번호**, **URL**(https://github.com/ndelphit/apkurlgrep), **API** 키, **암호화**, **블루투스 UUID**, **토큰** 등 흥미로운 정보를 검색할 수 있습니다. 코드 실행 **백도어**나 인증 백도어(앱에 하드코딩된 관리자 자격 증명)와 같은 것들도 찾아보세요.

**Firebase**

특히 **Firebase URL**에 주의를 기울이고, 잘못 구성되어 있는지 확인하세요. [Firebase가 무엇이며 어떻게 악용할 수 있는지에 대한 자세한 정보는 여기에서 확인하세요.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 애플리케이션의 기본 이해 - Manifest.xml, strings.xml

애플리케이션의 **Manifest.xml** 및 **strings.xml** 파일을 조사하면 잠재적인 보안 취약점을 발견할 수 있습니다. 이러한 파일은 디컴파일러를 사용하거나 APK 파일 확장자를 .zip으로 변경한 다음 압축을 해제하여 액세스할 수 있습니다.

**Manifest.xml**에서 식별된 **취약점**은 다음과 같습니다:

* **디버깅 가능한 애플리케이션**: _Manifest.xml_ 파일에서 `debuggable="true"`로 설정된 애플리케이션은 연결을 허용하여 악용될 수 있는 위험을 가지고 있습니다. 디버깅 가능한 애플리케이션을 찾고 악용하는 방법에 대한 자세한 이해를 위해 기기에서 디버깅 가능한 애플리케이션을 찾고 악용하는 튜토리얼을 참조하세요.

* **백업 설정**: `android:allowBackup="false"` 속성은 무단으로 adb를 통한 데이터 백업을 방지하기 위해 민감한 정보를 처리하는 애플리케이션에 명시적으로 설정되어야 합니다. 특히 USB 디버깅이 활성화된 경우에는 더욱 중요합니다.

* **네트워크 보안**: _res/xml/_에 있는 사용자 정의 네트워크 보안 구성(`android:networkSecurityConfig="@xml/network_security_config"`)은 인증서 핀 및 HTTP 트래픽 설정과 같은 보안 세부 정보를 지정할 수 있습니다. 특정 도메인에 대한 HTTP 트래픽을 허용하는 것이 예입니다.

* **내보낸 액티비티 및 서비스**: Manifest에서 내보낸 액티비티 및 서비스를 식별하면 오용될 수 있는 구성 요소를 강조할 수 있습니다. 동적 테스트 중에 이러한 구성 요소를 악용하는 방법을 확인할 수 있습니다.

* **콘텐츠 제공자 및 파일 제공자**: 노출된 콘텐츠 제공자는 무단 액세스 또는 데이터 수정을 허용할 수 있습니다. FileProvider의 구성도 검토되어야 합니다.

* **브로드캐스트 수신자 및 URL 스키마**: 이러한 구성 요소는 악용에 이용될 수 있으며, 특히 URL 스키마가 입력 취약점에 대해 어떻게 관리되는지에 주의를 기울여야 합니다.

* **SDK 버전**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 보안상의 이유로 오래된 취약한 Android 버전을 지원하지 않는 것이 중요합니다.

**strings.xml** 파일에서는 API 키, 사용자 정의 스키마 및 기타 개발자 노트와 같은 민감한 정보를 발견할 수 있으므로 이러한 리소스를 주의 깊게 검토해야 합니다.


### Tapjacking

**Tapjacking**은 악성 **애플리케이션이 피해 애플리케이션 위에 자리 잡는** 공격입니다. 피해 앱을 가려 사용자 인터페이스를 설계하여 사용자가 상호 작용하도록 속이는 동안 실제로는 피해 앱에서 작업을 수행하게 합니다.\
사용자는 실제로 피해 앱에서 작업을 수행하고 있다는 사실을 알지 못하고 작업을 수행하게 됩니다.

자세한 정보는 다음에서 확인하세요:

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### 작업 탈취

**`launchMode`**를 **`singleTask`**로 설정하고 **`taskAffinity`**를 정의하지 않은 **액티비티**는 작업 탈취에 취약합니다. 이는 애플리케이션을 설치하고 실제 애플리케이션보다 먼저 실행하면 실제 애플리케이션의 작업을 탈취할 수 있으므로 사용자는 실제 애플리케이션을 사용하는 것으로 착각하게 됩니다.

자세한 정보는 다음에서 확인하세요:

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### 보안이 취약한 데이터 저장

**내부 저장소**

Android에서 **내부 저장소에 저장된 파일은 해당 파일을 생성한 앱만이 액세스**할 수 있도록 설계되었습니다. 이 보안 조치는 Android 운영 체제에 의해 강제로 적용되며 대부분의 애플리케이션의 보안 요구 사항을 충분히 충족합니다. 그러나 개발자는 때로는 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`과 같은 모드를 사용하여 파일을 다른 애플리케이션 간에 공유할 수 있도록 합니다. 그러나 이러한 모드는 다른 애플리케이션, 특히 악성 애플리케이션에 의해 이러한 파일에 대한 액세스를 제한하지 않습니다.

1. **정적 분석:**
- `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`의 사용이 **신중하게 검토**되었는지 확인하세요. 이러한 모드는 파일이 **의도하지 않은 또는 무단의 액세스**에 노출될 수 있습니다.

2. **동적 분석:**
- 앱이 생성한 파일에 설정된 **권한**을 확인하세요. 특히 어떤 파일이 **전 세계에서 읽거나 쓸 수 있도록 설정**되어 있는지 확인하세요. 이는 잠재적으로 악성인지 여부나 출처에 관계없이 기기에 설치된 **모든 애플리케이션**이 이러한 파일을 **읽거나 수정**할 수 있게 됩니다.

**외부 저장소**

SD 카드와 같은 **외부 저장소**의 파일을 다룰 때는 다음과 같은 주의사항을 지켜야 합니다:

1. **접근성**:
- 외부 저장소의 파일은 **전역적으로 읽기 및 쓰기**가 가능합니다. 즉, 모든 애플리케이션 또는 사용자가 이러한 파일에 액세스할 수 있습니다.

2. **보안 문제**:
- 액세스의 용이성을 감안할 때, 외부 저장소에 **민감한 정보를 저장하지 않는 것이 좋습니다**.
- 외부 저장소는 제거되거나 다른 애플리케이션에서 액세스할 수 있으므로 보안이 취약합니다.

3.
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
이를 테스트하는 좋은 방법은 기기 내에서 Burp CA를 승인하지 않고 Burp와 같은 프록시를 사용하여 트래픽을 캡처하려고 시도하는 것입니다. 또한 Burp를 사용하여 다른 호스트 이름을 위한 인증서를 생성하고 사용할 수 있습니다.

### 암호화가 깨진 경우

**암호화 키 관리 과정이 부족한 경우**

일부 개발자는 민감한 데이터를 로컬 저장소에 저장하고 코드에서 하드코딩/예측 가능한 키로 암호화합니다. 이는 공격자가 기밀 정보를 추출할 수 있도록 역공학이 가능하기 때문에 이렇게 하면 안 됩니다.

**보안이 취약하거나 사용되지 않는 알고리즘 사용**

개발자는 **사용되지 않는 알고리즘**을 사용하여 **인증 확인**, **데이터 저장** 또는 **전송**을 수행해서는 안 됩니다. 이러한 알고리즘 중 일부는 RC4, MD4, MD5, SHA1 등입니다. 예를 들어 암호를 저장하기 위해 해시가 사용된다면, 소금과 함께 해시 브루트 포스에 강한 해시를 사용해야 합니다.

### 기타 확인 사항

* APK를 난독화하여 역공학 작업을 어렵게 하는 것이 좋습니다.
* 앱이 민감한 경우 (은행 앱과 같은 경우), 루팅된 모바일인지 여부를 확인하고 그에 따라 대응해야 합니다.
* 앱이 민감한 경우 (은행 앱과 같은 경우), 에뮬레이터를 사용하는지 확인해야 합니다.
* 앱이 민감한 경우 (은행 앱과 같은 경우), 실행하기 전에 자체 무결성을 확인해야 합니다.
* APK를 빌드할 때 사용된 컴파일러/패커/난독화 도구를 확인하기 위해 [**APKiD**](https://github.com/rednaga/APKiD)를 사용하세요.

### React Native 애플리케이션

React 애플리케이션의 JavaScript 코드에 쉽게 액세스하는 방법을 알아보려면 다음 페이지를 읽으세요:

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Xamarin 애플리케이션

Xamarin 애플리케이션의 C# 코드에 쉽게 액세스하는 방법을 알아보려면 다음 페이지를 읽으세요:

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### Superpacked 애플리케이션

[**블로그 게시물**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)에 따르면, Superpacked는 애플리케이션의 내용을 하나의 파일로 압축하는 메타 알고리즘입니다. 이 블로그는 이러한 종류의 앱을 압축 해제하는 앱을 만들 수 있는 가능성에 대해 이야기하며, **애플리케이션을 실행하고 파일 시스템에서 압축 해제된 파일을 수집하는 더 빠른 방법**도 소개합니다.

### 자동 정적 코드 분석

도구 [**mariana-trench**](https://github.com/facebook/mariana-trench)은 애플리케이션의 코드를 **스캔**하여 **취약점**을 찾을 수 있습니다. 이 도구에는 **알려진 소스**(사용자에 의해 **제어되는 입력**의 위치를 도구에 알려주는 것), **싱크**(악의적인 사용자 입력이 피해를 일으킬 수 있는 **위험한 위치**를 도구에 알려주는 것) 및 **규칙**이 포함되어 있습니다. 이러한 규칙은 취약점을 나타내는 **소스-싱크**의 조합을 나타냅니다.

이러한 지식을 바탕으로 **mariana-trench는 코드를 검토하고 가능한 취약점을 찾아냅니다**.

### 유출된 비밀 정보

애플리케이션에는 (API 키, 비밀번호, 숨겨진 URL, 서브도메인 등) 포함된 비밀 정보를 발견할 수 있는 경우가 있습니다. [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)와 같은 도구를 사용하여 이를 확인할 수 있습니다.

### 생체 인증 우회

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### 기타 흥미로운 기능

* **코드 실행**: `Runtime.exec(), ProcessBuilder(), native code:system()`
* **SMS 전송**: `sendTextMessage, sendMultipartTestMessage`
* `native`로 선언된 **네이티브 함수**: `public native, System.loadLibrary, System.load`
* **네이티브 함수를 역공학하는 방법**을 알아보려면 [여기](reversing-native-libraries.md)를 읽으세요.

### **기타 트릭**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

경험 많은 해커와 버그 바운티 헌터와 소통하기 위해 [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 참여하세요!

**해킹 인사이트**\
해킹의 스릴과 도전에 대해 다루는 콘텐츠에 참여하세요.

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰력을 통해 빠르게 변화하는 해킹 세계를 따라가세요.

**최신 공지사항**\
새로운 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대한 최신 정보를 받아보세요.

**[Discord](https://discord.com/invite/N3FrSbmwdy)에 가입하여 최고의 해커들과 협업을 시작하세요!**

***

## 동적 분석

> 먼저, 애플리케이션과 모든 환경 (Burp CA 인증서, Drozer 및 Frida 주로)을 설치할 수 있는 환경이 필요합니다. 따라서 루팅된 기기 (에뮬레이션 또는 비에뮬레이션)를 권장합니다.

### 온라인 동적 분석

[https://appetize.io/](https://appetize.io)에서 **무료 계정**을 만들 수 있습니다. 이 플랫폼은 APK를 **업로드**하고 **실행**할 수 있으므로 apk의 동작을 확인하는 데 유용합니다.

웹에서 애플리케이션의 로그를 **볼 수** 있고 **adb**를 통해 연결할 수도 있습니다.

![](<../../.gitbook/assets/image (60).png>)

ADB 연결을 통해 에뮬레이터 내에서 **Drozer**와 **Frida**를 사용할 수 있습니다.

### 로컬 동적 분석

#### 에뮬레이터 사용

* [**Android Studio**](https://developer.android.com/studio) (x86 및 arm 장치를 생성할 수 있으며, [**이**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)에 따르면 **최신 x86** 버전은 **느린 arm 에뮬레이터 없이도 ARM 라이브러리를 지원**합니다).
* 이 페이지에서 설정하는 방법을 배워보세요:

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **(무료 버전
#### 물리적 장치 사용

**디버깅** 옵션을 활성화해야하며, **루팅**이 가능하면 좋습니다:

1. **설정**.
2. (Android 8.0 이상) **시스템** 선택.
3. **휴대폰 정보** 선택.
4. **빌드 번호**를 7번 누르세요.
5. 뒤로 가서 **개발자 옵션**을 찾을 수 있습니다.

> 애플리케이션을 설치한 후에는 먼저 애플리케이션이 무엇을 하는지, 어떻게 작동하는지 조사하고 익숙해지는 것이 좋습니다.\
> MobSF 동적 분석 + pidcat을 사용하여 **초기 동적 분석을 수행**하는 것을 제안합니다. 이렇게 하면 MobSF가 나중에 검토할 수 있는 **많은 흥미로운 데이터**를 **캡처**하면서 애플리케이션이 **작동하는 방식을 배울** 수 있습니다.

### 의도하지 않은 데이터 유출

**로그 기록**

개발자는 **디버깅 정보**를 공개적으로 노출시키지 않도록 주의해야 합니다. 이는 민감한 데이터 유출로 이어질 수 있습니다. 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하기 위해 [**pidcat**](https://github.com/JakeWharton/pidcat) 및 `adb logcat` 도구를 사용하는 것이 좋습니다. **Pidcat**은 사용하기 쉽고 가독성이 좋아 선호됩니다.

{% hint style="warning" %}
**Android 4.0 이후의 최신 버전에서는 애플리케이션은 자체 로그에만 액세스할 수 있습니다**. 따라서 애플리케이션은 다른 앱의 로그에 액세스할 수 없습니다.\
그래도 **민감한 정보를 기록하지 않는 것이 좋습니다**.
{% endhint %}

**복사/붙여넣기 버퍼 캐싱**

Android의 **클립보드 기반** 프레임워크는 앱에서 복사 및 붙여넣기 기능을 가능하게 합니다. 그러나 다른 애플리케이션이 클립보드에 액세스할 수 있으므로 민감한 데이터가 노출될 수 있는 위험이 있습니다. 민감한 섹션(예: 신용 카드 세부 정보)에서 복사/붙여넣기 기능을 **비활성화**하는 것이 중요합니다.

**충돌 로그**

애플리케이션이 **충돌**하고 **로그를 저장**하는 경우, 이러한 로그는 애플리케이션을 역공학으로 분석할 수 없을 때 특히 공격자에게 도움이 될 수 있습니다. 이러한 위험을 완화하기 위해 충돌 시 로깅을 피하고 로그를 네트워크를 통해 전송해야 하는 경우 보안을 위해 SSL 채널을 통해 전송되도록 해야 합니다.

펜테스터로서 **이러한 로그를 살펴보려고 노력**하세요.

**3rd Party로 전송되는 분석 데이터**

애플리케이션은 종종 Google Adsense와 같은 서비스를 통합합니다. 그러나 개발자의 부적절한 구현으로 인해 민감한 데이터가 누출될 수 있습니다. 잠재적인 데이터 유출을 식별하기 위해 애플리케이션의 트래픽을 가로채고 제3자 서비스로 전송되는 민감한 정보가 있는지 확인하는 것이 좋습니다.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **내부 SQLite 데이터베이스**를 사용합니다. 펜테스트 중에 생성된 **데이터베이스**, **테이블** 및 **열**의 이름 및 저장된 **모든 데이터**를 확인하여 민감한 정보(취약점)를 발견할 수 있습니다.\
데이터베이스는 `/data/data/the.package.name/databases`와 같은 위치에 있어야 합니다. 예: `/data/data/com.mwr.example.sieve/databases`

데이터베이스가 기밀 정보를 저장하고 **암호화**되었지만 애플리케이션 내에서 **암호**를 찾을 수 있다면 여전히 **취약점**입니다.

`.tables`를 사용하여 테이블을 열거하고 `.schema <table_name>`을 사용하여 테이블의 열을 열거하세요.

### Drozer (Exploit Activities, Content Providers and Services)

[Drozer 문서](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)에서: **Drozer**를 사용하면 Android 앱의 역할을 가정하고 다른 앱과 상호 작용할 수 있습니다. Android의 프로세스 간 통신 (IPC) 메커니즘을 활용하고 기본 운영 체제와 상호 작용하는 등, 설치된 애플리케이션이 할 수 있는 모든 작업을 수행할 수 있습니다.\
Drozer는 다음 섹션에서 배울 수 있는 **내보낸 활동, 내보낸 서비스 및 콘텐츠 제공자**를 악용하기 위한 유용한 도구입니다.

### 내보낸 활동 악용

[**Android 활동이 무엇인지 다시 확인하려면 여기를 읽으세요.**](android-applications-basics.md#launcher-activity-and-other-activities)\
또한 활동의 코드는 **`onCreate`** 메서드에서 시작됩니다.

**인증 우회**

활동이 내보내진 경우 외부 앱에서 해당 화면을 호출할 수 있습니다. 따라서 **민감한 정보**가 있는 활동이 **내보내진** 경우 **인증 메커니즘을 우회**하여 **접근**할 수 있습니다.

[Drozer를 사용하여 내보낸 활동을 악용하는 방법을 알아보세요.](drozer-tutorial/#activities)

또한 adb에서 내보낸 활동을 시작할 수도 있습니다:

* 패키지 이름은 com.example.demo입니다.
* 내보낸 활동 이름은 com.example.test.MainActivity입니다.
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**참고**: MobSF는 활동의 `android:launchMode`로 _**singleTask/singleInstance**_를 사용하는 것을 악성으로 감지하지만, [이](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)로 인해 이는 오래된 버전(API 버전 < 21)에서만 위험하다고 합니다.

{% hint style="info" %}
인가 우회는 항상 취약점은 아닙니다. 우회 방법과 노출되는 정보에 따라 다를 수 있습니다.
{% endhint %}

**민감한 정보 누출**

**활동은 결과를 반환할 수도 있습니다**. 내보내고 보호되지 않은 활동에서 **`setResult`** 메서드를 호출하고 **민감한 정보를 반환**하는 경우, 민감한 정보 누출이 발생합니다.

#### Tapjacking

Tapjacking이 방지되지 않으면, 내보낸 활동을 악용하여 **사용자가 예상치 못한 동작을 수행**하게 할 수 있습니다. [**Tapjacking이란 무엇인지 자세히 알아보려면 링크를 따르세요**](./#tapjacking).

### 콘텐츠 제공자 악용 - 민감한 정보에 대한 액세스 및 조작

[**콘텐츠 제공자가 무엇인지 다시 확인하려면 이것을 읽으세요.**](android-applications-basics.md#content-provider)\
콘텐츠 제공자는 기본적으로 데이터를 **공유**하기 위해 사용됩니다. 앱에 사용 가능한 콘텐츠 제공자가 있는 경우, 해당 제공자에서 **민감한 데이터를 추출**할 수 있습니다. 또한 가능한 **SQL 인젝션** 및 **경로 순회**를 테스트하는 것도 흥미로울 수 있습니다.

[**Drozer를 사용하여 콘텐츠 제공자를 악용하는 방법을 배우세요.**](drozer-tutorial/#content-providers)

### **서비스 악용**

[**서비스가 무엇인지 다시 확인하려면 이것을 읽으세요.**](android-applications-basics.md#services)\
서비스는 기본적으로 **데이터를 수신**하고, **처리**하며, 응답을 **반환**하거나 반환하지 않을 수 있는 것입니다. 따라서, 애플리케이션이 일부 서비스를 내보내고 있다면, 해당 코드를 **확인**하여 무엇을 수행하는지 이해하고, 기밀 정보를 추출하거나 인증 조치를 우회하기 위해 동적으로 **테스트**해야 합니다.\
[**Drozer를 사용하여 서비스를 악용하는 방법을 배우세요.**](drozer-tutorial/#services)

### **브로드캐스트 수신자 악용**

[**브로드캐스트 수신자가 무엇인지 다시 확인하려면 이것을 읽으세요.**](android-applications-basics.md#broadcast-receivers)\
브로드캐스트 수신자는 특정 유형의 메시지를 기다리고 있습니다. 수신자가 메시지를 처리하는 방식에 따라 취약할 수 있습니다.\
[**Drozer를 사용하여 브로드캐스트 수신자를 악용하는 방법을 배우세요.**](./#exploiting-broadcast-receivers)

### **스키마 / 딥 링크 악용**

MobSF와 같은 도구 또는 [이 스크립트](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)와 같은 스크립트를 사용하여 딥 링크를 수동으로 찾을 수 있습니다.\
**adb** 또는 **브라우저**를 사용하여 선언된 **스키마**를 **열 수** 있습니다:

{% code overflow="wrap" %}
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_패키지 이름을 생략할 수 있으며, 모바일은 자동으로 해당 링크를 열어야 할 앱을 호출합니다._

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**실행된 코드**

앱에서 실행될 **코드를 찾으려면** 딥링크에 의해 호출되는 액티비티로 이동하고 **`onNewIntent`** 함수를 검색하십시오.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**민감한 정보**

딥링크를 찾을 때마다 URL 매개변수를 통해 민감한 데이터 (예: 비밀번호)를 **받지 않는지 확인**하십시오. 다른 애플리케이션이 딥링크를 가장하여 해당 데이터를 도용할 수 있습니다!

**경로 매개변수**

URL의 경로에 있는 매개변수를 사용하는 딥링크가 있는지도 **확인**해야 합니다. 예를 들어 `https://api.example.com/v1/users/{username}`와 같은 경우 `example://app/users?username=../../unwanted-endpoint%3fparam=value`와 같이 경로 트래버설에 접근할 수 있습니다.\
애플리케이션 내에서 올바른 엔드포인트를 찾으면 **Open Redirect** (경로 일부가 도메인 이름으로 사용될 경우), **계정 탈취** (CSRF 토큰 없이 사용자 세부 정보를 수정할 수 있고 취약한 엔드포인트가 올바른 메서드를 사용한 경우) 및 기타 취약점을 유발할 수 있습니다. [여기에서 자세한 정보를 확인하세요](http://dphoeniixx.com/2020/12/13-2/).

**추가 예시**

링크에 관한 [흥미로운 버그 바운티 보고서](https://hackerone.com/reports/855618) (_/.well-known/assetlinks.json_).

### 전송 계층 검사 및 검증 실패

- 안드로이드 애플리케이션에서는 **인증서를 항상 적절하게 검사하지 않습니다**. 이러한 애플리케이션은 경고를 무시하고 자체 서명된 인증서를 수락하거나 경우에 따라 HTTP 연결을 사용하도록 되돌릴 수 있습니다.
- SSL/TLS 핸드셰이크 중 협상이 약할 수 있으며, 보안이 취약한 암호화 알고리즘을 사용합니다. 이 취약점으로 인해 연결은 중간자 공격에 취약해져 데이터를 해독할 수 있습니다.
- 응용 프로그램이 안전한 채널을 사용하여 인증하지만 다른 트랜잭션에 대해 암호화되지 않은 채널을 통해 통신하는 경우 개인 정보가 유출될 수 있습니다. 이 접근 방식은 세션 쿠키나 사용자 세부 정보와 같은 민감한 데이터를 악의적인 개체에 의해 가로채기로부터 보호하지 못합니다.

#### 인증서 검증

**인증서 검증**에 중점을 둘 것입니다. 서버의 인증서 무결성을 검증하여 보안을 강화해야 합니다. 이는 보안되지 않은 TLS 구성 및 암호화되지 않은 채널을 통한 민감한 데이터의 전송이 중요한 위험을 초래할 수 있기 때문입니다. 서버 인증서를 검증하고 취약점을 해결하기 위한 자세한 단계에 대해서는 **[이 자료](https://manifestsecurity.com/android-application-security-part-10/)**를 참조하십시오.

#### SSL Pinning

SSL Pinning은 애플리케이션이 알려진 복사본과 서버의 인증서를 검증하는 보안 조치입니다. 이 방법은 MITM 공격을 방지하는 데 필수적입니다. 민감한 정보를 처리하는 애플리케이션에 대해 SSL Pinning을 구현하는 것이 강력히 권장됩니다.

#### 트래픽 검사

HTTP 트래픽을 검사하려면 프록시 도구의 인증서를 **설치**해야 합니다 (예: Burp). 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 보이지 않을 수 있습니다. 사용자 정의 CA 인증서를 설치하는 가이드에 대해서는 **[여기를 클릭하세요](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)**.

**API 레벨 24 이상**을 대상으로 하는 애플리케이션은 프록시의 CA 인증서를 수락하기 위해 네트워크 보안 구성을 수정해야 합니다. 이 단계는 암호화된 트래픽을 검사하는 데 중요합니다. 네트워크 보안 구성을 수정하는 방법에 대해서는 **[이 튜토리얼을 참조하세요](make-apk-accept-ca-certificate.md)**.

#### SSL Pinning 우회

SSL Pinning이 구현되었을 때, HTTPS 트래픽을 검사하기 위해 SSL Pinning을 우회해야 할 수 있습니다. 이를 위해 다음과 같은 여러 방법을 사용할 수 있습니다:

* [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)을 사용하여 **apk를 수정**하여 SSL Pinning을 **우회**할 수 있습니다. 이 옵션의 가장 큰 장점은 SSL Pinning을 우회하기 위해 루트 권한이 필요하지 않지만, 애플리케이션을 삭제하고 새로 설치해야 하며 항상 작동하지는 않습니다.
* 이 보호를 우회하기 위해 **Frida**를 사용할 수 있습니다. Burp+Frida+Genymotion을 사용하는 가이드는 다음을 참조하세요: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
* [**objection**](frida-tutorial/objection-tutorial.md)**을 사용하여 SSL Pinning을 자동으로 우회**할 수도 있습니다: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* **MobSF 동적 분석**을 사용하여 SSL Pinning을 자동으로 우회할 수도 있습니다 (아래에서 설명).
* 아직 캡처하지 못한 트래픽이 있다고 생각한다면 **iptables를 사용하여 트래픽을 burp로 전달**해 볼 수 있습니다. 이 블로그를 읽어보세요: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 일반적인 웹 취약점 찾기

애플리케이션 내에서 일반적인 웹 취약점을 찾는 것도 중요합니다. 이러한 취약점을 식별하고 완화하는 자세한 정보는 이 요약의 범위를 벗어나지만 다른 곳에서 상세히 다루고 있습니다.

### Frida

[Frida](https://www.frida.re)는 개발자, 역공학가 및 보안 연구원을 위한 동적 인스트루먼트 툴킷입니다.\
**실행 중인 애플리케이션에 액세스하고 실행 시간에 메서드를 후킹하여 동작을 변경하거나 값 변경, 값 추출, 다른 코드 실행 등을 할 수 있습니다.**\
안드로이드 애플리케이션을 펜테스트하려면 Frida의 사용 방법을 알아야 합니다.

* Frida 사용 방법 알아보기: [**Frida 튜토리얼**](frida-tutorial/)
* Frida 작업을 위한 "GUI": [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
* Ojection은 Frida 사용을 자동화하는 데 탁월합니다: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
* 여기에서 멋진 Frida 스크립트를 찾을 수 있습니다: [**https://codeshare.frida.re/**](https://codeshare.frida.re)

### **메모리 덤프 - Fridump**

애플리케이션이 암호나
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이 명령은 ./dump 폴더에 메모리를 덤프하며, 그 안에서 다음과 같이 grep을 사용할 수 있습니다:

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Keystore에 민감한 데이터**

Android에서 Keystore는 민감한 데이터를 저장하기에 가장 적합한 장소입니다. 그러나 충분한 권한이 있다면 여전히 **접근할 수 있습니다**. 애플리케이션은 일반적으로 여기에 **평문으로 민감한 데이터를 저장**하므로 펜테스트는 이를 확인해야 합니다. 루트 사용자 또는 기기에 물리적으로 접근할 수 있는 사람은 이 데이터를 도난할 수 있습니다.

Keystore에 데이터를 저장하더라도 데이터는 암호화되어야 합니다.

Keystore 내부의 데이터에 접근하려면 다음 Frida 스크립트를 사용할 수 있습니다: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **지문/생체 인증 우회**

다음 Frida 스크립트를 사용하면 Android 애플리케이션에서 수행하는 **특정 민감한 영역을 보호하기 위해 수행하는 지문 인증을 우회**할 수 있습니다:

{% code overflow="wrap" %}
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **배경 이미지**

애플리케이션을 백그라운드로 넣을 때, 안드로이드는 애플리케이션의 **스냅샷을 저장**하여 앱이 더 빨리 로드된 것처럼 보이도록 합니다.

그러나 이 스냅샷에 **민감한 정보**가 포함되어 있다면, 스냅샷에 접근할 수 있는 사람은 그 정보를 **훔칠 수 있습니다** (스냅샷에 접근하려면 루트 권한이 필요합니다).

스냅샷은 일반적으로 다음 경로에 저장됩니다: **`/data/system_ce/0/snapshots`**

안드로이드는 FLAG\_SECURE 레이아웃 매개변수를 설정하여 스크린샷 캡처를 **방지하는 방법을 제공**합니다. 이 플래그를 사용하면 창 내용이 안전하게 처리되어 스크린샷에 나타나지 않거나 안전하지 않은 디스플레이에서 볼 수 없습니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android 애플리케이션 분석기**

이 도구는 동적 분석 중에 다양한 도구를 관리하는 데 도움이 될 수 있습니다: [https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### Intent 삽입

개발자들은 종종 액티비티, 서비스 및 브로드캐스트 리시버와 같은 프록시 구성 요소를 생성하여 이러한 Intent를 처리하고 `startActivity(...)` 또는 `sendBroadcast(...)`와 같은 메서드로 전달합니다. 이는 위험할 수 있습니다.

위험은 공격자가 이러한 Intent를 잘못된 방향으로 전달하여 내보내지 않는 앱 구성 요소를 트리거하거나 민감한 콘텐츠 제공자에 액세스할 수 있게 하는 것입니다. 주목할만한 예로는 `WebView` 구성 요소가 URL을 `Intent.parseUri(...)`를 통해 `Intent` 객체로 변환한 다음 실행하여 악성 Intent 삽입으로 이어질 수 있습니다.

### 주요 포인트
- **Intent 삽입**은 웹의 Open Redirect 취약점과 유사합니다.
- 악용은 `Intent` 객체를 추가로 전달하여 안전하지 않은 작업을 실행할 수 있습니다.
- 이로 인해 내보내지 않는 구성 요소 및 콘텐츠 제공자가 공격자에게 노출될 수 있습니다.
- `WebView`의 URL을 `Intent`로 변환하는 것은 의도하지 않은 동작을 용이하게 할 수 있습니다.

### Android 클라이언트 측 삽입 및 기타

아마도 웹에서 이러한 종류의 취약점에 대해 알고 있을 것입니다. Android 애플리케이션에서 이러한 취약점에 특히 주의해야 합니다:

* **SQL 삽입:** 동적 쿼리나 콘텐츠 제공자를 다룰 때 매개변수화된 쿼리를 사용하는지 확인하세요.
* **JavaScript 삽입 (XSS):** WebView에서 JavaScript 및 플러그인 지원이 비활성화되어 있는지 확인하세요 (기본적으로 비활성화됨). [자세한 정보는 여기에서 확인하세요](webview-attacks.md#javascript-enabled).
* **로컬 파일 포함:** WebView는 파일 시스템에 대한 액세스가 비활성화되어 있어야 합니다 (기본적으로 활성화됨) - `(webview.getSettings().setAllowFileAccess(false);)`. [자세한 정보는 여기에서 확인하세요](webview-attacks.md#javascript-enabled).
* **영구 쿠키**: Android 애플리케이션이 세션을 종료할 때 쿠키가 폐기되지 않거나 디스크에 저장될 수 있습니다.
* [**쿠키의 Secure 플래그**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 가입하여 경험 많은 해커 및 버그 바운티 헌터와 소통하세요!

**해킹 인사이트**\
해킹의 스릴과 도전을 다루는 콘텐츠와 상호 작용하세요.

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰력을 통해 빠르게 변화하는 해킹 세계를 따라가세요.

**최신 공지사항**\
새로운 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대한 정보를 받아보세요.

**[Discord](https://discord.com/invite/N3FrSbmwdy)에 가입하여 최고의 해커들과 협업을 시작하세요!**

## 자동 분석

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**정적 분석**

![](<../../.gitbook/assets/image (61).png>)

**애플리케이션의 취약점 평가**를 위한 멋진 웹 기반 프론트엔드. 동적 분석도 수행할 수 있습니다 (하지만 환경을 준비해야 함).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSF는 **Android**(apk)**, IOS**(ipa) 및 Windows**(apx) 애플리케이션을 분석할 수 있습니다 (_Windows 애플리케이션은 Windows 호스트에 설치된 MobSF에서 분석해야 합니다_).\
또한, **Android** 또는 **IOS** 앱의 소스 코드를 **ZIP** 파일로 만들면 (애플리케이션의 루트 폴더로 이동하여 모두 선택한 다음 ZIP 파일을 만듭니다), MobSF에서도 분석할 수 있습니다.

MobSF는 또한 **diff/비교** 분석과 **VirusTotal** 통합을 지원합니다 (API 키를 _MobSF/settings.py_에 설정하고 활성화해야 합니다: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`). `VT_UPLOAD`를 `False`로 설정하면 파일 대신 **해시**가 업로드됩니다.

### MobSF를 사용한 보조 동적 분석

**MobSF**는 **Android**에서 동적 분석에 매우 유용할 수 있습니다. 그러나 이 경우에는 MobSF와 **genymotion**을 호스트에 설치해야 합니다 (VM이나 Docker는 작동하지 않습니다). _참고: **먼저 genymotion에서 VM을 시작**한 다음 **MobSF를 시작**해야 합니다._

**MobSF 동적 분석기**는 다음을 수행할 수 있습니다:

* **애플리케이션 데이터 덤프** (URL, 로그, 클립보드, 사용자가 캡처한 스크린샷, "**Exported Activity Tester**"가 캡처한 스크린샷, 이메일, SQLite 데이터베이스, XML 파일 및 기타 생성된 파일). 스크린샷을 제외한 모든 작업은 자동으로 수행되며, 스크린샷을 원할 때 누르거나 모든 내보낸 액티비티의 스크린샷을 얻으려면 "**Exported Activity Tester**"를 눌러야 합니다.
* **HTTPS 트래픽 캡처**
* **Frida**를 사용하여 **런타임 정보** 획득

**Android 버전 > 5**에서는 **자동으로 Frida를 시작**하고 전역 **프록시** 설정을 **캡처** 트래픽으로 설정합니다. 테스트된 애플리케이션에서만 트래픽을 캡처합니다.

**Frida**

기본적으로, MobSF는 SSL 핀단 우회, 루트 탐지 및 디버거 탐지를 우회하고 흥미로운 API를 모니터링하기 위해 일부 Frida 스크립트를 사용합니다.\
MobSF는 또한 내보낸 액티비티를 **호출**, 해당 액티비티의 **스크린샷**을 캡처하고 보고서에 **저장**할 수 있습니다.

동적 테스트를 시작하려면 "**Start Instrumentation**" 버튼을 누르세요. Frida 스크립트가 생성한 로그를 보려면 "**Frida Live Logs**"를 누르고, 후킹된 메서드에 대한 모든 호출, 전달된 인수 및 반환값을 볼려면 "**Live API Monitor**"를 누르세요 ("Start Instrumentation"을 누른 후에 나타납니다).\
MobSF는 사용자의 자체 **Frida 스크립트**를 로드할 수도 있습니다 (결과를 MobSF로 보내려면 `send()` 함수를 사용하세요). 또한 로드할 수 있는 **여러 사전 작성된 스크립트**가 있습니다 (`MobSF/DynamicAnalyzer/tools/frida_scripts/others/`에 추가할 수 있습니다). 그냥 **선택**하고 "**Load**"를 누르고 "**Start Instrumentation**"을 누르세요 (해당 스크립트의 로그를 "**Frida Live Logs**"에서 볼 수 있습니다).

![](<../../.gitbook/assets/image (215).png>)

또한, 일부 보조 Frida 기능을 사용할 수 있습니다:

* **로드된 클래스 열거**: 로드된 모든 클래스를 출력합니다.
* **문자열 캡처**: 애플리케이션 사용 중에 캡처된 모든 문자열을 출력합니다 (매우 노이즈가 많음).
* **문자열 비교 캡처**: 매우 유용할 수 있습니다. 비교된 2개의 문자열과 결과(True 또는 False)를 표시합니다.
* **클래스 메서드 열거**: 클래스 이름(예: "java.io.File")을 입력하면 클래스의 모든 메서드를 출력합니다.
* **클래스 패턴 검색**: 패턴으로 클래스를 검색합니다.
* **클래스 메서드 추적**: 클래스 전체를 추적합니다 (클래스의 모든 메서드의 입력 및 출력을 볼 수 있습니다). 기본적으로 MobSF는 몇 가지 흥미로운 Android API 메서드를 추적합니다.

사용하려는 보조 모듈을 선택한 후 "**Start Intrumentation**"을 누르면 모든 출력을 "**Frida Live Logs**"에서 볼 수 있습니다.

**Shell**

Mobsf는 동적 분석 페이지의 하단에 일부 **adb** 명령, **MobSF 명령** 및 일반적인 **shell 명령**을 제공합니다. 일부 흥미로운 명령어:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

HTTP 트래픽을 캡처하면 "**HTTP(S) 트래픽**" 하단에서 캡처된 트래픽의 불편한 모습을 볼 수 있거나 "**Start HTTPTools**" 녹색 버튼에서 더 나은 모습을 볼 수 있습니다. 두 번째 옵션에서는 캡처된 요청을 Burp나 Owasp ZAP와 같은 프록시로 **보낼 수 있습니다**.\
이를 위해, _Burp를 켜고 -->_ _Intercept를 끄고 --> MobSB HTTPTools에서 요청을 선택_ --> "**Send to Fuzzer**"를 누르고 --> _프록시 주소를 선택합니다_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF를 사용하여 동적 분석을 완료한 후 "**Start Web API Fuzzer**"를 눌러 **HTTP 요청을 퍼징**하고 취약점을 찾을 수 있습니다.

{% hint style="info" %}
MobSF로 동적 분석을 수행한 후 프록시 설정이 잘못되어 GUI에서 수정할 수 없는 경우가 있습니다. 프록시 설정을 수정하려면 다음을 수행할 수 있습니다:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Inspeckage를 사용한 도움되는 동적 분석

[**Inspeckage**](https://github.com/ac-pm/Inspeckage)에서 도구를 얻을 수 있습니다.\
이 도구는 몇 가지 **훅**을 사용하여 **애플리케이션에서 무슨 일이 일어나고 있는지** 동적 분석을 수행하는 동안 알려줍니다.


### [Yaazhini](https://www.vegabird.com/yaazhini/)

이것은 **GUI로 정적 분석을 수행하는 훌륭한 도구**입니다.

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

이 도구는 **소스 코드** 또는 **패키지된 APK**에서 여러 **보안 관련 Android 애플리케이션 취약점**을 찾기 위해 설계되었습니다. 이 도구는 또한 발견된 취약점 중 일부를 악용하기 위해 "Proof-of-Concept" 배포 가능한 APK 및 ADB 명령을 생성할 수 있습니다 (노출된 액티비티, 인텐트, 탭잭킹 등). Drozer와 마찬가지로 테스트 기기를 루팅할 필요가 없습니다.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* 쉬운 참조를 위해 모든 추출된 파일을 표시합니다.
* APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일합니다.
* 일반적인 취약점과 동작을 위해 AndroidManifest.xml을 분석합니다.
* 일반적인 취약점과 동작을 위한 정적 소스 코드 분석
* 기기 정보
* 그 외 다양한 기능들
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 명령줄 응용 프로그램으로, 취약점을 찾기 위해 _.apk_ 파일을 분석합니다. 이를 위해 APK를 압축 해제하고 취약점을 감지하기 위해 일련의 규칙을 적용합니다.

모든 규칙은 `rules.json` 파일에 중심을 두고 있으며, 각 회사나 테스터는 필요에 따라 자체 규칙을 생성할 수 있습니다.

최신 바이너리를 [다운로드 페이지](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAn은 모바일 애플리케이션에 대한 정적 코드 분석을 수행하는 개발자, 버그 바운티 헌터 및 윤리적 해커들을 돕는 **크로스 플랫폼** 도구입니다.

이 개념은 StaCoAn 애플리케이션에 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 끌어다 놓으면 시각적이고 휴대 가능한 보고서를 생성합니다. 설정과 단어 목록을 조정하여 사용자 정의 경험을 얻을 수 있습니다.

[최신 릴리스](https://github.com/vincentcox/StaCoAn/releases) 다운로드:
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Framework은 안드로이드 애플리케이션에서 잠재적인 보안 취약점을 찾는 데 도움이 되는 안드로이드 취약점 분석 시스템입니다. 개발자나 해커들이 안드로이드 애플리케이션에서 잠재적인 보안 취약점을 찾는 데 도움이 됩니다.\
[Windows 릴리스](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**은 주로 Android 애플리케이션에서 개발된 잠재적으로 악성 행위를 감지하고 사용자에게 경고하는 도구입니다.

이 도구는 [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용하여 애플리케이션의 Dalvik 바이트 코드를 **Smali**로 표현하여 **정적 분석**을 수행합니다.

이 도구는 전화 식별자 유출, 오디오/비디오 흐름 가로채기, PIM 데이터 수정, 임의의 코드 실행과 같은 **"나쁜" 애플리케이션의 일반적인 동작**을 찾습니다.
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA**는 **M**obile **A**pplication **R**everse engineering and **A**nalysis Framework의 약자입니다. 이 도구는 일반적으로 사용되는 모바일 애플리케이션 역공학 및 분석 도구를 모아서 OWASP 모바일 보안 위협에 대한 모바일 애플리케이션 테스트를 지원합니다. 그 목표는 모바일 애플리케이션 개발자와 보안 전문가들에게 이 작업을 더 쉽고 친숙하게 만드는 것입니다.

다음과 같은 작업을 수행할 수 있습니다:

* 다양한 도구를 사용하여 Java 및 Smali 코드 추출
* [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)를 사용하여 APK 분석
* 정규식을 사용하여 APK에서 개인 정보 추출
* Manifest 분석
* [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 및 [whatweb](https://github.com/urbanadventurer/WhatWeb)을 사용하여 찾은 도메인 분석
* [apk-deguard.com](http://www.apk-deguard.com)을 통해 APK의 난독화 해제

### Koodous

악성 코드를 감지하는 데 유용합니다: [https://koodous.com/](https://koodous.com)

## 코드 난독화/해독

코드를 난독화하는 서비스와 구성에 따라 비밀 정보가 난독화되었을 수도 있고 그렇지 않을 수도 있음에 유의하십시오.

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

[Wikipedia](https://en.wikipedia.org/wiki/ProGuard\_\(software\))에서 가져온 내용: **ProGuard**는 Java 코드를 축소, 최적화 및 난독화하는 오픈 소스 명령 줄 도구입니다. ProGuard는 바이트 코드를 최적화하고 사용되지 않는 명령을 감지하고 제거할 수 있습니다. ProGuard는 무료 소프트웨어이며 GNU General Public License, version 2로 배포됩니다.

ProGuard는 Android SDK의 일부로 제공되며 릴리스 모드로 애플리케이션을 빌드할 때 실행됩니다.


### [DexGuard](https://www.guardsquare.com/dexguard)

[https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)에서 apk의 난독화 해제에 대한 단계별 가이드를 찾을 수 있습니다.

(해당 가이드에서) 마지막으로 확인한 Dexguard의 작동 모드는 다음과 같습니다:

* InputStream으로 리소스를 로드합니다.
* 결과를 해독하기 위해 FilterInputStream을 상속하는 클래스에 전달합니다.
* 일부 무의미한 난독화를 수행하여 역공학자의 시간을 몇 분 낭비합니다.
* 해독된 결과를 ZipInputStream에 전달하여 DEX 파일을 얻습니다.
* `loadDex` 메서드를 사용하여 결과 DEX를 리소스로 로드합니다.

### [DeGuard](http://apk-deguard.com)

**DeGuard는 Android 난독화 도구에 의해 수행된 난독화 과정을 역전시킵니다. 이를 통해 코드 검사 및 라이브러리 예측 등 다양한 보안 분석이 가능합니다.**

난독화된 APK를 해당 플랫폼에 업로드할 수 있습니다.

### [Simplify](https://github.com/CalebFenton/simplify)

**일반적인 안드로이드 해독기**입니다. Simplify는 앱을 가상으로 실행하여 동작을 이해한 다음 코드를 최적화하여 동일한 동작을 수행하지만 사람이 이해하기 쉽도록 만듭니다. 각 최적화 유형은 간단하고 일반적이므로 특정 난독화 유형에 상관없이 작동합니다.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD는 **APK가 생성된 방식에 대한 정보**를 제공합니다. 다양한 **컴파일러**, **패커**, **난독화 도구** 및 기타 이상한 것들을 식별합니다. 이것은 Android의 [_PEiD_](https://www.aldeid.com/wiki/PEiD)입니다.

### 수동

[**사용자 정의 난독화를 역전시키는 방법에 대한** 튜토리얼을 읽어보세요](manual-deobfuscation.md)

## 랩

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b는 리버스 엔지니어링 및 악성 코드 분석을 위한 다양한 보안 전문가와 연구원들의 최신 프레임워크, 튜토리얼 및 랩을 포함한 우분투-메이트 기반의 Android 보안 가상 머신입니다.

## 참고 자료

* [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 이곳은 많은 리소스가 있는 좋은 목록입니다.
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 빠른 강좌
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
* [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## 아직 시도해보지 않음

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 가입하여 경험 많은 해커와 버그 바운티 헌터들과 소통하세요!

**해킹 인사이트**\
해킹의 스릴과 도전에 대해 다루는 콘텐츠와 상호 작용하세요.

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰력을 통해 빠르게 변화하는 해킹 세계를 따라가세요.

**최신 공지사항**\
새로운 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대한 정보를 받아보세요.

**[Discord](https://discord.com/invite/N3FrSbmwdy)에 가입하여 최고의 해커들과 협업을 시작하세요!**

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로에서 영웅까지 AWS 해킹을 배워보세요**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고
