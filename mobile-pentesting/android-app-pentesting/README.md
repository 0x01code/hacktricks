# Android Applications Pentesting

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug bounty!

**Insight sull'hacking**\
Interagisci con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Notizie sull'hacking in tempo reale**\
Resta aggiornato sul mondo dell'hacking frenetico attraverso notizie e approfondimenti in tempo reale

**Ultime notizie**\
Rimani informato sul lancio delle nuove bug bounty e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi stesso!

## Concetti di base delle applicazioni Android

√à altamente consigliato iniziare a leggere questa pagina per conoscere le **parti pi√π importanti relative alla sicurezza di Android e i componenti pi√π pericolosi in un'applicazione Android**:

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB (Android Debug Bridge)

Questo √® lo strumento principale di cui hai bisogno per connetterti a un dispositivo Android (emulato o fisico).\
**ADB** consente di controllare i dispositivi tramite **USB** o **Rete** da un computer. Questa utility consente la **copia** di file in entrambe le direzioni, l'**installazione** e la **disinstallazione** di app, l'**esecuzione** di comandi shell, il **backup** dei dati, la **lettura** dei log, tra le altre funzioni.

Dai un'occhiata alla seguente lista di [**Comandi ADB**](adb-commands.md) per imparare come utilizzare adb.

## Smali

A volte √® interessante **modificare il codice dell'applicazione** per accedere a **informazioni nascoste** (ad esempio password o flag ben oscurati). Quindi, potrebbe essere interessante decompilare l'apk, modificare il codice e ricompilarlo.\
[**In questo tutorial** puoi **imparare come decompilare un APK, modificare il codice Smali e ricompilare l'APK** con la nuova funzionalit√†](smali-changes.md). Questo potrebbe essere molto utile come **alternativa per diversi test durante l'analisi dinamica** che verranno presentati. Quindi, **tieni sempre presente questa possibilit√†**.

## Altri trucchi interessanti

* [Falsificare la tua posizione su Play Store](spoofing-your-location-in-play-store.md)
* **Scarica APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* Estrai APK dal dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
## Analisi statica

Innanzitutto, per analizzare un APK dovresti **dare un'occhiata al codice Java** utilizzando un decompiler.\
Per favore, [**leggi qui per trovare informazioni sui diversi decompiler disponibili**](apk-decompilers.md).

### Ricerca di informazioni interessanti

Semplicemente dando un'occhiata alle **stringhe** dell'APK puoi cercare **password**, **URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **chiavi api**, **crittografia**, **UUID Bluetooth**, **token** e qualsiasi altra cosa interessante... cerca anche backdoor di esecuzione del codice o backdoor di autenticazione (credenziali admin codificate nell'app).

**Firebase**

Presta particolare attenzione agli **URL di Firebase** e verifica se sono configurati in modo errato. [Ulteriori informazioni su cosa √® Firebase e come sfruttarlo qui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensione di base dell'applicazione - Manifest.xml, strings.xml

L'**esame dei file _Manifest.xml_ e _strings.xml_ di un'applicazione pu√≤ rivelare potenziali vulnerabilit√† di sicurezza**. Questi file possono essere accessibili utilizzando decompiler o rinominando l'estensione del file APK in .zip e quindi decomprimendolo.

Le **vulnerabilit√†** identificate dal **Manifest.xml** includono:

* **Applicazioni in modalit√† di debug**: Le applicazioni impostate come debuggable (`debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio in quanto consentono connessioni che possono portare a sfruttamenti. Per una comprensione pi√π approfondita su come sfruttare le applicazioni in modalit√† di debug, consulta un tutorial su come trovare ed esplorare le applicazioni in modalit√† di debug su un dispositivo.

* **Impostazioni di backup**: L'attributo `android:allowBackup="false"` dovrebbe essere impostato esplicitamente per le applicazioni che gestiscono informazioni sensibili per impedire il backup non autorizzato dei dati tramite adb, soprattutto quando il debug USB √® abilitato.

* **Sicurezza di rete**: Le configurazioni personalizzate di sicurezza di rete (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come pin dei certificati e impostazioni del traffico HTTP. Un esempio √® consentire il traffico HTTP per domini specifici.

* **Attivit√† e servizi esportati**: L'individuazione di attivit√† e servizi esportati nel manifesto pu√≤ evidenziare componenti che potrebbero essere utilizzati impropriamente. Un'analisi ulteriore durante il testing dinamico pu√≤ rivelare come sfruttare questi componenti.

* **Provider di contenuti e FileProviders**: I provider di contenuti esposti potrebbero consentire l'accesso o la modifica non autorizzati dei dati. Anche la configurazione dei FileProviders dovrebbe essere attentamente esaminata.

* **Broadcast Receiver e URL Scheme**: Questi componenti potrebbero essere sfruttati per scopi malevoli, prestando particolare attenzione a come vengono gestiti gli URL Scheme per le vulnerabilit√† di input.

* **Versioni SDK**: Gli attributi `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicano le versioni di Android supportate, evidenziando l'importanza di non supportare versioni obsolete e vulnerabili di Android per motivi di sicurezza.

Dal file **strings.xml**, √® possibile scoprire informazioni sensibili come chiavi API, schemi personalizzati e altre note degli sviluppatori, sottolineando la necessit√† di una revisione attenta di queste risorse.


### Tapjacking

**Tapjacking** √® un attacco in cui un'applicazione **malintenzionata** viene avviata e si posiziona sopra un'applicazione vittima. Una volta che oscura visivamente l'app vittima, la sua interfaccia utente √® progettata in modo tale da ingannare l'utente a interagire con essa, mentre passa l'interazione all'app vittima.\
In pratica, **acceca l'utente facendogli credere di eseguire azioni sull'app vittima**.

Trova ulteriori informazioni in:

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### Task Hijacking

Un'**attivit√†** con **`launchMode`** impostato su **`singleTask` senza alcun `taskAffinity`** definito √® vulnerabile all'hijacking del task. Ci√≤ significa che un'**applicazione** pu√≤ essere installata e se viene avviata prima dell'applicazione reale pu√≤ **dirottare il task dell'applicazione reale** (quindi l'utente interagir√† con l'applicazione malevola pensando di utilizzare quella reale).

Ulteriori informazioni in:

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### Archiviazione non sicura dei dati

**Archiviazione interna**

In Android, i file **archiviati** nell'**archiviazione interna** sono **progettati** per essere **accessibili** esclusivamente dall'**app** che li ha **creati**. Questa misura di sicurezza √® **imposta** dal sistema operativo Android ed √® generalmente adeguata alle esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, gli sviluppatori talvolta utilizzano modalit√† come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **consentire** la condivisione di file tra diverse applicazioni. Tuttavia, queste modalit√† **non limitano l'accesso** a questi file da parte di altre applicazioni, comprese quelle potenzialmente malevole.

1. **Analisi statica:**
- **Assicurarsi** che l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` sia **scrupolosamente esaminato**. Queste modalit√† **possono potenzialmente esporre** i file a **accessi non intenzionali o non autorizzati**.

2. **Analisi dinamica:**
- **Verificare** le **autorizzazioni** impostate sui file creati dall'app. In particolare, **verificare** se alcuni file sono **impostati come leggibili o scrivibili a livello globale**. Ci√≤ pu√≤ rappresentare un rischio significativo per la sicurezza, in quanto consentirebbe a **qualsiasi applicazione** installata sul dispositivo, indipendentemente dalla sua origine o intento, di **leggere o modificare** questi file.

**Archiviazione esterna**

Quando si lavora con file su **archiviazione esterna**, come le schede SD, √® necessario prendere alcune precauzioni:

1. **Accessibilit√†**:
- I file su archiviazione esterna sono **leggibili e scrivibili globalmente**. Ci√≤ significa che qualsiasi applicazione o utente pu√≤ accedere a questi file.

2. **Preoccupazioni per la sicurezza**:
- Date le facilit√† di accesso, √® consigliabile **non archiviare informazioni sensibili** su archiviazione esterna.
- L'archiviazione esterna pu√≤ essere rimossa o accessibile da qualsiasi applicazione, rendendola meno sicura.

3. **Gestione dei dati da archiviazione esterna**:
- Effettuare sempre una **validazione dell'input** sui dati recuperati dall'archiviazione esterna. Questo √® fondamentale perch√© i dati provengono da una fonte non attendibile.
- √à fortemente sconsigliato archiviare eseguibili o file di classe su archiviazione esterna per il caricamento dinamico.
- Se la tua applicazione deve recuperare file eseguibili da archiviazione esterna, assicurati che questi file siano **firmati e verificati crittograficamente** prima di essere caricati dinamicamente. Questo passaggio √® fondamentale per mantenere l'integrit√† della sicurezza della tua applicazione.

L'archiviazione esterna pu√≤ essere **accessibile** in `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

{% hint style="info" %}
A partire da Android 4.4 (**API 17**), la scheda SD ha una struttura delle directory che **limita l'accesso di un'app alla directory specifica per quell'app**. Ci√≤ impedisce alle applicazioni malevole di ottenere accesso in lettura o scrittura ai file di un'altra app.
{% endhint %}

**Dati sensibili archiviati in chiaro**

* **Preferenze condivise**: Android consente a ogni applicazione di salvare facilmente file XML nel percorso `/data/data/<nomedelpackage>/shared_prefs/` e talvolta √® possibile trovare informazioni sensibili in chiaro in quella cartella.
* **Database**: Android consente a ogni applicazione di salvare facilmente database SQLite nel percorso `/data/data/<nomedelpackage>/databases/` e talvolta √® possibile trovare informazioni sensibili in chiaro in quella cartella.

### TLS non sicuro

**Accettare tutti i certificati**

Per qualche motivo, a volte gli sviluppatori accettano tutti i certificati anche se, ad esempio, il nome host non corrisponde con righe di codice come la seguente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Un buon modo per testare ci√≤ √® cercare di catturare il traffico utilizzando un proxy come Burp senza autorizzare Burp CA all'interno del dispositivo. Inoltre, √® possibile generare con Burp un certificato per un nome host diverso e utilizzarlo.

### Crittografia non sicura

**Processi di gestione delle chiavi scadenti**

Alcuni sviluppatori salvano dati sensibili nella memoria locale e li crittografano con una chiave codificata/predicibile nel codice. Questo non dovrebbe essere fatto poich√© un'operazione di reversing potrebbe consentire agli attaccanti di estrarre le informazioni confidenziali.

**Utilizzo di algoritmi non sicuri e/o deprecati**

Gli sviluppatori non dovrebbero utilizzare algoritmi **deprecati** per eseguire **controlli** di **autorizzazione**, **memorizzare** o **inviare** dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se ad esempio vengono utilizzati hash per memorizzare le password, dovrebbero essere utilizzati hash resistenti all'attacco di forza bruta con salt.

### Altri controlli

* √à consigliabile **oscurare l'APK** per rendere pi√π difficile il lavoro di reverse engineering agli attaccanti.
* Se l'app √® sensibile (come le app bancarie), dovrebbe effettuare i **propri controlli per verificare se il dispositivo mobile √® rootato** e agire di conseguenza.
* Se l'app √® sensibile (come le app bancarie), dovrebbe verificare se viene utilizzato un **emulatore**.
* Se l'app √® sensibile (come le app bancarie), dovrebbe **verificare la propria integrit√† prima di eseguirsi** per verificare se √® stata modificata.
* Utilizzare [**APKiD**](https://github.com/rednaga/APKiD) per verificare quale compilatore/packer/obfuscator √® stato utilizzato per creare l'APK.

### Applicazione React Native

Leggi la seguente pagina per imparare come accedere facilmente al codice JavaScript delle applicazioni React:

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Applicazioni Xamarin

Leggi la seguente pagina per imparare come accedere facilmente al codice C# di un'applicazione Xamarin:

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### Applicazioni Superpacked

Secondo questo [**post del blog**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), Superpacked √® un algoritmo Meta che comprime il contenuto di un'applicazione in un singolo file. Il blog parla della possibilit√† di creare un'app che decomprime questo tipo di app... e un modo pi√π veloce che consiste nell'**eseguire l'applicazione e raccogliere i file decompressi dal filesystem**.

### Analisi statica automatizzata del codice

Lo strumento [**mariana-trench**](https://github.com/facebook/mariana-trench) √® in grado di individuare **vulnerabilit√†** analizzando il **codice** dell'applicazione. Questo strumento contiene una serie di **fonti conosciute** (che indicano allo strumento i **luoghi** in cui l'**input** √® **controllato dall'utente**), **sink** (che indicano allo strumento **luoghi pericolosi** in cui l'input utente malintenzionato potrebbe causare danni) e **regole**. Queste regole indicano la **combinazione** di **fonti-sink** che indica una vulnerabilit√†.

Con questa conoscenza, **mariana-trench esaminer√† il codice e trover√† possibili vulnerabilit√†**.

### Leaks di segreti

Un'applicazione potrebbe contenere segreti (API key, password, URL nascosti, sottodomini...) al suo interno che potresti essere in grado di scoprire. Puoi utilizzare uno strumento come [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass dell'autenticazione biometrica

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### Altre funzioni interessanti

* **Esecuzione di codice**: `Runtime.exec(), ProcessBuilder(), codice nativo: system()`
* **Invio di SMS**: `sendTextMessage, sendMultipartTestMessage`
* **Funzioni native** dichiarate come `native`: `public native, System.loadLibrary, System.load`
* [Leggi questo per imparare **come invertire le funzioni native**](reversing-native-libraries.md)

### **Altri trucchi**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug!

**Hacking Insights**\
Interagisci con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Notizie sull'hacking in tempo reale**\
Resta aggiornato sul mondo dell'hacking frenetico attraverso notizie e approfondimenti in tempo reale

**Ultime novit√†**\
Rimani informato sul lancio delle nuove taglie di bug e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi stesso!

***

## Analisi dinamica

> Innanzitutto, √® necessario un ambiente in cui √® possibile installare l'applicazione e tutto l'ambiente (certificato Burp CA, Drozer e Frida principalmente). Pertanto, √® estremamente consigliato un dispositivo rootato (emulato o meno).

### Analisi dinamica online

Puoi creare un **account gratuito** su: [https://appetize.io/](https://appetize.io). Questa piattaforma ti consente di **caricare** ed **eseguire** APK, quindi √® utile per vedere come si comporta un APK.

Puoi persino **visualizzare i log della tua applicazione** sul web e connetterti tramite **adb**.

![](<../../.gitbook/assets/image (60).png>)

Grazie alla connessione ADB, puoi utilizzare **Drozer** e **Frida** all'interno degli emulatori.

### Analisi dinamica locale

#### Utilizzo di un emulatore

* [**Android Studio**](https://developer.android.com/studio) (Puoi creare dispositivi **x86** e **arm**, e secondo [**questo** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**ultime versioni x86** **supportano le librerie ARM** senza la necessit√† di un lento emulatore ARM).
* Impara come configurarlo in questa pagina:

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versione gratuita:** Personal Edition, √® necessario creare un account. _Si consiglia di **scaricare** la versione **CON**_ _**VirtualBox** per evitare errori potenziali._)
* [**Nox**](https://es.bignox.com) (Gratuito, ma non supporta Frida o Drozer).

{% hint style="info" %}
Quando si crea un nuovo emulatore su qualsiasi piattaforma, ricorda che pi√π grande √® lo schermo, pi√π lento sar√† l'emulatore. Quindi seleziona schermi piccoli se possibile.
{% endhint %}

Per **installare i servizi Google** (come AppStore) in Genymotion, √® necessario fare clic sul pulsante evidenziato in rosso nell'immagine seguente:

![](<../../.gitbook/assets/image (200) (1).png>)

Inoltre, nota che nella **configurazione della VM Android in Genymotion** puoi selezionare la modalit√† **Bridge Network** (questo sar√† utile se ti connetterai alla VM Android da una diversa VM con gli strumenti).
#### Utilizzare un dispositivo fisico

√à necessario attivare le opzioni di **debugging** ed √® consigliabile **eseguire il root**:

1. **Impostazioni**.
2. (Da Android 8.0) Seleziona **Sistema**.
3. Seleziona **Informazioni sul telefono**.
4. Premi **Numero build** 7 volte.
5. Torna indietro e troverai le **Opzioni sviluppatore**.

> Una volta installata l'applicazione, la prima cosa da fare √® provarla e indagare su cosa fa, come funziona e familiarizzare con essa.\
> Suggerisco di **effettuare questa analisi dinamica iniziale utilizzando l'analisi dinamica di MobSF + pidcat**, in modo da poter **imparare come funziona l'applicazione** mentre MobSF **acquisisce** molti **dati interessanti** che potrai rivedere in seguito.

### Divulgazione non intenzionale di dati

**Logging**

Gli sviluppatori dovrebbero fare attenzione a esporre informazioni di **debugging** pubblicamente, poich√© ci√≤ pu√≤ portare a falle di sicurezza con la divulgazione di dati sensibili. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` sono consigliati per monitorare i log dell'applicazione al fine di identificare e proteggere informazioni sensibili. **Pidcat** √® preferito per la sua facilit√† d'uso e leggibilit√†.

{% hint style="warning" %}
Nota che a partire da **versioni successive ad Android 4.0**, **le applicazioni possono accedere solo ai propri log**. Quindi le applicazioni non possono accedere ai log di altre app.\
In ogni caso, √® comunque consigliabile **non registrare informazioni sensibili**.
{% endhint %}

**Copia/Incolla nella cache del buffer**

Il framework basato sulla **clipboard** di Android consente la funzionalit√† di copia e incolla nelle app, ma rappresenta un rischio in quanto **altre applicazioni** possono **accedere** alla clipboard, potenzialmente esponendo dati sensibili. √à fondamentale **disabilitare le funzioni di copia/incolla** per sezioni sensibili di un'applicazione, come i dettagli della carta di credito, per evitare fughe di dati.

**Log di crash**

Se un'applicazione **si blocca** e **salva i log**, questi log possono essere utili agli attaccanti, soprattutto quando l'applicazione non pu√≤ essere decompilata. Per mitigare questo rischio, evitare di registrare i crash e, se i log devono essere trasmessi tramite la rete, assicurarsi che vengano inviati tramite un canale SSL per la sicurezza.

Come pentester, **cerca di dare un'occhiata a questi log**.

**Dati di analisi inviati a terze parti**

Le applicazioni spesso integrano servizi come Google Adsense, che possono involontariamente **divulgare dati sensibili** a causa di un'implementazione impropria da parte degli sviluppatori. Per identificare possibili fughe di dati, √® consigliabile **intercettare il traffico dell'applicazione** e verificare se vengono inviate informazioni sensibili a servizi di terze parti.

### Database SQLite

La maggior parte delle applicazioni utilizzer√† **database SQLite interni** per salvare le informazioni. Durante il pentest, **controlla** i **database** creati, i nomi delle **tabelle** e delle **colonne** e tutti i **dati** salvati, poich√© potresti trovare **informazioni sensibili** (che costituirebbero una vulnerabilit√†).\
I database dovrebbero trovarsi in `/data/data/nome.pacchetto/databases` come `/data/data/com.mwr.example.sieve/databases`

Se il database sta salvando informazioni confidenziali ed √® **crittografato** ma puoi **trovare** la **password** all'interno dell'applicazione, √® comunque una **vulnerabilit√†**.

Elenca le tabelle utilizzando `.tables` e elenca le colonne delle tabelle con `.schema <nome_tabella>`

### Drozer (Attivit√† di exploit, Content Provider e Servizi)

Da [Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** ti consente di **assumere il ruolo di un'app Android** e interagire con altre app. Pu√≤ fare **tutto ci√≤ che un'applicazione installata pu√≤ fare**, come utilizzare il meccanismo di comunicazione interprocesso (IPC) di Android e interagire con il sistema operativo sottostante.\
Drozer √® uno strumento utile per **sfruttare attivit√† esportate, servizi esportati e Content Provider**, come imparerai nelle sezioni seguenti.

### Sfruttare attivit√† esportate

[**Leggi questo se vuoi rinfrescarti su cosa sia un'attivit√† Android.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda anche che il codice di un'attivit√† inizia nel metodo **`onCreate`**.

**Bypass dell'autorizzazione**

Quando un'attivit√† viene esportata, √® possibile invocare la sua schermata da un'app esterna. Pertanto, se un'attivit√† con **informazioni sensibili** √® **esportata**, potresti **eludere** i meccanismi di **autenticazione** per accedervi.

[**Scopri come sfruttare le attivit√† esportate con Drozer.**](drozer-tutorial/#activities)

Puoi anche avviare un'attivit√† esportata da adb:

* PackageName √® com.example.demo
* Nome attivit√† esportata √® com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF rilever√† come dannoso l'uso di _**singleTask/singleInstance**_ come `android:launchMode` in un'attivit√†, ma a causa di [questo](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparentemente ci√≤ √® pericoloso solo nelle vecchie versioni (versioni API < 21).

{% hint style="info" %}
Nota che un bypass di autorizzazione non √® sempre una vulnerabilit√†, dipender√† da come funziona il bypass e quali informazioni vengono esposte.
{% endhint %}

**Divulgazione di informazioni sensibili**

**Le attivit√† possono anche restituire risultati**. Se riesci a trovare un'attivit√† esportata e non protetta che chiama il metodo **`setResult`** e **restituisce informazioni sensibili**, si tratta di una divulgazione di informazioni sensibili.

#### Tapjacking

Se il tapjacking non viene impedito, √® possibile abusare dell'attivit√† esportata per far s√¨ che l'**utente esegua azioni impreviste**. Per ulteriori informazioni su [**cosa √® il Tapjacking segui il link**](./#tapjacking).

### Sfruttare i Content Provider - Accesso e manipolazione di informazioni sensibili

[**Leggi questo se vuoi rinfrescare cosa √® un Content Provider.**](android-applications-basics.md#content-provider)\
I content provider vengono utilizzati principalmente per **condividere dati**. Se un'app dispone di content provider disponibili, potresti essere in grado di **estrarre dati sensibili** da essi. √à anche interessante testare possibili **iniezioni SQL** e **traversali di percorso** in quanto potrebbero essere vulnerabili.

[**Scopri come sfruttare i Content Provider con Drozer.**](drozer-tutorial/#content-providers)

### **Sfruttare i Servizi**

[**Leggi questo se vuoi rinfrescare cosa √® un Servizio.**](android-applications-basics.md#services)\
Ricorda che le azioni di un servizio iniziano nel metodo `onStartCommand`.

Un servizio √® fondamentalmente qualcosa che **pu√≤ ricevere dati**, **elaborarli** e **restituire** (o meno) una risposta. Quindi, se un'applicazione esporta alcuni servizi, dovresti **controllare** il **codice** per capire cosa sta facendo e **testarlo** **dinamicamente** per estrarre informazioni confidenziali, eludere le misure di autenticazione...\
[**Scopri come sfruttare i Servizi con Drozer.**](drozer-tutorial/#services)

### **Sfruttare i Ricevitori di Trasmissione**

[**Leggi questo se vuoi rinfrescare cosa √® un Ricevitore di Trasmissione.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un ricevitore di trasmissione iniziano nel metodo `onReceive`.

Un ricevitore di trasmissione sar√† in attesa di un tipo di messaggio. A seconda di come il ricevitore gestisce il messaggio, potrebbe essere vulnerabile.\
[**Scopri come sfruttare i Ricevitori di Trasmissione con Drozer.**](./#exploiting-broadcast-receivers)

### **Sfruttare gli Schemi / Deep links**

Puoi cercare i deep link manualmente, utilizzando strumenti come MobSF o script come [questo](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puoi **aprire** uno **schema** dichiarato utilizzando **adb** o un **browser**:

{% code overflow="wrap" %}
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_Nota che puoi **ommettere il nome del pacchetto** e il dispositivo mobile chiamer√† automaticamente l'app che dovrebbe aprire quel link._

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**Codice eseguito**

Per trovare il **codice che verr√† eseguito nell'app**, vai all'attivit√† chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**Informazioni sensibili**

Ogni volta che trovi un deeplink, controlla che **non stia ricevendo dati sensibili (come password) tramite parametri URL**, perch√© qualsiasi altra applicazione potrebbe **fingere il deeplink e rubare quei dati!**

**Parametri nel percorso**

Devi controllare anche se un deeplink sta utilizzando un parametro all'interno del percorso dell'URL come: `https://api.example.com/v1/users/{username}`, in tal caso puoi forzare una traversa del percorso accedendo a qualcosa del genere: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Nota che se trovi gli endpoint corretti all'interno dell'applicazione potresti essere in grado di causare un **Open Redirect** (se parte del percorso viene utilizzato come nome di dominio), **account takeover** (se puoi modificare i dettagli degli utenti senza token CSRF e l'endpoint vulnerabile utilizza il metodo corretto) e qualsiasi altra vulnerabilit√†. Maggiori [informazioni su questo qui](http://dphoeniixx.com/2020/12/13-2/).

**Altri esempi**

Un [interessante rapporto di bug bounty](https://hackerone.com/reports/855618) sui link (_/.well-known/assetlinks.json_).

### Fallimenti di ispezione e verifica del livello di trasporto

- **I certificati non vengono sempre ispezionati correttamente** dalle applicazioni Android. √à comune che queste applicazioni ignorino gli avvisi e accettino certificati autofirmati o, in alcuni casi, tornino a utilizzare connessioni HTTP.
- **Le negoziazioni durante la handshake SSL/TLS sono talvolta deboli**, utilizzando suite di cifratura non sicure. Questa vulnerabilit√† rende la connessione suscettibile ad attacchi di tipo man-in-the-middle (MITM), consentendo agli attaccanti di decifrare i dati.
- **La divulgazione di informazioni private** √® un rischio quando le applicazioni si autenticano utilizzando canali sicuri ma poi comunicano su canali non sicuri per altre transazioni. Questo approccio non protegge i dati sensibili, come i cookie di sessione o i dettagli dell'utente, dall'intercettazione da parte di entit√† malevole.

#### Verifica del certificato

Ci concentreremo sulla **verifica del certificato**. √à necessario verificare l'integrit√† del certificato del server per migliorare la sicurezza. Questo √® fondamentale perch√© le configurazioni TLS non sicure e la trasmissione di dati sensibili su canali non crittografati possono comportare rischi significativi. Per dettagliati passaggi sulla verifica dei certificati del server e sulla risoluzione delle vulnerabilit√†, **[questa risorsa](https://manifestsecurity.com/android-application-security-part-10/)** fornisce una guida completa.

#### SSL Pinning

SSL Pinning √® una misura di sicurezza in cui l'applicazione verifica il certificato del server rispetto a una copia nota memorizzata all'interno dell'applicazione stessa. Questo metodo √® essenziale per prevenire attacchi MITM. L'implementazione di SSL Pinning √® fortemente consigliata per le applicazioni che gestiscono informazioni sensibili.

#### Ispezione del traffico

Per ispezionare il traffico HTTP, √® necessario **installare il certificato dello strumento di proxy** (ad esempio, Burp). Senza installare questo certificato, il traffico crittografato potrebbe non essere visibile attraverso il proxy. Per una guida sull'installazione di un certificato CA personalizzato, **[clicca qui](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)**.

Le applicazioni che mirano a **API Level 24 e superiori** richiedono modifiche alla configurazione di sicurezza di rete per accettare il certificato CA del proxy. Questo passaggio √® fondamentale per l'ispezione del traffico crittografato. Per istruzioni su come modificare la configurazione di sicurezza di rete, **[consulta questo tutorial](make-apk-accept-ca-certificate.md)**.

#### Bypassare SSL Pinning

Quando viene implementato SSL Pinning, diventa necessario bypassarlo per ispezionare il traffico HTTPS. Sono disponibili vari metodi a tal fine:

* Modificare automaticamente l'**apk** per **bypassare** SSL Pinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Il vantaggio principale di questa opzione √® che non sar√† necessario ottenere i permessi di root per bypassare l'SSL Pinning, ma sar√† necessario eliminare l'applicazione e reinstallarne una nuova, e ci√≤ non funzioner√† sempre.
* Puoi utilizzare **Frida** (discusso di seguito) per bypassare questa protezione. Qui trovi una guida su come utilizzare Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
* Puoi anche provare a **bypassare automaticamente l'SSL Pinning** utilizzando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* Puoi anche provare a **bypassare automaticamente l'SSL Pinning** utilizzando l'**analisi dinamica di MobSF** (spiegata di seguito)
* Se pensi ancora che ci sia del traffico che non stai catturando, puoi provare a **inoltrare il traffico a burp utilizzando iptables**. Leggi questo blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Ricerca di vulnerabilit√† web comuni

√à importante cercare anche vulnerabilit√† web comuni all'interno dell'applicazione. Le informazioni dettagliate sull'individuazione e sulla mitigazione di queste vulnerabilit√† esulano dallo scopo di questo riassunto, ma sono ampiamente trattate altrove.

### Frida

[Frida](https://www.frida.re) √® un toolkit di strumenti di strumentazione dinamica per sviluppatori, reverse engineer e ricercatori di sicurezza.\
**Puoi accedere all'applicazione in esecuzione e agganciare i metodi in tempo di esecuzione per cambiare il comportamento, cambiare i valori, estrarre valori, eseguire codice diverso...**\
Se vuoi fare pentesting delle applicazioni Android, devi sapere come usare Frida.

* Impara come usare Frida: [**Tutorial su Frida**](frida-tutorial/)
* Alcuni "GUI" per azioni con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
* Ojection √® ottimo per automatizzare l'uso di Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
* Puoi trovare alcuni script Frida fantastici qui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)

### **Dump della memoria - Fridump**

Verifica se l'applicazione sta memorizzando informazioni sensibili all'interno della memoria che non dovrebbe memorizzare, come password o mnemonici.

Utilizzando [**Fridump3**](https://github.com/rootbsd/fridump3) puoi eseguire il dump della memoria dell'app con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo comando scaricher√† la memoria nella cartella ./dump, e da l√¨ potrai utilizzare il comando grep con qualcosa del genere:

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Dati sensibili nel Keystore**

In Android, il Keystore √® il posto migliore per archiviare dati sensibili, tuttavia, con sufficienti privilegi, √® ancora **possibile accedervi**. Poich√© le applicazioni tendono a memorizzare qui **dati sensibili in chiaro**, i test di penetrazione dovrebbero verificarlo poich√© un utente root o qualcuno con accesso fisico al dispositivo potrebbe essere in grado di rubare questi dati.

Anche se un'app memorizza dati nel keystore, i dati dovrebbero essere criptati.

Per accedere ai dati all'interno del keystore, √® possibile utilizzare questo script di Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Bypass delle impronte digitali/biometria**

Utilizzando lo script Frida seguente potrebbe essere possibile **bypassare l'autenticazione tramite impronte digitali** che le applicazioni Android potrebbero eseguire al fine di **proteggere determinate aree sensibili:**

{% code overflow="wrap" %}
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **Immagini di sfondo**

Quando si mette un'applicazione in background, Android memorizza uno **snapshot dell'applicazione** in modo che quando viene ripristinata in primo piano, inizia a caricare l'immagine prima dell'app in modo che sembri che l'app sia stata caricata pi√π velocemente.

Tuttavia, se questo snapshot contiene **informazioni sensibili**, qualcuno con accesso allo snapshot potrebbe **rubare tali informazioni** (nota che √® necessario il root per accedervi).

Gli snapshot di solito vengono memorizzati in: **`/data/system_ce/0/snapshots`**

Android fornisce un modo per **prevenire la cattura dello screenshot impostando il parametro FLAG\_SECURE**. Utilizzando questo flag, i contenuti della finestra vengono trattati come sicuri, impedendo che vengano visualizzati negli screenshot o su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizzatore di Applicazioni Android**

Questo strumento potrebbe aiutarti a gestire diversi strumenti durante l'analisi dinamica: [https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### Iniezione di Intent

Gli sviluppatori spesso creano componenti proxy come attivit√†, servizi e ricevitori di trasmissione che gestiscono questi Intent e li passano a metodi come `startActivity(...)` o `sendBroadcast(...)`, il che pu√≤ essere rischioso.

Il pericolo risiede nel permettere agli attaccanti di attivare componenti dell'app non esportati o accedere a provider di contenuti sensibili deviando questi Intent. Un esempio notevole √® il componente `WebView` che converte gli URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, potenzialmente portando a iniezioni di Intent dannose.

### Concetti Fondamentali
- **Iniezione di Intent** √® simile al problema di reindirizzamento aperto del web.
- Gli exploit coinvolgono il passaggio di oggetti `Intent` come extra, che possono essere reindirizzati per eseguire operazioni non sicure.
- Pu√≤ esporre componenti non esportati e provider di contenuti agli attaccanti.
- La conversione di URL di `WebView` in `Intent` pu√≤ facilitare azioni non intenzionali.

### Iniezioni lato client Android e altre

Probabilmente conosci questo tipo di vulnerabilit√† dal Web. Devi fare particolare attenzione a queste vulnerabilit√† in un'applicazione Android:

* **SQL Injection:** Quando si gestiscono query dinamiche o Content-Provider, assicurarsi di utilizzare query parametrizzate.
* **JavaScript Injection (XSS):** Verificare che il supporto JavaScript e dei plugin sia disabilitato per qualsiasi WebView (disabilitato per impostazione predefinita). [Maggiori informazioni qui](webview-attacks.md#javascript-enabled).
* **Local File Inclusion:** Le WebView dovrebbero avere l'accesso al file system disabilitato (abilitato per impostazione predefinita) - `(webview.getSettings().setAllowFileAccess(false);)`. [Maggiori informazioni qui](webview-attacks.md#javascript-enabled).
* **Cookie eterni**: In diversi casi, quando l'applicazione Android termina la sessione, il cookie non viene revocato o potrebbe persino essere salvato su disco.
* [**Secure Flag** nei cookie](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug bounty!

**Approfondimenti sull'Hacking**\
Interagisci con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Notizie sull'Hacking in Tempo Reale**\
Resta aggiornato sul mondo dell'hacking frenetico attraverso notizie e approfondimenti in tempo reale

**Ultime Novit√†**\
Rimani informato sul lancio delle nuove bug bounty e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi stesso!

## Analisi Automatica

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analisi statica**

![](<../../.gitbook/assets/image (61).png>)

**Valutazione delle vulnerabilit√† dell'applicazione** utilizzando un'interfaccia web-based piacevole. √à anche possibile eseguire un'analisi dinamica (ma √® necessario preparare l'ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Si noti che MobSF pu√≤ analizzare le applicazioni **Android** (apk), **IOS** (ipa) e **Windows** (apx) (le applicazioni Windows devono essere analizzate da un MobSF installato in un host Windows).\
Inoltre, se crei un file **ZIP** con il codice sorgente di un'app **Android** o **IOS** (vai alla cartella principale dell'applicazione, seleziona tutto e crea un file ZIP), sar√† in grado di analizzarlo anche.

MobSF consente anche di confrontare/analizzare le analisi e di integrare VirusTotal (√® necessario impostare la chiave API in MobSF/settings.py e abilitarla: `VT_ENABLED = TRUE` `VT_API_KEY = <La tua chiave API>` `VT_UPLOAD = TRUE`). √à anche possibile impostare `VT_UPLOAD` su `False`, quindi l'hash verr√† caricato invece del file.

### Analisi dinamica assistita con MobSF

MobSF pu√≤ essere molto utile anche per l'analisi dinamica su Android, ma in questo caso sar√† necessario installare MobSF e genymotion nel tuo host (una VM o Docker non funzioneranno). Nota: √® necessario **avviare prima una VM in genymotion** e **poi MobSF**.\
L'analizzatore dinamico di MobSF pu√≤:

* Estrarre i dati dell'applicazione (URL, log, appunti, screenshot effettuati da te, screenshot effettuati da "Exported Activity Tester", email, database SQLite, file XML e altri file creati). Tutto ci√≤ viene fatto automaticamente tranne gli screenshot, devi premere quando desideri uno screenshot o devi premere "Exported Activity Tester" per ottenere gli screenshot di tutte le attivit√† esportate.
* Catturare il traffico HTTPS
* Utilizzare Frida per ottenere informazioni in tempo reale

A partire dalle versioni di Android > 5, avvier√† automaticamente Frida e imposter√† le impostazioni globali del proxy per catturare il traffico. Catturer√† solo il traffico dall'applicazione testata.

Frida

Per impostazione predefinita, utilizzer√† anche alcuni script di Frida per aggirare il pinning SSL, la rilevazione del root e la rilevazione del debugger e per monitorare le API interessanti.\
MobSF pu√≤ anche invocare attivit√† esportate, acquisire screenshot di esse e salvarle per il report.

Per avviare il test dinamico, premi il pulsante verde: "Start Instrumentation". Premi "Frida Live Logs" per visualizzare i log generati dagli script di Frida e "Live API Monitor" per visualizzare tutte le invocazioni ai metodi hook, gli argomenti passati e i valori restituiti (questo apparir√† dopo aver premuto "Start Instrumentation").\
MobSF consente anche di caricare i propri script di Frida (per inviare i risultati dei tuoi script di Frida a MobSF utilizza la funzione `send()`). Ha anche diversi script predefiniti che √® possibile caricare (√® possibile aggiungerne altri in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta selezionarli, premere "Load" e premere "Start Instrumentation" (sarai in grado di vedere i log di quegli script all'interno di "Frida Live Logs").

![](<../../.gitbook/assets/image (215).png>)

Inoltre, hai alcune funzionalit√† ausiliarie di Frida:

* Enumera le classi caricate: Stampa tutte le classi caricate
* Cattura stringhe: Stampa tutte le stringhe catturate durante l'utilizzo dell'applicazione (molto rumoroso)
* Cattura confronti di stringhe: Potrebbe essere molto utile. Mostra le 2 stringhe confrontate e se il risultato √® stato True o False.
* Enumera i metodi di classe: Inserisci il nome della classe (come "java.io.File") e stamper√† tutti i metodi della classe.
* Cerca modello di classe: Cerca classi per modello
* Traccia i metodi di classe: Traccia un'intera classe (vedi input e output di tutti i metodi della classe). Ricorda che per impostazione predefinita MobSF traccia diversi metodi interessanti delle API Android.

Una volta selezionato il modulo ausiliario che desideri utilizzare, √® necessario premere "Start Intrumentation" e vedrai tutti gli output in "Frida Live Logs".

Shell

Mobsf ti offre anche una shell con alcuni comandi adb, comandi MobSF e comandi shell comuni nella parte inferiore della pagina di analisi dinamica. Alcuni comandi interessanti:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Strumenti HTTP**

Quando viene catturato il traffico HTTP, √® possibile visualizzare una vista poco attraente del traffico catturato nella sezione "**HTTP(S) Traffic**" in basso o una vista pi√π piacevole nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, √® possibile **inviare** le **richieste catturate** a **proxy** come Burp o Owasp ZAP.\
Per farlo, _accendere Burp -->_ _disattivare l'intercettazione --> in MobSB HTTPTools selezionare la richiesta_ --> premere "**Send to Fuzzer**" --> _selezionare l'indirizzo del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una volta completata l'analisi dinamica con MobSF, √® possibile premere su "**Start Web API Fuzzer**" per **fuzzare le richieste HTTP** e cercare vulnerabilit√†.

{% hint style="info" %}
Dopo aver eseguito un'analisi dinamica con MobSF, le impostazioni del proxy potrebbero essere configurate in modo errato e non sar√† possibile correggerle dall'interfaccia grafica. √à possibile correggere le impostazioni del proxy eseguendo:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Analisi dinamica assistita con Inspeckage

Puoi ottenere lo strumento da [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo strumento utilizza alcuni **Hooks** per farti sapere **cosa sta succedendo nell'applicazione** mentre esegui un'**analisi dinamica**.


### [Yaazhini](https://www.vegabird.com/yaazhini/)

Questo √® un **ottimo strumento per eseguire un'analisi statica con una GUI**

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

Questo strumento √® progettato per cercare diverse **vulnerabilit√† di sicurezza delle applicazioni Android**, sia nel **codice sorgente** che negli **APK confezionati**. Lo strumento √® inoltre **in grado di creare un APK "Proof-of-Concept" deployable** e **comandi ADB**, per sfruttare alcune delle vulnerabilit√† trovate (attivit√† esposte, intenti, tapjacking...). Come Drozer, non √® necessario eseguire il root del dispositivo di test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* Mostra tutti i file estratti per un facile riferimento
* Decompila automaticamente i file APK nel formato Java e Smali
* Analizza AndroidManifest.xml per vulnerabilit√† e comportamenti comuni
* Analisi statica del codice sorgente per vulnerabilit√† e comportamenti comuni
* Informazioni sul dispositivo
* e altro ancora
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER √® un'applicazione da linea di comando che pu√≤ essere utilizzata su Windows, MacOS X e Linux per analizzare i file _.apk_ alla ricerca di vulnerabilit√†. Lo fa decomprimendo gli APK e applicando una serie di regole per rilevare tali vulnerabilit√†.

Tutte le regole sono contenute in un file `rules.json`, e ogni azienda o tester pu√≤ creare le proprie regole per analizzare ci√≤ di cui ha bisogno.

Scarica le ultime versioni binarie dalla [pagina di download](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAn √® uno strumento **crossplatform** che aiuta sviluppatori, cacciatori di bug e hacker etici a eseguire l'analisi del codice statico sulle applicazioni mobili.

Il concetto √® che trascini e rilasci il file dell'applicazione mobile (un file .apk o .ipa) sull'applicazione StaCoAn e generer√† un rapporto visuale e portatile per te. Puoi personalizzare le impostazioni e le liste di parole per ottenere un'esperienza personalizzata.

Scarica l'[ultima versione](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Framework √® un sistema di analisi delle vulnerabilit√† di Android che aiuta sviluppatori o hacker a individuare potenziali vulnerabilit√† di sicurezza nelle applicazioni Android.\
[Rilasci per Windows](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** √® uno strumento il cui obiettivo principale √® rilevare e avvertire l'utente riguardo potenziali comportamenti maligni sviluppati da un'applicazione Android.

La rilevazione viene effettuata tramite l'**analisi statica** del bytecode Dalvik dell'applicazione, rappresentato come **Smali**, con la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento cerca comportamenti comuni delle "cattive" applicazioni come: esfiltrazione di identificatori telefonici, intercettazione di flussi audio/video, modifica dei dati PIM, esecuzione di codice arbitrario...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [Framework MARA](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA** √® un **F**ramework di **R**everse engineering e **A**nalisi di **A**pplicazioni **M**obili. √à uno strumento che riunisce strumenti comuni utilizzati per il reverse engineering e l'analisi di applicazioni mobili, al fine di testare le applicazioni mobili contro le minacce alla sicurezza mobile di OWASP. Il suo obiettivo √® rendere questa attivit√† pi√π facile e amichevole per gli sviluppatori di applicazioni mobili e i professionisti della sicurezza.

√à in grado di:

* Estrarre codice Java e Smali utilizzando diversi strumenti
* Analizzare gli APK utilizzando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
* Estrarre informazioni private dall'APK utilizzando espressioni regolari.
* Analizzare il Manifest.
* Analizzare i domini trovati utilizzando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
* Deobfuscare l'APK tramite [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com)

## Codice di obfuscamento/deobfuscamento

Si noti che a seconda del servizio e della configurazione utilizzati per obfuscare il codice, i segreti possono essere o meno obfuscati.

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

Da [Wikipedia](https://en.wikipedia.org/wiki/ProGuard\_\(software\)): **ProGuard** √® uno strumento open source a riga di comando che riduce, ottimizza e obfusca il codice Java. √à in grado di ottimizzare il bytecode e rilevare ed eliminare istruzioni inutilizzate. ProGuard √® un software gratuito e viene distribuito con la licenza GNU General Public License, versione 2.

ProGuard viene distribuito come parte dell'Android SDK e viene eseguito durante la compilazione dell'applicazione in modalit√† di rilascio.


### [DexGuard](https://www.guardsquare.com/dexguard)

Trova una guida passo-passo per deobfuscare l'APK su [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Da quella guida) L'ultima volta che abbiamo controllato, la modalit√† di funzionamento di Dexguard era:

* caricare una risorsa come InputStream;
* alimentare il risultato a una classe che eredita da FilterInputStream per decifrarlo;
* fare qualche obfuscazione inutile per sprecare alcuni minuti di tempo a un reverser;
* alimentare il risultato decifrato a un ZipInputStream per ottenere un file DEX;
* infine caricare il DEX risultante come una risorsa utilizzando il metodo `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverte il processo di obfuscazione eseguito dagli strumenti di obfuscazione di Android. Ci√≤ consente numerose analisi di sicurezza, inclusa l'ispezione del codice e la previsione delle librerie.**

√à possibile caricare un APK obfuscati sulla loro piattaforma.

### [Simplify](https://github.com/CalebFenton/simplify)

√à un **deobfuscator generico per Android.** Simplify **esegue virtualmente un'app** per comprendere il suo comportamento e quindi **cerca di ottimizzare il codice** in modo che si comporti in modo identico ma sia pi√π comprensibile per un essere umano. Ogni tipo di ottimizzazione √® semplice e generico, quindi non importa quale tipo specifico di obfuscazione viene utilizzato.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD fornisce informazioni su **come √® stato creato un APK**. Identifica molti **compilatori**, **packer**, **obfuscatore** e altre cose strane. √à [_PEiD_](https://www.aldeid.com/wiki/PEiD) per Android.

### Manuale

[Leggi questo tutorial per imparare alcuni trucchi su **come invertire l'obfuscazione personalizzata**](manual-deobfuscation.md)

## Laboratori

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b √® una macchina virtuale di sicurezza Android basata su ubuntu-mate che include la raccolta degli ultimi framework, tutorial e laboratori di diversi esperti di sicurezza e ricercatori per il reverse engineering e l'analisi del malware.

## Riferimenti

* [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) √à una grande lista di risorse
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Corso rapido su Android
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
* [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## Ancora da provare

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug!

**Hacking Insights**\
Interagisci con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Notizie di Hacking in Tempo Reale**\
Resta aggiornato sul mondo dell'hacking frenetico attraverso notizie e approfondimenti in tempo reale

**Ultime Novit√†**\
Rimani informato sul lancio delle ultime taglie di bug e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **e inizia a collaborare con i migliori hacker oggi stesso!**

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) **e** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
