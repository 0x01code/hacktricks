# Pentesting de Aplicaciones Android

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén [**artículos oficiales de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Únete al servidor de [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) para comunicarte con hackers experimentados y cazadores de bugs!

**Perspectivas de Hacking**\
Involúcrate con contenido que profundiza en la emoción y desafíos del hacking

**Noticias de Hacking en Tiempo Real**\
Mantente actualizado con el mundo del hacking a través de noticias e información en tiempo real

**Últimos Anuncios**\
Mantente informado sobre los nuevos programas de recompensas por bugs y actualizaciones importantes de plataformas

**Únete a nosotros en** [**Discord**](https://discord.com/invite/N3FrSbmwdy) y comienza a colaborar con los mejores hackers hoy!

## Conceptos Básicos de Aplicaciones Android

Se recomienda encarecidamente comenzar leyendo esta página para conocer las **partes más importantes relacionadas con la seguridad de Android y los componentes más peligrosos en una aplicación de Android**:

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB (Android Debug Bridge)

Esta es la herramienta principal que necesitas para conectarte a un dispositivo Android (emulado o físico).\
**ADB** permite controlar dispositivos ya sea por **USB** o por **Red** desde una computadora. Esta utilidad permite la **copia** de archivos en ambas direcciones, **instalación** y **desinstalación** de aplicaciones, **ejecución** de comandos de shell, **respaldo** de datos, **lectura** de registros, entre otras funciones.

Echa un vistazo a la siguiente lista de [**Comandos ADB**](adb-commands.md) para aprender cómo usar adb.

## Smali

A veces es interesante **modificar el código de la aplicación** para acceder a **información oculta** (quizás contraseñas bien ofuscadas o banderas). Entonces, podría ser interesante descompilar el apk, modificar el código y recompilarlo.\
[**En este tutorial** puedes **aprender cómo descompilar un APK, modificar el código Smali y recompilar el APK** con la nueva funcionalidad](smali-changes.md). Esto podría ser muy útil como una **alternativa para varias pruebas durante el análisis dinámico** que se van a presentar. Entonces, **siempre ten en cuenta esta posibilidad**.

## Otros trucos interesantes

* [Falsificar tu ubicación en Play Store](spoofing-your-location-in-play-store.md)
* **Descargar APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* Extraer APK del dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
## Análisis Estático

En primer lugar, para analizar un APK debes **echar un vistazo al código Java** utilizando un decompilador.\
Por favor, [**lee aquí para encontrar información sobre diferentes decompiladores disponibles**](apk-decompilers.md).

### Buscando información interesante

Simplemente echando un vistazo a las **cadenas de texto** del APK puedes buscar **contraseñas**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), claves **API**, **encriptación**, **UUIDs de bluetooth**, **tokens** y cualquier cosa interesante... busca incluso por **puertas traseras** de ejecución de código o puertas traseras de autenticación (credenciales de administrador codificadas en la aplicación).

**Firebase**

Presta especial atención a las **URLs de Firebase** y verifica si está mal configurado. [Más información sobre qué es Firebase y cómo explotarlo aquí.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensión básica de la aplicación - Manifest.xml, strings.xml

El **examen de los archivos** **_**Manifest.xml**_** y **_**strings.xml**_** de una aplicación puede revelar posibles vulnerabilidades de seguridad**. Estos archivos se pueden acceder utilizando decompiladores o cambiando la extensión del archivo APK a .zip y luego descomprimiéndolo.

Las **vulnerabilidades** identificadas en el **Manifest.xml** incluyen:

* **Aplicaciones en modo depuración**: Las aplicaciones configuradas como depurables (`debuggable="true"`) en el archivo _Manifest.xml_ representan un riesgo ya que permiten conexiones que pueden llevar a la explotación. Para comprender mejor cómo explotar aplicaciones en modo depuración, consulta un tutorial sobre cómo encontrar y explotar aplicaciones en modo depuración en un dispositivo.
* **Configuración de copias de seguridad**: El atributo `android:allowBackup="false"` debe establecerse explícitamente para aplicaciones que manejan información sensible para evitar copias de seguridad no autorizadas a través de adb, especialmente cuando la depuración por USB está habilitada.
* **Seguridad de red**: Las configuraciones personalizadas de seguridad de red (`android:networkSecurityConfig="@xml/network_security_config"`) en _res/xml/_ pueden especificar detalles de seguridad como pines de certificados y configuraciones de tráfico HTTP. Un ejemplo es permitir tráfico HTTP para dominios específicos.
* **Actividades y servicios exportados**: Identificar actividades y servicios exportados en el manifiesto puede resaltar componentes que podrían ser mal utilizados. Un análisis adicional durante las pruebas dinámicas puede revelar cómo explotar estos componentes.
* **Proveedores de contenido y FileProviders**: Los proveedores de contenido expuestos podrían permitir el acceso o modificación no autorizados de datos. También se debe examinar la configuración de los FileProviders.
* **Receptores de difusión y esquemas de URL**: Estos componentes podrían ser aprovechados para la explotación, prestando especial atención a cómo se gestionan los esquemas de URL para posibles vulnerabilidades de entrada.
* **Versiones del SDK**: Los atributos `minSdkVersion`, `targetSDKVersion` y `maxSdkVersion` indican las versiones de Android compatibles, resaltando la importancia de no admitir versiones antiguas y vulnerables de Android por razones de seguridad.

Desde el archivo **strings.xml**, se pueden descubrir información sensible como claves API, esquemas personalizados y otras notas de desarrollador, subrayando la necesidad de revisar cuidadosamente estos recursos.

### Tapjacking

**Tapjacking** es un ataque donde una **aplicación maliciosa** se lanza y **se posiciona sobre una aplicación víctima**. Una vez que oculta visualmente la aplicación víctima, su interfaz de usuario está diseñada de tal manera que engaña al usuario para que interactúe con ella, mientras pasa la interacción a la aplicación víctima.\
En efecto, **engaña al usuario para que no sepa que en realidad está realizando acciones en la aplicación víctima**.

Encuentra más información en:

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### Secuestro de tareas

Una **actividad** con el **`launchMode`** configurado como **`singleTask` sin ninguna `taskAffinity`** definida es vulnerable al secuestro de tareas. Esto significa que una **aplicación** puede ser instalada y si se lanza antes que la aplicación real, podría **secuestrar la tarea de la aplicación real** (por lo que el usuario estará interactuando con la **aplicación maliciosa pensando que está usando la real**).

Más información en:

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### Almacenamiento de datos inseguro

**Almacenamiento interno**

En Android, los archivos **almacenados** en el **almacenamiento interno** están **diseñados** para ser **accesibles** exclusivamente por la **aplicación** que los **creó**. Esta medida de seguridad es **aplicada** por el sistema operativo Android y generalmente es adecuada para las necesidades de seguridad de la mayoría de las aplicaciones. Sin embargo, a veces los desarrolladores utilizan modos como `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` para **permitir** que los archivos sean **compartidos** entre diferentes aplicaciones. Sin embargo, estos modos **no restringen el acceso** a estos archivos por otras aplicaciones, incluidas las potencialmente maliciosas.

1. **Análisis estático:**
* **Asegúrate** de que el uso de `MODE_WORLD_READABLE` y `MODE_WORLD_WRITABLE` se **examine cuidadosamente**. Estos modos **pueden exponer potencialmente** los archivos a **accesos no deseados o no autorizados**.
2. **Análisis dinámico:**
* **Verifica** los **permisos** establecidos en los archivos creados por la aplicación. Específicamente, **verifica** si algún archivo está **configurado para ser legible o escribible a nivel mundial**. Esto puede representar un riesgo de seguridad significativo, ya que permitiría que **cualquier aplicación** instalada en el dispositivo, independientemente de su origen o intención, **lea o modifique** estos archivos.

**Almacenamiento externo**

Al tratar con archivos en el **almacenamiento externo**, como las tarjetas SD, se deben tomar ciertas precauciones:

1. **Accesibilidad**:
* Los archivos en el almacenamiento externo son **legibles y escribibles globalmente**. Esto significa que cualquier aplicación o usuario puede acceder a estos archivos.
2. **Preocupaciones de seguridad**:
* Dada la facilidad de acceso, se recomienda **no almacenar información sensible** en el almacenamiento externo.
* El almacenamiento externo puede ser eliminado o accedido por cualquier aplicación, lo que lo hace menos seguro.
3. **Manejo de datos desde el almacenamiento externo**:
* Siempre **realiza validación de entrada** en los datos recuperados desde el almacenamiento externo. Esto es crucial porque los datos provienen de una fuente no confiable.
* Almacenar ejecutables o archivos de clase en el almacenamiento externo para carga dinámica está fuertemente desaconsejado.
* Si tu aplicación debe recuperar archivos ejecutables desde el almacenamiento externo, asegúrate de que estos archivos estén **firmados y verificados criptográficamente** antes de ser cargados dinámicamente. Este paso es vital para mantener la integridad de seguridad de tu aplicación.

El almacenamiento externo puede ser **accedido** en `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

{% hint style="info" %}
A partir de Android 4.4 (**API 17**), la tarjeta SD tiene una estructura de directorios que **limita el acceso desde una aplicación al directorio específico para esa aplicación**. Esto evita que aplicaciones maliciosas obtengan acceso de lectura o escritura a los archivos de otra aplicación.
{% endhint %}

**Datos sensibles almacenados en texto claro**

* **Preferencias compartidas**: Android permite a cada aplicación guardar fácilmente archivos XML en la ruta `/data/data/<nombrepaquete>/shared_prefs/` y a veces es posible encontrar información sensible en texto claro en esa carpeta.
* **Bases de datos**: Android permite a cada aplicación guardar bases de datos SQLite fácilmente en la ruta `/data/data/<nombrepaquete>/databases/` y a veces es posible encontrar información sensible en texto claro en esa carpeta.

### TLS roto

**Aceptar todos los certificados**

Por alguna razón, a veces los desarrolladores aceptan todos los certificados incluso si, por ejemplo, el nombre de host no coincide con líneas de código como la siguiente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
### Criptografía Rota

**Procesos de Gestión de Claves Débiles**

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los cifran con una clave codificada/predecible en el código. Esto no debería hacerse, ya que un proceso de reversión podría permitir a los atacantes extraer la información confidencial.

**Uso de Algoritmos Inseguros y/o Obsoletos**

Los desarrolladores no deberían usar algoritmos obsoletos para realizar **verificaciones** de autorización, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se utilizan **hashes** para almacenar contraseñas, por ejemplo, se deben usar hashes resistentes a ataques de fuerza bruta con sal.

### Otras verificaciones

* Se recomienda **ofuscar el APK** para dificultar el trabajo de ingeniería inversa a los atacantes.
* Si la aplicación es sensible (como las aplicaciones bancarias), debería realizar sus **propias verificaciones para ver si el móvil está rooteado** y actuar en consecuencia.
* Si la aplicación es sensible (como las aplicaciones bancarias), debería verificar si se está utilizando un **emulador**.
* Si la aplicación es sensible (como las aplicaciones bancarias), debería **verificar su propia integridad antes de ejecutarse** para comprobar si fue modificada.
* Utiliza [**APKiD**](https://github.com/rednaga/APKiD) para verificar qué compilador/empaquetador/ofuscador se utilizó para construir el APK.

### Aplicación React Native

Lee la siguiente página para aprender cómo acceder fácilmente al código JavaScript de las aplicaciones React:

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Aplicaciones Xamarin

Lee la siguiente página para aprender cómo acceder fácilmente al código C# de las aplicaciones Xamarin:

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### Aplicaciones Superpacked

Según esta [**publicación de blog**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/), superpacked es un algoritmo Meta que comprime el contenido de una aplicación en un solo archivo. El blog habla sobre la posibilidad de crear una aplicación que descomprima este tipo de aplicaciones... y una forma más rápida que implica **ejecutar la aplicación y recopilar los archivos descomprimidos del sistema de archivos**.

### Análisis Estático Automatizado de Código

La herramienta [**mariana-trench**](https://github.com/facebook/mariana-trench) es capaz de encontrar **vulnerabilidades** escaneando el **código** de la aplicación. Esta herramienta contiene una serie de **fuentes conocidas** (que indican a la herramienta los **lugares** donde la **entrada** está **controlada por el usuario**), **sumideros** (que indican a la herramienta **lugares peligrosos** donde la entrada maliciosa del usuario podría causar daños) y **reglas**. Estas reglas indican la **combinación** de **fuentes-sumideros** que indican una vulnerabilidad.

Con este conocimiento, **mariana-trench revisará el código y encontrará posibles vulnerabilidades en él**.

### Secretos filtrados

Una aplicación puede contener secretos (claves API, contraseñas, URLs ocultas, subdominios...) en su interior que podrías descubrir. Podrías usar una herramienta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Saltar la Autenticación Biométrica

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### Otras funciones interesantes

* **Ejecución de código**: `Runtime.exec(), ProcessBuilder(), código nativo:system()`
* **Enviar SMS**: `sendTextMessage, sendMultipartTestMessage`
* **Funciones nativas** declaradas como `native`: `public native, System.loadLibrary, System.load`
* [Lee esto para aprender **cómo revertir funciones nativas**](reversing-native-libraries.md)

### **Otros trucos**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

¡Únete al servidor de [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) para comunicarte con hackers experimentados y cazadores de bugs!

**Perspectivas de Hacking**\
Participa en contenido que profundiza en la emoción y desafíos del hacking

**Noticias de Hacking en Tiempo Real**\
Mantente actualizado con el mundo del hacking a través de noticias e información en tiempo real

**Últimos Anuncios**\
Mantente informado sobre los nuevos programas de recompensas por errores que se lanzan y las actualizaciones importantes de la plataforma

**Únete a nosotros en** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ¡y comienza a colaborar con los mejores hackers hoy!

***

## Análisis Dinámico

> En primer lugar, necesitas un entorno donde puedas instalar la aplicación y todo el entorno (certificado Burp CA, Drozer y Frida principalmente). Por lo tanto, se recomienda encarecidamente un dispositivo rooteado (emulado o no).

### Análisis Dinámico en línea

Puedes crear una **cuenta gratuita** en: [https://appetize.io/](https://appetize.io). Esta plataforma te permite **subir** y **ejecutar** APKs, por lo que es útil para ver cómo se comporta un APK.

Incluso puedes **ver los registros de tu aplicación** en la web y conectarte a través de **adb**.

![](<../../.gitbook/assets/image (60).png>)

Gracias a la conexión ADB, puedes usar **Drozer** y **Frida** dentro de los emuladores.

### Análisis Dinámico Local

#### Usando un emulador

* [**Android Studio**](https://developer.android.com/studio) (Puedes crear dispositivos **x86** y **arm**, y según [**esto**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) las **últimas versiones x86** admiten bibliotecas ARM sin necesidad de un emulador ARM lento).
* Aprende a configurarlo en esta página:

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versión gratuita:** Personal Edition, necesitas crear una cuenta. _Se recomienda **descargar** la versión **CON**_ _**VirtualBox** para evitar posibles errores._)
* [**Nox**](https://es.bignox.com) (Gratis, pero no es compatible con Frida o Drozer).

{% hint style="info" %}
Al crear un nuevo emulador en cualquier plataforma, recuerda que cuanto más grande sea la pantalla, más lento funcionará el emulador. Por lo tanto, selecciona pantallas pequeñas si es posible.
{% endhint %}

Para **instalar servicios de Google** (como AppStore) en Genymotion, debes hacer clic en el botón marcado en rojo de la siguiente imagen:

![](<../../.gitbook/assets/image (200) (1).png>)

Además, ten en cuenta que en la **configuración de la VM de Android en Genymotion** puedes seleccionar el modo de red de puente (esto será útil si te conectarás a la VM de Android desde una VM diferente con las herramientas).
#### Usar un dispositivo físico

Necesitas activar las opciones de **depuración** y sería genial si puedes **rootearlo**:

1. **Ajustes**.
2. (Desde Android 8.0) Selecciona **Sistema**.
3. Selecciona **Acerca del teléfono**.
4. Presiona **Número de compilación** 7 veces.
5. Regresa y encontrarás las **Opciones de desarrollador**.

> Una vez que hayas instalado la aplicación, lo primero que debes hacer es probarla e investigar qué hace, cómo funciona y familiarizarte con ella.\
> Sugiero **realizar este análisis dinámico inicial usando el análisis dinámico de MobSF + pidcat**, así podremos **aprender cómo funciona la aplicación** mientras MobSF **captura** una gran cantidad de **datos interesantes** que puedes revisar más tarde.

### Fuga de Datos No Intencionada

**Registro**

Los desarrolladores deben tener cuidado al exponer información de **depuración** públicamente, ya que puede provocar fugas de datos sensibles. Se recomiendan las herramientas [**pidcat**](https://github.com/JakeWharton/pidcat) y `adb logcat` para monitorear los registros de la aplicación y así identificar y proteger información sensible. **Pidcat** es preferido por su facilidad de uso y legibilidad.

{% hint style="warning" %}
Ten en cuenta que a partir de **Android 4.0 en adelante**, **las aplicaciones solo pueden acceder a sus propios registros**. Por lo tanto, las aplicaciones no pueden acceder a los registros de otras aplicaciones.\
De todos modos, se recomienda **no registrar información sensible**.
{% endhint %}

**Almacenamiento en el Portapapeles**

El marco de Android basado en el portapapeles permite la funcionalidad de copiar y pegar en las aplicaciones, pero plantea un riesgo ya que **otras aplicaciones** pueden **acceder** al portapapeles, exponiendo potencialmente datos sensibles. Es crucial **desactivar las funciones de copiar/pegar** para secciones sensibles de una aplicación, como detalles de tarjetas de crédito, para evitar fugas de datos.

**Registros de Errores**

Si una aplicación **se bloquea** y **guarda registros**, estos registros pueden ayudar a los atacantes, especialmente cuando la aplicación no se puede ingenierizar inversamente. Para mitigar este riesgo, evita registrar en caso de errores, y si los registros deben transmitirse a través de la red, asegúrate de que se envíen a través de un canal SSL para mayor seguridad.

Como pentester, **intenta echar un vistazo a estos registros**.

**Datos Analíticos Enviados a Terceros**

Las aplicaciones a menudo integran servicios como Google Adsense, que pueden **filtrar datos sensibles** involuntariamente debido a una implementación incorrecta por parte de los desarrolladores. Para identificar posibles fugas de datos, es aconsejable **interceptar el tráfico de la aplicación** y verificar si se envía alguna información sensible a servicios de terceros.

### Bases de Datos SQLite

La mayoría de las aplicaciones utilizarán **bases de datos SQLite internas** para guardar información. Durante la prueba de penetración, echa un **vistazo** a las **bases de datos** creadas, los nombres de las **tablas** y **columnas** y todos los **datos** guardados, ya que podrías encontrar **información sensible** (lo cual sería una vulnerabilidad).\
Las bases de datos deben estar ubicadas en `/data/data/el.nombre.del.paquete/bases de datos` como `/data/data/com.mwr.example.sieve/bases de datos`

Si la base de datos está guardando información confidencial y está **encriptada** pero puedes **encontrar** la **contraseña** dentro de la aplicación, sigue siendo una **vulnerabilidad**.

Enumera las tablas usando `.tables` y enumera las columnas de las tablas con `.schema <nombre_de_la_tabla>`

### Drozer (Actividades de Explotación, Proveedores de Contenido y Servicios)

Desde [Documentos de Drozer](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** te permite **asumir el rol de una aplicación de Android** e interactuar con otras aplicaciones. Puede hacer **cualquier cosa que una aplicación instalada pueda hacer**, como hacer uso del mecanismo de Comunicación entre Procesos (IPC) de Android e interactuar con el sistema operativo subyacente.\
Drozer es una herramienta útil para **explotar actividades exportadas, servicios exportados y Proveedores de Contenido**, como aprenderás en las siguientes secciones.

### Explotando Actividades Exportadas

[**Lee esto si quieres recordar qué es una Actividad de Android.**](android-applications-basics.md#launcher-activity-and-other-activities)\
También recuerda que el código de una actividad comienza en el método **`onCreate`**.

**Bypass de Autorización**

Cuando una Actividad está exportada, puedes invocar su pantalla desde una aplicación externa. Por lo tanto, si una actividad con **información sensible** está **exportada**, podrías **burlar** los mecanismos de **autenticación** para acceder a ella.

[**Aprende cómo explotar actividades exportadas con Drozer.**](drozer-tutorial/#activities)

También puedes iniciar una actividad exportada desde adb:

* El nombre del paquete es com.example.demo
* El nombre de la Actividad Exportada es com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF detectará como malicioso el uso de _**singleTask/singleInstance**_ como `android:launchMode` en una actividad, pero debido a [esto](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente esto solo es peligroso en versiones antiguas (versiones de API < 21).

{% hint style="info" %}
Ten en cuenta que una omisión de autorización no siempre es una vulnerabilidad, dependerá de cómo funcione la omisión y qué información se exponga.
{% endhint %}

**Fuga de información sensible**

**Las actividades también pueden devolver resultados**. Si logras encontrar una actividad exportada y desprotegida que llame al método **`setResult`** y **devuelva información sensible**, entonces hay una fuga de información sensible.

#### Tapjacking

Si no se previene el tapjacking, podrías abusar de la actividad exportada para hacer que el **usuario realice acciones inesperadas**. Para obtener más información sobre [**qué es el Tapjacking sigue el enlace**](./#tapjacking).

### Explotando Proveedores de Contenido - Accediendo y manipulando información sensible

[**Lee esto si quieres recordar qué es un Proveedor de Contenido.**](android-applications-basics.md#content-provider)\
Los proveedores de contenido se utilizan básicamente para **compartir datos**. Si una aplicación tiene proveedores de contenido disponibles, es posible que puedas **extraer datos** sensibles de ellos. También es interesante probar posibles **inyecciones SQL** y **travesías de ruta** ya que podrían ser vulnerables.

[**Aprende cómo explotar Proveedores de Contenido con Drozer.**](drozer-tutorial/#content-providers)

### **Explotando Servicios**

[**Lee esto si quieres recordar qué es un Servicio.**](android-applications-basics.md#services)\
Recuerda que las acciones de un Servicio comienzan en el método `onStartCommand`.

Un servicio es básicamente algo que **puede recibir datos**, **procesarlos** y **devolver** (o no) una respuesta. Entonces, si una aplicación está exportando algunos servicios, debes **revisar** el **código** para entender qué está haciendo y **probarlo** **dinámicamente** para extraer información confidencial, evadir medidas de autenticación...\
[**Aprende cómo explotar Servicios con Drozer.**](drozer-tutorial/#services)

### **Explotando Receptores de Difusión**

[**Lee esto si quieres recordar qué es un Receptor de Difusión.**](android-applications-basics.md#broadcast-receivers)\
Recuerda que las acciones de un Receptor de Difusión comienzan en el método `onReceive`.

Un receptor de difusión estará esperando un tipo de mensaje. Dependiendo de cómo maneje el receptor el mensaje, podría ser vulnerable.\
[**Aprende cómo explotar Receptores de Difusión con Drozer.**](./#exploiting-broadcast-receivers)

### **Explotando Esquemas / Enlaces profundos**

Puedes buscar enlaces profundos manualmente, utilizando herramientas como MobSF o scripts como [este](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puedes **abrir** un **esquema** declarado usando **adb** o un **navegador**:

{% code overflow="wrap" %}
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_Tenga en cuenta que puede **omitir el nombre del paquete** y el móvil llamará automáticamente a la aplicación que debería abrir ese enlace._

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**Código ejecutado**

Para encontrar el **código que se ejecutará en la aplicación**, ve a la actividad llamada por el enlace profundo y busca la función **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**Información sensible**

Cada vez que encuentres un enlace profundo, verifica que **no esté recibiendo datos sensibles (como contraseñas) a través de parámetros de URL**, ¡porque cualquier otra aplicación podría **hacerse pasar por el enlace profundo y robar esos datos!**

**Parámetros en la ruta**

Debes verificar también si algún enlace profundo está utilizando un parámetro dentro de la ruta de la URL como: `https://api.example.com/v1/users/{username}`, en ese caso puedes forzar una travesía de ruta accediendo a algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Ten en cuenta que si encuentras los endpoints correctos dentro de la aplicación, podrías causar una **Redirección Abierta** (si parte de la ruta se utiliza como nombre de dominio), **toma de cuenta** (si puedes modificar los detalles de los usuarios sin token CSRF y el endpoint vulnerable utilizó el método correcto) y cualquier otra vulnerabilidad. Más [información al respecto aquí](http://dphoeniixx.com/2020/12/13-2/).

**Más ejemplos**

Un [informe interesante de recompensa por errores](https://hackerone.com/reports/855618) sobre enlaces (_/.well-known/assetlinks.json_).

### Fallas en la Inspección y Verificación de la Capa de Transporte

* Las aplicaciones de Android **no siempre inspeccionan adecuadamente los certificados**. Es común que estas aplicaciones pasen por alto advertencias y acepten certificados autofirmados o, en algunos casos, vuelvan a utilizar conexiones HTTP.
* A veces, las **negociaciones durante el handshake de SSL/TLS son débiles**, empleando suites de cifrado inseguras. Esta vulnerabilidad hace que la conexión sea susceptible a ataques de intermediarios (MITM), lo que permite a los atacantes descifrar los datos.
* Existe un riesgo de **fuga de información privada** cuando las aplicaciones se autentican utilizando canales seguros pero luego comunican a través de canales no seguros para otras transacciones. Este enfoque no protege los datos sensibles, como cookies de sesión o detalles de usuario, de la interceptación por entidades maliciosas.

#### Verificación de Certificados

Nos centraremos en la **verificación de certificados**. Se debe verificar la integridad del certificado del servidor para mejorar la seguridad. Esto es crucial porque las configuraciones de TLS inseguras y la transmisión de datos sensibles a través de canales no encriptados pueden plantear riesgos significativos. Para obtener pasos detallados sobre la verificación de certificados de servidor y abordar vulnerabilidades, [**este recurso**](https://manifestsecurity.com/android-application-security-part-10/) proporciona una guía completa.

#### Pinning de SSL

El Pinning de SSL es una medida de seguridad donde la aplicación verifica el certificado del servidor contra una copia conocida almacenada dentro de la propia aplicación. Este método es esencial para prevenir ataques MITM. Se recomienda encarecidamente implementar el Pinning de SSL en aplicaciones que manejan información sensible.

#### Inspección de Tráfico

Para inspeccionar el tráfico HTTP, es necesario **instalar el certificado de la herramienta de proxy** (por ejemplo, Burp). Sin instalar este certificado, es posible que el tráfico encriptado no sea visible a través del proxy. Para obtener una guía sobre cómo instalar un certificado de CA personalizado, [**haz clic aquí**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Las aplicaciones que apuntan a **API Level 24 y superior** requieren modificaciones en la Configuración de Seguridad de Red para aceptar el certificado de CA del proxy. Este paso es crítico para inspeccionar el tráfico encriptado. Para obtener instrucciones sobre cómo modificar la Configuración de Seguridad de Red, [**consulta este tutorial**](make-apk-accept-ca-certificate.md).

#### Saltar el Pinning de SSL

Cuando se implementa el Pinning de SSL, es necesario saltarlo para inspeccionar el tráfico HTTPS. Hay varios métodos disponibles para este propósito:

* Modificar automáticamente el **apk** para **saltar** el SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). La mayor ventaja de esta opción es que no necesitarás permisos de root para saltar el Pinning de SSL, pero deberás eliminar la aplicación e instalar la nueva, y esto no siempre funcionará.
* Puedes usar **Frida** (discutido a continuación) para saltar esta protección. Aquí tienes una guía para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
* También puedes intentar **saltar automáticamente el Pinning de SSL** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* También puedes intentar **saltar automáticamente el Pinning de SSL** usando **análisis dinámico de MobSF** (explicado a continuación)
* Si aún crees que hay tráfico que no estás capturando, puedes intentar **redirigir el tráfico a Burp usando iptables**. Lee este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Buscando Vulnerabilidades Web Comunes

También es importante buscar vulnerabilidades web comunes dentro de la aplicación. La información detallada sobre la identificación y mitigación de estas vulnerabilidades está más allá del alcance de este resumen, pero se cubre extensamente en otros lugares.

### Frida

[Frida](https://www.frida.re) es un kit de herramientas de instrumentación dinámica para desarrolladores, ingenieros inversos e investigadores de seguridad.\
**Puedes acceder a la aplicación en ejecución y enganchar métodos en tiempo de ejecución para cambiar el comportamiento, cambiar valores, extraer valores, ejecutar código diferente...**\
Si deseas hacer pruebas de penetración en aplicaciones de Android, necesitas saber cómo usar Frida.

* Aprende a usar Frida: [**Tutorial de Frida**](frida-tutorial/)
* Algunas "GUI" para acciones con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
* Ojection es excelente para automatizar el uso de Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
* Puedes encontrar algunos scripts impresionantes de Frida aquí: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
* Intenta saltar los mecanismos anti-depuración / anti-Frida cargando Frida como se indica en [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (herramienta [linjector](https://github.com/erfur/linjector-rs))

### **Volcado de Memoria - Fridump**

Verifica si la aplicación está almacenando información sensible dentro de la memoria que no debería estar almacenando, como contraseñas o mnemónicos.

Usando [**Fridump3**](https://github.com/rootbsd/fridump3) puedes volcar la memoria de la aplicación con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Esto volcará la memoria en la carpeta ./dump, y allí podrías buscar con algo como:

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Datos sensibles en el Keystore**

En Android, el Keystore es el mejor lugar para almacenar datos sensibles, sin embargo, con suficientes privilegios todavía es **posible acceder a ellos**. Como las aplicaciones tienden a almacenar aquí **datos sensibles en texto claro**, las pruebas de penetración deben verificar esto, ya que un usuario root o alguien con acceso físico al dispositivo podría robar estos datos.

Incluso si una aplicación almacenara datos en el keystore, los datos deberían estar encriptados.

Para acceder a los datos dentro del keystore, podrías utilizar este script de Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Bypass de Huella Dactilar/Biometría**

Usando el siguiente script de Frida, podría ser posible **bypassar la autenticación de huella dactilar** que las aplicaciones de Android podrían estar realizando para **proteger ciertas áreas sensibles:** 

{% code overflow="wrap" %}
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **Imágenes de Fondo**

Cuando pones una aplicación en segundo plano, Android almacena una **instantánea de la aplicación** para que, al recuperarla al primer plano, comience a cargar la imagen antes que la aplicación, de modo que parezca que la aplicación se cargó más rápido.

Sin embargo, si esta instantánea contiene **información sensible**, alguien con acceso a la instantánea podría **robar esa información** (ten en cuenta que se necesita acceso de root para acceder a ella).

Las instantáneas suelen almacenarse en: **`/data/system_ce/0/snapshots`**

Android proporciona una forma de **evitar la captura de pantalla configurando el parámetro de diseño FLAG\_SECURE**. Al utilizar esta bandera, el contenido de la ventana se trata como seguro, evitando que aparezca en capturas de pantalla o que se vea en pantallas no seguras.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizador de Aplicaciones Android**

Esta herramienta podría ayudarte a gestionar diferentes herramientas durante el análisis dinámico: [https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### Inyección de Intents

Los desarrolladores a menudo crean componentes proxy como actividades, servicios y receptores de difusión que manejan estos Intents y los pasan a métodos como `startActivity(...)` o `sendBroadcast(...)`, lo cual puede ser riesgoso.

El peligro radica en permitir a los atacantes activar componentes de la aplicación no exportados o acceder a proveedores de contenido sensibles al desviar estos Intents. Un ejemplo notable es el componente `WebView` que convierte URL a objetos `Intent` a través de `Intent.parseUri(...)` y luego los ejecuta, lo que potencialmente puede llevar a inyecciones maliciosas de Intents.

### Conclusiones Esenciales

* **Inyección de Intents** es similar al problema de Redirección Abierta en la web.
* Los exploits implican pasar objetos `Intent` como extras, que pueden ser redirigidos para ejecutar operaciones inseguras.
* Puede exponer componentes no exportados y proveedores de contenido a los atacantes.
* La conversión de URL a `Intent` en `WebView` puede facilitar acciones no deseadas.

### Inyecciones del Lado del Cliente en Android y otros

Probablemente conozcas este tipo de vulnerabilidades en la web. Debes tener especial cuidado con estas vulnerabilidades en una aplicación Android:

* **Inyección SQL:** Al tratar consultas dinámicas o Content-Providers, asegúrate de usar consultas parametrizadas.
* **Inyección de JavaScript (XSS):** Verifica que JavaScript y el soporte de plugins estén deshabilitados para cualquier WebView (deshabilitado por defecto). [Más información aquí](webview-attacks.md#javascript-enabled).
* **Inclusión de Archivos Locales:** Las WebViews deben tener acceso al sistema de archivos deshabilitado (habilitado por defecto) - `(webview.getSettings().setAllowFileAccess(false);)`. [Más información aquí](webview-attacks.md#javascript-enabled).
* **Cookies eternas:** En varios casos, cuando la aplicación Android finaliza la sesión, la cookie no se revoca o incluso podría guardarse en disco.
* [**Bandera Segura** en cookies](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Únete al servidor de [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) para comunicarte con hackers experimentados y cazadores de bugs!

**Perspectivas de Hacking**\
Participa en contenido que profundiza en la emoción y desafíos del hacking

**Noticias de Hacking en Tiempo Real**\
Mantente actualizado con el mundo del hacking a través de noticias e información en tiempo real

**Últimos Anuncios**\
Mantente informado sobre los nuevos programas de recompensas por bugs y actualizaciones importantes de plataformas

**Únete a nosotros en** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ¡y comienza a colaborar con los mejores hackers hoy!

## Análisis Automático

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Análisis estático**

![](<../../.gitbook/assets/image (61).png>)

**Evaluación de vulnerabilidades de la aplicación** utilizando una interfaz web agradable. También puedes realizar análisis dinámico (pero necesitas preparar el entorno).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Ten en cuenta que MobSF puede analizar aplicaciones de **Android**(apk), **IOS**(ipa) y Windows(apx) (_Las aplicaciones de Windows deben ser analizadas desde un MobSF instalado en un host de Windows_).\
Además, si creas un archivo **ZIP** con el código fuente de una aplicación de **Android** o de **IOS** (ve a la carpeta raíz de la aplicación, selecciona todo y crea un archivo ZIP), también podrá analizarlo.

MobSF también te permite **comparar/diferenciar** análisis e integrar **VirusTotal** (necesitarás configurar tu clave de API en _MobSF/settings.py_ y habilitarlo: `VT_ENABLED = TRUE` `VT_API_KEY = <Tu clave de API>` `VT_UPLOAD = TRUE`). También puedes establecer `VT_UPLOAD` en `False`, entonces el **hash** se **subirá** en lugar del archivo.

### Análisis dinámico asistido con MobSF

**MobSF** también puede ser muy útil para el **análisis dinámico** en **Android**, pero en ese caso necesitarás instalar MobSF y **genymotion** en tu host (una VM o Docker no funcionarán). _Nota: Necesitas **iniciar primero una VM en genymotion** y **luego MobSF**._\
El **analizador dinámico de MobSF** puede:

* **Volcar datos de la aplicación** (URLs, logs, portapapeles, capturas de pantalla realizadas por ti, capturas de pantalla realizadas por "**Exported Activity Tester**", correos electrónicos, bases de datos SQLite, archivos XML y otros archivos creados). Todo esto se hace automáticamente excepto las capturas de pantalla, debes presionar cuando desees una captura de pantalla o debes presionar "**Exported Activity Tester**" para obtener capturas de pantalla de todas las actividades exportadas.
* Capturar **tráfico HTTPS**
* Usar **Frida** para obtener **información en tiempo de ejecución**

A partir de las versiones de Android > 5, **iniciará automáticamente Frida** y establecerá la configuración global de **proxy** para **capturar** el tráfico. Solo capturará el tráfico de la aplicación probada.

**Frida**

Por defecto, también utilizará algunos Scripts de Frida para **burlar el pinning SSL**, **detección de root** y **detección de depurador** y para **monitorizar APIs interesantes**.\
MobSF también puede **invocar actividades exportadas**, capturar **capturas de pantalla** de ellas y **guardarlas** para el informe.

Para **iniciar** las pruebas dinámicas, presiona el botón verde: "**Start Instrumentation**". Presiona "**Frida Live Logs**" para ver los logs generados por los scripts de Frida y "**Live API Monitor**" para ver todas las invocaciones a los métodos enganchados, argumentos pasados y valores devueltos (esto aparecerá después de presionar "Start Instrumentation").\
MobSF también te permite cargar tus propios **scripts de Frida** (para enviar los resultados de tus scripts de Frida a MobSF, utiliza la función `send()`). También tiene **varios scripts preescritos** que puedes cargar (puedes añadir más en `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), simplemente **selecciona** uno, presiona "**Load**" y luego "**Start Instrumentation**" (podrás ver los logs de esos scripts dentro de "**Frida Live Logs**").

![](<../../.gitbook/assets/image (215).png>)

Además, tienes algunas funcionalidades auxiliares de Frida:

* **Enumerate Loaded Classes**: Imprimirá todas las clases cargadas
* **Capture Strings**: Imprimirá todas las cadenas capturadas mientras se usa la aplicación (muy ruidoso)
* **Capture String Comparisons**: Puede ser muy útil. Mostrará las 2 cadenas que se están comparando y si el resultado fue Verdadero o Falso.
* **Enumerate Class Methods**: Coloca el nombre de la clase (como "java.io.File") y imprimirá todos los métodos de la clase.
* **Search Class Pattern**: Buscar clases por patrón
* **Trace Class Methods**: **Rastrear** una **clase entera** (ver entradas y salidas de todos los métodos de la clase). Recuerda que por defecto MobSF rastrea varios métodos interesantes de la API de Android.

Una vez que hayas seleccionado el módulo auxiliar que deseas utilizar, debes presionar "**Start Intrumentation**" y verás todas las salidas en "**Frida Live Logs**".

**Shell**

Mobsf también te proporciona un shell con algunos comandos de **adb**, comandos de **MobSF** y comandos de **shell** comunes en la parte inferior de la página de análisis dinámico. Algunos comandos interesantes:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Herramientas HTTP**

Cuando se captura el tráfico http, puedes ver una vista poco atractiva del tráfico capturado en la parte inferior de "**HTTP(S) Traffic**" o una vista más agradable en el botón verde "**Start HTTPTools**". Desde la segunda opción, puedes **enviar** las **solicitudes capturadas** a **proxies** como Burp u Owasp ZAP.\
Para hacerlo, _enciende Burp -->_ _apaga Intercept --> en MobSB HTTPTools selecciona la solicitud_ --> presiona "**Send to Fuzzer**" --> _selecciona la dirección del proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Una vez que hayas terminado el análisis dinámico con MobSF, puedes presionar "**Start Web API Fuzzer**" para **fuzzear solicitudes http** y buscar vulnerabilidades.

{% hint style="info" %}
Después de realizar un análisis dinámico con MobSF, la configuración del proxy puede estar mal configurada y es posible que no puedas solucionarlo desde la GUI. Puedes arreglar la configuración del proxy haciendo:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Análisis Dinámico Asistido con Inspeckage

Puedes obtener la herramienta de [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Esta herramienta utiliza algunos **Hooks** para informarte **sobre lo que está sucediendo en la aplicación** mientras realizas un **análisis dinámico**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta es una **gran herramienta para realizar análisis estático con una interfaz gráfica**

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

Esta herramienta está diseñada para buscar varias **vulnerabilidades de seguridad relacionadas con aplicaciones de Android**, ya sea en **código fuente** o en **APKs empaquetados**. La herramienta también es **capaz de crear un APK desplegable de "Prueba de Concepto"** y **comandos ADB** para explotar algunas de las vulnerabilidades encontradas (actividades expuestas, intenciones, tapjacking...). Al igual que con Drozer, no es necesario rootear el dispositivo de prueba.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* Muestra todos los archivos extraídos para una fácil referencia
* Descompila automáticamente archivos APK al formato Java y Smali
* Analiza AndroidManifest.xml en busca de vulnerabilidades y comportamientos comunes
* Análisis estático del código fuente en busca de vulnerabilidades y comportamientos comunes
* Información del dispositivo
* y más
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER es una aplicación de línea de comandos que se puede utilizar en Windows, MacOS X y Linux, que analiza archivos _.apk_ en busca de vulnerabilidades. Lo hace descomprimiendo los APK y aplicando una serie de reglas para detectar esas vulnerabilidades.

Todas las reglas se centran en un archivo `rules.json`, y cada empresa o probador podría crear sus propias reglas para analizar lo que necesitan.

Descarga los últimos binarios en la [página de descargas](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAn es una herramienta **multiplataforma** que ayuda a desarrolladores, cazadores de bugs y hackers éticos a realizar [análisis de código estático](https://en.wikipedia.org/wiki/Static\_program\_analysis) en aplicaciones móviles.

El concepto es que arrastres y sueltes el archivo de tu aplicación móvil (un archivo .apk o .ipa) en la aplicación StaCoAn y generará un informe visual y portátil para ti. Puedes ajustar la configuración y listas de palabras para obtener una experiencia personalizada.

Descarga la [última versión](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Framework es un sistema de análisis de vulnerabilidades de Android que ayuda a desarrolladores o hackers a encontrar posibles vulnerabilidades de seguridad en aplicaciones de Android.\
[Versiones para Windows](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** es una herramienta cuyo objetivo principal es detectar y advertir al usuario sobre posibles comportamientos maliciosos desarrollados por una aplicación de Android.

La detección se realiza con el **análisis estático** del bytecode Dalvik de la aplicación, representado como **Smali**, con la biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta herramienta busca **comportamientos comunes de aplicaciones "malas"** como: exfiltración de identificadores de telefonía, interceptación de flujo de audio/video, modificación de datos PIM, ejecución de código arbitrario...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [Marco de trabajo MARA](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA** es un **M**arco de trabajo de **A**nálisis e **I**ngeniería **I**nversa de **A**plicaciones **M**óviles. Es una herramienta que reúne herramientas comúnmente utilizadas para la ingeniería inversa y análisis de aplicaciones móviles, para ayudar en la prueba de aplicaciones móviles contra las amenazas de seguridad móvil de OWASP. Su objetivo es hacer esta tarea más fácil y amigable para los desarrolladores de aplicaciones móviles y profesionales de seguridad.

Es capaz de:

* Extraer código Java y Smali utilizando diferentes herramientas
* Analizar APKs utilizando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
* Extraer información privada de la APK utilizando expresiones regulares.
* Analizar el Manifiesto.
* Analizar dominios encontrados utilizando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) y [whatweb](https://github.com/urbanadventurer/WhatWeb)
* Desofuscar APK a través de [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com)

## Ofuscación/Desofuscación de código

Tenga en cuenta que dependiendo del servicio y la configuración que utilice para ofuscar el código. Los secretos pueden o no terminar ofuscados.

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

Desde [Wikipedia](https://en.wikipedia.org/wiki/ProGuard\_\(software\)): **ProGuard** es una herramienta de línea de comandos de código abierto que reduce, optimiza y ofusca el código Java. Es capaz de optimizar el bytecode, así como detectar y eliminar instrucciones no utilizadas. ProGuard es software libre y se distribuye bajo la Licencia Pública General de GNU, versión 2.

ProGuard se distribuye como parte del SDK de Android y se ejecuta al compilar la aplicación en modo de lanzamiento.

### [DexGuard](https://www.guardsquare.com/dexguard)

Encuentre una guía paso a paso para desofuscar el apk en [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(De esa guía) La última vez que verificamos, el modo de operación de Dexguard era:

* cargar un recurso como un InputStream;
* alimentar el resultado a una clase que hereda de FilterInputStream para descifrarlo;
* hacer alguna ofuscación inútil para perder unos minutos de tiempo de un inversor;
* alimentar el resultado descifrado a un ZipInputStream para obtener un archivo DEX;
* finalmente cargar el DEX resultante como un Recurso utilizando el método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard revierte el proceso de ofuscación realizado por las herramientas de ofuscación de Android. Esto permite numerosos análisis de seguridad, incluida la inspección de código y la predicción de bibliotecas.**

Puede cargar un APK ofuscado en su plataforma.

### [Simplify](https://github.com/CalebFenton/simplify)

Es un **desofuscador genérico de Android.** Simplify **ejecuta virtualmente una aplicación** para comprender su comportamiento y luego **intenta optimizar el código** para que se comporte de manera idéntica pero sea más fácil de entender para un humano. Cada tipo de optimización es simple y genérico, por lo que no importa qué tipo específico de ofuscación se utilice.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD le proporciona información sobre **cómo se creó un APK**. Identifica muchos **compiladores**, **empaquetadores**, **ofuscadores** y otras cosas extrañas. Es [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Lea este tutorial para aprender algunos trucos sobre **cómo desofuscar la ofuscación personalizada**](manual-deobfuscation.md)

## Laboratorios

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b es una máquina virtual de seguridad de Android basada en ubuntu-mate que incluye la colección de los últimos marcos, tutoriales y laboratorios de diferentes geeks de seguridad e investigadores para ingeniería inversa y análisis de malware.

## Referencias

* [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) Es una gran lista de recursos
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
* [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## Por probar

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Únete al servidor de [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) para comunicarte con hackers experimentados y cazadores de bugs!

**Perspectivas de Hacking**\
Participa en contenido que profundiza en la emoción y desafíos del hacking

**Noticias de Hacking en Tiempo Real**\
Mantente actualizado con el mundo del hacking a través de noticias e información en tiempo real

**Últimos Anuncios**\
Mantente informado sobre los nuevos programas de recompensas por errores que se lanzan y actualizaciones importantes de plataformas

**Únete a nosotros en** [**Discord**](https://discord.com/invite/N3FrSbmwdy) y comienza a colaborar con los mejores hackers hoy!

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en github.

</details>
