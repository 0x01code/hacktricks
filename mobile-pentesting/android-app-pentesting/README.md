# Pentesting de Aplicativos Android

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

🐞 Leia tutoriais sobre bugs web3

🔔 Receba notificações sobre novos programas de recompensas por bugs

💬 Participe de discussões na comunidade

## Conceitos Básicos de Aplicativos Android

É altamente recomendável começar a ler esta página para saber sobre as **partes mais importantes relacionadas à segurança do Android e os componentes mais perigosos em um aplicativo Android**:

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB (Android Debug Bridge)

Esta é a principal ferramenta que você precisa para se conectar a um dispositivo Android (emulado ou físico).\
Ele permite que você controle seu dispositivo por **USB** ou **rede** a partir de um computador, **copie** arquivos de ida e volta, **instale** e desinstale aplicativos, execute comandos **shell**, faça **backups**, leia **logs** e muito mais.

Dê uma olhada na seguinte lista de [**Comandos ADB**](adb-commands.md) para aprender como usar o adb.

## Smali

Às vezes, é interessante **modificar o código do aplicativo** para acessar **informações ocultas** (talvez senhas bem ofuscadas ou flags). Então, pode ser interessante descompilar o apk, modificar o código e recompilá-lo.\
[Neste tutorial](smali-changes.md), você pode **aprender como descompilar um APK, modificar o código Smali e recompilar o APK** com a nova funcionalidade. Isso pode ser muito útil como uma **alternativa para vários testes durante a análise dinâmica** que serão apresentados. Então, **mantenha sempre em mente essa possibilidade**.

## Outros truques interessantes

* [Falsificando sua localização na Play Store](spoofing-your-location-in-play-store.md)
* **Baixe APKs**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* Extrair APK do dispositivo:
```
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2 
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

🐞 Leia tutoriais sobre bugs web3

🔔 Receba notificações sobre novas recompensas por bugs

💬 Participe de discussões na comunidade

## Análise Estática

Antes de tudo, para analisar um APK, você deve **dar uma olhada no código Java** usando um decompilador.\
Por favor, [**leia aqui para encontrar informações sobre diferentes decompiladores disponíveis**](apk-decompilers.md).

### Procurando por informações interessantes

Apenas olhando para as **strings** do APK, você pode procurar por **senhas**, **URLs** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **chaves** de API, **criptografia**, **UUIDs** de Bluetooth, **tokens** e qualquer coisa interessante... procure até por **backdoors** de execução de código ou backdoors de autenticação (credenciais de administrador codificadas no aplicativo).

**Firebase**

Preste atenção especial às **URLs do Firebase** e verifique se estão mal configuradas. [Mais informações sobre o que é o Firebase e como explorá-lo aqui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Compreensão básica do aplicativo - Manifest.xml, strings.xml

Usando qualquer um dos **decompiladores** mencionados [**aqui**](apk-decompilers.md), você poderá ler o _Manifest.xml_. Você também pode **renomear** a extensão do arquivo **apk para .zip** e **descompactá-lo**.\
Lendo o **manifest**, você pode encontrar **vulnerabilidades**:

* Em primeiro lugar, verifique se **o aplicativo pode ser depurado**. Um APK de produção não deve ser (ou outros poderão se conectar a ele). Você pode verificar se um aplicativo pode ser depurado procurando no manifesto pelo atributo `debuggable="true"` dentro da tag _\<application_ Exemplo: `<application theme="@2131296387" debuggable="true"`
  * [Aprenda aqui](drozer-tutorial/#is-debuggeable) como encontrar aplicativos depuráveis em um telefone e explorá-los
* **Backup**: O atributo **`android:allowBackup`** define se os dados do aplicativo podem ser salvos e restaurados por um usuário que habilitou a depuração USB. Se a bandeira de backup estiver definida como verdadeira, permite que um invasor faça backup dos dados do aplicativo via adb, mesmo que o dispositivo não esteja rooteado. Portanto, aplicativos que lidam e armazenam informações sensíveis, como detalhes de cartão, senhas etc., devem ter essa configuração explicitamente definida como **false**, porque por padrão ela é definida como **true** para evitar tais riscos.
  * `<application android:allowBackup="false"`
* **NetworkSecurity:** A segurança de rede do aplicativo pode sobrescrever os valores padrão com **`android:networkSecurityConfig="@xml/network_security_config"`**. Um arquivo com esse nome pode ser colocado em _**res/xml.**_ Este arquivo configurará configurações de segurança importantes, como pinos de certificado ou se permite tráfego HTTP. Você pode ler aqui mais informações sobre todas as coisas que podem ser configuradas, mas verifique este exemplo sobre como configurar o tráfego HTTP para alguns domínios:
  * `<domain-config cleartextTrafficPermitted="true"> <domain includeSubdomains="true">formation-software.co.uk </domain></domain-config>`
* **Atividades exportadas**: Verifique as atividades exportadas dentro do manifesto, pois isso pode ser perigoso. Mais tarde, na análise dinâmica, será explicado como [você pode abusar desse comportamento](./#exploiting-exported-activities-authorisation-bypass).
* **Provedores de conteúdo**: Se um provedor exportado estiver sendo exposto, você poderá acessar/modificar informações interessantes. Na análise dinâmica, [você aprenderá como abusá-los](./#exploiting-content-providers-accessing-and-manipulating-sensitive-information).
  * Verifique as configurações de **FileProviders** dentro do atributo `android:name="android.support.FILE_PROVIDER_PATHS"`. [Leia aqui para saber mais sobre FileProviders](./#fileprovider).
* **Serviços expostos**: Dependendo do que o serviço está fazendo internamente, vulnerabilidades podem ser exploradas. Na análise dinâmica, [você aprenderá como abusá-los](./#exploiting-services).
* **Receptores de transmissão**: [Você aprenderá como possivelmente explorá-los](./#exploiting-broadcast-receivers) durante a análise dinâmica.
* **Esquema de URL**: Leia o código da atividade que gerencia o esquema e procure por vulnerabilidades gerenciando a entrada do usuário. Mais informações sobre [o que é um esquema de URL aqui](./#url-schemes).
* **minSdkVersion**, **targetSDKVersion**, **maxSdkVersion**: Eles indicam as versões do Android em que o aplicativo será executado. É importante mantê-los em mente porque, do ponto de vista da segurança, suportar versões antigas permitirá que versões vulneráveis conhecidas do Android o executem.

Lendo **resources.arsc/strings.xml**, você pode encontrar algumas **informações interessantes**:

* Chaves de API
* Esquemas personalizados
* Outras informações interessantes que os desenvolvedores salvam neste arquivo

### Tapjacking

**Tapjacking** é um ataque em que um **aplicativo malicioso** é lançado e **se posiciona sobre um aplicativo vítima**. Uma vez que ele obscurece visivelmente o aplicativo vítima, sua interface do usuário é projetada de tal forma que engana o usuário a interagir com ele, enquanto passa a interação para o aplicativo vítima.\
Na verdade, ele está **cegando o usuário de saber que está realmente realizando ações no aplicativo vítima**.

Para detectar aplicativos vulneráveis a esse ataque, você deve procurar por **atividades exportadas** no manifesto do Android (observe que uma atividade com um filtro de intenção é automaticamente exportada por padrão). Depois de encontrar as atividades exportadas, **verifique se elas exigem alguma permissão**. Isso ocorre porque o **aplicativo malicioso também precisará dessa permissão**.\
Por fim, é importante verificar o código para possíveis configurações de **`setFilterTouchesWhenObscured`**. Se definido como **`true`**, um botão pode ser automaticamente desativado se estiver obscurecido:
```markup
<Button android:text="Button"
android:id="@+id/button1"
android:layout_width="wrap_content"
android:layout_height="wrap_content" 
android:filterTouchesWhenObscured="true">
</Button>
```
Você pode usar o [**qark**](https://github.com/linkedin/qark) com o parâmetro `--exploit-apk` para criar um aplicativo malicioso para testar possíveis vulnerabilidades de **Tapjacking**.\
Um projeto de exemplo que implementa esse tipo de recurso pode ser encontrado em [**FloatingWindowApp**](https://github.com/aminography/FloatingWindowApp).

A mitigação é relativamente simples, pois o desenvolvedor pode optar por não receber eventos de toque quando uma visualização é coberta por outra. Usando a [Referência do Desenvolvedor Android](https://developer.android.com/reference/android/view/View#security):

> Às vezes, é essencial que um aplicativo possa verificar se uma ação está sendo realizada com o pleno conhecimento e consentimento do usuário, como conceder uma solicitação de permissão, fazer uma compra ou clicar em um anúncio. Infelizmente, um aplicativo malicioso pode tentar enganar o usuário a realizar essas ações, sem saber, ocultando o propósito pretendido da visualização. Como remédio, o framework oferece um mecanismo de filtragem de toque que pode ser usado para melhorar a segurança de visualizações que fornecem acesso a funcionalidades sensíveis.
>
> Para habilitar a filtragem de toque, chame [`setFilterTouchesWhenObscured(boolean)`](https://developer.android.com/reference/android/view/View#setFilterTouchesWhenObscured%28boolean%29) ou defina o atributo de layout android:filterTouchesWhenObscured como true. Quando habilitado, o framework descartará toques que são recebidos sempre que a janela da visualização estiver obscurecida por outra janela visível. Como resultado, a visualização não receberá toques sempre que um toast, diálogo ou outra janela aparecer acima da janela da visualização.

### Sequestro de Tarefas

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### Armazenamento de Dados Inseguro

**Armazenamento Interno**

Arquivos **criados** no **armazenamento interno** são **acessíveis** apenas pelo **aplicativo**. Essa proteção é implementada pelo Android e é suficiente para a maioria dos aplicativos. Mas os desenvolvedores frequentemente usam `MODE_WORLD_READBALE` e `MODE_WORLD_WRITABLE` para dar acesso a esses arquivos a um aplicativo diferente, mas isso não impede que outros aplicativos (maliciosos) os acessem.\
Durante a **análise estática**, verifique o uso desses **modos**, durante a **análise dinâmica**, verifique as **permissões** dos arquivos criados (talvez alguns deles sejam legíveis/graváveis em todo o mundo).\
[Mais informações sobre essa vulnerabilidade e como corrigi-la aqui.](https://manifestsecurity.com/android-application-security-part-8/)

**Armazenamento Externo**

Arquivos criados no **armazenamento externo**, como cartões SD, são **globalmente legíveis e graváveis**. Como o armazenamento externo pode ser removido pelo usuário e também modificado por qualquer aplicativo, você **não deve armazenar informações confidenciais usando o armazenamento externo**.\
Assim como dados de qualquer fonte não confiável, você deve **realizar validação de entrada** ao lidar com **dados do armazenamento externo**. Recomendamos fortemente que você não armazene arquivos executáveis ou de classe no armazenamento externo antes do carregamento dinâmico. Se o seu aplicativo recuperar arquivos executáveis do armazenamento externo, os arquivos devem ser assinados e verificados criptograficamente antes do carregamento dinâmico.\
Informações retiradas daqui [aqui](https://manifestsecurity.com/android-application-security-part-8/).

O armazenamento externo pode ser **acessado** em `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

{% hint style="info" %}
A partir do Android 4.4 (**API 17**), o cartão SD tem uma estrutura de diretório que **limita o acesso de um aplicativo ao diretório que é especificamente para esse aplicativo**. Isso impede que aplicativos maliciosos obtenham acesso de leitura ou gravação aos arquivos de outro aplicativo.
{% endhint %}

**Dados Sensíveis Armazenados em Texto Claro**

* **Preferências compartilhadas**: O Android permite que cada aplicativo salve facilmente arquivos xml no caminho `/data/data/<nomedopacote>/shared_prefs/` e às vezes é possível encontrar informações confidenciais em texto claro nessa pasta.
* **Bancos de dados**: O Android permite que cada aplicativo salve bancos de dados sqlite facilmente no caminho `/data/data/<nomedopacote>/databases/` e às vezes é possível encontrar informações confidenciais em texto claro nessa pasta.

### TLS Quebrado

**Aceitar Todos os Certificados**

Por algum motivo, às vezes os desenvolvedores aceitam todos os certificados, mesmo que, por exemplo, o nome do host não corresponda com linhas de código como a seguinte:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
Uma boa maneira de testar isso é tentar capturar o tráfego usando algum proxy como o Burp sem autorizar o CA do Burp dentro do dispositivo. Além disso, você pode gerar com o Burp um certificado para um nome de host diferente e usá-lo.

### Criptografia Quebrada

**Processos de Gerenciamento de Chave Ruins**

Alguns desenvolvedores salvam dados sensíveis no armazenamento local e os criptografam com uma chave codificada/predizível no código. Isso não deve ser feito, pois alguns reversos podem permitir que os atacantes extraiam informações confidenciais.

**Uso de Algoritmos Inseguros e/ou Obsoletos**

Os desenvolvedores não devem usar algoritmos **obsoletos** para realizar verificações de autorização, armazenar ou enviar dados. Alguns desses algoritmos são: RC4, MD4, MD5, SHA1... Se **hashes** forem usados para armazenar senhas, por exemplo, hashes resistentes a **ataques de força bruta** devem ser usados com sal.

### Outras verificações

* É recomendável **ofuscar o APK** para dificultar o trabalho de engenharia reversa para os atacantes.
* Se o aplicativo for sensível (como aplicativos bancários), ele deve realizar suas **próprias verificações para ver se o dispositivo móvel está rooteado** e agir em consequência.
* Se o aplicativo for sensível (como aplicativos bancários), ele deve verificar se um **emulador** está sendo usado.
* Se o aplicativo for sensível (como aplicativos bancários), ele deve **verificar sua própria integridade antes de executá-lo** para verificar se foi modificado.
* Use o [**APKiD**](https://github.com/rednaga/APKiD) para verificar qual compilador/packer/ofuscador foi usado para construir o APK.

### Aplicação React Native

Leia a seguinte página para aprender como acessar facilmente o código JavaScript de aplicativos React:

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Aplicativos Xamarin

Os aplicativos **Xamarin** são escritos em **C#**, para acessar o código C# **descompactado**, você precisa obter os arquivos do **apk**:
```bash
7z r app.apk #Or any other zip decompression cmd
```
Em seguida, descompacte todos os DLsL usando o [**xamarin-decompress**](https://github.com/NickstaDB/xamarin-decompress)**:**
```
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
E, finalmente, você pode usar [**essas ferramentas recomendadas**](../../reversing/reversing-tools-basic-methods/#net-decompiler) para **ler o código C#** dos DLLs.

### Análise de código estático automatizada

A ferramenta [**mariana-trench**](https://github.com/facebook/mariana-trench) é capaz de encontrar **vulnerabilidades** **analisando** o **código** do aplicativo. Essa ferramenta contém uma série de **fontes conhecidas** (que indicam à ferramenta os **locais** onde a **entrada** é **controlada pelo usuário**), **sinks** (que indicam à ferramenta **locais perigosos** onde a entrada maliciosa do usuário pode causar danos) e **regras**. Essas regras indicam a **combinação** de **fontes-sinks** que indicam uma vulnerabilidade.

Com esse conhecimento, **mariana-trench revisará o código e encontrará possíveis vulnerabilidades nele**.

### Vazamentos de segredos

Um aplicativo pode conter segredos (chaves de API, senhas, URLs ocultas, subdomínios...) dentro dele que você pode descobrir. Você pode usar uma ferramenta como [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass na autenticação biométrica

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### Outras funções interessantes

* **Execução de código**: `Runtime.exec(), ProcessBuilder(), código nativo:system()`
* **Envio de SMS**: `sendTextMessage, sendMultipartTestMessage`
* **Funções nativas** declaradas como `native`: `public native, System.loadLibrary, System.load`
  * [Leia isso para aprender **como reverter funções nativas**](reversing-native-libraries.md)

### **Outros truques**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga o HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

🐞 Leia tutoriais de bugs web3

🔔 Receba notificações sobre novas recompensas por bugs

💬 Participe de discussões na comunidade

## Análise dinâmica

> Em primeiro lugar, você precisa de um ambiente onde possa instalar o aplicativo e todo o ambiente (certificado Burp CA, Drozer e Frida principalmente). Portanto, um dispositivo com root (emulado ou não) é extremamente recomendado.

### Análise dinâmica online

Você pode criar uma **conta gratuita** em: [https://appetize.io/](https://appetize.io). Essa plataforma permite que você **carregue** e **execute** APKs, portanto, é útil para ver como um APK está se comportando.

Você pode até **ver os logs do seu aplicativo** na web e se conectar por meio de **adb**.

![](<../../.gitbook/assets/image (60).png>)

Graças à conexão ADB, você pode usar **Drozer** e **Frida** dentro dos emuladores.

### Análise dinâmica local

Você pode usar algum **emulador** como:

* [**Android Studio**](https://developer.android.com/studio) (Você pode criar dispositivos **x86** e **arm**, e de acordo com [**este**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html) **últimas versões x86** suportam **bibliotecas ARM** sem precisar de um emulador ARM lento).
  * Se você quiser tentar **instalar** uma **imagem** e depois quiser **excluí-la**, poderá fazer isso no Windows:`C:\Users\<User>\AppData\Local\Android\sdk\system-images\` ou Mac: `/Users/myeongsic/Library/Android/sdk/system-image`
  * Este é o **principal emulador que recomendo usar e você pode** [**aprender a configurá-lo nesta página**](avd-android-virtual-device.md).
* [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versão gratuita:** Personal Edition, você precisa criar uma conta. _É recomendável **baixar** a versão **COM**_ _**VirtualBox** para evitar erros potenciais._)
* [Nox](https://es.bignox.com) (Grátis, mas não suporta Frida ou Drozer).

{% hint style="info" %}
Ao criar um novo emulador em qualquer plataforma, lembre-se de que quanto maior a tela, mais lento o emulador será executado. Portanto, selecione telas pequenas, se possível.
{% endhint %}

Como a maioria das pessoas usará o **Genymotion**, observe este truque. Para **instalar serviços do Google** (como AppStore), você precisa clicar no botão marcado em vermelho na seguinte imagem:

![](<../../.gitbook/assets/image (200) (1).png>)

Além disso, observe que na **configuração da VM Android no Genymotion** você pode selecionar o **modo de rede Bridge** (isso será útil se você se conectar à VM Android de uma VM diferente com as ferramentas).

Ou você pode usar um **dispositivo físico** (você precisa ativar as opções de depuração e será legal se puder fazer root):

1. **Configurações**.
2. (A partir do Android 8.0) Selecione **Sistema**.
3. Selecione **Sobre o telefone**.
4. Pressione **Número da compilação** 7 vezes.
5. Volte e você encontrará as **Opções do desenvolvedor**.

> Depois de instalar o aplicativo, a primeira coisa que você deve fazer é experimentá-lo e investigar o que ele faz, como funciona e se sentir confortável com ele.\
> Eu sugeriria **realizar essa análise dinâmica inicial usando a análise dinâmica do MobSF + pidcat**, para que você possa **aprender como o aplicativo funciona** enquanto o MobSF **captura** muitos **dados interessantes** que você pode revisar posteriormente.

### Vazamento de dados não intencional

**Logging**

Com frequência, os desenvolvedores deixam informações de depuração publicamente. Portanto, qualquer aplicativo com permissão `READ_LOGS` pode **acessar esses logs** e pode obter informações confidenciais por meio deles.\
Ao navegar pelo aplicativo, use [**pidcat**](https://github.com/JakeWharton/pidcat)_(Recomendado, é mais fácil de usar e ler_) ou [adb logcat](adb-commands.md#logcat) para ler os logs criados e **procurar informações confidenciais**.

{% hint style="warning" %}
Observe que a partir das versões posteriores ao Android 4.0, **os aplicativos só podem acessar seus próprios logs**. Portanto, os aplicativos não podem acessar os logs de outros aplicativos.\
De qualquer forma, ainda é recomendável **não registrar informações confidenciais**.
{% endhint %}

**Caching do buffer de cópia/cola**

O Android fornece um **quadro baseado em clipboard** para fornecer a função de cópia e colagem em aplicativos Android. Mas isso cria um problema sé
```
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: O MobSF detectará como malicioso o uso de _**singleTask/singleInstance**_ como `android:launchMode` em uma atividade, mas devido a [isso](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), aparentemente isso é perigoso apenas em versões antigas (API versões < 21).

{% hint style="info" %}
Observe que uma violação de autorização nem sempre é uma vulnerabilidade, dependerá de como a violação funciona e quais informações são expostas.
{% endhint %}

**Vazamento de informações sensíveis**

**As atividades também podem retornar resultados**. Se você conseguir encontrar uma atividade exportada e desprotegida que chame o método **`setResult`** e **retorne informações sensíveis**, haverá um vazamento de informações sensíveis.

### Explorando Provedores de Conteúdo - Acessando e manipulando informações sensíveis

[**Leia isto se quiser lembrar o que é um Provedor de Conteúdo.**](android-applications-basics.md#content-provider)\
Os provedores de conteúdo são basicamente usados para **compartilhar dados**. Se um aplicativo tiver provedores de conteúdo disponíveis, você poderá **extrair dados sensíveis** deles. Também é interessante testar possíveis **injeções de SQL** e **travessias de caminho** pois eles podem ser vulneráveis.\
[**Aprenda a explorar Provedores de Conteúdo com o Drozer.**](drozer-tutorial/#content-providers)

### **Explorando Serviços**

[**Leia isto se quiser lembrar o que é um Serviço.**](android-applications-basics.md#services)\
Lembre-se de que as ações de um serviço começam no método `onStartCommand`.

Um serviço é basicamente algo que **pode receber dados**, **processá-los** e **retornar** (ou não) uma resposta. Então, se um aplicativo estiver exportando alguns serviços, você deve **verificar** o **código** para entender o que ele está fazendo e **testá-lo** **dinamicamente** para extrair informações confidenciais, contornar medidas de autenticação...\
[**Aprenda a explorar Serviços com o Drozer.**](drozer-tutorial/#services)

### **Explorando Receptores de Transmissão**

[**Leia isto se quiser lembrar o que é um Receptor de Transmissão.**](android-applications-basics.md#broadcast-receivers)\
Lembre-se de que as ações de um Receptor de Transmissão começam no método `onReceive`.

Um receptor de transmissão estará aguardando um tipo de mensagem. Dependendo de como o receptor manipula a mensagem, ele pode ser vulnerável.\
[**Aprenda a explorar Receptores de Transmissão com o Drozer.**](./#exploiting-broadcast-receivers)

### **Explorando Esquemas / Links Profundos**

Você pode procurar links profundos manualmente, usando ferramentas como MobSF ou scripts como [este](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Você pode **abrir** um **esquema** declarado usando **adb** ou um **navegador**:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
Observe que você pode **omitir o nome do pacote** e o dispositivo móvel automaticamente chamará o aplicativo que deve abrir o link.
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**Código executado**

Para encontrar o **código que será executado no aplicativo**, vá para a atividade chamada pelo deep link e procure a função **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**Informações sensíveis**

Sempre que encontrar um deep link, verifique se ele não está recebendo dados sensíveis (como senhas) por meio de parâmetros de URL, porque qualquer outro aplicativo pode **se passar pelo deep link e roubar esses dados!**

**Parâmetros no caminho**

Você **também deve verificar se algum deep link está usando um parâmetro dentro do caminho** do URL, como: `https://api.example.com/v1/users/{username}`, nesse caso, você pode forçar uma travessia de caminho acessando algo como: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Observe que, se você encontrar os endpoints corretos dentro do aplicativo, poderá causar um **Redirecionamento Aberto** (se parte do caminho for usada como nome de domínio), **assumir a conta** (se puder modificar os detalhes dos usuários sem token CSRF e o endpoint vulnerável usar o método correto) e qualquer outra vulnerabilidade. Mais [informações sobre isso aqui](http://dphoeniixx.com/2020/12/13-2/).

**Mais exemplos**

Um [relatório interessante de bug bounty](https://hackerone.com/reports/855618) sobre links (_/.well-known/assetlinks.json_).

### Proteção Insuficiente da Camada de Transporte

* **Falta de Inspeção de Certificado:** O aplicativo Android não verifica a identidade do certificado apresentado a ele. A maioria dos aplicativos ignora os avisos e aceita qualquer certificado autoassinado apresentado. Alguns aplicativos, em vez disso, passam o tráfego por uma conexão HTTP.
* **Negociação de Handshake Fraca:** O aplicativo e o servidor realizam um handshake SSL/TLS, mas usam uma suíte de criptografia insegura que é vulnerável a ataques MITM. Assim, qualquer atacante pode facilmente descriptografar essa conexão.
* **Vazamento de Informações de Privacidade:** Na maioria das vezes, acontece que os aplicativos fazem autenticação por meio de um canal seguro, mas todas as outras conexões por meio de um canal não seguro. Isso não adiciona segurança ao aplicativo, porque o restante dos dados sensíveis, como cookie de sessão ou dados do usuário, pode ser interceptado por um usuário mal-intencionado.

Dos 3 cenários apresentados, vamos discutir **como verificar a identidade do certificado**. Os outros 2 cenários dependem da **configuração TLS** do servidor e se o **aplicativo envia dados não criptografados**. O pentester deve verificar por conta própria a configuração TLS do servidor ([aqui](../../network-services-pentesting/pentesting-web/#ssl-tls-vulnerabilites)) e detectar se algum **informação confidencial é enviada por um canal não criptografado/vulnerável**.\
Mais informações sobre como descobrir e corrigir esse tipo de vulnerabilidades [**aqui**](https://manifestsecurity.com/android-application-security-part-10/).

**SSL Pinning**

Por padrão, ao fazer uma conexão SSL, o cliente (aplicativo Android) verifica se o certificado do servidor tem uma cadeia de confiança verificável de volta a um certificado confiável (raiz) e corresponde ao nome do host solicitado. Isso leva ao problema de **ataques Man in the Middle (MITM)**.\
No certificate Pinnning, um aplicativo Android em si contém o certificado do servidor e só transmite dados se o mesmo certificado for apresentado.\
É recomendável **aplicar o SSL Pinning** para os sites onde informações sensíveis serão enviadas.

### Inspeção de tráfego HTTP

Em primeiro lugar, você deve (deve) **instalar o certificado** da ferramenta de **proxy** que você vai usar, provavelmente o Burp. Se você não instalar o certificado CA da ferramenta de proxy, provavelmente não verá o tráfego criptografado no proxy.\
**Por favor,** [**leia este guia para aprender como instalar um certificado CA personalizado**](android-burp-suite-settings.md)**.**

Para aplicativos direcionados ao **API Level 24+ não é suficiente instalar o certificado Burp** no dispositivo. Para contornar essa nova proteção, você precisa modificar o arquivo de Configuração de Segurança de Rede. Portanto, você pode modificar este arquivo para autorizar seu certificado CA ou pode [**ler esta página para um tutorial sobre como forçar o aplicativo a aceitar novamente todos os certificados instalados no dispositivo**](make-apk-accept-ca-certificate.md).

**SSL Pinning**

Já discutimos o que é SSL Pinning apenas 2 parágrafos antes. Quando implementado em um aplicativo, você precisará ignorá-lo para inspecionar o tráfego HTTPS ou não o verá.\
Aqui vou apresentar algumas opções que usei para ignorar essa proteção:

* **Modificar automaticamente** o **apk** para **ignorar** o SSLPinning com [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). O melhor pró dessa opção é que você não precisará de root para ignorar o SSL Pinning, mas precisará excluir o aplicativo e reinstalar o novo, e isso nem sempre funcionará.
* Você pode usar **Frida** (discutido abaixo) para ignorar essa proteção. Aqui está um guia para usar Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
* Você também pode tentar **ignorar automaticamente o SSL Pinning** usando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* Você também pode tentar **ignorar automaticamente o SSL Pinning** usando **MobSF dynamic analysis** (explicado abaixo)
* Se você ainda acha que há algum tráfego que não está capturando, pode tentar **encaminhar o tráfego para o burp usando iptables**. Leia este blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

**Vulnerabilidades Web comuns**

Observe que, nesta etapa, você deve procurar vulnerabilidades web comuns. Muitas informações sobre vulnerabilidades web podem ser encontradas neste livro, então não vou mencioná-las aqui.

### Frida

Kit de instrumentação dinâmica para desenvolvedores, engenheiros reversos e pesquisadores de segurança. Saiba mais em [www.frida.re](https://www.frida.re).\
**É incrível, você pode acessar o aplicativo em execução e conectar métodos em tempo de execução para alterar o comportamento, alterar valores, extrair
```
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Observe que o MobSF pode analisar aplicativos **Android** (apk), **IOS** (ipa) e **Windows** (apx) (os aplicativos do Windows devem ser analisados a partir de um MobSF instalado em um host do Windows).\
Além disso, se você criar um arquivo **ZIP** com o código-fonte de um aplicativo **Android** ou **IOS** (vá para a pasta raiz do aplicativo, selecione tudo e crie um arquivo ZIP), o MobSF também poderá analisá-lo.

O MobSF também permite que você faça uma **comparação/diferenciação** de análises e integre o **VirusTotal** (você precisará definir sua chave de API em _MobSF/settings.py_ e ativá-la: `VT_ENABLED = TRUE` `VT_API_KEY = <Sua chave de API>` `VT_UPLOAD = TRUE`). Você também pode definir `VT_UPLOAD` como `False`, então o **hash** será **carregado** em vez do arquivo.

### Análise dinâmica assistida com MobSF

O **MobSF** também pode ser muito útil para análise **dinâmica** no **Android**, mas nesse caso você precisará instalar o MobSF e o **genymotion** em seu host (uma VM ou Docker não funcionará). _Observação: você precisa **iniciar primeiro uma VM no genymotion** e **depois o MobSF**._\
O analisador dinâmico do **MobSF** pode:

* **Despejar dados do aplicativo** (URLs, logs, área de transferência, capturas de tela feitas por você, capturas de tela feitas pelo "**Exported Activity Tester**", e-mails, bancos de dados SQLite, arquivos XML e outros arquivos criados). Tudo isso é feito automaticamente, exceto pelas capturas de tela, você precisa pressionar quando desejar uma captura de tela ou precisa pressionar "**Exported Activity Tester**" para obter capturas de tela de todas as atividades exportadas.
* Capturar **tráfego HTTPS**
* Usar o **Frida** para obter **informações em tempo de execução**

A partir das versões do **Android > 5**, ele iniciará **automaticamente o Frida** e definirá as configurações globais de **proxy** para **capturar** o tráfego. Ele capturará apenas o tráfego do aplicativo testado.

**Frida**

Por padrão, ele também usará alguns scripts do Frida para **burlar o SSL pinning**, **detecção de root** e **detecção de depurador** e para **monitorar APIs interessantes**.\
O MobSF também pode **invocar atividades exportadas**, capturar **capturas de tela** delas e **salvá-las** para o relatório.

Para **iniciar** o teste dinâmico, pressione o botão verde: "**Start Instrumentation**". Pressione "**Frida Live Logs**" para ver os logs gerados pelos scripts do Frida e "**Live API Monitor**" para ver todas as invocações aos métodos conectados, argumentos passados e valores retornados (isso aparecerá após pressionar "Start Instrumentation").\
O MobSF também permite que você carregue seus próprios **scripts do Frida** (para enviar os resultados de seus scripts do Friday para o MobSF, use a função `send()`). Ele também possui **vários scripts pré-escritos** que você pode carregar (você pode adicionar mais em `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selecioná-los**, pressionar "**Load**" e pressionar "**Start Instrumentation**" (você poderá ver os logs desses scripts dentro de "**Frida Live Logs**").

![](<../../.gitbook/assets/image (215).png>)

Além disso, você tem algumas funcionalidades auxiliares do Frida:

* **Enumerate Loaded Classes**: Ele imprimirá todas as classes carregadas
* **Capture Strings**: Ele imprimirá todas as strings capturadas enquanto usa o aplicativo (super barulhento)
* **Capture String Comparisons**: Pode ser muito útil. Ele **mostrará as 2 strings sendo comparadas** e se o resultado foi Verdadeiro ou Falso.
* **Enumerate Class Methods**: Coloque o nome da classe (como "java.io.File") e ele imprimirá todos os métodos da classe.
* **Search Class Pattern**: Pesquise classes por padrão
* **Trace Class Methods**: **Trace** uma **classe inteira** (veja as entradas e saídas de todos os métodos da classe). Lembre-se de que, por padrão, o MobSF rastreia vários métodos interessantes da API do Android.

Depois de selecionar o módulo auxiliar que deseja usar, você precisa pressionar "**Start Intrumentation**" e verá todas as saídas em "**Frida Live Logs**".

**Shell**

O Mobsf também oferece um shell com alguns comandos **adb**, comandos **MobSF** e comandos **shell** comuns na parte inferior da página de análise dinâmica. Alguns comandos interessantes:
```
help
shell ls
activities
exported_activities
services
receivers
```
**Ferramentas HTTP**

Quando o tráfego http é capturado, você pode ver uma visão desagradável do tráfego capturado na parte inferior "**HTTP(S) Traffic**" ou uma visão mais agradável no botão verde "**Start HTTPTools**". A partir da segunda opção, você pode **enviar** as **solicitações capturadas** para **proxies** como Burp ou Owasp ZAP.\
Para fazer isso, _ligue o Burp -->_ _desligue o Intercept --> no MobSB HTTPTools selecione a solicitação_ --> pressione "**Send to Fuzzer**" --> _selecione o endereço do proxy_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

Depois de concluir a análise dinâmica com o MobSF, você pode pressionar "**Start Web API Fuzzer**" para **fuzz http requests** e procurar por vulnerabilidades.

{% hint style="info" %}
Depois de realizar uma análise dinâmica com o MobSF, as configurações de proxy podem estar incorretas e você não poderá corrigi-las pela GUI. Você pode corrigir as configurações de proxy fazendo:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Análise Dinâmica Assistida com Inspeckage

Você pode obter a ferramenta em [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Essa ferramenta usa alguns **Hooks** para permitir que você saiba **o que está acontecendo no aplicativo** enquanto você realiza uma **análise dinâmica**.

{% content-ref url="inspeckage-tutorial.md" %}
[inspeckage-tutorial.md](inspeckage-tutorial.md)
{% endcontent-ref %}

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Esta é uma **ótima ferramenta para realizar análise estática com uma GUI**

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

Esta ferramenta é projetada para procurar várias **vulnerabilidades de segurança relacionadas ao aplicativo Android**, seja no **código-fonte** ou em **APKs empacotados**. A ferramenta também é **capaz de criar um APK implantável "Proof-of-Concept"** e **comandos ADB**, para explorar algumas das vulnerabilidades encontradas (atividades expostas, intenções, tapjacking...). Assim como o Drozer, não é necessário fazer root no dispositivo de teste.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* Exibe todos os arquivos extraídos para fácil referência
* Decompila automaticamente arquivos APK para formato Java e Smali
* Analisa o AndroidManifest.xml em busca de vulnerabilidades e comportamentos comuns
* Análise estática do código-fonte em busca de vulnerabilidades e comportamentos comuns
  * Informações do dispositivo
  * Intenções
  * Execução de comandos
  * Referências SQLite
  * Referências de registro
  * Provedores de conteúdo
  * Receptores de transmissão
  * Referências de serviço
  * Referências de arquivo
  * Referências de criptografia
  * Segredos codificados
  * URL's
  * Conexões de rede
  * Referências SSL
  * Referências WebView
```
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

O SUPER é um aplicativo de linha de comando que pode ser usado no Windows, MacOS X e Linux, que analisa arquivos _.apk_ em busca de vulnerabilidades. Ele faz isso descompactando APKs e aplicando uma série de regras para detectar essas vulnerabilidades.

Todas as regras estão centralizadas em um arquivo `rules.json`, e cada empresa ou testador pode criar suas próprias regras para analisar o que precisam.

Baixe os binários mais recentes na [página de download](https://superanalyzer.rocks/download.html).
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAn é uma ferramenta **multiplataforma** que ajuda desenvolvedores, caçadores de bugs e hackers éticos a realizar análise de código estático em aplicativos móveis\*.

O conceito é que você arraste e solte o arquivo do seu aplicativo móvel (um arquivo .apk ou .ipa) na aplicação StaCoAn e ela gerará um relatório visual e portátil para você. Você pode ajustar as configurações e listas de palavras para obter uma experiência personalizada.

Baixe a [última versão](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

O AndroBugs Framework é um sistema de análise de vulnerabilidades do Android que ajuda desenvolvedores ou hackers a encontrar possíveis vulnerabilidades de segurança em aplicativos Android.\
[Releases para Windows](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** é uma ferramenta cujo objetivo principal é detectar e alertar o usuário sobre possíveis comportamentos maliciosos desenvolvidos por um aplicativo Android.

A detecção é realizada com a **análise estática** do bytecode Dalvik do aplicativo, representado como **Smali**, com a biblioteca [`androguard`](https://github.com/androguard/androguard).

Esta ferramenta procura por **comportamentos comuns de aplicativos "ruins"** como: exfiltração de identificadores de telefonia, interceptação de fluxo de áudio/vídeo, modificação de dados PIM, execução de código arbitrário...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA\_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA** é um **F**ramework de **R**everse **E**ngineering e **A**nálise de **A**plicativos **M**óveis. É uma ferramenta que reúne ferramentas comumente usadas para análise e reverse engineering de aplicativos móveis, para ajudar no teste de aplicativos móveis contra ameaças de segurança móvel OWASP. Seu objetivo é tornar essa tarefa mais fácil e amigável para desenvolvedores de aplicativos móveis e profissionais de segurança.

Ele é capaz de:

* Extrair código Java e Smali usando diferentes ferramentas
* Analisar APKs usando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs\_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
* Extrair informações privadas do APK usando regexps.
* Analisar o Manifest.
* Analisar domínios encontrados usando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
* Desofuscar APK via [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Útil para detectar malware: [https://koodous.com/](https://koodous.com)

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

🐞 Leia tutoriais de bugs web3

🔔 Receba notificações sobre novas recompensas por bugs

💬 Participe de discussões na comunidade

## Ofuscando/Desofuscando código

Observe que, dependendo do serviço e da configuração que você usa para ofuscar o código, segredos podem ou não ser ofuscados.

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

**ProGuard** é uma ferramenta de linha de comando de código aberto que encolhe, otimiza e ofusca o código Java. Ele é capaz de otimizar o bytecode e detectar e remover instruções não utilizadas. O ProGuard é um software gratuito e é distribuído sob a Licença Pública Geral GNU, versão 2.

O ProGuard é distribuído como parte do Android SDK e é executado ao compilar o aplicativo no modo de lançamento.

De: [https://en.wikipedia.org/wiki/ProGuard\_(software)](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

### [DexGuard](https://www.guardsquare.com/dexguard)

Encontre um guia passo a passo para desofuscar o apk em [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Daquele guia) Da última vez que verificamos, o modo de operação do Dexguard foi:

* carregar um recurso como um InputStream;
* alimentar o resultado para uma classe herdando de FilterInputStream para descriptografá-lo;
* fazer alguma ofuscação inútil para desperdiçar alguns minutos de tempo de um reverser;
* alimentar o resultado descriptografado para um ZipInputStream para obter um arquivo DEX;
* finalmente carregar o DEX resultante como um recurso usando o método `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard reverte o processo de ofuscação realizado pelas ferramentas de ofuscação do Android. Isso permite inúmeras análises de segurança, incluindo inspeção de código e previsão de bibliotecas.**

Você pode fazer upload de um APK ofuscado para a plataforma deles.

### [Simplify](https://github.com/CalebFenton/simplify)

É um **desofuscador genérico do Android.** Simplify **executa virtualmente um aplicativo** para entender seu comportamento e, em seguida, **tenta otimizar o código** para que ele se comporte de forma idêntica, mas seja mais fácil para um humano entender. Cada tipo de otimização é simples e genérico, portanto, não importa qual o tipo específico de ofuscação usado.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD fornece informações sobre **como um APK foi feito**. Ele identifica muitos **compiladores**, **empacotadores**, **ofuscadores** e outras coisas estranhas. É o [_PEiD_](https://www.aldeid.com/wiki/PEiD) para Android.

### Manual

[Leia este tutorial para aprender alguns truques sobre **como reverter a ofuscação personalizada**](manual-deobfuscation.md)

## Laboratórios

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b é uma máquina virtual de segurança Android baseada no ubuntu-mate que inclui a coleção dos últimos frameworks, tutoriais e laboratórios de diferentes geeks e pesquisadores de segurança para engenharia reversa e análise de malware.

### OWASP

{% embed url="https://github.com/OWASP/owasp-mstg%0Ahttps://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06g-testing-network-communication" %}

### Repositórios Git

[https://github.com/riddhi-shree/nullCommunity/tree/master/Android](https://github.com/riddhi-shree/nullCommunity/tree/master/Android)\
[https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## Referências

Para mais informações, visite:

* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) É uma ótima lista de recursos
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Curso rápido de Android
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)

## Para Testar

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

🐞 Leia tutoriais de bugs web3

🔔 Receba notificações sobre novas recompensas por bugs

💬 Participe de discussões na comunidade

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em
