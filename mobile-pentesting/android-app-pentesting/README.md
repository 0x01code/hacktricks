# Test delle Applicazioni Android

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug bounty!

**Approfondimenti sull'Hacking**\
Coinvolgiti con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Notizie sull'Hacking in Tempo Reale**\
Resta aggiornato con il mondo dell'hacking in rapida evoluzione attraverso notizie e approfondimenti in tempo reale

**Ultime Novit√†**\
Resta informato sui nuovi bug bounty in arrivo e sugli aggiornamenti cruciali delle piattaforme

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi stesso!

## Concetti di Base delle Applicazioni Android

√à altamente consigliato iniziare a leggere questa pagina per conoscere le **parti pi√π importanti relative alla sicurezza di Android e i componenti pi√π pericolosi in un'applicazione Android**:

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB (Android Debug Bridge)

Questo √® lo strumento principale di cui hai bisogno per connetterti a un dispositivo Android (emulato o fisico).\
**ADB** consente di controllare i dispositivi sia tramite **USB** che tramite **Rete** da un computer. Questa utility consente la **copia** di file in entrambe le direzioni, **installazione** e **disinstallazione** di app, **esecuzione** di comandi shell, **backup** dei dati, **lettura** dei log, tra le altre funzioni.

Dai un'occhiata alla seguente lista di [**Comandi ADB**](adb-commands.md) per imparare come utilizzare adb.

## Smali

A volte √® interessante **modificare il codice dell'applicazione** per accedere a **informazioni nascoste** (forse password ben oscurate o flag). Quindi, potrebbe essere interessante decompilare l'apk, modificare il codice e ricompilarlo.\
[**In questo tutorial** puoi **imparare come decompilare un APK, modificare il codice Smali e ricompilare l'APK** con la nuova funzionalit√†](smali-changes.md). Questo potrebbe essere molto utile come **alternativa per diversi test durante l'analisi dinamica** che verranno presentati. Quindi, **tieni sempre presente questa possibilit√†**.

## Altri trucchi interessanti

* [Falsificare la tua posizione nel Play Store](spoofing-your-location-in-play-store.md)
* **Scarica APK**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* Estrarre APK dal dispositivo:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
## Analisi Statica

Prima di tutto, per analizzare un APK dovresti **dare un'occhiata al codice Java** utilizzando un decompiler.\
Per favore, [**leggi qui per trovare informazioni sui diversi decompiler disponibili**](apk-decompilers.md).

### Ricerca di informazioni interessanti

Semplicemente guardando le **stringhe** dell'APK puoi cercare **password**, **URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)), **chiavi api**, **crittografia**, **UUID Bluetooth**, **token** e qualsiasi altra cosa interessante... cerca anche eventuali **backdoor** di esecuzione del codice o backdoor di autenticazione (credenziali admin codificate nell'app).

**Firebase**

Presta particolare attenzione agli **URL di Firebase** e controlla se sono configurati male. [Ulteriori informazioni su cosa sia Firebase e come sfruttarlo qui.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### Comprensione di base dell'applicazione - Manifest.xml, strings.xml

L'**esame dei file Manifest.xml e strings.xml di un'applicazione pu√≤ rivelare potenziali vulnerabilit√† di sicurezza**. Questi file possono essere accessati utilizzando decompiler o rinominando l'estensione del file APK in .zip e quindi decomprimendolo.

Le **vulnerabilit√†** identificate dal **Manifest.xml** includono:

* **Applicazioni in modalit√† di debug**: Le applicazioni impostate come debuggable (`debuggable="true"`) nel file _Manifest.xml_ rappresentano un rischio in quanto consentono connessioni che possono portare a sfruttamenti. Per una maggiore comprensione su come sfruttare le applicazioni in modalit√† di debug, consulta un tutorial su come trovare ed esplorare le applicazioni in modalit√† di debug su un dispositivo.
* **Impostazioni di backup**: L'attributo `android:allowBackup="false"` dovrebbe essere impostato esplicitamente per le applicazioni che gestiscono informazioni sensibili per impedire il backup non autorizzato dei dati tramite adb, specialmente quando il debug USB √® abilitato.
* **Sicurezza di rete**: Le configurazioni personalizzate di sicurezza di rete (`android:networkSecurityConfig="@xml/network_security_config"`) in _res/xml/_ possono specificare dettagli di sicurezza come i pin dei certificati e le impostazioni del traffico HTTP. Un esempio √® consentire il traffico HTTP per domini specifici.
* **Attivit√† e servizi esportati**: Identificare attivit√† e servizi esportati nel manifesto pu√≤ evidenziare componenti che potrebbero essere utilizzati impropriamente. Un'ulteriore analisi durante i test dinamici pu√≤ rivelare come sfruttare questi componenti.
* **Provider di contenuti e FileProviders**: I provider di contenuti esposti potrebbero consentire l'accesso o la modifica non autorizzati dei dati. Anche la configurazione dei FileProviders dovrebbe essere scrutinata.
* **Ricevitori di trasmissione e schemi URL**: Questi componenti potrebbero essere sfruttati per l'exploit, con particolare attenzione a come vengono gestiti gli schemi URL per le vulnerabilit√† di input.
* **Versioni SDK**: Gli attributi `minSdkVersion`, `targetSDKVersion` e `maxSdkVersion` indicano le versioni di Android supportate, evidenziando l'importanza di non supportare versioni di Android obsolete e vulnerabili per motivi di sicurezza.

Dal file **strings.xml**, possono essere scoperte informazioni sensibili come chiavi API, schemi personalizzati e altre note per gli sviluppatori, sottolineando la necessit√† di una revisione attenta di tali risorse.

### Tapjacking

**Tapjacking** √® un attacco in cui un'applicazione **malintenzionata** viene avviata e si **posiziona sopra un'applicazione vittima**. Una volta che oscura visivamente l'applicazione vittima, la sua interfaccia utente √® progettata in modo tale da ingannare l'utente affinch√© interagisca con essa, mentre passa l'interazione all'applicazione vittima.\
Di fatto, **acceca l'utente dal sapere che sta effettivamente eseguendo azioni sull'applicazione vittima**.

Trova ulteriori informazioni in:

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### Task Hijacking

Un'**attivit√†** con il **`launchMode`** impostato su **`singleTask` senza alcun `taskAffinity`** definito √® vulnerabile al Task Hijacking. Ci√≤ significa che un'**applicazione** pu√≤ essere installata e se avviata prima dell'applicazione reale potrebbe **dirottare il task dell'applicazione reale** (quindi l'utente interagir√† con l'**applicazione malintenzionata pensando di usare quella reale**).

Ulteriori informazioni in:

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### Archiviazione dati non sicura

**Archiviazione interna**

In Android, i file **archiviati** nella **memoria interna** sono **progettati** per essere **accessibili esclusivamente dall'applicazione che li ha creati**. Questa misura di sicurezza √® **imposta** dal sistema operativo Android ed √® generalmente sufficiente per le esigenze di sicurezza della maggior parte delle applicazioni. Tuttavia, a volte gli sviluppatori utilizzano modalit√† come `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` per **consentire** ai file di essere **condivisi** tra diverse applicazioni. Tuttavia, queste modalit√† **non limitano l'accesso** a questi file da parte di altre applicazioni, comprese quelle potenzialmente dannose.

1. **Analisi Statica:**
* **Assicurarsi** che l'uso di `MODE_WORLD_READABLE` e `MODE_WORLD_WRITABLE` sia **scrutinato attentamente**. Queste modalit√† **potrebbero esporre** i file a **accessi non intenzionali o non autorizzati**.
2. **Analisi Dinamica:**
* **Verificare** i **permessi** impostati sui file creati dall'app. In particolare, **verificare** se alcuni file sono **impostati come leggibili o scrivibili a livello globale**. Ci√≤ potrebbe rappresentare un rischio significativo per la sicurezza, poich√© consentirebbe a **qualsiasi applicazione** installata sul dispositivo, indipendentemente dalla sua origine o intento, di **leggere o modificare** questi file.

**Archiviazione esterna**

Quando si tratta di file su **memoria esterna**, come le schede SD, dovrebbero essere prese alcune precauzioni:

1. **Accessibilit√†**:
* I file su memoria esterna sono **leggibili e scrivibili globalmente**. Ci√≤ significa che qualsiasi applicazione o utente pu√≤ accedere a questi file.
2. **Preoccupazioni per la sicurezza**:
* Date la facilit√† di accesso, √® consigliabile **non memorizzare informazioni sensibili** su memoria esterna.
* La memoria esterna pu√≤ essere rimossa o accessibile da qualsiasi applicazione, rendendola meno sicura.
3. **Gestione dei dati dalla memoria esterna**:
* Effettuare sempre **validazione dell'input** sui dati recuperati dalla memoria esterna. Questo √® cruciale perch√© i dati provengono da una fonte non attendibile.
* Memorizzare eseguibili o file di classe su memoria esterna per il caricamento dinamico √® fortemente sconsigliato.
* Se la tua applicazione deve recuperare file eseguibili dalla memoria esterna, assicurati che questi file siano **firmati e verificati crittograficamente** prima di essere caricati dinamicamente. Questo passaggio √® vitale per mantenere l'integrit√† della sicurezza della tua applicazione.

La memoria esterna pu√≤ essere **accessibile** in `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`

{% hint style="info" %}
A partire da Android 4.4 (**API 17**), la scheda SD ha una struttura delle directory che **limita l'accesso da un'app alla directory specifica per quell'app**. Ci√≤ impedisce a un'applicazione dannosa di ottenere accesso in lettura o scrittura ai file di un'altra app.
{% endhint %}

**Dati sensibili memorizzati in chiaro**

* **Preferenze condivise**: Android consente a ogni applicazione di salvare facilmente file xml nel percorso `/data/data/<nomepacchetto>/shared_prefs/` e talvolta √® possibile trovare informazioni sensibili in chiaro in quella cartella.
* **Database**: Android consente a ogni applicazione di salvare facilmente database sqlite nel percorso `/data/data/<nomepacchetto>/databases/` e talvolta √® possibile trovare informazioni sensibili in chiaro in quella cartella.

### TLS non sicuro

**Accetta tutti i certificati**

Per qualche motivo a volte gli sviluppatori accettano tutti i certificati anche se ad esempio il nome host non corrisponde con righe di codice come la seguente:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
### Crittografia danneggiata

**Processi di gestione delle chiavi scadenti**

Alcuni sviluppatori salvano dati sensibili nello storage locale e li crittografano con una chiave codificata/prevedibile nel codice. Questo non dovrebbe essere fatto poich√© un'operazione di reverse engineering potrebbe consentire agli attaccanti di estrarre le informazioni confidenziali.

**Utilizzo di algoritmi insicuri e/o deprecati**

Gli sviluppatori non dovrebbero utilizzare **algoritmi deprecati** per effettuare **controlli di autorizzazione**, **memorizzare** o **inviare** dati. Alcuni di questi algoritmi sono: RC4, MD4, MD5, SHA1... Se vengono utilizzati **hash** per memorizzare le password ad esempio, dovrebbero essere utilizzati hash **resistenti** all'attacco di forza bruta con salt.

### Altri controlli

* √à consigliabile **oscurare l'APK** per rendere pi√π difficile il lavoro di reverse engineering agli attaccanti.
* Se l'app √® sensibile (come le app bancarie), dovrebbe effettuare i **propri controlli per verificare se il dispositivo mobile √® stato sradicato** e agire di conseguenza.
* Se l'app √® sensibile (come le app bancarie), dovrebbe verificare se viene utilizzato un **emulatore**.
* Se l'app √® sensibile (come le app bancarie), dovrebbe **verificare la propria integrit√† prima di eseguirsi** per controllare se √® stata modificata.
* Utilizzare [**APKiD**](https://github.com/rednaga/APKiD) per verificare quale compilatore/packer/obfuscator √® stato utilizzato per compilare l'APK

### Applicazione React Native

Leggi la seguente pagina per imparare come accedere facilmente al codice JavaScript delle applicazioni React:

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Applicazioni Xamarin

Leggi la seguente pagina per imparare come accedere facilmente al codice C# delle applicazioni Xamarin:

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### Applicazioni Superpacked

Secondo questo [**post sul blog**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/) superpacked √® un algoritmo Meta che comprime il contenuto di un'applicazione in un unico file. Il blog parla della possibilit√† di creare un'applicazione che decomprime questo tipo di app... e un modo pi√π veloce che coinvolge **eseguire l'applicazione e raccogliere i file decompressi dal filesystem**.

### Analisi statica automatizzata del codice

Lo strumento [**mariana-trench**](https://github.com/facebook/mariana-trench) √® in grado di individuare **vulnerabilit√†** esaminando il **codice** dell'applicazione. Questo strumento contiene una serie di **fonti conosciute** (che indicano allo strumento i **luoghi** in cui l'**input** √® **controllato dall'utente**), **sorgenti** (che indicano allo strumento i **luoghi pericolosi** in cui l'input malintenzionato dell'utente potrebbe causare danni) e **regole**. Queste regole indicano la **combinazione** di **fonti-sorgenti** che indica una vulnerabilit√†.

Con questa conoscenza, **mariana-trench esaminer√† il codice e individuer√† possibili vulnerabilit√† al suo interno**.

### Segreti rivelati

Un'applicazione potrebbe contenere segreti (chiavi API, password, URL nascosti, sottodomini...) al suo interno che potresti essere in grado di scoprire. Potresti utilizzare uno strumento come [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)

### Bypass dell'autenticazione biometrica

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### Altre funzioni interessanti

* **Esecuzione del codice**: `Runtime.exec(), ProcessBuilder(), codice nativo:system()`
* **Invio di SMS**: `sendTextMessage, sendMultipartTestMessage`
* **Funzioni native** dichiarate come `native`: `public native, System.loadLibrary, System.load`
* [Leggi questo per imparare **come invertire le funzioni native**](reversing-native-libraries.md)

### **Altri trucchi**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug!

**Approfondimenti sull'hacking**\
Coinvolgiti con contenuti che esplorano l'emozione e le sfide dell'hacking

**Notizie sull'hacking in tempo reale**\
Resta aggiornato con il mondo dell'hacking in rapida evoluzione attraverso notizie e approfondimenti in tempo reale

**Ultime notizie**\
Rimani informato sui nuovi bug bounty in arrivo e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi!

***

## Analisi dinamica

> Prima di tutto, √® necessario un ambiente in cui √® possibile installare l'applicazione e tutto l'ambiente (certificato Burp CA, Drozer e Frida principalmente). Pertanto, √® estremamente consigliato un dispositivo sradicato (emulato o meno).

### Analisi dinamica online

Puoi creare un **account gratuito** su: [https://appetize.io/](https://appetize.io). Questa piattaforma ti consente di **caricare** ed **eseguire** APK, quindi √® utile per vedere come si comporta un APK.

Puoi persino **visualizzare i log della tua applicazione** sul web e connetterti tramite **adb**.

![](<../../.gitbook/assets/image (60).png>)

Grazie alla connessione ADB puoi utilizzare **Drozer** e **Frida** all'interno degli emulatori.

### Analisi dinamica locale

#### Utilizzando un emulatore

* [**Android Studio**](https://developer.android.com/studio) (Puoi creare dispositivi **x86** e **arm**, e secondo [**questo** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)le **ultime versioni x86** supportano le librerie ARM senza necessit√† di un lento emulatore ARM).
* Impara a configurarlo in questa pagina:

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **(Versione gratuita:** Personal Edition, √® necessario creare un account. _Si consiglia di **scaricare** la versione **CON**_ _**VirtualBox** per evitare potenziali errori._)
* [**Nox**](https://es.bignox.com) (Gratuito, ma non supporta Frida o Drozer).

{% hint style="info" %}
Quando crei un nuovo emulatore su qualsiasi piattaforma, ricorda che maggiore √® la dimensione dello schermo, pi√π lento sar√† l'emulatore. Quindi seleziona schermi piccoli se possibile.
{% endhint %}

Per **installare i servizi Google** (come AppStore) in Genymotion √® necessario fare clic sul pulsante contrassegnato di rosso nell'immagine seguente:

![](<../../.gitbook/assets/image (200) (1).png>)

Inoltre, nota che nella **configurazione della VM Android in Genymotion** puoi selezionare la modalit√† **Bridge Network** (questo sar√† utile se ti connetterai alla VM Android da un'altra VM con gli strumenti).
#### Utilizzare un dispositivo fisico

√à necessario attivare le **opzioni di debug** e sarebbe ottimo se potessi **effettuare il root**:

1. **Impostazioni**.
2. (Da Android 8.0) Seleziona **Sistema**.
3. Seleziona **Informazioni sul telefono**.
4. Premi **Numero build** 7 volte.
5. Torna indietro e troverai le **Opzioni sviluppatore**.

> Una volta installata l'applicazione, la prima cosa da fare √® provarla e investigare cosa fa, come funziona e prendere confidenza con essa.\
> Suggerisco di **effettuare questa analisi dinamica iniziale utilizzando l'analisi dinamica di MobSF + pidcat**, in modo da poter **capire come funziona l'applicazione** mentre MobSF **cattura** molti **dati interessanti** che potrai esaminare in seguito.

### Divulgazione non intenzionale di dati

**Registrazione**

I developer dovrebbero fare attenzione a esporre informazioni di **debugging** pubblicamente, poich√© potrebbe portare a fughe di dati sensibili. Gli strumenti [**pidcat**](https://github.com/JakeWharton/pidcat) e `adb logcat` sono consigliati per monitorare i log dell'applicazione al fine di identificare e proteggere informazioni sensibili. **Pidcat** √® preferito per la sua facilit√† d'uso e leggibilit√†.

{% hint style="warning" %}
Nota che da **versioni successive ad Android 4.0**, le **applicazioni possono accedere solo ai propri log**. Quindi le applicazioni non possono accedere ai log di altre app.\
In ogni caso, √® comunque consigliabile **non registrare informazioni sensibili**.
{% endhint %}

**Cache del buffer di copia/incolla**

Il framework basato su **clipboard** di Android consente la funzionalit√† di copia/incolla nelle app, ma pone un rischio poich√© **altre applicazioni** possono **accedere** agli appunti, esponendo potenzialmente dati sensibili. √à cruciale **disabilitare le funzioni di copia/incolla** per sezioni sensibili di un'applicazione, come i dettagli della carta di credito, per prevenire fughe di dati.

**Log dei crash**

Se un'applicazione **va in crash** e **salva i log**, questi log possono aiutare gli attaccanti, specialmente quando l'applicazione non pu√≤ essere decompilata. Per mitigare questo rischio, evitare di registrare i crash e, se i log devono essere trasmessi tramite rete, assicurarsi che vengano inviati tramite un canale SSL per la sicurezza.

Come pentester, **prova a dare un'occhiata a questi log**.

**Dati di analisi inviati a terze parti**

Le applicazioni spesso integrano servizi come Google Adsense, che possono involontariamente **rivelare dati sensibili** a causa di un'implementazione impropria da parte dei developer. Per identificare possibili fughe di dati, √® consigliabile **intercettare il traffico dell'applicazione** e controllare se vengono inviate informazioni sensibili a servizi di terze parti.

### Database SQLite

La maggior parte delle applicazioni utilizzer√† **database SQLite interni** per salvare informazioni. Durante il pentest, dai un'**occhiata** ai **database** creati, ai nomi delle **tabelle** e delle **colonne** e a tutti i **dati** salvati poich√© potresti trovare **informazioni sensibili** (che potrebbero essere una vulnerabilit√†).\
I database dovrebbero trovarsi in `/data/data/nome.pacchetto/databases` come `/data/data/com.mwr.example.sieve/databases`

Se il database sta salvando informazioni confidenziali ed √® **criptato** ma puoi **trovare** la **password** all'interno dell'applicazione, √® comunque una **vulnerabilit√†**.

Enumera le tabelle utilizzando `.tables` e enumera le colonne delle tabelle con `.schema <nome_tabella>`

### Drozer (Attivit√† di exploit, Provider di contenuti e Servizi)

Da [Documenti di Drozer](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf): **Drozer** ti consente di **assumere il ruolo di un'app Android** e interagire con altre app. Pu√≤ fare **qualsiasi cosa che un'applicazione installata pu√≤ fare**, come ad esempio utilizzare il meccanismo di Comunicazione tra Processi di Android (IPC) e interagire con il sistema operativo sottostante.\
Drozer √® uno strumento utile per **sfruttare attivit√† esportate, servizi esportati e Provider di contenuti** come imparerai nelle sezioni seguenti.

### Sfruttare attivit√† esportate

[**Leggi questo se vuoi rinfrescare cosa sia un'Attivit√† Android.**](android-applications-basics.md#launcher-activity-and-other-activities)\
Ricorda anche che il codice di un'attivit√† inizia nel metodo **`onCreate`**.

**Bypass di autorizzazione**

Quando un'Attivit√† √® esportata, puoi invocare la sua schermata da un'app esterna. Pertanto, se un'attivit√† con **informazioni sensibili** √® **esportata**, potresti **bypassare** i **meccanismi di autenticazione** per accedervi.

[**Scopri come sfruttare le attivit√† esportate con Drozer.**](drozer-tutorial/#activities)

Puoi anche avviare un'attivit√† esportata da adb:

* Il nome del pacchetto √® com.example.demo
* Il nome dell'attivit√† esportata √® com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**NOTA**: MobSF rilever√† come dannoso l'uso di _**singleTask/singleInstance**_ come `android:launchMode` in un'attivit√†, ma a causa di [questo](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750), apparentemente questo √® pericoloso solo su vecchie versioni (versioni API < 21).

{% hint style="info" %}
Nota che un bypass di autorizzazione non √® sempre una vulnerabilit√†, dipender√† da come funziona il bypass e quali informazioni vengono esposte.
{% endhint %}

**Fuga di informazioni sensibili**

**Le attivit√† possono anche restituire risultati**. Se riesci a trovare un'attivit√† esportata e non protetta che chiama il metodo **`setResult`** e **restituisce informazioni sensibili**, si tratta di una fuga di informazioni sensibili.

#### Tapjacking

Se il tapjacking non √® impedito, potresti abusare dell'attivit√† esportata per fare s√¨ che l'**utente compia azioni inaspettate**. Per ulteriori informazioni su [**cosa √® il Tapjacking segui il link**](./#tapjacking).

### Sfruttare i Content Providers - Accesso e manipolazione di informazioni sensibili

[**Leggi questo se vuoi rinfrescare cosa sia un Content Provider.**](android-applications-basics.md#content-provider)\
I content provider sono fondamentalmente utilizzati per **condividere dati**. Se un'app dispone di content provider disponibili, potresti essere in grado di **estrarre dati sensibili** da essi. √à anche interessante testare possibili **iniezioni SQL** e **traversali di percorsi** poich√© potrebbero essere vulnerabili.

[**Scopri come sfruttare i Content Providers con Drozer.**](drozer-tutorial/#content-providers)

### **Sfruttare i Servizi**

[**Leggi questo se vuoi rinfrescare cosa sia un Servizio.**](android-applications-basics.md#services)\
Ricorda che le azioni di un Servizio iniziano nel metodo `onStartCommand`.

Un servizio √® fondamentalmente qualcosa che **pu√≤ ricevere dati**, **elaborarli** e **restituire** (o meno) una risposta. Quindi, se un'applicazione esporta alcuni servizi, dovresti **controllare** il **codice** per capire cosa sta facendo e **testarlo** **dinamicamente** per estrarre informazioni confidenziali, aggirare misure di autenticazione...\
[**Scopri come sfruttare i Servizi con Drozer.**](drozer-tutorial/#services)

### **Sfruttare i Ricevitori di Broadcast**

[**Leggi questo se vuoi rinfrescare cosa sia un Ricevitore di Broadcast.**](android-applications-basics.md#broadcast-receivers)\
Ricorda che le azioni di un Ricevitore di Broadcast iniziano nel metodo `onReceive`.

Un ricevitore di broadcast sar√† in attesa di un tipo di messaggio. A seconda di come il ricevitore gestisce il messaggio, potrebbe essere vulnerabile.\
[**Scopri come sfruttare i Ricevitori di Broadcast con Drozer.**](./#exploiting-broadcast-receivers)

### **Sfruttare gli Schemi / Deep links**

Puoi cercare manualmente deep links, utilizzando strumenti come MobSF o script come [questo](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py).\
Puoi **aprire** uno **schema** dichiarato usando **adb** o un **browser**:

{% code overflow="wrap" %}
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_Nota che puoi **omettere il nome del pacchetto** e il cellulare chiamer√† automaticamente l'app che dovrebbe aprire quel link._

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**Codice eseguito**

Per trovare il **codice che verr√† eseguito nell'App**, vai all'attivit√† chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**Informazioni sensibili**

Ogni volta che trovi un deep link, controlla che **non stia ricevendo dati sensibili (come password) tramite parametri URL**, poich√© qualsiasi altra applicazione potrebbe **fingersi il deep link e rubare quei dati!**

**Parametri nel percorso**

Devi controllare anche se un deep link sta utilizzando un parametro all'interno del percorso dell'URL come: `https://api.example.com/v1/users/{username}`, in tal caso puoi forzare un attraversamento del percorso accedendo a qualcosa del genere: `example://app/users?username=../../unwanted-endpoint%3fparam=value`.\
Nota che se trovi gli endpoint corretti all'interno dell'applicazione potresti essere in grado di causare un **Reindirizzamento Aperto** (se parte del percorso viene utilizzata come nome di dominio), **acquisizione dell'account** (se puoi modificare i dettagli degli utenti senza token CSRF e l'endpoint vulnerabile ha utilizzato il metodo corretto) e qualsiasi altra vulnerabilit√†. Maggiori [informazioni qui](http://dphoeniixx.com/2020/12/13-2/).

**Altri esempi**

Un [interessante rapporto di bug bounty](https://hackerone.com/reports/855618) sui link (_/.well-known/assetlinks.json_).

### Ispezioni e Fallimenti di Verifica del Livello di Trasporto

* Le **certificazioni non vengono sempre ispezionate correttamente** dalle applicazioni Android. √à comune che queste applicazioni trascurino gli avvisi e accettino certificati auto-firmati o, in alcuni casi, tornino a utilizzare connessioni HTTP.
* Le **negoziazioni durante l'handshake SSL/TLS sono a volte deboli**, impiegando suite di cifratura non sicure. Questa vulnerabilit√† rende la connessione suscettibile a attacchi di tipo man-in-the-middle (MITM), consentendo agli attaccanti di decifrare i dati.
* **La perdita di informazioni private** √® un rischio quando le applicazioni si autenticano utilizzando canali sicuri ma comunicano poi tramite canali non sicuri per altre transazioni. Questo approccio non protegge i dati sensibili, come i cookie di sessione o i dettagli dell'utente, dall'intercettazione da parte di entit√† malintenzionate.

#### Verifica del Certificato

Ci concentreremo sulla **verifica del certificato**. √à fondamentale verificare l'integrit√† del certificato del server per migliorare la sicurezza. Questo √® cruciale perch√© configurazioni TLS non sicure e la trasmissione di dati sensibili su canali non crittografati possono comportare rischi significativi. Per dettagliati passaggi sulla verifica dei certificati del server e sulla gestione delle vulnerabilit√†, [**questa risorsa**](https://manifestsecurity.com/android-application-security-part-10/) fornisce una guida completa.

#### SSL Pinning

Lo SSL Pinning √® una misura di sicurezza in cui l'applicazione verifica il certificato del server rispetto a una copia conosciuta memorizzata all'interno dell'applicazione stessa. Questo metodo √® essenziale per prevenire attacchi MITM. Implementare lo SSL Pinning √® fortemente consigliato per le applicazioni che gestiscono informazioni sensibili.

#### Ispezione del Traffico

Per ispezionare il traffico HTTP, √® necessario **installare il certificato dello strumento proxy** (ad esempio, Burp). Senza installare questo certificato, il traffico crittografato potrebbe non essere visibile attraverso il proxy. Per una guida sull'installazione di un certificato CA personalizzato, [**clicca qui**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

Le applicazioni che mirano al **Livello API 24 e superiore** richiedono modifiche alla Configurazione della Sicurezza di Rete per accettare il certificato CA del proxy. Questo passaggio √® fondamentale per ispezionare il traffico crittografato. Per istruzioni sulla modifica della Configurazione della Sicurezza di Rete, [**consulta questo tutorial**](make-apk-accept-ca-certificate.md).

#### Bypass dello SSL Pinning

Quando lo SSL Pinning √® implementato, diventa necessario bypassarlo per ispezionare il traffico HTTPS. Sono disponibili vari metodi a questo scopo:

* Modificare automaticamente l'**apk** per **bypassare** lo SSLPinning con [**apk-mitm**](https://github.com/shroudedcode/apk-mitm). Il principale vantaggio di questa opzione √® che non sar√† necessario il root per bypassare lo SSL Pinning, ma sar√† necessario eliminare l'applicazione e reinstallare la nuova, e ci√≤ non funzioner√† sempre.
* √à possibile utilizzare **Frida** (discusso di seguito) per bypassare questa protezione. Qui trovi una guida su come utilizzare Burp+Frida+Genymotion: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
* Puoi anche provare a **bypassare automaticamente lo SSL Pinning** utilizzando [**objection**](frida-tutorial/objection-tutorial.md)**:** `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* Puoi anche provare a **bypassare automaticamente lo SSL Pinning** utilizzando **l'analisi dinamica di MobSF** (spiegata di seguito)
* Se ritieni che ci sia del traffico che non stai catturando, puoi provare a **inoltrare il traffico a burp utilizzando iptables**. Leggi questo blog: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### Ricerca di Vulnerabilit√† Web Comuni

√à importante cercare anche vulnerabilit√† web comuni all'interno dell'applicazione. Le informazioni dettagliate sull'individuazione e sulla mitigazione di queste vulnerabilit√† vanno oltre il campo di questo riassunto ma sono ampiamente trattate altrove.

### Frida

[Frida](https://www.frida.re) √® un toolkit di strumenti di strumentazione dinamica per sviluppatori, reverse-engineers e ricercatori di sicurezza.\
**Puoi accedere all'applicazione in esecuzione e agganciare i metodi in tempo reale per cambiare il comportamento, i valori, estrarre valori, eseguire codice diverso...**\
Se vuoi fare pentesting delle applicazioni Android devi sapere come usare Frida.

* Impara come usare Frida: [**Tutorial su Frida**](frida-tutorial/)
* Alcuni "GUI" per azioni con Frida: [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
* Ojection √® ottimo per automatizzare l'uso di Frida: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
* Puoi trovare alcuni script impressionanti di Frida qui: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
* Prova a bypassare i meccanismi anti-debugging / anti-frida caricando Frida come indicato in [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace) (strumento [linjector](https://github.com/erfur/linjector-rs))

### **Dump della Memoria - Fridump**

Controlla se l'applicazione sta memorizzando informazioni sensibili all'interno della memoria che non dovrebbe memorizzare come password o mnemonici.

Utilizzando [**Fridump3**](https://github.com/rootbsd/fridump3) puoi eseguire il dump della memoria dell'applicazione con:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
Questo dumpa la memoria nella cartella ./dump e da l√¨ puoi fare una ricerca con qualcosa del genere:

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Dati sensibili nel Keystore**

In Android, il Keystore √® il miglior posto dove memorizzare dati sensibili, tuttavia, con abbastanza privilegi √® ancora **possibile accedervi**. Poich√© le applicazioni tendono a memorizzare qui **dati sensibili in chiaro**, i test di penetrazione dovrebbero controllare questo aspetto poich√© un utente root o qualcuno con accesso fisico al dispositivo potrebbe essere in grado di rubare tali dati.

Anche se un'app memorizzasse dati nel keystore, tali dati dovrebbero essere crittografati.

Per accedere ai dati all'interno del keystore, √® possibile utilizzare questo script Frida: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Bypass dell'impronta digitale/biometrici**

Utilizzando lo script Frida seguente potrebbe essere possibile **bypassare l'autenticazione dell'impronta digitale** che le applicazioni Android potrebbero eseguire per **proteggere determinate aree sensibili:**
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **Immagini di Sfondo**

Quando si mette un'applicazione in background, Android memorizza uno **snapshot dell'applicazione** in modo che quando viene ripristinata in primo piano inizi a caricare l'immagine prima dell'applicazione per far sembrare che l'app sia stata caricata pi√π velocemente.

Tuttavia, se questo snapshot contiene **informazioni sensibili**, chiunque abbia accesso allo snapshot potrebbe **rubare tali informazioni** (nota che √® necessario il root per accedervi).

Gli snapshot di solito sono memorizzati in: **`/data/system_ce/0/snapshots`**

Android fornisce un modo per **prevenire la cattura dello screenshot impostando il FLAG\_SECURE** come parametro di layout. Utilizzando questa flag, i contenuti della finestra vengono trattati come sicuri, impedendo che compaiano negli screenshot o che siano visualizzati su display non sicuri.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Analizzatore di Applicazioni Android**

Questo strumento potrebbe aiutarti a gestire diversi strumenti durante l'analisi dinamica: [https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### Iniezione di Intent

Gli sviluppatori spesso creano componenti proxy come attivit√†, servizi e ricevitori di trasmissione che gestiscono questi Intent e li passano a metodi come `startActivity(...)` o `sendBroadcast(...)`, il che pu√≤ essere rischioso.

Il pericolo risiede nel permettere agli attaccanti di attivare componenti dell'app non esportate o accedere a fornitori di contenuti sensibili deviando questi Intent. Un esempio notevole √® il componente `WebView` che converte gli URL in oggetti `Intent` tramite `Intent.parseUri(...)` e poi li esegue, potenzialmente portando a iniezioni di Intent maligne.

### Concetti Fondamentali

* **Iniezione di Intent** √® simile al problema di reindirizzamento aperto del web.
* Gli exploit coinvolgono il passaggio di oggetti `Intent` come extra, che possono essere reindirizzati per eseguire operazioni non sicure.
* Pu√≤ esporre componenti non esportate e fornitori di contenuti agli attaccanti.
* La conversione di URL in `Intent` di `WebView` pu√≤ facilitare azioni non intenzionali.

### Iniezioni Lato Client Android e altri

Probabilmente conosci questo tipo di vulnerabilit√† dal Web. Devi prestare particolare attenzione a queste vulnerabilit√† in un'applicazione Android:

* **SQL Injection:** Quando si gestiscono query dinamiche o Content-Providers, assicurati di utilizzare query parametriche.
* **Iniezione di JavaScript (XSS):** Verifica che il supporto JavaScript e dei Plugin sia disabilitato per qualsiasi WebView (disabilitato per impostazione predefinita). [Maggiori informazioni qui](webview-attacks.md#javascript-enabled).
* **Inclusione di File Locale:** Le WebViews dovrebbero avere l'accesso al file system disabilitato (abilitato per impostazione predefinita) - `(webview.getSettings().setAllowFileAccess(false);)`. [Maggiori informazioni qui](webview-attacks.md#javascript-enabled).
* **Cookie eterni**: In diversi casi, quando l'applicazione Android termina la sessione, il cookie non viene revocato o potrebbe persino essere salvato su disco.
* [**Flag Sicuro** nei cookie](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug!

**Approfondimenti sull'Hacking**\
Interagisci con contenuti che esplorano l'emozione e le sfide dell'hacking

**Notizie sull'Hacking in Tempo Reale**\
Resta aggiornato sul mondo dell'hacking frenetico attraverso notizie e approfondimenti in tempo reale

**Ultime Comunicazioni**\
Resta informato sui nuovi bug bounty in arrivo e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi!

## Analisi Automatica

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**Analisi statica**

![](<../../.gitbook/assets/image (61).png>)

**Valutazione delle vulnerabilit√† dell'applicazione** utilizzando un'interfaccia web front-end. √à anche possibile eseguire analisi dinamiche (ma √® necessario preparare l'ambiente).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
Si noti che MobSF pu√≤ analizzare le applicazioni **Android**(apk), **IOS**(ipa) e **Windows**(apx) (_le applicazioni Windows devono essere analizzate da un MobSF installato in un host Windows).\
Inoltre, se si crea un file **ZIP** con il codice sorgente di un'applicazione **Android** o **IOS** (andare alla cartella radice dell'applicazione, selezionare tutto e creare un file ZIP), sar√† in grado di analizzarlo anche.

MobSF consente anche di **diff/Confrontare** l'analisi e di integrare **VirusTotal** (√® necessario impostare la propria chiave API in _MobSF/settings.py_ e abilitarla: `VT_ENABLED = TRUE` `VT_API_KEY = <La tua chiave API>` `VT_UPLOAD = TRUE`). √à anche possibile impostare `VT_UPLOAD` su `False`, quindi l'**hash** verr√† **caricato** invece del file.

### Analisi dinamica assistita con MobSF

**MobSF** pu√≤ essere molto utile anche per l'**analisi dinamica** in **Android**, ma in questo caso sar√† necessario installare MobSF e **genymotion** nel proprio host (una VM o Docker non funzioneranno). _Nota: √à necessario **avviare prima una VM in genymotion** e **poi MobSF.**_\
Il **analizzatore dinamico di MobSF** pu√≤:

* **Estrarre dati dell'applicazione** (URL, log, appunti, screenshot realizzati da te, screenshot realizzati da "**Exported Activity Tester**", email, database SQLite, file XML e altri file creati). Tutto ci√≤ viene fatto automaticamente tranne i screenshot, √® necessario premere quando si desidera uno screenshot o premere "**Exported Activity Tester**" per ottenere gli screenshot di tutte le attivit√† esportate.
* Catturare il **traffico HTTPS**
* Utilizzare **Frida** per ottenere **informazioni in tempo reale**

Dalle versioni di Android > 5, avvier√† **automaticamente Frida** e imposter√† le impostazioni globali del **proxy** per **catturare** il traffico. Catturer√† solo il traffico dall'applicazione testata.

**Frida**

Per impostazione predefinita, utilizzer√† anche alcuni script di Frida per **bypassare il pinning SSL**, **rilevare il root** e **rilevare il debugger** e per **monitorare API interessanti**.\
MobSF pu√≤ anche **invocare attivit√† esportate**, acquisire **screenshot** di esse e **salvarli** per il report.

Per **avviare** il test dinamico premere il pulsante verde: "**Start Instrumentation**". Premere "**Frida Live Logs**" per visualizzare i log generati dagli script di Frida e "**Live API Monitor**" per visualizzare tutte le invocazioni ai metodi hookati, gli argomenti passati e i valori restituiti (questo apparir√† dopo aver premuto "Start Instrumentation").\
MobSF consente anche di caricare i propri **script di Frida** (per inviare i risultati dei tuoi script di Frida a MobSF utilizzare la funzione `send()`). Ha anche **diversi script pre-scritti** che √® possibile caricare (√® possibile aggiungerne altri in `MobSF/DynamicAnalyzer/tools/frida_scripts/others/`), basta **selezionarli**, premere "**Load**" e premere "**Start Instrumentation**" (sar√† possibile vedere i log di quegli script all'interno di "**Frida Live Logs**").

![](<../../.gitbook/assets/image (215).png>)

Inoltre, sono disponibili alcune funzionalit√† ausiliarie di Frida:

* **Enumerate Loaded Classes**: Stampa tutte le classi caricate
* **Capture Strings**: Stampa tutte le stringhe catturate durante l'uso dell'applicazione (molto rumoroso)
* **Capture String Comparisons**: Potrebbe essere molto utile. Mostrer√† le **2 stringhe confrontate** e se il risultato √® stato Vero o Falso.
* **Enumerate Class Methods**: Inserire il nome della classe (come "java.io.File") e verranno stampati tutti i metodi della classe.
* **Search Class Pattern**: Cerca classi per modello
* **Trace Class Methods**: **Traccia** un'**intera classe** (vedi input e output di tutti i metodi della classe). Ricorda che per impostazione predefinita MobSF traccia diversi metodi interessanti delle API di Android.

Una volta selezionato il modulo ausiliario che si desidera utilizzare, √® necessario premere "**Start Intrumentation**" e si vedranno tutti gli output in "**Frida Live Logs**".

**Shell**

Mobsf ti offre anche una shell con alcuni comandi **adb**, comandi **MobSF** e comandi **shell** comuni nella parte inferiore della pagina di analisi dinamica. Alcuni comandi interessanti:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**Strumenti HTTP**

Quando il traffico http viene catturato, √® possibile visualizzare una vista poco attraente del traffico catturato nella sezione "**HTTP(S) Traffic**" in basso o una vista pi√π piacevole nel pulsante verde "**Start HTTPTools**". Dalla seconda opzione, √® possibile **inviare** le **richieste catturate** a **proxy** come Burp o Owasp ZAP.\
Per farlo, _accendere Burp -->_ _disattivare l'Intercept --> nella sezione MobSB HTTPTools selezionare la richiesta_ --> premere "**Invia a Fuzzer**" --> _selezionare l'indirizzo del proxy_ ([http://127.0.0.1:8080\\](http://127.0.1:8080)).

Una volta completata l'analisi dinamica con MobSF, √® possibile premere su "**Avvia Web API Fuzzer**" per **fuzzare le richieste http** e cercare vulnerabilit√†.

{% hint style="info" %}
Dopo aver eseguito un'analisi dinamica con MobSF, le impostazioni del proxy potrebbero essere configurate in modo errato e potresti non essere in grado di correggerle dall'interfaccia grafica. √à possibile correggere le impostazioni del proxy facendo:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Analisi dinamica assistita con Inspeckage

Puoi ottenere lo strumento da [**Inspeckage**](https://github.com/ac-pm/Inspeckage).\
Questo strumento utilizzer√† alcuni **Hooks** per farti sapere **cosa sta succedendo nell'applicazione** mentre esegui un'**analisi dinamica**.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

Questo √® un **ottimo strumento per eseguire analisi statica con un'interfaccia grafica**

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

Questo strumento √® progettato per cercare diverse **vulnerabilit√† di sicurezza delle applicazioni Android**, sia nel **codice sorgente** che negli **APK confezionati**. Lo strumento √® inoltre **in grado di creare un APK deployable "Proof-of-Concept"** e **comandi ADB**, per sfruttare alcune delle vulnerabilit√† trovate (attivit√† esposte, intenti, tapjacking...). Come Drozer, non √® necessario eseguire il root del dispositivo di test.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* Mostra tutti i file estratti per un facile riferimento
* Decompila automaticamente i file APK nel formato Java e Smali
* Analizza AndroidManifest.xml per vulnerabilit√† e comportamenti comuni
* Analisi statica del codice sorgente per vulnerabilit√† e comportamenti comuni
* Informazioni sul dispositivo
* e altro
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER √® un'applicazione da riga di comando che pu√≤ essere utilizzata su Windows, MacOS X e Linux, che analizza i file _.apk_ alla ricerca di vulnerabilit√†. Fa ci√≤ decomprimendo gli APK e applicando una serie di regole per rilevare tali vulnerabilit√†.

Tutte le regole sono contenute in un file `rules.json`, e ogni azienda o tester potrebbe creare le proprie regole per analizzare ci√≤ di cui hanno bisogno.

Scarica le ultime versioni binarie dalla [pagina di download](https://superanalyzer.rocks/download.html)
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAn √® uno strumento **multi-piattaforma** che aiuta sviluppatori, cacciatori di bug e hacker etici a eseguire l'[analisi statica del codice](https://en.wikipedia.org/wiki/Static\_program\_analysis) su applicazioni mobili.

Il concetto √® che trascini e rilasci il file dell'applicazione mobile (un file .apk o .ipa) sull'applicazione StaCoAn e generer√† un rapporto visuale e portatile per te. Puoi personalizzare le impostazioni e gli elenchi di parole per ottenere un'esperienza personalizzata.

Scarica l'[ultima versione rilasciata](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Framework √® un sistema di analisi delle vulnerabilit√† di Android che aiuta gli sviluppatori o hacker a trovare potenziali vulnerabilit√† di sicurezza nelle applicazioni Android.\
[Rilasci per Windows](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** √® uno strumento il cui obiettivo principale √® rilevare e avvisare l'utente riguardo potenziali comportamenti dannosi sviluppati da un'applicazione Android.

La rilevazione avviene tramite l'**analisi statica** del bytecode Dalvik dell'applicazione, rappresentato come **Smali**, con la libreria [`androguard`](https://github.com/androguard/androguard).

Questo strumento cerca **comportamenti comuni delle applicazioni "cattive"** come: esfiltrazione di identificatori telefonici, intercettazione di flussi audio/video, modifica dei dati PIM, esecuzione di codice arbitrario...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [Framework MARA](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA** √® un **F**ramework di **R**everse **E**ngineering e **A**nalisi di **A**pplicazioni **M**obili. √à uno strumento che riunisce strumenti comunemente utilizzati per il reverse engineering e l'analisi di applicazioni mobili, per assistere nel test delle applicazioni mobili contro le minacce alla sicurezza mobile di OWASP. Il suo obiettivo √® rendere pi√π facile e amichevole questo compito agli sviluppatori di applicazioni mobili e ai professionisti della sicurezza.

√à in grado di:

* Estrarre codice Java e Smali utilizzando diversi strumenti
* Analizzare APK utilizzando: [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
* Estrarre informazioni private dall'APK utilizzando espressioni regolari.
* Analizzare il Manifest.
* Analizzare i domini trovati utilizzando: [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) e [whatweb](https://github.com/urbanadventurer/WhatWeb)
* Deobfuscare APK tramite [apk-deguard.com](http://www.apk-deguard.com)

### Koodous

Utile per rilevare malware: [https://koodous.com/](https://koodous.com)

## Codice di Obfuscamento/Deobfuscamento

Nota che a seconda del servizio e della configurazione che si utilizza per obfuscare il codice, i segreti possono o meno essere obfuscati.

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

Da [Wikipedia](https://en.wikipedia.org/wiki/ProGuard\_\(software\)): **ProGuard** √® uno strumento a riga di comando open source che riduce, ottimizza e obfusca il codice Java. √à in grado di ottimizzare il bytecode e individuare ed eliminare istruzioni non utilizzate. ProGuard √® un software gratuito e viene distribuito con licenza GNU General Public License, versione 2.

ProGuard √® distribuito come parte dell'SDK Android e viene eseguito durante la compilazione dell'applicazione in modalit√† di rilascio.

### [DexGuard](https://www.guardsquare.com/dexguard)

Trova una guida passo-passo per deobfuscare l'APK in [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)

(Da quella guida) L'ultima volta che abbiamo controllato, la modalit√† di funzionamento di Dexguard era:

* caricare una risorsa come un InputStream;
* alimentare il risultato a una classe che eredita da FilterInputStream per decodificarlo;
* fare un'obfuscazione inutile per sprecare alcuni minuti di tempo a un reverser;
* alimentare il risultato decodificato a un ZipInputStream per ottenere un file DEX;
* infine caricare il DEX risultante come una risorsa utilizzando il metodo `loadDex`.

### [DeGuard](http://apk-deguard.com)

**DeGuard inverte il processo di obfuscazione eseguito dagli strumenti di obfuscazione Android. Ci√≤ consente numerose analisi di sicurezza, inclusa l'ispezione del codice e la previsione delle librerie.**

√à possibile caricare un APK obfuscati sulla loro piattaforma.

### [Simplify](https://github.com/CalebFenton/simplify)

√à un **deobfuscator generico per Android.** Simplify **esegue virtualmente un'app** per comprendere il suo comportamento e quindi **cerca di ottimizzare il codice** in modo che si comporti in modo identico ma sia pi√π facile da capire per un essere umano. Ogni tipo di ottimizzazione √® semplice e generico, quindi non importa quale tipo specifico di obfuscazione venga utilizzato.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD fornisce informazioni su **come √® stato creato un APK**. Identifica molti **compilatori**, **packer**, **obfuscati** e altre cose strane. √à [_PEiD_](https://www.aldeid.com/wiki/PEiD) per Android.

### Manuale

[Leggi questo tutorial per imparare alcuni trucchi su **come invertire l'obfuscazione personalizzata**](manual-deobfuscation.md)

## Laboratori

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b √® una macchina virtuale di sicurezza Android basata su ubuntu-mate che include la raccolta degli ultimi framework, tutorial e laboratori di diversi esperti di sicurezza e ricercatori per il reverse engineering e l'analisi malware.

## Riferimenti

* [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) √à una grande lista di risorse
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Corso rapido su Android
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
* [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## Da provare

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Unisciti al [**server Discord di HackenProof**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug!

**Approfondimenti sull'Hacking**\
Interagisci con contenuti che approfondiscono l'emozione e le sfide dell'hacking

**Notizie sull'Hacking in Tempo Reale**\
Resta aggiornato sul mondo dell'hacking ad alta velocit√† attraverso notizie e approfondimenti in tempo reale

**Ultime Novit√†**\
Resta informato sui nuovi bug bounty in arrivo e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi!

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
