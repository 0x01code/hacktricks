# Androidアプリのペンテスト

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグバウンティの場所です。**

**遅延なしで報酬を受け取る**\
HackenProofのバウンティは、顧客が報酬予算を入金した後にのみ開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペンテストの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！その成長期におけるweb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)して、ハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## Androidアプリの基礎知識

Androidセキュリティに関連する**最も重要な部分やAndroidアプリの中で最も危険なコンポーネント**について知るために、このページを読むことを強くお勧めします：

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB（Android Debug Bridge）

これはAndroidデバイス（エミュレートまたは物理）に接続するために必要な主要なツールです。\
これにより、コンピュータからデバイスを**USB**または**ネットワーク**で制御し、ファイルを**コピー**したり、アプリを**インストール**またはアンインストールしたり、**シェル**コマンドを実行したり、**バックアップ**を作成したり、**ログ**を読んだりすることができます。

adbの使用方法については、次の[**ADBコマンドのリスト**](adb-commands.md)を参照してください。

## Smali

時には、**アプリケーションのコードを変更**して、**隠された情報**（おそらくよく難読化されたパスワードやフラグ）にアクセスすることが興味深い場合があります。その場合、APKを逆コンパイルしてコードを変更し、再コンパイルすることが興味深いかもしれません。\
[**このチュートリアル**では、APKを逆コンパイルし、Smaliコードを変更し、新しい機能を持つAPKを再コンパイルする方法を学ぶことができます](smali-changes.md)。これは、動的解析中に行われるいくつかのテストの代替手段として非常に役立つ場合があります。常にこの可能性を念頭に置いてください。

## その他の興味深いトリック

* [Playストアでの位置のスプーフィング](spoofing-your-location-in-play-store.md)
* **APKのダウンロード**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* デバイスからAPKを抽出する：
```
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグ報酬の場所です。**

**遅延なしで報酬を受け取る**\
HackenProofの報酬は、顧客が報酬予算を入金した後にのみ開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！成長するWeb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)してハッキングから収益を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## 静的解析

まず、APKを分析するためには、デコンパイラを使用してJavaコードを確認する必要があります。\
詳細については、[**ここを読んで利用可能なさまざまなデコンパイラについての情報を見つけてください**](apk-decompilers.md)。

### 興味深い情報を探す

APKの**文字列**を見るだけで、**パスワード**、**URL**（[https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)）、**API**キー、**暗号化**、**Bluetooth UUID**、**トークン**など、興味深い情報を検索できます...コード実行の**バックドア**や認証バックドア（アプリへのハードコードされた管理者資格情報）さえも探してください。

**Firebase**

特に**FirebaseのURL**に注意し、構成が正しくないかどうかを確認してください。[Firebaseとその悪用方法の詳細についてはこちらを参照してください。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本的な理解 - Manifest.xml、strings.xml

[**ここで**](apk-decompilers.md)言及されているいずれかのデコンパイラを使用すると、_Manifest.xml_を読むことができます。また、**apk**ファイルの拡張子を**.zip**に変更して**解凍**することもできます。\
マニフェストを読むことで、以下の**脆弱性**を見つけることができます。

* まず、アプリケーションが**デバッグ可能かどうか**を確認してください。本番のAPKはデバッグ可能ではないはずです（そうでなければ他の人が接続できます）。マニフェストで属性`debuggable="true"`を探すことで、アプリケーションがデバッグ可能かどうかを確認できます。例：`<application theme="@2131296387" debuggable="true"`
* [ここで](drozer-tutorial/#is-debuggeable)、電話でデバッグ可能なアプリケーションを見つけて悪用する方法を学びます。
* **バックアップ**：**`android:allowBackup`**属性は、USBデバッグを有効にしたユーザーがアプリケーションデータをバックアップおよび復元できるかどうかを定義します。バックアップフラグがtrueに設定されている場合、デバイスがルート化されていなくても、攻撃者はadbを介してアプリケーションデータのバックアップを取得できます。したがって、カードの詳細、パスワードなどの機密情報を処理および保存するアプリケーションは、この設定を明示的に**false**に設定する必要があります。デフォルトでは、これはリスクを防ぐために**true**に設定されています。
* `<application android:allowBackup="false"`
* **NetworkSecurity：**アプリケーションのネットワークセキュリティは、**`android:networkSecurityConfig="@xml/network_security_config"`**でデフォルト値を上書きできます。その名前のファイルを_**res/xml.**_に配置することができます。このファイルでは、証明書ピンやHTTPトラフィックを許可するかどうかなど、重要なセキュリティ設定を構成します。ここで構成できるすべてのことについての詳細情報はこちらを参照してくださいが、次の例はいくつかのドメインに対してHTTPトラフィックを設定する方法についてのものです：
* `<domain-config cleartextTrafficPermitted="true"> <domain includeSubdomains="true">formation-software.co.uk </domain></domain-config>`
* **エクスポートされたアクティビティ**：マニフェスト内のエクスポートされたアクティビティをチェックしてください。これは危険な場合があります。後で動的解析で[この動作を悪用する方法](./#exploiting-exported-activities-authorisation-bypass)について説明します。
* **コンテンツプロバイダー**：エクスポートされたプロバイダーが公開されている場合、興味深い情報にアクセス/変更できる場合があります。動的解析では、[これらを悪用する方法](./#exploiting-content-providers-accessing-and-manipulating-sensitive-information)について学びます。
* `android:name="android.support.FILE_PROVIDER_PATHS"`という属性内の**FileProviders**の構成を確認してください。[FileProvidersの詳細についてはこちらを参照してください](./#fileprovider)。
* **公開されたサービス**：サービスが内部で何を行っているかによって、脆弱性が悪用される場合があります。動的解析では、[これらを悪用する方法](./#exploiting-services)について学びます。
* **ブロードキャストレシーバー**：[悪用方法について学ぶことができます](./#exploiting-broadcast-receivers)（動的解析時）。
* **URLスキーム**：スキーマを管理するアクティビティのコードを読み、ユーザーの入力を処理する際の脆弱性を探してください。[URLスキームとは何かについての詳細情報はこちらを参照してください](./#url-schemes)。
* **minSdkVersion**、**targetSDKVersion**、**maxSdkVersion**：これらはアプリが実行されるAndroidのバージョンを示しています。セキュリティの観点から、古いバージョンをサポートすることは、既知の脆弱性のあるAndroidのバージョンを実行することを許可します。

**resources.arsc/strings.xml**を読むことで、いくつかの**興味深い情報**を見つけることができます：

* APIキー
* カスタムスキーマ
* 開発者がこのファイルに保存する他の興味深い情報

### タップジャッキング

**タップジャッキング**は、**悪意のあるアプリケーション**が起動し、**被害者アプリケーションの上に配置**される攻撃です。一度被害者アプリケーションを視覚的に隠すと、ユーザーインターフェースはユーザーをだましてそれと対話させ、その対話を被害者アプリケーションに渡します。\
実際には、ユーザーは自分が実際に被害者アプリケーション上で操作を行っていることを知ることができません。

この攻撃に対して脆弱なアプリを検出するためには、Androidマニフェストで**エクスポートされたアクティビティ**を検索する必要があります（インテントフィルタを持つアクティビティはデフォルトで自動的にエクスポートされます）。エクスポートされたアクティビティを見つけたら、**必要なパーミッションがあるかどうかを
```markup
<Button android:text="Button"
android:id="@+id/button1"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:filterTouchesWhenObscured="true">
</Button>
```
[**qark**](https://github.com/linkedin/qark)を`--exploit-apk`パラメータと共に使用すると、潜在的な**Tapjacking**の脆弱性をテストするための悪意のあるアプリケーションを作成することができます。\
このような機能を実装したサンプルプロジェクトは、[**FloatingWindowApp**](https://github.com/aminography/FloatingWindowApp)で見つけることができます。

対策は比較的簡単で、開発者は他のビューによって覆われた場合にタッチイベントを受け取らないように選択することができます。[Android Developer’s Reference](https://developer.android.com/reference/android/view/View#security)を使用します。

> 時には、ユーザーの完全な知識と同意のもとでアクションが実行されていることをアプリケーションが確認できることが重要です。例えば、許可リクエストの許可、購入の実行、広告のクリックなどです。残念ながら、悪意のあるアプリケーションは、意図したビューの目的を隠してユーザーにこれらのアクションを実行させようとするかもしれません。その対策として、フレームワークは、感度の高い機能へのアクセスを提供するビューのセキュリティを向上させるために使用できるタッチフィルタリングメカニズムを提供しています。
>
> タッチフィルタリングを有効にするには、[`setFilterTouchesWhenObscured(boolean)`](https://developer.android.com/reference/android/view/View#setFilterTouchesWhenObscured%28boolean%29)を呼び出すか、android:filterTouchesWhenObscuredレイアウト属性をtrueに設定します。有効にすると、フレームワークは、ビューのウィンドウが他の可視ウィンドウによって隠されている場合に受け取ったタッチを破棄します。その結果、ビューは、トースト、ダイアログ、または他のウィンドウがビューのウィンドウの上に表示される場合にタッチを受け取りません。

### タスクハイジャッキング

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### 安全でないデータの保存

**内部ストレージ**

**内部**ストレージに**作成**されたファイルは、**アプリ**のみが**アクセス可能**です。この保護はAndroidによって実装されており、ほとんどのアプリケーションには十分です。しかし、開発者はしばしば`MODE_WORLD_READBALE`および`MODE_WORLD_WRITABLE`を使用して、これらのファイルに別のアプリケーションへのアクセスを許可しますが、これにより他のアプリ（悪意のあるアプリ）がそれらにアクセスする制限はありません。\
**静的**解析では、これらの**モード**の使用をチェックし、**動的**解析では作成されたファイルの**許可**をチェックします（おそらくいくつかのファイルはグローバルに読み取り/書き込み可能です）。\
[この脆弱性についての詳細情報と修正方法はこちらを参照してください。](https://manifestsecurity.com/android-application-security-part-8/)

**外部ストレージ**

SDカードなどの**外部ストレージ**に作成されたファイルは、**グローバルに読み取りおよび書き込み可能**です。外部ストレージはユーザーによって取り外され、また任意のアプリケーションによって変更される可能性があるため、**外部ストレージを使用して機密情報を保存しないでください**。\
信頼できないソースからのデータと同様に、**外部ストレージからのデータを処理する際には入力検証を実行**する必要があります。アプリが外部ストレージから実行可能ファイルを取得する場合は、ファイルを署名し、動的ローディングの前に暗号的に検証する必要があります。\
情報は[こちら](https://manifestsecurity.com/android-application-security-part-8/)から取得しました。

外部ストレージは`/storage/emulated/0`、`/sdcard`、`/mnt/sdcard`で**アクセス**できます。

{% hint style="info" %}
Android 4.4（**API 17**）以降、SDカードにはアプリケーションごとに特定のディレクトリにアクセスを**制限するディレクトリ構造**があります。これにより、悪意のあるアプリケーションが他のアプリのファイルに読み取りまたは書き込みアクセスを取得することが防止されます。
{% endhint %}

**クリアテキストで保存された機密データ**

* **共有プリファレンス**：Androidは、各アプリケーションが簡単にxmlファイルを`/data/data/<packagename>/shared_prefs/`パスに保存できるようにし、そのフォルダにクリアテキストで機密情報が含まれている場合があります。
* **データベース**：Androidは、各アプリケーションが簡単にsqliteデータベースを`/data/data/<packagename>/databases/`パスに保存できるようにし、そのフォルダにクリアテキストで機密情報が含まれている場合があります。

### 破損したTLS

**すべての証明書を受け入れる**

何らかの理由で、ホスト名が一致しない場合でも、開発者はすべての証明書を受け入れることがあります。以下のようなコード行で証明書を受け入れることがあります。
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
### 破損した暗号化

**鍵管理プロセスの不備**

一部の開発者は、機密データをローカルストレージに保存し、コード内でハードコード化/予測可能な鍵で暗号化しています。これは行ってはいけません。逆向きエンジニアリングによって攻撃者が機密情報を抽出することができる可能性があるためです。

**安全でないおよび/または非推奨のアルゴリズムの使用**

開発者は、**非推奨のアルゴリズム**を使用して認証の**チェック**、**データの保存**または**送信**を行うべきではありません。これらのアルゴリズムのいくつかは、RC4、MD4、MD5、SHA1などです。たとえばパスワードを保存するためにハッシュが使用される場合、ソルトを使用したハッシュブルートフォース**耐性**を使用する必要があります。

### その他のチェック

* APKを**難読化**することをお勧めします。これにより、逆向きエンジニアリングを困難にすることができます。
* アプリが機密情報を扱う場合（銀行アプリなど）、モバイルがルート化されているかどうかを**独自にチェック**し、適切な対処を行うべきです。
* アプリが機密情報を扱う場合（銀行アプリなど）、エミュレータが使用されていないかをチェックするべきです。
* アプリが機密情報を扱う場合（銀行アプリなど）、実行する前に**自己の整合性をチェック**して、変更されていないかを確認するべきです。
* APKのビルドに使用されたコンパイラ/パッカー/難読化ツールをチェックするために、[**APKiD**](https://github.com/rednaga/APKiD)を使用してください。

### React Nativeアプリケーション

ReactアプリケーションのJavaScriptコードに簡単にアクセスする方法については、次のページを参照してください：

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Xamarinアプリケーション

**Xamarin**アプリは**C#**で書かれており、C#コードにアクセスするためには**apk**からファイルを取得する必要があります。
```bash
7z r app.apk #Or any other zip decompression cmd
```
次に、[**xamarin-decompress**](https://github.com/NickstaDB/xamarin-decompress)を使用して、すべてのDLsLを展開します。
```
python3 xamarin-decompress.py -o /path/to/decompressed/apk
```
### スーパーパックされたアプリケーション

[**このブログ記事**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)によると、スーパーパックはアプリケーションのコンテンツを1つのファイルに圧縮するメタアルゴリズムです。このブログでは、この種のアプリを解凍するアプリを作成する可能性について説明しています...そして、**アプリケーションを実行し、ファイルシステムから解凍されたファイルを収集する**より速い方法もあります。

### 自動静的コード解析

ツール[**mariana-trench**](https://github.com/facebook/mariana-trench)は、アプリケーションのコードをスキャンして**脆弱性**を見つけることができます。このツールには、**既知のソース**（ユーザーによって**制御される入力**の場所をツールに示す）**シンク**（悪意のあるユーザーの入力が損害を引き起こす可能性のある**危険な場所**をツールに示す）および**ルール**が含まれています。これらのルールは、脆弱性を示す**ソース-シンク**の組み合わせを示しています。

この知識を活用して、**mariana-trenchはコードをレビューし、可能な脆弱性を見つけます**。

### 漏洩した秘密

アプリケーションには、発見できるかもしれない秘密（APIキー、パスワード、隠されたURL、サブドメインなど）が含まれている場合があります。[https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)のようなツールを使用して、これらの秘密を発見することができます。

### バイオメトリック認証のバイパス

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### その他の興味深い機能

* **コードの実行**: `Runtime.exec(), ProcessBuilder(), native code:system()`
* **SMSの送信**: `sendTextMessage, sendMultipartTestMessage`
* `native`と宣言された**ネイティブ関数**: `public native, System.loadLibrary, System.load`
* [**ネイティブ関数をリバースエンジニアリングする方法**](reversing-native-libraries.md)については、これを読んでください。

### **その他のトリック**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグ報奨金の場所です。**

**遅延なしで報酬を受け取る**\
HackenProofの報奨金は、顧客が報奨金予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！成長するWeb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグで評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)してハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## 動的解析

> まず、アプリケーションとすべての環境（Burp CA証明書、Drozer、Fridaなど）をインストールできる環境が必要です。したがって、ルート化されたデバイス（エミュレートされたものでもないものでも）が非常におすすめです。

### オンライン動的解析

[https://appetize.io/](https://appetize.io)で**無料アカウント**を作成できます。このプラットフォームでは、APKを**アップロード**して**実行**することができるため、APKの動作を確認するのに便利です。

ウェブ上でアプリケーションのログを**表示**し、**adb**を介して接続することもできます。

![](<../../.gitbook/assets/image (60).png>)

ADB接続のおかげで、エミュレータ内で**Drozer**と**Frida**を使用することができます。

### ローカル動的解析

次のような**エミュレータ**を使用できます。

* [**Android Studio**](https://developer.android.com/studio)（**x86**と**arm**デバイスを作成でき、[**最新のx86**バージョンでは**ARMライブラリ**を使用できるため、遅いARMエミュレータは必要ありません](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)）。
* イメージを**インストール**してから**削除**しようとする場合は、Windowsの場合は`C:\Users\<User>\AppData\Local\Android\sdk\system-images\`、Macの場合は`/Users/myeongsic/Library/Android/sdk/system-image`を使用できます。
* これは、**主に使用するエミュレータであり、[このページで設定方法を学ぶことができます](avd-android-virtual-device.md)**。
* [**Genymotion**](https://www.genymotion.com/fun-zone/) **（無料版：Personal Edition、アカウントを作成する必要があります。_潜在的なエラーを回避するために**VirtualBox**を備えたバージョンをダウンロードすることをお勧めします。_）**
* [Nox](https://es.bignox.com)（無料ですが、FridaやDrozerはサポートしていません）。

{% hint style="info" %}
どのプラットフォームでも新しいエミュレータを作成する際には、画面が大きいほどエミュレータの動作が遅くなることに注意してください。可能な限り小さい画面を選択してください。
{% endhint %}

ほとんどの人が**Genymotion**を使用すると思われるので、このトリックに注意してください。AppStoreなどの**Googleサービスをインストール**するには、次の画像の赤でマークされたボタンをクリックする必要があります。

![](<../../.gitbook/assets/image (200) (1).png>)

また、Genymotionの**Android VMの設定**では、**Bridge Networkモード**を選択できます（これは、ツールを使用して別のVMからAndroid VMに接続する場合に便利です）。

または、**物理デバイス**を使用することもできます（デバッグオプションを有効にし、ルート化できると便利です）。

1. **設定**。
2. （Android 8.0以降）**システム**を選択します。
3. **端末について**を選択します。
4. **ビルド番号**を7回押します。
5. 戻ると、**開発者オプション**が表示されます。

> アプリケーションをインストールした後、最初に行うべきことは、アプリケーションを試して調査し、その動作や機能に慣れることです。\
> MobSFの動的解析+pidcatを使用して、**アプリケーションの動作を学びながら**、MobSFが後で確認できる**興味深いデータ**をキャプチャすることをおすすめします。
### 意図しないデータ漏洩

**ログ**

開発者はデバッグ情報を公開したままにすることがよくあります。そのため、`READ_LOGS`パーミッションを持つアプリケーションは、それらのログにアクセスし、それを通じて機密情報を入手することができます。\
アプリケーションを操作する際には、[**pidcat**](https://github.com/JakeWharton/pidcat)（推奨、使用しやすく読みやすい）または[adb logcat](adb-commands.md#logcat)を使用して作成されたログを読み取り、**機密情報を探します**。

{% hint style="warning" %}
Android 4.0以降のバージョンでは、**アプリケーションは自分自身のログにのみアクセスできる**ようになりました。そのため、アプリケーションは他のアプリのログにアクセスすることはできません。\
それでも、**機密情報をログに記録しない**ことをお勧めします。
{% endhint %}

**コピー/ペーストバッファのキャッシュ**

Androidは、Androidアプリケーションでコピー＆ペースト機能を提供するための**クリップボードベースの**フレームワークを提供しています。しかし、これにより、**他のアプリケーション**が一部の**機密データ**が含まれる**クリップボード**にアクセスできるという深刻な問題が発生します。**機密部分**のコピー/ペースト機能は**無効化**する必要があります。たとえば、クレジットカードの詳細をコピーすることを無効にします。

**クラッシュログ**

アプリケーションが実行中にクラッシュし、ログをどこかに保存する場合、それらのログは特にAndroidアプリケーションが逆アセンブルできない場合に、攻撃者にとって役立つ情報になる可能性があります。そのため、アプリケーションがクラッシュしたときにログを作成しないようにし、ログがネットワーク経由で送信される場合は、SSLチャネルを介して送信されることを確認してください。\
ペンテスターとして、これらのログを確認してみてください。

**第三者への解析データの送信**

ほとんどのアプリケーションは、Google AdSenseなどの他のサービスをアプリケーションで使用しますが、時には**機密データ**やそのサービスに送信する必要のないデータが**漏洩**することがあります。これは、開発者が機能を適切に実装していないために起こる可能性があります。アプリケーションのトラフィックを傍受し、第三者に機密データが送信されているかどうかを確認できます。

### SQLiteデータベース

ほとんどのアプリケーションは、情報を保存するために**内部のSQLiteデータベース**を使用します。ペンテスト中に作成された**データベース**、**テーブル**と**カラム**の名前、および保存されている**データ**を確認してください。そこには**機密情報**が含まれている可能性があります（これは脆弱性になります）。\
データベースは、`/data/data/the.package.name/databases`のように`/data/data/com.mwr.example.sieve/databases`に配置されるべきです。

データベースが機密情報を保存しており、**暗号化されている**が、アプリケーション内に**パスワード**が見つかる場合、それは依然として**脆弱性**です。

`.tables`を使用してテーブルを列挙し、`.schema <table_name>`を使用してテーブルの列を列挙します。

### Drozer（エクスポートされたアクティビティ、コンテンツプロバイダ、サービスの攻撃）

**Drozer**を使用すると、Androidアプリの役割を**仮定**し、他のアプリとやり取りすることができます。Androidのプロセス間通信（IPC）メカニズムを利用したり、基礎となるオペレーティングシステムとやり取りしたりするなど、**インストールされたアプリケーションができることは何でもできます**。[Drozerガイド](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)から。

Drozerは、以下のセクションで学ぶように、**エクスポートされたアクティビティ、エクスポートされたサービス、コンテンツプロバイダ**を攻撃するための便利なツールです。

### エクスポートされたアクティビティの攻撃

[**Androidアクティビティとは何かを思い出したい場合は、こちらを読んでください。**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、アクティビティのコードは`onCreate`メソッドから始まります。

**認証バイパス**

アクティビティがエクスポートされている場合、外部のアプリからその画面を呼び出すことができます。したがって、**機密情報**を含むアクティビティが**エクスポート**されている場合、**認証メカニズムをバイパス**してアクセスすることができます。\
[Drozerを使用してエクスポートされたアクティビティを攻撃する方法を学びましょう。](drozer-tutorial/#activities)

また、adbからエクスポートされたアクティビティを起動することもできます：

* パッケージ名はcom.example.demoです
* エクスポートされたアクティビティ名はcom.example.test.MainActivityです
```
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSFは、アクティビティの`android:launchMode`としての_singleTask/singleInstance_の使用を悪意のあるものとして検出しますが、[こちら](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)によると、これは古いバージョン（APIバージョン<21）ではのみ危険です。

{% hint style="info" %}
注意：認証バイパスは常に脆弱性ではありません。バイパスの動作方法と公開される情報によって異なります。
{% endhint %}

**機密情報の漏洩**

**アクティビティは結果を返すこともできます**。エクスポートされて保護されていないアクティビティが、**`setResult`**メソッドを呼び出し、**機密情報を返す**場合、機密情報の漏洩が発生します。

### コンテンツプロバイダの悪用 - 機密情報へのアクセスと操作

[**コンテンツプロバイダとは何かを思い出すにはこちらを読んでください。**](android-applications-basics.md#content-provider)\
コンテンツプロバイダは基本的にはデータの共有に使用されます。アプリに利用可能なコンテンツプロバイダがある場合、それらから**機密データ**を抽出することができるかもしれません。また、**SQLインジェクション**や**パストラバーサル**の可能性もテストすることが重要です。これらは脆弱性のある可能性があります。\
[**Drozerを使用してコンテンツプロバイダを悪用する方法を学びましょう。**](drozer-tutorial/#content-providers)

### **サービスの悪用**

[**サービスとは何かを思い出すにはこちらを読んでください。**](android-applications-basics.md#services)\
サービスのアクションは、`onStartCommand`メソッドで開始されます。

サービスは基本的には**データを受け取り**、**処理**し、**応答**（またはしない）を返すものです。したがって、アプリケーションがいくつかのサービスをエクスポートしている場合は、コードを**チェック**して、それが何をしているのかを理解し、機密情報の抽出や認証手段のバイパスなどを**動的に**テストする必要があります。\
[**Drozerを使用してサービスを悪用する方法を学びましょう。**](drozer-tutorial/#services)

### **ブロードキャストレシーバの悪用**

[**ブロードキャストレシーバとは何かを思い出すにはこちらを読んでください。**](android-applications-basics.md#broadcast-receivers)\
ブロードキャストレシーバのアクションは、`onReceive`メソッドで開始されます。

ブロードキャストレシーバは、特定のタイプのメッセージを待機しています。レシーバがメッセージをどのように処理するかによって、脆弱性がある可能性があります。\
[**Drozerを使用してブロードキャストレシーバを悪用する方法を学びましょう。**](./#exploiting-broadcast-receivers)

### **スキーム/ディープリンクの悪用**

MobSFのようなツールや[このスクリプト](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)などを使用して、ディープリンクを手動で検索することができます。\
**adb**または**ブラウザ**を使用して、宣言された**スキーム**を**開く**ことができます。
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
_パッケージ名を省略することができます。モバイルは自動的にそのリンクを開くべきアプリを呼び出します。_
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
**実行されるコード**

アプリで実行される**コードを見つける**には、ディープリンクで呼び出されるアクティビティに移動し、**`onNewIntent`**という関数を検索します。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**機密情報**

ディープリンクを見つけるたびに、URLパラメータを介して機密データ（パスワードなど）が送信されていないかを確認してください。なぜなら、他のアプリケーションがディープリンクをなりすましてそのデータを盗む可能性があるからです。

**パス内のパラメータ**

URLのパス内にパラメータを使用しているディープリンクがあるかどうかも**確認する必要があります**。例えば、`https://api.example.com/v1/users/{username}`のような場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value`のようにパストラバーサルを強制することができます。\
アプリケーション内で正しいエンドポイントを見つけることができれば、**オープンリダイレクト**（パスの一部がドメイン名として使用される場合）、**アカウント乗っ取り**（CSRFトークンなしでユーザーの詳細を変更でき、脆弱性のあるエンドポイントが正しいメソッドを使用している場合）などを引き起こすことができます。詳細は[こちら](http://dphoeniixx.com/2020/12/13-2/)を参照してください。

**その他の例**

リンクに関する[興味深いバグ報奨金レポート](https://hackerone.com/reports/855618)。

### 不十分なトランスポート層保護

* **証明書の検査の不足:** Androidアプリケーションは、それに提示された証明書の正当なチェーンを信頼された（ルート）証明書に戻すことができません。ほとんどのアプリケーションは警告を無視し、自己署名証明書を受け入れます。一部のアプリケーションは代わりにトラフィックをHTTP接続経由で送信します。
* **弱いハンドシェイクの交渉:** アプリケーションとサーバーはSSL/TLSハンドシェイクを実行しますが、MITM攻撃に対して脆弱な暗号スイートを使用します。したがって、攻撃者はその接続を簡単に復号化できます。
* **プライバシー情報の漏洩:** アプリケーションは認証を安全なチャネルを介して行うことが多いですが、その他の接続は非安全なチャネルを介して行われます。これは、セッションクッキーやユーザーデータなどの他の機密データが悪意のあるユーザーによって傍受される可能性があるため、アプリケーションのセキュリティには貢献しません。

提示された3つのシナリオから、**証明書の正当性を検証する方法**について説明します。他の2つのシナリオは、サーバーの**TLS設定**とアプリケーションが**暗号化されていないデータを送信**するかどうかに依存します。ペンテスターは、サーバーのTLS設定を自分でチェックし、[こちら](../../network-services-pentesting/pentesting-web/#ssl-tls-vulnerabilites)で**機密情報が暗号化されていない/脆弱な**チャネルを介して送信されていないかを検出する必要があります。\
この種の脆弱性を発見し修正する方法の詳細は、[**こちら**](https://manifestsecurity.com/android-application-security-part-10/)を参照してください。

**SSLピニング**

デフォルトでは、SSL接続を行う際に、クライアント（Androidアプリ）はサーバーの証明書が信頼された（ルート）証明書に対して検証可能な信頼チェーンを持ち、要求されたホスト名と一致するかどうかをチェックします。これにより、**中間者攻撃（MITM）**の問題が発生します。\
証明書ピニングでは、Androidアプリケーション自体がサーバーの証明書を含み、同じ証明書が提示された場合にのみデータを送信します。\
**機密情報が送信される可能性のあるサイトには、SSLピニングを適用することをお勧めします。**

### HTTPトラフィックの検査

まず、使用する**プロキシ**ツール（おそらくBurp）の**証明書をインストール**する必要があります。プロキシツールのCA証明書をインストールしない場合、プロキシで暗号化されたトラフィックは表示されません。\
**カスタムCA証明書のインストール方法については、[このガイドを読んでください](android-burp-suite-settings.md)**。

**APIレベル24以上を対象とするアプリケーションの場合、デバイスにBurp CA証明書をインストールするだけでは不十分です**。この新しい保護をバイパスするには、ネットワークセキュリティ構成ファイルを変更する必要があります。したがって、このファイルを変更してCA証明書を承認するか、[**このページを読んでデバイスにインストールされたすべての証明書を再度受け入れるようにアプリケーションを強制する方法についてのチュートリアルを参照してください**](make-apk-accept-ca-certificate.md)。

**SSLピニング**

すでに2つ前でSSLピニングについて説明しました。アプリケーションでSSLピニングが実装されている場合、HTTPSトラフィックを検査するためにそれをバイパスする必要があります。そうしないと、トラフィックは表示されません。\
ここでは、この保護をバイパスするために使用したいくつかのオプションを紹介します。

* [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)を使用して、自動的にapkを変更してSSLピニングをバイパスします。このオプションの最大の利点は、SSLピニングをバイパスするためにルート化が必要ないことですが、アプリケーションを削除して新しいものを再インストールする必要があり、これが常に機能するわけではありません。
* この保護をバイパスするために**Frida**（以下で説明）を使用することもできます。Burp+Frida+Genymotionの使用方法については、[こちらのガイド](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)を参照してください。
* [**objection**](frida-tutorial/objection-tutorial.md)を使用して、**自動的にSSLピニングをバイパス**することもできます: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* **MobSFの動的解析**を使用して、**自動的にSSLピニングをバイパス
### **Androidアプリケーションアナライザー**

このツールは、動的解析中にさまざまなツールを管理するのに役立ちます：[https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### インテントインジェクション

この脆弱性は、Webセキュリティの**オープンリダイレクト**に似ています。クラス`Intent`は`Parcelable`であるため、このクラスに属するオブジェクトは、別の`Intent`オブジェクトの**追加データ**として**渡すことができます**。\
多くの開発者は、この**機能**を利用して、`startActivity(...)`、`sendBroadcast(...)`などの危険なメソッドに埋め込まれた`Intent`を受け取り、それを渡す**プロキシコンポーネント**（アクティビティ、ブロードキャストレシーバー、サービス）を作成します。\
これは危険です。なぜなら、**攻撃者はアプリを強制的に起動させることができる非公開コンポーネントを起動させる**ことができず、または攻撃者にコンテンツプロバイダへのアクセス権限を与えることができるからです。**`WebView`**は、`Intent.parseUri(...)`メソッドを使用して、文字列から`Intent`オブジェクトに**URLを変更**し、それを`startActivity(...)`に渡すこともあります。

### Androidクライアントサイドインジェクションとその他

おそらく、Webからこの種の脆弱性については知っているでしょう。Androidアプリケーションでは、特に次の脆弱性に注意する必要があります：

* **SQLインジェクション：** 動的クエリやコンテンツプロバイダを扱う場合は、パラメータ化されたクエリを使用していることを確認してください。
* **JavaScriptインジェクション（XSS）：** 任意のWebViewでJavaScriptとプラグインサポートが無効になっていることを確認してください（デフォルトで無効になっています）。[詳細はこちら](webview-attacks.md#javascript-enabled)。
* **ローカルファイルインクルージョン：** 任意のWebViewでファイルシステムアクセスが無効になっていることを確認してください（デフォルトで有効になっています）（`webview.getSettings().setAllowFileAccess(false);`）。[詳細はこちら](webview-attacks.md#javascript-enabled)。
* **永続的なクッキー：** Androidアプリケーションがセッションを終了する場合、クッキーが取り消されない場合があります。また、クッキーがディスクに保存される場合もあります。
* [**クッキーのセキュアフラグ**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグ報奨金の場所です。**

**遅延なしで報酬を受け取る**\
HackenProofの報奨金は、顧客が報奨金予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントテストの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは、新しいインターネットです！成長するWeb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグで評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)して、ハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## 自動解析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静的解析**

![](<../../.gitbook/assets/image (61).png>)

**アプリケーションの脆弱性評価**を行うための素晴らしいWebベースのフロントエンド。動的解析も実行できます（ただし、環境を準備する必要があります）。
```
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSFは、**Android**(apk)**、IOS**(ipa)、およびWindows**(apx)アプリケーションを分析することができます（Windowsアプリケーションは、WindowsホストにインストールされたMobSFから分析する必要があります）。
また、**Android**または**IOS**アプリのソースコードをZIPファイルに作成すると（アプリケーションのルートフォルダに移動し、すべてを選択してZIPファイルを作成する）、それも分析することができます。

MobSFは、**diff/Compare**分析や**VirusTotal**の統合も可能です（_MobSF/settings.py_にAPIキーを設定し、有効にする必要があります: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`）。また、`VT_UPLOAD`を`False`に設定すると、ファイルの代わりに**ハッシュ**がアップロードされます。

### MobSFによるアシストされた動的分析

**MobSF**は、**Android**での動的分析にも非常に役立ちますが、その場合はMobSFと**genymotion**をホストにインストールする必要があります（VMやDockerでは動作しません）。_注意: **まずgenymotionでVMを起動**し、**その後にMobSFを起動する必要があります**。_
**MobSFの動的アナライザ**は以下のことができます:

* **アプリケーションデータのダンプ**（URL、ログ、クリップボード、自分が作成したスクリーンショット、"**Exported Activity Tester**"によって作成されたスクリーンショット、メール、SQLiteデータベース、XMLファイル、およびその他の作成されたファイル）。これらは自動的に行われますが、スクリーンショットは必要な時に押すか、すべてのエクスポートされたアクティビティのスクリーンショットを取得するために"**Exported Activity Tester**"を押す必要があります。
* **HTTPSトラフィックのキャプチャ**
* **Frida**を使用して**ランタイム情報**を取得する

Androidの**バージョン5以降**では、**自動的にFridaを起動**し、グローバル**プロキシ**設定を**キャプチャ**トラフィックに設定します。テストされたアプリケーションからのトラフィックのみキャプチャされます。

**Frida**

デフォルトでは、Fridaスクリプトを使用して、**SSLピニング**、**ルート検出**、**デバッガ検出**をバイパスし、**興味深いAPI**を監視するために使用します。
MobSFはまた、エクスポートされたアクティビティを**呼び出し**、それらのスクリーンショットを**取得**してレポートに**保存**することもできます。

動的テストを**開始**するには、緑色のボタン "**Start Instrumentation**" を押します。Fridaスクリプトによって生成されたログを表示するには "**Frida Live Logs**" を押し、フックされたメソッドの呼び出し、渡された引数、返された値をすべて表示するには "**Live API Monitor**" を押します（これは "Start Instrumentation" を押した後に表示されます）。
MobSFはまた、独自の**Fridaスクリプト**をロードすることもできます（Fridayスクリプトの結果をMobSFに送信するには `send()` 関数を使用します）。また、**いくつかの事前に書かれたスクリプト**もロードできます（`MobSF/DynamicAnalyzer/tools/frida_scripts/others/`に追加することもできます）。スクリプトを選択し、"**Load**" を押し、"**Start Instrumentation**" を押します（そのスクリプトのログを "**Frida Live Logs**" 内で表示できます）。

![](<../../.gitbook/assets/image (215).png>)

さらに、いくつかの補助的なFrida機能があります:

* **ロードされたクラスの列挙**: ロードされたすべてのクラスを表示します
* **文字列のキャプチャ**: アプリケーションの使用中にキャプチャされたすべての文字列を表示します（非常にノイズが多いです）
* **文字列の比較のキャプチャ**: 非常に便利です。比較された2つの文字列と結果（TrueまたはFalse）を表示します。
* **クラスメソッドの列挙**: クラス名（例: "java.io.File"）を入力すると、クラスのすべてのメソッドを表示します。
* **クラスパターンの検索**: パターンに一致するクラスを検索します
* **クラスメソッドのトレース**: クラス全体をトレースします（クラスのすべてのメソッドの入力と出力を表示します）。デフォルトでは、MobSFはいくつかの興味深いAndroid APIメソッドをトレースします。

使用する補助モジュールを選択したら、"**Start Intrumentation**" を押して、すべての出力を "**Frida Live Logs**" で確認できます。

**シェル**

MobSFには、動的分析ページの一番下に、いくつかの**adb**コマンド、**MobSFコマンド**、および一般的な**シェルコマンド**が含まれています。いくつかの興味深いコマンド:
```
help
shell ls
activities
exported_activities
services
receivers
```
**HTTPツール**

HTTPトラフィックがキャプチャされると、キャプチャされたトラフィックの見た目は「**HTTP(S) Traffic**」の下に見えるか、より見やすいビューは「**Start HTTPTools**」の緑のボタンで表示されます。2番目のオプションから、キャプチャされたリクエストをBurpやOwasp ZAPのようなプロキシに**送信**することができます。\
そのためには、_Burpを起動 --> Interceptをオフにする --> MobSB HTTPToolsでリクエストを選択_ --> "**Send to Fuzzer**"を押す --> _プロキシアドレスを選択_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

MobSFで動的解析を終えたら、「**Start Web API Fuzzer**」を押して、HTTPリクエストを**ファズ**し、脆弱性を探すことができます。

{% hint style="info" %}
MobSFで動的解析を行った後、プロキシ設定が誤っている場合、GUIから修正することができません。プロキシ設定を修正するには、以下の手順を実行してください:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Inspeckageによるアシストされた動的解析

[**Inspeckage**](https://github.com/ac-pm/Inspeckage)からツールを入手できます。\
このツールは、**フック**を使用して、**動的解析**を実行する際にアプリケーションで**何が起こっているかを知る**ことができます。

{% content-ref url="inspeckage-tutorial.md" %}
[inspeckage-tutorial.md](inspeckage-tutorial.md)
{% endcontent-ref %}

### [Yaazhini](https://www.vegabird.com/yaazhini/)

これは、GUIを使用して**静的解析を実行するための優れたツール**です。

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、**ソースコード**または**パッケージ化されたAPK**内のいくつかの**セキュリティ関連のAndroidアプリケーションの脆弱性**を検索するために設計されています。このツールはまた、見つかった脆弱性の一部（公開されたアクティビティ、インテント、タップジャッキングなど）を悪用するための「Proof-of-Concept」展開可能なAPKとADBコマンドを作成することもできます。Drozerと同様に、テストデバイスをルート化する必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* 簡単な参照のためにすべての抽出されたファイルを表示します
* APKファイルを自動的にJavaおよびSmali形式に逆コンパイルします
* 一般的な脆弱性と動作のためのAndroidManifest.xmlの分析
* 一般的な脆弱性と動作のための静的ソースコード分析
* デバイス情報
* インテント
* コマンドの実行
* SQLiteの参照
* ロギングの参照
* コンテンツプロバイダー
* ブロードキャストレシーバー
* サービスの参照
* ファイルの参照
* 暗号の参照
* ハードコードされた秘密情報
* URL
* ネットワーク接続
* SSLの参照
* WebViewの参照
```
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERは、Windows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、脆弱性を検出するために_.apk_ファイルを分析します。これは、APKを展開し、一連のルールを適用して脆弱性を検出することによって行われます。

すべてのルールは、`rules.json`ファイルに集約されており、各企業やテスターは必要なものを分析するために独自のルールを作成することができます。

最新のバイナリは[ダウンロードページ](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAnは、モバイルアプリケーションの[静的コード解析](https://en.wikipedia.org/wiki/Static\_program\_analysis)を実行する開発者、バグバウンティハンター、倫理的ハッカーを支援する**クロスプラットフォーム**ツールです\*。

このツールでは、モバイルアプリケーションファイル（.apkまたは.ipaファイル）をStaCoAnアプリケーションにドラッグアンドドロップすると、視覚的でポータブルなレポートが生成されます。設定やワードリストを調整して、カスタマイズされた体験を得ることができます。

[最新リリース](https://github.com/vincentcox/StaCoAn/releases)をダウンロードしてください。
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Frameworkは、開発者やハッカーがAndroidアプリケーションの潜在的なセキュリティ脆弱性を見つけるのを支援するAndroid脆弱性分析システムです。\
[Windowsリリース](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**は、主な目的はAndroidアプリケーションによって開発された潜在的な悪意のある振る舞いを検出し、ユーザーに警告することです。

検出は、アプリケーションのDalvikバイトコード（Smali形式）の**静的解析**によって行われます。この解析には、[`androguard`](https://github.com/androguard/androguard)ライブラリが使用されます。

このツールは、次のような「悪い」アプリケーションの一般的な振る舞いを探します：電話識別子の外部への漏洩、オーディオ/ビデオフローの傍受、PIMデータの変更、任意のコードの実行...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA**は、**M**obile **A**pplication **R**everse engineering and **A**nalysis Frameworkの略です。これは、一般的に使用されるモバイルアプリケーションの逆向きエンジニアリングと分析ツールを組み合わせたツールであり、OWASPモバイルセキュリティの脅威に対してモバイルアプリケーションのテストを支援します。その目的は、このタスクをモバイルアプリケーション開発者とセキュリティ専門家にとってより簡単で使いやすくすることです。

以下のことができます：

- 異なるツールを使用してJavaおよびSmaliコードを抽出する
- [smalisca](https://github.com/dorneanu/smalisca)、[ClassyShark](https://github.com/google/android-classyshark)、[androbugs](https://github.com/AndroBugs/AndroBugs_Framework)、[androwarn](https://github.com/maaaaz/androwarn)、[APKiD](https://github.com/rednaga/APKiD)を使用してAPKを分析する
- 正規表現を使用してAPKからプライベート情報を抽出する
- マニフェストを分析する
- [pyssltest](https://github.com/moheshmohan/pyssltest)、[testssl](https://github.com/drwetter/testssl.sh)、[whatweb](https://github.com/urbanadventurer/WhatWeb)を使用して見つかったドメインを分析する
- [apk-deguard.com](http://www.apk-deguard.com)を介してAPKの難読化を解除する

### Koodous

マルウェアを検出するのに便利です：[https://koodous.com/](https://koodous.com)

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグバウンティのホームです。**

**遅延なしで報酬を受け取る**\
HackenProofのバウンティは、顧客が報酬予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！成長する日々のWeb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグで評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)してハッキングから収益を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## コードの難読化/難読化解除

コードを難読化するために使用するサービスと設定によっては、秘密情報が難読化される場合とされない場合があります。

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

**ProGuard**は、Javaコードを縮小、最適化、難読化するためのオープンソースのコマンドラインツールです。バイトコードを最適化し、未使用の命令を検出および削除することができます。ProGuardは無料のソフトウェアであり、GNU General Public License、バージョン2で配布されています。

ProGuardはAndroid SDKの一部として配布され、リリースモードでアプリケーションをビルドする際に実行されます。

出典：[https://en.wikipedia.org/wiki/ProGuard\_(software)](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

### [DexGuard](https://www.guardsquare.com/dexguard)

APKの難読化を解除するためのステップバイステップガイドは[こちら](https://blog.lexfo.fr/dexguard.html)で見つけることができます。

（そのガイドから）最後に確認したとき、Dexguardの動作モードは次のようでした：

- リソースをInputStreamとしてロードする
- 結果をFilterInputStreamを継承したクラスにフィードして復号化する
- いくつかの無駄な難読化を行い、リバーサーの時間を数分無駄にする
- 復号化された結果をZipInputStreamにフィードしてDEXファイルを取得する
- 最終的に`loadDex`メソッドを使用して得られたDEXをリソースとしてロードする

### [DeGuard](http://apk-deguard.com)

**DeGuardは、Androidの難読化ツールによって実行された難読化のプロセスを逆転させます。これにより、コードの検査やライブラリの予測など、さまざまなセキュリティ分析が可能になります。**

難読化されたAPKをプラットフォームにアップロードすることができます。

### [Simplify](https://github.com/CalebFenton/simplify)

これは**汎用のAndroid難読化解除ツール**です。Simplifyはアプリを**仮想的に実行**してその動作を理解し、コードを最適化して同じ動作をするが人間にとって理解しやすいものにします。各最適化タイプはシンプルで汎用的であり、特定の難読化タイプは問題ありません。

### [APKiD](https://github.com/rednaga/APKiD)

APKiDは、APKの作成方法に関する情報を提供します。多くの**コンパイラ**、**パッカー**、**難読化ツール**、およびその他の奇妙なものを識別します。これはAndroidの[_PEiD_](https://www.aldeid.com/wiki/PEiD)です。

### 手動

[このチュートリアルを読んで、カスタムの難読化を逆向きにするためのトリックを学びましょう](manual-deobfuscation.md)

## ラボ

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4bは、ubuntu-mateをベースにしたAndroidセキュリティ仮想マシンであり、さまざまなセキュリティギークや研究者からの最新のフレームワーク、チュートリアル、ラボを含んでいます。逆向きエンジニアリングとマルウェア分析のためのものです。

### OWASP

{% embed url="https://github.com/OWASP/owasp-mstg%0Ahttps://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06g-testing-network-communication" %}

### Gitリポジトリ

[https://github.com/riddhi-shree/nullCommunity/tree/master/Android](https://github.com/riddhi-shree/nullCommunity/tree/master/Android)\
[https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## 参考文献

詳細については、以下を参照してください：

- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) リソースの素晴らしいリストです
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Androidクイックコース
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
## テストする

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグ報奨金の場所です。**

**遅延なしで報酬を受け取る**\
HackenProofの報奨金は、顧客が報酬予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！その成長期におけるweb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)してハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するために、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出してください。**

</details>
