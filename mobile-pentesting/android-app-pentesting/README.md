# Androidアプリケーションの侵入テスト

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい場合は**[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスウェグ**](https://peass.creator-spring.com)を手に入れる
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **Discordグループ**に参加する💬 [**Discord group**](https://discord.gg/hRep4RUj7f)または[**telegram group**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)をフォローする。
- **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取るために[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加しましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加する

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を追いかける

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新について知る

**[Discord](https://discord.com/invite/N3FrSbmwdy)に参加して、今日からトップハッカーと協力しましょう！**

## Androidアプリケーションの基礎

Androidセキュリティに関連する**最も重要な部分**やAndroidアプリケーションの中で**最も危険なコンポーネント**について知るために、このページを読むことを強くお勧めします：

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB（Android Debug Bridge）

これはAndroidデバイス（エミュレートされたものまたは物理的なもの）に接続するために必要な主要ツールです。\
これにより、コンピューターからデバイスを**USB**または**ネットワーク**経由で制御し、ファイルを**コピー**したり、アプリを**インストール**およびアンインストールしたり、**シェル**コマンドを実行したり、**バックアップ**を取ったり、**ログ**を読んだりすることができます。

ADBの使用方法を学ぶために、次の[**ADBコマンド**](adb-commands.md)のリストを参照してください。

## Smali

時には、**アプリケーションコードを変更**して**隠された情報**にアクセスすることが興味深いことがあります（おそらくよく難読化されたパスワードやフラグ）。その後、APKを逆コンパイルしてコードを変更し、再コンパイルすることが興味深いかもしれません。\
[**このチュートリアル**では、APKを逆コンパイルし、Smaliコードを変更してAPKを再コンパイルする方法](smali-changes.md)を学ぶことができます。これは、**動的解析中にいくつかのテストの代替手段として非常に役立つ**かもしれません。そのため、**常にこの可能性を念頭に置いておいてください**。

## その他の興味深いトリック

* [Play Storeでの位置偽装](spoofing-your-location-in-play-store.md)
* **APKのダウンロード**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* デバイスからAPKを抽出:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
## 静的解析

まず、APKを解析するためには、デコンパイラを使用してJavaコードを確認する必要があります。\
[**こちらを読んで、利用可能な異なるデコンパイラに関する情報を見つけてください**](apk-decompilers.md)。

### 興味深い情報を探す

APKの**strings**を見るだけで、**パスワード**、**URL**、**API**キー、**暗号化**、**Bluetooth UUID**、**トークン**など、興味深い情報を検索できます。コード実行の**バックドア**や認証バックドア（アプリにハードコードされた管理者資格情報）なども探してください。

**Firebase**

**Firebase URL**に特に注意し、それが適切に構成されているかどうかを確認してください。[こちらでFirebaseについての詳細情報とその悪用方法を確認してください。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本的な理解 - Manifest.xml、strings.xml

[**こちらで**](apk-decompilers.md)言及されているデコンパイラのいずれかを使用すると、_Manifest.xml_を読むことができます。また、**apk**ファイルの拡張子を**.zip**に変更して**解凍**することもできます。\
**マニフェスト**を読むと、次の**脆弱性**を見つけることができます：

* まず、アプリケーションが**デバッグ可能かどうか**を確認してください。本番用のAPKはデバッグ可能ではないはずです（そうでないと他の人が接続できます）。マニフェストで`debuggable="true"`属性を探してアプリケーションがデバッグ可能かどうかを確認できます。例：`<application theme="@2131296387" debuggable="true"`
* [こちらで](drozer-tutorial/#is-debuggeable)デバッグ可能なアプリケーションを見つけて悪用する方法を学んでください
* **バックアップ**：**`android:allowBackup`**属性は、USBデバッグを有効にしたユーザーがアプリケーションデータをバックアップおよび復元できるかどうかを定義します。バックアップフラグがtrueに設定されている場合、デバイスがルート化されていなくても、攻撃者はadbを介してアプリケーションデータのバックアップを取ることができます。したがって、カードの詳細、パスワードなどの機密情報を処理および保存するアプリケーションは、この設定を**false**に明示的に設定する必要があります。デフォルトでは、これを防ぐために**true**に設定されています。
* `<application android:allowBackup="false"`
* **NetworkSecurity:** アプリケーションのネットワークセキュリティは、**`android:networkSecurityConfig="@xml/network_security_config"`**でデフォルト値を上書きできます。その名前のファイルが_res/xml_に配置される可能性があります。このファイルは、証明書ピンやHTTPトラフィックを許可するかどうかなどの重要なセキュリティ設定を構成します。ここで設定できるすべての情報について詳しくはこちらを参照してくださいが、いくつかのドメインのHTTPトラフィックを構成する方法についての例を確認してください：
* `<domain-config cleartextTrafficPermitted="true"> <domain includeSubdomains="true">formation-software.co.uk </domain></domain-config>`
* **公開されたアクティビティ**: マニフェスト内の公開されたアクティビティを確認してください。これは危険な場合があります。動的解析では、[この動作を悪用する方法](./#exploiting-exported-activities-authorisation-bypass)について説明します。
* **コンテンツプロバイダ**: 公開されたプロバイダが公開されている場合、興味深い情報にアクセス/変更できる可能性があります。動的解析では、[それらを悪用する方法](./#exploiting-content-providers-accessing-and-manipulating-sensitive-information)を学びます。
* 属性`android:name="android.support.FILE_PROVIDER_PATHS"`内の**FileProviders**構成を確認してください。[こちらでFileProvidersについて詳しく学んでください](./#fileprovider)。
* **公開されたサービス**: サービスが内部で何を行っているかに応じて、脆弱性が悪用される可能性があります。動的解析では、[それらを悪用する方法](./#exploiting-services)を学びます。
* **ブロードキャストレシーバ**: [それらを悪用する方法](./#exploiting-broadcast-receivers)を学ぶことができます。
* **URLスキーム**: スキーマを管理するアクティビティのコードを読み、ユーザーの入力を処理する際の脆弱性を探してください。[URLスキームについての詳細情報はこちら](./#url-schemes)。
* **minSdkVersion**、**targetSDKVersion**、**maxSdkVersion**: アプリが実行されるAndroidのバージョンを示します。セキュリティの観点から、古いバージョンをサポートすることは既知の脆弱なAndroidバージョンが実行される可能性があるため重要です。

**resources.arsc/strings.xml**を読むと、いくつかの**興味深い情報**を見つけることができます：

* APIキー
* カスタムスキーマ
* 開発者がこのファイルに保存するその他の興味深い情報

### タップジャッキング

**タップジャッキング**は、**悪意のあるアプリケーション**が**被害者アプリケーションの上に配置**され、被害者アプリケーションを視覚的に遮蔽します。被害者アプリケーションが見えなくなると、ユーザーインターフェースが設計され、ユーザーがそれとやり取りするように誘導されるようになっていますが、実際にはその操作を被害者アプリケーションに渡しています。\
実際には、ユーザーが自分が実際に被害者アプリケーションでアクションを実行していることを知らないようにしています。

詳細は以下で確認できます：

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### タスクハイジャッキング

**`launchMode`**が**`singleTask`**に設定され、**`taskAffinity`**が定義されていない**アクティビティ**は、タスクハイジャッキングの脆弱性があります。これは、**アプリケーション**がインストールされ、実際のアプリケーションよりも先に起動された場合、実際のアプリケーションのタスクを**ハイジャック**できることを意味します（つまり、ユーザーは**実際のアプリケーションを使用していると思い込んで悪意のあるアプリケーションとやり取りしている**と思うことになります）。

詳細は以下で確認できます：

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### 安全でないデータの保存

**内部ストレージ**

Androidでは、内部ストレージに保存されたファイルは、それを作成した**アプリケーション**によって**独占的にアクセス**できるように**設計**されています。このセキュリティ対策はAndroidオペレーティングシステムによって**強制**され、ほとんどのアプリケーションのセキュリティニーズには一般的に十分です。ただし、開発者は、`MODE_WORLD_READABLE`や`MODE_WORLD_WRITABLE`などのモードを利用して、ファイルを異なるアプリケーション間で**共有**できるようにすることがあります。しかし、これらのモードは、他のアプリケーション（悪意のあるものを含む）によるこれらのファイルへのアクセスを**制限**しません。

1. **静的解析:**
- `MODE_WORLD_READABLE`や`MODE_WORLD_WRITABLE`の使用が**慎重に検討**されていることを**確認**してください。これらのモードは、ファイルを**意図しないアクセス**にさらす可能性があります。

2. **動的解析:**
- アプリケーションによって作成されたファイルに設定された**アクセス許可**を確認してください。特に、ファイルが**世界中で読み取りまたは書き込み可能**に設定されているかどうかを**確認**してください。これは、デバイスにインストールされている**どのアプリケーション**でも、その起源や意図に関係なく、これらのファイルを**読み取ったり変更**したりできる可能性があるため、重大なセキュリティリスクを引き起こす可能性があります。

**外部ストレージ**

### 外部ストレージ上のファイルの管理ガイドライン

外部ストレージ（SDカードなど）のファイルを扱う際には、次の注意が必要です：

1. **アクセシビリティ**:
- 外部ストレージ上のファイルは**グローバルに読み取りおよび書き込み可能**です。つまり、どのアプリケーションやユーザーでもこれらのファイルにアクセスできます。

2. **セキュリティ上の懸念**:
- アクセスが容易であるため、外部ストレージに**機密情報を保存しない**ことが推奨されます。
- 外部ストレージは取り外し可能であり、またどのアプリケーションからもアクセスできるため、セキュリティが低くなります。

3. **外部ストレージからのデータの取り扱い**:
- 外部ストレージから取得したデータには**入力検証**を常に行ってください。これは、データが信頼できないソースから取得されているため、重要です。
- 外部ストレージから実行可能ファイルやクラスファイルを動的に読み込むことは強く推奨されません。
- アプリケーションが外部ストレージから実行可能ファイルを取得する必要がある場合は、これらのファイルが**署名され、暗号的に検証**されることを確認してから動的に読み込まれるようにしてください。この手順は、アプリケーションのセキュリティの整合性を維持するために非常に重要です。

外部ストレージは`/storage/emulated/0`、`/sdcard`、`/mnt/sdcard`でアクセスできます。

{% hint style="info" %}
Android 4.4（**API 17**）以降、SDカードには、アプリケーションからそのアプリケーション専用のディレクトリにアクセスを**制限**するディレクトリ構造があります。これにより、悪意のあるアプリケーションが他のアプリケーションのファイルに読み取りまたは書き込みアクセスを取得するのを防ぎます。
{% endhint %}

**クリアテキストで保存された機密データ**

* **共有プリファレンス**: Androidは、各アプリケーションが`/data/data/<packagename>/shared_prefs/`パスに簡単にxmlファイルを保存できるようにし、このフォルダーにクリアテキストで機密情報を見つけることができる場合があります。
* **データベース**: Androidは、各アプリケーションが`/data/data/<packagename>/databases/`パスにsqliteデータベースを簡単に保存できるようにし、このフォルダーにクリアテキストで機密情報を見つけることができる場合があります。

### 破損したTLS

**すべての証明書を受け入れる**

何らかの理由で、開発者は、たとえばホスト名が一致しない場合でも、すべての証明書を受け入れることがあります。以下のようなコード行がある場合でもです。
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
### 破損した暗号化

**鍵管理プロセスの不備**

一部の開発者は、機密データをローカルストレージに保存し、コード内でハードコード化/予測可能なキーで暗号化しています。これは行うべきではありません。逆向きに進むことで攻撃者が機密情報を抽出できる可能性があるためです。

**安全でないおよび/または非推奨のアルゴリズムの使用**

開発者は、**非推奨のアルゴリズム**を使用して**認証チェック**、**データの保存**または**送信**を行うべきではありません。これらのアルゴリズムの一部には、RC4、MD4、MD5、SHA1などがあります。たとえばパスワードを保存するために**ハッシュ**が使用される場合、**ソルト**とともにハッシュブルートフォース**耐性**を持つものを使用する必要があります。

### その他のチェック

* **APKを難読化**することをお勧めします。これにより、逆向きの労力が増え、攻撃者がアプリを解析するのが難しくなります。
* アプリが機密情報を扱う場合（銀行アプリなど）、モバイルがルート化されているかどうかを**独自にチェック**し、それに応じて対応するべきです。
* アプリが機密情報を扱う場合（銀行アプリなど）、**エミュレータ**が使用されていないかを確認する必要があります。
* アプリが機密情報を扱う場合（銀行アプリなど）、**実行前に自己の整合性をチェック**して、変更されていないかを確認する必要があります。
* APKをビルドする際に使用された**コンパイラ/パッカー/難読化ツール**をチェックするために[**APKiD**](https://github.com/rednaga/APKiD)を使用します。

### React Nativeアプリケーション

ReactアプリケーションのJavaScriptコードに簡単にアクセスする方法を学ぶには、次のページを読んでください：

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Xamarinアプリケーション

XamarinアプリケーションのC#コードに簡単にアクセスする方法を学ぶには、次のページを読んでください：

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### スーパーパックされたアプリケーション

この[**ブログ投稿**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)によると、スーパーパックはアプリケーションのコンテンツを1つのファイルに圧縮するメタアルゴリズムです。ブログでは、この種のアプリを解凍するアプリを作成する可能性について説明しており、**アプリケーションを実行してファイルシステムから解凍されたファイルを収集する**というより速い方法についても説明しています。

### 自動静的コード解析

ツール[**mariana-trench**](https://github.com/facebook/mariana-trench)は、アプリケーションのコードをスキャンして**脆弱性**を見つけることができます。このツールには、**既知のソース**（ユーザーによって**制御される入力**の**場所**をツールに示す）や**シンク**（悪意のあるユーザー入力が損害を引き起こす**危険な場所**をツールに示す）および**ルール**が含まれています。これらのルールは、**ソース-シンク**の**組み合わせ**を示し、脆弱性を示します。

この知識を活用して、**mariana-trenchはコードをレビューし、可能な脆弱性を見つけます**。

### 漏洩した秘密情報

アプリケーションには、発見できるかもしれない秘密情報（APIキー、パスワード、隠されたURL、サブドメインなど）が含まれている場合があります。[https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)などのツールを使用してこれらの秘密情報を発見できます。

### バイオメトリック認証のバイパス

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### その他の興味深い機能

* **コード実行**: `Runtime.exec(), ProcessBuilder(), native code:system()`
* **SMSの送信**: `sendTextMessage, sendMultipartTestMessage`
* `native`と宣言された**ネイティブ機能**: `public native, System.loadLibrary, System.load`
* [**ネイティブ機能の逆向き**の方法を学ぶには、これを読んでください](reversing-native-libraries.md)

### **その他のテクニック**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルと課題に深く入り込むコンテンツに参加しましょう

**リアルタイムのハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を最新の状態に保ちます

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新情報を把握しましょう

**[Discord](https://discord.com/invite/N3FrSbmwdy)**に参加して、今日からトップハッカーと協力を始めましょう！

***

## 動的解析

> まず、アプリケーションとすべての環境（主にBurp CA証明書、Drozer、Frida）をインストールできる環境が必要です。したがって、ルート化されたデバイス（エミュレートされているかどうかにかかわらず）が非常にお勧めです。

### オンライン動的解析

[https://appetize.io/](https://appetize.io)で**無料アカウント**を作成できます。このプラットフォームを使用すると、APKを**アップロード**して**実行**できるため、APKの動作を確認するのに役立ちます。

Web上でアプリケーションのログを表示し、**adb**を介して接続することもできます。

![](<../../.gitbook/assets/image (60).png>)

ADB接続を介して、エミュレータ内で**Drozer**と**Frida**を使用できます。

### ローカル動的解析

#### エミュレータを使用する

* [**Android Studio**](https://developer.android.com/studio)（**x86**および**arm**デバイスを作成でき、[**最新のx86** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)バージョンは**遅いarmエミュレータを必要とせずにARMライブラリをサポート**しています）。
* このページで設定方法を学びます：

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **（無料版:** Personal Edition、アカウントを作成する必要があります。_潜在的なエラーを回避するために_ _**VirtualBoxを使用したバージョンをダウンロード**することをお勧めします。)
* [**Nox**](https://es.bignox.com)（無料ですが、FridaやDrozerをサポートしていません）。

{% hint style="info" %}
どのプラットフォームでも新しいエミュレータを作成する際には、画面が大きいほどエミュレータが遅くなることに注意してください。可能であれば小さな画面を選択してください。
{% endhint %}

Genymotionに**Googleサービス**（AppStoreなど）をインストールするには、次の画像の赤でマークされたボタンをクリックする必要があります：

![](<../../.gitbook/assets/image (200) (1).png>)

また、GenymotionのAndroid VMの**構成**で**Bridge Network mode**を選択できます（これは、他のVMからAndroid VMに接続する場合に便利です）。

#### 物理デバイスを使用する

デバッグオプションを有効にし、ルート化できると便利です：

1. **設定**。
2. （Android 8.0以降）**システム**を選択します。
3. **端末について**を選択します。
4. **ビルド番号**を7回押します。
5. 戻り、**開発者オプション**を見つけます。

> アプリケーションをインストールした後、最初に行うべきことは、それを試して調査し、その動作や機能を理解し、それに慣れることです。\
> **MobSF動的解析+pidcat**を使用してこの初期の動的解析を実行することをお勧めします。これにより、MobSFが後でレビューできる**興味深いデータ**を多く**キャプチャ**することができます。

### 意図しないデータ漏洩

**ログ**

開発者はしばしばデバッグ情報を公開しています。そのため、`READ_LOGS`権限を持つアプリケーションはこれらのログにアクセスでき、そこから機密情報を取得できます。\
アプリケーションを操作する際には、[**pidcat**](https://github.com/JakeWharton/pidcat)（お勧め、使用しやすく読みやすい）または[adb logcat](adb-commands.md#logcat)を使用して作成されたログを読み取り、**機密情報**を探します。

{% hint style="warning" %}
Android 4.0以降のバージョンでは、**アプリケーションは自分自身のログにのみアクセス**できるようになりました。そのため、アプリケーションは他のアプリのログにアクセスできません。\
それでも、**機密情報を記録しない**ことをお勧めします。
{% endhint %}

**コピー/ペーストバッファのキャッシング**

Androidは、Androidアプリケーションでコピー/ペースト機能を提供するためのクリップボードベースのフレームワークを提供しています。しかし、他のアプリケーションが**クリップボード**にアクセスできると、機密データを含む可能性のある**クリップボード**にアクセスできる重大な問題が発生します。**機密部分**のコピー/ペースト機能は**無効**にすべきです。たとえば、クレジットカードの詳細のコピーを無効にします。

**クラッシュログ**

アプリケーションが実行中にクラッシュし、ログをどこかに保存する場合、これらのログは、Androidアプリケーションを逆向きにエンジニアリングできない場合に特に攻撃者の役に立つことがあります。そのため、アプリケーションがクラッシュしたときにログを作成しないようにし、ログがネットワーク経由で送信される場合はSSLチャネルを介して送信されることを確認してください。\
ペンテスターとして、これらのログを確認してみてください。

**第三者に送信されるアナリティクスデータ**

ほとんどのアプリケーションは、Google AdSenseなどの他のサービスをアプリケーションで使用しますが、時には**機密データ**やそのサービスに送信する必要のないデータが**漏洩**することがあります。これは、開発者が機能を適切に実装していないために発生する可能性があります。アプリケーションのトラフィックをインターセプトして、第三者に機密データが送信されていないかどうかを確認できます。

### SQLiteデータベース

ほとんどのアプリケーションは、情報を保存するために**内部SQLiteデータベース**を使用します。ペンテスト中に作成された**データベース**、**テーブル**および**列**の名前、および保存されている**すべてのデータ
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSFは、アクティビティの`android:launchMode`で**singleTask/singleInstance**を使用することを悪意のあるものとして検出しますが、[こちら](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)によると、これは古いバージョン（APIバージョン< 21）でのみ危険だとされています。

{% hint style="info" %}
認可バイパスが常に脆弱性であるわけではないことに注意してください。バイパスの動作方法や露出される情報によって異なります。
{% endhint %}

**機密情報の漏洩**

**アクティビティは結果を返すこともできます**。エクスポートされた保護されていないアクティビティが**`setResult`**メソッドを呼び出し、**機密情報を返す**場合、機密情報の漏洩が発生します。

#### タップジャッキング

タップジャッキングが防止されていない場合、エクスポートされたアクティビティを悪用して**ユーザーに予期しないアクションを実行**させることができます。[**タップジャッキングとは何かについて詳しくはリンクを参照してください**](./#tapjacking)。

### コンテンツプロバイダの悪用 - 機密情報へのアクセスと操作

[**コンテンツプロバイダとは何かを思い出したい場合はこちらを読んでください。**](android-applications-basics.md#content-provider)\
コンテンツプロバイダは基本的にデータを**共有**するために使用されます。アプリに利用可能なコンテンツプロバイダがある場合、そこから**機密**データを**抽出**することができるかもしれません。また、潜在的に**SQLインジェクション**や**パストラバーサル**が脆弱であるかどうかをテストすることも興味深いでしょう。\
[**Drozerを使用してコンテンツプロバイダを悪用する方法を学ぶ**](drozer-tutorial/#content-providers)。

### **サービスの悪用**

[**サービスとは何かを思い出したい場合はこちらを読んでください。**](android-applications-basics.md#services)\
サービスのアクションは基本的に`onStartCommand`メソッドで開始されます。

サービスは基本的に**データを受信**し、それを**処理**して**応答**（またはしない）するものです。したがって、アプリケーションがいくつかのサービスをエクスポートしている場合は、それが何をしているかを理解するために**コード**をチェックし、機密情報の抽出、認証措置のバイパスなどを**動的に**テストする必要があります。\
[**Drozerを使用してサービスを悪用する方法を学ぶ**](drozer-tutorial/#services)。

### **ブロードキャストレシーバの悪用**

[**ブロードキャストレシーバとは何かを思い出したい場合はこちらを読んでください。**](android-applications-basics.md#broadcast-receivers)\
ブロードキャストレシーバのアクションは基本的に`onReceive`メソッドで開始されます。

ブロードキャストレシーバは特定の種類のメッセージを待機しています。レシーバがメッセージを処理する方法によって、脆弱性があるかもしれません。\
[**Drozerを使用してブロードキャストレシーバを悪用する方法を学ぶ**](./#exploiting-broadcast-receivers)。

### **スキーム / ディープリンクの悪用**

MobSFなどのツールを使用したり、[こちらのスクリプト](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)のようなスクリプトを使用して、ディープリンクを手動で検索できます。\
**adb**や**ブラウザ**を使用して宣言された**スキーム**を**開く**ことができます：

{% code overflow="wrap" %}
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_パッケージ名を**省略することができる**ことに注意してください。モバイルは自動的にそのリンクを開くべきアプリを呼び出します。_

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**実行されるコード**

**アプリで実行されるコード**を見つけるには、ディープリンクで呼び出されるアクティビティに移動し、**`onNewIntent`** 関数を検索します。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**機密情報**

ディープリンクを見つけるたびに、URLパラメータを介して機密データ（パスワードなど）を受信していないかどうかを確認してください。なぜなら、他のアプリケーションがディープリンクをなりすましてそのデータを盗む可能性があるからです！

**パス内のパラメータ**

URLのパス内でパラメータを使用しているディープリンクがあるかどうかも確認する必要があります。例えば、`https://api.example.com/v1/users/{username}` のような場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value` のようにパストラバーサルを強制することができます。\
アプリ内で正しいエンドポイントを見つけると、**オープンリダイレクト**（パスの一部がドメイン名として使用されている場合）、**アカウント乗っ取り**（CSRFトークンなしでユーザーの詳細を変更でき、脆弱性のあるエンドポイントが正しいメソッドを使用している場合）などを引き起こす可能性があります。詳細は[こちら](http://dphoeniixx.com/2020/12/13-2/)。

**その他の例**

リンクに関する興味深いバグ報奨レポートは[こちら](https://hackerone.com/reports/855618)。

### トランスポート層保護の不十分さ

* **証明書検査の不足:** Androidアプリケーションは、提示された証明書の正体を検証できません。ほとんどのアプリケーションは警告を無視し、提示された自己署名証明書を受け入れます。一部のアプリケーションは代わりにトラフィックをHTTP接続経由で送信します。
* **弱いハンドシェイク交渉:** アプリケーションとサーバーはSSL/TLSハンドシェイクを実行しますが、MITM攻撃に対して脆弱な暗号スイートを使用します。そのため、攻撃者はその接続を簡単に復号化できます。
* **プライバシー情報の漏洩:** 多くの場合、アプリケーションはセキュアチャネルを介して認証を行いますが、その他の接続はすべて非セキュアチャネルを介して行います。これは、セッションクッキーやユーザーデータなどの残りの機密データが悪意のあるユーザーによって傍受される可能性があるため、アプリケーションのセキュリティに貢献しません。

提示された3つのシナリオから、**証明書の正体を検証する方法**について説明します。残りの2つのシナリオは、サーバーの**TLS構成**と**アプリケーションが暗号化されていないデータを送信するかどうか**に依存します。ペンテスターは、サーバーのTLS構成を自分でチェックし、**機密情報が暗号化されていない/脆弱な**チャネルを介して送信されていないかを検出する必要があります（[こちら](../../network-services-pentesting/pentesting-web/#ssl-tls-vulnerabilites)）。
この種の脆弱性を発見して修正する方法についての詳細は[**こちら**](https://manifestsecurity.com/android-application-security-part-10/)。

**SSL Pinning**

SSL接続を行う際、クライアント（Androidアプリ）は、サーバーの証明書が信頼される（ルート）証明書に検証可能な信頼チェーンを持ち、要求されたホスト名と一致することを確認します。これにより、**中間者攻撃（MITM）**の問題が発生します。\
証明書ピンニングでは、Androidアプリケーション自体がサーバーの証明書を含み、同じ証明書が提示された場合にのみデータを送信します。\
**機密情報が送信されるサイトにはSSL Pinningを適用することが推奨**されています。

### HTTPトラフィックの検査

まず第一に、使用する**プロキシ**ツールの**証明書**を**インストール**する必要があります。おそらくBurpを使用するでしょう。プロキシツールのCA証明書をインストールしないと、プロキシで暗号化されたトラフィックを表示できない可能性があります。\
**必ず**、[**カスタムCA証明書をインストールする方法を学ぶためにこのガイドを読んでください**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)**。**

**APIレベル24以上を対象とするアプリケーションの場合、デバイスにBurp CA証明書をインストールするだけでは不十分**です。この新しい保護をバイパスするには、ネットワークセキュリティ構成ファイルを変更する必要があります。したがって、このファイルを変更してCA証明書を承認するか、[**デバイスにインストールされたすべての証明書を再度受け入れるようにアプリケーションを強制する方法に関するチュートリアルを読んでください**](make-apk-accept-ca-certificate.md)。

**SSL Pinning**

SSL Pinningについては、ちょうど2つ前で説明しました。アプリケーションに実装されている場合、HTTPSトラフィックを検査するためにそれをバイパスする必要があります。そうしないと、トラフィックを見ることができません。\
ここでは、この保護をバイパスするために使用したいくつかのオプションを紹介します：

* [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)を使用して、**apkを自動的に変更**して**SSL Pinningをバイパス**します。このオプションの最大の利点は、SSL Pinningをバイパスするためにルート権限が必要ないことですが、アプリケーションを削除して新しいものを再インストールする必要があり、これが常に機能するわけではありません。
* この保護をバイパスするために**Frida**（以下で説明）を使用することができます。Burp+Frida+Genymotionの使用方法については、[こちらのガイド](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)を参照してください。
* [**objection**](frida-tutorial/objection-tutorial.md)を使用して、**SSL Pinningを自動的にバイパス**することもできます：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* **MobSFダイナミック解析**を使用して、**SSL Pinningを自動的にバイパス**することもできます（以下で説明）。
* キャプチャしていないトラフィックがあると考える場合は、**iptablesを使用してトラフィックをBurpに転送**することができます。このブログを参照してください：[https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

**一般的なWeb脆弱性**

このステップでは、一般的なWeb脆弱性を探す必要があります。Web脆弱性に関する多くの情報がこの本に記載されているため、ここではそれらを言及しません。

### Frida

開発者、リバースエンジニア、セキュリティ研究者向けのダイナミックインストルメンテーションツールキット。詳細は[www.frida.re](https://www.frida.re)で確認できます。\
**素晴らしいツールであり、実行中のアプリケーションにアクセスして、実行時にメソッドをフックして動作を変更したり、値を変更したり、値を抽出したり、異なるコードを実行したりできます。**\
**Androidアプリケーションのペンテストを行う場合は、Fridaの使用方法を知っている必要があります。**

**Fridaの使用方法を学ぶ:** [**Fridaチュートリアル**](frida-tutorial/)\
**Fridaを使用したアクションのための"GUI":** [**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)\
**Fridaに基づく他の抽象化:** [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)\
**ここでいくつかの素晴らしいFridaスクリプトを見つけることができます:** [**https://codeshare.frida.re/**](https://codeshare.frida.re)

### **メモリのダンプ - Fridump**

アプリケーションがパスワードやニーモニックなど、保存すべきでない機密情報をメモリ内に保存していないかを確認してください。

[**Fridump3**](https://github.com/rootbsd/fridump3)を使用して、アプリのメモリをダンプできます。
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これにより、./dumpフォルダーにメモリがダンプされ、そこで次のようにgrepを使用できます：

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Keystore内の機密データ**

Androidでは、Keystoreは機密データを保存するのに最適な場所ですが、**十分な権限があれば**それにアクセスすることができます。アプリケーションはここに**平文の機密データを保存**する傾向があるため、ペンテストではrootユーザーとしてそれをチェックする必要があります。また、デバイスに物理的なアクセス権限を持つ者がこのデータを盗むことができる可能性があります。

アプリがKeystoreにデータを保存していたとしても、そのデータは暗号化されている必要があります。

Keystore内のデータにアクセスするには、このFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **指紋/生体認証バイパス**

以下のFridaスクリプトを使用すると、Androidアプリケーションが実行している可能性がある**特定の機密領域を保護するために行われる指紋認証をバイパス**することができます:
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **背景画像**

アプリケーションをバックグラウンドに置くと、Androidはアプリケーションの**スナップショット**を保存します。そのため、フォアグラウンドに復元されるとアプリケーションよりも先に画像の読み込みが開始され、アプリがより速く読み込まれたように見えます。

ただし、このスナップショットに**機密情報**が含まれている場合、スナップショットにアクセス権を持つ者がその情報を**盗み出す**可能性があります（スナップショットにアクセスするにはルート権限が必要です）。

スナップショットは通常、以下の場所に保存されます：**`/data/system_ce/0/snapshots`**

Androidは、FLAG\_SECUREレイアウトパラメータを設定することで、スクリーンショットのキャプチャを**防止**する方法を提供しています。このフラグを使用することで、ウィンドウの内容はセキュアとして扱われ、スクリーンショットに表示されたり、非セキュアなディスプレイで表示されることが防止されます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Androidアプリケーションアナライザー**

このツールは、ダイナミック解析中にさまざまなツールを管理するのに役立ちます：[https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### インテントインジェクション

この脆弱性は、Webセキュリティの**オープンリダイレクト**に似ています。`Intent`クラスは`Parcelable`であるため、このクラスに属する**オブジェクト**を別の`Intent`オブジェクトの**追加データ**として**渡す**ことができます。\
多くの開発者は、この**機能**を利用して、`startActivity(...)`、`sendBroadcast(...)`などの危険なメソッドに埋め込まれた`Intent`を受け取り、**プロキシ** **コンポーネント**（アクティビティ、ブロードキャストレシーバー、サービス）を作成します。\
これは危険です。なぜなら、**攻撃者がアプリを強制して他のアプリから直接起動できない非公開コンポーネントを起動させたり、攻撃者にコンテンツプロバイダへのアクセス権限を与えたりできる**からです。**`WebView`**は、時々`Intent.parseUri(...)`メソッドを使用してURLを文字列から`Intent`オブジェクトに変更し、`startActivity(...)`に渡します。

### Androidクライアントサイドインジェクションおよびその他

おそらくWebからこの種の脆弱性については知っているでしょう。Androidアプリケーションで特に注意すべき脆弱性については次のとおりです：

* **SQLインジェクション:** 動的クエリやContent-Providersを扱う場合は、パラメータ付きクエリを使用していることを確認してください。
* **JavaScriptインジェクション（XSS）:** すべてのWebViewでJavaScriptとプラグインサポートが無効になっていることを確認してください（デフォルトで無効）。[詳細はこちら](webview-attacks.md#javascript-enabled)。
* **ローカルファイルインクルージョン:** すべてのWebViewでファイルシステムアクセスが無効になっていることを確認してください（デフォルトで有効）（`webview.getSettings().setAllowFileAccess(false);`）。[詳細はこちら](webview-attacks.md#javascript-enabled)。
* **永続的なクッキー**: Androidアプリケーションがセッションを終了する場合、クッキーが取り消されないことがいくつかのケースであり、それがディスクに保存される可能性があります
* [**クッキーのSecureフラグ**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルと課題に深く入り込むコンテンツに参加

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を追いかける

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新に関する情報を入手

**[Discord](https://discord.com/invite/N3FrSbmwdy)**に参加して、今日からトップハッカーと協力を始めましょう！

## 自動解析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静的解析**

![](<../../.gitbook/assets/image (61).png>)

**アプリケーションの脆弱性評価**を行うための素敵なWebベースのフロントエンド。動的解析も実行できます（ただし、環境を準備する必要があります）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSFは**Android**(apk)**、IOS**(ipa)**、およびWindows**(apx)アプリケーションを分析できます（_WindowsアプリケーションはWindowsホストにインストールされたMobSFから分析する必要があります_）。\
また、**Android**または**IOS**アプリのソースコードをZIPファイルに作成すると（アプリケーションのルートフォルダに移動し、すべてを選択してZIPファイルを作成する）、それも分析できます。

MobSFは**diff/比較**分析と**VirusTotal**の統合も可能です（_MobSF/settings.py_にAPIキーを設定し、有効にする必要があります: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`）。`VT_UPLOAD`を`False`に設定すると、**ハッシュ**がファイルの代わりに**アップロード**されます。

### MobSFによるアシストされたダイナミック分析

**MobSF**は**Android**での**ダイナミック分析**にも非常に役立ちますが、その場合はホストにMobSFと**genymotion**をインストールする必要があります（VMやDockerでは機能しません）。_注意: **genymotion**で最初にVMを**起動**してから**MobSF**を起動する必要があります。_\
**MobSFダイナミックアナライザー**は以下が可能です:

* **アプリケーションデータのダンプ**（URL、ログ、クリップボード、自分が作成したスクリーンショット、"**Exported Activity Tester**"によって作成されたスクリーンショット、電子メール、SQLiteデータベース、XMLファイル、およびその他の作成されたファイル）。スクリーンショット以外はすべて自動的に行われますが、スクリーンショットを取得する場合は、スクリーンショットを取得したいタイミングで押すか、"**Exported Activity Tester**"を押してすべてのエクスポートされたアクティビティのスクリーンショットを取得する必要があります。
* **HTTPSトラフィックのキャプチャ**
* **Frida**を使用して**ランタイム情報**を取得する

**Android**のバージョンが5よりも新しい場合、**Fridaが自動的に開始**され、グローバル**プロキシ**設定が**トラフィックをキャプチャ**するように設定されます。テストされたアプリケーションからのトラフィックのみをキャプチャします。

**Frida**

デフォルトでは、いくつかのFridaスクリプトを使用して**SSLピニングのバイパス**、**ルート検出**、**デバッガー検出**、および**興味深いAPIの監視**も行います。\
MobSFは**エクスポートされたアクティビティを呼び出し**、それらの**スクリーンショットを取得**してレポートに保存することもできます。

ダイナミックテストを**開始**するには、緑色のボタン "**Start Instrumentation**" を押します。**Frida Live Logs**を押すと、Fridaスクリプトによって生成されたログが表示され、**Live API Monitor**を押すとフックされたメソッドへのすべての呼び出し、渡された引数、返された値が表示されます（これは "Start Instrumentation" を押した後に表示されます）。\
MobSFはまた、独自の**Fridaスクリプト**を読み込むことができます（Fridaスクリプトの結果をMobSFに送信するには `send()` 関数を使用します）。読み込むことができる**いくつかの事前書かれたスクリプト**もあります（`MobSF/DynamicAnalyzer/tools/frida_scripts/others/`に追加できます）、それらを選択して "**Load**" を押し、"**Start Instrumentation**" を押します（そのスクリプトのログを "**Frida Live Logs**" で確認できます）。

![](<../../.gitbook/assets/image (215).png>)

さらに、いくつかの補助的なFrida機能があります:

* **ロードされたクラスの列挙**: ロードされたすべてのクラスを表示します
* **文字列のキャプチャ**: アプリケーションを使用する際にキャプチャされたすべての文字列を表示します（非常にノイズが多い）
* **文字列比較のキャプチャ**: 非常に役立ちます。比較された2つの文字列と結果（TrueまたはFalse）を表示します。
* **クラスメソッドの列挙**: クラス名（例: "java.io.File"）を入力すると、そのクラスのすべてのメソッドを表示します。
* **クラスパターンの検索**: パターンに一致するクラスを検索します
* **クラスメソッドのトレース**: クラス全体をトレースします（クラスのすべてのメソッドの入力と出力を表示します）。デフォルトでは、MobSFはいくつかの興味深いAndroid APIメソッドをトレースします。

使用したい補助モジュールを選択したら、"**Start Intrumentation**" を押して、すべての出力を "**Frida Live Logs**" で確認できます。

**Shell**

Mobsfには、ダイナミック分析ページの一番下にいくつかの**adb**コマンド、**MobSFコマンド**、および一般的な**シェルコマンド**を備えたシェルが付属しています。いくつかの興味深いコマンド:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTPツール**

HTTPトラフィックがキャプチャされると、"**HTTP(S) Traffic**"の下にキャプチャされたトラフィックの見栄えが悪いビューが表示されるか、"**Start HTTPTools**"の緑のボタンで見栄えの良いビューが表示されます。2番目のオプションから、**キャプチャされたリクエスト**をBurpやOwasp ZAPなどの**プロキシ**に**送信**することができます。\
そのためには、_Burpを起動 -->_ _インターセプトをオフにする --> MobSB HTTPToolsでリクエストを選択_ --> "**Send to Fuzzer**"を押す --> _プロキシアドレスを選択_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

MobSFで動的解析を終えたら、"**Start Web API Fuzzer**"を押して、**HTTPリクエストをファズ**し、脆弱性を探すことができます。

{% hint style="info" %}
MobSFで動的解析を実行した後、プロキシ設定が誤って構成され、GUIから修正できない場合があります。プロキシ設定を修正するには、次の手順を実行します:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Inspeckageを使用したアシストされたダイナミック解析

[**Inspeckage**](https://github.com/ac-pm/Inspeckage)からツールを入手できます。\
このツールはいくつかの**フック**を使用して、**ダイナミック解析**を実行する際に**アプリケーション内で何が起こっているか**を知らせます。

{% content-ref url="inspeckage-tutorial.md" %}
[inspeckage-tutorial.md](inspeckage-tutorial.md)
{% endcontent-ref %}

### [Yaazhini](https://www.vegabird.com/yaazhini/)

これは**GUIを使用して静的解析を実行するための優れたツール**です

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、**ソースコード**または**パッケージ化されたAPK**内のいくつかの**セキュリティ関連のAndroidアプリケーションの脆弱性**を探すように設計されています。このツールはまた、いくつかの見つかった脆弱性を悪用するための「プルーフ・オブ・コンセプト」展開可能なAPKと**ADBコマンド**を作成することができます（公開されたアクティビティ、インテント、タップジャッキングなど）。Drozerと同様に、テストデバイスをルート化する必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* 簡単な参照のためにすべての抽出されたファイルを表示します
* APKファイルを自動的にJavaおよびSmali形式に逆コンパイルします
* 一般的な脆弱性と動作のためのAndroidManifest.xmlの分析
* 一般的な脆弱性と動作のための静的ソースコード分析
* デバイス情報
* インテント
* コマンドの実行
* SQLite参照
* ロギング参照
* コンテンツプロバイダ
* ブロードキャストレシーバ
* サービス参照
* ファイル参照
* 暗号参照
* ハードコードされた秘密情報
* URL
* ネットワーク接続
* SSL参照
* WebView参照
```
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERは、Windows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、.apkファイルを解析して脆弱性を検索するために使用されます。これは、APKを展開し、脆弱性を検出するための一連のルールを適用することによって行われます。

すべてのルールは`rules.json`ファイルに集約されており、各企業やテスターは必要なものを分析するために独自のルールを作成できます。

最新のバイナリを[ダウンロードページ](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAnは、モバイルアプリケーションに対する**静的コード解析**を実行する開発者、バグバウンティハンター、倫理的ハッカーを支援する**クロスプラットフォーム**ツールです\*。

コンセプトは、モバイルアプリケーションファイル（.apkまたは.ipaファイル）をStaCoAnアプリケーションにドラッグアンドドロップすると、視覚的でポータブルなレポートが生成されます。設定やワードリストを調整して、カスタマイズされた体験を得ることができます。

[最新リリースをダウンロード](https://github.com/vincentcox/StaCoAn/releases)：
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Frameworkは、Androidアプリケーション内の潜在的なセキュリティ脆弱性を見つけるのを手助けするAndroid脆弱性分析システムです。\
[Windows releases](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**は、Androidアプリケーションによって開発された潜在的な悪意のある振る舞いを検出し、ユーザーに警告することを主な目的とするツールです。

検出は、アプリケーションのDalvikバイトコードを**Smali**として表現し、[`androguard`](https://github.com/androguard/androguard)ライブラリを使用して**静的解析**を行います。

このツールは、電話識別子の流出、オーディオ/ビデオフローの傍受、PIMデータの変更、任意のコード実行など、**"悪い"アプリケーションの一般的な振る舞い**を探します。
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA\_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA**は**M**obile **A**pplication **R**everse engineering and **A**nalysis Frameworkの略称です。これは、一般的に使用されるモバイルアプリケーションのリバースエンジニアリングおよび分析ツールを組み合わせたツールで、OWASPモバイルセキュリティの脅威に対するモバイルアプリケーションのテストを支援します。その目的は、このタスクをモバイルアプリケーション開発者やセキュリティ専門家にとってより簡単で使いやすくすることです。

以下のことができます：

- 異なるツールを使用してJavaおよびSmaliコードを抽出する
- [smalisca](https://github.com/dorneanu/smalisca)、[ClassyShark](https://github.com/google/android-classyshark)、[androbugs](https://github.com/AndroBugs/AndroBugs\_Framework)、[androwarn](https://github.com/maaaaz/androwarn)、[APKiD](https://github.com/rednaga/APKiD)を使用してAPKを分析する
- 正規表現を使用してAPKからプライベート情報を抽出する
- マニフェストを分析する
- [pyssltest](https://github.com/moheshmohan/pyssltest)、[testssl](https://github.com/drwetter/testssl.sh)、[whatweb](https://github.com/urbanadventurer/WhatWeb)を使用して見つかったドメインを分析する
- [apk-deguard.com](http://www.apk-deguard.com)を介してAPKの難読化を解除する

### Koodous

マルウェアを検出するのに便利：[https://koodous.com/](https://koodous.com)

## コードの難読化/難読化解除

コードを難読化するために使用するサービスと構成によっては、秘密情報が難読化されるかどうかが異なることに注意してください。

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

**ProGuard**は、Javaコードを縮小し、最適化し、難読化するためのオープンソースのコマンドラインツールです。バイトコードを最適化し、未使用の命令を検出して削除することができます。ProGuardは無料のソフトウェアであり、GNU General Public Licenseバージョン2の下で配布されています。

ProGuardはAndroid SDKの一部として配布され、リリースモードでアプリケーションをビルドする際に実行されます。

出典：[https://en.wikipedia.org/wiki/ProGuard\_(software)](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

### [DexGuard](https://www.guardsquare.com/dexguard)

APKの難読化を解除するためのステップバイステップガイドは[こちら](https://blog.lexfo.fr/dexguard.html)

（そのガイドから）最後に確認したとき、Dexguardの動作モードは次のとおりでした：

- InputStreamとしてリソースをロードする
- それを復号化するためにFilterInputStreamを継承したクラスに結果をフィードする
- いくつかの無駄な難読化を行い、リバーサーの時間を数分無駄にする
- 復号化された結果をZipInputStreamにフィードしてDEXファイルを取得する
- 最終的に、`loadDex`メソッドを使用して結果のDEXをリソースとしてロードする

### [DeGuard](http://apk-deguard.com)

**DeGuardは、Androidの難読化ツールによって実行された難読化プロセスを逆転させます。これにより、コード検査やライブラリの予測を含む多数のセキュリティ分析が可能になります。**

難読化されたAPKを彼らのプラットフォームにアップロードできます。

### [Simplify](https://github.com/CalebFenton/simplify)

これは**一般的なAndroid難読化解除ツール**です。Simplifyはアプリを**仮想的に実行**してその動作を理解し、コードを最適化し、同じように動作するが人間が理解しやすいコードにします。各最適化タイプは単純で一般的なため、使用される難読化の具体的なタイプは問題ありません。

### [APKiD](https://github.com/rednaga/APKiD)

APKiDは、APKの作成方法に関する情報を提供します。多くの**コンパイラ**、**パッカー**、**難読化ツール**、およびその他の奇妙なものを識別します。これはAndroidの[_PEiD_](https://www.aldeid.com/wiki/PEiD)です。

### マニュアル

[このチュートリアルを読んで、**カスタム難読化を逆転する方法**について学びます](manual-deobfuscation.md)

## ラボ

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4bは、リバースエンジニアリングとマルウェア分析のための異なるセキュリティ愛好家や研究者からの最新のフレームワーク、チュートリアル、およびラボを含むubuntu-mateベースのAndroidセキュリティ仮想マシンです。

### OWASP

{% embed url="https://github.com/OWASP/owasp-mstg%0Ahttps://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06g-testing-network-communication" %}

### Gitリポジトリ

[https://github.com/riddhi-shree/nullCommunity/tree/master/Android](https://github.com/riddhi-shree/nullCommunity/tree/master/Android)\
[https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## 参考文献

詳細については、以下を参照してください：

- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) リソースの素晴らしいリスト
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Androidクイックコース
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)

## テストする

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加しましょう

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を最新の状態に保ちます

**最新のアナウンスメント**\
最新のバグバウンティの開始や重要なプラットフォームの更新情報を把握しましょう

[**Discord**](https://discord.com/invite/N3FrSbmwdy) に参加して、今日からトップハッカーと協力を始めましょう！

<details>

<summary><strong>**htARTE（HackTricks AWS Red Team Expert）**で**ゼロからヒーローまでのAWSハッキング**を学びましょう！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksを広告する**か**HackTricksをPDFでダウンロード**するには、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
- 独占的な[NFTs](https://opensea.io/collection/the-peass-family)である[**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)をフォローしましょう
- ハッキングのトリックを共有するために、[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する

</details>
