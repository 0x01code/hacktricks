# Androidアプリケーションの侵入テスト

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)をフォローする
- **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks)のGitHubリポジトリにPRを提出して、あなたのハッキングテクニックを共有する

</details>

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取るために[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加しましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加する

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を追いかける

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新について知る

**[Discord](https://discord.com/invite/N3FrSbmwdy)に参加して、今日からトップハッカーと協力しましょう！**

## Androidアプリケーションの基礎

Androidセキュリティに関連する**最も重要な部分やAndroidアプリケーションの中で最も危険なコンポーネントについて知る**には、このページを読むことを強くお勧めします：

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB（Android Debug Bridge）

これはAndroidデバイス（エミュレートされたものまたは物理的なもの）に接続するために必要な主要なツールです。\
**ADB**は、コンピューターからデバイスを**USB**または**ネットワーク**経由で制御することができます。このユーティリティは、ファイルの**コピー**、アプリの**インストール**と**アンインストール**、シェルコマンドの**実行**、データの**バックアップ**、ログの**読み取り**などを可能にします。

ADBの使用方法を学ぶために、次の[**ADBコマンド**](adb-commands.md)のリストを参照してください。

## Smali

時には、**アプリケーションコードを変更**して**隠された情報**にアクセスすることが興味深いことがあります（おそらくよく難読化されたパスワードやフラグ）。その後、APKを逆コンパイルしてコードを変更し、再コンパイルすることが興味深いかもしれません。\
[**このチュートリアル**では、APKを逆コンパイルし、Smaliコードを変更してAPKを再コンパイルする方法](smali-changes.md)を学ぶことができます。これは、**動的解析中に複数のテストの代替手段として非常に役立つ**場合があります。そのため、**常にこの可能性を念頭に置いておいてください**。

## その他の興味深いトリック

* [Playストアでの位置偽装](spoofing-your-location-in-play-store.md)
* **APKのダウンロード**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/), [https://github.com/kiber-io/apkd](https://github.com/kiber-io/apkd)
* デバイスからAPKを抽出:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
* [APKEditor](https://github.com/REAndroid/APKEditor)を使用して、すべての分割されたAPKとベースAPKをマージします。
```bash
mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 1 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
```
## 静的解析

まず、APKを解析するためには、デコンパイラを使用してJavaコードを確認する必要があります。\
[異なる利用可能なデコンパイラに関する情報はこちらを参照してください。](apk-decompilers.md)

### 興味深い情報を探す

APKの**strings**を見るだけで、**パスワード**、**URL**、**API**キー、**暗号化**、**Bluetooth UUID**、**トークン**など、興味深い情報を検索できます。コード実行の**バックドア**や認証バックドア（アプリにハードコードされた管理者資格情報）なども探してください。

**Firebase**

**Firebase URL**に特に注意し、それが適切に構成されているかどうかを確認してください。[Firebaseについての詳細情報とその悪用方法についてはこちらを参照してください。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本的な理解 - Manifest.xml、strings.xml

アプリケーションの**_Manifest.xml**_と**_**strings.xml**_**ファイルの検査により、潜在的なセキュリティ脆弱性が明らかになることがあります。これらのファイルには、デコンパイラを使用するか、APKファイルの拡張子を.zipに変更して解凍することでアクセスできます。

**Manifest.xml**から特定される**脆弱性**には次のものがあります：

* **デバッグ可能なアプリケーション**：_Manifest.xml_ファイルでデバッグ可能に設定されたアプリケーション（`debuggable="true"`）は、悪用につながる接続を許可するため、リスクがあります。デバッグ可能なアプリケーションの検出と悪用方法についての詳細は、デバイス上でデバッグ可能なアプリケーションを見つけて悪用するチュートリアルを参照してください。
* **バックアップ設定**：機密情報を扱うアプリケーションでは、`android:allowBackup="false"`属性を明示的に設定して、USBデバッグが有効になっている場合にadb経由での未承認のデータバックアップを防止する必要があります。
* **ネットワークセキュリティ**：_res/xml/_内のカスタムネットワークセキュリティ構成（`android:networkSecurityConfig="@xml/network_security_config"`）は、証明書ピンやHTTPトラフィック設定などのセキュリティ詳細を指定できます。特定のドメインのHTTPトラフィックを許可する例があります。
* **エクスポートされたアクティビティとサービス**：マニフェスト内のエクスポートされたアクティビティとサービスを特定すると、誤用される可能性のあるコンポーネントが明らかになります。動的テスト中のさらなる分析により、これらのコンポーネントをどのように悪用するかが明らかになります。
* **コンテンツプロバイダとFileProviders**：公開されたコンテンツプロバイダは、データへの未承認アクセスや変更を許可する可能性があります。FileProvidersの構成も検討する必要があります。
* **ブロードキャストレシーバとURLスキーム**：これらのコンポーネントは悪用される可能性があり、URLスキームが入力脆弱性のためにどのように管理されているかに特に注意する必要があります。
* **SDKバージョン**：`minSdkVersion`、`targetSDKVersion`、`maxSdkVersion`属性は、サポートされているAndroidバージョンを示し、セキュリティ上の理由から古い脆弱なAndroidバージョンをサポートしないことの重要性を強調します。

**strings.xml**ファイルからは、APIキー、カスタムスキーマ、その他の開発者ノートなどの機密情報が見つかる場合があり、これらのリソースを注意深く確認する必要があります。

### タップジャッキング

**タップジャッキング**は、**悪意のあるアプリケーション**が起動し、**被害者アプリケーションの上に配置**される攻撃です。被害者アプリを視覚的に隠すと、ユーザーインターフェースが設計され、ユーザーがそれとやり取りするように誤誘導され、その間に相互作用を被害者アプリに渡します。\
実際には、ユーザーが自分が実際に被害者アプリでアクションを実行していることを知らないようにしています。

詳細は以下で確認できます：

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### タスクハイジャッキング

`launchMode`が**`singleTask`**に設定され、`taskAffinity`が定義されていない**アクティビティ**は、タスクハイジャッキングの脆弱性があります。つまり、**アプリケーション**がインストールされ、実際のアプリケーションよりも先に起動されると、実際のアプリケーションのタスクを**ハイジャック**できます（ユーザーは実際のアプリケーションを使用していると思い込んで**悪意のあるアプリケーションとやり取り**している可能性があります）。

詳細は以下で確認できます：

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### 安全でないデータ保存

**内部ストレージ**

Androidでは、内部ストレージに保存されたファイルは、それを作成した**アプリケーションだけがアクセス**できるように**設計**されています。このセキュリティ対策はAndroidオペレーティングシステムによって強制され、ほとんどのアプリケーションのセキュリティニーズには一般的に適しています。ただし、開発者は時々、`MODE_WORLD_READABLE`や`MODE_WORLD_WRITABLE`などのモードを利用して、異なるアプリケーション間でファイルを共有することがあります。しかし、これらのモードは他のアプリケーションによるこれらのファイルへのアクセスを制限しない可能性があります。

1. **静的解析：**
* `MODE_WORLD_READABLE`や`MODE_WORLD_WRITABLE`の使用が**注意深く検討**されていることを**確認**してください。これらのモードは、ファイルを**意図しないかつ未承認のアクセス**にさらす可能性があります。
2. **動的解析：**
* アプリケーションによって作成されたファイルに設定された**アクセス許可**を確認してください。特に、ファイルが**世界中で読み取りまたは書き込み可能**に設定されているかどうかを**確認**してください。これは、デバイスにインストールされている**どのアプリケーション**でも、その出自や意図に関係なく、これらのファイルを**読み取ったり変更**したりできる可能性があるため、重大なセキュリティリスクを引き起こす可能性があります。

**外部ストレージ**

外部ストレージ（SDカードなど）のファイルを扱う際には、次の注意が必要です：

1. **アクセシビリティ**：
* 外部ストレージ上のファイルは**グローバルに読み取りおよび書き込み可能**です。つまり、どのアプリケーションやユーザーでもこれらのファイルにアクセスできます。
2. **セキュリティ上の懸念**：
* アクセスが容易であるため、外部ストレージに**機密情報を保存しない**ことが推奨されています。
* 外部ストレージは取り外し可能であり、どのアプリケーションでもアクセスできるため、セキュリティが低くなります。
3. **外部ストレージからのデータの取り扱い**：
* 外部ストレージから取得したデータには**入力検証を常に実行**してください。これは、データが信頼できないソースから取得されたものであるため、重要です。
* 外部ストレージから実行可能ファイルやクラスファイルを取得し、動的に読み込むことは強く推奨されません。
* アプリケーションが外部ストレージから実行可能ファイルを取得する必要がある場合は、これらのファイルが**署名され、暗号的に検証**されることを確認してから、これらのファイルが動的に読み込まれる前に重要です。

外部ストレージは`/storage/emulated/0`、`/sdcard`、`/mnt/sdcard`で**アクセス**できます。

{% hint style="info" %}
Android 4.4（**API 17**）以降、SDカードには、アプリケーションからそのアプリケーション専用のディレクトリにアクセスを制限するディレクトリ構造があります。これにより、悪意のあるアプリケーションが他のアプリケーションのファイルを読み取ったり書き込んだりすることが防止されます。
{% endhint %}

**クリアテキストで保存された機密データ**

* **共有プリファレンス**：Androidは、各アプリケーションが`/data/data/<packagename>/shared_prefs/`パスに簡単にxmlファイルを保存できるようにし、そのフォルダーにクリアテキストで機密情報を見つけることができる場合があります。
* **データベース**：Androidは、各アプリケーションが`/data/data/<packagename>/databases/`パスに簡単にsqliteデータベースを保存できるようにし、そのフォルダーにクリアテキストで機密情報を見つけることができる場合があります。

### 破損したTLS

**すべての証明書を受け入れる**

何らかの理由で、開発者は、たとえばホスト名が一致しない場合でも、以下のようなコード行で**すべての証明書を受け入れる**ことがあります：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
### 破損した暗号化

**鍵管理プロセスの不備**

一部の開発者は、機密データをローカルストレージに保存し、コード内でハードコード化/予測可能なキーで暗号化しています。これは行うべきではありません。逆向きの操作により、攻撃者が機密情報を抽出できる可能性があります。

**安全でないおよび/または非推奨のアルゴリズムの使用**

開発者は、**非推奨のアルゴリズム**を使用して**認証チェック**、**データの保存**または**送信**を行うべきではありません。これらのアルゴリズムの一部には、RC4、MD4、MD5、SHA1などがあります。たとえばパスワードを保存するために**ハッシュ**が使用されている場合、**ソルト**とともにハッシュブルートフォース**耐性**を持つべきです。

### その他のチェック

* **APKを難読化**することをお勧めします。これにより、逆向きの作業が難しくなります。
* アプリが機密情報を扱う場合（銀行アプリなど）、モバイルがルート化されているかどうかを確認し、それに応じて対処するべきです。
* アプリが機密情報を扱う場合（銀行アプリなど）、エミュレータが使用されていないかを確認すべきです。
* アプリが機密情報を扱う場合（銀行アプリなど）、実行前に**自己整合性を確認**するべきです。
* [**APKiD**](https://github.com/rednaga/APKiD)を使用して、APKのビルドに使用されたコンパイラ/パッカー/難読化プログラムを確認します。

### React Nativeアプリケーション

ReactアプリケーションのJavaScriptコードに簡単にアクセスする方法については、次のページを参照してください：

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Xamarinアプリケーション

XamarinアプリケーションのC#コードに簡単にアクセスする方法については、次のページを参照してください：

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### スーパーパックされたアプリケーション

この[**ブログ投稿**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)によると、スーパーパックはアプリケーションのコンテンツを1つのファイルに圧縮するメタアルゴリズムです。ブログでは、これらの種類のアプリを解凍するアプリを作成する可能性について説明しており、**アプリケーションを実行し、ファイルシステムから解凍されたファイルを収集する**というより速い方法についても説明しています。

### 自動静的コード解析

ツール[**mariana-trench**](https://github.com/facebook/mariana-trench)は、アプリケーションのコードをスキャンして**脆弱性**を見つけることができます。このツールには、**既知のソース**（ユーザーによって**制御される入力**の**場所**をツールに示す）**シンク**（悪意のあるユーザー入力が損害を引き起こす可能性のある**危険な場所**をツールに示す）および**ルール**が含まれています。これらのルールは、**ソース-シンク**の**組み合わせ**を示し、脆弱性を示します。

この知識を活用して、**mariana-trenchはコードをレビューし、可能な脆弱性を見つけます**。

### 漏洩した秘密情報

アプリケーションには、発見できるかもしれない秘密情報（APIキー、パスワード、隠されたURL、サブドメインなど）が含まれている場合があります。[https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)などのツールを使用できます。

### バイオメトリック認証のバイパス

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### その他の興味深い機能

* **コード実行**: `Runtime.exec(), ProcessBuilder(), native code:system()`
* **SMSの送信**: `sendTextMessage, sendMultipartTestMessage`
* `native`と宣言された**ネイティブ機能**: `public native, System.loadLibrary, System.load`
* [**ネイティブ機能の逆向き**の方法を学ぶには、これを読んでください](reversing-native-libraries.md)

### **その他のテクニック**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルと課題に深く入り込むコンテンツに参加しましょう

**リアルタイムのハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を最新の状態に保ちます

**最新のアナウンス**\
最新のバグバウンティの開始や重要なプラットフォームの更新情報を把握しましょう

**[Discord](https://discord.com/invite/N3FrSbmwdy)に参加**して、今日からトップハッカーと協力を始めましょう！

***

## 動的解析

> まず、アプリケーションとすべての環境（主にBurp CA証明書、Drozer、Frida）をインストールできる環境が必要です。したがって、ルート化されたデバイス（エミュレートされているかどうかに関係なく）を強くお勧めします。

### オンライン動的解析

[https://appetize.io/](https://appetize.io)で**無料アカウント**を作成できます。このプラットフォームを使用すると、APKを**アップロード**して**実行**できるため、APKの動作を確認するのに便利です。

Web上でアプリケーションのログを表示し、**adb**を介して接続することもできます。

![](<../../.gitbook/assets/image (831).png>)

ADB接続を使用すると、エミュレータ内で**Drozer**と**Frida**を使用できます。

### ローカル動的解析

#### エミュレータを使用する

* [**Android Studio**](https://developer.android.com/studio)（**x86**および**arm**デバイスを作成でき、[**最新のx86** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)バージョンでは、遅いarmエミュレータを必要とせずにARMライブラリをサポートしています）。
* このページで設定方法を学びます：

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **（無料版:** Personal Edition、アカウントを作成する必要があります。_潜在的なエラーを回避するために_ _**VirtualBoxを使用した**バージョンをダウンロードすることをお勧めします。_)
* [**Nox**](https://es.bignox.com)（無料ですが、FridaやDrozerをサポートしていません）。

{% hint style="info" %}
どのプラットフォームでも新しいエミュレータを作成する際には、画面が大きいほどエミュレータが遅くなることに注意してください。可能であれば小さな画面を選択してください。
{% endhint %}

Genymotionに**Googleサービス**（AppStoreなど）をインストールするには、次の画像の赤でマークされたボタンをクリックする必要があります：

![](<../../.gitbook/assets/image (277).png>)

また、Genymotionの**Android VMの構成**で**Bridge Network mode**を選択できます（これは、他のVMからAndroid VMに接続する場合に便利です）。

#### 物理デバイスを使用する

デバッグオプションを有効にし、ルート化できると便利です：

1. **設定**。
2. （Android 8.0以降）**システム**を選択します。
3. **端末について**を選択します。
4. **ビルド番号**を7回押します。
5. 戻り、**開発者オプション**が表示されます。

> アプリケーションをインストールした後、最初に行うべきことは、それを試して調査し、どのように動作し、それに慣れるかを調べることです。\
> **MobSF動的解析+pidcatを使用してこの初期の動的解析を実行**することをお勧めします。これにより、**アプリケーションの動作**を学びながら、MobSFが後でレビューできる**興味深いデータ**を**キャプチャ**します。
### 意図しないデータ漏洩

**ログ**

開発者は、**デバッグ情報**を公に公開することに注意する必要があります。これは機密データの漏洩につながる可能性があります。ツール[**pidcat**](https://github.com/JakeWharton/pidcat)と`adb logcat`を使用して、アプリケーションログを監視し、機密情報を特定および保護することが推奨されています。**Pidcat**は使いやすさと可読性の点で好まれています。

{% hint style="warning" %}
**Android 4.0より新しいバージョン**から、**アプリケーションは自分自身のログにのみアクセス**できるようになりました。つまり、アプリケーションは他のアプリのログにアクセスできません。\
とはいえ、**機密情報を記録しない**ことが依然として推奨されています。
{% endhint %}

**コピー/ペーストバッファのキャッシング**

Androidの**クリップボードベース**のフレームワークはアプリ内でのコピー＆ペースト機能を可能にしますが、他のアプリケーションがクリップボードにアクセスできるため、機密データが漏洩する危険性があります。アプリケーション内のクレジットカード情報などの機密セクションでのコピー/ペースト機能を**無効にする**ことは重要です。

**クラッシュログ**

アプリケーションが**クラッシュ**して**ログを保存**する場合、これらのログは攻撃者に役立つ可能性があります、特にアプリケーションを逆コンパイルできない場合。このリスクを軽減するために、クラッシュ時のログ記録を避け、ログをネットワーク経由で送信する場合は、セキュリティのためにSSLチャネルを介して送信されるようにします。

ペンテスターとして、これらのログを確認してみてください。

**第三者への送信されるアナリティクスデータ**

アプリケーションはしばしばGoogle AdSenseなどのサービスを統合しますが、開発者による不適切な実装により、機密データが**漏洩**する可能性があります。潜在的なデータ漏洩を特定するために、アプリケーションのトラフィックを**傍受**し、第三者サービスに送信される機密情報をチェックすることが望ましいです。

### SQLiteデータベース

ほとんどのアプリケーションは**内部SQLiteデータベース**を使用して情報を保存します。ペンテスト中に作成された**データベース**、**テーブル**および**列**の名前、および保存されている**データ**を確認してください。なぜなら、**機密情報**（脆弱性となる可能性がある）が見つかるかもしれません。\
データベースは`/data/data/the.package.name/databases`に配置されるべきです。例：`/data/data/com.mwr.example.sieve/databases`

データベースが機密情報を保存しており、**暗号化**されているが、アプリケーション内に**パスワード**が見つかる場合、それでも**脆弱性**となります。

`.tables`を使用してテーブルを列挙し、`.schema <table_name>`を使用してテーブルの列を列挙します。

### Drozer（エクスプロイトアクティビティ、コンテンツプロバイダー、サービス）

[Drozerドキュメント](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)によると、**Drozer**を使用すると、Androidアプリの役割を**担当**し、他のアプリとやり取りすることができます。インストールされたアプリケーションができることは何でもできます。Androidのプロセス間通信（IPC）メカニズムを利用したり、基礎となるオペレーティングシステムとやり取りすることができます。\
Drozerは、後述のセクションで学ぶように、**エクスポートされたアクティビティ、エクスポートされたサービス、コンテンツプロバイダー**をエクスプロイトするための便利なツールです。

### エクスポートされたアクティビティのエクスプロイト

[**Androidアクティビティとは何かを確認したい場合は、こちらを読んでください。**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、アクティビティのコードは**`onCreate`**メソッドから開始されることを覚えておいてください。

**認証バイパス**

アクティビティがエクスポートされている場合、外部アプリからその画面を呼び出すことができます。したがって、**機密情報**を含むアクティビティが**エクスポート**されている場合、**認証**メカニズムを**バイパス**してアクセスすることができます。

[**Drozerを使用してエクスポートされたアクティビティをエクスプロイトする方法を学びます。**](drozer-tutorial/#activities)

adbからもエクスポートされたアクティビティを起動できます：

* パッケージ名はcom.example.demo
* エクスポートされたアクティビティ名はcom.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSFは、アクティビティの`android:launchMode`で**singleTask/singleInstance**を使用することを悪意のあるものとして検出しますが、[こちら](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)によると、これは古いバージョン（APIバージョン< 21）でのみ危険だとされています。

{% hint style="info" %}
認可バイパスが常に脆弱性であるわけではないことに注意してください。バイパスの動作方法や露出される情報によって異なります。
{% endhint %}

**機密情報の漏洩**

**アクティビティは結果を返すこともできます**。エクスポートされた保護されていないアクティビティが**`setResult`**メソッドを呼び出し、**機密情報を返す**場合、機密情報の漏洩が発生します。

#### タップジャッキング

タップジャッキングが防止されていない場合、エクスポートされたアクティビティを悪用して**ユーザーに予期しないアクションを実行**させることができます。[**タップジャッキングとは何かについて詳しくはリンクを参照してください**](./#tapjacking)。

### コンテンツプロバイダの悪用 - 機密情報へのアクセスと操作

[**コンテンツプロバイダとは何かを確認したい場合はこちらを読んでください。**](android-applications-basics.md#content-provider)\
コンテンツプロバイダは基本的にデータを**共有**するために使用されます。アプリに利用可能なコンテンツプロバイダがある場合、そこから**機密**データを**抽出**することができるかもしれません。また、**SQLインジェクション**や**パストラバーサル**をテストすることも興味深いです。なぜなら、これらは脆弱性を持っている可能性があるからです。

[**Drozerを使用してコンテンツプロバイダを悪用する方法を学ぶ**](drozer-tutorial/#content-providers)

### **サービスの悪用**

[**サービスとは何かを確認したい場合はこちらを読んでください。**](android-applications-basics.md#services)\
サービスのアクションは基本的に`onStartCommand`メソッドで開始されます。

サービスは基本的にデータを**受信**し、それを**処理**して**応答**（またはしない）するものです。したがって、アプリケーションがいくつかのサービスをエクスポートしている場合は、それが何をしているかを理解するために**コード**を確認し、機密情報の抽出、認証措置のバイパスなどを**動的に**テストする必要があります。\
[**Drozerを使用してサービスを悪用する方法を学ぶ**](drozer-tutorial/#services)

### **ブロードキャストレシーバの悪用**

[**ブロードキャストレシーバとは何かを確認したい場合はこちらを読んでください。**](android-applications-basics.md#broadcast-receivers)\
ブロードキャストレシーバのアクションは基本的に`onReceive`メソッドで開始されます。

ブロードキャストレシーバは特定の種類のメッセージを待機しています。レシーバがメッセージを処理する方法によって、脆弱性が発生する可能性があります。\
[**Drozerを使用してブロードキャストレシーバを悪用する方法を学ぶ**](./#exploiting-broadcast-receivers)

### **スキーム / ディープリンクの悪用**

ディープリンクを手動で検索したり、MobSFのようなツールや[このようなスクリプト](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)を使用して検索できます。\
**スキーム**を宣言して**adb**や**ブラウザ**を使用して**開く**ことができます：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_パッケージ名を**省略することができる**ことに注意してください。モバイルは自動的にそのリンクを開くべきアプリを呼び出します。_

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**実行されるコード**

**アプリで実行されるコード**を見つけるには、ディープリンクで呼び出されるアクティビティに移動し、**`onNewIntent`** 関数を検索します。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**機密情報**

ディープリンクを見つけるたびに、URLパラメータを介して機密データ（パスワードなど）を受信していないかどうかを確認してください。なぜなら、他のアプリケーションがディープリンクをなりすましてそのデータを盗む可能性があるからです！

**パス内のパラメータ**

URLのパス内でパラメータを使用しているディープリンクがあるかどうかも**確認する必要があります**。例えば、`https://api.example.com/v1/users/{username}` のような場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value` のようにパストラバーサルを強制できます。\
アプリ内で正しいエンドポイントを見つけた場合、**オープンリダイレクト**（パスの一部がドメイン名として使用される場合）、**アカウント乗っ取り**（CSRFトークンなしでユーザーの詳細を変更でき、脆弱なエンドポイントが正しいメソッドを使用している場合）などを引き起こす可能性があります。詳細は[こちら](http://dphoeniixx.com/2020/12/13-2/)。

**さらなる例**

リンクに関する興味深いバグ報奨レポートは[こちら](https://hackerone.com/reports/855618)。

### トランスポート層の検査と検証の失敗

* Androidアプリケーションは、**証明書を適切に検査しない**ことがあります。これらのアプリケーションが警告を見落としたり、自己署名証明書を受け入れたり、一部の場合にはHTTP接続に戻ったりするのは一般的です。
* SSL/TLSハンドシェイク中の**交渉が弱い場合**があり、安全でない暗号スイートが使用されています。この脆弱性により、接続は中間者攻撃に対して脆弱になり、攻撃者がデータを復号化できるようになります。
* アプリケーションがセキュアチャネルを使用して認証した後、他のトランザクションで非セキュアチャネルを介して通信すると、**プライベート情報の漏洩**のリスクがあります。このアプローチは、セッションクッキーやユーザーの詳細などの機密データを悪意のあるエンティティによる傍受から保護できません。

#### 証明書の検証

**証明書の検証**に焦点を当てます。サーバーの証明書の整合性を検証してセキュリティを強化する必要があります。これは重要です。なぜなら、安全でないTLS構成や暗号化されていないチャネルを介して機密データを送信することは重大なリスクを引き起こす可能性があるからです。サーバー証明書の検証と脆弱性の対処の詳細な手順については、[**このリソース**](https://manifestsecurity.com/android-application-security-part-10/)が包括的なガイダンスを提供しています。

#### SSL Pinning

SSL Pinningは、アプリケーションがアプリケーション内に保存された既知のコピーに対してサーバーの証明書を検証するセキュリティ対策です。この方法は、MITM攻撃を防ぐために不可欠です。SSL Pinningの実装は、機密情報を扱うアプリケーションに強く推奨されます。

#### トラフィック検査

HTTPトラフィックを検査するには、プロキシツールの証明書を**インストールする必要があります**（例：Burp）。この証明書をインストールしないと、暗号化されたトラフィックはプロキシを介して表示されない場合があります。カスタムCA証明書をインストールする手順についてのガイドは、[**こちらをクリック**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)してください。

**APIレベル24以上を対象とする**アプリケーションでは、トラフィックを暗号化して検査するために、ネットワークセキュリティ構成を変更してプロキシのCA証明書を受け入れる必要があります。この手順は、暗号化されたトラフィックを検査するために重要です。ネットワークセキュリティ構成を変更する手順については、[**このチュートリアル**](make-apk-accept-ca-certificate.md)を参照してください。

#### SSL Pinningのバイパス

SSL Pinningが実装されている場合、HTTPSトラフィックを検査するためには、次のようなさまざまな方法があります：

* [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)を使用してSSL Pinningをバイパスするために**apkを自動的に変更**します。このオプションの最大の利点は、SSL Pinningをバイパスするためにルート権限が必要ないことですが、アプリケーションを削除して新しいものを再インストールする必要があり、これが常に機能するわけではないことです。
* この保護をバイパスするために**Frida**（以下で説明）を使用することができます。Burp+Frida+Genymotionの使用方法については、[こちらのガイド](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)を参照してください。
* [**objection**](frida-tutorial/objection-tutorial.md)を使用してSSL Pinningを自動的にバイパスすることもできます：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* **MobSFダイナミック解析**を使用してSSL Pinningを自動的にバイパスすることもできます（以下で説明）。
* キャプチャしていないトラフィックがあると考える場合は、**iptablesを使用してトラフィックをburpに転送**することができます。このブログを参照してください：[https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 一般的なWeb脆弱性の検索

アプリケーション内で一般的なWeb脆弱性を検索することも重要です。これらの脆弱性の特定と緩和に関する詳細な情報は、この要約の範囲を超えて詳細に説明されています。

### Frida

[Frida](https://www.frida.re)は、開発者、リバースエンジニア、セキュリティ研究者向けの動的インストルメンテーションツールキットです。\
**実行中のアプリケーションにアクセスして、実行時にメソッドをフックして動作を変更したり、値を変更したり、値を抽出したり、異なるコードを実行したりできます。**\
Androidアプリケーションのペントestingを行う場合は、Fridaの使用方法を知っておく必要があります。

* Fridaの使用方法を学ぶ：[**Fridaチュートリアル**](frida-tutorial/)
* Fridaを使用したアクションのための「GUI」：[**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
* OjectionはFridaの使用を自動化するのに最適です：[**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
* ここでいくつかの素晴らしいFridaスクリプトを見つけることができます：[**https://codeshare.frida.re/**](https://codeshare.frida.re)
* アンチデバッギング/アンチ-Fridaメカニズムをバイパスしようとする場合は、Fridaを読み込む方法を示した[https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)（ツール[linjector](https://github.com/erfur/linjector-rs)）

### **メモリのダンプ - Fridump**

アプリケーションがパスワードやニーモニックなどの機密情報を保存すべきでないメモリ内に保存していないかどうかを確認してください。

[**Fridump3**](https://github.com/rootbsd/fridump3)を使用して、アプリのメモリをダンプできます：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これにより、./dumpフォルダーにメモリがダンプされ、そこで次のようにgrepを使用できます：

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Keystore内の機密データ**

Androidでは、Keystoreは機密データを保存するのに最適な場所ですが、十分な権限があれば**アクセス可能**です。アプリケーションはここに**平文の機密データ**を保存する傾向があるため、ペンテストではrootユーザーまたはデバイスに物理アクセス権限を持つ者がこのデータを盗むことができるかどうかをチェックする必要があります。

アプリがKeystoreにデータを保存していたとしても、データは暗号化されるべきです。

Keystore内のデータにアクセスするには、このFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **指紋認証/生体認証のバイパス**

以下のFridaスクリプトを使用すると、Androidアプリケーションが実行している可能性がある**特定の機密領域を保護するために行われる指紋認証**を**バイパス**することができます：

{% code overflow="wrap" %}
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **背景画像**

アプリケーションをバックグラウンドに置くと、Androidはアプリケーションの**スナップショット**を保存します。そのため、前景に復元されるとアプリケーションよりも先に画像の読み込みが開始され、アプリがより速く読み込まれたように見えます。

ただし、このスナップショットに**機密情報**が含まれている場合、スナップショットにアクセス権を持つ者がその情報を**盗む**可能性があります（スナップショットにアクセスするにはルート権限が必要です）。

スナップショットは通常、以下の場所に保存されています：**`/data/system_ce/0/snapshots`**

Androidは、FLAG\_SECURE** レイアウトパラメータを設定することで、スクリーンショットのキャプチャを**防止**する方法を提供しています。このフラグを使用すると、ウィンドウの内容がセキュアとして扱われ、スクリーンショットに表示されたり、非セキュアなディスプレイで表示されたりするのを防ぎます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Androidアプリケーションアナライザー**

このツールは、ダイナミック解析中にさまざまなツールを管理するのに役立ちます：[https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### インテントインジェクション

開発者はしばしば、これらのインテントを処理し、`startActivity(...)`や`sendBroadcast(...)`などのメソッドに渡すアクティビティ、サービス、およびブロードキャストレシーバーなどのプロキシコンポーネントを作成しますが、これは危険です。

攻撃者がこれらのインテントを誤誘導して非公開のアプリコンポーネントをトリガーしたり、機密コンテンツプロバイダーにアクセスしたりすることを許可することによる危険があります。注目すべき例は、`WebView`コンポーネントが`Intent.parseUri(...)`を介してURLを`Intent`オブジェクトに変換し、それを実行することで、悪意のあるインテントインジェクションにつながる可能性があります。

### 要点

* **インテントインジェクション**は、Webのオープンリダイレクトの問題に類似しています。
* エクスプロイトは、`Intent`オブジェクトをエクストラとして渡すことにより、安全でない操作を実行するようにリダイレクトできます。
* 非公開のコンポーネントやコンテンツプロバイダーを攻撃者にさらす可能性があります。
* `WebView`のURLから`Intent`への変換は、意図しないアクションを容易にする可能性があります。

### Androidクライアントサイドインジェクションおよびその他

おそらくWebからこの種の脆弱性については知っているでしょう。Androidアプリケーションでこの種の脆弱性に特に注意する必要があります：

* **SQLインジェクション:** 動的クエリやコンテンツプロバイダーを扱う場合は、パラメータ化されたクエリを使用していることを確認してください。
* **JavaScriptインジェクション（XSS）:** すべてのWebViewsに対してJavaScriptとプラグインサポートが無効になっていることを確認してください（デフォルトで無効）。[詳細はこちら](webview-attacks.md#javascript-enabled)。
* **ローカルファイルインクルージョン:** WebViewsはファイルシステムへのアクセスが無効になっている必要があります（デフォルトで有効）- `(webview.getSettings().setAllowFileAccess(false);)。[詳細はこちら](webview-attacks.md#javascript-enabled)。
* **永続クッキー**: Androidアプリケーションがセッションを終了する場合、クッキーが取り消されないことがいくつかのケースであり、それがディスクに保存される可能性があります
* [**クッキーのSecureフラグ**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を追いかける

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新に関する情報を入手

**[Discord](https://discord.com/invite/N3FrSbmwdy)**に参加して、今日からトップハッカーと協力を始めましょう！

## 自動解析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静的解析**

![](<../../.gitbook/assets/image (866).png>)

アプリケーションの脆弱性評価を行うための素敵なWebベースのフロントエンドを使用します。ダイナミック解析も実行できます（ただし、環境を準備する必要があります）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSFは**Android**(apk)**、IOS**(ipa)**、およびWindows**(apx)アプリケーションを分析できます（_WindowsアプリケーションはWindowsホストにインストールされたMobSFから分析する必要があります_）。\
また、**Android**または**IOS**アプリのソースコードをZIPファイルに作成すると（アプリケーションのルートフォルダに移動し、すべてを選択してZIPファイルを作成する）、それも分析できます。

MobSFは**diff/比較**分析と**VirusTotal**の統合も可能です（_MobSF/settings.py_にAPIキーを設定して有効にする必要があります: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`）。`VT_UPLOAD`を`False`に設定すると、**ハッシュ**がファイルの代わりに**アップロード**されます。

### MobSFによるアシストされたダイナミック分析

**MobSF**は**Android**での**ダイナミック分析**にも非常に役立ちますが、その場合はホストにMobSFと**genymotion**をインストールする必要があります（VMやDockerでは機能しません）。_注意: **genymotion**で最初にVMを**起動**してから**MobSF**を起動する必要があります。_\
**MobSFダイナミックアナライザー**は以下が可能です:

* **アプリケーションデータのダンプ**（URL、ログ、クリップボード、自分が作成したスクリーンショット、"**Exported Activity Tester**"によって作成されたスクリーンショット、電子メール、SQLiteデータベース、XMLファイル、およびその他の作成されたファイル）。スクリーンショット以外はすべて自動的に行われますが、スクリーンショットを取得する場合は、スクリーンショットを取得したいタイミングで押すか、"**Exported Activity Tester**"を押してすべてのエクスポートされたアクティビティのスクリーンショットを取得する必要があります。
* **HTTPSトラフィックのキャプチャ**
* **Frida**を使用して**ランタイム情報**を取得する

**Android**のバージョンが**5より新しい**場合、**自動的にFridaを起動**し、グローバル**プロキシ**設定を**トラフィックのキャプチャ**に設定します。テストされたアプリケーションからのトラフィックのみをキャプチャします。

**Frida**

デフォルトでは、いくつかのFridaスクリプトを使用して**SSLピニングのバイパス**、**ルート検出**、**デバッガー検出**、および**興味深いAPIの監視**も行います。\
MobSFは**エクスポートされたアクティビティを呼び出し**、それらの**スクリーンショットを取得**してレポートに保存することもできます。

ダイナミックテストを**開始**するには、緑色のボタン "**Start Instrumentation**" を押します。**Frida Live Logs**を押すと、Fridaスクリプトによって生成されたログが表示され、**Live API Monitor**を押すとフックされたメソッドへのすべての呼び出し、渡された引数、返された値が表示されます（これは "Start Instrumentation" を押した後に表示されます）。\
MobSFはまた、独自の**Fridaスクリプト**を読み込むことができます（Fridayスクリプトの結果をMobSFに送信するには `send()` 関数を使用します）。また、読み込むことができる**いくつかの事前書かれたスクリプト**があります（`MobSF/DynamicAnalyzer/tools/frida_scripts/others/`に追加できます）、それらを**選択**して "**Load**" を押し、 "**Start Instrumentation**" を押します（そのスクリプトのログを "**Frida Live Logs**" で確認できます）。

![](<../../.gitbook/assets/image (419).png>)

さらに、いくつかの補助的なFrida機能があります:

* **ロードされたクラスの列挙**: ロードされたすべてのクラスを表示します
* **文字列のキャプチャ**: アプリケーションを使用する際にキャプチャされたすべての文字列を表示します（非常にノイジー）
* **文字列比較のキャプチャ**: 非常に役立ちます。比較された2つの文字列と結果（TrueまたはFalse）を表示します。
* **クラスメソッドの列挙**: クラス名（例: "java.io.File"）を入力すると、そのクラスのすべてのメソッドを表示します。
* **クラスパターンの検索**: パターンに一致するクラスを検索します
* **クラスメソッドのトレース**: クラス全体をトレースします（クラスのすべてのメソッドの入力と出力を表示します）。デフォルトでは、MobSFはいくつかの興味深いAndroid APIメソッドをトレースします。

使用したい補助モジュールを選択したら、**Start Intrumentation** を押して、すべての出力を **Frida Live Logs** で確認できます。

**Shell**

Mobsfには、ダイナミック分析ページの一番下にいくつかの**adb**コマンド、**MobSFコマンド**、および一般的な**シェルコマンド**を備えたシェルが付属しています。いくつかの興味深いコマンド:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTPツール**

HTTPトラフィックがキャプチャされると、"**HTTP(S) Traffic**"の下にキャプチャされたトラフィックの見栄えが悪いビューで表示されるか、"**Start HTTPTools**"の緑のボタンで見栄えの良いビューが表示されます。2番目のオプションから、**キャプチャされたリクエスト**をBurpやOwasp ZAPのような**プロキシ**に**送信**することができます。\
そのためには、_Burpを起動 -->_ _Interceptをオフにする --> MobSB HTTPToolsでリクエストを選択_ --> "**Send to Fuzzer**"を押す --> _プロキシアドレスを選択_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

MobSFで動的解析を終えたら、"**Start Web API Fuzzer**"を押して、**HTTPリクエストをファズ**し、脆弱性を探します。

{% hint style="info" %}
MobSFで動的解析を実行した後、プロキシ設定が誤って構成され、GUIから修正できない場合があります。プロキシ設定を修正するには、次の手順を実行します:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Inspeckageを使用したアシストされたダイナミック解析

[**Inspeckage**](https://github.com/ac-pm/Inspeckage)からツールを入手できます。\
このツールはいくつかの**フック**を使用して、**ダイナミック解析**を実行する際に**アプリケーション内で何が起こっているか**を知らせてくれます。

### [Yaazhini](https://www.vegabird.com/yaazhini/)

これは**GUIを備えた静的解析を実行するための優れたツール**です

![](<../../.gitbook/assets/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、**ソースコード**または**パッケージ化されたAPK**内のいくつかの**セキュリティ関連のAndroidアプリケーションの脆弱性**を探すように設計されています。このツールはまた、いくつか見つかった脆弱性を悪用するための「概念実証可能な」展開可能なAPKと**ADBコマンド**を作成することができます（公開されたアクティビティ、インテント、タップジャッキングなど）。Drozerと同様に、テストデバイスをルート化する必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* 簡単な参照のためにすべての抽出されたファイルを表示します
* APKファイルを自動的にJavaおよびSmali形式に逆コンパイルします
* 一般的な脆弱性と動作のためのAndroidManifest.xmlを分析します
* 一般的な脆弱性と動作のための静的ソースコード分析
* デバイス情報
* その他
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERは、Windows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、.apkファイルを解析して脆弱性を検出します。これは、APKを展開し、脆弱性を検出するための一連のルールを適用することによって行われます。

すべてのルールは`rules.json`ファイルに集約されており、各企業やテスターは必要なものを分析するために独自のルールを作成できます。

最新のバイナリを[ダウンロードページ](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (297).png>)

StaCoAnは、モバイルアプリケーションの[静的コード解析](https://en.wikipedia.org/wiki/Static\_program\_analysis)を実行する開発者、バグバウンティハンター、倫理的ハッカーを支援する**クロスプラットフォーム**ツールです。

このコンセプトは、モバイルアプリケーションファイル（.apkまたは.ipaファイル）をStaCoAnアプリケーションにドラッグアンドドロップすると、視覚的でポータブルなレポートが生成されます。設定やワードリストを調整して、カスタマイズされた体験を得ることができます。

[最新リリースをダウンロード](https://github.com/vincentcox/StaCoAn/releases)：
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Frameworkは、開発者やハッカーがAndroidアプリケーション内の潜在的なセキュリティ脆弱性を見つけるのに役立つAndroid脆弱性分析システムです。\
[Windows releases](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**は、Androidアプリケーションによって開発された潜在的な悪意のある振る舞いを検出し、ユーザーに警告することを主な目的とするツールです。

検出は、アプリケーションのDalvikバイトコード（**Smali**として表現される）の**静的解析**によって行われ、[`androguard`](https://github.com/androguard/androguard)ライブラリを使用しています。

このツールは、電話識別子の流出、オーディオ/ビデオフローの傍受、PIMデータの変更、任意のコード実行など、**"悪い"アプリケーションの一般的な振る舞い**を探します。
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (595).png>)

**MARA**は**M**obile **A**pplication **R**everse engineering and **A**nalysis Frameworkの略称です。これは、一般的に使用されるモバイルアプリケーションのリバースエンジニアリングおよび分析ツールを組み合わせたツールであり、OWASPモバイルセキュリティ脅威に対するモバイルアプリケーションのテストを支援します。その目的は、このタスクをモバイルアプリケーション開発者やセキュリティ専門家にとってより簡単で使いやすくすることです。

以下のことができます：

- 異なるツールを使用してJavaおよびSmaliコードを抽出する
- [smalisca](https://github.com/dorneanu/smalisca)、[ClassyShark](https://github.com/google/android-classyshark)、[androbugs](https://github.com/AndroBugs/AndroBugs_Framework)、[androwarn](https://github.com/maaaaz/androwarn)、[APKiD](https://github.com/rednaga/APKiD)を使用してAPKを分析する
- 正規表現を使用してAPKからプライベート情報を抽出する
- マニフェストを分析する
- [pyssltest](https://github.com/moheshmohan/pyssltest)、[testssl](https://github.com/drwetter/testssl.sh)、[whatweb](https://github.com/urbanadventurer/WhatWeb)を使用して見つかったドメインを分析する
- [apk-deguard.com](http://www.apk-deguard.com)を介してAPKの難読化を解除する

### Koodous

マルウェアを検出するのに便利：[https://koodous.com/](https://koodous.com)

## コードの難読化/難読化解除

コードを難読化するために使用するサービスと構成によっては、秘密情報が難読化されるかどうかが異なることに注意してください。

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

[Wikipedia](https://en.wikipedia.org/wiki/ProGuard\_\(software\))によると、**ProGuard**はJavaコードを縮小し、最適化し、難読化するオープンソースのコマンドラインツールです。バイトコードを最適化し、未使用の命令を検出して削除することができます。ProGuardはフリーソフトウェアであり、GNU General Public Licenseバージョン2の下で配布されています。

ProGuardはAndroid SDKの一部として配布され、リリースモードでアプリケーションをビルドする際に実行されます。

### [DexGuard](https://www.guardsquare.com/dexguard)

APKの難読化を解除するためのステップバイステップガイドは[こちら](https://blog.lexfo.fr/dexguard.html)にあります

(そのガイドから) 最後に確認したとき、Dexguardの動作モードは次のとおりでした：

- InputStreamとしてリソースをロードする
- それを復号化するためにFilterInputStreamを継承したクラスに結果をフィードする
- いくつかの無駄な難読化を行い、リバーサーの時間を数分無駄にする
- 復号化された結果をZipInputStreamにフィードしてDEXファイルを取得する
- 最終的に`loadDex`メソッドを使用して結果のDEXをリソースとしてロードする

### [DeGuard](http://apk-deguard.com)

**DeGuardはAndroidの難読化ツールによって実行された難読化プロセスを逆転させます。これにより、コード検査やライブラリの予測を含む多数のセキュリティ分析が可能になります。**

難読化されたAPKを彼らのプラットフォームにアップロードできます。

### [Simplify](https://github.com/CalebFenton/simplify)

これは**一般的なAndroid難読化解除ツール**です。Simplifyは**アプリを仮想的に実行**してその動作を理解し、コードを最適化しようとします。各最適化タイプは単純で一般的なため、使用される難読化の具体的なタイプは問題ありません。

### [APKiD](https://github.com/rednaga/APKiD)

APKiDは**APKの作成方法**に関する情報を提供します。多くの**コンパイラ**、**パッカー**、**難読化ツール**、およびその他の奇妙なものを識別します。これはAndroidの[_PEiD_](https://www.aldeid.com/wiki/PEiD)です。

### 手動

**[カスタム難読化を逆向きにする方法に関するトリックを学ぶためにこのチュートリアルを読んでください](manual-deobfuscation.md)**

## ラボ

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4bは、リバースエンジニアリングとマルウェア分析のための異なるセキュリティ愛好家や研究者からの最新のフレームワーク、チュートリアル、およびラボを含むubuntu-mateベースのAndroidセキュリティ仮想マシンです。

## 参考文献

* [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) これは素晴らしいリソースのリストです
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Androidクイックコース
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
* [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## まだ試していないもの

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加しましょう

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を最新の状態に保ちます

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新に関する情報を入手しましょう

**[Discord](https://discord.com/invite/N3FrSbmwdy)に参加**して、今日からトップハッカーと協力を始めましょう！
