# Androidアプリケーションの侵入テスト

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>こちら</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)コレクションを見る
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)をフォローする。
* **ハッキングトリックを共有するには、** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを送信してください。

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取るために[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加しましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加する

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を最新の状態に保つ

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新に関する情報を入手する

**[**Discord**](https://discord.com/invite/N3FrSbmwdy)に参加して、今日からトップハッカーと協力しましょう！**

## Androidアプリケーションの基礎

Androidセキュリティに関連する**最も重要な部分**やAndroidアプリケーションの中で**最も危険なコンポーネント**について知るために、このページを読むことを強くお勧めします：

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB（Android Debug Bridge）

これはAndroidデバイス（エミュレートされたものまたは物理的なもの）に接続するために必要な主要なツールです。\
**ADB**は、コンピューターからデバイスを**USB**または**ネットワーク**経由で制御することができます。このユーティリティは、ファイルの**コピー**、アプリの**インストール**と**アンインストール**、シェルコマンドの**実行**、データの**バックアップ**、ログの**読み取り**などを可能にします。

ADBの使用方法を学ぶために、次の[**ADBコマンド**](adb-commands.md)のリストを参照してください。

## Smali

時には、**アプリケーションコードを変更**して**隠された情報**にアクセスすることが興味深いことがあります（おそらくよく隠されたパスワードやフラグ）。その後、APKを逆コンパイルしてコードを変更し、再コンパイルすることが興味深いかもしれません。\
[**このチュートリアル**では、APKを逆コンパイルし、Smaliコードを変更してAPKを再コンパイルする方法](smali-changes.md)を学ぶことができます。これは、**ダイナミック解析中にいくつかのテストの代替手段として非常に役立つ**かもしれません。そのため、**常にこの可能性を念頭に置いておいてください**。

## その他の興味深いトリック

* [Play Storeでの位置のスプーフィング](spoofing-your-location-in-play-store.md)
* **APKのダウンロード**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* デバイスからAPKを抽出:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
## 静的解析

まず、APKを解析するためには、デコンパイラを使用してJavaコードを確認する必要があります。\
[**こちらを読んで、利用可能な異なるデコンパイラに関する情報を見つけてください**](apk-decompilers.md)。

### 興味深い情報を探す

APKの**strings**を見るだけで、**パスワード**、**URL**、**API**キー、**暗号化**、**Bluetooth UUID**、**トークン**などの興味深い情報を検索できます。さらに、コード実行の**バックドア**や認証バックドア（アプリにハードコードされた管理者資格情報）を探すこともできます。

**Firebase**

**Firebase URL**に特に注意し、構成が適切かどうかを確認してください。[Firebaseについての詳細情報とその悪用方法についてはこちらを参照してください。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本的な理解 - Manifest.xml、strings.xml

アプリケーションの _Manifest.xml_ および _strings.xml_ ファイルを調査することで、潜在的なセキュリティ脆弱性が明らかになる可能性があります。これらのファイルには、デコンパイラを使用するか、APKファイルの拡張子を.zipに変更して解凍することでアクセスできます。

**Manifest.xml** から特定される**脆弱性**には次のものがあります：

* **デバッグ可能なアプリケーション**： _Manifest.xml_ ファイルでデバッグ可能に設定されたアプリケーション（`debuggable="true"`）は、悪用につながる接続を許可するため、リスクをもたらします。デバッグ可能なアプリケーションの検出および悪用方法についての詳細は、デバイス上でデバッグ可能なアプリケーションを見つけて悪用するチュートリアルを参照してください。

* **バックアップ設定**：機密情報を扱うアプリケーションでは、`android:allowBackup="false"`属性を明示的に設定して、USBデバッグが有効になっている場合にadbを介した未承認のデータバックアップを防止する必要があります。

* **ネットワークセキュリティ**：_res/xml/_ でのカスタムネットワークセキュリティ構成（`android:networkSecurityConfig="@xml/network_security_config"`）は、証明書ピンやHTTPトラフィック設定などのセキュリティ詳細を指定できます。特定のドメインに対してHTTPトラフィックを許可する例があります。

* **エクスポートされたアクティビティとサービス**：マニフェストでエクスポートされたアクティビティとサービスを特定すると、誤用される可能性のあるコンポーネントが明らかになります。動的テスト中のさらなる分析により、これらのコンポーネントをどのように悪用するかが明らかになります。

* **コンテンツプロバイダとFileProviders**：公開されたコンテンツプロバイダは、データへの未承認アクセスや変更を許可する可能性があります。FileProvidersの構成も検討する必要があります。

* **ブロードキャストレシーバとURLスキーム**：これらのコンポーネントは悪用される可能性があり、URLスキームの管理方法に特に注意する必要があります。

* **SDKバージョン**：`minSdkVersion`、`targetSDKVersion`、`maxSdkVersion`属性は、サポートされているAndroidバージョンを示し、セキュリティ上の理由から古い脆弱性のあるAndroidバージョンをサポートしないことの重要性を強調します。

**strings.xml** ファイルからは、APIキー、カスタムスキーマ、およびその他の開発者ノートなどの機密情報が見つかる場合があり、これらのリソースを注意深く確認する必要があります。


### タップジャッキング

**タップジャッキング**は、**悪意のあるアプリケーション**が起動し、**被害者アプリケーションの上に配置**される攻撃です。被害者アプリを視覚的に隠すと、ユーザーがそれとやり取りしているように見せかけ、実際には被害者アプリでアクションを実行しています。\
実際には、ユーザーが自分が実際には被害者アプリでアクションを実行していることを知らないようにしています。

詳細は以下で確認できます：

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### タスクハイジャッキング

`launchMode` が **`singleTask`** に設定され、`taskAffinity` が定義されていない **アクティビティ** は、タスクハイジャッキングの脆弱性があります。これは、**アプリケーション**がインストールされ、実際のアプリケーションよりも先に起動された場合、実際のアプリケーションのタスクを**ハイジャック**できることを意味します（ユーザーは実際のアプリケーションを使用していると思い込んで、**悪意のあるアプリケーション**とやり取りしています）。

詳細は以下で確認できます：

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### 安全でないデータ保存

**内部ストレージ**

Androidでは、内部ストレージに保存されたファイルは、作成した**アプリケーション**のみが**アクセス**できるように**設計**されています。このセキュリティ対策はAndroidオペレーティングシステムによって強制されており、ほとんどのアプリケーションのセキュリティニーズには一般的に適しています。ただし、開発者は、`MODE_WORLD_READABLE` や `MODE_WORLD_WRITABLE` などのモードを利用して、異なるアプリケーション間でファイルを共有することがあります。しかし、これらのモードは、他のアプリケーション（悪意のあるものを含む）によるこれらのファイルへのアクセスを制限しません。

1. **静的解析：**
- `MODE_WORLD_READABLE` および `MODE_WORLD_WRITABLE` の使用が**注意深く検討**されていることを**確認**してください。これらのモードは、ファイルを**意図しないアクセス**に**さらす可能性**があります。

2. **動的解析：**
- アプリケーションによって作成されたファイルの**設定された権限**を確認してください。特に、ファイルが**世界中で読み取りまたは書き込み可能**に設定されているかどうかを**確認**してください。これは、デバイスにインストールされている**どのアプリケーション**でも、その起源や意図に関係なく、これらのファイルを**読み取ったり変更**したりできる可能性があるため、重大なセキュリティリスクをもたらす可能性があります。

**外部ストレージ**

外部ストレージ（SDカードなど）のファイルを扱う場合は、次の注意が必要です：

1. **アクセシビリティ**：
- 外部ストレージのファイルは**グローバルに読み取りおよび書き込み可能**です。つまり、どのアプリケーションやユーザーでもこれらのファイルにアクセスできます。

2. **セキュリティ上の懸念**：
- アクセスが容易であるため、外部ストレージに**機密情報を保存しない**ことが推奨されます。
- 外部ストレージは取り外し可能であり、どのアプリケーションでもアクセスできるため、セキュリティが低くなります。

3. **外部ストレージからのデータの取り扱い**：
- 外部ストレージから取得したデータには**入力検証**を常に行ってください。これは、データが信頼できないソースから取得されているため、重要です。
- 外部ストレージから実行可能ファイルやクラスファイルを取得し、動的に読み込むことは強く推奨されません。
- アプリケーションが外部ストレージから実行可能ファイルを取得する必要がある場合は、これらのファイルが**署名され、暗号的に検証**されることを確認してから、動的に読み込まれる前にこれらの手順を実行してください。この手順は、アプリケーションのセキュリティの整合性を維持するために重要です。

外部ストレージは `/storage/emulated/0`、`/sdcard`、`/mnt/sdcard` で**アクセス**できます。

{% hint style="info" %}
Android 4.4（**API 17**）以降、SDカードには、アプリケーションからそのアプリケーション専用のディレクトリにアクセスを**制限**するディレクトリ構造があります。これにより、悪意のあるアプリケーションが他のアプリケーションのファイルを読み取ったり書き込んだりすることが防止されます。
{% endhint %}

**クリアテキストで保存された機密データ**

* **共有プリファレンス**：Androidは、各アプリケーションが簡単にxmlファイルを保存できるようにし、そのパスは `/data/data/<packagename>/shared_prefs/` になります。時には、そのフォルダー内にクリアテキストで機密情報が見つかることがあります。
* **データベース**：Androidは、各アプリケーションが簡単にsqliteデータベースを保存できるようにし、そのパスは `/data/data/<packagename>/databases/` になります。時には、そのフォルダー内にクリアテキストで機密情報が見つかることがあります。

### 破損したTLS

**すべての証明書を受け入れる**

何らかの理由で、開発者は、たとえばホスト名が一致しない場合でも、以下のようなコード行で**すべての証明書を受け入れる**ことがあります：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
### 破損した暗号化

**鍵管理プロセスの不備**

一部の開発者は、機密データをローカルストレージに保存し、コード内でハードコード/予測可能なキーで暗号化しています。これは行うべきではありません。逆向きにすることで攻撃者が機密情報を抽出できる可能性があります。

**安全でないおよび/または非推奨のアルゴリズムの使用**

開発者は、**非推奨のアルゴリズム**を使用して**認証チェック**、**データの保存**または**送信**を行うべきではありません。これらのアルゴリズムの一部には、RC4、MD4、MD5、SHA1などがあります。たとえばパスワードを保存するためにハッシュが使用されている場合、ハッシュブルートフォース**耐性**を持つソルトとともに使用する必要があります。

### その他のチェック

* **APKを難読化**することをお勧めします。これにより、逆向きの労力が増え、攻撃者がアプリを解析するのが難しくなります。
* アプリが機密情報を扱う場合（銀行アプリなど）、モバイルがルート化されているかどうかを確認し、それに応じて対処する必要があります。
* アプリが機密情報を扱う場合（銀行アプリなど）、エミュレータが使用されていないかどうかを確認する必要があります。
* アプリが機密情報を扱う場合（銀行アプリなど）、変更されていないかを実行する前に**自己完全性を確認**する必要があります。
* APKをビルドする際に使用されたコンパイラ/パッカー/難読化ツールを確認するために[**APKiD**](https://github.com/rednaga/APKiD)を使用します。

### React Nativeアプリケーション

ReactアプリケーションのJavaScriptコードに簡単にアクセスする方法を学ぶには、次のページを読んでください：

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Xamarinアプリケーション

XamarinアプリケーションのC#コードに簡単にアクセスする方法を学ぶには、次のページを読んでください：

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### スーパーパックされたアプリケーション

この[**ブログ投稿**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)によると、スーパーパックはアプリケーションのコンテンツを1つのファイルに圧縮するメタアルゴリズムです。ブログでは、この種のアプリを解凍するアプリを作成する可能性について説明しており、**アプリケーションを実行してファイルシステムから解凍されたファイルを収集する**というより速い方法についても説明しています。

### 自動静的コード解析

ツール[**mariana-trench**](https://github.com/facebook/mariana-trench)は、アプリケーションのコードをスキャンして**脆弱性**を見つけることができます。このツールには、**既知のソース**（ユーザーによって**制御される入力**の**場所**をツールに示す）、**シンク**（悪意のあるユーザー入力が損害を引き起こす可能性のある**危険な場所**をツールに示す）および**ルール**が含まれています。これらのルールは、**ソース-シンク**の**組み合わせ**を示し、脆弱性を示します。

この知識を活用して、**mariana-trenchはコードを確認し、可能な脆弱性を見つけます**。

### 漏洩した秘密情報

アプリケーションには、発見できるかもしれない秘密情報（APIキー、パスワード、隠されたURL、サブドメインなど）が含まれている場合があります。[https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)などのツールを使用できます。

### バイオメトリック認証のバイパス

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### その他の興味深い機能

* **コード実行**: `Runtime.exec(), ProcessBuilder(), native code:system()`
* **SMSの送信**: `sendTextMessage, sendMultipartTestMessage`
* `native`と宣言された**ネイティブ機能**: `public native, System.loadLibrary, System.load`
* [**ネイティブ機能の逆向き**の方法を学ぶには、これを読んでください](reversing-native-libraries.md)

### **その他のテクニック**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルと課題に深く入り込むコンテンツに参加しましょう

**リアルタイムのハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を最新の状態に保ちます

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新情報を把握しましょう

**[Discord](https://discord.com/invite/N3FrSbmwdy)**に参加して、今日からトップハッカーと協力を始めましょう！

***

## 動的解析

> まず、アプリケーションとすべての環境（主にBurp CA証明書、Drozer、Frida）をインストールできる環境が必要です。したがって、ルート化されたデバイス（エミュレートされているかどうかに関係なく）を強くお勧めします。

### オンライン動的解析

[https://appetize.io/](https://appetize.io)で**無料アカウント**を作成できます。このプラットフォームを使用すると、APKを**アップロード**して**実行**できるため、APKの動作を確認するのに役立ちます。

Web上でアプリケーションのログを表示し、**adb**を介して接続することもできます。

![](<../../.gitbook/assets/image (60).png>)

ADB接続を介して、エミュレータ内で**Drozer**と**Frida**を使用できます。

### ローカル動的解析

#### エミュレータを使用する

* [**Android Studio**](https://developer.android.com/studio)（**x86**および**arm**デバイスを作成でき、[**最新のx86** ](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)バージョンは**遅いarmエミュレータを必要とせずにARMライブラリをサポート**しています）。
* このページで設定方法を学びます：

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **（無料版:** Personal Edition、アカウントを作成する必要があります。_潜在的なエラーを回避するために_ _**VirtualBoxを使用したバージョンをダウンロード**することをお勧めします。)
* [**Nox**](https://es.bignox.com)（無料ですが、FridaやDrozerをサポートしていません）。

{% hint style="info" %}
どのプラットフォームでも新しいエミュレータを作成する際には、画面が大きいほどエミュレータが遅くなることに注意してください。可能であれば小さな画面を選択してください。
{% endhint %}

Genymotionに**Googleサービス**（AppStoreなど）をインストールするには、次の画像の赤でマークされたボタンをクリックする必要があります：

![](<../../.gitbook/assets/image (200) (1).png>)

また、GenymotionのAndroid VMの**構成**で**Bridge Network mode**を選択できます（これは、他のVMからAndroid VMに接続する場合に便利です）。

#### 物理デバイスを使用する

**デバッグ**オプションを有効にし、できれば**ルート化**する必要があります。

1. **設定**。
2. （Android 8.0以降）**システム**を選択します。
3. **端末について**を選択します。
4. **ビルド番号**を7回押します。
5. 戻り、**開発者オプション**を見つけます。

> アプリケーションをインストールした後、最初に行うべきことは、それを試して調査し、その動作や機能を理解し、それに慣れることです。\
> **MobSF動的解析+pidcat**を使用してこの初期の動的解析を実行することをお勧めします。これにより、MobSFが後でレビューできる**興味深いデータ**を多く**キャプチャ**することができます。

### 意図しないデータ漏洩

**ログ**

デベロッパーは、公に**デバッグ情報**を公開することに注意する必要があります。これは機密データの漏洩につながる可能性があります。**pidcat**や`adb logcat`などのツールを使用して、アプリケーションのログを監視し、機密情報を特定して保護することをお勧めします。**Pidcat**は使いやすさと読みやすさで評価されています。

{% hint style="warning" %}
Android 4.0以降では、**アプリケーションは自分自身のログにのみアクセス**できます。したがって、アプリケーションは他のアプリのログにアクセスできません。\
それでも**機密情報を記録しない**ことをお勧めします。
{% endhint %}

**コピー/ペーストバッファのキャッシング**

Androidの**クリップボードベース**のフレームワークは、アプリでコピー/ペースト機能を有効にしますが、他のアプリケーションがクリップボードにアクセスできるため、機密データが漏洩するリスクがあります。クレジットカードの詳細など、アプリケーションの機密部分でコピー/ペースト機能を無効にすることが重要です。

**クラッシュログ**

アプリケーションが**クラッシュ**して**ログを保存**すると、特にアプリケーションが逆コンパイルできない場合、これらのログは攻撃者に役立ちます。このリスクを軽減するために、クラッシュ時のログ記録を避け、ログをネットワーク経由で送信する場合は、セキュリティのためにSSLチャネルを介して送信する必要があります。

ペンテスターとして、これらのログを確認してみてください。

**第三者に送信されるアナリティクスデータ**

アプリケーションはしばしばGoogle Adsenseなどのサービスを統合しますが、開発者の実装ミスにより機密データが漏洩する可能性があります。潜在的なデータ漏洩を特定するために、アプリケーションのトラフィックをインターセプトして、第三者サービスに送信される機密情報をチェックすることが望ましいです。

### SQLiteデータベース

ほとんどのアプリケーションは、情報を保存するために**内部SQLiteデータベース**を使用します。ペンテスト中に作成された**データベース**、**テーブル**および**列**の**名前**、および保存されている**すべてのデータ**を確認してください。そこには**機密情報**が含まれている可能性があります（これは脆弱性となります）。\
データベースは、`/data/data/the.package.name/databases`のように配置されるべきです。例：`/data/data/com.mwr.example.sieve/databases`

データベースが機密情報を保存しており、**暗号化**されているが、アプリケーション内で**パスワード**を見つけることができる場合、それでも**
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSFは、アクティビティの`android:launchMode`として_singleTask/singleInstance_の使用を悪意のあるものとして検出しますが、[こちら](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)によると、これは古いバージョン（APIバージョン< 21）でのみ危険だとされています。

{% hint style="info" %}
認可バイパスが常に脆弱性であるわけではないことに注意してください。バイパスの動作方法や露出される情報によって異なります。
{% endhint %}

**機密情報の漏洩**

**アクティビティは結果を返すこともできます**。エクスポートされた保護されていないアクティビティが**`setResult`**メソッドを呼び出し、**機密情報を返す**場合、機密情報の漏洩が発生します。

#### タップジャッキング

タップジャッキングが防止されていない場合、エクスポートされたアクティビティを悪用して**ユーザーに予期しないアクションを実行**させることができます。[**タップジャッキングとは何かについて詳しくはリンクを参照してください**](./#tapjacking)。

### コンテンツプロバイダの悪用 - 機密情報へのアクセスと操作

[**コンテンツプロバイダとは何かを確認したい場合はこちらを読んでください。**](android-applications-basics.md#content-provider)\
コンテンツプロバイダは基本的にデータの**共有**に使用されます。アプリに利用可能なコンテンツプロバイダがある場合、そこから**機密**データを**抽出**することができるかもしれません。また、潜在的に**SQLインジェクション**や**パストラバーサル**が脆弱性となっている可能性があるため、それらをテストすることも興味深いでしょう。

[**Drozerを使用してコンテンツプロバイダを悪用する方法を学ぶ**](drozer-tutorial/#content-providers)

### **サービスの悪用**

[**サービスとは何かを確認したい場合はこちらを読んでください。**](android-applications-basics.md#services)\
サービスのアクションは基本的に`onStartCommand`メソッドで開始されます。

サービスは基本的にデータを**受信**し、それを**処理**して**応答**（またはしない）するものです。したがって、アプリケーションがいくつかのサービスをエクスポートしている場合は、それが何をしているかを理解するために**コード**を**確認**し、機密情報の抽出、認証措置のバイパスなどを**動的に**テストする必要があります。\
[**Drozerを使用してサービスを悪用する方法を学ぶ**](drozer-tutorial/#services)

### **ブロードキャストレシーバの悪用**

[**ブロードキャストレシーバとは何かを確認したい場合はこちらを読んでください。**](android-applications-basics.md#broadcast-receivers)\
ブロードキャストレシーバのアクションは基本的に`onReceive`メソッドで開始されます。

ブロードキャストレシーバは特定の種類のメッセージを待機しています。レシーバがメッセージを処理する方法によって、脆弱性が発生する可能性があります。\
[**Drozerを使用してブロードキャストレシーバを悪用する方法を学ぶ**](./#exploiting-broadcast-receivers)

### **スキーム / ディープリンクの悪用**

MobSFなどのツールを使用したり、[こちらのスクリプト](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)のようなスクリプトを使用して、ディープリンクを手動で検索できます。\
**adb**や**ブラウザ**を使用して宣言された**スキーム**を**開く**ことができます：
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_パッケージ名を**省略することができる**ことに注意し、モバイルは自動的にそのリンクを開くべきアプリを呼び出します。_

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**実行されるコード**

**アプリで実行されるコード**を見つけるには、ディープリンクで呼び出されるアクティビティに移動し、**`onNewIntent`** 関数を検索します。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**機密情報**

ディープリンクを見つけるたびに、URLパラメータを介して機密データ（パスワードなど）を受信していないかを確認してください。なぜなら、他のアプリケーションがディープリンクをなりすましてそのデータを盗む可能性があるからです！

**パス内のパラメータ**

URLのパス内でパラメータを使用しているディープリンクがあるかどうかも**確認する必要があります**。例えば、`https://api.example.com/v1/users/{username}` のような場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value` のようにパストラバーサルを強制することができます。\
アプリ内で正しいエンドポイントを見つけた場合、**オープンリダイレクト**（パスの一部がドメイン名として使用されている場合）、**アカウント乗っ取り**（CSRFトークンなしでユーザーの詳細を変更でき、脆弱性のあるエンドポイントが正しいメソッドを使用している場合）などを引き起こす可能性があります。詳細は[こちら](http://dphoeniixx.com/2020/12/13-2/)。

**さらなる例**

リンクに関する興味深いバグ報奨金レポートは[こちら](https://hackerone.com/reports/855618)です。

### トランスポート層の検査と検証の失敗

- Androidアプリケーションは**証明書を適切に検査しない**ことがあります。これらのアプリケーションが警告を見落としたり、自己署名証明書を受け入れたり、場合によってはHTTP接続に戻ったりすることは一般的です。
- SSL/TLSハンドシェイク中の**交渉が弱い場合**があり、安全でない暗号スイートが使用されています。この脆弱性により、接続は中間者攻撃に対して脆弱になり、攻撃者がデータを復号化できるようになります。
- アプリケーションがセキュアチャネルを使用して認証し、その後他のトランザクションで非セキュアチャネルを介して通信すると、**プライベート情報の漏洩**のリスクがあります。このアプローチは、セッションクッキーやユーザーの詳細などの機密データを悪意のあるエンティティによる傍受から保護できなくなります。

#### 証明書の検証

**証明書の検証**に焦点を当てます。サーバーの証明書の整合性を検証してセキュリティを強化する必要があります。これは、安全でないTLS構成や暗号化されていないチャネルを介して機密データを送信することが重大なリスクをもたらすためです。サーバー証明書の検証と脆弱性の対処の詳細な手順については、**[このリソース](https://manifestsecurity.com/android-application-security-part-10/)**が包括的なガイダンスを提供しています。

#### SSL Pinning

SSL Pinningは、アプリケーションがアプリケーション内に保存された既知のコピーとサーバーの証明書を照合するセキュリティ対策です。この方法は、MITM攻撃を防ぐために重要です。SSL Pinningの実装は、機密情報を扱うアプリケーションに強く推奨されます。

#### トラフィック検査

HTTPトラフィックを検査するには、プロキシツールの証明書（例：Burp）を**インストールする必要があります**。この証明書をインストールしないと、暗号化されたトラフィックはプロキシを介して表示されない場合があります。カスタムCA証明書をインストールする手順についてのガイドは、**[こちらをクリックしてください](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine)**。

**APIレベル24以上を対象とする**アプリケーションでは、暗号化されたトラフィックを検査するためにネットワークセキュリティ構成を変更する必要があります。このステップは、暗号化されたトラフィックを検査するために重要です。ネットワークセキュリティ構成を変更する手順については、**[このチュートリアルを参照してください](make-apk-accept-ca-certificate.md)**。

#### SSL Pinningのバイパス

SSL Pinningが実装されている場合、HTTPSトラフィックを検査するためには、これをバイパスする必要があります。この目的のためにさまざまな方法があります：

* [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)を使用して**apkを自動的に変更**して**SSL Pinningをバイパス**します。このオプションの最大の利点は、SSL Pinningをバイパスするためにルート権限が必要ないことですが、アプリケーションを削除して新しいものを再インストールする必要があり、これが常に機能するわけではありません。
* この保護をバイパスするために**Frida**（以下で説明）を使用することができます。Burp+Frida+Genymotionの使用方法については、[こちらのガイド](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)を参照してください。
* [**objection**](frida-tutorial/objection-tutorial.md)を使用して**SSL Pinningを自動的にバイパス**することもできます：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* **MobSFダイナミック解析**を使用して**SSL Pinningを自動的にバイパス**することもできます（以下で説明）。
* まだキャプチャしていないトラフィックがあると考える場合は、**iptablesを使用してトラフィックをburpに転送**することができます。このブログを参照してください：[https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 一般的なWeb脆弱性の検索

アプリケーション内で一般的なWeb脆弱性を検索することも重要です。これらの脆弱性の特定と緩和に関する詳細な情報は、この要約の範囲を超えて詳細に説明されています。

### Frida

[Frida](https://www.frida.re)は、開発者、リバースエンジニア、セキュリティ研究者向けの動的インストルメンテーションツールキットです。\
**実行中のアプリケーションにアクセスしてメソッドをフックし、動作を変更したり、値を変更したり、値を抽出したり、異なるコードを実行したりできます。**\
Androidアプリケーションのペンテストを行う場合は、Fridaの使用方法を知っておく必要があります。

* Fridaの使用方法を学ぶ：[**Fridaチュートリアル**](frida-tutorial/)
* Fridaを使用したアクションのための「GUI」：[**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)
* OjectionはFridaの使用を自動化するのに最適です：[**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
* ここでいくつかの素晴らしいFridaスクリプトを見つけることができます：[**https://codeshare.frida.re/**](https://codeshare.frida.re)

### **メモリのダンプ - Fridump**

アプリケーションがパスワードやニーモニックなど、保存すべきでない機密情報をメモリ内に保存していないかを確認してください。

[**Fridump3**](https://github.com/rootbsd/fridump3)を使用して、アプリのメモリをダンプできます。
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これにより、./dumpフォルダーにメモリがダンプされ、そこで次のようにgrepを使用できます：

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
### **Keystore内の機密データ**

Androidでは、Keystoreは機密データを保存するのに最適な場所ですが、**十分な権限があればアクセス可能**です。アプリケーションはここに**平文の機密データを保存**する傾向があるため、ペンテストではrootユーザーとして、またはデバイスに物理的アクセス権限を持つ者がこのデータを盗む可能性があるかどうかを確認する必要があります。

アプリがKeystoreにデータを保存していたとしても、そのデータは暗号化されている必要があります。

Keystore内のデータにアクセスするには、このFridaスクリプトを使用できます: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **指紋/生体認証バイパス**

以下のFridaスクリプトを使用すると、Androidアプリケーションが実行している可能性がある**特定の機密領域を保護するために行われる指紋認証をバイパス**することができます:**

{% code overflow="wrap" %}
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **背景画像**

アプリケーションをバックグラウンドに置くと、Androidはアプリケーションの**スナップショット**を保存します。そのため、前景に復元されるとアプリケーションよりも先に画像の読み込みが開始され、アプリがより速く読み込まれたように見えます。

ただし、このスナップショットに**機密情報**が含まれている場合、スナップショットにアクセス権を持つ者がその情報を**盗み出す**可能性があります（スナップショットにアクセスするにはルート権限が必要です）。

スナップショットは通常、以下の場所に保存されます：**`/data/system_ce/0/snapshots`**

Androidは、FLAG\_SECUREレイアウトパラメータを設定することで、スクリーンショットのキャプチャを**防止**する方法を提供しています。このフラグを使用することで、ウィンドウの内容はセキュアとして扱われ、スクリーンショットに表示されることや非セキュアなディスプレイで表示されることが防止されます。
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Androidアプリケーションアナライザー**

このツールは、ダイナミック解析中にさまざまなツールを管理するのに役立ちます：[https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### インテントインジェクション

開発者はしばしば、これらのインテントを処理し、`startActivity(...)`や`sendBroadcast(...)`などのメソッドに渡すアクティビティ、サービス、およびブロードキャストレシーバーなどのプロキシコンポーネントを作成しますが、これは危険です。

攻撃者がこれらのインテントを誤誘導して非公開のアプリコンポーネントをトリガーしたり、機密コンテンツプロバイダーにアクセスしたりすることを許可する危険があります。注目すべき例は、`WebView`コンポーネントが`Intent.parseUri(...)`を介してURLを`Intent`オブジェクトに変換し、それらを実行することで、悪意のあるインテントインジェクションにつながる可能性があります。

### 要点
- **インテントインジェクション**は、Webのオープンリダイレクトの問題に類似しています。
- 攻撃は、`Intent`オブジェクトをエクストラとして渡すことに関与し、安全でない操作を実行するためにリダイレクトされる可能性があります。
- 非公開のコンポーネントやコンテンツプロバイダーを攻撃者にさらす可能性があります。
- `WebView`のURLから`Intent`への変換は、意図しないアクションを容易にする可能性があります。

### Androidクライアントサイドインジェクションおよびその他

おそらくWebからこの種の脆弱性については知っているでしょう。Androidアプリケーションでこれらの脆弱性に特に注意する必要があります：

* **SQLインジェクション:** 動的クエリやコンテンツプロバイダーを扱う場合は、パラメータ化されたクエリを使用していることを確認してください。
* **JavaScriptインジェクション（XSS）:** 任意のWebViewsに対してJavaScriptとプラグインサポートが無効になっていることを確認してください（デフォルトで無効）。[詳細はこちら](webview-attacks.md#javascript-enabled)。
* **ローカルファイルインクルージョン:** WebViewsはファイルシステムへのアクセスが無効になっている必要があります（デフォルトで有効）- `(webview.getSettings().setAllowFileAccess(false);)。[詳細はこちら](webview-attacks.md#javascript-enabled)。
* **永続クッキー**: Androidアプリケーションがセッションを終了する場合、クッキーが取り消されないことがいくつかのケースであり、ディスクに保存される可能性があります
* [**クッキーのSecureフラグ**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、迅速なハッキングワールドについて最新情報を入手

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新に関する情報を入手

**[Discord](https://discord.com/invite/N3FrSbmwdy)** に参加して、今日からトップハッカーと協力を始めましょう！

## 自動解析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静的解析**

![](<../../.gitbook/assets/image (61).png>)

アプリケーションの脆弱性評価を行うための素敵なWebベースのフロントエンド。ダイナミック解析も実行できます（ただし、環境を準備する必要があります）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSFは**Android**(apk)**、IOS**(ipa)**、およびWindows**(apx)アプリケーションを分析できます（_WindowsアプリケーションはWindowsホストにインストールされたMobSFから分析する必要があります_）。\
また、**Android**または**IOS**アプリのソースコードをZIPファイルに作成すると（アプリケーションのルートフォルダに移動し、すべてを選択してZIPファイルを作成する）、それも分析できます。

MobSFは**diff/比較**分析と**VirusTotal**の統合も可能です（_MobSF/settings.py_でAPIキーを設定し、有効にする必要があります: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`）。`VT_UPLOAD`を`False`に設定すると、**ハッシュ**がファイルの代わりに**アップロード**されます。

### MobSFによるアシストされたダイナミック分析

**MobSF**は**Android**での**ダイナミック分析**にも非常に役立ちますが、その場合はホストにMobSFと**genymotion**をインストールする必要があります（VMやDockerでは動作しません）。_注意: **genymotion**で最初にVMを**起動**してから**MobSF**を起動する必要があります。_\
**MobSFダイナミックアナライザー**は以下が可能です:

* **アプリケーションデータのダンプ**（URL、ログ、クリップボード、自分が作成したスクリーンショット、"**Exported Activity Tester**"によって作成されたスクリーンショット、電子メール、SQLiteデータベース、XMLファイル、およびその他の作成されたファイル）。スクリーンショット以外はすべて自動的に行われますが、スクリーンショットを取得する場合は、スクリーンショットを取得したいタイミングで押すか、"**Exported Activity Tester**"を押してすべてのエクスポートされたアクティビティのスクリーンショットを取得する必要があります。
* **HTTPSトラフィックのキャプチャ**
* **Frida**を使用して**ランタイム情報**を取得する

**Android**のバージョンが5よりも新しい場合、**Frida**が**自動的に起動**され、グローバル**プロキシ**設定が**トラフィックをキャプチャ**するように設定されます。テストされたアプリケーションからのトラフィックのみをキャプチャします。

**Frida**

デフォルトでは、いくつかのFridaスクリプトを使用して**SSLピニングのバイパス**、**ルート検出**、**デバッガー検出**、および**興味深いAPIの監視**も行います。\
MobSFは**エクスポートされたアクティビティ**を呼び出し、それらの**スクリーンショット**を取得してレポートに保存することもできます。

ダイナミックテストを**開始**するには、緑色のボタン "**Start Instrumentation**" を押します。**Frida Live Logs**を押すと、Fridaスクリプトによって生成されたログが表示され、**Live API Monitor**を押すとフックされたメソッドへのすべての呼び出し、渡された引数、返された値が表示されます（これは "Start Instrumentation" を押した後に表示されます）。\
MobSFはまた、独自の**Fridaスクリプト**をロードすることができます（Fridaスクリプトの結果をMobSFに送信するには `send()` 関数を使用します）。また、**いくつかの事前に書かれたスクリプト**をロードすることもできます（`MobSF/DynamicAnalyzer/tools/frida_scripts/others/`に追加できます）、それらを選択して "**Load**" を押し、 "**Start Instrumentation**" を押します（そのスクリプトのログを "**Frida Live Logs**" 内で確認できます）。

![](<../../.gitbook/assets/image (215).png>)

さらに、いくつかの補助的なFrida機能があります:

* **ロードされたクラスの列挙**: ロードされたすべてのクラスを表示します
* **文字列のキャプチャ**: アプリケーションを使用する際にキャプチャされたすべての文字列を表示します（非常にノイズが多い）
* **文字列比較のキャプチャ**: 非常に役立つ場合があります。比較された2つの文字列と結果（TrueまたはFalse）が表示されます。
* **クラスメソッドの列挙**: クラス名（例: "java.io.File"）を入力すると、そのクラスのすべてのメソッドが表示されます。
* **クラスパターンの検索**: パターンに一致するクラスを検索します
* **クラスメソッドのトレース**: クラス全体をトレースします（クラスのすべてのメソッドの入力と出力を参照）。デフォルトでは、MobSFはいくつかの興味深いAndroid APIメソッドをトレースします。

使用したい補助モジュールを選択したら、**Start Intrumentation** を押して、すべての出力を **Frida Live Logs** で確認できます。

**Shell**

Mobsfには、ダイナミック分析ページの一番下にいくつかの**adb**コマンド、**MobSFコマンド**、および一般的な**シェルコマンド**を備えたシェルが付属しています。いくつかの興味深いコマンド:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTPツール**

HTTPトラフィックがキャプチャされると、"**HTTP(S) Traffic**"の下にキャプチャされたトラフィックの見栄えが悪いビューで表示されるか、"**Start HTTPTools**"の緑のボタンで見栄えの良いビューが表示されます。2番目のオプションから、**キャプチャされたリクエスト**をBurpやOwasp ZAPなどの**プロキシ**に**送信**することができます。\
そのためには、_Burpを起動 -->_ _Interceptをオフにする --> MobSB HTTPToolsでリクエストを選択_ --> "**Send to Fuzzer**"を押す --> _プロキシアドレス_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))を選択します。

MobSFで動的解析を終えたら、"**Start Web API Fuzzer**"を押して、**HTTPリクエストをファズ**し、脆弱性を探します。

{% hint style="info" %}
MobSFで動的解析を実行した後、プロキシ設定が誤って構成され、GUIから修正できない場合があります。プロキシ設定を修正するには、次の手順を実行します:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Inspeckageを使用したアシストされたダイナミック解析

[**Inspeckage**](https://github.com/ac-pm/Inspeckage)からツールを入手できます。\
このツールは、いくつかの**フック**を使用して、**ダイナミック解析**を実行する際に**アプリケーション内で何が起こっているか**を知らせます。


### [Yaazhini](https://www.vegabird.com/yaazhini/)

これはGUIを使用した**静的解析を実行するための素晴らしいツール**です

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、**ソースコード**または**パッケージ化されたAPK**内のいくつかの**セキュリティ関連のAndroidアプリケーションの脆弱性**を探すように設計されています。このツールはまた、いくつかの見つかった脆弱性を悪用するための「Proof-of-Concept」展開可能なAPKと**ADBコマンド**を作成することができます（公開されたアクティビティ、インテント、タップジャッキングなど）。Drozerと同様に、テストデバイスをルート化する必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* 簡単な参照のためにすべての抽出されたファイルを表示します
* APKファイルを自動的にJavaおよびSmali形式に逆コンパイルします
* 一般的な脆弱性と動作のためのAndroidManifest.xmlを分析します
* 一般的な脆弱性と動作のための静的ソースコード分析
* デバイス情報
* その他
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERは、Windows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、.apkファイルを解析して脆弱性を検出します。これは、APKを展開し、一連のルールを適用してこれらの脆弱性を検出します。

すべてのルールは`rules.json`ファイルに集約されており、各企業やテスターは必要なものを分析するために独自のルールを作成できます。

最新のバイナリを[ダウンロードページ](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAnは、モバイルアプリケーションの[静的コード解析](https://en.wikipedia.org/wiki/Static\_program\_analysis)を実行する開発者、バグバウンティハンター、倫理的ハッカーを支援する**クロスプラットフォーム**ツールです。

このコンセプトは、モバイルアプリケーションファイル（.apkまたは.ipaファイル）をStaCoAnアプリケーションにドラッグアンドドロップすると、視覚的でポータブルなレポートが生成されます。設定やワードリストを調整して、カスタマイズされた体験を得ることができます。

[最新リリースをダウンロード](https://github.com/vincentcox/StaCoAn/releases)：
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Frameworkは、開発者やハッカーがAndroidアプリケーション内の潜在的なセキュリティ脆弱性を見つけるのに役立つAndroid脆弱性分析システムです。\
[Windows releases](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**は、Androidアプリケーションによって開発された潜在的な悪意のある振る舞いを検出してユーザーに警告することを主な目的とするツールです。

検出は、アプリケーションのDalvikバイトコード（**Smali**として表現される）の**静的解析**によって行われ、[`androguard`](https://github.com/androguard/androguard)ライブラリを使用しています。

このツールは、電話識別子の流出、オーディオ/ビデオフローの傍受、PIMデータの変更、任意のコード実行など、**"悪い"アプリケーションの一般的な振る舞い**を探します。
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA\_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA**は**M**obile **A**pplication **R**everse engineering and **A**nalysis Frameworkの略称です。これは、一般的に使用されるモバイルアプリケーションのリバースエンジニアリングおよび分析ツールを組み合わせたツールで、OWASPモバイルセキュリティの脅威に対するモバイルアプリケーションのテストを支援します。その目的は、このタスクをモバイルアプリケーション開発者やセキュリティ専門家にとってより簡単で使いやすくすることです。

以下のことができます：

* 異なるツールを使用してJavaおよびSmaliコードを抽出する
* [smalisca](https://github.com/dorneanu/smalisca)、[ClassyShark](https://github.com/google/android-classyshark)、[androbugs](https://github.com/AndroBugs/AndroBugs\_Framework)、[androwarn](https://github.com/maaaaz/androwarn)、[APKiD](https://github.com/rednaga/APKiD)を使用してAPKを分析する
* 正規表現を使用してAPKからプライベート情報を抽出する
* マニフェストを分析する
* [pyssltest](https://github.com/moheshmohan/pyssltest)、[testssl](https://github.com/drwetter/testssl.sh)、[whatweb](https://github.com/urbanadventurer/WhatWeb)を使用して見つかったドメインを分析する
* [apk-deguard.com](http://www.apk-deguard.com)を介してAPKの難読化を解除する

### Koodous

マルウェアを検出するのに便利：[https://koodous.com/](https://koodous.com)

## コードの難読化/難読化解除

コードを難読化するために使用するサービスと構成によっては、秘密情報が難読化されるかどうかが異なることに注意してください。

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

[Wikipedia](https://en.wikipedia.org/wiki/ProGuard\_\(software\))によると、**ProGuard**はJavaコードを縮小し、最適化し、難読化するオープンソースのコマンドラインツールです。バイトコードを最適化し、未使用の命令を検出および削除することができます。ProGuardはフリーソフトウェアであり、GNU General Public Licenseバージョン2の下で配布されています。

ProGuardはAndroid SDKの一部として配布され、リリースモードでアプリケーションをビルドする際に実行されます。

### [DexGuard](https://www.guardsquare.com/dexguard)

APKの難読化を解除するためのステップバイステップガイドは[こちら](https://blog.lexfo.fr/dexguard.html)にあります。

(そのガイドから) 最後に確認したとき、Dexguardの動作モードは次のとおりでした：

* InputStreamとしてリソースをロードする
* それを復号化するためにFilterInputStreamを継承したクラスに結果をフィードする
* いくつかの無駄な難読化を行い、リバーサーの時間を数分無駄にする
* 復号化された結果をZipInputStreamにフィードしてDEXファイルを取得する
* 最終的に`loadDex`メソッドを使用して結果のDEXをリソースとしてロードする

### [DeGuard](http://apk-deguard.com)

**DeGuardはAndroidの難読化ツールによって実行された難読化プロセスを逆転させます。これにより、コード検査やライブラリの予測を含む多数のセキュリティ分析が可能になります。**

難読化されたAPKを彼らのプラットフォームにアップロードできます。

### [Simplify](https://github.com/CalebFenton/simplify)

これは**一般的なAndroid難読化解除ツール**です。Simplifyはアプリを**仮想的に実行**してその動作を理解し、コードを最適化し、動作は同じままで人間が理解しやすくなるようにします。各最適化タイプは単純で一般的なため、使用される具体的な難読化のタイプは問題ありません。

### [APKiD](https://github.com/rednaga/APKiD)

APKiDは**APKの作成方法**に関する情報を提供します。多くの**コンパイラ**、**パッカー**、**難読化ツール**、およびその他の奇妙なものを識別します。これはAndroid用の[_PEiD_](https://www.aldeid.com/wiki/PEiD)です。

### マニュアル

**カスタム難読化を逆転する方法についてのトリックを学ぶ**ために、[このチュートリアルを読んでください](manual-deobfuscation.md)

## ラボ

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4bは、リバースエンジニアリングとマルウェア分析のための異なるセキュリティ愛好家や研究者からの最新のフレームワーク、チュートリアル、およびラボを含む、ubuntu-mateをベースにしたAndroidセキュリティ仮想マシンです。

## 参考文献

* [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) リソースの素晴らしいリストです
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Androidクイックコース
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
* [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## まだ試していない

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加しましょう

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を最新の状態に保ちましょう

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新情報を把握しましょう

**[Discord](https://discord.com/invite/N3FrSbmwdy)に参加**して、今日からトップハッカーと協力を始めましょう！

<details>

<summary><strong>**htARTE（HackTricks AWS Red Team Expert）**で**ゼロからヒーローまでのAWSハッキング**を学びましょう！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したり、HackTricksをPDFでダウンロードしたり**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
* 独占的な[NFTs](https://opensea.io/collection/the-peass-family)を含む、[**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)を**フォロー**しましょう
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングトリックを共有しましょう

</details>
