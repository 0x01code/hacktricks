# Android应用程序渗透测试

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞经过验证后，您将获得奖励。

**在web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！在其崛起的日子里掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声望积分，并登上每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客行动中获利！

{% embed url="https://hackenproof.com/register" %}

## Android应用程序基础知识

强烈建议您从阅读本页面开始，了解与Android安全相关的**最重要的部分**以及Android应用程序中最危险的组件：

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB（Android调试桥）

这是您连接到Android设备（模拟或物理）所需的主要工具。\
它允许您通过**USB**或**网络**从计算机上控制设备，**复制**文件来回，**安装**和卸载应用程序，运行**shell**命令，执行**备份**，读取**日志**等等。

请查看以下[**ADB命令**](adb-commands.md)列表，了解如何使用adb。

## Smali

有时候，修改应用程序代码以访问**隐藏信息**（可能是混淆良好的密码或标志）是很有趣的。然后，将apk反编译，修改代码并重新编译可能是有趣的。\
[**在本教程中，您可以学习如何反编译APK，修改Smali代码并重新编译APK**，以添加新功能](smali-changes.md)。这在动态分析期间作为**替代方案**可能非常有用。因此，**始终记住这种可能性**。

## 其他有趣的技巧

* [在Play商店中伪造您的位置](spoofing-your-location-in-play-store.md)
* **下载APK**：[https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/)，[https://apkpure.com/es/](https://apkpure.com/es/)，[https://www.apkmirror.com/](https://www.apkmirror.com)，[https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* 从设备中提取APK：
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
## 静态分析

首先，要分析一个APK，你应该使用反编译工具来查看Java代码。请在[这里阅读有关不同可用反编译工具的信息](apk-decompilers.md)。

### 寻找有趣的信息

只需查看APK的字符串，你就可以搜索密码、URL（[https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep)）、API密钥、加密、蓝牙UUID、令牌和其他有趣的内容...甚至可以查找代码执行的后门或身份验证后门（硬编码的管理员凭据）。

**Firebase**

特别注意Firebase的URL，并检查其是否配置错误。[在这里了解有关Firebase是什么以及如何利用它的更多信息。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 对应用程序的基本理解 - Manifest.xml，strings.xml

使用任何在[这里](apk-decompilers.md)提到的反编译工具之一，你将能够阅读Manifest.xml。你还可以将apk文件扩展名重命名为.zip并解压缩它。通过阅读清单，你可以发现以下漏洞：

* 首先，检查应用程序是否可调试。生产APK不应该是可调试的（否则其他人将能够连接到它）。你可以在清单中查找属性`debuggable="true"`来检查应用程序是否可调试。示例：`<application theme="@2131296387" debuggable="true"`
* [在这里学习如何在手机上查找可调试的应用程序并利用它们](drozer-tutorial/#is-debuggeable)
* **备份**：`android:allowBackup`属性定义了用户启用USB调试后是否可以备份和恢复应用程序数据。如果备份标志设置为true，则允许攻击者通过adb备份应用程序数据，即使设备未经root。因此，处理和存储敏感信息（如卡片详细信息、密码等）的应用程序应该将此设置显式设置为false，因为默认情况下它设置为true以防止此类风险。
* `<application android:allowBackup="false"`
* **NetworkSecurity**：应用程序的网络安全性可以通过`android:networkSecurityConfig="@xml/network_security_config"`覆盖默认值。可以在**res/xml**中放置一个名为network_security_config的文件。该文件将配置重要的安全设置，如证书固定或是否允许HTTP流量。你可以在这里阅读有关可以配置的所有内容的更多信息，但请查看以下关于如何为某些域配置HTTP流量的示例：
* `<domain-config cleartextTrafficPermitted="true"> <domain includeSubdomains="true">formation-software.co.uk </domain></domain-config>`
* **导出的活动**：检查清单中导出的活动，因为这可能是危险的。稍后在动态分析中，将解释如何[利用此行为](./#exploiting-exported-activities-authorisation-bypass)。
* **内容提供程序**：如果公开了一个导出的提供程序，你可能能够访问/修改有趣的信息。在动态分析中，你将学习如何[滥用它们](./#exploiting-content-providers-accessing-and-manipulating-sensitive-information)。
* 检查`android:name="android.support.FILE_PROVIDER_PATHS"`属性中的**FileProviders**配置。[在这里阅读有关FileProviders的更多信息](./#fileprovider)。
* **公开的服务**：根据服务在内部执行的操作，可能会存在漏洞。在动态分析中，你将学习如何[滥用它们](./#exploiting-services)。
* **广播接收器**：[你将学习如何可能利用它们](./#exploiting-broadcast-receivers)在动态分析中。
* **URL方案**：阅读管理方案的活动代码，并查找处理用户输入的漏洞。有关[URL方案的更多信息，请点击这里](./#url-schemes)。
* **minSdkVersion**，**targetSDKVersion**，**maxSdkVersion**：它们指示应用程序将在哪些Android版本上运行。从安全角度来看，支持旧版本将允许已知的Android漏洞版本运行。

阅读**resources.arsc/strings.xml**，你可以找到一些有趣的信息：

* API密钥
* 自定义模式
* 开发人员在此文件中保存的其他有趣信息

### Tapjacking



### 任务劫持

将**`launchMode`**设置为**`singleTask`**且未定义任何**`taskAffinity`**的**活动**容易受到任务劫持的攻击。这意味着，可以安装一个**应用程序**，如果在真正的应用程序之前启动它，它可以**劫持真正应用程序的任务**（因此用户将与**恶意应用程序交互，以为自己在使用真正的应用程序**）。

更多信息：

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### 不安全的数据存储

**内部存储**

在**内部存储**上创建的文件只能由应用程序访问。这种保护是由Android实现的，对于大多数应用程序来说已经足够。但是开发人员经常使用`MODE_WORLD_READBALE`和`MODE_WORLD_WRITABLE`将这些文件的访问权限授予其他应用程序，但这并不限制其他应用程序（恶意应用程序）访问它们。\
在**静态**分析中，检查是否使用了这些模式，在**动态**分析中，检查创建的文件的权限（也许其中一些是全球可读/可写的）。\
[在这里了解有关此漏洞及如何修复它的更多信息。](https://manifestsecurity.com/android-application-security-part-8/)

**外部存储**

在**外部存储**（如SD卡）上创建的文件是**全局可读和可写**的。由于外部存储可以被用户移除并且可以被任何应用程序修改，因此你不应该使用外部存储来存储敏感信息。\
与来自任何不受信任来源的数据一样，处理来自外部存储的数据时，应进行**输入验证**。我们强烈建议在动态加载之前不要将可执行文件或类文件存储在外部存储上。如果你的应用程序确实从外部存储检索可执行文件，那么在动态加载之前应对这些文件进行签名和加密验证。\
信息来源：[这里](https://manifestsecurity.com/android-application-security-part-8/)。

可以在`/storage/emulated/0`、`/sdcard`、`/mnt/sdcard`中访问外部存储。

{% hint style="info" %}
从Android 4.4（API 17）开始，SD卡具有目录结构，**限制应用程序对特定应用程序目录的访问**。这样可以防止恶意应用程序读取或写入另一个应用程序的文件。
{% endhint %}

**明文存储的敏感数据**

* **共享首选项**：Android允许每个应用程序轻松保存xml文件在路径`/data/data/<packagename>/shared_prefs/`中，有时可以在该文件夹中找到明文存储的敏感信息。
* **数据库**：Android允许每个应用程序轻松保存sqlite数据库在路径`/data/data/<packagename>/databases/`中，有时可以在该文件夹中找到明文存储的敏感信息。
### 破损的TLS

**接受所有证书**

由于某种原因，有时开发人员会接受所有证书，即使主机名与以下代码行不匹配，例如：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
一种测试的好方法是尝试使用像Burp这样的代理来捕获流量，而不需要在设备内授权Burp CA。此外，您可以使用Burp生成一个针对不同主机名的证书并使用它。

### 加密破解

**密钥管理流程不佳**

一些开发人员将敏感数据保存在本地存储中，并使用在代码中硬编码/可预测的密钥进行加密。这样做是不应该的，因为一些逆向工程可能会使攻击者提取机密信息。

**使用不安全和/或已弃用的算法**

开发人员不应使用**已弃用的算法**来执行授权**检查**、**存储**或**发送**数据。其中一些算法包括：RC4、MD4、MD5、SHA1...如果用于存储密码的哈希值，应使用具有盐的哈希值来抵御暴力破解。

### 其他检查

* 建议对APK进行**混淆**，以增加逆向工程的难度。
* 如果应用程序是敏感的（如银行应用程序），应该进行**自身检查以查看手机是否已经root**，并采取相应措施。
* 如果应用程序是敏感的（如银行应用程序），应检查是否正在使用模拟器。
* 如果应用程序是敏感的（如银行应用程序），应在执行之前**检查自身的完整性**，以检查是否已被修改。
* 使用[**APKiD**](https://github.com/rednaga/APKiD)检查用于构建APK的编译器/打包器/混淆器

### React Native应用程序

阅读以下页面，了解如何轻松访问React应用程序的JavaScript代码：

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Xamarin应用程序

阅读以下页面，了解如何轻松访问Xamarin应用程序的C#代码：

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### 超级打包应用程序

根据这篇[**博文**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)，超级打包是一种将应用程序的内容压缩到单个文件中的元算法。该博文讨论了创建一个解压这些类型应用程序的应用程序的可能性...以及一种更快的方法，即**执行应用程序并从文件系统中收集解压的文件**。

### 自动静态代码分析

工具[**mariana-trench**](https://github.com/facebook/mariana-trench)能够通过扫描应用程序的代码来查找**漏洞**。该工具包含一系列**已知源**（指示工具**用户控制的输入位置**）、**漏洞点**（指示工具**危险的位置**，恶意用户输入可能会造成损害）和**规则**。这些规则指示了**源-漏洞点**的组合，表明存在漏洞。

有了这些知识，**mariana-trench将审查代码并找出可能的漏洞**。

### 泄露的机密信息

应用程序中可能包含一些机密信息（API密钥、密码、隐藏的URL、子域名...），您可能能够发现这些信息。您可以使用诸如[https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)之类的工具。

### 绕过生物识别认证

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### 其他有趣的功能

* **代码执行**：`Runtime.exec(), ProcessBuilder(), native code:system()`
* **发送短信**：`sendTextMessage, sendMultipartTestMessage`
* 声明为`native`的**本地函数**：`public native, System.loadLibrary, System.load`
* [阅读此内容以了解**如何逆向本地函数**](reversing-native-libraries.md)

### **其他技巧**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞经过验证后，您将获得奖励。

**在web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！在其崛起之时掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占据每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客行动中获利！

{% embed url="https://hackenproof.com/register" %}

***

## 动态分析

> 首先，您需要一个可以安装应用程序和所有环境（主要是Burp CA证书、Drozer和Frida）的环境。因此，强烈建议使用已root的设备（模拟或非模拟）。

### 在线动态分析

您可以在[https://appetize.io/](https://appetize.io)创建一个**免费账户**。该平台允许您**上传**和**执行**APK文件，因此可以用于查看APK的行为。

您甚至可以在网页上**查看应用程序的日志**并通过**adb**进行连接。

![](<../../.gitbook/assets/image (60).png>)

通过ADB连接，您可以在模拟器中使用**Drozer**和**Frida**。

### 本地动态分析

#### 使用模拟器

* [**Android Studio**](https://developer.android.com/studio)（您可以创建**x86**和**arm**设备，并根据[**此链接**](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)**最新的x86**版本**支持ARM库**，无需使用缓慢的arm模拟器）。
* 了解如何在此页面中设置它：

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **（免费版本：个人版，您需要创建一个账户。建议**_**下载**_**带有VirtualBox的版本以避免潜在错误。）**
* [**Nox**](https://es.bignox.com)（免费，但不支持Frida或Drozer）。

{% hint style="info" %}
在任何平台上创建新模拟器时，请记住屏幕越大，模拟器运行得越慢。因此，如果可能，请选择小屏幕。
{% endhint %}

要在Genymotion中**安装Google服务**（如应用商店），您需要单击以下图像中标记为红色的按钮：

![](<../../.gitbook/assets/image (200) (1).png>)

此外，请注意在Genymotion中的**Android VM配置**中，您可以选择**桥接网络模式**（如果您将从具有工具的不同VM连接到Android VM，则这将非常有用）。
#### 使用物理设备

您需要激活**调试**选项，如果可以**root**它会很好：

1. **设置**。
2. （从Android 8.0开始）选择**系统**。
3. 选择**关于手机**。
4. 连续按**版本号**7次。
5. 返回，您将找到**开发者选项**。

> 安装应用程序后，您首先应该尝试并调查它的功能，了解它的工作原理，并熟悉它。\
> 我建议您使用MobSF动态分析+pidcat进行**初始动态分析**，这样您就可以在MobSF捕获大量有趣的数据的同时，**了解应用程序的工作方式**。

### 非预期的数据泄漏

**日志记录**

开发人员经常在公开场合留下调试信息。因此，任何具有`READ_LOGS`权限的应用程序都可以通过它们访问这些日志，并可以通过这些日志获得敏感信息。\
在浏览应用程序时，使用[**pidcat**](https://github.com/JakeWharton/pidcat)（推荐，更易于使用和阅读）或[adb logcat](adb-commands.md#logcat)来读取创建的日志，并**寻找敏感信息**。

{% hint style="warning" %}
请注意，从**Android 4.0的较新版本**开始，**应用程序只能访问自己的日志**。因此，应用程序无法访问其他应用程序的日志。\
无论如何，仍然建议**不要记录敏感信息**。
{% endhint %}

**复制/粘贴缓存**

Android提供了基于剪贴板的框架，用于在Android应用程序中提供复制粘贴功能。但是，当**其他应用程序**可以**访问**包含某些敏感数据的**剪贴板**时，这会引发严重问题。应该**禁用**应用程序的**敏感部分**的**复制/粘贴**功能。例如，禁用复制信用卡详细信息。

**崩溃日志**

如果应用程序在运行时崩溃并将日志保存在某个地方，那么这些日志对攻击者尤其有帮助，特别是在无法对Android应用程序进行逆向工程的情况下。然后，避免在应用程序崩溃时创建日志，并且如果日志通过网络发送，则确保它们通过SSL通道发送。\
作为渗透测试人员，**请尝试查看这些日志**。

**发送给第三方的分析数据**

大多数应用程序在其应用程序中使用其他服务，例如Google Adsense，但有时它们会**泄漏一些敏感数据**或不需要发送给该服务的数据。这可能是因为开发人员没有正确实现功能。您可以通过拦截应用程序的流量来**查看是否向第三方发送了敏感数据**。

### SQLite数据库

大多数应用程序将使用**内部SQLite数据库**保存信息。在渗透测试期间，查看创建的**数据库**、**表**和**列**的名称以及保存的**所有数据**，因为您可能会发现**敏感信息**（这将是一个漏洞）。\
数据库应位于`/data/data/the.package.name/databases`，例如`/data/data/com.mwr.example.sieve/databases`

如果数据库保存了机密信息并且**加密**，但您可以在应用程序中**找到**密码，这仍然是一个**漏洞**。

使用`.tables`枚举表，使用`.schema <table_name>`枚举表的列

### Drozer（利用活动、内容提供程序和服务）

**Drozer**允许您**扮演Android应用程序的角色**并与其他应用程序交互。它可以执行**已安装应用程序可以执行的任何操作**，例如利用Android的进程间通信（IPC）机制并与底层操作系统交互。详见[Drozer指南](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)。\
Drozer是一个有用的工具，可以在接下来的章节中学习如何**利用导出的活动、导出的服务和内容提供程序**。

### 利用导出的活动

[**如果您想回顾一下什么是Android活动，请阅读此内容。**](android-applications-basics.md#launcher-activity-and-other-activities)\
还要记住，活动的代码从`onCreate`方法开始。

**授权绕过**

当一个活动被导出时，您可以从外部应用程序调用其屏幕。因此，如果一个包含**敏感信息**的活动被**导出**，您可以**绕过**身份验证机制**访问它**。\
[**了解如何使用Drozer利用导出的活动。**](drozer-tutorial/#activities)

您还可以使用adb启动导出的活动：

* PackageName是com.example.demo
* 导出的ActivityName是com.example.test.MainActivity
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**：MobSF会将在活动中使用`android:launchMode`作为`singleTask/singleInstance`的行为检测为恶意，但根据[这个](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)的解释，这只在旧版本（API版本<21）中存在危险。

{% hint style="info" %}
请注意，授权绕过并不总是漏洞，这取决于绕过的方式以及暴露的信息。
{% endhint %}

**敏感信息泄露**

**活动也可以返回结果**。如果你找到了一个已导出且未受保护的活动，调用了**`setResult`**方法并**返回敏感信息**，那么就存在敏感信息泄露的风险。

#### 点击劫持

如果没有防止点击劫持，你可以滥用导出的活动来让**用户执行意外操作**。了解更多关于[**点击劫持是什么的信息，请点击此链接**](./#tapjacking)。

### 利用内容提供者 - 访问和操纵敏感信息

[**如果你想回顾一下什么是内容提供者，请阅读这篇文章。**](android-applications-basics.md#content-provider)\
内容提供者基本上用于**共享数据**。如果一个应用程序有可用的内容提供者，你可能能够从中**提取敏感**数据。同时，测试可能的**SQL注入**和**路径遍历**也是很有意义的，因为它们可能存在漏洞。\
[**学习如何使用Drozer来利用内容提供者。**](drozer-tutorial/#content-providers)

### **利用服务**

[**如果你想回顾一下什么是服务，请阅读这篇文章。**](android-applications-basics.md#services)\
记住，服务的操作是从`onStartCommand`方法开始的。

服务基本上是可以**接收数据**，**处理**它并**返回**（或不返回）响应的东西。因此，如果一个应用程序导出了一些服务，你应该**检查**代码以了解它在做什么，并**动态测试**以提取机密信息、绕过身份验证措施等...\
[**学习如何使用Drozer来利用服务。**](drozer-tutorial/#services)

### **利用广播接收器**

[**如果你想回顾一下什么是广播接收器，请阅读这篇文章。**](android-applications-basics.md#broadcast-receivers)\
记住，广播接收器的操作是从`onReceive`方法开始的。

广播接收器将等待某种类型的消息。根据接收器处理消息的方式，它可能存在漏洞。\
[**学习如何使用Drozer来利用广播接收器。**](./#exploiting-broadcast-receivers)

### **利用Scheme / Deep links**

你可以手动查找深层链接，使用像MobSF这样的工具或像[这个](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)的脚本。\
你可以使用**adb**或**浏览器**打开已声明的**scheme**：

{% code overflow="wrap" %}
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_请注意，您可以**省略包名**，手机将自动调用应该打开该链接的应用程序。_

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**执行的代码**

为了找到在应用程序中执行的代码，请转到由深度链接调用的活动，并搜索函数`onNewIntent`。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**敏感信息**

每次找到一个深度链接时，请检查它是否通过URL参数接收敏感数据（如密码），因为任何其他应用程序都可以冒充深度链接并窃取这些数据！

**路径中的参数**

您还必须检查任何深度链接是否在URL的路径中使用参数，例如：`https://api.example.com/v1/users/{username}`，在这种情况下，您可以通过访问`example://app/users?username=../../unwanted-endpoint%3fparam=value`来强制进行路径遍历。请注意，如果您在应用程序中找到了正确的端点，您可能能够引发**开放重定向**（如果路径的一部分用作域名），**账户劫持**（如果您可以在没有CSRF令牌的情况下修改用户详细信息，并且漏洞端点使用了正确的方法）和其他任何漏洞。有关此的更多信息，请参见[此处](http://dphoeniixx.com/2020/12/13-2/)。

**更多示例**

有关链接的[有趣的赏金漏洞报告](https://hackerone.com/reports/855618)（_/.well-known/assetlinks.json_）。

### 不足的传输层保护

* **缺乏证书检查：**Android应用程序未能验证呈现给它的证书的身份。大多数应用程序会忽略警告并接受任何自签名证书。而有些应用程序则通过HTTP连接传递流量。
* **弱握手协商：**应用程序和服务器进行了SSL/TLS握手，但使用了容易受到中间人攻击的不安全密码套件。因此，任何攻击者都可以轻松解密该连接。
* **隐私信息泄露：**大多数情况下，应用程序通过安全通道进行身份验证，但其余的连接都是通过非安全通道进行的。这并不增加应用程序的安全性，因为其余的敏感数据（如会话cookie或用户数据）可以被恶意用户拦截。

从所提供的3种情况中，我们将讨论**如何验证证书的身份**。另外两种情况取决于服务器的**TLS配置**以及应用程序是否发送**未加密的数据**。渗透测试人员应该自行检查服务器的TLS配置（[此处](../../network-services-pentesting/pentesting-web/#ssl-tls-vulnerabilites)）并检测是否通过**未加密/易受攻击的**通道发送了任何**机密信息**。有关如何发现和修复此类漏洞的更多信息，请参见[**此处**](https://manifestsecurity.com/android-application-security-part-10/)。

**SSL Pinning**

默认情况下，在进行SSL连接时，客户端（Android应用程序）会检查服务器的证书是否具有可验证的信任链，并与请求的主机名匹配。这会导致**中间人攻击（MITM）**的问题。\
在证书固定中，Android应用程序本身包含服务器的证书，并且只有在呈现相同证书时才传输数据。\
建议在将发送敏感信息的站点上**应用SSL Pinning**。

### 检查HTTP流量

首先，您应该（必须）**安装您将使用的代理工具（可能是Burp）的证书**。如果您不安装代理工具的CA证书，您可能无法在代理中看到加密的流量。\
**请**[**阅读此指南以了解如何安装自定义CA证书**](android-burp-suite-settings.md)**。**

对于针对**API级别24+的应用程序，仅安装Burp CA**证书在设备上是不够的。要绕过此新保护，您需要修改网络安全配置文件。因此，您可以修改此文件以授权您的CA证书，或者您可以[**阅读此页面以了解如何强制应用程序再次接受设备中安装的所有证书**](make-apk-accept-ca-certificate.md)。

**SSL Pinning**

我们已经在2段之前讨论了什么是SSL Pinning。当它在应用程序中实施时，您需要绕过它以检查HTTPS流量，否则您将无法看到它。\
这里我将介绍一些我用来绕过此保护的选项：

* 使用[**apk-mitm**](https://github.com/shroudedcode/apk-mitm)自动**修改apk**以绕过SSLPinning。这种选项的最大优点是，您无需root即可绕过SSL Pinning，但您需要删除应用程序并重新安装新应用程序，而且这种方法并不总是有效的。
* 您可以使用Frida（下面讨论）来绕过此保护。这里有一个使用Burp+Frida+Genymotion的指南：[https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
* 您还可以尝试使用[**objection**](frida-tutorial/objection-tutorial.md)自动绕过SSL Pinning：`objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* 您还可以尝试使用**MobSF动态分析**自动绕过SSL Pinning（下面解释）
* 如果您仍然认为有一些流量未被捕获，您可以尝试使用iptables将流量**转发到burp**。阅读此博客：[https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

**常见的Web漏洞**

请注意，在此步骤中，您应该寻找常见的Web漏洞。关于Web漏洞的大量信息可以在本书中找到，因此我不会在此处提及它们。

### Frida

用于开发人员、逆向工程师和安全研究人员的动态插装工具包。了解更多信息，请访问[www.frida.re](https://www.frida.re)。\
**它非常强大，您可以访问正在运行的应用程序并在运行时挂钩方法以更改行为、更改值、提取值、运行不同的代码...**\
**如果您想进行Android应用程序渗透测试，您需要知道如何使用Frida。**

**学习如何使用Frida：**[**Frida教程**](frida-tutorial/)\
**一些用于与Frida执行操作的“GUI”：**[**https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security**](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)\
**基于Frida的其他一些抽象：**[**https://github.com/sensepost/objection**](https://github.com/sensepost/objection)**，**[**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)\
**您可以在此处找到一些很棒的Frida脚本：**[**https://codeshare.frida.re/**](https://codeshare.frida.re)
### **转储内存 - Fridump**

检查应用程序是否在内存中存储了不应该存储的敏感信息，如密码或助记词。

使用[**Fridump3**](https://github.com/rootbsd/fridump3)，您可以通过以下方式转储应用程序的内存：
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
这将在./dump文件夹中转储内存，然后您可以使用类似以下命令进行grep搜索：

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Keystore中的敏感数据**

在Android中，Keystore是存储敏感数据的最佳位置，然而，具备足够权限的情况下，仍然**有可能访问它**。由于应用程序倾向于在此处以明文形式存储**敏感数据**，因此渗透测试应该以root用户或者具有物理访问设备权限的人员身份检查它，否则可能会导致数据被窃取。

即使应用程序将数据存储在Keystore中，数据也应该进行加密。

要访问Keystore中的数据，您可以使用以下Frida脚本：[https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Android应用程序分析器**

这个工具可以帮助您在动态分析过程中管理不同的工具：[https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### Intent注入

这个漏洞类似于Web安全中的**开放重定向**。由于`Intent`类是`Parcelable`的，**属于这个类的对象**可以作为**额外的数据**传递给另一个`Intent`对象。\
许多开发人员利用这个**特性**创建**代理组件**（活动、广播接收器和服务），将其嵌入的`Intent`传递给`startActivity(...)`、`sendBroadcast(...)`等危险方法。\
这是危险的，因为**攻击者可以强制应用启动一个无法直接从另一个应用程序启动的非导出组件**，或者授予攻击者对其内容提供程序的访问权限。**`WebView`**有时也会将**URL从字符串转换为`Intent`**对象，使用`Intent.parseUri(...)`方法，并将其传递给`startActivity(...)`。

### Android客户端注入和其他漏洞

可能您已经从Web中了解过这种漏洞。在Android应用程序中，您必须特别注意以下漏洞：

* **SQL注入：**在处理动态查询或内容提供程序时，请确保使用参数化查询。
* **JavaScript注入（XSS）：**验证任何WebView是否已禁用JavaScript和插件支持（默认情况下已禁用）。[更多信息请点击此处](webview-attacks.md#javascript-enabled)。
* **本地文件包含：**验证任何WebView是否已禁用文件系统访问（默认情况下已启用）`(webview.getSettings().setAllowFileAccess(false);)`。[更多信息请点击此处](webview-attacks.md#javascript-enabled)。
* **永久cookie：**在某些情况下，当Android应用程序结束会话时，cookie没有被撤销，或者甚至可能保存到磁盘上。
* [**cookie中的Secure标志**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞经过验证后，您将获得奖励。

**在web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！在其兴起的日子里掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占据每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客攻击中获利！

{% embed url="https://hackenproof.com/register" %}

## 自动分析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静态分析**

![](<../../.gitbook/assets/image (61).png>)

使用一个漂亮的基于Web的前端对应用程序进行**漏洞评估**。您还可以执行动态分析（但需要准备环境）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
请注意，MobSF可以分析**Android**（apk）、**IOS**（ipa）和**Windows**（apx）应用程序（_Windows应用程序必须从安装在Windows主机上的MobSF进行分析_）。此外，如果您创建了一个包含**Android**或**IOS**应用程序源代码的**ZIP**文件（转到应用程序的根文件夹，选择所有内容并创建ZIP文件），MobSF也可以分析它。

MobSF还允许您进行**差异/比较**分析，并集成**VirusTotal**（您需要在_MobSF/settings.py_中设置API密钥并启用它：`VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`）。您还可以将`VT_UPLOAD`设置为`False`，然后将上传**哈希**而不是文件。

### 使用MobSF进行辅助动态分析

对于**Android**的**动态分析**，MobSF也非常有帮助，但在这种情况下，您需要在主机上安装MobSF和**genymotion**（虚拟机或Docker不起作用）。_注意：您需要**先启动genymotion中的虚拟机**，然后再启动MobSF。_\
MobSF动态分析器可以：

* **转储应用程序数据**（URL、日志、剪贴板、您创建的截图、由“导出的Activity测试器”创建的截图、电子邮件、SQLite数据库、XML文件和其他创建的文件）。除了截图外，所有这些都是自动完成的，您需要在需要截图时按下按钮，或者按下“导出的Activity测试器”以获取所有导出活动的截图。
* 捕获**HTTPS流量**
* 使用**Frida**获取**运行时信息**

从**Android版本> 5**开始，它将**自动启动Frida**并设置全局**代理**设置以**捕获**流量。它只会捕获被测试应用程序的流量。

**Frida**

默认情况下，它还使用一些Frida脚本来**绕过SSL证书固定**、**检测Root**和**检测调试器**，以及**监视有趣的API**。\
MobSF还可以**调用导出的活动**，抓取它们的**截图**并将它们保存到报告中。

要开始动态测试，请按下绿色按钮：“**开始仪器化**”。按下“**Frida实时日志**”以查看Frida脚本生成的日志，按下“**实时API监视器**”以查看所有被挂钩方法的调用、传递的参数和返回值（在按下“开始仪器化”后出现）。\
MobSF还允许您加载自己的**Frida脚本**（要将Friday脚本的结果发送到MobSF，请使用函数`send()`）。它还有**几个预写的脚本**可以加载（您可以在`MobSF/DynamicAnalyzer/tools/frida_scripts/others/`中添加更多），只需**选择它们**，按下“**加载**”，然后按下“**开始仪器化**”（您将能够在“**Frida实时日志**”中看到该脚本的日志）。

![](<../../.gitbook/assets/image (215).png>)

此外，您还有一些辅助的Frida功能：

* **枚举已加载的类**：它将打印所有已加载的类
* **捕获字符串**：在使用应用程序时，它将打印所有捕获的字符串（非常嘈杂）
* **捕获字符串比较**：可能非常有用。它将**显示正在比较的两个字符串**以及结果是True还是False。
* **枚举类方法**：输入类名（如“java.io.File”），它将打印类的所有方法。
* **搜索类模式**：按模式搜索类
* **跟踪类方法**：**跟踪**整个类（查看类的所有方法的输入和输出）。请记住，默认情况下，MobSF跟踪几个有趣的Android Api方法。

选择要使用的辅助模块后，需要按下“**开始仪器化**”，然后您将在“**Frida实时日志**”中看到所有输出。

**Shell**

Mobsf还提供了一个带有一些**adb**命令、**MobSF命令**和常见**shell命令**的shell，位于动态分析页面的底部。一些有趣的命令：
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP工具**

当捕获到HTTP流量时，你可以在“**HTTP(S) Traffic**”底部看到捕获到的流量的丑陋视图，或者在“**Start HTTPTools**”绿色按钮中看到更好的视图。从第二个选项开始，你可以将捕获到的请求发送到像Burp或Owasp ZAP这样的代理服务器。\
要这样做，_启动Burp -->_ _关闭拦截 --> 在MobSB HTTPTools中选择请求_ --> 按下“**Send to Fuzzer**” --> _选择代理地址_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))。

在使用MobSF进行动态分析后，你可以点击“**Start Web API Fuzzer**”来对HTTP请求进行模糊测试并寻找漏洞。

{% hint style="info" %}
在使用MobSF进行动态分析后，代理设置可能会配置错误，你将无法通过GUI修复它们。你可以通过以下方式修复代理设置：
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### 使用Inspeckage进行辅助动态分析

您可以从[**Inspeckage**](https://github.com/ac-pm/Inspeckage)获取该工具。\
该工具使用一些**Hooks**，让您了解在您执行**动态分析**时应用程序中发生了什么。

{% content-ref url="inspeckage-tutorial.md" %}
[inspeckage-tutorial.md](inspeckage-tutorial.md)
{% endcontent-ref %}

### [Yaazhini](https://www.vegabird.com/yaazhini/)

这是一个**用于执行带有GUI的静态分析的优秀工具**

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

该工具旨在查找几种**与安全相关的Android应用程序漏洞**，无论是在**源代码**还是**打包的APK**中。该工具还**能够创建一个“Proof-of-Concept”可部署的APK**和**ADB命令**，以利用找到的一些漏洞（暴露的活动、意图、tapjacking...）。与Drozer一样，无需对测试设备进行root操作。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* 显示所有提取的文件以便参考
* 自动将APK文件反编译为Java和Smali格式
* 分析AndroidManifest.xml以查找常见的漏洞和行为
* 静态源代码分析以查找常见的漏洞和行为
* 设备信息
* 意图
* 命令执行
* SQLite引用
* 日志引用
* 内容提供者
* 广播接收器
* 服务引用
* 文件引用
* 加密引用
* 硬编码的秘密
* URL
* 网络连接
* SSL引用
* WebView引用
```
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER是一个命令行应用程序，可在Windows、MacOS X和Linux上使用，用于分析_.apk_文件以寻找漏洞。它通过解压APK并应用一系列规则来检测这些漏洞。

所有规则都集中在一个`rules.json`文件中，每个公司或测试人员都可以创建自己的规则来分析他们所需的内容。

从[下载页面](https://superanalyzer.rocks/download.html)下载最新的二进制文件。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAn是一个**跨平台**工具，可帮助开发人员、漏洞赏金猎人和道德黑客对移动应用程序进行[静态代码分析](https://en.wikipedia.org/wiki/Static\_program\_analysis)。

其概念是您将移动应用程序文件（.apk或.ipa文件）拖放到StaCoAn应用程序上，它将为您生成一个可视化和便携的报告。您可以调整设置和词汇表以获得定制化的体验。

下载[最新版本](https://github.com/vincentcox/StaCoAn/releases)：
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs框架是一个Android漏洞分析系统，帮助开发者或黑客发现Android应用中的潜在安全漏洞。\
[Windows版本](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn** 是一个工具，其主要目的是检测并警告用户有关 Android 应用程序可能存在的恶意行为。

该工具通过对应用程序的 Dalvik 字节码进行静态分析来进行检测，字节码以 **Smali** 形式表示，并使用 [`androguard`](https://github.com/androguard/androguard) 库。

该工具寻找“坏”应用程序的常见行为，例如：泄露电话标识符、拦截音视频流、修改 PIM 数据、任意代码执行等。
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA** 是一个移动应用程序逆向工程和分析框架。它是一个将常用的移动应用程序逆向工程和分析工具集合在一起的工具，用于测试移动应用程序的OWASP移动安全威胁。其目标是使移动应用程序开发人员和安全专业人员更容易和友好地完成这项任务。

它能够：

* 使用不同的工具提取Java和Smali代码
* 使用以下工具分析APK：[smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)
* 使用正则表达式从APK中提取私人信息。
* 分析清单。
* 使用以下工具分析找到的域名：[pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh) 和 [whatweb](https://github.com/urbanadventurer/WhatWeb)
* 通过 [apk-deguard.com](http://www.apk-deguard.com) 对APK进行反混淆

### Koodous

用于检测恶意软件：[https://koodous.com/](https://koodous.com)

## 代码混淆/反混淆

请注意，根据您用于混淆代码的服务和配置，秘密信息可能会被混淆或未被混淆。

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

**ProGuard** 是一个开源的命令行工具，用于缩小、优化和混淆Java代码。它能够优化字节码并检测和删除未使用的指令。ProGuard是免费软件，根据GNU通用公共许可证第2版分发。

ProGuard作为Android SDK的一部分分发，并在发布模式下构建应用程序时运行。

来源：[https://en.wikipedia.org/wiki/ProGuard\_(software)](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

### [DexGuard](https://www.guardsquare.com/dexguard)

在[https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)中找到了一个逐步指南来反混淆APK

（来自该指南）我们上次检查时，Dexguard的操作模式是：

* 将资源作为InputStream加载；
* 将结果提供给继承自FilterInputStream的类以进行解密；
* 进行一些无用的混淆，以浪费逆向工程师的几分钟时间；
* 将解密后的结果提供给ZipInputStream以获取DEX文件；
* 最后使用`loadDex`方法将生成的DEX作为资源加载。

### [DeGuard](http://apk-deguard.com)

**DeGuard 反混淆了Android混淆工具执行的混淆过程。这使得可以进行多种安全分析，包括代码检查和预测库。**

您可以将混淆的APK上传到他们的平台。

### [Simplify](https://github.com/CalebFenton/simplify)

它是一个**通用的Android反混淆器**。Simplify **虚拟执行一个应用程序**以了解其行为，然后**尝试优化代码**，使其行为相同但更容易理解。每种优化类型都是简单和通用的，因此不管使用的具体混淆类型是什么都没有关系。

### [APKiD](https://github.com/rednaga/APKiD)

APKiD提供有关**APK的制作方式**的信息。它可以识别许多**编译器**、**打包工具**、**混淆工具**和其他奇怪的东西。它是Android的[_PEiD_](https://www.aldeid.com/wiki/PEiD)。

### 手动

[阅读此教程以了解一些关于**如何反向自定义混淆**的技巧](manual-deobfuscation.md)

## 实验室

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b是一个基于ubuntu-mate的Android安全虚拟机，包括来自不同安全极客和研究人员的最新框架、教程和实验室，用于逆向工程和恶意软件分析。

### OWASP

{% embed url="https://github.com/OWASP/owasp-mstg%0Ahttps://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06g-testing-network-communication" %}

### Git Repos

[https://github.com/riddhi-shree/nullCommunity/tree/master/Android](https://github.com/riddhi-shree/nullCommunity/tree/master/Android)\
[https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## 参考资料

了解更多信息，请访问：

* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 这是一个很棒的资源列表
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android快速课程
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)

## 测试

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof 是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞经过验证后，您将获得奖励。

**在web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！在其崛起之初掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占据每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register) 开始从您的黑客行动中获利！

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 您在**网络安全公司**工作吗？您想在HackTricks中看到您的**公司广告**吗？或者您想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现[**The PEASS Family**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注**我在**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>
