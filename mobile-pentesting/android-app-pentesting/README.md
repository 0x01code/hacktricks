# Androidアプリのペンテスト

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグバウンティの場です。**

**遅延なしで報酬を受け取る**\
HackenProofのバウンティは、顧客が報酬予算を入金した後にのみ開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペンテストの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！その成長期におけるweb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)して、ハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## Androidアプリの基礎知識

Androidセキュリティに関連する**最も重要な部分やAndroidアプリの中で最も危険なコンポーネント**について知るために、このページを読むことを強くお勧めします：

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB（Android Debug Bridge）

これはAndroidデバイス（エミュレートまたは物理）に接続するために必要な主要なツールです。\
これにより、コンピュータからデバイスを**USB**または**ネットワーク**で制御し、ファイルを**コピー**したり、アプリを**インストール**またはアンインストールしたり、**シェル**コマンドを実行したり、**バックアップ**を作成したり、**ログ**を読んだりすることができます。

adbの使用方法については、次の[**ADBコマンドのリスト**](adb-commands.md)を参照してください。

## Smali

時には、**アプリケーションのコードを変更**して、**隠された情報**（おそらくよく難読化されたパスワードやフラグ）にアクセスすることが興味深い場合があります。その場合、APKを逆コンパイルしてコードを変更し、再コンパイルすることが興味深いかもしれません。\
[**このチュートリアル**では、APKを逆コンパイルし、Smaliコードを変更し、新しい機能を持つAPKを再コンパイルする方法を学ぶことができます](smali-changes.md)。これは、動的解析中に行われるいくつかのテストの代替手段として非常に役立つ場合があります。常にこの可能性を念頭に置いてください。

## その他の興味深いトリック

* [Playストアでの位置のスプーフィング](spoofing-your-location-in-play-store.md)
* **APKのダウンロード**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* デバイスからAPKを抽出する：
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
## 静的解析

まず、APKを解析するためには、デコンパイラを使用してJavaコードを確認する必要があります。[ここで利用可能なさまざまなデコンパイラに関する情報を読んでください](apk-decompilers.md)。

### 興味深い情報の探索

APKの文字列を見るだけで、**パスワード**、**URL** ([https://github.com/ndelphit/apkurlgrep](https://github.com/ndelphit/apkurlgrep))、**API**キー、**暗号化**、**Bluetooth UUID**、**トークン**など、興味深い情報を検索できます。さらに、コード実行の**バックドア**や認証バックドア（アプリへのハードコードされた管理者の資格情報）を探すこともできます。

**Firebase**

特に**FirebaseのURL**に注意し、構成が正しくないかどうかを確認してください。[Firebaseとその悪用方法についての詳細情報はこちらを参照してください。](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### アプリケーションの基本的な理解 - Manifest.xml、strings.xml

[ここで](apk-decompilers.md)言及されているデコンパイラのいずれかを使用すると、_Manifest.xml_を読むことができます。また、**apk**ファイルの拡張子を**.zip**に変更して**解凍**することもできます。\
マニフェストを読むことで、以下の脆弱性を見つけることができます。

* まず、アプリケーションが**デバッグ可能**かどうかを確認してください。本番のAPKでは（他の人が接続できるようにするため）デバッグ可能ではありません。マニフェストで属性`debuggable="true"`を探すことで、アプリケーションがデバッグ可能かどうかを確認できます。例：`<application theme="@2131296387" debuggable="true"`
* [ここで](drozer-tutorial/#is-debuggeable)、電話でデバッグ可能なアプリケーションを見つけて悪用する方法を学びます。
* **バックアップ**：**`android:allowBackup`**属性は、USBデバッグを有効にしたユーザーがアプリケーションデータをバックアップおよび復元できるかどうかを定義します。バックアップフラグがtrueに設定されている場合、デバイスがルート化されていなくても、攻撃者はadbを介してアプリケーションデータのバックアップを取得できます。したがって、カードの詳細、パスワードなどの機密情報を処理および保存するアプリケーションは、この設定を明示的に**false**に設定する必要があります。デフォルトでは、これを防ぐために**true**に設定されています。
* `<application android:allowBackup="false"`
* **NetworkSecurity:** アプリケーションのネットワークセキュリティは、**`android:networkSecurityConfig="@xml/network_security_config"`**でデフォルト値を上書きすることができます。その名前のファイルを**res/xml**に配置することができます。このファイルでは、証明書のピンやHTTPトラフィックを許可するかどうかなど、重要なセキュリティ設定を構成します。ここで設定できるすべてのことについての詳細情報は[こちら](./#network-security)で読むことができますが、次の例は特定のドメインに対してHTTPトラフィックを設定する方法についてのものです：
* `<domain-config cleartextTrafficPermitted="true"> <domain includeSubdomains="true">formation-software.co.uk </domain></domain-config>`
* **エクスポートされたアクティビティ**：マニフェスト内のエクスポートされたアクティビティをチェックしてください。これは危険な場合があります。後で動的解析で[この動作を悪用する方法](./#exploiting-exported-activities-authorisation-bypass)を説明します。
* **コンテンツプロバイダー**：エクスポートされたプロバイダーが公開されている場合、興味深い情報にアクセス/変更できる可能性があります。動的解析では、[これらを悪用する方法](./#exploiting-content-providers-accessing-and-manipulating-sensitive-information)を学びます。
* `android:name="android.support.FILE_PROVIDER_PATHS"`という属性内の**FileProviders**の設定を確認してください。[FileProvidersについての詳細はこちらを読んでください](./#fileprovider)。
* **公開されたサービス**：サービスが内部で何を行っているかによって、脆弱性が悪用される可能性があります。動的解析では、[これらを悪用する方法](./#exploiting-services)を学びます。
* **ブロードキャストレシーバー**：[悪用の可能性がある方法](./#exploiting-broadcast-receivers)を学びます。
* **URLスキーム**：スキームを管理するアクティビティのコードを読み、ユーザーの入力を管理する際の脆弱性を探します。[URLスキームについての詳細はこちら](./#url-schemes)。
* **minSdkVersion**、**targetSDKVersion**、**maxSdkVersion**：これらはアプリが実行されるAndroidのバージョンを示しています。セキュリティの観点から、古いバージョンをサポートすることは、既知の脆弱性のあるAndroidのバージョンを実行することを許可するため、重要です。

**resources.arsc/strings.xml**を読むことで、いくつかの興味深い情報を見つけることができます。

* APIキー
* カスタムスキーマ
* 他の開発者がこのファイルに保存する興味深い情報

### タップジャッキング

**タップジャッキング**は、**悪意のあるアプリケーション**が起動し、**被害者アプリケーションの上に配置**される攻撃です。被害者アプリを視覚的に隠し、ユーザーがそれと対話するように見せかけながら、実際には被害者アプリに対して操作を行っています。

この攻撃に対して脆弱なアプリを検出するためには、Androidマニフェストで**エクスポートされたアクティビティ**を検索する必要があります（インテントフィルタを持つアクティビティはデフォルトで自動的にエクスポートされます）。エクスポートされたアクティビティを見つけたら、**必要なパーミッションがあるかどうかを確認**することが重要です。なぜなら、**悪意のあるアプリケーションもそのパーミッションが必要**だからです。\
最後に、コード内で**`setFilterTouchesWhenObscured`**の設定があるかどうかを確認することが重要です。これが**`true`**に設定されている場合、ボタンは自動的に無効になる可能性があります。
```markup
<Button android:text="Button"
android:id="@+id/button1"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:filterTouchesWhenObscured="true">
</Button>
```
[**qark**](https://github.com/linkedin/qark)を`--exploit-apk` --sdk-path `/Users/username/Library/Android/sdk`のパラメータと共に使用して、潜在的な**Tapjacking**の脆弱性をテストするための悪意のあるアプリケーションを作成することができます。\
この種の機能を実装した例のプロジェクトは、[**FloatingWindowApp**](https://github.com/aminography/FloatingWindowApp)で見つけることができます。

対策は比較的簡単で、開発者は他のビューによってカバーされている場合にタッチイベントを受け取らないように選択することができます。[Android Developer’s Reference](https://developer.android.com/reference/android/view/View#security)を使用して次のように説明されています：

> ユーザーの完全な知識と同意のもとでアクションが実行されていることをアプリケーションが確認できることは、許可リクエストの許可、購入の実行、広告のクリックなど、いくつかの場合において重要です。残念ながら、悪意のあるアプリケーションは、意図したビューの目的を隠してユーザーにこれらのアクションを実行させようとすることがあります。この問題に対処するために、フレームワークはセキュリティを向上させるために使用できるタッチフィルタリングメカニズムを提供しています。
>
> タッチフィルタリングを有効にするには、[`setFilterTouchesWhenObscured(boolean)`](https://developer.android.com/reference/android/view/View#setFilterTouchesWhenObscured%28boolean%29)を呼び出すか、android:filterTouchesWhenObscuredレイアウト属性をtrueに設定します。有効にすると、フレームワークは、ビューのウィンドウが他の表示ウィンドウによって隠されている場合に受け取ったタッチを破棄します。その結果、ビューは、トースト、ダイアログ、または他のウィンドウがビューのウィンドウの上に表示されている場合にタッチを受け取りません。

### タスクハイジャッキング

**`launchMode`**を**`singleTask`**に設定し、**`taskAffinity`**を定義しない**アクティビティ**は、タスクハイジャッキングの脆弱性があります。つまり、**アプリケーション**がインストールされ、実際のアプリケーションよりも先に起動された場合、**実際のアプリケーションのタスクをハイジャック**することができます（ユーザーは**実際のアプリケーションを使用していると思い込んで**悪意のあるアプリケーションとやり取りします）。

詳細は以下を参照してください：

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### 安全でないデータの保存

**内部ストレージ**

内部ストレージに作成されたファイルは、**アプリケーション**のみがアクセスできます。この保護はAndroidによって実装されており、ほとんどのアプリケーションには十分です。しかし、開発者はしばしば`MODE_WORLD_READBALE`および`MODE_WORLD_WRITABLE`を使用して、これらのファイルに別のアプリケーションへのアクセスを許可しますが、これにより他のアプリ（悪意のあるアプリ）がそれらにアクセスすることは制限されません。\
**静的**解析では、これらの**モード**の使用をチェックし、**動的**解析では作成されたファイルの**許可**をチェックします（おそらくいくつかのファイルはグローバルに読み取り/書き込み可能です）。\
[この脆弱性についての詳細と修正方法はこちらを参照してください。](https://manifestsecurity.com/android-application-security-part-8/)

**外部ストレージ**

SDカードなどの**外部ストレージ**に作成されたファイルは、**グローバルに読み取りおよび書き込み可能**です。外部ストレージはユーザーによって取り外され、また任意のアプリケーションによって変更される可能性があるため、**外部ストレージを使用して機密情報を保存しないでください**。\
信頼できないソースからのデータと同様に、**外部ストレージからのデータを処理する際には入力検証を実行**する必要があります。動的ローディングの前に、実行可能ファイルやクラスファイルを外部ストレージに保存しないことを強くお勧めします。アプリが外部ストレージから実行可能ファイルを取得する場合は、ファイルを署名し、動的ローディングの前に暗号的に検証する必要があります。\
情報は[こちら](https://manifestsecurity.com/android-application-security-part-8/)から取得しました。

外部ストレージは`/storage/emulated/0`、`/sdcard`、`/mnt/sdcard`で**アクセス**できます。

{% hint style="info" %}
Android 4.4（**API 17**）以降、SDカードにはアプリケーションごとに特定のディレクトリにアクセスを**制限するディレクトリ構造**があります。これにより、悪意のあるアプリケーションが他のアプリのファイルに読み取りまたは書き込みアクセスを取得することが防止されます。
{% endhint %}

**クリアテキストで保存された機密データ**

* **共有プリファレンス**：Androidは、各アプリケーションが簡単にxmlファイルを`/data/data/<packagename>/shared_prefs/`のパスに保存できるようにします。そして、そのフォルダにクリアテキストで機密情報を見つけることができる場合があります。
* **データベース**：Androidは、各アプリケーションが簡単にsqliteデータベースを`/data/data/<packagename>/databases/`のパスに保存できるようにします。そして、そのフォルダにクリアテキストで機密情報を見つけることができる場合があります。

### 破損したTLS

**すべての証明書を受け入れる**

何らかの理由で、ホスト名が一致しない場合でも、開発者はすべての証明書を受け入れることがあります。以下のようなコード行で証明書を受け入れることがあります：
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
このテストを行う良い方法は、デバイス内でBurp CAの承認をせずに、Burpのようなプロキシを使用してトラフィックをキャプチャしようとすることです。また、Burpを使用して異なるホスト名の証明書を生成し、それを使用することもできます。

### 破損した暗号化

**鍵管理プロセスの不備**

一部の開発者は、機密データをローカルストレージに保存し、コード内でハードコード/予測可能なキーで暗号化しています。これは行ってはいけません。リバースエンジニアリングによって攻撃者が機密情報を抽出することができる可能性があるためです。

**安全でないおよび/または非推奨のアルゴリズムの使用**

開発者は、**非推奨のアルゴリズム**を使用して**認証のチェック**、**データの保存**または**送信**を行うべきではありません。これらのアルゴリズムのいくつかは、RC4、MD4、MD5、SHA1などです。たとえば、パスワードを保存するためにハッシュが使用される場合、ソルトを使用したハッシュブルートフォース**耐性**が必要です。

### その他のチェック

* APKを**難読化**することをお勧めします。これにより、逆向きエンジニアリングの作業が攻撃者にとって困難になります。
* アプリが機密情報（銀行アプリなど）である場合、モバイルがルート化されているかどうかを**独自にチェック**し、それに応じて動作する必要があります。
* アプリが機密情報（銀行アプリなど）である場合、エミュレータが使用されているかどうかをチェックする必要があります。
* アプリが機密情報（銀行アプリなど）である場合、実行する前に**独自の整合性をチェック**する必要があります。それが変更されたかどうかを確認するためです。
* APKのビルドに使用されたコンパイラ/パッカー/難読化ツールをチェックするために、[**APKiD**](https://github.com/rednaga/APKiD)を使用します。

### React Nativeアプリケーション

ReactアプリケーションのJavaScriptコードに簡単にアクセスする方法を学ぶには、次のページを読んでください：

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### Xamarinアプリケーション

XamarinアプリケーションのC#コードに簡単にアクセスする方法を学ぶには、次のページを読んでください：

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### スーパーパックされたアプリケーション

この[**ブログ記事**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)によると、スーパーパックはアプリケーションのコンテンツを1つのファイルに圧縮するメタアルゴリズムです。このブログでは、この種のアプリを解凍するアプリを作成する可能性について説明しています... および**アプリケーションを実行し、ファイルシステムから解凍されたファイルを収集する**より速い方法についても説明しています。

### 自動静的コード分析

ツール[**mariana-trench**](https://github.com/facebook/mariana-trench)は、アプリケーションのコードをスキャンして**脆弱性**を見つけることができます。このツールには、**既知のソース**（ユーザーによって**制御される入力**の**場所**をツールに示す）と**シンク**（悪意のあるユーザーの入力が損害を引き起こす可能性のある**危険な場所**をツールに示す）が含まれています。また、これらのルールは、脆弱性を示す**ソース-シンク**の組み合わせを示しています。

この知識を活用して、**mariana-trenchはコードをレビューし、可能な脆弱性を見つけます**。

### 漏洩した秘密情報

アプリケーションには、発見できるかもしれない秘密情報（APIキー、パスワード、隠されたURL、サブドメインなど）が含まれている場合があります。[https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)のようなツールを使用してこれらの情報を発見できます。

### バイオメトリック認証のバイパス

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### その他の興味深い機能

* **コードの実行**: `Runtime.exec(), ProcessBuilder(), native code:system()`
* **SMSの送信**: `sendTextMessage, sendMultipartTestMessage`
* `native`と宣言された**ネイティブ関数**: `public native, System.loadLibrary, System.load`
* [ネイティブ関数を**リバースエンジニアリングする方法**については、こちらを読んでください](reversing-native-libraries.md)

### **その他のトリック**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグバウンティの場所です。**

**遅延なしで報酬を受け取る**\
HackenProofのバウンティは、顧客が報酬予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！成長するWeb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグで評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)して、ハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

***

## 動的解析

> まず、アプリケーションとすべての環境（Burp CA証明書、Drozer、Fridaなど）をインストールできる環境が必要です。したがって、ルート化されたデバイス（エミュレートされているかどうかに関係なく）が非常におすすめです。

### オンライン動的解析

[https://appetize.io/](https://appetize.io)で**無料アカウント**を作成できます。このプラットフォームでは、APKを**アップロード**して**実行**することができるため、APKの動作を確認するのに便利です。

Web上でアプリケーションのログを**表示**し、**adb**を介して接続することもできます。

![](<../../.gitbook
#### 物理デバイスを使用する

デバッグオプションを有効にする必要があります。また、**ルート化**できると良いです。

1. **設定**を開きます。
2. (Android 8.0以降) **システム**を選択します。
3. **端末について**を選択します。
4. **ビルド番号**を7回押します。
5. 戻り、**開発者オプション**を見つけます。

> アプリケーションをインストールした後、最初に行うべきことは、それを試して調査し、それが何をするのか、どのように動作するのかを調べ、それに慣れることです。\
> MobSFの動的解析+pidcatを使用して、この初期の動的解析を実行することをお勧めします。これにより、MobSFが後で確認できる多くの興味深いデータを**キャプチャ**しながら、アプリケーションの動作を学ぶことができます。

### 意図しないデータ漏洩

**ログ**

開発者はデバッグ情報を公開することがよくあります。そのため、`READ_LOGS`権限を持つアプリケーションは、それらのログにアクセスし、それを通じて機密情報を取得することができます。\
アプリケーションを操作する際には、作成されたログを読むために[**pidcat**](https://github.com/JakeWharton/pidcat)_(おすすめ、使用しやすく読みやすい)_または[adb logcat](adb-commands.md#logcat)を使用して、**機密情報**を探します。

{% hint style="warning" %}
Android 4.0以降の**後のバージョンでは、アプリケーションは自分自身のログにのみアクセスできる**ようになりました。したがって、アプリケーションは他のアプリのログにアクセスすることはできません。\
それでも、**機密情報をログに記録しない**ことをお勧めします。
{% endhint %}

**コピー/ペーストバッファのキャッシュ**

Androidは、Androidアプリケーションでコピー＆ペースト機能を提供するための**クリップボードベースの**フレームワークを提供しています。しかし、これにより、**他のアプリケーション**が一部の機密データを含む**クリップボード**にアクセスできる重大な問題が発生します。**機密な部分**のコピー/ペースト機能は**無効化**する必要があります。たとえば、クレジットカードの詳細をコピーすることを無効にします。

**クラッシュログ**

アプリケーションが実行中にクラッシュし、ログをどこかに保存する場合、それらのログは、特にAndroidアプリケーションが逆アセンブルできない場合に、攻撃者にとって役立つことがあります。そのため、アプリケーションがクラッシュしたときにログを作成しないようにし、ログがネットワーク経由で送信される場合は、SSLチャネルを介して送信されることを確認してください。\
ペンテスターとして、これらのログを確認してみてください。

**サードパーティへの解析データの送信**

ほとんどのアプリケーションは、Google AdSenseなどの他のサービスをアプリケーションで使用しますが、時には**機密データ**やそのサービスに送信する必要のないデータが**漏洩**することがあります。これは、開発者が機能を適切に実装していないために発生する可能性があります。アプリケーションのトラフィックを傍受して、サードパーティに機密データが送信されているかどうかを確認できます。

### SQLiteデータベース

ほとんどのアプリケーションは、情報を保存するために**内部のSQLiteデータベース**を使用します。ペンテスト中に作成された**データベース**、**テーブル**と**カラム**の名前、および保存されている**データ**を確認してください。そこには**機密情報**が含まれている可能性があります（これは脆弱性です）。\
データベースは、`/data/data/the.package.name/databases`のように`/data/data/com.mwr.example.sieve/databases`に配置されるべきです。

データベースが機密情報を保存しており、**暗号化されている**が、アプリケーション内に**パスワード**が見つかる場合、それは依然として**脆弱性**です。

`.tables`を使用してテーブルを列挙し、`.schema <table_name>`を使用してテーブルの列を列挙します。

### Drozer（エクスポートされたアクティビティ、コンテンツプロバイダ、サービスの攻撃）

**Drozer**を使用すると、Androidアプリの役割を**仮定**し、他のアプリと対話することができます。Androidのプロセス間通信（IPC）メカニズムを利用したり、基礎となるオペレーティングシステムと対話したりするなど、**インストールされたアプリケーションができることは何でもできます**。[Drozerガイド](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)から。

Drozerは、以下のセクションで学ぶように、**エクスポートされたアクティビティ、エクスポートされたサービス、コンテンツプロバイダ**を攻撃するための便利なツールです。

### エクスポートされたアクティビティの攻撃

[**Androidアクティビティとは何かを思い出したい場合は、こちらを読んでください。**](android-applications-basics.md#launcher-activity-and-other-activities)\
また、アクティビティのコードは`onCreate`メソッドで始まります。

**認証バイパス**

アクティビティがエクスポートされている場合、外部のアプリからその画面を呼び出すことができます。したがって、**機密情報**を含むアクティビティが**エクスポート**されている場合、**認証**メカニズムを**バイパス**してアクセスすることができます。\
[Drozerを使用してエクスポートされたアクティビティを攻撃する方法を学びましょう。](drozer-tutorial/#activities)

また、adbからエクスポートされたアクティビティを起動することもできます：

* パッケージ名はcom.example.demoです。
* エクスポートされたアクティビティ名はcom.example.test.MainActivityです。
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**注意**: MobSFは、アクティビティの`android:launchMode`としての_singleTask/singleInstance_の使用を悪意のあるものとして検出しますが、[こちら](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)によると、これは古いバージョン（APIバージョン<21）ではのみ危険です。

{% hint style="info" %}
注意：認証バイパスは常に脆弱性ではありません。バイパスの動作方法と公開される情報によって異なります。
{% endhint %}

**機密情報の漏洩**

**アクティビティは結果を返すこともできます**。エクスポートされて保護されていないアクティビティが、**`setResult`**メソッドを呼び出し、**機密情報を返す**場合、機密情報の漏洩が発生します。

#### タップジャッキング

タップジャッキングが防止されていない場合、エクスポートされたアクティビティを悪用して、**ユーザーに予期しない操作を実行**させることができます。[**タップジャッキングとは何かについての詳細は、リンクを参照してください**](./#tapjacking)。

### コンテンツプロバイダの悪用 - 機密情報へのアクセスと操作

[**コンテンツプロバイダとは何かを思い出したい場合は、こちらを読んでください。**](android-applications-basics.md#content-provider)\
コンテンツプロバイダは基本的にはデータの共有に使用されます。アプリに利用可能なコンテンツプロバイダがある場合、それらから**機密データを抽出**することができるかもしれません。また、**SQLインジェクション**や**パストラバーサル**の可能性もテストすることが重要です。これらは脆弱性のある可能性があります。\
[**Drozerを使用してコンテンツプロバイダを悪用する方法を学びましょう。**](drozer-tutorial/#content-providers)

### **サービスの悪用**

[**サービスとは何かを思い出したい場合は、こちらを読んでください。**](android-applications-basics.md#services)\
サービスのアクションは、`onStartCommand`メソッドで開始されます。

サービスは基本的には**データを受け取り**、**処理**し、**応答**（またはしない場合もあります）するものです。したがって、アプリケーションがいくつかのサービスをエクスポートしている場合は、コードを**チェック**して何をしているのかを理解し、機密情報の抽出、認証手段のバイパスなどを**動的に**テストする必要があります。\
[**Drozerを使用してサービスを悪用する方法を学びましょう。**](drozer-tutorial/#services)

### **ブロードキャストレシーバの悪用**

[**ブロードキャストレシーバとは何かを思い出したい場合は、こちらを読んでください。**](android-applications-basics.md#broadcast-receivers)\
ブロードキャストレシーバのアクションは、`onReceive`メソッドで開始されます。

ブロードキャストレシーバは特定のタイプのメッセージを待機しています。レシーバがメッセージをどのように処理するかによって、脆弱性がある可能性があります。\
[**Drozerを使用してブロードキャストレシーバを悪用する方法を学びましょう。**](./#exploiting-broadcast-receivers)

### **スキーム/ディープリンクの悪用**

MobSFのようなツールや[このスクリプト](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)などを使用して、ディープリンクを手動で検索できます。\
**adb**または**ブラウザ**を使用して、宣言された**スキーム**を**開く**ことができます。

{% code overflow="wrap" %}
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_パッケージ名を省略することができることに注意してください。モバイルは自動的にそのリンクを開くべきアプリを呼び出します。_

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**実行されるコード**

アプリで実行されるコードを見つけるためには、ディープリンクによって呼び出されるアクティビティに移動し、**`onNewIntent`**という関数を検索します。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**機密情報**

ディープリンクを見つけるたびに、URLパラメータを介して機密データ（パスワードなど）が送信されていないかを確認してください。なぜなら、他のアプリケーションがディープリンクをなりすましてそのデータを盗む可能性があるからです。

**パス内のパラメータ**

URLのパス内にパラメータを使用しているディープリンクがあるかどうかも確認する必要があります。例えば、`https://api.example.com/v1/users/{username}`のような場合、`example://app/users?username=../../unwanted-endpoint%3fparam=value`のようにパストラバーサルを強制することができます。\
ただし、アプリケーション内で正しいエンドポイントを見つけることができれば、**オープンリダイレクト**（パスの一部がドメイン名として使用される場合）、**アカウント乗っ取り**（CSRFトークンなしでユーザーの詳細を変更できる場合）、その他の脆弱性を引き起こす可能性があります。詳細は[こちら](http://dphoeniixx.com/2020/12/13-2/)を参照してください。

**その他の例**

リンクに関する興味深いバグ報奨金レポートは[こちら](https://hackerone.com/reports/855618)です。

### 不十分なトランスポート層保護

* **証明書の検査の欠如:** Androidアプリケーションは、それに提示された証明書の正当なチェーンを信頼された（ルート）証明書に戻すことができません。ほとんどのアプリケーションは警告を無視し、自己署名証明書を受け入れます。一部のアプリケーションは代わりにトラフィックをHTTP接続経由で送信します。
* **弱いハンドシェイクの交渉:** アプリケーションとサーバーはSSL/TLSハンドシェイクを実行しますが、MITM攻撃に対して脆弱な暗号スイートを使用します。したがって、攻撃者はその接続を簡単に復号することができます。
* **プライバシー情報の漏洩:** アプリケーションはセキュアなチャネルを介して認証を行うことが多いですが、その他の接続は非セキュアなチャネルを介して行われます。これはアプリケーションのセキュリティに貢献しません。なぜなら、セッションクッキーやユーザーデータなどの他の機密データが悪意のあるユーザーによって傍受される可能性があるからです。

提示された3つのシナリオのうち、**証明書の正当性を検証する方法**について説明します。他の2つのシナリオは、サーバーの**TLS設定**とアプリケーションが**暗号化されていないデータを送信**するかどうかに依存します。ペンテスターは、サーバーのTLS設定を自分でチェックし、[こちら](../../network-services-pentesting/pentesting-web/#ssl-tls-vulnerabilites)で**機密情報が暗号化されていない/脆弱な**チャネルを介して送信されていないかを検出する必要があります。\
この種の脆弱性を発見し修正する方法の詳細は[**こちら**](https://manifestsecurity.com/android-application-security-part-10/)を参照してください。

**SSLピニング**

デフォルトでは、SSL接続を行う際に、クライアント（Androidアプリ）はサーバーの証明書が信頼された（ルート）証明書に対して検証可能な信頼チェーンを持ち、要求されたホスト名と一致するかどうかをチェックします。これにより、**中間者攻撃（MITM）**の問題が発生します。\
証明書ピニングでは、Androidアプリケーション自体がサーバーの証明書を含み、同じ証明書が提示された場合にのみデータを送信します。\
**機密情報が送信される可能性のあるサイトには、SSLピニングを適用することをお勧めします。**

### HTTPトラフィックの検査

まず、使用する**プロキシツール**（おそらくBurp）の**証明書をインストール**する必要があります。プロキシツールのCA証明書をインストールしない場合、プロキシで暗号化されたトラフィックは表示されません。\
**カスタムCA証明書をインストールする方法については、[このガイドを読んでください](android-burp-suite-settings.md)**。

**APIレベル24以上を対象とするアプリケーションの場合、デバイスにBurp CA証明書をインストールするだけでは不十分です。この新しい保護をバイパスするには、ネットワークセキュリティ構成ファイルを変更する必要があります。したがって、このファイルを変更してCA証明書を承認するか、[**こちらのページを読んで、アプリケーションがデバイスにインストールされたすべての証明書を再度受け入れるようにする方法について学んでください**](make-apk-accept-ca-certificate.md)。

**SSLピニング**

すでに2つ前でSSLピニングについて説明しました。アプリケーションでSSLピニングが実装されている場合、HTTPSトラフィックを検査するためにはそれをバイパスする必要があります。\
ここでは、この保護をバイパスするために使用したいくつかのオプションを紹介します。

* [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)を使用して、自動的にapkを変更してSSLピニングをバイパスします。このオプションの最大の利点は、SSLピニングをバイパスするためにルート化が必要ないことですが、アプリケーションを削除して新しいものを再インストールする必要があり、これが常に機能するわけではありません。
* この保護をバイパスするために**Frida**（以下で説明）を使用することもできます。Burp+Frida+Genymotionの使用方法については、[こちらのガイド](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)を参照してください。
* [**objection**](frida-tutorial/objection-tutorial.md)を使用して、**自動的にSSLピニングをバイパス**することもできます: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* **MobSFの動的解析**を使用して、**自動的にSSLピニングをバイパス**することもできます（以下で説明）。
* ま
### **メモリのダンプ - Fridump**

アプリケーションがパスワードやニーモニックなど、保存すべきでない機密情報をメモリ内に保存していないかを確認します。

[**Fridump3**](https://github.com/rootbsd/fridump3)を使用して、アプリのメモリをダンプすることができます。以下のコマンドを実行します。
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
これにより、./dumpフォルダにメモリがダンプされます。そこで、次のようにgrepを使用して検索できます：

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Keystoreにおける機密データ**

Androidでは、Keystoreは機密データを保存するための最適な場所ですが、特権を持っていればそれにアクセスすることができます。アプリケーションはここに機密データを平文で保存する傾向があるため、ペントテストではrootユーザーまたはデバイスへの物理的アクセスを持つ人物がこのデータを盗むことができるかどうかを確認する必要があります。

たとえアプリがKeystoreにデータを保存していたとしても、データは暗号化されるべきです。

Keystore内のデータにアクセスするには、次のFridaスクリプトを使用できます：[https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **Androidアプリケーションアナライザー**

このツールは、動的解析中にさまざまなツールを管理するのに役立ちます：[https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### インテントインジェクション

この脆弱性は、Webセキュリティの**オープンリダイレクト**に似ています。クラス`Intent`は`Parcelable`であるため、このクラスに属するオブジェクトは、別の`Intent`オブジェクトの**追加データ**として**渡すことができます**。\
多くの開発者は、この**機能**を利用して、`startActivity(...)`、`sendBroadcast(...)`などの危険なメソッドに埋め込まれた`Intent`を受け取り、それを渡す**プロキシコンポーネント**（アクティビティ、ブロードキャストレシーバー、サービス）を作成します。\
これは危険です。なぜなら、**攻撃者はアプリを強制的に起動させることができる非公開コンポーネントを起動させる**ことができず、または攻撃者にコンテンツプロバイダへのアクセス権限を与えることができるからです。**`WebView`**は、`Intent.parseUri(...)`メソッドを使用して、文字列から`Intent`オブジェクトに**URLを変更**し、それを`startActivity(...)`に渡すこともあります。

### Androidクライアントサイドインジェクションとその他

おそらく、Webからこの種の脆弱性については知っているでしょう。Androidアプリケーションでは、特に次の脆弱性に注意する必要があります：

* **SQLインジェクション：** 動的クエリやコンテンツプロバイダを扱う場合は、パラメータ化されたクエリを使用していることを確認してください。
* **JavaScriptインジェクション（XSS）：** 任意のWebViewでJavaScriptとプラグインサポートが無効になっていることを確認してください（デフォルトで無効になっています）。[詳細はこちら](webview-attacks.md#javascript-enabled)。
* **ローカルファイルインクルージョン：** 任意のWebViewでファイルシステムアクセスが無効になっていることを確認してください（デフォルトで有効になっています）（`webview.getSettings().setAllowFileAccess(false);`）。[詳細はこちら](webview-attacks.md#javascript-enabled)。
* **永続的なクッキー：** Androidアプリケーションがセッションを終了する場合、クッキーが取り消されない場合があります。また、クッキーがディスクに保存される場合もあります。
* [**クッキーのセキュアフラグ**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグ報奨金の場所です。**

**遅延なしで報酬を受け取る**\
HackenProofの報奨金は、顧客が報奨金予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントテストの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！成長するWeb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグで評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)してハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## 自動解析

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**静的解析**

![](<../../.gitbook/assets/image (61).png>)

**アプリケーションの脆弱性評価**を行うための素晴らしいWebベースのフロントエンド。動的解析も実行できます（ただし、環境を準備する必要があります）。
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSFは、**Android**(apk)**、IOS**(ipa)、およびWindows**(apx)アプリケーションを分析することができます（Windowsアプリケーションは、WindowsホストにインストールされたMobSFから分析する必要があります）。
また、**Android**または**IOS**アプリのソースコードをZIPファイルに作成すると（アプリケーションのルートフォルダに移動し、すべてを選択してZIPファイルを作成する）、それも分析することができます。

MobSFは、**diff/Compare**分析や**VirusTotal**の統合も可能です（_MobSF/settings.py_にAPIキーを設定し、有効にする必要があります: `VT_ENABLED = TRUE` `VT_API_KEY = <Your API key>` `VT_UPLOAD = TRUE`）。また、`VT_UPLOAD`を`False`に設定すると、ファイルの代わりに**ハッシュ**がアップロードされます。

### MobSFによるアシストされた動的分析

**MobSF**は、**Android**での動的分析にも非常に役立ちますが、その場合は、ホストにMobSFと**genymotion**をインストールする必要があります（VMやDockerでは動作しません）。_注意: **まずgenymotionでVMを起動**し、**その後にMobSFを起動する必要があります**。_
**MobSFの動的アナライザ**は以下のことができます:

* **アプリケーションデータのダンプ**（URL、ログ、クリップボード、自分が作成したスクリーンショット、"**Exported Activity Tester**"によって作成されたスクリーンショット、メール、SQLiteデータベース、XMLファイル、およびその他の作成されたファイル）。これらは自動的に行われますが、スクリーンショットは必要な時に押すか、すべてのエクスポートされたアクティビティのスクリーンショットを取得するために"**Exported Activity Tester**"を押す必要があります。
* **HTTPSトラフィックのキャプチャ**
* **Frida**を使用して**ランタイム情報**を取得する

Androidの**バージョン5以降**では、**自動的にFridaを起動**し、グローバル**プロキシ**設定を**キャプチャ**トラフィックに設定します。テストされたアプリケーションからのトラフィックのみキャプチャされます。

**Frida**

デフォルトでは、SSLピニングの**バイパス**、**ルート検出**および**デバッガ検出**、および**興味深いAPIのモニタリング**のために、いくつかのFridaスクリプトも使用されます。
MobSFはまた、エクスポートされたアクティビティを**呼び出し**、それらのスクリーンショットを**取得**してレポートに**保存**することもできます。

動的テストを**開始**するには、緑色のボタン "**Start Instrumentation**" を押します。Fridaスクリプトによって生成されたログを表示するには "**Frida Live Logs**" を押し、フックされたメソッドの呼び出し、渡された引数、および返された値を表示するには "**Live API Monitor**" を押します（これは "Start Instrumentation" を押した後に表示されます）。
MobSFはまた、独自の**Fridaスクリプト**をロードすることもできます（MobSFに結果を送信するためにFridayスクリプトの`send()`関数を使用します）。また、ロードできる**いくつかの事前に書かれたスクリプト**もあります（`MobSF/DynamicAnalyzer/tools/frida_scripts/others/`に追加することもできます）。スクリプトを選択し、"**Load**" を押し、"**Start Instrumentation**" を押します（そのスクリプトのログを "**Frida Live Logs**" 内で表示できます）。

![](<../../.gitbook/assets/image (215).png>)

さらに、いくつかの補助的なFrida機能があります:

* **ロードされたクラスの列挙**: ロードされたすべてのクラスを表示します
* **文字列のキャプチャ**: アプリケーションの使用中にキャプチャされたすべての文字列を表示します（非常にノイズが多いです）
* **文字列の比較のキャプチャ**: 非常に便利です。比較された2つの文字列と結果（TrueまたはFalse）を表示します。
* **クラスメソッドの列挙**: クラス名（例: "java.io.File"）を入力すると、クラスのすべてのメソッドを表示します。
* **クラスパターンの検索**: パターンに一致するクラスを検索します
* **クラスメソッドのトレース**: クラス全体をトレースします（クラスのすべてのメソッドの入力と出力を表示します）。デフォルトでは、MobSFはいくつかの興味深いAndroid APIメソッドをトレースします。

使用する補助モジュールを選択したら、"**Start Intrumentation**" を押して、すべての出力を "**Frida Live Logs**" で確認できます。

**シェル**

MobSFには、動的分析ページの一番下に、いくつかの**adb**コマンド、**MobSFコマンド**、および一般的な**シェルコマンド**が含まれています。いくつかの興味深いコマンド:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTPツール**

HTTPトラフィックがキャプチャされると、キャプチャされたトラフィックの見た目は「**HTTP(S) Traffic**」の下に見えるか、より見やすいビューは「**Start HTTPTools**」の緑のボタンで表示されます。2番目のオプションから、キャプチャされたリクエストをBurpやOwasp ZAPのようなプロキシに**送信**することができます。\
そのためには、_Burpを起動してください --> Interceptをオフにしてください --> MobSB HTTPToolsでリクエストを選択_ --> "**Send to Fuzzer**"を押してください --> ([http://127.0.0.1:8080\\](http://127.0.0.1:8080))のようなプロキシアドレスを選択してください。

MobSFで動的解析を終えたら、「**Start Web API Fuzzer**」を押して、HTTPリクエストを**ファズ**し、脆弱性を探すことができます。

{% hint style="info" %}
MobSFで動的解析を行った後、プロキシ設定が誤っている場合、GUIから修正することができません。プロキシ設定を修正するには、以下の手順を実行してください:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Inspeckageによるアシストされた動的解析

[**Inspeckage**](https://github.com/ac-pm/Inspeckage)からツールを入手できます。\
このツールは、**フック**を使用して、**動的解析**を実行する際にアプリケーションで**何が起こっているかを知る**ことができます。

{% content-ref url="inspeckage-tutorial.md" %}
[inspeckage-tutorial.md](inspeckage-tutorial.md)
{% endcontent-ref %}

### [Yaazhini](https://www.vegabird.com/yaazhini/)

これは、GUIを使用して**静的解析を実行するための優れたツール**です。

![](<../../.gitbook/assets/image (527).png>)

### [Qark](https://github.com/linkedin/qark)

このツールは、**ソースコード**または**パッケージ化されたAPK**内のいくつかの**セキュリティ関連のAndroidアプリケーションの脆弱性**を検索するために設計されています。このツールはまた、見つかった脆弱性の一部（公開されたアクティビティ、インテント、タップジャッキングなど）を悪用するための「Proof-of-Concept」展開可能なAPKとADBコマンドを作成することもできます。Drozerと同様に、テストデバイスをルート化する必要はありません。
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* 簡単な参照のためにすべての抽出されたファイルを表示します
* APKファイルを自動的にJavaおよびSmali形式に逆コンパイルします
* 一般的な脆弱性と動作のためのAndroidManifest.xmlの分析
* 一般的な脆弱性と動作のための静的ソースコード分析
* デバイス情報
* インテント
* コマンドの実行
* SQLiteの参照
* ロギングの参照
* コンテンツプロバイダー
* ブロードキャストレシーバー
* サービスの参照
* ファイルの参照
* 暗号の参照
* ハードコードされた秘密情報
* URL
* ネットワーク接続
* SSLの参照
* WebViewの参照
```
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPERは、Windows、MacOS X、Linuxで使用できるコマンドラインアプリケーションで、脆弱性を検出するために_.apk_ファイルを分析します。これは、APKを展開し、一連のルールを適用して脆弱性を検出することによって行われます。

すべてのルールは、`rules.json`ファイルに集約されており、各企業やテスターは必要なものを分析するために独自のルールを作成することができます。

最新のバイナリは[ダウンロードページ](https://superanalyzer.rocks/download.html)からダウンロードしてください。
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (62).png>)

StaCoAnは、モバイルアプリケーションの[静的コード解析](https://en.wikipedia.org/wiki/Static\_program\_analysis)を実行する開発者、バグバウンティハンター、倫理的ハッカーを支援する**クロスプラットフォーム**ツールです\*。

このツールでは、モバイルアプリケーションファイル（.apkまたは.ipaファイル）をStaCoAnアプリケーションにドラッグアンドドロップすると、視覚的でポータブルなレポートが生成されます。設定やワードリストを調整して、カスタマイズされた体験を得ることができます。

[最新リリース](https://github.com/vincentcox/StaCoAn/releases)をダウンロードしてください。
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Frameworkは、開発者やハッカーがAndroidアプリケーションの潜在的なセキュリティ脆弱性を見つけるのを支援するAndroid脆弱性分析システムです。\
[Windowsリリース](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**は、主な目的はAndroidアプリケーションによって開発された潜在的な悪意のある振る舞いを検出し、ユーザーに警告することです。

検出は、アプリケーションのDalvikバイトコード（Smali形式）の**静的解析**によって行われます。これには、[`androguard`](https://github.com/androguard/androguard)ライブラリが使用されます。

このツールは、次のような「悪い」アプリケーションの一般的な振る舞いを探します：電話識別子の外部への漏洩、オーディオ/ビデオフローの傍受、PIMデータの変更、任意のコードの実行...
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (81).png>)

**MARA**は、**M**obile **A**pplication **R**everse engineering and **A**nalysis Frameworkの略です。これは、一般的に使用されるモバイルアプリケーションの逆向きエンジニアリングと分析ツールを組み合わせたツールであり、OWASPモバイルセキュリティの脅威に対してモバイルアプリケーションのテストを支援します。その目的は、このタスクをモバイルアプリケーション開発者とセキュリティ専門家にとってより簡単で使いやすくすることです。

以下のことができます：

- 異なるツールを使用してJavaおよびSmaliコードを抽出する
- [smalisca](https://github.com/dorneanu/smalisca)、[ClassyShark](https://github.com/google/android-classyshark)、[androbugs](https://github.com/AndroBugs/AndroBugs_Framework)、[androwarn](https://github.com/maaaaz/androwarn)、[APKiD](https://github.com/rednaga/APKiD)を使用してAPKを分析する
- 正規表現を使用してAPKからプライベート情報を抽出する
- マニフェストを分析する
- [pyssltest](https://github.com/moheshmohan/pyssltest)、[testssl](https://github.com/drwetter/testssl.sh)、[whatweb](https://github.com/urbanadventurer/WhatWeb)を使用して見つかったドメインを分析する
- [apk-deguard.com](http://www.apk-deguard.com)を介してAPKの難読化を解除する

### Koodous

マルウェアを検出するのに便利です：[https://koodous.com/](https://koodous.com)

## コードの難読化/難読化解除

コードを難読化するために使用するサービスと設定によっては、秘密情報が難読化される場合とされない場合があります。

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

**ProGuard**は、Javaコードを縮小、最適化、難読化するためのオープンソースのコマンドラインツールです。バイトコードを最適化し、未使用の命令を検出および削除することができます。ProGuardは無料のソフトウェアであり、GNU General Public License、バージョン2で配布されています。

ProGuardはAndroid SDKの一部として配布され、リリースモードでアプリケーションをビルドする際に実行されます。

参照元：[https://en.wikipedia.org/wiki/ProGuard\_(software)](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

### [DexGuard](https://www.guardsquare.com/dexguard)

APKの難読化を解除するためのステップバイステップガイドは[https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)にあります。

（そのガイドから）最後に確認したとき、Dexguardの動作モードは次のようでした：

- リソースをInputStreamとしてロードする
- 結果をFilterInputStreamを継承したクラスにフィードして復号化する
- いくつかの無駄な難読化を行い、リバースエンジニアから数分間の時間を無駄にする
- 復号化された結果をZipInputStreamにフィードしてDEXファイルを取得する
- 最終的に、`loadDex`メソッドを使用して生成されたDEXをリソースとしてロードする

### [DeGuard](http://apk-deguard.com)

**DeGuardは、Androidの難読化ツールによって実行された難読化プロセスを逆転させます。これにより、コードの検査やライブラリの予測を含むさまざまなセキュリティ分析が可能になります。**

難読化されたAPKをプラットフォームにアップロードできます。

### [Simplify](https://github.com/CalebFenton/simplify)

これは**汎用のAndroid難読化解除ツール**です。Simplifyはアプリを**仮想的に実行**してその動作を理解し、コードを**最適化**して同じ動作をするが人間にとって理解しやすいものにします。各最適化タイプはシンプルで汎用的なため、特定の難読化タイプは問題ありません。

### [APKiD](https://github.com/rednaga/APKiD)

APKiDは、APKの作成方法に関する情報を提供します。多くの**コンパイラ**、**パッカー**、**難読化ツール**、およびその他の奇妙なものを識別します。これはAndroidの[_PEiD_](https://www.aldeid.com/wiki/PEiD)です。

### マニュアル

[このチュートリアルを読んで、**カスタム難読化を逆向きにする**いくつかのトリックを学びましょう](manual-deobfuscation.md)

## ラボ

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4bは、ubuntu-mateをベースにしたAndroidセキュリティ仮想マシンであり、リバースエンジニアリングとマルウェア分析のためのさまざまなセキュリティギークと研究者からの最新のフレームワーク、チュートリアル、ラボを含んでいます。

### OWASP

{% embed url="https://github.com/OWASP/owasp-mstg%0Ahttps://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06g-testing-network-communication" %}

### Gitリポジトリ

[https://github.com/riddhi-shree/nullCommunity/tree/master/Android](https://github.com/riddhi-shree/nullCommunity/tree/master/Android)\
[https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## 参考文献

詳細については、次を参照してください：

- [https://appsecwiki.com/#/](https://appsecwiki.com/#/) リソースの素晴らしいリストです
- [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Androidクイックコース
- [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
- [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)

## テストするために

- [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
- [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofは、すべての暗号バグバウンティの場所です。**

**遅延なしで報酬を受け取る**\
HackenProofのバウンティは、顧客が報酬予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新し
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう。これは私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**Telegramグループ**](https://t.me/peass)に参加するか、私を**Twitter**で[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォローしましょう。**
* 自分のハッキングテクニックを共有するために、[**hacktricksリポジトリ**](https://github.com/carlospolop/hacktricks)と[**hacktricks-cloudリポジトリ**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出しましょう。

</details>
