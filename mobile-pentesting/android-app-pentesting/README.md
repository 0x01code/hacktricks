# 안드로이드 애플리케이션 펜테스팅

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)를 통해 제로부터 영웅이 될 때까지 AWS 해킹을 배우세요</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하길 원한다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 얻으세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [디스코드 그룹](https://discord.gg/hRep4RUj7f)**에 가입하거나 [텔레그램 그룹](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

경험 많은 해커 및 버그 바운티 헌터와 소통하려면 [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 가입하세요!

**해킹 통찰력**\
해킹의 스릴과 도전에 대해 탐구하는 콘텐츠와 상호 작용

**실시간 해킹 뉴스**\
빠르게 변화하는 해킹 세계의 실시간 뉴스와 통찰력을 유지하세요

**최신 공지**\
출시되는 최신 버그 바운티 및 중요한 플랫폼 업데이트에 대해 알아두세요

**우리와 함께** [**디스코드**](https://discord.com/invite/N3FrSbmwdy)에 가입하여 오늘 최고의 해커들과 협업을 시작하세요!

## 안드로이드 애플리케이션 기초

**안드로이드 보안과 안드로이드 애플리케이션에서 가장 위험한 구성 요소에 관련된 가장 중요한 부분에 대해 알아보려면** 이 페이지를 읽기 시작하는 것이 매우 권장됩니다:

{% content-ref url="android-applications-basics.md" %}
[android-applications-basics.md](android-applications-basics.md)
{% endcontent-ref %}

## ADB (Android Debug Bridge)

이것은 안드로이드 장치(가상 또는 물리적)에 연결하는 데 필요한 주요 도구입니다.\
**ADB**는 컴퓨터에서 장치를 **USB** 또는 **네트워크**를 통해 제어할 수 있습니다. 이 유틸리티는 파일을 **양방향으로 복사**, 앱을 **설치** 및 **제거**, 셸 명령을 **실행**, 데이터를 **백업**, 로그를 **읽기** 등의 기능을 가능하게 합니다.

ADB를 사용하는 방법을 배우려면 다음 [**ADB 명령어 목록**](adb-commands.md)을 확인하세요.

## Smali

가끔은 **애플리케이션 코드를 수정**하여 **숨겨진 정보**(아마도 잘 난독화된 비밀번호 또는 플래그)에 액세스하는 것이 흥미로울 수 있습니다. 그런 다음 apk를 디컴파일하고 코드를 수정한 후 다시 컴파일하는 것이 흥미로울 수 있습니다.\
[**이 튜토리얼**에서는 **APK를 디컴파일하고, Smali 코드를 수정하고 새 기능이 추가된 APK를 다시 컴파일하는 방법**을 배울 수 있습니다](smali-changes.md). 이것은 **동적 분석 중에 여러 테스트를 위한 대안으로 매우 유용**할 수 있습니다. 그러므로 **언제나 이 가능성을 염두**하세요.

## 다른 흥미로운 트릭

* [Play Store에서 위치 위조하기](spoofing-your-location-in-play-store.md)
* **APK 다운로드**: [https://apps.evozi.com/apk-downloader/](https://apps.evozi.com/apk-downloader/), [https://apkpure.com/es/](https://apkpure.com/es/), [https://www.apkmirror.com/](https://www.apkmirror.com), [https://apkcombo.com/es-es/apk-downloader/](https://apkcombo.com/es-es/apk-downloader/)
* 장치에서 APK 추출:
```bash
adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2- Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
```
## 정적 분석

먼저, APK를 분석하기 위해 **디컴파일러를 사용하여 Java 코드를 살펴봐야**합니다.\
자세한 내용은 [**여기를 읽어서 다양한 사용 가능한 디컴파일러에 대한 정보를 찾으세요**](apk-decompilers.md).

### 흥미로운 정보 찾기

APK의 **문자열**을 살펴보기만 해도 **비밀번호**, **URL**, **API** 키, **암호화**, **블루투스 UUID**, **토큰** 및 흥미로운 모든 것을 검색할 수 있습니다... 코드 실행 **백도어**나 인증 백도어(앱에 대한 하드코딩된 관리자 자격 증명)를 찾아보세요.

**Firebase**

**Firebase URL**에 특별히 주의를 기울이고 잘못 구성되었는지 확인하세요. [Firebase가 무엇이며 어떻게 악용할 수 있는지에 대한 자세한 정보는 여기에서 확인하세요.](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)

### 애플리케이션의 기본 이해 - Manifest.xml, strings.xml

애플리케이션의 **_Manifest.xml_** 및 **_strings.xml_** 파일을 조사하면 잠재적인 보안 취약점을 발견할 수 있습니다. 이러한 파일은 디컴파일러를 사용하거나 APK 파일 확장자를 .zip으로 변경한 다음 압축 해제하여 액세스할 수 있습니다.

**Manifest.xml**에서 식별된 **취약점**은 다음과 같습니다:

* **디버깅 가능한 애플리케이션**: _Manifest.xml_ 파일에서 디버깅 가능으로 설정된 애플리케이션(`debuggable="true"`)은 연결을 허용하여 악용으로 이어질 수 있는 위험을 야기합니다. 디버깅 가능한 애플리케이션을 악용하는 방법에 대한 자세한 내용은 기기에서 디버깅 가능한 애플리케이션을 찾고 악용하는 튜토리얼을 참조하세요.
* **백업 설정**: 민감한 정보를 처리하는 애플리케이션에 대해 `android:allowBackup="false"` 속성을 명시적으로 설정하여 adb를 통한 무단 데이터 백업을 방지해야 합니다. 특히 USB 디버깅이 활성화된 경우 더욱 중요합니다.
* **네트워크 보안**: _res/xml/_에 있는 사용자 정의 네트워크 보안 구성(`android:networkSecurityConfig="@xml/network_security_config"`)은 인증서 핀 및 HTTP 트래픽 설정과 같은 보안 세부 정보를 지정할 수 있습니다. 특정 도메인에 대한 HTTP 트래픽을 허용하는 예시가 있습니다.
* **공개된 활동 및 서비스**: Manifest에서 공개된 활동 및 서비스를 식별하면 오용될 수 있는 구성 요소를 강조할 수 있습니다. 동적 테스트 중에 이러한 구성 요소를 어떻게 악용할지 확인할 수 있습니다.
* **콘텐츠 제공자 및 파일 제공자**: 노출된 콘텐츠 제공자는 데이터에 대한 무단 액세스 또는 수정을 허용할 수 있습니다. FileProvider의 구성도 면밀히 살펴봐야 합니다.
* **브로드캐스트 수신기 및 URL 스키마**: 이러한 구성 요소는 악용에 활용될 수 있으며 URL 스키마가 입력 취약점을 위해 어떻게 관리되는지에 특히 주의를 기울여야 합니다.
* **SDK 버전**: `minSdkVersion`, `targetSDKVersion`, `maxSdkVersion` 속성은 지원되는 Android 버전을 나타내며, 보안상의 이유로 오래된 취약한 Android 버전을 지원하지 않는 것이 중요함을 강조합니다.

**strings.xml** 파일에서 API 키, 사용자 정의 스키마 및 기타 개발자 노트와 같은 민감한 정보를 발견할 수 있으므로 이러한 리소스를 주의 깊게 검토해야 합니다.

### Tapjacking

**Tapjacking**은 **악성 애플리케이션이 피해 애플리케이션 위에 위치하도록 하여** 사용자를 속이는 공격입니다. 피해 앱을 시각적으로 가리면서 사용자 인터페이스를 설계하여 사용자가 상호 작용하도록 속이고 실제로는 피해 앱에서 작업을 수행하도록 합니다.\
사용자가 **피해 앱에서 작업을 수행하고 있다는 사실을 모르게 만들어** 사용자를 속이는 효과가 있습니다.

더 많은 정보는 다음에서 확인하세요:

{% content-ref url="tapjacking.md" %}
[tapjacking.md](tapjacking.md)
{% endcontent-ref %}

### 작업 탈취

`launchMode`가 **`singleTask`로 설정되고 `taskAffinity`가 정의되지 않은** **액티비티**는 작업 탈취에 취약합니다. 이는 **애플리케이션이 설치되고 실제 애플리케이션보다 먼저 실행되면 실제 애플리케이션의 작업을 탈취**할 수 있음을 의미합니다(따라서 사용자는 실제 애플리케이션을 사용하고 있다고 생각하면서 악성 애플리케이션과 상호 작용할 것입니다).

자세한 정보는 다음에서 확인하세요:

{% content-ref url="android-task-hijacking.md" %}
[android-task-hijacking.md](android-task-hijacking.md)
{% endcontent-ref %}

### 보안되지 않은 데이터 저장

**내부 저장소**

Android에서 내부 저장소에 저장된 파일은 생성한 **앱만이 액세스할 수 있도록 설계**되어 있습니다. 이 보안 조치는 Android 운영 체제에 의해 강제되며 대부분의 애플리케이션의 보안 요구를 충족하는 데 일반적으로 충분합니다. 그러나 개발자는 때로 `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE`과 같은 모드를 사용하여 파일을 **다른 애플리케이션 간에 공유**할 수 있습니다. 그러나 이러한 모드는 이러한 파일에 대한 다른 애플리케이션(잠재적으로 악성 애플리케이션 포함)의 액세스를 제한하지 않습니다.

1. **정적 분석:**
* `MODE_WORLD_READABLE` 및 `MODE_WORLD_WRITABLE` 사용이 **주의 깊게 검토**되었는지 확인하세요. 이러한 모드는 파일을 **의도하지 않은 또는 무단 액세스에 노출**시킬 수 있습니다.
2. **동적 분석:**
* 앱이 생성한 파일에 설정된 **권한**을 확인하세요. 특히, 어떤 파일이 **전 세계에서 읽거나 쓰기 가능하도록 설정**되었는지 확인하세요. 이는 잠재적으로 모든 애플리케이션이 이러한 파일을 읽거나 수정할 수 있게 하므로 중요한 보안 위험을 초래할 수 있습니다.

**외부 저장소**

외부 저장소(예: SD 카드)의 파일을 처리할 때는 특정 주의사항이 필요합니다:

1. **접근성**:
* 외부 저장소의 파일은 **전역적으로 읽기 및 쓰기 가능**합니다. 이는 모든 애플리케이션이나 사용자가 이러한 파일에 액세스할 수 있다는 것을 의미합니다.
2. **보안 문제**:
* 액세스 용이성을 고려하여 외부 저장소에 민감한 정보를 저장하지 않는 것이 좋습니다.
* 외부 저장소는 제거되거나 모든 애플리케이션이 액세스할 수 있으므로 덜 안전합니다.
3. **외부 저장소에서 데이터 처리**:
* 외부 저장소에서 검색된 데이터에 대해 **입력 유효성 검사**를 항상 수행해야 합니다. 이는 신뢰할 수 없는 소스에서 데이터를 가져왔기 때문에 중요합니다.
* 외부 저장소에 실행 파일이나 클래스 파일을 저장하여 동적으로 로드하는 것은 강력히 권장되지 않습니다.
* 애플리케이션이 외부 저장소에서 실행 파일을 검색해야 하는 경우, 이러한 파일이 동적으로 로드되기 전에 **서명되고 암호화가 확인**되도록 보장해야 합니다. 이 단계는 애플리케이션의 보안 무결성을 유지하는 데 중요합니다.

외부 저장소는 `/storage/emulated/0`, `/sdcard`, `/mnt/sdcard`에서 **액세스**할 수 있습니다.

{% hint style="info" %}
Android 4.4(API 17)부터 SD 카드에는 앱에 특정적으로 지정된 디렉토리에 대한 앱의 액세스을 제한하는 디렉토리 구조가 있습니다. 이로 인해 악성 애플리케이션이 다른 앱의 파일을 읽거나 쓸 수 없습니다.
{% endhint %}

**평문으로 저장된 민감한 데이터**

* **공유 환경 설정**: Android는 각 애플리케이션이 `/data/data/<패키지명>/shared_prefs/` 경로에 쉽게 XML 파일을 저장할 수 있도록 허용하며 때로는 해당 폴더에서 평문으로 민감한 정보를 찾을 수 있습니다.
* **데이터베이스**: Android는 각 애플리케이션이 `/data/data/<패키지명>/databases/` 경로에 쉽게 SQLite 데이터베이스를 저장할 수 있도록 허용하며 때로는 해당 폴더에서 평문으로 민감한 정보를 찾을 수 있습니다.

### TLS 깨진 상태

**모든 인증서 수락**

가끔 개발자들은 호스트 이름이 일치하지 않더라도 모든 인증서를 수락하는 경우가 있습니다. 코드 라인 예시:
```java
SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```
### 취약한 암호화

**약한 키 관리 프로세스**

일부 개발자는 민감한 데이터를 로컬 저장소에 저장하고 코드 내에서 하드코딩/예측 가능한 키로 암호화합니다. 이렇게 하면 공격자가 기밀 정보를 추출할 수 있게 될 수 있으므로 이는 피해야 합니다.

**안전하지 않거나 사용 중단된 알고리즘의 사용**

개발자는 **사용 중단된 알고리즘**을 사용하여 **인가 확인**, **저장** 또는 **데이터 전송**을 수행해서는 안 됩니다. 이러한 알고리즘 중 일부는 RC4, MD4, MD5, SHA1 등입니다. 예를 들어 암호를 저장하기 위해 **해시**가 사용된다면, 솔트와 함께 해시 브루트 포스 **내성**을 사용해야 합니다.

### 기타 확인 사항

* APK를 **난독화**하는 것이 좋습니다. 이렇게 하면 역공학 작업을 어렵게 할 수 있습니다.
* 앱이 민감한 경우(은행 앱 등), 모바일이 루팅되었는지 **자체 확인**하고 그에 따라 조치해야 합니다.
* 앱이 민감한 경우(은행 앱 등), **에뮬레이터**를 사용하는지 확인해야 합니다.
* 앱이 민감한 경우(은행 앱 등), **수정되었는지 확인**하기 위해 실행 전에 **자체 무결성을 확인**해야 합니다.
* APK를 빌드하는 데 사용된 컴파일러/패커/난독화기를 확인하기 위해 [**APKiD**](https://github.com/rednaga/APKiD)를 사용하세요.

### 리액트 네이티브 애플리케이션

리액트 애플리케이션의 자바스크립트 코드에 쉽게 액세스하는 방법을 알아보려면 다음 페이지를 읽어보세요:

{% content-ref url="react-native-application.md" %}
[react-native-application.md](react-native-application.md)
{% endcontent-ref %}

### 자마린 애플리케이션

자마린 애플리케이션의 C# 코드에 쉽게 액세스하는 방법을 알아보려면 다음 페이지를 읽어보세요:

{% content-ref url="../xamarin-apps.md" %}
[xamarin-apps.md](../xamarin-apps.md)
{% endcontent-ref %}

### 슈퍼팩킹된 애플리케이션

이 [**블로그 게시물**](https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/)에 따르면, 슈퍼팩킹은 애플리케이션의 내용을 하나의 파일로 압축하는 메타 알고리즘입니다. 이 블로그는 이러한 종류의 앱을 해제하는 앱을 만들 수 있는 가능성에 대해 이야기하며... 그리고 **애플리케이션을 실행하고 파일 시스템에서 해제된 파일을 수집하는** 더 빠른 방법에 대해 언급합니다.

### 자동 정적 코드 분석

도구 [**mariana-trench**](https://github.com/facebook/mariana-trench)은 애플리케이션의 코드를 **스캔**하여 **취약점**을 찾을 수 있습니다. 이 도구에는 **알려진 소스**(입력이 사용자에 의해 제어되는 **위치**를 도구에 알려주는 것), **싱크**(악의적 사용자 입력이 피해를 일으킬 수 있는 **위험한 위치**를 도구에 알려주는 것) 및 **규칙**이 포함되어 있습니다. 이러한 규칙은 취약점을 나타내는 **소스-싱크**의 **조합**을 나타냅니다.

이 지식을 바탕으로 **mariana-trench는 코드를 검토하고 가능한 취약점을 찾을 것**입니다.

### 누출된 비밀

애플리케이션에는 (API 키, 비밀번호, 숨겨진 URL, 서브도메인 등) 발견할 수 있는 비밀이 포함될 수 있습니다. [https://github.com/dwisiswant0/apkleaks](https://github.com/dwisiswant0/apkleaks)와 같은 도구를 사용하여 이를 발견할 수 있습니다.

### 생체 인증 우회

{% content-ref url="bypass-biometric-authentication-android.md" %}
[bypass-biometric-authentication-android.md](bypass-biometric-authentication-android.md)
{% endcontent-ref %}

### 기타 흥미로운 기능

* **코드 실행**: `Runtime.exec(), ProcessBuilder(), native code:system()`
* **SMS 전송**: `sendTextMessage, sendMultipartTestMessage`
* `native`로 선언된 **네이티브 함수**: `public native, System.loadLibrary, System.load`
* **네이티브 함수를 반전하는 방법**을 알아보려면 [여기를 읽으세요](reversing-native-libraries.md)

### **기타 트릭**

{% content-ref url="content-protocol.md" %}
[content-protocol.md](content-protocol.md)
{% endcontent-ref %}

***

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 가입하여 경험 많은 해커 및 버그 바운티 헌터와 소통하세요!

**해킹 통찰력**\
해킹의 스릴과 도전에 대해 탐구하는 콘텐츠에 참여하세요

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰력을 통해 빠른 속도로 변화하는 해킹 세계를 따라가세요

**최신 공지**\
최신 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대해 알아보세요

**[Discord](https://discord.com/invite/N3FrSbmwdy)**에 가입하여 최고의 해커들과 협업을 시작하세요!

***

## 동적 분석

> 먼저, 애플리케이션을 설치하고 모든 환경(Burp CA 인증서, Drozer 및 Frida 주로)를 설치할 수 있는 환경이 필요합니다. 따라서 루팅된 장치(가상 또는 아님)를 권장합니다.

### 온라인 동적 분석

[https://appetize.io/](https://appetize.io)에서 **무료 계정**을 만들 수 있습니다. 이 플랫폼을 사용하면 APK를 **업로드**하고 **실행**할 수 있으므로 apk의 작동 방식을 확인하는 데 유용합니다.

웹에서 애플리케이션의 로그를 볼 수 있고 **adb**를 통해 연결할 수도 있습니다.

![](<../../.gitbook/assets/image (831).png>)

ADB 연결을 통해 에뮬레이터 내에서 **Drozer** 및 **Frida**를 사용할 수 있습니다.

### 로컬 동적 분석

#### 에뮬레이터 사용

* [**Android Studio**](https://developer.android.com/studio) (x86 및 arm 장치를 만들 수 있으며, [**최신 x86** 버전은 ARM 라이브러리를 지원](https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html)하므로 느린 arm 에뮬레이터가 필요하지 않습니다).
* 이 페이지에서 설정 방법을 배울 수 있습니다:

{% content-ref url="avd-android-virtual-device.md" %}
[avd-android-virtual-device.md](avd-android-virtual-device.md)
{% endcontent-ref %}

* [**Genymotion**](https://www.genymotion.com/fun-zone/) **(무료 버전:** Personal Edition, 계정을 만들어야 합니다. _잠재적인 오류를 피하기 위해_ _**VirtualBox**가 포함된 버전을 **다운로드**하는 것이 좋습니다._)
* [**Nox**](https://es.bignox.com) (무료, 하지만 Frida 또는 Drozer를 지원하지 않습니다).

{% hint style="info" %}
어떤 플랫폼에서든 새로운 에뮬레이터를 만들 때 화면이 클수록 에뮬레이터가 느려집니다. 가능하면 작은 화면을 선택하세요.
{% endhint %}

Genymotion에서 **AppStore**와 같은 구글 서비스를 설치하려면 다음 이미지의 빨간색으로 표시된 버튼을 클릭해야 합니다:

![](<../../.gitbook/assets/image (277).png>)

또한, Genymotion의 **Android VM 구성**에서 **Bridge Network mode**를 선택할 수 있습니다(다른 VM에서 도구를 사용하여 Android VM에 연결할 경우 유용합니다).

#### 실제 장치 사용

디버깅 옵션을 활성화하고 가능하면 루팅하는 것이 좋습니다:

1. **설정**.
2. (Android 8.0부터) **시스템** 선택.
3. **휴대폰 정보** 선택.
4. **빌드 번호**를 7번 누릅니다.
5. 뒤로 가서 **개발자 옵션**을 찾을 수 있습니다.

> 애플리케이션을 설치한 후에 해야 할 첫 번째 작업은 앱을 시험해보고 작동 방식을 조사하고 익숙해지는 것입니다.\
> MobSF 동적 분석 + pidcat을 사용하여 **초기 동적 분석을 수행**하는 것을 제안합니다. 이렇게 하면 MobSF가 나중에 검토할 수 있는 많은 **흥미로운 데이터를 캡처**하면서 애플리케이션의 작동 방식을 배울 수 있습니다.
### 의도하지 않은 데이터 누출

**로깅**

개발자는 **디버깅 정보**를 공개로 노출시키지 않도록 주의해야 합니다. 이는 민감한 데이터 누출로 이어질 수 있습니다. **Pidcat** 및 `adb logcat` 도구를 사용하여 애플리케이션 로그를 모니터링하여 민감한 정보를 식별하고 보호하는 것이 권장됩니다. **Pidcat**은 사용하기 쉽고 가독성이 좋아 선호됩니다.

{% hint style="warning" %}
**Android 4.0 이후의 최신 버전**에서는 **애플리케이션은 자체 로그에만 액세스할 수 있습니다**. 따라서 애플리케이션은 다른 앱의 로그에 액세스할 수 없습니다.\
그래도 **민감한 정보를 기록하지 않는 것**이 좋습니다.
{% endhint %}

**복사/붙여넣기 버퍼 캐싱**

Android의 **클립보드 기반** 프레임워크는 앱에서 복사 및 붙여넣기 기능을 가능하게 하지만 **다른 애플리케이션**이 클립보드에 **액세스**할 수 있어 민감한 데이터가 노출될 수 있습니다. 애플리케이션의 민감한 섹션(예: 신용 카드 세부 정보)에 대한 복사/붙여넣기 기능을 비활성화하여 데이터 누출을 방지하는 것이 중요합니다.

**크래시 로그**

애플리케이션이 **크래시**되고 **로그가 저장**된 경우, 이러한 로그는 특히 애플리케이션이 역공학화될 수 없는 경우에 공격자를 지원할 수 있습니다. 이러한 위험을 줄이기 위해 크래시 시 로깅을 피하고 로그를 네트워크를 통해 전송해야 하는 경우 SSL 채널을 통해 안전하게 전송되도록 해야 합니다.

펜테스터로서 **이러한 로그를 살펴보려고 노력**해야 합니다.

**3rd 파티에 전송된 분석 데이터**

애플리케이션은 종종 Google Adsense와 같은 서비스를 통합하는데, 개발자의 부적절한 구현으로 인해 민감한 데이터가 **누출**될 수 있습니다. 잠재적인 데이터 누출을 식별하기 위해 애플리케이션의 트래픽을 **가로채어** 제3자 서비스로 전송되는 민감한 정보를 확인하는 것이 좋습니다.

### SQLite DBs

대부분의 애플리케이션은 정보를 저장하기 위해 **내부 SQLite 데이터베이스**를 사용할 것입니다. 펜테스트 중에는 생성된 **데이터베이스**, **테이블** 및 **열의 이름** 및 저장된 **모든 데이터**를 살펴보는 것이 중요합니다. 왜냐하면 **민감한 정보**(취약점이 될 수 있는)를 발견할 수 있기 때문입니다.\
데이터베이스는 `/data/data/the.package.name/databases`와 같이 위치해야 합니다. 예를 들어 `/data/data/com.mwr.example.sieve/databases`

데이터베이스가 기밀 정보를 저장하고 **암호화**되어 있지만 애플리케이션 내에서 **암호**를 **찾을 수** 있다면 여전히 **취약점**입니다.

`.tables`를 사용하여 테이블을 나열하고 `.schema <table_name>`을 사용하여 테이블의 열을 나열하세요.

### Drozer (Exploit Activities, Content Providers and Services)

[Drozer Docs](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)에 따르면 **Drozer**를 사용하면 **Android 앱의 역할을 가정**하고 다른 앱과 상호작용할 수 있습니다. Android의 Inter-Process Communication (IPC) 메커니즘을 활용하고 기본 운영 체제와 상호작용하는 등 설치된 애플리케이션이 할 수 있는 모든 작업을 수행할 수 있습니다.\
Drozer는 내보낸 활동, 내보낸 서비스 및 콘텐츠 제공자를 **악용**하는 데 유용한 도구입니다.

### 내보낸 활동 악용

[**Android 활동이 무엇인지 다시 확인하려면 이 문서를 읽어보세요.**](android-applications-basics.md#launcher-activity-and-other-activities)\
또한 활동의 코드는 **`onCreate`** 메서드에서 시작됨을 기억하세요.

**인증 우회**

활동이 내보내어지면 외부 앱에서 해당 화면을 호출할 수 있습니다. 따라서 **민감한 정보**가 있는 활동이 **내보내어진** 경우 **인증** 메커니즘을 **우회**하여 **액세스**할 수 있습니다.

[Drozer를 사용하여 내보낸 활동을 악용하는 방법을 배우세요.](drozer-tutorial/#activities)

또한 adb에서 내보낸 활동을 시작할 수 있습니다:

* 패키지 이름은 com.example.demo입니다.
* 내보낸 활동 이름은 com.example.test.MainActivity입니다.
```bash
adb shell am start -n com.example.demo/com.example.test.MainActivity
```
**참고**: MobSF는 액티비티의 `android:launchMode`로 _**singleTask/singleInstance**_를 사용하는 것을 악성으로 감지할 것이지만, [여기](https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750)에 따르면 이는 이제 오래된 버전(API 버전 < 21)에서만 위험하다고 합니다.

{% hint style="info" %}
인가 우회(authorisation bypass)가 항상 취약점은 아닙니다. 우회가 작동하는 방식과 노출되는 정보에 따라 다릅니다.
{% endhint %}

**민감한 정보 누출**

**액티비티는 결과를 반환할 수도 있습니다**. 노출되고 보호되지 않은 액티비티에서 **`setResult`** 메소드를 호출하고 **민감한 정보를 반환**하는 경우, 민감한 정보 누출이 발생합니다.

#### 탭재킹

탭재킹을 방지하지 않으면, 노출된 액티비티를 악용하여 **사용자가 예상치 못한 작업을 수행**하게 할 수 있습니다. [**탭재킹이 무엇인지 알아보려면 링크를 따르세요**](./#tapjacking).

### 콘텐츠 제공자 악용 - 민감한 정보 접근 및 조작

[**콘텐츠 제공자가 무엇인지 다시 확인하려면 이를 읽으세요.**](android-applications-basics.md#content-provider)\
콘텐츠 제공자는 기본적으로 **데이터를 공유**하는 데 사용됩니다. 앱에 사용 가능한 콘텐츠 제공자가 있다면 **민감한** 데이터를 **추출**할 수 있을 수도 있습니다. 가능한 **SQL 인젝션** 및 **경로 탐색**을 테스트하는 것도 흥미로울 수 있습니다.

[Drozer로 콘텐츠 제공자를 악용하는 방법을 배우세요.](drozer-tutorial/#content-providers)

### **서비스 악용**

[**서비스가 무엇인지 다시 확인하려면 이를 읽으세요.**](android-applications-basics.md#services)\
서비스는 기본적으로 데이터를 **받을 수 있고**, **처리**하고 **응답**을 반환(하거나 하지 않을 수 있습니다). 따라서, 어떤 애플리케이션이 서비스를 내보내고 있다면, 그 코드를 확인하여 민감한 정보를 추출하거나 인증 조치를 우회하는 등의 작업을 **동적으로** 테스트해야 합니다.

[Drozer로 서비스를 악용하는 방법을 배우세요.](drozer-tutorial/#services)

### **브로드캐스트 수신기 악용**

[**브로드캐스트 수신기가 무엇인지 다시 확인하려면 이를 읽으세요.**](android-applications-basics.md#broadcast-receivers)\
브로드캐스트 수신기는 특정 유형의 메시지를 기다리고 있습니다. 수신기가 메시지를 처리하는 방식에 따라 취약할 수 있습니다.

[Drozer로 브로드캐스트 수신기를 악용하는 방법을 배우세요.](./#exploiting-broadcast-receivers)

### **스키마 / 딥 링크 악용**

MobSF와 같은 도구를 사용하여 수동으로 딥 링크를 찾을 수 있습니다. 또는 [이 스크립트](https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py)와 같은 스크립트를 사용할 수도 있습니다.\
**adb** 또는 **브라우저**를 사용하여 선언된 **스키마**를 **열 수** 있습니다:
```bash
adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
```
{% endcode %}

_패키지 이름을 **생략할 수 있다는 점**을 유의하십시오. 모바일은 자동으로 해당 링크를 열어야 할 앱을 호출할 것입니다._

{% code overflow="wrap" %}
```markup
<!-- Browser regular link -->
<a href="scheme://hostname/path?param=value">Click me</a>
<!-- fallback in your url you could try the intent url -->
<a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end">with alternative</a>
```
{% endcode %}

**실행된 코드**

**앱에서 실행될 코드를 찾으려면** 딥링크로 호출된 활동으로 이동하여 **`onNewIntent`** 함수를 찾으세요.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

**민감한 정보**

딥링크를 찾을 때마다 **URL 매개변수를 통해 민감한 데이터(예: 비밀번호)를 받지 않는지** 확인하십시오. 다른 애플리케이션이 **딥링크를 흉내내어 해당 데이터를 도난당할 수 있습니다!**

**경로 내 매개변수**

URL의 경로 내에 매개변수를 사용하는 딥링크가 있는지도 확인해야 합니다. 예를 들어 `https://api.example.com/v1/users/{username}`와 같은 경우, `example://app/users?username=../../unwanted-endpoint%3fparam=value`와 같이 액세스 경로 순회를 강제할 수 있습니다.\
애플리케이션 내에서 올바른 엔드포인트를 찾으면 **Open Redirect**(일부 경로가 도메인 이름으로 사용될 경우), **계정 탈취**(CSRF 토큰 없이 사용자 세부 정보를 수정할 수 있는 경우 및 취약한 엔드포인트가 올바른 방법을 사용한 경우) 및 기타 취약점을 유발할 수 있습니다. [여기에서 자세한 정보 확인](http://dphoeniixx.com/2020/12/13-2/).

**추가 예시**

링크에 관한 [흥미로운 버그 바운티 보고서](https://hackerone.com/reports/855618)입니다.

### 전송 계층 검사 및 확인 실패

* Android 애플리케이션에서는 **인증서를 항상 제대로 검사하지 않는 경우**가 있습니다. 이러한 애플리케이션에서는 경고를 무시하고 자체 서명된 인증서를 수락하거나 경우에 따라 HTTP 연결을 사용하도록 되돌아가는 것이 일반적입니다.
* SSL/TLS 핸드셰이크 중 협상이 때로는 취약하며, 보안되지 않은 암호 스위트를 사용합니다. 이 취약점으로 인해 연결이 중간자 공격에 취약해져 데이터를 해독할 수 있습니다.
* **개인 정보 누출**은 보안 채널을 통해 인증하는 애플리케이션에서 다른 트랜잭션에 대해 비보안 채널을 통해 통신하는 경우 발생할 수 있는 위험입니다. 이 방법은 세션 쿠키나 사용자 세부 정보와 같은 민감한 데이터를 악의적인 주체가 가로채지 못하게 하는 데 실패합니다.

#### 인증서 확인

**인증서 확인**에 중점을 둘 것입니다. 서버의 인증서 무결성을 확인하여 보안을 강화해야 합니다. 이는 보안 TLS 구성 및 민감한 데이터의 암호화되지 않은 채널을 통한 전송이 중요한 위험을 초래할 수 있기 때문에 중요합니다. 서버 인증서를 확인하고 취약점을 해결하기 위한 자세한 단계에 대한 안내는 [**이 리소스**](https://manifestsecurity.com/android-application-security-part-10/)에서 포괄적인 지침을 제공합니다.

#### SSL Pinning

SSL Pinning은 애플리케이션이 알려진 복사본과 서버의 인증서를 확인하는 보안 조치입니다. 이 방법은 MITM 공격을 방지하는 데 필수적입니다. 민감한 정보를 처리하는 애플리케이션에 대해 SSL Pinning을 구현하는 것이 강력히 권장됩니다.

#### 트래픽 검사

HTTP 트래픽을 검사하려면 프록시 도구의 인증서를 **설치해야** 합니다(예: Burp). 이 인증서를 설치하지 않으면 암호화된 트래픽이 프록시를 통해 보이지 않을 수 있습니다. 사용자 정의 CA 인증서를 설치하는 방법에 대한 안내는 [**여기를 클릭하세요**](avd-android-virtual-device.md#install-burp-certificate-on-a-virtual-machine).

**API 레벨 24 이상을 대상으로 하는** 애플리케이션은 네트워크 보안 구성을 수정하여 프록시의 CA 인증서를 수락해야 합니다. 이 단계는 암호화된 트래픽을 검사하는 데 중요합니다. 네트워크 보안 구성을 수정하는 방법에 대한 지침은 [**이 튜토리얼을 참조하세요**](make-apk-accept-ca-certificate.md).

#### SSL Pinning 우회

SSL Pinning이 구현된 경우 HTTPS 트래픽을 검사하기 위해 우회하는 것이 필요할 수 있습니다. 이를 위해 다음과 같은 여러 방법이 있습니다:

* [**apk-mitm**](https://github.com/shroudedcode/apk-mitm)를 사용하여 SSLPinning을 우회하는 **apk를 자동으로 수정**할 수 있습니다. 이 방법의 가장 큰 장점은 SSL Pinning을 우회하기 위해 루트가 필요하지 않지만, 애플리케이션을 삭제하고 새로 설치해야 하며 항상 작동하지는 않습니다.
* 이 보호를 우회하기 위해 **Frida**(아래 참조)를 사용할 수 있습니다. Burp+Frida+Genymotion 사용 가이드: [https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/](https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/)
* [**objection**](frida-tutorial/objection-tutorial.md)을 사용하여 SSL Pinning을 자동으로 우회할 수 있습니다: `objection --gadget com.package.app explore --startup-command "android sslpinning disable"`
* **MobSF 동적 분석**을 사용하여 SSL Pinning을 자동으로 우회할 수도 있습니다(아래 설명).
* 캡처하지 못하는 트래픽이 있다고 생각한다면 **iptables를 사용하여 트래픽을 burp로 전달**할 수 있습니다. 이 블로그를 읽어보세요: [https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62](https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62)

#### 일반 웹 취약점 찾기

애플리케이션 내에서 일반적인 웹 취약점을 찾는 것도 중요합니다. 이러한 취약점을 식별하고 완화하는 자세한 정보는 이 요약의 범위를 벗어나지만 다른 곳에서 상세히 다루고 있습니다.

### Frida

[Frida](https://www.frida.re)는 개발자, 역공학자 및 보안 연구원을 위한 동적 계기화 도구입니다.\
**실행 중인 애플리케이션에 액세스하고 실행 시간에 메서드를 후킹하여 동작을 변경하거나 값 변경, 값 추출, 다른 코드 실행 등을 할 수 있습니다.**\
Android 애플리케이션을 펜테스트하려면 Frida 사용 방법을 알아야 합니다.

* Frida 사용 방법 익히기: [**Frida 튜토리얼**](frida-tutorial/)
* Frida 작업을 자동화하는 데 좋은 Ojection: [**https://github.com/sensepost/objection**](https://github.com/sensepost/objection) **,** [**https://github.com/dpnishant/appmon**](https://github.com/dpnishant/appmon)
* 여기에서 멋진 Frida 스크립트를 찾을 수 있습니다: [**https://codeshare.frida.re/**](https://codeshare.frida.re)
* Frida를 로드하여 안티 디버깅 / 안티 Frida 메커니즘을 우회하려면 [https://erfur.github.io/blog/dev/code-injection-without-ptrace](https://erfur.github.io/blog/dev/code-injection-without-ptrace)에 나와 있는 대로 Frida를 로드하면 됩니다(도구 [linjector](https://github.com/erfur/linjector-rs))

### **메모리 덤프 - Fridump**

애플리케이션이 암호나 니모닉과 같은 민감한 정보를 저장해서는 안 되는 메모리 내에 저장하는지 확인하세요.

[**Fridump3**](https://github.com/rootbsd/fridump3)를 사용하여 앱의 메모리를 덤프할 수 있습니다:
```bash
# With PID
python3 fridump3.py -u <PID>

# With name
frida-ps -Uai
python3 fridump3.py -u "<Name>"
```
이 명령은 ./dump 폴더에 메모리를 덤프하며, 거기에서 다음과 같이 grep을 사용할 수 있습니다:

{% code overflow="wrap" %}
```bash
strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
```
{% endcode %}

### **Keystore에 있는 민감한 데이터**

Android에서 Keystore는 민감한 데이터를 저장하기에 가장 좋은 장소이지만, 충분한 권한이 있다면 여전히 **액세스할 수 있습니다**. 애플리케이션은 여기에 **평문으로 민감한 데이터를 저장**하는 경향이 있으므로 펜테스트는 루트 사용자로서 이를 확인해야 합니다. 또는 기기에 물리적 액세스 권한이 있는 사용자가 이 데이터를 도난당할 수 있습니다.

앱이 Keystore에 데이터를 저장했더라도, 데이터는 암호화되어야 합니다.

Keystore 내부의 데이터에 액세스하려면 이 Frida 스크립트를 사용할 수 있습니다: [https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js](https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js)
```bash
frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
```
### **지문/생체 인증 우회**

다음 Frida 스크립트를 사용하면 Android 애플리케이션이 수행할 수 있는 **특정 민감한 영역을 보호하기 위해 수행할 수 있는 지문 인증 우회**가 가능할 수 있습니다: 

{% code overflow="wrap" %}
```bash
frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f <app.package>
```
{% endcode %}

### **배경 이미지**

애플리케이션을 백그라운드로 넣을 때 Android는 애플리케이션의 **스냅샷**을 저장하여 다시 포그라운드로 복원될 때 앱보다 이미지를 먼저 로드하여 앱이 더 빨리 로드된 것처럼 보이게 합니다.

그러나 이 스냅샷에 **민감한 정보**가 포함되어 있다면, 해당 스냅샷에 액세스 권한이 있는 사람은 그 정보를 **도용**할 수 있습니다 (스냅샷에 액세스하려면 루트 액세스가 필요합니다).

스냅샷은 일반적으로 다음 위치에 저장됩니다: **`/data/system_ce/0/snapshots`**

Android는 **FLAG\_SECURE** 레이아웃 매개변수를 설정하여 스크린샷 캡처를 방지하는 방법을 제공합니다. 이 플래그를 사용하면 창 내용이 안전하게 처리되어 스크린샷에 나타나지 않거나 안전하지 않은 디스플레이에서 볼 수 없게 됩니다.
```bash
getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
```
### **Android Application Analyzer**

이 도구는 동적 분석 중에 다양한 도구를 관리하는 데 도움이 될 수 있습니다: [https://github.com/NotSoSecure/android\_application\_analyzer](https://github.com/NotSoSecure/android\_application\_analyzer)

### Intent Injection

개발자들은 종종 이러한 Intents를 처리하고 `startActivity(...)` 또는 `sendBroadcast(...)`와 같은 메서드로 전달하는 활동, 서비스 및 브로드캐스트 수신기와 같은 프록시 구성 요소를 만듭니다. 이는 위험할 수 있습니다.

위험은 공격자가 이러한 Intents를 잘못된 방향으로 전달하여 비내보내진 앱 구성 요소를 트리거하거나 민감한 콘텐츠 제공자에 액세스할 수 있도록 하는 데 있습니다. 주목할 만한 예는 `WebView` 구성 요소가 URL을 `Intent` 객체로 변환하고 `Intent.parseUri(...)`를 통해 실행하여 악의적인 Intent 삽입으로 이어질 수 있는 가능성이 있습니다.

### 주요 포인트

* **Intent Injection**은 웹의 Open Redirect 문제와 유사합니다.
* 악용은 안전하지 않은 작업을 실행할 수 있는 `Intent` 객체를 추가로 전달하는 것을 포함합니다.
* 비내보내진 구성 요소 및 콘텐츠 제공자를 공격자에게 노출시킬 수 있습니다.
* `WebView`의 URL을 `Intent`로 변환하는 것은 의도하지 않은 작업을 용이하게 할 수 있습니다.

### Android 클라이언트 측 삽입 및 기타

아마도 웹에서 이러한 종류의 취약점에 대해 알고 있을 것입니다. Android 애플리케이션에서 이러한 취약점에 특히 주의해야 합니다:

* **SQL Injection:** 동적 쿼리나 콘텐츠 제공자를 다룰 때는 매개변수화된 쿼리를 사용하는지 확인하십시오.
* **JavaScript Injection (XSS):** JavaScript 및 플러그인 지원이 비활성화되어 있는지 확인하십시오 (기본적으로 비활성화됨). [자세한 정보는 여기를 참조하십시오](webview-attacks.md#javascript-enabled).
* **로컬 파일 포함:** WebView는 파일 시스템 액세스가 비활성화되어 있는지 확인해야 합니다 (기본적으로 활성화됨) - `(webview.getSettings().setAllowFileAccess(false);)`. [자세한 정보는 여기를 참조하십시오](webview-attacks.md#javascript-enabled).
* **영구 쿠키**: Android 애플리케이션이 세션을 종료할 때 쿠키가 취소되지 않거나 디스크에 저장될 수도 있습니다.
* [쿠키의 **Secure Flag**](../../pentesting-web/hacking-with-cookies/#cookies-flags)

***

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 가입하여 경험 많은 해커 및 버그 바운티 헌터와 소통하세요!

**해킹 통찰**\
해킹의 즐거움과 도전에 대해 탐구하는 콘텐츠와 상호 작용하세요

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰을 통해 빠른 속도의 해킹 세계를 따라가세요

**최신 공지**\
최신 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대해 알아두세요

**지금 [**Discord**](https://discord.com/invite/N3FrSbmwdy)에 참여하여 최고의 해커들과 협업을 시작하세요!**

## 자동 분석

### [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

**정적 분석**

![](<../../.gitbook/assets/image (866).png>)

**애플리케이션의 취약점 평가**를 위한 멋진 웹 기반 프론트엔드를 사용합니다. 동적 분석도 수행할 수 있습니다 (하지만 환경을 준비해야 합니다).
```bash
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```
MobSF는 **Android**(apk), **IOS**(ipa) 및 Windows(apx) 애플리케이션을 분석할 수 있습니다 (_Windows 애플리케이션은 Windows 호스트에 설치된 MobSF에서 분석해야 합니다_). 또한 **Android** 또는 **IOS** 앱의 소스 코드로 ZIP 파일을 만들면 (애플리케이션의 루트 폴더로 이동하여 모두 선택하고 ZIP 파일을 만듭니다), MobSF가 분석할 수도 있습니다.

MobSF는 **분석 비교** 및 **VirusTotal** 통합을 허용합니다 (MobSF/settings.py에서 API 키를 설정하고 활성화해야 합니다: `VT_ENABLED = TRUE`, `VT_API_KEY = <Your API key>`, `VT_UPLOAD = TRUE`). `VT_UPLOAD`를 `False`로 설정하면 **해시**가 **파일 대신 업로드**됩니다.

### MobSF를 사용한 보조 동적 분석

**MobSF**는 **Android**에서 **동적 분석**에 매우 유용할 수 있지만 이 경우 호스트에 MobSF와 **genymotion**을 설치해야 합니다 (VM 또는 Docker는 작동하지 않습니다). _참고: **genymotion**에서 먼저 VM을 시작하고 **그런 다음 MobSF를 시작해야 합니다.**_\
**MobSF 동적 분석기**는 다음을 수행할 수 있습니다:

* **애플리케이션 데이터 덤프** (URL, 로그, 클립보드, 사용자가 캡처한 스크린샷, "**Exported Activity Tester**"가 캡처한 스크린샷, 이메일, SQLite 데이터베이스, XML 파일 및 생성된 기타 파일). 스크린샷을 제외한 모든 작업은 자동으로 수행되며, 스크린샷을 원할 때 누르거나 "**Exported Activity Tester**"를 눌러 내보낸 모든 활동의 스크린샷을 얻어야 합니다.
* **HTTPS 트래픽 캡처**
* **Frida**를 사용하여 **런타임 정보** 획득

**Android** 버전이 **5보다 큰 경우**, **Frida가 자동으로 시작**되고 전역 **프록시** 설정이 **트래픽 캡처**로 설정됩니다. 테스트된 애플리케이션에서만 트래픽을 캡처합니다.

**Frida**

기본적으로 **SSL 핀닝 우회**, **루트 탐지**, **디버거 탐지** 및 **흥미로운 API 모니터링**을 위해 일부 Frida 스크립트를 사용합니다.\
MobSF는 또한 내보낸 활동을 **호출**, 해당 활동의 **스크린샷**을 캡처하고 보고서에 저장할 수 있습니다.

동적 테스트를 시작하려면 "**Start Instrumentation**" 버튼을 누르세요. Frida 스크립트에 의해 생성된 로그를 보려면 "**Frida Live Logs**"를 누르세요. "**Live API Monitor**"를 눌러 후킹된 메서드의 모든 호출, 전달된 인수 및 반환된 값들을 볼 수 있습니다 ("Start Instrumentation"을 누른 후에 나타납니다).\
MobSF는 사용자의 **Frida 스크립트**를 로드할 수 있습니다 (Friday 스크립트의 결과를 MobSF로 보내려면 `send()` 함수를 사용하세요). 또한 로드할 수 있는 **여러 사전 작성된 스크립트**가 있습니다 (`MobSF/DynamicAnalyzer/tools/frida_scripts/others/`에 더 많은 스크립트를 추가할 수 있습니다). 그냥 **선택**하고 "**Load**"를 누르고 "**Start Instrumentation**"을 누르세요 (해당 스크립트의 로그를 "**Frida Live Logs**"에서 볼 수 있습니다).

![](<../../.gitbook/assets/image (419).png>)

또한 보조 Frida 기능이 있습니다:

* **로드된 클래스 나열**: 로드된 모든 클래스를 출력합니다.
* **문자열 캡처**: 애플리케이션 사용 중에 캡처된 모든 문자열을 출력합니다 (매우 시끄러울 수 있음).
* **문자열 비교 캡처**: 매우 유용할 수 있습니다. 비교된 2개의 문자열과 결과가 True인지 False인지 표시합니다.
* **클래스 메서드 나열**: 클래스 이름을 입력하면 (예: "java.io.File") 클래스의 모든 메서드를 출력합니다.
* **클래스 패턴 검색**: 패턴으로 클래스 검색
* **클래스 메서드 추적**: 전체 클래스를 추적합니다 (클래스의 모든 메서드의 입력 및 출력을 볼 수 있습니다). MobSF는 기본적으로 여러 흥미로운 Android API 메서드를 추적합니다.

사용하려는 보조 모듈을 선택한 후 "**Start Intrumentation**"을 눌러 모든 출력을 "**Frida Live Logs**"에서 볼 수 있습니다.

**Shell**

Mobsf는 동적 분석 페이지 하단에 일부 **adb** 명령어, **MobSF 명령어** 및 일반 **shell 명령어**를 포함한 셸을 제공합니다. 일부 흥미로운 명령어:
```bash
help
shell ls
activities
exported_activities
services
receivers
```
**HTTP 도구**

HTTP 트래픽을 캡처하면 "**HTTP(S) Traffic**" 하단에서 캡처된 트래픽의 불편한 모습을 볼 수 있거나 "**Start HTTPTools**" 녹색 버튼에서 더 나은 모습을 볼 수 있습니다. 두 번째 옵션에서는 **캡처된 요청**을 Burp 또는 Owasp ZAP와 같은 **프록시**로 **전송**할 수 있습니다.\
이를 위해 _Burp를 켜고 -->_ _Intercept를 끕니다 --> MobSB HTTPTools에서 요청을 선택_ --> "**Send to Fuzzer**"를 누릅니다 --> _프록시 주소를 선택_ ([http://127.0.0.1:8080\\](http://127.0.0.1:8080)).

MobSF로 동적 분석을 완료하면 "**Start Web API Fuzzer**"를 눌러 **http 요청을 퍼징**하고 취약점을 찾을 수 있습니다.

{% hint style="info" %}
MobSF로 동적 분석을 수행한 후 프록시 설정이 잘못 구성될 수 있으며 GUI에서 수정할 수 없을 수 있습니다. 프록시 설정을 수정하려면 다음을 수행할 수 있습니다:
```
adb shell settings put global http_proxy :0
```
{% endhint %}

### Inspeckage를 사용한 보조 동적 분석

[**Inspeckage**](https://github.com/ac-pm/Inspeckage)에서 도구를 얻을 수 있습니다.\
이 도구는 몇 가지 **훅**을 사용하여 **애플리케이션에서 무슨 일이 일어나고 있는지**를 알려주며 **동적 분석**을 수행할 때 도움이 됩니다.

### [Yaazhini](https://www.vegabird.com/yaazhini/)

이것은 **GUI로 정적 분석을 수행하는 뛰어난 도구**입니다

![](<../../.gitbook/assets/image (741).png>)

### [Qark](https://github.com/linkedin/qark)

이 도구는 **소스 코드** 또는 **패키지된 APK**에서 여러 **보안 관련 Android 애플리케이션 취약점**을 찾도록 설계되었습니다. 이 도구는 또한 발견된 일부 취약점을 이용하기 위해 "Proof-of-Concept" 배포 가능한 APK 및 **ADB 명령**을 생성할 수 있습니다 (노출된 액티비티, 인텐트, 탭잭킹 등). Drozer와 마찬가지로 테스트 기기를 루팅할 필요가 없습니다.
```bash
pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
```
### [**ReverseAPK**](https://github.com/1N3/ReverseAPK.git)

* 쉬운 참조를 위해 모든 추출된 파일 표시
* APK 파일을 자동으로 Java 및 Smali 형식으로 디컴파일
* 일반적인 취약점 및 동작을 위해 AndroidManifest.xml 분석
* 일반적인 취약점 및 동작을 위한 정적 소스 코드 분석
* 기기 정보
* 그 외
```bash
reverse-apk relative/path/to/APP.apk
```
### [SUPER Android Analyzer](https://github.com/SUPERAndroidAnalyzer/super)

SUPER는 Windows, MacOS X 및 Linux에서 사용할 수 있는 명령줄 응용 프로그램으로, 취약점을 찾기 위해 _.apk_ 파일을 분석합니다. 이를 위해 APK를 압축 해제하고 취약점을 감지하기 위해 일련의 규칙을 적용합니다.

모든 규칙은 `rules.json` 파일에 중점을 두고 있으며, 각 회사 또는 테스터는 필요한 내용을 분석하기 위해 자체 규칙을 만들 수 있습니다.

최신 이진 파일을 [다운로드 페이지](https://superanalyzer.rocks/download.html)에서 다운로드하세요.
```
super-analyzer {apk_file}
```
### [StaCoAn](https://github.com/vincentcox/StaCoAn)

![](<../../.gitbook/assets/image (297).png>)

StaCoAn은 **크로스플랫폼** 도구로, 개발자, 버그바운티 헌터 및 윤리적 해커들이 모바일 애플리케이션에 대한 [정적 코드 분석](https://en.wikipedia.org/wiki/Static\_program\_analysis)을 수행하는 데 도움이 됩니다.

이 개념은 모바일 애플리케이션 파일(.apk 또는 .ipa 파일)을 StaCoAn 애플리케이션으로 끌어다 놓으면 시각적이고 휴대용 보고서를 생성해줍니다. 설정 및 워드리스트를 조정하여 사용자 정의 경험을 얻을 수 있습니다.

[최신 릴리스 다운로드](https://github.com/vincentcox/StaCoAn/releases):
```
./stacoan
```
### [AndroBugs](https://github.com/AndroBugs/AndroBugs\_Framework)

AndroBugs Framework은 Android 애플리케이션에서 잠재적인 보안 취약점을 찾는 데 도움을 주는 Android 취약점 분석 시스템입니다.\
[Windows 릴리스](https://github.com/AndroBugs/AndroBugs\_Framework/releases)
```
python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
```
### [Androwarn](https://github.com/maaaaz/androwarn)

**Androwarn**는 주로 안드로이드 애플리케이션에 의해 개발된 잠재적으로 악성 행위를 감지하고 사용자에게 경고하는 데 중점을 둔 도구입니다.

이 감지는 애플리케이션의 Dalvik 바이트 코드를 **Smali**로 표현하여 수행되며, [`androguard`](https://github.com/androguard/androguard) 라이브러리를 사용하여 **정적 분석**이 수행됩니다.

이 도구는 전화 식별자 유출, 오디오/비디오 흐름 가로채기, PIM 데이터 수정, 임의 코드 실행과 같은 **"나쁜" 애플리케이션의 일반적인 동작**을 찾습니다.
```
python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
```
### [MARA Framework](https://github.com/xtiankisutsa/MARA_Framework)

![](<../../.gitbook/assets/image (595).png>)

**MARA**는 **M**obile **A**pplication **R**everse engineering 및 **A**nalysis Framework입니다. 이 도구는 일반적으로 사용되는 모바일 애플리케이션 역공학 및 분석 도구를 결합하여 OWASP 모바일 보안 위협에 대한 모바일 애플리케이션 테스트를 지원합니다. 그 목표는 모바일 애플리케이션 개발자와 보안 전문가들이 이 작업을 더 쉽고 친숙하게 할 수 있도록 하는 것입니다.

다음을 수행할 수 있습니다:

* 다양한 도구를 사용하여 Java 및 Smali 코드 추출
* [smalisca](https://github.com/dorneanu/smalisca), [ClassyShark](https://github.com/google/android-classyshark), [androbugs](https://github.com/AndroBugs/AndroBugs_Framework), [androwarn](https://github.com/maaaaz/androwarn), [APKiD](https://github.com/rednaga/APKiD)를 사용하여 APK 분석
* APK에서 정규식을 사용하여 개인 정보 추출
* Manifest 분석
* [pyssltest](https://github.com/moheshmohan/pyssltest), [testssl](https://github.com/drwetter/testssl.sh), [whatweb](https://github.com/urbanadventurer/WhatWeb)를 사용하여 발견된 도메인 분석
* [apk-deguard.com](http://www.apk-deguard.com)를 통해 APK의 난독화 해제

### Koodous

악성 코드 감지에 유용: [https://koodous.com/](https://koodous.com)

## 코드 난독화/해제 난독화

코드를 난독화하는 서비스 및 구성에 따라 비밀 정보가 난독화되었을 수도 있고 그렇지 않을 수도 있음에 유의하십시오.

### [ProGuard](https://en.wikipedia.org/wiki/ProGuard\_\(software\))

[Wikipedia](https://en.wikipedia.org/wiki/ProGuard\_\(software\))에 따르면 **ProGuard**는 Java 코드를 축소화, 최적화 및 난독화하는 오픈 소스 명령줄 도구입니다. ProGuard는 바이트코드를 최적화하고 사용되지 않는 명령을 감지하고 제거할 수 있습니다. ProGuard는 GNU General Public License 버전 2 하에 배포되는 무료 소프트웨어입니다.

ProGuard는 Android SDK의 일부로 제공되며 릴리스 모드로 애플리케이션을 빌드할 때 실행됩니다.

### [DexGuard](https://www.guardsquare.com/dexguard)

APK의 난독화를 해제하는 단계별 가이드는 [https://blog.lexfo.fr/dexguard.html](https://blog.lexfo.fr/dexguard.html)에서 확인할 수 있습니다.

(해당 가이드로부터) 최근 확인한 바에 따르면 Dexguard의 작동 방식은 다음과 같습니다:

* InputStream으로 리소스를 로드
* 결과를 복호화하는 FilterInputStream에서 상속된 클래스에 전달
* 일부 무용한 난독화를 수행하여 역공학자의 시간을 소비
* 복호화된 결과를 얻기 위해 ZipInputStream에 전달하여 DEX 파일을 얻음
* 최종적으로 `loadDex` 메서드를 사용하여 결과 DEX를 리소스로 로드

### [DeGuard](http://apk-deguard.com)

**DeGuard는 Android 난독화 도구에 의해 수행된 난독화 과정을 반전시킵니다. 이를 통해 코드 검사 및 라이브러리 예측을 포함한 다양한 보안 분석이 가능해집니다.**

난독화된 APK를 해당 플랫폼에 업로드할 수 있습니다.

### [Simplify](https://github.com/CalebFenton/simplify)

**일반적인 Android 해독기**입니다. Simplify는 **앱을 가상으로 실행**하여 그 동작을 이해한 후 코드를 **최적화**하여 동일하게 동작하지만 사람이 이해하기 쉽도록 만듭니다. 각 최적화 유형은 간단하고 일반적이므로 특정 난독화 유형이 무엇이든 상관없습니다.

### [APKiD](https://github.com/rednaga/APKiD)

APKiD는 **APK가 만들어진 방식에 대한 정보**를 제공합니다. **컴파일러**, **패커**, **난독화 도구** 및 기타 이상한 것들을 식별합니다. Android용 [_PEiD_](https://www.aldeid.com/wiki/PEiD)입니다.

### 수동

[**사용자 정의 난독화를 반전하는 방법에 대한 팁을 학습**하기 위해 이 튜토리얼을 읽으세요](manual-deobfuscation.md)

## Labs

### [Androl4b](https://github.com/sh4hin/Androl4b)

AndroL4b는 우분투-메이트를 기반으로 한 Android 보안 가상 머신으로, 다양한 보안 전문가 및 연구원들의 최신 프레임워크, 튜토리얼 및 랩을 포함합니다. 역공학 및 악성 코드 분석을 위한 것입니다.

## References

* [https://owasp.org/www-project-mobile-app-security/](https://owasp.org/www-project-mobile-app-security/)
* [https://appsecwiki.com/#/](https://appsecwiki.com/#/) 리소스 목록
* [https://maddiestone.github.io/AndroidAppRE/](https://maddiestone.github.io/AndroidAppRE/) Android 빠른 코스
* [https://manifestsecurity.com/android-application-security/](https://manifestsecurity.com/android-application-security/)
* [https://github.com/Ralireza/Android-Security-Teryaagh](https://github.com/Ralireza/Android-Security-Teryaagh)
* [https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec](https://www.youtube.com/watch?v=PMKnPaGWxtg\&feature=youtu.be\&ab\_channel=B3nacSec)

## 아직 시도해보지 않은 것

* [https://www.vegabird.com/yaazhini/](https://www.vegabird.com/yaazhini/)
* [https://github.com/abhi-r3v0/Adhrit](https://github.com/abhi-r3v0/Adhrit)

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 가입하여 경험 많은 해커 및 버그 바운티 헌터들과 소통하세요!

**해킹 통찰**\
해킹의 즐거움과 도전에 대해 탐구하는 콘텐츠와 상호 작용하세요

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰을 통해 빠른 속도의 해킹 세계를 따라가세요

**최신 공지**\
최신 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대해 알아두세요

**[**Discord**](https://discord.com/invite/N3FrSbmwdy)에서 최고의 해커들과 협업을 시작하세요!**

<details>

<summary><strong>**htARTE (HackTricks AWS Red Team Expert)**로부터 제로에서 영웅까지 AWS 해킹을 배우세요</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **HackTricks** 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>
