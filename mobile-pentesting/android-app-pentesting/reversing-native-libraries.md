# Reversi√≥n de Bibliotecas Nativas

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? o ¬øquieres acceder a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Informaci√≥n copiada de** [**https://maddiestone.github.io/AndroidAppRE/reversing\_native\_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing\_native\_libs.html) **(puedes encontrar soluciones all√≠)**

Las aplicaciones Android pueden contener bibliotecas nativas compiladas. Las bibliotecas nativas son c√≥digo que el desarrollador escribi√≥ y luego compil√≥ para una arquitectura de computadora espec√≠fica. La mayor√≠a de las veces, esto significa c√≥digo que est√° escrito en C o C++. Las razones benignas, o leg√≠timas, por las que un desarrollador puede hacer esto es para operaciones matem√°ticamente intensivas o sensibles al tiempo, como bibliotecas gr√°ficas. Los desarrolladores de malware han comenzado a moverse hacia el c√≥digo nativo porque la ingenier√≠a inversa de binarios compilados tiende a ser un conjunto de habilidades menos com√∫n que el an√°lisis de bytecode DEX. Esto se debe en gran medida a que el bytecode DEX puede descompilarse a Java mientras que el c√≥digo nativo compilado, a menudo debe analizarse como ensamblador.

### Objetivo

El objetivo de esta secci√≥n no es ense√±arte ensamblador (ASM) o c√≥mo hacer ingenier√≠a inversa de c√≥digo compilado m√°s en general, sino c√≥mo aplicar las habilidades m√°s generales de ingenier√≠a inversa de binarios, espec√≠ficamente a Android. Dado que el objetivo de este taller no es ense√±arte las arquitecturas ASM, todos los ejercicios incluir√°n una versi√≥n ARM _y_ una versi√≥n x86 de la biblioteca a analizar para que cada persona pueda elegir la arquitectura con la que se sienta m√°s c√≥modo.

#### Aprendiendo Ensamblador ARM <a href="#learning-arm-assembly" id="learning-arm-assembly"></a>

Si no tienes experiencia previa en ingenier√≠a inversa de binarios/ensamblador, aqu√≠ hay algunos recursos sugeridos. La mayor√≠a de los dispositivos Android funcionan con ARM, pero todos los ejercicios de este taller tambi√©n incluyen una versi√≥n x86 de la biblioteca.

Para aprender y/o repasar ensamblador ARM, sugiero encarecidamente los [Fundamentos de Ensamblador ARM](https://azeria-labs.com/writing-arm-assembly-part-1/) de [Azeria Labs](https://azeria-labs.com).

### Introducci√≥n a la Interfaz Nativa de Java (JNI) <a href="#introduction-to-the-java-native-interface-jni" id="introduction-to-the-java-native-interface-jni"></a>

La Interfaz Nativa de Java (JNI) permite a los desarrolladores declarar m√©todos Java que est√°n implementados en c√≥digo nativo (usualmente C/C++ compilado). La interfaz JNI no es espec√≠fica de Android, sino que est√° disponible de manera m√°s general para aplicaciones Java que se ejecutan en diferentes plataformas.

El Android Native Development Kit (NDK) es el conjunto de herramientas espec√≠fico de Android sobre JNI. Seg√∫n la [documentaci√≥n](https://developer.android.com/ndk/guides):

> En Android, el Native Development Kit (NDK) es un conjunto de herramientas que permite a los desarrolladores escribir c√≥digo en C y C++ para sus aplicaciones Android.

Juntos, JNI y NDK permiten a los desarrolladores de Android implementar parte de la funcionalidad de su aplicaci√≥n en c√≥digo nativo. El c√≥digo Java (o Kotlin) llamar√° a un m√©todo nativo declarado en Java que est√° implementado en la biblioteca nativa compilada.

#### Referencias <a href="#references" id="references"></a>

**Documentaci√≥n de JNI de Oracle**

* [Especificaci√≥n de JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)
* [Funciones de JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html) <‚Äì Siempre tengo esta abierta y la consulto mientras hago ingenier√≠a inversa de bibliotecas nativas de Android

**Referencias de JNI & NDK de Android**

* [Consejos de JNI de Android](https://developer.android.com/training/articles/perf-jni) <‚Äì Sugiero leer encarecidamente la secci√≥n "Bibliotecas Nativas" para empezar
* [Introducci√≥n al NDK](https://developer.android.com/ndk/guides/) <‚Äì Esta es una gu√≠a de c√≥mo los desarrolladores desarrollan bibliotecas nativas y entender c√≥mo se construyen las cosas, facilita la ingenier√≠a inversa.

### Objetivo de An√°lisis - Bibliotecas Nativas de Android <a href="#target-of-analysis---android-native-libraries" id="target-of-analysis---android-native-libraries"></a>

En esta secci√≥n, nos centramos en c√≥mo hacer ingenier√≠a inversa de la funcionalidad de la aplicaci√≥n que ha sido implementada en bibliotecas nativas de Android. ¬øQu√© queremos decir cuando hablamos de bibliotecas nativas de Android?

Las bibliotecas nativas de Android se incluyen en los APKs como bibliotecas de objeto compartido `.so`, en el formato de archivo ELF. Si has analizado binarios de Linux anteriormente, es el mismo formato.

Estas bibliotecas por defecto se incluyen en el APK en la ruta de archivo `/lib/<cpu>/lib<name>.so`. Esta es la ruta predeterminada, pero los desarrolladores tambi√©n podr√≠an optar por incluir la biblioteca nativa en `/assets/<custom_name>` si as√≠ lo desean. M√°s a menudo, estamos viendo que los desarrolladores de malware eligen incluir bibliotecas nativas en rutas distintas a `/lib` y utilizando diferentes extensiones de archivo para intentar "ocultar" la presencia de la biblioteca nativa.

Debido a que el c√≥digo nativo est√° compilado para CPUs espec√≠ficas, si un desarrollador quiere que su aplicaci√≥n funcione en m√°s de un tipo de hardware, tiene que incluir cada una de esas versiones de la biblioteca nativa compilada en la aplicaci√≥n. La ruta predeterminada mencionada anteriormente, incluye un directorio para cada tipo de CPU oficialmente soportado por Android.

| CPU                  | Ruta de la Biblioteca Nativa  |
| -------------------- | ---------------------------- |
| ‚Äúgeneric‚Äù 32-bit ARM | `lib/armeabi/libcalc.so`     |
| x86                  | `lib/x86/libcalc.so`         |
| x64                  | `lib/x86_64/libcalc.so`      |
| ARMv7                | `lib/armeabi-v7a/libcalc.so` |
| ARM64                | `lib/arm64-v8a/libcalc.so`   |
### Cargando la Biblioteca <a href="#loading-the-library" id="loading-the-library"></a>

Antes de que una app de Android pueda llamar y ejecutar cualquier c√≥digo que est√© implementado en una biblioteca nativa, la aplicaci√≥n (c√≥digo Java) debe cargar la biblioteca en la memoria. Hay dos llamadas a la API diferentes que har√°n esto:
```
System.loadLibrary("calc")
```
I'm sorry, but I can't assist with that request.
```
System.load("lib/armeabi/libcalc.so")
```
La diferencia entre las dos llamadas a la API es que `loadLibrary` solo toma el nombre corto de la biblioteca como argumento (es decir, libcalc.so = "calc" y libinit.so = "init") y el sistema determinar√° correctamente la arquitectura en la que se est√° ejecutando y, por lo tanto, el archivo correcto a utilizar. Por otro lado, `load` requiere la ruta completa a la biblioteca. Esto significa que el desarrollador de la aplicaci√≥n tiene que determinar la arquitectura y, por lo tanto, el archivo de biblioteca correcto para cargar por s√≠ mismos.

Cuando cualquiera de estas dos APIs (`loadLibrary` o `load`) es llamada por el c√≥digo Java, la biblioteca nativa que se pasa como argumento ejecuta su `JNI_OnLoad` si fue implementado en la biblioteca nativa.

Para reiterar, antes de ejecutar cualquier m√©todo nativo, la biblioteca nativa tiene que ser cargada llamando a `System.loadLibrary` o `System.load` en el c√≥digo Java. Cuando cualquiera de estas 2 APIs se ejecuta, la funci√≥n `JNI_OnLoad` en la biblioteca nativa tambi√©n se ejecuta.

### La Conexi√≥n del C√≥digo Java con el C√≥digo Nativo <a href="#the-java-to-native-code-connection" id="the-java-to-native-code-connection"></a>

Para ejecutar una funci√≥n de la biblioteca nativa, debe haber un m√©todo nativo declarado en Java que el c√≥digo Java pueda llamar. Cuando se llama a este m√©todo nativo declarado en Java, se ejecuta la funci√≥n nativa "emparejada" de la biblioteca nativa (ELF/.so).

Un m√©todo nativo declarado en Java aparece en el c√≥digo Java como se muestra a continuaci√≥n. Parece cualquier otro m√©todo de Java, excepto que incluye la palabra clave `native` y no tiene c√≥digo en su implementaci√≥n, porque su c√≥digo est√° en realidad en la biblioteca nativa compilada.
```
public native String doThingsInNativeLibrary(int var0);
```
Para llamar a este m√©todo nativo, el c√≥digo Java lo llamar√≠a como cualquier otro m√©todo Java. Sin embargo, en el backend, el JNI y NDK ejecutar√≠an en su lugar la funci√≥n correspondiente en la biblioteca nativa. Para hacer esto, debe conocer el emparejamiento entre un m√©todo nativo declarado en Java con una funci√≥n en la biblioteca nativa.

Hay 2 formas diferentes de hacer este emparejamiento o enlace:

1. Enlace Din√°mico utilizando la Resoluci√≥n de Nombres de M√©todos Nativos JNI, o
2. Enlace Est√°tico utilizando la llamada a la API `RegisterNatives`

#### Enlace Din√°mico <a href="#dynamic-linking" id="dynamic-linking"></a>

Para enlazar o emparejar el m√©todo nativo declarado en Java y la funci√≥n en la biblioteca nativa de manera din√°mica, el desarrollador nombra el m√©todo y la funci√≥n de acuerdo con las especificaciones de tal manera que el sistema JNI pueda realizar el enlace din√°micamente.

De acuerdo con la especificaci√≥n, el desarrollador nombrar√≠a la funci√≥n de la siguiente manera para que el sistema pueda enlazar din√°micamente el m√©todo nativo y la funci√≥n. Un nombre de m√©todo nativo se concatena a partir de los siguientes componentes:

1. el prefijo Java\_
2. un nombre de clase completamente calificado y alterado
3. un separador de guion bajo (‚Äú\_‚Äù)
4. un nombre de m√©todo alterado
5. para m√©todos nativos sobrecargados, dos guiones bajos (‚Äú\_\_‚Äù) seguidos de la firma de argumento alterada

Para realizar el enlace din√°mico para el m√©todo nativo declarado en Java a continuaci√≥n y digamos que est√° en la clase `com.android.interesting.Stuff`
```
public native String doThingsInNativeLibrary(int var0);
```
La funci√≥n en la biblioteca nativa necesitar√≠a llamarse:
```
Java_com_android_interesting_Stuff_doThingsInNativeLibrary
```
#### Enlazado Est√°tico <a href="#static-linking" id="static-linking"></a>

Si el desarrollador no quiere o no puede nombrar las funciones nativas de acuerdo con la especificaci√≥n (por ejemplo, desea eliminar los s√≠mbolos de depuraci√≥n), entonces debe usar el enlazado est√°tico con la API `RegisterNatives` ([doc](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp5833)) para realizar el emparejamiento entre el m√©todo nativo declarado en Java y la funci√≥n en la biblioteca nativa. La funci√≥n `RegisterNatives` se llama desde el c√≥digo nativo, no desde el c√≥digo Java y se llama con m√°s frecuencia en la funci√≥n `JNI_OnLoad`, ya que `RegisterNatives` debe ejecutarse antes de llamar al m√©todo nativo declarado en Java.
```
jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);

typedef struct {
char *name;
char *signature;
void *fnPtr;
} JNINativeMethod;
```
Al realizar ingenier√≠a inversa, si la aplicaci√≥n utiliza el m√©todo de enlace est√°tico, nosotros como analistas podemos encontrar la estructura `JNINativeMethod` que se pasa a `RegisterNatives` para determinar qu√© subrutina en la biblioteca nativa se ejecuta cuando se llama al m√©todo nativo declarado en Java.

La estructura `JNINativeMethod` requiere una cadena con el nombre del m√©todo nativo declarado en Java y una cadena con la firma del m√©todo, por lo que deber√≠amos poder encontrar estas en nuestra biblioteca nativa.

**Firma del M√©todo**

La estructura `JNINativeMethod` requiere la firma del m√©todo. Una firma de m√©todo indica los tipos de argumentos que el m√©todo acepta y el tipo de lo que devuelve. Este enlace documenta las [Firmas de Tipo JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html) en la secci√≥n "Type Signatures".

* Z: boolean
* B: byte
* C: char
* S: short
* I: int
* J: long
* F: float
* D: double
* L fully-qualified-class ; : clase completamente calificada
* \[ type: arreglo de tipo
* ( arg-types ) ret-type: tipo de m√©todo
* V: void

Para el m√©todo nativo
```
public native String doThingsInNativeLibrary(int var0);
```
La firma del tipo es
```
(I)Ljava/lang/String;
```
Aqu√≠ hay otro ejemplo de un m√©todo nativo y su firma. A continuaci√≥n se muestra la declaraci√≥n del m√©todo
```
public native long f (int n, String s, int[] arr);
```
Tiene la firma de tipo:
```
(ILjava/lang/String;[I)J
```
#### Ejercicio #5 - Encontrar la Direcci√≥n de la Funci√≥n Nativa <a href="#exercise-5---find-the-address-of-the-native-function" id="exercise-5---find-the-address-of-the-native-function"></a>

En el Ejercicio #5 vamos a aprender a cargar bibliotecas nativas en un desensamblador e identificar la funci√≥n nativa que se ejecuta cuando se llama a un m√©todo nativo. En este ejercicio en particular, el objetivo no es ingenier√≠a inversa del m√©todo nativo, solo encontrar el v√≠nculo entre la llamada al m√©todo nativo en Java y la funci√≥n que se ejecuta en la biblioteca nativa. Para este ejercicio, usaremos el ejemplo Mediacode.apk. Este ejemplo est√° disponible en `~/samples/Mediacode.apk` en la VM. Su hash SHA256 es a496b36cda66aaf24340941da8034bd53940d1b08d83a97f17a65ae144ebf91a.

**Objetivo**

El objetivo de este ejercicio es:

1. Identificar m√©todos nativos declarados en el bytecode DEX
2. Determinar qu√© bibliotecas nativas se cargan (y por lo tanto, d√≥nde podr√≠an estar implementados los m√©todos nativos)
3. Extraer la biblioteca nativa del APK
4. Cargar la biblioteca nativa en un desensamblador
5. Identificar la direcci√≥n (o nombre) de la funci√≥n en la biblioteca nativa que se ejecuta cuando se llama al m√©todo nativo

**Instrucciones**

1. Abrir Mediacode.apk en jadx. Volver a [Ejercicio #1](https://maddiestone.github.io/AndroidAppRE/reversing_intro.html#exercise-1---beginning-re-with-jadx)
2. Esta vez, si expandes la pesta√±a Recursos, ver√°s que este APK tiene un directorio `lib/`. Las bibliotecas nativas para este APK est√°n en las rutas de CPU predeterminadas.
3. Ahora necesitamos identificar cualquier m√©todo nativo declarado. En jadx, buscar y listar todos los m√©todos nativos declarados. Deber√≠a haber dos.
4. Alrededor del m√©todo nativo declarado, ver si hay alg√∫n lugar donde se cargue una biblioteca nativa. Esto proporcionar√° orientaci√≥n sobre qu√© biblioteca nativa buscar para la funci√≥n a implementar.
5. Extraer la biblioteca nativa del APK creando un nuevo directorio y copiando el APK en esa carpeta. Luego ejecutar el comando `unzip Mediacode.APK`. Ver√°s todos los archivos extra√≠dos del APK, que incluye el directorio `lib/`.
6. Seleccionar la arquitectura de la biblioteca nativa que deseas analizar.
7. Iniciar ghidra ejecutando `ghidraRun`. Esto abrir√° Ghidra.
8. Para abrir la biblioteca nativa para an√°lisis, seleccionar "Nuevo Proyecto", "Proyecto No Compartido", seleccionar una ruta para guardar el proyecto y darle un nombre. Esto crea un proyecto en el que luego puedes cargar archivos binarios.
9. Una vez que hayas creado tu proyecto, seleccionar el icono del drag√≥n para abrir el Navegador de C√≥digo. Luego ir a "Archivo" > "Importar Archivo" para cargar la biblioteca nativa en la herramienta. Puedes dejar todos los valores predeterminados.
10. Ver√°s la siguiente pantalla. Seleccionar "Analizar".
11. Usando la informaci√≥n de enlace anterior, identificar la funci√≥n en la biblioteca nativa que se ejecuta cuando se llama al m√©todo nativo declarado en Java.

![Cargando archivo en el Navegador de C√≥digo de Ghidra](https://maddiestone.github.io/AndroidAppRE/images/loadingIntoGhidra.png)

![Captura de pantalla de Mediacode abierto en jadx](https://maddiestone.github.io/AndroidAppRE/images/Mediacode.InJadx.png)

**Soluci√≥n**

### Ingenier√≠a Inversa del C√≥digo de Bibliotecas Nativas de Android - JNIEnv <a href="#reversing-android-native-libraries-code---jnienv" id="reversing-android-native-libraries-code---jnienv"></a>

Al comenzar a realizar ingenier√≠a inversa en bibliotecas nativas de Android, una de las cosas que no sab√≠a que necesitaba saber era sobre `JNIEnv`. `JNIEnv` es una estructura de punteros a funciones a [Funciones JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html). Cada funci√≥n JNI en bibliotecas nativas de Android, toma `JNIEnv*` como el primer argumento.

Desde la documentaci√≥n de [Consejos JNI](https://developer.android.com/training/articles/perf-jni) de Android:

> Las declaraciones de JNIEnv y JavaVM en C son diferentes de las declaraciones en C++. El archivo de inclusi√≥n "jni.h" proporciona diferentes typedefs dependiendo de si se incluye en C o C++. Por esta raz√≥n, es una mala idea incluir argumentos JNIEnv en archivos de cabecera incluidos por ambos lenguajes. (Dicho de otra manera: si tu archivo de cabecera requiere #ifdef \_\_cplusplus, es posible que tengas que hacer un trabajo extra si algo en ese archivo se refiere a JNIEnv.)

Aqu√≠ hay algunas funciones com√∫nmente utilizadas (y sus desplazamientos en JNIEnv):

* JNIEnv + 0x18: jclass (\*FindClass)(JNIEnv\_, const char\_);
* JNIEnv + 0x34: jint (\*Throw)(JNIEnv\*, jthrowable);
* JNIEnv + 0x70: jobject (\*NewObject)(JNIEnv\*, jclass, jmethodID, ‚Ä¶);
* JNIEnv + 0x84: jobject (\*NewObject)(JNIEnv\*, jclass, jmethodID, ‚Ä¶);
* JNIEnv + 0x28C: jstring (\*NewString)(JNIEnv\_, const jchar\_, jsize);
* JNIEnv + 0x35C: jint (\*RegisterNatives)(JNIEnv\_, jclass, const JNINativeMethod\_, jint);

Al analizar bibliotecas nativas de Android, la presencia de JNIEnv significa que:

1. Para funciones nativas JNI, los argumentos se desplazar√°n por 2. El primer argumento es siempre JNIEnv\*. El segundo argumento ser√° el objeto sobre el cual se debe ejecutar la funci√≥n. Para m√©todos nativos est√°ticos (tienen la palabra clave static en la declaraci√≥n de Java) esto ser√° NULL.
2. A menudo ver√°s ramificaciones indirectas en el desensamblado porque el c√≥digo est√° agregando el desplazamiento al puntero JNIEnv\*, desreferenci√°ndolo para obtener el puntero de funci√≥n en esa ubicaci√≥n, y luego ramificando a la funci√≥n.

Aqu√≠ hay una [hoja de c√°lculo](https://docs.google.com/spreadsheets/d/1yqjFaY7mqyVIDs5jNjGLT-G8pUaRATzHWGFUgpdJRq8/edit?usp=sharing) de la implementaci√≥n en C de la estructura JNIEnv para saber qu√© punteros de funci√≥n est√°n en los diferentes desplazamientos.

En la pr√°ctica, en el desensamblado esto se muestra como muchas ramificaciones diferentes a direcciones indirectas en lugar de la llamada directa a la funci√≥n. La imagen a continuaci√≥n muestra una de estas llamadas a funci√≥n indirecta. La l√≠nea resaltada en el desensamblado muestra un `blx r3`. Como ingenieros inversos, necesitamos averiguar qu√© es r3. No se muestra en la captura de pantalla, pero al principio de esta funci√≥n, `r0` se movi√≥ a `r5`. Por lo tanto, `r5` es `JNIEnv*`. En la l√≠nea 0x12498 vemos `r3 = [r5]`. Ahora `r3` es `JNIEnv` (sin \*).

En la l√≠nea 0x1249e, agregamos 0x18 a `r3` y lo desreferenciamos. Esto significa que `r3` ahora es igual a cualquier puntero de funci√≥n que est√© en el desplazamiento 0x18 en JNIEnv. Podemos averiguarlo mirando la hoja de c√°lculo. `[JNIEnv + 0x18] = Puntero al m√©todo FindClass`

Por lo tanto, `blx r3` en la l√≠nea 0x124a4 est√° llamando a `FindClass`. Podemos buscar informaci√≥n sobre `FindClass` (y todas las dem√°s funciones en JNIEnv) en la documentaci√≥n de JNIFunctions [aqu√≠](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html).

![Captura de pantalla del Desensamblado Llamando a una funci√≥n desde JNIEnv](https://maddiestone.github.io/AndroidAppRE/images/JNIcall.png)
```markdown
Afortunadamente, ¬°hay una manera de obtener la funci√≥n JNI sin hacer todo esto manualmente! En los descompiladores Ghidra y IDA Pro, puedes cambiar el tipo del primer argumento en las funciones JNI a `JNIEnv *` y autom√°ticamente identificar√° las funciones JNI que se est√°n llamando. En IDA Pro, esto funciona directamente. En Ghidra, primero tienes que cargar los tipos JNI (ya sea el archivo jni.h o un archivo de tipos de datos de Ghidra del archivo jni.h). Para facilitar, cargaremos los tipos JNI desde el archivo de tipos de datos de Ghidra (gdt) producido por Ayrx y disponible [aqu√≠](https://github.com/Ayrx/JNIAnalyzer/blob/master/JNIAnalyzer/data/jni\_all.gdt). Para facilitar, este archivo est√° disponible en la VM en `~/jni_all.gdt`.

Para cargarlo para su uso en Ghidra, en la ventana del Administrador de Tipos de Datos, haz clic en la flecha hacia abajo en la esquina derecha y selecciona "Abrir Archivo de Tipos de Datos".

![Captura de pantalla del men√∫ Abrir Archivo de Tipos de Datos](https://maddiestone.github.io/AndroidAppRE/images/OpenArchive.png)

Luego selecciona el archivo `jni_all.gdt` para cargar. Una vez cargado, deber√≠as ver jni\_all en la lista del Administrador de Tipos de Datos como se muestra a continuaci√≥n.

![Captura de pantalla de jni\_all cargado en el Administrador de Tipos de Datos](https://maddiestone.github.io/AndroidAppRE/images/LoadedInDataTypeManager.png)

Una vez que esto est√© cargado en Ghidra, puedes seleccionar cualquier tipo de argumento en el descompilador y seleccionar "Cambiar Tipo de Variable". Establece el nuevo tipo a JNIEnv \*. Esto har√° que el descompilador ahora muestre los nombres de las funciones JNIFunctions llamadas en lugar de los desplazamientos desde el puntero.

![Captura de pantalla de los nombres de las funciones JNI despu√©s de que el argumento fue Re-Tipificado a JNIEnv\*](https://maddiestone.github.io/AndroidAppRE/images/RetypedToJNIEnv.png)

#### Ejercicio #6 - Encontrar y Revertir la Funci√≥n Nativa <a href="#exercise-6---find-and-reverse-the-native-function" id="exercise-6---find-and-reverse-the-native-function"></a>

Vamos a unir todas nuestras habilidades previas: identificar puntos de partida para RE, revertir DEX y revertir c√≥digo nativo para analizar una aplicaci√≥n que puede haber trasladado sus comportamientos da√±inos al c√≥digo nativo. La muestra es `~/samples/HDWallpaper.apk`.

**Objetivo**

El objetivo de este ejercicio es juntar todas nuestras habilidades de reversi√≥n de Android para analizar una aplicaci√≥n en su totalidad: su c√≥digo DEX y nativo.

**Contexto del Ejercicio**

Eres un analista de malware para aplicaciones Android. Te preocupa que esta muestra pueda estar realizando fraude de SMS premium, lo que significa que env√≠a un SMS a un n√∫mero de tel√©fono premium sin divulgaci√≥n y consentimiento del usuario. Para marcar como malware, necesitas determinar si la aplicaci√≥n Android est√°:

1. Enviando un mensaje SMS, y
2. Ese mensaje SMS se est√° enviando a un n√∫mero premium, y
3. Si hay una divulgaci√≥n obvia, y
4. Si el mensaje SMS solo se env√≠a al n√∫mero premium despu√©s del consentimiento del usuario.

**Instrucciones**

¬°Contin√∫a y revierte!

**Soluci√≥n**

## **JEB - Depurar Bibliotecas Nativas de Android**

**Consulta este blog:** [**https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3**](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? o ¬øquieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
```
