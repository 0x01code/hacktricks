<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une entreprise de cybers√©curit√©? Voulez-vous voir votre entreprise annonc√©e dans HackTricks? ou voulez-vous avoir acc√®s √† la derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!

- D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs.

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live).

- **Partagez vos astuces de piratage en soumettant des PR au [repo hacktricks](https://github.com/carlospolop/hacktricks) et au [repo hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>


**Informations copi√©es de** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)** (vous pouvez trouver des solutions l√†-bas)**

Les applications Android peuvent contenir des biblioth√®ques natives compil√©es. Les biblioth√®ques natives sont du code que le d√©veloppeur a √©crit puis compil√© pour une architecture informatique sp√©cifique. Le plus souvent, cela signifie du code √©crit en C ou C++. Les raisons b√©nignes ou l√©gitimes pour lesquelles un d√©veloppeur peut le faire sont des op√©rations intensives en math√©matiques ou sensibles au temps, telles que les biblioth√®ques graphiques. Les d√©veloppeurs de logiciels malveillants ont commenc√© √† passer au code natif car l'ing√©nierie inverse de binaires compil√©s tend √† √™tre un ensemble de comp√©tences moins courant que l'analyse du bytecode DEX. Cela est largement d√ª au fait que le bytecode DEX peut √™tre d√©compil√© en Java, tandis que le code natif compil√© doit souvent √™tre analys√© en tant qu'assemblage.

## Objectif

L'objectif de cette section n'est pas de vous apprendre l'assemblage (ASM) ou comment inverser le code compil√© de mani√®re plus g√©n√©rale, mais plut√¥t comment appliquer les comp√©tences d'ing√©nierie inverse binaire plus g√©n√©rales, sp√©cifiquement √† Android. Parce que l'objectif de cet atelier n'est pas de vous enseigner les architectures ASM, tous les exercices incluront une version ARM _et_ une version x86 de la biblioth√®que √† analyser afin que chaque personne puisse choisir l'architecture avec laquelle elle est plus √† l'aise.

### Apprentissage de l'assemblage ARM <a href="learning-arm-assembly" id="learning-arm-assembly"></a>

Si vous n'avez pas d'exp√©rience pr√©alable en ing√©nierie inverse binaire / assemblage, voici quelques ressources sugg√©r√©es. La plupart des appareils Android fonctionnent sur ARM, mais tous les exercices de cet atelier incluent √©galement une version x86 de la biblioth√®que.

Pour apprendre et / ou r√©viser l'assemblage ARM, je sugg√®re fortement les [bases de l'assemblage ARM](https://azeria-labs.com/writing-arm-assembly-part-1/) de [Azeria Labs](https://azeria-labs.com).

## Introduction √† l'interface native Java (JNI) <a href="introduction-to-the-java-native-interface-jni" id="introduction-to-the-java-native-interface-jni"></a>

L'interface native Java (JNI) permet aux d√©veloppeurs de d√©clarer des m√©thodes Java qui sont impl√©ment√©es dans du code natif (g√©n√©ralement compil√© en C/C++). L'interface JNI n'est pas sp√©cifique √† Android, mais est disponible plus g√©n√©ralement aux applications Java qui s'ex√©cutent sur diff√©rentes plates-formes.

Le kit de d√©veloppement natif Android (NDK) est l'ensemble d'outils sp√©cifique √† Android sur JNI. Selon les [docs](https://developer.android.com/ndk/guides):

> Dans Android, le kit de d√©veloppement natif (NDK) est un ensemble d'outils qui permet aux d√©veloppeurs d'√©crire du code C et C++ pour leurs applications Android.

Ensemble, JNI et NDK permettent aux d√©veloppeurs Android d'impl√©menter une partie de la fonctionnalit√© de leur application en code natif. Le code Java (ou Kotlin) appellera une m√©thode native d√©clar√©e en Java qui est impl√©ment√©e dans la biblioth√®que native compil√©e.

### R√©f√©rences <a href="references" id="references"></a>

**Oracle JNI Docs**

* [Sp√©cification JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)
* [Fonctions JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html) <‚Äì J'ai toujours celui-ci ouvert et je m'y r√©f√®re lors de l'inversion de biblioth√®ques natives Android

**R√©f√©rences JNI & NDK Android**

* [Conseils JNI Android](https://developer.android.com/training/articles/perf-jni) <‚Äì Je recommande vivement de lire la section "Biblioth√®ques natives" pour commencer
* [Commencer avec le NDK](https://developer.android.com/ndk/guides/) <‚Äì Il s'agit d'un guide pour aider les d√©veloppeurs √† d√©velopper des biblioth√®ques natives et √† comprendre comment les choses sont construites, ce qui facilite l'inversion.

## Cible d'analyse - Biblioth√®ques natives Android <a href="target-of-analysis---android-native-libraries" id="target-of-analysis---android-native-libraries"></a>

Pour cette section, nous nous concentrons sur la mani√®re d'inverser la fonctionnalit√© de l'application qui a √©t√© impl√©ment√©e dans des biblioth√®ques natives Android. Lorsque nous disons biblioth√®ques natives Android, qu'entendons-nous?

Les biblioth√®ques natives Android sont incluses dans les APK sous forme de biblioth√®ques d'objets partag√©s `.so`, dans le format de fichier ELF. Si vous avez d√©j√† analys√© des binaires Linux, c'est le m√™me format.

Ces biblioth√®ques sont incluses par d√©faut dans l'APK au chemin de fichier `/lib/<cpu>/lib<name>.so`. C'est le chemin par d√©faut, mais les d√©veloppeurs peuvent √©galement choisir d'inclure la biblioth√®que native dans `/assets/<custom_name>` s'ils le souhaitent. Plus souvent, nous voyons les d√©veloppeurs de logiciels malveillants choisir d'inclure des biblioth√®ques natives dans des chemins autres que `/lib` et d'utiliser des extensions de fichier diff√©rentes pour tenter de "cacher" la pr√©sence de la biblioth√®que native.

√âtant donn√© que le code natif est compil√© pour des CPU sp√©cifiques, si un d√©veloppeur veut que son application s'ex√©cute sur plus d'un type de mat√©riel, il doit inclure chacune de ces versions de la biblioth√®que native compil√©e dans l'application. Le chemin par d√©faut mentionn√© ci-dessus inclut un r√©pertoire pour chaque type de CPU officiellement pris en charge par Android.

| CPU                  | Chemin de la biblioth√®que native          |
| -------------------- | ---------------------------- |
| ARM 32 bits g√©n√©rique | `lib/armeabi/libcalc.so`     |
| x86                  | `lib/x86/libcalc.so`         |
| x64                  | `lib/x86_64/libcalc.so`      |
| ARMv7                | `lib/armeabi-v7a/libcalc.so` |
| ARM64                | `lib/arm64-v8a/libcalc.so`   |

## Chargement de la biblioth√®que <a href="loading-the-library" id="loading-the-library"></a>

Avant qu'une application Android ne puisse appeler et ex√©cuter un code impl√©ment√© dans une biblioth√®que native, l'application (code Java) doit charger la biblioth√®que en m√©moire. Il existe deux appels d'API diff√©rents qui feront cela:
```
System.loadLibrary("calc")
```
Voici le contenu traduit en fran√ßais :

# R√©tro-ing√©nierie de biblioth√®ques natives

## Introduction

Les biblioth√®ques natives sont des fichiers binaires compil√©s qui contiennent du code machine pour une architecture sp√©cifique. Les biblioth√®ques natives sont souvent utilis√©es pour fournir des fonctionnalit√©s suppl√©mentaires √† une application, telles que l'acc√®s √† des fonctionnalit√©s du syst√®me d'exploitation ou √† des biblioth√®ques tierces. Les biblioth√®ques natives sont souvent utilis√©es dans les applications Android pour fournir des fonctionnalit√©s telles que la prise en charge de la cam√©ra, l'acc√®s aux bases de donn√©es, etc.

## Extraire les biblioth√®ques natives

Les biblioth√®ques natives sont g√©n√©ralement stock√©es dans le r√©pertoire `lib` de l'APK. Pour extraire les biblioth√®ques natives, vous pouvez utiliser l'outil `apktool`. L'outil `apktool` est un outil open source qui permet de d√©compiler et de recompiler des APK.

Pour extraire les biblioth√®ques natives, vous pouvez utiliser la commande suivante :

```
apktool d -s -o <output_directory> <apk_file>
```

Cette commande extraira les biblioth√®ques natives dans le r√©pertoire de sortie sp√©cifi√©.

## Analyse des biblioth√®ques natives

Les biblioth√®ques natives sont des fichiers binaires compil√©s, ce qui signifie qu'elles ne peuvent pas √™tre lues directement. Pour analyser les biblioth√®ques natives, vous devez les d√©sassembler en code assembleur.

Il existe plusieurs outils pour d√©sassembler les biblioth√®ques natives, tels que `IDA Pro`, `Hopper`, `Ghidra`, etc. Ces outils permettent de d√©sassembler les biblioth√®ques natives en code assembleur et de les analyser.

## Recherche de vuln√©rabilit√©s

Une fois que vous avez d√©sassembl√© les biblioth√®ques natives, vous pouvez rechercher des vuln√©rabilit√©s dans le code. Les vuln√©rabilit√©s courantes dans les biblioth√®ques natives comprennent les d√©passements de tampon, les fuites de m√©moire, les erreurs de format de cha√Æne, etc.

Pour rechercher des vuln√©rabilit√©s dans le code, vous pouvez utiliser des outils tels que `grep`, `strings`, `objdump`, etc. Ces outils permettent de rechercher des cha√Ænes de caract√®res sp√©cifiques dans le code, de rechercher des appels de fonctions dangereuses, etc.

## Conclusion

La r√©tro-ing√©nierie des biblioth√®ques natives est une comp√©tence importante pour les testeurs de p√©n√©tration et les chercheurs en s√©curit√©. En comprenant comment les biblioth√®ques natives sont utilis√©es dans les applications Android et comment les analyser, vous pouvez identifier les vuln√©rabilit√©s et aider √† s√©curiser les applications.
```
System.load("lib/armeabi/libcalc.so")
```
La diff√©rence entre les deux appels d'API est que `loadLibrary` ne prend que le nom court de la biblioth√®que en argument (c'est-√†-dire libcalc.so = "calc" et libinit.so = "init") et le syst√®me d√©termine correctement l'architecture sur laquelle il s'ex√©cute et donc le fichier correct √† utiliser. D'autre part, `load` n√©cessite le chemin complet de la biblioth√®que. Cela signifie que le d√©veloppeur de l'application doit d√©terminer l'architecture et donc le fichier de biblioth√®que correct √† charger lui-m√™me.

Lorsque l'un de ces deux API (`loadLibrary` ou `load`) est appel√© par le code Java, la biblioth√®que native qui est pass√©e en argument ex√©cute son `JNI_OnLoad` si elle a √©t√© impl√©ment√©e dans la biblioth√®que native.

Pour r√©it√©rer, avant d'ex√©cuter des m√©thodes natives, la biblioth√®que native doit √™tre charg√©e en appelant `System.loadLibrary` ou `System.load` dans le code Java. Lorsque l'une de ces 2 API est ex√©cut√©e, la fonction `JNI_OnLoad` dans la biblioth√®que native est √©galement ex√©cut√©e.

## La connexion entre le code Java et le code natif <a href="the-java-to-native-code-connection" id="the-java-to-native-code-connection"></a>

Pour ex√©cuter une fonction de la biblioth√®que native, il doit y avoir une m√©thode native d√©clar√©e en Java que le code Java peut appeler. Lorsque cette m√©thode native d√©clar√©e en Java est appel√©e, la fonction native "associ√©e" de la biblioth√®que native (ELF/.so) est ex√©cut√©e.

Une m√©thode native d√©clar√©e en Java appara√Æt dans le code Java comme ci-dessous. Elle appara√Æt comme n'importe quelle autre m√©thode Java, sauf qu'elle inclut le mot-cl√© `native` et n'a pas de code dans sa mise en ≈ìuvre, car son code est en fait dans la biblioth√®que native compil√©e.
```
public native String doThingsInNativeLibrary(int var0);
```
Pour appeler cette m√©thode native, le code Java l'appellerait comme n'importe quelle autre m√©thode Java. Cependant, en arri√®re-plan, le JNI et le NDK ex√©cuteraient plut√¥t la fonction correspondante dans la biblioth√®que native. Pour ce faire, il doit conna√Ætre l'appariement entre une m√©thode native d√©clar√©e en Java et une fonction dans la biblioth√®que native.

Il existe 2 fa√ßons diff√©rentes de faire cet appariement, ou de le lier :

1. Liaison dynamique en utilisant la r√©solution de nom de m√©thode native JNI, ou
2. Liaison statique en utilisant l'appel d'API `RegisterNatives`

### Liaison dynamique <a href="dynamic-linking" id="dynamic-linking"></a>

Pour lier, ou appairer, la m√©thode native d√©clar√©e en Java et la fonction dans la biblioth√®que native de mani√®re dynamique, le d√©veloppeur nomme la m√©thode et la fonction selon les sp√©cifications de sorte que le syst√®me JNI puisse faire la liaison dynamiquement.

Selon la sp√©cification, le d√©veloppeur nommerait la fonction comme suit pour que le syst√®me puisse lier dynamiquement la m√©thode native et la fonction. Un nom de m√©thode native est concat√©n√© √† partir des composants suivants :

1. le pr√©fixe Java\_
2. un nom de classe qualifi√© enti√®rement mangl√©
3. un s√©parateur de soulignement ("\_")
4. un nom de m√©thode mangl√©
5. pour les m√©thodes natives surcharg√©es, deux traits de soulignement ("\__") suivis de la signature d'argument mangl√©e

Pour effectuer une liaison dynamique pour la m√©thode native d√©clar√©e en Java ci-dessous et disons qu'elle se trouve dans la classe `com.android.interesting.Stuff`
```
public native String doThingsInNativeLibrary(int var0);
```
La fonction dans la biblioth√®que native devrait √™tre nomm√©e:
```
Java_com_android_interesting_Stuff_doThingsInNativeLibrary
```
Si une fonction avec ce nom n'existe pas dans la biblioth√®que native, cela signifie que l'application doit effectuer une liaison statique.

### Liaison statique <a href="static-linking" id="static-linking"></a>

Si le d√©veloppeur ne veut pas ou ne peut pas nommer les fonctions natives selon la sp√©cification (par exemple, s'il veut supprimer les symboles de d√©bogage), il doit utiliser la liaison statique avec l'API `RegisterNatives` ([doc](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp5833)) afin de faire correspondre la m√©thode native d√©clar√©e en Java avec la fonction dans la biblioth√®que native. La fonction `RegisterNatives` est appel√©e √† partir du code natif, pas du code Java, et est le plus souvent appel√©e dans la fonction `JNI_OnLoad`, car `RegisterNatives` doit √™tre ex√©cut√©e avant d'appeler la m√©thode native d√©clar√©e en Java.
```
jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);

typedef struct { 
    char *name; 
    char *signature; 
    void *fnPtr; 
} JNINativeMethod;
```
Lors de l'ing√©nierie inverse, si l'application utilise la m√©thode de liaison statique, nous, en tant qu'analystes, pouvons trouver la structure `JNINativeMethod` qui est transmise √† `RegisterNatives` afin de d√©terminer quelle sous-routine de la biblioth√®que native est ex√©cut√©e lorsque la m√©thode native d√©clar√©e en Java est appel√©e.

La structure `JNINativeMethod` n√©cessite une cha√Æne de caract√®res pour le nom de la m√©thode native d√©clar√©e en Java et une cha√Æne de caract√®res pour la signature de la m√©thode, nous devrions donc √™tre en mesure de les trouver dans notre biblioth√®que native.

**Signature de m√©thode**

La structure `JNINativeMethod` n√©cessite la signature de la m√©thode. Une signature de m√©thode indique les types des arguments que la m√©thode prend et le type de ce qu'elle renvoie. Ce lien documente les [Signatures de type JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html) dans la section "Signatures de type".

* Z: boolean
* B: byte
* C: char
* S: short
* I: int
* J: long
* F: float
* D: double
* L fully-qualified-class ; :classe enti√®rement qualifi√©e
* \[ type: type\[]
* ( arg-types ) ret-type: type de m√©thode
* V: void

Pour la m√©thode native
```
public native String doThingsInNativeLibrary(int var0);
```
La signature de type est
```
(I)Ljava/lang/String;
```
Voici un autre exemple de m√©thode native et de sa signature. Pour cela, voici la d√©claration de la m√©thode :
```
public native long f (int n, String s, int[] arr); 
```
Il a la signature de type :
```
(ILjava/lang/String;[I)J
```
### Exercice #5 - Trouver l'adresse de la fonction native <a href="exercise-5---find-the-address-of-the-native-function" id="exercise-5---find-the-address-of-the-native-function"></a>

Dans l'exercice #5, nous allons apprendre √† charger des biblioth√®ques natives dans un d√©sassembleur et √† identifier la fonction native qui est ex√©cut√©e lorsqu'une m√©thode native est appel√©e. Pour cet exercice particulier, le but n'est pas de r√©tro-ing√©nierie la m√©thode native, mais simplement de trouver le lien entre l'appel √† la m√©thode native en Java et la fonction qui est ex√©cut√©e dans la biblioth√®que native. Pour cet exercice, nous utiliserons l'√©chantillon Mediacode.apk. Cet √©chantillon est disponible √† `~/samples/Mediacode.apk` dans la VM. Son hachage SHA256 est a496b36cda66aaf24340941da8034bd53940d1b08d83a97f17a65ae144ebf91a.

**Objectif**

L'objectif de cet exercice est de :

1. Identifier les m√©thodes natives d√©clar√©es dans le bytecode DEX
2. D√©terminer quelles biblioth√®ques natives sont charg√©es (et donc o√π les m√©thodes natives peuvent √™tre impl√©ment√©es)
3. Extraire la biblioth√®que native de l'APK
4. Charger la biblioth√®que native dans un d√©sassembleur
5. Identifier l'adresse (ou le nom) de la fonction dans la biblioth√®que native qui est ex√©cut√©e lorsque la m√©thode native est appel√©e

**Instructions**

1. Ouvrez Mediacode.apk dans jadx. R√©f√©rez-vous √† l'[Exercice #1](https://maddiestone.github.io/AndroidAppRE/reversing_intro.html#exercise-1---beginning-re-with-jadx)
2. Cette fois, si vous d√©veloppez l'onglet Ressources, vous verrez que cet APK a un r√©pertoire `lib/`. Les biblioth√®ques natives pour cet APK sont dans les chemins CPU par d√©faut.
3. Maintenant, nous devons identifier toutes les m√©thodes natives d√©clar√©es. Dans jadx, recherchez et r√©pertoriez toutes les m√©thodes natives d√©clar√©es. Il devrait y en avoir deux.
4. Autour de la m√©thode native d√©clar√©e, voyez s'il y a un endroit o√π une biblioth√®que native est charg√©e. Cela fournira des indications sur la biblioth√®que native dans laquelle chercher la fonction √† impl√©menter.
5. Extrayez la biblioth√®que native de l'APK en cr√©ant un nouveau r√©pertoire et en copiant l'APK dans ce dossier. Ensuite, ex√©cutez la commande `unzip Mediacode.APK`. Vous verrez tous les fichiers extraits de l'APK, y compris le r√©pertoire `lib/`.
6. S√©lectionnez l'architecture de la biblioth√®que native que vous souhaitez analyser.
7. D√©marrez ghidra en ex√©cutant `ghidraRun`. Cela ouvrira Ghidra.
8. Pour ouvrir la biblioth√®que native pour l'analyse, s√©lectionnez "Nouveau projet", "Projet non partag√©", s√©lectionnez un chemin pour enregistrer le projet et donnez-lui un nom. Cela cr√©e un projet dans lequel vous pouvez ensuite charger des fichiers binaires.
9. Une fois que vous avez cr√©√© votre projet, s√©lectionnez l'ic√¥ne du dragon pour ouvrir le navigateur de code. Allez dans "Fichier" > "Importer un fichier" pour charger la biblioth√®que native dans l'outil. Vous pouvez laisser tous les param√®tres par d√©faut.
10. Vous verrez l'√©cran suivant. S√©lectionnez "Analyser".
11. √Ä l'aide des informations de liaison ci-dessus, identifiez la fonction dans la biblioth√®que native qui est ex√©cut√©e lorsque la m√©thode native d√©clar√©e en Java est appel√©e.

![Chargement du fichier dans le navigateur de code Ghidra](https://maddiestone.github.io/AndroidAppRE/images/loadingIntoGhidra.png)

![Capture d'√©cran de Mediacode ouvert dans jadx](https://maddiestone.github.io/AndroidAppRE/images/Mediacode.InJadx.png)

**Solution**

## R√©tro-ing√©nierie du code des biblioth√®ques natives Android - JNIEnv <a href="reversing-android-native-libraries-code---jnienv" id="reversing-android-native-libraries-code---jnienv"></a>

Lorsque vous commencez √† r√©tro-ing√©nierie des biblioth√®ques natives Android, l'une des choses que je ne savais pas que je devais savoir √©tait √† propos de `JNIEnv`. `JNIEnv` est une structure de pointeurs de fonction vers les [fonctions JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html). Chaque fonction JNI dans les biblioth√®ques natives Android prend `JNIEnv*` comme premier argument.

De la documentation [JNI Tips](https://developer.android.com/training/articles/perf-jni)
