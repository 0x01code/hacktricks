<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!

- Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)

- **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Comparte tus trucos de hacking enviando PRs al [repositorio de hacktricks](https://github.com/carlospolop/hacktricks) y al [repositorio de hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>


**Informaci√≥n copiada de** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)** (puedes encontrar soluciones all√≠)**

Las aplicaciones de Android pueden contener bibliotecas nativas compiladas. Las bibliotecas nativas son c√≥digo que el desarrollador escribi√≥ y luego compil√≥ para una arquitectura de computadora espec√≠fica. Con mayor frecuencia, esto significa c√≥digo que est√° escrito en C o C++. Las razones benignas o leg√≠timas por las que un desarrollador puede hacer esto son para operaciones matem√°ticamente intensivas o sensibles al tiempo, como bibliotecas de gr√°ficos. Los desarrolladores de malware han comenzado a moverse hacia el c√≥digo nativo porque la ingenier√≠a inversa de binarios compilados tiende a ser un conjunto de habilidades menos com√∫n que el an√°lisis de bytecode DEX. Esto se debe en gran parte a que el bytecode DEX se puede descompilar a Java, mientras que el c√≥digo nativo compilado a menudo debe analizarse como ensamblaje.

## Objetivo

El objetivo de esta secci√≥n no es ense√±arte ensamblador (ASM) o c√≥mo revertir el c√≥digo compilado de manera m√°s general, sino c√≥mo aplicar las habilidades de ingenier√≠a inversa de binarios m√°s generales, espec√≠ficamente a Android. Debido a que el objetivo de este taller no es ense√±arte las arquitecturas ASM, todos los ejercicios incluir√°n una versi√≥n ARM _y_ una versi√≥n x86 de la biblioteca que se analizar√° para que cada persona pueda elegir la arquitectura con la que se sienta m√°s c√≥moda.

### Aprendiendo ensamblador ARM <a href="learning-arm-assembly" id="learning-arm-assembly"></a>

Si no tienes experiencia previa en ingenier√≠a inversa de binarios/ensamblador, aqu√≠ hay algunos recursos sugeridos. La mayor√≠a de los dispositivos Android funcionan con ARM, pero todos los ejercicios en este taller tambi√©n incluyen una versi√≥n x86 de la biblioteca.

Para aprender y/o revisar el ensamblador ARM, sugiero encarecidamente los [conceptos b√°sicos del ensamblador ARM](https://azeria-labs.com/writing-arm-assembly-part-1/) de [Azeria Labs](https://azeria-labs.com).

## Introducci√≥n a la Interfaz Nativa de Java (JNI) <a href="introduction-to-the-java-native-interface-jni" id="introduction-to-the-java-native-interface-jni"></a>

La Interfaz Nativa de Java (JNI) permite a los desarrolladores declarar m√©todos de Java que se implementan en c√≥digo nativo (generalmente compilado en C/C++). La interfaz JNI no es espec√≠fica de Android, pero est√° disponible de manera m√°s general para aplicaciones de Java que se ejecutan en diferentes plataformas.

El Kit de Desarrollo Nativo de Android (NDK) es el conjunto de herramientas espec√≠fico de Android en la parte superior de JNI. Seg√∫n la [documentaci√≥n](https://developer.android.com/ndk/guides):

> En Android, el Kit de Desarrollo Nativo (NDK) es un conjunto de herramientas que permite a los desarrolladores escribir c√≥digo C y C++ para sus aplicaciones de Android.

Juntos, JNI y NDK permiten a los desarrolladores de Android implementar parte de la funcionalidad de su aplicaci√≥n en c√≥digo nativo. El c√≥digo Java (o Kotlin) llamar√° a un m√©todo nativo declarado en Java que est√° implementado en la biblioteca nativa compilada.

### Referencias <a href="references" id="references"></a>

**Documentaci√≥n de Oracle JNI**

* [Especificaci√≥n JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)
* [Funciones JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html) <‚Äì Siempre tengo esta abierta y me refiero a ella mientras revierto bibliotecas nativas de Android

**Referencias de JNI y NDK de Android**

* [Consejos de JNI de Android](https://developer.android.com/training/articles/perf-jni) <‚Äì Recomiendo leer la secci√≥n "Bibliotecas nativas" para empezar
* [Introducci√≥n al NDK](https://developer.android.com/ndk/guides/) <‚Äì Esta es una gu√≠a para que los desarrolladores desarrollen bibliotecas nativas y entender c√≥mo se construyen las cosas, lo que hace que sea m√°s f√°cil revertir.

## Objetivo de an√°lisis - Bibliotecas nativas de Android <a href="target-of-analysis---android-native-libraries" id="target-of-analysis---android-native-libraries"></a>

Para esta secci√≥n, nos enfocamos en c√≥mo revertir la funcionalidad de la aplicaci√≥n que se ha implementado en bibliotecas nativas de Android. Cuando decimos bibliotecas nativas de Android, ¬øa qu√© nos referimos?

Las bibliotecas nativas de Android se incluyen en los APK como bibliotecas de objetos compartidos `.so`, en el formato de archivo ELF. Si has analizado binarios de Linux anteriormente, es el mismo formato.

Estas bibliotecas por defecto se incluyen en el APK en la ruta de archivo `/lib/<cpu>/lib<name>.so`. Esta es la ruta predeterminada, pero los desarrolladores tambi√©n podr√≠an elegir incluir la biblioteca nativa en `/assets/<custom_name>` si as√≠ lo desean. Con mayor frecuencia, estamos viendo que los desarrolladores de malware eligen incluir bibliotecas nativas en rutas distintas a `/lib` y usando diferentes extensiones de archivo para intentar "ocultar" la presencia de la biblioteca nativa.

Debido a que el c√≥digo nativo se compila para CPUs espec√≠ficas, si un desarrollador quiere que su aplicaci√≥n se ejecute en m√°s de un tipo de hardware, debe incluir cada una de esas versiones de la biblioteca nativa compilada en la aplicaci√≥n. La ruta predeterminada mencionada anteriormente incluye un directorio para cada tipo de CPU oficialmente compatible con Android.

| CPU                  | Ruta de la biblioteca nativa          |
| -------------------- | ---------------------------- |
| ARM gen√©rico de 32 bits | `lib/armeabi/libcalc.so`     |
| x86                  | `lib/x86/libcalc.so`         |
| x64                  | `lib/x86_64/libcalc.so`      |
| ARMv7                | `lib/armeabi-v7a/libcalc.so` |
| ARM64                | `lib/arm64-v8a/libcalc.so`   |

## Cargando la biblioteca <a href="loading-the-library" id="loading-the-library"></a>

Antes de que una aplicaci√≥n de Android pueda llamar y ejecutar cualquier c√≥digo que se implemente en una biblioteca nativa, la aplicaci√≥n (c√≥digo Java) debe cargar la biblioteca en memoria. Hay dos llamadas de API diferentes que har√°n esto:
```
System.loadLibrary("calc")
```
El siguiente contenido es de un libro de hacking sobre t√©cnicas de hacking de plataformas en la nube, SaaS, CI/CD... El contenido siguiente es del archivo /hive/hacktricks/mobile-pentesting/android-app-pentesting/reversing-native-libraries.md. Traduzca el texto relevante al espa√±ol y devuelva la traducci√≥n manteniendo la sintaxis de markdown. No traduzca cosas como c√≥digo, nombres de t√©cnicas de hacking, nombres de plataformas en la nube/SaaS (como Workspace, aws, gcp...), la palabra 'leak' y las etiquetas de markdown. Adem√°s, no agregue nada aparte de la traducci√≥n y la sintaxis de markdown.
```
System.load("lib/armeabi/libcalc.so")
```
La diferencia entre las dos llamadas de API es que `loadLibrary` solo toma el nombre corto de la biblioteca como argumento (es decir, libcalc.so = "calc" y libinit.so = "init") y el sistema determinar√° correctamente la arquitectura en la que se est√° ejecutando y, por lo tanto, el archivo correcto a utilizar. Por otro lado, `load` requiere la ruta completa de la biblioteca. Esto significa que el desarrollador de la aplicaci√≥n debe determinar la arquitectura y, por lo tanto, el archivo de biblioteca correcto para cargar.

Cuando se llama a cualquiera de estos dos API (`loadLibrary` o `load`) desde el c√≥digo Java, la biblioteca nativa que se pasa como argumento ejecuta su `JNI_OnLoad` si se implement√≥ en la biblioteca nativa.

Para reiterar, antes de ejecutar cualquier m√©todo nativo, la biblioteca nativa debe cargarse llamando a `System.loadLibrary` o `System.load` en el c√≥digo Java. Cuando se ejecuta cualquiera de estas 2 API, tambi√©n se ejecuta la funci√≥n `JNI_OnLoad` en la biblioteca nativa.

## La conexi√≥n de c√≥digo Java a c√≥digo nativo <a href="the-java-to-native-code-connection" id="the-java-to-native-code-connection"></a>

Para ejecutar una funci√≥n de la biblioteca nativa, debe haber un m√©todo nativo declarado en Java que el c√≥digo Java pueda llamar. Cuando se llama a este m√©todo nativo declarado en Java, se ejecuta la funci√≥n "asociada" de la biblioteca nativa (ELF/.so).

Un m√©todo nativo declarado en Java aparece en el c√≥digo Java como se muestra a continuaci√≥n. Aparece como cualquier otro m√©todo de Java, excepto que incluye la palabra clave `native` y no tiene c√≥digo en su implementaci√≥n, porque su c√≥digo est√° en realidad en la biblioteca nativa compilada.
```
public native String doThingsInNativeLibrary(int var0);
```
Para llamar a este m√©todo nativo, el c√≥digo Java lo llamar√≠a como cualquier otro m√©todo Java. Sin embargo, en el backend, JNI y NDK ejecutar√≠an en su lugar la funci√≥n correspondiente en la biblioteca nativa. Para hacer esto, debe conocer la asociaci√≥n entre un m√©todo nativo declarado en Java con una funci√≥n en la biblioteca nativa.

Existen 2 formas diferentes de hacer esta asociaci√≥n o enlace:

1. Enlace din√°mico utilizando la resoluci√≥n de nombres de m√©todo nativo JNI, o
2. Enlace est√°tico utilizando la llamada de API `RegisterNatives`

### Enlace din√°mico <a href="dynamic-linking" id="dynamic-linking"></a>

Para enlazar o asociar din√°micamente el m√©todo nativo declarado en Java y la funci√≥n en la biblioteca nativa, el desarrollador nombra el m√©todo y la funci√≥n de acuerdo con las especificaciones para que el sistema JNI pueda hacer la vinculaci√≥n din√°mica.

Seg√∫n las especificaciones, el desarrollador nombrar√≠a la funci√≥n de la siguiente manera para que el sistema pueda vincular din√°micamente el m√©todo nativo y la funci√≥n. Un nombre de m√©todo nativo se concatena a partir de los siguientes componentes:

1. el prefijo Java\_
2. un nombre de clase completo mangleado
3. un separador de gui√≥n bajo (‚Äú\_‚Äù)
4. un nombre de m√©todo mangleado
5. para m√©todos nativos sobrecargados, dos guiones bajos (‚Äú\__‚Äù) seguidos de la firma de argumento mangleada

Para hacer el enlace din√°mico para el m√©todo nativo declarado en Java a continuaci√≥n y digamos que est√° en la clase `com.android.interesting.Stuff`
```
public native String doThingsInNativeLibrary(int var0);
```
La funci√≥n en la biblioteca nativa deber√≠a tener el nombre:
```
Java_com_android_interesting_Stuff_doThingsInNativeLibrary
```
Si no hay una funci√≥n en la biblioteca nativa con ese nombre, eso significa que la aplicaci√≥n debe estar haciendo enlace est√°tico.

### Enlace est√°tico <a href="static-linking" id="static-linking"></a>

Si el desarrollador no quiere o no puede nombrar las funciones nativas de acuerdo con la especificaci√≥n (por ejemplo, quiere eliminar los s√≠mbolos de depuraci√≥n), entonces debe usar el enlace est√°tico con la API `RegisterNatives` ([doc](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp5833)) para hacer la asociaci√≥n entre el m√©todo nativo declarado en Java y la funci√≥n en la biblioteca nativa. La funci√≥n `RegisterNatives` se llama desde el c√≥digo nativo, no desde el c√≥digo Java, y se llama con mayor frecuencia en la funci√≥n `JNI_OnLoad`, ya que `RegisterNatives` debe ejecutarse antes de llamar al m√©todo nativo declarado en Java.
```
jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);

typedef struct { 
    char *name; 
    char *signature; 
    void *fnPtr; 
} JNINativeMethod;
```
Cuando se realiza ingenier√≠a inversa, si la aplicaci√≥n utiliza el m√©todo de enlace est√°tico, nosotros como analistas podemos encontrar la estructura `JNINativeMethod` que se est√° pasando a `RegisterNatives` para determinar qu√© subrutina en la biblioteca nativa se ejecuta cuando se llama al m√©todo nativo declarado en Java.

La estructura `JNINativeMethod` requiere una cadena con el nombre del m√©todo nativo declarado en Java y una cadena con la firma del m√©todo, por lo que deber√≠amos poder encontrar estas en nuestra biblioteca nativa.

**Firma del M√©todo**

La estructura `JNINativeMethod` requiere la firma del m√©todo. Una firma del m√©todo indica los tipos de los argumentos que toma el m√©todo y el tipo de lo que devuelve. Este enlace documenta [Firmas de Tipo JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html) en la secci√≥n "Firmas de Tipo".

* Z: booleano
* B: byte
* C: char
* S: short
* I: int
* J: long
* F: flotante
* D: doble
* L fully-qualified-class ; :clase completamente calificada
* \[ type: type\[]: tipo de matriz
* ( arg-types ) ret-type: tipo de m√©todo
* V: vac√≠o

Para el m√©todo nativo.
```
public native String doThingsInNativeLibrary(int var0);
```
La firma de tipo es
```
(I)Ljava/lang/String;
```
Aqu√≠ hay otro ejemplo de un m√©todo nativo y su firma. Para lo siguiente es la declaraci√≥n del m√©todo.
```
public native long f (int n, String s, int[] arr); 
```
Tiene la firma de tipo:
```
(ILjava/lang/String;[I)J
```
### Ejercicio #5 - Encontrar la direcci√≥n de la funci√≥n nativa <a href="exercise-5---find-the-address-of-the-native-function" id="exercise-5---find-the-address-of-the-native-function"></a>

En el Ejercicio #5 vamos a aprender a cargar bibliotecas nativas en un desensamblador e identificar la funci√≥n nativa que se ejecuta cuando se llama a un m√©todo nativo. Para este ejercicio en particular, el objetivo no es ingenier√≠a inversa del m√©todo nativo, solo encontrar el enlace entre la llamada al m√©todo nativo en Java y la funci√≥n que se ejecuta en la biblioteca nativa. Para este ejercicio, usaremos la muestra Mediacode.apk. Esta muestra est√° disponible en `~/samples/Mediacode.apk` en la VM. Su hash SHA256 es a496b36cda66aaf24340941da8034bd53940d1b08d83a97f17a65ae144ebf91a.

**Objetivo**

El objetivo de este ejercicio es:

1. Identificar los m√©todos nativos declarados en el bytecode DEX
2. Determinar qu√© bibliotecas nativas se cargan (y, por lo tanto, d√≥nde se pueden implementar los m√©todos nativos)
3. Extraer la biblioteca nativa del APK
4. Cargar la biblioteca nativa en un desensamblador
5. Identificar la direcci√≥n (o nombre) de la funci√≥n en la biblioteca nativa que se ejecuta cuando se llama al m√©todo nativo

**Instrucciones**

1. Abra Mediacode.apk en jadx. Consulte el [Ejercicio #1](https://maddiestone.github.io/AndroidAppRE/reversing_intro.html#exercise-1---beginning-re-with-jadx) para obtener m√°s informaci√≥n.
2. Esta vez, si expande la pesta√±a Recursos, ver√° que este APK tiene un directorio `lib/`. Las bibliotecas nativas para este APK est√°n en las rutas de CPU predeterminadas.
3. Ahora necesitamos identificar cualquier m√©todo nativo declarado. En jadx, busque y liste todos los m√©todos nativos declarados. Deber√≠a haber dos.
4. Alrededor del m√©todo nativo declarado, vea si hay alg√∫n lugar donde se cargue una biblioteca nativa. Esto proporcionar√° orientaci√≥n sobre en qu√© biblioteca nativa buscar la funci√≥n a implementar.
5. Extraiga la biblioteca nativa del APK creando un nuevo directorio y copiando el APK en esa carpeta. Luego ejecute el comando `unzip Mediacode.APK`. Ver√° todos los archivos extra√≠dos del APK, que incluyen el directorio `lib/`.
6. Seleccione la arquitectura de la biblioteca nativa que desea analizar.
7. Inicie ghidra ejecutando `ghidraRun`. Esto abrir√° Ghidra.
8. Para abrir la biblioteca nativa para su an√°lisis, seleccione "Nuevo proyecto", "Proyecto no compartido", seleccione una ruta para guardar el proyecto y as√≠gnele un nombre. Esto crea un proyecto en el que puede cargar archivos binarios.
9. Una vez que haya creado su proyecto, seleccione el icono del drag√≥n para abrir el navegador de c√≥digo. Vaya a "Archivo" > "Importar archivo" para cargar la biblioteca nativa en la herramienta. Puede dejar todos los valores predeterminados.
10. Ver√° la siguiente pantalla. Seleccione "Analizar".
11. Usando la informaci√≥n de enlace anterior, identifique la funci√≥n en la biblioteca nativa que se ejecuta cuando se llama al m√©todo nativo declarado en Java.

![Cargando archivo en el navegador de c√≥digo Ghidra](https://maddiestone.github.io/AndroidAppRE/images/loadingIntoGhidra.png)

![Captura de pantalla de Mediacode abierta en jadx](https://maddiestone.github.io/AndroidAppRE/images/Mediacode.InJadx.png)

**Soluci√≥n**

## Reversi√≥n de c√≥digo de bibliotecas nativas de Android - JNIEnv <a href="reversing-android-native-libraries-code---jnienv" id="reversing-android-native-libraries-code---jnienv"></a>

Al comenzar a realizar ingenier√≠a inversa de bibliotecas nativas de Android, una de las cosas que no sab√≠a que necesitaba saber era sobre `JNIEnv`. `JNIEnv` es una estructura de punteros de funci√≥n a [Funciones JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html). Cada funci√≥n JNI en bibliotecas nativas de Android toma `JNIEnv*` como primer argumento.

Desde la documentaci√≥n de Android [JNI Tips](https://developer.android.com/training/articles/perf-jni):

> Las declaraciones C de JNIEnv y JavaVM son diferentes de las declaraciones C++. El archivo de inclusi√≥n "jni.h" proporciona diferentes typedefs dependiendo de si se incluye en C o C++. Por esta raz√≥n, es una mala idea incluir argumentos JNIEnv en archivos de encabezado incluidos por ambos idiomas. (Dicho de otra manera: si su archivo de encabezado requiere #ifdef \__cplusplus, es posible que deba hacer un trabajo adicional
