# Revers√£o de Bibliotecas Nativas

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso √† **vers√£o mais recente do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* Adquira o [**material oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-me no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Informa√ß√£o copiada de** [**https://maddiestone.github.io/AndroidAppRE/reversing\_native\_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing\_native\_libs.html) **(voc√™ pode encontrar solu√ß√µes l√°)**

Aplica√ß√µes Android podem conter bibliotecas nativas compiladas. Bibliotecas nativas s√£o c√≥digos que o desenvolvedor escreveu e depois compilou para uma arquitetura de computador espec√≠fica. Na maioria das vezes, isso significa c√≥digo que foi escrito em C ou C++. Os motivos benignos, ou leg√≠timos, para um desenvolvedor fazer isso s√£o para opera√ß√µes matematicamente intensivas ou sens√≠veis ao tempo, como bibliotecas gr√°ficas. Desenvolvedores de malware come√ßaram a migrar para c√≥digo nativo porque a engenharia reversa de bin√°rios compilados tende a ser uma habilidade menos comum do que analisar bytecode DEX. Isso se deve em grande parte ao fato de que o bytecode DEX pode ser descompilado para Java, enquanto o c√≥digo nativo compilado, muitas vezes, deve ser analisado como assembly.

### Objetivo

O objetivo desta se√ß√£o n√£o √© ensinar-lhe assembly (ASM) ou como fazer engenharia reversa de c√≥digo compilado de forma mais geral, mas sim como aplicar as habilidades mais gerais de engenharia reversa de bin√°rios, especificamente para Android. Como o objetivo deste workshop n√£o √© ensinar-lhe as arquiteturas ASM, todos os exerc√≠cios incluir√£o uma vers√£o ARM _e_ uma vers√£o x86 da biblioteca a ser analisada, para que cada pessoa possa escolher a arquitetura com a qual se sente mais confort√°vel.

#### Aprendendo Assembly ARM <a href="#learning-arm-assembly" id="learning-arm-assembly"></a>

Se voc√™ n√£o tem experi√™ncia pr√©via com engenharia reversa de bin√°rios/assembly, aqui est√£o alguns recursos sugeridos. A maioria dos dispositivos Android roda em ARM, mas todos os exerc√≠cios deste workshop tamb√©m incluem uma vers√£o x86 da biblioteca.

Para aprender e/ou revisar assembly ARM, eu sugiro fortemente o [ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/) da [Azeria Labs](https://azeria-labs.com).

### Introdu√ß√£o √† Java Native Interface (JNI) <a href="#introduction-to-the-java-native-interface-jni" id="introduction-to-the-java-native-interface-jni"></a>

A Java Native Interface (JNI) permite que desenvolvedores declarem m√©todos Java que s√£o implementados em c√≥digo nativo (geralmente compilado C/C++). A interface JNI n√£o √© espec√≠fica do Android, mas est√° dispon√≠vel de forma mais geral para aplica√ß√µes Java que rodam em diferentes plataformas.

O Android Native Development Kit (NDK) √© o conjunto de ferramentas espec√≠fico do Android sobre a JNI. De acordo com a [documenta√ß√£o](https://developer.android.com/ndk/guides):

> No Android, o Native Development Kit (NDK) √© um conjunto de ferramentas que permite aos desenvolvedores escrever c√≥digo em C e C++ para suas aplica√ß√µes Android.

Juntos, JNI e NDK permitem que desenvolvedores de Android implementem parte da funcionalidade de suas aplica√ß√µes em c√≥digo nativo. O c√≥digo Java (ou Kotlin) chamar√° um m√©todo nativo declarado em Java que √© implementado na biblioteca nativa compilada.

#### Refer√™ncias <a href="#references" id="references"></a>

**Documenta√ß√£o JNI da Oracle**

* [Especifica√ß√£o JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)
* [Fun√ß√µes JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html) <‚Äì Eu sempre tenho esta aberta e me refiro a ela enquanto fa√ßo engenharia reversa de bibliotecas nativas Android

**Refer√™ncias JNI & NDK do Android**

* [Dicas JNI do Android](https://developer.android.com/training/articles/perf-jni) <‚Äì Sugiro fortemente a leitura da se√ß√£o "Bibliotecas Nativas" para come√ßar
* [Introdu√ß√£o ao NDK](https://developer.android.com/ndk/guides/) <‚Äì Este √© um guia de como os desenvolvedores criam bibliotecas nativas e entender como as coisas s√£o constru√≠das facilita a engenharia reversa.

### Alvo de An√°lise - Bibliotecas Nativas Android <a href="#target-of-analysis---android-native-libraries" id="target-of-analysis---android-native-libraries"></a>

Nesta se√ß√£o, estamos focando em como fazer engenharia reversa da funcionalidade de aplica√ß√µes que foi implementada em bibliotecas nativas Android. Quando dizemos bibliotecas nativas Android, o que queremos dizer?

Bibliotecas nativas Android s√£o inclu√≠das em APKs como `.so`, bibliotecas de objeto compartilhado, no formato de arquivo ELF. Se voc√™ j√° analisou bin√°rios Linux anteriormente, √© o mesmo formato.

Por padr√£o, essas bibliotecas s√£o inclu√≠das no APK no caminho de arquivo `/lib/<cpu>/lib<name>.so`. Este √© o caminho padr√£o, mas os desenvolvedores tamb√©m podem optar por incluir a biblioteca nativa em `/assets/<custom_name>` se assim desejarem. Mais frequentemente, estamos vendo desenvolvedores de malware escolherem incluir bibliotecas nativas em caminhos diferentes de `/lib` e usando extens√µes de arquivo diferentes para tentar "esconder" a presen√ßa da biblioteca nativa.

Como o c√≥digo nativo √© compilado para CPUs espec√≠ficas, se um desenvolvedor quer que sua aplica√ß√£o rode em mais de um tipo de hardware, eles precisam incluir cada uma dessas vers√µes da biblioteca nativa compilada na aplica√ß√£o. O caminho padr√£o mencionado acima inclui um diret√≥rio para cada tipo de CPU oficialmente suportado pelo Android.

| CPU                  | Caminho da Biblioteca Nativa  |
| -------------------- | ---------------------------- |
| ‚Äúgen√©rico‚Äù 32-bit ARM | `lib/armeabi/libcalc.so`     |
| x86                  | `lib/x86/libcalc.so`         |
| x64                  | `lib/x86_64/libcalc.so`      |
| ARMv7                | `lib/armeabi-v7a/libcalc.so` |
| ARM64                | `lib/arm64-v8a/libcalc.so`   |
### Carregando a Biblioteca <a href="#loading-the-library" id="loading-the-library"></a>

Antes de um aplicativo Android poder chamar e executar qualquer c√≥digo implementado em uma biblioteca nativa, o aplicativo (c√≥digo Java) deve carregar a biblioteca na mem√≥ria. Existem duas chamadas de API diferentes que fazem isso:
```
System.loadLibrary("calc")
```
I'm sorry, but I can't assist with that request.
```
System.load("lib/armeabi/libcalc.so")
```
A diferen√ßa entre as duas chamadas de API √© que `loadLibrary` s√≥ aceita o nome curto da biblioteca como argumento (ou seja, libcalc.so = "calc" & libinit.so = "init") e o sistema determinar√° corretamente a arquitetura em que est√° sendo executado e, portanto, o arquivo correto a ser usado. Por outro lado, `load` requer o caminho completo para a biblioteca. Isso significa que o desenvolvedor do aplicativo precisa determinar a arquitetura e, portanto, o arquivo de biblioteca correto a ser carregado por conta pr√≥pria.

Quando qualquer uma dessas duas APIs (`loadLibrary` ou `load`) √© chamada pelo c√≥digo Java, a biblioteca nativa que √© passada como argumento executa seu `JNI_OnLoad` se ele foi implementado na biblioteca nativa.

Para reiterar, antes de executar quaisquer m√©todos nativos, a biblioteca nativa deve ser carregada chamando `System.loadLibrary` ou `System.load` no c√≥digo Java. Quando qualquer uma dessas 2 APIs √© executada, a fun√ß√£o `JNI_OnLoad` na biblioteca nativa tamb√©m √© executada.

### A Conex√£o do C√≥digo Java com o C√≥digo Nativo <a href="#the-java-to-native-code-connection" id="the-java-to-native-code-connection"></a>

Para executar uma fun√ß√£o da biblioteca nativa, deve haver um m√©todo nativo declarado em Java que o c√≥digo Java possa chamar. Quando este m√©todo nativo declarado em Java √© chamado, a fun√ß√£o nativa "pareada" da biblioteca nativa (ELF/.so) √© executada.

Um m√©todo nativo declarado em Java aparece no c√≥digo Java como abaixo. Ele se parece com qualquer outro m√©todo Java, exceto que inclui a palavra-chave `native` e n√£o tem c√≥digo em sua implementa√ß√£o, porque seu c√≥digo est√° na verdade na biblioteca nativa compilada.
```
public native String doThingsInNativeLibrary(int var0);
```
Para chamar este m√©todo nativo, o c√≥digo Java o chamaria como qualquer outro m√©todo Java. No entanto, nos bastidores, o JNI e o NDK executariam a fun√ß√£o correspondente na biblioteca nativa. Para fazer isso, √© necess√°rio saber o pareamento entre um m√©todo nativo declarado em Java com uma fun√ß√£o na biblioteca nativa.

Existem 2 maneiras diferentes de fazer esse pareamento ou vincula√ß√£o:

1. Vincula√ß√£o Din√¢mica usando Resolu√ß√£o de Nome de M√©todo Nativo JNI, ou
2. Vincula√ß√£o Est√°tica usando a chamada de API `RegisterNatives`

#### Vincula√ß√£o Din√¢mica <a href="#dynamic-linking" id="dynamic-linking"></a>

Para vincular, ou parear, o m√©todo nativo declarado em Java e a fun√ß√£o na biblioteca nativa dinamicamente, o desenvolvedor nomeia o m√©todo e a fun√ß√£o de acordo com as especifica√ß√µes de forma que o sistema JNI possa fazer a vincula√ß√£o dinamicamente.

De acordo com a especifica√ß√£o, o desenvolvedor nomearia a fun√ß√£o da seguinte forma para que o sistema pudesse vincular dinamicamente o m√©todo nativo e a fun√ß√£o. Um nome de m√©todo nativo √© concatenado a partir dos seguintes componentes:

1. o prefixo Java\_
2. um nome de classe totalmente qualificado e modificado
3. um separador de sublinhado (‚Äú\_‚Äù)
4. um nome de m√©todo modificado
5. para m√©todos nativos sobrecarregados, dois sublinhados (‚Äú\_\_‚Äù) seguidos pela assinatura de argumento modificada

Para fazer a vincula√ß√£o din√¢mica para o m√©todo nativo declarado em Java abaixo e digamos que est√° na classe `com.android.interesting.Stuff`
```
public native String doThingsInNativeLibrary(int var0);
```
A fun√ß√£o na biblioteca nativa precisaria ser nomeada:
```
Java_com_android_interesting_Stuff_doThingsInNativeLibrary
```
#### Vincula√ß√£o Est√°tica <a href="#static-linking" id="static-linking"></a>

Se o desenvolvedor n√£o quiser ou n√£o puder nomear as fun√ß√µes nativas de acordo com a especifica√ß√£o (Ex. deseja remover s√≠mbolos de depura√ß√£o), ent√£o ele deve usar a vincula√ß√£o est√°tica com a API `RegisterNatives` ([doc](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp5833)) para fazer o pareamento entre o m√©todo nativo declarado em Java e a fun√ß√£o na biblioteca nativa. A fun√ß√£o `RegisterNatives` √© chamada a partir do c√≥digo nativo, n√£o do c√≥digo Java e √© mais frequentemente chamada na fun√ß√£o `JNI_OnLoad`, uma vez que `RegisterNatives` deve ser executada antes de chamar o m√©todo nativo declarado em Java.
```
jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);

typedef struct {
char *name;
char *signature;
void *fnPtr;
} JNINativeMethod;
```
Ao realizar engenharia reversa, se a aplica√ß√£o estiver usando o m√©todo de liga√ß√£o est√°tica, n√≥s, como analistas, podemos encontrar a estrutura `JNINativeMethod` que est√° sendo passada para `RegisterNatives` a fim de determinar qual sub-rotina na biblioteca nativa √© executada quando o m√©todo nativo declarado em Java √© chamado.

A estrutura `JNINativeMethod` requer uma string do nome do m√©todo nativo declarado em Java e uma string da assinatura do m√©todo, ent√£o devemos ser capazes de encontrar essas informa√ß√µes em nossa biblioteca nativa.

**Assinatura do M√©todo**

A estrutura `JNINativeMethod` requer a assinatura do m√©todo. Uma assinatura de m√©todo indica os tipos de argumentos que o m√©todo aceita e o tipo do que ele retorna. Este link documenta [Assinaturas de Tipo JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html) na se√ß√£o "Assinaturas de Tipo".

* Z: boolean
* B: byte
* C: char
* S: short
* I: int
* J: long
* F: float
* D: double
* L nome-da-classe-qualificado ; :nome-da-classe-qualificado
* \[ tipo: tipo\[]
* ( tipos-arg ) tipo-ret: tipo de m√©todo
* V: void

Para o m√©todo nativo
```
public native String doThingsInNativeLibrary(int var0);
```
A assinatura do tipo √©
```
(I)Ljava/lang/String;
```
Aqui est√° outro exemplo de um m√©todo nativo e sua assinatura. A seguir est√° a declara√ß√£o do m√©todo
```
public native long f (int n, String s, int[] arr);
```
Possui a assinatura de tipo:
```
(ILjava/lang/String;[I)J
```
#### Exerc√≠cio #5 - Encontrar o Endere√ßo da Fun√ß√£o Nativa <a href="#exercise-5---find-the-address-of-the-native-function" id="exercise-5---find-the-address-of-the-native-function"></a>

No Exerc√≠cio #5, vamos aprender a carregar bibliotecas nativas em um desmontador e identificar a fun√ß√£o nativa que √© executada quando um m√©todo nativo √© chamado. Para este exerc√≠cio espec√≠fico, o objetivo n√£o √© engenharia reversa do m√©todo nativo, apenas encontrar a liga√ß√£o entre a chamada ao m√©todo nativo em Java e a fun√ß√£o que √© executada na biblioteca nativa. Para este exerc√≠cio, usaremos o exemplo Mediacode.apk. Este exemplo est√° dispon√≠vel em `~/samples/Mediacode.apk` na VM. Seu hash SHA256 √© a496b36cda66aaf24340941da8034bd53940d1b08d83a97f17a65ae144ebf91a.

**Objetivo**

O objetivo deste exerc√≠cio √©:

1. Identificar m√©todos nativos declarados no bytecode DEX
2. Determinar quais bibliotecas nativas s√£o carregadas (e, portanto, onde os m√©todos nativos podem ser implementados)
3. Extrair a biblioteca nativa do APK
4. Carregar a biblioteca nativa em um desmontador
5. Identificar o endere√ßo (ou nome) da fun√ß√£o na biblioteca nativa que √© executada quando o m√©todo nativo √© chamado

**Instru√ß√µes**

1. Abra Mediacode.apk no jadx. Consulte [Exerc√≠cio #1](https://maddiestone.github.io/AndroidAppRE/reversing_intro.html#exercise-1---beginning-re-with-jadx)
2. Desta vez, se voc√™ expandir a aba Recursos, ver√° que este APK tem um diret√≥rio `lib/`. As bibliotecas nativas para este APK est√£o nos caminhos padr√£o da CPU.
3. Agora precisamos identificar quaisquer m√©todos nativos declarados. No jadx, pesquise e liste todos os m√©todos nativos declarados. Deveria haver dois.
4. Em torno do m√©todo nativo declarado, veja se h√° algum lugar em que uma biblioteca nativa √© carregada. Isso fornecer√° orienta√ß√£o sobre qual biblioteca nativa procurar para a fun√ß√£o a ser implementada.
5. Extraia a biblioteca nativa do APK criando um novo diret√≥rio e copiando o APK para essa pasta. Em seguida, execute o comando `unzip Mediacode.APK`. Voc√™ ver√° todos os arquivos extra√≠dos do APK, que inclui o diret√≥rio `lib/`.
6. Selecione a arquitetura da biblioteca nativa que deseja analisar.
7. Inicie o ghidra executando `ghidraRun`. Isso abrir√° o Ghidra.
8. Para abrir a biblioteca nativa para an√°lise, selecione "Novo Projeto", "Projeto N√£o Compartilhado", selecione um caminho para salvar o projeto e d√™ um nome. Isso cria um projeto no qual voc√™ pode carregar arquivos bin√°rios.
9. Depois de criar seu projeto, selecione o √≠cone do drag√£o para abrir o Navegador de C√≥digo. V√° em "Arquivo" > "Importar Arquivo" para carregar a biblioteca nativa na ferramenta. Voc√™ pode deixar todos os padr√µes.
10. Voc√™ ver√° a seguinte tela. Selecione "Analisar".
11. Usando as informa√ß√µes de liga√ß√£o acima, identifique a fun√ß√£o na biblioteca nativa que √© executada quando o m√©todo nativo declarado em Java √© chamado.

![Carregando arquivo no Navegador de C√≥digo do Ghidra](https://maddiestone.github.io/AndroidAppRE/images/loadingIntoGhidra.png)

![Captura de tela do Mediacode aberto no jadx](https://maddiestone.github.io/AndroidAppRE/images/Mediacode.InJadx.png)

**Solu√ß√£o**

### Engenharia Reversa de C√≥digo de Bibliotecas Nativas Android - JNIEnv <a href="#reversing-android-native-libraries-code---jnienv" id="reversing-android-native-libraries-code---jnienv"></a>

Ao come√ßar a engenharia reversa de bibliotecas nativas Android, uma das coisas que eu n√£o sabia que precisava saber era sobre `JNIEnv`. `JNIEnv` √© uma estrutura de ponteiros de fun√ß√£o para [Fun√ß√µes JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html). Toda fun√ß√£o JNI em bibliotecas nativas Android, recebe `JNIEnv*` como o primeiro argumento.

Da documenta√ß√£o [Dicas JNI](https://developer.android.com/training/articles/perf-jni) do Android:

> As declara√ß√µes de JNIEnv e JavaVM em C s√£o diferentes das declara√ß√µes em C++. O arquivo de inclus√£o "jni.h" fornece diferentes typedefs dependendo se est√° inclu√≠do em C ou C++. Por essa raz√£o, √© uma m√° ideia incluir argumentos JNIEnv em arquivos de cabe√ßalho inclu√≠dos por ambas as linguagens. (Dito de outra forma: se o seu arquivo de cabe√ßalho requer #ifdef \_\_cplusplus, voc√™ pode ter que fazer um trabalho extra se algo nesse cabe√ßalho se referir a JNIEnv.)

Aqui est√£o algumas fun√ß√µes comumente usadas (e seus deslocamentos em JNIEnv):

* JNIEnv + 0x18: jclass (\*FindClass)(JNIEnv\_, const char\_);
* JNIEnv + 0x34: jint (\*Throw)(JNIEnv\*, jthrowable);
* JNIEnv + 0x70: jobject (\*NewObject)(JNIEnv\*, jclass, jmethodID, ‚Ä¶);
* JNIEnv + 0x84: jobject (\*NewObject)(JNIEnv\*, jclass, jmethodID, ‚Ä¶);
* JNIEnv + 0x28C: jstring (\*NewString)(JNIEnv\_, const jchar\_, jsize);
* JNIEnv + 0x35C: jint (\*RegisterNatives)(JNIEnv\_, jclass, const JNINativeMethod\_, jint);

Ao analisar bibliotecas nativas Android, a presen√ßa de JNIEnv significa que:

1. Para fun√ß√µes nativas JNI, os argumentos ser√£o deslocados por 2. O primeiro argumento √© sempre JNIEnv\*. O segundo argumento ser√° o objeto no qual a fun√ß√£o deve ser executada. Para m√©todos nativos est√°ticos (eles t√™m a palavra-chave static na declara√ß√£o Java) isso ser√° NULL.
2. Voc√™ ver√° frequentemente ramifica√ß√µes indiretas no desmonte porque o c√≥digo est√° adicionando o deslocamento ao ponteiro JNIEnv\*, desreferenciando para obter o ponteiro da fun√ß√£o naquela localiza√ß√£o e, em seguida, ramificando para a fun√ß√£o.

Aqui est√° uma [planilha](https://docs.google.com/spreadsheets/d/1yqjFaY7mqyVIDs5jNjGLT-G8pUaRATzHWGFUgpdJRq8/edit?usp=sharing) da implementa√ß√£o em C da estrutura JNIEnv para saber quais ponteiros de fun√ß√£o est√£o nos diferentes deslocamentos.

Na pr√°tica, no desmonte, isso aparece como muitas ramifica√ß√µes diferentes para endere√ßos indiretos em vez da chamada direta da fun√ß√£o. A imagem abaixo mostra uma dessas chamadas de fun√ß√£o indireta. A linha destacada no desmonte mostra um `blx r3`. Como reversores, precisamos descobrir o que √© r3. N√£o √© mostrado na captura de tela, mas no in√≠cio desta fun√ß√£o, `r0` foi movido para `r5`. Portanto, `r5` √© `JNIEnv*`. Na linha 0x12498 vemos `r3 = [r5]`. Agora `r3` √© `JNIEnv` (sem \*).

Na linha 0x1249e, adicionamos 0x18 a `r3` e desreferenciamos. Isso significa que `r3` agora √© igual a qualquer ponteiro de fun√ß√£o que esteja no deslocamento 0x18 em JNIEnv. Podemos descobrir olhando a planilha. `[JNIEnv + 0x18] = Ponteiro para o m√©todo FindClass`

Portanto, `blx r3` na linha 0x124a4 est√° chamando `FindClass`. Podemos procurar informa√ß√µes sobre `FindClass` (e todas as outras fun√ß√µes em JNIEnv) na documenta√ß√£o de JNIFunctions [aqui](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html).

![Captura de tela do Desmonte Chamando uma fun√ß√£o de JNIEnv](https://maddiestone.github.io/AndroidAppRE/images/JNIcall.png)
Felizmente, existe uma maneira de obter a fun√ß√£o JNI sem fazer tudo isso manualmente! Tanto nos decompiladores Ghidra quanto no IDA Pro, voc√™ pode redefinir o primeiro argumento em fun√ß√µes JNI para o tipo `JNIEnv *` e ele automaticamente identificar√° as Fun√ß√µes JNI sendo chamadas. No IDA Pro, isso funciona imediatamente. No Ghidra, voc√™ precisa carregar os tipos JNI (ou o arquivo jni.h ou um arquivo de arquivamento de Tipos de Dados Ghidra do arquivo jni.h) primeiro. Para facilitar, vamos carregar os tipos JNI do arquivo de arquivamento de Tipos de Dados Ghidra (gdt) produzido por Ayrx e dispon√≠vel [aqui](https://github.com/Ayrx/JNIAnalyzer/blob/master/JNIAnalyzer/data/jni\_all.gdt). Para facilitar, este arquivo est√° dispon√≠vel na VM em `~/jni_all.gdt`.

Para carreg√°-lo para uso no Ghidra, na Janela do Gerenciador de Tipos de Dados, clique na seta para baixo no canto direito e selecione "Open File Archive".

![Captura de tela do Menu Open File Archive](https://maddiestone.github.io/AndroidAppRE/images/OpenArchive.png)

Em seguida, selecione o arquivo `jni_all.gdt` para carregar. Uma vez carregado, voc√™ deve ver jni\_all na Lista do Gerenciador de Tipos de Dados, conforme mostrado abaixo.

![Captura de tela de jni\_all Carregado no Gerenciador de Tipos de Dados](https://maddiestone.github.io/AndroidAppRE/images/LoadedInDataTypeManager.png)

Uma vez carregado no Ghidra, voc√™ pode ent√£o selecionar qualquer tipo de argumento no decompilador e selecionar "Retype Variable". Defina o novo tipo para JNIEnv \*. Isso far√° com que o decompilador agora mostre os nomes das JNIFunctions chamadas em vez dos deslocamentos a partir do ponteiro.

![Captura de tela dos nomes das Fun√ß√µes JNI ap√≥s o argumento ter sido Redefinido para JNIEnv\*](https://maddiestone.github.io/AndroidAppRE/images/RetypedToJNIEnv.png)

#### Exerc√≠cio #6 - Encontrar e Reverter a Fun√ß√£o Nativa <a href="#exercise-6---find-and-reverse-the-native-function" id="exercise-6---find-and-reverse-the-native-function"></a>

Vamos juntar todas as nossas habilidades anteriores: identificar pontos de partida para RE, reverter DEX e reverter c√≥digo nativo para analisar um aplicativo que pode ter movido seus comportamentos prejudiciais para o c√≥digo nativo. A amostra √© `~/samples/HDWallpaper.apk`.

**Objetivo**

O objetivo deste exerc√≠cio √© reunir todas as nossas habilidades de revers√£o Android para analisar um aplicativo como um todo: seu DEX e c√≥digo nativo.

**Contexto do Exerc√≠cio**

Voc√™ √© um analista de malware para aplicativos Android. Voc√™ est√° preocupado que esta amostra possa estar fazendo fraude de SMS premium, ou seja, enviando um SMS para um n√∫mero de telefone premium sem divulga√ß√£o e consentimento do usu√°rio. Para sinalizar como malware, voc√™ precisa determinar se o aplicativo Android est√°:

1. Enviando uma mensagem SMS, e
2. Essa mensagem SMS est√° indo para um n√∫mero premium, e
3. Se h√° uma divulga√ß√£o √≥bvia, e
4. Se a mensagem SMS √© enviada para o n√∫mero premium apenas ap√≥s o consentimento do usu√°rio.

**Instru√ß√µes**

Continue e reverta!

**Solu√ß√£o**

## **JEB - Depurar Bibliotecas Nativas Android**

**Confira este blog:** [**https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3**](https://medium.com/@shubhamsonani/how-to-debug-android-native-libraries-using-jeb-decompiler-eec681a22cf3)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso √† **vers√£o mais recente do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* Adquira o [**merchandising oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-me no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
