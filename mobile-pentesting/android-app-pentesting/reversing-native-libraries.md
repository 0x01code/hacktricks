<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一家**网络安全公司**工作吗？想要在HackTricks中看到你的**公司广告**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[NFT](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获取[**官方PEASS和HackTricks的衣物**](https://peass.creator-spring.com)

- **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或者 [**电报群组**](https://t.me/peass) 或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>


**从**[**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)**复制的信息（你可以在那里找到解决方案）**

Android应用程序可以包含编译的本地库。本地库是开发人员编写并为特定计算机架构编译的代码。最常见的情况是使用C或C++编写的代码。开发人员之所以这样做的正当原因是进行数学密集型或时间敏感的操作，例如图形库。恶意软件开发人员开始使用本地代码，因为反向工程编译的二进制文件往往不如分析DEX字节码那样常见。这主要是因为DEX字节码可以反编译为Java，而本地编译的代码通常必须作为汇编代码进行分析。

## 目标

本节的目标不是教你汇编语言（ASM）或如何更一般地反向工程编译代码，而是如何将更一般的二进制反向工程技能应用于Android。因为本次研讨会的目标不是教你ASM架构，所以所有的练习都将包括要分析的库的ARM版本和x86版本，以便每个人都可以选择自己更熟悉的架构。

### 学习ARM汇编 <a href="learning-arm-assembly" id="learning-arm-assembly"></a>

如果你没有之前的二进制反向工程/汇编经验，这里有一些建议的资源。大多数Android设备都运行在ARM上，但是本研讨会中的所有练习都包括库的x86版本。

要学习和/或复习ARM汇编，我强烈推荐[Azeria Labs](https://azeria-labs.com)的[ARM汇编基础知识](https://azeria-labs.com/writing-arm-assembly-part-1/)。

## Java本地接口（JNI）简介 <a href="introduction-to-the-java-native-interface-jni" id="introduction-to-the-java-native-interface-jni"></a>

Java本地接口（JNI）允许开发人员声明在本地代码（通常是编译的C/C++代码）中实现的Java方法。JNI接口不是特定于Android的，而是更普遍地适用于在不同平台上运行的Java应用程序。

Android本地开发工具包（NDK）是JNI之上的Android特定工具集。根据[文档](https://developer.android.com/ndk/guides)：

> 在Android中，本地开发工具包（NDK）是一个工具集，允许开发人员为其Android应用程序编写C和C++代码。

JNI和NDK一起允许Android开发人员在本地代码中实现一些应用程序的功能。Java（或Kotlin）代码将调用在编译的本地库中实现的Java声明的本地方法。

### 参考资料 <a href="references" id="references"></a>

**Oracle JNI文档**

* [JNI规范](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)
* [JNI函数](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html) <– 我总是打开这个并在反向工程Android本地库时参考它

**Android JNI和NDK参考资料**

* [Android JNI技巧](https://developer.android.com/training/articles/perf-jni) <– 强烈建议阅读“本地库”部分以开始
* [入门NDK](https://developer.android.com/ndk/guides/) <– 这是开发人员开发本地库和理解构建过程的指导，这样更容易进行反向工程。

## 分析目标 - Android本地库 <a href="target-of-analysis---android-native-libraries" id="target-of-analysis---android-native-libraries"></a>

在本节中，我们重点介绍如何反向工程在Android本地库中实现的应用程序功能。当我们说Android本地库时，我们指的是什么？

Android本地库以ELF文件格式的`.so`共享对象库的形式包含在APK中。如果你之前分析过Linux二进制文件，那么它们的格式是相同的。

这些库默认情况下包含在APK的文件路径`/lib/<cpu>/lib<name>.so`中。这是默认路径，但开发人员也可以选择将本地库包含在`/assets/<custom_name>`中。更常见的是，我们看到恶意软件开发人员选择将本地库包含在`/lib`以外的路径，并使用不同的文件扩展名来试图“隐藏”本地库的存在。

由于本地代码是针对特定的CPU编译的，如果开发人员希望他们的应用程序在多种类型的硬件上运行，他们必须在应用程序中包含每个编译的本地库的版本。上面提到的默认路径包括了Android官方支持的每种CPU类型的目录。

| CPU                  | 本地库路径                    |
| -------------------- | ---------------------------- |
| “generic” 32位ARM    | `lib/armeabi/libcalc.so`     |
| x86                  | `lib/x86/libcalc.so`         |
| x64                  | `lib/x86_64/libcalc.so`      |
| ARMv7                | `lib/armeabi-v7a/libcalc.so` |
| ARM64                | `lib/arm64-v8a/libcalc.so`   |
## 加载库 <a href="loading-the-library" id="loading-the-library"></a>

在 Android 应用程序可以调用和执行任何在本地库中实现的代码之前，应用程序（Java 代码）必须将库加载到内存中。有两个不同的 API 调用可以完成这个操作：
```
System.loadLibrary("calc")
```
或者
```
System.load("lib/armeabi/libcalc.so")
```
两个API调用的区别在于`loadLibrary`只需要传入库的短名称作为参数（例如libcalc.so = “calc”和libinit.so = “init”），系统会正确确定当前运行的架构，从而使用正确的文件。另一方面，`load`需要传入库的完整路径。这意味着应用程序开发人员必须确定架构，从而加载正确的库文件。

当Java代码调用这两个（`loadLibrary`或`load`）API之一时，作为参数传递的本地库会执行其`JNI_OnLoad`函数（如果在本地库中实现了该函数）。

再次强调，在执行任何本地方法之前，必须通过在Java代码中调用`System.loadLibrary`或`System.load`来加载本地库。当执行这两个API之一时，本地库中的`JNI_OnLoad`函数也会被执行。

## Java与本地代码的连接 <a href="the-java-to-native-code-connection" id="the-java-to-native-code-connection"></a>

为了执行本地库中的函数，必须有一个Java声明的本地方法供Java代码调用。当调用这个Java声明的本地方法时，与之“配对”的本地库函数（ELF/.so）会被执行。

Java声明的本地方法在Java代码中的形式如下。它看起来像任何其他Java方法，只是包含了`native`关键字，并且在其实现中没有代码，因为它的代码实际上在编译后的本地库中。
```
public native String doThingsInNativeLibrary(int var0);
```
要调用这个本地方法，Java代码会像调用其他Java方法一样调用它。然而，在后台，JNI和NDK会执行本地库中相应的函数。为了做到这一点，它必须知道Java声明的本地方法与本地库中的函数之间的配对关系。

有两种不同的方法可以进行这种配对或链接：

1. 使用JNI本地方法名称解析进行动态链接，或
2. 使用`RegisterNatives` API调用进行静态链接

### 动态链接 <a href="dynamic-linking" id="dynamic-linking"></a>

为了动态地将Java声明的本地方法和本地库中的函数进行链接或配对，开发人员根据规范命名方法和函数，以便JNI系统可以动态地进行链接。

根据规范，开发人员将函数命名如下，以便系统能够动态链接本地方法和函数。本地方法名称由以下组件连接而成：

1. 前缀Java\_
2. 一个编码后的完全限定类名
3. 一个下划线（“\_”）分隔符
4. 一个编码后的方法名
5. 对于重载的本地方法，两个下划线（“\__”）后跟编码后的参数签名

为了对下面的Java声明的本地方法进行动态链接，假设它在类`com.android.interesting.Stuff`中。
```
public native String doThingsInNativeLibrary(int var0);
```
本地库中的函数需要命名为：
```
Java_com_android_interesting_Stuff_doThingsInNativeLibrary
```
如果原生库中没有这个名称的函数，那就意味着应用程序必须进行静态链接。

### 静态链接 <a href="static-linking" id="static-linking"></a>

如果开发人员不想或者不能按照规范命名原生函数（例如，想要剥离调试符号），那么他们必须使用`RegisterNatives`（[文档](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp5833)）API进行静态链接，以便在Java声明的原生方法和原生库中的函数之间进行配对。`RegisterNatives`函数是从原生代码中调用的，而不是从Java代码中调用的，通常在`JNI_OnLoad`函数中调用`RegisterNatives`，因为必须在调用Java声明的原生方法之前执行`RegisterNatives`。
```
jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);

typedef struct {
char *name;
char *signature;
void *fnPtr;
} JNINativeMethod;
```
当进行逆向工程时，如果应用程序使用静态链接方法，作为分析人员，我们可以找到传递给`RegisterNatives`的`JNINativeMethod`结构体，以确定在调用Java声明的本地方法时执行的本地库中的子程序。

`JNINativeMethod`结构体需要Java声明的本地方法名称的字符串和方法的签名的字符串，因此我们应该能够在我们的本地库中找到这些信息。

**方法签名**

`JNINativeMethod`结构体需要方法签名。方法签名指定方法接受的参数类型和返回类型的类型。此链接文档记录了[JNI类型签名](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html)在“类型签名”部分。

* Z: boolean
* B: byte
* C: char
* S: short
* I: int
* J: long
* F: float
* D: double
* L fully-qualified-class ; :fully-qualified-class
* \[ type: type\[]
* ( arg-types ) ret-type: method type
* V: void

对于本地方法
```
public native String doThingsInNativeLibrary(int var0);
```
类型签名是
```
(I)Ljava/lang/String;
```
以下是另一个本地方法及其签名的示例。以下是方法声明：

```java
public native String encryptData(String data, String key);
```

In this example, the native method is called `encryptData` and it takes two parameters: `data` of type `String` and `key` of type `String`. The return type of the method is also `String`. 

在这个例子中，本地方法被称为`encryptData`，它接受两个参数：类型为`String`的`data`和类型为`String`的`key`。方法的返回类型也是`String`。
```
public native long f (int n, String s, int[] arr);
```
它具有类型签名：
```
(ILjava/lang/String;[I)J
```
### 练习 #5 - 查找本地函数的地址 <a href="exercise-5---find-the-address-of-the-native-function" id="exercise-5---find-the-address-of-the-native-function"></a>

在练习 #5 中，我们将学习如何在反汇编器中加载本地库，并确定在调用本地方法时执行的本地函数。对于这个特定的练习，目标不是逆向工程本地方法，而是找到Java中调用本地方法的调用与在本地库中执行的函数之间的链接。在这个练习中，我们将使用样本Mediacode.apk。该样本在虚拟机中的路径为`~/samples/Mediacode.apk`。其SHA256哈希值为a496b36cda66aaf24340941da8034bd53940d1b08d83a97f17a65ae144ebf91a。

**目标**

本练习的目标是：

1. 识别DEX字节码中声明的本地方法
2. 确定加载了哪些本地库（从而确定本地方法可能实现在哪里）
3. 从APK中提取本地库
4. 将本地库加载到反汇编器中
5. 确定调用本地方法时在本地库中执行的函数的地址（或名称）

**说明**

1. 在jadx中打开Mediacode.apk。参考[练习 #1](https://maddiestone.github.io/AndroidAppRE/reversing_intro.html#exercise-1---beginning-re-with-jadx)
2. 这次，如果展开资源选项卡，你会看到这个APK有一个`lib/`目录。该APK的本地库位于默认的CPU路径中。
3. 现在我们需要识别任何声明的本地方法。在jadx中搜索并列出所有声明的本地方法。应该有两个。
4. 在声明的本地方法周围，查看是否有加载本地库的地方。这将指导我们在哪个本地库中查找要实现的函数。
5. 通过创建一个新目录并将APK复制到该文件夹中，从APK中提取本地库。然后运行命令`unzip Mediacode.APK`。你将看到从APK中提取的所有文件，其中包括`lib/`目录。
6. 选择要分析的本地库的架构。
7. 运行`ghidraRun`启动ghidra。这将打开Ghidra。
8. 要打开本地库进行分析，选择“New Project”，“Non-Shared Project”，选择保存项目的路径并给它一个名称。这将创建一个项目，然后可以将二进制文件加载到其中。
9. 创建项目后，选择龙图标打开代码浏览器。然后转到“File” > “Import File”将本地库加载到工具中。可以保留所有默认设置。
10. 你将看到以下屏幕。选择“Analyze”。
11. 使用上面的链接信息，确定在调用Java声明的本地方法时在本地库中执行的函数。

![将文件加载到Ghidra代码浏览器中](https://maddiestone.github.io/AndroidAppRE/images/loadingIntoGhidra.png)

![Mediacode在jadx中打开的截图](https://maddiestone.github.io/AndroidAppRE/images/Mediacode.InJadx.png)

**解决方案**

## 反向工程Android本地库代码 - JNIEnv <a href="reversing-android-native-libraries-code---jnienv" id="reversing-android-native-libraries-code---jnienv"></a>

当开始反向工程Android本地库时，我不知道需要了解的一件事是`JNIEnv`。`JNIEnv`是一个指向[JNI函数](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html)的函数指针结构。在Android本地库中的每个JNI函数都以`JNIEnv*`作为第一个参数。

根据Android [JNI提示](https://developer.android.com/training/articles/perf-jni)文档：

> JNIEnv和JavaVM的C声明与C++声明不同。`jni.h`包含文件根据是否包含在C或C++中提供不同的typedef。因此，在同时包含两种语言的头文件中包含JNIEnv参数是一个坏主意。（换句话说：如果你的头文件需要`#ifdef \__cplusplus`，那么如果该头文件中的任何内容引用了JNIEnv，你可能需要做一些额外的工作。）

下面是一些常用的函数（及其在JNIEnv中的偏移量）：

* JNIEnv + 0x18: jclass (\*FindClass)(JNIEnv_, const char_);
* JNIEnv + 0x34: jint (\*Throw)(JNIEnv\*, jthrowable);
* JNIEnv + 0x70: jobject (\*NewObject)(JNIEnv\*, jclass, jmethodID, …);
* JNIEnv + 0x84: jobject (\*NewObject)(JNIEnv\*, jclass, jmethodID, …);
* JNIEnv + 0x28C: jstring (\*NewString)(JNIEnv_, const jchar_, jsize);
* JNIEnv + 0x35C: jint (\*RegisterNatives)(JNIEnv_, jclass, const JNINativeMethod_, jint);

在分析Android本地库时，JNIEnv的存在意味着：

1. 对于JNI本地函数，参数将向后移动2个位置。第一个参数始终是JNIEnv\*。第二个参数将是应该运行该函数的对象。对于静态本地方法（在Java声明中具有static关键字），这将为NULL。
2. 在反汇编中，你经常会看到间接分支，因为代码正在将偏移量添加到JNIEnv\*指针，解引用以获取该位置处的函数指针，然后跳转到该函数。

下面是一个JNIEnv结构的C实现的[电子表格](https://docs.google.com/spreadsheets/d/1yqjFaY7mqyVIDs5jNjGLT-G8pUaRATzHWGFUgpdJRq8/edit?usp=sharing)，以了解不同偏移量处的函数指针。

在实践中，在反汇编中，这将显示为许多不同的间接地址分支，而不是直接的函数调用。下面的图像显示了其中一个间接函数调用。反向工程师需要弄清楚r3是什么。在截图中没有显示，但在该函数的开头，`r0`被移动到`r5`。因此，`r5`是`JNIEnv*`。在0x12498行，我们看到`r3 = [r5]`。现在，`r3`是`JNIEnv`（没有\*）。

在0x1249e行，我们将0x18添加到`r3`并解引用它。这意味着`r3`现在等于在JNIEnv的偏移量0x18处的函数指针。我们可以通过查看电子表格来找到。`[JNIEnv + 0x18] = 指向FindClass方法的指针`

因此，0x124a4行的`blx r3`调用了`FindClass`。我们可以在JNIFunctions文档[这里](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html)查找有关`FindClass`（以及JNIEnv中的所有其他函数）的信息。

![反汇编调用JNIEnv中的函数的截图](https://maddiestone.github.io/AndroidAppRE/images/JNIcall.png)
幸运的是，有一种方法可以在不手动操作的情况下获取JNI函数！在Ghidra和IDA Pro反编译器中，您可以将JNI函数的第一个参数重新定义为`JNIEnv *`类型，它将自动识别被调用的JNI函数。在IDA Pro中，这个功能可以直接使用。在Ghidra中，您需要先加载JNI类型（可以是jni.h文件或jni.h文件的Ghidra数据类型存档）。为了方便起见，我们将从Ayrx生成的Ghidra数据类型存档（gdt）中加载JNI类型，该存档可以在[这里](https://github.com/Ayrx/JNIAnalyzer/blob/master/JNIAnalyzer/data/jni_all.gdt)找到。为了方便起见，该文件在虚拟机中的路径是`~/jni_all.gdt`。

要在Ghidra中加载它以供使用，请在“数据类型管理器”窗口中，点击右下角的向下箭头，然后选择“打开文件存档”。

![打开文件存档菜单的截图](https://maddiestone.github.io/AndroidAppRE/images/OpenArchive.png)

然后选择`jni_all.gdt`文件进行加载。加载完成后，您应该在数据类型管理器列表中看到jni_all，如下图所示。

![在数据类型管理器中加载的jni_all的截图](https://maddiestone.github.io/AndroidAppRE/images/LoadedInDataTypeManager.png)

在Ghidra中加载了这个之后，您可以选择反编译器中的任何参数类型，并选择“重新定义变量”。将新类型设置为JNIEnv \*。这将导致反编译器显示被调用的JNIFunctions的名称，而不是指针的偏移量。

![将参数重新定义为JNIEnv\*后，JNI函数名称的截图](https://maddiestone.github.io/AndroidAppRE/images/RetypedToJNIEnv.png)

### 练习 #6 - 查找和反向工程本地函数 <a href="exercise-6---find-and-reverse-the-native-function" id="exercise-6---find-and-reverse-the-native-function"></a>

我们将把之前的所有技巧综合起来：识别反向工程的起始点、反向工程DEX和本地代码，以分析一个可能将其有害行为移至本地代码的应用程序。示例是`~/samples/HDWallpaper.apk`。

**目标**

本练习的目标是将我们的Android反向工程技巧综合起来，对一个应用程序进行整体分析：包括其DEX和本地代码。

**练习背景**

您是一名Android应用程序的恶意软件分析师。您担心这个样本可能会进行高级短信欺诈，即在未经披露和用户同意的情况下向高级电话号码发送短信。为了将其标记为恶意软件，您需要确定Android应用程序是否：

1. 发送短信，以及
2. 该短信是否发送到高级号码，以及
3. 是否存在明显的披露，以及
4. 用户同意后是否只将短信发送到高级号码。

**操作说明**

开始进行反向工程吧！

**解决方案**


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 您在一家**网络安全公司**工作吗？您想在HackTricks中**为您的公司做广告**吗？或者您想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[NFT收藏品](https://opensea.io/collection/the-peass-family)——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **通过向[hacktricks仓库](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud仓库](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享您的黑客技巧**。

</details>
