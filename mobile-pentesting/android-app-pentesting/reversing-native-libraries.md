<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!

- Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)

- **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Compartilhe suas t√©cnicas de hacking enviando PRs para o [reposit√≥rio hacktricks](https://github.com/carlospolop/hacktricks) e [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**.

</details>


**Informa√ß√µes copiadas de** [**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)** (voc√™ pode encontrar solu√ß√µes l√°)**

Os aplicativos Android podem conter bibliotecas nativas compiladas. As bibliotecas nativas s√£o c√≥digos que o desenvolvedor escreveu e depois compilou para uma arquitetura de computador espec√≠fica. Na maioria das vezes, isso significa c√≥digo escrito em C ou C++. As raz√µes benignas, ou leg√≠timas, pelas quais um desenvolvedor pode fazer isso √© para opera√ß√µes matematicamente intensivas ou sens√≠veis ao tempo, como bibliotecas gr√°ficas. Os desenvolvedores de malware come√ßaram a migrar para o c√≥digo nativo porque a engenharia reversa de bin√°rios compilados tende a ser um conjunto de habilidades menos comum do que a an√°lise do bytecode DEX. Isso se deve em grande parte ao fato de que o bytecode DEX pode ser descompilado para Java, enquanto o c√≥digo nativo compilado geralmente deve ser analisado como assembly.

## Objetivo

O objetivo desta se√ß√£o n√£o √© ensinar assembly (ASM) ou como engenharia reversa de c√≥digo compilado de forma mais geral, mas sim como aplicar as habilidades de engenharia reversa bin√°ria mais gerais, especificamente para Android. Como o objetivo deste workshop n√£o √© ensinar as arquiteturas ASM, todos os exerc√≠cios incluir√£o uma vers√£o ARM _e_ uma vers√£o x86 da biblioteca a ser analisada para que cada pessoa possa escolher a arquitetura com a qual se sinta mais confort√°vel.

### Aprendendo a Assembleia ARM <a href="learning-arm-assembly" id="learning-arm-assembly"></a>

Se voc√™ n√£o tem experi√™ncia anterior em engenharia reversa bin√°ria / assembly, aqui est√£o alguns recursos sugeridos. A maioria dos dispositivos Android roda em ARM, mas todos os exerc√≠cios deste workshop tamb√©m incluem uma vers√£o x86 da biblioteca.

Para aprender e / ou revisar a assembleia ARM, eu sugiro fortemente o [ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/) do [Azeria Labs](https://azeria-labs.com).

## Introdu√ß√£o √† Interface Nativa do Java (JNI) <a href="introduction-to-the-java-native-interface-jni" id="introduction-to-the-java-native-interface-jni"></a>

A Interface Nativa do Java (JNI) permite que os desenvolvedores declarem m√©todos Java que s√£o implementados em c√≥digo nativo (geralmente compilado em C/C++). A interface JNI n√£o √© espec√≠fica do Android, mas est√° dispon√≠vel mais geralmente para aplicativos Java que s√£o executados em diferentes plataformas.

O Android Native Development Kit (NDK) √© o conjunto de ferramentas espec√≠fico do Android em cima do JNI. De acordo com a [documenta√ß√£o](https://developer.android.com/ndk/guides):

> No Android, o Kit de Desenvolvimento Nativo (NDK) √© um conjunto de ferramentas que permite que os desenvolvedores escrevam c√≥digo C e C++ para seus aplicativos Android.

Juntos, JNI e NDK permitem que os desenvolvedores Android implementem parte da funcionalidade de seus aplicativos em c√≥digo nativo. O c√≥digo Java (ou Kotlin) chamar√° um m√©todo nativo declarado em Java que √© implementado na biblioteca nativa compilada.

### Refer√™ncias <a href="references" id="references"></a>

**Documenta√ß√£o Oracle JNI**

* [Especifica√ß√£o JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)
* [Fun√ß√µes JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html) <‚Äì Eu sempre tenho este aberto e me refiro a ele ao reverter bibliotecas nativas do Android

**Refer√™ncias do JNI e NDK do Android**

* [Dicas do JNI do Android](https://developer.android.com/training/articles/perf-jni) <‚Äì Altamente sugiro ler a se√ß√£o "Bibliotecas nativas" para come√ßar
* [Introdu√ß√£o ao NDK](https://developer.android.com/ndk/guides/) <‚Äì Este √© um guia para como os desenvolvedores desenvolvem bibliotecas nativas e entender como as coisas s√£o constru√≠das, torna mais f√°cil reverter.

## Alvo de An√°lise - Bibliotecas Nativas do Android <a href="target-of-analysis---android-native-libraries" id="target-of-analysis---android-native-libraries"></a>

Para esta se√ß√£o, estamos nos concentrando em como reverter a funcionalidade do aplicativo que foi implementada em bibliotecas nativas do Android. Quando dizemos bibliotecas nativas do Android, o que queremos dizer?

As bibliotecas nativas do Android s√£o inclu√≠das nos APKs como bibliotecas de objeto compartilhado `.so`, no formato de arquivo ELF. Se voc√™ j√° analisou bin√°rios Linux anteriormente, √© o mesmo formato.

Essas bibliotecas por padr√£o s√£o inclu√≠das no APK no caminho do arquivo `/lib/<cpu>/lib<name>.so`. Este √© o caminho padr√£o, mas os desenvolvedores tamb√©m podem optar por incluir a biblioteca nativa em `/assets/<custom_name>` se assim o desejarem. Com mais frequ√™ncia, estamos vendo desenvolvedores de malware escolherem incluir bibliotecas nativas em caminhos diferentes de `/lib` e usando diferentes extens√µes de arquivo para tentar "ocultar" a presen√ßa da biblioteca nativa.

Como o c√≥digo nativo √© compilado para CPUs espec√≠ficas, se um desenvolvedor quiser que seu aplicativo seja executado em mais de um tipo de hardware, ele ter√° que incluir cada uma dessas vers√µes da biblioteca nativa compilada no aplicativo. O caminho padr√£o mencionado acima inclui um diret√≥rio para cada tipo de CPU oficialmente suportado pelo Android.

| CPU                  | Caminho da Biblioteca Nativa          |
| -------------------- | ---------------------------- |
| ‚Äúgeneric‚Äù 32-bit ARM | `lib/armeabi/libcalc.so`     |
| x86                  | `lib/x86/libcalc.so`         |
| x64                  | `lib/x86_64/libcalc.so`      |
| ARMv7                | `lib/armeabi-v7a/libcalc.so` |
| ARM64                | `lib/arm64-v8a/libcalc.so`   |

## Carregando a Biblioteca <a href="loading-the-library" id="loading-the-library"></a>

Antes que um aplicativo Android possa chamar e executar qualquer c√≥digo que seja implementado em uma biblioteca nativa, o aplicativo (c√≥digo Java) deve carregar a biblioteca na mem√≥ria. Existem duas chamadas de API diferentes que far√£o isso:
```
System.loadLibrary("calc")
```
Desculpe, eu n√£o entendi. Voc√™ poderia reformular sua solicita√ß√£o?
```
System.load("lib/armeabi/libcalc.so")
```
A diferen√ßa entre as duas chamadas de API √© que `loadLibrary` s√≥ recebe o nome curto da biblioteca como argumento (ou seja, libcalc.so = "calc" e libinit.so = "init") e o sistema determinar√° corretamente a arquitetura em que est√° sendo executado e, portanto, o arquivo correto a ser usado. Por outro lado, `load` requer o caminho completo para a biblioteca. Isso significa que o desenvolvedor do aplicativo tem que determinar a arquitetura e, portanto, o arquivo de biblioteca correto a ser carregado.

Quando qualquer um desses dois APIs (`loadLibrary` ou `load`) √© chamado pelo c√≥digo Java, a biblioteca nativa que √© passada como argumento executa seu `JNI_OnLoad` se ele foi implementado na biblioteca nativa.

Para reiterar, antes de executar quaisquer m√©todos nativos, a biblioteca nativa deve ser carregada chamando `System.loadLibrary` ou `System.load` no c√≥digo Java. Quando qualquer um desses 2 APIs √© executado, a fun√ß√£o `JNI_OnLoad` na biblioteca nativa tamb√©m √© executada.

## A Conex√£o de C√≥digo Java para C√≥digo Nativo <a href="the-java-to-native-code-connection" id="the-java-to-native-code-connection"></a>

Para executar uma fun√ß√£o da biblioteca nativa, deve haver um m√©todo nativo declarado em Java que o c√≥digo Java possa chamar. Quando este m√©todo nativo declarado em Java √© chamado, a fun√ß√£o nativa "pareada" da biblioteca nativa (ELF/.so) √© executada.

Um m√©todo nativo declarado em Java aparece no c√≥digo Java como abaixo. Ele aparece como qualquer outro m√©todo Java, exceto que inclui a palavra-chave `native` e n√£o tem c√≥digo em sua implementa√ß√£o, porque seu c√≥digo est√° realmente na biblioteca nativa compilada.
```
public native String doThingsInNativeLibrary(int var0);
```
Para chamar este m√©todo nativo, o c√≥digo Java o chamaria como qualquer outro m√©todo Java. No entanto, nos bastidores, o JNI e o NDK executariam a fun√ß√£o correspondente na biblioteca nativa. Para isso, √© necess√°rio conhecer a associa√ß√£o entre um m√©todo nativo declarado em Java e uma fun√ß√£o na biblioteca nativa.

Existem duas maneiras diferentes de fazer essa associa√ß√£o, ou vincula√ß√£o:

1. Vincula√ß√£o din√¢mica usando a Resolu√ß√£o de Nome de M√©todo Nativo JNI, ou
2. Vincula√ß√£o est√°tica usando a chamada de API `RegisterNatives`

### Vincula√ß√£o Din√¢mica <a href="dynamic-linking" id="dynamic-linking"></a>

Para vincular, ou associar, o m√©todo nativo declarado em Java e a fun√ß√£o na biblioteca nativa dinamicamente, o desenvolvedor nomeia o m√©todo e a fun√ß√£o de acordo com as especifica√ß√µes para que o sistema JNI possa fazer a vincula√ß√£o dinamicamente.

De acordo com a especifica√ß√£o, o desenvolvedor nomearia a fun√ß√£o da seguinte forma para que o sistema possa vincular dinamicamente o m√©todo nativo e a fun√ß√£o. Um nome de m√©todo nativo √© concatenado a partir dos seguintes componentes:

1. o prefixo Java\_
2. um nome de classe qualificado completo codificado
3. um separador de sublinhado (‚Äú\_‚Äù)
4. um nome de m√©todo codificado
5. para m√©todos nativos sobrecarregados, dois sublinhados (‚Äú\__‚Äù) seguidos da assinatura de argumento codificada

Para fazer a vincula√ß√£o din√¢mica para o m√©todo nativo declarado em Java abaixo e digamos que ele esteja na classe `com.android.interesting.Stuff`
```
public native String doThingsInNativeLibrary(int var0);
```
A fun√ß√£o na biblioteca nativa precisaria ter o nome:
```
Java_com_android_interesting_Stuff_doThingsInNativeLibrary
```
Se n√£o houver uma fun√ß√£o na biblioteca nativa com esse nome, isso significa que o aplicativo deve estar fazendo uma vincula√ß√£o est√°tica.

### Vincula√ß√£o Est√°tica <a href="static-linking" id="static-linking"></a>

Se o desenvolvedor n√£o quiser ou n√£o puder nomear as fun√ß√µes nativas de acordo com a especifica√ß√£o (por exemplo, deseja remover s√≠mbolos de depura√ß√£o), ele deve usar a vincula√ß√£o est√°tica com a API `RegisterNatives` ([doc](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp5833)) para fazer a associa√ß√£o entre o m√©todo nativo declarado em Java e a fun√ß√£o na biblioteca nativa. A fun√ß√£o `RegisterNatives` √© chamada a partir do c√≥digo nativo, n√£o do c√≥digo Java, e √© mais frequentemente chamada na fun√ß√£o `JNI_OnLoad`, uma vez que `RegisterNatives` deve ser executado antes de chamar o m√©todo nativo declarado em Java.
```
jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);

typedef struct { 
    char *name; 
    char *signature; 
    void *fnPtr; 
} JNINativeMethod;
```
Ao realizar engenharia reversa, se a aplica√ß√£o estiver usando o m√©todo de vincula√ß√£o est√°tica, n√≥s, como analistas, podemos encontrar a estrutura `JNINativeMethod` que est√° sendo passada para `RegisterNatives` para determinar qual sub-rotina na biblioteca nativa √© executada quando o m√©todo nativo declarado em Java √© chamado.

A estrutura `JNINativeMethod` requer uma string com o nome do m√©todo nativo declarado em Java e uma string com a assinatura do m√©todo, ent√£o devemos ser capazes de encontrar essas informa√ß√µes em nossa biblioteca nativa.

**Assinatura do M√©todo**

A estrutura `JNINativeMethod` requer a assinatura do m√©todo. Uma assinatura do m√©todo indica os tipos dos argumentos que o m√©todo recebe e o tipo do que ele retorna. Este link documenta [Assinaturas de Tipo JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html) na se√ß√£o "Assinaturas de Tipo".

* Z: booleano
* B: byte
* C: char
* S: short
* I: int
* J: long
* F: float
* D: double
* L fully-qualified-class ; :classe total-qualificada
* \[ type: type\[]: tipo de matriz
* ( arg-types ) ret-type: tipo de m√©todo
* V: vazio

Para o m√©todo nativo.
```
public native String doThingsInNativeLibrary(int var0);
```
A assinatura de tipo √©
```
(I)Ljava/lang/String;
```
Aqui est√° outro exemplo de um m√©todo nativo e sua assinatura. Para o seguinte √© a declara√ß√£o do m√©todo:
```
public native long f (int n, String s, int[] arr); 
```
Possui a assinatura de tipo:
```
(ILjava/lang/String;[I)J
```
### Exerc√≠cio #5 - Encontre o endere√ßo da fun√ß√£o nativa

No Exerc√≠cio #5, vamos aprender a carregar bibliotecas nativas em um desmontador e identificar a fun√ß√£o nativa que √© executada quando um m√©todo nativo √© chamado. Para este exerc√≠cio em particular, o objetivo n√£o √© engenharia reversa do m√©todo nativo, apenas encontrar o link entre a chamada ao m√©todo nativo em Java e a fun√ß√£o que √© executada na biblioteca nativa. Para este exerc√≠cio, usaremos o aplicativo de amostra Mediacode.apk. Esta amostra est√° dispon√≠vel em `~/samples/Mediacode.apk` na VM. Seu hash SHA256 √© a496b36cda66aaf24340941da8034bd53940d1b08d83a97f17a65ae144ebf91a.

**Objetivo**

O objetivo deste exerc√≠cio √©:

1. Identificar m√©todos nativos declarados no bytecode DEX
2. Determinar quais bibliotecas nativas s√£o carregadas (e, portanto, onde os m√©todos nativos podem ser implementados)
3. Extrair a biblioteca nativa do APK
4. Carregar a biblioteca nativa em um desmontador
5. Identificar o endere√ßo (ou nome) da fun√ß√£o na biblioteca nativa que √© executada quando o m√©todo nativo √© chamado

**Instru√ß√µes**

1. Abra o Mediacode.apk no jadx. Consulte o [Exerc√≠cio #1](https://maddiestone.github.io/AndroidAppRE/reversing_intro.html#exercise-1---beginning-re-with-jadx) para obter mais informa√ß√µes.
2. Desta vez, se voc√™ expandir a guia Recursos, ver√° que este APK tem um diret√≥rio `lib/`. As bibliotecas nativas para este APK est√£o nos caminhos padr√£o da CPU.
3. Agora precisamos identificar quaisquer m√©todos nativos declarados. No jadx, pesquise e liste todos os m√©todos nativos declarados. Deve haver dois.
4. Em torno do m√©todo nativo declarado, veja se h√° algum lugar em que uma biblioteca nativa √© carregada. Isso fornecer√° orienta√ß√£o sobre em qual biblioteca nativa procurar a fun√ß√£o a ser implementada.
5. Extraia a biblioteca nativa do APK criando um novo diret√≥rio e copiando o APK para essa pasta. Em seguida, execute o comando `unzip Mediacode.APK`. Voc√™ ver√° todos os arquivos extra√≠dos do APK, que incluem o diret√≥rio `lib/`.
6. Selecione a arquitetura da biblioteca nativa que voc√™ deseja analisar.
7. Inicie o ghidra executando `ghidraRun`. Isso abrir√° o Ghidra.
8. Para abrir a biblioteca nativa para an√°lise, selecione "Novo Projeto", "Projeto N√£o Compartilhado", selecione um caminho para salvar o projeto e d√™ um nome a ele. Isso cria um projeto que voc√™ pode ent√£o carregar arquivos bin√°rios.
9. Depois de criar seu projeto, selecione o √≠cone do drag√£o para abrir o Navegador de C√≥digo. V√° em "Arquivo" > "Importar Arquivo" para carregar a biblioteca nativa na ferramenta. Voc√™ pode deixar todos os padr√µes.
10. Voc√™ ver√° a seguinte tela. Selecione "Analisar".
11. Usando as informa√ß√µes de vincula√ß√£o acima, identifique a fun√ß√£o na biblioteca nativa que √© executada quando o m√©todo nativo declarado em Java √© chamado.

![Carregando arquivo no Ghidra Code Browser](https://maddiestone.github.io/AndroidAppRE/images/loadingIntoGhidra.png)

![Captura de tela do Mediacode aberto no jadx](https://maddiestone.github.io/AndroidAppRE/images/Mediacode.InJadx.png)

**Solu√ß√£o**

## Revers√£o de c√≥digo de bibliotecas nativas do Android - JNIEnv

Ao come√ßar a engenharia reversa de bibliotecas nativas do Android, uma das coisas que eu n√£o sabia que precisava saber era sobre `JNIEnv`. `JNIEnv` √© uma estrutura de ponteiros de fun√ß√£o para [Fun√ß√µes JNI](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html). Toda fun√ß√£o JNI em bibliotecas nativas do Android, leva `JNIEnv*` como primeiro argumento.

Da documenta√ß√£o do Android [JNI Tips](https://developer.android.com/training/articles/perf-jni):

> As declara√ß√µes C de JNIEnv e JavaVM s√£o diferentes das declara√ß√µes C++. O arquivo de inclus√£o "jni.h" fornece diferentes typedefs dependendo se ele √© inclu√≠do em C ou C++. Por esse motivo, √© uma m√° ideia incluir argumentos JNIEnv em arquivos de cabe√ßalho inclu√≠dos por ambos os idiomas. (Dito de outra forma: se o seu arquivo de cabe√ßalho requer #ifdef \__cplusplus, voc√™ pode ter que fazer algum trabalho extra se algo nesse cabe√ßalho se referir a JNIEnv.)

Aqui est√£o algumas fun√ß√µes
