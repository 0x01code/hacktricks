<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンを入手したり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクション

- [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **ハッキングのトリックを共有するために、[hacktricksリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudリポジトリ](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>


**情報はここからコピーされました**[**https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html**](https://maddiestone.github.io/AndroidAppRE/reversing_native_libs.html)**（解決策はそこにあります）**

Androidアプリケーションには、コンパイルされたネイティブライブラリが含まれることがあります。ネイティブライブラリは、開発者が特定のコンピュータアーキテクチャ向けに書いてコンパイルしたコードです。ほとんどの場合、これはCまたはC++で書かれたコードを意味します。開発者がこれを行う正当な理由は、数学的に集中的な操作や時間的に敏感な操作（グラフィックスライブラリなど）のためです。マルウェア開発者は、DEXバイトコードの解析よりもコンパイルされたバイナリのリバースエンジニアリングのスキルセットが一般的に少ないため、ネイティブコードに移行し始めています。これは、DEXバイトコードはJavaに逆コンパイルできるのに対し、ネイティブのコンパイルされたコードはアセンブリとして解析する必要があるためです。

## ゴール

このセクションの目的は、アセンブリ（ASM）を教えることやコンパイルされたコードをより一般的にリバースエンジニアリングする方法を教えることではありません。代わりに、より一般的なバイナリリバースエンジニアリングのスキルをAndroidに特化して適用する方法を教えます。このワークショップの目的はASMアーキテクチャを教えることではないため、すべての演習には解析するためのARMバージョンとx86バージョンのライブラリが含まれています。各人がより快適なアーキテクチャを選択できるようにするためです。

### ARMアセンブリの学習 <a href="learning-arm-assembly" id="learning-arm-assembly"></a>

バイナリリバースエンジニアリング/アセンブリの経験がない場合、以下のリソースを参照してください。ほとんどのAndroidデバイスはARM上で実行されますが、このワークショップのすべての演習にはライブラリのx86バージョンも含まれています。

ARMアセンブリを学び、または復習するには、[Azeria Labs](https://azeria-labs.com)の[ARM Assembly Basics](https://azeria-labs.com/writing-arm-assembly-part-1/)を強くお勧めします。

## Java Native Interface（JNI）の紹介 <a href="introduction-to-the-java-native-interface-jni" id="introduction-to-the-java-native-interface-jni"></a>

Java Native Interface（JNI）は、ネイティブコード（通常はコンパイルされたC/C++）で実装されたJavaメソッドを宣言することを開発者に許可します。JNIインターフェースはAndroid固有ではありませんが、さまざまなプラットフォームで実行されるJavaアプリケーションに一般的に利用できます。

Android Native Development Kit（NDK）は、JNIの上にあるAndroid固有のツールセットです。[ドキュメント](https://developer.android.com/ndk/guides)によると：

> Androidでは、ネイティブ開発キット（NDK）は、開発者がAndroidアプリのためにCおよびC++コードを書くことを許可するツールセットです。

JNIとNDKを組み合わせることで、Android開発者はアプリの一部の機能をネイティブコードで実装することができます。Java（またはKotlin）コードは、コンパイルされたネイティブライブラリで実装されたJavaで宣言されたネイティブメソッドを呼び出します。

### 参考文献 <a href="references" id="references"></a>

**Oracle JNIドキュメント**

* [JNI仕様](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)
* [JNI関数](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html) <– Androidネイティブライブラリのリバースエンジニアリング時に常に参照しています

**Android JNI＆NDKリファレンス**

* [Android JNIのヒント](https://developer.android.com/training/articles/perf-jni) <– 「ネイティブライブラリ」セクションを読むことを強くお勧めします
* [NDKのはじめ方](https://developer.android.com/ndk/guides/) <– ネイティブライブラリの開発方法とビルド方法を理解するためのガイダンスです。これにより、リバースエンジニアリングが容易になります。

## 解析対象 - Androidネイティブライブラリ <a href="target-of-analysis---android-native-libraries" id="target-of-analysis---android-native-libraries"></a>

このセクションでは、Androidネイティブライブラリに実装されたアプリの機能をリバースエンジニアリングする方法に焦点を当てています。Androidネイティブライブラリとは何を意味するのでしょうか？

Androidネイティブライブラリは、APKに`.so`という拡張子の共有オブジェクトライブラリとして含まれます。以前にLinuxバイナリを分析したことがある場合、同じ形式です。

これらのライブラリはデフォルトでAPKに以下の
## ライブラリの読み込み <a href="loading-the-library" id="loading-the-library"></a>

Androidアプリがネイティブライブラリで実装されたコードを呼び出して実行する前に、アプリケーション（Javaコード）はライブラリをメモリに読み込む必要があります。これを行うためには、2つの異なるAPI呼び出しがあります。
```
System.loadLibrary("calc")
```
または
```
System.load("lib/armeabi/libcalc.so")
```
## ネイティブライブラリのリバースエンジニアリング

2つのAPI呼び出しの違いは、`loadLibrary`はライブラリの短い名前（例：libcalc.so = "calc"、libinit.so = "init"）を引数として受け取るだけであり、システムは現在実行中のアーキテクチャとそれに応じた正しいファイルを自動的に選択します。一方、`load`はライブラリの完全なパスを必要とします。つまり、アプリの開発者はアーキテクチャとそれに応じた正しいライブラリファイルを自分で選択する必要があります。

これらのいずれか（`loadLibrary`または`load`）のAPIがJavaコードによって呼び出されると、引数として渡されたネイティブライブラリは、ネイティブライブラリに実装されている場合に`JNI_OnLoad`を実行します。

再度強調しますが、ネイティブメソッドを実行する前に、ネイティブライブラリをJavaコードで`System.loadLibrary`または`System.load`を呼び出してロードする必要があります。これらの2つのAPIのいずれかが実行されると、ネイティブライブラリ内の`JNI_OnLoad`関数も実行されます。

## Javaからネイティブコードへの接続 <a href="the-java-to-native-code-connection" id="the-java-to-native-code-connection"></a>

ネイティブライブラリから関数を実行するためには、Javaコードから呼び出すことができるJavaで宣言されたネイティブメソッドが必要です。このJavaで宣言されたネイティブメソッドが呼び出されると、ネイティブライブラリ（ELF/.so）から「ペアリングされた」ネイティブ関数が実行されます。

Javaで宣言されたネイティブメソッドは、以下のようにJavaコードに表示されます。他のJavaメソッドと同様に表示されますが、`native`キーワードが含まれ、実装にコードがないため、実際のコードはコンパイルされたネイティブライブラリにあります。
```
public native String doThingsInNativeLibrary(int var0);
```
このネイティブメソッドを呼び出すために、Javaコードは他のJavaメソッドと同様に呼び出します。しかし、バックエンドでは、JNIとNDKは代わりにネイティブライブラリ内の対応する関数を実行します。これを行うためには、Javaで宣言されたネイティブメソッドとネイティブライブラリ内の関数のペアリングを知る必要があります。

このペアリング、またはリンクを行うためには、2つの異なる方法があります。

1. JNIネイティブメソッド名の解決を使用した動的リンキング、または
2. `RegisterNatives` API呼び出しを使用した静的リンキング

### 動的リンキング <a href="dynamic-linking" id="dynamic-linking"></a>

Javaで宣言されたネイティブメソッドとネイティブライブラリ内の関数を動的にリンクまたはペアリングするために、開発者はメソッドと関数の名前を仕様に従って指定し、JNIシステムが動的にリンクできるようにします。

仕様によれば、開発者は以下のコンポーネントからなる関数名を指定する必要があります。ネイティブメソッド名は次のように連結されます。

1. プレフィックスJava\_
2. マングル化された完全修飾クラス名
3. アンダースコア（"\_"）セパレータ
4. マングル化されたメソッド名
5. オーバーロードされたネイティブメソッドの場合、アンダースコア2つ（"\__"）に続いてマングル化された引数シグネチャ

以下のJavaで宣言されたネイティブメソッドに対して動的リンキングを行うために、例えばクラス`com.android.interesting.Stuff`内にあるとします。
```
public native String doThingsInNativeLibrary(int var0);
```
ネイティブライブラリ内の関数は次のように名前付ける必要があります：
```
Java_com_android_interesting_Stuff_doThingsInNativeLibrary
```
もしネイティブライブラリにその名前の関数が存在しない場合、アプリケーションは静的リンキングを行っている可能性があります。

### 静的リンキング <a href="static-linking" id="static-linking"></a>

開発者が仕様に従ってネイティブ関数の名前を付けることを望まない場合（例：デバッグシンボルを削除したい場合）、またはできない場合、Javaで宣言されたネイティブメソッドとネイティブライブラリの関数をペアリングするために、`RegisterNatives`（[ドキュメント](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp5833)）APIを使用する必要があります。`RegisterNatives`関数はネイティブコードから呼び出され、Javaコードではなく、通常は`JNI_OnLoad`関数内で呼び出されます。なぜなら、`RegisterNatives`はJavaで宣言されたネイティブメソッドを呼び出す前に実行する必要があるからです。
```
jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);

typedef struct {
char *name;
char *signature;
void *fnPtr;
} JNINativeMethod;
```
リバースエンジニアリングを行う際、アプリケーションが静的リンキング方式を使用している場合、私たちアナリストは`RegisterNatives`に渡される`JNINativeMethod`構造体を見つけることができます。これにより、Javaで宣言されたネイティブメソッドが呼び出された際にネイティブライブラリ内のどのサブルーチンが実行されるかを特定することができます。

`JNINativeMethod`構造体には、Javaで宣言されたネイティブメソッド名の文字列とメソッドのシグネチャの文字列が必要です。そのため、これらをネイティブライブラリ内で見つけることができるはずです。

**メソッドのシグネチャ**

`JNINativeMethod`構造体には、メソッドのシグネチャが必要です。メソッドのシグネチャは、メソッドが受け取る引数の型と返り値の型を示します。このリンクでは、[JNIの型シグネチャ](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html)が「Type Signatures」セクションで文書化されています。

* Z: boolean
* B: byte
* C: char
* S: short
* I: int
* J: long
* F: float
* D: double
* L fully-qualified-class ; :fully-qualified-class
* \[ type: type\[]
* ( arg-types ) ret-type: method type
* V: void

ネイティブメソッドの場合
```
public native String doThingsInNativeLibrary(int var0);
```
型シグネチャは以下の通りです。
```
(I)Ljava/lang/String;
```
以下は、ネイティブメソッドとそのシグネチャの別の例です。以下は、メソッドの宣言です。
```
public native long f (int n, String s, int[] arr);
```
それは次の型シグネチャを持っています：
```
(ILjava/lang/String;[I)J
```
### Exercise #5 - ネイティブ関数のアドレスを見つける <a href="exercise-5---find-the-address-of-the-native-function" id="exercise-5---find-the-address-of-the-native-function"></a>

Exercise #5では、ディスアセンブラでネイティブライブラリをロードし、ネイティブメソッドが呼び出されたときに実行されるネイティブ関数を特定する方法を学びます。この演習では、ネイティブメソッドをリバースエンジニアリングすることではなく、Javaでネイティブメソッドが呼び出されるときに実行される関数とネイティブライブラリの関連を見つけることが目標です。この演習では、サンプルのMediacode.apkを使用します。このサンプルはVM内の`~/samples/Mediacode.apk`にあります。SHA256ハッシュはa496b36cda66aaf24340941da8034bd53940d1b08d83a97f17a65ae144ebf91aです。

**目標**

この演習の目標は次のとおりです。

1. DEXバイトコードで宣言されたネイティブメソッドを特定する
2. ロードされるネイティブライブラリを特定する（したがって、ネイティブメソッドが実装されている場所）
3. APKからネイティブライブラリを抽出する
4. ネイティブライブラリをディスアセンブラにロードする
5. ネイティブメソッドが呼び出されたときに実行されるネイティブライブラリ内の関数のアドレス（または名前）を特定する

**手順**

1. jadxでMediacode.apkを開きます。[Exercise #1](https://maddiestone.github.io/AndroidAppRE/reversing_intro.html#exercise-1---beginning-re-with-jadx)を参照してください。
2. 今回は、リソースタブを展開すると、このAPKには`lib/`ディレクトリがあることがわかります。このAPKのネイティブライブラリはデフォルトのCPUパスにあります。
3. 宣言されたネイティブメソッドを特定します。jadxで検索し、宣言されたネイティブメソッドをリストアップします。2つあるはずです。
4. 宣言されたネイティブメソッドの周りを見て、ネイティブライブラリがどこかでロードされているかどうかを確認します。これにより、実装される関数を探すためのガイダンスが得られます。
5. 新しいディレクトリを作成し、APKをそのフォルダにコピーしてネイティブライブラリをAPKから抽出します。次に、`unzip Mediacode.APK`コマンドを実行します。APKから抽出されたすべてのファイル（`lib/`ディレクトリを含む）が表示されます。
6. 分析したいネイティブライブラリのアーキテクチャを選択します。
7. `ghidraRun`を実行してghidraを起動します。これにより、Ghidraが開きます。
8. 分析のためにネイティブライブラリを開くには、「新しいプロジェクト」、「非共有プロジェクト」を選択し、プロジェクトを保存するパスを選択し、名前を付けます。これにより、バイナリファイルをロードできるプロジェクトが作成されます。
9. プロジェクトを作成したら、コードブラウザを開くためにドラゴンアイコンを選択します。次に、「ファイル」>「ファイルのインポート」を選択してネイティブライブラリをツールにロードします。すべてのデフォルトのままで構いません。
10. 以下の画面が表示されます。[解析]を選択します。
11. 上記のリンク情報を使用して、Javaで宣言されたネイティブメソッドが呼び出されたときに実行されるネイティブライブラリ内の関数を特定します。

![Ghidra Code Browserにファイルをロードする](https://maddiestone.github.io/AndroidAppRE/images/loadingIntoGhidra.png)

![jadxで開いたMediacodeのスクリーンショット](https://maddiestone.github.io/AndroidAppRE/images/Mediacode.InJadx.png)

**解決策**

## Androidネイティブライブラリのコードをリバースエンジニアリングする - JNIEnv <a href="reversing-android-native-libraries-code---jnienv" id="reversing-android-native-libraries-code---jnienv"></a>

Androidネイティブライブラリをリバースエンジニアリングする際に、私が知る必要があると思わなかったことの1つは、`JNIEnv`についてでした。`JNIEnv`は、[JNI関数](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html)への関数ポインタの構造体です。AndroidネイティブライブラリのすべてのJNI関数は、最初の引数として`JNIEnv*`を取ります。

Androidの[JNIのヒント](https://developer.android.com/training/articles/perf-jni)ドキュメントによると：

> JNIEnvとJavaVMのCの宣言は、C++の宣言とは異なります。 "jni.h"のインクルードファイルは、CまたはC++に含まれるかどうかに応じて異なるtypedefを提供します。そのため、ヘッダファイルにJNIEnv引数を含めるのは良くありません。両方の言語で含まれるヘッダファイルに\__cplusplusの#ifdefが必要な場合は、そのヘッダ内の何かがJNIEnvを参照している場合、いくつかの追加作業が必要になるかもしれません。

以下は一部のよく使用される関数（およびJNIEnv内のオフセット）です。

* JNIEnv + 0x18: jclass (\*FindClass)(JNIEnv_, const char_);
* JNIEnv + 0x34: jint (\*Throw)(JNIEnv\*, jthrowable);
* JNIEnv + 0x70: jobject (\*NewObject)(JNIEnv\*, jclass, jmethodID, …);
* JNIEnv + 0x84: jobject (\*NewObject)(JNIEnv\*, jclass, jmethodID, …);
* JNIEnv + 0x28C: jstring (\*NewString)(JNIEnv_, const jchar_, jsize);
* JNIEnv + 0x35C: jint (\*RegisterNatives)(JNIEnv_, jclass, const JNINativeMethod_, jint);

Androidネイティブライブラリを分析する際に、JNIEnvの存在は次のことを意味します。

1. JNIネイティブ関数の場合、引数は2つずつシフトされます。最初の引数は常にJNIEnv\*です。2番目の引数は、関数が実行されるべきオブジェクトです。静的なネイティブメソッド（Javaの宣言にstaticキーワードがある）の場合、これはNULLになります。
2. ディスアセンブリには間接分岐が頻繁に表示されます。これは、コードがJNIEnv\*ポインタにオフセットを追加し、その場所の関数ポインタを参照し、関数に分岐するためです。

以下は、JNIEnv構造体のC実装の[スプレッドシート](https://docs.google.com/spreadsheets/d/1yqjFaY7mqyVIDs5jNjGLT-G8pUaRATzHWGFUgpdJRq8/edit?usp=sharing)です。異なるオフセットにある関数ポインタを知るためのものです。

実
幸いなことに、これを手動で行う必要なく、JNI関数を取得する方法があります！GhidraとIDA Proの両方のデコンパイラでは、JNI関数の最初の引数を`JNIEnv *`型に再入力すると、自動的に呼び出されるJNI関数を識別します。IDA Proでは、これはそのまま機能します。Ghidraでは、最初にJNIの型（jni.hファイルまたはjni.hファイルのGhidraデータタイプアーカイブ）をロードする必要があります。簡単にするために、Ayrxによって作成され、[ここ](https://github.com/Ayrx/JNIAnalyzer/blob/master/JNIAnalyzer/data/jni_all.gdt)で利用可能なGhidra Data Typesアーカイブ（gdt）からJNIの型をロードします。簡単のため、このファイルはVMの`~/jni_all.gdt`にあります。

Ghidraで使用するためにこれをロードするには、データタイプマネージャーウィンドウで、右下隅の矢印をクリックして「Open File Archive」を選択します。

![Open File Archiveメニューのスクリーンショット](https://maddiestone.github.io/AndroidAppRE/images/OpenArchive.png)

次に、`jni_all.gdt`ファイルを選択してロードします。ロードされると、以下のようにデータタイプマネージャーリストにjni_allが表示されます。

![データタイプマネージャーにロードされたjni_allのスクリーンショット](https://maddiestone.github.io/AndroidAppRE/images/LoadedInDataTypeManager.png)

これがGhidraでロードされたら、デコンパイラで任意の引数の型を選択し、「Retype Variable」を選択します。新しい型をJNIEnv \*に設定します。これにより、デコンパイラはポインタからのオフセットではなく、呼び出されるJNIFunctionsの名前を表示するようになります。

![引数がJNIEnv\*に再入力された後のJNI関数名のスクリーンショット](https://maddiestone.github.io/AndroidAppRE/images/RetypedToJNIEnv.png)

### Exercise #6 - ネイティブ関数を見つけてリバースエンジニアリングする <a href="exercise-6---find-and-reverse-the-native-function" id="exercise-6---find-and-reverse-the-native-function"></a>

これまでのスキルを組み合わせて、REの起点を特定し、DEXをリバースエンジニアリングし、ネイティブコードをリバースエンジニアリングして、有害な動作をネイティブコードに移動した可能性のあるアプリケーションを分析します。サンプルは`~/samples/HDWallpaper.apk`です。

**目標**

この演習の目標は、Androidのリバースエンジニアリングのスキルをすべて組み合わせて、アプリケーション全体（DEXとネイティブコード）を分析することです。

**演習のコンテキスト**

あなたはAndroidアプリケーションのマルウェアアナリストです。このサンプルがプレミアムSMS詐欺を行っている可能性があることに懸念を抱いています。つまり、ユーザーの同意や開示なしにプレミアム電話番号にSMSを送信している可能性があります。マルウェアとしてフラグを立てるために、Androidアプリケーションが以下の条件を満たしているかどうかを判断する必要があります。

1. SMSメッセージを送信しているかどうか、および
2. そのSMSメッセージがプレミアム番号に送信されているかどうか、および
3. 明白な開示があるかどうか、および
4. ユーザーの同意後にのみプレミアム番号にSMSメッセージが送信されているかどうか。

**手順**

進んでリバースエンジニアリングを行ってください！

**解決策**


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ企業で働いていますか？ HackTricksであなたの会社を宣伝したいですか？または、PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロードしたりしたいですか？ [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！**

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[NFT](https://opensea.io/collection/the-peass-family)のコレクション

- [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**をフォローしてください。**

- **ハッキングのトリックを共有するには、[hacktricksリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudリポジトリ](https://github.com/carlospolop/hacktricks-cloud)にPRを提出してください。**

</details>
