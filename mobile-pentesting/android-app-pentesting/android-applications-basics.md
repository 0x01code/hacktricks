# Conceptos B치sicos de Aplicaciones Android

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan m치s para poder solucionarlas m치s r치pido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en todo tu stack tecnol칩gico, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru칠balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Modelo de Seguridad de Android

**Hay dos capas:**

* El **SO**, que mantiene las aplicaciones instaladas aisladas unas de otras.
* La **aplicaci칩n en s칤**, que permite a los desarrolladores **exponer ciertas funcionalidades** y configura las capacidades de la aplicaci칩n.

### Separaci칩n de UID

**A cada aplicaci칩n se le asigna un ID de Usuario espec칤fico**. Esto se hace durante la instalaci칩n de la app para que **la app solo pueda interactuar con archivos propiedad de su ID de Usuario o archivos compartidos**. Por lo tanto, solo la propia app, ciertos componentes del SO y el usuario root pueden acceder a los datos de la app.

### Compartici칩n de UID

**Dos aplicaciones pueden configurarse para usar el mismo UID**. Esto puede ser 칰til para compartir informaci칩n, pero si una de ellas se ve comprometida, los datos de ambas aplicaciones estar치n comprometidos. Por eso se **desaconseja** este comportamiento.\
**Para compartir el mismo UID, las aplicaciones deben definir el mismo valor `android:sharedUserId` en sus manifiestos.**

### Aislamiento (Sandboxing)

El **Sandbox de Aplicaciones Android** permite ejecutar **cada aplicaci칩n** como un **proceso separado bajo un ID de usuario separado**. Cada proceso tiene su propia m치quina virtual, por lo que el c칩digo de una app se ejecuta aislado de otras apps.\
Desde Android 5.0(L) se aplica **SELinux**. B치sicamente, SELinux deniega todas las interacciones de procesos y luego crea pol칤ticas para **permitir solo las interacciones esperadas entre ellos**.

### Permisos

Cuando instalas una **app y esta pide permisos**, la app est치 solicitando los permisos configurados en los elementos **`uses-permission`** en el archivo **AndroidManifest.xml**. El elemento **uses-permission** indica el nombre del permiso solicitado dentro del **atributo name**. Tambi칠n tiene el atributo **maxSdkVersion** que deja de pedir permisos en versiones superiores a la especificada.\
Nota que las aplicaciones de android no necesitan pedir todos los permisos al principio, tambi칠n pueden **pedir permisos din치micamente** pero todos los permisos deben estar **declarados** en el **manifiesto.**

Cuando una app expone funcionalidad, puede limitar el **acceso solo a apps que tienen un permiso especificado**.\
Un elemento de permiso tiene tres atributos:

* El **nombre** del permiso
* El atributo **permission-group**, que permite agrupar permisos relacionados.
* El **protection-level** que indica c칩mo se otorgan los permisos. Hay cuatro tipos:
  * **Normal**: Usado cuando no hay **amenazas conocidas** para la app. El usuario **no necesita aprobarlo**.
  * **Peligroso (Dangerous)**: Indica que el permiso otorga a la aplicaci칩n solicitante alg칰n **acceso elevado**. **Se solicita a los usuarios que los aprueben**.
  * **Firma (Signature)**: Solo **apps firmadas por el mismo certificado que el** que exporta el componente pueden recibir permiso. Este es el tipo de protecci칩n m치s fuerte.
  * **FirmaOSistema (SignatureOrSystem)**: Solo **apps firmadas por el mismo certificado que el** que exporta el componente o **apps que se ejecutan con acceso a nivel de sistema** pueden recibir permisos

## Aplicaciones Preinstaladas

Estas apps generalmente se encuentran en los directorios **`/system/app`** o **`/system/priv-app`** y algunas de ellas est치n **optimizadas** (puede que ni siquiera encuentres el archivo `classes.dex`). Estas aplicaciones valen la pena revisarlas porque a veces est치n **ejecut치ndose con demasiados permisos** (como root).

* Las que vienen con la **ROM** del **AOSP** (Proyecto de C칩digo Abierto de Android)
* A침adidas por el **fabricante del dispositivo**
* A침adidas por el proveedor de **telefon칤a m칩vil** (si se compr칩 a trav칠s de ellos)

## Rooting

Para obtener acceso root en un dispositivo android f칤sico generalmente necesitas **explotar** 1 o 2 **vulnerabilidades** que suelen ser **espec칤ficas** para el **dispositivo** y **versi칩n**.\
Una vez que el exploit ha funcionado, generalmente se copia el binario `su` de Linux en una ubicaci칩n especificada en la variable de entorno PATH del usuario, como `/system/xbin`.

Una vez configurado el binario su, se utiliza otra aplicaci칩n de Android para interactuar con el binario `su` y **procesar solicitudes de acceso root** como **Superuser** y **SuperSU** (disponibles en Google Play store).

{% hint style="danger" %}
Nota que el proceso de rooting es muy peligroso y puede da침ar severamente el dispositivo
{% endhint %}

### ROMs

Es posible **reemplazar el SO instalando un firmware personalizado**. Haciendo esto es posible extender la utilidad de un dispositivo antiguo, eludir restricciones de software o acceder al c칩digo m치s reciente de Android.\
**OmniROM** y **LineageOS** son dos de los firmwares m치s populares para usar.

Nota que **no siempre es necesario rootear el dispositivo** para instalar un firmware personalizado. **Algunos fabricantes permiten** el desbloqueo de sus gestores de arranque de una manera bien documentada y segura.

### Implicaciones

Una vez que un dispositivo est치 rooteado, cualquier app podr칤a solicitar acceso como root. Si una aplicaci칩n maliciosa lo obtiene, tendr치 acceso a casi todo y podr치 da침ar el tel칠fono.

## Fundamentos de la Aplicaci칩n Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

Esta introducci칩n est치 tomada de [https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html](https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html)

### Revisi칩n de Fundamentos <a href="#fundamentals-review" id="fundamentals-review"></a>

* Las aplicaciones Android est치n en el _formato de archivo APK_. **APK es b치sicamente un archivo ZIP**. (Puedes cambiar la extensi칩n del archivo a .zip y usar unzip para abrirlo y ver su contenido.)
* Contenidos del APK (No exhaustivo)
  * **AndroidManifest.xml**
  * resources.arsc/strings.xml
  * resources.arsc: un archivo que contiene recursos precompilados, como XML binario, por ejemplo.
  * res/xml/files\_paths.xml
  * META-INF/
    * 춰El certificado vive aqu칤!
  * **classes.dex**
    * Bytecode Dalvik para la aplicaci칩n en formato de archivo DEX. **Este es el c칩digo Java (o Kotlin) compilado** que la aplicaci칩n ejecutar치 por defecto.
  * lib/
    * Las bibliotecas nativas para la aplicaci칩n, por defecto, 춰viven aqu칤! Bajo el directorio lib/, est치n los directorios espec칤ficos de la CPU.
    * `armeabi`: c칩digo compilado solo para procesadores basados en ARM
    * `armeabi-v7a`: c칩digo compilado solo para procesadores basados en ARMv7 y superiores
    * `x86`: c칩digo compilado para X86
    * `mips`: c칩digo compilado solo para procesadores MIPS
  * assets/
    * Cualquier otro archivo que pueda ser necesario para la app.
    * Bibliotecas nativas adicionales o archivos DEX pueden estar incluidos aqu칤. Esto puede suceder especialmente cuando los autores de malware quieren intentar "ocultar" c칩digo adicional, nativo o Dalvik, al no incluirlo en las ubicaciones predeterminadas.
  * res/
    * el directorio que contiene recursos no compilados en resources.arsc

### **Dalvik & Smali**

La mayor칤a de las aplicaciones Android est치n escritas en Java. Kotlin tambi칠n es compatible e interoperable con Java. Para simplificar, por el resto de este taller, cuando me refiera a "Java", puedes asumir que me refiero a "Java o Kotlin". **En lugar de que el c칩digo Java se ejecute en la M치quina Virtual de Java** (JVM) como las aplicaciones de escritorio, en Android, el **Java se compila al formato de bytecode \_Dalvik Executable (DEX)**\_\*\*.\*\* Para versiones anteriores de Android, el bytecode era traducido por la m치quina virtual Dalvik. Para versiones m치s recientes de Android, se utiliza el Android Runtime (ART).\
Si los desarrolladores escriben en Java y el c칩digo se compila a bytecode DEX, para la ingenier칤a inversa, trabajamos en la direcci칩n opuesta.\
\\

![Diagrama de flujo del proceso del desarrollador. Java a bytecode DEX](https://maddiestone.github.io/AndroidAppRE/images/DevelopersFlow.jpg)

![Diagrama de flujo del proceso del ingeniero inverso. Bytecode DEX a SMALI a Java descompilado](https://maddiestone.github.io/AndroidAppRE/images/ReversersFlow.jpg)

**Smali es la versi칩n legible por humanos del bytecode Dalvik**. T칠cnicamente, Smali y baksmali son los nombres de las herramientas (ensamblador y desensamblador, respectivamente), pero en Android, a menudo usamos el t칠rmino "Smali" para referirnos a las instrucciones. Si has hecho ingenier칤a inversa o arquitectura inform치tica en c칩digo compilado C/C++. **SMALI es como el lenguaje ensamblador: entre el c칩digo fuente de alto nivel y el bytecode**.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan m치s para poder solucionarlas m치s r치pido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en todo tu stack tecnol칩gico, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru칠balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Intents

Los Intents son el principal medio por el cual las aplicaciones Android se comunican entre sus componentes o con otras apps. Estos objetos de mensaje tambi칠n pueden llevar datos entre apps o componentes, de manera similar a c칩mo se utilizan las solicitudes GET/POST en las comunicaciones HTTP.

Entonces, un Intent es b치sicamente un **mensaje que se pasa entre componentes**. Los Intents **pueden dirigirse** a componentes o apps espec칤ficas, **o pueden enviarse sin un destinatario espec칤fico**.\
Para ser simples, los Intents pueden usarse:

* Para iniciar una Actividad, abriendo t칤picamente una interfaz de usuario para una app
* Como difusiones para informar al sistema y a las apps de cambios
* Para iniciar, detener y comunicarse con un servicio en segundo plano
* Para acceder a datos a trav칠s de ContentProviders
* Como callbacks para manejar eventos

Una implementaci칩n incorrecta podr칤a resultar en la fuga de datos, funciones restringidas siendo llamadas y la manipulaci칩n del flujo del programa.

### Intent-Filter

Un Intent Filter especifica **los tipos de Intents a los que puede responder una actividad, servicio o Broadcast Receiver**. Especifica lo que una actividad o servicio puede hacer y qu칠 tipos de difusiones puede manejar un Receiver. Permite que el componente correspondiente reciba Intents del tipo declarado. Los Intent Filters se definen t칤picamente **a trav칠s del archivo AndroidManifest.xml**. Para **Broadcast Receiver** tambi칠n es posible definirlos en **c칩digo**. Un Intent Filter se define por su categor칤a, acci칩n y filtros de datos. Tambi칠n puede contener metadatos adicionales.

En Android, una actividad/servicio/content provider/broadcast receiver es **p칰blico** cuando **`exported`** est치 configurado en **`true`** pero un componente es **tambi칠n p칰blico** si el **manifiesto especifica un Intent filter** para 칠l. Sin embargo,\
los desarrolladores pueden **hacer expl칤citamente privados los componentes** (independientemente de cualquier filtro de intent)\
configurando el atributo \*\* `exported` a `false`\*\* para cada componente en el archivo del manifiesto.\
Los desarrolladores tambi칠n pueden configurar el atributo **`permission`** para **requerir cierto permiso para acceder** al componente, restringiendo as칤 el acceso al componente.

### Intents Impl칤citos

Los Intents se crean program치ticamente utilizando un constructor de Intent:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
El **Action** del intent previamente declarado es **ACTION\_SEND** y el **Extra** es un **Uri** mailto (el Extra es la informaci칩n adicional que el intent espera).

Este intent debe declararse dentro del manifiesto como en el siguiente ejemplo:
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Un intent-filter necesita coincidir con la **acci칩n**, **datos** y **categor칤a** para recibir un mensaje.

El proceso de "Resoluci칩n de Intent" determina qu칠 aplicaci칩n debe recibir cada mensaje. Este proceso considera el **atributo de prioridad**, que se puede establecer en la **declaraci칩n del intent-filter**, y **se seleccionar치 el que tenga la mayor prioridad**. Esta prioridad se puede establecer entre -1000 y 1000 y las aplicaciones pueden usar el valor `SYSTEM_HIGH_PRIORITY`. Si surge un **conflicto**, aparece una ventana de "elecci칩n" para que el **usuario pueda decidir**.

### Intents Expl칤citos

Un intent expl칤cito especifica el nombre de la clase al que est치 dirigido:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
En otras aplicaciones para acceder al intent previamente declarado puedes usar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Estos permiten que otras aplicaciones **realicen acciones en nombre de tu aplicaci칩n**, utilizando la identidad y permisos de tu app. Al construir un Pending Intent se debe **especificar un intent y la acci칩n a realizar**. Si el **intent declarado no es Expl칤cito** (no declara qu칠 intent puede llamarlo) una **aplicaci칩n maliciosa podr칤a realizar la acci칩n declarada** en nombre de la app v칤ctima. Adem치s, **si no se especifica una acci칩n**, la aplicaci칩n maliciosa podr치 realizar **cualquier acci칩n en nombre de la v칤ctima**.

### Broadcast Intents

A diferencia de los intents anteriores, que solo son recibidos por una app, los broadcast intents **pueden ser recibidos por m칰ltiples aplicaciones**. Sin embargo, desde la versi칩n de API 14, es **posible especificar la aplicaci칩n que debe recibir** el mensaje usando Intent.set Package.

Alternativamente, tambi칠n es posible **especificar un permiso al enviar el broadcast**. La aplicaci칩n receptora necesitar치 tener ese permiso.

Hay **dos tipos** de Broadcasts: **Normal** (asincr칩nico) y **Ordenado** (sincr칩nico). El **orden** se basa en la **prioridad configurada dentro del elemento receptor**. **Cada app puede procesar, retransmitir o descartar el Broadcast.**

Es posible **enviar** un **broadcast** utilizando la funci칩n **`sendBroadcast(intent, receiverPermission)`** de la clase `Context`.\
Tambi칠n podr칤as usar la funci칩n **`sendBroadcast`** del **`LocalBroadCastManager`** asegura que el **mensaje nunca salga de la app**. Usando esto ni siquiera necesitar치s exportar un componente receptor.

### Sticky Broadcasts

Este tipo de Broadcasts **puede ser accedido mucho tiempo despu칠s de haber sido enviado**.\
Fueron obsoletos en el nivel de API 21 y se recomienda **no usarlos**.\
**Permiten que cualquier aplicaci칩n husmee los datos, pero tambi칠n los modifique.**

Si encuentras funciones que contienen la palabra "sticky" como **`sendStickyBroadcast`** o **`sendStickyBroadcastAsUser`**, **verifica el impacto e intenta eliminarlas**.

## Deep links / Esquemas de URL

**Los deep links permiten activar un Intent a trav칠s de una URL**. Una aplicaci칩n puede declarar un **esquema de URL** dentro de una actividad para que cada vez que el dispositivo Android intente **acceder a una direcci칩n usando ese esquema** se llame a la actividad de la aplicaci칩n:

![](<../../.gitbook/assets/image (214).png>)

En este caso el esquema es `myapp://` (nota tambi칠n la **`categor칤a BROWSABLE`**)

Si dentro del `intent-filter` encuentras algo como esto:

![](<../../.gitbook/assets/image (263).png>)

Entonces, est치 esperando algo como `http://www.example.com/gizmos`

Si encuentras algo como esto:

![](<../../.gitbook/assets/image (262).png>)

Significar치 que est치 esperando una URL que comience con `example://gizmos`\
En este caso podr칤as intentar abusar de la funcionalidad creando una web con los siguientes payloads. Intentar치 navegar a p치ginas arbitrarias y tratar de ejecutar JS:
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Para encontrar el **c칩digo que se ejecutar치 en la App**, ve a la actividad llamada por el deeplink y busca la funci칩n **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Aprende c칩mo [llamar a deep links sin usar p치ginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Lenguaje de Definici칩n de Interfaz de Android

El **Lenguaje de Definici칩n de Interfaz de Android** (AIDL) te permite definir la interfaz de programaci칩n que tanto el cliente como el servicio acuerdan para **comunicarse entre s칤 utilizando la comunicaci칩n entre procesos** (IPC). En Android, **un proceso normalmente no puede acceder a la memoria de otro proceso**. Por lo tanto, para comunicarse, necesitan descomponer sus objetos en primitivas que el **sistema operativo** pueda entender y trasladar los objetos a trav칠s de ese l칤mite por ti. El c칩digo para hacer ese traslado es tedioso de escribir, por lo que Android lo maneja por ti con AIDL.

Los servicios que utilizan AIDL se conocen como **Servicios Vinculados**. En la clase del Servicio encontrar치s el m칠todo **`onBind`**. Aqu칤 es **donde comienza la interacci칩n**, por lo que es la parte inicial del c칩digo a revisar en busca de posibles vulnerabilidades.

Un servicio vinculado es el servidor en una interfaz cliente-servidor. **Permite que componentes (como actividades) se vinculen al servicio, env칤en solicitudes, reciban respuestas y realicen comunicaci칩n entre procesos** (IPC). Un servicio vinculado normalmente solo existe mientras sirve a otro componente de la aplicaci칩n y no se ejecuta en segundo plano indefinidamente.

### Messenger

Un Messenger es otro tipo de mecanismo IPC. Dado que el **Messenger tambi칠n es un "Servicio Vinculado"**, los datos pasados desde la aplicaci칩n cliente tambi칠n se procesan a trav칠s del m칠todo `onBind`. Por lo tanto, la revisi칩n del c칩digo debe comenzar en este m칠todo y debes buscar la invocaci칩n de funcionalidades sensibles o el manejo inseguro de datos.

### Binder

Es raro encontrar una clase Binder invocada directamente ya que es mucho m치s f치cil usar AIDL (que abstrae la clase Binder). Sin embargo, es bueno saber que **Binder es un controlador a nivel de kernel que mueve datos de la memoria de un proceso a la de otro** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Componentes

Estos incluyen: **Actividades, Servicios, Receptores de Difusi칩n y Proveedores.**

### Actividad de Inicio y otras actividades

Una **actividad de Android** es una pantalla de la interfaz de usuario de la **app de Android**. De esa manera, una **actividad de Android** es muy similar a las ventanas en una aplicaci칩n de escritorio. Una **app de Android** puede contener una o m치s actividades, es decir, una o m치s pantallas.

La **actividad de inicio** es lo que la mayor칤a de las personas consideran como el **punto de entrada** a una aplicaci칩n de Android. La actividad de inicio es la actividad que se inicia cuando un usuario hace clic en el 칤cono de una aplicaci칩n. Puedes determinar la actividad de inicio mirando el manifiesto de la aplicaci칩n. La actividad de inicio tendr치 los siguientes intentos MAIN y LAUNCHER listados.

Ten en cuenta que no todas las aplicaciones tendr치n una actividad de inicio, especialmente las aplicaciones sin una UI. Ejemplos de aplicaciones sin UI (y por lo tanto sin actividad de inicio) son aplicaciones preinstaladas que realizan servicios en segundo plano, como el buz칩n de voz.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Las Activities pueden ser exportadas permitiendo que otros procesos en el dispositivo inicien la activity. Por defecto, no est치n exportadas, pero puedes exportarlas configurando:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Tenga en cuenta que la capacidad de **bypass activity protections no siempre es una vulnerabilidad**, necesita verificar a qu칠 datos ha obtenido acceso.\
Adem치s, **algunas actividades devuelven datos al llamador**. En estos escenarios, necesita buscar el m칠todo **`setResult`** y verificar los datos que se pasan al par치metro Intent. **Si son datos sensibles, podr칤a tener una vulnerabilidad de fuga de informaci칩n** y es explotable con aplicaciones capaces de comunicarse con la Actividad.

**El c칩digo de una actividad comienza con el m칠todo `onCreate`.**

### Subclase de Aplicaci칩n

Las aplicaciones Android pueden definir una **subclase** de [Application](https://developer.android.com/reference/android/app/Application). Las aplicaciones pueden, pero no tienen que definir una subclase personalizada de Application. Si una aplicaci칩n Android define una subclase de Application, **esta clase se instancia antes que cualquier otra clase en la aplicaci칩n**.

Si el m칠todo **`attachBaseContext`** est치 definido en la subclase de Application, se llama primero, antes del m칠todo **`onCreate`**.

### Servicios

Los [Services](https://developer.android.com/guide/components/services) **funcionan en segundo plano sin una interfaz de usuario (UI).** Se utilizan para realizar **procesos de larga duraci칩n, incluso si el usuario comienza a utilizar una aplicaci칩n diferente**.

Hay una mir칤ada de formas en que se pueden iniciar y, por lo tanto, son un punto de entrada para aplicaciones. La forma predeterminada en que un servicio puede iniciarse como punto de entrada a una aplicaci칩n es a trav칠s de **Intents**.

Cuando se llama al m칠todo **`startService`** para iniciar un Servicio, se ejecuta el m칠todo **`onStart`** en el Servicio. Funcionar치 indefinidamente hasta que se llame al m칠todo **`stopService`**. Si el servicio solo es necesario mientras el cliente est치 conectado, el cliente debe "vincularse" a 칠l utilizando el m칠todo **`bindService`**.

Para un **servicio vinculado** (ver secci칩n anterior), los datos se pasar치n al m칠todo **`onBind`**.

Por ejemplo, un servicio podr칤a reproducir m칰sica en segundo plano mientras el usuario est치 en una aplicaci칩n diferente, o podr칤a obtener datos a trav칠s de la red sin bloquear la interacci칩n del usuario con una actividad.

Un **servicio puede ser exportado lo que permite a otros procesos en el dispositivo iniciar el servicio**. Por defecto los servicios no se exportan pero se puede configurar en el Manifiesto:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

Los Broadcasts pueden considerarse un sistema de mensajer칤a y **los receptores de broadcast son los oyentes**. Si una aplicaci칩n ha registrado un receptor para un broadcast espec칤fico, el c칩digo en ese receptor se ejecuta cuando el sistema env칤a el broadcast. Tenga en cuenta que en este caso **varias aplicaciones pueden recibir el mismo mensaje**.

Hay **2 formas** en que una aplicaci칩n puede **registrar un receptor**: en el **Manifiesto de la aplicaci칩n o registrado din치micamente** en el c칩digo de la aplicaci칩n utilizando la llamada a la API **`registerReceiver`**. En el manifiesto, puedes limitar los broadcasts que aceptas mediante el **uso de permisos dentro del elemento receptor**. Cuando se define **din치micamente**, puedes **pasar el permiso al m칠todo `registerReceiver`**.

En ambos casos, para registrar el receptor, se establecen los **filtros de intenci칩n para el receptor**. Estos filtros de intenci칩n son los broadcasts que deben activar el receptor.

Cuando se env칤an los broadcasts espec칤ficos para los que se ha registrado el receptor, se **ejecuta** **`onReceive`** en la clase BroadcastReceiver.

Una aplicaci칩n puede registrar un receptor para el mensaje de bater칤a baja, por ejemplo, y cambiar su comportamiento en base a esa informaci칩n.

Los Broadcasts pueden ser **asincr칩nicos** (todos los receptores lo reciben) o **sincr칩nicos** (el broadcast se recibe de manera ordenada en base a la prioridad establecida para recibirlo).

{% hint style="danger" %}
**Tenga en cuenta que cualquier aplicaci칩n puede establecerse como m치xima prioridad para recibir un Broadcast.**
{% endhint %}

Para **examinar** el **c칩digo** implementado en un BroadcastReceiver, necesita buscar el m칠todo **`onReceive`** de la clase del receptor.\
Tenga en cuenta que **los Broadcasts Ordenados pueden descartar el Intent recibido o incluso modificarlo** utilizando uno de los m칠todos setter. Por lo tanto, los **receptores deben validar los datos**.

### Content Provider

Los Content Providers son la forma en que las **aplicaciones comparten datos estructurados**, como bases de datos relacionales. Por lo tanto, es muy importante usar **permisos** y establecer el nivel de protecci칩n adecuado para protegerlos.\
Los Content Providers pueden usar los atributos **`readPermission`** y **`writePermission`** para especificar qu칠 permisos debe tener una aplicaci칩n. **Estos permisos tienen prioridad sobre el atributo de permiso**.\
Adem치s, tambi칠n pueden **permitir excepciones temporales** configurando **`grantUriPermission`** en verdadero y luego configurando los par치metros apropiados en el elemento **`grant-uri-permission`** dentro del elemento del proveedor en el archivo del manifiesto.

El **`grant-uri-permission`** tiene tres atributos: path, pathPrefix y pathPattern:

* **path**: Permite especificar la ruta completa a excluir
* **pathPrefix**: Permite especificar el comienzo de la ruta
* **pathPattern**: Permite el uso de comodines y reemplazos simb칩licos para obtener un control m치s granular.

Es **importante validar y sanear la entrada recibida** para evitar vulnerabilidades potenciales como la inyecci칩n SQL.

**Caracter칤sticas del Content Provider:**

* El componente Content Provider suministra datos de una aplicaci칩n a otras bajo solicitud.
* Puedes almacenar los datos en el sistema de archivos, una base de datos SQLite, en la web o cualquier otro lugar de almacenamiento persistente al que tu aplicaci칩n pueda acceder.
* A trav칠s del content provider, otras aplicaciones pueden consultar o incluso modificar los datos (si el content provider lo permite).
* Content Provider es 칰til en casos en que una aplicaci칩n quiere compartir datos con otra aplicaci칩n.
* Es muy similar a las bases de datos y tiene cuatro m칠todos.
* insert()
* update()
* delete()
* query()

**FileProvider**

Este es un tipo de Content Provider que **compartir치 archivos** desde una carpeta. Puedes declarar un file provider as칤:
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Tenga en cuenta el atributo **`android:exported`** porque si es **`true`**, las aplicaciones externas podr치n acceder a las carpetas compartidas.\
Observe que la configuraci칩n `android:resource="@xml/filepaths"` est치 indicando que el archivo _res/xml/filepaths.xml_ contiene la configuraci칩n de **qu칠 carpetas** este **FileProvider** va a **compartir**. Este es un ejemplo de c칩mo indicar compartir una carpeta en ese archivo:
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Compartir algo como **`path="."`** podr칤a ser **peligroso** incluso si el proveedor no est치 exportado si hay otra vulnerabilidad en alguna parte del c칩digo que intent칩 acceder a este proveedor.\
Podr칤as **acceder** a una **imagen** dentro de esa carpeta con `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

El elemento `<paths>` puede tener m칰ltiples hijos, cada uno especificando un directorio diferente para compartir. Adem치s del elemento **`<files-path>`**, puedes usar el elemento **`<external-path>`** para compartir directorios en **almacenamiento externo**, y el elemento **`<cache-path>`** para compartir directorios en tu **directorio de cach칠 interno**.\
[Para m치s informaci칩n sobre atributos espec칤ficos de proveedores de archivos, haz clic aqu칤.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[M치s informaci칩n sobre FileProviders aqu칤](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

Los WebViews son efectivamente **navegadores web** incrustados en aplicaciones Android.\
El contenido de los WebViews puede provenir de sitios remotos o ser archivos incluidos en la aplicaci칩n.\
Los WebViews son **vulnerables a las mismas vulnerabilidades que afectan a cualquier navegador web**. Sin embargo, hay algunas **configuraciones** que pueden ser 칰tiles para **limitar** la **superficie de ataque**.

Hay dos tipos de WebViews en Android:

* El **WebViewClient**, m치s adecuado para la renderizaci칩n simple de HTML. Este no ejecutar치 la funci칩n de alerta JS. Por lo tanto, las pruebas de XSS utilizando esa funci칩n ser치n inv치lidas.
* El **WebChrome** **client**, es un navegador Chrome.

Ten en cuenta que los **navegadores WebView no tienen acceso a las cookies del navegador nativo**.

Para cargar una URL o archivo es posible usar las funciones **`loadUrl`**, **`loadData`** o **`loadDataWithBaseURL`**. **Es importante acceder solo a URLs saneadas.**\
La seguridad de WebView se puede configurar a trav칠s del objeto **`WebSettings`**.\
Por ejemplo, la ejecuci칩n de c칩digo JS se puede deshabilitar usando el m칠todo **`setJavaScriptEnabled`** con el valor **`false`**. Esto eliminar치 la posibilidad de un **XSS** y otras vulnerabilidades relacionadas con JS.

La funcionalidad "Bridge" de JavaScript **inyecta objetos Java en un WebView haci칠ndolos accesibles a JS**. Desde Android 4.2 los m칠todos deben estar anotados con **`@JavascriptInterface`** para ser accesibles a JavaScript.

Si se pasa **`true`** a **`setAllowContentAccess`**, **los WebViews podr치n acceder a los Proveedores de Contenido** a trav칠s del esquema **`content://`**. Esto obviamente representa un riesgo de seguridad. Ten en cuenta que si se otorga este acceso, es muy importante **asegurarse** de que la URL **`content://`** sea **segura**.

Por defecto, los archivos locales pueden ser accedidos por WebViews a trav칠s de URLs file://, pero hay varias formas de prevenir este comportamiento:

* Pasar **`false`** a **`setAllowFileAccess`**, previene el acceso al sistema de archivos con la excepci칩n de los activos a trav칠s de `file:///android_asset` _y_ `file:///android_res`. Estas rutas deben usarse solo para datos no sensibles (como im치genes), por lo que esto deber칤a ser seguro.
* El m칠todo **`setAllowFileAccess`** indica si una ruta de una URL `file://` deber칤a poder acceder al contenido de otras URLs del esquema de archivo.
* El m칠todo **`setAllowUniversalAccessFromFileURLs`** indica si una ruta de una URL `file://` deber칤a poder acceder al contenido de cualquier origen.

## Otros componentes de la aplicaci칩n

### **Firma de Aplicaciones**

* Android requiere que **todas las aplicaciones est칠n firmadas digitalmente con un certificado** antes de que puedan ser instaladas. Android utiliza este certificado para identificar al autor de una aplicaci칩n.
* Para ejecutar la aplicaci칩n en el dispositivo, debe estar firmada. Cuando se instala la aplicaci칩n en un dispositivo, el **gestor de paquetes verifica** si la aplicaci칩n ha sido correctamente firmada con el certificado en el archivo apk o no.
* La aplicaci칩n puede estar autofirmada o puede ser firmada a trav칠s de una CA.
* La firma de aplicaciones asegura que una aplicaci칩n no pueda acceder a otra aplicaci칩n excepto a trav칠s de IPC bien definido y tambi칠n que se pase sin modificaciones al dispositivo.

### **Verificaci칩n de Aplicaciones**

* Android 4.2 y versiones posteriores admiten la verificaci칩n de aplicaciones. Los usuarios pueden optar por habilitar "Verificar aplicaciones" y tener las aplicaciones evaluadas por un verificador de aplicaciones antes de la instalaci칩n.
* La verificaci칩n de aplicaciones puede alertar al usuario si intentan instalar una aplicaci칩n que podr칤a ser da침ina; si una aplicaci칩n es especialmente mala, puede bloquear la instalaci칩n.

## Gesti칩n de Dispositivos M칩viles

MDM o Gesti칩n de Dispositivos M칩viles son suites de software que se utilizan para **asegurar el control y los requisitos de seguridad** sobre dispositivos m칩viles. Estas suites utilizan las caracter칤sticas denominadas API de Administraci칩n de Dispositivos y requieren que se instale una aplicaci칩n Android.

Generalmente, las soluciones MDM realizan funciones como imponer pol칤ticas de contrase침as, forzar el cifrado de almacenamiento y habilitar el borrado remoto de datos del dispositivo.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan m치s para que puedas solucionarlas m치s r치pido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en toda tu pila tecnol칩gica, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru칠balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
