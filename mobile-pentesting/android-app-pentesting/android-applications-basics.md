# Android 애플리케이션 기본 사항

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* HackTricks에서 **회사 광고를 보거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** 팔로우하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

가장 중요한 취약점을 찾아서 빠르게 수정할 수 있습니다. Intruder는 공격 대상 범위를 추적하고 예방적인 위협 스캔을 실행하여 API부터 웹 앱 및 클라우드 시스템까지 전체 기술 스택에서 문제를 찾습니다. [**무료로 시도해보세요**](https://www.intruder.io/?utm_source=referral&utm_campaign=hacktricks) 오늘.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Android 보안 모델

**두 가지 레이어가 있습니다:**

* **OS**: 설치된 애플리케이션을 서로 격리시킵니다.
* **애플리케이션 자체**: 개발자가 특정 기능을 노출하고 애플리케이션 기능을 구성할 수 있게 합니다.

### UID 분리

**각 애플리케이션에는 특정 사용자 ID가 할당**됩니다. 이는 앱 설치 중에 수행되므로 앱은 해당 사용자 ID 또는 공유 파일 소유자가 소유한 파일과만 상호 작용할 수 있습니다. 따라서 앱 자체, OS의 특정 구성 요소 및 루트 사용자만 앱 데이터에 액세스할 수 있습니다.

### UID 공유

**두 개의 애플리케이션은 동일한 UID를 사용하도록 구성**할 수 있습니다. 이는 정보를 공유하는 데 유용할 수 있지만, 그 중 하나가 손상되면 두 애플리케이션의 데이터가 손상됩니다. 이러한 동작은 **비권장**되기 때문입니다.\
**동일한 UID를 공유하려면 애플리케이션은 매니페스트에서 동일한 `android:sharedUserId` 값을 정의해야 합니다.**

### 샌드박싱

**Android 애플리케이션 샌드박스**는 **각 애플리케이션을 별도의 프로세스로 실행**할 수 있게 합니다. 각 프로세스에는 고유한 가상 머신이 있으므로 앱의 코드는 다른 앱과 격리된 상태에서 실행됩니다.\
Android 5.0(L)부터는 **SELinux**가 강제로 적용됩니다. 기본적으로 SELinux는 모든 프로세스 상호 작용을 거부한 다음 예상되는 상호 작용만 허용하는 정책을 생성합니다.

### 권한

앱을 설치하고 **권한을 요청**할 때, 앱은 **AndroidManifest.xml** 파일의 **`uses-permission`** 요소에 구성된 권한을 요청합니다. **uses-permission** 요소는 **name** **속성** 내에서 요청된 권한의 이름을 나타냅니다. 또한 **maxSdkVersion** 속성이 있으며, 지정된 버전보다 높은 버전에서 권한을 요청하지 않도록 합니다.\
Android 애플리케이션은 처음부터 모든 권한을 요청할 필요가 없으며, **동적으로 권한을 요청**할 수도 있지만 모든 권한은 **매니페스트**에 **선언**되어야 합니다.

앱이 기능을 노출할 때, **특정 권한을 가진 앱에만 액세스**를 제한할 수 있습니다.\
권한 요소에는 세 가지 속성이 있습니다:

* 권한의 **이름**
* 권한을 그룹화하는 **permission-group** 속성
* 권한이 부여되는 방식을 나타내는 **protection-level**. 네 가지 유형이 있습니다:
* **Normal**: 앱에 **알려진 위협이 없을 때** 사용됩니다. 사용자는 **승인을 요청받지 않습니다**.
* **Dangerous**: 권한이 요청한 애플리케이션에 **고급 액세스**를 부여합니다. **사용자에게 승인을 요청합니다**.
* **Signature**: 구성 요소를 내보내는 **동일한 인증서로 서명된 앱만** 권한을 부여할 수 있습니다. 이것은 가장 강력한 보호 수준입니다.
* **SignatureOrSystem**: 구성 요소를 내보내는 **동일한 인증서로 서명된 앱 또는 시스템 수준 액세스로 실행되는 앱만** 권한을 부여할 수 있습니다.

## 사전 설치된 애플리케이션

이러한 앱은 일반적으로 **`/system/app`** 또는 **`/system/priv-app`** 디렉토리에 있으며, 일부 앱은 **최적화**되어 있습니다(`classes.dex` 파일을 찾을 수 없을 수도 있음). 이러한 애플리케이션은 때로는 **루트 권한으로 실행**되기 때문에 권한이 너무 많은지 확인하는 것이 좋습니다.

* **AOSP**(Android OpenSource Project) **ROM**에 포함된 앱
* **장치 제조업체**에 의해 추가됨
* **휴대폰 공급업체**에 의해 추가됨(공급업체에서 구매한 경우)

## 루팅

물리적인 Android 장치에서 루트 액세스를 얻으려면 일반적으로 **장치**와 **버전**에 **특정한 취약점**을 **악용**해야 합니다.\
일단 악용이 성공하면 일반적으로 Linux `su` 이진 파일이 사용자의 PATH 환경 변수에 지정된 위치(예: `/system/xbin`)로 복사됩니다.

su 이진 파일이 구성되면 다른 Android 앱을 사용하여 `su` 이진 파일과 **루트 액세스 요청을 처리**합니다. 예를 들어 **Superuser**와 **SuperSU**(Google Play 스토어에서 사용 가능)가 있습니다.

{% hint style="danger" %}
루팅 프로세스는 매우 위험하며 장치를 심각하게 손상시킬 수
### **Dalvik & Smali**

안드로이드 개발에서 앱을 만들기 위해 **Java 또는 Kotlin**을 사용합니다. 데스크톱 앱과 달리 안드로이드는 이 코드를 **Dalvik Executable (DEX) bytecode**로 컴파일합니다. 이전에는 Dalvik 가상 머신이 이 bytecode를 처리했지만, 최신 안드로이드 버전에서는 Android Runtime (ART)가 이를 대신 처리합니다.

역공학을 위해 **Smali**가 중요해집니다. 이는 DEX bytecode의 사람이 읽을 수 있는 버전으로, 소스 코드를 bytecode 명령어로 번역하여 어셈블리 언어처럼 작동합니다. 이 문맥에서 어셈블리 및 디어셈블리 도구를 가리키는 것이 바로 Smali와 baksmali입니다.


***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

가장 중요한 취약점을 찾아서 더 빠르게 수정할 수 있습니다. Intruder는 공격 표면을 추적하고 적극적인 위협 스캔을 실행하여 API부터 웹 앱 및 클라우드 시스템까지 전체 기술 스택에서 문제를 찾습니다. [**무료로 시도해보세요**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) 오늘.


***

## Intents

Intents는 안드로이드 앱이 구성 요소 간 또는 다른 앱과 통신하는 주요 수단입니다. 이 메시지 객체는 HTTP 통신에서 GET/POST 요청이 사용되는 것과 유사하게 앱 또는 구성 요소 간에 데이터를 전달할 수도 있습니다.

따라서 Intent는 기본적으로 **구성 요소 간에 전달되는 메시지**입니다. Intent는 특정 구성 요소 또는 앱에 **직접 전송**될 수 있으며, **특정 수신자 없이 전송**될 수도 있습니다.\
간단히 말해 Intent는 다음과 같이 사용할 수 있습니다:

* 액티비티를 시작하여 앱의 사용자 인터페이스를 열기 위해
* 변경 사항을 시스템 및 앱에 알리기 위한 브로드캐스트로
* 백그라운드 서비스를 시작, 중지 및 통신하기 위해
* ContentProviders를 통해 데이터에 액세스하기 위해
* 이벤트를 처리하기 위한 콜백으로

취약하다면, **Intents를 사용하여 다양한 공격을 수행**할 수 있습니다.

### Intent-Filter

**Intent Filters**는 **액티비티, 서비스 또는 브로드캐스트 수신기가 다양한 유형의 Intents와 상호 작용하는 방법을 정의**합니다. 이러한 구성 요소의 기능을 설명하는 것으로, 수행할 수 있는 작업이나 처리할 수 있는 브로드캐스트 유형과 같은 것을 설명합니다. 이러한 필터를 선언하는 주요 위치는 **AndroidManifest.xml 파일**이지만, 브로드캐스트 수신기의 경우에는 코드로 작성하는 것도 가능합니다.

Intent Filters는 카테고리, 액션 및 데이터 필터로 구성되며, 추가 메타데이터를 포함할 수도 있습니다. 이 설정을 통해 구성 요소는 선언된 기준과 일치하는 특정 Intents를 처리할 수 있습니다.

안드로이드 구성 요소(액티비티/서비스/콘텐트 프로바이더/브로드캐스트 수신기)의 중요한 측면은 가시성 또는 **공개 상태**입니다. 구성 요소가 **`true`** 값으로 **`exported`**로 설정되거나 매니페스트에 대한 Intent Filter가 선언된 경우, 해당 구성 요소는 공개로 간주되어 다른 앱과 상호 작용할 수 있습니다. 그러나 개발자는 이러한 구성 요소를 명시적으로 비공개로 유지하여 다른 앱과의 의도하지 않은 상호 작용을 방지할 수 있습니다. 이는 매니페스트 정의에서 **`exported`** 속성을 **`false`**로 설정하여 달성할 수 있습니다.

또한, 개발자는 특정 권한을 요구함으로써 이러한 구성 요소에 대한 액세스를 보다 안전하게 제한할 수 있습니다. **`permission`** 속성을 설정하여 지정된 권한을 가진 앱만이 해당 구성 요소에 액세스할 수 있도록 강제할 수 있으며, 이를 통해 보안과 상호 작용할 수 있는 사용자를 제어할 수 있습니다.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### 암시적 인텐트

인텐트는 Intent 생성자를 사용하여 프로그래밍적으로 생성됩니다:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
이전에 선언된 인텐트의 **Action**은 **ACTION\_SEND**이고 **Extra**는 mailto **Uri**입니다 (Extra는 인텐트가 기대하는 추가 정보입니다).

이 인텐트는 다음 예시와 같이 매니페스트에 선언되어야 합니다:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
인텐트 필터는 메시지를 수신하기 위해 **액션**, **데이터** 및 **카테고리**와 일치해야 합니다.

"인텐트 해결" 프로세스는 각 메시지를 수신해야 할 앱을 결정합니다. 이 프로세스는 **우선순위 속성**을 고려하며, 이 속성은 **인텐트 필터 선언**에서 설정할 수 있으며, **더 높은 우선순위를 가진 것이 선택**됩니다. 이 우선순위는 -1000부터 1000까지 설정할 수 있으며, 애플리케이션은 `SYSTEM_HIGH_PRIORITY` 값을 사용할 수 있습니다. **충돌**이 발생하면 "선택기" 창이 나타나서 **사용자가 결정**할 수 있습니다.

### 명시적 인텐트

명시적 인텐트는 대상 클래스 이름을 지정합니다:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
다른 애플리케이션에서 이전에 선언된 인텐트에 액세스하려면 다음을 사용할 수 있습니다:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### 보류 중인 인텐트

이를 통해 다른 애플리케이션이 **귀하의 애플리케이션을 대신하여 작업을 수행**할 수 있습니다. 보류 중인 인텐트를 구성할 때는 **인텐트와 수행할 작업을 지정**해야 합니다. **명시적으로 선언된 인텐트가 아닌 경우** (어떤 인텐트가 호출할 수 있는지 선언하지 않음) 악성 애플리케이션이 피해 앱을 대신하여 선언된 작업을 수행할 수 있습니다. 또한, **작업이 지정되지 않은 경우** 악성 앱은 피해자를 대신하여 **임의의 작업을 수행**할 수 있습니다.

### 브로드캐스트 인텐트

이전 인텐트와 달리, 브로드캐스트 인텐트는 **여러 앱에서 수신**할 수 있습니다. 그러나 API 버전 14부터는 Intent.set Package를 사용하여 메시지를 **수신해야 하는 앱을 지정**할 수 있습니다.

또한, 브로드캐스트를 보낼 때 **퍼미션을 지정**할 수도 있습니다. 수신 앱은 해당 퍼미션을 가져야 합니다.

브로드캐스트에는 **두 가지 유형**이 있습니다: **일반** (비동기)과 **순서가 지정된** (동기). **순서**는 **수신자 내에서 구성된 우선순위**에 따라 결정됩니다. **각 앱은 브로드캐스트를 처리, 중계 또는 삭제**할 수 있습니다.

`Context` 클래스의 `sendBroadcast(intent, receiverPermission)` 함수를 사용하여 **브로드캐스트를 보낼 수** 있습니다.\
또한, **`LocalBroadCastManager`**의 **`sendBroadcast`** 함수를 사용하면 **메시지가 앱을 벗어나지 않습니다**. 이를 사용하면 수신자 구성 요소를 내보낼 필요조차 없습니다.

### 스티키 브로드캐스트

이 유형의 브로드캐스트는 **보낸 후에도 오랫동안 액세스할 수 있습니다**.\
이들은 API 레벨 21에서 사용 중지되었으며 **사용하지 않는 것이 권장**됩니다.\
**이들은 모든 애플리케이션이 데이터를 엿볼 수 있을 뿐만 아니라 수정할 수도 있습니다.**

**`sendStickyBroadcast`** 또는 **`sendStickyBroadcastAsUser`**와 같이 "sticky"라는 단어를 포함하는 함수를 찾으면, **영향을 확인하고 제거를 시도**해야 합니다.

## 딥 링크 / URL 스키마

Android 애플리케이션에서 **딥 링크**는 URL을 통해 직접 작업 (인텐트)을 시작하는 데 사용됩니다. 이는 활동 내에서 특정 **URL 스키마**를 선언함으로써 수행됩니다. Android 기기가 이러한 스키마를 가진 URL에 **액세스하려고 할 때**, 애플리케이션 내에서 지정된 활동이 시작됩니다.

스키마는 **`AndroidManifest.xml`** 파일에 선언되어야 합니다:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
이전 예제의 스킴은 `exampleapp://`입니다 (또한 **`category BROWSABLE`**에 유의하세요).

그런 다음 데이터 필드에서 **호스트**와 **경로**를 지정할 수 있습니다:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
웹에서 액세스하려면 다음과 같이 링크를 설정할 수 있습니다:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
앱에서 실행될 **코드를 찾으려면**, 딥링크에 의해 호출되는 액티비티로 이동하고 **`onNewIntent`** 함수를 검색하세요.

[HTML 페이지를 사용하지 않고 딥링크를 호출하는 방법](./#exploiting-schemes-deep-links)을 배워보세요.

## AIDL - Android Interface Definition Language

**Android Interface Definition Language (AIDL)**은 안드로이드 애플리케이션에서 **프로세스간 통신**(IPC)을 통해 클라이언트와 서비스 간의 통신을 용이하게 하는 것을 목적으로 설계되었습니다. 안드로이드에서는 다른 프로세스의 메모리에 직접 액세스하는 것이 허용되지 않기 때문에, AIDL은 객체를 운영체제가 이해할 수 있는 형식으로 변환하여 다른 프로세스 간의 통신을 용이하게 합니다.

### 주요 개념

- **Bound Services**: 이러한 서비스는 IPC를 위해 AIDL을 사용하여 액티비티나 컴포넌트가 서비스에 바인딩하여 요청을 수행하고 응답을 받을 수 있게 합니다. 서비스의 클래스에 있는 `onBind` 메서드는 상호작용을 시작하기 위해 중요한 역할을 하며, 취약점을 찾기 위한 보안 검토에 있어서 중요한 영역입니다.

- **Messenger**: 바운드 서비스로 작동하는 Messenger는 `onBind` 메서드를 통해 데이터 처리에 중점을 둔 IPC를 용이하게 합니다. 이 메서드를 안전하지 않은 데이터 처리나 민감한 함수의 실행 여부에 대해 주의깊게 검토해야 합니다.

- **Binder**: AIDL의 추상화로 인해 Binder 클래스의 직접적인 사용은 덜 일반적이지만, Binder는 다른 프로세스의 메모리 공간 간의 데이터 전송을 용이하게 하는 커널 수준 드라이버로 작동합니다. 더 자세한 이해를 위해 [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)에서 관련 자료를 참고할 수 있습니다.

## 컴포넌트

이에는 **액티비티, 서비스, 브로드캐스트 리시버 및 프로바이더**가 포함됩니다.

### 런처 액티비티와 다른 액티비티

안드로이드 앱에서 **액티비티**는 앱의 사용자 인터페이스의 다른 부분을 보여주는 화면과 같습니다. 앱은 여러 개의 액티비티를 가질 수 있으며, 각각은 사용자에게 고유한 화면을 제공합니다.

**런처 액티비티**는 앱의 주요 게이트웨이로, 앱 아이콘을 탭할 때 실행됩니다. 이는 앱의 매니페스트 파일에서 특정한 MAIN 및 LAUNCHER 인텐트로 정의됩니다:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
앱에는 런처 액티비티가 필요하지 않은 경우도 있습니다. 특히 백그라운드 서비스와 같이 사용자 인터페이스가 없는 경우입니다.

액티비티는 매니페스트에서 "exported"로 표시하여 다른 앱이나 프로세스에서 사용할 수 있도록 만들 수 있습니다. 이 설정은 다른 앱이 이 액티비티를 시작할 수 있게 합니다:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
그러나 다른 앱에서 액티비티에 접근하는 것은 항상 보안 위험은 아닙니다. 민감한 데이터가 부적절하게 공유되는 경우에만 문제가 발생하며, 이는 정보 누출로 이어질 수 있습니다.

액티비티의 수명 주기는 **onCreate 메서드로 시작**하여 UI를 설정하고 사용자와 상호 작용할 준비를 합니다.

### 애플리케이션 서브클래스

Android 개발에서 앱은 [Application](https://developer.android.com/reference/android/app/Application) 클래스의 **서브클래스**를 만들 수 있지만 필수는 아닙니다. 이러한 서브클래스가 정의되면 앱 내에서 가장 먼저 인스턴스화되는 클래스가 됩니다. 이 서브클래스에서 구현된 **`attachBaseContext`** 메서드는 **`onCreate`** 메서드보다 먼저 실행됩니다. 이 설정을 통해 애플리케이션이 시작되기 전에 초기화를 미리 수행할 수 있습니다.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### 서비스

[서비스](https://developer.android.com/guide/components/services)는 사용자 인터페이스 없이 작업을 실행할 수 있는 **백그라운드 작업자**입니다. 이 작업은 사용자가 다른 애플리케이션으로 전환해도 계속 실행될 수 있으므로, 서비스는 **장기간 실행되는 작업**에 중요합니다.

서비스는 다양한 방법으로 시작할 수 있으며, **인텐트**가 애플리케이션의 진입점으로 사용되는 주요 방법입니다. `startService` 메서드를 사용하여 서비스를 시작하면, `onStart` 메서드가 실행되고 `stopService` 메서드가 명시적으로 호출될 때까지 계속 실행됩니다. 또는, 서비스의 역할이 활성 클라이언트 연결에 의존하는 경우, `bindService` 메서드를 사용하여 클라이언트를 서비스에 바인딩하고 데이터를 전달하기 위해 `onBind` 메서드를 사용합니다.

서비스의 흥미로운 응용 프로그램에는 백그라운드에서 음악 재생이나 네트워크 데이터 가져오기가 포함됩니다. 또한, 서비스는 **내보내기**를 통해 동일한 장치의 다른 프로세스에서 접근할 수 있도록 만들 수 있습니다. 이는 기본 동작이 아니며, Android Manifest 파일에서 명시적으로 구성해야 합니다:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### 방송 수신기

**방송 수신기**는 메시징 시스템에서 리스너로 작동하여 여러 애플리케이션이 시스템으로부터 동일한 메시지에 응답할 수 있게 합니다. 앱은 **두 가지 주요 방법**으로 수신기를 등록할 수 있습니다: 앱의 **Manifest**를 통해 또는 앱의 코드 내에서 **동적으로** `registerReceiver` API를 사용하여. Manifest에서는 방송을 권한으로 필터링하며, 동적으로 등록된 수신기는 등록 시 권한을 지정할 수도 있습니다.

**Intent 필터**는 두 등록 방법 모두에서 중요하며, 어떤 방송이 수신기를 트리거하는지를 결정합니다. 일치하는 방송이 전송되면 수신기의 `onReceive` 메서드가 호출되어 앱이 해당에 맞게 반응할 수 있게 됩니다. 예를 들어, 배터리 부족 경고에 대한 반응으로 동작을 조정할 수 있습니다.

방송은 **비동기식**으로 전달되어 순서 없이 모든 수신기에 도달하거나, **동기식**으로 전달되어 우선순위에 따라 수신기가 방송을 받을 수 있습니다. 그러나 잠재적인 보안 위험에 유의해야 합니다. 어떤 앱이든 자신을 우선순위로 설정하여 방송을 가로챌 수 있습니다.

수신기의 기능을 이해하려면 해당 클래스 내에서 `onReceive` 메서드를 찾아보세요. 이 메서드의 코드는 수신된 Intent를 조작할 수 있으며, 특히 **순서가 지정된 방송**에서는 Intent를 수정하거나 삭제할 수 있으므로 수신기에 의한 데이터 유효성 검사의 필요성이 강조됩니다.

### 콘텐츠 제공자

**콘텐츠 제공자**는 앱 간에 **구조화된 데이터를 공유**하는 데 필수적이며, 데이터 보안을 보장하기 위해 **권한**을 구현하는 중요성을 강조합니다. 이들은 데이터베이스, 파일 시스템 또는 웹을 포함한 다양한 소스에서 데이터에 액세스할 수 있게 합니다. `readPermission` 및 `writePermission`과 같은 특정 권한은 액세스를 제어하는 데 중요합니다. 또한 앱의 Manifest에서 `grantUriPermission` 설정을 통해 일시적인 액세스를 부여할 수 있으며, `path`, `pathPrefix`, `pathPattern`과 같은 속성을 사용하여 자세한 액세스 제어를 수행할 수 있습니다.

SQL 인젝션과 같은 취약점을 방지하기 위해 입력 유효성 검사가 필수적입니다. 콘텐츠 제공자는 `insert()`, `update()`, `delete()`, `query()`와 같은 기본 작업을 지원하여 데이터 조작과 애플리케이션 간의 데이터 공유를 용이하게 합니다.

**FileProvider**는 파일을 안전하게 공유하기 위한 특수한 콘텐츠 제공자로, 폴더에 대한 액세스를 제어하기 위해 앱의 Manifest에 특정 속성으로 정의됩니다. 이는 `android:exported` 및 `android:resource`를 사용하여 폴더 구성에 대한 액세스를 제어합니다. 민감한 데이터가 노출되지 않도록 주의해야 합니다.

FileProvider에 대한 예제 Manifest 선언:

```xml
<provider
    android:name="androidx.core.content.FileProvider"
    android:authorities="com.example.myapp.fileprovider"
    android:exported="false"
    android:grantUriPermissions="true">
    <meta-data
        android:name="android.support.FILE_PROVIDER_PATHS"
        android:resource="@xml/file_paths" />
</provider>
```
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
그리고 `filepaths.xml`에서 공유 폴더를 지정하는 예시입니다:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
추가 정보는 다음을 참조하십시오:
- [Android 개발자: 콘텐츠 제공자](https://developer.android.com/guide/topics/providers/content-providers)
- [Android 개발자: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## 웹뷰

웹뷰는 안드로이드 앱 내에서 웹 또는 로컬 파일에서 콘텐츠를 가져오는 것과 같이 **미니 웹 브라우저**입니다. 일반 브라우저와 유사한 위험에 직면하지만 특정 **설정**을 통해 이러한 위험을 **줄일 수 있는 방법**이 있습니다.

안드로이드는 두 가지 주요 웹뷰 유형을 제공합니다:

- **WebViewClient**는 기본 HTML에 적합하지만 JavaScript 경고 기능을 지원하지 않아 XSS 공격을 테스트하는 방법에 영향을 줍니다.
- **WebChromeClient**는 전체 Chrome 브라우저 경험과 유사하게 작동합니다.

중요한 점은 웹뷰 브라우저가 기기의 주요 브라우저와 **쿠키를 공유하지 않는다는 것**입니다.

````loadUrl````, ````loadData````, ````loadDataWithBaseURL````과 같은 메서드를 사용하여 콘텐츠를 로드할 수 있습니다. 이러한 URL 또는 파일이 **안전하게 사용**되는지 확인하는 것이 중요합니다. 보안 설정은 ````WebSettings```` 클래스를 통해 관리할 수 있습니다. 예를 들어, ````setJavaScriptEnabled(false)````로 JavaScript를 비활성화하면 XSS 공격을 방지할 수 있습니다.

JavaScript "Bridge"를 사용하면 Java 객체가 JavaScript와 상호 작용할 수 있으며, Android 4.2 이상에서는 메서드에 ````@JavascriptInterface````를 표시하여 보안을 제공해야 합니다.

콘텐츠 액세스를 허용하면 (````setAllowContentAccess(true)````), 웹뷰가 콘텐츠 제공자에 액세스할 수 있으며, 콘텐츠 URL이 안전하다고 확인되지 않는 한 위험이 될 수 있습니다.

파일 액세스를 제어하려면:
- 파일 액세스 비활성화 (````setAllowFileAccess(false)````)는 파일 시스템에 대한 액세스를 제한하며, 특정 자산에 대해서는 예외를 허용하여 민감한 콘텐츠에만 사용되도록 보장합니다.

## 다른 앱 구성 요소 및 모바일 장치 관리

### **애플리케이션의 디지털 서명**

- 안드로이드 앱은 **디지털 서명**을 해야 하며, 설치 전에 **정품인증**을 보장합니다. 이 프로세스는 앱 식별을 위해 인증서를 사용하며, 설치 시 디바이스의 패키지 관리자에서 확인해야 합니다. 앱은 **자체 서명 또는 외부 CA에 의해 인증**될 수 있으며, 무단 액세스로부터 보호되며 배달 중에 변경되지 않도록 보장합니다.

### **강화된 보안을 위한 앱 검증**

- **Android 4.2**부터 **앱 검증**이라는 기능을 통해 사용자는 설치 전에 앱의 안전성을 확인할 수 있습니다. 이 **검증 프로세스**는 사용자에게 잠재적으로 유해한 앱에 대한 경고를 표시하거나 특히 악성 앱의 설치를 방지할 수 있어 사용자 보안을 강화합니다.

### **모바일 장치 관리 (MDM)**

- **MDM 솔루션**은 **디바이스 관리 API**를 통해 모바일 장치의 **감시 및 보안**을 제공합니다. 이를 위해 모바일 장치의 효과적인 관리와 보안을 위해 안드로이드 앱을 설치해야 합니다. 주요 기능으로는 **비밀번호 정책 강제 적용**, **저장소 암호화 강제 적용**, **원격 데이터 삭제 허용** 등이 있어 모바일 장치에 대한 포괄적인 제어와 보안을 보장합니다.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

가장 중요한 취약점을 찾아서 빠르게 수정할 수 있습니다. Intruder는 공격 대상을 추적하고 적극적인 위협 스캔을 실행하여 API부터 웹 앱 및 클라우드 시스템까지 전체 기술 스택에서 문제를 찾습니다. [**지금 무료로 사용해보세요**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks).

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왑**](https://peass.creator-spring.com)을 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
