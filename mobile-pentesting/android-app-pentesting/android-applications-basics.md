# Concetti di base delle applicazioni Android

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Modello di sicurezza Android

**Ci sono due livelli:**

* Il **SO**, che mantiene le applicazioni installate isolate l'una dall'altra.
* L'applicazione stessa, che consente agli sviluppatori di **esporre determinate funzionalit√†** e configurare le capacit√† dell'applicazione.

### Separazione UID

**A ogni applicazione viene assegnato un ID utente specifico**. Questo avviene durante l'installazione dell'app in modo che **l'app possa interagire solo con i file di propriet√† del suo ID utente o condivisi**. Pertanto, solo l'app stessa, determinati componenti del SO e l'utente root possono accedere ai dati delle app.

### Condivisione UID

**Due applicazioni possono essere configurate per utilizzare lo stesso UID**. Questo pu√≤ essere utile per condividere informazioni, ma se una di esse viene compromessa, i dati di entrambe le applicazioni saranno compromessi. Per questo motivo questo comportamento √® **sconsigliato**.\
**Per condividere lo stesso UID, le applicazioni devono definire lo stesso valore `android:sharedUserId` nei loro manifest.**

### Isolamento

Il **sandbox delle applicazioni Android** consente di eseguire **ogni applicazione** come un **processo separato sotto un ID utente separato**. Ogni processo ha la propria macchina virtuale, quindi il codice di un'app viene eseguito in isolamento da altre app.\
A partire da Android 5.0(L) **SELinux** √® obbligatorio. Fondamentalmente, SELinux nega tutte le interazioni tra processi e quindi crea delle politiche per **consentire solo le interazioni attese tra di loro**.

### Autorizzazioni

Quando si installa un'app e richiede autorizzazioni, l'app sta chiedendo le autorizzazioni configurate negli elementi **`uses-permission`** nel file **AndroidManifest.xml**. L'elemento **uses-permission** indica il nome dell'autorizzazione richiesta all'interno dell'attributo **name**. Ha anche l'attributo **maxSdkVersion** che smette di chiedere autorizzazioni su versioni superiori a quella specificata.\
Nota che le applicazioni Android non devono chiedere tutte le autorizzazioni all'inizio, possono anche **chiedere autorizzazioni dinamicamente** ma tutte le autorizzazioni devono essere **dichiarate** nel **manifest.**

Quando un'app espone funzionalit√† pu√≤ limitare l'**accesso solo alle app che hanno una determinata autorizzazione**.\
Un elemento di autorizzazione ha tre attributi:

* Il **nome** dell'autorizzazione
* L'attributo **permission-group**, che consente di raggruppare autorizzazioni correlate.
* Il **livello di protezione** che indica come vengono concesse le autorizzazioni. Ci sono quattro tipi:
* **Normale**: Usato quando non ci sono **minacce conosciute** per l'app. All'utente **non √® richiesto di approvarla**.
* **Pericoloso**: Indica che l'autorizzazione concede all'applicazione richiedente un **accesso elevato**. **Gli utenti sono invitati ad approvarle**.
* **Firma**: Solo **le app firmate dallo stesso certificato di quello** che esporta il componente possono ottenere l'autorizzazione. Questo √® il tipo di protezione pi√π forte.
* **FirmaOSystema**: Solo **le app firmate dallo stesso certificato di quello** che esporta il componente o **le app in esecuzione con accesso a livello di sistema** possono ottenere autorizzazioni

## Applicazioni preinstallate

Queste app si trovano generalmente nelle directory **`/system/app`** o **`/system/priv-app`** e alcune di esse sono **ottimizzate** (potresti non trovare nemmeno il file `classes.dex`). Queste applicazioni meritano attenzione perch√© a volte **funzionano con troppe autorizzazioni** (come root).

* Quelle fornite con il **ROM AOSP** (Android OpenSource Project)
* Aggiunte dal **produttore del dispositivo**
* Aggiunte dal **provider del telefono cellulare** (se acquistato da loro)

## Rooting

Per ottenere l'accesso root a un dispositivo Android fisico √® generalmente necessario **sfruttare** 1 o 2 **vulnerabilit√†** che solitamente sono **specifiche** per il **dispositivo** e la **versione**.\
Una volta che l'exploit ha funzionato, di solito il binario Linux `su` viene copiato in una posizione specificata nella variabile di ambiente PATH dell'utente come `/system/xbin`.

Una volta configurato il binario su, un'altra app Android viene utilizzata per interfacciarsi con il binario `su` e **elaborare le richieste di accesso root** come **Superuser** e **SuperSU** (disponibili su Google Play Store).

{% hint style="danger" %}
Nota che il processo di rooting √® molto pericoloso e pu√≤ danneggiare gravemente il dispositivo
{% endhint %}

### ROM

√à possibile **sostituire il sistema operativo installando un firmware personalizzato**. Facendo ci√≤ √® possibile estendere l'utilit√† di un vecchio dispositivo, bypassare le restrizioni software o accedere al codice Android pi√π recente.\
**OmniROM** e **LineageOS** sono due dei firmware pi√π popolari da utilizzare.

Nota che **non √® sempre necessario eseguire il root del dispositivo** per installare un firmware personalizzato. **Alcuni produttori consentono** lo sblocco dei loro bootloader in modo ben documentato e sicuro.

### Implicazioni

Una volta che un dispositivo √® stato sradicato, qualsiasi app potrebbe richiedere l'accesso come root. Se un'applicazione dannosa lo ottiene, potr√† accedere a quasi tutto e sar√† in grado di danneggiare il telefono.

## Fondamenti delle Applicazioni Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Il formato delle applicazioni Android √® chiamato _formato file APK_. √à essenzialmente un **file ZIP** (rinominando l'estensione del file in .zip, √® possibile estrarre e visualizzare i contenuti).
- Contenuti APK (non esaustivi)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: contiene risorse precompilate, come XML binario.
- res/xml/files\_paths.xml
- META-INF/
- Qui si trova il Certificato!
- **classes.dex**
- Contiene bytecode Dalvik, che rappresenta il codice Java (o Kotlin) compilato che l'applicazione esegue per impostazione predefinita.
- lib/
- Contiene librerie native, suddivise per architettura CPU in sottodirectory.
- `armeabi`: codice per processori basati su ARM
- `armeabi-v7a`: codice per processori basati su ARMv7 e superiori
- `x86`: codice per processori X86
- `mips`: codice solo per processori MIPS
- assets/
- Conserva file vari necessari dall'app, potenzialmente inclusi librerie native aggiuntive o file DEX, talvolta utilizzati dagli autori di malware per nascondere codice aggiuntivo.
- res/
- Contiene risorse che non sono compilate in resources.arsc
### **Dalvik & Smali**

Nello sviluppo Android, viene utilizzato **Java o Kotlin** per creare app. Invece di utilizzare la JVM come nelle app desktop, Android compila questo codice in **Dalvik Executable (DEX) bytecode**. In passato, la macchina virtuale Dalvik gestiva questo bytecode, ma ora, nelle versioni pi√π recenti di Android, subentra l'Android Runtime (ART).

Per l'ingegneria inversa, **Smali** diventa cruciale. √à la versione leggibile dall'uomo del bytecode DEX, agendo come linguaggio assembly traducendo il codice sorgente in istruzioni bytecode. Smali e baksmali si riferiscono agli strumenti di assembly e disassemblaggio in questo contesto.

## Intents

Gli Intents sono il principale mezzo attraverso il quale le app Android comunicano tra i loro componenti o con altre app. Questi oggetti messaggio possono anche trasportare dati tra app o componenti, simile a come vengono utilizzate le richieste GET/POST nelle comunicazioni HTTP.

Quindi un Intent √® fondamentalmente un **messaggio che viene passato tra i componenti**. Gli Intents **possono essere diretti** a componenti o app specifici, **o possono essere inviati senza un destinatario specifico**.\
Per semplificare, un Intent pu√≤ essere utilizzato per:

* Avviare un'Attivit√†, aprendo tipicamente un'interfaccia utente per un'app
* Come trasmissioni per informare il sistema e le app di cambiamenti
* Avviare, fermare e comunicare con un servizio in background
* Accedere ai dati tramite ContentProviders
* Come richiami per gestire eventi

Se vulnerabili, **gli Intents possono essere utilizzati per eseguire una variet√† di attacchi**.

### Intent-Filter

**Gli Intent Filters** definiscono **come un'attivit√†, un servizio o un ricevitore di trasmissioni possono interagire con diversi tipi di Intents**. Essenzialmente, descrivono le capacit√† di questi componenti, come le azioni che possono eseguire o i tipi di trasmissioni che possono elaborare. Il luogo principale per dichiarare questi filtri √® all'interno del file **AndroidManifest.xml**, anche se per i ricevitori di trasmissioni, √® anche un'opzione codificarli.

Gli Intent Filters sono composti da categorie, azioni e filtri dati, con la possibilit√† di includere metadati aggiuntivi. Questa configurazione consente ai componenti di gestire Intents specifici che corrispondono ai criteri dichiarati.

Un aspetto critico dei componenti Android (attivit√†/servizi/provider di contenuti/ricevitori di trasmissioni) √® la loro visibilit√† o **stato pubblico**. Un componente √® considerato pubblico e pu√≤ interagire con altre app se √® **`esportato`** con un valore di **`true`** o se √® dichiarato un Intent Filter per esso nel manifesto. Tuttavia, c'√® un modo per gli sviluppatori di mantenere esplicitamente privati questi componenti, garantendo che non interagiscano con altre app involontariamente. Questo viene realizzato impostando l'attributo **`esportato`** su **`false`** nelle loro definizioni di manifesto.

Inoltre, gli sviluppatori hanno l'opzione di proteggere ulteriormente l'accesso a questi componenti richiedendo specifici permessi. L'attributo **`permission`** pu√≤ essere impostato per garantire che solo le app con il permesso designato possano accedere al componente, aggiungendo un ulteriore livello di sicurezza e controllo su chi pu√≤ interagire con esso.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Intenti Impliciti

Gli intenti vengono creati programmaticamente utilizzando un costruttore Intent:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
L'**Azione** dell'intento dichiarato in precedenza √® **ACTION\_SEND** e l'**Extra** √® un **Uri** di tipo mailto (l'Extra √® l'informazione aggiuntiva che l'intento si aspetta).

Questo intento dovrebbe essere dichiarato all'interno del manifesto come nell'esempio seguente:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Un intent-filter deve corrispondere all'**azione**, ai **dati** e alla **categoria** per ricevere un messaggio.

Il processo di "risoluzione dell'intento" determina quale app dovrebbe ricevere ciascun messaggio. Questo processo considera l'attributo di **priorit√†**, che pu√≤ essere impostato nella dichiarazione dell'**intent-filter**, e **quello con la priorit√† pi√π alta verr√† selezionato**. Questa priorit√† pu√≤ essere impostata tra -1000 e 1000 e le applicazioni possono utilizzare il valore `SYSTEM_HIGH_PRIORITY`. Se sorge un **conflitto**, compare una finestra "chooser" in modo che l'**utente possa decidere**.

### Intenti Espliciti

Un intento esplicito specifica il nome della classe a cui si sta puntando:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
In altre applicazioni per accedere all'intento precedentemente dichiarato √® possibile utilizzare:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Intenti Pendenti

Questi permettono ad altre applicazioni di **eseguire azioni per conto della tua applicazione**, utilizzando l'identit√† e i permessi della tua app. Per costruire un Intent Pendente, dovrebbe essere **specificato un intent e l'azione da eseguire**. Se l'**intent dichiarato non √® Esplicito** (non dichiara quale intent pu√≤ chiamarlo) un'applicazione malevola potrebbe eseguire l'azione dichiarata **per conto dell'applicazione vittima**. Inoltre, **se un'azione non √® specificata**, l'app malevola sar√† in grado di fare **qualsiasi azione per conto della vittima**.

### Intenti di Broadcast

A differenza degli intenti precedenti, che vengono ricevuti solo da un'app, gli intenti di broadcast **possono essere ricevuti da pi√π app**. Tuttavia, a partire dalla versione API 14, √® **possibile specificare l'app che dovrebbe ricevere** il messaggio utilizzando Intent.setPackage.

In alternativa √® anche possibile **specificare un permesso durante l'invio del broadcast**. L'app ricevente dovr√† avere quel permesso.

Ci sono **due tipi** di Broadcast: **Normale** (asincrono) e **Ordinato** (sincrono). L'**ordine** √® basato sulla **priorit√† configurata all'interno dell'elemento ricevente**. **Ogni app pu√≤ elaborare, inoltrare o eliminare il Broadcast.**

√à possibile **inviare** un **broadcast** utilizzando la funzione `sendBroadcast(intent, receiverPermission)` dalla classe `Context`.\
√à anche possibile utilizzare la funzione **`sendBroadcast`** dal **`LocalBroadCastManager`** per garantire che il **messaggio non esca mai dall'app**. Utilizzando questo metodo, non sar√† nemmeno necessario esportare un componente ricevente.

### Broadcast Sticky

Questo tipo di Broadcast **pu√≤ essere accessibile molto tempo dopo essere stato inviato**.\
Sono stati deprecati nel livello API 21 ed √® consigliato **non utilizzarli**.\
**Permettono a qualsiasi applicazione di intercettare i dati, ma anche di modificarli.**

Se trovi funzioni contenenti la parola "sticky" come **`sendStickyBroadcast`** o **`sendStickyBroadcastAsUser`**, **verifica l'impatto e cerca di rimuoverle**.

## Deep links / Schema URL

Nelle applicazioni Android, i **deep link** vengono utilizzati per avviare un'azione (Intent) direttamente tramite un URL. Ci√≤ viene fatto dichiarando uno specifico **schema URL** all'interno di un'attivit√†. Quando un dispositivo Android cerca di **accedere a un URL con questo schema**, viene avviata l'attivit√† specificata all'interno dell'applicazione.

Lo schema deve essere dichiarato nel file **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Il protocollo dell'esempio precedente √® `exampleapp://` (nota anche la **`categoria BROWSABLE`**)

Successivamente, nel campo dati, puoi specificare l'**host** e il **percorso**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Per accedervi da un web √® possibile impostare un link come:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Per trovare il **codice che verr√† eseguito nell'App**, vai all'attivit√† chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

Scopri come [chiamare deep link senza utilizzare pagine HTML](./#exploiting-schemes-deep-links).

## AIDL - Linguaggio di Definizione dell'Interfaccia Android

Il **Linguaggio di Definizione dell'Interfaccia Android (AIDL)** √® progettato per facilitare la comunicazione tra client e servizio nelle applicazioni Android attraverso la **comunicazione tra processi** (IPC). Poich√© su Android non √® consentito accedere direttamente alla memoria di un altro processo, AIDL semplifica il processo marshalling degli oggetti in un formato comprensibile dal sistema operativo, facilitando cos√¨ la comunicazione tra processi diversi.

### Concetti Chiave

- **Servizi Vincolati**: Questi servizi utilizzano AIDL per IPC, consentendo ad attivit√† o componenti di collegarsi a un servizio, fare richieste e ricevere risposte. Il metodo `onBind` nella classe del servizio √® fondamentale per avviare l'interazione, rendendolo una zona vitale per la revisione della sicurezza alla ricerca di vulnerabilit√†.

- **Messaggero**: Operando come un servizio vincolato, il Messaggero facilita l'IPC con un focus sul trattamento dei dati attraverso il metodo `onBind`. √à essenziale ispezionare attentamente questo metodo per qualsiasi gestione non sicura dei dati o esecuzione di funzioni sensibili.

- **Binder**: Anche se l'uso diretto della classe Binder √® meno comune a causa dell'astrazione di AIDL, √® utile comprendere che Binder agisce come un driver a livello di kernel facilitando il trasferimento di dati tra gli spazi di memoria di processi diversi. Per una maggiore comprensione, √® disponibile una risorsa su [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Componenti

Queste includono: **Attivit√†, Servizi, Ricevitori di Trasmissione e Provider.**

### Attivit√† di Avvio e altre attivit√†

Nelle app Android, le **attivit√†** sono come schermate che mostrano diverse parti dell'interfaccia utente dell'app. Un'app pu√≤ avere molte attivit√†, ognuna presentando uno schermo unico all'utente.

L'**attivit√† di avvio** √® il principale gateway per un'app, avviata quando si tocca l'icona dell'app. Viene definita nel file di manifesto dell'app con intent specifici MAIN e LAUNCHER:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Non tutte le app hanno bisogno di un'attivit√† di lancio, specialmente quelle senza un'interfaccia utente, come i servizi in background.

Le attivit√† possono essere rese disponibili ad altre app o processi contrassegnandole come "esportate" nel manifesto. Questa impostazione consente ad altre app di avviare questa attivit√†:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Tuttavia, accedere a un'attivit√† da un'altra app non √® sempre un rischio per la sicurezza. La preoccupazione sorge se i dati sensibili vengono condivisi impropriamente, il che potrebbe portare a fughe di informazioni.

Il ciclo di vita di un'attivit√† **inizia con il metodo onCreate**, impostando l'interfaccia utente e preparando l'attivit√† per l'interazione con l'utente.

### Sottoclasse dell'Applicazione

Nello sviluppo di Android, un'app ha l'opzione di creare una **sottoclasse** della classe [Application](https://developer.android.com/reference/android/app/Application), anche se non √® obbligatorio. Quando viene definita una tale sottoclasse, diventa la prima classe istanziata all'interno dell'app. Il metodo **`attachBaseContext`**, se implementato in questa sottoclasse, viene eseguito prima del metodo **`onCreate`**. Questa configurazione consente una inizializzazione anticipata prima che il resto dell'applicazione inizi.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Servizi

I [Servizi](https://developer.android.com/guide/components/services) sono **operazioni in background** capaci di eseguire compiti senza un'interfaccia utente. Questi compiti possono continuare ad essere eseguiti anche quando gli utenti passano a diverse applicazioni, rendendo i servizi cruciali per le **operazioni a lungo termine**.

I servizi sono versatili; possono essere avviati in vari modi, con gli **Intent** che rappresentano il metodo principale per avviarli come punto di ingresso dell'applicazione. Una volta che un servizio viene avviato utilizzando il metodo `startService`, il suo metodo `onStart` entra in azione e continua ad essere eseguito fino a quando non viene chiamato esplicitamente il metodo `stopService`. In alternativa, se il ruolo di un servizio dipende da una connessione client attiva, viene utilizzato il metodo `bindService` per collegare il client al servizio, attivando il metodo `onBind` per il passaggio dei dati.

Un'applicazione interessante dei servizi include la riproduzione di musica in background o il recupero di dati di rete senza ostacolare l'interazione dell'utente con un'app. Inoltre, i servizi possono essere resi accessibili ad altri processi sullo stesso dispositivo tramite **esportazione**. Questo non √® il comportamento predefinito e richiede una configurazione esplicita nel file Android Manifest:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Ricevitori di trasmissione

I **ricevitori di trasmissione** fungono da ascoltatori in un sistema di messaggistica, consentendo a pi√π applicazioni di rispondere agli stessi messaggi dal sistema. Un'app pu√≤ **registrare un ricevitore** in **due modi principali**: tramite il **Manifest** dell'app o **dinamicamente** all'interno del codice dell'app tramite l'API **`registerReceiver`**. Nel Manifest, le trasmissioni vengono filtrate con le autorizzazioni, mentre i ricevitori registrati dinamicamente possono anche specificare autorizzazioni durante la registrazione.

I **filtri di intenti** sono cruciali in entrambi i metodi di registrazione, determinando quali trasmissioni attivano il ricevitore. Una volta inviata una trasmissione corrispondente, viene invocato il metodo **`onReceive`** del ricevitore, consentendo all'app di reagire di conseguenza, ad esempio regolando il comportamento in risposta a un avviso di batteria scarica.

Le trasmissioni possono essere sia **asincrone**, raggiungendo tutti i ricevitori senza un ordine specifico, sia **sincrone**, dove i ricevitori ricevono la trasmissione in base alle priorit√† impostate. Tuttavia, √® importante notare il potenziale rischio per la sicurezza, poich√© qualsiasi app pu√≤ dare priorit√† a se stessa per intercettare una trasmissione.

Per comprendere la funzionalit√† di un ricevitore, cercare il metodo **`onReceive`** all'interno della sua classe. Il codice di questo metodo pu√≤ manipolare l'Intent ricevuto, evidenziando la necessit√† di convalida dei dati da parte dei ricevitori, specialmente nelle **Trasmissioni Ordinate**, che possono modificare o eliminare l'Intent.

### Provider di contenuti

I **Provider di contenuti** sono essenziali per **condividere dati strutturati** tra le app, sottolineando l'importanza dell'implementazione delle **autorizzazioni** per garantire la sicurezza dei dati. Consentono alle app di accedere ai dati da varie fonti, inclusi database, filesystem o web. Autorizzazioni specifiche, come **`readPermission`** e **`writePermission`**, sono cruciali per controllare l'accesso. Inoltre, l'accesso temporaneo pu√≤ essere concesso tramite le impostazioni **`grantUriPermission`** nel manifesto dell'app, sfruttando attributi come `path`, `pathPrefix` e `pathPattern` per un controllo dettagliato dell'accesso.

La convalida dell'input √® fondamentale per prevenire vulnerabilit√†, come l'SQL injection. I Provider di contenuti supportano operazioni di base: `insert()`, `update()`, `delete()` e `query()`, facilitando la manipolazione e la condivisione dei dati tra le applicazioni.

**FileProvider**, un Provider di contenuti specializzato, si concentra sulla condivisione sicura dei file. Viene definito nel manifesto dell'app con attributi specifici per controllare l'accesso alle cartelle, indicati da `android:exported` e `android:resource` che puntano alle configurazioni delle cartelle. Si consiglia cautela quando si condividono directory per evitare di esporre involontariamente dati sensibili.

Esempio di dichiarazione nel manifesto per FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
E un esempio di specifica delle cartelle condivise in `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Per ulteriori informazioni controlla:
- [Sviluppatori Android: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Sviluppatori Android: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

I WebViews sono come **mini browser web** all'interno delle app Android, che recuperano contenuti sia dal web che da file locali. Affrontano rischi simili ai browser tradizionali, ma ci sono modi per **ridurre questi rischi** attraverso **impostazioni specifiche**.

Android offre due tipi principali di WebView:

- **WebViewClient** √® ottimo per l'HTML di base ma non supporta la funzione di avviso JavaScript, influenzando come gli attacchi XSS possono essere testati.
- **WebChromeClient** si comporta pi√π come l'esperienza completa del browser Chrome.

Un punto chiave √® che i browser WebView **non condividono i cookie** con il browser principale del dispositivo.

Per il caricamento dei contenuti, sono disponibili metodi come ````loadUrl````, ````loadData````, e ````loadDataWithBaseURL````. √à cruciale assicurarsi che questi URL o file siano **sicuri da utilizzare**. Le impostazioni di sicurezza possono essere gestite tramite la classe ````WebSettings````. Ad esempio, disabilitare JavaScript con ````setJavaScriptEnabled(false)```` pu√≤ prevenire gli attacchi XSS.

Il "Bridge" JavaScript consente agli oggetti Java di interagire con JavaScript, richiedendo che i metodi siano contrassegnati con ````@JavascriptInterface```` per la sicurezza da Android 4.2 in poi.

Consentire l'accesso ai contenuti (````setAllowContentAccess(true)````) consente alle WebViews di raggiungere i Content Providers, il che potrebbe essere un rischio a meno che gli URL dei contenuti siano verificati come sicuri.

Per controllare l'accesso ai file:
- Disabilitare l'accesso ai file (````setAllowFileAccess(false)````) limita l'accesso al filesystem, con eccezioni per determinati asset, garantendo che siano utilizzati solo per contenuti non sensibili.

## Altri Componenti dell'App e Gestione dei Dispositivi Mobili

### **Firma Digitale delle Applicazioni**

- La **firma digitale** √® un must per le app Android, garantendo che siano **autenticamente autenticate** prima dell'installazione. Questo processo utilizza un certificato per l'identificazione dell'app e deve essere verificato dal package manager del dispositivo durante l'installazione. Le app possono essere **auto-firmate o certificate da una CA esterna**, proteggendo dall'accesso non autorizzato e garantendo che l'app rimanga intatta durante la consegna al dispositivo.

### **Verifica dell'App per una Sicurezza Potenziata**

- A partire da **Android 4.2**, una funzionalit√† chiamata **Verifica App** consente agli utenti di verificare la sicurezza delle app prima dell'installazione. Questo **processo di verifica** pu√≤ avvisare gli utenti contro app potenzialmente dannose, o addirittura impedire l'installazione di quelle particolarmente maliziose, potenziando la sicurezza dell'utente.

### **Gestione dei Dispositivi Mobili (MDM)**

- Le **soluzioni MDM** forniscono **controllo e sicurezza** per i dispositivi mobili tramite **API di Amministrazione Dispositivi**. Necessitano dell'installazione di un'app Android per gestire e proteggere efficacemente i dispositivi mobili. Le funzioni chiave includono **l'applicazione di politiche di password**, **l'obbligo di crittografia dello storage**, e **il consenso al wipe remoto dei dati**, garantendo un controllo e una sicurezza completi sui dispositivi mobili.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**Gruppo di sicurezza Try Hard**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
