# Androidアプリケーションの基礎

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告掲載したい場合**や**HackTricksをPDFでダウンロードしたい場合**は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する。私たちの独占的な[**NFTコレクション**](https://opensea.io/collection/the-peass-family)です。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**してください。
* **ハッキングのコツを共有するために、** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて、より早く修正する。Intruderは攻撃面を追跡し、積極的な脅威スキャンを実行し、APIからウェブアプリ、クラウドシステムまでの技術スタック全体で問題を見つけます。今日[**無料で試す**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Androidセキュリティモデル

**2つのレイヤーがあります：**

* **OS**は、インストールされたアプリケーションを互いに隔離します。
* **アプリケーション自体**は、開発者が特定の機能を**公開することを許可**し、アプリケーションの機能を設定します。

### UIDの分離

**各アプリケーションには特定のユーザーIDが割り当てられます**。これはアプリのインストール時に行われるため、アプリは自身のユーザーIDが所有するファイルや共有されたファイルとのみ**相互作用できます**。したがって、アプリ自体、OSの特定のコンポーネント、およびrootユーザーのみがアプリのデータにアクセスできます。

### UIDの共有

**2つのアプリケーションが同じUIDを使用するように設定することができます**。これは情報を共有するのに役立ちますが、そのうちの1つが侵害されると、両方のアプリケーションのデータが侵害される可能性があります。これが**非推奨**である理由です。\
**同じUIDを共有するには、アプリケーションがマニフェストで同じ`android:sharedUserId`値を定義する必要があります。**

### サンドボックス

**Androidアプリケーションサンドボックス**は、**各アプリケーション**を**別のユーザーIDの下で別のプロセスとして実行する**ことを可能にします。各プロセスには独自の仮想マシンがあり、アプリのコードは他のアプリから隔離されて実行されます。\
Android 5.0(L)からは**SELinux**が強制されています。基本的に、SELinuxはすべてのプロセスの相互作用を拒否し、その後、それらの間の**予想される相互作用のみを許可するポリシーを作成しました**。

### パーミッション

アプリをインストールするときに**パーミッションを求められる**と、アプリは**AndroidManifest.xml**ファイルの**`uses-permission`**要素で設定されたパーミッションを求めています。**uses-permission**要素は、**name**属性内の要求されたパーミッションの名前を示します。また、**maxSdkVersion**属性もあり、指定されたバージョンよりも高いバージョンではパーミッションの要求を停止します。\
アンドロイドアプリケーションは、すべてのパーミッションを最初に求める必要はなく、**動的にパーミッションを求めることもできます**が、すべてのパーミッションは**マニフェストで宣言されている必要があります**。

アプリが機能を公開するとき、特定のパーミッションを持つアプリのみに**アクセスを制限することができます**。\
パーミッション要素には3つの属性があります：

* パーミッションの**名前**
* 関連するパーミッションをグループ化するための**permission-group**属性。
* パーミッションがどのように付与されるかを示す**protection-level**。4つのタイプがあります：
  * **Normal**: アプリに**既知の脅威がない**場合に使用されます。ユーザーは**承認する必要はありません**。
  * **Dangerous**: パーミッションがリクエストするアプリケーションに**高度なアクセスを付与する**ことを示します。**ユーザーに承認を求められます**。
  * **Signature**: コンポーネントをエクスポートするものと同じ証明書によって署名された**アプリのみ**がパーミッションを付与されます。これは最も強力なタイプの保護です。
  * **SignatureOrSystem**: コンポーネントをエクスポートするものと同じ証明書によって署名された**アプリのみ**、または**システムレベルのアクセスを持つアプリ**がパーミッションを付与されます

## プリインストールされたアプリケーション

これらのアプリは一般的に**`/system/app`**または**`/system/priv-app`**ディレクトリにあり、いくつかは**最適化されています**（`classes.dex`ファイルが見つからないこともあります）。これらのアプリケーションは、時には**多くのパーミッションで実行されている**ため、チェックする価値があります（rootとして）。

* **AOSP**（Android OpenSource Project）**ROM**に付属しているもの
* デバイス**メーカー**によって追加されたもの
* 携帯電話**プロバイダー**によって追加されたもの（彼らから購入した場合）

## ルーティング

物理的なAndroidデバイスにrootアクセスを取得するためには、一般的に**デバイス**と**バージョン**に**特有の1つまたは2つの脆弱性を**利用する必要があります。\
エクスプロイトが機能した後、通常はLinuxの`su`バイナリがユーザーのPATH環境変数に指定された場所、例えば`/system/xbin`にコピーされます。

suバイナリが設定されると、別のAndroidアプリが`su`バイナリとインターフェースし、**rootアクセスのリクエストを処理する**ように使用されます。例えば**Superuser**や**SuperSU**（Google Playストアで入手可能）などです。

{% hint style="danger" %}
ルーティングプロセスは非常に危険で、デバイスに深刻な損傷を与える可能性があることに注意してください
{% endhint %}

### ROM

**カスタムファームウェアをインストールしてOSを置き換える**ことが可能です。これにより、古いデバイスの有用性を延ばしたり、ソフトウェアの制限を回避したり、最新のAndroidコードにアクセスしたりすることができます。\
**OmniROM**と**LineageOS**は、使用するのに最も人気のあるファームウェアの2つです。

カスタムファームウェアをインストールするために**必ずしもデバイスをroot化する必要はありません**。**一部のメーカーは**、安全で文書化された方法でブートローダーのロック解除を許可しています。

### 影響

デバイスがroot化されると、どのアプリもrootとしてのアクセスを要求できます。悪意のあるアプリケーションがそれを取得した場合、ほぼすべてにアクセスでき、電話を損傷する可能性があります。

## Androidアプリケーションの基本 <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

この紹介は[https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html](https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html)から取られています

### 基本のレビュー <a href="#fundamentals-review" id="fundamentals-review"></a>

* Androidアプリケーションは_APKファイル形式_です。**APKは基本的にZIPファイルです**。（ファイル拡張子を.zipに変更してunzipを使用し、その内容を開いて見ることができます。）
* APKの内容（網羅的ではありません）
  * **AndroidManifest.xml**
  * resources.arsc/strings.xml
  * resources.arsc: 例えばバイナリXMLなど、プリコンパイルされたリソースを含むファイルです。
  * res/xml/files\_paths.xml
  * META-INF/
  * 証明書がここにあります！
  * **classes.dex**
  * アプリケーションのDalvikバイトコードがDEXファイル形式でここにあります。**これはデフォルトでアプリケーションが実行するJava（またはKotlin）コード**がコンパイルされたものです。
  * lib/
  * アプリケーションのネイティブライブラリは、デフォルトではここにあります！lib/ディレクトリの下には、CPU固有のディレクトリがあります。
    * `armeabi`: ARMベースのプロセッサのみのためのコンパイルされたコード
    * `armeabi-v7a`: ARMv7以上のプロセッサのみのためのコンパイルされたコード
    * `x86`: X86のためのコンパイルされたコード
    * `mips`: MIPSプロセッサのみのためのコンパイルされたコード
  * assets/
  * アプリに必要なその他のファイル。
  * 追加のネイティブライブラリやDEXファイルがここに含まれることがあります。これは特にマルウェアの作者が、デフォルトの場所に含まれていない追加のコード、ネイティブまたはDalvikを「隠そう」とするときに発生することがあります。
  * res/
  * resources.arscにコンパイルされていないリソースを含むディレクトリ

### **Dalvik & Smali**

ほとんどのAndroidアプリケーションはJavaで書かれています。Kotlinもサポートされており、Javaと相互運用可能です。簡単にするために、このワークショップの残りの部分では、「Java」と言うときは、「JavaまたはKotlin」を意味すると仮定してください。**JavaコードがデスクトップアプリケーションのようにJava Virtual Machine**（JVM）で実行されるのではなく、Androidでは、**Javaは\_Dalvik Executable (DEX)バイトコード**\_\*\*形式\*\*にコンパイルされます。Androidの初期バージョンでは、バイトコードはDalvik仮想マシンによって翻訳されました。Androidのより最近のバージョンでは、Android Runtime（ART）が使用されます。\
開発者がJavaで書き、コードがDEXバイトコードにコンパイルされる場合、リバースエンジニアリングを行うときは、逆の方向で作業します。\
\\

![開発者のプロセスのフローチャート。JavaからDEXバイトコードへ](https://maddiestone.github.io/AndroidAppRE/images/DevelopersFlow.jpg)

![リバースエンジニアのプロセスのフローチャート。DEXバイトコードからSMALIからデコンパイルされたJavaへ](https://maddiestone.github.io/AndroidAppRE/images/ReversersFlow.jpg)

**SmaliはDalvikバイトコードの人間が読めるバージョンです**。技術的には、Smaliとbaksmaliはツールの名前です（それぞれアセンブラとディスアセンブラ）、しかしAndroidでは、「Smali」という用語をしばしば指示に使用します。もし、あなたがコンパイルされたC/C++コードのリバ
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**アクション**は、先に宣言されたインテントの**ACTION\_SEND**であり、**エクストラ**はmailto **Uri**です（エクストラはインテントが期待する追加情報です）。

このインテントは、以下の例のようにマニフェスト内で宣言されるべきです：
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
インテントフィルターは、メッセージを受信するために**アクション**、**データ**、**カテゴリ**と一致する必要があります。

"インテント解決"プロセスは、どのアプリが各メッセージを受け取るべきかを決定します。このプロセスは、**intent-filter宣言**で設定できる**優先度属性**を考慮し、**より高い優先度を持つものが選択されます**。この優先度は-1000から1000の間で設定でき、アプリケーションは`SYSTEM_HIGH_PRIORITY`値を使用できます。**競合**が発生した場合、**ユーザーが決定できる**ように"chooser"ウィンドウが表示されます。

### 明示的インテント

明示的インテントは、ターゲットとするクラス名を指定します：
```java
Intent downloadIntent = new (this, DownloadService.class):
```
他のアプリケーションでは、以前に宣言されたインテントにアクセスするために、次の方法を使用できます：
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents（保留中のインテント）

これらは他のアプリケーションが**あなたのアプリケーションに代わって行動を取ることを可能にします**。あなたのアプリのアイデンティティと権限を使用しています。Pending Intentを構築する際には、**インテントと実行するアクションを指定する必要があります**。**宣言されたインテントがExplicitでない**（どのインテントがそれを呼び出すことができるかを宣言していない）場合、**悪意のあるアプリケーションが被害者アプリに代わって宣言されたアクションを実行する可能性があります**。さらに、**アクションが指定されていない場合**、悪意のあるアプリは**被害者に代わって任意のアクションを行うことができます**。

### Broadcast Intents（ブロードキャストインテント）

前述のインテントとは異なり、一つのアプリだけが受信するのではなく、ブロードキャストインテントは**複数のアプリによって受信される可能性があります**。しかし、APIバージョン14からは、Intent.set Packageを使用して**メッセージを受信するべきアプリを指定することが可能です**。

また、ブロードキャストを送信する際に**パーミッションを指定することも可能です**。受信アプリはそのパーミッションを持っている必要があります。

ブロードキャストには**二種類**があります：**Normal**（非同期）と**Ordered**（同期）。**順序**は**レシーバー要素内で設定された優先度に基づいています**。**各アプリはブロードキャストを処理、中継、またはドロップすることができます**。

`Context`クラスからの関数**`sendBroadcast(intent, receiverPermission)`**を使用して**ブロードキャストを送信**することが可能です。\
また、**`LocalBroadCastManager`**からの関数**`sendBroadcast`**を使用すると、**メッセージがアプリを離れることはありません**。これを使用すると、レシーバーコンポーネントをエクスポートする必要さえありません。

### Sticky Broadcasts（スティッキーブロードキャスト）

この種のブロードキャストは、**送信された後も長い間アクセスすることができます**。\
これらはAPIレベル21で非推奨とされ、**使用しないことを推奨されています**。\
**任意のアプリケーションがデータを嗅ぎ取るだけでなく、変更することも可能です**。

**`sendStickyBroadcast`**や**`sendStickyBroadcastAsUser`**のような"sticky"という単語が含まれる関数を見つけた場合、**影響を確認し、それらを削除しようと試みてください**。

## Deep links / URL schemes（ディープリンク / URLスキーム）

**ディープリンクはURL経由でインテントをトリガーすることを可能にします**。アプリケーションはアクティビティ内に**URLスキーマを宣言することができ、Androidデバイスがそのスキーマを使用してアドレスにアクセスしようとするたびに、アプリケーションのアクティビティが呼び出されます**：

![](<../../.gitbook/assets/image (214).png>)

この場合のスキームは`myapp://`です（**`category BROWSABLE`**も注目してください）

`intent-filter`内で以下のようなものを見つけた場合：

![](<../../.gitbook/assets/image (263).png>)

それは`http://www.example.com/gizmos`のようなものを期待しています。

以下のようなものを見つけた場合：

![](<../../.gitbook/assets/image (262).png>)

それは`example://gizmos`で始まるURLを期待しています。\
この場合、以下のペイロードを含むウェブを作成して機能を悪用しようとすることができます。任意のページにナビゲートし、JSを実行しようとします：
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
アプリで**実行されるコードを見つける**ためには、deeplinkによって呼び出されるアクティビティに移動し、**`onNewIntent`** 関数を探します。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

[HTMLページを使用せずにディープリンクを呼び出す方法](./#exploiting-schemes-deep-links)を学びましょう。

## AIDL - Android Interface Definition Language

**Android Interface Definition Language**（AIDL）を使用すると、クライアントとサービスが**相互に通信するために合意するプログラミングインターフェースを定義できます**（IPC）。Androidでは、**通常、一つのプロセスは別のプロセスのメモリにアクセスできません**。したがって、通信するためには、オブジェクトを**オペレーティングシステム**が理解できるプリミティブに分解し、その境界を越えてオブジェクトをマーシャリングする必要があります。そのマーシャリングを行うコードは書くのが面倒なので、AndroidがAIDLを使って処理します。

AIDLを使用するサービスは**Bound Services**として参照されます。サービスのクラスでは、**`onBind`** メソッドが見つかります。これは**相互作用が始まる場所**であり、潜在的な脆弱性を探すためにレビューするコードの初期部分です。

バウンドサービスはクライアントサーバーインターフェースのサーバーです。**コンポーネント（アクティビティなど）がサービスにバインドし、リクエストを送信し、応答を受け取り、プロセス間通信**（IPC）を実行できるようにします。バウンドサービスは通常、他のアプリケーションコンポーネントにサービスを提供している間のみ存在し、無期限にバックグラウンドで実行されることはありません。

### Messenger

Messengerは別のタイプのIPCメカニズムです。**Messengerも「Bound Service」**であるため、クライアントアプリから渡されたデータも`onBind`メソッドを通じて処理されます。したがって、コードレビューはこのメソッドから始め、機密機能の呼び出しやデータの不安全な取り扱いを探すべきです。

### Binder

Binderクラスが直接呼び出されることは珍しいですが、AIDL（Binderクラスを抽象化する）を使用する方がはるかに簡単です。ただし、**Binderはカーネルレベルのドライバーであり、あるプロセスのメモリから別のプロセスのメモリにデータを移動する**ことを知っておくと良いでしょう（[https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)）。

## コンポーネント

これには、**アクティビティ、サービス、ブロードキャストレシーバー、プロバイダー**が含まれます。

### ランチャーアクティビティとその他のアクティビティ

**Androidアクティビティ**は、**Android**アプリのユーザーインターフェースの1画面です。その意味で、**Androidアクティビティ**はデスクトップアプリケーションのウィンドウに非常に似ています。**Android**アプリには1つ以上のアクティビティ、つまり1つ以上の画面が含まれる場合があります。

**ランチャーアクティビティ**は、ほとんどの人がAndroidアプリケーションの**エントリーポイント**と考えるものです。ランチャーアクティビティは、ユーザーがアプリケーションのアイコンをクリックしたときに開始されるアクティビティです。アプリケーションのマニフェストを見ることでランチャーアクティビティを特定できます。ランチャーアクティビティには、以下のMAINおよびLAUNCHERインテントがリストされています。

UIを持たないアプリ、特にバックグラウンドでサービスを実行するプリインストールアプリケーションなど、ランチャーアクティビティを持たないアプリケーションもあることに注意してください。UIを持たないアプリケーション（したがってランチャーアクティビティもない）の例には、ボイスメールなどのバックグラウンドでサービスを実行するプリインストールアプリケーションがあります。
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
```markdown
アクティビティはエクスポート可能で、デバイス上の他のプロセスがアクティビティを起動できます。デフォルトではエクスポートされていませんが、以下の設定でエクスポートできます：
```
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
アクティビティの保護を**バイパスする能力が常に脆弱性であるわけではありません**。アクセスを得たデータを確認する必要があります。
また、**一部のアクティビティは呼び出し元にデータを返します**。これらのシナリオでは、**`setResult`** メソッドを探し、Intent パラメータに渡されるデータを確認する必要があります。**もし機密データであれば、情報漏洩の脆弱性があり、アクティビティと通信できるアプリで悪用可能です**。

**アクティビティのコードは `onCreate` メソッドから始まります。**

### アプリケーションサブクラス

Android アプリケーションは、[Application](https://developer.android.com/reference/android/app/Application) の**サブクラス**を定義できます。アプリケーションはカスタムサブクラスを定義する必要はありませんが、定義することもできます。Android アプリが Application サブクラスを定義する場合、**このクラスはアプリケーション内の他のクラスよりも先にインスタンス化されます**。

もし Application サブクラスで **`attachBaseContext`** メソッドが定義されている場合、**`onCreate`** メソッドの前に最初に呼び出されます。

### サービス

[サービス](https://developer.android.com/guide/components/services) は**UI なしでバックグラウンドで実行されます**。ユーザーが別のアプリケーションを使用し始めても、**長時間実行するプロセスを実行するために使用されます**。

サービスを開始する方法は多岐にわたり、アプリケーションのエントリポイントです。サービスがアプリケーションのエントリポイントとして開始されるデフォルトの方法は、**Intents** を介してです。

**`startService`** メソッドが呼び出されてサービスを開始すると、サービス内の **`onStart`** メソッドが実行されます。**`stopService`** メソッドが呼び出されるまで無期限に実行されます。サービスがクライアントが接続している間のみ必要な場合、クライアントは **`bindService`** メソッドを使用してそれに "バインド" するべきです。

**バインドされたサービス**（前のセクションを参照）の場合、データは **`onBind`** メソッドに渡されます。

例えば、サービスはユーザーが別のアプリケーションを使用している間にバックグラウンドで音楽を再生したり、アクティビティとのユーザーのやり取りをブロックすることなくネットワーク経由でデータを取得することができます。

**サービスはエクスポート可能で、デバイス上の他のプロセスがサービスを開始できるようになります**。デフォルトではサービスはエクスポートされていませんが、Manifest で設定できます：
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

ブロードキャストはメッセージングシステムと考えることができ、**broadcast receivers はリスナーです**。アプリケーションが特定のブロードキャストに対してレシーバーを登録している場合、そのレシーバーのコードはシステムがブロードキャストを送信すると実行されます。この場合、**複数のアプリが同じメッセージを受信する可能性がある**ことに注意してください。

アプリがレシーバーを**登録する方法は2つ**あります：**アプリのManifest内で、またはアプリのコード内で動的に** **`registerReceiver`** APIコールを使用して登録します。Manifestでは、レシーバー要素内のパーミッションを使用して受け入れるブロードキャストを制限できます。**動的に**定義する場合は、**`registerReceiver` メソッドにパーミッションを渡す**ことができます。

どちらの場合も、レシーバーを登録するためには、**レシーバーのためのインテントフィルターが設定されます**。これらのインテントフィルターは、レシーバーをトリガーするべきブロードキャストです。

レシーバーが登録されている特定のブロードキャストが送信されると、BroadcastReceiverクラスの**`onReceive`** が**実行されます**。

例えば、アプリケーションは低バッテリーメッセージのためにレシーバーを登録し、その情報に基づいて動作を変更するかもしれません。

ブロードキャストは**非同期**（すべてのレシーバーが受信する）または**同期**（優先順位に基づいて順序よく受信される）のいずれかです。

{% hint style="danger" %}
**任意のアプリケーションがブロードキャストを受信するための最優先に設定することができることに注意してください。**
{% endhint %}

Broadcast Receiverに実装されている**コードを調査する**には、レシーバーのクラスの**`onReceive`** メソッドを探す必要があります。\
**Ordered Broadcastsは受け取ったIntentをドロップしたり、setterメソッドのいずれかを使用して変更することができる**ため、**レシーバーはデータを検証するべきです**。

### Content Provider

Content Providersは、リレーショナルデータベースなどの**アプリが構造化されたデータを共有する方法**です。したがって、それらを保護するために**パーミッション**を使用し、適切な保護レベルを設定することが非常に重要です。\
Content Providersは、アプリが持っている必要があるパーミッションを指定するために、**`readPermission`** および **`writePermission`** 属性を使用できます。**これらのパーミッションはパーミッション属性よりも優先されます**。\
さらに、**`grantUriPermission`** をtrueに設定し、Manifestファイル内のprovider要素内の**`grant-uri-permission`** 要素で適切なパラメータを設定することにより、**一時的な例外を許可する**こともできます。

**`grant-uri-permission`** には三つの属性があります：path、pathPrefix、pathPattern：

* **path**：除外する完全なパスを指定することができます
* **pathPrefix**：パスの始まりを指定することができます
* **pathPattern**：ワイルドカードや象徴的な置換を使用して、より細かい制御を得ることができます。

SQLインジェクションのような潜在的な脆弱性を避けるために、**受け取った入力を検証し、サニタイズすることが重要です**。

**Content Providerの特徴:**

* Content Providerコンポーネントは、要求に応じて他のアプリケーションにデータを提供します。
* データはファイルシステム、SQLiteデータベース、ウェブ、またはアプリがアクセスできるその他の永続的なストレージ場所に保存できます。
* Content Providerを通じて、他のアプリはデータをクエリしたり、Content Providerが許可する場合は変更することもできます。
* Content Providerは、アプリが他のアプリとデータを共有したい場合に役立ちます。
* データベースに非常に似ており、四つのメソッドがあります。
* insert()
* update()
* delete()
* query()

**FileProvider**

これは、フォルダから**ファイルを共有する**Content Providerのタイプです。FileProviderをこのように宣言できます：
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
**`android:exported`** 属性に注意してください。これが **`true`** であれば、外部アプリケーションが共有フォルダにアクセスできるようになります。\
`android:resource="@xml/filepaths"` の設定は、_res/xml/filepaths.xml_ ファイルに、この **FileProvider** が**共有する** **どのフォルダ**に関する設定が含まれていることを示しています。以下はそのファイルでフォルダを共有するための指示の例です：
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
```markdown
**`path="."`** が共有されることは、プロバイダがエクスポートされていなくても、このプロバイダにアクセスしようとするコードの一部に他の脆弱性がある場合、**危険**です。
`content://com.example.myapp.fileprovider/myimages/default_image.jpg` を使ってそのフォルダ内の**画像**に**アクセス**することができます。

`<paths>` 要素には複数の子要素を持つことができ、それぞれが共有する異なるディレクトリを指定します。**`<files-path>`** 要素に加えて、**`<external-path>`** 要素を使用して**外部ストレージ**内のディレクトリを共有したり、**`<cache-path>`** 要素を使用して**内部キャッシュディレクトリ**内のディレクトリを共有することができます。
[特定のファイルプロバイダの属性についての詳細はこちらをご覧ください。](https://developer.android.com/reference/androidx/core/content/FileProvider)

[FileProvidersについての詳細はこちら](https://developer.android.com/training/secure-file-sharing/setup-sharing)。

## WebViews

WebViewsは、Androidアプリに組み込まれた**ウェブブラウザ**です。
WebViewsのコンテンツはリモートサイトから取得されることも、アプリに含まれるファイルから取得されることもあります。
WebViewsは**ウェブブラウザに影響する同じ脆弱性に対して脆弱**です。しかし、**攻撃** **面**を**制限**するためのいくつかの**設定**が役立ちます。

Androidには2種類のWebViewsがあります：

* **WebViewClient**は、単純なHTMLレンダリングに最適です。これはJSのalert関数を実行しません。したがって、その関数を使用するXSSテストは無効です。
* **WebChrome** **クライアント**は、Chromeブラウザです。

**WebViewブラウザはネイティブブラウザのクッキーにアクセスできない**ことに注意してください。

URLまたはファイルをロードするには、**`loadUrl`**、**`loadData`**、または**`loadDataWithBaseURL`**の関数を使用できます。**検査済みのURLのみにアクセスすることが重要です。**
WebViewのセキュリティは**`WebSettings`**オブジェクトを通じて設定できます。
例えば、**`setJavaScriptEnabled`**メソッドを**`false`**値で使用してJSコードの実行を無効にすることで、**XSS**やその他のJS関連の脆弱性を**除去**することができます。

JavaScriptの"**Bridge**"機能は**JavaオブジェクトをWebViewに注入し、JSからアクセス可能にします**。Android 4.2からは、JavaScriptからアクセス可能にするためにはメソッドが**`@JavascriptInterface`**で注釈されている必要があります。

**`setAllowContentAccess`**に**`true`**を渡すと、**WebViewsは**`content://`**スキームを介してContent Providersにアクセスできるようになります**。これは明らかにセキュリティリスクをもたらします。このアクセスが許可された場合、**`content://`** URLが**安全**であることを**確認**することが非常に重要です。

デフォルトでは、WebViewsはfile:// URLを介してローカルファイルにアクセスできますが、この挙動を防ぐいくつかの方法があります：

* **`setAllowFileAccess`**に**`false`**を渡すと、`file:///android_asset` _および_ `file:///android_res`を除くファイルシステムへのアクセスが防止されます。これらのパスは非機密データ（画像など）にのみ使用されるべきなので、これは安全であるべきです。
* メソッド**`setAllowFileAccess`**は、`file://` URLのパスが他のファイルスキームURLのコンテンツにアクセスできるかどうかを示します。
* メソッド**`setAllowUniversalAccessFromFileURLs`**は、`file://` URLのパスが任意のオリジンのコンテンツにアクセスできるかどうかを示します。

## その他のアプリコンポーネント

### **アプリケーション署名**

* Androidは、インストールされる前に**すべてのアプリが証明書でデジタル署名されている**ことを要求しています。Androidはこの証明書を使用してアプリの作者を識別します。
* デバイス上でアプリケーションを実行するには、署名されている必要があります。デバイスにアプリケーションがインストールされると、**パッケージマネージャは**apkファイルの証明書で適切に署名されているかどうかを検証します。
* アプリケーションは自己署名されることも、CAを通じて署名されることもあります。
* アプリケーション署名は、一つのアプリケーションが定義されたIPCを通じてのみ他のアプリケーションにアクセスでき、またデバイスに変更されずに渡されることを保証します。

### **アプリケーション検証**

* Android 4.2以降はアプリケーション検証をサポートしています。ユーザーは「アプリを検証する」を有効にして、インストール前にアプリケーション検証機関による評価を受けることを選択できます。
* アプリ検証は、ユーザーが有害かもしれないアプリをインストールしようとした場合に警告することができます。アプリケーションが特に悪質な場合は、インストールをブロックすることができます。

## モバイルデバイス管理

MDMまたはモバイルデバイス管理は、モバイルデバイスに対する**管理とセキュリティ要件**を保証するために使用されるソフトウェアスイートです。これらのスイートはデバイス管理APIとして知られる機能を使用し、Androidアプリのインストールを必要とします。

一般的にMDMソリューションは、パスワードポリシーの強制、ストレージの暗号化の強制、デバイスデータのリモートワイプの有効化などの機能を実行します。

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて、より早く修正できるようにします。Intruderは攻撃面を追跡し、積極的な脅威スキャンを実行し、APIからウェブアプリ、クラウドシステムまでの技術スタック全体で問題を見つけます。今日[**無料でお試し**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksに広告を掲載したい**場合や**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手してください。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見してください。私たちの独占的な[**NFTコレクション**](https://opensea.io/collection/the-peass-family)です。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有**してください。

</details>
```
