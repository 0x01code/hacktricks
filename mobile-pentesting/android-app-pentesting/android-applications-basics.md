# Fundamentos de Aplica√ß√µes Android

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encontre vulnerabilidades que importam mais para que voc√™ possa corrigi-las mais rapidamente. O Intruder rastreia sua superf√≠cie de ataque, executa varreduras proativas de amea√ßas, encontra problemas em toda a sua pilha tecnol√≥gica, de APIs a aplicativos web e sistemas em nuvem. [**Experimente gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoje.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Modelo de Seguran√ßa Android

**Existem duas camadas:**

* O **SO**, que mant√©m as aplica√ß√µes instaladas isoladas umas das outras.
* A **pr√≥pria aplica√ß√£o**, que permite aos desenvolvedores **expor certas funcionalidades** e configura as capacidades da aplica√ß√£o.

### Separa√ß√£o de UID

**Cada aplica√ß√£o √© atribu√≠da a um User ID espec√≠fico**. Isso √© feito durante a instala√ß√£o do aplicativo para que **o aplicativo s√≥ possa interagir com arquivos de propriedade de seu User ID ou arquivos compartilhados**. Portanto, apenas o pr√≥prio aplicativo, certos componentes do SO e o usu√°rio root podem acessar os dados do aplicativo.

### Compartilhamento de UID

**Duas aplica√ß√µes podem ser configuradas para usar o mesmo UID**. Isso pode ser √∫til para compartilhar informa√ß√µes, mas se uma delas for comprometida, os dados de ambas as aplica√ß√µes ser√£o comprometidos. √â por isso que esse comportamento √© **desencorajado**.
**Para compartilhar o mesmo UID, as aplica√ß√µes devem definir o mesmo valor `android:sharedUserId` em seus manifestos.**

### Sandboxing

O **Sandbox de Aplica√ß√µes Android** permite executar **cada aplica√ß√£o** como um **processo separado sob um User ID separado**. Cada processo tem sua pr√≥pria m√°quina virtual, ent√£o o c√≥digo de um aplicativo √© executado isoladamente de outros aplicativos.
A partir do Android 5.0(L) o **SELinux** √© aplicado. Basicamente, o SELinux nega todas as intera√ß√µes de processos e depois cria pol√≠ticas para **permitir apenas as intera√ß√µes esperadas entre eles**.

### Permiss√µes

Quando voc√™ instala um **aplicativo e ele pede permiss√µes**, o aplicativo est√° solicitando as permiss√µes configuradas nos elementos **`uses-permission`** no arquivo **AndroidManifest.xml**. O elemento **uses-permission** indica o nome da permiss√£o solicitada dentro do atributo **name**. Ele tamb√©m tem o atributo **maxSdkVersion** que para de pedir permiss√µes em vers√µes superiores √† especificada.
Observe que os aplicativos Android n√£o precisam pedir todas as permiss√µes no in√≠cio, eles tamb√©m podem **pedir permiss√µes dinamicamente** mas todas as permiss√µes devem ser **declaradas** no **manifesto**.

Quando um aplicativo exp√µe funcionalidades, ele pode limitar o **acesso apenas a aplicativos que t√™m uma permiss√£o especificada**.
Um elemento de permiss√£o tem tr√™s atributos:

* O **nome** da permiss√£o
* O atributo **permission-group**, que permite agrupar permiss√µes relacionadas.
* O **protection-level** que indica como as permiss√µes s√£o concedidas. Existem quatro tipos:
  * **Normal**: Usado quando n√£o h√° **amea√ßas conhecidas** ao aplicativo. O usu√°rio **n√£o √© obrigado a aprov√°-lo**.
  * **Perigoso**: Indica que a permiss√£o concede ao aplicativo solicitante algum **acesso elevado**. **Os usu√°rios s√£o solicitados a aprov√°-los**.
  * **Assinatura**: Apenas **aplicativos assinados pelo mesmo certificado que o** exportando o componente podem receber permiss√£o. Este √© o tipo mais forte de prote√ß√£o.
  * **AssinaturaOuSistema**: Apenas **aplicativos assinados pelo mesmo certificado que o** exportando o componente ou **aplicativos executando com acesso a n√≠vel de sistema** podem receber permiss√µes

## Aplica√ß√µes Pr√©-Instaladas

Esses aplicativos geralmente s√£o encontrados nos diret√≥rios **`/system/app`** ou **`/system/priv-app`** e alguns deles s√£o **otimizados** (voc√™ pode nem mesmo encontrar o arquivo `classes.dex`). Essas aplica√ß√µes valem a pena verificar porque √†s vezes est√£o **executando com muitas permiss√µes** (como root).

* As que v√™m com o **AOSP** (Projeto de C√≥digo Aberto Android) **ROM**
* Adicionadas pelo **fabricante** do dispositivo
* Adicionadas pelo provedor de **telefonia celular** (se compradas por eles)

## Rooting

Para obter acesso root em um dispositivo Android f√≠sico, geralmente √© necess√°rio **explorar** 1 ou 2 **vulnerabilidades** que costumam ser **espec√≠ficas** para o **dispositivo** e **vers√£o**.
Uma vez que o exploit funcionou, geralmente o bin√°rio `su` do Linux √© copiado para um local especificado na vari√°vel de ambiente PATH do usu√°rio, como `/system/xbin`.

Uma vez que o bin√°rio su est√° configurado, outro aplicativo Android √© usado para interagir com o bin√°rio `su` e **processar solicita√ß√µes de acesso root** como **Superuser** e **SuperSU** (dispon√≠veis na Google Play Store).

{% hint style="danger" %}
Observe que o processo de root √© muito perigoso e pode danificar severamente o dispositivo
{% endhint %}

### ROMs

√â poss√≠vel **substituir o SO instalando um firmware personalizado**. Fazendo isso √© poss√≠vel estender a utilidade de um dispositivo antigo, contornar restri√ß√µes de software ou acessar o c√≥digo Android mais recente.
**OmniROM** e **LineageOS** s√£o dois dos firmwares mais populares para usar.

Observe que **nem sempre √© necess√°rio fazer root no dispositivo** para instalar um firmware personalizado. **Alguns fabricantes permitem** o desbloqueio de seus bootloaders de maneira bem documentada e segura.

### Implica√ß√µes

Uma vez que um dispositivo √© rooteado, qualquer aplicativo pode solicitar acesso como root. Se um aplicativo malicioso obtiver, ele ter√° acesso a quase tudo e poder√° danificar o telefone.

## Fundamentos de Aplica√ß√£o Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

Esta introdu√ß√£o foi retirada de [https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html](https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html)

### Revis√£o dos Fundamentos <a href="#fundamentals-review" id="fundamentals-review"></a>

* Aplica√ß√µes Android est√£o no _formato de arquivo APK_. **APK √© basicamente um arquivo ZIP**. (Voc√™ pode renomear a extens√£o do arquivo para .zip e usar o descompactador para abrir e ver seu conte√∫do.)
* Conte√∫do do APK (N√£o exaustivo)
  * **AndroidManifest.xml**
  * resources.arsc/strings.xml
  * resources.arsc: um arquivo contendo recursos pr√©-compilados, como XML bin√°rio, por exemplo.
  * res/xml/files\_paths.xml
  * META-INF/
    * Certificado vive aqui!
  * **classes.dex**
    * Bytecode Dalvik para aplica√ß√£o no formato de arquivo DEX. **Este √© o c√≥digo Java (ou Kotlin)** compilado que a aplica√ß√£o executar√° por padr√£o.
  * lib/
    * Bibliotecas nativas para a aplica√ß√£o, por padr√£o, vivem aqui! Sob o diret√≥rio lib/, existem os diret√≥rios espec√≠ficos da CPU.
    * `armeabi`: c√≥digo compilado apenas para processadores baseados em ARM
    * `armeabi-v7a`: c√≥digo compilado apenas para processadores baseados em ARMv7 e acima
    * `x86`: c√≥digo compilado para X86
    * `mips`: c√≥digo compilado apenas para processadores MIPS
  * assets/
    * Quaisquer outros arquivos que possam ser necess√°rios pelo aplicativo.
    * Bibliotecas nativas adicionais ou arquivos DEX podem ser inclu√≠dos aqui. Isso pode acontecer especialmente quando autores de malware querem tentar "esconder" c√≥digo adicional, nativo ou Dalvik, n√£o incluindo-o nos locais padr√£o.
  * res/
    * o diret√≥rio contendo recursos n√£o compilados em resources.arsc

### **Dalvik & Smali**

A maioria das aplica√ß√µes Android s√£o escritas em Java. Kotlin tamb√©m √© suportado e interoper√°vel com Java. Para facilitar, pelo resto deste workshop, quando me refiro a "Java", voc√™ pode assumir que eu quero dizer "Java ou Kotlin". **Em vez do c√≥digo Java ser executado na M√°quina Virtual Java** (JVM) como aplica√ß√µes de desktop, no Android, o **Java √© compilado para o formato de bytecode \_Dalvik Executable (DEX)\_\*\* **. Para vers√µes anteriores do Android, o bytecode era traduzido pela m√°quina virtual Dalvik. Para vers√µes mais recentes do Android, o Android Runtime (ART) √© usado.
Se os desenvolvedores escrevem em Java e o c√≥digo √© compilado para bytecode DEX, para fazer engenharia reversa, trabalhamos na dire√ß√£o oposta.
\\

![Fluxograma do processo do desenvolvedor. Java para bytecode DEX](https://maddiestone.github.io/AndroidAppRE/images/DevelopersFlow.jpg)

![Fluxograma do processo do Engenheiro Reverso. Bytecode DEX para SMALI para Java Decompilado](https://maddiestone.github.io/AndroidAppRE/images/ReversersFlow.jpg)

**Smali √© a vers√£o leg√≠vel por humanos do bytecode Dalvik**. Tecnicamente, Smali e baksmali s√£o os nomes das ferramentas (montador e desmontador, respectivamente), mas no Android, muitas vezes usamos o termo "Smali" para nos referir √†s instru√ß√µes. Se voc√™ j√° fez engenharia reversa ou arquitetura de computadores em c√≥digo C/C++ compilado. **SMALI √© como a linguagem de montagem: entre o c√≥digo fonte de alto n√≠vel e o bytecode**.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encontre vulnerabilidades que importam mais para que voc√™ possa corrigi-las mais rapidamente. O Intruder rastreia sua superf√≠cie de ataque, executa varreduras proativas de amea√ßas, encontra problemas em toda a sua pilha tecnol√≥gica, de APIs a aplicativos web e sistemas em nuvem. [**Experimente gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoje.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Intents

Intents s√£o o principal meio pelo qual aplicativos Android se comunicam entre seus componentes ou com outros aplicativos. Esses objetos de mensagem tamb√©m podem transportar dados entre aplicativos ou componentes, de forma semelhante a como as solicita√ß√µes GET/POST s√£o usadas em comunica√ß√µes HTTP.

Ent√£o, um Intent √© basicamente uma **mensagem que √© passada entre componentes**. Intents **podem ser direcionados** a componentes ou aplicativos espec√≠ficos, **ou podem ser enviados sem um destinat√°rio espec√≠fico**.
Para ser simples, Intent pode ser usado:

* Para iniciar uma Activity, normalmente abrindo uma interface de usu√°rio para um aplicativo
* Como broadcasts para informar o sistema e aplicativos sobre mudan√ßas
* Para iniciar, parar e se comunicar com um servi√ßo em segundo plano
* Para acessar dados via ContentProviders
* Como callbacks para lidar com eventos

Uma implementa√ß√£o inadequada pode resultar em vazamento de dados, fun√ß√µes restritas sendo chamadas e manipula√ß√£o do fluxo do programa.

### Intent-Filter

Um Intent Filter especifica **os tipos de Intent que uma activity, servi√ßo ou Broadcast Receiver podem responder**. Ele especifica o que uma activity ou servi√ßo pode fazer e que tipos de broadcasts um Receiver pode lidar. Ele permite que o componente correspondente receba Intents do tipo declarado. Intent Filters s√£o tipicamente **definidos atrav√©s do arquivo AndroidManifest.xml**. Para **Broadcast Receiver** tamb√©m √© poss√≠vel defini-los em **c√≥digo**. Um Intent Filter √© definido por sua categoria, a√ß√£o e filtros de dados. Ele tamb√©m pode conter metadados adicionais.

No Android, uma activity/service/content provider/broadcast receiver √© **p√∫blico** quando **`exported`** est√° definido como **`true`**, mas um componente √© **tamb√©m p√∫blico** se o **manifesto especifica um Intent filter** para ele. No entanto,
desenvolvedores podem **explicitamente tornar componentes privados** (independentemente de quaisquer filtros de intent)
definindo o atributo **`exported`** como `false` para cada componente no arquivo de manifesto.
Desenvolvedores tamb√©m podem definir o atributo **`permission`** para **exigir uma certa permiss√£o para acessar** o componente, restringindo assim o acesso ao componente.

### Intents Impl√≠citos

Intents s√£o criados programaticamente usando um construtor de Intent:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
O **Action** do intent previamente declarado √© **ACTION\_SEND** e o **Extra** √© um **Uri** mailto (o Extra √© a informa√ß√£o adicional que o intent est√° esperando).

Este intent deve ser declarado dentro do manifesto como no seguinte exemplo:
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Um intent-filter precisa corresponder √† **a√ß√£o**, **dados** e **categoria** para receber uma mensagem.

O processo de "Resolu√ß√£o de Intent" determina qual aplicativo deve receber cada mensagem. Esse processo considera o **atributo de prioridade**, que pode ser definido na **declara√ß√£o do intent-filter**, e **aquele com a maior prioridade ser√° selecionado**. Essa prioridade pode ser definida entre -1000 e 1000 e os aplicativos podem usar o valor `SYSTEM_HIGH_PRIORITY`. Se um **conflito** surgir, uma janela de "escolha" aparece para que o **usu√°rio possa decidir**.

### Intents Expl√≠citos

Um intent expl√≠cito especifica o nome da classe que est√° sendo alvo:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Em outras aplica√ß√µes, para acessar o intent previamente declarado, voc√™ pode usar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Esses permitem que outras aplica√ß√µes **tomem a√ß√µes em nome da sua aplica√ß√£o**, usando a identidade e permiss√µes do seu app. Ao construir um Pending Intent deve-se **especificar uma intent e a a√ß√£o a realizar**. Se a **intent declarada n√£o for Expl√≠cita** (n√£o declara qual intent pode cham√°-la), uma **aplica√ß√£o maliciosa poder√° realizar a a√ß√£o declarada** em nome do app v√≠tima. Al√©m disso, **se uma a√ß√£o n√£o for especificada**, o app malicioso poder√° fazer **qualquer a√ß√£o em nome da v√≠tima**.

### Broadcast Intents

Ao contr√°rio dos intents anteriores, que s√£o recebidos apenas por um app, os broadcast intents **podem ser recebidos por m√∫ltiplos apps**. No entanto, a partir da vers√£o 14 da API, √© **poss√≠vel especificar o app que deve receber** a mensagem usando Intent.set Package.

Alternativamente, tamb√©m √© poss√≠vel **especificar uma permiss√£o ao enviar o broadcast**. O app receptor precisar√° ter essa permiss√£o.

Existem **dois tipos** de Broadcasts: **Normal** (ass√≠ncrono) e **Ordenado** (s√≠ncrono). A **ordem** √© baseada na **prioridade configurada dentro do elemento receptor**. **Cada app pode processar, retransmitir ou descartar o Broadcast.**

√â poss√≠vel **enviar** um **broadcast** usando a fun√ß√£o **`sendBroadcast(intent, receiverPermission)`** da classe `Context`.\
Voc√™ tamb√©m pode usar a fun√ß√£o **`sendBroadcast`** do **`LocalBroadCastManager`** que garante que a **mensagem nunca saia do app**. Usando isso, voc√™ nem precisar√° exportar um componente receptor.

### Sticky Broadcasts

Esse tipo de Broadcasts **pode ser acessado muito tempo depois de terem sido enviados**.\
Eles foram depreciados no n√≠vel 21 da API e √© recomendado **n√£o us√°-los**.\
**Eles permitem que qualquer aplica√ß√£o fareje os dados, mas tamb√©m os modifique.**

Se voc√™ encontrar fun√ß√µes contendo a palavra "sticky" como **`sendStickyBroadcast`** ou **`sendStickyBroadcastAsUser`**, **verifique o impacto e tente remov√™-las**.

## Deep links / Esquemas de URL

**Deep links permitem acionar uma Intent via URL**. Uma aplica√ß√£o pode declarar um **esquema de URL** dentro de uma atividade para que, sempre que o dispositivo Android tentar **acessar um endere√ßo usando esse esquema**, a atividade da aplica√ß√£o seja chamada:

![](<../../.gitbook/assets/image (214).png>)

Neste caso, o esquema √© `myapp://` (note tamb√©m a **`categoria BROWSABLE`**)

Se dentro do `intent-filter` voc√™ encontrar algo como isto:

![](<../../.gitbook/assets/image (263).png>)

Ent√£o, est√° esperando algo como `http://www.example.com/gizmos`

Se voc√™ encontrar algo assim:

![](<../../.gitbook/assets/image (262).png>)

Isso significar√° que est√° esperando uma URL come√ßando por `example://gizmos`\
Neste caso, voc√™ poderia tentar abusar da funcionalidade criando uma web com os seguintes payloads. Ele tentar√° navegar para p√°ginas arbitr√°rias e tentar executar JS:
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Para encontrar o **c√≥digo que ser√° executado no App**, v√° para a atividade chamada pelo deeplink e procure a fun√ß√£o **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Aprenda como [chamar deep links sem usar p√°ginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Linguagem de Defini√ß√£o de Interface Android

A **Linguagem de Defini√ß√£o de Interface Android** (AIDL) permite que voc√™ defina a interface de programa√ß√£o que tanto o cliente quanto o servi√ßo concordam em usar para **comunicar-se entre si usando comunica√ß√£o entre processos** (IPC). No Android, **um processo normalmente n√£o pode acessar a mem√≥ria de outro processo**. Ent√£o, para se comunicarem, eles precisam decompor seus objetos em primitivas que o **sistema operacional** possa entender e transportar os objetos atrav√©s dessa fronteira para voc√™. O c√≥digo para fazer esse transporte √© tedioso de escrever, ent√£o o Android lida com isso para voc√™ com AIDL.

Servi√ßos que usam AIDL s√£o referidos como **Servi√ßos Vinculados**. Na classe do Servi√ßo, voc√™ encontrar√° o m√©todo **`onBind`**. √â **aqui que a intera√ß√£o come√ßa**, portanto √© a parte inicial do c√≥digo a ser revisada em busca de potenciais vulnerabilidades.

Um servi√ßo vinculado √© o servidor em uma interface cliente-servidor. **Ele permite que componentes (como atividades) se vinculem ao servi√ßo, enviem solicita√ß√µes, recebam respostas e realizem comunica√ß√£o entre processos** (IPC). Um servi√ßo vinculado normalmente existe apenas enquanto atende outro componente da aplica√ß√£o e n√£o roda indefinidamente em segundo plano.

### Messenger

Um Messenger √© outro tipo de mecanismo IPC. Como o **Messenger tamb√©m √© um "Servi√ßo Vinculado"**, os dados passados do aplicativo cliente tamb√©m s√£o processados atrav√©s do m√©todo `onBind`. Portanto, a revis√£o de c√≥digo deve come√ßar neste m√©todo e voc√™ deve procurar pela invoca√ß√£o de funcionalidades sens√≠veis ou manipula√ß√£o insegura de dados.

### Binder

√â raro encontrar uma classe Binder invocada diretamente, pois √© muito mais f√°cil usar AIDL (que abstrai a classe Binder). No entanto, √© bom saber que **Binder √© um driver de n√≠vel de kernel que move dados da mem√≥ria de um processo para a de outro** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Componentes

Estes incluem: **Atividades, Servi√ßos, Receptores de Transmiss√£o e Provedores.**

### Atividade Inicial e outras atividades

Uma **atividade Android** √© uma tela da interface do usu√°rio do aplicativo **Android**. Dessa forma, uma **atividade Android** √© muito semelhante a janelas em um aplicativo de desktop. Um aplicativo **Android** pode conter uma ou mais atividades, ou seja, uma ou mais telas.

A **atividade inicial** √© o que a maioria das pessoas considera como o **ponto de entrada** para um aplicativo Android. A atividade inicial √© a atividade que √© iniciada quando um usu√°rio clica no √≠cone de um aplicativo. Voc√™ pode determinar a atividade inicial olhando para o manifesto do aplicativo. A atividade inicial ter√° as seguintes inten√ß√µes MAIN e LAUNCHER listadas.

Lembre-se de que nem todo aplicativo ter√° uma atividade inicial, especialmente aplicativos sem uma UI. Exemplos de aplicativos sem UI (e, portanto, sem atividade inicial) s√£o aplicativos pr√©-instalados que realizam servi√ßos em segundo plano, como correio de voz.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
As Activities podem ser exportadas, permitindo que outros processos no dispositivo iniciem a Activity. Por padr√£o, elas n√£o s√£o exportadas, mas voc√™ pode export√°-las configurando:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Note que a capacidade de **bypassar prote√ß√µes de atividade nem sempre √© uma vulnerabilidade**, voc√™ precisa verificar a qual dado voc√™ obteve acesso.
Al√©m disso, **algumas atividades retornam dados para um chamador**. Nestes cen√°rios, voc√™ precisa procurar pelo m√©todo **`setResult`** e verificar os dados que s√£o passados no par√¢metro Intent. **Se for dado sens√≠vel, voc√™ pode ter uma vulnerabilidade de vazamento de informa√ß√£o** e √© explor√°vel com apps capazes de se comunicar com a Atividade.

**O c√≥digo de uma atividade come√ßa com o m√©todo `onCreate`.**

### Subclasse de Aplica√ß√£o

Aplica√ß√µes Android podem definir uma **subclasse** de [Application](https://developer.android.com/reference/android/app/Application). Aplica√ß√µes podem, mas n√£o precisam definir uma subclasse personalizada de Application. Se um app Android define uma subclasse de Application, **essa classe √© instanciada antes de qualquer outra classe na aplica√ß√£o**.

Se o m√©todo **`attachBaseContext`** √© definido na subclasse Application, ele √© chamado primeiro, antes do m√©todo **`onCreate`**.

### Servi√ßos

[Servi√ßos](https://developer.android.com/guide/components/services) **funcionam em segundo plano sem uma UI.** Eles s√£o usados para realizar **processos de longa dura√ß√£o, mesmo se o usu√°rio come√ßar a usar uma aplica√ß√£o diferente**.

H√° uma mir√≠ade de maneiras que eles podem ser iniciados e, portanto, s√£o um ponto de entrada para aplica√ß√µes. A maneira padr√£o que um servi√ßo pode ser iniciado como um ponto de entrada para uma aplica√ß√£o √© atrav√©s de **Intents**.

Quando o m√©todo **`startService`** √© chamado para iniciar um Servi√ßo, o m√©todo **`onStart`** no Servi√ßo √© executado. Ele funcionar√° indefinidamente at√© que o m√©todo **`stopService`** seja chamado. Se o servi√ßo √© necess√°rio apenas enquanto o cliente est√° conectado, o cliente deve "vincular-se" a ele usando o m√©todo **`bindService`**.

Para um **servi√ßo vinculado** (veja a se√ß√£o anterior), os dados ser√£o passados para o m√©todo **`onBind`**.

Por exemplo, um servi√ßo pode tocar m√∫sica em segundo plano enquanto o usu√°rio est√° em uma aplica√ß√£o diferente, ou pode buscar dados pela rede sem bloquear a intera√ß√£o do usu√°rio com uma atividade.

Um **servi√ßo pode ser exportado, o que permite que outros processos no dispositivo iniciem o servi√ßo**. Por padr√£o, servi√ßos n√£o s√£o exportados, mas isso pode ser configurado no Manifest:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receivers

Broadcasts podem ser vistos como um sistema de mensagens e **broadcast receivers s√£o os ouvintes**. Se uma aplica√ß√£o registrou um receiver para um broadcast espec√≠fico, o c√≥digo desse receiver √© executado quando o sistema envia o broadcast. Note que, neste caso, **v√°rias apps podem receber a mesma mensagem**.

Existem **2 maneiras** que uma app pode **registrar um receiver**: no **Manifest da app ou registrado dinamicamente** no c√≥digo da app usando a chamada de API **`registerReceiver`**. No manifest, voc√™ pode limitar os broadcasts que aceita atrav√©s do **uso de permiss√µes dentro do elemento receiver**. Quando **definido dinamicamente**, voc√™ pode **passar a permiss√£o para o m√©todo `registerReceiver`**.

Em ambos os casos, para registrar o receiver, os **filtros de intent para o receiver s√£o definidos**. Esses filtros de intent s√£o os broadcasts que devem acionar o receiver.

Quando os broadcasts espec√≠ficos para os quais o receiver est√° registrado s√£o enviados, **`onReceive`** na classe BroadcastReceiver √© **executado**.

Uma aplica√ß√£o pode registrar um receiver para a mensagem de bateria baixa, por exemplo, e mudar seu comportamento com base nessa informa√ß√£o.

Broadcasts podem ser **ass√≠ncronos** (todos os receivers recebem) ou **s√≠ncronos** (o broadcast √© recebido de maneira ordenada com base na prioridade definida para receb√™-lo).

{% hint style="danger" %}
**Note que qualquer aplica√ß√£o pode se definir como prioridade m√°xima para receber um Broadcast.**
{% endhint %}

Para **examinar** o **c√≥digo** implementado em um Broadcast Receiver, voc√™ precisa procurar pelo m√©todo **`onReceive`** da classe do receiver.\
Note que **Broadcasts Ordenados podem descartar o Intent recebido ou at√© modific√°-lo** usando um dos m√©todos setter. Portanto, os **receivers devem validar os dados**.

### Content Provider

Content Providers s√£o a maneira de **apps compartilharem dados estruturados**, como bancos de dados relacionais. Portanto, √© muito importante usar **permiss√µes** e definir o n√≠vel de prote√ß√£o apropriado para proteg√™-los.\
Content Providers podem usar os atributos **`readPermission`** e **`writePermission`** para especificar quais permiss√µes uma app deve ter. **Essas permiss√µes t√™m preced√™ncia sobre o atributo de permiss√£o**.\
Al√©m disso, eles tamb√©m podem **permitir exce√ß√µes tempor√°rias** definindo **`grantUriPermission`** como verdadeiro e depois configurando os par√¢metros apropriados no elemento **`grant-uri-permission`** dentro do elemento provider no arquivo de manifesto.

O **`grant-uri-permission`** tem tr√™s atributos: path, pathPrefix e pathPattern:

* **path**: Permite especificar o caminho inteiro a excluir
* **pathPrefix**: Permite especificar o in√≠cio do caminho
* **pathPattern**: Permite o uso de curingas e substitui√ß√µes simb√≥licas para obter um controle mais granular.

√â **importante validar e higienizar a entrada recebida** para evitar vulnerabilidades potenciais como inje√ß√£o de SQL.

**Recursos do Content Provider:**

* O componente Content Provider fornece dados de uma aplica√ß√£o para outras mediante solicita√ß√£o.
* Voc√™ pode armazenar os dados no sistema de arquivos, em um banco de dados SQLite, na web ou em qualquer outro local de armazenamento persistente que sua app possa acessar.
* Atrav√©s do content provider, outras apps podem consultar ou at√© modificar os dados (se o content provider permitir).
* Content Provider √© √∫til em casos em que uma app deseja compartilhar dados com outra app.
* √â muito semelhante a bancos de dados e possui quatro m√©todos.
* insert()
* update()
* delete()
* query()

**FileProvider**

Este √© um tipo de Content Provider que ir√° **compartilhar arquivos** de uma pasta. Voc√™ pode declarar um file provider assim:
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Observe o atributo **`android:exported`** porque se estiver **`true`**, aplicativos externos poder√£o acessar as pastas compartilhadas.\
Note que a configura√ß√£o `android:resource="@xml/filepaths"` est√° indicando que o arquivo _res/xml/filepaths.xml_ cont√©m a configura√ß√£o de **quais pastas** este **FileProvider** vai **compartilhar**. Este √© um exemplo de como indicar para compartilhar uma pasta nesse arquivo:
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
```markdown
Compartilhar algo como **`path="."`** pode ser **perigoso** mesmo que o provedor n√£o seja exportado se houver outra vulnerabilidade em alguma parte do c√≥digo que tentou acessar esse provedor.\
Voc√™ poderia **acessar** uma **imagem** dentro dessa pasta com `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

O elemento `<paths>` pode ter v√°rios filhos, cada um especificando um diret√≥rio diferente para compartilhar. Al√©m do elemento **`<files-path>`**, voc√™ pode usar o elemento **`<external-path>`** para compartilhar diret√≥rios no **armazenamento externo**, e o elemento **`<cache-path>`** para compartilhar diret√≥rios no seu **diret√≥rio de cache interno**.\
[Para mais informa√ß√µes sobre atributos espec√≠ficos de provedores de arquivo, acesse aqui.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[Mais informa√ß√µes sobre FileProviders aqui](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

WebViews s√£o efetivamente **navegadores web** embutidos em Aplicativos Android.\
O conte√∫do de WebViews pode ser obtido de sites remotos ou pode ser arquivos inclu√≠dos no aplicativo.\
WebViews s√£o **vulner√°veis √†s mesmas vulnerabilidades que afetam qualquer navegador web**. No entanto, existem algumas **configura√ß√µes** que podem ser √∫teis para **limitar** a **superf√≠cie de ataque**.

Existem dois tipos de WebViews no Android:

* O **WebViewClient**, mais adequado para renderiza√ß√£o simples de HTML. Este n√£o executar√° a fun√ß√£o de alerta JS. Portanto, testes de XSS usando essa fun√ß√£o ser√£o inv√°lidos.
* O **WebChrome** **client**, √© um navegador Chrome.

Note que **navegadores WebView n√£o t√™m acesso aos cookies do navegador nativo**.

Para carregar uma URL ou arquivo √© poss√≠vel usar as fun√ß√µes **`loadUrl`**, **`loadData`** ou **`loadDataWithBaseURL`**. **√â importante acessar apenas URLs sanitizadas.**\
A seguran√ßa do WebView pode ser configurada atrav√©s do objeto **`WebSettings`**.\
Por exemplo, a execu√ß√£o de c√≥digo JS pode ser desativada usando o m√©todo **`setJavaScriptEnabled`** com o valor **`false`**. Isso ir√° **remover** a possibilidade de um **XSS** e outras vulnerabilidades relacionadas a JS.

A funcionalidade "Bridge" do JavaScript **injeta objetos Java em um WebView tornando-os acess√≠veis ao JS**. A partir do Android 4.2, os m√©todos devem ser anotados com **`@JavascriptInterface`** para serem acess√≠veis ao JavaScript.

Se **`true`** for passado para **`setAllowContentAccess`**, **WebViews poder√£o acessar Content Providers** via esquema **`content://`**. Isso obviamente representa um risco de seguran√ßa. Note que se esse acesso for concedido, √© muito importante **garantir** que a URL **`content://`** seja **segura**.

Por padr√£o, arquivos locais podem ser acessados por WebViews via URLs file://, mas existem v√°rias maneiras de prevenir esse comportamento:

* Passar **`false`** para **`setAllowFileAccess`**, impede o acesso ao sistema de arquivos com exce√ß√£o de ativos via `file:///android_asset` _e_ `file:///android_res`. Esses caminhos devem ser usados apenas para dados n√£o sens√≠veis (como imagens), ent√£o isso deve ser seguro.
* O m√©todo **`setAllowFileAccess`** indica se um caminho de uma URL `file://` deve ser capaz de acessar o conte√∫do de outras URLs de esquema de arquivo.
* O m√©todo **`setAllowUniversalAccessFromFileURLs`** indica se um caminho de uma URL `file://` deve ser capaz de acessar conte√∫do de qualquer origem.

## Outros Componentes de Aplicativos

### **Assinatura de Aplicativos**

* O Android exige que **todos os aplicativos sejam assinados digitalmente com um certificado** antes de poderem ser instalados. O Android usa esse certificado para identificar o autor de um aplicativo.
* Para executar aplicativos no dispositivo, eles devem ser assinados. Quando um aplicativo √© instalado em um dispositivo, o **gerenciador de pacotes verifica** se o aplicativo foi devidamente assinado com o certificado no arquivo apk ou n√£o.
* O aplicativo pode ser autoassinado ou pode ser assinado por uma AC.
* A assinatura de aplicativos garante que um aplicativo n√£o possa acessar outro aplicativo, exceto por meio de IPC bem definido e tamb√©m que seja passado sem modifica√ß√µes para o dispositivo.

### **Verifica√ß√£o de Aplicativos**

* O Android 4.2 e vers√µes posteriores suportam a verifica√ß√£o de aplicativos. Os usu√°rios podem optar por ativar a "Verifica√ß√£o de Aplicativos" e ter aplicativos avaliados por um verificador de aplicativos antes da instala√ß√£o.
* A verifica√ß√£o de aplicativos pode alertar o usu√°rio se eles tentarem instalar um aplicativo que possa ser prejudicial; se um aplicativo for especialmente ruim, ele pode bloquear a instala√ß√£o.

## Gerenciamento de Dispositivos M√≥veis

MDM ou Gerenciamento de Dispositivos M√≥veis s√£o conjuntos de software usados para **garantir controle e requisitos de seguran√ßa** sobre dispositivos m√≥veis. Esses conjuntos usam os recursos referidos como API de Administra√ß√£o de Dispositivos e requerem que um aplicativo Android seja instalado.

Geralmente, as solu√ß√µes de MDM realizam fun√ß√µes como impor pol√≠ticas de senha, for√ßar a criptografia de armazenamento e habilitar a limpeza remota de dados do dispositivo.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encontre vulnerabilidades que importam mais para que voc√™ possa corrigi-las mais rapidamente. Intruder rastreia sua superf√≠cie de ataque, executa varreduras de amea√ßas proativas, encontra problemas em toda a sua pilha de tecnologia, de APIs a aplicativos web e sistemas em nuvem. [**Experimente gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoje.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**merchandising oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas dicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
```
