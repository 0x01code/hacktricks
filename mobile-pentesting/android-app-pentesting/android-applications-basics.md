# Androidアプリケーションの基礎

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>こちら</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)をフォローする
- **ハッキングトリックを共有するには、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて迅速に修正できるようにしましょう。Intruderは、攻撃対象を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリケーション、クラウドシステムまでの問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm_source=referral\&utm_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Androidセキュリティモデル

**2つのレイヤーがあります：**

- **OS**：インストールされたアプリケーションを互いに分離します。
- **アプリケーション自体**：開発者が**特定の機能を公開**し、アプリケーションの機能を構成できるようにします。

### UID分離

**各アプリケーションには特定のユーザーIDが割り当てられます**。これはアプリのインストール中に行われ、**アプリは自分のユーザーIDで所有されているファイルまたは共有ファイルにのみアクセス**できます。したがって、アプリ自体、OSの特定のコンポーネント、およびルートユーザーだけがアプリのデータにアクセスできます。

### UID共有

**2つのアプリケーションを同じUIDを使用するように構成できます**。これは情報を共有するのに役立ちますが、1つが侵害されると両方のアプリケーションのデータが侵害されます。このため、この動作は**推奨されていません**。\
**同じUIDを共有するには、アプリケーションはマニフェストで同じ`android:sharedUserId`値を定義する必要があります。**

### サンドボックス

**Androidアプリケーションサンドボックス**を使用すると、**各アプリケーション**を**別のプロセスとして別のユーザーIDで実行**できます。各プロセスには独自の仮想マシンがあり、アプリのコードは他のアプリから隔離されて実行されます。\
Android 5.0（L）からは**SELinux**が強制されています。基本的に、SELinuxはすべてのプロセスの相互作用を拒否し、それらの間で**予想される相互作用のみを許可するポリシーを作成**しました。

### 権限

**アプリをインストールし、権限を要求するとき**、アプリは**AndroidManifest.xml**ファイルの**`uses-permission`**要素で構成された権限を要求しています。**uses-permission**要素は、**name** **属性内の要求された権限の名前**を示します。**maxSdkVersion**属性もあり、指定されたバージョンよりも高いバージョンでは権限を要求しなくなります。\
Androidアプリケーションは最初からすべての権限を要求する必要はなく、**動的に権限を要求**することもできますが、すべての権限は**マニフェストで宣言**されている必要があります。

アプリが機能を公開すると、**指定された権限を持つアプリにのみアクセスを制限**できます。\
権限要素には3つの属性があります：

- 権限の**名前**
- 権限グループをグループ化する**permission-group**属性
- 権限が付与される方法を示す**protection-level**。4つのタイプがあります：
  - **Normal**：アプリに**既知の脅威がない**場合に使用されます。ユーザーは**承認を求められません**。
  - **Dangerous**：権限が要求されたアプリケーションに**一部の昇格アクセス**を付与することを示します。**ユーザーは承認を求められます**。
  - **Signature**：**エクスポートしているコンポーネントと同じ証明書で署名されたアプリ**のみが権限を付与されることができます。これは最も強力な保護のタイプです。
  - **SignatureOrSystem**：**エクスポートしているコンポーネントと同じ証明書で署名されたアプリ**または**システムレベルのアクセスで実行されているアプリ**のみが権限を付与されることができます。

## 事前インストールされたアプリケーション

これらのアプリは一般的に**`/system/app`**または**`/system/priv-app`**ディレクトリにあり、一部は**最適化されています**（`classes.dex`ファイルが見つからない場合があります）。これらのアプリケーションは、**rootとして実行されていることがあるため**、確認する価値があります。

- **AOSP**（Androidオープンソースプロジェクト）**ROM**に含まれるもの
- デバイスの**製造元**によって追加されたもの
- 携帯電話プロバイダーによって追加されたもの（それらから購入した場合）

## ルート化

物理的なAndroidデバイスでルートアクセスを取得するには、通常、デバイスとバージョンに**特定の脆弱性を悪用**する必要があります。\
悪用が成功すると、通常、Linuxの`su`バイナリがユーザーのPATH環境変数で指定された場所（`/system/xbin`など）にコピーされます。

suバイナリが構成されると、他のAndroidアプリが`su`バイナリとのリクエストを処理するために使用されます。**Superuser**や**SuperSU**などのアプリがこれに該当し、Google Playストアで入手できます。

{% hint style="danger" %}
ルート化プロセスは非常に危険であり、デバイスに重大な損害を与える可能性があります
{% endhint %}

### ROM

カスタムファームウェアをインストールしてOSを置き換えることができます。これにより、古いデバイスの有用性を拡張したり、ソフトウェアの制限をバイパスしたり、最新のAndroidコードにアクセスしたりすることができます。\
**OmniROM**と**LineageOS**は、最も人気のあるファームウェアの2つです。

デバイスをルート化する必要があるとは限らないことに注意してください。**一部のメーカーは**、ブートローダーのアンロックを**十分に文書化された安全な方法**で許可しています。

### 影響

デバイスがルート化されると、任意のアプリがルートアクセスを要求できます。悪意のあるアプリがそれを取得した場合、ほとんどすべてにアクセスし、電話を破損させることができます。

## Androidアプリケーションの基本 <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Androidアプリケーションの形式は_APKファイル形式_と呼ばれます。実質的には**ZIPファイル**です（ファイル拡張子を.zipに変更することで、内容を抽出して表示できます）。
- APKの内容（完全ではありません）
  - **AndroidManifest.xml**
  - resources.arsc/strings.xml
  - resources.arsc：バイナリXMLなど、事前にコンパイルされたリソースを含む
  - res/xml/files\_paths.xml
  - META-INF/
  - ここに証明書があります！
  - **classes.dex**
  - デフォルトでアプリが実行するコンパイルされたJava（またはKotlin）コードを表すDalvikバイトコードが含まれています。
  - lib/
  - CPUアーキテクチャごとにサブディレクトリに分かれたネイティブライブラリが格納されています。
    - `armeabi`：ARMベースのプロセッサ用のコード
    - `armeabi-v7a`：ARMv7およびそれ以上のプロセッサ用のコード
    - `x86`：X86プロセッサ用のコード
    - `mips`：MIPSプロセッサ用のコードのみ
  - assets/
  - アプリが必要とするさまざまなファイルを格納し、追加のネイティブライブラリやDEXファイルを含む場合があります。これは、マルウェアの作者が追加のコードを隠すために使用することがあります。
  - res/
  - resources.arscにコンパイルされていないリソースが含まれています

### **Dalvik & Smali**

Android開発では、アプリの作成には**JavaまたはKotlin**が使用されます。デスクトップアプリケーションのようにJVMを使用する代わりに、Androidはこのコードを**Dalvik Executable（DEX）バイトコード**にコンパイルします。以前はDalvik仮想マシンがこのバイトコードを処理していましたが、新しいAndroidバージョンではAndroid Runtime（ART）が引き継いでいます。

逆コンパイルには、**Smali**が重要です。これは、ソースコードをバイトコード命令に変換することで、アセンブリ言語のように機能するDEXバイトコードの人間が読めるバージョンです。この文脈では、アセンブリと逆アセンブリのツールを指すSmaliとbaksmaliがあります。

***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて迅速に修正できるようにしましょう。Intruderは、攻撃対象を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリケーション、クラウドシステムまでの問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm_source=referral\&utm_campaign=hacktricks)。
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### 暗黙的インテント

インテントは、Intentコンストラクタを使用してプログラムで作成されます：
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**アクション**は以前に宣言されたインテントの**ACTION\_SEND**であり、**Extra**はmailto **Uri**です（Extraはインテントが期待している追加情報です）。

このインテントは、次の例のようにマニフェスト内で宣言する必要があります：
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
インテントフィルタは、メッセージを受信するために**アクション**、**データ**、および**カテゴリ**と一致する必要があります。

"インテント解決"プロセスは、どのアプリが各メッセージを受信するかを決定します。このプロセスは、**priority属性**を考慮します。これは**intent-filter宣言**で設定でき、**優先度が高いものが選択されます**。この優先度は-1000から1000の間で設定でき、アプリケーションは`SYSTEM_HIGH_PRIORITY`値を使用できます。**競合**が発生すると、"選択"ウィンドウが表示され、**ユーザーが決定**できます。

### 明示的インテント

明示的インテントは、ターゲットとするクラス名を指定します。
```java
Intent downloadIntent = new (this, DownloadService.class):
```
他のアプリケーションで以前に宣言されたインテントにアクセスするためには、次のようにします:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### 保留中のインテント

これにより、他のアプリケーションが**あなたのアプリケーションの代わりにアクションを実行**できます。保留中のインテントを構築する際には、**インテントと実行するアクションを指定する必要があります**。**宣言されたインテントが明示的でない**場合（どのインテントが呼び出せるかを宣言していない場合）、**悪意のあるアプリケーションが被害者アプリの代わりに宣言されたアクションを実行**できます。さらに、**アクションが指定されていない**場合、悪意のあるアプリは**被害者の代わりに任意のアクションを実行**できます。

### ブロードキャストインテント

以前のインテントとは異なり、ブロードキャストインテントは**複数のアプリに受信される**ことができます。ただし、APIバージョン14以降では、Intent.set Packageを使用して**メッセージを受信するアプリを指定**することが可能です。

また、ブロードキャストを送信する際に**パーミッションを指定することも可能**です。受信アプリはそのパーミッションを持っている必要があります。

ブロードキャストには**2つのタイプ**があります：**通常**（非同期）と**順序付け**（同期）。**順序**は**レシーバ内で構成された優先度に基づいて**います。**各アプリはブロードキャストを処理、中継、または破棄できます**。

`Context`クラスから`sendBroadcast(intent, receiverPermission)`関数を使用して**ブロードキャストを送信**することが可能です。\
また、**`LocalBroadCastManager`**から**`sendBroadcast`**関数を使用すると、**メッセージがアプリを離れることはなくなります**。これにより、レシーバコンポーネントをエクスポートする必要すらありません。

### スティッキーブロードキャスト

この種のブロードキャストは、**送信後も長い間アクセスできます**。\
これらはAPIレベル21で非推奨となり、**使用しないことが推奨**されています。\
**これにより、任意のアプリケーションがデータを嗅ぎ取るだけでなく、変更することも可能**です。

**`sendStickyBroadcast`**や**`sendStickyBroadcastAsUser`**など、"sticky"という単語を含む関数を見つけた場合は、**影響を確認し、削除を試みてください**。

## ディープリンク / URLスキーム

Androidアプリケーションでは、**ディープリンク**が使用され、URLを介して直接アクション（インテント）を開始します。これは、アクティビティ内で特定の**URLスキーム**を宣言することによって行われます。Androidデバイスがこのスキームを持つURLにアクセスしようとすると、アプリケーション内の指定されたアクティビティが起動されます。

スキームは**`AndroidManifest.xml`**ファイルに宣言する必要があります。
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
前の例からのスキームは `exampleapp://`（**`category BROWSABLE`** も参照）  

次に、データフィールドで **ホスト** と **パス** を指定できます：
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Webからアクセスするには、次のようにリンクを設定することができます:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
アプリで実行される**コードを見つける**には、ディープリンクで呼び出されるアクティビティに移動し、**`onNewIntent`** 関数を検索します。

HTML ページを使用せずに[ディープリンクを呼び出す方法](./#exploiting-schemes-deep-links)を学びます。

## AIDL - Android Interface Definition Language

**Android Interface Definition Language (AIDL)** は、Android アプリケーション内のクライアントとサービス間の通信を容易にするために設計されています。別のプロセスのメモリに直接アクセスすることは Android では許可されていないため、AIDL はオブジェクトをオペレーティングシステムが理解する形式に変換することで、異なるプロセス間の通信を容易にします。

### 主要な概念

- **バウンド サービス**: これらのサービスは IPC に AIDL を使用し、アクティビティやコンポーネントがサービスにバインドしてリクエストを行い、レスポンスを受け取ることを可能にします。サービスのクラス内の `onBind` メソッドは、相互作用を開始するために重要であり、脆弱性を探すためのセキュリティレビューの重要な領域としてマークされています。

- **Messenger**: バウンド サービスとして機能する Messenger は、`onBind` メソッドを介してデータの処理に焦点を当てた IPC を可能にします。このメソッドを注意深く検査し、安全でないデータ処理や機密関数の実行がないかを確認することが重要です。

- **Binder**: AIDL の抽象化により Binder クラスの直接的な使用は一般的ではありませんが、Binder は異なるプロセスのメモリ空間間でのデータ転送を可能にするカーネルレベルのドライバーとして機能します。さらなる理解のために、次のリソースが利用可能です: [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)。

## コンポーネント

これには、**アクティビティ、サービス、ブロードキャスト レシーバー、プロバイダー** が含まれます。

### ランチャーアクティビティとその他のアクティビティ

Android アプリでは、**アクティビティ**は画面のようなもので、アプリのユーザーインターフェースの異なる部分を表示します。アプリには多くのアクティビティがあり、それぞれがユーザーに一意の画面を表示します。

**ランチャーアクティビティ**はアプリへのメインゲートウェイであり、アプリのアイコンをタップすると起動されます。これはアプリのマニフェストファイルで特定の MAIN および LAUNCHER インテントで定義されています:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
## Android Applications Basics

Not all apps need a launcher activity, especially those without a user interface, like background services.

Activities can be made available to other apps or processes by marking them as "exported" in the manifest. This setting allows other apps to start this activity:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
しかし、別のアプリからアクティビティにアクセスすることは常にセキュリティリスクとは限りません。懸念が生じるのは、機密データが適切に共有されていない場合であり、これは情報漏洩につながる可能性があります。

アクティビティのライフサイクルは、**`onCreate`メソッド**で始まり、UIの設定とアクティビティのユーザーとのやり取りの準備を行います。

### アプリケーションのサブクラス

Android開発では、アプリは[Application](https://developer.android.com/reference/android/app/Application)クラスの**サブクラス**を作成するオプションがありますが、これは必須ではありません。このようなサブクラスが定義されている場合、そのサブクラスがアプリ内で最初にインスタンス化されます。このサブクラスで実装されている場合、**`attachBaseContext`**メソッドは**`onCreate`**メソッドの前に実行されます。このセットアップにより、アプリケーションの残りの部分が開始される前に初期化を行うことができます。
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### サービス

[サービス](https://developer.android.com/guide/components/services)はユーザーインターフェースなしでタスクを実行できる**バックグラウンドオペレータ**です。これらのタスクは、ユーザーが異なるアプリケーションに切り替えても継続して実行されるため、サービスは**長時間実行される操作**にとって重要です。

サービスは多目的であり、さまざまな方法で開始できます。**インテント**は、サービスを起動するための主要な方法であり、アプリケーションのエントリーポイントとして機能します。サービスを`startService`メソッドを使用して開始すると、その`onStart`メソッドが実行され、`stopService`メソッドが明示的に呼び出されるまで実行を維持します。また、サービスの役割がアクティブなクライアント接続に依存する場合、`bindService`メソッドを使用してクライアントをサービスにバインドし、データの受け渡しに`onBind`メソッドを使用します。

サービスの興味深い応用例には、ユーザーがアプリとのやり取りを妨げることなく、バックグラウンドで音楽を再生したり、ネットワークデータを取得したりすることが挙げられます。さらに、サービスは**エクスポート**を介して同じデバイス上の他のプロセスからアクセス可能にすることができます。これはデフォルトの動作ではなく、Android Manifestファイルで明示的に構成する必要があります。
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### ブロードキャストレシーバ

**ブロードキャストレシーバ**は、メッセージングシステムにおけるリスナーとして機能し、複数のアプリケーションがシステムからの同じメッセージに応答できるようにします。アプリは、**マニフェスト**を介してまたはアプリのコード内で**`registerReceiver`** APIを使用して、**2つの主要な方法**で**レシーバを登録**できます。マニフェストでは、ブロードキャストは権限でフィルタリングされますが、動的に登録されたレシーバは登録時に権限を指定することもできます。

**インテントフィルタ**は、登録方法に関係なく重要であり、どのブロードキャストがレシーバをトリガーするかを決定します。一致するブロードキャストが送信されると、レシーバの**`onReceive`**メソッドが呼び出され、アプリは適切に反応することができます。たとえば、低バッテリーアラートに応答して動作を調整することができます。

ブロードキャストは、**非同期**であり、順不同ですべてのレシーバに到達するか、**同期**であり、優先順位に基づいてブロードキャストを受信するかのいずれかです。ただし、どのアプリも自分自身を優先してブロードキャストを傍受できる可能性があるため、潜在的なセキュリティリスクに注意することが重要です。

レシーバの機能を理解するには、そのクラス内の**`onReceive`**メソッドを探します。このメソッドのコードは受信したインテントを操作でき、特に**順序付けられたブロードキャスト**では、レシーバによるデータの検証が必要であることが強調されます。これにより、インテントが変更されたり破棄されたりする可能性があります。

### コンテンツプロバイダ

**コンテンツプロバイダ**は、アプリケーション間で**構造化されたデータを共有**するために不可欠であり、データセキュリティを確保するために**権限の実装**の重要性を強調しています。これにより、データベース、ファイルシステム、Webなど、さまざまなソースからデータにアクセスできます。**`readPermission`**や**`writePermission`**などの特定の権限は、アクセスを制御するために重要です。また、一時的なアクセスは、アプリのマニフェストで**`grantUriPermission`**設定を介して付与でき、`path`、`pathPrefix`、`pathPattern`などの属性を活用して詳細なアクセス制御を行うことができます。

脆弱性（SQLインジェクションなど）を防ぐために、入力検証が極めて重要です。コンテンツプロバイダは、`insert()`、`update()`、`delete()`、`query()`などの基本操作をサポートしており、データの操作とアプリケーション間での共有を容易にしています。

**FileProvider**は、ファイルを安全に共有することに焦点を当てた特殊なコンテンツプロバイダです。フォルダへのアクセスを制御するための特定の属性でアプリのマニフェストで定義され、`android:exported`や`android:resource`などの属性を利用してフォルダ構成を指定します。機密データが誤って公開されるのを避けるために、ディレクトリを共有する際には注意が必要です。

FileProviderの例示的なマニフェスト宣言：
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
そして、`filepaths.xml` で共有フォルダを指定する例:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews are like **mini web browsers** inside Android apps, pulling content either from the web or from local files. They face similar risks as regular browsers, yet there are ways to **reduce these risks** through specific **settings**.

Android offers two main WebView types:

- **WebViewClient** is great for basic HTML but doesn't support the JavaScript alert function, affecting how XSS attacks can be tested.
- **WebChromeClient** acts more like the full Chrome browser experience.

A key point is that WebView browsers do **not share cookies** with the device's main browser.

For loading content, methods such as ````loadUrl````, ````loadData````, and ````loadDataWithBaseURL```` are available. It's crucial to ensure these URLs or files are **safe to use**. Security settings can be managed via the ````WebSettings```` class. For instance, disabling JavaScript with ````setJavaScriptEnabled(false)```` can prevent XSS attacks.

The JavaScript "Bridge" lets Java objects interact with JavaScript, requiring methods to be marked with ````@JavascriptInterface```` for security from Android 4.2 onwards.

Allowing content access (````setAllowContentAccess(true)````) lets WebViews reach Content Providers, which could be a risk unless the content URLs are verified as secure.

To control file access:
- Disabling file access (````setAllowFileAccess(false)````) limits access to the filesystem, with exceptions for certain assets, ensuring they're only used for non-sensitive content.

## Other App Components and Mobile Device Management

### **Digital Signing of Applications**

- **Digital signing** is a must for Android apps, ensuring they're **authentically authored** before installation. This process uses a certificate for app identification and must be verified by the device's package manager upon installation. Apps can be **self-signed or certified by an external CA**, safeguarding against unauthorized access and ensuring the app remains untampered during its delivery to the device.

### **App Verification for Enhanced Security**

- Starting from **Android 4.2**, a feature called **Verify Apps** allows users to have apps checked for safety before installation. This **verification process** can warn users against potentially harmful apps, or even prevent the installation of particularly malicious ones, enhancing user security.

### **Mobile Device Management (MDM)**

- **MDM solutions** provide **oversight and security** for mobile devices through **Device Administration API**. They necessitate the installation of an Android app to manage and secure mobile devices effectively. Key functions include **enforcing password policies**, **mandating storage encryption**, and **permitting remote data wipe**, ensuring comprehensive control and security over mobile devices.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて、迅速に修正できます。Intruderは攻撃対象を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリ、クラウドシステムまで、技術スタック全体で問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) 今すぐ。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**をフォローする。**
* **HackTricks**と**HackTricks Cloud**のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>
