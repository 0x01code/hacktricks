# Android 应用基础

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 HackTricks 中看到您的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs**](https://opensea.io/collection/the-peass-family) 收藏
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

找到对您最重要的漏洞，以便更快修复它们。Intruder 跟踪您的攻击面，运行主动威胁扫描，在您的整个技术堆栈中找到问题，从 API 到 web 应用程序和云系统。[**今天免费试用**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Android 安全模型

**有两层：**

* **操作系统**，它使安装的应用程序彼此隔离。
* **应用程序本身**，它允许开发人员**暴露某些功能**并配置应用程序能力。

### UID 分离

**每个应用程序都分配了一个特定的用户 ID**。这是在安装应用程序时完成的，因此**应用程序只能与其用户 ID 或共享**文件拥有的文件进行交互。因此，只有应用程序本身、操作系统的某些组件和 root 用户可以访问应用程序数据。

### UID 共享

**两个应用程序可以配置为使用相同的 UID**。这对于共享信息很有用，但如果其中一个受到损害，两个应用程序的数据都将受到损害。这就是为什么这种行为是**不鼓励**的。\
**要共享相同的 UID，应用程序必须在其清单中定义相同的 `android:sharedUserId` 值。**

### 沙箱化

**Android 应用程序沙箱**允许**每个应用程序**作为**单独的进程在单独的用户 ID 下运行**。每个进程都有自己的虚拟机，因此应用程序的代码与其他应用程序隔离运行。\
从 Android 5.0(L) 开始强制执行 **SELinux**。基本上，SELinux 拒绝了所有进程交互，然后创建策略来**只允许它们之间的预期交互**。

### 权限

当您安装**应用程序并请求权限**时，应用程序正在请求在**AndroidManifest.xml** 文件中配置的 **`uses-permission`** 元素中的权限。**uses-permission** 元素在**名称**属性中指示请求的权限的名称。它还具有**maxSdkVersion** 属性，该属性在指定的版本以上停止请求权限。\
请注意，android 应用程序不需要在一开始就请求所有权限，它们也可以**动态请求权限**，但所有权限都必须在**清单中声明**。

当应用程序暴露功能时，它可以限制**只有具有指定权限的应用程序才能访问**。\
权限元素有三个属性：

* 权限的**名称**
* **permission-group** 属性，允许对相关权限进行分组。
* **protection-level** 指示如何授予权限。有四种类型：
  * **Normal**：当对应用程序**没有已知威胁**时使用。用户**无需批准**。
  * **Dangerous**：表明权限授予请求应用程序一些**提升的访问权限**。**用户被要求批准它们**。
  * **Signature**：只有**由与导出组件相同的证书签名的应用程序**才能被授予权限。这是最强的保护类型。
  * **SignatureOrSystem**：只有**由与导出组件相同的证书签名的应用程序**或**具有系统级访问权限的应用程序**才能被授予权限

## 预装应用程序

这些应用程序通常位于 **`/system/app`** 或 **`/system/priv-app`** 目录中，其中一些是**优化过的**（您甚至可能找不到 `classes.dex` 文件）。这些应用程序值得检查，因为有时它们**运行的权限太多**（作为 root）。

* 随 **AOSP**（Android 开源项目）**ROM** 一起提供的
* 由设备**制造商**添加
* 由手机**服务提供商**添加（如果是从他们那里购买的）

## Rooting

为了获得物理 Android 设备的 root 访问权限，通常需要**利用** 1 或 2 个**漏洞**，这些漏洞通常是**特定于**设备和**版本**的。\
一旦漏洞利用成功，通常会将 Linux `su` 二进制文件复制到用户的 PATH 环境变量中指定的位置，如 `/system/xbin`。

配置 su 二进制文件后，另一个 Android 应用程序用于与 `su` 二进制文件交互并**处理 root 访问请求**，如 **Superuser** 和 **SuperSU**（在 Google Play 商店中可用）。

{% hint style="danger" %}
请注意，rooting 过程非常危险，可能会严重损坏设备
{% endhint %}

### ROMs

可以**替换操作系统安装自定义固件**。这样做可以扩展旧设备的用途，绕过软件限制或获取最新的 Android 代码。\
**OmniROM** 和 **LineageOS** 是两个最受欢迎的固件。

请注意，**并不总是需要 root 设备**来安装自定义固件。**一些制造商允许**以记录良好且安全的方式解锁他们的引导加载程序。

### 影响

一旦设备被 root，任何应用程序都可以请求以 root 身份访问。如果恶意应用程序获得了它，它几乎可以访问所有内容，并且能够损坏手机。

## Android 应用程序基础 <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

这个介绍摘自 [https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html](https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html)

### 基础复习 <a href="#fundamentals-review" id="fundamentals-review"></a>

* Android 应用程序以 _APK 文件格式_ 存在。**APK 基本上是一个 ZIP 文件**。（您可以将文件扩展名重命名为 .zip 并使用 unzip 打开并查看其内容。）
* APK 内容（不详尽）
  * **AndroidManifest.xml**
  * resources.arsc/strings.xml
  * resources.arsc：包含预编译资源的文件，例如二进制 XML。
  * res/xml/files\_paths.xml
  * META-INF/
  * 证书就在这里！
  * **classes.dex**
  * 应用程序的 Dalvik 字节码，以 DEX 文件格式编译。**这是应用程序将默认运行的 Java（或 Kotlin）代码**。
  * lib/
  * 应用程序的本地库，默认情况下位于此处！在 lib/ 目录下，有针对特定 CPU 的目录。
    * `armeabi`：仅为所有基于 ARM 的处理器编译的代码
    * `armeabi-v7a`：仅为所有基于 ARMv7 及以上处理器编译的代码
    * `x86`：仅为 X86 编译的代码
    * `mips`：仅为 MIPS 处理器编译的代码
  * assets/
  * 应用程序可能需要的任何其他文件。
  * 此处可能包括额外的本地库或 DEX 文件。当恶意软件作者想尝试“隐藏”额外的代码，本地或 Dalvik，不包括在默认位置时，尤其会发生这种情况。
  * res/
  * 包含未编译到 resources.arsc 中的资源的目录

### **Dalvik & Smali**

大多数 Android 应用程序是用 Java 编写的。Kotlin 也得到支持，并且与 Java 兼容。为了简单起见，对于本次研讨会的其余部分，当我提到“Java”时，您可以假设我指的是“Java 或 Kotlin”。**与桌面应用程序一样，Java 代码在 Java 虚拟机**（JVM）中运行，而在 Android 中，**Java 被编译为 \_Dalvik 可执行（DEX）字节码**\_\*\* 格式\*\*。对于 Android 的早期版本，字节码由 Dalvik 虚拟机翻译。对于 Android 的较新版本，使用 Android 运行时（ART）。\
如果开发人员用 Java 编写代码并将其编译为 DEX 字节码，为了进行逆向工程，我们会反向操作。\
\\

![开发人员流程的流程图。Java 到 DEX 字节码](https://maddiestone.github.io/AndroidAppRE/images/DevelopersFlow.jpg)

![逆向工程师流程的流程图。DEX 字节码到 SMALI 到 Decompiled Java](https://maddiestone.github.io/AndroidAppRE/images/ReversersFlow.jpg)

**Smali 是 Dalvik 字节码的可读版本**。从技术上讲，Smali 和 baksmali 是工具的名称（分别是汇编器和反汇编器），但在 Android 中，我们经常使用“Smali”一词来指代指令。如果您在编译的 C/C++ 代码上进行过逆向工程或计算机架构。**SMALI 就像汇编语言：介于更高级别的源代码和字节码之间**。

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

找到对您最重要的漏洞，以便更快修复它们。Intruder 跟踪您的攻击面，运行主动威胁扫描，在您的整个技术堆栈中找到问题，从 API 到 web 应用程序和云系统。[**今天免费试用**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Intents

Intents 是 Android 应用程序之间或与其他应用程序通信的主要方式。这些消息对象也可以在应用程序或组件之间传递数据，类似于 HTTP 通信中使用的 GET/POST 请求。

因此，Intent 基本上是在组件之间传递的**消息**。Intents **可以定向**到特定组件或应用程序，**也可以在没有特定接收者的情况下发送**。\
简单来说，Intent 可以用于：

* 启动一个 Activity，通常为应用程序打开用户界面
* 作为广播通知系统和应用程序的变化
* 启动、停止和与后台服务通信
* 通过 ContentProviders 访问数据
* 作为回调处理事件

实现不当可能导致数据泄露、受限功能被调用和程序流程被操纵。

### Intent-Filter

Intent Filter 指定活动、服务或广播接收器可以响应的**Intent 类型**。它指定活动或服务可以做什么以及接收器可以处理的广播类型。它允许相应的组件接收声明类型的 Intents。Intent Filters 通常**通过 AndroidManifest.xml 文件定义**。对于**广播接收器**，也可以在**编码中定义**。Intent Filter 由其类别、动作和数据过滤器定义。它还可以包含额外的元数据。

在 Android 中，当**`exported`** 设置为 **`true`** 时，活动/服务/内容提供者/广播接收器是**公开的**，但如果**清单为其指定了 Intent filter**，组件**也是公开的**。然而，\
开发人员可以**明确地将组件设为私有**（不管任何 intent filters）\
通过在清单文件中为每个组件设置 \*\* `exported` 属性为 `false`\*\*。\
开发人员还可以设置**`permission`** 属性来**要求特定权限以访问**组件，从而限制对组件的访问。

### 隐式 Intents

Intents 是使用 Intent 构造函数在程序中创建的：
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
```markdown
**动作**是之前声明的意图是 **ACTION\_SEND**，而**额外数据**是一个mailto **Uri**（额外数据是意图期望的额外信息）。

此意图应在清单中声明，如下例所示：
```
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
一个intent-filter需要匹配**动作**、**数据**和**类别**来接收消息。

"Intent解析"过程决定哪个应用应该接收每个消息。这个过程考虑了**优先级属性**，可以在**intent-filter声明**中设置，**优先级较高的将被选中**。这个优先级可以设置在-1000到1000之间，应用程序可以使用`SYSTEM_HIGH_PRIORITY`值。如果出现**冲突**，会出现一个"选择器"窗口，以便**用户可以决定**。

### 显式Intents

一个显式intent指定了它目标的类名：
```java
Intent downloadIntent = new (this, DownloadService.class):
```
在其他应用程序中，为了访问之前声明的intent，你可以使用：
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### 待处理的意图

这些允许其他应用程序**代表您的应用程序采取行动**，使用您的应用程序的身份和权限。构建一个待处理的意图时，应该**指定一个意图和要执行的动作**。如果**声明的意图不是显式的**（没有声明哪个意图可以调用它），一个**恶意应用程序可能会代表受害者应用程序执行声明的动作**。此外，**如果没有指定动作**，恶意应用程序将能够代表受害者执行**任何动作**。

### 广播意图

与前面的意图不同，只被一个应用程序接收，广播意图**可以被多个应用程序接收**。然而，从API版本14开始，**可以指定应该接收消息的应用程序**，使用Intent.set Package。

另外，发送广播时也可以**指定一个权限**。接收应用程序将需要拥有那个权限。

有**两种类型**的广播：**普通**（异步）和**有序**（同步）。**顺序**基于**接收器**元素内配置的**优先级**。**每个应用程序可以处理、转发或丢弃广播。**

可以使用`Context`类中的**`sendBroadcast(intent, receiverPermission)`** 函数**发送**一个**广播**。\
您还可以使用**`LocalBroadCastManager`** 中的 **`sendBroadcast`** 函数确保**消息永远不会离开应用程序**。使用这个您甚至不需要导出接收器组件。

### 粘性广播

这种类型的广播**在发送后很久仍然可以访问**。\
它们在API级别21中被弃用，建议**不要使用它们**。\
**它们允许任何应用程序嗅探数据，但也可以修改数据。**

如果您发现包含“sticky”这个词的函数，如**`sendStickyBroadcast`** 或 **`sendStickyBroadcastAsUser`**，**检查影响并尝试移除它们**。

## 深度链接 / URL方案

**深度链接允许通过URL触发一个意图**。一个应用程序可以在活动中声明一个**URL方案**，所以每次Android设备尝试**使用该方案访问地址**时，应用程序的活动将被调用：

![](<../../.gitbook/assets/image (214).png>)

在这个例子中方案是 `myapp://`（也注意**`category BROWSABLE`**）

如果在`intent-filter`中找到这样的内容：

![](<../../.gitbook/assets/image (263).png>)

那么，它期待的是像 `http://www.example.com/gizmos` 这样的内容

如果你找到这样的内容：

![](<../../.gitbook/assets/image (262).png>)

这将意味着它期待一个以 `example://gizmos` 开头的URL\
在这种情况下，您可以尝试滥用该功能，创建一个带有以下有效载荷的网页。它将尝试导航到任意页面并尝试执行JS：
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
为了找到**将在应用中执行的代码**，请转到被deeplink调用的activity，并搜索函数**`onNewIntent`**。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

学习如何[不使用HTML页面调用深层链接](./#exploiting-schemes-deep-links)。

## AIDL - Android接口定义语言

**Android接口定义语言**（AIDL）允许您定义客户端和服务同意的编程接口，以便使用**进程间通信**（IPC）**相互通信**。在Android上，**一个进程通常无法访问另一个进程的内存**。因此，为了通信，它们需要将对象分解为**操作系统**可以理解的原语，并为您跨越那个边界传输对象。编写执行该传输的代码是乏味的，因此Android使用AIDL为您处理这些工作。）

使用AIDL的服务被称为**绑定服务**。在服务的类中，您会找到**`onBind`**方法。这是**交互开始的地方**，因此它是审查代码寻找潜在漏洞的初始部分。

绑定服务是客户端-服务器接口中的服务器。**它允许组件（如活动）绑定到服务，发送请求，接收响应，并执行进程间通信**（IPC）。绑定服务通常只在为另一个应用程序组件服务时存在，并不会无限期地在后台运行。

### Messenger

Messenger是另一种IPC机制。由于**Messenger也是“绑定服务”**，因此客户端应用传递的数据也通过`onBind`方法处理。因此，代码审查应从此方法开始，并且您应该寻找对敏感功能的调用或对数据的不安全处理。

### Binder

直接调用Binder类是很奇怪的，因为使用AIDL（它抽象了Binder类）要容易得多。但是，了解**Binder是一个内核级驱动程序，它将数据从一个进程的内存移动到另一个进程的内存**（[https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)）是有好处的。

## 组件

这些包括：**活动，服务，广播接收器和提供者。**

### 启动器活动和其他活动

**Android活动**是**Android**应用用户界面的一个屏幕。这样，**Android活动**与桌面应用程序中的窗口非常相似。一个**Android**应用可能包含一个或多个活动，即一个或多个屏幕。

**启动器活动**是大多数人认为的Android应用程序的**入口点**。启动器活动是用户点击应用程序图标时启动的活动。您可以通过查看应用程序的清单来确定启动器活动。启动器活动将列出以下MAIN和LAUNCHER意图。

请记住，并非每个应用程序都会有启动器活动，特别是没有UI的应用程序。没有UI（因此没有启动器活动）的应用程序示例包括在后台执行服务的预安装应用程序，例如语音邮件。
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Activities 可以被导出，允许设备上的其他进程启动该 activity。默认情况下，它们不会被导出，但你可以通过设置来导出它们：
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
请注意，**绕过活动保护并不总是一个漏洞**，您需要检查您获得了哪些数据的访问权限。\
此外，**有些活动会向调用者返回数据**。在这些情况下，您需要搜索 **`setResult`** 方法并检查传递给 Intent 参数的数据。**如果是敏感数据，您可能有一个信息泄露漏洞**，并且可以通过能够与活动通信的应用程序来利用它。

**一个活动的代码从 `onCreate` 方法开始。**

### 应用子类

Android 应用程序可以定义 [Application](https://developer.android.com/reference/android/app/Application) 的**子类**。应用程序可以定义，也可以不定义 Application 的自定义子类。如果 Android 应用程序定义了 Application 子类，**这个类会在应用程序中的任何其他类之前实例化**。

如果在 Application 子类中定义了 **`attachBaseContext`** 方法，它将在 **`onCreate`** 方法之前首先被调用。

### 服务

[服务](https://developer.android.com/guide/components/services) **在没有用户界面的情况下在后台运行。** 它们用于执行**长时间运行的进程，即使用户开始使用其他应用程序**。

它们可以通过多种方式启动，因此是应用程序的入口点。服务作为应用程序入口点的默认启动方式是通过 **Intents**。

当调用 **`startService`** 方法启动服务时，服务中的 **`onStart`** 方法将被执行。它将无限期运行，直到调用 **`stopService`** 方法。如果只有在客户端连接时才需要服务，客户端应该使用 **`bindService`** 方法“绑定”到它。

对于**绑定服务**（见前一节），数据将传递给 **`onBind`** 方法。

例如，服务可能在用户使用其他应用程序时在后台播放音乐，或者在不阻塞用户与活动交互的情况下通过网络获取数据。

**服务可以被导出，允许设备上的其他进程启动服务**。默认情况下服务不会被导出，但可以在 Manifest 中配置：
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### 广播接收器

广播可以被认为是一种消息系统，**广播接收器是监听者**。如果一个应用程序为特定的广播注册了接收器，当系统发送广播时，接收器中的代码就会被执行。注意，在这种情况下**多个应用程序可以接收到相同的消息**。

有**两种方式**可以让应用程序**注册接收器**：在**应用程序的Manifest中注册**或在应用程序的代码中使用**`registerReceiver`** API调用**动态注册**。在manifest中，你可以通过在接收器元素内使用权限来限制你接受的广播。当**动态**定义时，你可以**将权限传递给`registerReceiver`方法**。

在这两种情况下，为了注册接收器，都需要设置**接收器的意图过滤器**。这些意图过滤器是应该触发接收器的广播。

当注册的接收器的特定广播被发送时，BroadcastReceiver类中的**`onReceive`** 方法会被**执行**。

例如，一个应用程序可能会为低电量消息注册一个接收器，并根据该信息改变其行为。

广播可以是**异步的**（每个接收器都接收到它）或**同步的**（根据设置的优先级，广播以有序的方式接收）。

{% hint style="danger" %}
**注意，任何应用程序都可以将自己设置为接收广播的最高优先级。**
{% endhint %}

要**检查**实现在广播接收器中的**代码**，你需要搜索接收器类中的**`onReceive`** 方法。\
注意，**有序广播可以丢弃收到的Intent，甚至可以使用其中的一个设置方法对其进行修改**。因此，**接收器应该验证数据**。

### 内容提供者

内容提供者是**应用程序共享结构化数据**的方式，例如关系型数据库。因此，使用**权限**并设置适当的保护级别来保护它们非常重要。\
内容提供者可以使用**`readPermission`** 和 **`writePermission`** 属性来指定应用程序必须拥有的权限。**这些权限优先于permission属性**。\
此外，它们还可以通过将**`grantUriPermission`** 设置为true，并在manifest文件中的provider元素内配置适当的参数，来**允许临时例外**。

**`grant-uri-permission`** 有三个属性：path、pathPrefix 和 pathPattern：

* **path**：允许指定整个路径以排除
* **pathPrefix**：允许指定路径的开始部分
* **pathPattern**：允许使用通配符和符号替换来获得更细粒度的控制。

**验证和清理接收到的输入非常重要**，以避免潜在的漏洞，如SQL注入。

**内容提供者特点：**

* 内容提供者组件根据请求从一个应用程序向其他应用程序提供数据。
* 你可以将数据存储在文件系统、SQLite数据库、网络上，或者你的应用程序可以访问的任何其他持久存储位置。
* 通过内容提供者，其他应用程序可以查询甚至修改数据（如果内容提供者允许的话）。
* 内容提供者在应用程序想要与另一个应用程序共享数据时非常有用。
* 它与数据库非常相似，有四种方法。
* insert()
* update()
* delete()
* query()

**文件提供者**

这是一种内容提供者，它将**共享**来自文件夹的文件。你可以这样声明一个文件提供者：
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
注意 **`android:exported`** 属性，因为如果它是 **`true`**，外部应用程序将能够访问共享文件夹。\
注意配置 `android:resource="@xml/filepaths"` 表示文件 _res/xml/filepaths.xml_ 包含配置，指出 **FileProvider** 将要**共享**的**哪些文件夹**。这是一个示例，展示如何在该文件中指示共享一个文件夹：
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
```markdown
分享类似 **`path="."`** 的内容即使提供者没有导出，如果代码的其他部分存在尝试访问此提供者的漏洞，也可能是**危险的**。
您可以使用 `content://com.example.myapp.fileprovider/myimages/default_image.jpg` **访问**文件夹内的**图片**。

`<paths>` 元素可以有多个子元素，每个子元素指定要共享的不同目录。除了 **`<files-path>`** 元素，您还可以使用 **`<external-path>`** 元素共享**外部存储**中的目录，以及 **`<cache-path>`** 元素共享您的**内部缓存目录**中的目录。
[有关特定文件提供者属性的更多信息，请点击这里。](https://developer.android.com/reference/androidx/core/content/FileProvider)

[关于FileProviders的更多信息在这里](https://developer.android.com/training/secure-file-sharing/setup-sharing)。

## WebViews

WebViews 实际上是嵌入到 Android 应用中的**网络浏览器**。
WebViews 的内容可以从远程站点拉取，也可以是应用中包含的文件。
WebViews **容易受到影响任何网络浏览器的同样漏洞**。然而，有一些**配置**可以用来**限制**攻击**面**。

Android 中有两种类型的 WebViews：

* **WebViewClient**，最适合简单HTML渲染。这不会运行 JS alert 函数。因此，使用该函数的 XSS 测试将无效。
* **WebChrome** **client**，是一个 Chrome 浏览器。

请注意，**WebView 浏览器无法访问原生浏览器的 cookies**。

要加载 URL 或文件，可以使用 **`loadUrl`**、**`loadData`** 或 **`loadDataWithBaseURL`** 函数。**重要的是只访问经过消毒的 URL。**
WebView 安全性可以通过 **`WebSettings`** 对象进行配置。
例如，可以使用 **`setJavaScriptEnabled`** 方法并将值设置为 **`false`** 来禁用 JS 代码执行。这将**移除** **XSS** 和其他与 JS 相关的漏洞的可能性。

JavaScript "**Bridge**" 功能**将 Java 对象注入 WebView，使它们可以被 JS 访问**。从 Android 4.2 开始，方法必须用 **`@JavascriptInterface`** 注解才能被 JavaScript 访问。

如果对 **`setAllowContentAccess`** 传递 **`true`**，**WebViews 将能够通过** **`content://`** 方案访问内容提供者**。这显然构成了安全风险。请注意，如果授予此访问权限，非常重要的是要**确保** **`content://`** URL 是**安全的**。

默认情况下，WebViews 可以通过 file:// URLs 访问本地文件，但有几种方法可以防止这种行为：

* 对 **`setAllowFileAccess`** 传递 **`false`**，可以防止访问文件系统，但可以通过 `file:///android_asset` _和_ `file:///android_res` 访问资产。这些路径应仅用于非敏感数据（如图像），因此应该是安全的。
* 方法 **`setAllowFileAccess`** 指示是否应允许来自 `file://` URL 的路径访问其他文件方案 URL 的内容。
* 方法 **`setAllowUniversalAccessFromFileURLs`** 指示是否应允许来自 `file://` URL 的路径访问任何来源的内容。

## 其他应用组件

### **应用签名**

* Android 要求在安装之前，**所有应用都必须用证书进行数字签名**。Android 使用这个证书来识别应用的作者。
* 要在设备上运行应用程序，它应该被签名。当应用程序安装到设备上时，**包管理器验证**是否已经使用 apk 文件中的证书正确签名。
* 应用程序可以自签名，也可以通过 CA 签名。
* 应用签名确保一个应用程序不能访问其他应用程序，除非通过定义良好的 IPC，并且确保它未经修改地传递到设备。

### **应用验证**

* Android 4.2 及更高版本支持应用验证。用户可以选择启用“验证应用程序”，并在安装之前由应用验证器评估应用程序。
* 如果用户尝试安装可能有害的应用程序，应用验证可以提醒用户；如果应用程序特别糟糕，它可以阻止安装。

## 移动设备管理

MDM 或移动设备管理是用于**确保对移动设备的控制和安全要求**的软件套件。这些套件使用称为设备管理 API 的功能，并要求安装 Android 应用程序。

通常，MDM 解决方案执行的功能包括强制执行密码策略、强制加密存储和启用远程擦除设备数据。

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

找到对您最重要的漏洞，以便更快修复。Intruder 跟踪您的攻击面，运行主动威胁扫描，在您的整个技术堆栈中找到问题，从 API 到网络应用程序和云系统。[**今天就免费试用**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零开始学习 AWS 黑客攻击！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 HackTricks 中看到您的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs**](https://opensea.io/collection/the-peass-family) 收藏
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>
```
