# Podstawy aplikacji Android

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Znajduj podatności, które mają największe znaczenie, aby móc je szybko naprawić. Intruder śledzi powierzchnię ataku, wykonuje proaktywne skanowanie zagrożeń, znajduje problemy we wszystkich technologiach, od interfejsów API po aplikacje internetowe i systemy chmurowe. [**Wypróbuj go za darmo**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) już dziś.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Model bezpieczeństwa Androida

**Istnieją dwie warstwy:**

* **System operacyjny**, który izoluje zainstalowane aplikacje od siebie nawzajem.
* **Sama aplikacja**, która umożliwia programistom **udostępnianie określonych funkcji** i konfigurację możliwości aplikacji.

### Separacja UID

**Każdej aplikacji przypisywane jest określone ID użytkownika**. Dzieje się to podczas instalacji aplikacji, dzięki czemu aplikacja może interakcjonować tylko z plikami należącymi do jej ID użytkownika lub plikami udostępnionymi. Dlatego tylko sama aplikacja, niektóre komponenty systemu operacyjnego i użytkownik root mają dostęp do danych aplikacji.

### Współdzielenie UID

**Dwie aplikacje mogą być skonfigurowane do korzystania z tego samego UID**. Może to być przydatne do współdzielenia informacji, ale jeśli jedna z nich zostanie skompromitowana, dane obu aplikacji zostaną naruszone. Dlatego zachowanie to jest **odradzane**.\
**Aby współdzielić to samo UID, aplikacje muszą zdefiniować ten sam atrybut `android:sharedUserId` w swoich manifestach.**

### Izolacja

**Piaskownica aplikacji Android** pozwala uruchamiać **każdą aplikację** jako **oddzielny proces pod oddzielnym identyfikatorem użytkownika**. Każdy proces ma swoją własną maszynę wirtualną, więc kod aplikacji działa w izolacji od innych aplikacji.\
Od wersji Androida 5.0(L) jest stosowany **SELinux**. W skrócie, SELinux odrzuca wszystkie interakcje między procesami, a następnie tworzy polityki, które **pozwalają tylko na oczekiwane interakcje między nimi**.

### Uprawnienia

Podczas instalacji **aplikacji i żądania uprawnień**, aplikacja prosi o uprawnienia skonfigurowane w elementach **`uses-permission`** w pliku **AndroidManifest.xml**. Element **uses-permission** wskazuje nazwę żądanego uprawnienia w atrybucie **name**. Ma również atrybut **maxSdkVersion**, który przestaje prosić o uprawnienia w wersjach wyższych niż określona.\
Należy zauważyć, że aplikacje Android nie muszą prosić o wszystkie uprawnienia na początku, mogą również **dynamicznie prosić o uprawnienia**, ale wszystkie uprawnienia muszą być **zadeklarowane** w manifeście.

Gdy aplikacja udostępnia funkcjonalność, może ograniczyć **dostęp tylko do aplikacji posiadających określone uprawnienie**.\
Element uprawnienia ma trzy atrybuty:

* **Nazwa** uprawnienia
* Atrybut **permission-group**, który umożliwia grupowanie powiązanych uprawnień.
* **Poziom ochrony**, który wskazuje, jak uprawnienia są udzielane. Istnieją cztery typy:
* **Normalne**: Używane, gdy nie ma **znanych zagrożeń** dla aplikacji. Użytkownik **nie musi go zatwierdzać**.
* **Niebezpieczne**: Wskazuje, że uprawnienie udziela żądającej aplikacji pewnego **podwyższonego dostępu**. **Użytkownicy są proszeni o zatwierdzenie**.
* **Podpis**: Tylko **aplikacje podpisane tym samym certyfikatem co eksportujący komponent** mogą otrzymać uprawnienie. To jest najmocniejszy typ ochrony.
* **Podpis lub system**: Tylko **aplikacje podpisane tym samym certyfikatem co eksportujący komponent lub aplikacje działające z dostępem na poziomie systemu** mogą otrzymać uprawnienia.

## Wstępnie zainstalowane aplikacje

Te aplikacje zazwyczaj znajdują się w katalogach **`/system/app`** lub **`/system/priv-app`**, a niektóre z nich są **zoptymalizowane** (możliwe, że nie znajdziesz nawet pliku `classes.dex`). Warto sprawdzić te aplikacje, ponieważ czasami działają zbyt wieloma uprawnieniami (jako root).

* Te dostarczone z **ROM-em** (Android OpenSource Project) **AOSP**
* Dodane przez **producenta** urządzenia
* Dodane przez **dostawcę** telefonu komórkowego (jeśli zakupione od nich)

## Rootowanie

Aby uzyskać dostęp do roota na fizycznym urządzeniu z systemem Android, zazwyczaj musisz **wykorzystać** 1 lub 2 **podatności**, które zwykle są **specyficzne** dla **urządzenia** i **wersji**.\
Po udanym wykorzystaniu podatności, zazwyczaj binarny `su` systemu Linux jest kopiowany do lokalizacji określonej w zmiennej środowiskowej PATH użytkownika, na przykład `/system/xbin`.

Po skonfigurowaniu binarnego su, inną aplikację Android można użyć do komunikacji z binarnym `su` i **przetwarzania żądań dostępu do roota**, takich jak **Superuser** i **SuperSU** (dostępne w sklepie Google Play).

{% hint style="danger" %}
Należy pamiętać, że proces rootowania jest bardzo niebezpieczny i może poważnie uszkodzić urządzenie
{% endhint %}

### ROM-y

Możliwe jest **zastąpienie systemu operacyjnego, instalując niestandardowe oprogramowanie**. Dzięki temu można rozszerzyć funkcjonalność starego urządzenia, ominąć ograniczenia oprogramowania lub uzyskać dostęp do najnowszego kodu Androida.\
**OmniROM** i **LineageOS** to dwie z najpopularniejszych niestandardowych wersji oprogramowania.

Należy zauważyć, że **nie zawsze jest konieczne zrootowanie urządzenia**, aby zainstalować niestandardowe oprogramowanie.
### **Dalvik & Smali**

W rozwoju Androida do tworzenia aplikacji używa się **Javy lub Kotlinu**. Zamiast używać JVM jak w aplikacjach na komputery stacjonarne, Android kompiluje ten kod do **bajtkodu Dalvik Executable (DEX)**. Wcześniej, maszyna wirtualna Dalvik obsługiwała ten bajtkod, ale teraz w nowszych wersjach Androida przejmuje to Android Runtime (ART).

W przypadku inżynierii wstecznej, kluczowe staje się **Smali**. Jest to czytelna dla człowieka wersja bajtkodu DEX, działająca jak język asemblera, tłumacząca kod źródłowy na instrukcje bajtkodu. Smali i baksmali odnoszą się do narzędzi montażu i demontażu w tym kontekście.


***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Znajdź najważniejsze podatności, aby szybko je naprawić. Intruder śledzi powierzchnię ataku, wykonuje skanowanie zagrożeń proaktywnych, znajduje problemy w całym stosie technologicznym, od interfejsów API po aplikacje internetowe i systemy chmurowe. [**Wypróbuj go za darmo**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) już dziś.

***

## Intents

Intents są podstawowym środkiem komunikacji między komponentami aplikacji Android lub innymi aplikacjami. Obiekty tych wiadomości mogą również przenosić dane między aplikacjami lub komponentami, podobnie jak w przypadku żądań GET/POST w komunikacji HTTP.

Więc Intents to w zasadzie **wiadomość przekazywana między komponentami**. Intents **mogą być skierowane** do konkretnych komponentów lub aplikacji, **lub mogą być wysyłane bez określonego odbiorcy**.\
W skrócie, Intent może być używany:

* Do uruchamiania Activity, zwykle otwierania interfejsu użytkownika dla aplikacji
* Jako transmisje, informujące system i aplikacje o zmianach
* Do uruchamiania, zatrzymywania i komunikacji z usługą w tle
* Do uzyskiwania dostępu do danych za pośrednictwem dostawców treści
* Jako wywołania zwrotne do obsługi zdarzeń

Jeśli są podatne, **Intents mogą być wykorzystane do przeprowadzenia różnych ataków**.

### Intent-Filter

**Intent Filters** definiują **sposób interakcji między aktywnością, usługą lub odbiornikiem transmisji a różnymi typami Intents**. W zasadzie opisują one możliwości tych komponentów, takie jak jakie działania mogą wykonywać lub jakie rodzaje transmisji mogą przetwarzać. Głównym miejscem deklaracji tych filtrów jest plik **AndroidManifest.xml**, choć dla odbiorników transmisji możliwe jest również ich kodowanie.

Intent Filters składają się z kategorii, działań i filtrów danych, z możliwością dodania dodatkowych metadanych. Taka konfiguracja pozwala komponentom obsługiwać konkretne Intents, które pasują do zadeklarowanych kryteriów.

Krytycznym aspektem komponentów Androida (aktywności/usług/dostawców treści/odbiorców transmisji) jest ich widoczność lub **status publiczny**. Komponent jest uważany za publiczny i może współpracować z innymi aplikacjami, jeśli jest **`eksportowany`** z wartością **`true`** lub jeśli dla niego w manifestu jest zadeklarowany Intent Filter. Jednak deweloperzy mają możliwość utrzymania tych komponentów w trybie prywatnym, aby zapewnić, że nie będą one niezamierzenie współpracować z innymi aplikacjami. Można to osiągnąć, ustawiając atrybut **`eksportowany`** na **`false`** w definicjach manifestu.

Ponadto, deweloperzy mają możliwość dodatkowego zabezpieczenia dostępu do tych komponentów, wymagając określonych uprawnień. Atrybut **`permission`** może być ustawiony, aby wymusić, że tylko aplikacje z wyznaczonym uprawnieniem mogą uzyskać dostęp do komponentu, dodając dodatkową warstwę bezpieczeństwa i kontroli nad tym, kto może z nim współpracować.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Implicite Intencje

Intencje są tworzone programowo za pomocą konstruktora Intencji:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**Akcja** wcześniej zadeklarowanego zamiaru to **ACTION\_SEND**, a **Extra** to mailto **Uri** (Extra to dodatkowe informacje, których oczekuje zamiar).

Ten zamiar powinien być zadeklarowany w manifestu, jak w poniższym przykładzie:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Intent-filter musi pasować do **akcji**, **danych** i **kategorii**, aby otrzymać wiadomość.

Proces "rozwiązywania intencji" określa, która aplikacja powinna otrzymać każdą wiadomość. Proces ten uwzględnia atrybut **priorytetu**, który może być ustawiony w deklaracji **intent-filter**, a **wybrana zostanie ta z wyższym priorytetem**. Priorytet ten może być ustawiony w zakresie od -1000 do 1000, a aplikacje mogą używać wartości `SYSTEM_HIGH_PRIORITY`. Jeśli pojawi się **konflikt**, pojawia się okno "wyboru", w którym **użytkownik może zdecydować**.

### Jawne intencje

Jawna intencja określa nazwę klasy, do której jest skierowana:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
W innych aplikacjach, aby uzyskać dostęp do wcześniej zadeklarowanego intencji, można użyć:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Oczekujące Intenty

Pozwalają innym aplikacjom **wykonywać działania w imieniu Twojej aplikacji**, korzystając z tożsamości i uprawnień Twojej aplikacji. Konstruując Oczekujący Intent, należy **określić intencję i działanie do wykonania**. Jeśli **zadeklarowana intencja nie jest jawna** (nie określa, która intencja może ją wywołać), **złośliwa aplikacja może wykonać zadeklarowane działanie** w imieniu aplikacji ofiary. Ponadto, **jeśli nie jest określone żadne działanie**, złośliwa aplikacja będzie mogła wykonać **dowolne działanie w imieniu ofiary**.

### Intenty Rozgłoszeniowe

W przeciwieństwie do poprzednich intencji, które są odbierane tylko przez jedną aplikację, intencje rozgłoszeniowe **mogą być odbierane przez wiele aplikacji**. Jednak od wersji API 14, **można określić aplikację, która powinna otrzymać** wiadomość, używając Intent.set Package.

Alternatywnie, przy wysyłaniu rozgłoszenia można **określić uprawnienie**. Aplikacja odbiorcza będzie musiała posiadać to uprawnienie.

Istnieją **dwa rodzaje** rozgłoszeń: **Normalne** (asynchroniczne) i **Uporządkowane** (synchroniczne). **Kolejność** jest oparta na **ustawionym priorytecie wewnątrz elementu odbiorcy**. **Każda aplikacja może przetwarzać, przekazywać lub odrzucać rozgłoszenie**.

Można **wysłać** rozgłoszenie, używając funkcji `sendBroadcast(intent, receiverPermission)` z klasy `Context`.\
Można również użyć funkcji **`sendBroadcast`** z **`LocalBroadCastManager`**, która zapewnia, że **wiadomość nigdy nie opuści aplikacji**. Dzięki temu nie będzie nawet konieczne eksportowanie komponentu odbiorcy.

### Trwałe Rozgłoszenia

Ten rodzaj rozgłoszeń **można uzyskać dostęp do nich długo po ich wysłaniu**.\
Zostały one oznaczone jako przestarzałe w poziomie API 21 i **nie zaleca się ich używania**.\
**Pozwalają dowolnej aplikacji na podsłuchanie danych, ale także na ich modyfikację**.

Jeśli znajdziesz funkcje zawierające słowo "sticky", takie jak **`sendStickyBroadcast`** lub **`sendStickyBroadcastAsUser`**, **sprawdź ich wpływ i spróbuj je usunąć**.

## Głębokie linki / Schematy URL

W aplikacjach Android, **głębokie linki** są używane do inicjowania działania (Intencji) bezpośrednio za pomocą adresu URL. Dokonuje się tego poprzez zadeklarowanie określonego **schematu URL** wewnątrz aktywności. Gdy urządzenie z systemem Android próbuje **uzyskać dostęp do adresu URL z tym schematem**, uruchamiana jest określona aktywność w ramach aplikacji.

Schemat musi być zadeklarowany w pliku **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Schemat z poprzedniego przykładu to `exampleapp://` (zwróć uwagę również na **`kategorie BROWSABLE`**)

Następnie, w polu danych, możesz określić **host** i **ścieżkę**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Aby uzyskać do niego dostęp z przeglądarki internetowej, można ustawić link w ten sposób:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Aby znaleźć **kod, który zostanie wykonany w aplikacji**, przejdź do aktywności wywołanej przez deep link i wyszukaj funkcję **`onNewIntent`**.

Dowiedz się, jak [wywoływać deep linki bez użycia stron HTML](./#wykorzystywanie-schematów-deep-linków).

## AIDL - Android Interface Definition Language

**Android Interface Definition Language (AIDL)** został zaprojektowany w celu ułatwienia komunikacji między klientem a usługą w aplikacjach Android za pomocą **komunikacji międzyprocesowej** (IPC). Ponieważ bezpośredni dostęp do pamięci innego procesu nie jest dozwolony w systemie Android, AIDL upraszcza ten proces, serializując obiekty do formatu zrozumiałego dla systemu operacyjnego, ułatwiając tym samym komunikację między różnymi procesami.

### Kluczowe pojęcia

- **Bound Services**: Usługi te wykorzystują AIDL do IPC, umożliwiając aktywnościom lub komponentom powiązanie się z usługą, składanie żądań i otrzymywanie odpowiedzi. Metoda `onBind` w klasie usługi jest kluczowa dla inicjowania interakcji, dlatego stanowi ważne miejsce do przeglądu pod kątem podatności na zagrożenia.

- **Messenger**: Działając jako powiązana usługa, Messenger ułatwia IPC, skupiając się na przetwarzaniu danych za pomocą metody `onBind`. Ważne jest dokładne sprawdzenie tej metody pod kątem niebezpiecznego przetwarzania danych lub wykonywania funkcji zawierających poufne informacje.

- **Binder**: Chociaż bezpośrednie użycie klasy Binder jest mniej powszechne ze względu na abstrakcję AIDL, warto zrozumieć, że Binder działa jako sterownik na poziomie jądra, ułatwiając transfer danych między przestrzeniami pamięci różnych procesów. Dla lepszego zrozumienia dostępny jest materiał na stronie [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Komponenty

Obejmują one: **Aktywności, Usługi, Odbiorniki nadawcze i Dostawcy.**

### Aktywność uruchamiająca i inne aktywności

W aplikacjach Android **aktywności** są jak ekrany, prezentujące różne części interfejsu użytkownika aplikacji. Aplikacja może mieć wiele aktywności, z których każda prezentuje unikalny ekran użytkownikowi.

**Aktywność uruchamiająca** jest głównym wejściem do aplikacji, uruchamianym po naciśnięciu ikony aplikacji. Jest ona zdefiniowana w pliku manifestu aplikacji za pomocą konkretnych intencji MAIN i LAUNCHER:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Nie wszystkie aplikacje potrzebują aktywności uruchamiającej, zwłaszcza te bez interfejsu użytkownika, takie jak usługi w tle.

Aktywności mogą być udostępniane innym aplikacjom lub procesom poprzez oznaczenie ich jako "eksportowane" w pliku manifestu. Ta opcja umożliwia innym aplikacjom uruchamianie tej aktywności:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Jednak dostęp do aktywności z innej aplikacji nie zawsze stanowi ryzyko dla bezpieczeństwa. Obawy pojawiają się, jeśli poufne dane są udostępniane nieprawidłowo, co może prowadzić do wycieku informacji.

Cykl życia aktywności **rozpoczyna się od metody onCreate**, która ustawia interfejs użytkownika i przygotowuje aktywność do interakcji z użytkownikiem.

### Podklasa aplikacji

W przypadku tworzenia aplikacji na Androida, istnieje opcja utworzenia **podklasy** klasy [Application](https://developer.android.com/reference/android/app/Application), choć nie jest to obowiązkowe. Gdy taka podklasa jest zdefiniowana, staje się pierwszą klasą, która zostaje zainicjowana w ramach aplikacji. Metoda **`attachBaseContext`**, jeśli jest zaimplementowana w tej podklasie, jest wykonywana przed metodą **`onCreate`**. Taka konfiguracja umożliwia wczesną inicjalizację przed rozpoczęciem reszty aplikacji.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Usługi

[Usługi](https://developer.android.com/guide/components/services) to **operacje w tle**, które mogą wykonywać zadania bez interfejsu użytkownika. Te zadania mogą działać nawet wtedy, gdy użytkownicy przełączają się na inne aplikacje, co czyni usługi niezbędnymi do **długotrwałych operacji**.

Usługi są wszechstronne; mogą być uruchamiane na różne sposoby, przy czym **Intenty** są główną metodą uruchamiania ich jako punktu wejścia aplikacji. Po uruchomieniu usługi za pomocą metody `startService`, jej metoda `onStart` rozpoczyna działanie i działa aż do wywołania jawnego metody `stopService`. Alternatywnie, jeśli rola usługi zależy od aktywnego połączenia klienta, używana jest metoda `bindService` do powiązania klienta z usługą, co angażuje metodę `onBind` do przekazywania danych.

Interesującym zastosowaniem usług jest odtwarzanie muzyki w tle lub pobieranie danych z sieci bez utrudniania interakcji użytkownika z aplikacją. Ponadto, usługi mogą być udostępniane innym procesom na tym samym urządzeniu poprzez **eksportowanie**. Nie jest to zachowanie domyślne i wymaga jawnie skonfigurowania w pliku Android Manifest:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Odbiorniki transmisji

**Odbiorniki transmisji** działają jako słuchacze w systemie wiadomości, pozwalając wielu aplikacjom reagować na te same wiadomości od systemu. Aplikacja może **zarejestrować odbiornik** na **dwa główne sposoby**: poprzez **Manifest** aplikacji lub **dynamicznie** w kodzie aplikacji za pomocą interfejsu API **`registerReceiver`**. W przypadku Manifestu, transmisje są filtrowane z uprawnieniami, podczas gdy odbiorniki zarejestrowane dynamicznie mogą również określić uprawnienia podczas rejestracji.

**Filtry intencji** są kluczowe w obu metodach rejestracji, określając, które transmisje wywołują odbiornik. Po wysłaniu pasującej transmisji, wywoływana jest metoda **`onReceive`** odbiornika, umożliwiając aplikacji reakcję w odpowiedni sposób, na przykład dostosowanie zachowania w odpowiedzi na alert o niskim poziomie baterii.

Transmisje mogą być **asynchroniczne**, docierając do wszystkich odbiorników bez kolejności, lub **synchroniczne**, gdzie odbiorniki otrzymują transmisję na podstawie ustawionych priorytetów. Ważne jest jednak zauważenie potencjalnego ryzyka bezpieczeństwa, ponieważ dowolna aplikacja może nadać sobie priorytet w celu przechwycenia transmisji.

Aby zrozumieć funkcjonalność odbiornika, należy szukać metody **`onReceive`** wewnątrz jego klasy. Kod tej metody może manipulować otrzymaną intencją, co podkreśla konieczność walidacji danych przez odbiorniki, zwłaszcza w przypadku **uporządkowanych transmisji**, które mogą modyfikować lub odrzucać intencję.

### Dostawca treści

**Dostawcy treści** są niezbędni do **udostępniania strukturalnych danych** między aplikacjami, co podkreśla znaczenie implementacji **uprawnień** w celu zapewnienia bezpieczeństwa danych. Pozwalają aplikacjom uzyskiwać dostęp do danych z różnych źródeł, w tym baz danych, systemów plików lub sieci. Określone uprawnienia, takie jak **`readPermission`** i **`writePermission`**, są kluczowe dla kontroli dostępu. Dodatkowo, tymczasowy dostęp można udzielić za pomocą ustawień **`grantUriPermission`** w manifeście aplikacji, wykorzystując atrybuty takie jak `path`, `pathPrefix` i `pathPattern` do szczegółowej kontroli dostępu.

Walidacja danych wejściowych jest niezwykle ważna w celu zapobiegania podatnościom, takim jak wstrzyknięcie SQL. Dostawcy treści obsługują podstawowe operacje: `insert()`, `update()`, `delete()` i `query()`, ułatwiające manipulację danymi i ich udostępnianie między aplikacjami.

**FileProvider**, specjalizowany dostawca treści, skupia się na bezpiecznym udostępnianiu plików. Jest on zdefiniowany w manifeście aplikacji za pomocą określonych atrybutów do kontrolowania dostępu do folderów, oznaczonych przez `android:exported` i `android:resource`, wskazujących na konfiguracje folderów. Należy zachować ostrożność podczas udostępniania katalogów, aby uniknąć nieumyślnego ujawnienia poufnych danych.

Przykładowe zadeklarowanie FileProvidera w manifeście:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
I przykład określenia udostępnionych folderów w `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Aby uzyskać dalsze informacje, sprawdź:
- [Android Developers: Dostawcy treści](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews są jak **mini przeglądarki internetowe** wewnątrz aplikacji Android, pobierające treść zarówno z sieci, jak i z lokalnych plików. Stoją przed podobnymi zagrożeniami jak zwykłe przeglądarki, ale istnieją sposoby na **zmniejszenie tych zagrożeń** poprzez odpowiednie **ustawienia**.

Android oferuje dwa główne typy WebView:

- **WebViewClient** jest idealny do podstawowego HTML, ale nie obsługuje funkcji alert JavaScript, co wpływa na testowanie ataków XSS.
- **WebChromeClient** działa bardziej jak pełne doświadczenie przeglądarki Chrome.

Kluczowym punktem jest to, że przeglądarki WebView **nie dzielą się plikami cookie** z główną przeglądarką urządzenia.

Do ładowania treści dostępne są metody takie jak ````loadUrl````, ````loadData````, i ````loadDataWithBaseURL````. Ważne jest, aby upewnić się, że te adresy URL lub pliki są **bezpieczne do użycia**. Ustawienia związane z bezpieczeństwem można zarządzać za pomocą klasy ````WebSettings````. Na przykład, wyłączenie JavaScript za pomocą ````setJavaScriptEnabled(false)```` może zapobiec atakom XSS.

JavaScript "Bridge" umożliwia interakcję obiektów Java z JavaScript, wymagając, aby metody były oznaczone jako ````@JavascriptInterface```` dla bezpieczeństwa od wersji Android 4.2 wzwyż.

Zezwalanie na dostęp do treści (````setAllowContentAccess(true)````) pozwala WebView na dostęp do dostawców treści, co może stanowić ryzyko, chyba że adresy URL treści są zweryfikowane jako bezpieczne.

Aby kontrolować dostęp do plików:
- Wyłączenie dostępu do plików (````setAllowFileAccess(false)````) ogranicza dostęp do systemu plików, z wyjątkami dla określonych zasobów, zapewniając, że są one używane tylko do treści niewrażliwych.

## Inne składniki aplikacji i zarządzanie urządzeniami mobilnymi

### **Cyfrowe podpisywanie aplikacji**

- **Cyfrowe podpisywanie** jest niezbędne dla aplikacji Android, zapewniając, że są **autentycznie autoryzowane** przed instalacją. Proces ten wykorzystuje certyfikat do identyfikacji aplikacji i musi zostać zweryfikowany przez menedżera pakietów urządzenia podczas instalacji. Aplikacje mogą być **podpisane przez siebie same lub certyfikowane przez zewnętrznego CA**, chroniąc przed nieautoryzowanym dostępem i zapewniając, że aplikacja pozostaje nietknięta podczas dostarczania na urządzenie.

### **Weryfikacja aplikacji dla zwiększonego bezpieczeństwa**

- Począwszy od **Androida 4.2**, funkcja o nazwie **Weryfikuj aplikacje** pozwala użytkownikom sprawdzić bezpieczeństwo aplikacji przed ich instalacją. Ten **proces weryfikacji** może ostrzegać użytkowników przed potencjalnie szkodliwymi aplikacjami lub nawet uniemożliwiać instalację szczególnie złośliwych, zwiększając bezpieczeństwo użytkownika.

### **Zarządzanie urządzeniami mobilnymi (MDM)**

- **Rozwiązania MDM** zapewniają **nadzór i bezpieczeństwo** dla urządzeń mobilnych za pomocą **interfejsu API administracji urządzeniem**. Wymagają one instalacji aplikacji Android do skutecznego zarządzania i zabezpieczania urządzeń mobilnych. Kluczowe funkcje obejmują **narzucanie polityk dotyczących haseł**, **wymuszanie szyfrowania pamięci** i **zezwolenie na zdalne kasowanie danych**, zapewniając kompleksową kontrolę i bezpieczeństwo urządzeń mobilnych.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Znajdź najważniejsze podatności, aby móc je szybko naprawić. Intruder śledzi powierzchnię ataku, wykonuje proaktywne skanowanie zagrożeń, znajduje problemy w całym stosie technologicznym, od interfejsów API po aplikacje internetowe i systemy chmurowe. [**Wypróbuj go za darmo**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) już dziś.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytoriów GitHub.**

</details>
