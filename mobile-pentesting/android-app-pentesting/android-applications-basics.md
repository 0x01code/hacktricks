# Fundamentos de las Aplicaciones Android

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof es el hogar de todas las recompensas por errores de criptograf√≠a.**

**Obt√©n recompensas sin demoras**\
Las recompensas de HackenProof se lanzan solo cuando sus clientes depositan el presupuesto de recompensa. Obtendr√°s la recompensa despu√©s de que se verifique el error.

**Obt√©n experiencia en pentesting web3**\
¬°Los protocolos de blockchain y los contratos inteligentes son el nuevo Internet! Domina la seguridad web3 en sus d√≠as de crecimiento.

**Convi√©rtete en la leyenda del hacker web3**\
Gana puntos de reputaci√≥n con cada error verificado y conquista la cima de la clasificaci√≥n semanal.

[**Reg√≠strate en HackenProof**](https://hackenproof.com/register) ¬°comienza a ganar con tus hacks!

{% embed url="https://hackenproof.com/register" %}

## Modelo de Seguridad de Android

**Hay dos capas:**

* El **SO**, que mantiene las aplicaciones instaladas aisladas entre s√≠.
* La **aplicaci√≥n en s√≠**, que permite a los desarrolladores **exponer ciertas funcionalidades** y configurar las capacidades de la aplicaci√≥n.

### Separaci√≥n de UID

**A cada aplicaci√≥n se le asigna un ID de usuario espec√≠fico**. Esto se hace durante la instalaci√≥n de la aplicaci√≥n para que la aplicaci√≥n solo pueda interactuar con archivos propiedad de su ID de usuario o archivos compartidos. Por lo tanto, solo la aplicaci√≥n en s√≠, ciertos componentes del SO y el usuario root pueden acceder a los datos de las aplicaciones.

### Compartir UID

**Dos aplicaciones pueden configurarse para usar el mismo UID**. Esto puede ser √∫til para compartir informaci√≥n, pero si una de ellas se ve comprometida, los datos de ambas aplicaciones se ver√°n comprometidos. Por eso, este comportamiento est√° **desaconsejado**.\
**Para compartir el mismo UID, las aplicaciones deben definir el mismo valor `android:sharedUserId` en sus manifiestos.**

### Aislamiento

El **Sandbox de Aplicaciones Android** permite ejecutar **cada aplicaci√≥n** como un **proceso separado bajo un ID de usuario separado**. Cada proceso tiene su propia m√°quina virtual, por lo que el c√≥digo de una aplicaci√≥n se ejecuta de forma aislada de otras aplicaciones.\
A partir de Android 5.0(L), se aplica SELinux. B√°sicamente, SELinux deniega todas las interacciones entre procesos y luego crea pol√≠ticas para **permitir solo las interacciones esperadas entre ellos**.

### Permisos

Cuando instalas una **aplicaci√≥n y solicita permisos**, la aplicaci√≥n est√° solicitando los permisos configurados en los elementos **`uses-permission`** en el archivo **AndroidManifest.xml**. El elemento **uses-permission** indica el nombre del permiso solicitado dentro del atributo **name**. Tambi√©n tiene el atributo **maxSdkVersion**, que deja de solicitar permisos en versiones superiores a la especificada.\
Ten en cuenta que las aplicaciones de Android no necesitan solicitar todos los permisos al principio, tambi√©n pueden **solicitar permisos de forma din√°mica**, pero todos los permisos deben estar **declarados** en el manifiesto.

Cuando una aplicaci√≥n expone funcionalidades, puede limitar el **acceso solo a aplicaciones que tengan un permiso especificado**.\
Un elemento de permiso tiene tres atributos:

* El **nombre** del permiso
* El atributo **permission-group**, que permite agrupar permisos relacionados.
* El **nivel de protecci√≥n**, que indica c√≥mo se otorgan los permisos. Hay cuatro tipos:
* **Normal**: Se utiliza cuando no hay **amenazas conocidas** para la aplicaci√≥n. El usuario **no est√° obligado a aprobarlo**.
* **Peligroso**: Indica que el permiso otorga a la aplicaci√≥n solicitante un **acceso elevado**. **Se solicita a los usuarios que los aprueben**.
* **Firma**: Solo se pueden otorgar permisos a las **aplicaciones firmadas con el mismo certificado que el que** exporta el componente. Este es el tipo de protecci√≥n m√°s fuerte.
* **FirmaO Sistema**: Solo se pueden otorgar permisos a las **aplicaciones firmadas con el mismo certificado que el que** exporta el componente o **aplicaciones que se ejecutan con acceso a nivel de sistema**.

## Aplicaciones Preinstaladas

Estas aplicaciones generalmente se encuentran en los directorios **`/system/app`** o **`/system/priv-app`** y algunas de ellas est√°n **optimizadas** (es posible que ni siquiera encuentres el archivo `classes.dex`). Vale la pena verificar estas aplicaciones porque a veces se est√°n **ejecutando con demasiados permisos** (como root).

* Las que se env√≠an con el **ROM** de **AOSP** (Proyecto de C√≥digo Abierto de Android)
* Agregadas por el **fabricante** del dispositivo
* Agregadas por el **proveedor** de telefon√≠a celular (si se compr√≥ a ellos)
## Rooting

Para obtener acceso root en un dispositivo Android f√≠sico, generalmente necesitas **explotar** 1 o 2 **vulnerabilidades** que suelen ser **espec√≠ficas** para el **dispositivo** y la **versi√≥n**. Una vez que la explotaci√≥n ha funcionado, generalmente se copia el binario `su` de Linux en una ubicaci√≥n especificada en la variable de entorno PATH del usuario, como `/system/xbin`.

Una vez que el binario `su` est√° configurado, se utiliza otra aplicaci√≥n de Android para interactuar con el binario `su` y **procesar solicitudes de acceso root** como **Superuser** y **SuperSU** (disponibles en Google Play Store).

{% hint style="danger" %}
Ten en cuenta que el proceso de rootear es muy peligroso y puede da√±ar gravemente el dispositivo.
{% endhint %}

### ROMs

Es posible **reemplazar el sistema operativo instalando un firmware personalizado**. Al hacer esto, es posible ampliar la utilidad de un dispositivo antiguo, evitar restricciones de software o acceder al √∫ltimo c√≥digo de Android. **OmniROM** y **LineageOS** son dos de los firmwares m√°s populares para usar.

Ten en cuenta que **no siempre es necesario rootear el dispositivo** para instalar un firmware personalizado. **Algunos fabricantes permiten** el desbloqueo de sus cargadores de arranque de manera documentada y segura.

### Implicaciones

Una vez que un dispositivo est√° rooteado, cualquier aplicaci√≥n puede solicitar acceso como root. Si una aplicaci√≥n maliciosa lo obtiene, tendr√° acceso a casi todo y podr√° da√±ar el tel√©fono.

## Fundamentos de las aplicaciones de Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

Esta introducci√≥n se toma de [https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html](https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html)

### Revisi√≥n de los fundamentos <a href="#fundamentals-review" id="fundamentals-review"></a>

* Las aplicaciones de Android est√°n en formato de archivo _APK_. **APK es b√°sicamente un archivo ZIP**. (Puedes cambiar la extensi√≥n del archivo a .zip y usar unzip para abrirlo y ver su contenido).
* Contenido del APK (no exhaustivo)
* **AndroidManifest.xml**
* resources.arsc/strings.xml
* resources.arsc: un archivo que contiene recursos precompilados, como XML binario, por ejemplo.
* res/xml/files\_paths.xml
* META-INF/
* ¬°Aqu√≠ se encuentra el certificado!
* **classes.dex**
* C√≥digo de bytecode Dalvik para la aplicaci√≥n en formato de archivo DEX. **Este es el c√≥digo Java (o Kotlin)** compilado que la aplicaci√≥n ejecutar√° de forma predeterminada.
* lib/
* Bibliotecas nativas para la aplicaci√≥n, por defecto, se encuentran aqu√≠. Bajo el directorio lib/, se encuentran los directorios espec√≠ficos de la CPU.
* `armeabi`: c√≥digo compilado solo para procesadores basados en ARM
* `armeabi-v7a`: c√≥digo compilado solo para procesadores basados en ARMv7 y superiores
* `x86`: c√≥digo compilado para X86
* `mips`: c√≥digo compilado solo para procesadores MIPS
* assets/
* Cualquier otro archivo que pueda ser necesario para la aplicaci√≥n.
* Aqu√≠ se pueden incluir bibliotecas nativas adicionales o archivos DEX. Esto puede suceder especialmente cuando los autores de malware quieren intentar "ocultar" c√≥digo adicional, nativo o Dalvik, al no incluirlo en las ubicaciones predeterminadas.
* res/
* el directorio que contiene recursos no compilados en resources.arsc

### **Dalvik y Smali**

La mayor√≠a de las aplicaciones de Android est√°n escritas en Java. Kotlin tambi√©n es compatible e interoperable con Java. Para mayor facilidad, para el resto de este taller, cuando me refiero a "Java", puedes asumir que me refiero a "Java o Kotlin". **En lugar de que el c√≥digo Java se ejecute en la M√°quina Virtual de Java** (JVM) como las aplicaciones de escritorio, en Android, el **Java se compila al bytecode \_Dalvik Executable (DEX)**\_\* formato\*\*. Para versiones anteriores de Android, el bytecode se traduc√≠a mediante la m√°quina virtual Dalvik. Para versiones m√°s recientes de Android, se utiliza el Android Runtime (ART).
Si los desarrolladores escriben en Java y el c√≥digo se compila a bytecode DEX, para ingenier√≠a inversa, trabajamos en la direcci√≥n opuesta.

![Diagrama de flujo del proceso del desarrollador. De Java a bytecode DEX](https://maddiestone.github.io/AndroidAppRE/images/DevelopersFlow.jpg)

![Diagrama de flujo del proceso del ingeniero inverso. De bytecode DEX a SMALI a Java descompilado](https://maddiestone.github.io/AndroidAppRE/images/ReversersFlow.jpg)

**Smali es la versi√≥n legible por humanos del bytecode Dalvik**. T√©cnicamente, Smali y baksmali son los nombres de las herramientas (ensamblador y desensamblador, respectivamente), pero en Android, a menudo usamos el t√©rmino "Smali" para referirnos a las instrucciones. Si has realizado ingenier√≠a inversa o arquitectura de computadoras en c√≥digo C/C++ compilado, **SMALI es como el lenguaje ensamblador: entre el c√≥digo fuente de nivel superior y el bytecode**.

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof es el hogar de todas las recompensas por errores de cifrado.**

**Obt√©n recompensas sin demoras**\
Las recompensas de HackenProof se lanzan solo cuando sus clientes depositan el presupuesto de recompensa. Recibir√°s la recompensa despu√©s de que se verifique el error.

**Obt√©n experiencia en pentesting web3**\
¬°Los protocolos de blockchain y los contratos inteligentes son el nuevo Internet! Domina la seguridad web3 en sus d√≠as de crecimiento.

**Convi√©rtete en la leyenda del hacker web3**\
Obt√©n puntos de reputaci√≥n con cada error verificado y conquista la cima de la clasificaci√≥n semanal.

[**Reg√≠strate en HackenProof**](https://hackenproof.com/register) ¬°comienza a ganar con tus hacks!

{% embed url="https://hackenproof.com/register" %}

## Intents

Los Intents son el principal medio por el cual las aplicaciones de Android se comunican entre sus componentes o con otras aplicaciones. Estos objetos de mensaje tambi√©n pueden transportar datos entre aplicaciones o componentes, de manera similar a c√≥mo se utilizan las solicitudes GET/POST en las comunicaciones HTTP.

Entonces, un Intent es b√°sicamente un **mensaje que se pasa entre componentes**. Los Intents **pueden dirigirse** a componentes o aplicaciones espec√≠ficas, **o pueden enviarse sin un destinatario espec√≠fico**.\
Para simplificar, un Intent se puede utilizar:

* Para iniciar una Actividad, generalmente abriendo una interfaz de usuario para una aplicaci√≥n.
* Como transmisiones para informar al sistema y a las aplicaciones sobre cambios.
* Para iniciar, detener y comunicarse con un servicio en segundo plano.
* Para acceder a datos a trav√©s de ContentProviders.
* Como devoluciones de llamada para manejar eventos.

Una implementaci√≥n incorrecta podr√≠a resultar en fugas de datos, llamadas a funciones restringidas y manipulaci√≥n del flujo del programa.

### Filtro de Intents

Un filtro de Intent especifica los **tipos de Intents a los que una actividad, servicio o receptor de transmisiones puede responder**. Especifica lo que una actividad o servicio puede hacer y qu√© tipos de transmisiones puede manejar un receptor. Permite que el componente correspondiente reciba Intents del tipo declarado. Los filtros de Intents generalmente se **definen a trav√©s del archivo AndroidManifest.xml**. Para los **receptores de transmisiones**, tambi√©n es posible definirlos en **c√≥digo**. Un filtro de Intent se define por su categor√≠a, acciones y filtros de datos. Tambi√©n puede contener metadatos adicionales.

En Android, una actividad/servicio/proveedor de contenido/receptor de transmisiones es **p√∫blico** cuando se establece **`exported`** en **`true`**, pero un componente tambi√©n es p√∫blico si el manifiesto especifica un filtro de Intent para √©l. Sin embargo, los desarrolladores pueden **hacer que los componentes sean privados expl√≠citamente** (independientemente de cualquier filtro de Intent) al establecer el atributo **`exported`** en **`false`** para cada componente en el archivo de manifiesto. Los desarrolladores tambi√©n pueden establecer el atributo **`permission`** para **requerir un permiso espec√≠fico para acceder** al componente, restringiendo as√≠ el acceso al componente.
### Intenciones impl√≠citas

Las intenciones se crean program√°ticamente utilizando un constructor de Intents:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
La **Acci√≥n** del intent previamente declarado es **ACTION\_SEND** y el **Extra** es un **Uri** de correo electr√≥nico (el Extra es la informaci√≥n adicional que el intent espera).

Este intent debe ser declarado dentro del manifiesto como en el siguiente ejemplo:
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Un intent-filter necesita coincidir con la **acci√≥n**, **datos** y **categor√≠a** para recibir un mensaje.

El proceso de "resoluci√≥n de intenciones" determina qu√© aplicaci√≥n debe recibir cada mensaje. Este proceso considera el atributo de **prioridad**, que se puede establecer en la **declaraci√≥n del intent-filter**, y **se seleccionar√° el que tenga la prioridad m√°s alta**. Esta prioridad se puede establecer entre -1000 y 1000 y las aplicaciones pueden usar el valor `SYSTEM_HIGH_PRIORITY`. Si surge un **conflicto**, aparece una ventana de "selector" para que el **usuario pueda decidir**.

### Intenciones expl√≠citas

Una intenci√≥n expl√≠cita especifica el nombre de la clase a la que se dirige:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
En otras aplicaciones, para acceder a la intenci√≥n previamente declarada, puedes utilizar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Intenciones pendientes

Estas permiten que otras aplicaciones **realicen acciones en nombre de tu aplicaci√≥n**, utilizando la identidad y los permisos de tu aplicaci√≥n. Al construir una Intenci√≥n Pendiente, se debe **especificar una intenci√≥n y la acci√≥n a realizar**. Si la **intenci√≥n declarada no es expl√≠cita** (no declara qu√© intenci√≥n puede llamarla), una **aplicaci√≥n maliciosa podr√≠a realizar la acci√≥n declarada** en nombre de la aplicaci√≥n v√≠ctima. Adem√°s, **si no se especifica una acci√≥n**, la aplicaci√≥n maliciosa podr√° realizar **cualquier acci√≥n en nombre de la v√≠ctima**.

### Intenciones de difusi√≥n

A diferencia de las intenciones anteriores, que solo son recibidas por una aplicaci√≥n, las intenciones de difusi√≥n **pueden ser recibidas por varias aplicaciones**. Sin embargo, a partir de la versi√≥n 14 de la API, es **posible especificar la aplicaci√≥n que debe recibir** el mensaje utilizando Intent.setPackage.

Alternativamente, tambi√©n es posible **especificar un permiso al enviar la difusi√≥n**. La aplicaci√≥n receptora deber√° tener ese permiso.

Existen **dos tipos** de difusiones: **Normales** (asincr√≥nicas) y **Ordenadas** (sincr√≥nicas). El **orden** se basa en la **prioridad configurada dentro del receptor**. **Cada aplicaci√≥n puede procesar, retransmitir o descartar la difusi√≥n**.

Es posible **enviar** una **difusi√≥n** utilizando la funci√≥n \*\*`sendBroadcast(intent, receiverPermission)` \*\* de la clase `Context`.\
Tambi√©n se puede utilizar la funci√≥n **`sendBroadcast`** del **`LocalBroadCastManager`** que asegura que el **mensaje nunca salga de la aplicaci√≥n**. Utilizando esto, ni siquiera necesitar√°s exportar un componente receptor.

### Difusiones persistentes

Este tipo de difusiones **pueden ser accedidas mucho tiempo despu√©s de ser enviadas**.\
Estas fueron descontinuadas en el nivel de API 21 y se recomienda **no utilizarlas**.\
**Permiten que cualquier aplicaci√≥n esp√≠e los datos, pero tambi√©n los modifique**.

Si encuentras funciones que contienen la palabra "sticky" como **`sendStickyBroadcast`** o **`sendStickyBroadcastAsUser`**, **verifica el impacto e intenta eliminarlas**.

## Enlaces profundos / Esquemas de URL

**Los enlaces profundos permiten activar una Intenci√≥n a trav√©s de una URL**. Una aplicaci√≥n puede declarar un **esquema de URL** dentro de una actividad para que cada vez que el dispositivo Android intente **acceder a una direcci√≥n utilizando ese esquema**, se llame a la actividad de la aplicaci√≥n:

![](<../../.gitbook/assets/image (214).png>)

En este caso, el esquema es `myapp://` (tambi√©n se observa la **`categor√≠a BROWSABLE`**)

Si dentro del `intent-filter` encuentras algo como esto:

![](<../../.gitbook/assets/image (263).png>)

Entonces, est√° esperando algo como `http://www.example.com/gizmos`

Si encuentras algo como esto:

![](<../../.gitbook/assets/image (262).png>)

Significar√° que est√° esperando una URL que comienza con `example://gizmos`\
En este caso, podr√≠as intentar abusar de la funcionalidad creando una p√°gina web con las siguientes cargas √∫tiles. Intentar√° navegar a p√°ginas arbitrarias e intentar√° ejecutar JS:
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Para encontrar el **c√≥digo que se ejecutar√° en la aplicaci√≥n**, ve a la actividad llamada por el enlace profundo y busca la funci√≥n **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Aprende c√≥mo [llamar enlaces profundos sin usar p√°ginas HTML](./#explotando-esquemas-enlaces-profundos).

## AIDL - Lenguaje de Definici√≥n de Interfaz de Android

El **Lenguaje de Definici√≥n de Interfaz de Android** (AIDL) te permite definir la interfaz de programaci√≥n en la que tanto el cliente como el servicio acuerdan para **comunicarse entre s√≠ utilizando la comunicaci√≥n entre procesos** (IPC). En Android, **un proceso normalmente no puede acceder a la memoria de otro proceso**. Por lo tanto, para comunicarse, necesitan descomponer sus objetos en primitivas que el **sistema operativo** pueda entender y transmitir los objetos a trav√©s de esa barrera por ti. El c√≥digo para realizar esa transmisi√≥n es tedioso de escribir, por lo que Android lo maneja por ti con AIDL.

Los servicios que utilizan AIDL se denominan **Servicios Vinculados**. En la clase del servicio encontrar√°s el m√©todo **`onBind`**. Aqu√≠ es **donde comienza la interacci√≥n**, por lo que es la parte inicial del c√≥digo que debes revisar en busca de posibles vulnerabilidades.

Un servicio vinculado es el servidor en una interfaz cliente-servidor. **Permite que los componentes (como las actividades) se vinculen al servicio, env√≠en solicitudes, reciban respuestas y realicen comunicaci√≥n entre procesos** (IPC). Un servicio vinculado generalmente solo existe mientras sirve a otro componente de la aplicaci√≥n y no se ejecuta indefinidamente en segundo plano.

### Messenger

Un Messenger es otro tipo de mecanismo de IPC. Dado que el **Messenger tambi√©n es un "Servicio Vinculado"**, los datos enviados desde la aplicaci√≥n cliente tambi√©n se procesan a trav√©s del m√©todo `onBind`. Por lo tanto, la revisi√≥n del c√≥digo debe comenzar en este m√©todo y debes buscar la invocaci√≥n de funcionalidades sensibles o el manejo inseguro de datos.

### Binder

Es raro encontrar una clase Binder invocada directamente, ya que es mucho m√°s f√°cil usar AIDL (que abstrae la clase Binder). Sin embargo, es bueno saber que **Binder es un controlador de nivel de kernel que mueve datos de la memoria de un proceso a otro** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Componentes

Estos incluyen: **Actividades, Servicios, Receptores de Difusi√≥n y Proveedores**.

### Actividad de inicio y otras actividades

Una **actividad de Android** es una pantalla de la interfaz de usuario de la aplicaci√≥n de Android. De esta manera, una **actividad de Android** es muy similar a las ventanas de una aplicaci√≥n de escritorio. Una aplicaci√≥n de Android puede contener una o m√°s actividades, lo que significa una o m√°s pantallas.

La **actividad de inicio** es lo que la mayor√≠a de las personas consideran como el **punto de entrada** de una aplicaci√≥n de Android. La actividad de inicio es la actividad que se inicia cuando un usuario hace clic en el icono de una aplicaci√≥n. Puedes determinar la actividad de inicio mirando el manifiesto de la aplicaci√≥n. La actividad de inicio tendr√° los siguientes intents MAIN y LAUNCHER enumerados.

Ten en cuenta que no todas las aplicaciones tendr√°n una actividad de inicio, especialmente las aplicaciones sin una interfaz de usuario. Ejemplos de aplicaciones sin una interfaz de usuario (y, por lo tanto, sin una actividad de inicio) son las aplicaciones preinstaladas que realizan servicios en segundo plano, como el correo de voz.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Las actividades pueden ser exportadas permitiendo que otros procesos en el dispositivo inicien la actividad. Por defecto, no est√°n exportadas, pero puedes exportarlas configurando:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ten en cuenta que la capacidad de **burlar las protecciones de actividad no siempre es una vulnerabilidad**, debes verificar a qu√© datos has obtenido acceso.
Adem√°s, **algunas actividades devuelven datos a un llamador**. En estos escenarios, debes buscar el m√©todo **`setResult`** y verificar los datos que se pasan al par√°metro Intent. Si son datos sensibles, puede haber una vulnerabilidad de filtraci√≥n de informaci√≥n y es explotable con aplicaciones capaces de comunicarse con la actividad.

**El c√≥digo de una actividad comienza con el m√©todo `onCreate`.**

### Subclase de Aplicaci√≥n

Las aplicaciones de Android pueden definir una **subclase** de [Application](https://developer.android.com/reference/android/app/Application). Las aplicaciones pueden, pero no tienen que definir una subclase personalizada de Application. Si una aplicaci√≥n de Android define una subclase de Application, **esta clase se instancia antes que cualquier otra clase en la aplicaci√≥n**.

Si el m√©todo **`attachBaseContext`** est√° definido en la subclase de Application, se llama primero, antes del m√©todo **`onCreate`**.

### Servicios

[Los servicios](https://developer.android.com/guide/components/services) **se ejecutan en segundo plano sin una interfaz de usuario**. Se utilizan para realizar **procesos de larga duraci√≥n, incluso si el usuario comienza a usar una aplicaci√≥n diferente**.

Hay muchas formas en las que se pueden iniciar y, por lo tanto, son un punto de entrada para las aplicaciones. La forma predeterminada en que un servicio puede iniciarse como punto de entrada a una aplicaci√≥n es a trav√©s de **Intents**.

Cuando se llama al m√©todo **`startService`** para iniciar un servicio, se ejecuta el m√©todo **`onStart`** en el servicio. Se ejecutar√° indefinidamente hasta que se llame al m√©todo **`stopService`**. Si el servicio solo se necesita mientras el cliente est√° conectado, el cliente debe "vincularse" a √©l utilizando el m√©todo **`bindService`**.

Para un **servicio vinculado** (ver secci√≥n anterior), los datos se pasar√°n al m√©todo **`onBind`**.

Por ejemplo, un servicio podr√≠a reproducir m√∫sica en segundo plano mientras el usuario est√° en una aplicaci√≥n diferente, o podr√≠a obtener datos a trav√©s de la red sin bloquear la interacci√≥n del usuario con una actividad.

Un **servicio puede ser exportado, lo que permite que otros procesos en el dispositivo inicien el servicio**. Por defecto, los servicios no est√°n exportados, pero se pueden configurar en el Manifiesto:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Receptores de difusi√≥n

Las difusiones se pueden considerar como un sistema de mensajer√≠a y los **receptores de difusi√≥n son los oyentes**. Si una aplicaci√≥n ha registrado un receptor para una difusi√≥n espec√≠fica, el c√≥digo de ese receptor se ejecuta cuando el sistema env√≠a la difusi√≥n. Tenga en cuenta que en este caso **varias aplicaciones pueden recibir el mismo mensaje**.

Hay **2 formas** en las que una aplicaci√≥n puede **registrar un receptor**: en el **manifiesto de la aplicaci√≥n o registrado din√°micamente** en el c√≥digo de la aplicaci√≥n utilizando la llamada de API **`registerReceiver`**. En el manifiesto, puede limitar las difusiones que acepta mediante el **uso de permisos dentro del elemento receptor**. Cuando se define de forma din√°mica, puede **pasar el permiso al m√©todo `registerReceiver`**.

En ambos casos, para registrar el receptor, se establecen los **filtros de intenci√≥n para el receptor**. Estos filtros de intenci√≥n son las difusiones que deben activar el receptor.

Cuando se env√≠an las difusiones espec√≠ficas para las que el receptor est√° registrado, se **ejecuta** el m√©todo **`onReceive`** en la clase BroadcastReceiver.

Una aplicaci√≥n puede registrar un receptor para el mensaje de bater√≠a baja, por ejemplo, y cambiar su comportamiento en funci√≥n de esa informaci√≥n.

Las difusiones pueden ser **asincr√≥nicas** (cada receptor las recibe) o **sincr√≥nicas** (la difusi√≥n se recibe de manera ordenada seg√∫n la prioridad establecida para recibirla).

{% hint style="danger" %}
**Tenga en cuenta que cualquier aplicaci√≥n puede establecerse como m√°xima prioridad para recibir una difusi√≥n.**
{% endhint %}

Para **examinar** el **c√≥digo** implementado en un receptor de difusi√≥n, debe buscar el m√©todo **`onReceive`** de la clase del receptor.\
Tenga en cuenta que las difusiones ordenadas pueden descartar la intenci√≥n recibida o incluso modificarla utilizando uno de los m√©todos setter. Por lo tanto, los **receptores deben validar los datos**.

### Proveedor de contenido

Los proveedores de contenido son la forma en que las aplicaciones comparten datos estructurados, como bases de datos relacionales. Por lo tanto, es muy importante utilizar **permisos** y establecer el nivel de protecci√≥n adecuado para protegerlos.\
Los proveedores de contenido pueden utilizar los atributos **`readPermission`** y **`writePermission`** para especificar qu√© permisos debe tener una aplicaci√≥n. **Estos permisos tienen prioridad sobre el atributo de permiso**.\
Adem√°s, tambi√©n pueden **permitir excepciones temporales** estableciendo **`grantUriPermission`** en true y luego configurando los par√°metros adecuados en el elemento **`grant-uri-permission`** dentro del elemento proveedor en el archivo de manifiesto.

El elemento **`grant-uri-permission`** tiene tres atributos: path, pathPrefix y pathPattern:

* **path**: Permite especificar la ruta completa a excluir
* **pathPrefix**: Permite especificar el inicio de la ruta
* **pathPattern**: Permite el uso de comodines y reemplazos simb√≥licos para obtener un control m√°s granular.

Es **importante validar y sanitizar la entrada recibida** para evitar posibles vulnerabilidades como la inyecci√≥n de SQL.

**Caracter√≠sticas del proveedor de contenido:**

* El componente del proveedor de contenido suministra datos de una aplicaci√≥n a otras bajo solicitud.
* Puede almacenar los datos en el sistema de archivos, una base de datos SQLite, en la web o en cualquier otra ubicaci√≥n de almacenamiento persistente a la que su aplicaci√≥n pueda acceder.
* A trav√©s del proveedor de contenido, otras aplicaciones pueden consultar o incluso modificar los datos (si el proveedor de contenido lo permite).
* El proveedor de contenido es √∫til en casos en los que una aplicaci√≥n desea compartir datos con otra aplicaci√≥n.
* Es muy similar a las bases de datos y tiene cuatro m√©todos.
* insert()
* update()
* delete()
* query()

**FileProvider**

Este es un tipo de proveedor de contenido que **compartir√° archivos** desde una carpeta. Puede declarar un proveedor de archivos de la siguiente manera:
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Ten en cuenta el atributo **`android:exported`** porque si es **`true`**, las aplicaciones externas podr√°n acceder a las carpetas compartidas.\
Ten en cuenta que la configuraci√≥n `android:resource="@xml/filepaths"` indica que el archivo _res/xml/filepaths.xml_ contiene la configuraci√≥n de **qu√© carpetas** va a **compartir** este **FileProvider**. Este es un ejemplo de c√≥mo indicar la compartici√≥n de una carpeta en ese archivo:
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Compartir algo como **`path="."`** podr√≠a ser **peligroso** incluso si el proveedor no est√° exportado, si hay alguna otra vulnerabilidad en alguna parte del c√≥digo que intente acceder a este proveedor.\
Puedes **acceder** a una **imagen** dentro de esa carpeta con `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

El elemento `<paths>` puede tener varios hijos, cada uno especificando un directorio diferente para compartir. Adem√°s del elemento **`<files-path>`**, puedes usar el elemento **`<external-path>`** para compartir directorios en el almacenamiento externo, y el elemento **`<cache-path>`** para compartir directorios en tu directorio de cach√© interno.\
[Para obtener m√°s informaci√≥n sobre los atributos espec√≠ficos de los proveedores de archivos, ve aqu√≠.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[M√°s informaci√≥n sobre FileProviders aqu√≠](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

Las WebViews son efectivamente **navegadores web** integrados en aplicaciones de Android.\
El contenido de las WebViews puede provenir de sitios remotos o pueden ser archivos incluidos en la aplicaci√≥n.\
Las WebViews son **vulnerables a las mismas vulnerabilidades que afectan a cualquier navegador web**. Sin embargo, hay algunas **configuraciones** que pueden ser √∫tiles para **limitar** la **superficie de ataque**.

Hay dos tipos de WebViews en Android:

* El **WebViewClient**, m√°s adecuado para la representaci√≥n de HTML simple. Esto no ejecutar√° la funci√≥n de alerta de JS. Por lo tanto, las pruebas de XSS que utilizan esa funci√≥n ser√°n inv√°lidas.
* El **cliente WebChrome**, es un navegador Chrome.

Tenga en cuenta que los navegadores **WebView no tienen acceso a las cookies del navegador nativo**.

Para cargar una URL o un archivo, es posible utilizar las funciones **`loadUrl`**, **`loadData`** o **`loadDataWithBaseURL`**. **Es importante acceder solo a URL sanitizadas.**\
La seguridad de WebView se puede configurar a trav√©s del objeto **`WebSettings`**.\
Por ejemplo, la ejecuci√≥n de c√≥digo JS se puede desactivar utilizando el m√©todo **`setJavaScriptEnabled`** con el valor **`false`**. Esto **eliminar√°** la posibilidad de una vulnerabilidad de XSS y otras relacionadas con JS.

La funcionalidad de JavaScript "**Bridge**" **inyecta objetos Java en un WebView haci√©ndolos accesibles para JS**. A partir de Android 4.2, los m√©todos deben estar anotados con **`@JavascriptInterface`** para que sean accesibles desde JavaScript.

Si se pasa **`true`** a **`setAllowContentAccess`**, las WebViews podr√°n acceder a los Proveedores de Contenido a trav√©s del esquema **`content://`**. Esto obviamente plantea un riesgo de seguridad. Tenga en cuenta que si se otorga este acceso, es muy importante **asegurarse** de que la URL **`content://`** sea **segura**.

De forma predeterminada, los archivos locales se pueden acceder mediante URL file://, pero hay varias formas de evitar este comportamiento:

* Pasar **`false`** a **`setAllowFileAccess`**, evita el acceso al sistema de archivos con la excepci√≥n de los activos a trav√©s de `file:///android_asset` _y_ `file:///android_res`. Estas rutas deben usarse solo para datos no sensibles (como im√°genes), por lo que esto deber√≠a ser seguro.
* El m√©todo **`setAllowFileAccess`** indica si una ruta de una URL `file://` debe poder acceder al contenido de otras URL de esquema de archivo.
* El m√©todo **`setAllowUniversalAccessFromFileURLs`** indica si una ruta de una URL `file://` debe poder acceder al contenido de cualquier origen.

## Otros componentes de la aplicaci√≥n

### **Firma de la aplicaci√≥n**

* Android requiere que **todas las aplicaciones est√©n firmadas digitalmente con un certificado** antes de que puedan ser instaladas. Android utiliza este certificado para identificar al autor de una aplicaci√≥n.
* Para ejecutar una aplicaci√≥n en el dispositivo, debe estar firmada. Cuando se instala una aplicaci√≥n en un dispositivo, el **administrador de paquetes verifica** si la aplicaci√≥n ha sido firmada correctamente con el certificado del archivo APK o no.
* La aplicaci√≥n puede ser auto-firmada o puede ser firmada a trav√©s de una CA.
* La firma de la aplicaci√≥n garantiza que una aplicaci√≥n no pueda acceder a ninguna otra aplicaci√≥n excepto a trav√©s de IPC bien definido y tambi√©n que se pase sin modificaciones al dispositivo.

### **Verificaci√≥n de la aplicaci√≥n**

* Android 4.2 y versiones posteriores admiten la verificaci√≥n de aplicaciones. Los usuarios pueden optar por habilitar "Verificar aplicaciones" y hacer que las aplicaciones sean evaluadas por un verificador de aplicaciones antes de la instalaci√≥n.
* La verificaci√≥n de aplicaciones puede alertar al usuario si intentan instalar una aplicaci√≥n que podr√≠a ser da√±ina; si una aplicaci√≥n es especialmente mala, puede bloquear la instalaci√≥n.

## Gesti√≥n de dispositivos m√≥viles

MDM o Mobile Device Management son suites de software que se utilizan para **garantizar un control y requisitos de seguridad** sobre dispositivos m√≥viles. Estas suites utilizan las caracter√≠sticas denominadas API de Administraci√≥n de Dispositivos y requieren la instalaci√≥n de una aplicaci√≥n de Android.

Generalmente, las soluciones de MDM realizan funciones como hacer cumplir pol√≠ticas de contrase√±as, forzar el cifrado del almacenamiento y permitir el borrado remoto de los datos del dispositivo.

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof es el hogar de todas las recompensas por errores de cifrado.**

**Obt√©n recompensas sin demoras**\
Las recompensas de HackenProof se lanzan solo cuando sus clientes depositan el presupuesto de recompensa. Recibir√°s la recompensa despu√©s de que se verifique el error.

**Obt√©n experiencia en pentesting web3**\
¬°Los protocolos de blockchain y los contratos inteligentes son el nuevo Internet! Domina la seguridad web3 en sus d√≠as de crecimiento.

**Convi√©rtete en la leyenda del hacker web3**\
Gana puntos de reputaci√≥n con cada error verificado y conquista la cima de la clasificaci√≥n semanal.

[**Reg√≠strate en HackenProof**](https://hackenproof.com/register) ¬°comienza a ganar con tus hacks!

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos.
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
