# Fondamenti delle applicazioni Android

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di github.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trova le vulnerabilit√† che contano di pi√π in modo da poterle correggere pi√π velocemente. Intruder traccia la tua superficie di attacco, esegue scansioni proattive delle minacce, trova problemi in tutta la tua infrastruttura tecnologica, dalle API alle applicazioni web e ai sistemi cloud. [**Provalo gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) oggi stesso.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Modello di sicurezza di Android

**Ci sono due livelli:**

* Il **SO**, che mantiene le applicazioni installate isolate l'una dall'altra.
* L'**applicazione stessa**, che consente agli sviluppatori di **esporre determinate funzionalit√†** e configura le capacit√† dell'applicazione.

### Separazione UID

**Ogni applicazione viene assegnata un ID utente specifico**. Questo avviene durante l'installazione dell'app in modo che l'app possa interagire solo con i file di propriet√† del suo ID utente o condivisi. Pertanto, solo l'app stessa, determinati componenti del SO e l'utente root possono accedere ai dati delle app.

### Condivisione UID

**Due applicazioni possono essere configurate per utilizzare lo stesso UID**. Questo pu√≤ essere utile per condividere informazioni, ma se una di esse viene compromessa, i dati di entrambe le applicazioni saranno compromessi. Ecco perch√© questo comportamento √® **sconsigliato**.\
**Per condividere lo stesso UID, le applicazioni devono definire lo stesso valore `android:sharedUserId` nei loro manifesti.**

### Sandboxing

Il **sandbox delle applicazioni Android** consente di eseguire **ogni applicazione** come un **processo separato con un ID utente separato**. Ogni processo ha la propria macchina virtuale, quindi il codice di un'app viene eseguito in isolamento dalle altre app.\
A partire da Android 5.0(L), viene applicato SELinux. Fondamentalmente, SELinux nega tutte le interazioni tra i processi e quindi crea delle politiche per **consentire solo le interazioni previste tra di loro**.

### Autorizzazioni

Quando si installa un'app e richiede autorizzazioni, l'app sta richiedendo le autorizzazioni configurate negli elementi **`uses-permission`** nel file **AndroidManifest.xml**. L'elemento **uses-permission** indica il nome dell'autorizzazione richiesta all'interno dell'attributo **name**. Ha anche l'attributo **maxSdkVersion** che smette di richiedere autorizzazioni su versioni superiori a quella specificata.\
Si noti che le applicazioni Android non devono richiedere tutte le autorizzazioni all'inizio, possono anche **richiedere autorizzazioni dinamicamente**, ma tutte le autorizzazioni devono essere **dichiarate** nel **manifest.**

Quando un'app espone funzionalit√†, pu√≤ limitare l'**accesso solo alle app che hanno una determinata autorizzazione**.\
Un elemento di autorizzazione ha tre attributi:

* Il **nome** dell'autorizzazione
* L'attributo **permission-group**, che consente di raggruppare autorizzazioni correlate.
* Il **livello di protezione** che indica come vengono concesse le autorizzazioni. Ci sono quattro tipi:
* **Normale**: Usato quando non ci sono **minacce note** per l'app. All'utente **non viene richiesto di approvarla**.
* **Pericoloso**: Indica che l'autorizzazione concede all'applicazione richiedente un **accesso elevato**. **Gli utenti sono invitati ad approvarli**.
* **Firma**: Solo **le app firmate con lo stesso certificato di quella** che esporta il componente possono ottenere l'autorizzazione. Questo √® il tipo di protezione pi√π forte.
* **FirmaOSystema**: Solo **le app firmate con lo stesso certificato di quella** che esporta il componente o **le app che eseguono con accesso di livello di sistema** possono ottenere le autorizzazioni.

## Applicazioni preinstallate

Queste app si trovano generalmente nelle directory **`/system/app`** o **`/system/priv-app`** e alcune di esse sono **ottimizzate** (potresti non trovare nemmeno il file `classes.dex`). Queste applicazioni meritano di essere controllate perch√© a volte **vengono eseguite con troppe autorizzazioni** (come root).

* Quelle fornite con il **ROM** (Android OpenSource Project) **AOSP**
* Aggiunte dal **produttore** del dispositivo
* Aggiunte dal **fornitore** del telefono cellulare (se acquistato da loro)

## Rooting

Per ottenere l'accesso root a un dispositivo Android fisico, di solito √® necessario **sfruttare** 1 o 2 **vulnerabilit√†** che solitamente sono **specifiche** per il **dispositivo** e la **versione**.\
Una volta che l'exploit ha funzionato, di solito il binario Linux `su` viene copiato in una posizione specificata nella variabile di ambiente PATH dell'utente come `/system/xbin`.

Una volta configurato il binario su, un'altra app Android viene utilizzata per interfacciarsi con il binario `su` e **elaborare le richieste di accesso root** come **Superuser** e **SuperSU** (disponibili su Google Play Store).

{% hint style="danger" %}
Si noti che il processo di rooting √® molto pericoloso e pu√≤ danneggiare gravemente il dispositivo
{% endhint %}

### ROM

√à possibile **sostituire il sistema operativo installando un firmware personalizzato**. Facendo ci√≤ √® possibile estendere l'utilit√† di un vecchio dispositivo, bypassare le restrizioni software o ottenere accesso al codice Android pi√π recente.\
**OmniROM** e **LineageOS** sono due dei firmware pi√π popolari da utilizzare.

Si noti che **non sempre √® necessario eseguire il root del dispositivo** per installare un firmware personalizzato. **Alcuni produttori consentono** lo sblocco dei loro bootloader in modo documentato e sicuro.

### Implicazioni

Una volta che un dispositivo √® stato sottoposto a root, qualsiasi app potrebbe richiedere l'accesso come root. Se un'applicazione dannosa lo ottiene, avr√† accesso a quasi tutto e sar√† in grado di danneggiare il telefono.

## Fondamenti delle applicazioni Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Il formato delle applicazioni Android √® chiamato _formato file APK_. √à essenzialmente un **file ZIP** (rinominando l'estensione del file in .zip, √® possibile estrarre e visualizzare i contenuti).
- Contenuto APK (non esaustivo)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: contiene risorse precompilate, come XML binario.
- res/xml/files\_paths.xml
- META-INF/
- Qui si trova il certificato!
- **classes.dex**
- Contiene il bytecode di Dalvik, che rappresenta il codice Java (o Kotlin) compilato che l'applicazione esegue per impostazione predefinita.
- lib/
- Contiene librerie native, suddivise per
### **Dalvik & Smali**

Nello sviluppo di Android, **Java o Kotlin** vengono utilizzati per creare app. Invece di utilizzare la JVM come nelle app desktop, Android compila questo codice in **bytecode Dalvik Executable (DEX)**. In passato, la macchina virtuale Dalvik gestiva questo bytecode, ma ora, nelle versioni pi√π recenti di Android, viene utilizzato l'Android Runtime (ART).

Per l'ingegneria inversa, diventa fondamentale utilizzare **Smali**. √à la versione leggibile dall'uomo del bytecode DEX, che agisce come un linguaggio assembly traducendo il codice sorgente in istruzioni bytecode. Smali e baksmali si riferiscono agli strumenti di assemblaggio e disassemblaggio in questo contesto.


***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trova le vulnerabilit√† pi√π importanti in modo da poterle correggere pi√π velocemente. Intruder monitora la tua superficie di attacco, esegue scansioni proattive delle minacce, individua problemi in tutta la tua infrastruttura tecnologica, dalle API alle applicazioni web e ai sistemi cloud. [**Provalo gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) oggi stesso.

***

## Intents

Gli Intents sono il principale mezzo attraverso il quale le app Android comunicano tra i loro componenti o con altre app. Questi oggetti di messaggio possono anche trasportare dati tra app o componenti, simili a come vengono utilizzate le richieste GET/POST nelle comunicazioni HTTP.

Quindi un Intent √® fondamentalmente un **messaggio che viene passato tra i componenti**. Gli Intents **possono essere diretti** a componenti o app specifici, **o possono essere inviati senza un destinatario specifico**.\
Per semplificare, gli Intent possono essere utilizzati per:

* Avviare un'Activity, aprendo tipicamente un'interfaccia utente per un'app
* Come trasmissioni per informare il sistema e le app di cambiamenti
* Avviare, interrompere e comunicare con un servizio in background
* Accedere ai dati tramite ContentProviders
* Come callback per gestire eventi

Se vulnerabili, gli Intents possono essere utilizzati per eseguire una variet√† di attacchi.

### Intent-Filter

Gli **Intent Filter** definiscono **come un'activity, un servizio o un ricevitore di trasmissione possono interagire con diversi tipi di Intents**. Essenzialmente, descrivono le capacit√† di questi componenti, come le azioni che possono eseguire o i tipi di trasmissioni che possono elaborare. Il luogo principale per dichiarare questi filtri √® il file **AndroidManifest.xml**, anche se per i ricevitori di trasmissione √® possibile anche codificarli.

Gli Intent Filter sono composti da categorie, azioni e filtri di dati, con la possibilit√† di includere metadati aggiuntivi. Questa configurazione consente ai componenti di gestire Intents specifici che corrispondono ai criteri dichiarati.

Un aspetto critico dei componenti Android (activity/servizi/content provider/ricevitori di trasmissione) √® la loro visibilit√† o **stato pubblico**. Un componente viene considerato pubblico e pu√≤ interagire con altre app se viene **`esportato`** con un valore di **`true`** o se viene dichiarato un Intent Filter per esso nel manifesto. Tuttavia, gli sviluppatori hanno la possibilit√† di mantenere esplicitamente privati questi componenti, garantendo che non interagiscano con altre app in modo non intenzionale. Questo viene ottenuto impostando l'attributo **`esportato`** su **`false`** nelle loro definizioni di manifesto.

Inoltre, gli sviluppatori hanno la possibilit√† di proteggere ulteriormente l'accesso a questi componenti richiedendo autorizzazioni specifiche. L'attributo **`permission`** pu√≤ essere impostato per garantire che solo le app con l'autorizzazione designata possano accedere al componente, aggiungendo un ulteriore livello di sicurezza e controllo su chi pu√≤ interagire con esso.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Intent impliciti

Gli intenti vengono creati programmaticamente utilizzando un costruttore Intent:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
L'**Azione** dell'intent precedentemente dichiarato √® **ACTION\_SEND** e l'**Extra** √® un **Uri** mailto (l'Extra √® l'informazione extra che l'intent si aspetta).

Questo intent dovrebbe essere dichiarato nel manifesto come nell'esempio seguente:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Un intent-filter deve corrispondere all'**azione**, ai **dati** e alla **categoria** per ricevere un messaggio.

Il processo di "risoluzione dell'intent" determina quale app dovrebbe ricevere ogni messaggio. Questo processo considera l'attributo di **priorit√†**, che pu√≤ essere impostato nella **dichiarazione dell'intent-filter**, e **quello con la priorit√† pi√π alta sar√† selezionato**. Questa priorit√† pu√≤ essere impostata tra -1000 e 1000 e le applicazioni possono utilizzare il valore `SYSTEM_HIGH_PRIORITY`. Se si verifica un **conflitto**, viene visualizzata una finestra "chooser" in modo che **l'utente possa decidere**.

### Intent Espliciti

Un intent esplicito specifica il nome della classe a cui √® indirizzato:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
In altre applicazioni, per accedere all'intent precedentemente dichiarato, √® possibile utilizzare:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

Questi permettono ad altre applicazioni di **eseguire azioni a nome della tua applicazione**, utilizzando l'identit√† e i permessi della tua app. Per costruire un Pending Intent, √® necessario **specificare un intent e l'azione da eseguire**. Se l'intent dichiarato non √® esplicito (non dichiara quale intent pu√≤ chiamarlo), un'applicazione malintenzionata potrebbe eseguire l'azione dichiarata a nome dell'app della vittima. Inoltre, **se non viene specificata un'azione**, l'app malintenzionata sar√† in grado di eseguire **qualsiasi azione a nome della vittima**.

### Broadcast Intents

A differenza degli intent precedenti, che vengono ricevuti solo da un'app, gli intent di broadcast **possono essere ricevuti da pi√π app**. Tuttavia, a partire dalla versione API 14, √® **possibile specificare l'app che dovrebbe ricevere** il messaggio utilizzando Intent.setPackage.

In alternativa, √® anche possibile **specificare un permesso durante l'invio del broadcast**. L'app ricevente dovr√† avere quel permesso.

Ci sono **due tipi** di broadcast: **Normale** (asincrono) e **Ordinato** (sincrono). L'**ordine** si basa sulla **priorit√† configurata all'interno dell'elemento ricevente**. **Ogni app pu√≤ elaborare, inoltrare o eliminare il broadcast**.

√à possibile **inviare** un **broadcast** utilizzando la funzione `sendBroadcast(intent, receiverPermission)` della classe `Context`.\
√à anche possibile utilizzare la funzione **`sendBroadcast`** del **`LocalBroadCastManager`** che garantisce che il **messaggio non esca mai dall'app**. Utilizzando questa funzione, non sar√† nemmeno necessario esportare un componente ricevente.

### Sticky Broadcasts

Questo tipo di broadcast **pu√≤ essere accessibile molto tempo dopo l'invio**.\
Sono stati deprecati nella versione API 21 ed √® consigliato **non utilizzarli**.\
**Permettono a qualsiasi applicazione di intercettare i dati, ma anche di modificarli**.

Se trovi funzioni che contengono la parola "sticky" come **`sendStickyBroadcast`** o **`sendStickyBroadcastAsUser`**, **verifica l'impatto e cerca di rimuoverle**.

## Deep links / URL schemes

Nelle applicazioni Android, i **deep link** vengono utilizzati per avviare un'azione (Intent) direttamente tramite un URL. Ci√≤ viene fatto dichiarando uno specifico **URL scheme** all'interno di un'attivit√†. Quando un dispositivo Android cerca di **accedere a un URL con questo schema**, viene avviata l'attivit√† specificata all'interno dell'applicazione.

Lo schema deve essere dichiarato nel file **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Lo schema dell'esempio precedente √® `exampleapp://` (nota anche la **`categoria BROWSABLE`**)

Successivamente, nel campo dei dati, √® possibile specificare l'**host** e il **percorso**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Per accedervi da un sito web √® possibile impostare un link come:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Per trovare il **codice che verr√† eseguito nell'app**, vai all'attivit√† chiamata dal deeplink e cerca la funzione **`onNewIntent`**.

Scopri come [chiamare deeplink senza utilizzare pagine HTML](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

L'**Android Interface Definition Language (AIDL)** √® progettato per facilitare la comunicazione tra client e servizio nelle applicazioni Android attraverso la **comunicazione interprocessuale** (IPC). Poich√© su Android non √® consentito accedere direttamente alla memoria di un altro processo, AIDL semplifica il processo marshalling degli oggetti in un formato comprensibile dal sistema operativo, facilitando cos√¨ la comunicazione tra processi diversi.

### Concetti chiave

- **Servizi collegati**: Questi servizi utilizzano AIDL per l'IPC, consentendo alle attivit√† o ai componenti di collegarsi a un servizio, fare richieste e ricevere risposte. Il metodo `onBind` nella classe del servizio √® fondamentale per avviare l'interazione, rendendolo una zona critica per la revisione della sicurezza alla ricerca di vulnerabilit√†.

- **Messenger**: Funzionando come un servizio collegato, Messenger facilita l'IPC con un focus sul trattamento dei dati attraverso il metodo `onBind`. √à essenziale ispezionare attentamente questo metodo per eventuali manipolazioni non sicure dei dati o esecuzioni di funzioni sensibili.

- **Binder**: Sebbene l'uso diretto della classe Binder sia meno comune a causa dell'astrazione di AIDL, √® utile comprendere che Binder agisce come un driver a livello di kernel che facilita il trasferimento di dati tra gli spazi di memoria di processi diversi. Per una comprensione pi√π approfondita, √® disponibile una risorsa su [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Componenti

Questi includono: **Attivit√†, Servizi, Ricevitori di trasmissione e Provider.**

### Attivit√† di avvio e altre attivit√†

Nelle app Android, le **attivit√†** sono come schermate che mostrano diverse parti dell'interfaccia utente dell'app. Un'app pu√≤ avere molte attivit√†, ognuna che presenta uno schermo unico all'utente.

L'**attivit√† di avvio** √® il principale punto di accesso a un'app, lanciata quando si tocca l'icona dell'app. √à definita nel file di manifesto dell'app con intent specifici MAIN e LAUNCHER:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Non tutte le app hanno bisogno di un'attivit√† di avvio, specialmente quelle senza un'interfaccia utente, come i servizi in background.

Le attivit√† possono essere rese disponibili ad altre app o processi contrassegnandole come "esportate" nel manifesto. Questa impostazione consente ad altre app di avviare questa attivit√†:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Tuttavia, accedere a un'attivit√† da un'altra app non √® sempre un rischio per la sicurezza. La preoccupazione sorge se i dati sensibili vengono condivisi impropriamente, il che potrebbe portare a fughe di informazioni.

Il ciclo di vita di un'attivit√† **inizia con il metodo onCreate**, che configura l'interfaccia utente e prepara l'attivit√† per l'interazione con l'utente.

### Sottoclasse dell'applicazione

Nello sviluppo di Android, un'app ha l'opzione di creare una **sottoclasse** della classe [Application](https://developer.android.com/reference/android/app/Application), anche se non √® obbligatorio. Quando viene definita una tale sottoclasse, diventa la prima classe ad essere istanziata all'interno dell'app. Il metodo **`attachBaseContext`**, se implementato in questa sottoclasse, viene eseguito prima del metodo **`onCreate`**. Questa configurazione consente una inizializzazione anticipata prima che il resto dell'applicazione inizi.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Servizi

I [servizi](https://developer.android.com/guide/components/services) sono **operazioni in background** capaci di eseguire compiti senza un'interfaccia utente. Questi compiti possono continuare ad eseguirsi anche quando gli utenti passano a diverse applicazioni, rendendo i servizi cruciali per **operazioni a lungo termine**.

I servizi sono versatili; possono essere avviati in vari modi, con gli **Intent** che rappresentano il metodo principale per avviarli come punto di ingresso di un'applicazione. Una volta che un servizio viene avviato utilizzando il metodo `startService`, il suo metodo `onStart` entra in azione e continua ad eseguirsi fino a quando il metodo `stopService` non viene chiamato esplicitamente. In alternativa, se il ruolo di un servizio dipende da una connessione client attiva, viene utilizzato il metodo `bindService` per collegare il client al servizio, coinvolgendo il metodo `onBind` per il passaggio dei dati.

Un'applicazione interessante dei servizi include la riproduzione di musica in background o il recupero di dati di rete senza ostacolare l'interazione dell'utente con un'app. Inoltre, i servizi possono essere resi accessibili ad altri processi sullo stesso dispositivo tramite **esportazione**. Questo non √® il comportamento predefinito e richiede una configurazione esplicita nel file Android Manifest:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Ricevitori di trasmissione

I **ricevitori di trasmissione** agiscono come ascoltatori in un sistema di messaggistica, consentendo a pi√π applicazioni di rispondere agli stessi messaggi provenienti dal sistema. Un'app pu√≤ **registrare un ricevitore** in **due modi principali**: tramite il **Manifest** dell'app o **dinamicamente** all'interno del codice dell'app tramite l'API **`registerReceiver`**. Nel Manifest, le trasmissioni vengono filtrate con le autorizzazioni, mentre i ricevitori registrati dinamicamente possono specificare anche le autorizzazioni durante la registrazione.

I **filtri di intent** sono cruciali in entrambi i metodi di registrazione, determinando quali trasmissioni attivano il ricevitore. Una volta inviata una trasmissione corrispondente, viene invocato il metodo **`onReceive`** del ricevitore, consentendo all'app di reagire di conseguenza, ad esempio regolando il comportamento in risposta a un avviso di batteria scarica.

Le trasmissioni possono essere sia **asincrone**, raggiungendo tutti i ricevitori senza un ordine specifico, sia **sincrone**, in cui i ricevitori ricevono la trasmissione in base alle priorit√† impostate. Tuttavia, √® importante notare il potenziale rischio per la sicurezza, poich√© qualsiasi app pu√≤ dare priorit√† a se stessa per intercettare una trasmissione.

Per comprendere la funzionalit√† di un ricevitore, cercare il metodo **`onReceive`** all'interno della sua classe. Il codice di questo metodo pu√≤ manipolare l'Intent ricevuto, evidenziando la necessit√† di convalida dei dati da parte dei ricevitori, specialmente nelle **trasmissioni ordinate**, che possono modificare o eliminare l'Intent.

### Provider di contenuti

I **provider di contenuti** sono essenziali per **condividere dati strutturati** tra le app, sottolineando l'importanza di implementare **autorizzazioni** per garantire la sicurezza dei dati. Consentono alle app di accedere a dati provenienti da varie fonti, tra cui database, filesystem o web. Autorizzazioni specifiche, come **`readPermission`** e **`writePermission`**, sono cruciali per controllare l'accesso. Inoltre, l'accesso temporaneo pu√≤ essere concesso tramite le impostazioni **`grantUriPermission`** nel manifesto dell'app, sfruttando attributi come `path`, `pathPrefix` e `pathPattern` per un controllo dettagliato dell'accesso.

La convalida dell'input √® fondamentale per prevenire vulnerabilit√†, come l'SQL injection. I provider di contenuti supportano operazioni di base: `insert()`, `update()`, `delete()` e `query()`, facilitando la manipolazione e la condivisione dei dati tra le applicazioni.

**FileProvider**, un provider di contenuti specializzato, si concentra sulla condivisione sicura di file. Viene definito nel manifesto dell'app con attributi specifici per controllare l'accesso alle cartelle, indicato da `android:exported` e `android:resource` che puntano alle configurazioni delle cartelle. Si consiglia cautela nella condivisione delle directory per evitare di esporre involontariamente dati sensibili.

Esempio di dichiarazione nel manifesto per FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
E un esempio di specifica delle cartelle condivise in `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Per ulteriori informazioni, consulta:
- [Sviluppatori Android: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Sviluppatori Android: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

Le WebViews sono come **mini browser web** all'interno delle app Android, che caricano contenuti sia dal web che da file locali. Affrontano rischi simili ai browser regolari, ma ci sono modi per **ridurre questi rischi** attraverso specifiche **impostazioni**.

Android offre due tipi principali di WebView:

- **WebViewClient** √® ottimo per l'HTML di base ma non supporta la funzione di avviso JavaScript, influenzando come gli attacchi XSS possono essere testati.
- **WebChromeClient** si comporta pi√π come l'esperienza completa del browser Chrome.

Un punto chiave √® che i browser WebView **non condividono i cookie** con il browser principale del dispositivo.

Per caricare contenuti, sono disponibili metodi come ````loadUrl````, ````loadData````, e ````loadDataWithBaseURL````. √à fondamentale assicurarsi che questi URL o file siano **sicuri da utilizzare**. Le impostazioni di sicurezza possono essere gestite tramite la classe ````WebSettings````. Ad esempio, disabilitando JavaScript con ````setJavaScriptEnabled(false)```` √® possibile prevenire gli attacchi XSS.

Il "Bridge" JavaScript consente agli oggetti Java di interagire con JavaScript, richiedendo che i metodi siano contrassegnati con ````@JavascriptInterface```` per la sicurezza da Android 4.2 in poi.

Consentire l'accesso al contenuto (````setAllowContentAccess(true)````) consente alle WebViews di raggiungere i Content Providers, il che potrebbe essere un rischio a meno che gli URL del contenuto siano verificati come sicuri.

Per controllare l'accesso ai file:
- Disabilitando l'accesso ai file (````setAllowFileAccess(false)````) si limita l'accesso al file system, con eccezioni per determinate risorse, garantendo che vengano utilizzate solo per contenuti non sensibili.

## Altri Componenti dell'App e Gestione dei Dispositivi Mobili

### **Firma Digitale delle App**

- La **firma digitale** √® un must per le app Android, garantendo che siano **autenticamente autenticate** prima dell'installazione. Questo processo utilizza un certificato per l'identificazione dell'app e deve essere verificato dal package manager del dispositivo durante l'installazione. Le app possono essere **auto-firmate o certificate da un CA esterno**, proteggendo dall'accesso non autorizzato e garantendo che l'app rimanga intatta durante la sua distribuzione al dispositivo.

### **Verifica dell'App per una Sicurezza Migliorata**

- A partire da **Android 4.2**, una funzione chiamata **Verifica App** consente agli utenti di verificare la sicurezza delle app prima dell'installazione. Questo **processo di verifica** pu√≤ avvisare gli utenti contro le app potenzialmente dannose, o addirittura impedire l'installazione di quelle particolarmente maliziose, migliorando la sicurezza dell'utente.

### **Gestione dei Dispositivi Mobili (MDM)**

- Le soluzioni **MDM** forniscono **controllo e sicurezza** per i dispositivi mobili tramite l'**API di Amministrazione del Dispositivo**. Richiedono l'installazione di un'app Android per gestire e proteggere efficacemente i dispositivi mobili. Le funzioni chiave includono **l'applicazione di politiche di password**, **l'obbligo di crittografia dello storage** e **l'autorizzazione alla cancellazione remota dei dati**, garantendo un controllo e una sicurezza completi sui dispositivi mobili.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trova le vulnerabilit√† che contano di pi√π in modo da poterle correggere pi√π velocemente. Intruder traccia la tua superficie di attacco, esegue scansioni proattive delle minacce, trova problemi in tutto il tuo stack tecnologico, dalle API alle app web e ai sistemi cloud. [**Provalo gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) oggi.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
