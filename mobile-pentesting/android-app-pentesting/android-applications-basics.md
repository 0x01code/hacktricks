# Conceitos B√°sicos de Aplicativos Android

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? Ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof √© o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof s√£o lan√ßadas apenas quando os clientes depositam o or√ßamento de recompensa. Voc√™ receber√° a recompensa ap√≥s a verifica√ß√£o do bug.

**Adquira experi√™ncia em pentesting web3**\
Protocolos de blockchain e contratos inteligentes s√£o a nova Internet! Domine a seguran√ßa web3 em seus dias de ascens√£o.

**Torne-se a lenda do hacker web3**\
Ganhe pontos de reputa√ß√£o com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

## Modelo de Seguran√ßa do Android

**Existem duas camadas:**

* O **SO**, que mant√©m os aplicativos instalados isolados uns dos outros.
* O **pr√≥prio aplicativo**, que permite aos desenvolvedores **expor determinadas funcionalidades** e configura as capacidades do aplicativo.

### Separa√ß√£o de UID

**Cada aplicativo recebe um ID de usu√°rio espec√≠fico**. Isso √© feito durante a instala√ß√£o do aplicativo para que o aplicativo possa interagir apenas com arquivos de propriedade de seu ID de usu√°rio ou arquivos compartilhados. Portanto, apenas o pr√≥prio aplicativo, certos componentes do SO e o usu√°rio root podem acessar os dados dos aplicativos.

### Compartilhamento de UID

**Dois aplicativos podem ser configurados para usar o mesmo UID**. Isso pode ser √∫til para compartilhar informa√ß√µes, mas se um deles for comprometido, os dados de ambos os aplicativos ser√£o comprometidos. √â por isso que esse comportamento √© **desencorajado**.\
**Para compartilhar o mesmo UID, os aplicativos devem definir o mesmo valor `android:sharedUserId` em seus manifestos.**

### Isolamento

A **Sandbox de Aplicativos Android** permite executar **cada aplicativo** como um **processo separado sob um ID de usu√°rio separado**. Cada processo tem sua pr√≥pria m√°quina virtual, portanto, o c√≥digo de um aplicativo √© executado isoladamente de outros aplicativos.\
A partir do Android 5.0(L), o **SELinux** √© aplicado. Basicamente, o SELinux nega todas as intera√ß√µes de processos e, em seguida, cria pol√≠ticas para **permitir apenas as intera√ß√µes esperadas entre eles**.

### Permiss√µes

Quando voc√™ instala um **aplicativo e ele solicita permiss√µes**, o aplicativo est√° solicitando as permiss√µes configuradas nos elementos **`uses-permission`** no arquivo **AndroidManifest.xml**. O elemento **uses-permission** indica o nome da permiss√£o solicitada dentro do **atributo name**. Ele tamb√©m possui o atributo **maxSdkVersion**, que impede a solicita√ß√£o de permiss√µes em vers√µes superiores √† especificada.\
Observe que os aplicativos Android n√£o precisam solicitar todas as permiss√µes no in√≠cio, eles tamb√©m podem **solicitar permiss√µes dinamicamente**, mas todas as permiss√µes devem ser **declaradas** no manifesto.

Quando um aplicativo exp√µe funcionalidades, ele pode limitar o **acesso apenas a aplicativos que possuem uma permiss√£o especificada**.\
Um elemento de permiss√£o possui tr√™s atributos:

* O **nome** da permiss√£o
* O atributo **permission-group**, que permite agrupar permiss√µes relacionadas.
* O **n√≠vel de prote√ß√£o**, que indica como as permiss√µes s√£o concedidas. Existem quatro tipos:
* **Normal**: Usado quando n√£o h√° **amea√ßas conhecidas** ao aplicativo. O usu√°rio **n√£o precisa aprovar**.
* **Perigoso**: Indica que a permiss√£o concede ao aplicativo solicitante algum **acesso elevado**. **Os usu√°rios s√£o solicitados a aprov√°-los**.
* **Assinatura**: Somente **aplicativos assinados pelo mesmo certificado que o** exportador do componente podem receber permiss√£o. Este √© o tipo de prote√ß√£o mais forte.
* **AssinaturaOuSistema**: Somente **aplicativos assinados pelo mesmo certificado que o** exportador do componente ou **aplicativos em execu√ß√£o com acesso de n√≠vel do sistema** podem receber permiss√µes.

## Aplicativos Pr√©-Instalados

Esses aplicativos geralmente s√£o encontrados nos diret√≥rios **`/system/app`** ou **`/system/priv-app`** e alguns deles s√£o **otimizados** (voc√™ pode nem encontrar o arquivo `classes.dex`). Vale a pena verificar esses aplicativos porque √†s vezes eles est√£o **executando com muitas permiss√µes** (como root).

* Os que s√£o enviados com o **ROM** do **AOSP** (Android OpenSource Project)
* Adicionados pelo **fabricante** do dispositivo
* Adicionados pelo **provedor de telefonia celular** (se comprado deles)
## Rooting

Para obter acesso root a um dispositivo Android f√≠sico, geralmente √© necess√°rio **explorar** 1 ou 2 **vulnerabilidades** que costumam ser **espec√≠ficas** para o **dispositivo** e **vers√£o**.\
Uma vez que a explora√ß√£o tenha funcionado, geralmente o bin√°rio `su` do Linux √© copiado para uma localiza√ß√£o especificada na vari√°vel de ambiente PATH do usu√°rio, como `/system/xbin`.

Uma vez que o bin√°rio su esteja configurado, outro aplicativo Android √© usado para interagir com o bin√°rio `su` e **processar solicita√ß√µes de acesso root**, como **Superuser** e **SuperSU** (dispon√≠veis na Google Play Store).

{% hint style="danger" %}
Observe que o processo de root √© muito perigoso e pode danificar gravemente o dispositivo.
{% endhint %}

### ROMs

√â poss√≠vel **substituir o sistema operacional instalando um firmware personalizado**. Fazendo isso, √© poss√≠vel estender a utilidade de um dispositivo antigo, contornar restri√ß√µes de software ou obter acesso ao c√≥digo mais recente do Android.\
**OmniROM** e **LineageOS** s√£o dois dos firmwares mais populares para usar.

Observe que **nem sempre √© necess√°rio fazer root no dispositivo** para instalar um firmware personalizado. **Alguns fabricantes permitem** o desbloqueio de seus bootloaders de maneira bem documentada e segura.

### Implica√ß√µes

Uma vez que um dispositivo est√° rooteado, qualquer aplicativo pode solicitar acesso como root. Se um aplicativo malicioso obtiver acesso, ele poder√° ter acesso a quase tudo e poder√° danificar o telefone.

## Fundamentos de Aplicativos Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

Esta introdu√ß√£o foi retirada de [https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html](https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html)

### Revis√£o dos Fundamentos <a href="#fundamentals-review" id="fundamentals-review"></a>

* Os aplicativos Android est√£o no formato de arquivo _APK_. **APK √© basicamente um arquivo ZIP**. (Voc√™ pode renomear a extens√£o do arquivo para .zip e usar o unzip para abrir e ver seu conte√∫do.)
* Conte√∫do do APK (n√£o exaustivo)
* **AndroidManifest.xml**
* resources.arsc/strings.xml
* resources.arsc: um arquivo contendo recursos pr√©-compilados, como XML bin√°rio, por exemplo.
* res/xml/files\_paths.xml
* META-INF/
* O certificado fica aqui!
* **classes.dex**
* Bytecode Dalvik para o aplicativo no formato de arquivo DEX. **Este √© o c√≥digo Java (ou Kotlin) compilado que o aplicativo executar√° por padr√£o**.
* lib/
* Bibliotecas nativas para o aplicativo, por padr√£o, ficam aqui! Sob o diret√≥rio lib/, existem os diret√≥rios espec√≠ficos do processador.
* `armeabi`: c√≥digo compilado apenas para processadores baseados em ARM
* `armeabi-v7a`: c√≥digo compilado apenas para processadores baseados em ARMv7 e acima
* `x86`: c√≥digo compilado para X86
* `mips`: c√≥digo compilado apenas para processadores MIPS
* assets/
* Quaisquer outros arquivos que possam ser necess√°rios pelo aplicativo.
* Bibliotecas nativas adicionais ou arquivos DEX podem ser inclu√≠dos aqui. Isso pode acontecer especialmente quando os autores de malware desejam tentar "ocultar" c√≥digo adicional, nativo ou Dalvik, n√£o incluindo-o nos locais padr√£o.
* res/
* o diret√≥rio que cont√©m recursos n√£o compilados em resources.arsc

### **Dalvik & Smali**

A maioria dos aplicativos Android √© escrita em Java. O Kotlin tamb√©m √© suportado e interoper√°vel com o Java. Para facilitar, para o restante deste workshop, quando me referir a "Java", voc√™ pode assumir que estou me referindo a "Java ou Kotlin". **Em vez de o c√≥digo Java ser executado na M√°quina Virtual Java** (JVM) como aplicativos de desktop, no Android, o **Java √© compilado para o bytecode \_Dalvik Executable (DEX)**\_\* formato\*\*. Para vers√µes anteriores do Android, o bytecode era traduzido pela m√°quina virtual Dalvik. Para vers√µes mais recentes do Android, o Android Runtime (ART) √© usado.\
Se os desenvolvedores escrevem em Java e o c√≥digo √© compilado para bytecode DEX, para engenharia reversa, trabalhamos na dire√ß√£o oposta.\
\\

![Fluxograma do processo do desenvolvedor. Java para bytecode DEX](https://maddiestone.github.io/AndroidAppRE/images/DevelopersFlow.jpg)

![Fluxograma do processo de engenharia reversa. Bytecode DEX para SMALI para Java descompilado](https://maddiestone.github.io/AndroidAppRE/images/ReversersFlow.jpg)

**Smali √© a vers√£o leg√≠vel por humanos do bytecode Dalvik**. Tecnicamente, Smali e baksmali s√£o os nomes das ferramentas (montador e desmontador, respectivamente), mas no Android, geralmente usamos o termo "Smali" para se referir √†s instru√ß√µes. Se voc√™ j√° fez engenharia reversa ou arquitetura de computadores em c√≥digo C/C++ compilado. **SMALI √© como a linguagem de montagem: entre o c√≥digo-fonte de n√≠vel superior e o bytecode**.

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof √© o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof s√£o lan√ßadas apenas quando seus clientes depositam o or√ßamento de recompensa. Voc√™ receber√° a recompensa ap√≥s a verifica√ß√£o do bug.

**Adquira experi√™ncia em pentesting web3**\
Protocolos de blockchain e contratos inteligentes s√£o a nova Internet! Domine a seguran√ßa web3 em seus dias de ascens√£o.

**Torne-se a lenda do hacker web3**\
Ganhe pontos de reputa√ß√£o com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

## Intents

Intents s√£o o principal meio pelo qual os aplicativos Android se comunicam entre seus componentes ou com outros aplicativos. Esses objetos de mensagem tamb√©m podem transportar dados entre aplicativos ou componentes, semelhante √† forma como as solicita√ß√µes GET/POST s√£o usadas nas comunica√ß√µes HTTP.

Portanto, um Intent √© basicamente uma **mensagem que √© passada entre componentes**. Intents **podem ser direcionados** para componentes ou aplicativos espec√≠ficos, **ou podem ser enviados sem um destinat√°rio espec√≠fico**.\
Para simplificar, um Intent pode ser usado:

* Para iniciar uma Activity, geralmente abrindo uma interface de usu√°rio para um aplicativo
* Como transmiss√µes para informar o sistema e os aplicativos sobre altera√ß√µes
* Para iniciar, parar e se comunicar com um servi√ßo em segundo plano
* Para acessar dados por meio de ContentProviders
* Como callbacks para lidar com eventos

A implementa√ß√£o inadequada pode resultar em vazamento de dados, chamadas de fun√ß√µes restritas e manipula√ß√£o do fluxo do programa.

### Filtro de Intents

Um Filtro de Intent especifica os **tipos de Intent que uma activity, service ou Broadcast Receiver pode responder**. Ele especifica o que uma activity ou service pode fazer e quais tipos de transmiss√µes um Receiver pode lidar. Ele permite que o componente correspondente receba Intents do tipo declarado. Os Filtros de Intent s√£o normalmente **definidos por meio do arquivo AndroidManifest.xml**. Para **Broadcast Receiver**, tamb√©m √© poss√≠vel defini-los em **c√≥digo**. Um Filtro de Intent √© definido por sua categoria, a√ß√£o e filtros de dados. Ele tamb√©m pode conter metadados adicionais.

No Android, uma activity/service/content provider/broadcast receiver √© **p√∫blica** quando o atributo **`exported`** √© definido como **`true`**, mas um componente tamb√©m √© p√∫blico se o manifesto especificar um filtro de Intent para ele. No entanto,\
os desenvolvedores podem **tornar explicitamente os componentes privados** (independentemente de quaisquer filtros de intent)\
definindo o atributo **`exported`** como **`false`** para cada componente no arquivo de manifesto.\
Os desenvolvedores tamb√©m podem definir o atributo **`permission`** para **exigir uma determinada permiss√£o para acessar** o componente, restringindo assim o acesso ao componente.
### Inten√ß√µes Impl√≠citas

Inten√ß√µes s√£o criadas programaticamente usando um construtor de Inten√ß√µes:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
A **A√ß√£o** do intent previamente declarado √© **ACTION\_SEND** e o **Extra** √© um **Uri** de mailto (o Extra √© a informa√ß√£o extra que o intent est√° esperando).

Este intent deve ser declarado dentro do manifesto como no exemplo a seguir:
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Um intent-filter precisa corresponder √† **a√ß√£o**, **dados** e **categoria** para receber uma mensagem.

O processo de "resolu√ß√£o de inten√ß√£o" determina qual aplicativo deve receber cada mensagem. Esse processo considera o atributo de **prioridade**, que pode ser definido na declara√ß√£o do **intent-filter**, e **o que tiver a maior prioridade ser√° selecionado**. Essa prioridade pode ser definida entre -1000 e 1000, e os aplicativos podem usar o valor `SYSTEM_HIGH_PRIORITY`. Se ocorrer um **conflito**, uma janela de "escolha" aparece para que o **usu√°rio possa decidir**.

### Inten√ß√µes Expl√≠citas

Uma inten√ß√£o expl√≠cita especifica o nome da classe que est√° sendo direcionada:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Em outras aplica√ß√µes, para acessar a inten√ß√£o previamente declarada, voc√™ pode usar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Inten√ß√µes Pendentes

Essas permitem que outras aplica√ß√µes **tomem a√ß√µes em nome da sua aplica√ß√£o**, usando a identidade e permiss√µes do seu app. Ao construir uma Inten√ß√£o Pendente, deve-se **especificar uma inten√ß√£o e a a√ß√£o a ser executada**. Se a **inten√ß√£o declarada n√£o for expl√≠cita** (n√£o declara qual inten√ß√£o pode cham√°-la), um **aplicativo malicioso pode executar a a√ß√£o declarada** em nome do aplicativo da v√≠tima. Al√©m disso, **se uma a√ß√£o n√£o for especificada**, o aplicativo malicioso poder√° fazer **qualquer a√ß√£o em nome da v√≠tima**.

### Inten√ß√µes de Transmiss√£o

Ao contr√°rio das inten√ß√µes anteriores, que s√£o recebidas apenas por um aplicativo, as inten√ß√µes de transmiss√£o **podem ser recebidas por v√°rios aplicativos**. No entanto, a partir da vers√£o API 14, √© **poss√≠vel especificar o aplicativo que deve receber** a mensagem usando Intent.setPackage.

Alternativamente, tamb√©m √© poss√≠vel **especificar uma permiss√£o ao enviar a transmiss√£o**. O aplicativo receptor precisar√° ter essa permiss√£o.

Existem **dois tipos** de transmiss√µes: **Normais** (ass√≠ncronas) e **Ordenadas** (s√≠ncronas). A **ordem** √© baseada na **prioridade configurada dentro do receptor**. **Cada aplicativo pode processar, retransmitir ou descartar a transmiss√£o**.

√â poss√≠vel **enviar** uma **transmiss√£o** usando a fun√ß√£o \*\*`sendBroadcast(intent, receiverPermission)` \*\* da classe `Context`.\
Voc√™ tamb√©m pode usar a fun√ß√£o **`sendBroadcast`** do **`LocalBroadCastManager`** para garantir que a **mensagem nunca saia do aplicativo**. Usando isso, voc√™ nem precisa exportar um componente receptor.

### Transmiss√µes Persistentes

Esse tipo de transmiss√£o **pode ser acessado muito tempo depois de ser enviado**.\
Essas foram descontinuadas no n√≠vel da API 21 e √© recomendado **n√£o us√°-las**.\
**Elas permitem que qualquer aplicativo intercepte os dados, mas tamb√©m os modifique.**

Se voc√™ encontrar fun√ß√µes contendo a palavra "persistent" como **`sendStickyBroadcast`** ou **`sendStickyBroadcastAsUser`**, **verifique o impacto e tente remov√™-las**.

## Deep links / Esquemas de URL

**Deep links permitem acionar uma Inten√ß√£o por meio de uma URL**. Um aplicativo pode declarar um **esquema de URL** dentro de uma atividade, para que toda vez que o dispositivo Android tente **acessar um endere√ßo usando esse esquema**, a atividade do aplicativo seja chamada:

![](<../../.gitbook/assets/image (214).png>)

Neste caso, o esquema √© `myapp://` (observe tamb√©m a **`categoria BROWSABLE`**)

Se dentro do `intent-filter` voc√™ encontrar algo como isso:

![](<../../.gitbook/assets/image (263).png>)

Ent√£o, est√° esperando algo como `http://www.example.com/gizmos`

Se voc√™ encontrar algo como isso:

![](<../../.gitbook/assets/image (262).png>)

Significar√° que est√° esperando uma URL que comece com `example://gizmos`\
Nesse caso, voc√™ pode tentar abusar da funcionalidade criando uma p√°gina da web com as seguintes cargas √∫teis. Ela tentar√° navegar para p√°ginas arbitr√°rias e tentar executar JS:
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Para encontrar o **c√≥digo que ser√° executado no aplicativo**, v√° para a atividade chamada pelo deeplink e procure a fun√ß√£o **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Aprenda como [chamar deep links sem usar p√°ginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

A **Linguagem de Defini√ß√£o de Interface Android** (AIDL) permite que voc√™ defina a interface de programa√ß√£o que tanto o cliente quanto o servi√ßo concordam em usar para **comunicar-se entre si usando comunica√ß√£o entre processos** (IPC). No Android, **um processo normalmente n√£o pode acessar a mem√≥ria de outro processo**. Portanto, para se comunicarem, eles precisam decompor seus objetos em primitivas que o **sistema operacional** possa entender e enviar os objetos atrav√©s dessa fronteira para voc√™. O c√≥digo para fazer essa transfer√™ncia √© tedioso de escrever, ent√£o o Android lida com isso para voc√™ com o AIDL.

Servi√ßos que usam o AIDL s√£o chamados de **Servi√ßos Vinculados**. Na classe do servi√ßo, voc√™ encontrar√° o m√©todo **`onBind`**. √â **onde a intera√ß√£o come√ßa**, ent√£o √© a parte inicial do c√≥digo a ser revisada em busca de vulnerabilidades potenciais.

Um servi√ßo vinculado √© o servidor em uma interface cliente-servidor. **Ele permite que componentes (como atividades) se vinculem ao servi√ßo, enviem solicita√ß√µes, recebam respostas e realizem comunica√ß√£o entre processos** (IPC). Um servi√ßo vinculado normalmente existe apenas enquanto atende a outro componente do aplicativo e n√£o √© executado indefinidamente em segundo plano.

### Messenger

Um Messenger √© outro tipo de mecanismo IPC. Como o **Messenger tamb√©m √© um "Servi√ßo Vinculado"**, os dados enviados pelo aplicativo cliente tamb√©m s√£o processados atrav√©s do m√©todo `onBind`. Portanto, a revis√£o do c√≥digo deve come√ßar por esse m√©todo e voc√™ deve procurar a invoca√ß√£o de funcionalidades sens√≠veis ou manipula√ß√£o insegura de dados.

### Binder

√â incomum encontrar uma classe Binder invocada diretamente, pois √© muito mais f√°cil usar o AIDL (que abstrai a classe Binder). No entanto, √© bom saber que o **Binder √© um driver de n√≠vel de kernel que move dados da mem√≥ria de um processo para outro** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Componentes

Isso inclui: **Atividades, Servi√ßos, Receptores de Transmiss√£o e Provedores**.

### Atividade de Lan√ßamento e outras atividades

Uma **atividade Android** √© uma tela da interface do usu√°rio do aplicativo Android. Nesse sentido, uma **atividade Android** √© muito semelhante a janelas em um aplicativo de desktop. Um aplicativo Android pode conter uma ou mais atividades, ou seja, uma ou mais telas.

A **atividade de lan√ßamento** √© o que a maioria das pessoas considera como o **ponto de entrada** de um aplicativo Android. A atividade de lan√ßamento √© a atividade que √© iniciada quando um usu√°rio clica no √≠cone de um aplicativo. Voc√™ pode determinar a atividade de lan√ßamento olhando o manifesto do aplicativo. A atividade de lan√ßamento ter√° as seguintes inten√ß√µes MAIN e LAUNCHER listadas.

Lembre-se de que nem todo aplicativo ter√° uma atividade de lan√ßamento, especialmente aplicativos sem interface do usu√°rio. Exemplos de aplicativos sem uma interface do usu√°rio (e, portanto, sem uma atividade de lan√ßamento) s√£o aplicativos pr√©-instalados que executam servi√ßos em segundo plano, como correio de voz.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
As atividades podem ser exportadas, permitindo que outros processos no dispositivo iniciem a atividade. Por padr√£o, elas n√£o s√£o exportadas, mas voc√™ pode export√°-las definindo:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Observe que a capacidade de **burlar as prote√ß√µes de atividade nem sempre √© uma vulnerabilidade**, voc√™ precisa verificar a qual dados voc√™ obteve acesso.
Al√©m disso, **algumas atividades retornam dados para um chamador**. Nesses cen√°rios, voc√™ precisa procurar pelo m√©todo **`setResult`** e verificar os dados que s√£o passados como par√¢metro para o Intent. **Se forem dados sens√≠veis, pode haver uma vulnerabilidade de vazamento de informa√ß√µes** e ela pode ser explorada por aplicativos capazes de se comunicar com a atividade.

**O c√≥digo de uma atividade come√ßa com o m√©todo `onCreate`.**

### Subclasse de Aplicativo

Os aplicativos Android podem definir uma **subclasse** de [Application](https://developer.android.com/reference/android/app/Application). Os aplicativos podem, mas n√£o precisam, definir uma subclasse personalizada de Application. Se um aplicativo Android define uma subclasse de Application, **essa classe √© instanciada antes de qualquer outra classe no aplicativo**.

Se o m√©todo **`attachBaseContext`** for definido na subclasse de Application, ele ser√° chamado primeiro, antes do m√©todo **`onCreate`**.

### Servi√ßos

[Servi√ßos](https://developer.android.com/guide/components/services) **executam em segundo plano sem uma interface de usu√°rio**. Eles s√£o usados para realizar **processos de longa dura√ß√£o, mesmo se o usu√°rio come√ßar a usar um aplicativo diferente**.

Existem v√°rias maneiras de inici√°-los e, portanto, s√£o um ponto de entrada para aplicativos. A maneira padr√£o de iniciar um servi√ßo como ponto de entrada para um aplicativo √© por meio de **Intents**.

Quando o m√©todo **`startService`** √© chamado para iniciar um servi√ßo, o m√©todo **`onStart`** no servi√ßo √© executado. Ele ser√° executado indefinidamente at√© que o m√©todo **`stopService`** seja chamado. Se o servi√ßo for necess√°rio apenas enquanto o cliente estiver conectado, o cliente deve "vincular-se" a ele usando o m√©todo **`bindService`**.

Para um **servi√ßo vinculado** (veja a se√ß√£o anterior), os dados ser√£o passados para o m√©todo **`onBind`**.

Por exemplo, um servi√ßo pode reproduzir m√∫sica em segundo plano enquanto o usu√°rio est√° em um aplicativo diferente, ou pode buscar dados pela rede sem bloquear a intera√ß√£o do usu√°rio com uma atividade.

Um **servi√ßo pode ser exportado, permitindo que outros processos no dispositivo iniciem o servi√ßo**. Por padr√£o, os servi√ßos n√£o s√£o exportados, mas isso pode ser configurado no Manifest:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Receptores de Transmiss√£o

As transmiss√µes podem ser consideradas um sistema de mensagens e os **receptores de transmiss√£o s√£o os ouvintes**. Se um aplicativo tiver registrado um receptor para uma transmiss√£o espec√≠fica, o c√≥digo desse receptor ser√° executado quando o sistema enviar a transmiss√£o. Note que, nesse caso, **v√°rios aplicativos podem receber a mesma mensagem**.

Existem **2 maneiras** pelas quais um aplicativo pode **registrar um receptor**: no **Manifest do aplicativo ou registrado dinamicamente** no c√≥digo do aplicativo usando a chamada de API **`registerReceiver`**. No manifesto, voc√™ pode limitar as transmiss√µes que aceita por meio do **uso de permiss√µes dentro do elemento receptor**. Quando definido **dinamicamente**, voc√™ pode **passar a permiss√£o para o m√©todo `registerReceiver`**.

Em ambos os casos, para registrar o receptor, s√£o definidos os **filtros de inten√ß√£o para o receptor**. Esses filtros de inten√ß√£o s√£o as transmiss√µes que devem acionar o receptor.

Quando as transmiss√µes espec√≠ficas para as quais o receptor est√° registrado s√£o enviadas, o m√©todo **`onReceive`** na classe BroadcastReceiver √© **executado**.

Um aplicativo pode registrar um receptor para a mensagem de bateria fraca, por exemplo, e alterar seu comportamento com base nessas informa√ß√µes.

As transmiss√µes podem ser **ass√≠ncronas** (todos os receptores as recebem) ou **s√≠ncronas** (a transmiss√£o √© recebida de maneira ordenada com base na prioridade definida para receb√™-la).

{% hint style="danger" %}
**Observe que qualquer aplicativo pode se definir como prioridade m√°xima para receber uma transmiss√£o.**
{% endhint %}

Para **examinar** o **c√≥digo** implementado em um Receptor de Transmiss√£o, voc√™ precisa procurar pelo m√©todo **`onReceive`** da classe do receptor.\
Observe que as **Transmiss√µes Ordenadas** podem descartar a Inten√ß√£o recebida ou at√© mesmo modific√°-la usando um dos m√©todos setter. Portanto, os **receptores devem validar os dados**.

### Provedor de Conte√∫do

Os Provedores de Conte√∫do s√£o a maneira como os aplicativos compartilham dados estruturados, como bancos de dados relacionais. Portanto, √© muito importante usar **permiss√µes** e definir o n√≠vel de prote√ß√£o apropriado para proteg√™-los.\
Os Provedores de Conte√∫do podem usar os atributos **`readPermission`** e **`writePermission`** para especificar quais permiss√µes um aplicativo deve ter. **Essas permiss√µes t√™m preced√™ncia sobre o atributo de permiss√£o**.\
Al√©m disso, eles tamb√©m podem **permitir exce√ß√µes tempor√°rias** definindo **`grantUriPermission`** como true e, em seguida, configurando os par√¢metros apropriados no elemento **`grant-uri-permission`** dentro do elemento provedor no arquivo manifesto.

O **`grant-uri-permission`** possui tr√™s atributos: path, pathPrefix e pathPattern:

* **path**: Permite especificar o caminho inteiro a ser exclu√≠do
* **pathPrefix**: Permite especificar o in√≠cio do caminho
* **pathPattern**: Permite o uso de curingas e substitui√ß√µes simb√≥licas para obter um controle mais granular.

√â **importante validar e sanitizar a entrada recebida** para evitar vulnerabilidades potenciais, como inje√ß√£o de SQL.

**Recursos do Provedor de Conte√∫do:**

* O componente Provedor de Conte√∫do fornece dados de um aplicativo para outros mediante solicita√ß√£o.
* Voc√™ pode armazenar os dados no sistema de arquivos, em um banco de dados SQLite, na web ou em qualquer outro local de armazenamento persistente que seu aplicativo possa acessar.
* Por meio do provedor de conte√∫do, outros aplicativos podem consultar ou at√© mesmo modificar os dados (se o provedor de conte√∫do permitir).
* O Provedor de Conte√∫do √© √∫til em casos em que um aplicativo deseja compartilhar dados com outro aplicativo.
* √â muito semelhante a bancos de dados e possui quatro m√©todos.
* insert()
* update()
* delete()
* query()

**FileProvider**

Este √© um tipo de Provedor de Conte√∫do que ir√° **compartilhar arquivos** de uma pasta. Voc√™ pode declarar um provedor de arquivos da seguinte forma:
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Observe o atributo **`android:exported`** porque se for **`true`**, aplicativos externos poder√£o acessar as pastas compartilhadas.\
Observe que a configura√ß√£o `android:resource="@xml/filepaths"` indica que o arquivo _res/xml/filepaths.xml_ cont√©m a configura√ß√£o de **quais pastas** este **FileProvider** ir√° **compartilhar**. Este √© um exemplo de como indicar o compartilhamento de uma pasta nesse arquivo:
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Compartilhar algo como **`path="."`** pode ser **perigoso**, mesmo que o provedor n√£o seja exportado, se houver outra vulnerabilidade em alguma parte do c√≥digo que tente acessar esse provedor.\
Voc√™ pode **acessar** uma **imagem** dentro dessa pasta com `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

O elemento `<paths>` pode ter v√°rios filhos, cada um especificando um diret√≥rio diferente para compartilhar. Al√©m do elemento **`<files-path>`**, voc√™ pode usar o elemento **`<external-path>`** para compartilhar diret√≥rios no **armazenamento externo**, e o elemento **`<cache-path>`** para compartilhar diret√≥rios no diret√≥rio de cache interno.\
[Para obter mais informa√ß√µes sobre atributos espec√≠ficos de provedores de arquivos, clique aqui.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[Mais informa√ß√µes sobre FileProviders aqui](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

WebViews s√£o **navegadores da web** incorporados em aplicativos Android.\
O conte√∫do dos WebViews pode ser obtido de sites remotos ou pode ser arquivos inclu√≠dos no aplicativo.\
Os WebViews s√£o **vulner√°veis √†s mesmas vulnerabilidades que afetam qualquer navegador da web**. No entanto, existem algumas **configura√ß√µes** que podem ser √∫teis para **limitar** a **superf√≠cie de ataque**.

Existem dois tipos de WebViews no Android:

* O **WebViewClient**, mais adequado para renderiza√ß√£o de HTML simples. Isso n√£o executar√° a fun√ß√£o de alerta JS. Portanto, testes de XSS usando essa fun√ß√£o ser√£o inv√°lidos.
* O **cliente WebChrome**, √© um navegador Chrome.

Observe que os navegadores **WebView n√£o t√™m acesso aos cookies do navegador nativo**.

Para carregar uma URL ou arquivo, √© poss√≠vel usar as fun√ß√µes **`loadUrl`**, **`loadData`** ou **`loadDataWithBaseURL`**. **√â importante acessar apenas URLs sanitizadas.**\
A seguran√ßa do WebView pode ser configurada por meio do objeto **`WebSettings`**.\
Por exemplo, a execu√ß√£o de c√≥digo JS pode ser desativada usando o m√©todo **`setJavaScriptEnabled`** com o valor **`false`**. Isso **remover√°** a possibilidade de um **XSS** e outras vulnerabilidades relacionadas ao JS.

A funcionalidade de JavaScript "**Bridge**" **injeta objetos Java em um WebView, tornando-os acess√≠veis ao JS**. A partir do Android 4.2, os m√©todos devem ser anotados com **`@JavascriptInterface`** para serem acess√≠veis ao JavaScript.

Se **`true`** for passado para **`setAllowContentAccess`**, os WebViews poder√£o acessar Provedores de Conte√∫do por meio do esquema **`content://`**. Isso obviamente representa um risco de seguran√ßa. Observe que, se esse acesso for concedido, √© muito importante **garantir** que a URL **`content://`** seja **segura**.

Por padr√£o, arquivos locais podem ser acessados pelos WebViews por meio de URLs file://, mas existem v√°rias maneiras de evitar esse comportamento:

* Passar **`false`** para **`setAllowFileAccess`**, impede o acesso ao sistema de arquivos com exce√ß√£o dos ativos via `file:///android_asset` _e_ `file:///android_res`. Esses caminhos devem ser usados apenas para dados n√£o sens√≠veis (como imagens), portanto, isso deve ser seguro.
* O m√©todo **`setAllowFileAccess`** indica se um caminho de uma URL `file://` deve ser capaz de acessar o conte√∫do de outras URLs de esquema de arquivo.
* O m√©todo **`setAllowUniversalAccessFromFileURLs`** indica se um caminho de uma URL `file://` deve ser capaz de acessar conte√∫do de qualquer origem.

## Outros componentes do aplicativo

### **Assinatura do aplicativo**

* O Android requer que **todos os aplicativos sejam assinados digitalmente com um certificado** antes de poderem ser instalados. O Android usa esse certificado para identificar o autor de um aplicativo.
* Para executar o aplicativo no dispositivo, ele deve ser assinado. Quando o aplicativo √© instalado em um dispositivo, o **gerenciador de pacotes verifica** se o aplicativo foi devidamente assinado com o certificado no arquivo apk ou n√£o.
* O aplicativo pode ser autoassinado ou pode ser assinado por uma Autoridade de Certifica√ß√£o (CA).
* A assinatura do aplicativo garante que um aplicativo n√£o possa acessar nenhum outro aplicativo, exceto por meio de IPC bem definido, e tamb√©m que ele seja transmitido sem modifica√ß√µes para o dispositivo.

### **Verifica√ß√£o do aplicativo**

* O Android 4.2 e posterior suportam a verifica√ß√£o do aplicativo. Os usu√°rios podem optar por ativar a op√ß√£o "Verificar aplicativos" e ter os aplicativos avaliados por um verificador de aplicativos antes da instala√ß√£o.
* A verifica√ß√£o do aplicativo pode alertar o usu√°rio se ele tentar instalar um aplicativo que possa ser prejudicial; se um aplicativo for especialmente ruim, ele pode bloquear a instala√ß√£o.

## Gerenciamento de dispositivos m√≥veis

MDM ou Mobile Device Management s√£o conjuntos de software usados para **garantir controle e requisitos de seguran√ßa** em dispositivos m√≥veis. Esses conjuntos usam recursos referidos como API de Administra√ß√£o de Dispositivos e exigem a instala√ß√£o de um aplicativo Android.

Geralmente, as solu√ß√µes de MDM executam fun√ß√µes como impor pol√≠ticas de senha, for√ßar a criptografia de armazenamento e permitir a exclus√£o remota de dados do dispositivo.

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof √© o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof s√£o lan√ßadas apenas quando os clientes depositam o or√ßamento de recompensa. Voc√™ receber√° a recompensa ap√≥s a verifica√ß√£o do bug.

**Adquira experi√™ncia em pentesting web3**\
Protocolos de blockchain e contratos inteligentes s√£o a nova Internet! Domine a seguran√ßa web3 em seus dias de ascens√£o.

**Torne-se a lenda do hacker web3**\
Ganhe pontos de reputa√ß√£o com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) e comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **vers√£o mais recente do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas dicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
