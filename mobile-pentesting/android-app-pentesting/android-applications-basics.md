# Fundamentos de Aplicaciones Android

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan para que puedas solucionarlas más rápido. Intruder rastrea tu superficie de ataque, ejecuta escaneos proactivos de amenazas, encuentra problemas en toda tu pila tecnológica, desde APIs hasta aplicaciones web y sistemas en la nube. [**¡Pruébalo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Modelo de Seguridad de Android

**Hay dos capas:**

* El **SO**, que mantiene las aplicaciones instaladas aisladas entre sí.
* La **aplicación en sí**, que permite a los desarrolladores **exponer ciertas funcionalidades** y configurar las capacidades de la aplicación.

### Separación de UID

**A cada aplicación se le asigna un ID de usuario específico**. Esto se hace durante la instalación de la aplicación para que **la aplicación solo pueda interactuar con archivos propiedad de su ID de usuario o archivos compartidos**. Por lo tanto, solo la aplicación en sí, ciertos componentes del SO y el usuario root pueden acceder a los datos de las aplicaciones.

### Compartir UID

**Dos aplicaciones pueden configurarse para usar el mismo UID**. Esto puede ser útil para compartir información, pero si una de ellas se ve comprometida, los datos de ambas aplicaciones se verán comprometidos. Por eso este comportamiento es **desaconsejado**.\
**Para compartir el mismo UID, las aplicaciones deben definir el mismo valor `android:sharedUserId` en sus manifiestos.**

### Aislamiento

La **Sandbox de Aplicaciones Android** permite ejecutar **cada aplicación** como un **proceso separado bajo un ID de usuario separado**. Cada proceso tiene su propia máquina virtual, por lo que el código de una aplicación se ejecuta de forma aislada de otras aplicaciones.\
A partir de Android 5.0(L) se aplica **SELinux**. Básicamente, SELinux denegó todas las interacciones de procesos y luego creó políticas para **permitir solo las interacciones esperadas entre ellos**.

### Permisos

Cuando instalas una **aplicación y solicita permisos**, la aplicación está pidiendo los permisos configurados en los elementos **`uses-permission`** en el archivo **AndroidManifest.xml**. El elemento **uses-permission** indica el nombre del permiso solicitado dentro del **atributo de nombre**. También tiene el atributo **maxSdkVersion** que deja de solicitar permisos en versiones superiores a la especificada.\
Ten en cuenta que las aplicaciones de Android no necesitan solicitar todos los permisos al principio, también pueden **solicitar permisos dinámicamente** pero todos los permisos deben estar **declarados** en el **manifiesto**.

Cuando una aplicación expone funcionalidades puede limitar el **acceso solo a aplicaciones que tengan un permiso especificado**.\
Un elemento de permiso tiene tres atributos:

* El **nombre** del permiso
* El atributo **permission-group**, que permite agrupar permisos relacionados.
* El **nivel de protección** que indica cómo se otorgan los permisos. Hay cuatro tipos:
  * **Normal**: Se utiliza cuando no hay **amenazas conocidas** para la aplicación. No se requiere que el usuario lo apruebe.
  * **Peligroso**: Indica que el permiso otorga a la aplicación solicitante cierto **acceso elevado**. **Se solicita a los usuarios que los aprueben**.
  * **Firma**: Solo **las aplicaciones firmadas por el mismo certificado que la** que exporta el componente pueden recibir permiso. Este es el tipo de protección más fuerte.
  * **FirmaOSystema**: Solo **las aplicaciones firmadas por el mismo certificado que la** que exporta el componente o **las aplicaciones que se ejecutan con acceso a nivel de sistema** pueden recibir permisos.

## Aplicaciones Preinstaladas

Estas aplicaciones generalmente se encuentran en los directorios **`/system/app`** o **`/system/priv-app`** y algunas de ellas están **optimizadas** (es posible que ni siquiera encuentres el archivo `classes.dex`). Vale la pena verificar estas aplicaciones porque a veces están **ejecutándose con demasiados permisos** (como root).

* Las que se envían con el **ROM** de **AOSP** (Proyecto de Código Abierto de Android)
* Agregadas por el **fabricante** del dispositivo
* Agregadas por el **proveedor** de telefonía celular (si se compró a través de ellos)

## Rooting

Para obtener acceso root en un dispositivo Android físico generalmente necesitas **explotar** 1 o 2 **vulnerabilidades** que suelen ser **específicas** para el **dispositivo** y la **versión**.\
Una vez que la explotación ha funcionado, generalmente se copia el binario `su` de Linux en una ubicación especificada en la variable de entorno PATH del usuario como `/system/xbin`.

Una vez configurado el binario su, se utiliza otra aplicación de Android para interactuar con el binario `su` y **procesar solicitudes de acceso root** como **Superuser** y **SuperSU** (disponibles en Google Play Store).

{% hint style="danger" %}
Ten en cuenta que el proceso de rooting es muy peligroso y puede dañar gravemente el dispositivo
{% endhint %}

### ROMs

Es posible **reemplazar el SO instalando un firmware personalizado**. Haciendo esto es posible extender la utilidad de un dispositivo antiguo, evadir restricciones de software o acceder al código más reciente de Android.\
**OmniROM** y **LineageOS** son dos de los firmwares más populares para usar.

Ten en cuenta que **no siempre es necesario rootear el dispositivo** para instalar un firmware personalizado. **Algunos fabricantes permiten** el desbloqueo de sus cargadores de arranque de manera documentada y segura.

### Implicaciones

Una vez que un dispositivo está rooteado, cualquier aplicación podría solicitar acceso como root. Si una aplicación maliciosa lo obtiene, podrá acceder a casi todo y podrá dañar el teléfono.

## Fundamentos de Aplicaciones Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- El formato de las aplicaciones de Android se denomina formato de archivo _APK_. Es esencialmente un **archivo ZIP** (al cambiar la extensión del archivo a .zip, se pueden extraer y ver los contenidos).
- Contenidos de APK (No exhaustivo)
  - **AndroidManifest.xml**
  - resources.arsc/strings.xml
  - resources.arsc: contiene recursos precompilados, como XML binario.
  - res/xml/files\_paths.xml
  - META-INF/
    - ¡Aquí se encuentra el Certificado!
  - **classes.dex**
    - Contiene bytecode Dalvik, que representa el código Java (o Kotlin) compilado que la aplicación ejecuta de forma predeterminada.
  - lib/
    - Contiene bibliotecas nativas, segregadas por arquitectura de CPU en subdirectorios.
      - `armeabi`: código para procesadores basados en ARM
      - `armeabi-v7a`: código para procesadores basados en ARMv7 y superiores
      - `x86`: código para procesadores X86
      - `mips`: código solo para procesadores MIPS
  - assets/
    - Almacena archivos diversos necesarios para la aplicación, potencialmente incluyendo bibliotecas nativas adicionales o archivos DEX, a veces utilizados por autores de malware para ocultar código adicional.
  - res/
    - Contiene recursos que no se compilan en resources.arsc

### **Dalvik y Smali**

- La mayoría de las aplicaciones de Android se desarrollan en Java o Kotlin (intercambiables en este contexto cuando se refieren a "Java").
- **En lugar de ejecutar código Java en la Máquina Virtual Java** (JVM) como las aplicaciones de escritorio, Android compila Java en **código de bytes Dalvik Ejecutable (DEX)**.
- La traducción de bytecode históricamente era manejada por la máquina virtual Dalvik, mientras que las versiones más recientes de Android utilizan el Android Runtime (ART).
- El proceso de ingeniería inversa implica descompilar el bytecode DEX a un formato legible por humanos.

**Smali es la forma legible por humanos del bytecode Dalvik**. Aunque "Smali" y "baksmali" técnicamente se refieren a las herramientas ensambladoras y desensambladoras, en el contexto de Android, "Smali" a menudo denota las instrucciones en sí mismas. **SMALI es similar al lenguaje ensamblador, sirviendo como intermediario entre el código fuente y el bytecode**.


<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan para que puedas solucionarlas más rápido. Intruder rastrea tu superficie de ataque, ejecuta escaneos proactivos de amenazas, encuentra problemas en toda tu pila tecnológica, desde APIs hasta aplicaciones web y sistemas en la nube. [**¡Pruébalo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

***

## Intents

Los Intents son el principal medio por el cual las aplicaciones de Android se comunican entre sus componentes o con otras aplicaciones. Estos objetos de mensaje también pueden transportar datos entre aplicaciones o componentes, similar a cómo se utilizan las solicitudes GET/POST en las comunicaciones HTTP.

Por lo tanto, un Intent es básicamente un **mensaje que se pasa entre componentes**. Los Intents **pueden dirigirse** a componentes o aplicaciones específicas, **o pueden enviarse sin un destinatario específico**.\
Para simplificar, un Intent se puede usar para:

* Iniciar una Actividad, abriendo típicamente una interfaz de usuario para una aplicación
* Como transmisiones para informar al sistema y a las aplicaciones de cambios
* Para iniciar, detener y comunicarse con un servicio en segundo plano
* Para acceder a datos a través de ContentProviders
* Como devoluciones de llamada para manejar eventos

Una implementación incorrecta podría resultar en fuga de datos, llamadas a funciones restringidas y manipulación del flujo del programa.

### Filtro de Intents

Un Filtro de Intent especifica los **tipos de Intent a los que una actividad, servicio o Receptor de Difusión puede responder**. Especifica lo que una actividad o servicio puede hacer y qué tipos de transmisiones puede manejar un Receptor. Permite que el componente correspondiente reciba Intents del tipo declarado. Los Filtros de Intent se definen típicamente a través del archivo AndroidManifest.xml. Para **Receptor de Difusión** también es posible definirlos en **código**. Un Filtro de Intent se define por su categoría, acción y filtros de datos. También puede contener metadatos adicionales.

En Android, una actividad/servicio/proveedor de contenido/receptor de difusión es **público** cuando **`exported`** se establece en **`true`** pero un componente también es **público** si el **manifiesto especifica un filtro de Intent** para él. Sin embargo,\
los desarrolladores pueden **hacer explícitamente privados los componentes** (independientemente de cualquier filtro de Intent)\
configurando el atributo \*\* `exported` en `false`\*\* para cada componente en el archivo de manifiesto.\
Los desarrolladores también pueden establecer el atributo **`permission`** para **requerir un cierto permiso para acceder** al componente, restringiendo así el acceso al componente.

### Intents Implícitos

Los Intents se crean programáticamente utilizando un constructor de Intent:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
La **Acción** del intent previamente declarado es **ACTION\_SEND** y el **Extra** es un **Uri** de mailto (el Extra es la información adicional que el intent espera).

Este intent debe ser declarado dentro del manifiesto como en el siguiente ejemplo:
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Un intent-filter necesita coincidir con la **acción**, **datos** y **categoría** para recibir un mensaje.

El proceso de "resolución de intenciones" determina qué aplicación debe recibir cada mensaje. Este proceso considera el atributo de **prioridad**, que se puede establecer en la **declaración del intent-filter**, y **se seleccionará el que tenga la prioridad más alta**. Esta prioridad se puede establecer entre -1000 y 1000 y las aplicaciones pueden usar el valor `SYSTEM_HIGH_PRIORITY`. Si surge un **conflicto**, aparece una ventana de "selector" para que el **usuario pueda decidir**.

### Intenciones Explícitas

Una intención explícita especifica el nombre de la clase a la que apunta:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
En otras aplicaciones, para acceder al intent previamente declarado, puedes usar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Intenciones Pendientes

Estas permiten que otras aplicaciones **realicen acciones en nombre de tu aplicación**, utilizando la identidad y permisos de tu aplicación. Al construir una Intención Pendiente, se debe **especificar una intención y la acción a realizar**. Si la **intención declarada no es explícita** (no declara qué intención puede llamarla), una **aplicación maliciosa podría realizar la acción declarada** en nombre de la aplicación víctima. Además, **si no se especifica una acción**, la aplicación maliciosa podrá realizar **cualquier acción en nombre de la víctima**.

### Intenciones de Difusión

A diferencia de las intenciones anteriores, que solo son recibidas por una aplicación, las intenciones de difusión **pueden ser recibidas por múltiples aplicaciones**. Sin embargo, a partir de la versión 14 de la API, es **posible especificar la aplicación que debe recibir** el mensaje utilizando Intent.setPackage.

Alternativamente, también es posible **especificar un permiso al enviar la difusión**. La aplicación receptora necesitará tener ese permiso.

Existen **dos tipos** de Difusiones: **Normales** (asincrónicas) y **Ordenadas** (sincrónicas). El **orden** se basa en la **prioridad configurada dentro del receptor**. **Cada aplicación puede procesar, retransmitir o descartar la Difusión**.

Es posible **enviar** una **difusión** utilizando la función \*\*`sendBroadcast(intent, receiverPermission)` \*\* de la clase `Context`.\
También se puede utilizar la función **`sendBroadcast`** del **`LocalBroadCastManager`** para asegurar que el **mensaje nunca abandone la aplicación**. Al hacer esto, ni siquiera necesitarás exportar un componente receptor.

### Difusiones Persistentes

Este tipo de Difusiones **pueden ser accedidas mucho tiempo después de ser enviadas**.\
Fueron desaprobadas en el nivel de API 21 y se recomienda **no utilizarlas**.\
**Permiten que cualquier aplicación husmee los datos, pero también los modifique**.

Si encuentras funciones que contienen la palabra "persistentes" como **`sendStickyBroadcast`** o **`sendStickyBroadcastAsUser`**, **verifica el impacto e intenta eliminarlas**.

## Enlaces Profundos / Esquemas de URL

**Los enlaces profundos permiten activar una Intención a través de una URL**. Una aplicación puede declarar un **esquema de URL** dentro de una actividad para que cada vez que el dispositivo Android intente **acceder a una dirección utilizando ese esquema**, se llame a la actividad de la aplicación:

![](<../../.gitbook/assets/image (214).png>)

En este caso, el esquema es `myapp://` (también se observa la **`categoría BROWSABLE`**)

Si dentro del `intent-filter` encuentras algo como esto:

![](<../../.gitbook/assets/image (263).png>)

Entonces, está esperando algo como `http://www.example.com/gizmos`

Si encuentras algo como esto:

![](<../../.gitbook/assets/image (262).png>)

Significará que está esperando una URL que comience con `example://gizmos`\
En este caso, podrías intentar abusar de la funcionalidad creando una web con los siguientes payloads. Intentará navegar a páginas arbitrarias e intentará ejecutar JS:
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Para encontrar el **código que se ejecutará en la aplicación**, ve a la actividad llamada por el enlace profundo y busca la función **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Aprende cómo [llamar a enlaces profundos sin usar páginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

El **Lenguaje de Definición de Interfaz de Android** (AIDL) te permite definir la interfaz de programación en la que tanto el cliente como el servicio acuerdan para **comunicarse entre sí utilizando comunicación entre procesos** (IPC). En Android, **un proceso normalmente no puede acceder a la memoria de otro proceso**. Por lo tanto, para comunicarse, necesitan descomponer sus objetos en primitivas que el **sistema operativo** pueda entender y transmitir los objetos a través de ese límite por ti. El código para realizar esa transmisión es tedioso de escribir, por lo que Android lo maneja por ti con AIDL.

Los servicios que utilizan AIDL se conocen como **Servicios Vinculados**. En la clase del Servicio encontrarás el método **`onBind`**. Este es **donde comienza la interacción**, por lo que es la parte inicial del código a revisar en busca de posibles vulnerabilidades.

Un servicio vinculado es el servidor en una interfaz cliente-servidor. **Permite a los componentes (como actividades) vincularse al servicio, enviar solicitudes, recibir respuestas y realizar comunicación entre procesos** (IPC). Un servicio vinculado normalmente solo está activo mientras sirve a otro componente de la aplicación y no se ejecuta indefinidamente en segundo plano.

### Messenger

Un Messenger es otro tipo de mecanismo IPC. Dado que el **Messenger también es un "Servicio Vinculado"**, los datos enviados desde la aplicación cliente también se procesan a través del método `onBind`. Por lo tanto, la revisión de código debe comenzar en este método y debes buscar la invocación de funcionalidades sensibles o el manejo inseguro de datos.

### Binder

Es raro encontrar una clase Binder invocada directamente, ya que es mucho más fácil usar AIDL (que abstrae la clase Binder). Sin embargo, es bueno saber que **Binder es un controlador a nivel de kernel que mueve datos de la memoria de un proceso a la de otro** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Componentes

Estos incluyen: **Actividades, Servicios, Receptores de Difusión y Proveedores**.

### Actividad de Inicio y otras actividades

Una **actividad de Android** es una pantalla de la interfaz de usuario de la aplicación de **Android**. De esa manera, una **actividad de Android** es muy similar a las ventanas en una aplicación de escritorio. Una aplicación de **Android** puede contener una o más actividades, lo que significa una o más pantallas.

La **actividad de inicio** es lo que la mayoría de la gente piensa como el **punto de entrada** a una aplicación de Android. La actividad de inicio es la actividad que se inicia cuando un usuario hace clic en el icono de una aplicación. Puedes determinar la actividad de inicio mirando el manifiesto de la aplicación. La actividad de inicio tendrá las siguientes intenciones MAIN y LAUNCHER listadas.

Ten en cuenta que no todas las aplicaciones tendrán una actividad de inicio, especialmente las aplicaciones sin interfaz de usuario. Ejemplos de aplicaciones sin interfaz de usuario (y por lo tanto sin actividad de inicio) son las aplicaciones preinstaladas que realizan servicios en segundo plano, como el correo de voz.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Las actividades se pueden exportar permitiendo que otros procesos en el dispositivo inicien la actividad. Por defecto, no están exportadas, pero puedes exportarlas configurando:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ten en cuenta que la capacidad de **burlar las protecciones de actividad no siempre es una vulnerabilidad**, debes verificar a qué datos has obtenido acceso.  
Además, **algunas actividades devuelven datos a un llamante**. En estos escenarios, debes buscar el método **`setResult`** y verificar los datos que se pasan al parámetro Intent. **Si son datos sensibles, podrías tener una vulnerabilidad de fuga de información** y ser explotable con aplicaciones capaces de comunicarse con la Actividad.

**El código de una actividad comienza con el método `onCreate`.**

### Subclase de Aplicación

Las aplicaciones de Android pueden definir una **subclase** de [Application](https://developer.android.com/reference/android/app/Application). Las aplicaciones pueden, pero no tienen que definir una subclase personalizada de Application. Si una aplicación de Android define una subclase de Application, **esta clase se instancia antes que cualquier otra clase en la aplicación**.

Si se define el método **`attachBaseContext`** en la subclase de Application, se llama primero, antes del método **`onCreate`**.

### Servicios

[Los servicios](https://developer.android.com/guide/components/services) **se ejecutan en segundo plano sin una interfaz de usuario**. Se utilizan para realizar **procesos de larga duración, incluso si el usuario comienza a usar una aplicación diferente**.

Hay una miríada de formas en las que pueden iniciarse y, por lo tanto, son un punto de entrada para las aplicaciones. La forma predeterminada en que un servicio puede iniciarse como punto de entrada a una aplicación es a través de **Intents**.

Cuando se llama al método **`startService`** para iniciar un Servicio, se ejecuta el método **`onStart`** en el Servicio. Se ejecutará indefinidamente hasta que se llame al método **`stopService`**. Si el servicio solo es necesario mientras el cliente está conectado, el cliente debería "vincularse" a él usando el método **`bindService`**.

Para un **servicio vinculado** (ver sección anterior), los datos se pasarán al método **`onBind`**.

Por ejemplo, un servicio podría reproducir música en segundo plano mientras el usuario está en una aplicación diferente, o podría recuperar datos a través de la red sin bloquear la interacción del usuario con una actividad.

Un **servicio puede ser exportado, lo que permite a otros procesos en el dispositivo iniciar el servicio**. Por defecto, los servicios no están exportados, pero se pueden configurar en el Manifiesto:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Receptores de difusión

Las difusiones se pueden considerar un sistema de mensajería y **los receptores de difusión son los oyentes**. Si una aplicación ha registrado un receptor para una difusión específica, el código en ese receptor se ejecuta cuando el sistema envía la difusión. Tenga en cuenta que en este caso **varias aplicaciones pueden recibir el mismo mensaje**.

Hay **2 formas** en que una aplicación puede **registrar un receptor**: en el **Manifiesto de la aplicación o registrado dinámicamente** en el código de la aplicación utilizando la llamada a la API **`registerReceiver`**. En el manifiesto, puede limitar las difusiones que acepta a través del **uso de permisos dentro del elemento receptor**. Cuando se define **dinámicamente**, puede **pasar el permiso al método `registerReceiver`**.

En ambos casos, para registrar el receptor, se establecen los **filtros de intención para el receptor**. Estos filtros de intención son las difusiones que deben activar el receptor.

Cuando se envían las difusiones específicas para las que se ha registrado el receptor, se ejecuta **`onReceive`** en la clase BroadcastReceiver.

Una aplicación puede registrar un receptor para el mensaje de batería baja, por ejemplo, y cambiar su comportamiento en función de esa información.

La difusión puede ser **asíncrona** (cada receptor la recibe) o **sincrónica** (la difusión se recibe de manera ordenada según la prioridad establecida para recibirla).

{% hint style="danger" %}
**Tenga en cuenta que cualquier aplicación puede establecerse como máxima prioridad para recibir una difusión.**
{% endhint %}

Para **examinar** el **código** implementado en un Receptor de difusión, es necesario buscar el método **`onReceive`** de la clase del receptor.\
Tenga en cuenta que las **Difusiones ordenadas pueden descartar la Intención recibida o incluso modificarla** utilizando uno de los métodos setter. Por lo tanto, los **receptores deben validar los datos**.

### Proveedor de contenido

Los Proveedores de contenido son la forma en que las **aplicaciones comparten datos estructurados**, como bases de datos relacionales. Por lo tanto, es muy importante utilizar **permisos** y establecer el nivel de protección adecuado para protegerlos.\
Los Proveedores de contenido pueden utilizar los atributos **`readPermission`** y **`writePermission`** para especificar qué permisos debe tener una aplicación. **Estos permisos tienen prioridad sobre el atributo de permiso**.\
Además, también pueden **permitir excepciones temporales** configurando el **`grantUriPermission`** como verdadero y luego configurando los parámetros apropiados en el elemento **`grant-uri-permission`** dentro del elemento proveedor dentro del archivo de manifiesto.

El **`grant-uri-permission`** tiene tres atributos: path, pathPrefix y pathPattern:

* **path**: Permite especificar la ruta completa a excluir
* **pathPrefix**: Permite especificar el inicio de la ruta
* **pathPattern**: Permite el uso de comodines y reemplazos simbólicos para obtener un control más granular.

Es **importante validar y sanear la entrada recibida** para evitar posibles vulnerabilidades como la inyección SQL.

**Características del Proveedor de contenido:**

* El componente Proveedor de contenido suministra datos de una aplicación a otras bajo demanda.
* Puede almacenar los datos en el sistema de archivos, una base de datos SQLite, en la web, o en cualquier otra ubicación de almacenamiento persistente a la que pueda acceder su aplicación.
* A través del proveedor de contenido, otras aplicaciones pueden consultar o incluso modificar los datos (si el proveedor de contenido lo permite).
* El Proveedor de contenido es útil en casos en los que una aplicación desea compartir datos con otra aplicación.
* Es muy similar a las bases de datos y tiene cuatro métodos.
  * insert()
  * update()
  * delete()
  * query()

**FileProvider**

Este es un tipo de Proveedor de contenido que **compartirá archivos** desde una carpeta. Puede declarar un proveedor de archivos de la siguiente manera:
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Toma nota del atributo **`android:exported`** porque si está **`true`** las aplicaciones externas podrán acceder a las carpetas compartidas.\
Ten en cuenta que la configuración `android:resource="@xml/filepaths"` indica que el archivo _res/xml/filepaths.xml_ contiene la configuración de **qué carpetas** va a **compartir** este **FileProvider**. Este es un ejemplo de cómo indicar que se comparta una carpeta en ese archivo:
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Compartir algo como **`path="."`** podría ser **peligroso** incluso si el proveedor no está exportado si hay otra vulnerabilidad en alguna parte del código que intenta acceder a este proveedor.\
Podrías **acceder** a una **imagen** dentro de esa carpeta con `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

El elemento `<paths>` puede tener varios hijos, cada uno especificando un directorio diferente para compartir. Además del elemento **`<files-path>`**, puedes usar el elemento **`<external-path>`** para compartir directorios en el **almacenamiento externo**, y el elemento **`<cache-path>`** para compartir directorios en tu **directorio de caché interno**.\
[Para obtener más información sobre los atributos específicos de los proveedores de archivos, ve aquí.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[Más información sobre FileProviders aquí](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

Los WebViews son efectivamente **navegadores web** integrados en las aplicaciones de Android.\
El contenido de los WebViews puede provenir de sitios remotos o de archivos incluidos en la aplicación.\
Los WebViews son **vulnerables a las mismas vulnerabilidades que afectan a cualquier navegador web**. Sin embargo, hay algunas **configuraciones** que pueden ser útiles para **limitar** la **superficie de ataque**.

Hay dos tipos de WebViews en Android:

* El **WebViewClient**, más adecuado para la representación de HTML simple. Esto no ejecutará la función de alerta JS. Por lo tanto, las pruebas de XSS que utilizan esa función serán inválidas.
* El **cliente WebChrome**, es un navegador Chrome.

Ten en cuenta que los **navegadores WebView no tienen acceso a las cookies del navegador nativo**.

Para cargar una URL o un archivo, es posible utilizar las funciones **`loadUrl`**, **`loadData`** o **`loadDataWithBaseURL`**. **Es importante acceder solo a URLs sanitizadas.**\
La seguridad de WebView se puede configurar a través del objeto **`WebSettings`**.\
Por ejemplo, la ejecución de código JS se puede deshabilitar utilizando el método **`setJavaScriptEnabled`** con el valor **`false`**. Esto **eliminará** la posibilidad de un **XSS** y otras vulnerabilidades relacionadas con JS.

La funcionalidad de JavaScript "**Bridge**" **inyecta objetos Java en un WebView haciéndolos accesibles para JS**. A partir de Android 4.2, los métodos deben estar anotados con **`@JavascriptInterface`** para ser accesibles desde JavaScript.

Si se pasa **`true`** a **`setAllowContentAccess`**, los **WebViews podrán acceder a los Proveedores de Contenido** a través del esquema **`content://`**. Esto obviamente plantea un riesgo de seguridad. Ten en cuenta que si se otorga este acceso, es muy importante **asegurarse** de que la URL de **`content://`** sea **segura**.

Por defecto, los archivos locales pueden ser accedidos por los WebViews a través de URLs file://, pero hay varias formas de evitar este comportamiento:

* Pasar **`false`** a **`setAllowFileAccess`**, evita el acceso al sistema de archivos con la excepción de los activos a través de `file:///android_asset` _y_ `file:///android_res`. Estas rutas deben usarse solo para datos no sensibles (como imágenes) por lo que esto debería ser seguro.
* El método **`setAllowFileAccess`** indica si una ruta de una URL `file://` debería poder acceder al contenido de otras URLs de esquema de archivo.
* El método **`setAllowUniversalAccessFromFileURLs`** indica si una ruta de una URL `file://` debería poder acceder al contenido desde cualquier origen.

## Otros componentes de la aplicación

### **Firma de la aplicación**

* Android requiere que **todas las aplicaciones estén firmadas digitalmente con un certificado** antes de que puedan ser instaladas. Android utiliza este certificado para identificar al autor de una aplicación.
* Para ejecutar la aplicación en el dispositivo, debe estar firmada. Cuando la aplicación se instala en un dispositivo, el **gestor de paquetes verifica** si la aplicación ha sido correctamente firmada con el certificado en el archivo apk o no.
* La aplicación puede ser auto-firmada o firmada a través de una CA.
* La firma de la aplicación garantiza que una aplicación no pueda acceder a ninguna otra aplicación excepto a través de IPC bien definidos y también que se pase sin modificaciones al dispositivo.

### **Verificación de la aplicación**

* Android 4.2 y versiones posteriores admiten la verificación de aplicaciones. Los usuarios pueden optar por habilitar "Verificar aplicaciones" y hacer que las aplicaciones sean evaluadas por un verificador de aplicaciones antes de la instalación.
* La verificación de aplicaciones puede alertar al usuario si intentan instalar una aplicación que podría ser dañina; si una aplicación es especialmente mala, puede bloquear la instalación.

## Gestión de dispositivos móviles

MDM o Gestión de Dispositivos Móviles son suites de software que se utilizan para **garantizar requisitos de control y seguridad** sobre dispositivos móviles. Estas suites utilizan las funciones denominadas API de Administración de Dispositivos y requieren que se instale una aplicación de Android.

Generalmente, las soluciones MDM realizan funciones como hacer cumplir políticas de contraseñas, forzar el cifrado de almacenamiento y habilitar el borrado remoto de datos del dispositivo.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra las vulnerabilidades que más importan para que puedas solucionarlas más rápido. Intruder rastrea tu superficie de ataque, ejecuta escaneos proactivos de amenazas, encuentra problemas en toda tu pila tecnológica, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pruébalo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>Aprende a hackear AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
