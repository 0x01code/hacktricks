# Bases des Applications Android

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

**Groupe de S√©curit√© Try Hard**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Mod√®le de S√©curit√© Android

**Il y a deux couches :**

* Le **syst√®me d'exploitation (OS)**, qui maintient les applications install√©es isol√©es les unes des autres.
* L'**application elle-m√™me**, qui permet aux d√©veloppeurs de **exposer certaines fonctionnalit√©s** et de configurer les capacit√©s de l'application.

### S√©paration des UID

**Chaque application se voit attribuer un ID utilisateur sp√©cifique**. Cela est fait lors de l'installation de l'application afin que **l'application puisse interagir uniquement avec les fichiers appartenant √† son ID utilisateur ou des fichiers partag√©s**. Par cons√©quent, seule l'application elle-m√™me, certains composants du syst√®me d'exploitation et l'utilisateur root peuvent acc√©der aux donn√©es des applications.

### Partage des UID

**Deux applications peuvent √™tre configur√©es pour utiliser le m√™me UID**. Cela peut √™tre utile pour partager des informations, mais si l'une d'elles est compromise, les donn√©es des deux applications seront compromises. C'est pourquoi ce comportement est **d√©conseill√©**.\
**Pour partager le m√™me UID, les applications doivent d√©finir la m√™me valeur `android:sharedUserId`** dans leurs manifestes.

### Isolation

Le **bac √† sable des applications Android** permet d'ex√©cuter **chaque application** en tant que **processus s√©par√© sous un ID utilisateur distinct**. Chaque processus a sa propre machine virtuelle, de sorte que le code d'une application s'ex√©cute de mani√®re isol√©e par rapport aux autres applications.\
√Ä partir d'Android 5.0 (L), **SELinux** est appliqu√©. Fondamentalement, SELinux a refus√© toutes les interactions entre les processus, puis a cr√©√© des politiques pour **autoriser uniquement les interactions attendues entre eux**.

### Autorisations

Lorsque vous installez une **application et qu'elle demande des autorisations**, l'application demande les autorisations configur√©es dans les √©l√©ments **`uses-permission`** dans le fichier **AndroidManifest.xml**. L'√©l√©ment **uses-permission** indique le nom de l'autorisation demand√©e dans l'attribut **name**. Il a √©galement l'attribut **maxSdkVersion** qui arr√™te de demander des autorisations sur des versions sup√©rieures √† celle sp√©cifi√©e.\
Notez que les applications Android n'ont pas besoin de demander toutes les autorisations au d√©but, elles peuvent √©galement **demander des autorisations dynamiquement** mais toutes les autorisations doivent √™tre **d√©clar√©es** dans le **manifeste**.

Lorsqu'une application expose des fonctionnalit√©s, elle peut limiter l'**acc√®s uniquement aux applications ayant une autorisation sp√©cifi√©e**.\
Un √©l√©ment d'autorisation a trois attributs :

* Le **nom** de l'autorisation
* L'attribut **permission-group**, qui permet de regrouper les autorisations connexes.
* Le **niveau de protection** qui indique comment les autorisations sont accord√©es. Il existe quatre types :
* **Normal** : Utilis√© lorsqu'il n'y a **aucune menace connue** pour l'application. L'utilisateur n'est **pas tenu d'approuver**.
* **Dangereux** : Indique que l'autorisation accorde √† l'application demandeur un **acc√®s √©lev√©**. **Les utilisateurs sont invit√©s √† les approuver**.
* **Signature** : Seules les **applications sign√©es par le m√™me certificat que celui** exportant le composant peuvent se voir accorder l'autorisation. Il s'agit du type de protection le plus fort.
* **SignatureOrSystem** : Seules les **applications sign√©es par le m√™me certificat que celui** exportant le composant ou les **applications s'ex√©cutant avec un acc√®s de niveau syst√®me** peuvent se voir accorder des autorisations.

## Applications Pr√©-Install√©es

Ces applications se trouvent g√©n√©ralement dans les r√©pertoires **`/system/app`** ou **`/system/priv-app`** et certaines d'entre elles sont **optimis√©es** (vous ne trouverez peut-√™tre m√™me pas le fichier `classes.dex`). Ces applications valent la peine d'√™tre v√©rifi√©es car parfois elles **fonctionnent avec trop de permissions** (en tant que root).

* Celles livr√©es avec le **ROM AOSP** (Android OpenSource Project)
* Ajout√©es par le **fabricant de l'appareil**
* Ajout√©es par le **fournisseur de t√©l√©phonie mobile** (si achet√© chez eux)

## Rootage

Pour obtenir un acc√®s root sur un appareil Android physique, vous devez g√©n√©ralement **exploiter** 1 ou 2 **vuln√©rabilit√©s** qui sont g√©n√©ralement **sp√©cifiques** au **dispositif** et √† la **version**.\
Une fois l'exploit r√©ussi, g√©n√©ralement le binaire Linux `su` est copi√© dans un emplacement sp√©cifi√© dans la variable d'environnement PATH de l'utilisateur comme `/system/xbin`.

Une fois le binaire su configur√©, une autre application Android est utilis√©e pour interagir avec le binaire `su` et **traiter les demandes d'acc√®s root** comme **Superuser** et **SuperSU** (disponibles dans le Google Play Store).

{% hint style="danger" %}
Notez que le processus de rootage est tr√®s dangereux et peut endommager gravement l'appareil
{% endhint %}

### ROMs

Il est possible de **remplacer le syst√®me d'exploitation en installant un firmware personnalis√©**. En faisant cela, il est possible d'√©tendre l'utilit√© d'un ancien appareil, contourner les restrictions logicielles ou acc√©der au dernier code Android.\
**OmniROM** et **LineageOS** sont deux des firmwares les plus populaires √† utiliser.

Notez que **il n'est pas toujours n√©cessaire de rooter l'appareil** pour installer un firmware personnalis√©. **Certains fabricants permettent** le d√©verrouillage de leurs chargeurs d'amor√ßage de mani√®re bien document√©e et s√©curis√©e.

### Implications

Une fois qu'un appareil est root√©, n'importe quelle application pourrait demander l'acc√®s en tant que root. Si une application malveillante l'obtient, elle pourra acc√©der √† presque tout et endommager le t√©l√©phone.

## Fondamentaux des Applications Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Le format des applications Android est appel√© _format de fichier APK_. Il s'agit essentiellement d'un **fichier ZIP** (en renommant l'extension de fichier en .zip, le contenu peut √™tre extrait et visualis√©).
- Contenu de l'APK (non exhaustif)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc : contient des ressources pr√©compil√©es, comme du XML binaire.
- res/xml/files\_paths.xml
- META-INF/
- C'est l√† que se trouve le Certificat !
- **classes.dex**
- Contient le bytecode Dalvik, repr√©sentant le code Java (ou Kotlin) compil√© que l'application ex√©cute par d√©faut.
- lib/
- Contient des biblioth√®ques natives, s√©par√©es par architecture CPU dans des sous-r√©pertoires.
- `armeabi` : code pour les processeurs bas√©s sur ARM
- `armeabi-v7a` : code pour les processeurs bas√©s sur ARMv7 et sup√©rieurs
- `x86` : code pour les processeurs X86
- `mips` : code pour les processeurs MIPS uniquement
- assets/
- Stocke des fichiers divers n√©cessaires √† l'application, potentiellement y compris des biblioth√®ques natives suppl√©mentaires ou des fichiers DEX, parfois utilis√©s par les auteurs de logiciels malveillants pour dissimuler du code suppl√©mentaire.
- res/
- Contient des ressources qui ne sont pas compil√©es dans resources.arsc
### **Dalvik & Smali**

En d√©veloppement Android, **Java ou Kotlin** est utilis√© pour cr√©er des applications. Au lieu d'utiliser le JVM comme dans les applications de bureau, Android compile ce code en **code bytecode Dalvik ex√©cutable (DEX)**. Auparavant, la machine virtuelle Dalvik g√©rait ce bytecode, mais maintenant, l'Android Runtime (ART) prend le relais dans les nouvelles versions d'Android.

Pour l'ing√©nierie inverse, **Smali** devient crucial. C'est la version lisible par l'homme du bytecode DEX, agissant comme un langage d'assemblage en traduisant le code source en instructions bytecode. Smali et baksmali font r√©f√©rence aux outils d'assemblage et de d√©sassemblage dans ce contexte.

## Intentions

Les Intentions sont le principal moyen par lequel les applications Android communiquent entre leurs composants ou avec d'autres applications. Ces objets de message peuvent √©galement transporter des donn√©es entre les applications ou les composants, de mani√®re similaire √† la fa√ßon dont les requ√™tes GET/POST sont utilis√©es dans les communications HTTP.

Ainsi, une Intention est essentiellement un **message qui est pass√© entre les composants**. Les Intentions **peuvent √™tre dirig√©es** vers des composants ou des applications sp√©cifiques, **ou peuvent √™tre envoy√©es sans destinataire sp√©cifique**.\
Pour simplifier, une Intention peut √™tre utilis√©e pour :

* D√©marrer une Activit√©, ouvrir g√©n√©ralement une interface utilisateur pour une application
* Comme diffusions pour informer le syst√®me et les applications des changements
* Pour d√©marrer, arr√™ter et communiquer avec un service en arri√®re-plan
* Acc√©der aux donn√©es via des ContentProviders
* Comme rappels pour g√©rer des √©v√©nements

Si elles sont vuln√©rables, les **Intentions peuvent √™tre utilis√©es pour effectuer diverses attaques**.

### Filtre d'Intention

Les **Filtres d'Intention** d√©finissent **comment une activit√©, un service ou un r√©cepteur de diffusion peuvent interagir avec diff√©rents types d'Intentions**. Essentiellement, ils d√©crivent les capacit√©s de ces composants, comme les actions qu'ils peuvent effectuer ou les types de diffusions qu'ils peuvent traiter. Le principal endroit pour d√©clarer ces filtres est dans le fichier **AndroidManifest.xml**, bien que pour les r√©cepteurs de diffusion, les coder soit √©galement une option.

Les Filtres d'Intention sont compos√©s de cat√©gories, d'actions et de filtres de donn√©es, avec la possibilit√© d'inclure des m√©tadonn√©es suppl√©mentaires. Cette configuration permet aux composants de g√©rer des Intentions sp√©cifiques qui correspondent aux crit√®res d√©clar√©s.

Un aspect critique des composants Android (activit√©s/services/fournisseurs de contenu/r√©cepteurs de diffusion) est leur visibilit√© ou leur **statut public**. Un composant est consid√©r√© comme public et peut interagir avec d'autres applications s'il est **`export√©`** avec une valeur de **`true`** ou si un Filtre d'Intention est d√©clar√© pour lui dans le manifeste. Cependant, les d√©veloppeurs peuvent explicitement garder ces composants priv√©s pour s'assurer qu'ils n'interagissent pas avec d'autres applications de mani√®re non intentionnelle. Cela est r√©alis√© en d√©finissant l'attribut **`exported`** sur **`false`** dans leurs d√©finitions de manifeste.

De plus, les d√©veloppeurs ont la possibilit√© de s√©curiser davantage l'acc√®s √† ces composants en exigeant des autorisations sp√©cifiques. L'attribut **`permission`** peut √™tre d√©fini pour obliger uniquement les applications disposant de l'autorisation d√©sign√©e √† acc√©der au composant, ajoutant une couche suppl√©mentaire de s√©curit√© et de contr√¥le sur qui peut interagir avec lui.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Intentions implicites

Les intentions sont cr√©√©es de mani√®re programmatique en utilisant un constructeur Intent :
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
L'**Action** de l'intent pr√©c√©demment d√©clar√© est **ACTION\_SEND** et l'**Extra** est un **Uri** mailto (l'Extra est l'information suppl√©mentaire que l'intent attend).

Cet intent doit √™tre d√©clar√© dans le manifeste comme dans l'exemple suivant:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Un intent-filter doit correspondre √† l'**action**, aux **donn√©es** et √† la **cat√©gorie** pour recevoir un message.

Le processus de "r√©solution de l'intent" d√©termine quelle application doit recevoir chaque message. Ce processus prend en compte l'attribut de **priorit√©**, qui peut √™tre d√©fini dans la d√©claration de l'**intent-filter**, et **celui avec la priorit√© la plus √©lev√©e sera s√©lectionn√©**. Cette priorit√© peut √™tre d√©finie entre -1000 et 1000 et les applications peuvent utiliser la valeur `SYSTEM_HIGH_PRIORITY`. En cas de **conflit**, une fen√™tre "choisir" appara√Æt pour que l'**utilisateur puisse d√©cider**.

### Intents explicites

Un intent explicite sp√©cifie le nom de la classe qu'il cible:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Dans d'autres applications, pour acc√©der √† l'intention pr√©c√©demment d√©clar√©e, vous pouvez utiliser :
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Intentions en attente

Ces intentions permettent √† d'autres applications de **prendre des actions au nom de votre application**, en utilisant l'identit√© et les autorisations de votre application. Pour construire une Intention en attente, il faut **sp√©cifier une intention et l'action √† effectuer**. Si l'intention **d√©clar√©e n'est pas explicite** (ne d√©clare pas quelle intention peut l'appeler), une **application malveillante pourrait effectuer l'action d√©clar√©e** au nom de l'application victime. De plus, **si une action n'est pas sp√©cifi√©e**, l'application malveillante pourra effectuer **n'importe quelle action au nom de la victime**.

### Intentions de diffusion

Contrairement aux intentions pr√©c√©dentes, qui ne sont re√ßues que par une seule application, les intentions de diffusion **peuvent √™tre re√ßues par plusieurs applications**. Cependant, √† partir de la version API 14, il est **possible de sp√©cifier l'application qui doit recevoir** le message en utilisant Intent.setPackage.

Il est √©galement possible de **sp√©cifier une autorisation lors de l'envoi de la diffusion**. L'application r√©ceptrice devra disposer de cette autorisation.

Il existe **deux types** de diffusions : **Normales** (asynchrones) et **Ordonn√©es** (synchrones). L'**ordre** est bas√© sur la **priorit√© configur√©e dans l'√©l√©ment r√©cepteur**. **Chaque application peut traiter, relayer ou abandonner la diffusion**.

Il est possible d'**envoyer** une **diffusion** en utilisant la fonction `sendBroadcast(intent, receiverPermission)` de la classe `Context`.\
Vous pourriez √©galement utiliser la fonction **`sendBroadcast`** du **`LocalBroadcastManager`** pour garantir que le **message ne quitte jamais l'application**. En utilisant cela, vous n'aurez m√™me pas besoin d'exporter un composant r√©cepteur.

### Diffusions persistantes

Ce type de diffusions **peut √™tre consult√© longtemps apr√®s leur envoi**.\
Ils ont √©t√© obsol√®tes √† partir du niveau API 21 et il est recommand√© de **ne pas les utiliser**.\
**Ils permettent √† n'importe quelle application de renifler les donn√©es, mais aussi de les modifier**.

Si vous trouvez des fonctions contenant le mot "persistant" comme **`sendStickyBroadcast`** ou **`sendStickyBroadcastAsUser`**, **v√©rifiez l'impact et essayez de les supprimer**.

## Liens profonds / Sch√©mas d'URL

Dans les applications Android, les **liens profonds** sont utilis√©s pour initier une action (Intention) directement via une URL. Cela se fait en d√©clarant un **sch√©ma d'URL sp√©cifique** au sein d'une activit√©. Lorsqu'un appareil Android tente d'**acc√©der √† une URL avec ce sch√©ma**, l'activit√© sp√©cifi√©e dans l'application est lanc√©e.

Le sch√©ma doit √™tre d√©clar√© dans le fichier **`AndroidManifest.xml`** :
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Le sch√©ma de l'exemple pr√©c√©dent est `exampleapp://` (notez √©galement la **`cat√©gorie BROWSABLE`**)

Ensuite, dans le champ des donn√©es, vous pouvez sp√©cifier l'**h√¥te** et le **chemin** :
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Pour y acc√©der depuis un site web, il est possible de d√©finir un lien comme suit :
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Pour trouver le **code qui sera ex√©cut√© dans l'application**, allez √† l'activit√© appel√©e par le lien profond et recherchez la fonction **`onNewIntent`**.

Apprenez comment [appeler des liens profonds sans utiliser de pages HTML](./#exploiting-schemes-deep-links).

## AIDL - Langage de d√©finition d'interface Android

Le **Langage de D√©finition d'Interface Android (AIDL)** est con√ßu pour faciliter la communication entre le client et le service dans les applications Android via la **communication interprocessus** (IPC). √âtant donn√© qu'il n'est pas permis d'acc√©der directement √† la m√©moire d'un autre processus sur Android, AIDL simplifie le processus en marshalling des objets dans un format compris par le syst√®me d'exploitation, facilitant ainsi la communication entre diff√©rents processus.

### Concepts Cl√©s

- **Services li√©s**: Ces services utilisent AIDL pour l'IPC, permettant aux activit√©s ou composants de se lier √† un service, de faire des requ√™tes et de recevoir des r√©ponses. La m√©thode `onBind` dans la classe du service est essentielle pour initier l'interaction, en faisant de cette zone un domaine vital pour l'examen de la s√©curit√© √† la recherche de vuln√©rabilit√©s.

- **Messager**: Agissant en tant que service li√©, Messenger facilite l'IPC en se concentrant sur le traitement des donn√©es via la m√©thode `onBind`. Il est essentiel d'inspecter cette m√©thode de pr√®s pour tout traitement de donn√©es non s√©curis√© ou l'ex√©cution de fonctions sensibles.

- **Binder**: Bien que l'utilisation directe de la classe Binder soit moins courante en raison de l'abstraction d'AIDL, il est b√©n√©fique de comprendre que Binder agit comme un pilote au niveau du noyau facilitant le transfert de donn√©es entre les espaces m√©moire de diff√©rents processus. Pour une meilleure compr√©hension, une ressource est disponible sur [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Composants

Ceux-ci incluent: **Activit√©s, Services, R√©cepteurs de diffusion et Fournisseurs.**

### Activit√© de lancement et autres activit√©s

Dans les applications Android, les **activit√©s** sont comme des √©crans, affichant diff√©rentes parties de l'interface utilisateur de l'application. Une application peut avoir de nombreuses activit√©s, chacune pr√©sentant un √©cran unique √† l'utilisateur.

L'**activit√© de lancement** est la passerelle principale vers une application, lanc√©e lorsque vous appuyez sur l'ic√¥ne de l'application. Elle est d√©finie dans le fichier manifeste de l'application avec des intentions MAIN et LAUNCHER sp√©cifiques:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Pas toutes les applications ont besoin d'une activit√© de lancement, en particulier celles sans interface utilisateur, comme les services en arri√®re-plan.

Les activit√©s peuvent √™tre rendues disponibles √† d'autres applications ou processus en les marquant comme "export√©es" dans le manifeste. Ce param√®tre permet √† d'autres applications de d√©marrer cette activit√© :
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Cependant, acc√©der √† une activit√© depuis une autre application n'est pas toujours un risque de s√©curit√©. Le probl√®me survient si des donn√©es sensibles sont partag√©es de mani√®re inappropri√©e, ce qui pourrait entra√Æner des fuites d'informations.

Le cycle de vie d'une activit√© **commence avec la m√©thode onCreate**, configurant l'interface utilisateur et pr√©parant l'activit√© pour l'interaction avec l'utilisateur.

### Sous-classe d'application

Dans le d√©veloppement Android, une application a la possibilit√© de cr√©er une **sous-classe** de la [classe Application](https://developer.android.com/reference/android/app/Application), bien que cela ne soit pas obligatoire. Lorsqu'une telle sous-classe est d√©finie, elle devient la premi√®re classe √† √™tre instanci√©e dans l'application. La m√©thode **`attachBaseContext`**, si elle est impl√©ment√©e dans cette sous-classe, est ex√©cut√©e avant la m√©thode **`onCreate`**. Cette configuration permet une initialisation pr√©coce avant le d√©marrage du reste de l'application.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Services

[Les services](https://developer.android.com/guide/components/services) sont des **op√©rations en arri√®re-plan** capables d'ex√©cuter des t√¢ches sans interface utilisateur. Ces t√¢ches peuvent continuer √† s'ex√©cuter m√™me lorsque les utilisateurs passent √† diff√©rentes applications, ce qui rend les services cruciaux pour les **op√©rations de longue dur√©e**.

Les services sont polyvalents ; ils peuvent √™tre initi√©s de diff√©rentes mani√®res, les **Intents** √©tant la m√©thode principale pour les lancer en tant que point d'entr√©e d'une application. Une fois qu'un service est d√©marr√© en utilisant la m√©thode `startService`, sa m√©thode `onStart` entre en action et continue √† s'ex√©cuter jusqu'√† ce que la m√©thode `stopService` soit explicitement appel√©e. Alternativement, si le r√¥le d'un service d√©pend d'une connexion client active, la m√©thode `bindService` est utilis√©e pour lier le client au service, en engageant la m√©thode `onBind` pour le passage de donn√©es.

Une application int√©ressante des services comprend la lecture de musique en arri√®re-plan ou la r√©cup√©ration de donn√©es r√©seau sans entraver l'interaction de l'utilisateur avec une application. De plus, les services peuvent √™tre rendus accessibles √† d'autres processus sur le m√™me appareil gr√¢ce √† l'**exportation**. Ce n'est pas le comportement par d√©faut et n√©cessite une configuration explicite dans le fichier Android Manifest :
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### R√©cepteurs de diffusion

Les **r√©cepteurs de diffusion** agissent comme des √©couteurs dans un syst√®me de messagerie, permettant √† plusieurs applications de r√©pondre aux m√™mes messages du syst√®me. Une application peut **enregistrer un r√©cepteur** de **deux mani√®res principales** : via le **Manifest** de l'application ou **dynamiquement** dans le code de l'application via l'API **`registerReceiver`**. Dans le Manifest, les diffusions sont filtr√©es avec des autorisations, tandis que les r√©cepteurs enregistr√©s dynamiquement peuvent √©galement sp√©cifier des autorisations lors de l'enregistrement.

Les **filtres d'intention** sont cruciaux dans les deux m√©thodes d'enregistrement, d√©terminant quelles diffusions d√©clenchent le r√©cepteur. Une fois qu'une diffusion correspondante est envoy√©e, la m√©thode **`onReceive`** du r√©cepteur est invoqu√©e, permettant √† l'application de r√©agir en cons√©quence, comme ajuster le comportement en r√©ponse √† une alerte de batterie faible.

Les diffusions peuvent √™tre soit **asynchrones**, atteignant tous les r√©cepteurs sans ordre, soit **synchrones**, o√π les r√©cepteurs re√ßoivent la diffusion en fonction des priorit√©s d√©finies. Cependant, il est important de noter le risque potentiel pour la s√©curit√©, car toute application peut se donner la priorit√© pour intercepter une diffusion.

Pour comprendre la fonctionnalit√© d'un r√©cepteur, recherchez la m√©thode **`onReceive`** √† l'int√©rieur de sa classe. Le code de cette m√©thode peut manipuler l'Intention re√ßue, soulignant la n√©cessit√© de la validation des donn√©es par les r√©cepteurs, en particulier dans les **Diffusions ordonn√©es**, qui peuvent modifier ou supprimer l'Intention.

### Fournisseur de contenu

Les **fournisseurs de contenu** sont essentiels pour **partager des donn√©es structur√©es** entre les applications, mettant en avant l'importance de mettre en ≈ìuvre des **autorisations** pour garantir la s√©curit√© des donn√©es. Ils permettent aux applications d'acc√©der √† des donn√©es provenant de diff√©rentes sources, y compris des bases de donn√©es, des syst√®mes de fichiers ou le web. Des autorisations sp√©cifiques, telles que **`readPermission`** et **`writePermission`**, sont cruciales pour contr√¥ler l'acc√®s. De plus, un acc√®s temporaire peut √™tre accord√© via les param√®tres **`grantUriPermission`** dans le manifest de l'application, en exploitant des attributs tels que `path`, `pathPrefix` et `pathPattern` pour un contr√¥le d'acc√®s d√©taill√©.

La validation des entr√©es est primordiale pour pr√©venir les vuln√©rabilit√©s, telles que les injections SQL. Les fournisseurs de contenu prennent en charge des op√©rations de base : `insert()`, `update()`, `delete()` et `query()`, facilitant la manipulation et le partage de donn√©es entre les applications.

**FileProvider**, un Fournisseur de contenu sp√©cialis√©, se concentre sur le partage s√©curis√© de fichiers. Il est d√©fini dans le manifest de l'application avec des attributs sp√©cifiques pour contr√¥ler l'acc√®s aux dossiers, indiqu√©s par `android:exported` et `android:resource` pointant vers des configurations de dossiers. Il est conseill√© de faire preuve de prudence lors du partage de r√©pertoires pour √©viter d'exposer involontairement des donn√©es sensibles.

D√©claration de manifeste exemple pour FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Et un exemple de sp√©cification des dossiers partag√©s dans `filepaths.xml` :
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Pour plus d'informations, consultez :
- [D√©veloppeurs Android : Fournisseurs de contenu](https://developer.android.com/guide/topics/providers/content-providers)
- [D√©veloppeurs Android : FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

Les WebViews sont comme des **mini navigateurs web** √† l'int√©rieur des applications Android, affichant du contenu soit depuis le web, soit depuis des fichiers locaux. Ils sont confront√©s √† des risques similaires √† ceux des navigateurs classiques, mais il existe des moyens de **r√©duire ces risques** gr√¢ce √† des **param√®tres sp√©cifiques**.

Android propose deux principaux types de WebView :

- **WebViewClient** est id√©al pour le HTML de base mais ne prend pas en charge la fonction d'alerte JavaScript, ce qui affecte la mani√®re dont les attaques XSS peuvent √™tre test√©es.
- **WebChromeClient** se comporte davantage comme l'exp√©rience compl√®te du navigateur Chrome.

Un point cl√© est que les navigateurs WebView ne **partagent pas les cookies** avec le navigateur principal de l'appareil.

Pour le chargement du contenu, des m√©thodes telles que ````loadUrl````, ````loadData````, et ````loadDataWithBaseURL```` sont disponibles. Il est crucial de s'assurer que ces URL ou fichiers sont **s√ªrs √† utiliser**. Les param√®tres de s√©curit√© peuvent √™tre g√©r√©s via la classe ````WebSettings````. Par exemple, d√©sactiver JavaScript avec ````setJavaScriptEnabled(false)```` peut pr√©venir les attaques XSS.

Le "Bridge" JavaScript permet aux objets Java d'interagir avec JavaScript, exigeant que les m√©thodes soient marqu√©es avec ````@JavascriptInterface```` pour la s√©curit√© √† partir d'Android 4.2.

Autoriser l'acc√®s au contenu (````setAllowContentAccess(true)````) permet aux WebViews d'acc√©der aux Fournisseurs de contenu, ce qui pourrait repr√©senter un risque √† moins que les URL du contenu ne soient v√©rifi√©es comme s√©curis√©es.

Pour contr√¥ler l'acc√®s aux fichiers :
- D√©sactiver l'acc√®s aux fichiers (````setAllowFileAccess(false)````) limite l'acc√®s au syst√®me de fichiers, avec des exceptions pour certains actifs, en veillant √† ce qu'ils ne soient utilis√©s que pour du contenu non sensible.

## Autres composants d'application et gestion des appareils mobiles

### **Signature num√©rique des applications**

- La **signature num√©rique** est indispensable pour les applications Android, garantissant qu'elles sont **authentiquement authentifi√©es** avant l'installation. Ce processus utilise un certificat pour l'identification de l'application et doit √™tre v√©rifi√© par le gestionnaire de packages de l'appareil lors de l'installation. Les applications peuvent √™tre **auto-sign√©es ou certifi√©es par une AC externe**, se prot√©geant ainsi contre les acc√®s non autoris√©s et garantissant que l'application reste intacte lors de sa livraison √† l'appareil.

### **V√©rification de l'application pour une s√©curit√© renforc√©e**

- √Ä partir d'**Android 4.2**, une fonctionnalit√© appel√©e **V√©rifier les applications** permet aux utilisateurs de v√©rifier la s√©curit√© des applications avant l'installation. Ce **processus de v√©rification** peut avertir les utilisateurs contre les applications potentiellement dangereuses, voire emp√™cher l'installation de celles particuli√®rement malveillantes, renfor√ßant la s√©curit√© des utilisateurs.

### **Gestion des appareils mobiles (MDM)**

- Les **solutions MDM** fournissent une **surveillance et une s√©curit√©** pour les appareils mobiles via l'**API d'administration des appareils**. Elles n√©cessitent l'installation d'une application Android pour g√©rer et s√©curiser efficacement les appareils mobiles. Les fonctions cl√©s incluent **l'application de politiques de mot de passe**, **l'obligation de chiffrement du stockage**, et **l'autorisation de l'effacement des donn√©es √† distance**, assurant un contr√¥le et une s√©curit√© complets sur les appareils mobiles.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**Groupe de s√©curit√© Try Hard**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
