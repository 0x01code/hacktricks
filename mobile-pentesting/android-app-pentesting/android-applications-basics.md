# Βασικά για Εφαρμογές Android

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** Ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Βρείτε ευπάθειες που έχουν μεγαλύτερη σημασία, ώστε να μπορείτε να τις διορθώσετε πιο γρήγορα. Ο Intruder παρακολουθεί την επιθετική επιφάνεια σας, εκτελεί προληπτικές απειλητικές αναζητήσεις, εντοπίζει προβλήματα σε ολόκληρο το τεχνολογικό σας στοίβα, από APIs έως web εφαρμογές και συστήματα στο cloud. [**Δοκιμάστε το δωρεάν**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) σήμερα.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Μοντέλο Ασφάλειας Android

**Υπάρχουν δύο επίπεδα:**

* Το **Λειτουργικό Σύστημα**, το οποίο διατηρεί τις εγκατεστημένες εφαρμογές απομονωμένες μεταξύ τους.
* Η **ίδια η εφαρμογή**, η οποία επιτρέπει στους προγραμματιστές να **αποκαλύπτουν ορισμένες λειτουργίες** και να διαμορφώνουν τις δυνατότητες της εφαρμογής.

### Διαχωρισμός UID

**Κάθε εφαρμογή αντιστοιχίζεται ένα συγκεκριμένο User ID**. Αυτό γίνεται κατά την εγκατάσταση της εφαρμογής, έτσι ώστε η εφαρμογή να μπορεί να αλληλεπιδρά μόνο με αρχεία που ανήκουν στο User ID της ή με κοινόχρηστα αρχεία. Επομένως, μόνο η ίδια η εφαρμογή, ορισμένα στοιχεία του Λειτουργικού Συστήματος και ο ριζικός χρήστης μπορούν να έχουν πρόσβαση στα δεδομένα των εφαρμογών.

### Κοινή χρήση UID

**Δύο εφαρμογές μπορούν να ρυθμιστούν να χρησιμοποιούν το ίδιο UID**. Αυτό μπορεί να είναι χρήσιμο για την κοινή χρήση πληροφοριών, αλλά αν μία από αυτές διαρρεύσει, τα δεδομένα και των δύο εφαρμογών θα διαρρεύσουν. Γι' αυτό το λόγο αυτή η συμπεριφορά είναι **αποθαρρυντική**.\
**Για να μοιραστούν το ίδιο UID, οι εφαρμογές πρέπει να ορίσουν την ίδια τιμή `android:sharedUserId` στα αρχεία τους.**

### Απομόνωση

Το **Android Application Sandbox** επιτρέπει την εκτέλεση **κάθε εφαρμογής** ως **ξεχωριστή διεργασία με ξεχωριστό User ID**. Κάθε διεργασία έχει τη δική της εικονική μηχανή, έτσι το κώδικας μιας εφαρμογής εκτελείται απομονωμένος από άλλες εφαρμογές.\
Από το Android 5.0(L)
### **Dalvik & Smali**

Στην ανάπτυξη Android, χρησιμοποιείται **Java ή Kotlin** για τη δημιουργία εφαρμογών. Αντί να χρησιμοποιεί το JVM όπως στις εφαρμογές επιφάνειας εργασίας, το Android μεταγλωττίζει αυτόν τον κώδικα σε **Dalvik Executable (DEX) bytecode**. Παλαιότερα, η εικονική μηχανή Dalvik χειριζόταν αυτόν τον bytecode, αλλά τώρα, η Android Runtime (ART) αναλαμβάνει σε νεότερες εκδόσεις του Android.

Για την αντιστροφή μηχανική, το **Smali** γίνεται κρίσιμο. Είναι η αναγνώσιμη αντιστοίχιση του DEX bytecode, λειτουργώντας ως γλώσσα συναρμολόγησης μεταφράζοντας τον πηγαίο κώδικα σε εντολές bytecode. Το Smali και το baksmali αναφέρονται στα εργαλεία συναρμολόγησης και αποσυναρμολόγησης σε αυτό το πλαίσιο.

***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Βρείτε ευπάθειες που είναι πιο σημαντικές, ώστε να μπορείτε να τις διορθώσετε πιο γρήγορα. Το Intruder παρακολουθεί την επιθετική επιφάνεια σας, εκτελεί προληπτικές απειλητικές αναζητήσεις, εντοπίζει προβλήματα σε ολόκληρο το τεχνολογικό σας στοίβα, από APIs έως ιστοσελίδες και συστήματα στον νέφος. [**Δοκιμάστε το δωρεάν**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) σήμερα.

***

## Intents

Τα Intents είναι ο κύριος τρόπος με τον οποίο οι εφαρμογές Android επικοινωνούν μεταξύ των στοιχείων τους ή με άλλες εφαρμογές. Αυτά τα αντικείμενα μηνυμάτων μπορούν επίσης να μεταφέρουν δεδομένα μεταξύ εφαρμογών ή στοιχείων, παρόμοια με τον τρόπο που χρησιμοποιούνται οι αιτήσεις GET/POST στις επικοινωνίες HTTP.

Έτσι, ένα Intent είναι βασικά ένα **μήνυμα που περνάει μεταξύ στοιχείων**. Τα Intents **μπορούν να κατευθυνθούν** σε συγκεκριμένα στοιχεία ή εφαρμογές, **ή μπορούν να σταλούν χωρίς συγκεκριμένο παραλήπτη**.\
Για να είναι απλό, το Intent μπορεί να χρησιμοποιηθεί:

* Για να ξεκινήσει μια δραστηριότητα, συνήθως ανοίγοντας μια διεπαφή χρήστη για μια εφαρμογή
* Ως εκπομπές για να ενημερώσει το σύστημα και τις εφαρμογές για αλλαγές
* Για να ξεκινήσει, να σταματήσει και να επικοινωνήσει με ένα υπόβαθρο υπηρεσίας
* Για να έχει πρόσβαση σε δεδομένα μέσω ContentProviders
* Ως κλήσεις πίσω για να χειριστεί γεγονότα

Εάν είναι ευπάθεις, τα **Intents μπορούν να χρησιμοποιηθούν για να πραγματοποιήσουν διάφορες επιθέσεις**.

### Intent-Filter

Τα **Intent Filters** καθορίζουν **πώς μια δραστηριότητα, μια υπηρεσία ή ένας Broadcast Receiver μπορεί να αλληλεπιδράσει με διάφορους τύπους Intents**. Ουσιαστικά, περιγράφουν τις δυνατότητες αυτών των στοιχείων, όπως τι ενέργειες μπορούν να εκτελέσουν ή ποιους τύπους εκπομπών μπορούν να επεξεργαστούν. Ο κύριος τρόπος να δηλώσετε αυτά τα φίλτρα είναι μέσα στο αρχείο **AndroidManifest.xml**, αν και για τους Broadcast Receivers, μπορεί επίσης να γίνει προγραμματιστικά.

Τα Intent Filters αποτελούνται από κατηγορίες, ενέργειες και φίλτρα δεδομένων, με τη δυνατότητα να περιλαμβάνουν επιπλέον μεταδεδομένα. Αυτή η ρύθμιση επιτρέπει στα στοιχεία να χειριστούν συγκεκριμένα Intents που ταιριάζουν με τα δηλωμένα κριτήρια.

Ένα κρίσιμο στοιχείο των στοιχείων Android (δραστηριοτήτων/υπηρεσιών/content providers/broadcast receivers) είναι η ορατότητά τους ή η **δημόσια κατάστασή τους**. Ένα στοιχείο θεωρείται δημόσιο και μπορεί να αλληλεπιδράσει με άλλες εφαρμογές εάν είναι **`εξαγωγή`** με μια τιμή **`true`** ή εάν έχει δηλωθεί ένα Intent Filter για αυτό στον προσδιορισμό του. Ωστόσο, υπάρχει ένας τρόπος για τους προγραμματιστές να κρατήσουν αυτά τα στοιχεία ιδιωτικά, εξασφαλίζοντας ότι δεν θα αλληλεπιδράσουν με άλλες εφαρμογές ακούσια. Αυτό επιτυγχάνεται θέτοντας το χαρακτηριστικό **`εξαγωγή`** σε **`false`** στον ορισμό τους στο αρχείο τους.

Επιπλέον, οι προγραμματιστές έχουν τη δυνατότητα να ενισχύσουν περαιτέρω την πρόσβαση σε αυτά τα στοιχεία απαιτώντας συγκεκριμένες άδειες. Το χαρακτηριστικό **`άδεια`** μπορεί να οριστεί για να επιβάλει ότι μόνο οι εφαρμογές με την καθορισμένη άδεια μπορούν να έχουν πρόσβαση στο στοιχείο, προσθέτοντας ένα επιπλέον επίπεδο ασφάλειας και έλεγχο για το ποιος μπορεί να αλληλεπιδράσει με αυτό.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Έμμεσες Προθέσεις

Οι προθέσεις δημιουργούνται προγραμματικά χρησιμοποιώντας έναν κατασκευαστή προθέσεων (Intent constructor):
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
Η **Ενέργεια** της προηγουμένως δηλωμένης πρόθεσης είναι **ACTION\_SEND** και το **Extra** είναι ένα mailto **Uri** (το Extra είναι η επιπλέον πληροφορία που αναμένει η πρόθεση).

Αυτή η πρόθεση πρέπει να δηλωθεί μέσα στο αρχείο manifest όπως στο παρακάτω παράδειγμα:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Ένα intent-filter πρέπει να ταιριάζει με την **action**, **data** και **category** για να λάβει ένα μήνυμα.

Η διαδικασία "Intent resolution" καθορίζει ποια εφαρμογή θα πρέπει να λάβει κάθε μήνυμα. Αυτή η διαδικασία λαμβάνει υπόψη το **προτεραιότητας attribute**, το οποίο μπορεί να οριστεί στη δήλωση του **intent-filter**, και **επιλέγεται αυτό με την υψηλότερη προτεραιότητα**. Αυτή η προτεραιότητα μπορεί να οριστεί από -1000 έως 1000 και οι εφαρμογές μπορούν να χρησιμοποιήσουν την τιμή `SYSTEM_HIGH_PRIORITY`. Εάν προκύψει **σύγκρουση**, εμφανίζεται ένα παράθυρο "choser" ώστε ο **χρήστης να αποφασίσει**.

### Συγκεκριμένα Intents

Ένα συγκεκριμένο intent καθορίζει το όνομα της κλάσης που στοχεύει:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Σε άλλες εφαρμογές, για να έχετε πρόσβαση στην προηγουμένως δηλωμένη πρόθεση, μπορείτε να χρησιμοποιήσετε:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Εκκρεμείς Προθέσεις

Αυτές επιτρέπουν σε άλλες εφαρμογές να **πραγματοποιούν ενέργειες εκ μέρους της εφαρμογής σας**, χρησιμοποιώντας την ταυτότητα και τις άδειες της εφαρμογής σας. Για την κατασκευή μιας εκκρεμούς πρόθεσης, πρέπει να **καθοριστεί μια πρόθεση και η ενέργεια που πρέπει να πραγματοποιηθεί**. Εάν η **καθορισμένη πρόθεση δεν είναι έκφραση** (δεν καθορίζει ποια πρόθεση μπορεί να την καλέσει), μια **κακόβουλη εφαρμογή μπορεί να πραγματοποιήσει την καθορισμένη ενέργεια** εκ μέρους της εφαρμογής θύματος. Επιπλέον, **εάν δεν καθοριστεί μια ενέργεια**, η κακόβουλη εφαρμογή θα μπορεί να πραγματοποιήσει **οποιαδήποτε ενέργεια εκ μέρους του θύματος**.

### Εκπομπή Προθέσεων

Αντίθετα από τις προηγούμενες προθέσεις, οι οποίες λαμβάνονται μόνο από μία εφαρμογή, οι εκπομπές προθέσεων **μπορούν να ληφθούν από πολλές εφαρμογές**. Ωστόσο, από την έκδοση API 14, είναι **δυνατό να καθοριστεί η εφαρμογή που θα λάβει** το μήνυμα χρησιμοποιώντας το Intent.set Package.

Εναλλακτικά, είναι επίσης δυνατό να **καθοριστεί μια άδεια κατά την αποστολή της εκπομπής**. Η εφαρμογή παραλήπτης θα πρέπει να έχει αυτήν την άδεια.

Υπάρχουν **δύο τύποι** εκπομπών: **Κανονικές** (ασύγχρονες) και **Ταξινομημένες** (σύγχρονες). Η **σειρά** βασίζεται στην **προτεραιότητα που έχει διαμορφωθεί στον παραλήπτη**. **Κάθε εφαρμογή μπορεί να επεξεργαστεί, να ανακατευθύνει ή να απορρίψει την εκπομπή**.

Είναι δυνατό να **αποστείλετε** μια **εκπομπή** χρησιμοποιώντας τη συνάρτηση `sendBroadcast(intent, receiverPermission)` από την κλάση `Context`.\
Μπορείτε επίσης να χρησιμοποιήσετε τη συνάρτηση **`sendBroadcast`** από το **`LocalBroadCastManager`** που εξασφαλίζει ότι το μήνυμα δεν αποχωρίζεται ποτέ από την εφαρμογή. Χρησιμοποιώντας αυτό, δεν θα χρειαστεί ακόμα και να εξαχθεί ένας δέκτης συστατικό.

### Κολλώδεις Εκπομπές

Αυτού του είδους οι εκπομπές **μπορούν να προσπελαστούν αρκετό καιρό μετά την αποστολή τους**.\
Αυτές αποσυντέθηκαν στην έκδοση API 21 και συνιστάται να **μην χρησιμοποιούνται**.\
**Επιτρέπουν σε οποιαδήποτε εφαρμογή να παρακολουθεί τα δεδομένα, αλλά και να τα τροποποιεί**.

Εάν βρείτε συναρτήσεις που περιέχουν τη λέξη "κολλώδης" όπως **`sendStickyBroadcast`** ή **`sendStickyBroadcastAsUser`**, **ελέγξτε την επίδραση και προσπαθήστε να τις αφαιρέσετε**.

## Βαθιές συνδέσεις / Σχήματα URL

Στις εφαρμογές Android, οι **βαθιές συνδέσεις** χρησιμοποιούνται για να προκαλέσουν μια ενέργεια (Intent) απευθείας μέσω ενός URL. Αυτό γίνεται δηλώνοντας ένα συγκεκριμένο **σχήμα URL** μέσα σε μια δραστηριότητα. Όταν μια συσκευή Android προσπαθεί να **αποκτήσει πρόσβαση σε ένα URL με αυτό το σχήμα**, η καθορισμένη δραστηριότητα εντός της εφαρμογής εκκινείται.

Το σχήμα πρέπει να δηλωθεί στο αρχείο **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Το σχήμα από το προηγούμενο παράδειγμα είναι `exampleapp://` (σημειώστε επίσης την **κατηγορία BROWSABLE**)

Στο πεδίο δεδομένων, μπορείτε να καθορίσετε τον **host** και το **path**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Για να έχετε πρόσβαση από τον ιστό, είναι δυνατόν να ορίσετε ένα σύνδεσμο όπως:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Για να βρείτε τον **κώδικα που θα εκτελεστεί στην εφαρμογή**, πηγαίνετε στη δραστηριότητα που καλείται από το deeplink και αναζητήστε τη συνάρτηση **`onNewIntent`**.

Μάθετε πώς να [καλείτε deep links χωρίς τη χρήση σελίδων HTML](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

Η **Android Interface Definition Language (AIDL)** σχεδιάστηκε για να διευκολύνει την επικοινωνία μεταξύ πελάτη και υπηρεσίας στις εφαρμογές Android μέσω της **διαδικασίας επικοινωνίας μεταξύ διεργασιών** (IPC). Καθώς η πρόσβαση στη μνήμη μιας άλλης διεργασίας δεν επιτρέπεται στο Android, η AIDL απλοποιεί τη διαδικασία μετατρέποντας αντικείμενα σε ένα μορφότυπο που κατανοείται από το λειτουργικό σύστημα, διευκολύνοντας έτσι την επικοινωνία μεταξύ διαφορετικών διεργασιών.

### Βασικές έννοιες

- **Υπηρεσίες που συνδέονται**: Αυτές οι υπηρεσίες χρησιμοποιούν την AIDL για την IPC, επιτρέποντας σε δραστηριότητες ή στοιχεία να συνδέονται με μια υπηρεσία, να κάνουν αιτήσεις και να λαμβάνουν απαντήσεις. Η μέθοδος `onBind` στην κλάση της υπηρεσίας είναι κρίσιμη για την έναρξη της αλληλεπίδρασης και αποτελεί σημαντική περιοχή για αναθεώρηση ασφάλειας για την ανίχνευση ευπάθειών.

- **Messenger**: Λειτουργώντας ως συνδεδεμένη υπηρεσία, ο Messenger διευκολύνει την IPC με έμφαση στην επεξεργασία δεδομένων μέσω της μεθόδου `onBind`. Είναι απαραίτητο να επιθεωρήσετε προσεκτικά αυτήν τη μέθοδο για οποιαδήποτε μη ασφαλή χειρισμό δεδομένων ή εκτέλεση ευαίσθητων λειτουργιών.

- **Binder**: Παρόλο που η άμεση χρήση της κλάσης Binder είναι λιγότερο κοινή λόγω της αφαίρεσης της AIDL, είναι χρήσιμο να κατανοήσετε ότι ο Binder λειτουργεί ως οδηγός σε επίπεδο πυρήνα που διευκολύνει τη μεταφορά δεδομένων μεταξύ των χώρων μνήμης διαφορετικών διεργασιών. Για περαιτέρω κατανόηση, υπάρχει ένας πόρος στο [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Στοιχεία

Αυτά περιλαμβάνουν: **Δραστηριότητες, Υπηρεσίες, Δέκτες Εκπομπής και Παρόχους**.

### Δραστηριότητα εκκίνησης και άλλες δραστηριότητες

Στις εφαρμογές Android, οι **δραστηριότητες** είναι σαν οθόνες, που εμφανίζουν διάφορα μέρη του περιβάλλοντος χρήστη της εφαρμογής. Μια εφαρμογή μπορεί να έχει πολλές δραστηριότητες, καθεμία παρουσιάζοντας μια μοναδική οθόνη στον χρήστη.

Η **δραστηριότητα εκκίνησης** είναι η κύρια πύλη εισόδου σε μια εφαρμογή, που εκκινείται όταν πατάτε το εικονίδιο της εφαρμογής. Ορίζεται στο αρχείο manifest της εφαρμογής με συγκεκριμένες προθέσεις MAIN και LAUNCHER:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Όχι όλες οι εφαρμογές χρειάζονται μια δραστηριότητα εκκίνησης, ειδικά αυτές που δεν έχουν διεπαφή χρήστη, όπως οι υπηρεσίες φόντου.

Οι δραστηριότητες μπορούν να γίνουν διαθέσιμες σε άλλες εφαρμογές ή διεργασίες με το να τις σημειώνουμε ως "εξαγόμενες" στο αρχείο manifest. Αυτή η ρύθμιση επιτρέπει σε άλλες εφαρμογές να ξεκινήσουν αυτήν τη δραστηριότητα:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ωστόσο, η πρόσβαση σε μια δραστηριότητα από μια άλλη εφαρμογή δεν είναι πάντα ένας κίνδυνος για την ασφάλεια. Η ανησυχία προκύπτει εάν τα ευαίσθητα δεδομένα κοινοποιούνται εσφαλμένα, κάτι που μπορεί να οδηγήσει σε διαρροή πληροφοριών.

Ο κύκλος ζωής μιας δραστηριότητας **ξεκινά με τη μέθοδο onCreate**, δημιουργώντας το UI και προετοιμάζοντας τη δραστηριότητα για αλληλεπίδραση με τον χρήστη.

### Υποκλάση Εφαρμογής

Στην ανάπτυξη Android, μια εφαρμογή έχει τη δυνατότητα να δημιουργήσει μια **υποκλάση** της κλάσης [Application](https://developer.android.com/reference/android/app/Application), αν και δεν είναι υποχρεωτικό. Όταν ορίζεται μια τέτοια υποκλάση, γίνεται η πρώτη κλάση που δημιουργείται μέσα στην εφαρμογή. Η μέθοδος **`attachBaseContext`**, εάν υλοποιηθεί σε αυτήν την υποκλάση, εκτελείται πριν από τη μέθοδο **`onCreate`**. Αυτή η ρύθμιση επιτρέπει την πρώιμη αρχικοποίηση πριν ξεκινήσει η υπόλοιπη εφαρμογή.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Υπηρεσίες

[Οι υπηρεσίες](https://developer.android.com/guide/components/services) είναι **φόντο εργαζόμενοι** που μπορούν να εκτελούν εργασίες χωρίς διεπαφή χρήστη. Αυτές οι εργασίες μπορούν να συνεχίσουν να εκτελούνται ακόμα και όταν οι χρήστες αλλάζουν σε διάφορες εφαρμογές, καθιστώντας τις υπηρεσίες ζωτικής σημασίας για **εργασίες μεγάλης διάρκειας**.

Οι υπηρεσίες είναι ευέλικτες· μπορούν να ξεκινήσουν με διάφορους τρόπους, με τα **Intents** να είναι η κύρια μέθοδος για την εκκίνησή τους ως σημείο εισόδου μιας εφαρμογής. Μόλις μια υπηρεσία ξεκινήσει χρησιμοποιώντας τη μέθοδο `startService`, η μέθοδος `onStart` της εκκινεί και συνεχίζει να εκτελείται μέχρι να κληθεί ρητά η μέθοδος `stopService`. Εναλλακτικά, αν ο ρόλος μιας υπηρεσίας εξαρτάται από μια ενεργή σύνδεση πελάτη, χρησιμοποιείται η μέθοδος `bindService` για τη σύνδεση του πελάτη με την υπηρεσία, εμπλέκοντας τη μέθοδο `onBind` για τη μετάδοση δεδομένων.

Ένα ενδιαφέρον παράδειγμα χρήσης των υπηρεσιών περιλαμβάνει την αναπαραγωγή μουσικής στο φόντο ή τη λήψη δεδομένων δικτύου χωρίς να επηρεάζεται η αλληλεπίδραση του χρήστη με μια εφαρμογή. Επιπλέον, οι υπηρεσίες μπορούν να γίνουν προσβάσιμες σε άλλες διεργασίες στην ίδια συσκευή μέσω της **εξαγωγής**. Αυτή δεν είναι η προεπιλεγμένη συμπεριφορά και απαιτεί συγκεκριμένη διαμόρφωση στο αρχείο Android Manifest:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Αποστολείς Εκπομπής

Οι **αποστολείς εκπομπής** λειτουργούν ως ακροατές σε ένα σύστημα μηνυμάτων, επιτρέποντας σε πολλές εφαρμογές να ανταποκρίνονται στα ίδια μηνύματα από το σύστημα. Μια εφαρμογή μπορεί να **καταχωρήσει έναν αποστολέα εκπομπής** με **δύο κύριους τρόπους**: μέσω του **Manifest** της εφαρμογής ή **δυναμικά** μέσα στον κώδικα της εφαρμογής μέσω του API **`registerReceiver`**. Στο Manifest, οι εκπομπές φιλτράρονται με δικαιώματα, ενώ οι δυναμικά καταχωρημένοι αποστολείς εκπομπής μπορούν επίσης να καθορίσουν δικαιώματα κατά την καταχώρηση.

Οι **φίλτρα προθέσεων** είναι κρίσιμα και στις δύο μεθόδους καταχώρησης, καθορίζοντας ποιες εκπομπές ενεργοποιούν τον αποστολέα εκπομπής. Μόλις αποσταλεί μια αντίστοιχη εκπομπή, καλείται η μέθοδος **`onReceive`** του αποστολέα εκπομπής, επιτρέποντας στην εφαρμογή να αντιδράσει αναλόγως, όπως να προσαρμόσει τη συμπεριφορά της ανάλογα με μια ειδοποίηση για χαμηλή μπαταρία.

Οι εκπομπές μπορούν να είναι είτε **ασύγχρονες**, φθάνοντας σε όλους τους αποστολείς εκπομπής χωρίς σειρά, είτε **σύγχρονες**, όπου οι αποστολείς εκπομπής λαμβάνουν την εκπομπή βάσει των προτεραιοτήτων που έχουν οριστεί. Ωστόσο, είναι σημαντικό να σημειωθεί ο δυνητικός κίνδυνος για την ασφάλεια, καθώς οποιαδήποτε εφαρμογή μπορεί να δώσει προτεραιότητα στον εαυτό της για να παρεμβάλει μια εκπομπή.

Για να κατανοήσετε τη λειτουργικότητα ενός αποστολέα εκπομπής, αναζητήστε τη μέθοδο **`onReceive`** μέσα στην κλάση του. Ο κώδικας αυτής της μεθόδου μπορεί να τροποποιήσει την ληφθείσα πρόθεση, υπογραμμίζοντας την ανάγκη για επικύρωση δεδομένων από τους αποστολείς εκπομπής, ιδιαίτερα σε **Ταξινομημένες Εκπομπές**, που μπορούν να τροποποιήσουν ή να απορρίψουν την πρόθεση.

### Πάροχος Περιεχομένου

Οι **πάροχοι περιεχομένου** είναι ουσιώδεις για την **κοινή χρήση δομημένων δεδομένων** μεταξύ εφαρμογών, τονίζοντας τη σημασία της εφαρμογής **δικαιωμάτων** για να εξασφαλιστεί η ασφάλεια των δεδομένων. Επιτρέπουν στις εφαρμογές να έχουν πρόσβαση σε δεδομένα από διάφορες πηγές, όπως βάσεις δεδομένων, αρχεία συστήματος ή τον ιστό. Ειδικά δικαιώματα, όπως το **`readPermission`** και το **`writePermission`**, είναι κρίσιμα για τον έλεγχο της πρόσβασης. Επιπλέον, μπορεί να χορηγηθεί προσωρινή πρόσβαση μέσω των ρυθμίσεων **`grantUriPermission`** στο Manifest της εφαρμογής, εκμεταλλευόμενοι χαρακτηριστικά όπως το `path`, `pathPrefix` και `pathPattern` για λεπτομερή έλεγχο πρόσβασης.

Η επικύρωση της εισόδου είναι ζωτικής σημασίας για την αποτροπή ευπάθειών, όπως η εισχώρηση SQL. Οι πάροχοι περιεχομένου υποστηρίζουν βασικές λειτουργίες: `insert()`, `update()`, `delete()` και `query()`, διευκολύνοντας την επεξεργασία και την κοινή χρήση δεδομένων μεταξύ εφαρμογών.

Ο **FileProvider**, ένας εξειδικευμένος πάροχος περιεχομένου, επικεντρώνεται στην ασφαλή κοινή χρήση αρχείων. Ορίζεται στο Manifest της εφαρμογής με συγκεκριμένα χαρακτηριστικά για τον έλεγχο της πρόσβασης σε φακέλους, που υποδεικνύονται από τα `android:exported` και `android:resource` που αναφέρονται σε ρυθμίσεις φακέλων. Συνιστάται προσοχή κατά την κοινή χρήση φακέλων για να αποφευχθεί η ακούσια αποκάλυψη ευαίσθητων δεδομένων.

Παράδειγμα δήλωσης στο Manifest για τον FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Και ένα παράδειγμα για τον καθορισμό κοινόχρηστων φακέλων στο `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Για περαιτέρω πληροφορίες, ελέγξτε:
- [Πάροχοι περιεχομένου των Android Developers](https://developer.android.com/guide/topics/providers/content-providers)
- [FileProvider των Android Developers](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

Οι WebViews είναι σαν **μικροί περιηγητές ιστού** μέσα σε εφαρμογές Android, που εμφανίζουν περιεχόμενο είτε από τον ιστό είτε από τοπικά αρχεία. Αντιμετωπίζουν παρόμοιους κινδύνους με τους κανονικούς περιηγητές, αλλά υπάρχουν τρόποι για να **μειωθούν αυτοί οι κίνδυνοι** μέσω συγκεκριμένων **ρυθμίσεων**.

Το Android προσφέρει δύο κύριους τύπους WebView:

- Ο **WebViewClient** είναι κατάλληλος για βασικό HTML, αλλά δεν υποστηρίζει τη συνάρτηση ειδοποίησης JavaScript, επηρεάζοντας τον τρόπο δοκιμής των επιθέσεων XSS.
- Ο **WebChromeClient** λειτουργεί περισσότερο όπως η πλήρης εμπειρία του περιηγητή Chrome.

Ένα σημαντικό σημείο είναι ότι οι περιηγητές WebView **δεν μοιράζονται cookies** με τον κύριο περιηγητή της συσκευής.

Για τη φόρτωση περιεχομένου, είναι διαθέσιμες μέθοδοι όπως η ````loadUrl````, ````loadData````, και ````loadDataWithBaseURL````. Είναι κρίσιμο να διασφαλίζεται ότι αυτές οι διευθύνσεις URL ή αρχεία είναι **ασφαλείς για χρήση**. Οι ρυθμίσεις ασφαλείας μπορούν να διαχειριστούνται μέσω της κλάσης ````WebSettings````. Για παράδειγμα, η απενεργοποίηση του JavaScript με την εντολή ````setJavaScriptEnabled(false)```` μπορεί να αποτρέψει επιθέσεις XSS.

Η "Bridge" του JavaScript επιτρέπει στα αντικείμενα Java να αλληλεπιδρούν με το JavaScript, απαιτώντας οι μέθοδοι να επισημαίνονται με το ````@JavascriptInterface```` για ασφάλεια από το Android 4.2 και μετά.

Η επιτροπή πρόσβασης σε περιεχόμενο (````setAllowContentAccess(true)````) επιτρέπει στις WebViews να φτάνουν τους Παρόχους Περιεχομένου, που μπορεί να αποτελέσει κίνδυνο εκτός εάν οι διευθύνσεις URL του περιεχομένου επαληθεύονται ως ασφαλείς.

Για τον έλεγχο της πρόσβασης σε αρχεία:
- Η απενεργοποίηση της πρόσβασης σε αρχεία (````setAllowFileAccess(false)````) περιορίζει την πρόσβαση στο σύστημα αρχείων, με εξαιρέσεις για ορισμένα αρχεία πόρων, εξασφαλίζοντας ότι χρησιμοποιούνται μόνο για μη ευαίσθητο περιεχόμενο.

## Άλλα Στοιχεία Εφαρμογής και Διαχείρισης Κινητών Συσκευών

### **Ψηφιακή Υπογραφή Εφαρμογών**

- Η **ψηφιακή υπογραφή** είναι απαραίτητη για τις εφαρμογές Android, εξασφαλίζοντας ότι είναι **αυθεντικά πιστοποιημένες** πριν από την εγκατάσταση. Αυτή η διαδικασία χρησιμοποιεί ένα πιστοποιητικό για την αναγνώριση της εφαρμογής και πρέπει να επαληθεύεται από τον διαχειριστή πακέτων της συσκευής κατά την εγκατάσταση. Οι εφαρμογές μπορούν να είναι **αυτο-υπογεγραμμένες ή πιστοποιημένες από εξωτερική αρχή**, προστατεύοντας έτσι από μη εξουσιοδοτημένη πρόσβαση και εξασφαλίζοντας ότι η εφαρμογή παραμένει ανέπαφη κατά την παράδοσή της στη συσκευή.

### **Επαλήθευση Εφαρμογών για Ενισχυμένη Ασφάλεια**

- Από την έκδοση **Android 4.2** και μετά, μια λειτουργία που ονομάζεται **Verify Apps** επιτρέπει στους χρήστες να ελέγχουν την ασφάλεια των εφαρμογών πριν από την εγκατάστασή τους. Αυτή η διαδικασία επαλήθευσης μπορεί να προειδοποιήσει τους χρήστες για πιθανά επικίνδυνα προγράμματα ή ακόμη και να αποτρέψει την εγκατάσταση ιδιαίτερα κακόβουλων προγραμμάτων, ενισχύοντας έτσι την ασφάλεια των χρηστών.

### **Διαχείριση Κινητών Συσκευών (MDM)**

- Οι λύσεις **MDM** παρέχουν εποπτεία και ασφάλεια για τις κινητές συσκευές μέσω του **Device Administration API**. Απαιτούν την εγκατάσταση μιας εφαρμογής Android για να διαχειρίζονται και να ασφαλίζουν αποτελεσματικά τις κινητές συσκευές. Οι βασικές λειτουργίες περιλαμβάνουν την **επιβολή πολιτικών κωδικού πρόσβασης**, την **υποχρέωση κρυπτογράφησης αποθήκευσης** και την **επιτροπή απομάκρυνσης δεδομένων**, εξασφαλίζοντας ολοκληρωμένο έλεγχο και ασφάλεια για τις κινητές συσκευές.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Βρείτε ευπάθειες που έχουν μεγαλύτερη σημασία, ώστε να μπορείτε να τις διορθώσετε πιο γρήγορα. Ο Intruder παρακολουθεί την επιθετική επιφάνεια σας, εκτελεί προληπτικές απειλητικές αναζητήσεις, εντοπίζει προβλήματα σε ολόκληρο το τεχνολογικό σας στοίβα, από τις διεπαφές προγραμματισμού εφαρμογών (APIs) μέχρι τις ιστοσελίδες και τα συστήματα στον νέφος. [**Δοκιμάστε το δωρεάν**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) σήμερα.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF**, ελέγξτε τα [**ΠΑΚΕΤΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα κόλπα σας στο hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
