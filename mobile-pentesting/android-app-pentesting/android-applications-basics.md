# Android Applications Basics

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)をフォローする
- **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて修正を迅速化します。Intruderは攻撃面を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリ、クラウドシステムまでの問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) 今すぐ。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Androidセキュリティモデル

**2つのレイヤーがあります：**

- **OS**：インストールされたアプリケーションを互いに分離します。
- **アプリケーション自体**：開発者が**特定の機能を公開**し、アプリケーションの機能を構成できます。

### UID分離

**各アプリケーションには特定のユーザーIDが割り当てられます**。これはアプリのインストール中に行われ、**アプリは自分のユーザーIDで所有されているファイルまたは共有ファイルにのみアクセス**できます。したがって、アプリ自体、OSの特定のコンポーネント、およびルートユーザーだけがアプリのデータにアクセスできます。

### UID共有

**2つのアプリケーションを同じUIDを使用するように構成できます**。これは情報を共有するのに役立ちますが、1つが侵害されると両方のアプリケーションのデータが侵害されます。このため、この動作は**推奨されません**。\
**同じUIDを共有するには、アプリケーションはマニフェストで同じ `android:sharedUserId` 値を定義する必要があります。**

### サンドボックス

**Androidアプリケーションサンドボックス**を使用すると、**各アプリケーション**を**別のプロセスとして別のユーザーIDで実行**できます。各プロセスには独自の仮想マシンがあり、アプリのコードは他のアプリから隔離されて実行されます。\
Android 5.0（L）からは**SELinux**が強制されています。基本的に、SELinuxはすべてのプロセスの相互作用を拒否し、それらの間で**予想される相互作用のみを許可するポリシーを作成**しました。

### 権限

アプリをインストールするときに**権限を要求すると、**AndroidManifest.xml**ファイルの**`uses-permission`**要素で構成された権限を要求しています。**uses-permission**要素は、**name** **属性内の要求された権限の名前**を示します。**maxSdkVersion**属性もあり、指定されたバージョンよりも高いバージョンでは権限を要求しなくなります。\
Androidアプリケーションは最初からすべての権限を要求する必要はなく、**動的に権限を要求**することもできますが、すべての権限は**マニフェストで宣言**されている必要があります。

アプリが機能を公開すると、**指定された権限を持つアプリにのみアクセス**を制限できます。\
権限要素には3つの属性があります：

- 権限の**名前**
- **permission-group**属性：関連する権限をグループ化するための属性
- 権限が付与される方法を示す**protection-level**。4つのタイプがあります：
  - **Normal**：アプリに**既知の脅威がない**場合に使用されます。ユーザーは**承認を求められません**。
  - **Dangerous**：権限が要求されたアプリケーションに**一部の昇格アクセス**を付与することを示します。**ユーザーは承認を求められます**。
  - **Signature**：**エクスポートしているコンポーネントと同じ証明書で署名されたアプリ**のみが権限を付与されることができます。これは最も強力な保護のタイプです。
  - **SignatureOrSystem**：**エクスポートしているコンポーネントと同じ証明書で署名されたアプリ**または**システムレベルのアクセスで実行されているアプリ**のみが権限を付与されることができます

## 事前インストールされたアプリケーション

これらのアプリは一般的に**`/system/app`**または**`/system/priv-app`**ディレクトリにあり、一部は**最適化されています**（`classes.dex`ファイルが見つからない場合があります）。これらのアプリケーションは、**時々ルートとして実行される権限が多すぎる**ため、チェックする価値があります。

- **AOSP**（Androidオープンソースプロジェクト）**ROM**に含まれるもの
- デバイスの**製造元**によって追加されたもの
- 携帯電話プロバイダーによって追加されたもの（彼らから購入した場合）

## ルート化

物理的なAndroidデバイスでルートアクセスを取得するには、通常、デバイスとバージョンに**特定の脆弱性を悪用**する必要があります。\
悪用が成功すると、通常、Linuxの `su` バイナリがユーザーのPATH環境変数で指定された場所にコピーされます（例：`/system/xbin`）。

suバイナリが構成されると、他のAndroidアプリが `su` バイナリとのインターフェースを使用して**ルートアクセスのリクエストを処理**します。例：**Superuser**や**SuperSU**（Google Playストアで利用可能）。

{% hint style="danger" %}
ルート化プロセスは非常に危険であり、デバイスに重大な損害を与える可能性があります
{% endhint %}

### ROM

カスタムファームウェアをインストールしてOSを**置き換えることができます**。これにより、古いデバイスの有用性を拡張したり、ソフトウェアの制限をバイパスしたり、最新のAndroidコードにアクセスしたりすることができます。\
**OmniROM**と**LineageOS**は、最も人気のあるファームウェアの2つです。

デバイスをルート化する必要があるとは限らないことに注意してください。**一部のメーカーは**、ブートローダーの**アンロックを許可**する方法を十分に文書化して安全に行うことができます。

### 影響

デバイスがルート化されると、任意のアプリがルートアクセスを要求できます。悪意のあるアプリがそれを取得した場合、ほとんどすべてにアクセスでき、電話を破損させることができます。

## Androidアプリケーションの基本 <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Androidアプリケーションの形式は_APKファイル形式_と呼ばれます。基本的には**ZIPファイル**です（ファイル拡張子を.zipに変更することで、内容を抽出して表示できます）。
- APKの内容（完全ではありません）
  - **AndroidManifest.xml**
  - resources.arsc/strings.xml
  - resources.arsc：バイナリXMLなど、事前にコンパイルされたリソースを含む
  - res/xml/files\_paths.xml
  - META-INF/
  - ここに証明書があります！
  - **classes.dex**
  - デフォルトでアプリが実行するコンパイルされたJava（またはKotlin）コードを表すDalvikバイトコードが含まれています。
  - lib/
  - CPUアーキテクチャごとにサブディレクトリに分かれたネイティブライブラリが格納されています。
    - `armeabi`：ARMベースのプロセッサ用のコード
    - `armeabi-v7a`：ARMv7およびそれ以上のプロセッサ用のコード
    - `x86`：X86プロセッサ用のコード
    - `mips`：MIPSプロセッサ用のコードのみ
  - assets/
  - アプリが必要とするさまざまなファイルを格納し、追加のネイティブライブラリやDEXファイルを含む場合があります。マルウェアの作者が追加のコードを隠すために使用することがあります。
  - res/
  - resources.arscにコンパイルされていないリソースが含まれています

### **Dalvik & Smali**

- ほとんどのAndroidアプリはJavaまたはKotlinで開発されています（この文脈では「Java」として言及されるときは互換性があります）。
- デスクトップアプリのようにJavaコードをJava仮想マシン（JVM）で実行する代わりに、AndroidはJavaを**Dalvik Executable（DEX）バイトコード**にコンパイルします。
- バイトコードの変換は、歴史的にはDalvik仮想マシンが処理していましたが、より新しいAndroidバージョンではAndroidランタイム（ART）が使用されています。
- 逆コンパイルプロセスには、DEXバイトコードを人間が読める形式に戻す作業が含まれます。

**SmaliはDalvikバイトコードの人間が読める形式**です。技術的には、アセンブラとディスアセンブラツールを指しますが、Androidのコンテキストでは、「Smali」はしばしば命令自体を指します。**SMALIはアセンブリ言語に似ており、ソースコードとバイトコードの間の中間形式として機能します**。
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**アクション**は以前に宣言されたインテントの**ACTION\_SEND**であり、**Extra**はmailto **Uri**です（Extraはインテントが期待している追加情報です）。

このインテントは、次の例のようにマニフェスト内で宣言する必要があります：
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
An intent-filter needs to match the **action**, **data** and **category** to receive a message.

The "Intent resolution" process determine which app should receive each message. This process considers the **priority attribute**, which can be set in the **intent-filter declaration**, and **the one with the higher priority will be selected**. This priority can be set between -1000 and 1000 and applications can use the `SYSTEM_HIGH_PRIORITY` value. If a **conflict** arises, a "choser" Window appears so the **user can decide**.

### Explicit Intents

An explicit intent specifies the class name it's targeting:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
他のアプリケーションで以前に宣言されたインテントにアクセスするには、次のようにします:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### ペンディングインテント

これにより、他のアプリケーションが**あなたのアプリケーションの代わりにアクションを実行**できます。ペンディングインテントを構築する際は、**インテントと実行するアクションを指定する必要があります**。**宣言されたインテントが明示的でない**場合（どのインテントが呼び出せるかを宣言していない場合）、**悪意のあるアプリケーションが被害者アプリの代わりに宣言されたアクションを実行**できます。さらに、**アクションが指定されていない**場合、悪意のあるアプリは**被害者の代わりに任意のアクションを実行**できます。

### ブロードキャストインテント

以前のインテントとは異なり、ブロードキャストインテントは**複数のアプリに受信される**ことができます。ただし、APIバージョン14以降では、Intent.set Packageを使用して**メッセージを受信するアプリを指定**することが可能です。

また、ブロードキャストを送信する際に**パーミッションを指定することも可能**です。受信アプリはそのパーミッションを持っている必要があります。

ブロードキャストには**通常**（非同期）と**順序付け**（同期）の**2つのタイプ**があります。**順序**は**受信側の構成された優先度に基づいて**います。**各アプリはブロードキャストを処理、中継、または破棄**できます。

`Context`クラスから\*\*`sendBroadcast(intent, receiverPermission)` \*\* 関数を使用して**ブロードキャストを送信**することが可能です。\
また、**`LocalBroadCastManager`**から**`sendBroadcast`** 関数を使用すると、**メッセージがアプリを離れることはなく**なります。これにより、受信コンポーネントをエクスポートする必要すらありません。

### スティッキーブロードキャスト

この種のブロードキャストは、**送信後も長い間アクセスできます**。\
これらはAPIレベル21で廃止され、**使用しないことが推奨**されています。\
**これにより、任意のアプリケーションがデータを嗅ぎ取るだけでなく、変更することも可能**です。

**`sendStickyBroadcast`** や **`sendStickyBroadcastAsUser`** のように「sticky」という単語を含む関数を見つけた場合は、**影響を確認し、それらを削除しよう**。

## ディープリンク / URLスキーム

**ディープリンクはURL経由でインテントをトリガーできます**。アプリケーションは、アクティビティ内に**URLスキーマ**を宣言できるため、Androidデバイスが**そのスキーマを使用してアドレスにアクセスしようとするたびに**アプリケーションのアクティビティが呼び出されます。

![](<../../.gitbook/assets/image (214).png>)

この場合、`myapp://`がスキームです（**`category BROWSABLE`** も注意してください）

`intent-filter`内で次のようなものを見つけた場合：

![](<../../.gitbook/assets/image (263).png>)

それは `http://www.example.com/gizmos` のようなものを期待しています

次のようなものを見つけた場合：

![](<../../.gitbook/assets/image (262).png>)

それは `example://gizmos` で始まるURLを期待しています\
この場合、以下のペイロードを使用して機能を悪用し、任意のページに移動し、JSを実行しようとします。
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
**アプリで実行されるコード**を見つけるには、ディープリンクで呼び出されるアクティビティに移動し、**`onNewIntent`** 関数を検索します。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

HTML ページを使用せずに[ディープリンクを呼び出す方法](./#exploiting-schemes-deep-links)を学ぶ。

## AIDL - Android Interface Definition Language

**Android Interface Definition Language**（AIDL）は、**クライアントとサービスが合意して相互通信を行うために定義するプログラミングインターフェース**を定義することができます。Androidでは、**通常、1つのプロセスは他のプロセスのメモリにアクセスできません**。そのため、通信するためには、オブジェクトをオペレーティングシステムが理解できるプリミティブに分解し、オブジェクトをその境界を越えてマーシャリングする必要があります。そのマーシャリングを行うコードは書くのが面倒なので、Android は AIDL で処理します。

AIDL を使用するサービスは**バウンドサービス**と呼ばれます。サービスのクラスには **`onBind`** メソッドがあります。これは**相互作用が始まる場所**であり、潜在的な脆弱性を探すためにレビューするコードの最初の部分です。

バウンドサービスはクライアントサーバーインターフェースのサーバーです。**コンポーネント（アクティビティなど）がサービスにバインドし、リクエストを送信し、レスポンスを受信し、相互通信を行う**ことができます。バウンドサービスは通常、他のアプリケーションコンポーネントにサービスを提供する間だけ存在し、無期限にバックグラウンドで実行されることはありません。

### Messenger

Messenger は別の IPC メカニズムです。**Messenger も「バウンドサービス」**であるため、クライアントアプリから渡されるデータは `onBind` メソッドを介して処理されます。したがって、コードレビューはこのメソッドから始め、機密機能の呼び出しやデータの安全でない処理を探す必要があります。

### Binder

Binder クラスが直接呼び出されているのは珍しいですが、Binder クラスを抽象化する AIDL を使用する方が簡単です。ただし、**Binder はデータを1つのプロセスのメモリから別のプロセスのメモリに移動するカーネルレベルのドライバー**であることを知っておくと良いでしょう。

## コンポーネント

これには、**アクティビティ、サービス、ブロードキャストレシーバー、プロバイダー**が含まれます。

### ランチャーアクティビティとその他のアクティビティ

**Android アクティビティ**は、**Android**アプリのユーザーインターフェースの1画面です。そのため、**Android アクティビティ**はデスクトップアプリケーションのウィンドウに非常に似ています。**Android**アプリには1つ以上のアクティビティが含まれる場合があります。

**ランチャーアクティビティ**は、ほとんどの人がAndroidアプリケーションの**エントリーポイント**と考えるものです。ランチャーアクティビティは、ユーザーがアプリケーションのアイコンをクリックしたときに開始されるアクティビティです。ランチャーアクティビティはアプリケーションのマニフェストを見て特定できます。ランチャーアクティビティは、次の MAIN および LAUNCHER インテントがリストされています。

UI を持たないアプリケーション、つまりバックグラウンドでサービスを実行するプリインストールされたアプリケーション（例：ボイスメールなど）など、ランチャーアクティビティを持たないアプリケーションもあることに注意してください。
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
アクティビティは、他のデバイス上のプロセスがアクティビティを起動できるようにエクスポートすることができます。デフォルトではエクスポートされませんが、次の設定を行うことでエクスポートできます:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
注意: **アクティビティ保護をバイパスする能力があるからといって、常に脆弱性とは限りません**。取得したデータを確認する必要があります。\
また、**一部のアクティビティは呼び出し元にデータを返します**。このようなシナリオでは、**`setResult`** メソッドを検索し、Intentパラメータに渡されるデータを確認する必要があります。**もし機密データであれば、情報漏洩の脆弱性があり、アクティビティと通信可能なアプリで悪用される可能性があります**。

**アクティビティのコードは `onCreate`** メソッドで始まります。

### アプリケーションのサブクラス

Androidアプリケーションは、[Application](https://developer.android.com/reference/android/app/Application) の**サブクラス**を定義できます。AndroidアプリがApplicationのサブクラスを定義することができますが、必ずしも定義する必要はありません。AndroidアプリがApplicationのサブクラスを定義する場合、**このクラスはアプリ内の他のクラスよりも先にインスタンス化されます**。

Applicationのサブクラスで **`attachBaseContext`** メソッドが定義されている場合、**`onCreate`** メソッドの前に呼び出されます。

### サービス

[サービス](https://developer.android.com/guide/components/services) は**UIを持たずにバックグラウンドで実行**されます。**ユーザーが別のアプリを使用し始めても、長時間実行するプロセスに使用されます**。

サービスはさまざまな方法で開始できるため、アプリケーションのエントリーポイントとなります。サービスをアプリケーションのエントリーポイントとして開始するデフォルトの方法は、**インテント**を介して行われます。

**`startService`** メソッドが呼び出されてサービスを開始すると、サービス内の **`onStart`** メソッドが実行されます。サービスは **`stopService`** メソッドが呼び出されるまで無期限に実行されます。サービスがクライアントが接続している間だけ必要な場合、クライアントは **`bindService`** メソッドを使用してそれに「バインド」する必要があります。

**バインドされたサービス**（前のセクションを参照）の場合、データは **`onBind`** メソッドに渡されます。

たとえば、サービスはユーザーが別のアプリを使用している間にバックグラウンドで音楽を再生したり、アクティビティのユーザーインタラクションをブロックせずにネットワーク経由でデータを取得したりすることがあります。

**サービスは他のプロセスがデバイス上でサービスを開始できるようにエクスポートできます**。デフォルトではサービスはエクスポートされませんが、マニフェストで構成できます：
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### ブロードキャストレシーバ

ブロードキャストはメッセージングシステムと考えることができ、**ブロードキャストレシーバはリスナー**です。アプリケーションが特定のブロードキャストの受信者を登録している場合、システムがブロードキャストを送信すると、その受信者内のコードが実行されます。この場合、**複数のアプリが同じメッセージを受け取る可能性がある**ことに注意してください。

アプリがレシーバを登録する方法には**2つ**あります：**アプリのマニフェスト内で登録するか、`registerReceiver`** API呼び出しを使用してアプリのコード内で**動的に登録**します。マニフェストでは、レシーバ要素内で**権限を使用して受け入れるブロードキャストを制限**できます。**動的に**定義する場合は、`registerReceiver`メソッドに権限を**渡す**ことができます。

両方の場合、レシーバを登録するためには、レシーバの**インテントフィルタが設定**されます。これらのインテントフィルタは、レシーバをトリガーすべきブロードキャストです。

レシーバが登録されている特定のブロードキャストが送信されると、BroadcastReceiverクラスの**`onReceive`**が**実行**されます。

例えば、アプリケーションは低電池メッセージのためのレシーバを登録し、その情報に基づいて動作を変更することができます。

ブロードキャストは**非同期**（すべての受信者が受信する）または**同期**（優先度に基づいて順番に受信される）である可能性があります。

{% hint style="danger" %}
**どのアプリケーションでも自身を最優先でブロードキャストを受信するように設定できることに注意してください。**
{% endhint %}

ブロードキャストレシーバに実装されたコードを**調査**するには、レシーバクラスの**`onReceive`**メソッドを検索する必要があります。\
**順序付けされたブロードキャスト**では、受信したIntentを破棄したり、setterメソッドを使用して変更したりすることができます。そのため、**受信者はデータを検証**する必要があります。

### コンテンツプロバイダ

コンテンツプロバイダは、リレーショナルデータベースなどの構造化データを**アプリ間で共有する方法**です。したがって、これらを保護するために**権限を使用**し、適切な保護レベルを設定することが非常に重要です。\
コンテンツプロバイダは、アプリが持っている必要がある権限を指定するために**`readPermission`**および**`writePermission`**属性を使用できます。**これらの権限は、permission属性より優先されます**。\
さらに、**`grantUriPermission`**をtrueに設定し、その後マニフェストファイル内のプロバイダ要素内の**`grant-uri-permission`**要素を適切に構成することで、**一時的な例外を許可**することもできます。

**`grant-uri-permission`**には、path、pathPrefix、pathPatternの3つの属性があります：

* **path**：除外する完全なパスを指定できます
* **pathPrefix**：パスの先頭部分を指定できます
* **pathPattern**：ワイルドカードとシンボル置換を使用して、より細かい制御を得ることができます。

潜在的な脆弱性（SQLインジェクションなど）を回避するために、**受け取った入力を検証およびサニタイズすることが重要**です。

**コンテンツプロバイダの特徴：**

* コンテンツプロバイダコンポーネントは、リクエストに応じて1つのアプリケーションから他のアプリケーションにデータを供給します。
* データをファイルシステム、SQLiteデータベース、Web上、またはアプリがアクセスできる他の永続的なストレージ場所に保存できます。
* コンテンツプロバイダを介して、他のアプリケーションはデータをクエリしたり、変更したりすることができます（コンテンツプロバイダが許可する場合）。
* コンテンツプロバイダは、アプリが他のアプリとデータを共有したい場合に便利です。
* データベースと非常に似ており、4つのメソッドを持っています。
  * insert()
  * update()
  * delete()
  * query()

**FileProvider**

これは、フォルダから**ファイルを共有**するタイプのコンテンツプロバイダです。次のようにファイルプロバイダを宣言できます：
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
注意してください**`android:exported`**属性が**`true`**である場合、外部アプリケーションが共有フォルダにアクセスできるようになります。\
構成`android:resource="@xml/filepaths"`が、ファイル _res/xml/filepaths.xml_ が**どのフォルダ**をこの**FileProvider**が**共有**するかの構成を含んでいることを示していることに注意してください。このファイルでフォルダを共有する方法の例は次のとおりです：
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
**`path="."`**のような情報を共有することは、他の部分のコードでこのプロバイダにアクセスしようとする脆弱性がある場合には、提供元がエクスポートされていなくても**危険**です。\
`content://com.example.myapp.fileprovider/myimages/default_image.jpg`のようなフォルダ内の**画像**にアクセスできます。

`<paths>`要素には複数の子要素があり、それぞれ異なるディレクトリを共有することができます。**`<files-path>`**要素に加えて、**`<external-path>`**要素を使用して**外部ストレージ**内のディレクトリを共有したり、**`<cache-path>`**要素を使用して**内部キャッシュディレクトリ**内のディレクトリを共有したりできます。\
[特定のファイルプロバイダ属性に関する詳細情報はこちらを参照してください。](https://developer.android.com/reference/androidx/core/content/FileProvider)

[FileProvidersに関する詳細情報はこちら](https://developer.android.com/training/secure-file-sharing/setup-sharing)。

## WebViews

WebViewsはAndroidアプリに埋め込まれた**ウェブブラウザ**です。\
WebViewsのコンテンツはリモートサイトから取得するか、アプリに含まれるファイルから取得できます。\
WebViewsは**他のウェブブラウザに影響を受ける脆弱性に対して脆弱**です。ただし、**攻撃** **範囲**を**制限**するのに役立つ**構成**がいくつかあります。

Androidには2種類のWebViewsがあります：

* **WebViewClient**は、シンプルなHTMLのレンダリングに最適です。これはJSのalert関数を実行しません。そのため、この関数を使用したXSSテストは無効になります。
* **WebChrome** **client**はChromeブラウザです。

**WebViewブラウザはネイティブブラウザのクッキーにアクセスできません**。

URLやファイルを読み込むには、**`loadUrl`**、**`loadData`**、または**`loadDataWithBaseURL`**関数を使用できます。**サニタイズされたURLにのみアクセスすることが重要**です。\
WebViewのセキュリティは**`WebSettings`**オブジェクトを介して構成できます。\
たとえば、JSコードの実行を無効にするには、**`setJavaScriptEnabled`**メソッドを**`false`**の値で使用します。これにより、**XSS**やその他のJS関連の脆弱性の可能性が**除去**されます。

JavaScriptの**"Bridge"**機能は、JavaオブジェクトをWebViewに**注入**してJSからアクセス可能にします。Android 4.2以降、メソッドはJavaScriptからアクセス可能にするために**`@JavascriptInterface`**で注釈付けする必要があります。

**`setAllowContentAccess`**に**`true`**を渡すと、**WebViewsは`content://`**スキームを介して**コンテンツプロバイダにアクセス**できます。これは明らかにセキュリティリスクを引き起こします。このアクセスが許可される場合は、**`content://`** URLが**安全**であることを非常に重要です。

デフォルトでは、ローカルファイルはWebViewがfile:// URLを介してアクセスできますが、この動作を防止するためのいくつかの方法があります：

* **`setAllowFileAccess`**に**`false`**を渡すと、`file:///android_asset` _および_ `file:///android_res`を除くファイルシステムへのアクセスが防止されます。これらのパスは非機密データ（画像など）にのみ使用すべきですので、これは安全です。
* **`setAllowFileAccess`**メソッドは、`file://` URLからのパスが他のファイルスキームURLからコンテンツにアクセスできるかどうかを示します。
* **`setAllowUniversalAccessFromFileURLs`**メソッドは、`file://` URLからのパスが任意のオリジンからコンテンツにアクセスできるかどうかを示します。

## その他のアプリコンポーネント

### **アプリケーション署名**

* Androidでは、**すべてのアプリはデジタル証明書で署名されている必要があります**。Androidはこの証明書を使用してアプリの著者を識別します。
* デバイスでアプリを実行するには、アプリケーションが適切に署名されているかどうかをパッケージマネージャが確認します。アプリケーションがAPKファイル内の証明書で適切に署名されているかどうかを確認します。
* アプリケーションは自己署名されるか、CAを介して署名されるかのどちらかです。
* アプリケーションの署名により、アプリケーションが他のアプリケーションにアクセスできないようになり、明確に定義されたIPCを介してのみアクセスできるようになり、また変更されずにデバイスに渡されることが保証されます。

### **アプリケーション検証**

* Android 4.2以降はアプリケーション検証をサポートしています。ユーザーは「アプリの検証」を有効にして、インストール前にアプリケーション検証プログラムによってアプリケーションが評価されるように選択できます。
* アプリケーション検証は、有害かもしれないアプリをインストールしようとした場合にユーザーに警告を表示できます。アプリケーションが特に悪質な場合、インストールをブロックすることもできます。

## モバイルデバイス管理

MDMまたはモバイルデバイス管理は、モバイルデバイス上での**制御とセキュリティ要件を確保**するために使用されるソフトウェアスイートです。これらのスイートは、デバイス管理APIと呼ばれる機能を使用し、Androidアプリのインストールが必要です。

一般的に、MDMソリューションはパスワードポリシーの強制、ストレージの暗号化の強制、デバイスデータのリモート消去の有効化などの機能を実行します。
