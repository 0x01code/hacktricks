# Βασικά Εφαρμογών Android

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Red Team του HackTricks AWS)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα **HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Μοντέλο Ασφάλειας Android

**Υπάρχουν δύο επίπεδα:**

* Το **Λειτουργικό Σύστημα (OS)**, το οποίο διατηρεί τις εγκατεστημένες εφαρμογές απομονωμένες μεταξύ τους.
* Η **ίδια η εφαρμογή**, η οποία επιτρέπει στους προγραμματιστές να **εκθέτουν ορισμένες λειτουργίες** και να διαμορφώνουν τις δυνατότητες της εφαρμογής.

### Διαχωρισμός UID

**Κάθε εφαρμογή ανατίθεται ένα συγκεκριμένο User ID**. Αυτό γίνεται κατά την εγκατάσταση της εφαρμογής ώστε **η εφαρμογή να μπορεί να αλληλεπιδρά μόνο με αρχεία που ανήκουν στο User ID της ή με κοινά** αρχεία. Συνεπώς, μόνο η εφαρμογή, κάποια στοιχεία του OS και ο ριζικός χρήστης μπορούν να έχουν πρόσβαση στα δεδομένα των εφαρμογών.

### Διαμοιρασμός UID

**Δύο εφαρμογές μπορούν να ρυθμιστούν να χρησιμοποιούν το ίδιο UID**. Αυτό μπορεί να είναι χρήσιμο για να μοιραστούν πληροφορίες, αλλά αν μία από αυτές διαρρεύσει, τα δεδομένα και των δύο εφαρμογών θα διαρρεύσουν. Γι' αυτό η συμπεριφορά αυτή είναι **αποθαρρυντική**.\
**Για να μοιράζονται το ίδιο UID, οι εφαρμογές πρέπει να ορίσουν την ίδια τιμή `android:sharedUserId` στα μεταδεδομένα τους.**

### Αμμοθυρίωση

Το **Αμμοθυρίωμα της Εφαρμογής Android** επιτρέπει την εκτέλεση **κάθε εφαρμογής** ως ένα **ξεχωριστό διεργασία υπό ένα διαφορετικό User ID**. Κάθε διεργασία έχει τη δική της εικονική μηχανή, έτσι ο κώδικας μιας εφαρμογής εκτελείται απομονωμένα από άλλες εφαρμογές.\
Από το Android 5.0(L) εφαρμόζεται το **SELinux**. Βασικά, το SELinux απαγόρευε όλες τις αλληλεπιδράσεις διεργασιών και στη συνέχεια δημιούργησε πολιτικές για να **επιτρέψει μόνο τις αναμενόμενες αλληλεπιδράσεις μεταξύ τους**.

### Δικαιώματα

Όταν εγκαθιστάτε μια **εφαρμογή και σας ζητά δικαιώματα**, η εφαρμογή ζητά τα δικαιώματα που έχουν διαμορφωθεί στα στοιχεία **`uses-permission`** στο αρχείο **AndroidManifest.xml**. Το στοιχείο **uses-permission** υποδεικνύει το όνομα του ζητούμενου δικαιώματος μέσα στο **όνομα** **χαρακτηριστικό.** Έχει επίσης το χαρακτηριστικό **maxSdkVersion** που σταματά το αίτημα δικαιωμάτων σε εκδόσεις υψηλότερες από αυτήν που καθορίζεται.\
Σημειώστε ότι οι εφαρμογές Android δεν χρειάζεται να ζητήσουν όλα τα δικαιώματα από την αρχή, μπορούν επίσης **να ζητήσουν δικαιώματα δυναμικά** αλλά όλα τα δικαιώματα πρέπει να **δηλωθούν** στο **μεταδεδομένα.**

Όταν μια εφαρμογή εκθέτει λειτουργικότητα, μπορεί να περιορίσει την **πρόσβαση μόνο σε εφαρμογές που έχουν ένα συγκεκριμένο δικαίωμα**.\
Ένα στοιχείο δικαιώματος έχει τρία χαρακτηριστικά:

* Το **όνομα** του δικαιώματος
* Το χαρακτηριστικό **permission-group**, που επιτρέπει την ομαδοποίηση σχετικών δικαιωμάτων.
* Το **επίπεδο προστασίας** που υποδεικνύει πώς χορηγούνται τα δικαιώματα. Υπάρχουν τέσσερα είδη:
* **Κανονικό**: Χρησιμοποιείται όταν δεν υπάρχουν **γνωστές απειλές** για την εφαρμογή. Δεν απαιτείται η έγκριση του χρήστη.
* **Επικίνδυνο**: Υποδεικνύει ότι το δικαίωμα χορηγεί στην αιτούσα εφαρμογή κάποια **υψηλότερη πρόσβαση**. **Οι χρήστες καλούνται να τα εγκρίνουν**.
* **Υπογραφή**: Μόνο **εφαρμογές που έχουν υπογραφεί από τον ίδιο πιστοποιητικό με αυτόν** που εξάγει το στοιχείο μπορούν να χορηγηθούν δικαιώματα. Αυτό είναι το ισχυρότερο επίπεδο προστασίας.
* **ΥπογραφήΉΣύστημα**: Μόνο **εφαρμογές που έχουν υπογραφεί από τον ίδιο πιστοποιητικό με αυτόν** που εξάγει το στοιχείο ή **εφαρμογές που λειτουργούν με επίπεδο πρόσβασης συστήματος** μπορούν να χορηγηθούν δικαιώματα

## Προεγκατεστημένες Εφαρμογές

Αυτές οι εφαρμογές βρίσκονται συνήθως στους καταλόγους **`/system/app`** ή **`/system/priv-app`** και κάποιες από αυτές είναι **βελτιστοποιημένες** (μπορεί να μην βρείτε καν το αρχείο `classes.dex`). Αξίζει να ελέγξετε αυτές τις εφαρμογές επειδή μερικές φορές τρέχουν με **πάρα πολλά δικαιώματα** (ως ριζικός χρήστης).

* Αυτές που παρέχονται με το **AOSP** (Android OpenSource Project) **ROM**
* Προστέθηκαν από τον **κατασκευαστή της συσκευής**
* Προστέθηκαν από τον πάροχο **κινητής τηλεφωνίας** (αν αγοράστηκε από αυτούς)

## Rooting

Για να αποκτήσετε ριζική πρόσβαση σε μια φυσική συσκευή Android, γενικά χρειάζεται να **εκμεταλλευτείτε** 1 ή 2 **ευπάθειες** που συνήθως είναι **συγκεκριμένες** για τη **συσκευή** και τη **έκδοση**.\
### **Dalvik & Smali**

Στην ανάπτυξη Android, χρησιμοποιείται **Java ή Kotlin** για τη δημιουργία εφαρμογών. Αντί να χρησιμοποιεί το JVM όπως στις εφαρμογές επιφάνειας εργασίας, το Android μεταγλωττίζει αυτόν τον κώδικα σε **Dalvik Executable (DEX) bytecode**. Παλαιότερα, η εικονική μηχανή Dalvik χειριζόταν αυτόν τον bytecode, αλλά τώρα, η Android Runtime (ART) αναλαμβάνει σε νεότερες εκδόσεις Android.

Για την ανάστροφη μηχανική, το **Smali** γίνεται κρίσιμο. Είναι η αναγνώσιμη από ανθρώπους έκδοση του DEX bytecode, λειτουργώντας όπως η γλώσσα συναρμολόγησης μεταφράζοντας τον πηγαίο κώδικα σε εντολές bytecode. Το Smali και το baksmali αναφέρονται στα εργαλεία συναρμολόγησης και αποσυναρμολόγησης σε αυτό το πλαίσιο.

## Intents

Τα Intents είναι ο κύριος τρόπος με τον οποίο οι εφαρμογές Android επικοινωνούν μεταξύ των συστατικών τους ή με άλλες εφαρμογές. Αυτά τα αντικείμενα μηνυμάτων μπορούν επίσης να μεταφέρουν δεδομένα μεταξύ εφαρμογών ή στοιχείων, παρόμοια με τον τρόπο με τον οποίο χρησιμοποιούνται οι αιτήσεις GET/POST στις επικοινωνίες HTTP.

Έτσι, ένα Intent είναι βασικά ένα **μήνυμα που περνάει μεταξύ συστατικών**. Τα Intents **μπορούν να κατευθυνθούν** σε συγκεκριμένα στοιχεία ή εφαρμογές, **ή να σταλούν χωρίς συγκεκριμένο παραλήπτη**.\
Για να είναι απλό, το Intent μπορεί να χρησιμοποιηθεί:

* Για να ξεκινήσει μια Δραστηριότητα, συνήθως ανοίγοντας μια διεπαφή χρήστη για μια εφαρμογή
* Ως μεταδόσεις για να ενημερώσουν το σύστημα και τις εφαρμογές για αλλαγές
* Για να ξεκινήσει, να σταματήσει και να επικοινωνήσει με ένα υπόβαθρο υπηρεσία
* Για πρόσβαση σε δεδομένα μέσω ContentProviders
* Ως κλήσεις πίσω για την χειρισμό συμβάντων

Εάν είναι ευάλωτα, τα **Intents μπορούν να χρησιμοποιηθούν για να πραγματοποιήσουν μια ποικιλία επιθέσεων**.

### Intent-Filter

Τα **Intent Filters** ορίζουν **πώς μια δραστηριότητα, υπηρεσία ή Δέκτης Μετάδοσης μπορεί να αλληλεπιδράσει με διαφορετικούς τύπους Intents**. Βασικά, περιγράφουν τις δυνατότητες αυτών των στοιχείων, όπως ποιες ενέργειες μπορούν να εκτελέσουν ή τι είδους μεταδόσεις μπορούν να επεξεργαστούν. Ο κύριος τρόπος να δηλωθούν αυτά τα φίλτρα είναι μέσα στο **αρχείο AndroidManifest.xml**, αν και για τους Δέκτες Μετάδοσης, η κωδικοποίησή τους είναι επίσης μια επιλογή.

Τα Intent Filters αποτελούνται από κατηγορίες, ενέργειες και φίλτρα δεδομένων, με τη δυνατότητα συμπερίληψης επιπλέον μεταδεδομένων. Αυτή η ρύθμιση επιτρέπει στα στοιχεία να χειριστούν συγκεκριμένα Intents που ταιριάζουν με τα δηλωμένα κριτήρια.

Ένα κρίσιμο στοιχείο των στοιχείων Android (δραστηριότητες/υπηρεσίες/παρόχοι περιεχομένου/δέκτες μετάδοσης) είναι η ορατότητά τους ή **δημόσια κατάσταση**. Ένα στοιχείο θεωρείται δημόσιο και μπορεί να αλληλεπιδρά με άλλες εφαρμογές εάν είναι **`εξαγόμενο`** με μια τιμή **`true`** ή αν έχει δηλωθεί ένα Intent Filter για αυτό στον προσανατολισμό. Ωστόσο, Ͽαρχει ένας τρόπος για τους προγραμματιστές να κρατήσουν αυτά τα στοιχεία ιδιωτικά ρητά, εξασφαλίζοντας ότι δεν θα αλληλεπιδράν με άλλες εφαρμογές ακούσια. Αυτό επιτυγχάνεται με την ρύθμιση του χαρακτηριστικού **`εξαγόμενο`** σε **`false`** στις ορισμούς τους στον προσανατολισμό τους.

Επιπλέον, οι προγραμματιστές έχουν τη δυνατότητα να ασφαλίσουν περαιτέρω την πρόσβαση σε αυτά τα στοιχεία απαιτώντας συγκεκριμένες άδειες. Το χαρακτηριστικό **`άδεια`** μπορεί να οριστεί για να επιβάλει ότι μόνο οι εφαρμογές με την καθορισμένη άδεια μπορούν να έχουν πρόσβαση στο στοιχείο, προσθέτοντας ένα επιπλέον επίπεδο ασφάλειας και έλεγχο πάνω σε ποιος μπορεί να αλληλεπιδρά με αυτό.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Συμπεριληπτικές Προθέσεις

Οι προθέσεις δημιουργούνται προγραμματικά χρησιμοποιώντας έναν κατασκευαστή Πρόθεσης:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
Η **Ενέργεια** της προηγουμένως δηλωμένης πρόθεσης είναι **ACTION\_SEND** και το **Επιπλέον** είναι ένα mailto **Uri** (το Επιπλέον είναι η επιπλέον πληροφορία που αναμένει η πρόθεση).

Αυτή η πρόθεση πρέπει να δηλωθεί μέσα στον πίνακα όπως στο παρακάτω παράδειγμα:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Ένα intent-filter χρειάζεται να ταιριάζει την **action**, **data** και **category** για να λάβει ένα μήνυμα.

Η διαδικασία "Επίλυση Intent" καθορίζει ποια εφαρμογή θα πρέπει να λάβει κάθε μήνυμα. Αυτή η διαδικασία λαμβάνει υπόψη το **προτεραιότητας attribute**, το οποίο μπορεί να οριστεί στη δήλωση του **intent-filter**, και **επιλέγεται αυτό με τη μεγαλύτερη προτεραιότητα**. Αυτή η προτεραιότητα μπορεί να οριστεί μεταξύ -1000 και 1000 και οι εφαρμογές μπορούν να χρησιμοποιήσουν την τιμή `SYSTEM_HIGH_PRIORITY`. Αν προκύψει **σύγκρουση**, εμφανίζεται ένα παράθυρο "επιλογής" ώστε ο **χρήστης να αποφασίσει**.

### Σαφή Intents

Ένα σαφές intent καθορίζει το όνομα της κλάσης που στοχεύει:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Σε άλλες εφαρμογές για να έχετε πρόσβαση στο προηγουμένως δηλωμένο intent μπορείτε να χρησιμοποιήσετε:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Ενέργειες σε εκκρεμείς προθέσεις

Αυτές επιτρέπουν σε άλλες εφαρμογές να **εκτελούν ενέργειες εκ μέρους της εφαρμογής σας**, χρησιμοποιώντας την ταυτότητα και τις άδειες της εφαρμογής σας. Κατά τη δημιουργία μιας εκκρεμούς πρόθεσης πρέπει να **καθοριστεί μια πρόθεση και η ενέργεια που πρέπει να εκτελεστεί**. Αν η **δηλωμένη πρόθεση δεν είναι Σαφής** (δεν δηλώνει ποια πρόθεση μπορεί να την καλέσει), μια **κακόβουλη εφαρμογή μπορεί να εκτελέσει τη δηλωμένη ενέργεια** εκ μέρους της εφαρμογής θύματος. Επιπλέον, **αν δεν καθοριστεί μια ενέργεια**, η κακόβουλη εφαρμογή θα μπορεί να κάνει **οποιαδήποτε ενέργεια εκ μέρους του θύματος**.

### Εκπομπές Προθέσεων

Σε αντίθεση με τις προηγούμενες προθέσεις, οι οποίες λαμβάνονται μόνο από μία εφαρμογή, οι εκπομπές προθέσεων **μπορούν να ληφθούν από πολλές εφαρμογές**. Ωστόσο, από την έκδοση API 14, είναι **δυνατό να καθοριστεί η εφαρμογή που πρέπει να λάβει** το μήνυμα χρησιμοποιώντας το Intent.set Package.

Εναλλακτικά, είναι επίσης δυνατό να **καθοριστεί μια άδεια κατά την αποστολή της εκπομπής**. Η εφαρμογή παραλήπτης θα πρέπει να έχει αυτήν την άδεια.

Υπάρχουν **δύο τύποι** Εκπομπών: **Κανονικές** (ασύγχρονες) και **Ταξινομημένες** (σύγχρονες). Η **σειρά** βασίζεται στη **διαμορφωμένη προτεραιότητα εντός του στοιχείου παραλήπτη**. **Κάθε εφαρμογή μπορεί να επεξεργαστεί, να μεταδώσει ή να απορρίψει την Εκπομπή.**

Είναι δυνατό να **στείλετε** μια **εκπομπή** χρησιμοποιώντας τη συνάρτηση `sendBroadcast(intent, receiverPermission)` από την κλάση `Context`.\
Μπορείτε επίσης να χρησιμοποιήσετε τη συνάρτηση **`sendBroadcast`** από το **`LocalBroadCastManager`** εξασφαλίζοντας ότι το **μήνυμα δεν αφήνει ποτέ την εφαρμογή**. Χρησιμοποιώντας αυτό, ακόμα και δεν θα χρειαστεί να εξαγάγετε ένα στοιχείο παραλήπτη.

### Κολλώδεις Εκπομπές

Αυτού του είδους οι Εκπομπές **μπορούν να ανακτηθούν πολύ καιρό μετά την αποστολή τους**.\
Αυτές αποσύρθηκαν στην έκδοση API επιπέδου 21 και συνιστάται να **μην χρησιμοποιούνται**.\
**Επιτρέπουν σε οποιαδήποτε εφαρμογή να κατασκοπεύσει τα δεδομένα, αλλά και να τα τροποποιήσει.**

Αν βρείτε συναρτήσεις που περιέχουν τη λέξη "κολλώδεις" όπως **`sendStickyBroadcast`** ή **`sendStickyBroadcastAsUser`**, **ελέγξτε τις επιπτώσεις και προσπαθήστε να τις αφαιρέσετε**.

## Βαθιοί σύνδεσμοι / Σχήματα URL

Στις εφαρμογές Android, οι **βαθιοί σύνδεσμοι** χρησιμοποιούνται για να εκκινήσουν μια ενέργεια (Πρόθεση) απευθείας μέσω ενός URL. Αυτό γίνεται δηλώνοντας ένα συγκεκριμένο **σχήμα URL** εντός μιας δραστηριότητας. Όταν μια συσκευή Android προσπαθεί να **έχει πρόσβαση σε ένα URL με αυτό το σχήμα**, η συγκεκριμένη δραστηριότητα εντός της εφαρμογής εκκινείται.

Το σχήμα πρέπει να δηλωθεί στο αρχείο **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Το σχήμα από το προηγούμενο παράδειγμα είναι `exampleapp://` (σημειώστε επίσης τη **`κατηγορία BROWSABLE`**)

Στο πεδίο δεδομένων, μπορείτε να καθορίσετε το **host** και τη **διαδρομή**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Για να έχετε πρόσβαση μέσω ιστοσελίδας είναι δυνατόν να ορίσετε ένα σύνδεσμο όπως:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Για να βρείτε τον **κώδικα που θα εκτελεστεί στην εφαρμογή**, πηγαίνετε στη δραστηριότητα που καλείται από το deeplink και αναζητήστε τη συνάρτηση **`onNewIntent`**.

Μάθετε πώς να [καλείτε deep links χωρίς τη χρήση σελίδων HTML](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

Η **Γλώσσα Ορισμού Διεπαφής Android (AIDL)** σχεδιάστηκε για τη διευκόλυνση της επικοινωνίας μεταξύ πελάτη και υπηρεσίας σε εφαρμογές Android μέσω **διαδικασίας μεταξύ διεργασιών** (IPC). Δεδομένου ότι η πρόσβαση απευθείας στη μνήμη μιας άλλης διεργασίας δεν επιτρέπεται στο Android, η AIDL απλοποιεί τη διαδικασία με το να μετατρέπει αντικείμενα σε ένα μορφότυπο που κατανοεί το λειτουργικό σύστημα, διευκολύνοντας έτσι την επικοινωνία μεταξύ διαφορετικών διεργασιών.

### Βασικές Έννοιες

- **Υπηρεσίες που είναι συνδεδεμένες**: Αυτές οι υπηρεσίες χρησιμοποιούν την AIDL για IPC, επιτρέποντας σε δραστηριότητες ή στοιχεία να συνδέονται με μια υπηρεσία, να κάνουν αιτήσεις και να λαμβάνουν απαντήσεις. Η μέθοδος `onBind` στην κλάση της υπηρεσίας είναι κρίσιμη για την έναρξη της αλληλεπίδρασης, καθιστώντας την έναν ζωτικό τομέα για αναθεώρηση ασφάλειας ώστε να αναζητηθούν ευπάθειες.

- **Messenger**: Λειτουργώντας ως συνδεδεμένη υπηρεσία, ο Messenger διευκολύνει το IPC με έμφαση στην επεξεργασία δεδομένων μέσω της μεθόδου `onBind`. Είναι ουσιώδες να ελέγξετε προσεκτικά αυτήν τη μέθοδο για οποιαδήποτε μη ασφαλή χειρισμό δεδομένων ή εκτέλεση ευαίσθητων λειτουργιών.

- **Binder**: Παρόλο που η άμεση χρήση της κλάσης Binder είναι λιγότερο συνηθισμένη λόγω της αφαίρεσης της AIDL, είναι χρήσιμο να κατανοήσετε ότι ο Binder λειτουργεί ως οδηγός σε επίπεδο πυρήνα που διευκολύνει τη μεταφορά δεδομένων μεταξύ των χώρων μνήμης διαφορετικών διεργασιών. Για περισσότερη κατανόηση, υπάρχει ένας πόρος στο [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Στοιχεία

Αυτά περιλαμβάνουν: **Δραστηριότητες, Υπηρεσίες, Δέκτες Εκπομπής και Παροχείς.**

### Δραστηριότητες εκκίνησης και άλλες δραστηριότητες

Στις εφαρμογές Android, οι **δραστηριότητες** είναι σαν οθόνες, εμφανίζοντας διαφορετικά τμήματα της διεπαφής χρήστη της εφαρμογής. Μια εφαρμογή μπορεί να έχει πολλές δραστηριότητες, καθεμία παρουσιάζοντας μια μοναδική οθόνη στον χρήστη.

Η **δραστηριότητα εκκίνησης** είναι η κύρια πύλη εισόδου σε μια εφαρμογή, εκκινούμενη όταν πατάτε το εικονίδιο της εφαρμογής. Ορίζεται στο αρχείο με τις δηλώσεις της εφαρμογής με συγκεκριμένες προθέσεις MAIN και LAUNCHER:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Δεν όλες οι εφαρμογές χρειάζονται μια δραστηριότητα εκκίνησης, ειδικά αυτές που δεν έχουν διεπαφή χρήστη, όπως οι υπηρεσίες φόντου.

Οι δραστηριότητες μπορούν να γίνουν διαθέσιμες σε άλλες εφαρμογές ή διεργασίες επισημαίνοντάς τες ως "εξαγωγή" στον πίνακα. Αυτή η ρύθμιση επιτρέπει σε άλλες εφαρμογές να ξεκινήσουν αυτήν τη δραστηριότητα:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ωστόσο, η πρόσβαση σε μια δραστηριότητα από μια άλλη εφαρμογή δεν αποτελεί πάντα κίνδυνο για την ασφάλεια. Η ανησυχία προκύπτει εάν ευαίσθητα δεδομένα κοινοποιούνται εσφαλμένα, κάτι που θα μπορούσε να οδηγήσει σε διαρροές πληροφοριών.

Η διαδικασία ζωής μιας δραστηριότητας **ξεκινά με τη μέθοδο onCreate**, δημιουργώντας το UI και προετοιμάζοντας τη δραστηριότητα για αλληλεπίδραση με τον χρήστη.

### Υποκλάση Εφαρμογής

Στην ανάπτυξη Android, μια εφαρμογή έχει τη δυνατότητα να δημιουργήσει μια **υποκλάση** της [Κλάσης Εφαρμογής](https://developer.android.com/reference/android/app/Application), αν και δεν είναι υποχρεωτικό. Όταν ορίζεται μια τέτοια υποκλάση, γίνεται η πρώτη κλάση που δημιουργείται στην εφαρμογή. Η μέθοδος **`attachBaseContext`**, εάν υλοποιηθεί σε αυτή την υποκλάση, εκτελείται πριν τη μέθοδο **`onCreate`**. Αυτή η ρύθμιση επιτρέπει την πρώιμη αρχικοποίηση πριν ξεκινήσει η υπόλοιπη εφαρμογή.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Υπηρεσίες

[Οι υπηρεσίες](https://developer.android.com/guide/components/services) είναι **φόντο λειτουργοί** ικανοί να εκτελούν εργασίες χωρίς διεπαφή χρήστη. Αυτές οι εργασίες μπορούν να συνεχίσουν να εκτελούνται ακόμα και όταν οι χρήστες μεταβαίνουν σε διαφορετικές εφαρμογές, κάνοντας τις υπηρεσίες κρίσιμες για **εργασίες με μεγάλη διάρκεια**.

Οι υπηρεσίες είναι ευέλικτες. Μπορούν να εκκινηθούν με διάφορους τρόπους, με τα **Intents** να είναι ο κύριος τρόπος εκκίνησής τους ως σημείο εισόδου μιας εφαρμογής. Μόλις μια υπηρεσία ξεκινήσει χρησιμοποιώντας τη μέθοδο `startService`, η μέθοδος `onStart` της ενεργοποιείται και συνεχίζει να εκτελείται μέχρι να κληθεί εκ των υστέρων η μέθοδος `stopService`. Εναλλακτικά, αν ο ρόλος μιας υπηρεσίας εξαρτάται από μια ενεργή σύνδεση πελάτη, χρησιμοποιείται η μέθοδος `bindService` για τη σύνδεση του πελάτη με την υπηρεσία, ενεργοποιώντας τη μέθοδο `onBind` για τη μετάδοση δεδομένων.

Ένα ενδιαφέρον παράδειγμα χρήσης των υπηρεσιών περιλαμβάνει την αναπαραγωγή μουσικής στο φόντο ή τη λήψη δεδομένων δικτύου χωρίς να εμποδίζεται η αλληλεπίδραση του χρήστη με μια εφαρμογή. Επιπλέον, οι υπηρεσίες μπορούν να γίνουν προσβάσιμες σε άλλες διεργασίες στην ίδια συσκευή μέσω της **εξαγωγής**. Αυτή δεν είναι η προεπιλεγμένη συμπεριφορά και απαιτεί σαφή ρύθμιση στο αρχείο Android Manifest:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Ανακοινωτές Εκπομπής

Οι **ανακοινωτές εκπομπής** λειτουργούν ως ακροατές σε ένα σύστημα μηνυμάτων, επιτρέποντας σε πολλές εφαρμογές να ανταποκριθούν στα ίδια μηνύματα από το σύστημα. Μια εφαρμογή μπορεί να **καταχωρήσει έναν ανακοινωτή** με **δύο κύριους τρόπους**: μέσω του **Μανιφέστου** της εφαρμογής ή **δυναμικά** μέσα στον κώδικα της εφαρμογής μέσω του API **`registerReceiver`**. Στο Μανιφέστο, οι εκπομπές φιλτράρονται με δικαιώματα, ενώ οι δυναμικά καταχωρημένοι ανακοινωτές μπορούν επίσης να καθορίσουν δικαιώματα κατά την καταχώρηση.

Οι **φίλτρα Intent** είναι κρίσιμα σε και τους δύο τρόπους καταχώρησης, καθορίζοντας ποιες εκπομπές ενεργοποιούν τον ανακοινωτή. Μόλα που στάλθηκε μια αντιστοιχίζουσα εκπομπή, ενεργοποιείται η μέθοδος **`onReceive`** του ανακοινωτή, επιτρέποντας στην εφαρμογή να αντιδράσει ανάλογα, όπως προσαρμογή της συμπεριφοράς σε απάντηση σε μια ειδοποίηση χαμηλής μπαταρίας.

Οι εκπομπές μπορούν να είναι είτε **ασύγχρονες**, φτάνοντας σε όλους τους ανακοινωτές χωρίς σειρά, είτε **σύγχρονες**, όπου οι ανακοινωτές λαμβάνουν την εκπομπή με βάση τις καθορισμένες προτεραιότητες. Ωστόσο, είναι σημαντικό να σημειωθεί ο δυνητικός κίνδυνος για την ασφάλεια, καθώς οποιαδήποτε εφαρμογή μπορεί να δώσει προτεραιότητα στον εαυτό της για να παρεμβαίνει σε μια εκπομπή.

Για να κατανοήσετε τη λειτουργικότητα ενός ανακοινωτή, αναζητήστε τη μέθοδο **`onReceive`** μέσα στην κλάση του. Ο κώδικας αυτής της μεθόδου μπορεί να χειριστεί το ληφθέν Intent, υπογραμμίζοντας την ανάγκη επικύρωσης δεδομένων από τους ανακοινωτές, ειδικά σε **Ταξινομημένες Εκπομπές**, οι οποίες μπορούν να τροποποιήσουν ή να απορρίψουν το Intent.

### Πάροχοι Περιεχομένου

Οι **Πάροχοι Περιεχομένου** είναι ουσιώδεις για το **διαμοιρασμό δομημένων δεδομένων** μεταξύ εφαρμογών, τονίζοντας τη σημασία της υλοποίησης **δικαιωμάτων** για να διασφαλιστεί η ασφάλεια των δεδομένων. Επιτρέπουν στις εφαρμογές να έχουν πρόσβαση σε δεδομένα από διάφορες πηγές, συμπεριλαμβανομένων βάσεων δεδομένων, συστημάτων αρχείων ή του web. Ειδικά δικαιώματα, όπως **`readPermission`** και **`writePermission`**, είναι κρίσιμα για τον έλεγχο της πρόσβασης. Επιπλέον, μπορεί να χορηγηθεί προσωρινή πρόσβαση μέσω ρυθμίσεων **`grantUriPermission`** στο μανιφέστο της εφαρμογής, εκμεταλλευόμενο χαρακτηριστικά όπως `path`, `pathPrefix` και `pathPattern` για λεπτομερή έλεγχο πρόσβασης.

Η επικύρωση εισόδου είναι ζωτικής σημασίας για την πρόληψη ευπαθειών, όπως η εισχώρηση SQL. Οι Πάροχοι Περιεχομένου υποστηρίζουν βασικές λειτουργίες: `insert()`, `update()`, `delete()` και `query()`, διευκολύνοντας τη διαχείριση δεδομένων και τον διαμοιρασμό μεταξύ εφαρμογών.

**FileProvider**, ένας εξειδικευμένος Πάροχος Περιεχομένου, επικεντρώνεται στον ασφαλή διαμοιρασμό αρχείων. Ορίζεται στο μανιφέστο της εφαρμογής με συγκεκριμένα χαρακτηριστικά για τον έλεγχο της πρόσβασης σε φακέλους, που υποδεικνύονται από τα `android:exported` και `android:resource` που δείχνουν σε ρυθμίσεις φακέλων. Συνιστάται προσοχή κατά τον διαμοιρασμό καταλόγων για να αποφευχθεί η αποκάλυψη ευαίσθητων δεδομένων κατά λάθος.

Παράδειγμα δήλωσης μανιφέστου για το FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Και ένα παράδειγμα καθορισμού κοινόχρηστων φακέλων στο `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Για περισσότερες πληροφορίες ελέγξτε:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

Τα WebViews είναι σαν **μικροί web browsers** μέσα σε εφαρμογές Android, εμφανίζοντας περιεχόμενο είτε από το web είτε από τοπικά αρχεία. Αντιμετωπίζουν παρόμοιους κινδύνους με τους κανονικούς browsers, ωστόσο υπάρχουν τρόποι για να **μειωθούν αυτοί οι κίνδυνοι** μέσω συγκεκριμένων **ρυθμίσεων**.

Το Android προσφέρει δύο κύριους τύπους WebView:

- Ο **WebViewClient** είναι ιδανικός για βασικό HTML αλλά δεν υποστηρίζει τη λειτουργία ειδοποίησης JavaScript, επηρεάζοντας τον τρόπο που μπορούν να δοκιμαστούν οι επιθέσεις XSS.
- Ο **WebChromeClient** λειτουργεί περισσότερο σαν την πλήρη εμπειρία του πλοηγού Chrome.

Ένα σημαντικό σημείο είναι ότι οι WebView browsers **δεν μοιράζονται cookies** με τον κύριο browser της συσκευής.

Για τη φόρτωση περιεχομένου, διατίθενται μέθοδοι όπως η ````loadUrl````, ````loadData```` και ````loadDataWithBaseURL````. Είναι κρίσιμο να εξασφαλίσετε ότι αυτά τα URLs ή αρχεία είναι **ασφαλή για χρήση**. Οι ρυθμίσεις ασφαλείας μπορούν να διαχειριστούν μέσω της κλάσης ````WebSettings````. Για παράδειγμα, η απενεργοποίηση του JavaScript με την εντολή ````setJavaScriptEnabled(false)```` μπορεί να αποτρέψει επιθέσεις XSS.

Η γέφυρα JavaScript επιτρέπει στα αντικείμενα Java να αλληλεπιδρούν με το JavaScript, απαιτώντας οι μέθοδοι να επισημαίνονται με το ````@JavascriptInterface```` για ασφάλεια από το Android 4.2 και μετά.

Η επιτροπή πρόσβασης περιεχομένου (````setAllowContentAccess(true)````) επιτρέπει στις WebViews να φτάσουν τους Content Providers, που θα μπορούσε να αποτελέσει κίνδυνο εκτός αν επαληθευτούν τα URLs του περιεχομένου ως ασφαλή.

Για τον έλεγχο της πρόσβασης σε αρχεία:
- Η απενεργοποίηση της πρόσβασης σε αρχεία (````setAllowFileAccess(false)````) περιορίζει την πρόσβαση στο σύστημα αρχείων, με εξαιρέσεις για συγκεκριμένα assets, εξασφαλίζοντας ότι χρησιμοποιούνται μόνο για μη-ευαίσθητο περιεχόμενο.

## Άλλα Στοιχεία Εφαρμογών και Διαχείρισης Κινητών Συσκευών

### **Ψηφιακή Υπογραφή Εφαρμογών**

- Η **ψηφιακή υπογραφή** είναι απαραίτητη για τις εφαρμογές Android, εξασφαλίζοντας ότι είναι **αυθεντικά υπογεγραμμένες** πριν την εγκατάσταση. Αυτή η διαδικασία χρησιμοποιεί ένα πιστοποιητικό για την ταυτοποίηση της εφαρμογής και πρέπει να επαληθεύεται από τον διαχειριστή πακέτων της συσκευής κατά την εγκατάσταση. Οι εφαρμογές μπορούν να είναι **αυτο-υπογεγραμμένες ή πιστοποιημένες από εξωτερική αρχή**, προστατεύοντας από μη εξουσιοδοτημένη πρόσβαση και εξασφαλίζοντας ότι η εφαρμογή παραμένει αμετάβλητη κατά την παράδοσή της στη συσκευή.

### **Επαλήθευση Εφαρμογών για Ενισχυμένη Ασφάλεια**

- Ξεκινώντας από το **Android 4.2**, μια λειτουργία που ονομάζεται **Επαλήθευση Εφαρμογών** επιτρέπει στους χρήστες να ελέγχουν τις εφαρμογές για ασφάλεια πριν την εγκατάσταση. Αυτή η **διαδικασία επαλήθευσης** μπορεί να προειδοποιήσει τους χρήστες για πιθανά επικίνδυνες εφαρμογές, ή ακόμα και να αποτρέψει την εγκατάσταση ιδιαίτερα κακόβουλων, βελτιώνοντας την ασφάλεια του χρήστη.

### **Διαχείριση Κινητών Συσκευών (MDM)**

- Οι **λύσεις MDM** παρέχουν **επίβλεψη και ασφάλεια** για κινητές συσκευές μέσω του **API Διαχείρισης Συσκευών**. Απαιτούν την εγκατάσταση μιας εφαρμογής Android για την αποτελεσματική διαχείριση και ασφάλιση κινητών συσκευών. Κύριες λειτουργίες περιλαμβάνουν την **επιβολή πολιτικών κωδικών πρόσβασης**, την **υποχρέωση κρυπτογράφησης αποθήκευσης** και την **επιτροπή απομάκρυνσης δεδομένων**, εξασφαλίζοντας πλήρη έλεγχο και ασφάλεια πάνω στις κινητές συσκευές.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**Ομάδα Ασφαλείας Try Hard**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή τη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
