# Conceitos B√°sicos de Aplica√ß√µes Android

<details>

<summary><strong>Aprenda a hackear a AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Modelo de Seguran√ßa Android

**Existem duas camadas:**

* O **SO**, que mant√©m aplicativos instalados isolados uns dos outros.
* O **pr√≥prio aplicativo**, que permite aos desenvolvedores **expor certas funcionalidades** e configurar as capacidades do aplicativo.

### Separa√ß√£o de UID

**Cada aplicativo √© atribu√≠do a um ID de Usu√°rio espec√≠fico**. Isso √© feito durante a instala√ß√£o do aplicativo para que o **aplicativo possa interagir apenas com arquivos de propriedade de seu ID de Usu√°rio ou arquivos compartilhados**. Portanto, apenas o pr√≥prio aplicativo, certos componentes do SO e o usu√°rio root podem acessar os dados dos aplicativos.

### Compartilhamento de UID

**Dois aplicativos podem ser configurados para usar o mesmo UID**. Isso pode ser √∫til para compartilhar informa√ß√µes, mas se um deles for comprometido, os dados de ambos os aplicativos ser√£o comprometidos. Por isso, esse comportamento √© **desencorajado**.\
**Para compartilhar o mesmo UID, os aplicativos devem definir o mesmo valor `android:sharedUserId` em seus manifestos.**

### Isolamento

A **Sandbox de Aplicativos Android** permite executar **cada aplicativo** como um **processo separado sob um ID de usu√°rio separado**. Cada processo tem sua pr√≥pria m√°quina virtual, ent√£o o c√≥digo de um aplicativo √© executado isoladamente de outros aplicativos.\
A partir do Android 5.0(L), o **SELinux** √© aplicado. Basicamente, o SELinux nega todas as intera√ß√µes de processos e ent√£o cria pol√≠ticas para **permitir apenas as intera√ß√µes esperadas entre eles**.

### Permiss√µes

Quando voc√™ instala um **aplicativo e ele solicita permiss√µes**, o aplicativo est√° pedindo as permiss√µes configuradas nos elementos **`uses-permission`** no arquivo **AndroidManifest.xml**. O elemento **uses-permission** indica o nome da permiss√£o solicitada dentro do **atributo de nome**. Ele tamb√©m possui o atributo **maxSdkVersion** que impede a solicita√ß√£o de permiss√µes em vers√µes superiores √† especificada.\
Observe que os aplicativos Android n√£o precisam solicitar todas as permiss√µes no in√≠cio, eles tamb√©m podem **solicitar permiss√µes dinamicamente**, mas todas as permiss√µes devem ser **declaradas** no **manifesto**.

Quando um aplicativo exp√µe funcionalidades, ele pode limitar o **acesso apenas a aplicativos que possuem uma permiss√£o especificada**.\
Um elemento de permiss√£o tem tr√™s atributos:

* O **nome** da permiss√£o
* O atributo **permission-group**, que permite agrupar permiss√µes relacionadas.
* O **n√≠vel de prote√ß√£o** que indica como as permiss√µes s√£o concedidas. Existem quatro tipos:
* **Normal**: Usado quando n√£o h√° **amea√ßas conhecidas** ao aplicativo. O usu√°rio **n√£o precisa aprovar**.
* **Perigoso**: Indica que a permiss√£o concede ao aplicativo solicitante algum **acesso elevado**. **Os usu√°rios s√£o solicitados a aprov√°-los**.
* **Assinatura**: Apenas **aplicativos assinados pelo mesmo certificado que o** exportando o componente podem receber permiss√£o. Este √© o tipo mais forte de prote√ß√£o.
* **AssinaturaOuSistema**: Apenas **aplicativos assinados pelo mesmo certificado que o** exportando o componente ou **aplicativos em execu√ß√£o com acesso de n√≠vel de sistema** podem receber permiss√µes.

## Aplica√ß√µes Pr√©-Instaladas

Esses aplicativos geralmente s√£o encontrados nos diret√≥rios **`/system/app`** ou **`/system/priv-app`** e alguns deles s√£o **otimizados** (voc√™ pode nem encontrar o arquivo `classes.dex`). Esses aplicativos valem a pena verificar porque √†s vezes eles est√£o **executando com muitas permiss√µes** (como root).

* Os que s√£o enviados com o **ROM** do **AOSP** (Projeto de C√≥digo Aberto Android)
* Adicionados pelo **fabricante** do dispositivo
* Adicionados pelo **provedor** de telefonia celular (se comprado deles)

## Root

Para obter acesso root a um dispositivo Android f√≠sico, geralmente √© necess√°rio **explorar** 1 ou 2 **vulnerabilidades** que costumam ser **espec√≠ficas** para o **dispositivo** e **vers√£o**.\
Uma vez que o exploit funcionou, geralmente o bin√°rio `su` do Linux √© copiado para uma localiza√ß√£o especificada na vari√°vel de ambiente PATH do usu√°rio, como `/system/xbin`.

Depois que o bin√°rio su estiver configurado, outro aplicativo Android √© usado para interagir com o bin√°rio `su` e **processar solicita√ß√µes de acesso root** como **Superuser** e **SuperSU** (dispon√≠vel na Google Play Store).

{% hint style="danger" %}
Observe que o processo de root √© muito perigoso e pode danificar gravemente o dispositivo
{% endhint %}

### ROMs

√â poss√≠vel **substituir o SO instalando um firmware personalizado**. Fazendo isso, √© poss√≠vel estender a utilidade de um dispositivo antigo, contornar restri√ß√µes de software ou obter acesso ao c√≥digo Android mais recente.\
**OmniROM** e **LineageOS** s√£o dois dos firmwares mais populares para usar.

Observe que **nem sempre √© necess√°rio fazer root no dispositivo** para instalar um firmware personalizado. **Alguns fabricantes permitem** o desbloqueio de seus carregadores de inicializa√ß√£o de maneira bem documentada e segura.

### Implica√ß√µes

Uma vez que um dispositivo √© rooteado, qualquer aplicativo pode solicitar acesso como root. Se um aplicativo malicioso obtiver, ele ter√° acesso a quase tudo e poder√° danificar o telefone.

## Fundamentos de Aplica√ß√µes Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- O formato de aplicativos Android √© referido como _formato de arquivo APK_. √â essencialmente um **arquivo ZIP** (renomeando a extens√£o do arquivo para .zip, o conte√∫do pode ser extra√≠do e visualizado).
- Conte√∫do do APK (N√£o exaustivo)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: cont√©m recursos pr√©-compilados, como XML bin√°rio.
- res/xml/files\_paths.xml
- META-INF/
- Aqui √© onde o Certificado est√° localizado!
- **classes.dex**
- Cont√©m bytecode Dalvik, representando o c√≥digo Java (ou Kotlin) compilado que o aplicativo executa por padr√£o.
- lib/
- Armazena bibliotecas nativas, segregadas por arquitetura de CPU em subdiret√≥rios.
- `armeabi`: c√≥digo para processadores baseados em ARM
- `armeabi-v7a`: c√≥digo para processadores baseados em ARMv7 e superiores
- `x86`: c√≥digo para processadores X86
- `mips`: c√≥digo apenas para processadores MIPS
- assets/
- Armazena arquivos diversos necess√°rios pelo aplicativo, potencialmente incluindo bibliotecas nativas adicionais ou arquivos DEX, √†s vezes usados por autores de malware para ocultar c√≥digo adicional.
- res/
- Cont√©m recursos que n√£o s√£o compilados em resources.arsc
### **Dalvik & Smali**

Na desenvolvimento Android, **Java ou Kotlin** s√£o usados para criar aplicativos. Em vez de usar o JVM como em aplicativos desktop, o Android compila esse c√≥digo em **Dalvik Executable (DEX) bytecode**. Anteriormente, a m√°quina virtual Dalvik lidava com esse bytecode, mas agora, o Android Runtime (ART) assume em vers√µes mais recentes do Android.

Para engenharia reversa, **Smali** se torna crucial. √â a vers√£o leg√≠vel por humanos do bytecode DEX, atuando como linguagem de montagem ao traduzir o c√≥digo-fonte em instru√ß√µes de bytecode. Smali e baksmali referem-se √†s ferramentas de montagem e desmontagem nesse contexto.

## Intents

Intents s√£o o principal meio pelo qual os aplicativos Android se comunicam entre seus componentes ou com outros aplicativos. Esses objetos de mensagem tamb√©m podem transportar dados entre aplicativos ou componentes, semelhante √† forma como as solicita√ß√µes GET/POST s√£o usadas em comunica√ß√µes HTTP.

Portanto, um Intent √© basicamente uma **mensagem que √© passada entre componentes**. Intents **podem ser direcionados** para componentes ou aplicativos espec√≠ficos, **ou podem ser enviados sem um destinat√°rio espec√≠fico**.\
Para ser simples, um Intent pode ser usado para:

* Iniciar uma Activity, normalmente abrindo uma interface de usu√°rio para um aplicativo
* Como transmiss√µes para informar o sistema e aplicativos sobre altera√ß√µes
* Para iniciar, parar e comunicar-se com um servi√ßo em segundo plano
* Para acessar dados por meio de ContentProviders
* Como callbacks para lidar com eventos

Se vulner√°veis, **Intents podem ser usados para realizar uma variedade de ataques**.

### Intent-Filter

**Intent Filters** definem **como uma atividade, servi√ßo ou Broadcast Receiver pode interagir com diferentes tipos de Intents**. Essencialmente, eles descrevem as capacidades desses componentes, como quais a√ß√µes podem executar ou os tipos de transmiss√µes que podem processar. O local principal para declarar esses filtros √© dentro do arquivo **AndroidManifest.xml**, embora para Broadcast Receivers, codific√°-los tamb√©m seja uma op√ß√£o.

Os Intent Filters s√£o compostos por categorias, a√ß√µes e filtros de dados, com a possibilidade de incluir metadados adicionais. Essa configura√ß√£o permite que os componentes lidem com Intents espec√≠ficos que correspondam aos crit√©rios declarados.

Um aspecto cr√≠tico dos componentes Android (atividades/servi√ßos/content providers/broadcast receivers) √© sua visibilidade ou **status p√∫blico**. Um componente √© considerado p√∫blico e pode interagir com outros aplicativos se for **`exported`** com um valor de **`true`** ou se um Intent Filter for declarado para ele no manifesto. No entanto, os desenvolvedores t√™m a op√ß√£o de manter explicitamente esses componentes privados, garantindo que n√£o interajam com outros aplicativos inadvertidamente. Isso √© alcan√ßado definindo o atributo **`exported`** como **`false`** em suas defini√ß√µes de manifesto.

Al√©m disso, os desenvolvedores t√™m a op√ß√£o de garantir ainda mais o acesso a esses componentes exigindo permiss√µes espec√≠ficas. O atributo **`permission`** pode ser definido para garantir que apenas aplicativos com a permiss√£o designada possam acessar o componente, adicionando uma camada extra de seguran√ßa e controle sobre quem pode interagir com ele.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Inten√ß√µes Impl√≠citas

As inten√ß√µes s√£o criadas programaticamente usando um construtor de Inten√ß√µes:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
A **A√ß√£o** do intent previamente declarado √© **ACTION\_SEND** e o **Extra** √© um **Uri** mailto (o Extra √© a informa√ß√£o extra que o intent est√° esperando).

Este intent deve ser declarado dentro do manifesto como no exemplo a seguir:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Um intent-filter precisa corresponder √† **a√ß√£o**, **dados** e **categoria** para receber uma mensagem.

O processo de "resolu√ß√£o de Intent" determina qual aplicativo deve receber cada mensagem. Esse processo considera o atributo de **prioridade**, que pode ser definido na declara√ß√£o do **intent-filter**, e **o que tiver a prioridade mais alta ser√° selecionado**. Essa prioridade pode ser definida entre -1000 e 1000 e os aplicativos podem usar o valor `SYSTEM_HIGH_PRIORITY`. Se surgir um **conflito**, uma janela de "escolha" aparece para que o **usu√°rio possa decidir**.

### Inten√ß√µes Expl√≠citas

Uma inten√ß√£o expl√≠cita especifica o nome da classe que est√° direcionando:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Em outras aplica√ß√µes, para acessar o intent previamente declarado, voc√™ pode usar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Inten√ß√µes Pendentes

Estas permitem que outras aplica√ß√µes **realizem a√ß√µes em nome da sua aplica√ß√£o**, utilizando a identidade e permiss√µes da sua aplica√ß√£o. Ao construir uma Inten√ß√£o Pendente, deve ser **especificada uma inten√ß√£o e a a√ß√£o a ser realizada**. Se a **inten√ß√£o declarada n√£o for Expl√≠cita** (n√£o declara qual inten√ß√£o pode cham√°-la), uma **aplica√ß√£o maliciosa poder√° realizar a a√ß√£o declarada** em nome da aplica√ß√£o da v√≠tima. Al√©m disso, **se uma a√ß√£o n√£o for especificada**, a aplica√ß√£o maliciosa poder√° realizar **qualquer a√ß√£o em nome da v√≠tima**.

### Inten√ß√µes de Transmiss√£o

Ao contr√°rio das inten√ß√µes anteriores, que s√£o recebidas apenas por uma aplica√ß√£o, as inten√ß√µes de transmiss√£o **podem ser recebidas por v√°rias aplica√ß√µes**. No entanto, a partir da vers√£o API 14, √© **poss√≠vel especificar a aplica√ß√£o que deve receber** a mensagem usando Intent.setPackage.

Alternativamente, tamb√©m √© poss√≠vel **especificar uma permiss√£o ao enviar a transmiss√£o**. A aplica√ß√£o receptora precisar√° ter essa permiss√£o.

Existem **dois tipos** de Transmiss√µes: **Normais** (ass√≠ncronas) e **Ordenadas** (s√≠ncronas). A **ordem** √© baseada na **prioridade configurada dentro do receptor**. **Cada aplica√ß√£o pode processar, retransmitir ou descartar a Transmiss√£o**.

√â poss√≠vel **enviar** uma **transmiss√£o** usando a fun√ß√£o `sendBroadcast(intent, receiverPermission)` da classe `Context`.\
Tamb√©m √© poss√≠vel usar a fun√ß√£o **`sendBroadcast`** do **`LocalBroadCastManager`** para garantir que a **mensagem nunca saia da aplica√ß√£o**. Usando isso, nem ser√° necess√°rio exportar um componente receptor.

### Transmiss√µes Persistentes

Este tipo de Transmiss√µes **pode ser acessado muito tempo ap√≥s serem enviadas**.\
Estas foram descontinuadas no n√≠vel da API 21 e √© recomendado **n√£o utiliz√°-las**.\
**Elas permitem que qualquer aplica√ß√£o espie os dados, mas tamb√©m os modifique**.

Se encontrar fun√ß√µes contendo a palavra "persistentes" como **`sendStickyBroadcast`** ou **`sendStickyBroadcastAsUser`**, **verifique o impacto e tente remov√™-las**.

## Links Profundos / Esquemas de URL

Nas aplica√ß√µes Android, os **links profundos** s√£o utilizados para iniciar uma a√ß√£o (Inten√ß√£o) diretamente atrav√©s de um URL. Isso √© feito ao declarar um **esquema de URL espec√≠fico** dentro de uma atividade. Quando um dispositivo Android tenta **acessar um URL com este esquema**, a atividade especificada dentro da aplica√ß√£o √© iniciada.

O esquema deve ser declarado no arquivo **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
O esquema do exemplo anterior √© `exampleapp://` (observe tamb√©m a **`categoria BROWSABLE`**)

Em seguida, no campo de dados, voc√™ pode especificar o **host** e o **caminho**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Para acess√°-lo a partir de um site, √© poss√≠vel definir um link como:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Para encontrar o **c√≥digo que ser√° executado no aplicativo**, v√° para a atividade chamada pelo deeplink e procure a fun√ß√£o **`onNewIntent`**.

Saiba como [chamar deep links sem usar p√°ginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Linguagem de Defini√ß√£o de Interface Android

A **Linguagem de Defini√ß√£o de Interface Android (AIDL)** √© projetada para facilitar a comunica√ß√£o entre cliente e servi√ßo em aplicativos Android por meio da **comunica√ß√£o entre processos** (IPC). Como acessar diretamente a mem√≥ria de outro processo n√£o √© permitido no Android, o AIDL simplifica o processo ao empacotar objetos em um formato compreendido pelo sistema operacional, facilitando assim a comunica√ß√£o entre diferentes processos.

### Conceitos Chave

- **Servi√ßos Vinculados**: Esses servi√ßos utilizam AIDL para IPC, permitindo que atividades ou componentes se vinculem a um servi√ßo, fa√ßam solicita√ß√µes e recebam respostas. O m√©todo `onBind` na classe do servi√ßo √© crucial para iniciar a intera√ß√£o, tornando-o uma √°rea vital para revis√£o de seguran√ßa em busca de vulnerabilidades.

- **Messenger**: Funcionando como um servi√ßo vinculado, o Messenger facilita o IPC com foco no processamento de dados por meio do m√©todo `onBind`. √â essencial inspecionar este m√©todo de perto em busca de qualquer manipula√ß√£o de dados insegura ou execu√ß√£o de fun√ß√µes sens√≠veis.

- **Binder**: Embora o uso direto da classe Binder seja menos comum devido √† abstra√ß√£o do AIDL, √© ben√©fico entender que o Binder atua como um driver de n√≠vel de kernel facilitando a transfer√™ncia de dados entre os espa√ßos de mem√≥ria de diferentes processos. Para maior compreens√£o, um recurso est√° dispon√≠vel em [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Componentes

Estes incluem: **Atividades, Servi√ßos, Receptores de Transmiss√£o e Provedores.**

### Atividade de Lan√ßamento e outras atividades

Nos aplicativos Android, as **atividades** s√£o como telas, mostrando diferentes partes da interface do usu√°rio do aplicativo. Um aplicativo pode ter muitas atividades, cada uma apresentando uma tela √∫nica ao usu√°rio.

A **atividade de lan√ßamento** √© a principal porta de entrada para um aplicativo, sendo lan√ßada quando voc√™ toca no √≠cone do aplicativo. Ela √© definida no arquivo de manifesto do aplicativo com inten√ß√µes MAIN e LAUNCHER espec√≠ficas:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
N√£o todos os aplicativos precisam de uma atividade de lan√ßamento, especialmente aqueles sem uma interface de usu√°rio, como servi√ßos em segundo plano.

As atividades podem ser disponibilizadas para outros aplicativos ou processos marcando-as como "exportadas" no manifesto. Essa configura√ß√£o permite que outros aplicativos iniciem essa atividade:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
No entanto, acessar uma atividade de outro aplicativo nem sempre √© um risco de seguran√ßa. A preocupa√ß√£o surge se dados sens√≠veis estiverem sendo compartilhados de forma inadequada, o que poderia levar a vazamentos de informa√ß√µes.

O ciclo de vida de uma atividade **come√ßa com o m√©todo onCreate**, configurando a interface do usu√°rio e preparando a atividade para intera√ß√£o com o usu√°rio.

### Subclasse de Aplicativo

No desenvolvimento Android, um aplicativo tem a op√ß√£o de criar uma **subclasse** da classe [Application](https://developer.android.com/reference/android/app/Application), embora n√£o seja obrigat√≥rio. Quando tal subclasse √© definida, ela se torna a primeira classe a ser instanciada dentro do aplicativo. O m√©todo **`attachBaseContext`**, se implementado nesta subclasse, √© executado antes do m√©todo **`onCreate`**. Essa configura√ß√£o permite uma inicializa√ß√£o precoce antes do restante do aplicativo iniciar.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Servi√ßos

[Servi√ßos](https://developer.android.com/guide/components/services) s√£o **operadores em segundo plano** capazes de executar tarefas sem uma interface de usu√°rio. Essas tarefas podem continuar em execu√ß√£o mesmo quando os usu√°rios alternam para diferentes aplicativos, tornando os servi√ßos cruciais para **opera√ß√µes de longa dura√ß√£o**.

Os servi√ßos s√£o vers√°teis; eles podem ser iniciados de v√°rias maneiras, sendo os **Intents** o m√©todo principal para lan√ß√°-los como ponto de entrada de um aplicativo. Uma vez que um servi√ßo √© iniciado usando o m√©todo `startService`, seu m√©todo `onStart` entra em a√ß√£o e continua em execu√ß√£o at√© que o m√©todo `stopService` seja chamado explicitamente. Alternativamente, se o papel de um servi√ßo depender de uma conex√£o ativa do cliente, o m√©todo `bindService` √© usado para vincular o cliente ao servi√ßo, envolvendo o m√©todo `onBind` para a passagem de dados.

Uma aplica√ß√£o interessante dos servi√ßos inclui a reprodu√ß√£o de m√∫sica em segundo plano ou a busca de dados de rede sem prejudicar a intera√ß√£o do usu√°rio com um aplicativo. Al√©m disso, os servi√ßos podem ser tornados acess√≠veis a outros processos no mesmo dispositivo por meio da **exporta√ß√£o**. Este n√£o √© o comportamento padr√£o e requer configura√ß√£o expl√≠cita no arquivo Android Manifest:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Receptores de Transmiss√£o

Os **receptores de transmiss√£o** atuam como ouvintes em um sistema de mensagens, permitindo que v√°rias aplica√ß√µes respondam √†s mesmas mensagens do sistema. Um aplicativo pode **registrar um receptor** de **duas maneiras principais**: atrav√©s do **Manifest** do aplicativo ou **dinamicamente** dentro do c√≥digo do aplicativo via API **`registerReceiver`**. No Manifest, as transmiss√µes s√£o filtradas com permiss√µes, enquanto receptores registrados dinamicamente tamb√©m podem especificar permiss√µes durante o registro.

Os **filtros de inten√ß√£o** s√£o cruciais em ambos os m√©todos de registro, determinando quais transmiss√µes acionam o receptor. Uma vez que uma transmiss√£o correspondente √© enviada, o m√©todo **`onReceive`** do receptor √© invocado, permitindo que o aplicativo reaja adequadamente, como ajustar o comportamento em resposta a um alerta de bateria fraca.

As transmiss√µes podem ser **ass√≠ncronas**, alcan√ßando todos os receptores sem ordem, ou **s√≠ncronas**, onde os receptores recebem a transmiss√£o com base em prioridades definidas. No entanto, √© importante observar o risco de seguran√ßa potencial, pois qualquer aplicativo pode se priorizar para interceptar uma transmiss√£o.

Para entender a funcionalidade de um receptor, procure pelo m√©todo **`onReceive`** dentro de sua classe. O c√≥digo deste m√©todo pode manipular a Inten√ß√£o recebida, destacando a necessidade de valida√ß√£o de dados pelos receptores, especialmente em **Transmiss√µes Ordenadas**, que podem modificar ou descartar a Inten√ß√£o.

### Provedor de Conte√∫do

Os **Provedores de Conte√∫do** s√£o essenciais para **compartilhar dados estruturados** entre aplicativos, enfatizando a import√¢ncia de implementar **permiss√µes** para garantir a seguran√ßa dos dados. Eles permitem que aplicativos acessem dados de v√°rias fontes, incluindo bancos de dados, sistemas de arquivos ou a web. Permiss√µes espec√≠ficas, como **`readPermission`** e **`writePermission`**, s√£o cruciais para controlar o acesso. Al√©m disso, o acesso tempor√°rio pode ser concedido por meio das configura√ß√µes **`grantUriPermission`** no manifesto do aplicativo, aproveitando atributos como `path`, `pathPrefix` e `pathPattern` para um controle de acesso detalhado.

A valida√ß√£o de entrada √© fundamental para evitar vulnerabilidades, como inje√ß√£o de SQL. Os Provedores de Conte√∫do suportam opera√ß√µes b√°sicas: `insert()`, `update()`, `delete()` e `query()`, facilitando a manipula√ß√£o e compartilhamento de dados entre aplicativos.

**FileProvider**, um Provedor de Conte√∫do especializado, foca em compartilhar arquivos de forma segura. Ele √© definido no manifesto do aplicativo com atributos espec√≠ficos para controlar o acesso a pastas, indicadas por `android:exported` e `android:resource` apontando para configura√ß√µes de pasta. √â aconselh√°vel ter cautela ao compartilhar diret√≥rios para evitar expor inadvertidamente dados sens√≠veis.

Exemplo de declara√ß√£o no manifesto para FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
E um exemplo de especifica√ß√£o de pastas compartilhadas no `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Para mais informa√ß√µes, consulte:
- [Desenvolvedores Android: Provedores de Conte√∫do](https://developer.android.com/guide/topics/providers/content-providers)
- [Desenvolvedores Android: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews s√£o como **mini navegadores da web** dentro de aplicativos Android, exibindo conte√∫do tanto da web quanto de arquivos locais. Eles enfrentam riscos semelhantes aos dos navegadores regulares, mas existem maneiras de **reduzir esses riscos** por meio de **configura√ß√µes espec√≠ficas**.

O Android oferece dois tipos principais de WebView:

- **WebViewClient** √© √≥timo para HTML b√°sico, mas n√£o suporta a fun√ß√£o de alerta JavaScript, afetando como os ataques XSS podem ser testados.
- **WebChromeClient** se comporta mais como a experi√™ncia completa do navegador Chrome.

Um ponto chave √© que os navegadores WebView **n√£o compartilham cookies** com o navegador principal do dispositivo.

Para carregar conte√∫do, m√©todos como ````loadUrl````, ````loadData````, e ````loadDataWithBaseURL```` est√£o dispon√≠veis. √â crucial garantir que esses URLs ou arquivos sejam **seguros para uso**. As configura√ß√µes de seguran√ßa podem ser gerenciadas por meio da classe ````WebSettings````. Por exemplo, desativar JavaScript com ````setJavaScriptEnabled(false)```` pode prevenir ataques XSS.

A "Bridge" JavaScript permite que objetos Java interajam com JavaScript, exigindo que os m√©todos sejam marcados com ````@JavascriptInterface```` para seguran√ßa a partir do Android 4.2.

Permitir acesso ao conte√∫do (````setAllowContentAccess(true)````) permite que WebViews acessem Provedores de Conte√∫do, o que poderia representar um risco, a menos que os URLs de conte√∫do sejam verificados como seguros.

Para controlar o acesso a arquivos:
- Desativar o acesso a arquivos (````setAllowFileAccess(false)````) limita o acesso ao sistema de arquivos, com exce√ß√µes para determinados ativos, garantindo que sejam usados apenas para conte√∫do n√£o sens√≠vel.

## Outros Componentes de Aplicativos e Gerenciamento de Dispositivos M√≥veis

### **Assinatura Digital de Aplicativos**

- A **assinatura digital** √© essencial para aplicativos Android, garantindo que sejam **autenticamente autorizados** antes da instala√ß√£o. Esse processo utiliza um certificado para identifica√ß√£o do aplicativo e deve ser verificado pelo gerenciador de pacotes do dispositivo durante a instala√ß√£o. Os aplicativos podem ser **autoassinados ou certificados por uma AC externa**, protegendo contra acessos n√£o autorizados e garantindo que o aplicativo permane√ßa √≠ntegro durante a entrega ao dispositivo.

### **Verifica√ß√£o de Aplicativos para Seguran√ßa Aprimorada**

- A partir do **Android 4.2**, um recurso chamado **Verificar Apps** permite que os usu√°rios verifiquem a seguran√ßa dos aplicativos antes da instala√ß√£o. Esse **processo de verifica√ß√£o** pode alertar os usu√°rios sobre aplicativos potencialmente prejudiciais, ou at√© mesmo impedir a instala√ß√£o de aplicativos particularmente maliciosos, aprimorando a seguran√ßa do usu√°rio.

### **Gerenciamento de Dispositivos M√≥veis (MDM)**

- As **solu√ß√µes de MDM** fornecem **supervis√£o e seguran√ßa** para dispositivos m√≥veis por meio da **API de Administra√ß√£o de Dispositivos**. Elas exigem a instala√ß√£o de um aplicativo Android para gerenciar e proteger dispositivos m√≥veis de forma eficaz. As fun√ß√µes principais incluem **impor pol√≠ticas de senha**, **exigir criptografia de armazenamento** e **permitir a exclus√£o remota de dados**, garantindo controle abrangente e seguran√ßa sobre dispositivos m√≥veis.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**Grupo de Seguran√ßa Try Hard**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
