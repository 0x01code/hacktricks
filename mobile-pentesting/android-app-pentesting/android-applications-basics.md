# Android Uygulamaları Temelleri

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com)'ni edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

**Try Hard Güvenlik Grubu**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Android Güvenlik Modeli

**İki katman bulunmaktadır:**

* **İşletim Sistemi (OS)**, yüklenmiş uygulamaları birbirinden izole eder.
* **Uygulama kendisi**, geliştiricilere belirli işlevleri **açığa çıkarmalarına** ve uygulama yeteneklerini yapılandırmalarına olanak tanır.

### UID Ayrımı

**Her uygulamaya belirli bir Kullanıcı Kimliği (UID) atanır**. Bu, uygulamanın yüklenmesi sırasında yapılır, böylece **uygulama yalnızca kendi UID'sine ait dosyalara veya paylaşılan** dosyalara erişebilir. Bu nedenle, yalnızca uygulama kendisi, işletim sisteminin belirli bileşenleri ve kök kullanıcı uygulama verilerine erişebilir.

### UID Paylaşımı

**İki uygulama aynı UID'yi kullanacak şekilde yapılandırılabilir**. Bu bilgi paylaşımı için faydalı olabilir, ancak bunlardan biri tehlikeye düşerse her iki uygulamanın verileri de tehlikeye düşer. Bu nedenle bu davranışın **önerilmediğini** unutmayın.\
**Aynı UID'yi paylaşmak için uygulamalar, manifestolarında aynı `android:sharedUserId` değerini tanımlamalıdır.**

### Kum Sandığı (Sandboxing)

**Android Uygulama Kum Sandığı**, **her uygulamanın** ayrı bir süreç olarak çalışmasına olanak tanır ve her sürecin kendi sanal makinesi vardır, bu nedenle bir uygulamanın kodu diğer uygulamalardan izole bir şekilde çalışır.\
Android 5.0(L) itibariyle **SELinux** zorunlu hale getirilmiştir. Temelde, SELinux tüm süreç etkileşimlerini reddetti ve ardından bunlar arasındaki **beklenen etkileşimlere yalnızca izin veren politikalar oluşturdu**.

### İzinler

Bir **uygulama yüklediğinizde ve izinler istediğinde**, uygulama **AndroidManifest.xml** dosyasındaki **`uses-permission`** öğelerinde yapılandırılan izinleri istemektedir. **uses-permission** öğesi, istenen iznin adını içeren **name** **özniteliğini** belirtir. Ayrıca **maxSdkVersion** özniteliği vardır, bu özellik belirtilenden daha yüksek sürümlerde izin istemeyi durdurur.\
Android uygulamalarının tüm izinleri başlangıçta sorması gerekmediğini unutmayın, ayrıca **izinleri dinamik olarak da isteyebilirler** ancak tüm izinler **manifestoda belirtilmelidir**.

Bir uygulama işlevsellik açığa çıkardığında, **erişimi yalnızca belirli bir izne sahip uygulamalara sınırlayabilir**.\
Bir izin öğesinin üç özelliği vardır:

* İzinin **adı**
* İzin grubu özniteliği, ilgili izinleri gruplandırmaya olanak tanır.
* İzinlerin nasıl verildiğini belirten **koruma düzeyi**. Dört tür vardır:
* **Normal**: Uygulamaya **bilinen tehditler** olmadığında kullanılır. Kullanıcının **onayı gerekmez**.
* **Tehlikeli**: İzinin isteyen uygulamaya bazı **yükseltilmiş erişimler** sağladığını belirtir. **Kullanıcıların onayını talep eder**.
* **Signature**: Yalnızca **aynı sertifika ile imzalanan uygulamalar**, bileşeni dışa aktaranın sertifikasıyla aynı sertifika ile imzalanmış uygulamalara izin verilebilir. Bu, en güçlü koruma türüdür.
* **SignatureOrSystem**: Yalnızca **aynı sertifika ile imzalanan uygulamalar**, bileşeni dışa aktaranın sertifikasıyla aynı sertifika ile imzalanan uygulamalar veya **sistem düzeyinde erişimle çalışan uygulamalar** izin alabilir

## Ön Yüklü Uygulamalar

Bu uygulamalar genellikle **`/system/app`** veya **`/system/priv-app`** dizinlerinde bulunur ve bazıları **optimize edilmiştir** (bazen `classes.dex` dosyasını bile bulamayabilirsiniz). Bu uygulamalar kontrol edilmeye değerdir çünkü bazen **çok fazla izinle çalışıyor olabilirler** (kök olarak).

* **AOSP** (Android Açık Kaynak Projesi) **ROM** ile birlikte gönderilenler
* Cihaz **üreticisi** tarafından eklenenler
* Cep **telefonu sağlayıcısı** tarafından eklenenler (onlardan satın alındıysa)

## Rootlama

Fiziksel bir Android cihaza kök erişim elde etmek için genellikle cihaza ve sürüme **özgü** olan 1 veya 2 **zafiyeti sömürmeniz gerekir**.\
Sömürü işe yaradığında genellikle Linux `su` ikili dosyası, kullanıcının PATH çevresel değişkeninde belirtilen bir konuma (`/system/xbin` gibi) kopyalanır.

`su` ikili dosyası yapılandırıldığında, başka bir Android uygulaması `su` ikili dosyasıyla etkileşim kurmak ve **kök erişimi taleplerini işlemek için** kullanılır, örneğin **Superuser** ve **SuperSU** (Google Play Store'da mevcuttur).

{% hint style="danger" %}
Rootlama işlemi çok tehlikelidir ve cihaza ciddi zarar verebilir
{% endhint %}

### ROM'lar

**Özel bir yazılım yükleyerek işletim sistemini değiştirmek mümkündür**. Bunu yaparak eski bir cihazın kullanışlılığını artırabilir, yazılım kısıtlamalarını atlayabilir veya en son Android koduna erişim sağlayabilirsiniz.\
**OmniROM** ve **LineageOS**, kullanılan en popüler yazılımlardan ikisidir.

Cihazın **özelleştirilmiş bir yazılım yüklemek için kök erişim gerekli olmadığı** unutulmamalıdır. **Bazı üreticiler**, bootloader'larının belgeli ve güvenli bir şekilde kilidini açmalarına izin verir.

### Etkiler

Bir cihaz köklendiğinde, herhangi bir uygulama kök erişimini isteyebilir. Kötü niyetli bir uygulama bunu alırsa, neredeyse her şeye erişimi olacak ve telefona zarar verebilecektir.

## Android Uygulama Temelleri <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Android uygulamalarının formatı _APK dosya formatı_ olarak adlandırılır. Temelde bir **ZIP dosyasıdır** (dosya uzantısını .zip olarak değiştirerek içeriği çıkarılabilir ve görüntülenebilir).
- APK İçeriği (Eksiksiz Değil)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: derlenmiş kaynakları, biner XML gibi içeren.
- res/xml/files\_paths.xml
- META-INF/
- Sertifikanın bulunduğu yer burasıdır!
- **classes.dex**
- Uygulamanın varsayılan olarak yürüttüğü derlenmiş Java (veya Kotlin) kodunu temsil eden Dalvik bytecode içerir.
- lib/
- CPU mimarisine göre alt dizinlerde ayrılmış yerel kütüphaneleri barındırır.
- `armeabi`: ARM tabanlı işlemciler için kod
- `armeabi-v7a`: ARMv7 ve daha yüksek tabanlı işlemciler için kod
- `x86`: X86 işlemciler için kod
- `mips`: Yalnızca MIPS işlemciler için kod
- assets/
- Uygulama tarafından gereken çeşitli dosyaları saklar, ekstra kodu gizlemek için bazen kötü niyetli yazarlar tarafından kullanılan ek deneysel kütüphaneler veya DEX dosyalarını içerebilir.
- res/
- Derlenmiş olmayan kaynakları içerir.
### **Dalvik ve Smali**

Android geliştirmede **Java veya Kotlin** uygulamalar oluşturmak için kullanılır. Masaüstü uygulamalarında JVM kullanılmak yerine Android bu kodu **Dalvik Yürütülebilir (DEX) bytecode**'a derler. Önceden, Dalvik sanal makinesi bu bytecode'u işlerken, şimdi yeni Android sürümlerinde Android Runtime (ART) devralır.

Tersine mühendislik için **Smali** hayati öneme sahiptir. Bu, DEX bytecode'un insan tarafından okunabilir versiyonudur ve kaynak kodunu bytecode talimatlarına çevirerek montaj dili gibi davranır. Smali ve baksmali, bu bağlamda montaj ve montajdan çıkarma araçlarını ifade eder.

## İntentler

İntentler, Android uygulamalarının bileşenleri arasında veya diğer uygulamalarla iletişim kurmanın temel yoludur. Bu mesaj nesneleri aynı zamanda uygulamalar veya bileşenler arasında veri taşıyabilir, HTTP iletişiminde kullanılan GET/POST istekleri gibi.

Yani bir İntent temelde **bileşenler arasında iletilen bir mesajdır**. İntentler **belirli bileşenlere veya uygulamalara yönlendirilebilir** veya **belirli bir alıcı olmadan gönderilebilir**.\
Basitçe İntent şunlar için kullanılabilir:

* Bir Etkinliği başlatmak, genellikle bir uygulama için bir kullanıcı arayüzü açma
* Sistem ve uygulamaları değişiklikler hakkında bilgilendirmek için yayınlar
* Arkaplan hizmetini başlatmak, durdurmak ve iletişim kurmak
* ContentProvider'lar aracılığıyla veriye erişmek
* Olayları işlemek için geri çağrılar olarak kullanmak

Eğer zayıfsa, **İntentler çeşitli saldırıları gerçekleştirmek için kullanılabilir**.

### İntent-Filtre

**İntent Filtreleri**, bir etkinlik, hizmet veya Yayın Alıcısının farklı türdeki İntent'lerle nasıl etkileşimde bulunabileceğini tanımlar. Temelde, bu bileşenlerin ne tür eylemler gerçekleştirebileceğini veya hangi yayınları işleyebileceğini açıklarlar. Bu filtreleri tanımlamanın temel yeri **AndroidManifest.xml dosyası** olmasına rağmen, Yayın Alıcıları için bunları kodlamak da bir seçenektir.

İntent Filtreleri, kategoriler, eylemler ve veri filtrelerinden oluşur ve ek meta verileri içerebilme olasılığı vardır. Bu yapı, bileşenlerin belirtilen kriterleri karşılayan belirli İntent'leri işlemesine olanak tanır.

Android bileşenlerinin (etkinlikler/hizmetler/content sağlayıcılar/yayın alıcıları) kritik bir yönü, görünürlükleri veya **genel durumları**dır. Bir bileşen, manifestte **`true`** değeri ile **`exported`** olarak ayarlanmışsa veya için bir İntent Filtresi belirtilmişse, diğer uygulamalarla etkileşime girebilir. Bununla birlikte, geliştiricilerin bu bileşenleri yanlışlıkla diğer uygulamalarla etkileşime girmesini engellemek için bu bileşenleri açıkça özel tutma yolu vardır. Bu, manifest tanımlamalarında **`exported`** özniteliğini **`false`** olarak ayarlayarak sağlanır.

Ayrıca, geliştiriciler bu bileşenlere erişimi daha da güvenli hale getirmek için belirli izinleri gerektirebilir. **`izin`** özniteliği, yalnızca belirli izne sahip uygulamaların bileşene erişebileceğini zorlamak için ayarlanabilir, böylece kiminle etkileşimde bulunabileceği üzerinde ek bir güvenlik ve kontrol katmanı eklenir.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### İmplit Intentler

Intentler, bir Intent yapıcısı kullanılarak programatik olarak oluşturulur:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**Eylem** önceden belirtilen niyetin **ACTION\_SEND** ve **Ekstra**'sı bir mailto **Uri**'dir (Ekstra, niyetin beklediği ek bilgidir).

Bu niyet, aşağıdaki örnekte olduğu gibi manifest dosyasının içinde bildirilmelidir:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Bir intent-filtresinin bir mesajı alabilmesi için **action**, **data** ve **category** eşleşmesi gerekmektedir.

"Intent çözümleme" süreci, her mesajın hangi uygulamanın alması gerektiğini belirler. Bu süreç, **öncelik özniteliğini** dikkate alır, bu öncelik i**ntent-filtresi bildiriminde** ayarlanabilir ve **daha yüksek önceliğe sahip olan seçilir**. Bu öncelik -1000 ile 1000 arasında ayarlanabilir ve uygulamalar `SYSTEM_HIGH_PRIORITY` değerini kullanabilir. Bir **çakışma** ortaya çıkarsa, bir "seçici" Penceresi görünür, böylece **kullanıcı karar verebilir**.

### Açık İntentler

Açık bir intent, hedeflediği sınıf adını belirtir:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Diğer uygulamalarda önceden belirtilen amaçlara erişmek için şunu kullanabilirsiniz:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Bekleyen İzinler

Bu, diğer uygulamaların **uygulamanız adına hareketlerde bulunmasına izin verir**, uygulamanızın kimliğini ve izinlerini kullanarak. Bekleyen İzin oluşturulurken bir niyet ve gerçekleştirilecek eylem **belirtilmelidir**. Eğer **belirtilen niyet Açık değilse** (hangi niyetin onu çağırabileceğini belirtmez) **kötü niyetli bir uygulama belirtilen eylemi** kurban uygulama adına gerçekleştirebilir. Dahası, **bir eylem belirtilmemişse**, kötü niyetli uygulama **kurban adına herhangi bir eylemi gerçekleştirebilir**.

### Yayın İzinleri

Önceki izinlerin aksine, yayın izinleri **birden fazla uygulama tarafından alınabilir**. Ancak API sürümü 14'ten itibaren, mesajı alması gereken uygulamayı belirtmek mümkündür **Intent.setPackage** kullanarak.

Alternatif olarak, yayın gönderirken **bir izin belirtmek de mümkündür**. Alıcı uygulamanın o izne sahip olması gerekecektir.

İki tür Yayın vardır: **Normal** (asykron) ve **Sıralı** (senkron). **Sıra**, alıcı içindeki **ayarlanmış önceliğe göre belirlenir**. **Her uygulama Yayını işleyebilir, iletebilir veya bırakabilir**.

`Context` sınıfından `sendBroadcast(intent, receiverPermission)` işlevini kullanarak bir yayın göndermek mümkündür.\
Ayrıca, **`LocalBroadCastManager`**'dan **`sendBroadcast`** işlevini kullanarak **mesajın uygulamayı terk etmemesini sağlayabilirsiniz**. Bunu kullanarak bir alıcı bileşenini dışa aktarmanıza gerek kalmaz.

### Kalıcı Yayınlar

Bu tür Yayınlar **gönderildikten uzun bir süre sonra erişilebilir**.\
Bu, API seviyesi 21'de kullanımdan kaldırıldı ve **kullanılmaması önerilir**.\
**Herhangi bir uygulamanın verileri izlemesine ve değiştirmesine izin verirler**.

Eğer **`sendStickyBroadcast`** veya **`sendStickyBroadcastAsUser`** gibi "sticky" kelimesini içeren işlevler bulursanız, **etkisini kontrol edin ve bunları kaldırmayı deneyin**.

## Derin Bağlantılar / URL şemaları

Android uygulamalarında, **derin bağlantılar** bir URL aracılığıyla doğrudan bir eylemi (Niyet) başlatmak için kullanılır. Bu, bir etkinlik içinde belirli bir **URL şemasının** bildirilmesiyle yapılır. Bir Android cihazı, bu şemayla bir URL'ye **erişmeye çalıştığında**, uygulama içinde belirtilen etkinlik başlatılır.

Şema, **`AndroidManifest.xml`** dosyasında bildirilmelidir:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Önceki örnekteki şema `exampleapp://` (ayrıca **`category BROWSABLE`**'ı da not edin)

Ardından, veri alanında **ana bilgisayar (host)** ve **yol (path)** belirtebilirsiniz:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Web'den erişmek için bir bağlantı kurmak mümkündür:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
**Uygulamada yürütülecek kodu bulmak** için deeplink tarafından çağrılan etkinliğe gidin ve **`onNewIntent`** işlevini arayın.

[HTML sayfaları kullanmadan derin bağlantıları nasıl çağıracağınızı](./#exploiting-schemes-deep-links) öğrenin.

## AIDL - Android Arayüz Tanım Dili

**Android Arayüz Tanım Dili (AIDL)**, Android uygulamalarında istemci ve hizmet arasındaki iletişimi kolaylaştırmak amacıyla tasarlanmıştır ve **işlem arası iletişim** (IPC) yoluyla gerçekleştirilir. Android'de başka bir işlemin belleğine doğrudan erişim izin verilmediğinden, AIDL işlemi nesneleri işletim sistemi tarafından anlaşılabilir bir formata dönüştürerek farklı işlemler arasında iletişimi kolaylaştırır.

### Temel Kavramlar

- **Bağlı Hizmetler**: Bu hizmetler, IPC için AIDL'yi kullanır ve etkinliklerin veya bileşenlerin bir hizmete bağlanmasını, isteklerde bulunmasını ve yanıtlar almasını sağlar. Hizmetin sınıfındaki `onBind` yöntemi etkileşimi başlatmak için kritiktir ve güvenlik açıkları arayışında önemli bir alan olarak işaretlenir.

- **Messenger**: Bağlı bir hizmet olarak çalışan Messenger, verilerin `onBind` yöntemi aracılığıyla işlenmesine odaklanarak IPC'yi kolaylaştırır. Bu yöntemi güvenli olmayan veri işleme veya hassas işlevlerin yürütülmesi açısından yakından incelemek önemlidir.

- **Binder**: Binder sınıfının doğrudan kullanımı AIDL'nin soyutlaması nedeniyle daha az yaygındır, ancak Binder'ın farklı işlemlerin bellek alanları arasında veri transferini kolaylaştıran bir çekirdek seviye sürücü olarak hareket ettiğini anlamak faydalıdır. Daha fazla anlayış için bir kaynak [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8) adresinde bulunmaktadır.

## Bileşenler

Bunlar şunları içerir: **Etkinlikler, Hizmetler, Yayın Alıcılar ve Sağlayıcılar.**

### Başlatıcı Etkinlik ve diğer etkinlikler

Android uygulamalarında **etkinlikler**, uygulamanın kullanıcı arayüzünün farklı bölümlerini gösteren ekranlar gibidir. Bir uygulamada birçok etkinlik olabilir, her biri kullanıcıya benzersiz bir ekran sunar.

**Başlatıcı etkinlik**, uygulamanın ana giriş kapısıdır ve uygulamanın simgesine dokunduğunuzda başlatılır. Belirli MAIN ve LAUNCHER niyetleriyle uygulamanın manifest dosyasında tanımlanmıştır:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
### Bazı uygulamaların, arka plan hizmetleri gibi kullanıcı arayüzü olmayanlar da dahil olmak üzere bir başlatıcı etkinliğine ihtiyacı yoktur.

### Etkinlikler, manifest dosyasında "ihracat" olarak işaretlenerek diğer uygulamalar veya işlemler için erişilebilir hale getirilebilir. Bu ayar, diğer uygulamaların bu etkinliği başlatmasına izin verir:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ancak, başka bir uygulamadan bir etkinliğe erişmek her zaman bir güvenlik riski oluşturmaz. Endişe, hassas verilerin yanlış şekilde paylaşılması durumunda ortaya çıkar, bu da bilgi sızıntılarına yol açabilir.

Bir etkinliğin yaşam döngüsü **onCreate yöntemiyle başlar**, UI'yi kurar ve etkinliği kullanıcıyla etkileşime hazırlar.

### Uygulama Alt Sınıfı

Android geliştirmede, bir uygulamanın [Application](https://developer.android.com/reference/android/app/Application) sınıfının bir **alt sınıfını** oluşturma seçeneği vardır, ancak zorunlu değildir. Böyle bir alt sınıf tanımlandığında, uygulama içinde ilk olarak örneklenen sınıf haline gelir. Bu alt sınıfta uygulandıysa **`attachBaseContext`** yöntemi, **`onCreate`** yönteminden önce yürütülür. Bu kurulum, uygulamanın geri kalanının başlamasından önce erken başlatma olanağı sağlar.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Hizmetler

[Hizmetler](https://developer.android.com/guide/components/services), kullanıcı arayüzü olmadan görevleri yürütebilen **arka plan işlemcileri**dir. Bu görevler, kullanıcıların farklı uygulamalara geçiş yapmaları durumunda bile devam edebilir, bu nedenle hizmetler **uzun süre çalışan işlemler** için hayati öneme sahiptir.

Hizmetler çok yönlüdür; çeşitli şekillerde başlatılabilirler ve bunları başlatmanın temel yolu **Intent'ler**dir, uygulamanın giriş noktası olarak. Bir hizmet, `startService` yöntemi kullanılarak başlatıldığında, `onStart` yöntemi devreye girer ve `stopService` yöntemi açıkça çağrılana kadar çalışmaya devam eder. Alternatif olarak, bir hizmetin rolü aktif bir istemci bağlantısına bağlıysa, istemciyi hizmete bağlamak için `bindService` yöntemi kullanılır ve veri iletimi için `onBind` yöntemi devreye girer.

Hizmetlerin ilginç bir uygulaması, arka planda müzik çalma veya ağ verilerini almanın kullanıcının bir uygulayla etkileşimini engellemeden yapılmasıdır. Ayrıca, hizmetler diğer işlemlerin aynı cihazdaki erişimine olanak tanınarak **dışa aktarılabilir**. Bu varsayılan davranış değildir ve Android Manifest dosyasında açıkça yapılandırma gerektirir:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Yayın Alıcıları

**Yayın alıcıları**, bir iletişim sisteminde dinleyici olarak hareket eder ve birden fazla uygulamanın sistemden gelen aynı iletilere yanıt vermesine olanak tanır. Bir uygulama bir yayın alıcısını **iki temel yol** ile **kaydedebilir**: uygulamanın **Manifest** dosyası aracılığıyla veya uygulamanın kodu içinde **dinamik olarak** **`registerReceiver`** API'si aracılığıyla. Manifest dosyasında yayınlar izinlerle filtrelenirken, dinamik olarak kaydedilen alıcılar kayıt sırasında izinleri de belirtebilir.

**Intent filtreleri**, kayıt yöntemlerinde de önemli olup, hangi yayınların alıcıyı tetiklediğini belirler. Eşleşen bir yayın gönderildiğinde, alıcının **`onReceive`** yöntemi çağrılır ve uygulamanın düşük pil uyarısına yanıt vererek davranışını ayarlamasına olanak tanır.

Yayınlar ya **asenkron** olabilir, tüm alıcılara sırasız ulaşır, ya da **senkron** olabilir, alıcılar önceliklere göre yayına ulaşır. Ancak, herhangi bir uygulamanın kendisini önceliklendirerek bir yayını ele geçirmesine olanak tanıma potansiyel güvenlik riskine dikkat etmek önemlidir.

Bir alıcının işlevselliğini anlamak için, sınıfındaki **`onReceive`** yöntemini arayın. Bu yöntemin kodu alınan Intent'i değiştirebilir, özellikle **Sıralı Yayınlar** içinde, Intent'i değiştirebilir veya düşürebileceği için alıcılar tarafından veri doğrulamasının gerekliliğini vurgular.

### İçerik Sağlayıcı

**İçerik Sağlayıcıları**, uygulamalar arasında **yapılandırılmış veri paylaşımı** için önemlidir ve veri güvenliğini sağlamak için **izinlerin** uygulanmasının önemini vurgular. İçerik sağlayıcıları, veritabanları, dosya sistemleri veya web gibi çeşitli kaynaklardan verilere erişime olanak tanır. **`readPermission`** ve **`writePermission`** gibi belirli izinler, erişimi kontrol etmek için önemlidir. Ayrıca, geçici erişim, ayrıntılı erişim kontrolü için `path`, `pathPrefix` ve `pathPattern` gibi özellikleri kullanarak uygulamanın manifestinde **`grantUriPermission`** ayarları aracılığıyla verilebilir.

Güvenlik açıklarını önlemek için giriş doğrulaması önemlidir, örneğin SQL enjeksiyonu. İçerik Sağlayıcıları, `insert()`, `update()`, `delete()` ve `query()` gibi temel işlemleri destekler, veri manipülasyonunu ve uygulamalar arasında paylaşımı kolaylaştırır.

**FileProvider**, güvenli bir şekilde dosya paylaşımına odaklanan özel bir İçerik Sağlayıcıdır. Klasör erişimini kontrol etmek için belirli özelliklerle uygulamanın manifest dosyasında tanımlanır, `android:exported` ve `android:resource` klasör yapılandırmalarına işaret eder. Hassas verilerin yanlışlıkla açığa çıkarılmasını önlemek için dizinlerin paylaşımında dikkatli olunması önerilir.

FileProvider için örnek manifest bildirimi:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Ve paylaşılan klasörleri belirtme örneği için `filepaths.xml` dosyasında aşağıdaki gibi belirtilebilir:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Daha fazla bilgi için şu kaynaklara bakabilirsiniz:
- [Android Geliştiriciler: İçerik Sağlayıcılar](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Geliştiriciler: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews, Android uygulamalarının içinde **mini web tarayıcıları** gibi davranır, içeriği web'den veya yerel dosyalardan alır. Bunlar normal tarayıcılar gibi benzer risklerle karşılaşır, ancak belirli **ayarlar** aracılığıyla bu riskleri **azaltmanın yolları** vardır.

Android, iki ana WebView türü sunar:

- **WebViewClient**, temel HTML için harikadır ancak JavaScript uyarı işlevini desteklemez, bu da XSS saldırılarının nasıl test edilebileceğini etkiler.
- **WebChromeClient**, tam Chrome tarayıcı deneyimine daha çok benzer.

Önemli bir nokta, WebView tarayıcılarının cihazın ana tarayıcısıyla **çerezleri paylaşmamasıdır**.

İçerik yükleme için ````loadUrl````, ````loadData````, ve ````loadDataWithBaseURL```` gibi yöntemler mevcuttur. Bu URL'lerin veya dosyaların **güvenli olduğundan emin olmak** önemlidir. Güvenlik ayarları, ````WebSettings```` sınıfı aracılığıyla yönetilebilir. Örneğin, ````setJavaScriptEnabled(false)```` ile JavaScript devre dışı bırakılarak XSS saldırıları engellenebilir.

JavaScript "Bridge", Java nesnelerinin JavaScript ile etkileşimde bulunmasını sağlar ve yöntemlerin güvenliği için Android 4.2'den itibaren ````@JavascriptInterface```` ile işaretlenmesi gerekmektedir.

İçeriğe erişime izin vermek (````setAllowContentAccess(true)````), WebViews'in İçerik Sağlayıcılara ulaşmasına izin verir, ancak içerik URL'lerinin güvenli olduğu doğrulanmadıkça bir risk oluşturabilir.

Dosya erişimini kontrol etmek için:
- Dosya erişimini devre dışı bırakmak (````setAllowFileAccess(false)````), dosya sistemine erişimi sınırlar, belirli varlıklar için istisnalar yapar ve bunların hassas olmayan içerikler için kullanıldığından emin olur.

## Diğer Uygulama Bileşenleri ve Mobil Cihaz Yönetimi

### **Uygulamaların Dijital İmzalanması**

- Android uygulamaları için **dijital imzalama**, uygulamaların kurulmadan önce **gerçekten kimin tarafından yazıldığını** sağlamak için gereklidir. Bu süreç, uygulama kimliği için bir sertifika kullanır ve kurulum sırasında cihazın paket yöneticisi tarafından doğrulanmalıdır. Uygulamalar **kendi kendine imzalanabilir veya harici bir CA tarafından onaylanabilir**, yetkisiz erişime karşı koruma sağlar ve uygulamanın cihaza teslim edilirken değiştirilmediğinden emin olur.

### **Gelişmiş Güvenlik için Uygulama Doğrulaması**

- **Android 4.2**'den itibaren başlayarak, **Uygulamaları Doğrula** adlı bir özellik, kullanıcıların uygulamaları kurulmadan önce güvenlik açısından kontrol etmelerine olanak tanır. Bu **doğrulama süreci**, kullanıcıları potansiyel olarak zararlı uygulamalar konusunda uyarabilir veya özellikle kötü amaçlı olanların kurulumunu engelleyebilir, kullanıcı güvenliğini artırır.

### **Mobil Cihaz Yönetimi (MDM)**

- **MDM çözümleri**, mobil cihazlar için **denetim ve güvenlik** sağlar ve **Cihaz Yönetimi API'si** aracılığıyla gerektirir. Mobil cihazların etkili bir şekilde yönetilmesi ve güvenliğinin sağlanması için bir Android uygulamasının kurulmasını zorunlu kılar. Temel fonksiyonlar arasında **şifre politikalarının zorunlu kılınması**, **depolama şifrelemesinin zorunlu kılınması** ve **uzaktan veri silmeye izin verilmesi** bulunur, mobil cihazlar üzerinde kapsamlı kontrol ve güvenlik sağlar.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**Try Hard Güvenlik Grubu**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na göz atın(https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family)
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
