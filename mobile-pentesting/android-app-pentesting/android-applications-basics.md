# Androidアプリケーションの基礎

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスウェグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見る
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)をフォローする。
- **ハッキングトリックを共有するには、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

## Androidセキュリティモデル

**2つのレイヤーがあります：**

- **OS**：インストールされたアプリケーションを互いに分離します。
- **アプリケーション自体**：開発者が**特定の機能を公開**し、アプリケーションの機能を構成できるようにします。

### UID分離

**各アプリケーションには特定のユーザーIDが割り当てられます**。これはアプリのインストール時に行われ、**アプリは自分のユーザーIDで所有されているファイルまたは共有**ファイルにのみアクセスできます。したがって、アプリ自体、OSの特定のコンポーネント、およびルートユーザーだけがアプリのデータにアクセスできます。

### UID共有

**2つのアプリケーションを同じUIDを使用するように構成できます**。これは情報を共有するのに役立ちますが、1つが侵害されると両方のアプリケーションのデータが侵害されます。このため、この動作は**推奨されません**。\
**同じUIDを共有するには、アプリケーションはマニフェストで同じ `android:sharedUserId` 値を定義する必要があります。**

### サンドボックス

**Androidアプリケーションサンドボックス**を使用すると、**各アプリケーション**を**別のプロセスとして別のユーザーID**で実行できます。各プロセスには独自の仮想マシンがあり、アプリのコードは他のアプリから隔離されて実行されます。\
Android 5.0（L）からは**SELinux**が強制されています。基本的に、SELinuxはすべてのプロセスの相互作用を拒否し、それからそれらの間の**予想される相互作用のみを許可するポリシーを作成**しました。

### 権限

アプリをインストールするときに**権限を要求すると**、アプリは**AndroidManifest.xml**ファイルの**`uses-permission`**要素で構成された権限を要求しています。**uses-permission**要素は、**name** **属性**内の要求された権限の名前を示します。**maxSdkVersion**属性もあり、指定されたバージョンよりも高いバージョンでは権限を要求しなくなります。\
Androidアプリケーションは最初からすべての権限を要求する必要はなく、**権限を動的に要求**することもできますが、すべての権限は**マニフェストで宣言**されている必要があります。

アプリが機能を公開すると、**指定された権限を持つアプリにのみアクセス**を制限できます。\
権限要素には3つの属性があります：

- 権限の**名前**
- 権限グループをグループ化する**permission-group**属性
- 権限がどのように付与されるかを示す**protection-level**。4つのタイプがあります：
  - **Normal**：アプリに**既知の脅威がない**場合に使用されます。ユーザーは**承認を求められません**。
  - **Dangerous**：権限が要求されたアプリケーションに**一部の権限が与えられる**ことを示します。**ユーザーは承認を求められます**。
  - **Signature**：**エクスポートしているコンポーネントと同じ証明書で署名されたアプリ**のみが権限を付与されることができます。これは最も強力な保護のタイプです。
  - **SignatureOrSystem**：**エクスポートしているコンポーネントと同じ証明書で署名されたアプリ**または**システムレベルのアクセスで実行されているアプリ**のみが権限を付与されることができます。

## 事前インストールされたアプリケーション

これらのアプリは一般的に**`/system/app`**または**`/system/priv-app`**ディレクトリにあり、一部は**最適化**されています（`classes.dex`ファイルが見つからない場合があります）。これらのアプリケーションは、**ルートとして実行されることが多いため**、チェックする価値があります。

- **AOSP**（Androidオープンソースプロジェクト）**ROM**に含まれるもの
- デバイスの**製造元**に追加されたもの
- 携帯電話プロバイダーによって追加されたもの（彼らから購入した場合）

## ルート化

物理的なAndroidデバイスでルートアクセスを取得するには、通常、**デバイス**と**バージョン**に**特有**の1つまたは2つの**脆弱性を悪用**する必要があります。\
悪用が機能すると、通常、Linuxの `su` バイナリがユーザーのPATH環境変数で指定された場所にコピーされます（たとえば `/system/xbin`）。

suバイナリが構成されると、別のAndroidアプリが `su` バイナリとのインターフェイスを提供し、**Superuser**や**SuperSU**などのルートアクセスのリクエストを処理します（Google Playストアで利用可能）。

{% hint style="danger" %}
ルート化プロセスは非常に危険であり、デバイスに重大な損害を与える可能性があります
{% endhint %}

### ROM

**カスタムファームウェアをインストールしてOSを置き換える**ことができます。これにより、古いデバイスの有用性を拡張したり、ソフトウェアの制限をバイパスしたり、最新のAndroidコードにアクセスしたりすることができます。\
**OmniROM**と**LineageOS**は、最も人気のあるファームウェアの2つです。

デバイスにカスタムファームウェアをインストールするためには、**デバイスをルート化する必要があるわけではない**ことがあります。**一部のメーカーは**、十分に文書化された安全な方法でブートローダーのロックを解除することを許可しています。

### 影響

デバイスがルート化されると、任意のアプリがルートアクセスを要求できます。悪意のあるアプリケーションがそれを取得した場合、ほとんどすべてにアクセスでき、電話を破損させることができます。

## Androidアプリケーションの基本 <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Androidアプリケーションの形式は_APKファイル形式_と呼ばれます。実質的には**ZIPファイル**です（ファイル拡張子を .zip に変更することで、内容を抽出して表示できます）。
- APKの内容（完全ではありません）
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc：バイナリXMLなど、事前にコンパイルされたリソースが含まれています。
- res/xml/files\_paths.xml
- META-INF/
- ここに証明書があります！
- **classes.dex**
- デフォルトでアプリケーションが実行する、コンパイルされたJava（またはKotlin）コードを表すDalvikバイトコードが含まれています。
- lib/
- CPUアーキテクチャごとにサブディレクトリに分かれたネイティブライブラリが格納されています。
  - `armeabi`：ARMベースのプロセッサ用のコード
  - `armeabi-v7a`：ARMv7およびそれ以上のプロセッサ用のコード
  - `x86`：X86プロセッサ用のコード
  - `mips`：MIPSプロセッサ用のコードのみ
- assets/
- アプリが必要とするさまざまなファイルを格納し、追加のネイティブライブラリやDEXファイルを含む場合があります。マルウェアの作者が追加のコードを隠すために使用することがあります。
- res/
- resources.arscにコンパイルされていないリソースが含まれています。
### **Dalvik & Smali**

Android開発では、**JavaまたはKotlin**がアプリを作成するために使用されます。デスクトップアプリケーションとは異なり、Androidはこのコードを**Dalvik Executable (DEX) bytecode**にコンパイルします。以前はDalvik仮想マシンがこのバイトコードを処理していましたが、新しいAndroidバージョンではAndroid Runtime (ART)が引き継いでいます。

逆アセンブリのために、**Smali**が重要になります。これはDEXバイトコードの人間が読めるバージョンであり、ソースコードをバイトコード命令に変換することでアセンブリ言語のように機能します。この文脈では、Smaliとbaksmaliはアセンブリと逆アセンブリのツールを指します。

## インテント

インテントは、Androidアプリがコンポーネント間や他のアプリと通信する主要手段です。これらのメッセージオブジェクトは、HTTP通信でのGET/POSTリクエストのように、アプリ間やコンポーネント間でデータをやり取りすることもできます。

つまり、インテントは基本的に**コンポーネント間で渡されるメッセージ**です。インテントは特定のコンポーネントやアプリに**向けられることもあります**し、特定の受信者なしに送信されることもあります。\
簡単に言うと、インテントは以下のように使用できます：

* 通常はアプリのユーザーインターフェースを開くためにActivityを開始するため
* システムやアプリに変更を通知するためのブロードキャストとして
* バックグラウンドサービスの開始、停止、通信のため
* ContentProvidersを介してデータにアクセスするため
* イベントを処理するためのコールバックとして

脆弱性がある場合、**インテントはさまざまな攻撃に使用できます**。

### インテントフィルタ

**インテントフィルタ**は、**アクティビティ、サービス、またはブロードキャストレシーバが異なるタイプのインテントとやり取りする方法**を定義します。基本的に、これらのコンポーネントの機能を記述し、どのようなアクションを実行できるかや処理できるブロードキャストの種類などを示します。これらのフィルタを宣言する主な場所は**AndroidManifest.xmlファイル**ですが、ブロードキャストレシーバの場合はコーディングすることもできます。

インテントフィルタは、カテゴリ、アクション、データフィルタから構成され、追加のメタデータを含めることもできます。この設定により、特定の基準に一致するインテントを処理できるようになります。

Androidコンポーネント（アクティビティ/サービス/コンテンツプロバイダ/ブロードキャストレシーバ）の重要な側面は、その可視性または**公開状態**です。コンポーネントは、マニフェストで**`exported`**属性を**`true`**に設定するか、そのコンポーネントのためにインテントフィルタが宣言されている場合にのみ、他のアプリとやり取りできると見なされます。ただし、開発者はこれらのコンポーネントを意図せず他のアプリとやり取りさせないように明示的に非公開に保つ方法があります。これは、マニフェスト定義で**`exported`**属性を**`false`**に設定することで実現できます。

さらに、開発者はこれらのコンポーネントへのアクセスをさらに保護するために特定の権限を要求するオプションがあります。**`permission`**属性を設定して、指定された権限を持つアプリのみがコンポーネントにアクセスできるように強制することができ、誰がそれとやり取りできるかに対する追加のセキュリティと制御を提供します。
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### 暗黙的インテント

インテントは、Intentコンストラクタを使用してプログラムで作成されます：
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**アクション**は以前に宣言されたインテントの**ACTION\_SEND**であり、**Extra**はmailto **Uri**です（Extraはインテントが期待している追加情報です）。

このインテントは、次の例のようにマニフェスト内で宣言する必要があります：
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
インテントフィルタは、メッセージを受信するために**アクション**、**データ**、および**カテゴリ**と一致する必要があります。

"インテント解決"プロセスは、どのアプリが各メッセージを受信するかを決定します。このプロセスは**優先度属性**を考慮します。これは**インテントフィルタ宣言**で設定でき、**優先度が高いものが選択されます**。この優先度は-1000から1000の間で設定でき、アプリケーションは`SYSTEM_HIGH_PRIORITY`値を使用できます。**競合**が発生すると、"選択ウィンドウ"が表示され、**ユーザーが決定**できます。

### 明示的インテント

明示的インテントは、ターゲットとするクラス名を指定します。
```java
Intent downloadIntent = new (this, DownloadService.class):
```
他のアプリケーションで以前に宣言されたインテントにアクセスするには、次のようにします:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### ペンディングインテント

これにより、他のアプリケーションが**あなたのアプリケーションの代わりにアクションを実行**できます。ペンディングインテントを構築する際は、**インテントと実行するアクションを指定する必要があります**。**宣言されたインテントが明示的でない**場合（どのインテントが呼び出せるかを宣言していない場合）、**悪意のあるアプリケーションが被害者アプリの代わりに宣言されたアクションを実行**できます。さらに、**アクションが指定されていない場合**、悪意のあるアプリは**被害者の代わりに任意のアクションを実行**できます。

### ブロードキャストインテント

以前のインテントとは異なり、ブロードキャストインテントは**複数のアプリに受信される**ことができます。ただし、APIバージョン14以降では、Intent.set Packageを使用して**メッセージを受信するアプリを指定**することが可能です。

また、ブロードキャストを送信する際に**パーミッションを指定することも可能**です。受信アプリはそのパーミッションを持っている必要があります。

ブロードキャストには**通常**（非同期）と**順序付け**（同期）の**2つのタイプ**があります。**順序**は**受信側の構成された優先度に基づいて**います。**各アプリはブロードキャストを処理、中継、または破棄できます**。

`Context`クラスから`sendBroadcast(intent, receiverPermission)`関数を使用して**ブロードキャストを送信**することが可能です。\
また、**`LocalBroadCastManager`**から**`sendBroadcast`**関数を使用すると、**メッセージがアプリを離れることはなくなります**。これにより、受信コンポーネントをエクスポートする必要すらありません。

### スティッキーブロードキャスト

この種のブロードキャストは、**送信後も長い間アクセスできます**。\
これらはAPIレベル21で非推奨となり、**使用しないことが推奨**されています。\
**これにより、任意のアプリケーションがデータを嗅ぎ取るだけでなく、変更することも可能**です。

**`sendStickyBroadcast`**や**`sendStickyBroadcastAsUser`**など、"sticky"という単語を含む関数を見つけた場合は、**影響を確認し、削除を試みてください**。

## ディープリンク / URLスキーム

Androidアプリケーションでは、**ディープリンク**が使用され、URLを介して直接アクション（インテント）を開始します。これは、アクティビティ内で特定の**URLスキーム**を宣言することによって行われます。Androidデバイスがこのスキームを持つURLにアクセスしようとすると、アプリケーション内の指定されたアクティビティが起動されます。

スキームは**`AndroidManifest.xml`**ファイルに宣言する必要があります。
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
前の例からのスキームは `exampleapp://`（**`category BROWSABLE`** も参照）  

次に、データフィールドで **ホスト** と **パス** を指定できます：
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Webからアクセスするには、次のようなリンクを設定することができます：
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
アプリで実行される**コードを見つける**には、ディープリンクで呼び出されるアクティビティに移動し、**`onNewIntent`** 関数を検索します。

HTML ページを使用せずに[ディープリンクを呼び出す方法](./#exploiting-schemes-deep-links)を学びます。

## AIDL - Android Interface Definition Language

**Android Interface Definition Language (AIDL)** は、Android アプリケーション内のクライアントとサービス間のコミュニケーションを**プロセス間通信**（IPC）を通じて容易にするために設計されています。Android では他のプロセスのメモリに直接アクセスすることは許可されていないため、AIDL はオブジェクトをオペレーティングシステムが理解できる形式に変換することで、異なるプロセス間の通信を容易にします。

### 主要な概念

- **バウンド サービス**: これらのサービスは IPC に AIDL を使用し、アクティビティやコンポーネントがサービスにバインドしてリクエストを行い、レスポンスを受け取ることを可能にします。サービスのクラス内の `onBind` メソッドは、相互作用を開始するために重要であり、脆弱性を探すためのセキュリティレビューの重要な領域としてマークされています。

- **Messenger**: バウンド サービスとして機能する Messenger は、`onBind` メソッドを介してデータの処理に焦点を当てた IPC を可能にします。このメソッドを注意深く検査して、安全でないデータ処理や機密関数の実行がないかを確認することが重要です。

- **Binder**: AIDL の抽象化により Binder クラスの直接的な使用は一般的ではありませんが、Binder は異なるプロセスのメモリ空間間でのデータ転送を可能にするカーネルレベルのドライバーとして機能します。さらなる理解のために、リソースが[こちら](https://www.youtube.com/watch?v=O-UHvFjxwZ8)で利用可能です。

## コンポーネント

これには、**アクティビティ、サービス、ブロードキャストレシーバー、プロバイダー**が含まれます。

### ランチャーアクティビティとその他のアクティビティ

Android アプリでは、**アクティビティ**は画面のようなもので、アプリのユーザーインターフェースの異なる部分を表示します。アプリには多くのアクティビティがあり、それぞれがユーザーに一意の画面を表示します。

**ランチャーアクティビティ**は、アプリのアイコンをタップすると起動されるアプリのメインゲートウェイです。これは、アプリのマニフェストファイルで特定の MAIN および LAUNCHER インテントで定義されています。
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
いくつかのアプリには、バックグラウンドサービスのようにユーザーインターフェースを持たないものも含まれるため、すべてのアプリがランチャーアクティビティを必要とするわけではありません。

アクティビティは、マニフェストで「exported」とマークすることで、他のアプリやプロセスで利用可能にすることができます。この設定により、他のアプリがこのアクティビティを起動できるようになります。
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
しかし、別のアプリからアクティビティにアクセスすることは常にセキュリティリスクとは限りません。懸念されるのは、機密データが適切に共有されていない場合であり、これは情報漏洩につながる可能性があります。

アクティビティのライフサイクルは、**`onCreate`メソッド**で始まり、UIの設定とアクティビティのユーザーとのやり取りの準備を行います。

### アプリケーションのサブクラス

Android開発では、アプリは[Application](https://developer.android.com/reference/android/app/Application)クラスの**サブクラス**を作成するオプションがありますが、これは必須ではありません。このようなサブクラスが定義されている場合、そのサブクラスがアプリ内で最初にインスタンス化されます。このサブクラスで実装されている場合、**`attachBaseContext`**メソッドは**`onCreate`**メソッドの前に実行されます。このセットアップにより、アプリケーションの残りの部分が開始される前に初期化を行うことができます。
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### サービス

[サービス](https://developer.android.com/guide/components/services)はユーザーインターフェースなしでタスクを実行できる**バックグラウンドオペレーター**です。これらのタスクは、ユーザーが異なるアプリケーションに切り替えても継続して実行されるため、**長時間実行される操作**にはサービスが不可欠です。

サービスは多目的であり、さまざまな方法で開始できます。**インテント**は、サービスを起動するための主要な方法であり、アプリケーションのエントリーポイントとして機能します。サービスを`startService`メソッドを使用して開始すると、その`onStart`メソッドが実行され、`stopService`メソッドが明示的に呼び出されるまで実行を継続します。また、サービスの役割がアクティブなクライアント接続に依存する場合、クライアントをサービスにバインドするために`bindService`メソッドが使用され、データの受け渡しに`onBind`メソッドが関与します。

サービスの興味深い応用例には、アプリとのやり取りを妨げることなく、バックグラウンドで音楽を再生したりネットワークデータを取得したりすることが含まれます。さらに、サービスは**エクスポート**を介して同じデバイス上の他のプロセスからアクセス可能にすることができます。これはデフォルトの動作ではなく、Android Manifestファイルで明示的に構成する必要があります。
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### ブロードキャストレシーバ

**ブロードキャストレシーバ**は、メッセージングシステムにおけるリスナーとして機能し、複数のアプリケーションがシステムからの同じメッセージに応答できるようにします。アプリは、**マニフェスト**を介してまたはアプリのコード内で **`registerReceiver`** API を使用して、**2つの主要な方法**で **レシーバを登録**できます。マニフェストでは、ブロードキャストは権限でフィルタリングされますが、動的に登録されたレシーバは登録時に権限を指定することもできます。

**インテントフィルタ**は、登録方法に関係なく重要であり、どのブロードキャストがレシーバをトリガーするかを決定します。一致するブロードキャストが送信されると、レシーバの **`onReceive`** メソッドが呼び出され、アプリは適切に反応することができます。たとえば、低電池アラートに応じて動作を調整するなどです。

ブロードキャストは、**非同期**であり、順不同ですべてのレシーバに到達するか、**同期**であり、レシーバが優先順位に基づいてブロードキャストを受け取るかのいずれかです。ただし、どのアプリも自分自身を優先してブロードキャストを傍受できる可能性があるため、潜在的なセキュリティリスクに注意することが重要です。

レシーバの機能を理解するには、そのクラス内の **`onReceive`** メソッドを探します。このメソッドのコードは受信したインテントを操作でき、特に **順序付けられたブロードキャスト**では、インテントを変更したり破棄したりする必要があるため、レシーバによるデータの検証が重要です。

### コンテンツプロバイダ

**コンテンツプロバイダ**は、アプリケーション間で **構造化されたデータを共有**するために不可欠であり、データのセキュリティを確保するために **権限の実装**の重要性を強調しています。これにより、アプリはデータベース、ファイルシステム、またはウェブなど、さまざまなソースからデータにアクセスできます。`readPermission` および `writePermission` などの特定の権限は、アクセスを制御するために重要です。さらに、一時的なアクセスは、アプリのマニフェストで **`grantUriPermission`** 設定を介して付与でき、`path`、`pathPrefix`、`pathPattern` などの属性を活用して詳細なアクセス制御を行います。

脆弱性（SQLインジェクションなど）を防ぐために、入力検証が極めて重要です。コンテンツプロバイダは、`insert()`、`update()`、`delete()`、`query()` などの基本操作をサポートし、データの操作とアプリケーション間での共有を容易にします。

**FileProvider** は、ファイルを安全に共有することに焦点を当てた特殊なコンテンツプロバイダです。フォルダへのアクセスを制御するための特定の属性でアプリのマニフェストで定義され、`android:exported` および `android:resource` がフォルダ構成を指すようになっています。機密データが誤って公開されるのを避けるために、ディレクトリを共有する際には注意が必要です。

FileProvider の例示的なマニフェスト宣言：
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
そして、`filepaths.xml` で共有フォルダを指定する例:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
For further information check:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews are like **mini web browsers** inside Android apps, pulling content either from the web or from local files. They face similar risks as regular browsers, yet there are ways to **reduce these risks** through specific **settings**.

Android offers two main WebView types:

- **WebViewClient** is great for basic HTML but doesn't support the JavaScript alert function, affecting how XSS attacks can be tested.
- **WebChromeClient** acts more like the full Chrome browser experience.

A key point is that WebView browsers do **not share cookies** with the device's main browser.

For loading content, methods such as ````loadUrl````, ````loadData````, and ````loadDataWithBaseURL```` are available. It's crucial to ensure these URLs or files are **safe to use**. Security settings can be managed via the ````WebSettings```` class. For instance, disabling JavaScript with ````setJavaScriptEnabled(false)```` can prevent XSS attacks.

The JavaScript "Bridge" lets Java objects interact with JavaScript, requiring methods to be marked with ````@JavascriptInterface```` for security from Android 4.2 onwards.

Allowing content access (````setAllowContentAccess(true)````) lets WebViews reach Content Providers, which could be a risk unless the content URLs are verified as secure.

To control file access:
- Disabling file access (````setAllowFileAccess(false)````) limits access to the filesystem, with exceptions for certain assets, ensuring they're only used for non-sensitive content.

## Other App Components and Mobile Device Management

### **Digital Signing of Applications**

- **Digital signing** is a must for Android apps, ensuring they're **authentically authored** before installation. This process uses a certificate for app identification and must be verified by the device's package manager upon installation. Apps can be **self-signed or certified by an external CA**, safeguarding against unauthorized access and ensuring the app remains untampered during its delivery to the device.

### **App Verification for Enhanced Security**

- Starting from **Android 4.2**, a feature called **Verify Apps** allows users to have apps checked for safety before installation. This **verification process** can warn users against potentially harmful apps, or even prevent the installation of particularly malicious ones, enhancing user security.

### **Mobile Device Management (MDM)**

- **MDM solutions** provide **oversight and security** for mobile devices through **Device Administration API**. They necessitate the installation of an Android app to manage and secure mobile devices effectively. Key functions include **enforcing password policies**, **mandating storage encryption**, and **permitting remote data wipe**, ensuring comprehensive control and security over mobile devices.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong>を使用して、ゼロからヒーローまでAWSハッキングを学びましょう！</summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションをご覧ください
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)を**フォロー**してください。
- **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>
