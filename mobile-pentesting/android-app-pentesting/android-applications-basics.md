# Androidアプリケーションの基礎

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見る
- **Discordグループ**に**参加**する💬（https://discord.gg/hRep4RUj7f）または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦で**フォロー**する [**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
- **HackTricks**（https://github.com/carlospolop/hacktricks）と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出して、あなたのハッキングテクニックを共有してください。

</details>

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Androidセキュリティモデル

**2つのレイヤーがあります：**

- **OS**：インストールされたアプリケーションを互いに分離します。
- **アプリケーション自体**：開発者が**特定の機能を公開**し、アプリケーションの機能を構成できるようにします。

### UID分離

**各アプリケーションには特定のユーザーIDが割り当てられます**。これはアプリのインストール中に行われ、**アプリは自分のユーザーIDで所有しているファイルまたは共有ファイルにのみアクセス**できます。したがって、アプリ自体、OSの特定のコンポーネント、およびルートユーザーだけがアプリのデータにアクセスできます。

### UID共有

**2つのアプリケーションを同じUIDを使用するように構成できます**。これは情報を共有するのに役立ちますが、1つが侵害されると両方のアプリケーションのデータが侵害されます。このため、この動作は**推奨されません**。\
**同じUIDを共有するには、アプリケーションはマニフェストで同じ `android:sharedUserId` 値を定義する必要があります。**

### サンドボックス

**Androidアプリケーションサンドボックス**を使用すると、**各アプリケーション**を**別のプロセスとして別のユーザーIDで実行**できます。各プロセスには独自の仮想マシンがあり、アプリのコードは他のアプリから隔離されて実行されます。\
Android 5.0（L）からは**SELinux**が強制されています。基本的に、SELinuxはすべてのプロセスの相互作用を拒否し、それからそれらの間で**予想される相互作用のみを許可するポリシーを作成**しました。

### 権限

アプリをインストールするときに**権限を要求すると、**AndroidManifest.xml**ファイルの**`uses-permission`**要素で構成された権限を要求しています。**uses-permission**要素は、**name** **属性内の要求された権限の名前**を示します。**maxSdkVersion**属性もあり、指定されたバージョンよりも高いバージョンでは権限を要求しなくなります。\
Androidアプリケーションは最初からすべての権限を要求する必要はなく、**動的に権限を要求**することもできますが、すべての権限は**マニフェストで宣言**されている必要があります。

アプリが機能を公開すると、**指定された権限を持つアプリにのみアクセス**を制限できます。\
権限要素には3つの属性があります：

- 権限の**名前**
- 権限グループをグループ化する**permission-group**属性
- 権限がどのように付与されるかを示す**protection-level**。4つのタイプがあります：
  - **Normal**：アプリに**既知の脅威がない**場合に使用されます。ユーザーは**承認を求められません**。
  - **Dangerous**：権限が要求されたアプリケーションに**一部の権限が与えられる**ことを示します。**ユーザーは承認を求められます**。
  - **Signature**：**エクスポートしているコンポーネントと同じ証明書で署名されたアプリ**のみが権限を付与されることができます。これは最も強力な保護のタイプです。
  - **SignatureOrSystem**：**エクスポートしているコンポーネントと同じ証明書で署名されたアプリ**または**システムレベルのアクセスで実行されているアプリ**のみが権限を付与されることができます。

## 事前インストールされたアプリケーション

これらのアプリは一般的に**`/system/app`**または**`/system/priv-app`**ディレクトリにあり、一部は**最適化されています**（`classes.dex`ファイルが見つからない場合があります）。これらのアプリケーションは、**rootとして実行されることが多いため**、チェックする価値があります。

- **AOSP**（Androidオープンソースプロジェクト）**ROM**に含まれるもの
- デバイスの**製造元**によって追加されたもの
- 携帯電話プロバイダーによって追加されたもの（それらから購入した場合）

## ルート化

物理的なAndroidデバイスにルートアクセスを取得するには、通常、デバイスとバージョンに**特定の脆弱性を悪用**する必要があります。\
悪用が機能すると、通常、Linuxの`su`バイナリがユーザーのPATH環境変数で指定された場所にコピーされます（たとえば`/system/xbin`）。

suバイナリが構成されると、他のAndroidアプリが`su`バイナリとのやり取りを処理するために使用されます。**Superuser**や**SuperSU**などのアプリ（Google Playストアで利用可能）。

{% hint style="danger" %}
ルート化プロセスは非常に危険であり、デバイスに重大な損害を与える可能性があります
{% endhint %}

### ROM

**カスタムファームウェアをインストールしてOSを置き換える**ことができます。これにより、古いデバイスの有用性を拡張したり、ソフトウェアの制限をバイパスしたり、最新のAndroidコードにアクセスしたりすることができます。\
**OmniROM**と**LineageOS**は、最も人気のあるファームウェアの2つです。

デバイスをルート化する必要があるわけではないことに注意してください。**一部のメーカーは**、ブートローダーのアンロックを**十分に文書化された安全な方法**で許可しています。

### 影響

デバイスがルート化されると、任意のアプリがルートアクセスを要求できます。悪意のあるアプリがそれを取得した場合、ほとんどすべてにアクセスでき、電話を破損させることができます。

## Androidアプリケーションの基礎 <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Androidアプリケーションの形式は_APKファイル形式_と呼ばれます。基本的には**ZIPファイル**です（ファイル拡張子を.zipに変更することで、内容を抽出して表示できます）。
- APKの内容（完全ではありません）
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc：バイナリXMLなど、事前にコンパイルされたリソースを含む
- res/xml/files\_paths.xml
- META-INF/
- 証明書が配置されている場所です！
- **classes.dex**
- デフォルトでアプリケーションが実行する、コンパイルされたJava（またはKotlin）コードを表すDalvikバイトコードが含まれています。
- lib/
- CPUアーキテクチャごとにサブディレクトリに分かれたネイティブライブラリが格納されています。
  - `armeabi`：ARMベースのプロセッサ用のコード
  - `armeabi-v7a`：ARMv7およびそれ以上のプロセッサ用のコード
  - `x86`：X86プロセッサ用のコード
  - `mips`：MIPSプロセッサ用のコードのみ
- assets/
- アプリに必要なその他のファイルを格納し、追加のネイティブライブラリやDEXファイルを含むことがあります。これは、追加のコードを隠すためにマルウェア作成者によって使用されることがあります。
- res/
- resources.arscにコンパイルされていないリソースが含まれています
### **Dalvik & Smali**

Android開発では、**JavaまたはKotlin**がアプリを作成するために使用されます。デスクトップアプリケーションとは異なり、Androidはこのコードを**Dalvik Executable (DEX) bytecode**にコンパイルします。以前はDalvik仮想マシンがこのバイトコードを処理していましたが、新しいAndroidバージョンではAndroid Runtime (ART)が引き継いでいます。

逆コンパイルには、**Smali**が重要になります。これはDEXバイトコードの人間が読めるバージョンであり、ソースコードをバイトコード命令に変換することでアセンブリ言語のように機能します。Smaliとbaksmaliはこの文脈でのアセンブリおよび逆アセンブリツールを指します。

## インテント

インテントは、Androidアプリがコンポーネント間や他のアプリと通信する主要手段です。これらのメッセージオブジェクトは、アプリ間やコンポーネント間でデータをやり取りするために使用され、HTTP通信でのGET/POSTリクエストのように機能します。

つまり、インテントは基本的に**コンポーネント間で渡されるメッセージ**です。インテントは特定のコンポーネントやアプリに**向けられることもあり**、**特定の受信者なしに送信**されることもあります。\
簡単に言うと、インテントは以下のように使用できます：

* 通常はアプリのユーザーインターフェースを開くためにActivityを開始するため
* システムやアプリに変更を通知するためのブロードキャストとして
* バックグラウンドサービスの開始、停止、および通信のため
* ContentProvidersを介してデータにアクセスするため
* イベントを処理するためのコールバックとして

脆弱性がある場合、**インテントはさまざまな攻撃に使用**される可能性があります。

### インテントフィルタ

**インテントフィルタ**は、**アクティビティ、サービス、またはブロードキャストレシーバが異なるタイプのインテントとやり取りする方法**を定義します。基本的に、これらのコンポーネントが行うアクションや処理できるブロードキャストの種類など、これらのコンポーネントの機能を記述します。これらのフィルタを宣言する主な場所は**AndroidManifest.xmlファイル**ですが、ブロードキャストレシーバの場合はコーディングすることもできます。

インテントフィルタは、カテゴリ、アクション、およびデータフィルタから構成され、追加のメタデータを含めることも可能です。この設定により、特定の基準に一致するインテントを処理するコンポーネントを設定できます。

Androidコンポーネント（アクティビティ/サービス/コンテンツプロバイダ/ブロードキャストレシーバ）の重要な側面は、その可視性または**公開状態**です。コンポーネントは、マニフェストで**`exported`**属性を**`true`**に設定するか、そのコンポーネントのためにインテントフィルタが宣言されている場合に、他のアプリとやり取りできると見なされます。ただし、開発者がこれらのコンポーネントを意図せずに他のアプリとやり取りさせないようにする方法があります。これは、マニフェスト定義で**`exported`**属性を**`false`**に設定することで実現できます。

さらに、開発者はこれらのコンポーネントへのアクセスをさらに保護するために特定の権限を要求するオプションがあります。**`permission`**属性を設定して、指定された権限を持つアプリのみがコンポーネントにアクセスできるように強制することができ、誰がそれとやり取りできるかに対する追加のセキュリティと制御のレイヤーを追加します。
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### 暗黙的インテント

インテントは、Intentコンストラクタを使用してプログラムで作成されます：
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**アクション**は以前に宣言されたインテントの**ACTION\_SEND**であり、**Extra**はmailto **Uri**です（Extraはインテントが期待している追加情報です）。

このインテントは、次の例のようにマニフェスト内で宣言する必要があります：
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
インテントフィルタは、メッセージを受信するために**アクション**、**データ**、および**カテゴリ**と一致する必要があります。

"インテント解決"プロセスは、どのアプリが各メッセージを受信するかを決定します。このプロセスは**優先度属性**を考慮します。これは**インテントフィルタ宣言**で設定でき、**優先度が高いものが選択されます**。この優先度は-1000から1000の間で設定でき、アプリケーションは`SYSTEM_HIGH_PRIORITY`値を使用できます。**競合**が発生すると、"選択"ウィンドウが表示され、**ユーザーが決定**できます。

### 明示的インテント

明示的インテントは、ターゲットとするクラス名を指定します。
```java
Intent downloadIntent = new (this, DownloadService.class):
```
他のアプリケーションで以前に宣言されたインテントにアクセスするには、次のようにします:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### ペンディングインテント

これらは、他のアプリケーションが**あなたのアプリケーションの代わりにアクションを実行**することを可能にします。ペンディングインテントを構築する際には、**インテントと実行するアクションを指定する必要があります**。**宣言されたインテントが明示的でない**場合（どのインテントが呼び出せるかを宣言していない）、**悪意のあるアプリケーションが被害者アプリの代わりに宣言されたアクションを実行**する可能性があります。さらに、**アクションが指定されていない場合**、悪意のあるアプリは**被害者の代わりに任意のアクションを実行**することができます。

### ブロードキャストインテント

以前のインテントとは異なり、ブロードキャストインテントは**複数のアプリケーションに受信される**ことができます。ただし、APIバージョン14からは、Intent.setPackageを使用して**メッセージを受信するアプリを指定することが可能**です。

また、ブロードキャストを送信する際に**パーミッションを指定することも可能**です。受信アプリはそのパーミッションを持っている必要があります。

ブロードキャストには**2つのタイプ**があります：**通常**（非同期）と**順序付け**（同期）。**順序**は**レシーバ内で構成された優先順位に基づいて**います。**各アプリはブロードキャストを処理、中継、または破棄できます**。

`Context`クラスから`sendBroadcast(intent, receiverPermission)`関数を使用して**ブロードキャストを送信**することが可能です。\
また、**`LocalBroadCastManager`**から**`sendBroadcast`**関数を使用すると、**メッセージがアプリを離れることはなく**なります。これを使用すると、レシーバコンポーネントをエクスポートする必要すらありません。

### スティッキーブロードキャスト

この種のブロードキャストは、**送信されてから長い時間が経過してもアクセスできます**。\
これらはAPIレベル21で非推奨となり、**使用しないことが推奨**されています。\
**これらは任意のアプリケーションがデータを嗅ぐだけでなく、変更することも可能**です。

**`sendStickyBroadcast`**や**`sendStickyBroadcastAsUser`**のように「sticky」という単語を含む関数を見つけた場合は、**影響を確認して削除を試みてください**。

## ディープリンク / URLスキーム

Androidアプリケーションでは、**ディープリンク**が使用され、URLを介して直接アクション（インテント）を開始します。これは、アクティビティ内で特定の**URLスキーム**を宣言することによって行われます。Androidデバイスがこのスキームを持つURLにアクセスしようとすると、アプリケーション内の指定されたアクティビティが起動されます。

スキームは**`AndroidManifest.xml`**ファイルに宣言する必要があります。
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
前の例からのスキームは `exampleapp://`（**`category BROWSABLE`** も参照）  

次に、データフィールドで **ホスト** と **パス** を指定できます：
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Web からアクセスするには、次のようにリンクを設定することができます:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
**アプリで実行されるコード**を見つけるには、ディープリンクによって呼び出されるアクティビティに移動し、**`onNewIntent`** 関数を検索します。

[HTML ページを使用せずにディープリンクを呼び出す方法](./#exploiting-schemes-deep-links)を学びます。

## AIDL - Android インターフェース定義言語

**Android インターフェース定義言語 (AIDL)** は、Android アプリケーション内のクライアントとサービス間のコミュニケーションを容易にするために設計されています。別のプロセスのメモリに直接アクセスすることは Android では許可されていないため、AIDL はオブジェクトをオペレーティングシステムが理解する形式にマーシャリングして、異なるプロセス間での通信を容易にします。

### 主要な概念

- **バウンド サービス**: これらのサービスは IPC に AIDL を利用し、アクティビティやコンポーネントがサービスにバインドしてリクエストを行い、レスポンスを受け取ることができます。サービスのクラス内の `onBind` メソッドは、相互作用を開始するために重要であり、脆弱性を探すためのセキュリティレビューの重要な領域としてマークされています。

- **Messenger**: バウンド サービスとして動作する Messenger は IPC を容易にし、`onBind` メソッドを通じてデータの処理に焦点を当てています。このメソッドを注意深く検査して、安全でないデータ処理や機密関数の実行がないかを確認することが重要です。

- **Binder**: AIDL の抽象化により Binder クラスの直接的な使用は一般的ではありませんが、Binder が異なるプロセスのメモリ空間間でデータ転送を可能にするカーネルレベルのドライバーとして機能することを理解することは有益です。詳細な理解のために、次のリソースが利用可能です: [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)。

## コンポーネント

これには、**アクティビティ、サービス、ブロードキャスト レシーバー、プロバイダー**が含まれます。

### ランチャーアクティビティとその他のアクティビティ

Android アプリでは、**アクティビティ**は画面のようなもので、アプリのユーザーインターフェースの異なる部分を表示します。アプリには多くのアクティビティがあり、それぞれがユーザーに一意の画面を表示します。

**ランチャーアクティビティ**はアプリへのメインゲートウェイであり、アプリのアイコンをタップすると起動されます。特定の MAIN および LAUNCHER インテントでアプリのマニフェストファイルで定義されています。
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
不要なランチャーアクティビティを持つアプリもありますが、特にバックグラウンドサービスのようなユーザーインターフェースを持たないアプリもあります。

アクティビティは、マニフェストで「exported」とマークすることで、他のアプリやプロセスから利用可能にすることができます。この設定により、他のアプリがこのアクティビティを起動できるようになります。
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
しかし、別のアプリからアクティビティにアクセスすることは常にセキュリティリスクとは限りません。懸念されるのは、機密データが適切に共有されていない場合であり、これは情報漏洩につながる可能性があります。

アクティビティのライフサイクルは、**`onCreate`メソッドで始まり**、UIの設定とアクティビティをユーザーとのやり取りに準備します。

### アプリケーションのサブクラス

Android開発では、アプリは[Application](https://developer.android.com/reference/android/app/Application)クラスの**サブクラス**を作成するオプションがありますが、これは必須ではありません。このようなサブクラスが定義されている場合、それはアプリ内で最初にインスタンス化されるクラスとなります。このサブクラスで実装されている場合、**`attachBaseContext`**メソッドは**`onCreate`**メソッドの前に実行されます。このセットアップにより、アプリケーションの残りの部分が開始する前に初期化を行うことができます。
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### サービス

[サービス](https://developer.android.com/guide/components/services)はユーザーインターフェースなしでタスクを実行できる**バックグラウンドオペレータ**です。これらのタスクは、ユーザーが異なるアプリケーションに切り替えても継続して実行されるため、サービスは**長時間実行される操作**にとって重要です。

サービスは多目的であり、さまざまな方法で開始できます。**インテント**は、サービスを起動するための主要な方法であり、アプリケーションのエントリーポイントとして機能します。サービスを`startService`メソッドを使用して開始すると、その`onStart`メソッドが実行され、`stopService`メソッドが明示的に呼び出されるまで実行を維持します。また、サービスの役割がアクティブなクライアント接続に依存する場合は、クライアントをサービスにバインドするために`bindService`メソッドが使用され、データの受け渡しに`onBind`メソッドが関与します。

サービスの興味深い応用例には、アプリとのやり取りを妨げることなく、バックグラウンドで音楽を再生したりネットワークデータを取得したりすることが含まれます。さらに、サービスは**エクスポート**を介して同じデバイス上の他のプロセスからアクセス可能にすることができます。これはデフォルトの動作ではなく、Android Manifestファイルで明示的に構成する必要があります。
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### ブロードキャストレシーバ

**ブロードキャストレシーバ**は、メッセージングシステムにおけるリスナーとして機能し、複数のアプリケーションがシステムからの同じメッセージに応答できるようにします。アプリは、**マニフェスト**を介してまたはアプリのコード内で **`registerReceiver`** API を使用して、**2つの主要な方法**で **レシーバを登録**できます。マニフェストでは、ブロードキャストは権限でフィルタリングされますが、動的に登録されたレシーバは登録時に権限を指定することもできます。

**インテントフィルタ**は、登録方法に関係なく重要であり、どのブロードキャストがレシーバをトリガーするかを決定します。一致するブロードキャストが送信されると、レシーバの **`onReceive`** メソッドが呼び出され、アプリは適切に反応することができます。たとえば、低バッテリーアラートに応じて動作を調整するなどです。

ブロードキャストは、**非同期**であり、順不同ですべてのレシーバに到達するか、**同期**であり、レシーバが優先順位に基づいてブロードキャストを受信するかのいずれかです。ただし、どのアプリも自分自身を優先してブロードキャストを傍受できる可能性があるため、潜在的なセキュリティリスクに注意することが重要です。

レシーバの機能を理解するには、そのクラス内の **`onReceive`** メソッドを探します。このメソッドのコードは受信したインテントを操作でき、特に **順序付けられたブロードキャスト**では、インテントを変更したり破棄したりする必要があるため、レシーバによるデータの検証が重要です。

### コンテンツプロバイダ

**コンテンツプロバイダ**は、アプリケーション間で **構造化されたデータを共有**するために不可欠であり、データセキュリティを確保するために **権限の実装**の重要性を強調しています。これにより、アプリはデータベース、ファイルシステム、またはウェブなど、さまざまなソースからデータにアクセスできます。**`readPermission`** および **`writePermission`** のような特定の権限は、アクセスを制御するために重要です。また、一時的なアクセスは、アプリのマニフェストで **`grantUriPermission`** 設定を介して付与でき、`path`、`pathPrefix`、`pathPattern` などの属性を活用して詳細なアクセス制御を行うことができます。

脆弱性（SQLインジェクションなど）を防ぐために、入力検証は極めて重要です。コンテンツプロバイダは、`insert()`、`update()`、`delete()`、`query()` などの基本操作をサポートしており、データの操作やアプリケーション間での共有を容易にしています。

**FileProvider** は、ファイルを安全に共有することに焦点を当てた特殊なコンテンツプロバイダです。フォルダへのアクセスを制御するための特定の属性でアプリのマニフェストに定義され、`android:exported` および `android:resource` によってフォルダ構成を指定します。機密データが誤って公開されるのを避けるために、ディレクトリを共有する際には注意が必要です。

FileProvider の例示的なマニフェスト宣言：
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
そして、`filepaths.xml` で共有フォルダを指定する例:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
For further information check:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews are like **mini web browsers** inside Android apps, pulling content either from the web or from local files. They face similar risks as regular browsers, yet there are ways to **reduce these risks** through specific **settings**.

Android offers two main WebView types:

- **WebViewClient** is great for basic HTML but doesn't support the JavaScript alert function, affecting how XSS attacks can be tested.
- **WebChromeClient** acts more like the full Chrome browser experience.

A key point is that WebView browsers do **not share cookies** with the device's main browser.

For loading content, methods such as ````loadUrl````, ````loadData````, and ````loadDataWithBaseURL```` are available. It's crucial to ensure these URLs or files are **safe to use**. Security settings can be managed via the ````WebSettings```` class. For instance, disabling JavaScript with ````setJavaScriptEnabled(false)```` can prevent XSS attacks.

The JavaScript "Bridge" lets Java objects interact with JavaScript, requiring methods to be marked with ````@JavascriptInterface```` for security from Android 4.2 onwards.

Allowing content access (````setAllowContentAccess(true)````) lets WebViews reach Content Providers, which could be a risk unless the content URLs are verified as secure.

To control file access:
- Disabling file access (````setAllowFileAccess(false)````) limits access to the filesystem, with exceptions for certain assets, ensuring they're only used for non-sensitive content.

## Other App Components and Mobile Device Management

### **Digital Signing of Applications**

- **Digital signing** is a must for Android apps, ensuring they're **authentically authored** before installation. This process uses a certificate for app identification and must be verified by the device's package manager upon installation. Apps can be **self-signed or certified by an external CA**, safeguarding against unauthorized access and ensuring the app remains untampered during its delivery to the device.

### **App Verification for Enhanced Security**

- Starting from **Android 4.2**, a feature called **Verify Apps** allows users to have apps checked for safety before installation. This **verification process** can warn users against potentially harmful apps, or even prevent the installation of particularly malicious ones, enhancing user security.

### **Mobile Device Management (MDM)**

- **MDM solutions** provide **oversight and security** for mobile devices through **Device Administration API**. They necessitate the installation of an Android app to manage and secure mobile devices effectively. Key functions include **enforcing password policies**, **mandating storage encryption**, and **permitting remote data wipe**, ensuring comprehensive control and security over mobile devices.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）を使用して、ゼロからヒーローまでAWSハッキングを学ぶ</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[NFTs](https://opensea.io/collection/the-peass-family)コレクションを見つける
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)で**フォロー**する
- **HackTricks**および**HackTricks Cloud**のgithubリポジトリにPRを提出して、あなたのハッキングトリックを共有する

</details>
