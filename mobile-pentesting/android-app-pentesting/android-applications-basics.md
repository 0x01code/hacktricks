# Androidアプリケーションの基礎

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて修正できるようにしましょう。Intruderは、攻撃対象の範囲を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリまで、クラウドシステムまで、問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Androidセキュリティモデル

**2つのレイヤーがあります：**

* **OS**は、インストールされたアプリケーションを互いに分離します。
* **アプリケーション自体**は、開発者が**特定の機能を公開**し、アプリケーションの機能を設定できるようにします。

### UIDの分離

**各アプリケーションには、特定のユーザーIDが割り当てられます**。これはアプリのインストール時に行われ、**アプリは自分のユーザーIDが所有するファイルと共有されるファイルとのみやり取りできます**。したがって、アプリ自体、OSの特定のコンポーネント、およびルートユーザーのみがアプリのデータにアクセスできます。

### UIDの共有

**2つのアプリケーションは同じUIDを使用するように設定できます**。これは情報を共有するために便利ですが、1つが侵害されると両方のアプリケーションのデータが侵害されます。これがこの動作が**推奨されない**理由です。\
**同じUIDを共有するには、アプリケーションはマニフェストで同じ`android:sharedUserId`値を定義する必要があります。**

### サンドボックス

**Androidアプリケーションサンドボックス**は、**各アプリケーション**を**別のプロセスとして別のユーザーIDで実行**することを可能にします。各プロセスには独自の仮想マシンがあり、アプリのコードは他のアプリから分離して実行されます。\
Android 5.0（L）以降、**SELinux**が強制されています。基本的に、SELinuxはすべてのプロセス間の相互作用を拒否し、それらの間の**予想される相互作用のみを許可するポリシーを作成**します。

### 権限

アプリをインストールすると、アプリは**権限を要求**します。これは、**AndroidManifest.xml**ファイルの**`uses-permission`**要素で構成された権限を要求していることを意味します。**uses-permission**要素は、**name**属性内の要求された権限の名前を示します。また、**maxSdkVersion**属性もあり、指定したバージョンよりも高いバージョンでは権限の要求を停止します。\
Androidアプリケーションは最初からすべての権限を要求する必要はなく、**動的に権限を要求**することもできますが、すべての権限は**マニフェストに宣言**されている必要があります。

アプリが機能を公開する場合、**指定された権限を持つアプリのみがアクセスできるように制限**することができます。\
権限要素には3つの属性があります：

* 権限の**名前**
* 関連する権限をグループ化するための**permission-group**属性
* 権限がどのように付与されるかを示す**protection-level**。4つのタイプがあります：
  * **Normal**：アプリに**既知の脅威がない**場合に使用されます。ユーザーは**承認する必要はありません**。
  * **Dangerous**：権限が要求するアプリケーションに**特権アクセス**を与えます。**ユーザーに承認を要求します**。
  * **Signature**：コンポーネントをエクスポートする**同じ証明書で署名されたアプリ**のみが権限を付与されます。これは最も強力な保護のタイプです。
  * **SignatureOrSystem**：コンポーネントをエクスポートする**同じ証明書で署名されたアプリ**または**システムレベルのアクセスで実行されるアプリ**のみが権限を付与されます。

## 事前インストールされたアプリケーション

これらのアプリは一般的に**`/system/app`**または**`/system/priv-app`**ディレクトリにあり、その中には**最適化された**ものもあります（`classes.dex`ファイルが見つからない場合があります）。これらのアプリケーションは、**実行時に多くの権限で実行されている**場合があるため、確認する価値があります（rootとして）。

* **AOSP**（Android OpenSource Project）**ROM**に含まれるもの
* デバイスの**製造元**に追加されたもの
* 携帯電話プロバイダーによって追加されたもの（それらから購入した場合）

## ルート化

物理的なAndroidデバイスでルートアクセスを取得するには、通常、**デバイス**と**バージョン**に**特定の脆弱性**を1つまたは2つ**悪用する必要があります**。\
悪用が成功した後、通常はLinuxの`su`バイナリがユーザーのPATH環境変数で指
### ROMs

カスタムファームウェアをインストールすることで、OSを置き換えることが可能です。これにより、古いデバイスの有用性を拡張したり、ソフトウェアの制限を回避したり、最新のAndroidコードにアクセスしたりすることができます。OmniROMとLineageOSは、最も人気のあるファームウェアの2つです。

デバイスにカスタムファームウェアをインストールするためには、必ずしもルート化する必要はありません。一部のメーカーは、ブートローダーのアンロックを十分に文書化された安全な方法で許可しています。

### 影響

デバイスがルート化されると、任意のアプリがルートアクセスを要求することができます。悪意のあるアプリがこれを取得した場合、ほとんどすべてにアクセスでき、電話を破損させることができます。

## Androidアプリケーションの基礎 <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

この導入は、[https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html](https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html)から引用されています。

### 基礎の復習 <a href="#fundamentals-review" id="fundamentals-review"></a>

* Androidアプリケーションは_APKファイル形式_であり、APKは基本的にZIPファイルです（ファイルの拡張子を.zipに変更し、unzipを使用して内容を開くことができます）。
* APKの内容（完全ではありません）
* AndroidManifest.xml
* resources.arsc/strings.xml
* resources.arsc: 例えばバイナリXMLなどの、事前にコンパイルされたリソースを含むファイルです。
* res/xml/files\_paths.xml
* META-INF/
* 証明書がここにあります！
* classes.dex
* アプリケーションがデフォルトで実行するJava（またはKotlin）コードである、DEXファイル形式のDalvikバイトコードです。
* lib/
* アプリケーションのネイティブライブラリは、デフォルトではここにあります。lib/ディレクトリの下に、cpu固有のディレクトリがあります。
* `armeabi`: ARMベースのプロセッサ用のコンパイルされたコードのみ
* `armeabi-v7a`: ARMv7およびそれ以上のプロセッサ用のコンパイルされたコードのみ
* `x86`: X86用のコンパイルされたコード
* `mips`: MIPSプロセッサ用のコンパイルされたコードのみ
* assets/
* アプリが必要とする他のファイルが含まれる場所です。
* ここには、追加のネイティブライブラリやDEXファイルが含まれる場合があります。これは、マルウェアの作成者が追加のコード（ネイティブまたはDalvik）をデフォルトの場所に含めないことで、「隠す」ために行われることがあります。
* res/
* resources.arscにコンパイルされていないリソースが含まれるディレクトリです。

### **DalvikとSmali**

ほとんどのAndroidアプリケーションはJavaで書かれています。Kotlinもサポートされており、Javaとの相互運用が可能です。このワークショップの残りの部分では、私が「Java」と言及するときは「JavaまたはKotlin」という意味だと思ってください。デスクトップアプリケーションのようにJavaコードがJava仮想マシン（JVM）で実行されるのではなく、AndroidではJavaは\_Dalvik Executable（DEX）バイトコード\_\*\*形式にコンパイルされます\*\*。Androidの以前のバージョンでは、バイトコードはDalvik仮想マシンによって変換されました。最近のAndroidのバージョンでは、Androidランタイム（ART）が使用されています。
開発者がJavaで書き、コードがDEXバイトコードにコンパイルされる場合、逆アセンブルするためには逆の方向で作業します。

![開発者のプロセスのフローチャート。JavaからDEXバイトコードへ](https://maddiestone.github.io/AndroidAppRE/images/DevelopersFlow.jpg)

![リバースエンジニアのプロセスのフローチャート。DEXバイトコードからSMALIから逆コンパイルされたJavaへ](https://maddiestone.github.io/AndroidAppRE/images/ReversersFlow.jpg)

**SmaliはDalvikバイトコードの人間が読めるバージョンです**。厳密には、Smaliとbaksmaliはツール（アセンブラとディスアセンブラ）の名前ですが、Androidでは、私たちはしばしば「Smali」という用語を命令に言及するために使用します。コンパイルされたC/C++コードのリバースエンジニアリングやコンピュータアーキテクチャを行ったことがある場合、SMALIはアセンブリ言語のようなものです。それは、より高いレベルのソースコードとバイトコードの間のものです。

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて、より速く修正できるようにしましょう。Intruderは、攻撃対象の範囲を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリまで、テックスタック全体で問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## インテント

インテントは、Androidアプリがコンポーネント間または他のアプリとの間で通信するための主要な手段です。これらのメッセージオブジェクトは、HTTP通信でのGET/POSTリクエストのように、アプリ間またはコンポーネント間でデータを運ぶこともできます。

したがって、インテントは基本的には**コンポーネント間で渡されるメッセージ**です。インテントは特定のコンポーネントやアプリに**向けられることもありますし、特定の受信者なしで送信されることもあります**。
簡単に言えば、インテントは次のように使用できます：

* アクティビティを開始するために、通常はアプリのユーザーインターフェースを開くために使用します。
* システムとアプリに変更を通知するためのブロードキャストとして
* バックグラウンドサービスの開始、停止、および通信のために
* ContentProviderを介してデータにアクセスするために
* イベントを処理するためのコールバックとして

不適切な実装は、データの漏洩、制限された関数の呼び出し、およびプログラムフローの操作につながる可能性があります。

### インテントフィルタ

インテントフィルタは、アクティビティ、サービス、またはブロードキャストレシーバが応答できるインテントの種類を指定します。それはアクティビティやサービスが何ができるか、レシーバがどの種類のブロードキャストを処理できるかを指定します。対応するコンポーネントが宣言されたタイプのインテントを受け取ることができるようにします。インテントフィルタは通常、AndroidManifest.xmlファイルを介して定義されます。ブロードキャストレシーバの場合、コーディングでも定義することができます。インテントフィルタは、カテゴリ、アクション、およびデータフィルタによって定義されます。さらに、追加のメタデータを含むこともあります。

Androidでは、アクティビティ/サービス/コンテンツプロバイダ/ブロードキャストレシーバが`exported
### 暗黙的なインテント

インテントは、Intentコンストラクタを使用してプログラム上で作成されます。
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
以前に宣言されたインテントの**アクション**は**ACTION\_SEND**であり、**エクストラ**はmailto **Uri**です（エクストラはインテントが期待する追加情報です）。

このインテントは、次の例のようにマニフェスト内で宣言する必要があります：
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
インテントフィルタは、メッセージを受け取るために**アクション**、**データ**、および**カテゴリ**と一致する必要があります。

「インテントの解決」プロセスは、各メッセージを受け取るべきアプリを決定します。このプロセスでは、**優先度属性**が考慮されます。この属性は、**インテントフィルタの宣言**で設定でき、**優先度が高いものが選択されます**。この優先度は、-1000から1000の間で設定でき、アプリケーションは`SYSTEM_HIGH_PRIORITY`の値を使用することができます。**競合**が発生した場合、ユーザーが**決定できるように「選択」ウィンドウが表示されます**。

### 明示的インテント

明示的インテントは、ターゲットとなるクラス名を指定します：
```java
Intent downloadIntent = new (this, DownloadService.class):
```
他のアプリケーションでは、事前に宣言されたインテントにアクセスするために次のように使用することができます：
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### 保留中のインテント

これにより、他のアプリケーションがあなたのアプリケーションのアイデンティティと権限を使用してアクションを実行できます。保留中のインテントを構築する際には、インテントと実行するアクションを指定する必要があります。宣言されたインテントが明示的でない場合（どのインテントが呼び出せるかを宣言しない場合）、悪意のあるアプリケーションは被害者アプリの代わりに宣言されたアクションを実行することができます。さらに、アクションが指定されていない場合、悪意のあるアプリは被害者の代わりに任意のアクションを実行することができます。

### ブロードキャストインテント

以前のインテントとは異なり、ブロードキャストインテントは複数のアプリケーションによって受信されることができます。ただし、APIバージョン14以降では、Intent.setPackageを使用してメッセージを受信するアプリを指定することが可能です。

また、ブロードキャストを送信する際には、パーミッションを指定することも可能です。受信側のアプリはそのパーミッションを持っている必要があります。

ブロードキャストには2つのタイプがあります：通常（非同期）と順序付けられた（同期）。順序は、受信側の要素内で設定された優先度に基づいています。各アプリはブロードキャストを処理、中継、または破棄することができます。

Contextクラスの`sendBroadcast(intent, receiverPermission)`関数を使用してブロードキャストを送信することが可能です。また、LocalBroadCastManagerの`sendBroadcast`関数を使用すると、メッセージがアプリを離れることはありません。これを使用すると、受信側コンポーネントをエクスポートする必要もありません。

### スティッキーブロードキャスト

この種のブロードキャストは、送信後に長時間アクセスできます。これらはAPIレベル21で非推奨とされており、使用しないことが推奨されています。これにより、任意のアプリケーションがデータを嗅覚するだけでなく、変更することも可能です。

「sticky」を含む関数（`sendStickyBroadcast`や`sendStickyBroadcastAsUser`など）が見つかった場合は、その影響を確認し、それらを削除しようとしてください。

## ディープリンク/URLスキーム

ディープリンクは、URLを介してインテントをトリガーすることができます。アプリケーションは、アクティビティ内にURLスキームを宣言することができます。したがって、Androidデバイスがそのスキームを使用してアドレスにアクセスしようとするたびに、アプリケーションのアクティビティが呼び出されます。

![](<../../.gitbook/assets/image (214).png>)

この場合、スキームは`myapp://`です（また、**`category BROWSABLE`**に注意してください）。

`intent-filter`内に次のようなものが見つかった場合：

![](<../../.gitbook/assets/image (263).png>)

それは`http://www.example.com/gizmos`のようなものを期待しています。

次のようなものが見つかった場合：

![](<../../.gitbook/assets/image (262).png>)

それは`example://gizmos`で始まるURLを期待していることを意味します。この場合、以下のペイロードを使用して機能を悪用し、任意のページに移動し、JSを実行しようとすることができます。
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
**アプリで実行されるコード**を見つけるために、ディープリンクによって呼び出されるアクティビティに移動し、**`onNewIntent`** 関数を検索します。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

[HTML ページを使用せずにディープリンクを呼び出す方法](./#exploiting-schemes-deep-links)を学びます。

## AIDL - Android Interface Definition Language

**Android Interface Definition Language**（AIDL）を使用すると、**クライアントとサービスが相互プロセス通信**（IPC）を使用してお互いと通信するために合意するプログラミングインターフェースを定義できます。Androidでは、**通常、1つのプロセスは他のプロセスのメモリにアクセスできません**。そのため、通信するために、オブジェクトをオペレーティングシステムが理解できるプリミティブに分解し、オブジェクトをその境界を越えてマーシャリングする必要があります。そのマーシャリングを行うコードは書くのが面倒なので、AndroidはAIDLでそれを処理します。

AIDLを使用するサービスは、**バウンドサービス**と呼ばれます。サービスのクラスには、**`onBind`** メソッドがあります。これが**相互作用が始まる場所**であり、潜在的な脆弱性を探すためにレビューするコードの最初の部分です。

バウンドサービスは、クライアント-サーバーインターフェースのサーバーです。**コンポーネント（アクティビティなど）がサービスにバインドし、リクエストを送信し、レスポンスを受け取り、相互プロセス通信**（IPC）を実行できるようにします。バウンドサービスは通常、他のアプリケーションコンポーネントを提供する間だけ存在し、無期限にバックグラウンドで実行されません。

### Messenger

Messengerは、別のIPCメカニズムの一種です。**Messengerも「バウンドサービス」**であるため、クライアントアプリから渡されるデータも`onBind`メソッドを介して処理されます。したがって、コードレビューはこのメソッドから始め、機密な機能の呼び出しやデータの安全な処理を探す必要があります。

### Binder

Binderクラスが直接呼び出されることは珍しいですが、Binderクラスを抽象化するAIDLを使用する方が簡単です。ただし、**Binderはカーネルレベルのドライバであり、データを1つのプロセスのメモリから別のプロセスのメモリに移動します**（[https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)）。

## コンポーネント

これには、**アクティビティ、サービス、ブロードキャストレシーバー、プロバイダー**が含まれます。

### ランチャーアクティビティとその他のアクティビティ

**Androidアクティビティ**は、**Androidアプリ**のユーザーインターフェースの1つの画面です。そのため、**Androidアクティビティ**はデスクトップアプリケーションのウィンドウに非常に似ています。**Android**アプリには1つ以上のアクティビティが含まれる場合があります。

**ランチャーアクティビティ**は、ほとんどの人がAndroidアプリケーションの**エントリーポイント**と考えるものです。ランチャーアクティビティは、ユーザーがアプリケーションのアイコンをクリックしたときに起動されるアクティビティです。ランチャーアクティビティは、アプリケーションのマニフェストを見ることで特定できます。ランチャーアクティビティは、以下のMAINとLAUNCHERのインテントがリストされています。

UIを持たないアプリケーション、特にバックグラウンドでサービスを実行するプリインストールされたアプリケーション（例：ボイスメール）には、ランチャーアクティビティがない場合があることに注意してください。
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
アクティビティは、デバイス上の他のプロセスがアクティビティを起動できるようにエクスポートすることができます。デフォルトでは、エクスポートされませんが、以下の設定を行うことでエクスポートすることができます。

```xml
android:exported="true"
```

この設定を行うことで、他のプロセスからアクティビティが起動できるようになります。
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
注意：**アクティビティの保護をバイパスする能力は常に脆弱性ではありません**。アクセスしたデータを確認する必要があります。
また、**一部のアクティビティは呼び出し元にデータを返します**。この場合、**`setResult`**メソッドを検索し、Intentパラメータに渡されるデータを確認する必要があります。**もしデータが機密情報であれば、情報漏洩の脆弱性があり、アクティビティと通信可能なアプリで悪用される可能性があります**。

**アクティビティのコードは`onCreate`メソッドで始まります**。

### アプリケーションのサブクラス

Androidアプリケーションは、[Application](https://developer.android.com/reference/android/app/Application)の**サブクラス**を定義することができます。AndroidアプリがApplicationのサブクラスを定義する場合、**このクラスはアプリケーション内の他のクラスよりも先にインスタンス化されます**。

アプリケーションのサブクラスで**`attachBaseContext`**メソッドが定義されている場合、**`onCreate`**メソッドの前に呼び出されます。

### サービス

[サービス](https://developer.android.com/guide/components/services)は、**UIを持たないバックグラウンドで実行される**ものです。**ユーザーが別のアプリケーションを使用し始めても、長時間実行するために使用されます**。

サービスはさまざまな方法で開始されるため、アプリケーションのエントリーポイントとなります。サービスをエントリーポイントとして開始するデフォルトの方法は、**インテント**を使用することです。

サービスを開始するために**`startService`**メソッドが呼び出されると、サービス内の**`onStart`**メソッドが実行されます。このメソッドは、**`stopService`**メソッドが呼び出されるまで無期限に実行されます。サービスがクライアントが接続している間だけ必要な場合は、クライアントは**`bindService`**メソッドを使用してサービスに「バインド」する必要があります。

**バウンドサービス**の場合（前のセクションを参照）、データは**`onBind`**メソッドに渡されます。

たとえば、サービスはユーザーが別のアプリケーションにいる間にバックグラウンドで音楽を再生したり、ネットワーク経由でデータを取得したりする場合があります。

**サービスはエクスポートされることがあり、デバイス上の他のプロセスからサービスを開始できます**。デフォルトでは、サービスはエクスポートされませんが、マニフェストで設定することができます。
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### ブロードキャストレシーバー

ブロードキャストはメッセージングシステムと考えることができ、**ブロードキャストレシーバーはリスナーです**。アプリケーションが特定のブロードキャストのためにレシーバーを登録している場合、システムがブロードキャストを送信すると、そのレシーバー内のコードが実行されます。なお、この場合、**複数のアプリが同じメッセージを受け取ることができます**。

アプリは**2つの方法**でレシーバーを登録することができます。**アプリのマニフェスト**に登録するか、アプリのコードで**`registerReceiver`** API呼び出しを使用して**動的に登録**するかです。マニフェストでは、レシーバー要素内で**パーミッションを使用して受け入れるブロードキャストを制限**することができます。**動的に**定義する場合は、**`registerReceiver`メソッドにパーミッションを渡す**ことができます。

いずれの場合でも、レシーバーを登録するためには、レシーバーの**インテントフィルターを設定**する必要があります。これらのインテントフィルターは、レシーバーをトリガーするべきブロードキャストです。

レシーバーが登録されている特定のブロードキャストが送信されると、BroadcastReceiverクラスの**`onReceive`**が**実行**されます。

例えば、アプリケーションは低電池メッセージのためにレシーバーを登録し、その情報に基づいて動作を変更することができます。

ブロードキャストは**非同期**（すべてのレシーバーが受信する）または**同期**（優先度に基づいて順序付けられた方法でブロードキャストが受信される）のいずれかです。

{% hint style="danger" %}
**注意：どのアプリケーションでも自身を最優先でブロードキャストを受け取るように設定できます。**
{% endhint %}

ブロードキャストレシーバーに実装されたコードを**調査**するには、レシーバーのクラスの**`onReceive`**メソッドを検索する必要があります。\
なお、**順序付けられたブロードキャストは受信したIntentを破棄したり、変更したりすることができます**。そのため、**レシーバーはデータを検証する必要があります**。

### コンテンツプロバイダー

コンテンツプロバイダーは、関係データベースなどの**構造化データをアプリ間で共有する方法**です。そのため、これらを保護するために**パーミッション**を使用し、適切な保護レベルを設定することが非常に重要です。\
コンテンツプロバイダーは、アプリが持つ必要のあるパーミッションを指定するために**`readPermission`**および**`writePermission`**属性を使用することができます。**これらのパーミッションは、permission属性よりも優先されます**。\
さらに、**`grantUriPermission`**をtrueに設定し、その後、マニフェストファイル内のプロバイダ要素内の**`grant-uri-permission`**要素で適切なパラメータを設定することで、**一時的な例外を許可する**こともできます。

**`grant-uri-permission`**には、path、pathPrefix、pathPatternの3つの属性があります。

* **path**: 除外するための完全なパスを指定する
* **pathPrefix**: パスの先頭部分を指定する
* **pathPattern**: ワイルドカードとシンボリック置換を使用して、より詳細な制御を行う

潜在的な脆弱性（SQLインジェクションなど）を回避するために、受け取った入力を**検証およびサニタイズすることが重要です**。

**コンテンツプロバイダーの特徴:**

* コンテンツプロバイダーコンポーネントは、他のアプリケーションからのリクエストに応じてデータを供給します。
* データはファイルシステム、SQLiteデータベース、Web上、またはアプリがアクセスできる他の永続ストレージ場所に保存することができます。
* コンテンツプロバイダーを介して、他のアプリケーションはデータをクエリしたり、変更したりすることができます（コンテンツプロバイダーが許可している場合）。
* コンテンツプロバイダーは、アプリが他のアプリとデータを共有したい場合に便利です。
* データベースと非常に似ており、4つのメソッドがあります。
* insert()
* update()
* delete()
* query()

**FileProvider**

これは、フォルダから**ファイルを共有する**タイプのコンテンツプロバイダーです。次のようにファイルプロバイダーを宣言できます：
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
**`android:exported`** 属性に注意してください。もし **`true`** であれば、外部のアプリケーションが共有フォルダにアクセスできるようになります。\
`android:resource="@xml/filepaths"` という設定は、ファイル _res/xml/filepaths.xml_ が **FileProvider** が **共有するフォルダ** の設定を含んでいることを示しています。以下は、そのファイルでフォルダを共有する方法の例です：
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
**`path="."`**のようなものを共有することは、プロバイダがエクスポートされていなくても、コードの他の部分で脆弱性がある場合には危険です。\
`content://com.example.myapp.fileprovider/myimages/default_image.jpg`を使用して、そのフォルダ内の**画像**にアクセスすることができます。

`<paths>`要素には複数の子要素を持つことができ、それぞれが共有する異なるディレクトリを指定します。**`<files-path>`**要素に加えて、**`<external-path>`**要素を使用して外部ストレージのディレクトリを共有し、**`<cache-path>`**要素を使用して内部キャッシュディレクトリのディレクトリを共有することもできます。\
[特定のファイルプロバイダの属性に関する詳細はこちらを参照してください。](https://developer.android.com/reference/androidx/core/content/FileProvider)

[FileProvidersに関する詳細はこちらを参照してください。](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

WebViewsはAndroidアプリに埋め込まれた**ウェブブラウザ**です。\
WebViewsのコンテンツはリモートサイトから取得することも、アプリに含まれるファイルから取得することもできます。\
WebViewsは**他のウェブブラウザと同じ脆弱性に対しても脆弱です**。ただし、**攻撃の表面を制限するためのいくつかの設定**があります。

Androidには2つのタイプのWebViewがあります：

* **WebViewClient**は、シンプルなHTMLのレンダリングに最適です。これはJSのalert関数を実行しません。したがって、この関数を使用したXSSテストは無効になります。
* **WebChromeクライアント**はChromeブラウザです。

なお、**WebViewブラウザはネイティブブラウザのクッキーにアクセスできません**。

URLまたはファイルを読み込むには、**`loadUrl`**、**`loadData`**、または**`loadDataWithBaseURL`**関数を使用することができます。**サニタイズされたURLにのみアクセスすることが重要です。**\
WebViewのセキュリティは**`WebSettings`**オブジェクトを介して設定することができます。\
たとえば、JSコードの実行を無効にするには、**`setJavaScriptEnabled`**メソッドを**`false`**の値で使用します。これにより、XSSやその他のJS関連の脆弱性の可能性がなくなります。

JavaScriptの「**Bridge**」機能は、JavaオブジェクトをWebViewに**注入し、JSからアクセス可能にします**。Android 4.2以降では、JavaScriptからアクセス可能にするためにメソッドに**`@JavascriptInterface`**を注釈する必要があります。

**`setAllowContentAccess`**に**`true`**を渡すと、**WebViewsは`content://`スキームを介してコンテンツプロバイダにアクセスできます**。これは明らかにセキュリティリスクを引き起こします。このアクセスが与えられる場合、**`content://`** URLが**安全であることを確認することが非常に重要です**。

デフォルトでは、ローカルファイルはWebViewからfile:// URLを介してアクセスできますが、この動作を防ぐためのいくつかの方法があります：

* **`setAllowFileAccess`**に**`false`**を渡すと、`file:///android_asset`および`file:///android_res`を除くファイルシステムへのアクセスが防止されます。これらのパスは非機密データ（画像など）にのみ使用する必要があるため、これは安全です。
* **`setAllowFileAccess`**メソッドは、`file://` URLのパスが他のfileスキームURLからコンテンツにアクセスできるかどうかを示します。
* **`setAllowUniversalAccessFromFileURLs`**メソッドは、`file://` URLのパスが任意のオリジンからコンテンツにアクセスできるかどうかを示します。

## その他のアプリコンポーネント

### **アプリケーションの署名**

* Androidでは、アプリをインストールする前に、**すべてのアプリがデジタル証明書で署名される必要があります**。Androidはこの証明書を使用してアプリの作者を識別します。
* デバイスでアプリを実行するには、アプリは署名されている必要があります。アプリがデバイスにインストールされると、パッケージマネージャはapkファイルの証明書が正しく署名されているかどうかを検証します。
* アプリは自己署名されるか、CAを介して署名されることがあります。
* アプリの署名により、アプリはウェル定義されたIPCを介して他のアプリにアクセスすることはできず、変更されずにデバイスに渡されることが保証されます。

### **アプリケーションの検証**

* Android 4.2以降、アプリケーションの検証がサポートされています。ユーザーは「アプリの検証」を有効にすることができ、アプリケーションがインストール前にアプリケーション検証プログラムによって評価されます。
* アプリの検証では、ユーザーが有害なアプリをインストールしようとした場合にユーザーに警告することができます。特に悪質なアプリの場合、インストールをブロックすることもできます。

## モバイルデバイス管理

MDMまたはモバイルデバイス管理は、モバイルデバイス上での制御とセキュリティ要件を確保するために使用されるソフトウェアスイートです。これらのスイートは、デバイス管理APIと呼ばれる機能を使用し、Androidアプリのインストールが必要です。

一般的に、MDMソリューションはパスワードポリシーの強制、ストレージの暗号化の強制、デバイスデータのリモートワイプの有効化などの機能を実行します。

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて、より速く修正できるようにしましょう。Intruderは攻撃対象を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリまで、テックスタック全体で問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥
