# Android Uygulamaları Temelleri

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramanla öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklam vermek** veya HackTricks'i **PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com)'ni edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **katkıda bulunun**.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

En önemli güvenlik açıklarını bulun ve daha hızlı düzeltebilin. Intruder saldırı yüzeyinizi takip eder, proaktif tehdit taramaları yapar, API'lerden web uygulamalarına ve bulut sistemlerine kadar tüm teknoloji yığınınızda sorunları bulur. [**Ücretsiz deneyin**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) bugün.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Android Güvenlik Modeli

**İki katman vardır:**

* **İşletim Sistemi (OS)**, yüklü uygulamaları birbirinden izole tutar.
* **Uygulama kendisi**, geliştiricilere belirli işlevleri **açığa çıkarma** ve uygulama yeteneklerini yapılandırma imkanı sağlar.

### UID Ayrımı

**Her uygulamaya belirli bir Kullanıcı Kimliği (UID) atanır**. Bu, uygulamanın yalnızca kendi UID'sine ait veya paylaşılan dosyalara erişebilmesi için uygulama yüklenirken yapılır. Bu nedenle, yalnızca uygulama kendisi, OS'nin belirli bileşenleri ve kök kullanıcı uygulamanın verilerine erişebilir.

### UID Paylaşımı

**İki uygulama aynı UID'yi kullanacak şekilde yapılandırılabilir**. Bu bilgi paylaşımı için faydalı olabilir, ancak bunlardan biri tehlikeye düşerse her iki uygulamanın verileri de tehlikeye düşer. Bu nedenle bu davranış **önerilmez**.\
**Aynı UID'yi paylaşmak için uygulamaların manifest dosyalarında aynı `android:sharedUserId` değerini tanımlamaları gerekir.**

### Kum Sandığı

**Android Uygulama Kum Sandığı**, **her uygulamayı** ayrı bir süreç olarak çalıştırmak için **ayrı bir kullanıcı kimliği altında** çalışmasına izin verir. Her sürecin kendi sanal makinesi vardır, bu nedenle bir uygulamanın kodu diğer uygulamalardan izole bir şekilde çalışır.\
Android 5.0(L)'den itibaren **SELinux** uygulanır. Temel olarak, SELinux tüm süreç etkileşimlerini reddeder ve ardından bunlar arasında **yalnızca beklenen etkileşimlere izin veren politikalar oluşturur**.

### İzinler

Bir uygulama **yüklendiğinde ve izinler istendiğinde**, uygulama **AndroidManifest.xml** dosyasındaki **`uses-permission`** öğelerinde yapılandırılan izinleri istemektedir. **uses-permission** öğesi, istenen iznin adını **name** **özniteliği** içinde belirtir. Ayrıca, izinlerin belirtilenden daha yüksek sürümlerde istenmesini durduran **maxSdkVersion** özniteliği vardır.\
Android uygulamalarının başlangıçta tüm izinleri istemeleri gerekmez, aynı zamanda **izinleri dinamik olarak isteyebilirler** ancak tüm izinlerin **manifestoda bildirilmesi** gerekir.

Bir uygulama işlevselliği açığa çıkardığında, **erişimi yalnızca belirli bir izne sahip uygulamalara sınırlayabilir**.\
Bir izin öğesinin üç özelliği vardır:

* İzinin **adı**
* İzin grubunu gruplama izni veren **permission-group** özniteliği.
* İzinlerin nasıl verildiğini belirten **protection-level**. Dört tür vardır:
* **Normal**: Uygulama için **bilinen tehditler yoksa** kullanılır. Kullanıcının **onaylaması gerekmez**.
* **Tehlikeli**: İzin, isteyen uygulamaya bazı **yüksek erişimler** sağlar. **Kullanıcıların onayını isteyebilir**.
* **Signature**: Yalnızca bileşeni dışa aktaran sertifika ile aynı sertifikaya sahip **uygulamalara izin verilir**. Bu en güçlü koruma türüdür.
* **SignatureOrSystem**: Yalnızca bileşeni dışa aktaran sertifika ile aynı sertifikaya sahip **uygulamalar veya sistem düzeyinde erişimle çalışan uygulamalar** izin alabilir.

## Önceden Yüklenmiş Uygulamalar

Bu uygulamalar genellikle **`/system/app`** veya **`/system/priv-app`** dizinlerinde bulunur ve bazıları **optimize edilmiştir** (`classes.dex` dosyasını bile bulamayabilirsiniz). Bu uygulamalar, bazen **root** olarak çalıştıkları için **çok fazla izinle** çalıştırıldıklarında kontrol edilmeye değerdir.

* Android Açık Kaynak Projesi (AOSP) ROM ile birlikte **gönderilenler**
* Cihaz **üreticisi** tarafından eklenenler
* Cep **telefonu sağlayıcısı** tarafından eklenenler (onlardan satın alındıysa)

## Rootlama

Fiziksel bir Android cihazda kök erişimi elde etmek için genellikle **cihaza özgü** olan 1 veya 2 **zafiyeti sömürmek** gerekmektedir.\
Sömürü işlemi başarılı olduğunda, genellikle Linux `su` ikili dosyası, kullanıcının PATH ortam değişkeninde belirtilen bir konuma (`/system/xbin` gibi) kopyalanır.

su ikili dosyası yapılandırıldığında, başka bir Android uygulaması `su` ikili dosyasıyla etkileşim kurmak ve **kök erişimi taleplerini işlemek** için kullanılır, örneğin **Superuser** ve **SuperSU** (Google Play Store'da mevcuttur).

{% hint style="danger" %}
Rootlama işlemi çok tehlikelidir ve cihaza ciddi zarar verebilir.
{% endhint %}

### ROM'lar

Özel bir firmware yükleyerek OS'yi **değiştirmek mümkündür**. Bunu yaparak eski bir cihazın kullanışlılığını artırabilir, yazılım kısıtlamalarını aşabilir veya en son Android koduna erişim elde
### **Dalvik ve Smali**

Android uygulama geliştirmede, uygulamalar oluşturmak için **Java veya Kotlin** kullanılır. Masaüstü uygulamalarda JVM kullanmak yerine, Android bu kodu **Dalvik Yürütülebilir (DEX) bytecode**'a derler. Daha önce, Dalvik sanal makinesi bu bytecode'u işlerken, şimdi daha yeni Android sürümlerinde Android Runtime (ART) devralır.

Tersine mühendislik için, **Smali** önemli hale gelir. Bu, DEX bytecode'unun insan tarafından okunabilir versiyonudur ve kaynak kodunu bytecode talimatlarına çevirerek bir montaj dili gibi hareket eder. Smali ve baksmali, bu bağlamda montaj ve montajdan çıkarma araçlarını ifade eder.

***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

En önemli güvenlik açıklarını bulun, böylece daha hızlı düzeltebilirsiniz. Intruder saldırı yüzeyinizi takip eder, proaktif tehdit taramaları yapar, API'lerden web uygulamalarına ve bulut sistemlerine kadar tüm teknoloji yığınınızda sorunları bulur. [**Ücretsiz deneyin**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) bugün.

***

## İstekler (Intents)

İstekler, Android uygulamalarının bileşenleri arasında veya diğer uygulamalarla iletişim kurmanın temel yollarıdır. Bu mesaj nesneleri, HTTP iletişimindeki GET/POST isteklerinin nasıl kullanıldığı gibi, veri taşıyabilirler.

Yani bir İstek, temel olarak bileşenler arasında geçirilen bir **mesajdır**. İstekler, belirli bileşenlere veya uygulamalara **yönlendirilebilir** veya belirli bir alıcı olmadan gönderilebilir.\
Basitçe söylemek gerekirse, İstek şunlar için kullanılabilir:

* Bir etkinliği başlatmak için, genellikle bir uygulama için bir kullanıcı arayüzü açmak için
* Sistem ve uygulamalara değişiklikleri bildirmek için yayınlar olarak
* Bir arka plan hizmetini başlatmak, durdurmak ve iletişim kurmak için
* ContentProvider'lar aracılığıyla veriye erişmek için
* Olayları işlemek için geri çağırmalar olarak

Eğer güvenlik açığı varsa, **İstekler çeşitli saldırıları gerçekleştirmek için kullanılabilir**.

### İstek-Filtresi (Intent-Filter)

**İstek Filtreleri**, bir etkinlik, hizmet veya Yayın Alıcısının farklı türdeki İsteklerle nasıl etkileşimde bulunabileceğini tanımlar. Temel olarak, bu bileşenlerin ne tür eylemler gerçekleştirebileceği veya hangi tür yayınları işleyebileceği gibi yeteneklerini açıklarlar. Bu filtreleri bildirmenin temel yeri, **AndroidManifest.xml** dosyasıdır, ancak Yayın Alıcıları için bunları kodlamak da bir seçenektir.

İstek Filtreleri, kategoriler, eylemler ve veri filtreleri olmak üzere, ek meta verileri içermek de mümkündür. Bu yapı, bileşenlerin belirtilen kriterlere uyan belirli İstekleri işlemesine olanak tanır.

Android bileşenlerinin (etkinlikler/hizmetler/content provider'lar/yayın alıcıları) önemli bir yönü, görünürlükleri veya **genel durumları**'dır. Bir bileşen, **`exported`** değeri **`true`** olarak ayarlanmışsa veya manifestte bir İstek Filtresi bildirilmişse, diğer uygulamalarla etkileşimde bulunabilir ve genel olarak kabul edilir. Bununla birlikte, geliştiricilerin bu bileşenleri açıkça özel tutmaları ve diğer uygulamalarla istemeden etkileşime girmemelerini sağlamaları bir yol vardır. Bu, manifest tanımlarında **`exported`** özniteliğini **`false`** olarak ayarlayarak elde edilir.

Ayrıca, geliştiriciler bu bileşenlere erişimi daha da güvence altına almak için belirli izinleri gerektirebilirler. **`permission`** özniteliği, yalnızca belirli izne sahip uygulamaların bileşene erişebileceğini zorlamak için ayarlanabilir, böylece kiminle etkileşimde bulunabileceğiniz konusunda ek bir güvenlik ve kontrol katmanı eklenir.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### İma Eylemleri

Eylemler, bir Intent yapıcısı kullanılarak programatik olarak oluşturulur:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
Önceden belirtilen niyetin **EYLEM\_GÖNDER** olduğu ve **Ekstra**'nın bir mailto **Uri** olduğu (Ekstra, niyetin beklediği ek bilgidir).

Bu niyet, aşağıdaki örnekte olduğu gibi manifest içinde belirtilmelidir:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Bir intent-filter, bir mesaj almak için **eylem**, **veri** ve **kategori** ile eşleşmelidir.

"Intent çözümleme" süreci, her mesajın hangi uygulamanın alması gerektiğini belirler. Bu süreç, **öncelik özniteliğini** dikkate alır, bu öznitelik **intent-filter bildiriminde** ayarlanabilir ve **daha yüksek önceliğe sahip olan seçilir**. Bu öncelik -1000 ile 1000 arasında ayarlanabilir ve uygulamalar `SYSTEM_HIGH_PRIORITY` değerini kullanabilir. Bir **çakışma** oluşursa, kullanıcının karar verebilmesi için bir "seçici" penceresi görüntülenir.

### Açık İntentler

Açık bir intent, hedeflediği sınıf adını belirtir:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Diğer uygulamalarda önceden belirtilen intent'e erişmek için şunu kullanabilirsiniz:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Bekleyen İstekler

Bu, diğer uygulamaların, uygulamanızın kimliği ve izinleri kullanarak **uygulamanız adına işlemler yapmasına olanak tanır**. Bekleyen bir istek oluştururken, bir niyet ve gerçekleştirilecek eylem belirtilmelidir. **Belirtilen niyet açıkça belirtilmezse** (hangi niyetin çağrılabileceğini belirtmez), **kötü niyetli bir uygulama, kurban uygulama adına belirtilen eylemi gerçekleştirebilir**. Dahası, **bir eylem belirtilmezse**, kötü niyetli uygulama, kurban adına **herhangi bir eylem yapabilir**.

### Yayın İstekleri

Önceki isteklerin aksine, yayın istekleri **birden fazla uygulama tarafından alınabilir**. Ancak, API sürümü 14'ten itibaren, mesajın alması gereken uygulamayı belirtmek için Intent.setPackage kullanmak mümkündür.

Alternatif olarak, yayını gönderirken **bir izin belirtmek de mümkündür**. Alıcı uygulamanın bu izne sahip olması gerekecektir.

Yayınların **iki türü** vardır: **Normal** (asenkron) ve **Sıralı** (senkron). **Sıralama**, alıcı öğe içinde yapılandırılan önceliğe dayanır. **Her uygulama yayını işleyebilir, iletebilir veya bırakabilir**.

`Context` sınıfından `sendBroadcast(intent, receiverPermission)` işlevini kullanarak bir yayın göndermek mümkündür.\
Ayrıca, **`LocalBroadCastManager`**'dan **`sendBroadcast`** işlevini kullanarak **mesajın uygulamadan çıkmamasını** sağlayabilirsiniz. Bunu kullanarak bir alıcı bileşenini dışa aktarmanıza gerek kalmaz.

### Yapışkan Yayınlar

Bu tür yayınlara, gönderildikten sonra **uzun bir süre erişilebilir**.\
Bunlar API seviyesi 21'de kullanımdan kaldırıldı ve **kullanılmamaları önerilir**.\
**Herhangi bir uygulamanın verileri izlemesine ve değiştirmesine izin verirler**.

Eğer "sticky" kelimesini içeren **`sendStickyBroadcast`** veya **`sendStickyBroadcastAsUser`** gibi işlevler bulursanız, **etkisini kontrol edin ve bunları kaldırmaya çalışın**.

## Derin bağlantılar / URL şemaları

Android uygulamalarında, **derin bağlantılar**, bir URL aracılığıyla doğrudan bir eylemi (Niyet) başlatmak için kullanılır. Bu, bir etkinlik içinde belirli bir **URL şemasının** bildirilmesiyle yapılır. Bir Android cihazı, bu şemayla bir URL'ye **erişmeye çalıştığında**, uygulama içinde belirtilen etkinlik başlatılır.

Şema, **`AndroidManifest.xml`** dosyasında bildirilmelidir:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Önceki örnekteki şema `exampleapp://` (ayrıca **`category BROWSABLE`**'ı da dikkate alın)

Ardından, veri alanında **host** ve **path** belirtebilirsiniz:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Web üzerinden erişmek için şu şekilde bir bağlantı kurmak mümkündür:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
**Kodun uygulamada çalıştırılacağı kodu** bulmak için, deeplink tarafından çağrılan aktiviteye gidin ve **`onNewIntent`** fonksiyonunu arayın.

[HTML sayfaları kullanmadan derin bağlantıları çağırma](./#exploiting-schemes-deep-links) hakkında bilgi edinin.

## AIDL - Android Arayüz Tanım Dili

**Android Arayüz Tanım Dili (AIDL)**, Android uygulamalarında **süreçler arası iletişimi** (IPC) kolaylaştırmak için tasarlanmıştır. Android'de başka bir sürecin belleğine doğrudan erişim izin verilmediği için, AIDL işlemi kolaylaştırarak nesneleri işletim sistemi tarafından anlaşılan bir formata dönüştürerek farklı süreçler arasında iletişimi kolaylaştırır.

### Temel Kavramlar

- **Bağlı Servisler**: Bu servisler, IPC için AIDL'yi kullanır ve etkinliklerin veya bileşenlerin bir servise bağlanmasını, istek yapmasını ve yanıt almasını sağlar. Servisin sınıfındaki `onBind` yöntemi etkileşimi başlatmak için önemlidir ve güvenlik açığı arayışında kritik bir alan olarak işaretlenir.

- **Messenger**: Bağlı bir servis olarak çalışan Messenger, verilerin `onBind` yöntemi aracılığıyla işlenmesine odaklanan IPC'yi kolaylaştırır. Bu yöntemi güvensiz veri işleme veya hassas işlevlerin yürütülmesi açısından yakından incelemek önemlidir.

- **Binder**: AIDL'nin soyutlaması nedeniyle Binder sınıfının doğrudan kullanımı daha az yaygın olsa da, Binder'ın farklı süreçlerin bellek alanları arasında veri transferini kolaylaştıran bir çekirdek seviye sürücü olarak hareket ettiğini anlamak faydalıdır. Daha fazla anlayış için bir kaynak [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8) adresinde bulunmaktadır.

## Bileşenler

Bunlar şunları içerir: **Etkinlikler, Servisler, Yayın Alıcılar ve Sağlayıcılar.**

### Başlatıcı Etkinlik ve diğer etkinlikler

Android uygulamalarında, **etkinlikler** ekranlara benzer ve uygulamanın kullanıcı arayüzünün farklı bölümlerini gösterir. Bir uygulama birçok etkinliğe sahip olabilir, her biri kullanıcıya benzersiz bir ekran sunar.

**Başlatıcı etkinlik**, uygulamanın simgesine dokunduğunuzda başlatılan uygulamanın ana giriş noktasıdır. Belirli MAIN ve LAUNCHER niyetleriyle uygulamanın manifest dosyasında tanımlanır.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
# Android Uygulamaları Temelleri

Bazı uygulamaların, özellikle arka plan hizmetleri gibi kullanıcı arayüzü olmayanlarının bir başlatıcı etkinliğe ihtiyacı yoktur.

Etkinlikler, manifest dosyasında "exported" olarak işaretlenerek diğer uygulamalar veya işlemler tarafından kullanılabilir hale getirilebilir. Bu ayar, diğer uygulamaların bu etkinliği başlatmasına izin verir:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ancak, başka bir uygulamadan bir etkinliğe erişmek her zaman bir güvenlik riski oluşturmaz. Endişe, hassas verilerin yanlış şekilde paylaşılması durumunda ortaya çıkar, bu da bilgi sızıntılarına yol açabilir.

Bir etkinliğin yaşam döngüsü, **onCreate yöntemiyle başlar**, UI'yi ayarlar ve etkinliği kullanıcıyla etkileşime hazırlar.

### Uygulama Alt Sınıfı

Android geliştirmede, bir uygulamanın [Application](https://developer.android.com/reference/android/app/Application) sınıfının bir **alt sınıfını** oluşturma seçeneği vardır, ancak zorunlu değildir. Böyle bir alt sınıf tanımlandığında, uygulama içinde öncelikle bu sınıf örneklendirilir. Bu alt sınıfta **`attachBaseContext`** yöntemi uygulanmışsa, **`onCreate`** yönteminden önce bu yöntem çalıştırılır. Bu yapı, uygulamanın geri kalanının başlamadan önce erken başlatma için olanak sağlar.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Hizmetler

[Hizmetler](https://developer.android.com/guide/components/services), kullanıcı arayüzü olmadan görevleri gerçekleştirebilen **arka planda çalışan işlemlerdir**. Bu görevler, kullanıcıların farklı uygulamalara geçse bile devam edebilir, bu nedenle hizmetler **uzun süreli işlemler** için önemlidir.

Hizmetler çok yönlüdür; çeşitli şekillerde başlatılabilirler ve bunları başlatmanın temel yöntemi **Intentler**dir. Bir hizmet, `startService` yöntemi kullanılarak başlatıldığında, `onStart` yöntemi devreye girer ve `stopService` yöntemi açıkça çağrılana kadar çalışmaya devam eder. Alternatif olarak, bir hizmetin rolü, etkin bir istemci bağlantısına bağlıysa, istemciyi hizmete bağlamak için `bindService` yöntemi kullanılır ve veri geçişi için `onBind` yöntemi devreye girer.

Hizmetlerin ilginç bir uygulaması, kullanıcının bir uygulayla etkileşimini engellemeden arka planda müzik çalma veya ağ verisi almadır. Ayrıca, hizmetler aynı cihazdaki diğer işlemler tarafından erişilebilir hale getirilebilir. Bu, varsayılan davranış değildir ve Android Manifest dosyasında açıkça yapılandırma gerektirir:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Yayın Alıcıları

**Yayın alıcıları**, bir mesajlaşma sisteminde dinleyici olarak hareket eder ve sistemden gelen aynı mesajlara birden fazla uygulamanın yanıt vermesine olanak tanır. Bir uygulama, alıcıyı **iki temel yol** ile **kaydedebilir**: uygulamanın **Manifest** dosyası aracılığıyla veya uygulamanın kodu içinde **dinamik olarak** **`registerReceiver`** API'si ile. Manifest dosyasında yayınlar izinlerle filtrelenirken, dinamik olarak kaydedilen alıcılar kayıt sırasında izinleri belirtebilir.

**Intent filtreleri**, kayıt yöntemlerinde de önemli bir rol oynar ve alıcının hangi yayınları tetikleyeceğini belirler. Eşleşen bir yayın gönderildiğinde, alıcının **`onReceive`** yöntemi çağrılır ve uygulamanın buna uygun şekilde tepki vermesini sağlar, örneğin düşük pil uyarısına yanıt olarak davranışı ayarlamak gibi.

Yayınlar ya **asenkron** olarak, sırasız bir şekilde tüm alıcılara ulaşır ya da **senkron** olarak, alıcılar belirlenen önceliklere göre yayını alır. Ancak, herhangi bir uygulama yayını ele geçirmek için kendisini önceliklendirebileceğinden, potansiyel bir güvenlik riski olduğunu unutmamak önemlidir.

Bir alıcının işlevselliğini anlamak için, sınıf içindeki **`onReceive`** yöntemine bakın. Bu yöntemin kodu alınan Intent'i değiştirebilir, bu nedenle alıcılar tarafından veri doğrulamasının yapılması gereklidir, özellikle Intent'i değiştirebilen veya atabilen **Sıralı Yayınlar** için.

### İçerik Sağlayıcı

**İçerik Sağlayıcıları**, yapılandırılmış verilerin uygulamalar arasında paylaşılması için önemlidir ve veri güvenliğini sağlamak için **izinlerin** uygulanmasının önemini vurgular. İçerik Sağlayıcıları, veritabanları, dosya sistemleri veya web gibi çeşitli kaynaklardan veriye erişimi sağlar. **`readPermission`** ve **`writePermission`** gibi belirli izinler, erişimi kontrol etmek için önemlidir. Ayrıca, geçici erişim, ayrıntılı erişim kontrolü için uygulamanın manifestindeki **`grantUriPermission`** ayarları aracılığıyla sağlanabilir ve `path`, `pathPrefix` ve `pathPattern` gibi özniteliklerden yararlanır.

Güvenlik açıklarını önlemek için giriş doğrulaması son derece önemlidir, örneğin SQL enjeksiyonu gibi. İçerik Sağlayıcıları, `insert()`, `update()`, `delete()` ve `query()` gibi temel işlemleri destekler ve veri manipülasyonunu ve uygulamalar arasında paylaşımı kolaylaştırır.

**FileProvider**, dosyaların güvenli bir şekilde paylaşılmasına odaklanan özel bir İçerik Sağlayıcıdır. Klasörlere erişimi kontrol etmek için belirli özniteliklerle uygulamanın manifestinde tanımlanır ve `android:exported` ve `android:resource` ile klasör yapılandırmalarına işaret eder. Hassas verilerin yanlışlıkla ortaya çıkmasını önlemek için dikkatli olunmalıdır.

FileProvider için örnek manifest bildirimi:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Ve `filepaths.xml` dosyasında paylaşılan klasörleri belirtme örneği:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Daha fazla bilgi için şu kaynaklara bakabilirsiniz:
- [Android Geliştiriciler: İçerik Sağlayıcılar](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Geliştiriciler: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews, Android uygulamalarının içindeki **mini web tarayıcılar** gibidir ve içeriği webden veya yerel dosyalardan alır. Bunlar, normal tarayıcılar gibi benzer risklerle karşılaşır, ancak belirli **ayarlar** aracılığıyla bu riskleri **azaltmanın yolları** vardır.

Android, iki ana WebView türü sunar:

- **WebViewClient**, temel HTML için harikadır, ancak JavaScript uyarı işlevini desteklemez, bu da XSS saldırılarının nasıl test edileceğini etkiler.
- **WebChromeClient**, tam Chrome tarayıcı deneyimine daha çok benzer.

Bir nokta şudur ki, WebView tarayıcıları, cihazın ana tarayıcısıyla **çerez paylaşmaz**.

İçerik yükleme için ````loadUrl````, ````loadData````, ve ````loadDataWithBaseURL```` gibi yöntemler kullanılabilir. Bu URL'lerin veya dosyaların **güvenli** olduğundan emin olmak önemlidir. Güvenlik ayarları, ````WebSettings```` sınıfı aracılığıyla yönetilebilir. Örneğin, ````setJavaScriptEnabled(false)```` ile JavaScript devre dışı bırakılarak XSS saldırıları önlenir.

Java nesnelerinin JavaScript ile etkileşimde bulunmasını sağlayan JavaScript "Bridge", Android 4.2'den itibaren güvenlik için yöntemlerin ````@JavascriptInterface```` ile işaretlenmesini gerektirir.

İçeriğe erişime izin vermek (````setAllowContentAccess(true)````), WebViews'in İçerik Sağlayıcılara erişmesine olanak tanır, ancak içerik URL'leri güvenli olarak doğrulanmadıkça bir risk oluşturabilir.

Dosya erişimini kontrol etmek için:
- Dosya erişimini devre dışı bırakmak (````setAllowFileAccess(false)````), dosya sistemi erişimini sınırlar ve belirli varlıklar için istisnalar yapar, böylece bunlar yalnızca hassas olmayan içerik için kullanılır.

## Diğer Uygulama Bileşenleri ve Mobil Cihaz Yönetimi

### **Uygulamaların Dijital İmzalanması**

- Android uygulamaları için **dijital imzalama**, kurulumdan önce bunların **gerçekten yetkilendirilmiş** olduğunu sağlar. Bu süreç, uygulama kimliği için bir sertifika kullanır ve kurulum sırasında cihazın paket yöneticisi tarafından doğrulanmalıdır. Uygulamalar, yetkisiz erişime karşı koruma sağlayan ve uygulamanın teslimatı sırasında değiştirilmeden kalmasını sağlayan **kendini imzalayan veya harici bir CA tarafından onaylanmış** olabilir.

### **Gelişmiş Güvenlik için Uygulama Doğrulama**

- **Android 4.2**'den itibaren, **Uygulama Doğrulama** adlı bir özellik, kullanıcıların uygulamaları kurmadan önce güvenlik açısından kontrol etmelerine olanak tanır. Bu **doğrulama süreci**, kullanıcıları potansiyel olarak zararlı uygulamalar konusunda uyarabilir veya özellikle kötü niyetli olanların kurulumunu engelleyebilir, kullanıcı güvenliğini artırır.

### **Mobil Cihaz Yönetimi (MDM)**

- **MDM çözümleri**, Mobil Cihaz Yönetimi API'si aracılığıyla mobil cihazlar için **denetim ve güvenlik** sağlar. Mobil cihazları etkili bir şekilde yönetmek ve güvence altına almak için bir Android uygulamasının kurulumunu gerektirirler. Ana işlevler arasında **parola politikalarının zorunlu kılınması**, **depolama şifrelemesinin zorunlu kılınması** ve **uzaktan veri silme izni** gibi özellikler bulunur, böylece mobil cihazlar üzerinde kapsamlı kontrol ve güvenlik sağlanır.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

En önemli güvenlik açıklarını bulun, böylece daha hızlı düzeltebilirsiniz. Intruder saldırı yüzeyinizi takip eder, proaktif tehdit taramaları yapar, API'lerden web uygulamalarına ve bulut sistemlerine kadar tüm teknoloji yığınınızda sorunları bulur. [**Ücretsiz deneyin**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) bugün.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman olmak için AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek veya HackTricks'i PDF olarak indirmek isterseniz** [**ABONELİK PLANLARI'na**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family)
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'ı takip edin**.
* **Hacking hilelerinizi HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github depolarına PR göndererek paylaşın**.

</details>
