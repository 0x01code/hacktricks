# Βασικά Εφαρμογών Android

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα αποθετήρια του **HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Μοντέλο Ασφαλείας Android

**Υπάρχουν δύο επίπεδα:**

* Το **ΛΕΣ**, το οποίο διατηρεί τις εγκατεστημένες εφαρμογές απομονωμένες μεταξύ τους.
* Η **ίδια η εφαρμογή**, η οποία επιτρέπει στους προγραμματιστές να **εκθέτουν ορισμένες λειτουργίες** και να διαμορφώνει τις δυνατότητες της εφαρμογής.

### Διαχωρισμός UID

**Κάθε εφαρμογή ανατίθεται ένα συγκεκριμένο αναγνωριστικό χρήστη (UID)**. Αυτό γίνεται κατά την εγκατάσταση της εφαρμογής ώστε **η εφαρμογή να μπορεί να αλληλεπιδρά μόνο με αρχεία που ανήκουν στο UID της ή με κοινόχρηστα** αρχεία. Συνεπώς, μόνο η ίδια η εφαρμογή, κάποια στοιχεία του ΛΕΣ και ο ριζικός χρήστης μπορούν να έχουν πρόσβαση στα δεδομένα των εφαρμογών.

### Διαμοιρασμός UID

**Δύο εφαρμογές μπορούν να ρυθμιστούν ώστε να χρησιμοποιούν το ίδιο UID**. Αυτό μπορεί να είναι χρήσιμο για να μοιράζονται πληροφορίες, αλλά αν μία από αυτές διαρρεύσει, τα δεδομένα και των δύο εφαρμογών θα διαρρεύσουν. Γι' αυτό ο συγκεκριμένος τρόπος συμπεριφοράς είναι **αποθαρρυντικός**.\
**Για να μοιράζονται το ίδιο UID, οι εφαρμογές πρέπει να ορίσουν την ίδια τιμή `android:sharedUserId` στα μεταδεδομένα τους.**

### Αμμοθάλασσα

Η **Αμμοθάλασσα Εφαρμογών Android** επιτρέπει την εκτέλεση **κάθε εφαρμογής** ως ένα **ξεχωριστό διεργασία υπό ένα ξεχωριστό αναγνωριστικό χρήστη**. Κάθε διεργασία έχει τη δική της εικονική μηχανή, έτσι ο κώδικας μιας εφαρμογής εκτελείται απομονωμένα από άλλες εφαρμογές.\
Από το Android 5.0(L) εφαρμόζεται το **SELinux**. Βασικά, το SELinux απαγόρευε όλες τις αλληλεπιδράσεις διεργασιών και στη συνέχεια δημιούργησε πολιτικές για να **επιτρέψει μόνο τις αναμενόμενες αλληλεπιδράσεις μεταξύ τους**.

### Δικαιώματα

Όταν εγκαθιστάτε μια **εφαρμογή και σας ζητά δικαιώματα**, η εφαρμογή ζητά τα δικαιώματα που έχουν διαμορφωθεί στα στοιχεία **`uses-permission`** στο αρχείο **AndroidManifest.xml**. Το στοιχείο **uses-permission** υποδεικνύει το όνομα του ζητούμενου δικαιώματος μέσα στο **όνομα** **χαρακτηριστικού.** Διαθέτει επίσης το χαρακτηριστικό **maxSdkVersion** που σταματά το αίτημα δικαιωμάτων σε εκδόσεις υψηλότερες από αυτήν που καθορίζεται.\
Σημειώστε ότι οι εφαρμογές Android δεν χρειάζεται να ζητήσουν όλα τα δικαιώματα από την αρχή, μπορούν επίσης **να ζητήσουν δικαιώματα δυναμικά** αλλά όλα τα δικαιώματα πρέπει να **δηλωθούν** στο **μεταδεδομένα.**

Όταν μια εφαρμογή εκθέτει λειτουργικότητα, μπορεί να περιορίσει την **πρόσβαση μόνο σε εφαρμογές που έχουν ένα συγκεκριμένο δικαίωμα**.\
Ένα στοιχείο δικαιώματος έχει τρία χαρακτηριστικά:

* Το **όνομα** του δικαιώματος
* Το χαρακτηριστικό **permission-group**, που επιτρέπει την ομαδοποίηση σχετικών δικαιωμάτων.
* Το **επίπεδο προστασίας** που υποδεικνύει πώς χορηγούνται τα δικαιώματα. Υπάρχουν τέσσερα είδη:
* **Κανονικό**: Χρησιμοποιείται όταν δεν υπάρχουν **γνωστές απειλές** για την εφαρμογή. Δεν απαιτείται η έγκριση του χρήστη.
* **Επικίνδυνο**: Υποδεικνύει ότι το δικαίωμα χορηγεί στην αιτούσα εφαρμογή κάποια **υψηλότερη πρόσβαση**. **Οι χρήστες καλούνται να τα εγκρίνουν**.
* **Υπογραφή**: Μόνο **εφαρμογές που έχουν υπογραφεί από τον ίδιο πιστοποιητικό με αυτόν** που εξάγει το στοιχείο μπορούν να χορηγηθούν δικαιώματα. Αυτό είναι το ισχυρότερο είδος προστασίας.
* **ΥπογραφήΉΣύστημα**: Μόνο **εφαρμογές που έχουν υπογραφεί από τον ίδιο πιστοποιητικό με αυτόν** που εξάγει το στοιχείο ή **εφαρμογές που λειτουργούν με επίπεδο πρόσβασης συστήματος** μπορούν να χορηγηθούν δικαιώματα

## Προ-εγκατεστημένες Εφαρμογές

Αυτές οι εφαρμογές βρίσκονται συνήθως στους καταλόγους **`/system/app`** ή **`/system/priv-app`** και κάποιες από αυτές είναι **βελτιστοποιημένες** (μπορεί να μην βρείτε καν το αρχείο `classes.dex`). Αξίζει να ελέγξετε αυτές τις εφαρμογές επειδή μερικές φορές τρέχουν με **πάρα πολλά δικαιώματα** (ως ριζικός χρήστης).

* Αυτές που αποστέλλονται με το **AOSP** (Android OpenSource Project) **ROM**
* Προστέθηκαν από τον **κατασκευαστή της συσκευής**
* Προστέθηκαν από τον πάροχο **κινητής τηλεφωνίας** (αν αγοράστηκαν από αυτόν)

## Rooting

Για να αποκτήσετε ριζική πρόσβαση σε μια φυσική συσκευή Android, γενικά χρειάζεται να **εκμεταλλευτείτε** 1 ή 2 **ευπάθειες** που συνήθως είναι **συγκεκριμένες** για τη
### **Dalvik & Smali**

Στην ανάπτυξη Android, χρησιμοποιείται **Java ή Kotlin** για τη δημιουργία εφαρμογών. Αντί να χρησιμοποιεί το JVM όπως στις εφαρμογές επιφάνειας εργασίας, το Android μεταγλωττίζει αυτόν τον κώδικα σε **Dalvik Executable (DEX) bytecode**. Παλαιότερα, η εικονική μηχανή Dalvik χειριζόταν αυτόν τον bytecode, αλλά τώρα, η Android Runtime (ART) αναλαμβάνει σε νεότερες εκδόσεις του Android.

Για την αντιστροφή μηχανική, το **Smali** γίνεται κρίσιμο. Είναι η αναγνώσιμη από ανθρώπους έκδοση του DEX bytecode, λειτουργώντας όπως η γλώσσα συναρμολόγησης μεταφράζοντας τον πηγαίο κώδικα σε εντολές bytecode. Το Smali και το baksmali αναφέρονται στα εργαλεία συναρμολόγησης και αποσυναρμολόγησης σε αυτό το πλαίσιο.

## Intents

Τα Intents είναι ο κύριος τρόπος με τον οποίο οι εφαρμογές Android επικοινωνούν μεταξύ των συστατικών τους ή με άλλες εφαρμογές. Αυτά τα αντικείμενα μηνυμάτων μπορούν επίσης να μεταφέρουν δεδομένα μεταξύ εφαρμογών ή συστατικών, παρόμοια με τον τρόπο με τον οποίο χρησιμοποιούνται οι αιτήσεις GET/POST στις επικοινωνίες HTTP.

Έτσι, ένα Intent είναι βασικά ένα **μήνυμα που περνάει μεταξύ συστατικών**. Τα Intents **μπορούν να κατευθυνθούν** σε συγκεκριμένα στοιχεία ή εφαρμογές, **ή να σταλούν χωρίς συγκεκριμένο παραλήπτη**.\
Για να είναι απλό, το Intent μπορεί να χρησιμοποιηθεί:

* Για να ξεκινήσει μια Δραστηριότητα, συνήθως ανοίγοντας μια διεπαφή χρήστη για μια εφαρμογή
* Ως μεταδόσεις για να ενημερώσουν το σύστημα και τις εφαρμογές για αλλαγές
* Για να ξεκινήσει, να σταματήσει και να επικοινωνήσει με ένα υπόβαθρο υπηρεσίας
* Για να έχει πρόσβαση σε δεδομένα μέσω ContentProviders
* Ως κλήσεις πίσω για την χειρισμό συμβάντων

Εάν είναι ευάλωτα, τα **Intents μπορούν να χρησιμοποιηθούν για να πραγματοποιήσουν μια ποικιλία επιθέσεων**.

### Intent-Filter

Τα **Intent Filters** ορίζουν **πώς μια δραστηριότητα, υπηρεσία ή Broadcast Receiver μπορεί να αλληλεπιδράσει με διαφορετικούς τύπους Intents**. Βασικά, περιγράφουν τις δυνατότητες αυτών των στοιχείων, όπως ποιες ενέργειες μπορούν να εκτελέσουν ή τι είδους μεταδόσεις μπορούν να επεξεργαστούν. Ο κύριος τρόπος να δηλωθούν αυτά τα φίλτρα είναι μέσα στο **αρχείο AndroidManifest.xml**, αν και για τους Broadcast Receivers, η κωδικοποίησή τους είναι επίσης μια επιλογή.

Τα Intent Filters αποτελούνται από κατηγορίες, ενέργειες και φίλτρα δεδομένων, με τη δυνατότητα συμπερίληψης επιπλέον μεταδεδομένων. Αυτή η ρύθμιση επιτρέπει στα στοιχεία να χειριστούν συγκεκριμένα Intents που ταιριάζουν με τα δηλωμένα κριτήρια.

Ένα κρίσιμο στοιχείο των στοιχείων Android (δραστηριότητες/υπηρεσίες/content providers/Broadcast Receivers) είναι η ορατότητά τους ή **δημόσια κατάσταση**. Ένα στοιχείο θεωρείται δημόσιο και μπορεί να αλληλεπιδρά με άλλες εφαρμογές εάν είναι **`εξαγόμενο`** με μια τιμή **`true`** ή αν έχει δηλωθεί ένα Intent Filter για αυτό στον κατάλογο. Ωστόσο, Ͽα υπάρχει ένας τρόπος για τους προγραμματιστές να κρατήσουν αυτά τα στοιχεία ιδιωτικά ρητά, εξασφαλίζοντας ότι δεν θα αλληλεπιδράν με άλλες εφαρμογές ακούσια. Αυτό επιτυγχάνεται με τον καθορισμό του χαρακτηριστικού **`εξαγωγή`** σε **`false`** στις ορισμούς τους στον κατάλογο.

Επιπλέον, οι προγραμματιστές έχουν τη δυνατότητα να ασφαλίσουν περαιτέρω την πρόσβαση σε αυτά τα στοιχεία απαιτώντας συγκεκριμένες άδειες. Το χαρακτηριστικό **`άδεια`** μπορεί να οριστεί για να επιβάλει ότι μόνο οι εφαρμογές με την καθορισμένη άδεια μπορούν να έχουν πρόσβαση στο στοιχείο, προσθέτοντας ένα επιπλέον επίπεδο ασφάλειας και έλεγχο πάνω σε ποιος μπορεί να αλληλεπιδρά με αυτό.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Σιωπηρές Προθέσεις

Οι προθέσεις δημιουργούνται προγραμματικά χρησιμοποιώντας έναν κατασκευαστή Πρόθεσης:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
Η **Ενέργεια** της προηγουμένως δηλωμένης πρόθεσης είναι **ACTION\_SEND** και το **Επιπλέον** είναι ένα mailto **Uri** (το Επιπλέον είναι η επιπλέον πληροφορία που αναμένει η πρόθεση).

Αυτή η πρόθεση πρέπει να δηλωθεί μέσα στον manifest όπως στο παρακάτω παράδειγμα:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Ένα intent-filter χρειάζεται να ταιριάζει την **action**, **data** και **category** για να λάβει ένα μήνυμα.

Η διαδικασία "Επίλυση Intent" καθορίζει ποια εφαρμογή θα πρέπει να λάβει κάθε μήνυμα. Αυτή η διαδικασία λαμβάνει υπόψη το **προτεραιότητας attribute**, το οποίο μπορεί να οριστεί στη δήλωση του **intent-filter**, και **επιλέγεται αυτό με τη μεγαλύτερη προτεραιότητα**. Αυτή η προτεραιότητα μπορεί να οριστεί μεταξύ -1000 και 1000 και οι εφαρμογές μπορούν να χρησιμοποιήσουν την τιμή `SYSTEM_HIGH_PRIORITY`. Εάν προκύψει **σύγκρουση**, εμφανίζεται ένα παράθυρο "επιλογής" ώστε ο **χρήστης να αποφασίσει**.

### Σαφή Intents

Ένα σαφές intent καθορίζει το όνομα της κλάσης στην οποία απευθύνεται:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Σε άλλες εφαρμογές για να έχετε πρόσβαση στο προηγουμένως δηλωμένο intent μπορείτε να χρησιμοποιήσετε:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Ενέργειες που εκκρεμούν

Αυτές επιτρέπουν σε άλλες εφαρμογές να **εκτελούν ενέργειες εκ μέρους της εφαρμογής σας**, χρησιμοποιώντας την ταυτότητα και τις άδειες της εφαρμογής σας. Κατά τη δημιουργία μιας Ενέργειας που εκκρεμεί πρέπει να **καθοριστεί ένα intent και η ενέργεια που πρέπει να εκτελεστεί**. Αν το **καθορισμένο intent δεν είναι Συγκεκριμένο** (δεν καθορίζει ποιο intent μπορεί να το καλέσει), μια **κακόβουλη εφαρμογή μπορεί να εκτελέσει την καθορισμένη ενέργεια** εκ μέρους της εφαρμογής θύματος. Επιπλέον, **αν δεν καθοριστεί μια ενέργεια**, η κακόβουλη εφαρμογή θα μπορεί να κάνει **οποιαδήποτε ενέργεια εκ μέρους του θύματος**.

### Ενέργειες Διανομής

Αντίθετα με τις προηγούμενες ενέργειες, οι οποίες λαμβάνονται μόνο από μία εφαρμογή, οι ενέργειες διανομής **μπορούν να ληφθούν από πολλές εφαρμογές**. Ωστόσο, από την έκδοση API 14, είναι **δυνατό να καθοριστεί η εφαρμογή που πρέπει να λάβει** το μήνυμα χρησιμοποιώντας το Intent.set Package.

Εναλλακτικά, είναι επίσης δυνατό να **καθοριστεί μια άδεια κατά την αποστολή της διανομής**. Η εφαρμογή παραλήπτης θα πρέπει να έχει αυτήν την άδεια.

Υπάρχουν **δύο τύποι** Διανομών: **Κανονικές** (ασύγχρονες) και **Ταξινομημένες** (σύγχρονες). Η **σειρά** βασίζεται στη **διαμορφωμένη προτεραιότητα εντός του στοιχείου παραλήπτη**. **Κάθε εφαρμογή μπορεί να επεξεργαστεί, να μεταδώσει ή να απορρίψει τη Διανομή.**

Είναι δυνατό να **στείλετε** μια **διανομή** χρησιμοποιώντας τη λειτουργία `sendBroadcast(intent, receiverPermission)` από την κλάση `Context`.\
Μπορείτε επίσης να χρησιμοποιήσετε τη λειτουργία **`sendBroadcast`** από το **`LocalBroadCastManager`** εξασφαλίζοντας ότι το **μήνυμα δεν αφήνει ποτέ την εφαρμογή**. Χρησιμοποιώντας αυτό, ακόμη και δεν θα χρειαστεί να εξαγάγετε ένα στοιχείο παραλήπτη.

### Κολλητές Διανομές

Αυτού του είδους οι Διανομές **μπορούν να αποκτηθούν πολύ καιρό μετά την αποστολή τους**.\
Αυτές αποσύρθηκαν στο επίπεδο API 21 και συνιστάται να **μην χρησιμοποιούνται**.\
**Επιτρέπουν σε οποιαδήποτε εφαρμογή να κατασκοπεύσει τα δεδομένα, αλλά και να τα τροποποιήσει.**

Αν βρείτε λειτουργίες που περιέχουν τη λέξη "κολλητή" όπως **`sendStickyBroadcast`** ή **`sendStickyBroadcastAsUser`**, **ελέγξτε τις επιπτώσεις και προσπαθήστε να τις αφαιρέσετε**.

## Βαθιοί σύνδεσμοι / Σχήματα URL

Στις εφαρμογές Android, οι **βαθιοί σύνδεσμοι** χρησιμοποιούνται για να εκκινήσουν μια ενέργεια (Intent) απευθείας μέσω ενός URL. Αυτό γίνεται δηλώνοντας ένα συγκεκριμένο **σχήμα URL** εντός μιας δραστηριότητας. Όταν μια συσκευή Android προσπαθεί να **έχει πρόσβαση σε ένα URL με αυτό το σχήμα**, η συγκεκριμένη δραστηριότητα εντός της εφαρμογής εκκινείται.

Το σχήμα πρέπει να δηλωθεί στο αρχείο **`AndroidManifest.xml`**:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Το σχήμα από το προηγούμενο παράδειγμα είναι `exampleapp://` (σημειώστε επίσης τη **`κατηγορία BROWSABLE`**)

Στο πεδίο δεδομένων, μπορείτε να καθορίσετε το **host** και τη **διαδρομή**:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Για να έχετε πρόσβαση από το web, μπορείτε να ορίσετε ένα σύνδεσμο όπως:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Για να βρείτε τον **κώδικα που θα εκτελεστεί στην εφαρμογή**, πηγαίνετε στη δραστηριότητα που καλείται από το deeplink και αναζητήστε τη λειτουργία **`onNewIntent`**.

Μάθετε πώς να [καλέσετε deep links χωρίς τη χρήση σελίδων HTML](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

Η **Γλώσσα Ορισμού Διεπαφής Android (AIDL)** σχεδιάστηκε για τη διευκόλυνση της επικοινωνίας μεταξύ πελάτη και υπηρεσίας στις εφαρμογές Android μέσω **διαδικασίας μεταξύ διεργασιών** (IPC). Δεδομένου ότι η πρόσβαση στη μνήμη μιας άλλης διεργασίας δεν επιτρέπεται στο Android, η AIDL απλοποιεί τη διαδικασία μετατροπής αντικειμένων σε ένα μορφότυπο που κατανοεί το λειτουργικό σύστημα, διευκολύνοντας έτσι την επικοινωνία μεταξύ διαφορετικών διεργασιών.

### Βασικές Έννοιες

- **Υπηρεσίες που συνδέονται**: Αυτές οι υπηρεσίες χρησιμοποιούν την AIDL για IPC, επιτρέποντας σε δραστηριότητες ή στοιχεία να συνδεθούν με μια υπηρεσία, να κάνουν αιτήσεις και να λαμβάνουν απαντήσεις. Η μέθοδος `onBind` στην κλάση της υπηρεσίας είναι κρίσιμη για την έναρξη της αλληλεπίδρασης, καθιστώντας την έναν σημαντικό τομέα για αναθεώρηση ασφάλειας ώστε να αναζητηθούν ευπάθειες.

- **Messenger**: Λειτουργώντας ως συνδεδεμένη υπηρεσία, το Messenger διευκολύνει το IPC με έμφαση στην επεξεργασία δεδομένων μέσω της μεθόδου `onBind`. Είναι ουσιώδες να ελέγξετε προσεκτικά αυτήν τη μέθοδο για οποιαδήποτε μη ασφαλή χειρισμό δεδομένων ή εκτέλεση ευαίσθητων λειτουργιών.

- **Binder**: Παρόλο που η άμεση χρήση της κλάσης Binder είναι λιγότερο συνηθισμένη λόγω της αφαίρεσης της AIDL, είναι χρήσιμο να κατανοήσετε ότι ο Binder λειτουργεί ως οδηγός σε επίπεδο πυρήνα που διευκολύνει τη μεταφορά δεδομένων μεταξύ των χώρων μνήμης διαφορετικών διεργασιών. Για περισσότερη κατανόηση, υπάρχει ένας πόρος στο [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Στοιχεία

Αυτά περιλαμβάνουν: **Δραστηριότητες, Υπηρεσίες, Δέκτες Εκπομπής και Παροχείς.**

### Δραστηριότητες εκκίνησης και άλλες δραστηριότητες

Στις εφαρμογές Android, οι **δραστηριότητες** είναι σαν οθόνες, που εμφανίζουν διαφορετικά μέρη της διεπαφής χρήστη της εφαρμογής. Μια εφαρμογή μπορεί να έχει πολλές δραστηριότητες, καθεμία παρουσιάζοντας μια μοναδική οθόνη στον χρήστη.

Η **δραστηριότητα εκκίνησης (launcher activity)** είναι η κύρια πύλη εισόδου σε μια εφαρμογή, που εκκινείται όταν πατάτε το εικονίδιο της εφαρμογής. Ορίζεται στο αρχείο με τις δηλώσεις της εφαρμογής με συγκεκριμένες προθέσεις MAIN και LAUNCHER:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Δεν όλες οι εφαρμογές χρειάζονται μια δραστηριότητα εκκίνησης, ειδικά αυτές χωρίς διεπαφή χρήστη, όπως οι υπηρεσίες φόντου.

Οι δραστηριότητες μπορούν να γίνουν διαθέσιμες σε άλλες εφαρμογές ή διεργασίες σημειώνοντάς τες ως "εξαγωγή" στον πίνακα. Αυτή η ρύθμιση επιτρέπει σε άλλες εφαρμογές να ξεκινήσουν αυτήν τη δραστηριότητα:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ωστόσο, η πρόσβαση σε μια δραστηριότητα από μια άλλη εφαρμογή δεν αποτελεί πάντα κίνδυνο για την ασφάλεια. Η ανησυχία προκύπτει εάν ευαίσθητα δεδομένα μοιράζονται εσφαλμένα, κάτι που θα μπορούσε να οδηγήσει σε διαρροές πληροφοριών.

Η διαδικασία ζωής μιας δραστηριότητας **ξεκινά με τη μέθοδο onCreate**, ρυθμίζοντας το UI και προετοιμάζοντας τη δραστηριότητα για αλληλεπίδραση με τον χρήστη.

### Υποκλάση Εφαρμογής

Στην ανάπτυξη Android, μια εφαρμογή έχει τη δυνατότητα να δημιουργήσει μια **υποκλάση** της [Εφαρμογής](https://developer.android.com/reference/android/app/Application) κλάσης, αν και δεν είναι υποχρεωτικό. Όταν ορίζεται μια τέτοια υποκλάση, γίνεται η πρώτη κλάση που δημιουργείται μέσα στην εφαρμογή. Η μέθοδος **`attachBaseContext`**, εάν υλοποιηθεί σε αυτή την υποκλάση, εκτελείται πριν τη μέθοδο **`onCreate`**. Αυτή η ρύθμιση επιτρέπει την πρώιμη αρχικοποίηση πριν ξεκινήσει η υπόλοιπη εφαρμογή.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Υπηρεσίες

[Οι υπηρεσίες](https://developer.android.com/guide/components/services) είναι **φόντο λειτουργοί** ικανοί να εκτελούν εργασίες χωρίς διεπαφή χρήστη. Αυτές οι εργασίες μπορούν να συνεχίσουν να εκτελούνται ακόμα και όταν οι χρήστες μεταβαίνουν σε διαφορετικές εφαρμογές, κάνοντας τις υπηρεσίες κρίσιμες για **εργασίες με μεγάλη διάρκεια**.

Οι υπηρεσίες είναι ευέλικτες. Μπορούν να εκκινηθούν με διάφορους τρόπους, με τα **Intents** να είναι ο κύριος τρόπος εκκίνησής τους ως σημείο εισόδου μιας εφαρμογής. Μόλις μια υπηρεσία ξεκινήσει χρησιμοποιώντας τη μέθοδο `startService`, η μέθοδος `onStart` της ενεργοποιείται και συνεχίζει να εκτελείται μέχρι να κληθεί εκ των υστέρων η μέθοδος `stopService`. Εναλλακτικά, αν ο ρόλος μιας υπηρεσίας εξαρτάται από μια ενεργή σύνδεση πελάτη, χρησιμοποιείται η μέθοδος `bindService` για τη σύνδεση του πελάτη με την υπηρεσία, ενεργοποιώντας τη μέθοδο `onBind` για τη μετάδοση δεδομένων.

Ένα ενδιαφέρον παράδειγμα χρήσης των υπηρεσιών περιλαμβάνει την αναπαραγωγή μουσικής στο φόντο ή τη λήψη δεδομένων δικτύου χωρίς να εμποδίζεται η αλληλεπίδραση του χρήστη με μια εφαρμογή. Επιπλέον, οι υπηρεσίες μπορούν να γίνουν προσβάσιμες σε άλλες διεργασίες στην ίδια συσκευή μέσω της **εξαγωγής**. Αυτή δεν είναι η προεπιλεγμένη συμπεριφορά και απαιτεί σαφή ρύθμιση στο αρχείο Android Manifest:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Αναμεταδότες Εκπομπής

Οι **αναμεταδότες εκπομπής** λειτουργούν ως ακροατές σε ένα σύστημα μηνυμάτων, επιτρέποντας σε πολλές εφαρμογές να ανταποκρίνονται στα ίδια μηνύματα από το σύστημα. Μια εφαρμογή μπορεί να **καταχωρήσει έναν αναμεταδότη** με **δύο βασικούς τρόπους**: μέσω του **Μανιφέστου** της εφαρμογής ή **δυναμικά** μέσα στον κώδικα της εφαρμογής μέσω του API **`registerReceiver`**. Στο Μανιφέστο, οι εκπομπές φιλτράρονται με δικαιώματα, ενώ οι αναμεταδότες που καταχωρούνται δυναμικά μπορούν επίσης να καθορίσουν δικαιώματα κατά την καταχώρηση.

Οι **φίλτρα προθέσεων** είναι κρίσιμα σε και τους δύο τρόπους καταχώρησης, καθορίζοντας ποιες εκπομπές ενεργοποιούν τον αναμεταδότη. Μόλις αποσταλεί μια αντίστοιχη εκπομπή, ενεργοποιείται η μέθοδος **`onReceive`** του αναμεταδότη, επιτρέποντας στην εφαρμογή να αντιδρά αναλόγως, όπως προσαρμογή της συμπεριφοράς σε απάντηση σε μια ειδοποίηση για χαμηλή μπαταρία.

Οι εκπομπές μπορούν να είναι είτε **ασύγχρονες**, φτάνοντας σε όλους τους αναμεταδότες χωρίς σειρά, είτε **σύγχρονες**, όπου οι αναμεταδότες λαμβάνουν την εκπομπή με βάση τις καθορισμένες προτεραιότητες. Ωστόσο, είναι σημαντικό να σημειωθεί ο δυνητικός κίνδυνος για την ασφάλεια, καθώς οποιαδήποτε εφαρμογή μπορεί να δώσει προτεραιότητα στον εαυτό της για να παρεμβαίνει σε μια εκπομπή.

Για να κατανοήσετε τη λειτουργικότητα ενός αναμεταδότη, ψάξτε για τη μέθοδο **`onReceive`** μέσα στην κλάση του. Ο κώδικας αυτής της μεθόδου μπορεί να χειριστεί την ληφθείσα Πρόθεση, υπογραμμίζοντας την ανάγκη επικύρωσης δεδομένων από τους αναμεταδότες, ειδικά σε **Ταξινομημένες Εκπομπές**, οι οποίες μπορούν να τροποποιήσουν ή να απορρίψουν την Πρόθεση.

### Πάροχοι Περιεχομένου

Οι **Πάροχοι Περιεχομένου** είναι ουσιώδεις για το **διαμοιρασμό δομημένων δεδομένων** μεταξύ εφαρμογών, υπογραμμίζοντας τη σημασία της εφαρμογής **δικαιωμάτων** για να διασφαλιστεί η ασφάλεια των δεδομένων. Επιτρέπουν στις εφαρμογές να έχουν πρόσβαση σε δεδομένα από διάφορες πηγές, συμπεριλαμβανομένων βάσεων δεδομένων, συστημάτων αρχείων ή του web. Ειδικά δικαιώματα, όπως **`readPermission`** και **`writePermission`**, είναι κρίσιμα για τον έλεγχο της πρόσβασης. Επιπλέον, μπορεί να χορηγηθεί προσωρινή πρόσβαση μέσω των ρυθμίσεων **`grantUriPermission`** στο μανιφέστο της εφαρμογής, εκμεταλλευόμενο χαρακτηριστικά όπως `path`, `pathPrefix` και `pathPattern` για λεπτομερή έλεγχο πρόσβασης.

Η επικύρωση εισόδου είναι ζωτικής σημασίας για την πρόληψη ευπαθειών, όπως η εισχώρηση SQL. Οι Πάροχοι Περιεχομένου υποστηρίζουν βασικές λειτουργίες: `insert()`, `update()`, `delete()` και `query()`, διευκολύνοντας τη διαχείριση δεδομένων και τον διαμοιρασμό μεταξύ εφαρμογών.

**FileProvider**, ένας εξειδικευμένος Πάροχος Περιεχομένου, επικεντρώνεται στον ασφαλή διαμοιρασμό αρχείων. Ορίζεται στο μανιφέστο της εφαρμογής με συγκεκριμένα χαρακτηριστικά για τον έλεγχο της πρόσβασης σε φακέλους, που υποδεικνύονται από τα `android:exported` και `android:resource` που δείχνουν σε ρυθμίσεις φακέλων. Συνιστάται προσοχή κατά τον διαμοιρασμό καταλόγων για να αποφευχθεί η αποκάλυψη ευαίσθητων δεδομένων κατά λάθος.

Παράδειγμα δήλωσης μανιφέστου για το FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Και ένα παράδειγμα καθορισμού κοινόχρηστων φακέλων στο `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Για περισσότερες πληροφορίες ελέγξτε:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

Τα WebViews είναι σαν **μικροί web browsers** μέσα σε εφαρμογές Android, εμφανίζοντας περιεχόμενο είτε από το web είτε από τοπικά αρχεία. Αντιμετωπίζουν παρόμοιους κινδύνους με τους κανονικούς browsers, ωστόσο υπάρχουν τρόποι για να **μειωθούν αυτοί οι κίνδυνοι** μέσω συγκεκριμένων **ρυθμίσεων**.

Το Android προσφέρει δύο κύριους τύπους WebView:

- Ο **WebViewClient** είναι ιδανικός για βασικό HTML αλλά δεν υποστηρίζει τη λειτουργία ειδοποίησης JavaScript, επηρεάζοντας τον τρόπο που μπορούν να δοκιμαστούν οι επιθέσεις XSS.
- Ο **WebChromeClient** λειτουργεί περισσότερο σαν την πλήρη εμπειρία του περιηγητή Chrome.

Ένα σημαντικό σημείο είναι ότι οι browsers των WebViews **δεν μοιράζονται cookies** με τον κύριο browser της συσκευής.

Για τη φόρτωση περιεχομένου, διατίθενται μέθοδοι όπως η ````loadUrl````, ````loadData````, και ````loadDataWithBaseURL````. Είναι κρίσιμο να εξασφαλίσετε ότι αυτά τα URLs ή αρχεία είναι **ασφαλή για χρήση**. Οι ρυθμίσεις ασφαλείας μπορούν να διαχειριστούν μέσω της κλάσης ````WebSettings````. Για παράδειγμα, η απενεργοποίηση του JavaScript με την εντολή ````setJavaScriptEnabled(false)```` μπορεί να αποτρέψει επιθέσεις XSS.

Η JavaScript "Bridge" επιτρέπει σε αντικείμενα Java να αλληλεπιδρούν με το JavaScript, απαιτώντας οι μέθοδοι να επισημαίνονται με το ````@JavascriptInterface```` για ασφάλεια από το Android 4.2 και μετά.

Η επιτροπή πρόσβασης περιεχομένου (````setAllowContentAccess(true)````) επιτρέπει στις WebViews να φτάσουν τους Content Providers, που θα μπορούσε να αποτελέσει κίνδυνο εκτός αν οι διευθύνσεις περιεχομένου επαληθευτούν ως ασφαλείς.

Για τον έλεγχο της πρόσβασης σε αρχεία:
- Η απενεργοποίηση της πρόσβασης σε αρχεία (````setAllowFileAccess(false)````) περιορίζει την πρόσβαση στο σύστημα αρχείων, με εξαιρέσεις για συγκεκριμένα assets, εξασφαλίζοντας ότι χρησιμοποιούνται μόνο για μη-ευαίσθητο περιεχόμενο.

## Άλλα Στοιχεία Εφαρμογής και Διαχείριση Κινητής Συσκευής

### **Ψηφιακή Υπογραφή Εφαρμογών**

- Η **ψηφιακή υπογραφή** είναι απαραίτητη για τις εφαρμογές Android, εξασφαλίζοντας ότι είναι **αυθεντικά υπογεγραμμένες** πριν την εγκατάσταση. Αυτή η διαδικασία χρησιμοποιεί ένα πιστοποιητικό για την ταυτοποίηση της εφαρμογής και πρέπει να επαληθευτεί από τον διαχειριστή πακέτων της συσκευής κατά την εγκατάσταση. Οι εφαρμογές μπορούν να είναι **αυτο-υπογεγραμμένες ή πιστοποιημένες από εξωτερική αρχή πιστοποίησης**, προστατεύοντας από την μη εξουσιοδοτημένη πρόσβαση και εξασφαλίζοντας ότι η εφαρμογή παραμένει αμετάβλητη κατά την παράδοσή της στη συσκευή.

### **Επαλήθευση Εφαρμογής για Ενισχυμένη Ασφάλεια**

- Ξεκινώντας από την **Android 4.2**, μια λειτουργία που ονομάζεται **Επαλήθευση Εφαρμογών** επιτρέπει στους χρήστες να ελέγχουν τις εφαρμογές για ασφάλεια πριν την εγκατάσταση. Αυτή η **διαδικασία επαλήθευσης** μπορεί να προειδοποιήσει τους χρήστες για πιθανά επικίνδυνες εφαρμογές, ή ακόμα και να αποτρέψει την εγκατάσταση ιδιαίτερα κακόβουλων, βελτιώνοντας την ασφάλεια του χρήστη.

### **Διαχείριση Κινητής Συσκευής (MDM)**

- Οι **λύσεις MDM** παρέχουν **επίβλεψη και ασφάλεια** για κινητές συσκευές μέσω του **API Διαχείρισης Συσκευών**. Απαιτούν την εγκατάσταση μιας εφαρμογής Android για την αποτελεσματική διαχείριση και ασφάλεια των κινητών συσκευών. Κύριες λειτουργίες περιλαμβάνουν την **επιβολή πολιτικών κωδικού πρόσβασης**, την **υποχρέωση κρυπτογράφησης αποθήκευσης**, και την **επιτροπή απομάκρυνσης δεδομένων**, εξασφαλίζοντας πλήρη έλεγχο και ασφάλεια πάνω στις κινητές συσκευές.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Red Team του HackTricks AWS)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>
