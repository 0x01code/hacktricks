# Android Uygulamaları Temelleri

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com)'ni edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

**Try Hard Güvenlik Grubu**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Android Güvenlik Modeli

**İki katman bulunmaktadır:**

* **İşletim Sistemi (OS)**, yüklü uygulamaları birbirinden izole eder.
* **Uygulama kendisi**, geliştiricilere belirli işlevleri **açığa çıkarmalarına** ve uygulama yeteneklerini yapılandırmalarına olanak tanır.

### UID Ayrımı

**Her uygulamaya belirli bir Kullanıcı Kimliği (UID) atanır**. Bu, uygulamanın yüklenmesi sırasında yapılır, böylece uygulama yalnızca kendi UID'sine ait dosyalara veya paylaşılan dosyalara erişebilir. Bu nedenle, yalnızca uygulama kendisi, işletim sisteminin belirli bileşenleri ve kök kullanıcı uygulama verilerine erişebilir.

### UID Paylaşımı

**İki uygulama aynı UID'yi kullanacak şekilde yapılandırılabilir**. Bu bilgi paylaşımı için yararlı olabilir, ancak bunlardan biri tehlikeye düşerse her iki uygulamanın verileri de tehlikeye düşer. Bu nedenle bu davranış **önerilmez**.\
**Aynı UID'yi paylaşmak için uygulamalar, manifestolarında aynı `android:sharedUserId` değerini tanımlamalıdır.**

### Kum Sandığı (Sandboxing)

**Android Uygulama Kum Sandığı**, **her uygulamanın** ayrı bir süreç olarak çalışmasına olanak tanır ve her birine ayrı bir kullanıcı kimliği atar. Her sürecin kendi sanal makinesi vardır, bu nedenle bir uygulamanın kodu diğer uygulamalardan izole bir şekilde çalışır.\
Android 5.0(L) itibariyle **SELinux** zorunlu hale getirilmiştir. Temelde, SELinux tüm süreç etkileşimlerini reddetti ve ardından bunlar arasındaki **beklenen etkileşimlere yalnızca izin veren politikalar oluşturdu**.

### İzinler

Bir **uygulama yüklediğinizde ve izinler istediğinde**, uygulama **AndroidManifest.xml** dosyasındaki **`uses-permission`** öğelerinde yapılandırılan izinleri istemektedir. **uses-permission** öğesi, istenen iznin adını içeren **name** **özniteliğini** belirtir. Ayrıca **maxSdkVersion** özniteliği vardır, bu özellik belirtilenden daha yüksek sürümlerde izin istemeyi durdurur.\
Android uygulamalarının tüm izinleri başlangıçta sorması gerekmediğini unutmayın, ayrıca **izinleri dinamik olarak da isteyebilirler** ancak tüm izinler **manifestoda belirtilmelidir**.

Bir uygulama işlevsellik açığa çıkardığında, **erişimi yalnızca belirli bir izne sahip uygulamalara sınırlayabilir**.\
Bir izin öğesinin üç özelliği vardır:

* İzinin **adı**
* İzin grubu özniteliği, ilgili izinleri gruplandırmaya olanak tanır.
* İzinlerin nasıl verildiğini belirten **koruma düzeyi**. Dört tür vardır:
* **Normal**: Uygulamaya **bilinen tehditler** olmadığında kullanılır. Kullanıcının **onayı gerekmez**.
* **Tehlikeli**: İzinin isteyen uygulamaya bazı **yükseltilmiş erişim** sağladığını belirtir. **Kullanıcıların onayını talep eder**.
* **Signature**: Yalnızca **bileşeni ihraç eden sertifika ile aynı sertifikaya sahip uygulamalara** izin verilebilir. Bu en güçlü koruma türüdür.
* **SignatureOrSystem**: Yalnızca **bileşeni ihraç eden sertifika ile aynı sertifikaya sahip uygulamalara** veya **sistem düzeyinde erişimle çalışan uygulamalara** izin verilebilir

## Ön Yüklü Uygulamalar

Bu uygulamalar genellikle **`/system/app`** veya **`/system/priv-app`** dizinlerinde bulunur ve bazıları **optimize edilmiştir** (bazen `classes.dex` dosyasını bile bulamayabilirsiniz). Bu uygulamalar kontrol edilmeye değerdir çünkü bazen **çok fazla izinle çalışırlar** (kök olarak).

* **AOSP** (Android Açık Kaynak Projesi) **ROM** ile birlikte gönderilenler
* Cihaz **üreticisi** tarafından eklenenler
* Cep telefonu sağlayıcısı tarafından eklenenler (onlardan satın alındıysa)

## Rootlama

Fiziksel bir Android cihaza kök erişim elde etmek için genellikle cihaza ve sürüme **özgü** olan 1 veya 2 **zafiyeti sömürmeniz gerekir**.\
Sömürü çalıştığında genellikle Linux `su` ikili dosyası, kullanıcının PATH çevresel değişkeninde belirtilen bir konuma kopyalanır, örneğin `/system/xbin`.

`su` ikili dosyası yapılandırıldığında, başka bir Android uygulaması `su` ikili dosyasıyla etkileşim kurmak ve **kök erişimi taleplerini işlemek için** kullanılır, örneğin **Superuser** ve **SuperSU** (Google Play Store'da mevcuttur).

{% hint style="danger" %}
Rootlama işlemi çok tehlikelidir ve cihaza ciddi zarar verebilir
{% endhint %}

### ROM'lar

**Özel bir yazılım yükleyerek işletim sistemini değiştirmek mümkündür**. Bunu yaparak eski bir cihazın kullanışlılığını artırabilir, yazılım kısıtlamalarını atlayabilir veya en son Android koduna erişim sağlayabilirsiniz.\
**OmniROM** ve **LineageOS**, kullanılan en popüler yazılımlardan ikisidir.

Cihazın **özelleştirilmiş bir yazılım yüklemek için kök erişim gerekli olmadığına** dikkat edin. **Bazı üreticiler**, bootloader'larının belgeli ve güvenli bir şekilde kilidini açmalarına izin verir.

### Sonuçlar

Bir cihaz köklendiğinde, herhangi bir uygulama kök erişimini isteyebilir. Kötü niyetli bir uygulama bunu alırsa, neredeyse her şeye erişimi olacak ve telefona zarar verebilecektir.

## Android Uygulama Temelleri <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Android uygulamalarının formatı _APK dosya formatı_ olarak adlandırılır. Temelde bir **ZIP dosyasıdır** (dosya uzantısını .zip olarak değiştirerek içerik çıkarılabilir ve görüntülenebilir).
- APK İçeriği (Eksiksiz Değil)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: derlenmiş kaynakları, ikili XML gibi içeren.
- res/xml/files\_paths.xml
- META-INF/
- Burada Sertifika bulunur!
- **classes.dex**
- Uygulamanın varsayılan olarak yürüttüğü derlenmiş Java (veya Kotlin) kodunu temsil eden Dalvik bytecode içerir.
- lib/
- CPU mimarisine göre alt dizinlerde ayrılmış yerel kütüphaneleri barındırır.
- `armeabi`: ARM tabanlı işlemciler için kod
- `armeabi-v7a`: ARMv7 ve daha yüksek tabanlı işlemciler için kod
- `x86`: X86 işlemciler için kod
- `mips`: Yalnızca MIPS işlemciler için kod
- assets/
- Uygulama tarafından gereken çeşitli dosyaları saklar, ek kodu gizlemek için bazen kötü niyetli yazarlar tarafından kullanılan ek yerel kütüpheler veya DEX dosyalarını içerebilir.
- res/
- Derlenmiş olmayan kaynakları içerir.
### **Dalvik ve Smali**

Android geliştirmede **Java veya Kotlin** uygulamalar oluşturmak için kullanılır. Masaüstü uygulamalarında JVM kullanmak yerine Android bu kodu **Dalvik Yürütülebilir (DEX) bytecode**'a derler. Önceden, Dalvik sanal makinesi bu bytecode'u işlerken, şimdi daha yeni Android sürümlerinde Android Runtime (ART) devralır.

Tersine mühendislik için **Smali** hayati hale gelir. Bu, DEX bytecode'un insan tarafından okunabilir versiyonudur ve kaynak kodunu bytecode talimatlarına çevirerek montaj dili gibi davranır. Smali ve baksmali, bu bağlamda montaj ve montajdan çıkarma araçlarını ifade eder.

## İntentler

İntentler, Android uygulamalarının bileşenleri arasında veya diğer uygulamalarla iletişim kurmanın temel yollarıdır. Bu mesaj nesneleri aynı zamanda veri taşıyabilir ve uygulamalar veya bileşenler arasında GET/POST isteklerinin HTTP iletişiminde nasıl kullanıldığına benzer şekilde veri taşıyabilir.

Yani bir İntent temelde **bileşenler arasında iletilen bir mesajdır**. İntentler **belirli bileşenlere veya uygulamalara yönlendirilebilir** veya **belirli bir alıcı olmadan gönderilebilir**.\
Basitçe İntent şunlar için kullanılabilir:

* Bir Etkinliği başlatmak için, genellikle bir uygulama için bir kullanıcı arayüzü açma
* Değişiklikleri sistem ve uygulamalara bildirmek için yayınlar olarak
* Arkaplan hizmetini başlatmak, durdurmak ve iletişim kurmak için
* ContentProvider'lar aracılığıyla veriye erişmek için
* Olayları işlemek için geri çağrılar olarak

Eğer zayıfsa, **İntentler çeşitli saldırıları gerçekleştirmek için kullanılabilir**.

### İntent-Filtre

**İntent Filtreleri**, bir etkinlik, hizmet veya Yayın Alıcısının farklı türdeki İntent'lerle nasıl etkileşime geçebileceğini tanımlar. Temelde, bu bileşenlerin ne tür eylemler gerçekleştirebileceğini veya hangi yayınları işleyebileceğini açıklarlar. Bu filtreleri tanımlamanın temel yeri **AndroidManifest.xml dosyası** içindedir, ancak Yayın Alıcıları için bunları kodlamak da bir seçenektir.

İntent Filtreleri, kategoriler, eylemler ve veri filtrelerinden oluşur ve ek meta verileri içerebilme olasılığı vardır. Bu yapı, belirtilen kriterleri karşılayan belirli İntent'leri işlemek için bileşenlere izin verir.

Android bileşenlerinin (etkinlikler/hizmetler/içerik sağlayıcılar/yayın alıcıları) kritik bir yönü, **genel görünürlük veya** **`exported`** değerinin **`true`** olarak ayarlanması durumunda diğer uygulamalarla etkileşime girebilmesidir veya manifestte için bir İntent Filtresi belirtilmişse. Bununla birlikte, geliştiricilerin bu bileşenleri yanlışlıkla diğer uygulamalarla etkileşime girmesini engellemek için bu bileşenleri açıkça özel tutma seçeneği vardır. Bu, manifest tanımlamalarında **`exported`** özniteliğini **`false`** olarak ayarlayarak sağlanır.

Ayrıca, geliştiriciler bu bileşenlere erişimi daha da güvenli hale getirmek için belirli izinleri gerektirebilir. **`izin`** özniteliği, yalnızca belirli izne sahip uygulamaların bileşene erişebilmesini zorlamak için ayarlanabilir, böylece kiminle etkileşimde bulunabileceği üzerinde ek bir güvenlik ve kontrol katmanı eklenir.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### İmplit Intentler

Intentler, bir Intent yapıcısı kullanılarak programatik olarak oluşturulur:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**Eylem** önceden belirtilen niyetin **ACTION\_SEND** ve **Ekstra** bir mailto **Uri**'dir (Ekstra, niyetin beklediği ekstra bilgidir).

Bu niyet, aşağıdaki örnekte olduğu gibi manifest dosyasının içinde belirtilmelidir:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Bir intent-filtresinin bir mesajı alabilmesi için **action**, **data** ve **category**'nin eşleşmesi gerekir.

"Intent çözümleme" süreci, her mesajın hangi uygulamanın alması gerektiğini belirler. Bu süreç, **öncelik özniteliğini** dikkate alır, bu öncelik, **intent-filtresi bildiriminde** ayarlanabilir ve **daha yüksek önceliğe sahip olan seçilir**. Bu öncelik -1000 ile 1000 arasında ayarlanabilir ve uygulamalar `SYSTEM_HIGH_PRIORITY` değerini kullanabilir. Bir **çakışma** ortaya çıkarsa, "seçici" Penceresi görünür, böylece **kullanıcı karar verebilir**.

### Açık İntentler

Açık bir intent, hedeflediği sınıf adını belirtir:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Diğer uygulamalarda önceden belirtilen amaçlara erişmek için şunu kullanabilirsiniz:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Bekleyen İzinler

Bu, diğer uygulamaların **uygulamanız adına hareketlerde bulunmasına izin verir**, uygulamanızın kimliğini ve izinlerini kullanarak. Bekleyen İzin oluşturulurken bir niyet ve gerçekleştirilecek eylem **belirtilmelidir**. Eğer **belirtilen niyet açık değilse** (hangi niyetin onu çağırabileceğini belirtmez) **kötü niyetli bir uygulama belirtilen eylemi** kurban uygulama adına gerçekleştirebilir. Dahası, **bir eylem belirtilmemişse**, kötü niyetli uygulama kurban adına **herhangi bir eylem yapabilir**.

### Yayın İzinleri

Önceki izinlerin aksine, yayın izinleri **birden fazla uygulama tarafından alınabilir**. Ancak, API sürümü 14'ten itibaren, mesajı alması gereken uygulamayı belirtmek mümkündür Intent.setPackage kullanarak.

Alternatif olarak, yayın gönderirken **bir izin belirtmek de mümkündür**. Alıcı uygulamanın o izne sahip olması gerekecektir.

İki tür Yayın vardır: **Normal** (asykron) ve **Sıralı** (senkron). **Sıralama**, **alıcı içinde yapılandırılmış önceliğe** göre belirlenir. **Her uygulama Yayını işleyebilir, iletebilir veya bırakabilir**.

`Context` sınıfından `sendBroadcast(intent, receiverPermission)` işlevini kullanarak bir yayın göndermek mümkündür.\
Ayrıca, **`LocalBroadCastManager`**'dan **`sendBroadcast`** işlevini kullanarak **mesajın uygulamadan çıkmamasını** sağlayabilirsiniz. Bunu kullanarak bir alıcı bileşenini dışa aktarmanıza gerek kalmaz.

### Kalıcı Yayınlar

Bu tür Yayınlar **gönderildikten uzun süre sonra erişilebilir**.\
Bu, API seviyesi 21'de kullanımdan kaldırıldı ve **kullanılmaması önerilir**.\
**Herhangi bir uygulamanın verileri izlemesine ve değiştirmesine izin verirler**.

Eğer **"sticky"** kelimesini içeren işlevler bulursanız, örneğin **`sendStickyBroadcast`** veya **`sendStickyBroadcastAsUser`**, **etkisini kontrol edin ve bunları kaldırmayı deneyin**.

## Derin Bağlantılar / URL şemaları

Android uygulamalarında, **derin bağlantılar** bir URL aracılığıyla doğrudan bir eylemi (Niyet) başlatmak için kullanılır. Bu, bir etkinlik içinde belirli bir **URL şemasının** bildirilmesiyle yapılır. Bir Android cihazı, bu şemayla bir URL'ye **erişmeye çalıştığında**, uygulama içinde belirtilen etkinlik başlatılır.

Şema, **`AndroidManifest.xml`** dosyasında belirtilmelidir:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Önceki örneğin şeması `exampleapp://` (ayrıca **`category BROWSABLE`**'ı da not edin)

Ardından, veri alanında **host** ve **path**'i belirtebilirsiniz:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Web'den erişmek için bir bağlantı belirlemek mümkündür:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
**Uygulamada yürütülecek kodu bulmak** için deeplink tarafından çağrılan etkinliğe gidin ve **`onNewIntent`** işlevini arayın.

Derin bağlantıları **HTML sayfaları kullanmadan** nasıl [çağıracağınızı öğrenin](./#exploiting-schemes-deep-links).

## AIDL - Android Arayüz Tanım Dili

**Android Arayüz Tanım Dili (AIDL)**, Android uygulamalarında istemci ve hizmet arasındaki iletişimi kolaylaştırmak amacıyla tasarlanmıştır, **işlem arası iletişim** (IPC) yoluyla. Android'de başka bir işlemin belleğine doğrudan erişim izin verilmediğinden, AIDL işlemi basitleştirerek nesneleri işletim sistemi tarafından anlaşılan bir formata dönüştürerek farklı işlemler arasında iletişimi kolaylaştırır.

### Temel Kavramlar

- **Bağlı Hizmetler**: Bu hizmetler, IPC için AIDL'yi kullanır, etkinliklerin veya bileşenlerin bir hizmete bağlanmasını, isteklerde bulunmasını ve yanıtlar almasını sağlar. Hizmetin sınıfındaki `onBind` yöntemi etkileşimi başlatmak için kritiktir ve güvenlik açıklarını aramak için önemli bir alan olarak işaretlenmiştir.

- **Messenger**: Bağlı bir hizmet olarak çalışan Messenger, verilerin işlenmesine odaklanarak IPC'yi kolaylaştırır. Bu yöntemi güvenli olmayan veri işleme veya hassas işlevlerin yürütülmesi açısından yakından incelemek önemlidir.

- **Binder**: AIDL'nin soyutlaması nedeniyle Binder sınıfının doğrudan kullanımı daha az yaygın olsa da, Binder'ın farklı işlemlerin bellek alanları arasında veri transferini kolaylaştıran bir çekirdek seviye sürücü olarak hareket ettiğini anlamak faydalıdır. Daha fazla anlayış için bir kaynak [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8) adresinde bulunmaktadır.

## Bileşenler

Bunlar şunları içerir: **Etkinlikler, Hizmetler, Yayın Alıcılar ve Sağlayıcılar.**

### Başlatıcı Etkinlik ve diğer etkinlikler

Android uygulamalarında **etkinlikler**, uygulamanın kullanıcı arayüzünün farklı bölümlerini gösteren ekranlar gibidir. Bir uygulamada birçok etkinlik olabilir, her biri kullanıcıya benzersiz bir ekran sunar.

**Başlatıcı etkinlik**, uygulamanın ana giriş kapısıdır ve uygulamanın simgesine dokunduğunuzda başlatılır. Uygulamanın belirli MAIN ve LAUNCHER niyetleriyle uygulamanın manifest dosyasında tanımlanmıştır:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
### Android Uygulamaları Temelleri

Launcher etkinliğine ihtiyaç duymayan uygulamalar, özellikle arka plan hizmetleri gibi kullanıcı arayüzü olmayanlar, bulunabilir.

Etkinlikler, manifest dosyasında "ihracat" olarak işaretlenerek diğer uygulamalara veya işlemlere erişilebilir hale getirilebilir. Bu ayar, diğer uygulamaların bu etkinliği başlatmasına izin verir:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ancak, bir uygulamadan diğer bir uygulamaya erişmek her zaman bir güvenlik riski oluşturmaz. Endişe, hassas verilerin yanlış şekilde paylaşılması durumunda ortaya çıkar, bu da bilgi sızıntılarına yol açabilir.

Bir aktivitenin yaşam döngüsü **onCreate yöntemiyle başlar**, UI'yi kurar ve aktiviteyi kullanıcıyla etkileşime hazırlar.

### Uygulama Alt Sınıfı

Android geliştirmede, bir uygulamanın [Application](https://developer.android.com/reference/android/app/Application) sınıfının bir **alt sınıfını** oluşturma seçeneği vardır, ancak zorunlu değildir. Bu tür bir alt sınıf tanımlandığında, uygulama içinde ilk olarak örneklenen sınıf olur. Bu alt sınıfta uygulandıysa **`attachBaseContext`** yöntemi, **`onCreate`** yönteminden önce yürütülür. Bu kurulum, uygulamanın geri kalanının başlamasından önce erken başlatma olanağı sağlar.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Hizmetler

[Hizmetler](https://developer.android.com/guide/components/services), kullanıcı arayüzü olmadan görevleri yürütebilen **arka plan işlemcileri**dir. Bu görevler, kullanıcılar farklı uygulamalara geçtiklerinde bile çalışmaya devam edebilir, bu nedenle hizmetler **uzun süre çalışan işlemler** için hayati öneme sahiptir.

Hizmetler çok yönlüdür; çeşitli şekillerde başlatılabilirler ve bunları başlatmanın temel yolu **Intent'ler**dir, uygulamanın giriş noktası olarak. Bir hizmet, `startService` yöntemi kullanılarak başlatıldığında, `onStart` yöntemi devreye girer ve `stopService` yöntemi açıkça çağrılana kadar çalışmaya devam eder. Alternatif olarak, bir hizmetin rolü aktif bir istemci bağlantısına bağlıysa, istemciyi hizmete bağlamak için `bindService` yöntemi kullanılır ve veri iletimi için `onBind` yöntemi devreye girer.

Hizmetlerin ilginç bir uygulaması, arka planda müzik çalma veya ağ verisi alma gibi işlemleri kullanıcının bir uygulayla etkileşimini engellemeden gerçekleştirmektir. Ayrıca, hizmetler diğer işlemlerin aynı cihazda erişebilmesi için **dışa aktarılabilir**. Bu varsayılan davranış değildir ve Android Manifest dosyasında açıkça yapılandırma gerektirir:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Yayın Alıcıları

**Yayın alıcıları**, bir iletişim sisteminde dinleyici olarak hareket eder ve sistemden gelen aynı iletilere birden fazla uygulamanın yanıt vermesine olanak tanır. Bir uygulama bir yayın alıcısını **iki temel yol** ile **kaydedebilir**: uygulamanın **Manifest** dosyası aracılığıyla veya uygulamanın kodu içinde **dinamik olarak** **`registerReceiver`** API'si aracılığıyla. Manifest dosyasında yayınlar izinlerle filtrelenirken, dinamik olarak kaydedilen alıcılar kayıt sırasında izinleri de belirtebilir.

**Intent filtreleri**, kayıt yöntemlerinde de önemli olup, alıcının hangi yayınların alınacağını belirler. Eşleşen bir yayın gönderildiğinde, alıcının **`onReceive`** yöntemi çağrılır ve uygulamanın buna uygun şekilde tepki vermesini sağlar, örneğin, düşük pil uyarısına yanıt olarak davranışı ayarlar.

Yayınlar ya **asenkron** olabilir, tüm alıcılara sırasız ulaşır, ya da **senkron** olabilir, burada alıcılar belirlenen önceliklere göre yayını alır. Ancak, herhangi bir uygulamanın bir yayını ele geçirmek için kendisini önceliklendirebileceği potansiyel güvenlik riskini göz önünde bulundurmak önemlidir.

Bir alıcının işlevselliğini anlamak için, sınıfındaki **`onReceive`** yöntemini arayın. Bu yöntemin kodu alınan Intent'i manipüle edebilir, bu da alıcılar tarafından veri doğrulamasının gerekliliğini vurgular, özellikle de Intent'i değiştirebilen veya bırakabilen **Sıralı Yayınlar** için.

### İçerik Sağlayıcı

**İçerik Sağlayıcılar**, uygulamalar arasında **yapılandırılmış veri paylaşımı** için önemlidir ve veri güvenliğini sağlamak için **izinlerin** uygulanmasının önemini vurgular. Bu, veritabanları, dosya sistemleri veya web gibi çeşitli kaynaklardan veriye erişim sağlar. **`readPermission`** ve **`writePermission`** gibi belirli izinler, erişimi kontrol etmek için önemlidir. Ayrıca, geçici erişim, ayrıntılı erişim kontrolü için `path`, `pathPrefix` ve `pathPattern` gibi özellikleri kullanarak uygulamanın manifestindeki **`grantUriPermission`** ayarları aracılığıyla verilebilir.

SQL enjeksiyonu gibi güvenlik açıklarını önlemek için giriş doğrulaması son derece önemlidir. İçerik Sağlayıcılar, `insert()`, `update()`, `delete()` ve `query()` gibi temel işlemleri destekler, veri manipülasyonunu ve uygulamalar arasında paylaşımı kolaylaştırır.

**FileProvider**, güvenli bir şekilde dosya paylaşımına odaklanan özel bir İçerik Sağlayıcıdır. Klasör erişimini kontrol etmek için belirli özelliklerle uygulamanın manifest dosyasında tanımlanır ve `android:exported` ve `android:resource` ile klasör yapılandırmalarına işaret eder. Hassas verilerin yanlışlıkla açığa çıkarılmasını önlemek için dizinlerin paylaşımında dikkatli olunması önerilir.

FileProvider için örnek manifest bildirimi:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Ve `filepaths.xml` dosyasında paylaşılan klasörleri belirtmenin bir örneği:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
- Daha fazla bilgi için şu kaynaklara bakabilirsiniz:
  - [Android Geliştiriciler: İçerik Sağlayıcılar](https://developer.android.com/guide/topics/providers/content-providers)
  - [Android Geliştiriciler: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews, Android uygulamaları içindeki **mini web tarayıcıları** gibidir, içeriği web'den veya yerel dosyalardan alırlar. Bunlar normal tarayıcılar gibi benzer risklerle karşılaşırlar, ancak belirli **ayarlar** aracılığıyla bu riskleri **azaltmanın yolları** vardır.

Android, iki ana WebView türü sunar:

- **WebViewClient**, temel HTML için harikadır ancak JavaScript uyarı işlevini desteklemez, bu da XSS saldırılarının nasıl test edilebileceğini etkiler.
- **WebChromeClient**, tam Chrome tarayıcı deneyimine daha çok benzer.

Önemli bir nokta, WebView tarayıcılarının cihazın ana tarayıcısıyla **çerezleri paylaşmamasıdır**.

İçerik yükleme için ````loadUrl````, ````loadData````, ve ````loadDataWithBaseURL```` gibi yöntemler mevcuttur. Bu URL'lerin veya dosyaların **güvenli olduğundan emin olmak** önemlidir. Güvenlik ayarları, ````WebSettings```` sınıfı aracılığıyla yönetilebilir. Örneğin, ````setJavaScriptEnabled(false)```` ile JavaScript devre dışı bırakılarak XSS saldırıları engellenebilir.

Java nesnelerinin JavaScript ile etkileşimini sağlayan JavaScript "Bridge", yöntemlerin Android 4.2'den itibaren güvenlik için ````@JavascriptInterface```` ile işaretlenmesini gerektirir.

İçeriğe erişime izin vermek (````setAllowContentAccess(true)````), WebViews'in İçerik Sağlayıcılara ulaşmasına izin verir, ancak içerik URL'lerinin güvenli olduğu doğrulanmadıkça bir risk olabilir.

Dosya erişimini kontrol etmek için:
- Dosya erişiminin devre dışı bırakılması (````setAllowFileAccess(false)````), dosya sistemine erişimi sınırlar, belirli varlıklar için istisnalar yaparak, bunların hassas olmayan içerikler için kullanıldığından emin olur.

## Diğer Uygulama Bileşenleri ve Mobil Cihaz Yönetimi

### **Uygulamaların Dijital İmzalanması**

- Android uygulamaları için **dijital imzalama**, kurulumdan önce uygulamaların **gerçekten kimin tarafından yazıldığını** sağlamak için gereklidir. Bu süreç, uygulama kimliği için bir sertifika kullanır ve kurulum sırasında cihazın paket yöneticisi tarafından doğrulanmalıdır. Uygulamalar **kendi kendine imzalanabilir veya harici bir CA tarafından onaylanabilir**, yetkisiz erişime karşı koruma sağlar ve uygulamanın cihaza teslim edilirken değiştirilmediğinden emin olur.

### **Gelişmiş Güvenlik için Uygulama Doğrulaması**

- **Android 4.2'den** itibaren, **Uygulamaları Doğrula** adlı bir özellik, kullanıcıların uygulamaları kurulmadan önce güvenlik açısından kontrol etmelerine olanak tanır. Bu **doğrulama süreci**, kullanıcıları potansiyel olarak zararlı uygulamalar konusunda uyarabilir veya özellikle kötü niyetli olanların kurulumunu engelleyebilir, kullanıcı güvenliğini artırır.

### **Mobil Cihaz Yönetimi (MDM)**

- **MDM çözümleri**, mobil cihazlar için **denetim ve güvenlik** sağlar ve **Cihaz Yönetimi API'si** aracılığıyla gerektirir. Mobil cihazların etkili bir şekilde yönetilmesi ve güvence altına alınması için bir Android uygulamasının kurulmasını zorunlu kılar. Temel fonksiyonlar arasında **şifre politikalarının zorunlu kılınması**, **depolama şifrelemesinin zorunlu kılınması** ve **uzaktan veri silmeye izin verilmesi** bulunur, mobil cihazlar üzerinde kapsamlı kontrol ve güvenlik sağlar.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**Try Hard Güvenlik Grubu**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI'na**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
