# Grundlagen von Android-Anwendungen

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen** oder **HackTricks als PDF herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositorys einreichen.

</details>

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Android-Sicherheitsmodell

**Es gibt zwei Ebenen:**

* Das **Betriebssystem**, das installierte Anwendungen voneinander isoliert.
* Die **Anwendung selbst**, die Entwicklern erm√∂glicht, **bestimmte Funktionalit√§ten freizulegen** und Anwendungsf√§higkeiten zu konfigurieren.

### UID-Trennung

**Jede Anwendung wird eine spezifische Benutzer-ID zugewiesen**. Dies geschieht w√§hrend der Installation der App, damit **die App nur mit Dateien interagieren kann, die ihrer Benutzer-ID geh√∂ren oder gemeinsam genutzte** Dateien. Daher k√∂nnen nur die App selbst, bestimmte Komponenten des Betriebssystems und der Root-Benutzer auf die Daten der Apps zugreifen.

### UID-Sharing

**Zwei Anwendungen k√∂nnen so konfiguriert werden, dass sie dieselbe UID verwenden**. Dies kann n√ºtzlich sein, um Informationen zu teilen, aber wenn eine von ihnen kompromittiert ist, werden die Daten beider Anwendungen kompromittiert. Deshalb wird dieses Verhalten **nicht empfohlen**.\
**Um dieselbe UID zu teilen, m√ºssen Anwendungen denselben `android:sharedUserId`-Wert in ihren Manifesten definieren.**

### Sandboxing

Das **Android Application Sandbox** erm√∂glicht es, **jede Anwendung** als **eigenen Prozess unter einer separaten Benutzer-ID** auszuf√ºhren. Jeder Prozess hat seine eigene virtuelle Maschine, sodass der Code einer App isoliert von anderen Apps ausgef√ºhrt wird.\
Ab Android 5.0(L) wird **SELinux** durchgesetzt. Grunds√§tzlich hat SELinux alle Prozessinteraktionen verweigert und dann Richtlinien erstellt, um **nur die erwarteten Interaktionen zwischen ihnen zuzulassen**.

### Berechtigungen

Wenn Sie eine **App installieren und um Berechtigungen bitten**, fordert die App die in den **`uses-permission`**-Elementen in der **AndroidManifest.xml**-Datei konfigurierten Berechtigungen an. Das **uses-permission**-Element gibt den Namen der angeforderten Berechtigung im **name**-**Attribut** an. Es hat auch das **maxSdkVersion**-Attribut, das das Anfordern von Berechtigungen auf Versionen h√∂her als die angegebene stoppt.\
Beachten Sie, dass Android-Anwendungen nicht alle Berechtigungen von Anfang an anfordern m√ºssen, sie k√∂nnen auch **Berechtigungen dynamisch anfordern**, aber alle Berechtigungen m√ºssen im **Manifest deklariert** sein.

Wenn eine App Funktionalit√§ten freigibt, kann sie den **Zugriff nur auf Apps beschr√§nken, die √ºber eine bestimmte Berechtigung verf√ºgen**.\
Ein Berechtigungselement hat drei Attribute:

* Der **Name** der Berechtigung
* Das **permission-group**-Attribut, das das Gruppieren von verwandten Berechtigungen erm√∂glicht.
* Das **Schutzniveau**, das angibt, wie die Berechtigungen gew√§hrt werden. Es gibt vier Typen:
* **Normal**: Wird verwendet, wenn der App **keine bekannten Bedrohungen** drohen. Der Benutzer muss sie **nicht genehmigen**.
* **Gef√§hrlich**: Gibt an, dass die Berechtigung der anfordernden Anwendung einen **erh√∂hten Zugriff** gew√§hrt. **Benutzer werden aufgefordert, sie zu genehmigen**.
* **Signature**: Nur **Apps, die vom selben Zertifikat wie das** exportierende Komponente signiert sind, k√∂nnen Berechtigungen erhalten. Dies ist die st√§rkste Schutzart.
* **SignatureOrSystem**: Nur **Apps, die vom selben Zertifikat wie das** exportierende Komponente signiert sind oder **Apps, die mit Systemzugriff ausgef√ºhrt werden**, k√∂nnen Berechtigungen erhalten.

## Vorinstallierte Anwendungen

Diese Apps befinden sich in der Regel in den Verzeichnissen **`/system/app`** oder **`/system/priv-app`** und einige von ihnen sind **optimiert** (m√∂glicherweise finden Sie nicht einmal die Datei `classes.dex`). Diese Anwendungen sind es wert, √ºberpr√ºft zu werden, da sie manchmal mit zu vielen Berechtigungen (als Root) **ausgef√ºhrt werden**.

* Diejenigen, die mit dem **AOSP** (Android OpenSource Project) **ROM** ausgeliefert werden
* Hinzugef√ºgt vom Ger√§tehersteller
* Hinzugef√ºgt vom Mobilfunkanbieter (wenn bei ihnen gekauft)

## Rooting

Um Root-Zugriff auf ein physisches Android-Ger√§t zu erhalten, m√ºssen Sie in der Regel 1 oder 2 **Schwachstellen ausnutzen**, die normalerweise **spezifisch** f√ºr das **Ger√§t** und die **Version** sind.\
Sobald der Exploit funktioniert hat, wird normalerweise das Linux `su`-Bin√§r in einen vom Benutzer festgelegten Pfad wie `/system/xbin` kopiert.

Sobald das su-Bin√§r konfiguriert ist, wird eine andere Android-App verwendet, um mit dem `su`-Bin√§r zu interagieren und **Anfragen f√ºr Root-Zugriff zu verarbeiten** wie **Superuser** und **SuperSU** (erh√§ltlich im Google Play Store).

{% hint style="danger" %}
Beachten Sie, dass der Rooting-Prozess sehr gef√§hrlich ist und das Ger√§t schwer besch√§digen kann.
{% endhint %}

### ROMs

Es ist m√∂glich, das Betriebssystem zu ersetzen, indem Sie eine benutzerdefinierte Firmware installieren. Dadurch ist es m√∂glich, die N√ºtzlichkeit eines alten Ger√§ts zu erweitern, Softwarebeschr√§nkungen zu umgehen oder Zugriff auf den neuesten Android-Code zu erhalten.\
**OmniROM** und **LineageOS** sind zwei der beliebtesten Firmware-Versionen.

Beachten Sie, dass **nicht immer erforderlich ist, das Ger√§t zu rooten**, um eine benutzerdefinierte Firmware zu installieren. **Einige Hersteller erlauben** das Entsperren ihrer Bootloader auf dokumentierte und sichere Weise.

### Auswirkungen

Sobald ein Ger√§t gerootet ist, k√∂nnte jede App Zugriff als Root anfordern. Wenn eine b√∂sartige Anwendung dies erh√§lt, kann sie auf fast alles zugreifen und das Telefon besch√§digen.

## Grundlagen von Android-Anwendungen <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Das Format von Android-Anwendungen wird als _APK-Dateiformat_ bezeichnet. Es handelt sich im Wesentlichen um eine **ZIP-Datei** (durch Umbenennen der Dateierweiterung in .zip k√∂nnen die Inhalte extrahiert und angezeigt werden).
- APK-Inhalte (nicht ersch√∂pfend)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: enth√§lt vorab kompilierte Ressourcen, wie bin√§re XML.
- res/xml/files\_paths.xml
- META-INF/
- Hier befindet sich das Zertifikat!
- **classes.dex**
- Enth√§lt Dalvik-Bytecode, der den standardm√§√üig ausgef√ºhrten kompilierten Java- (oder Kotlin-)Code der Anwendung darstellt.
- lib/
- Enth√§lt native Bibliotheken, aufgeteilt nach CPU-Architektur in Unterverzeichnissen.
- `armeabi`: Code f√ºr ARM-basierte Prozessoren
- `armeabi-v7a`: Code f√ºr ARMv7 und h√∂here Prozessoren
- `x86`: Code f√ºr X86-Prozessoren
- `mips`: Code nur f√ºr MIPS-Prozessoren
- assets/
- Speichert verschiedene Dateien, die von der App ben√∂tigt werden, m√∂glicherweise einschlie√ülich zus√§tzlicher nativer Bibliotheken oder DEX-Dateien, die manchmal von Malware-Autoren verwendet werden, um zus√§tzlichen Code zu verbergen.
- res/
- Enth√§lt Ressourcen, die nicht in resources.arsc kompiliert sind.
### **Dalvik & Smali**

In der Android-Entwicklung wird **Java oder Kotlin** zur Erstellung von Apps verwendet. Anstatt wie bei Desktop-Apps den JVM zu verwenden, kompiliert Android diesen Code in **Dalvik Executable (DEX) Bytecode**. Fr√ºher verarbeitete die Dalvik Virtual Machine diesen Bytecode, aber jetzt √ºbernimmt in neueren Android-Versionen die Android-Laufzeitumgebung (ART).

F√ºr Reverse Engineering wird **Smali** entscheidend. Es ist die menschenlesbare Version des DEX-Bytecodes und fungiert wie eine Assemblersprache, indem es Quellcode in Bytecode-Anweisungen √ºbersetzt. Smali und baksmali beziehen sich in diesem Kontext auf die Assemblierungs- und Disassemblierungstools.

## Intents

Intents sind das Hauptmittel, mit dem Android-Apps zwischen ihren Komponenten oder mit anderen Apps kommunizieren. Diese Nachrichtenobjekte k√∂nnen auch Daten zwischen Apps oder Komponenten √ºbertragen, √§hnlich wie GET/POST-Anfragen bei HTTP-Kommunikationen verwendet werden.

Ein Intent ist also im Grunde genommen eine **Nachricht, die zwischen Komponenten √ºbermittelt wird**. Intents **k√∂nnen an bestimmte Komponenten oder Apps gerichtet sein**, **oder ohne spezifischen Empf√§nger gesendet werden**.\
Um es einfach auszudr√ºcken, kann ein Intent verwendet werden:

* Um eine Aktivit√§t zu starten, die typischerweise eine Benutzeroberfl√§che f√ºr eine App √∂ffnet
* Als Broadcasts, um das System und Apps √ºber √Ñnderungen zu informieren
* Um einen Hintergrunddienst zu starten, zu stoppen und mit ihm zu kommunizieren
* Um Daten √ºber ContentProvider abzurufen
* Als R√ºckrufe, um Ereignisse zu behandeln

Wenn anf√§llig, **k√∂nnen Intents f√ºr verschiedene Angriffe verwendet werden**.

### Intent-Filter

**Intent-Filter** definieren **wie eine Aktivit√§t, ein Dienst oder ein Broadcast-Empf√§nger mit verschiedenen Arten von Intents interagieren kann**. Im Wesentlichen beschreiben sie die F√§higkeiten dieser Komponenten, wie z.B. welche Aktionen sie ausf√ºhren k√∂nnen oder welche Arten von Broadcasts sie verarbeiten k√∂nnen. Der prim√§re Ort, um diese Filter zu deklarieren, ist in der **AndroidManifest.xml-Datei**, obwohl es auch m√∂glich ist, sie f√ºr Broadcast-Empf√§nger zu codieren.

Intent-Filter bestehen aus Kategorien, Aktionen und Datenfiltern, wobei die M√∂glichkeit besteht, zus√§tzliche Metadaten einzuschlie√üen. Diese Konfiguration erm√∂glicht es Komponenten, spezifische Intents zu verarbeiten, die den deklarierten Kriterien entsprechen.

Ein entscheidender Aspekt von Android-Komponenten (Aktivit√§ten/Dienste/Content Provider/Broadcast-Empf√§nger) ist ihre Sichtbarkeit oder **√∂ffentlicher Status**. Eine Komponente wird als √∂ffentlich betrachtet und kann mit anderen Apps interagieren, wenn sie mit einem Wert von **`true`** als **`exportiert`** markiert ist oder wenn f√ºr sie ein Intent-Filter im Manifest deklariert ist. Es gibt jedoch eine M√∂glichkeit f√ºr Entwickler, diese Komponenten explizit privat zu halten, um sicherzustellen, dass sie nicht unbeabsichtigt mit anderen Apps interagieren. Dies wird erreicht, indem das Attribut **`exportiert`** in ihren Manifestdefinitionen auf **`false`** gesetzt wird.

Dar√ºber hinaus haben Entwickler die M√∂glichkeit, den Zugriff auf diese Komponenten weiter abzusichern, indem sie spezifische Berechtigungen verlangen. Das Attribut **`permission`** kann festgelegt werden, um durchzusetzen, dass nur Apps mit der festgelegten Berechtigung auf die Komponente zugreifen k√∂nnen, was eine zus√§tzliche Sicherheitsebene und Kontrolle dar√ºber bietet, wer mit ihr interagieren kann.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Implizite Intents

Intents werden programmgesteuert mithilfe eines Intent-Konstruktors erstellt:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
Die **Aktion** des zuvor deklarierten Intents ist **ACTION\_SEND** und das **Extra** ist eine mailto-**Uri** (das Extra ist die zus√§tzliche Information, die der Intent erwartet).

Dieser Intent sollte im Manifest wie im folgenden Beispiel deklariert werden:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Ein Intent-Filter muss die **Aktion**, **Daten** und **Kategorie** √ºbereinstimmen, um eine Nachricht zu empfangen.

Der "Intent-Aufl√∂sungsprozess" bestimmt, welche App jede Nachricht erhalten soll. Dieser Prozess ber√ºcksichtigt das **Priorit√§tsattribut**, das in der **Intent-Filter-Deklaration** festgelegt werden kann, und **die mit der h√∂heren Priorit√§t wird ausgew√§hlt**. Diese Priorit√§t kann zwischen -1000 und 1000 festgelegt werden, und Anwendungen k√∂nnen den Wert `SYSTEM_HIGH_PRIORITY` verwenden. Bei einem **Konflikt** erscheint ein "Auswahlfenster", damit der **Benutzer entscheiden kann**.

### Explizite Intents

Ein expliziter Intent gibt den Klassennamen an, den er anvisiert:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
In anderen Anwendungen k√∂nnen Sie auf das zuvor deklarierte Intent zugreifen, indem Sie Folgendes verwenden:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Ausstehende Intents

Diese erm√∂glichen es anderen Anwendungen, **im Namen Ihrer Anwendung Aktionen auszuf√ºhren**, unter Verwendung der Identit√§t und Berechtigungen Ihrer App. Beim Erstellen eines ausstehenden Intents sollte **ein Intent und die auszuf√ºhrende Aktion angegeben werden**. Wenn der **deklarierte Intent nicht explizit ist** (nicht angibt, welcher Intent ihn aufrufen kann), k√∂nnte eine **b√∂sartige Anwendung die deklarierte Aktion** im Namen der Opfer-App ausf√ºhren. Dar√ºber hinaus, **wenn keine Aktion angegeben ist**, kann die b√∂sartige App **beliebige Aktionen im Namen des Opfers** ausf√ºhren.

### Broadcast-Intents

Im Gegensatz zu den vorherigen Intents, die nur von einer App empfangen werden, k√∂nnen Broadcast-Intents **von mehreren Apps empfangen werden**. Ab API-Version 14 ist es jedoch **m√∂glich, die App anzugeben, die die Nachricht empfangen soll**, indem Intent.setPackage verwendet wird.

Alternativ ist es auch m√∂glich, **eine Berechtigung beim Senden des Broadcasts anzugeben**. Die empfangende App muss √ºber diese Berechtigung verf√ºgen.

Es gibt **zwei Arten** von Broadcasts: **Normal** (asynchron) und **Geordnet** (synchron). Die **Reihenfolge** basiert auf der **konfigurierten Priorit√§t innerhalb des Empf√§ngerelements**. **Jede App kann den Broadcast verarbeiten, weiterleiten oder verwerfen**.

Es ist m√∂glich, einen **Broadcast** mithilfe der Funktion `sendBroadcast(intent, receiverPermission)` aus der Klasse `Context` zu **senden**.\
Sie k√∂nnten auch die Funktion **`sendBroadcast`** aus dem **`LocalBroadCastManager`** verwenden, um sicherzustellen, dass die **Nachricht die App nie verl√§sst**. Dadurch m√ºssen Sie nicht einmal einen Empf√§nger exportieren.

### Sticky Broadcasts

Diese Art von Broadcasts **k√∂nnen lange nach dem Senden abgerufen werden**.\
Diese wurden in der API-Ebene 21 veraltet und es wird empfohlen, **sie nicht zu verwenden**.\
**Sie erm√∂glichen es jeder Anwendung, die Daten abzufangen, aber auch zu √§ndern**.

Wenn Sie Funktionen finden, die das Wort "sticky" enthalten, wie **`sendStickyBroadcast`** oder **`sendStickyBroadcastAsUser`**, **√ºberpr√ºfen Sie die Auswirkungen und versuchen Sie, sie zu entfernen**.

## Deep Links / URL-Schemas

In Android-Anwendungen werden **Deep Links** verwendet, um eine Aktion (Intent) direkt √ºber eine URL zu initiieren. Dies geschieht durch Deklarieren eines spezifischen **URL-Schemas** innerhalb einer Aktivit√§t. Wenn ein Android-Ger√§t versucht, **auf eine URL mit diesem Schema zuzugreifen**, wird die angegebene Aktivit√§t innerhalb der Anwendung gestartet.

Das Schema muss in der **`AndroidManifest.xml`**-Datei deklariert werden:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Die Schema aus dem vorherigen Beispiel ist `exampleapp://` (beachten Sie auch die **`Kategorie BROWSABLE`**)

Dann k√∂nnen Sie im Datenfeld den **Host** und **Pfad** angeben:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Um darauf von einem Web aus zuzugreifen, ist es m√∂glich, einen Link wie folgt festzulegen:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Um den **Code zu finden, der in der App ausgef√ºhrt wird**, gehen Sie zur Aktivit√§t, die durch den Deeplink aufgerufen wird, und suchen Sie die Funktion **`onNewIntent`**.

Erfahren Sie, wie Sie [Deeplinks aufrufen, ohne HTML-Seiten zu verwenden](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

Die **Android Interface Definition Language (AIDL)** ist darauf ausgelegt, die Kommunikation zwischen Client und Service in Android-Anwendungen durch **Interprozesskommunikation** (IPC) zu erleichtern. Da der direkte Zugriff auf den Speicher eines anderen Prozesses auf Android nicht zul√§ssig ist, vereinfacht AIDL den Prozess, indem Objekte in ein vom Betriebssystem verstandenes Format umgewandelt werden, wodurch die Kommunikation zwischen verschiedenen Prozessen erleichtert wird.

### Schl√ºsselkonzepte

- **Gebundene Dienste**: Diese Dienste nutzen AIDL f√ºr IPC, erm√∂glichen es Aktivit√§ten oder Komponenten, sich an einen Dienst zu binden, Anfragen zu stellen und Antworten zu erhalten. Die Methode `onBind` in der Klasse des Dienstes ist entscheidend f√ºr die Initiierung der Interaktion und markiert sie als einen wichtigen Bereich f√ºr Sicherheits√ºberpr√ºfungen auf der Suche nach Schwachstellen.

- **Messenger**: Als gebundener Dienst erleichtert Messenger die IPC mit dem Schwerpunkt auf der Verarbeitung von Daten durch die Methode `onBind`. Es ist wichtig, diese Methode genau auf unsichere Datenverarbeitung oder die Ausf√ºhrung sensibler Funktionen zu √ºberpr√ºfen.

- **Binder**: Obwohl die direkte Verwendung der Binder-Klasse aufgrund der Abstraktion von AIDL weniger h√§ufig ist, ist es n√ºtzlich zu verstehen, dass Binder als Kernel-Level-Treiber fungiert, der den Datentransfer zwischen den Speicherbereichen verschiedener Prozesse erleichtert. Zur weiteren Veranschaulichung steht ein Ressource unter [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8) zur Verf√ºgung.

## Komponenten

Diese umfassen: **Aktivit√§ten, Dienste, Broadcast-Empf√§nger und Provider.**

### Startaktivit√§t und andere Aktivit√§ten

In Android-Apps sind **Aktivit√§ten** wie Bildschirme, die verschiedene Teile der Benutzeroberfl√§che der App anzeigen. Eine App kann viele Aktivit√§ten haben, von denen jede dem Benutzer einen einzigartigen Bildschirm pr√§sentiert.

Die **Startaktivit√§t** ist das Haupttor zu einer App, das gestartet wird, wenn Sie auf das Symbol der App tippen. Sie ist in der Manifestdatei der App mit spezifischen MAIN- und LAUNCHER-Intents definiert:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Nicht alle Apps ben√∂tigen eine Startaktivit√§t, insbesondere solche ohne Benutzeroberfl√§che, wie Hintergrunddienste.

Aktivit√§ten k√∂nnen anderen Apps oder Prozessen zur Verf√ºgung gestellt werden, indem sie im Manifest als "exportiert" markiert werden. Diese Einstellung erm√∂glicht es anderen Apps, diese Aktivit√§t zu starten:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Jedoch ist der Zugriff auf eine Aktivit√§t von einer anderen App nicht immer ein Sicherheitsrisiko. Die Sorge entsteht, wenn sensible Daten unsachgem√§√ü geteilt werden, was zu Informationslecks f√ºhren k√∂nnte.

Der Lebenszyklus einer Aktivit√§t **beginnt mit der Methode onCreate**, die die Benutzeroberfl√§che einrichtet und die Aktivit√§t auf die Interaktion mit dem Benutzer vorbereitet.

### Anwendungsteilklasse

In der Android-Entwicklung hat eine App die M√∂glichkeit, eine **Teilklasse** der [Application](https://developer.android.com/reference/android/app/Application)-Klasse zu erstellen, obwohl dies nicht obligatorisch ist. Wenn eine solche Teilklasse definiert ist, wird sie als erste Klasse innerhalb der App instanziiert. Die Methode **`attachBaseContext`**, wenn sie in dieser Teilklasse implementiert ist, wird vor der **`onCreate`**-Methode ausgef√ºhrt. Dieses Setup erm√∂glicht eine fr√ºhe Initialisierung, bevor der Rest der Anwendung startet.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Dienste

[Dienste](https://developer.android.com/guide/components/services) sind **Hintergrundoperationen**, die in der Lage sind, Aufgaben ohne Benutzeroberfl√§che auszuf√ºhren. Diese Aufgaben k√∂nnen auch dann weiterlaufen, wenn Benutzer zu anderen Anwendungen wechseln, wodurch Dienste f√ºr **lang laufende Operationen** unerl√§sslich sind.

Dienste sind vielseitig einsetzbar; sie k√∂nnen auf verschiedene Arten initiiert werden, wobei **Intents** die prim√§re Methode zum Starten sind, da sie als Einstiegspunkt einer Anwendung dienen. Sobald ein Dienst mit der Methode `startService` gestartet wird, wird seine `onStart`-Methode aktiviert und l√§uft weiter, bis die Methode `stopService` explizit aufgerufen wird. Alternativ, wenn die Rolle eines Dienstes von einer aktiven Clientverbindung abh√§ngt, wird die Methode `bindService` verwendet, um den Client mit dem Dienst zu verbinden, wobei die `onBind`-Methode f√ºr den Datenaustausch aktiviert wird.

Eine interessante Anwendung von Diensten umfasst die Wiedergabe von Hintergrundmusik oder das Abrufen von Netzwerkdaten, ohne die Interaktion des Benutzers mit einer App zu beeintr√§chtigen. Dar√ºber hinaus k√∂nnen Dienste f√ºr andere Prozesse auf demselben Ger√§t √ºber **Exportieren** zug√§nglich gemacht werden. Dies ist nicht das Standardverhalten und erfordert eine explizite Konfiguration in der Android-Manifestdatei:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receiver

**Broadcast-Empf√§nger** fungieren als Zuh√∂rer in einem Nachrichtensystem und erm√∂glichen es mehreren Anwendungen, auf dieselben Nachrichten des Systems zu reagieren. Eine App kann einen Empf√§nger auf **zwei Hauptarten** registrieren: √ºber das **Manifest** der App oder **dynamisch** im Code der App √ºber die **`registerReceiver`** API. Im Manifest werden Broadcasts mit Berechtigungen gefiltert, w√§hrend dynamisch registrierte Empf√§nger auch Berechtigungen bei der Registrierung angeben k√∂nnen.

**Intent-Filter** sind in beiden Registrierungsmethoden entscheidend und bestimmen, welche Broadcasts den Empf√§nger ausl√∂sen. Sobald ein passender Broadcast gesendet wird, wird die Methode **`onReceive`** des Empf√§ngers aufgerufen, was der App erm√∂glicht, entsprechend zu reagieren, z. B. das Verhalten anhand einer Benachrichtigung √ºber einen niedrigen Akkustand anzupassen.

Broadcasts k√∂nnen entweder **asynchron** sein und alle Empf√§nger ohne Reihenfolge erreichen oder **synchron**, wobei Empf√§nger den Broadcast basierend auf festgelegten Priorit√§ten erhalten. Es ist jedoch wichtig zu beachten, dass jede App sich selbst priorisieren kann, um einen Broadcast abzufangen.

Um die Funktionalit√§t eines Empf√§ngers zu verstehen, suchen Sie nach der Methode **`onReceive`** innerhalb seiner Klasse. Der Code dieser Methode kann das empfangene Intent manipulieren, was die Notwendigkeit der Datenvalidierung durch Empf√§nger hervorhebt, insbesondere bei **Geordneten Broadcasts**, die das Intent √§ndern oder verwerfen k√∂nnen.

### Content Provider

**Content Provider** sind f√ºr das **Teilen strukturierter Daten** zwischen Apps unerl√§sslich und betonen die Bedeutung der Implementierung von **Berechtigungen**, um die Datensicherheit zu gew√§hrleisten. Sie erm√∂glichen es Apps, auf Daten aus verschiedenen Quellen zuzugreifen, einschlie√ülich Datenbanken, Dateisystemen oder dem Web. Spezifische Berechtigungen wie **`readPermission`** und **`writePermission`** sind entscheidend f√ºr die Kontrolle des Zugriffs. Dar√ºber hinaus kann tempor√§rer Zugriff durch Einstellungen wie **`grantUriPermission`** im Manifest der App gew√§hrt werden, wobei Attribute wie `path`, `pathPrefix` und `pathPattern` f√ºr eine detaillierte Zugriffskontrolle genutzt werden.

Die Eingabevalidierung ist entscheidend, um Sicherheitsl√ºcken wie SQL-Injektionen zu verhindern. Content Provider unterst√ºtzen grundlegende Operationen: `insert()`, `update()`, `delete()` und `query()`, die die Datenmanipulation und den Austausch zwischen Anwendungen erleichtern.

**FileProvider**, ein spezialisierter Content Provider, konzentriert sich auf das sichere Teilen von Dateien. Er wird im Manifest der App mit spezifischen Attributen definiert, um den Zugriff auf Ordner zu kontrollieren, die durch `android:exported` und `android:resource` auf Ordnerkonfigurationen verweisen. Es wird empfohlen, Vorsicht walten zu lassen, wenn Verzeichnisse geteilt werden, um eine versehentliche Offenlegung sensibler Daten zu vermeiden.

Beispielhafte Manifestdeklaration f√ºr FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Und ein Beispiel zur Spezifizierung von freigegebenen Ordnern in `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
F√ºr weitere Informationen siehe:
- [Android-Entwickler: Inhaltsanbieter](https://developer.android.com/guide/topics/providers/content-providers)
- [Android-Entwickler: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews sind wie **Mini-Webbrowser** innerhalb von Android-Apps, die Inhalte entweder aus dem Web oder aus lokalen Dateien abrufen. Sie sind √§hnlichen Risiken wie regul√§re Browser ausgesetzt, aber es gibt M√∂glichkeiten, diese Risiken durch spezifische **Einstellungen zu reduzieren**.

Android bietet zwei Hauptarten von WebViews:

- **WebViewClient** eignet sich gut f√ºr grundlegendes HTML, unterst√ºtzt jedoch nicht die JavaScript-Alertfunktion, was sich darauf auswirkt, wie XSS-Angriffe getestet werden k√∂nnen.
- **WebChromeClient** verh√§lt sich mehr wie die vollst√§ndige Chrome-Browsererfahrung.

Ein wichtiger Punkt ist, dass WebView-Browser **keine Cookies mit dem Hauptbrowser des Ger√§ts teilen**.

F√ºr das Laden von Inhalten stehen Methoden wie ````loadUrl````, ````loadData```` und ````loadDataWithBaseURL```` zur Verf√ºgung. Es ist entscheidend sicherzustellen, dass diese URLs oder Dateien **sicher zu verwenden** sind. Sicherheitseinstellungen k√∂nnen √ºber die Klasse ````WebSettings```` verwaltet werden. Beispielsweise kann das Deaktivieren von JavaScript mit ````setJavaScriptEnabled(false)```` XSS-Angriffe verhindern.

Die JavaScript-"Bridge" erm√∂glicht es Java-Objekten, mit JavaScript zu interagieren, wobei Methoden ab Android 4.2 mit ````@JavascriptInterface```` markiert werden m√ºssen, um Sicherheit zu gew√§hrleisten.

Das Zulassen des Zugriffs auf Inhalte (````setAllowContentAccess(true)````) erm√∂glicht es WebViews, auf Inhaltsanbieter zuzugreifen, was ein Risiko darstellen kann, es sei denn, die Inhalts-URLs sind als sicher verifiziert.

Um den Dateizugriff zu kontrollieren:
- Das Deaktivieren des Dateizugriffs (````setAllowFileAccess(false)````) beschr√§nkt den Zugriff auf das Dateisystem, mit Ausnahmen f√ºr bestimmte Ressourcen, um sicherzustellen, dass sie nur f√ºr nicht-sensitive Inhalte verwendet werden.

## Andere App-Komponenten und Mobile Ger√§teverwaltung

### **Digitale Signierung von Anwendungen**

- **Digitale Signierung** ist ein Muss f√ºr Android-Apps, um sicherzustellen, dass sie vor der Installation **authentisch autorisiert** sind. Dieser Prozess verwendet ein Zertifikat zur App-Identifizierung und muss vom Paketmanager des Ger√§ts bei der Installation √ºberpr√ºft werden. Apps k√∂nnen **selbst signiert oder von einer externen Zertifizierungsstelle zertifiziert** sein, um unbefugten Zugriff zu verhindern und sicherzustellen, dass die App w√§hrend der Bereitstellung auf dem Ger√§t unver√§ndert bleibt.

### **App-Verifizierung f√ºr erh√∂hte Sicherheit**

- Ab **Android 4.2** erm√∂glicht eine Funktion namens **Apps √ºberpr√ºfen** Benutzern, Apps vor der Installation auf Sicherheit zu √ºberpr√ºfen. Dieser **Verifizierungsprozess** kann Benutzer vor potenziell sch√§dlichen Apps warnen oder sogar die Installation besonders b√∂sartiger Apps verhindern, um die Sicherheit der Benutzer zu erh√∂hen.

### **Mobile Ger√§teverwaltung (MDM)**

- **MDM-L√∂sungen** bieten **√úberwachung und Sicherheit** f√ºr mobile Ger√§te √ºber die **Device Administration API**. Sie erfordern die Installation einer Android-App, um mobile Ger√§te effektiv zu verwalten und zu sichern. Zu den Hauptfunktionen geh√∂ren die **Durchsetzung von Kennwortrichtlinien**, die **Vorgabe der Speicherungsverschl√ºsselung** und die **Erm√∂glichung des Remote-Datenl√∂schens**, um umfassende Kontrolle und Sicherheit √ºber mobile Ger√§te zu gew√§hrleisten.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys einreichen.

</details>
