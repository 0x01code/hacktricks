# 안드로이드 애플리케이션 기본 사항

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)로부터 AWS 해킹을 처음부터 전문가까지 배우세요</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를 팔로우**하세요.
* **해킹 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 제출하세요.

</details>

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## 안드로이드 보안 모델

**두 가지 레이어가 있습니다:**

* **OS**: 설치된 애플리케이션을 서로 격리시킵니다.
* **애플리케이션 자체**: 개발자가 **특정 기능을 노출**하고 애플리케이션 기능을 구성할 수 있습니다.

### UID 분리

**각 애플리케이션에는 특정 사용자 ID가 할당**됩니다. 이는 앱 설치 중에 수행되어 **앱은 해당 사용자 ID 또는 공유된** 파일에만 상호 작용할 수 있습니다. 따라서 앱 자체, OS의 특정 구성 요소 및 루트 사용자만이 앱 데이터에 액세스할 수 있습니다.

### UID 공유

**두 애플리케이션은 동일한 UID를 사용하도록 구성**할 수 있습니다. 이는 정보를 공유하는 데 유용할 수 있지만 그 중 하나가 손상되면 두 애플리케이션의 데이터가 손상됩니다. 이것이 **이러한 동작이 권장되지 않는 이유**입니다.\
**동일한 UID를 공유하려면 애플리케이션은 매니페스트에서 동일한 `android:sharedUserId` 값을 정의**해야 합니다.

### 샌드박싱

**Android 애플리케이션 샌드박스**는 **각 애플리케이션을** 별도의 **사용자 ID로 별도의 프로세스로 실행**할 수 있게 합니다. 각 프로세스에는 자체 가상 머신이 있어 앱의 코드가 다른 앱과 격리된 상태에서 실행됩니다.\
Android 5.0(L)부터 **SELinux**가 강제됩니다. 기본적으로 SELinux는 모든 프로세스 상호 작용을 거부한 다음 그들 사이의 **예상된 상호 작용만 허용하는 정책을 생성**했습니다.

### 권한

앱을 설치하고 **권한을 요청할 때**, 앱은 **AndroidManifest.xml** 파일의 **`uses-permission`** 요소에 구성된 권한을 요청합니다. **uses-permission** 요소는 요청된 권한의 이름을 **name** **속성** 내에 나타냅니다. 또한 **maxSdkVersion** 속성이 있어 지정된 버전보다 높은 버전에서 권한 요청을 중지합니다.\
Android 애플리케이션은 처음에 모든 권한을 요청할 필요가 없으며 **동적으로 권한을 요청**할 수 있지만 모든 권한은 **매니페스트에 선언**되어야 합니다.

앱이 기능을 노출할 때 **특정 권한이 있는 앱에만 액세스**를 제한할 수 있습니다.\
권한 요소에는 세 가지 속성이 있습니다:

* 권한의 **이름**
* **permission-group** 속성, 관련 권한을 그룹화하는 데 사용됩니다.
* 권한이 부여되는 방식을 나타내는 **protection-level**이 있습니다. 네 가지 유형이 있습니다:
* **Normal**: 앱에 **알려진 위협이 없을 때 사용**됩니다. 사용자가 **승인할 필요가 없습니다**.
* **Dangerous**: 권한이 요청된 애플리케이션에 일부 **상승된 액세스**를 부여함을 나타냅니다. **사용자가 승인을 요청**받습니다.
* **Signature**: **구성 요소를 내보내는** 인증서와 동일한 인증서로 **서명된 앱만 권한을 부여**받을 수 있습니다. 이것은 가장 강력한 보호 유형입니다.
* **SignatureOrSystem**: **구성 요소를 내보내는** 인증서와 동일한 인증서로 **서명된 앱 또는 시스템 수준 액세스로 실행되는 앱만 권한을 부여**받을 수 있습니다

## 사전 설치된 애플리케이션

이러한 앱은 일반적으로 **`/system/app`** 또는 **`/system/priv-app`** 디렉토리에서 찾을 수 있으며 일부는 **최적화**되어 있습니다(`classes.dex` 파일을 찾을 수 없을 수도 있음). 이러한 애플리케이션은 때로는 **루트로 실행되는 권한이 너무 많은** 경우가 있으므로 확인할 가치가 있습니다.

* **AOSP**(Android 오픈소스 프로젝트) **ROM**에 포함된 앱
* **장치 제조업체**가 추가한 앱
* **휴대전화 제공업체**가 추가한 앱(그들로부터 구매한 경우)

## 루팅

물리적 안드로이드 장치에서 루트 액세스를 얻으려면 일반적으로 **장치 및 버전에 특정한 취약점을 이용**해야 합니다.\
일단 취약점이 작동하면 일반적으로 Linux `su` 이진 파일이 사용자의 PATH 환경 변수에 지정된 위치로 복사됩니다(`/system/xbin`과 같은 위치).

su 이진 파일이 구성되면 다른 Android 앱이 `su` 이진 파일과 **루트 액세스 요청을 처리**하는 데 사용됩니다. 이러한 앱에는 **Superuser** 및 **SuperSU**가 포함됩니다(구글 플레이 스토어에서 사용 가능).

{% hint style="danger" %}
루팅 프로세스는 매우 위험하며 장치를 심각하게 손상시킬 수 있습니다
{% endhint %}

### ROM

**커스텀 펌웨어를 설치하여 OS를 대체**할 수 있습니다. 이렇게 하면 오래된 장치의 유용성을 확장하거나 소프트웨어 제한을 우회하거나 최신 Android 코드에 액세스할 수 있습니다.\
**OmniROM** 및 **LineageOS**는 사용할 수 있는 가장 인기 있는 펌웨어 중 두 가지입니다.

장치를 루팅할 필요가 **항상 있는 것은 아니라는 점**을 유의하세요. **일부 제조업체는** 부팅로더의 잠금 해제를 **잘 문서화되고 안전한 방식**으로 허용합니다.

### 영향

장치가 루팅되면 모든 앱이 루트 액세스를 요청할 수 있습니다. 악성 애플리케이션이 액세스를 얻으면 거의 모든 것에 액세스할 수 있으며 전화를 손상시킬 수 있습니다.

## 안드로이드 애플리케이션 기본 사항 <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- 안드로이드 애플리케이션의 형식은 _APK 파일 형식_으로 참조됩니다. 이는 본질적으로 **ZIP 파일**입니다(파일 확장자를 .zip로 변경하면 내용을 추출하고 볼 수 있습니다).
- APK 내용(완전하지 않음)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: 바이너리 XML과 같은 사전 컴파일된 리소스를 포함합니다.
- res/xml/files\_paths.xml
- META-INF/
- 여기에 인증서가 위치합니다!
- **classes.dex**
- 애플리케이션이 기본적으로 실행하는 컴파일된 Java(또는 Kotlin) 코드를 나타내는 Dalvik 바이트 코드를 포함합니다.
- lib/
- CPU 아키텍처별로 하위 디렉터리에 분리된 네이티브 라이브러리를 보관합니다.
- `armeabi`: ARM 기반 프로세서용 코드
- `armeabi-v7a`: ARMv7 및 그 이상 기반 프로세서용 코드
- `x86`: X86 프로세서용 코드
- `mips`: MIPS 프로세서 전용 코드
- assets/
- 앱에서 필요한 기타 파일을 저장하며 때로는 악성 소프트웨어 작성자가 추가 코드를 숨기기 위해 추가 네이티브 라이브러리 또는 DEX 파일을 포함할 수 있습니다.
- res/
- resources.arsc에 컴파일되지 않은 리소스를 포함합니다.
### **Dalvik & Smali**

안드로이드 개발에서 앱을 만들 때는 **Java 또는 Kotlin**을 사용합니다. 데스크톱 앱과 달리 안드로이드는 이 코드를 **Dalvik Executable (DEX) bytecode**로 컴파일합니다. 이전에는 Dalvik 가상 머신이 이 bytecode를 처리했지만 최신 안드로이드 버전에서는 Android Runtime (ART)가 이를 처리합니다.

역공학을 위해 **Smali**가 중요해집니다. 이는 DEX bytecode의 사람이 읽을 수 있는 버전으로, 소스 코드를 bytecode 명령어로 번역하여 어셈블리 언어처럼 작동합니다. 이 맥락에서 Smali와 baksmali는 어셈블리 및 역어셈블리 도구를 가리킵니다.

## Intents

Intents는 안드로이드 앱이 구성 요소 간이나 다른 앱과 통신하는 주요 수단입니다. 이러한 메시지 객체는 앱이나 구성 요소 간에 데이터를 전달할 수도 있으며, 이는 HTTP 통신에서 GET/POST 요청이 사용되는 방식과 유사합니다.

따라서 Intent는 기본적으로 **구성 요소 간에 전달되는 메시지**입니다. Intents는 **특정 구성 요소나 앱에게 직접 전달**될 수 있으며, **특정 수신자 없이 전송**될 수도 있습니다.\
간단히 말해 Intent는 다음과 같이 사용할 수 있습니다:

* 활동을 시작하여 일반적으로 앱의 사용자 인터페이스를 엽니다
* 변경 사항을 시스템 및 앱에 알리기 위한 브로드캐스트로 사용
* 백그라운드 서비스를 시작, 중지 및 통신하기 위해 사용
* ContentProviders를 통해 데이터에 액세스하기 위해 사용
* 이벤트를 처리하기 위한 콜백으로 사용

취약하다면 **Intents는 다양한 공격을 수행하는 데 사용될 수 있습니다**.

### Intent-Filter

**Intent Filters**는 **활동, 서비스 또는 브로드캐스트 수신기가 다양한 유형의 Intents와 상호 작용하는 방식을 정의**합니다. 기본적으로 이러한 구성 요소의 기능을 설명하며, 수행할 수 있는 작업이나 처리할 수 있는 브로드캐스트 유형과 같은 내용을 설명합니다. 이러한 필터를 선언하는 주요 위치는 **AndroidManifest.xml 파일**이지만, 브로드캐스트 수신기의 경우 코드로 작성하는 것도 가능합니다.

Intent Filters는 카테고리, 작업 및 데이터 필터로 구성되어 있으며 추가 메타데이터를 포함할 수 있습니다. 이 설정을 통해 선언된 기준과 일치하는 특정 Intents를 처리할 수 있습니다.

안드로이드 구성 요소(액티비티/서비스/콘텐츠 제공자/브로드캐스트 수신기)의 중요한 측면은 그들의 가시성 또는 **공개 상태**입니다. 구성 요소가 **`true`** 값을 가진 **`exported`**로 내보내어진 경우나 매니페스트에 대한 Intent Filter가 선언된 경우에만 다른 앱과 상호 작용할 수 있습니다. 그러나 개발자가 이러한 구성 요소를 의도치 않게 다른 앱과 상호 작용하지 않도록 명시적으로 비공개로 유지할 수 있는 방법이 있습니다. 이는 매니페스트 정의에서 **`exported`** 속성을 **`false`**로 설정하여 달성할 수 있습니다.

또한, 개발자는 이러한 구성 요소에 대한 액세스를 더욱 안전하게 보호하기 위해 특정 권한을 요구할 수 있습니다. **`permission`** 속성을 설정하여 지정된 권한을 가진 앱만 해당 구성 요소에 액세스할 수 있도록 강제할 수 있으며, 이를 통해 누가 상호 작용할 수 있는지에 대한 추가적인 보안 및 제어 수단을 추가할 수 있습니다.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### 암시적 인텐트

인텐트는 Intent 생성자를 사용하여 프로그래밍적으로 생성됩니다:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**Action**으로 이전에 선언된 intent는 **ACTION\_SEND**이고 **Extra**는 mailto **Uri**입니다 (Extra는 intent가 기대하는 추가 정보입니다).

이 intent는 다음 예제와 같이 manifest 안에 선언되어야 합니다:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
인텐트 필터는 메시지를 수신하기 위해 **액션**, **데이터** 및 **카테고리**와 일치해야 합니다.

"인텐트 해결" 프로세스는 각 메시지를 수신해야 하는 앱을 결정합니다. 이 프로세스는 **우선순위 속성**을 고려합니다. 이 속성은 **인텐트 필터 선언**에서 설정할 수 있으며, **더 높은 우선순위를 가진 것이 선택**됩니다. 이 우선순위는 -1000에서 1000 사이로 설정할 수 있으며 애플리케이션은 `SYSTEM_HIGH_PRIORITY` 값을 사용할 수 있습니다. **충돌**이 발생하면 "선택기" 창이 나타나므로 **사용자가 결정**할 수 있습니다.

### 명시적 인텐트

명시적 인텐트는 대상 클래스 이름을 지정합니다:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
다른 애플리케이션에서 이전에 선언된 intent에 액세스하려면 다음을 사용할 수 있습니다:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### 보류 중인 인텐트

이를 통해 다른 애플리케이션이 **귀하의 애플리케이션 대신 작업을 수행**할 수 있습니다. 보류 중인 인텐트를 구성할 때는 **인텐트와 수행할 작업을 지정**해야 합니다. **선언된 인텐트가 명시적이지 않은 경우** (어떤 인텐트가 호출할 수 있는지 선언하지 않은 경우) **악성 애플리케이션이 피해 앱 대신 선언된 작업을 수행**할 수 있습니다. 또한 **작업이 지정되지 않은 경우**, 악성 앱은 **피해자를 대신하여 모든 작업을 수행**할 수 있습니다.

### 브로드캐스트 인텐트

이전 인텐트와 달리 브로드캐스트 인텐트는 **여러 앱에서 수신**할 수 있습니다. 그러나 API 버전 14부터는 Intent.set Package를 사용하여 **메시지를 수신해야 하는 앱을 지정**할 수 있습니다.

또는 브로드캐스트를 **보낼 때 권한을 지정**할 수도 있습니다. 수신 앱은 해당 권한이 있어야 합니다.

브로드캐스트에는 **두 가지 유형**이 있습니다: **일반** (비동기) 및 **순서가 지정된** (동기). **순서**는 **수신기 내에서 구성된 우선순위에 따라** 결정됩니다. **각 앱은 브로드캐스트를 처리, 중계 또는 삭제**할 수 있습니다.

`Context` 클래스에서 `sendBroadcast(intent, receiverPermission)` 함수를 사용하여 **브로드캐스트를 보낼 수** 있습니다.\
또한 **`LocalBroadCastManager`**에서 **`sendBroadcast`** 함수를 사용하여 **메시지가 앱을 벗어나지 않도록** 할 수 있습니다. 이를 사용하면 수신기 구성 요소를 내보내지 않아도 됩니다.

### 스티키 브로드캐스트

이 유형의 브로드캐스트는 **보낸 후 오랫동안 액세스할 수 있습니다**.\
이러한 것들은 API 레벨 21에서 사용 중단되었으며 **사용하지 않는 것이 권장**됩니다.\
**어떤 애플리케이션이 데이터를 가로채고 수정할 수 있게 합니다.**

**`sendStickyBroadcast`** 또는 **`sendStickyBroadcastAsUser`**와 같이 "sticky"라는 단어를 포함하는 함수를 찾으면 **영향을 확인하고 제거하려고 시도**하십시오.

## 딥 링크 / URL 스키마

Android 애플리케이션에서 **딥 링크**는 URL을 통해 직접 작업 (인텐트)을 시작하는 데 사용됩니다. 이는 활동 내에서 특정 **URL 스키마**를 선언함으로써 수행됩니다. Android 기기가 **이러한 스키마를 포함하는 URL에 액세스**하려고 할 때, 애플리케이션 내의 지정된 활동이 시작됩니다.

스키마는 **`AndroidManifest.xml`** 파일에 선언되어야 합니다.
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
이전 예제의 scheme은 `exampleapp://`입니다 (또한 **`category BROWSABLE`**도 참고하세요)

그런 다음 데이터 필드에서 **host**와 **path**를 지정할 수 있습니다:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
웹에서 액세스하려면 다음과 같이 링크를 설정할 수 있습니다:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
**앱에서 실행될 코드를 찾으려면** 딥링크로 호출된 액티비티로 이동하여 **`onNewIntent`** 함수를 검색하십시오.

[HTML 페이지를 사용하지 않고 딥링크를 호출하는 방법](./#exploiting-schemes-deep-links)을 배우세요.

## AIDL - Android Interface Definition Language

**Android Interface Definition Language (AIDL)**은 Android 애플리케이션에서 **프로세스 간 통신** (IPC)을 통해 클라이언트와 서비스 간 통신을 용이하게 하는 데 사용됩니다. Android에서 다른 프로세스의 메모리에 직접 액세스하는 것은 허용되지 않기 때문에 AIDL은 객체를 운영 체제가 이해하는 형식으로 마샬링하여 서로 다른 프로세스 간 통신을 용이하게 합니다.

### 주요 개념

- **바운드 서비스**: 이러한 서비스는 IPC를 위해 AIDL을 활용하여 활동이나 구성 요소가 서비스에 바인딩되어 요청을 수행하고 응답을 받을 수 있게 합니다. 서비스 클래스의 `onBind` 메서드는 상호 작용을 시작하는 데 중요하며 취약점을 찾기 위한 보안 검토의 중요한 영역으로 표시됩니다.

- **Messenger**: 바운드 서비스로 작동하는 Messenger는 `onBind` 메서드를 통해 데이터 처리에 중점을 둔 IPC를 용이하게 합니다. 이 메서드를 신중하게 검사하여 안전하지 않은 데이터 처리나 민감한 기능의 실행 여부를 확인하는 것이 중요합니다.

- **Binder**: AIDL의 추상화로 인해 Binder 클래스의 직접적인 사용은 덜 흔하지만, Binder가 서로 다른 프로세스의 메모리 공간 간 데이터 전송을 용이하게 하는 커널 수준 드라이버로 작동한다는 점을 이해하는 것이 유익합니다. 자세한 내용은 [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)에서 확인할 수 있습니다.

## 구성 요소

이는 **액티비티, 서비스, 브로드캐스트 수신자 및 프로바이더**를 포함합니다.

### 런처 액티비티 및 기타 액티비티

Android 앱에서 **액티비티**는 화면처럼 작동하여 앱의 사용자 인터페이스의 다른 부분을 보여줍니다. 앱은 각각이 사용자에게 고유한 화면을 제공하는 많은 액티비티를 가질 수 있습니다.

**런처 액티비티**는 앱의 주요 게이트웨이로, 앱 아이콘을 탭할 때 시작됩니다. 이는 앱의 매니페스트 파일에 MAIN 및 LAUNCHER 인텐트로 정의됩니다.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
모든 앱이 런처 액티비티를 필요로 하는 것은 아닙니다, 특히 사용자 인터페이스가 없는 백그라운드 서비스와 같은 경우입니다.

액티비티는 매니페스트에서 "exported"로 표시하여 다른 앱이나 프로세스에서 사용할 수 있도록 만들 수 있습니다. 이 설정을 통해 다른 앱이 이 액티비티를 시작할 수 있습니다:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
그러나 다른 앱에서 활동에 액세스하는 것이 항상 보안 위험은 아닙니다. 민감한 데이터가 부적절하게 공유되는 경우에는 정보 누출로 이어질 수 있습니다.

활동의 수명주기는 **onCreate 메서드로 시작**되며 UI를 설정하고 사용자와 상호 작용할 수 있도록 활동을 준비합니다.

### 애플리케이션 서브클래스

Android 개발에서 앱은 [Application](https://developer.android.com/reference/android/app/Application) 클래스의 **서브클래스**를 만들 수 있지만 필수는 아닙니다. 이러한 서브클래스가 정의된 경우 해당 서브클래스가 앱 내에서 가장 먼저 인스턴스화됩니다. 이 서브클래스에서 구현된 **`attachBaseContext`** 메서드는 **`onCreate`** 메서드보다 먼저 실행됩니다. 이 설정을 통해 애플리케이션이 시작되기 전에 초기화를 빠르게 수행할 수 있습니다.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### 서비스

[서비스](https://developer.android.com/guide/components/services)는 사용자 인터페이스 없이 작업을 실행할 수 있는 **백그라운드 작업자**입니다. 이러한 작업은 사용자가 다른 애플리케이션으로 전환해도 계속 실행될 수 있어서 **장기 실행 작업**에 중요합니다.

서비스는 다양하게 활용될 수 있으며, **인텐트**가 애플리케이션의 진입점으로 사용되는 주요한 방법으로 서비스를 시작할 수 있습니다. `startService` 메소드를 사용하여 서비스를 시작하면 `onStart` 메소드가 실행되어 `stopService` 메소드가 명시적으로 호출될 때까지 계속 실행됩니다. 또한, 서비스의 역할이 활성 클라이언트 연결에 의존하는 경우, 클라이언트를 서비스에 바인딩하기 위해 `bindService` 메소드가 사용되며 데이터 전달을 위해 `onBind` 메소드가 활용됩니다.

서비스의 흥미로운 응용 사례로는 앱과 상호 작용을 방해하지 않고 백그라운드에서 음악 재생이나 네트워크 데이터 가져오기가 있습니다. 또한, 서비스는 **내보내기**를 통해 동일한 장치의 다른 프로세스에서 접근할 수 있습니다. 이는 기본 동작이 아니며 Android Manifest 파일에서 명시적으로 구성해야 합니다:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### 브로드캐스트 수신기

**브로드캐스트 수신기**는 메시징 시스템에서 청취자 역할을 하며, 여러 애플리케이션이 시스템에서 오는 동일한 메시지에 응답할 수 있게 합니다. 앱은 **두 가지 주요 방법**으로 **수신기를 등록**할 수 있습니다: 앱의 **Manifest**를 통해 또는 앱의 코드 내에서 **`registerReceiver`** API를 통해 **동적으로** 등록합니다. Manifest에서는 브로드캐스트가 권한으로 필터링되며, 동적으로 등록된 수신기는 등록 시 권한을 지정할 수도 있습니다.

**인텐트 필터**는 등록 방법 모두에서 중요하며, 어떤 브로드캐스트가 수신기를 트리거하는지를 결정합니다. 일치하는 브로드캐스트가 전송되면 수신기의 **`onReceive`** 메소드가 호출되어 앱이 적절히 반응할 수 있게 되며, 예를 들어 배터리 부족 경고에 대한 반응을 조정할 수 있습니다.

브로드캐스트는 **비동기적**일 수도 있고, 순서 없이 모든 수신기에 도달할 수도 있으며, **동기적**일 수도 있어서 수신기가 우선순위에 따라 브로드캐스트를 받을 수 있습니다. 그러나 잠재적인 보안 위험을 인지하는 것이 중요합니다. 왜냐하면 어떤 앱이든 자신을 우선시하여 브로드캐스트를 가로챌 수 있기 때문입니다.

수신기의 기능을 이해하려면 해당 클래스 내의 **`onReceive`** 메소드를 찾아보세요. 이 메소드의 코드는 받은 인텐트를 조작할 수 있으며, 특히 **순서가 정해진 브로드캐스트**에서는 데이터 유효성 검사가 필요하다는 점을 강조합니다. 이는 인텐트를 수정하거나 삭제할 수 있기 때문입니다.

### 콘텐츠 제공자

**콘텐츠 제공자**는 앱 간에 **구조화된 데이터를 공유**하는 데 필수적이며, 데이터 보안을 보장하기 위해 **권한을 구현**하는 중요성을 강조합니다. 이를 통해 앱은 데이터베이스, 파일 시스템 또는 웹을 포함한 다양한 소스에서 데이터에 액세스할 수 있습니다. **`readPermission`** 및 **`writePermission`**과 같은 특정 권한은 액세스를 제어하는 데 중요합니다. 또한 앱의 Manifest에서 **`grantUriPermission`** 설정을 통해 일시적인 액세스를 부여할 수 있으며, 자세한 액세스 제어를 위해 `path`, `pathPrefix`, `pathPattern`과 같은 속성을 활용할 수 있습니다.

SQL 인젝션과 같은 취약점을 방지하기 위해 입력 유효성 검사가 중요합니다. 콘텐츠 제공자는 `insert()`, `update()`, `delete()`, `query()`와 같은 기본 작업을 지원하여 데이터 조작 및 애플리케이션 간 데이터 공유를 용이하게 합니다.

**FileProvider**는 안전하게 파일을 공유하는 데 중점을 둔 특수한 콘텐츠 제공자입니다. 특정 속성을 사용하여 폴더 액세스를 제어하는 앱의 Manifest에 정의되며, `android:exported` 및 `android:resource`로 폴더 구성에 대한 액세스를 제어합니다. 민감한 데이터 노출을 피하기 위해 디렉토리를 공유할 때 주의가 필요합니다.

FileProvider에 대한 예제 Manifest 선언:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
그리고 `filepaths.xml`에서 공유 폴더를 지정하는 예시:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
- 추가 정보는 다음을 확인하십시오:
  - [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
  - [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews는 Android 앱 내부에 있는 **미니 웹 브라우저**와 같으며, 웹이나 로컬 파일에서 콘텐츠를 불러옵니다. 일반 브라우저와 유사한 위험에 직면하지만, 특정 **설정**을 통해 이러한 위험을 **줄일 수 있는 방법**이 있습니다.

Android는 두 가지 주요 WebView 유형을 제공합니다:

- **WebViewClient**는 기본 HTML에 적합하지만 JavaScript 경고 기능을 지원하지 않아 XSS 공격을 테스트하는 방법에 영향을 줍니다.
- **WebChromeClient**는 전체 Chrome 브라우저 경험과 유사하게 작동합니다.

중요한 점은 WebView 브라우저가 기기의 주요 브라우저와 **쿠키를 공유하지 않는다**는 것입니다.

콘텐츠를 로드하기 위해 ````loadUrl````, ````loadData````, ````loadDataWithBaseURL````과 같은 메서드를 사용할 수 있습니다. 이러한 URL이나 파일이 **안전하게 사용**되도록 보장하는 것이 중요합니다. 보안 설정은 ````WebSettings```` 클래스를 통해 관리할 수 있습니다. 예를 들어, ````setJavaScriptEnabled(false)````로 JavaScript를 비활성화하면 XSS 공격을 방지할 수 있습니다.

JavaScript "Bridge"를 통해 Java 객체가 JavaScript와 상호 작용할 수 있으며, Android 4.2 이후 보안을 위해 메서드에 ````@JavascriptInterface````를 표시해야 합니다.

콘텐츠 액세스를 허용하면 (````setAllowContentAccess(true)````), WebViews가 Content Providers에 액세스할 수 있지만, 콘텐츠 URL이 안전하다는 것이 확인되지 않는 한 위험이 될 수 있습니다.

파일 액세스를 제어하려면:
- 파일 액세스 비활성화 (````setAllowFileAccess(false)````)는 파일 시스템에 대한 액세스를 제한하며, 특정 자산에 대한 예외를 허용하여 민감한 콘텐츠에만 사용되도록 보장합니다.

## 기타 앱 구성 요소 및 모바일 장치 관리

### **애플리케이션의 디지털 서명**

- Android 앱에 대한 **디지털 서명**은 **인증된 작성자**임을 보장하기 위해 반드시 필요합니다. 이 프로세스는 앱 식별을 위해 인증서를 사용하며, 설치 시 기기의 패키지 관리자에 의해 확인되어야 합니다. 앱은 **자체 서명 또는 외부 CA에 의해 인증**될 수 있으며, 무단 액세스로부터 보호되고 전달 중에 앱이 변경되지 않도록 보장합니다.

### **향상된 보안을 위한 앱 확인**

- **Android 4.2**부터 **앱 확인**이라는 기능을 통해 사용자는 설치 전에 앱을 안전하게 확인할 수 있습니다. 이 **확인 프로세스**를 통해 사용자는 잠재적으로 해로운 앱에 대해 경고를 받거나 특히 악성 앱의 설치를 방지할 수 있어 사용자 보안을 강화할 수 있습니다.

### **모바일 장치 관리 (MDM)**

- **MDM 솔루션**은 **장치 관리 API**를 통해 모바일 장치에 대한 **감독 및 보안**을 제공합니다. 이를 위해 Android 앱을 설치하여 모바일 장치를 효과적으로 관리하고 보호해야 합니다. 주요 기능으로는 **암호 정책 강제 적용**, **저장소 암호화 강제 적용**, **원격 데이터 삭제 허용** 등이 있어 모바일 장치에 대한 포괄적인 제어와 보안을 보장합니다.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**트라이 하드 보안 그룹**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)를 통해 제로부터 히어로까지 AWS 해킹 배우기</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 PDF로 HackTricks를 다운로드하길 원한다면** [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나** Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 팔로우하세요**.**
* **해킹 트릭을 공유하려면 PR을 제출하여** [**HackTricks**](https://github.com/carlospolop/hacktricks) **및** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 저장소에 기여하세요.**

</details>
