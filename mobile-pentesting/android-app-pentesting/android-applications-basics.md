# Grundlagen von Android-Anwendungen

<details>

<summary><strong>Lernen Sie das Hacken von AWS von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Finden Sie die wichtigsten Sicherheitsl√ºcken, damit Sie sie schneller beheben k√∂nnen. Intruder verfolgt Ihre Angriffsfl√§che, f√ºhrt proaktive Bedrohungsscans durch und findet Probleme in Ihrer gesamten Technologie-Stack, von APIs √ºber Webanwendungen bis hin zu Cloud-Systemen. [**Probieren Sie es noch heute kostenlos aus**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks).

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Android-Sicherheitsmodell

**Es gibt zwei Ebenen:**

* Das **Betriebssystem**, das installierte Anwendungen voneinander isoliert.
* Die **Anwendung selbst**, die Entwicklern erm√∂glicht, bestimmte Funktionen freizugeben und Anwendungsfunktionen zu konfigurieren.

### UID-Trennung

**Jede Anwendung erh√§lt eine bestimmte Benutzer-ID**. Dies geschieht w√§hrend der Installation der App, damit die App nur mit Dateien interagieren kann, die ihrer Benutzer-ID geh√∂ren oder gemeinsam genutzte Dateien. Daher k√∂nnen nur die App selbst, bestimmte Komponenten des Betriebssystems und der Root-Benutzer auf die App-Daten zugreifen.

### UID-Sharing

**Zwei Anwendungen k√∂nnen so konfiguriert werden, dass sie dieselbe UID verwenden**. Dies kann n√ºtzlich sein, um Informationen zu teilen, aber wenn eine davon kompromittiert ist, werden die Daten beider Anwendungen kompromittiert. Aus diesem Grund wird dieses Verhalten **nicht empfohlen**.\
**Um dieselbe UID zu teilen, m√ºssen Anwendungen denselben `android:sharedUserId`-Wert in ihren Manifesten definieren.**

### Sandboxing

Die **Android Application Sandbox** erm√∂glicht das Ausf√ºhren **jeder Anwendung** als **eigenst√§ndiger Prozess unter einer separaten Benutzer-ID**. Jeder Prozess hat seine eigene virtuelle Maschine, sodass der Code einer App isoliert von anderen Apps ausgef√ºhrt wird.\
Ab Android 5.0(L) wird **SELinux** durchgesetzt. Grunds√§tzlich verweigert SELinux alle Prozessinteraktionen und erstellt dann Richtlinien, um **nur die erwarteten Interaktionen zwischen ihnen zuzulassen**.

### Berechtigungen

Wenn Sie eine **App installieren und sie um Berechtigungen bitten**, fragt die App nach den in den **`uses-permission`**-Elementen in der **AndroidManifest.xml**-Datei konfigurierten Berechtigungen. Das **uses-permission**-Element gibt den Namen der angeforderten Berechtigung im **name**-Attribut an. Es hat auch das **maxSdkVersion**-Attribut, das das Bitten um Berechtigungen in Versionen h√∂her als der angegebenen stoppt.\
Beachten Sie, dass Android-Anwendungen nicht alle Berechtigungen von Anfang an beantragen m√ºssen, sie k√∂nnen auch **dynamisch Berechtigungen beantragen**, aber alle Berechtigungen m√ºssen im Manifest **deklariert** sein.

Wenn eine App Funktionen freigibt, kann sie den **Zugriff nur auf Apps beschr√§nken, die √ºber eine bestimmte Berechtigung verf√ºgen**.\
Ein Berechtigungselement hat drei Attribute:

* Der **Name** der Berechtigung
* Das **permission-group**-Attribut, das das Gruppieren verwandter Berechtigungen erm√∂glicht.
* Das **protection-level**, das angibt, wie die Berechtigungen gew√§hrt werden. Es gibt vier Arten:
* **Normal**: Wird verwendet, wenn f√ºr die App **keine bekannten Bedrohungen** bestehen. Der Benutzer muss sie **nicht genehmigen**.
* **Gef√§hrlich**: Gibt an, dass die Berechtigung der anfordernden Anwendung einen **erh√∂hten Zugriff** gew√§hrt. **Benutzer werden aufgefordert, sie zu genehmigen**.
* **Signature**: Nur **Apps, die mit demselben Zertifikat wie das exportierende** Komponente signiert sind, k√∂nnen Berechtigungen erhalten. Dies ist die st√§rkste Art des Schutzes.
* **SignatureOrSystem**: Nur **Apps, die mit demselben Zertifikat wie das exportierende** Komponente signiert sind oder **Apps, die mit Systemzugriff ausgef√ºhrt werden**, k√∂nnen Berechtigungen erhalten.

## Vorinstallierte Anwendungen

Diese Apps befinden sich in der Regel in den Verzeichnissen **`/system/app`** oder **`/system/priv-app`** und einige von ihnen sind **optimiert** (m√∂glicherweise finden Sie nicht einmal die Datei `classes.dex`). Diese Anwendungen sind es wert, √ºberpr√ºft zu werden, da sie manchmal mit zu vielen Berechtigungen (als Root) ausgef√ºhrt werden.

* Diejenigen, die mit dem **AOSP** (Android OpenSource Project) **ROM** ausgeliefert werden
* Hinzugef√ºgt vom Ger√§tehersteller
* Hinzugef√ºgt vom Mobilfunkanbieter (wenn vom Anbieter gekauft)

## Rooting

Um Root-Zugriff auf ein physisches Android-Ger√§t zu erhalten, m√ºssen Sie in der Regel 1 oder 2 **Schwachstellen ausnutzen**, die normalerweise **spezifisch** f√ºr das **Ger√§t** und die **Version** sind.\
Sobald der Exploit funktioniert hat, wird normalerweise das Linux `su`-Bin√§r in einen Ort kopiert, der in der PATH-Umgebungsvariable des Benutzers angegeben ist, z. B. `/system/xbin`.

Sobald das su-Bin√§r konfiguriert ist, wird eine andere Android-App verwendet, um mit dem `su`-Bin√§r zu kommunizieren und **Anfragen f√ºr Root-Zugriff zu verarbeiten**, wie z. B. **Superuser** und **SuperSU** (im Google Play Store erh√§ltlich).

{% hint style="danger" %}
Beachten Sie, dass der Rooting-Prozess sehr gef√§hrlich ist und das Ger√§t schwer besch√§digen kann.
{% endhint %}

### ROMs

Es ist m√∂glich, das Betriebssystem durch Installation einer benutzerdefinierten Firmware zu **ersetzen**. Dadurch kann die N√ºtzlichkeit eines alten Ger√§ts erweitert, Softwarebeschr√§nkungen umgangen oder Zugriff auf den neuesten Android-Code erhalten werden.\
**OmniROM** und **LineageOS** sind zwei der beliebtesten Firmware-Versionen.

Beachten Sie, dass **nicht immer eine Root-Berechtigung erforderlich ist**, um eine benutzerdefinierte Firmware zu installieren. **Einige Hersteller erlauben** das Entsperren ihrer Bootloader auf dokumentierte und sichere Weise.

### Auswirkungen

Sobald ein Ger√§t gerootet ist, kann jede App Zugriff als Root anfordern. Wenn eine b√∂sartige Anwendung dies erh√§lt, hat sie Zugriff auf fast alles und kann das Telefon besch√§digen.

## Grundlagen von Android-Anwendungen <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Das Format von Android-Anwendungen wird als _APK-Dateiformat_ bezeichnet. Es handelt sich im Wesentlichen um eine **ZIP-Datei** (durch Umbenennen der Dateierweiterung in .zip k√∂nnen die Inhalte extrahiert und angezeigt werden).
- APK-Inhalte (nicht abschlie√üend)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: enth√§lt vorkompilierte Ressour
### **Dalvik & Smali**

In der Android-Entwicklung werden **Java oder Kotlin** zur Erstellung von Apps verwendet. Anstelle des JVM wie bei Desktop-Apps kompiliert Android diesen Code in **Dalvik Executable (DEX) Bytecode**. Fr√ºher wurde dies vom Dalvik-Virtual-Machine-Bytecode behandelt, aber jetzt √ºbernimmt die Android Runtime (ART) in neueren Android-Versionen.

F√ºr Reverse Engineering wird **Smali** entscheidend. Es ist die menschenlesbare Version des DEX-Bytecodes und fungiert wie eine Assemblersprache, indem es den Quellcode in Bytecode-Anweisungen √ºbersetzt. Smali und baksmali beziehen sich in diesem Zusammenhang auf die Assembly- und Disassembly-Tools.


***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Finden Sie die wichtigsten Schwachstellen, damit Sie sie schneller beheben k√∂nnen. Intruder verfolgt Ihre Angriffsfl√§che, f√ºhrt proaktive Bedrohungsscans durch und findet Probleme in Ihrer gesamten Technologie-Stack, von APIs √ºber Web-Apps bis hin zu Cloud-Systemen. [**Probieren Sie es noch heute kostenlos aus**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks).

***

## Intents

Intents sind das Hauptmittel, mit dem Android-Apps zwischen ihren Komponenten oder mit anderen Apps kommunizieren. Diese Nachrichtenobjekte k√∂nnen auch Daten zwischen Apps oder Komponenten transportieren, √§hnlich wie GET/POST-Anfragen in der HTTP-Kommunikation verwendet werden.

Ein Intent ist also eine **Nachricht, die zwischen Komponenten √ºbermittelt wird**. Intents **k√∂nnen an bestimmte Komponenten oder Apps gerichtet werden**, **oder ohne einen bestimmten Empf√§nger gesendet werden**.\
Um es einfach auszudr√ºcken, kann ein Intent verwendet werden:

* Um eine Aktivit√§t zu starten, normalerweise um eine Benutzeroberfl√§che f√ºr eine App zu √∂ffnen
* Als Broadcasts, um das System und Apps √ºber √Ñnderungen zu informieren
* Um einen Hintergrunddienst zu starten, zu stoppen und mit ihm zu kommunizieren
* Um auf Daten √ºber ContentProvider zuzugreifen
* Als R√ºckrufe, um Ereignisse zu behandeln

Wenn sie anf√§llig sind, **k√∂nnen Intents f√ºr verschiedene Angriffe verwendet werden**.

### Intent-Filter

**Intent-Filter** definieren **wie eine Aktivit√§t, ein Dienst oder ein Broadcast Receiver mit verschiedenen Arten von Intents interagieren kann**. Sie beschreiben im Wesentlichen die F√§higkeiten dieser Komponenten, wie z.B. welche Aktionen sie ausf√ºhren k√∂nnen oder welche Arten von Broadcasts sie verarbeiten k√∂nnen. Der prim√§re Ort, um diese Filter zu deklarieren, ist die **AndroidManifest.xml-Datei**, obwohl sie auch f√ºr Broadcast Receiver codiert werden k√∂nnen.

Intent-Filter bestehen aus Kategorien, Aktionen und Datenfiltern, mit der M√∂glichkeit, zus√§tzliche Metadaten einzuschlie√üen. Diese Einrichtung erm√∂glicht es Komponenten, spezifische Intents zu verarbeiten, die den deklarierten Kriterien entsprechen.

Ein wesentlicher Aspekt von Android-Komponenten (Aktivit√§ten/Dienste/Content Provider/Broadcast Receiver) ist ihre Sichtbarkeit oder **√∂ffentlicher Status**. Eine Komponente gilt als √∂ffentlich und kann mit anderen Apps interagieren, wenn sie mit einem Wert von **`true`** als **`exported`** markiert ist oder wenn f√ºr sie ein Intent-Filter im Manifest deklariert ist. Es gibt jedoch eine M√∂glichkeit f√ºr Entwickler, diese Komponenten explizit privat zu halten, um sicherzustellen, dass sie nicht unbeabsichtigt mit anderen Apps interagieren. Dies wird erreicht, indem das Attribut **`exported`** in ihren Manifestdefinitionen auf **`false`** gesetzt wird.

Dar√ºber hinaus haben Entwickler die M√∂glichkeit, den Zugriff auf diese Komponenten weiter abzusichern, indem sie bestimmte Berechtigungen verlangen. Das Attribut **`permission`** kann festgelegt werden, um durchzusetzen, dass nur Apps mit der festgelegten Berechtigung auf die Komponente zugreifen k√∂nnen. Dadurch wird eine zus√§tzliche Sicherheitsebene und Kontrolle dar√ºber hinzugef√ºgt, wer mit ihr interagieren kann.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Implizite Intents

Intents werden programmatisch mithilfe eines Intent-Konstruktors erstellt:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
Die **Aktion** des zuvor deklarierten Intents ist **ACTION\_SEND** und das **Extra** ist eine mailto-**Uri** (das Extra ist die zus√§tzliche Information, die der Intent erwartet).

Dieser Intent sollte im Manifest wie im folgenden Beispiel deklariert werden:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Ein Intent-Filter muss mit der **Aktion**, **Daten** und **Kategorie** √ºbereinstimmen, um eine Nachricht zu empfangen.

Der "Intent-Aufl√∂sungsprozess" bestimmt, welche App jede Nachricht erhalten soll. Dieser Prozess ber√ºcksichtigt das **Priorit√§tsattribut**, das in der **Intent-Filter-Deklaration** festgelegt werden kann, und **diejenige mit der h√∂heren Priorit√§t wird ausgew√§hlt**. Diese Priorit√§t kann zwischen -1000 und 1000 festgelegt werden und Anwendungen k√∂nnen den Wert `SYSTEM_HIGH_PRIORITY` verwenden. Wenn ein **Konflikt** auftritt, erscheint ein "Chooser"-Fenster, damit der **Benutzer entscheiden kann**.

### Explizite Intents

Ein expliziter Intent gibt den Klassennamen an, auf den er abzielt:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
In anderen Anwendungen k√∂nnen Sie auf den zuvor deklarierten Intent zugreifen, indem Sie Folgendes verwenden:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Ausstehende Absichten

Diese erm√∂glichen es anderen Anwendungen, im Namen Ihrer Anwendung Aktionen auszuf√ºhren, unter Verwendung der Identit√§t und Berechtigungen Ihrer App. Beim Erstellen einer ausstehenden Absicht muss eine Absicht und die auszuf√ºhrende Aktion angegeben werden. Wenn die deklarierte Absicht nicht explizit ist (nicht angibt, welche Absicht sie aufrufen kann), kann eine b√∂sartige Anwendung die deklarierte Aktion im Namen der Opfer-App ausf√ºhren. Dar√ºber hinaus, wenn keine Aktion angegeben ist, kann die b√∂sartige App beliebige Aktionen im Namen des Opfers ausf√ºhren.

### Broadcast-Absichten

Im Gegensatz zu den vorherigen Absichten, die nur von einer App empfangen werden, k√∂nnen Broadcast-Absichten von mehreren Apps empfangen werden. Ab API-Version 14 ist es m√∂glich, die App anzugeben, die die Nachricht erhalten soll, indem Intent.setPackage verwendet wird.

Alternativ ist es auch m√∂glich, beim Senden des Broadcasts eine Berechtigung anzugeben. Die Empf√§nger-App muss √ºber diese Berechtigung verf√ºgen.

Es gibt zwei Arten von Broadcasts: Normal (asynchron) und Ordered (synchron). Die Reihenfolge basiert auf der konfigurierten Priorit√§t innerhalb des Empf√§ngerelements. Jede App kann den Broadcast verarbeiten, weiterleiten oder verwerfen.

Es ist m√∂glich, einen Broadcast mithilfe der Funktion `sendBroadcast(intent, receiverPermission)` aus der Klasse `Context` zu senden. Sie k√∂nnen auch die Funktion `sendBroadcast` aus dem `LocalBroadCastManager` verwenden, um sicherzustellen, dass die Nachricht die App nie verl√§sst. Dadurch m√ºssen Sie nicht einmal einen Empf√§nger exportieren.

### Sticky-Broadcasts

Diese Art von Broadcasts kann lange nach dem Senden darauf zugegriffen werden. Sie wurden in der API-Ebene 21 veraltet und es wird empfohlen, sie nicht zu verwenden. Sie erm√∂glichen es jeder Anwendung, die Daten abzufangen, aber auch zu √§ndern.

Wenn Sie Funktionen finden, die das Wort "sticky" enthalten, wie `sendStickyBroadcast` oder `sendStickyBroadcastAsUser`, √ºberpr√ºfen Sie die Auswirkungen und versuchen Sie, sie zu entfernen.

## Deep Links / URL-Schemas

In Android-Anwendungen werden Deep Links verwendet, um eine Aktion (Intent) direkt √ºber eine URL zu initiieren. Dies geschieht durch Deklarieren eines spezifischen URL-Schemas innerhalb einer Aktivit√§t. Wenn ein Android-Ger√§t versucht, auf eine URL mit diesem Schema zuzugreifen, wird die angegebene Aktivit√§t innerhalb der Anwendung gestartet.

Das Schema muss in der Datei `AndroidManifest.xml` deklariert werden:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Das Schema aus dem vorherigen Beispiel ist `exampleapp://` (beachte auch die **`Kategorie BROWSABLE`**)

Dann kannst du im Datenfeld den **Host** und **Pfad** angeben:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Um darauf von einer Webseite aus zuzugreifen, ist es m√∂glich, einen Link wie folgt einzurichten:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Um den **Code, der in der App ausgef√ºhrt wird**, zu finden, gehe zur Aktivit√§t, die durch den Deeplink aufgerufen wird, und suche nach der Funktion **`onNewIntent`**.

Erfahre, wie man [Deeplinks aufruft, ohne HTML-Seiten zu verwenden](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

Die **Android Interface Definition Language (AIDL)** wurde entwickelt, um die Kommunikation zwischen Client und Service in Android-Anwendungen durch **Interprozesskommunikation** (IPC) zu erleichtern. Da der direkte Zugriff auf den Speicher eines anderen Prozesses auf Android nicht erlaubt ist, vereinfacht AIDL den Prozess, indem es Objekte in ein vom Betriebssystem verstandenes Format umwandelt und so die Kommunikation zwischen verschiedenen Prozessen erleichtert.

### Schl√ºsselkonzepte

- **Bound Services**: Diese Services nutzen AIDL f√ºr IPC und erm√∂glichen es Aktivit√§ten oder Komponenten, sich an einen Service zu binden, Anfragen zu stellen und Antworten zu erhalten. Die Methode `onBind` in der Klasse des Services ist entscheidend f√ºr die Initiierung der Interaktion und stellt daher einen wichtigen Bereich f√ºr die Sicherheits√ºberpr√ºfung auf Schwachstellen dar.

- **Messenger**: Als gebundener Service erm√∂glicht Messenger IPC mit dem Schwerpunkt auf der Verarbeitung von Daten durch die `onBind`-Methode. Es ist wichtig, diese Methode genau auf unsichere Datenverarbeitung oder die Ausf√ºhrung sensibler Funktionen zu √ºberpr√ºfen.

- **Binder**: Obwohl die direkte Verwendung der Binder-Klasse aufgrund der Abstraktion von AIDL weniger h√§ufig vorkommt, ist es hilfreich zu verstehen, dass Binder als Kernel-Treiber fungiert, der den Datentransfer zwischen den Speicherbereichen verschiedener Prozesse erm√∂glicht. F√ºr ein besseres Verst√§ndnis steht eine Ressource unter [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8) zur Verf√ºgung.

## Komponenten

Diese umfassen: **Aktivit√§ten, Services, Broadcast Receiver und Provider.**

### Launcher-Aktivit√§t und andere Aktivit√§ten

In Android-Apps sind **Aktivit√§ten** wie Bildschirme, die verschiedene Teile der Benutzeroberfl√§che der App anzeigen. Eine App kann viele Aktivit√§ten haben, von denen jede einen einzigartigen Bildschirm f√ºr den Benutzer darstellt.

Die **Launcher-Aktivit√§t** ist das Haupttor zu einer App und wird gestartet, wenn Sie auf das Symbol der App tippen. Sie wird in der Manifestdatei der App mit spezifischen MAIN- und LAUNCHER-Intents definiert:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Nicht alle Apps ben√∂tigen eine Startaktivit√§t, insbesondere solche ohne Benutzeroberfl√§che wie Hintergrunddienste.

Aktivit√§ten k√∂nnen f√ºr andere Apps oder Prozesse verf√ºgbar gemacht werden, indem sie im Manifest als "exportiert" markiert werden. Diese Einstellung erm√∂glicht es anderen Apps, diese Aktivit√§t zu starten:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Jedoch ist der Zugriff auf eine Aktivit√§t von einer anderen App nicht immer ein Sicherheitsrisiko. Die Bedenken entstehen, wenn sensible Daten unsachgem√§√ü geteilt werden, was zu Informationslecks f√ºhren k√∂nnte.

Der Lebenszyklus einer Aktivit√§t **beginnt mit der onCreate-Methode**, die die Benutzeroberfl√§che einrichtet und die Aktivit√§t auf die Interaktion mit dem Benutzer vorbereitet.

### Anwendungssubklasse

Bei der Android-Entwicklung hat eine App die M√∂glichkeit, eine **Unterklasse** der [Application](https://developer.android.com/reference/android/app/Application)-Klasse zu erstellen, obwohl dies nicht obligatorisch ist. Wenn eine solche Unterklasse definiert ist, wird sie als erste Klasse innerhalb der App instanziiert. Die Methode **`attachBaseContext`**, wenn sie in dieser Unterklasse implementiert ist, wird vor der **`onCreate`**-Methode ausgef√ºhrt. Diese Einrichtung erm√∂glicht eine fr√ºhe Initialisierung, bevor der Rest der Anwendung startet.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Dienste

[Dienste](https://developer.android.com/guide/components/services) sind **Hintergrundoperationen**, die in der Lage sind, Aufgaben ohne Benutzeroberfl√§che auszuf√ºhren. Diese Aufgaben k√∂nnen auch dann weiterlaufen, wenn Benutzer zu anderen Anwendungen wechseln, wodurch Dienste f√ºr **lang andauernde Operationen** unerl√§sslich sind.

Dienste sind vielseitig einsetzbar; sie k√∂nnen auf verschiedene Arten gestartet werden, wobei **Intents** die prim√§re Methode zum Starten als Einstiegspunkt einer Anwendung sind. Sobald ein Dienst mit der Methode `startService` gestartet wird, wird seine Methode `onStart` aktiviert und l√§uft weiter, bis die Methode `stopService` explizit aufgerufen wird. Alternativ, wenn die Rolle eines Dienstes von einer aktiven Client-Verbindung abh√§ngt, wird die Methode `bindService` verwendet, um den Client an den Dienst zu binden und die Methode `onBind` f√ºr den Datenaustausch zu nutzen.

Eine interessante Anwendung von Diensten umfasst das Abspielen von Hintergrundmusik oder das Abrufen von Netzwerkdaten, ohne die Interaktion des Benutzers mit einer App zu beeintr√§chtigen. Dar√ºber hinaus k√∂nnen Dienste f√ºr andere Prozesse auf demselben Ger√§t √ºber **Exportieren** zug√§nglich gemacht werden. Dies ist nicht das Standardverhalten und erfordert eine explizite Konfiguration in der Android Manifest-Datei:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Broadcast Receiver

**Broadcast Receiver** fungieren als Zuh√∂rer in einem Messaging-System und erm√∂glichen es mehreren Anwendungen, auf dieselben Nachrichten vom System zu reagieren. Eine App kann einen Empf√§nger auf zwei Hauptarten **registrieren**: √ºber das **Manifest** der App oder **dynamisch** im Code der App √ºber die **`registerReceiver`** API. Im Manifest werden Broadcasts mit Berechtigungen gefiltert, w√§hrend bei dynamisch registrierten Empf√§ngern Berechtigungen auch bei der Registrierung angegeben werden k√∂nnen.

**Intent-Filter** sind in beiden Registrierungsmethoden entscheidend und bestimmen, welche Broadcasts den Empf√§nger ausl√∂sen. Sobald ein passender Broadcast gesendet wird, wird die Methode **`onReceive`** des Empf√§ngers aufgerufen, sodass die App entsprechend reagieren kann, z. B. das Verhalten anpassen, um auf eine niedrige Akkuanzeige zu reagieren.

Broadcasts k√∂nnen entweder **asynchron** sein und alle Empf√§nger ohne Reihenfolge erreichen oder **synchron**, bei denen Empf√§nger den Broadcast basierend auf festgelegten Priorit√§ten erhalten. Es ist jedoch wichtig zu beachten, dass hier ein potenzielles Sicherheitsrisiko besteht, da jede App sich selbst priorisieren kann, um einen Broadcast abzufangen.

Um die Funktionalit√§t eines Empf√§ngers zu verstehen, suchen Sie nach der Methode **`onReceive`** innerhalb seiner Klasse. Der Code dieser Methode kann das empfangene Intent manipulieren, was die Notwendigkeit der Datenvalidierung durch Empf√§nger hervorhebt, insbesondere bei **geordneten Broadcasts**, die das Intent √§ndern oder verwerfen k√∂nnen.

### Content Provider

**Content Provider** sind f√ºr das **Teilen strukturierter Daten** zwischen Apps unerl√§sslich und betonen die Bedeutung der Implementierung von **Berechtigungen**, um die Datensicherheit zu gew√§hrleisten. Sie erm√∂glichen Apps den Zugriff auf Daten aus verschiedenen Quellen, einschlie√ülich Datenbanken, Dateisystemen oder dem Web. Spezifische Berechtigungen wie **`readPermission`** und **`writePermission`** sind entscheidend f√ºr die Kontrolle des Zugriffs. Dar√ºber hinaus kann √ºber die Einstellungen **`grantUriPermission`** im Manifest der App ein tempor√§rer Zugriff gew√§hrt werden, wobei Attribute wie `path`, `pathPrefix` und `pathPattern` f√ºr eine detaillierte Zugriffskontrolle genutzt werden.

Die Eingabevalidierung ist entscheidend, um Sicherheitsl√ºcken wie SQL-Injection zu verhindern. Content Provider unterst√ºtzen grundlegende Operationen wie `insert()`, `update()`, `delete()` und `query()`, die die Manipulation und den Austausch von Daten zwischen Anwendungen erleichtern.

**FileProvider**, ein spezialisierter Content Provider, konzentriert sich auf das sichere Teilen von Dateien. Er wird im Manifest der App mit spezifischen Attributen definiert, um den Zugriff auf Ordner zu kontrollieren, die durch `android:exported` und `android:resource` auf Ordnerkonfigurationen verweisen. Es wird empfohlen, Vorsicht walten zu lassen, wenn Verzeichnisse freigegeben werden, um versehentlich sensible Daten preiszugeben.

Beispielhafte Manifestdeklaration f√ºr FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Und ein Beispiel f√ºr die Angabe von freigegebenen Ordnern in `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
F√ºr weitere Informationen siehe:
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews sind wie **Mini-Webbrowser** innerhalb von Android-Apps, die Inhalte entweder aus dem Web oder aus lokalen Dateien abrufen. Sie sind √§hnlichen Risiken wie regul√§re Browser ausgesetzt, aber es gibt M√∂glichkeiten, diese Risiken durch spezifische **Einstellungen** zu **minimieren**.

Android bietet zwei Haupttypen von WebViews:

- **WebViewClient** ist gut f√ºr grundlegendes HTML, unterst√ºtzt jedoch nicht die JavaScript-Alert-Funktion, was sich darauf auswirkt, wie XSS-Angriffe getestet werden k√∂nnen.
- **WebChromeClient** verh√§lt sich eher wie die vollst√§ndige Chrome-Browser-Erfahrung.

Ein wichtiger Punkt ist, dass WebView-Browser **keine Cookies** mit dem Hauptbrowser des Ger√§ts teilen.

F√ºr das Laden von Inhalten stehen Methoden wie ````loadUrl````, ````loadData````, und ````loadDataWithBaseURL```` zur Verf√ºgung. Es ist entscheidend sicherzustellen, dass diese URLs oder Dateien **sicher verwendet** werden k√∂nnen. Sicherheitseinstellungen k√∂nnen √ºber die Klasse ````WebSettings```` verwaltet werden. Zum Beispiel kann das Deaktivieren von JavaScript mit ````setJavaScriptEnabled(false)```` XSS-Angriffe verhindern.

Die JavaScript-"Bridge" erm√∂glicht es Java-Objekten, mit JavaScript zu interagieren. Ab Android 4.2 m√ºssen Methoden mit ````@JavascriptInterface```` markiert werden, um die Sicherheit zu gew√§hrleisten.

Das Zulassen des Zugriffs auf Inhalte (````setAllowContentAccess(true)````) erm√∂glicht es WebViews, auf Content Provider zuzugreifen, was ein Risiko darstellen kann, es sei denn, die Inhalts-URLs werden als sicher √ºberpr√ºft.

Um den Dateizugriff zu kontrollieren:
- Das Deaktivieren des Dateizugriffs (````setAllowFileAccess(false)````) beschr√§nkt den Zugriff auf das Dateisystem, mit Ausnahmen f√ºr bestimmte Ressourcen, um sicherzustellen, dass sie nur f√ºr nicht sensible Inhalte verwendet werden.

## Andere App-Komponenten und Mobile Device Management

### **Digitale Signierung von Anwendungen**

- Die **digitale Signierung** ist ein Muss f√ºr Android-Apps, um sicherzustellen, dass sie vor der Installation **authentisch erstellt** wurden. Dieser Prozess verwendet ein Zertifikat zur App-Identifizierung und muss vom Paketmanager des Ger√§ts bei der Installation √ºberpr√ºft werden. Apps k√∂nnen **selbst signiert oder von einer externen Zertifizierungsstelle zertifiziert** sein, um unbefugten Zugriff zu verhindern und sicherzustellen, dass die App w√§hrend der Auslieferung an das Ger√§t nicht manipuliert wurde.

### **App-Verifizierung f√ºr erh√∂hte Sicherheit**

- Ab **Android 4.2** erm√∂glicht eine Funktion namens **Verify Apps** Benutzern, Apps vor der Installation auf Sicherheit zu √ºberpr√ºfen. Dieser **Verifizierungsprozess** kann Benutzer vor potenziell sch√§dlichen Apps warnen oder sogar die Installation besonders b√∂sartiger Apps verhindern und die Sicherheit der Benutzer erh√∂hen.

### **Mobile Device Management (MDM)**

- **MDM-L√∂sungen** bieten √úberwachung und Sicherheit f√ºr mobile Ger√§te √ºber die **Device Administration API**. Sie erfordern die Installation einer Android-App, um mobile Ger√§te effektiv zu verwalten und zu sichern. Zu den wichtigsten Funktionen geh√∂ren die **Durchsetzung von Passwortrichtlinien**, die **Verpflichtung zur Speicherung von Verschl√ºsselung** und die **Erm√∂glichung des Remote-Datenl√∂schens**, um umfassende Kontrolle und Sicherheit √ºber mobile Ger√§te zu gew√§hrleisten.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
***

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Finden Sie die wichtigsten Sicherheitsl√ºcken, damit Sie sie schneller beheben k√∂nnen. Intruder verfolgt Ihre Angriffsfl√§che, f√ºhrt proaktive Bedrohungsscans durch und findet Probleme in Ihrer gesamten Technologie-Stack, von APIs √ºber Webanwendungen bis hin zu Cloud-Systemen. [**Probieren Sie es noch heute kostenlos aus**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks).

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***


<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
