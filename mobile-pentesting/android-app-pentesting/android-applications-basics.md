# Android应用程序基础知识

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞经过验证后，您将获得奖励。

**在web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！在其崛起的日子里掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占据每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客行动中获利！

{% embed url="https://hackenproof.com/register" %}

## Android安全模型

**有两个层次：**

* **操作系统**，将安装的应用程序相互隔离。
* **应用程序本身**，允许开发人员**公开某些功能**并配置应用程序的功能。

### UID分离

**每个应用程序都被分配一个特定的用户ID**。这是在应用程序安装过程中完成的，因此应用程序只能与其用户ID拥有的文件或共享文件进行交互。因此，只有应用程序本身、操作系统的某些组件和root用户可以访问应用程序的数据。

### UID共享

**两个应用程序可以配置为使用相同的UID**。这可能有助于共享信息，但如果其中一个应用程序受到损害，则两个应用程序的数据将受到损害。因此，这种行为是**不鼓励的**。\
**要共享相同的UID，应用程序必须在其清单中定义相同的`android:sharedUserId`值。**

### 沙箱

**Android应用程序沙箱**允许将**每个应用程序**作为**单独的进程在单独的用户ID下运行**。每个进程都有自己的虚拟机，因此应用程序的代码在其他应用程序中运行时处于隔离状态。\
从Android 5.0（L）开始，强制执行**SELinux**。基本上，SELinux拒绝了所有进程之间的交互，然后创建了**仅允许它们之间的预期交互的策略**。

### 权限

当您安装一个**应用程序并请求权限**时，该应用程序正在请求在**AndroidManifest.xml**文件中的**`uses-permission`**元素中配置的权限。**uses-permission**元素指示请求的权限的名称在**name**属性中。它还具有**maxSdkVersion**属性，该属性停止在高于指定版本的版本上请求权限。\
请注意，Android应用程序不需要一开始就请求所有权限，它们也可以**动态请求权限**，但所有权限必须在**清单**中**声明**。

当应用程序公开功能时，它可以限制**仅允许具有指定权限的应用程序访问**。\
权限元素有三个属性：

* 权限的**名称**
* **permission-group**属性，允许对相关权限进行分组。
* **protection-level**，指示如何授予权限。有四种类型：
* **Normal**：当应用程序**没有已知的威胁**时使用。用户**不需要批准**。
* **Dangerous**：表示权限授予请求应用程序一些**提升的访问权限**。**用户被要求批准**。
* **Signature**：只有与导出组件相同的证书签名的应用程序才能被授予权限。这是最强的保护类型。
* **SignatureOrSystem**：只有与导出组件相同的证书签名的应用程序或以系统级访问权限运行的应用程序才能被授予权限。

## 预安装应用程序

这些应用程序通常位于**`/system/app`**或**`/system/priv-app`**目录中，其中一些应用程序经过了**优化**（您可能找不到`classes.dex`文件）。这些应用程序值得检查，因为有时它们以**太多权限**（如root）运行。

* 随**AOSP**（Android开源项目）**ROM**一起提供的应用程序
* 设备**制造商**添加的应用程序
* 由**手机提供商**添加（如果从他们那里购买）
## Rooting

为了在物理安卓设备上获得root访问权限，通常需要利用1或2个特定于设备和版本的漏洞。一旦漏洞被利用成功，通常会将Linux的`su`二进制文件复制到用户的PATH环境变量指定的位置，如`/system/xbin`。

一旦su二进制文件被配置好，另一个安卓应用程序被用来与su二进制文件进行交互，并处理对root访问的请求，如Superuser和SuperSU（在Google Play商店中可用）。

{% hint style="danger" %}
请注意，root过程非常危险，可能会严重损坏设备。
{% endhint %}

### ROMs

可以通过安装自定义固件来替换操作系统。这样可以扩展旧设备的功能，绕过软件限制或访问最新的安卓代码。OmniROM和LineageOS是最流行的两个固件。

请注意，并不总是需要root设备才能安装自定义固件。一些制造商允许以一种有文档记录且安全的方式解锁他们的引导加载程序。

### 影响

一旦设备被root，任何应用程序都可以请求root访问权限。如果恶意应用程序获得了这个权限，它将能够访问几乎所有内容，并且可以损坏手机。

## 安卓应用程序基础 <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

这个介绍来自于[https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html](https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html)

### 基础回顾 <a href="#fundamentals-review" id="fundamentals-review"></a>

* 安卓应用程序以_APK文件格式_存在。APK基本上是一个ZIP文件。（您可以将文件扩展名更改为.zip并使用解压缩工具打开并查看其内容。）
* APK内容（不详尽）
* **AndroidManifest.xml**
* resources.arsc/strings.xml
* resources.arsc：包含预编译资源的文件，例如二进制XML。
* res/xml/files\_paths.xml
* META-INF/
* 证书存放在这里！
* **classes.dex**
* 应用程序的Dalvik字节码以DEX文件格式存在。这是应用程序默认运行的Java（或Kotlin）代码的编译版本。
* lib/
* 应用程序的本地库默认存放在这里！在lib/目录下，有特定于CPU的目录。
* `armeabi`：仅适用于所有基于ARM的处理器的编译代码
* `armeabi-v7a`：仅适用于所有基于ARMv7及以上的处理器的编译代码
* `x86`：适用于X86的编译代码
* `mips`：仅适用于MIPS处理器的编译代码
* assets/
* 应用程序可能需要的其他文件。
* 可以在此处包含其他本地库或DEX文件。这可能发生在恶意软件作者想要尝试“隐藏”其他代码（本地或Dalvik），而不将其包含在默认位置时。
* res/
* 包含未编译到resources.arsc中的资源的目录

### **Dalvik和Smali**

大多数安卓应用程序是用Java编写的。Kotlin也受支持，并且与Java可互操作。为了简便起见，在本次研讨会的其余部分中，当我提到“Java”时，您可以认为我是指“Java或Kotlin”。与桌面应用程序不同，安卓中的Java代码不是在Java虚拟机（JVM）中运行，而是编译为_Dalvik可执行（DEX）字节码_格式。在早期的安卓版本中，字节码由Dalvik虚拟机翻译。在较新的安卓版本中，使用安卓运行时（ART）。\
如果开发人员使用Java编写代码并将其编译为DEX字节码，那么在进行逆向工程时，我们将按相反的方向进行工作。

![开发人员流程的流程图。Java到DEX字节码](https://maddiestone.github.io/AndroidAppRE/images/DevelopersFlow.jpg)

![逆向工程师流程的流程图。DEX字节码到SMALI到反编译的Java](https://maddiestone.github.io/AndroidAppRE/images/ReversersFlow.jpg)

**Smali是Dalvik字节码的可读版本**。从技术上讲，Smali和baksmali是工具的名称（汇编器和反汇编器），但在安卓中，我们经常使用术语“Smali”来指代指令。如果您曾经对编译的C/C++代码进行过逆向工程或计算机体系结构研究，那么SMALI就像汇编语言：介于高级源代码和字节码之间。

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞经过验证后，您将获得奖励。

**在web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！在其崛起之时掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占领每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客行动中获利！

{% embed url="https://hackenproof.com/register" %}

## 意图

意图是安卓应用程序在其组件之间或与其他应用程序之间进行通信的主要方式。这些消息对象还可以在应用程序或组件之间传递数据，类似于HTTP通信中使用GET/POST请求的方式。

因此，意图基本上是在组件之间传递的消息。意图可以被指定给特定的组件或应用程序，也可以在没有特定接收者的情况下发送。\
简单来说，意图可以用于以下目的：

* 启动一个Activity，通常是打开应用程序的用户界面
* 作为广播，通知系统和应用程序发生的变化
* 启动、停止和与后台服务通信
* 通过ContentProviders访问数据
* 作为回调来处理事件

不正确的实现可能导致数据泄露、调用受限函数和操纵程序流程。

### 意图过滤器

意图过滤器指定了一个活动、服务或广播接收器可以响应的意图类型。它指定了一个活动或服务可以做什么，以及接收器可以处理哪些类型的广播。它允许相应的组件接收声明类型的意图。意图过滤器通常通过AndroidManifest.xml文件定义。对于广播接收器，也可以在编码中定义它们。意图过滤器由其类别、操作和数据过滤器定义。它还可以包含其他元数据。

在安卓中，当`exported`设置为`true`时，活动/服务/内容提供程序/广播接收器是**公开的**，但如果清单文件为组件指定了意图过滤器，那么组件也是**公开的**。然而，开发人员可以通过在清单文件中为每个组件将`exported`属性设置为`false`来**显式地将组件设置为私有**，而不管任何意图过滤器。开发人员还可以通过设置`permission`属性来要求特定权限来访问组件，从而限制对组件的访问。
### 隐式意图

意图是通过使用意图构造函数在程序中创建的：
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
之前声明的意图的**Action**是**ACTION\_SEND**，**Extra**是一个mailto **Uri**（Extra是意图期望的额外信息）。

这个意图应该在清单文件中声明，如下面的示例所示：
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
一个intent-filter需要匹配**action**、**data**和**category**才能接收到消息。

"Intent resolution"过程确定了每个消息应该由哪个应用接收。这个过程考虑了**priority属性**，它可以在**intent-filter声明**中设置，**优先级较高的将被选择**。这个优先级可以在-1000到1000之间设置，并且应用程序可以使用`SYSTEM_HIGH_PRIORITY`值。如果出现**冲突**，会出现一个"选择器"窗口，让**用户决定**。

### 显式Intent

显式Intent指定了它所针对的类名：
```java
Intent downloadIntent = new (this, DownloadService.class):
```
在其他应用程序中，为了访问先前声明的意图，您可以使用：
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Pending Intents

这些允许其他应用程序代表您的应用程序采取行动，使用您的应用程序的身份和权限。构建一个Pending Intent时，应指定一个意图和要执行的操作。如果声明的意图不是明确的（没有声明哪个意图可以调用它），恶意应用程序可以代表受害者应用程序执行声明的操作。此外，如果未指定操作，恶意应用程序将能够代表受害者执行任何操作。

### Broadcast Intents

与之前的意图不同，只有一个应用程序接收到的意图，广播意图可以被多个应用程序接收。然而，从API版本14开始，可以使用Intent.setPackage来指定应该接收消息的应用程序。

另外，发送广播时也可以指定权限。接收器应用程序将需要具有该权限。

广播有两种类型：正常（异步）和有序（同步）。顺序基于接收器元素中配置的优先级。每个应用程序可以处理、中继或丢弃广播。

可以使用Context类的sendBroadcast(intent, receiverPermission)函数发送广播。您还可以使用LocalBroadCastManager的sendBroadcast函数确保消息永远不会离开应用程序。使用这种方法，您甚至不需要导出接收器组件。

### Sticky Broadcasts

这种类型的广播可以在发送后很长时间内访问。这些在API级别21中已被弃用，建议不要使用它们。它们允许任何应用程序嗅探数据，但也可以修改数据。

如果找到包含"sticky"一词的函数，如sendStickyBroadcast或sendStickyBroadcastAsUser，请检查其影响并尝试删除它们。

## Deep links / URL schemes

深度链接允许通过URL触发意图。应用程序可以在活动中声明一个URL模式，因此每当Android设备尝试使用该模式访问地址时，应用程序的活动将被调用：

![](<../../.gitbook/assets/image (214).png>)

在这种情况下，模式是`myapp://`（还要注意`category BROWSABLE`）

如果在`intent-filter`中找到类似以下内容：

![](<../../.gitbook/assets/image (263).png>)

那么，它期望的是类似`http://www.example.com/gizmos`的东西

如果找到类似以下内容：

![](<../../.gitbook/assets/image (262).png>)

这意味着它期望以`example://gizmos`开头的URL\
在这种情况下，您可以尝试滥用功能，创建一个包含以下有效负载的网页。它将尝试导航到任意页面并尝试执行JS：
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
为了找到在应用程序中执行的代码，转到由深度链接调用的活动，并搜索名为`onNewIntent`的函数。

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

了解如何[在不使用HTML页面的情况下调用深度链接](./#exploiting-schemes-deep-links)。

## AIDL - Android接口定义语言

Android接口定义语言（AIDL）允许您定义客户端和服务之间达成一致的编程接口，以便使用进程间通信进行通信。在Android上，一个进程通常无法访问另一个进程的内存。因此，为了进行通信，它们需要将对象分解为操作系统可以理解的原语，并在此边界上对对象进行编组。编写执行此编组的代码很繁琐，因此Android使用AIDL来处理它。

使用AIDL的服务称为绑定服务。在服务的类中，您将找到`onBind`方法。这是交互开始的地方，因此它是要检查的代码的初始部分，以寻找潜在的漏洞。

绑定服务是客户端-服务器接口中的服务器。它允许组件（如活动）绑定到服务，发送请求，接收响应并执行进程间通信（IPC）。绑定服务通常仅在为另一个应用程序组件提供服务时才存在，并且不会无限期在后台运行。

### Messenger

Messenger是另一种IPC机制。由于Messenger也是“绑定服务”，因此从客户端应用程序传递的数据也会通过`onBind`方法进行处理。因此，代码审查应从此方法开始，并查找对敏感功能的调用或对数据的不安全处理。

### Binder

直接调用Binder类很奇怪，因为使用AIDL（抽象了Binder类）更容易。但是，了解Binder是一个内核级驱动程序，它将数据从一个进程的内存移动到另一个进程的内存是很好的（[https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)）。

## 组件

这些包括：活动（Activities）、服务（Services）、广播接收器（Broadcast Receivers）和内容提供器（Providers）。

### 启动器活动和其他活动

Android活动是Android应用程序用户界面的一个屏幕。在这种方式上，Android活动与桌面应用程序中的窗口非常相似。一个Android应用程序可以包含一个或多个活动，意味着一个或多个屏幕。

启动器活动是大多数人认为是Android应用程序的入口点。启动器活动是当用户点击应用程序图标时启动的活动。您可以通过查看应用程序的清单来确定启动器活动。启动器活动将列出以下MAIN和LAUNCHER意图。

请记住，并非每个应用程序都会有一个启动器活动，特别是没有UI的应用程序。没有UI的应用程序（因此也没有启动器活动）的示例是在后台执行服务的预安装应用程序，例如语音邮件。
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
活动可以被导出，允许设备上的其他进程启动该活动。默认情况下，它们不会被导出，但是您可以通过设置来导出它们：
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
请注意，**绕过活动保护并不总是漏洞**，您需要检查您已获得访问权限的数据。此外，**某些活动会将数据返回给调用者**。在这种情况下，您需要搜索**`setResult`**方法并检查传递给Intent参数的数据。**如果这是敏感数据，您可能存在信息泄露漏洞**，并且可以利用能够与活动通信的应用程序进行利用。

**活动的代码从`onCreate`方法开始。**

### 应用程序子类

Android应用程序可以定义一个[Application](https://developer.android.com/reference/android/app/Application)的**子类**。应用程序可以定义一个自定义的Application子类，但不一定要这样做。如果Android应用程序定义了一个Application子类，则**此类在应用程序中的任何其他类之前实例化**。

如果在Application子类中定义了**`attachBaseContext`**方法，则在**`onCreate`**方法之前调用它。

### 服务

[服务](https://developer.android.com/guide/components/services)在后台运行，没有用户界面。它们用于执行**长时间运行的进程，即使用户开始使用其他应用程序**。

它们可以通过各种方式启动，因此是应用程序的入口点。启动服务作为应用程序入口点的默认方式是通过**意图**。

当调用**`startService`**方法启动服务时，服务中的**`onStart`**方法将被执行。它将无限期地运行，直到调用**`stopService`**方法。如果只需要在客户端连接时使用服务，客户端应使用**`bindService`**方法进行“绑定”。

对于**绑定服务**（参见前一节），数据将传递给**`onBind`**方法。

例如，服务可以在用户位于不同应用程序时在后台播放音乐，或者可以在不阻塞与活动的用户交互的情况下从网络获取数据。

**服务可以导出，允许设备上的其他进程启动服务**。默认情况下，服务不会导出，但可以在清单文件中进行配置：
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### 广播接收器

广播可以被看作是一种消息系统，而**广播接收器则是监听器**。如果一个应用程序为特定的广播注册了接收器，当系统发送广播时，接收器中的代码将被执行。需要注意的是，在这种情况下，**多个应用程序可以接收相同的消息**。

有**两种方式**可以**注册接收器**：在应用程序的清单中或在应用程序的代码中使用**`registerReceiver`** API调用进行动态注册。在清单中，可以通过在接收器元素中使用权限来限制接受的广播。当动态定义时，可以将权限传递给`registerReceiver`方法。

在这两种情况下，都需要设置接收器的**意图过滤器**来注册接收器。这些意图过滤器是应该触发接收器的广播。

当发送接收器注册的特定广播时，将执行BroadcastReceiver类中的**`onReceive`**方法。

例如，应用程序可以为低电量消息注册一个接收器，并根据该信息更改其行为。

广播可以是**异步的**（每个接收器都会接收到它）或**同步的**（广播按照设置的优先级有序接收）。

{% hint style="danger" %}
**请注意，任何应用程序都可以将自己设置为接收广播的最高优先级。**
{% endhint %}

要**检查**广播接收器中实现的**代码**，需要搜索接收器类的**`onReceive`**方法。\
需要注意的是，**有序广播可以丢弃接收到的Intent甚至修改它**，使用其中一个setter方法。因此，**接收器应该验证数据**。

### 内容提供器

内容提供器是应用程序之间共享结构化数据（如关系数据库）的方式。因此，使用**权限**并设置适当的保护级别来保护它们非常重要。\
内容提供器可以使用**`readPermission`**和**`writePermission`**属性来指定应用程序必须具有的权限。**这些权限优先于权限属性**。\
此外，它们还可以通过将**`grantUriPermission`**设置为true，然后在清单文件中的提供程序元素内配置适当的参数来**允许临时例外**。

**`grant-uri-permission`**有三个属性：path、pathPrefix和pathPattern：

* **path**：允许指定要排除的整个路径
* **pathPrefix**：允许指定路径的开头
* **pathPattern**：允许使用通配符和符号替换来获得更精细的控制。

**重要的是验证和清理接收到的输入**，以避免潜在的漏洞，如SQL注入。

**内容提供器的特点：**

* 内容提供器组件根据请求从一个应用程序向其他应用程序提供数据。
* 您可以将数据存储在文件系统、SQLite数据库、Web上或应用程序可以访问的任何其他持久存储位置中。
* 通过内容提供器，其他应用程序可以查询甚至修改数据（如果内容提供器允许）。
* 内容提供器在应用程序想要与另一个应用程序共享数据的情况下非常有用。
* 它与数据库非常相似，有四种方法。
* insert()
* update()
* delete()
* query()

**FileProvider**

这是一种可以从文件夹中**共享文件**的内容提供器。可以像这样声明一个文件提供器：
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
请注意**`android:exported`**属性，如果它的值为**`true`**，外部应用程序将能够访问共享文件夹。\
请注意，配置项`android:resource="@xml/filepaths"`表示文件_res/xml/filepaths.xml_包含了**FileProvider**将要**共享**的**文件夹**的配置。以下是在该文件中指定共享文件夹的示例：
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
共享像 **`path="."`** 这样的东西可能是**危险的**，即使提供者没有被导出，如果代码的某个部分尝试访问这个提供者时存在其他漏洞。\
你可以使用 `content://com.example.myapp.fileprovider/myimages/default_image.jpg` 来访问该文件夹内的一个**图片**。

`<paths>` 元素可以有多个子元素，每个子元素指定一个不同的目录来共享。除了 **`<files-path>`** 元素外，还可以使用 **`<external-path>`** 元素来共享外部存储中的目录，以及使用 **`<cache-path>`** 元素来共享内部缓存目录中的目录。\
[有关特定文件提供者属性的更多信息，请点击此处。](https://developer.android.com/reference/androidx/core/content/FileProvider)

[在此处了解有关文件提供者的更多信息](https://developer.android.com/training/secure-file-sharing/setup-sharing)。

## WebViews

WebViews 是嵌入到 Android 应用程序中的**网页浏览器**。\
WebViews 的内容可以来自远程站点，也可以是包含在应用程序中的文件。\
WebViews **容易受到影响任何网页浏览器的漏洞**。但是，有一些**配置**可以用来**限制**攻击**面**。

Android 中有两种类型的 WebViews：

* **WebViewClient**，最适合简单的 HTML 渲染。它不会运行 JS 的 alert 函数。因此，使用该函数进行 XSS 测试将无效。
* **WebChrome** **client**，是一个 Chrome 浏览器。

请注意，**WebView 浏览器无法访问本机浏览器的 cookie**。

可以使用 **`loadUrl`**、**`loadData`** 或 **`loadDataWithBaseURL`** 函数来加载 URL 或文件。**只能访问经过消毒的 URL 是很重要的**。\
WebView 的安全性可以通过 **`WebSettings`** 对象进行配置。\
例如，可以使用 **`setJavaScriptEnabled`** 方法将 JS 代码执行禁用为 **`false`** 值。这将**消除** XSS 和其他与 JS 相关的漏洞的可能性。

JavaScript 的 "**Bridge**" 功能**将 Java 对象注入到 WebView 中，使其可以被 JS 访问**。从 Android 4.2 开始，必须使用 **`@JavascriptInterface`** 进行方法注释，以便 JavaScript 可以访问它们。

如果将 **`true`** 传递给 **`setAllowContentAccess`**，则 WebView 将能够通过 **`content://`** 方案访问内容提供者。这显然会带来安全风险。请注意，如果给予此访问权限，非常重要的是**确保** **`content://`** URL 是**安全的**。

默认情况下，WebViews 可以通过 file:// URL 访问本地文件，但有几种方法可以防止这种行为：

* 将 **`false`** 传递给 **`setAllowFileAccess`**，防止访问文件系统，但允许通过 `file:///android_asset` 和 `file:///android_res` 访问资源。这些路径应仅用于非敏感数据（如图像），因此这应该是安全的。
* **`setAllowFileAccess`** 方法指示是否应该允许来自 `file://` URL 的路径能够访问其他文件方案 URL 的内容。
* **`setAllowUniversalAccessFromFileURLs`** 方法指示是否应该允许来自 `file://` URL 的路径能够访问任何来源的内容。

## 其他应用组件

### **应用程序签名**

* Android 要求在应用程序安装之前，**所有应用程序都必须使用证书进行数字签名**。Android 使用此证书来识别应用程序的作者。
* 要在设备上运行应用程序，它必须经过签名。当应用程序安装到设备上时，**包管理器会验证**应用程序是否已使用 apk 文件中的证书正确签名。
* 应用程序可以自签名，也可以通过 CA 进行签名。
* 应用程序签名确保一个应用程序不能访问任何其他应用程序，除非通过明确定义的 IPC，并且它未经修改地传递到设备上。

### **应用程序验证**

* Android 4.2 及更高版本支持应用程序验证。用户可以选择启用“验证应用程序”，并在安装之前由应用程序验证器对应用程序进行评估。
* 应用程序验证可以在用户尝试安装可能有害的应用程序时向用户发出警报；如果应用程序特别糟糕，它可以阻止安装。

## 移动设备管理

MDM 或移动设备管理是用于在移动设备上**确保控制和安全要求**的软件套件。这些套件使用称为设备管理 API 的功能，并需要安装一个 Android 应用程序。

通常，MDM 解决方案执行诸如强制密码策略、强制加密存储和启用远程擦除设备数据等功能。

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof 是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof 的赏金只有在客户存入奖励预算后才会启动。在漏洞经过验证后，您将获得奖励。

**在 web3 渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！掌握 web3 安全的崛起之日。

**成为 web3 黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占领每周排行榜的榜首。

[**在 HackenProof 上注册**](https://hackenproof.com/register) 开始从您的黑客行动中获利！

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 您在**网络安全公司**工作吗？您想在 HackTricks 中看到您的公司广告吗？或者您想获得最新版本的 PEASS 或下载 PDF 格式的 HackTricks 吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family) 集合 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方 PEASS 和 HackTricks 商品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass)，或在 **Twitter** 上 **关注**我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享您的黑客技巧。**

</details>
