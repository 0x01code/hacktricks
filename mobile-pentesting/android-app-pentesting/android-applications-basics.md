# Android Applications Basics

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスウェグ**](https://peass.creator-spring.com)を手に入れる
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見る
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[Telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)をフォローする
- **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する

</details>

**Try Hard Security Group**

<figure><img src="../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Androidセキュリティモデル

**2つのレイヤーがあります：**

- **OS**：インストールされたアプリケーションを互いに分離します。
- **アプリケーション自体**：開発者が**特定の機能を公開**し、アプリケーションの機能を構成できます。

### UID分離

**各アプリケーションには特定のユーザーIDが割り当てられます**。これはアプリのインストール時に行われ、**アプリは自分のユーザーIDで所有するファイルまたは共有ファイルにのみアクセス**できます。したがって、アプリ自体、OSの特定のコンポーネント、およびルートユーザーだけがアプリのデータにアクセスできます。

### UID共有

**2つのアプリケーションを同じUIDを使用するように構成できます**。これは情報を共有するのに役立ちますが、1つが侵害されると両方のアプリケーションのデータが侵害されます。このため、この動作は**推奨されません**。\
**同じUIDを共有するには、アプリケーションはマニフェストで同じ `android:sharedUserId` 値を定義する必要があります。**

### サンドボックス

**Androidアプリケーションサンドボックス**を使用すると、**各アプリケーション**を**別のプロセスとして別のユーザーIDで実行**できます。各プロセスには独自の仮想マシンがあり、アプリのコードは他のアプリから隔離されて実行されます。\
Android 5.0（L）からは**SELinux**が強制されています。基本的に、SELinuxはすべてのプロセスの相互作用を拒否し、それらの間で**予想される相互作用のみを許可するポリシーを作成**しました。

### 権限

**アプリをインストールし、権限を要求するとき**、アプリは**AndroidManifest.xml**ファイルの**`uses-permission`**要素で構成された権限を要求しています。**uses-permission**要素は、**name** **属性内の要求された権限の名前**を示します。**maxSdkVersion**属性もあり、指定されたバージョンよりも高いバージョンでは権限を要求しなくなります。\
Androidアプリケーションは最初からすべての権限を要求する必要はなく、**権限を動的に要求**することもできますが、すべての権限は**マニフェストで宣言**されている必要があります。

アプリが機能を公開すると、**指定された権限を持つアプリにのみアクセス**を制限できます。\
権限要素には3つの属性があります：

- 権限の**名前**
- 関連する権限をグループ化する**permission-group**属性
- 権限がどのように付与されるかを示す**protection-level**。4つのタイプがあります：
  - **Normal**：アプリに**既知の脅威がない**場合に使用されます。ユーザーは**承認を求められません**。
  - **Dangerous**：権限が要求されたアプリケーションに**一部の権限が与えられる**ことを示します。**ユーザーは承認を求められます**。
  - **Signature**：**エクスポートしているコンポーネントと同じ証明書で署名されたアプリ**のみが権限を付与されることができます。これは最も強力な保護のタイプです。
  - **SignatureOrSystem**：**エクスポートしているコンポーネントと同じ証明書で署名されたアプリ**または**システムレベルのアクセスで実行されているアプリ**のみが権限を付与されることができます。

## 事前インストールされたアプリケーション

これらのアプリは一般的に**`/system/app`**または**`/system/priv-app`**ディレクトリにあり、一部は**最適化されています**（`classes.dex`ファイルが見つからない場合があります）。これらのアプリケーションは、**時々ルートとして実行されている**ため、チェックする価値があります。

- **AOSP**（Androidオープンソースプロジェクト）**ROM**に含まれるもの
- デバイスの**製造元**によって追加されたもの
- 携帯電話プロバイダーによって追加されたもの（それらから購入した場合）

## ルート化

物理的なAndroidデバイスでルートアクセスを取得するには、通常、デバイスとバージョンに**特定の脆弱性を悪用**する必要があります。\
悪用が成功すると、通常、Linuxの `su` バイナリがユーザーのPATH環境変数で指定された場所（`/system/xbin`など）にコピーされます。

suバイナリが構成されると、別のAndroidアプリが `su` バイナリとのインターフェイスを使用して**ルートアクセスのリクエストを処理**します。例：**Superuser**や**SuperSU**（Google Playストアで利用可能）。

{% hint style="danger" %}
ルート化プロセスは非常に危険であり、デバイスに重大な損害を与える可能性があります
{% endhint %}

### ROM

**カスタムファームウェアをインストールしてOSを置き換える**ことができます。これにより、古いデバイスの有用性を拡張したり、ソフトウェアの制限をバイパスしたり、最新のAndroidコードにアクセスしたりすることができます。\
**OmniROM**と**LineageOS**は、最も人気のあるファームウェアの2つです。

デバイスをルート化する必要があるわけではないことに注意してください。**一部のメーカーは**、ブートローダーのアンロックを**十分に文書化された安全な方法**で許可しています。

### 影響

デバイスがルート化されると、任意のアプリがルートアクセスを要求できます。悪意のあるアプリがそれを取得した場合、ほとんどすべてにアクセスでき、電話を破損させることができます。

## Androidアプリケーションの基礎 <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Androidアプリケーションの形式は_APKファイル形式_と呼ばれます。基本的には**ZIPファイル**です（ファイル拡張子を .zip に変更することで、内容を抽出して表示できます）。
- APKの内容（完全ではありません）
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc：バイナリXMLなど、事前にコンパイルされたリソースが含まれています。
- res/xml/files\_paths.xml
- META-INF/
- ここに証明書があります！
- **classes.dex**
- デフォルトでアプリケーションが実行する、コンパイルされたJava（またはKotlin）コードを表すDalvikバイトコードが含まれています。
- lib/
- CPUアーキテクチャごとにサブディレクトリに分かれたネイティブライブラリが格納されています。
  - `armeabi`：ARMベースのプロセッサ用のコード
  - `armeabi-v7a`：ARMv7およびそれ以上のプロセッサ用のコード
  - `x86`：X86プロセッサ用のコード
  - `mips`：MIPSプロセッサ用のコードのみ
- assets/
- アプリに必要なその他のファイルを格納し、追加のネイティブライブラリやDEXファイルを含むことがあります。マルウェア作成者が追加のコードを隠すために使用することもあります。
- res/
- resources.arscにコンパイルされていないリソースが含まれています
### **Dalvik & Smali**

Android開発では、**JavaまたはKotlin**がアプリを作成するために使用されます。デスクトップアプリケーションとは異なり、Androidはこのコードを**Dalvik Executable (DEX) bytecode**にコンパイルします。以前はDalvik仮想マシンがこのバイトコードを処理していましたが、新しいAndroidバージョンではAndroid Runtime (ART)が引き継いでいます。

逆コンパイルには、**Smali**が重要になります。これはDEXバイトコードの人間が読めるバージョンであり、ソースコードをバイトコード命令に変換することでアセンブリ言語のように機能します。この文脈では、Smaliとbaksmaliはアセンブリと逆アセンブリのツールを指します。

## インテント

インテントは、Androidアプリがコンポーネント間や他のアプリと通信する主要な手段です。これらのメッセージオブジェクトは、HTTP通信でのGET/POSTリクエストのように、アプリ間やコンポーネント間でデータをやり取りすることもできます。

つまり、インテントは基本的に**コンポーネント間で渡されるメッセージ**です。インテントは特定のコンポーネントやアプリに**向けられることができ**、**特定の受信者なしに送信**することもできます。\
簡単に言うと、インテントは以下のように使用できます：

* 通常はアプリのユーザーインターフェースを開くためにActivityを開始するため
* システムやアプリに変更を通知するためのブロードキャストとして
* バックグラウンドサービスの開始、停止、および通信のため
* ContentProvidersを介してデータにアクセスするため
* イベントを処理するためのコールバックとして

脆弱性がある場合、**インテントはさまざまな攻撃に使用**される可能性があります。

### インテントフィルタ

**インテントフィルタ**は、**アクティビティ、サービス、またはブロードキャストレシーバが異なるタイプのインテントとやり取りする方法**を定義します。基本的に、これらのコンポーネントの機能を説明し、どのようなアクションを実行できるかや処理できるブロードキャストの種類などを示します。これらのフィルタを宣言する主な場所は**AndroidManifest.xmlファイル**ですが、ブロードキャストレシーバの場合はコーディングすることも選択肢です。

インテントフィルタは、カテゴリ、アクション、およびデータフィルタで構成され、追加のメタデータを含めることも可能です。この設定により、特定の基準に一致するインテントを処理できるようになります。

Androidコンポーネント（アクティビティ/サービス/コンテンツプロバイダ/ブロードキャストレシーバ）の重要な側面は、その可視性または**公開状態**です。コンポーネントは、マニフェストで**`exported`**属性を**`true`**に設定するか、そのためのインテントフィルタが宣言されている場合にのみ、他のアプリとやり取りできると見なされます。ただし、開発者がこれらのコンポーネントを意図せずに他のアプリとやり取りさせないようにする方法があります。これは、マニフェスト定義で**`exported`**属性を**`false`**に設定することで実現できます。

さらに、開発者はこれらのコンポーネントへのアクセスをさらに保護するために特定の権限を要求するオプションがあります。**`permission`**属性を設定して、指定された権限を持つアプリのみがコンポーネントにアクセスできるように強制することができ、誰がそれとやり取りできるかに対する追加のセキュリティと制御のレイヤーを追加します。
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### 暗黙的インテント

インテントは、Intentコンストラクタを使用してプログラムで作成されます：
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
**アクション**は以前に宣言されたインテントの**ACTION\_SEND**であり、**Extra**はmailto **Uri**です（Extraはインテントが期待している追加情報です）。

このインテントは、次の例のようにマニフェスト内で宣言する必要があります：
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
An intent-filter needs to match the **action**, **data** and **category** to receive a message.

The "Intent resolution" process determine which app should receive each message. This process considers the **priority attribute**, which can be set in the **intent-filter declaration**, and **the one with the higher priority will be selected**. This priority can be set between -1000 and 1000 and applications can use the `SYSTEM_HIGH_PRIORITY` value. If a **conflict** arises, a "choser" Window appears so the **user can decide**.

### Explicit Intents

An explicit intent specifies the class name it's targeting:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
他のアプリケーションで以前に宣言されたインテントにアクセスするには、次のようにします:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### ペンディングインテント

これにより、他のアプリケーションが**あなたのアプリケーションの代わりにアクションを実行**できます。ペンディングインテントを構築する際は、**インテントと実行するアクションを指定する必要があります**。**宣言されたインテントが明示的でない**場合（どのインテントが呼び出せるかを宣言していない場合）、**悪意のあるアプリケーションが被害者アプリの代わりに宣言されたアクションを実行**できます。さらに、**アクションが指定されていない場合**、悪意のあるアプリは**被害者の代わりに任意のアクションを実行**できます。

### ブロードキャストインテント

以前のインテントとは異なり、ブロードキャストインテントは**複数のアプリケーションに受信される**ことができます。ただし、APIバージョン14以降では、Intent.set Packageを使用して**メッセージを受信するアプリを指定**することが可能です。

また、ブロードキャストを送信する際に**パーミッションを指定することも可能**です。受信アプリはそのパーミッションを持っている必要があります。

ブロードキャストには**2つのタイプ**があります：**通常**（非同期）と**順序付け**（同期）。**順序**は**受信側の構成された優先度に基づいて**います。**各アプリはブロードキャストを処理、中継、または破棄できます**。

`Context`クラスから`sendBroadcast(intent, receiverPermission)`関数を使用して**ブロードキャストを送信**することが可能です。\
また、**`LocalBroadCastManager`**から**`sendBroadcast`**関数を使用すると、**メッセージがアプリを離れることはなくなります**。これを使用すると、受信コンポーネントをエクスポートする必要すらありません。

### スティッキーブロードキャスト

この種のブロードキャストは、**送信後も長い間アクセスできます**。\
これらはAPIレベル21で非推奨となり、**使用しないことが推奨**されています。\
**これにより、任意のアプリケーションがデータを嗅ぎ取るだけでなく、変更することも可能**です。

**`sendStickyBroadcast`**や**`sendStickyBroadcastAsUser`**など、"sticky"という単語を含む関数を見つけた場合は、**影響を確認し、削除を試みてください**。

## ディープリンク / URLスキーム

Androidアプリケーションでは、**ディープリンク**が使用され、URLを介して直接アクション（インテント）を開始します。これは、アクティビティ内で特定の**URLスキーム**を宣言することによって行われます。Androidデバイスがこのスキームを持つURLにアクセスしようとすると、アプリケーション内の指定されたアクティビティが起動されます。

スキームは**`AndroidManifest.xml`**ファイルに宣言する必要があります。
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
前の例からのスキームは `exampleapp://`（**`category BROWSABLE`** も参照）  

次に、データフィールドで **ホスト** と **パス** を指定できます：
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Web からアクセスするには、次のようにリンクを設定することができます:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
**アプリで実行されるコード**を見つけるには、ディープリンクで呼び出されるアクティビティに移動し、**`onNewIntent`** 関数を検索します。

[HTML ページを使用せずにディープリンクを呼び出す方法](./#exploiting-schemes-deep-links)を学びます。

## AIDL - Android Interface Definition Language

**Android Interface Definition Language (AIDL)** は、Android アプリケーション内のクライアントとサービス間のコミュニケーションを促進するために設計されています。別のプロセスのメモリに直接アクセスすることは Android では許可されていないため、AIDL はオブジェクトをオペレーティングシステムが理解する形式にマーシャリングして、異なるプロセス間での通信を容易にします。

### 主要な概念

- **バウンド サービス**: これらのサービスは IPC に AIDL を使用し、アクティビティやコンポーネントがサービスにバインドしてリクエストを行い、レスポンスを受け取ることができます。サービスのクラス内の `onBind` メソッドは、相互作用を開始するために重要であり、脆弱性を探すためのセキュリティレビューの重要な領域としてマークされています。

- **Messenger**: バウンド サービスとして動作する Messenger は、`onBind` メソッドを介してデータの処理に焦点を当てた IPC を可能にします。このメソッドを注意深く検査して、安全でないデータ処理や機密関数の実行がないかを確認することが重要です。

- **Binder**: AIDL の抽象化により Binder クラスの直接的な使用は一般的ではありませんが、Binder は異なるプロセスのメモリ空間間でのデータ転送を可能にするカーネルレベルのドライバとして機能します。さらなる理解のために、リソースが [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8) で利用可能です。

## コンポーネント

これには、**アクティビティ、サービス、ブロードキャスト レシーバー、プロバイダー**が含まれます。

### ランチャーアクティビティとその他のアクティビティ

Android アプリでは、**アクティビティ**は画面のようなもので、アプリのユーザーインターフェースの異なる部分を表示します。アプリには多くのアクティビティがあり、それぞれがユーザーに一意の画面を表示します。

**ランチャーアクティビティ**はアプリへのメインゲートウェイであり、アプリのアイコンをタップすると起動されます。これはアプリのマニフェストファイルで特定の MAIN および LAUNCHER インテントで定義されています。
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
## Android Applications Basics

いくつかのアプリには、バックグラウンドサービスのようにユーザーインターフェースを持たないものを含め、ランチャーアクティビティが必要ないものもあります。

アクティビティは、マニフェストで「exported」とマークすることで、他のアプリやプロセスで利用可能にすることができます。この設定により、他のアプリがこのアクティビティを起動できるようになります。
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
しかし、別のアプリからアクティビティにアクセスすることが常にセキュリティリスクとは限りません。懸念が生じるのは、機密データが適切に共有されていない場合であり、情報漏洩につながる可能性があります。

アクティビティのライフサイクルは、**`onCreate`** メソッドで始まり、UIの設定とアクティビティのユーザーとのやり取りの準備を行います。

### アプリケーションのサブクラス

Android開発では、アプリは[Application](https://developer.android.com/reference/android/app/Application)クラスの**サブクラス**を作成するオプションがありますが、これは必須ではありません。このようなサブクラスが定義されている場合、そのサブクラスがアプリ内で最初にインスタンス化されます。このサブクラスで実装されている場合、**`attachBaseContext`** メソッドは **`onCreate`** メソッドの前に実行されます。このセットアップにより、アプリケーションの残りの部分が開始される前に初期化を行うことができます。
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### サービス

[サービス](https://developer.android.com/guide/components/services)はユーザーインターフェースなしでタスクを実行できる**バックグラウンドオペレータ**です。これらのタスクは、ユーザーが異なるアプリケーションに切り替えても継続して実行されるため、サービスは**長時間実行される操作**にとって重要です。

サービスは多目的であり、さまざまな方法で開始できます。**インテント**は、サービスを起動するための主要な方法であり、アプリケーションのエントリーポイントとして機能します。サービスを`startService`メソッドを使用して開始すると、その`onStart`メソッドが実行され、`stopService`メソッドが明示的に呼び出されるまで実行を維持します。また、サービスの役割がアクティブなクライアント接続に依存する場合、`bindService`メソッドを使用してクライアントをサービスにバインドし、データの受け渡しに`onBind`メソッドを使用します。

サービスの興味深い応用例には、アプリとのやり取りを妨げることなく、バックグラウンドで音楽を再生したりネットワークデータを取得したりすることが含まれます。さらに、サービスは**エクスポート**を介して同じデバイス上の他のプロセスからアクセス可能にすることができます。これはデフォルトの動作ではなく、Android Manifestファイルで明示的に構成する必要があります。
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### ブロードキャストレシーバ

**ブロードキャストレシーバ**は、メッセージングシステムにおけるリスナーとして機能し、複数のアプリケーションがシステムからの同じメッセージに応答できるようにします。アプリは、**マニフェスト**を介してまたはアプリのコード内で **`registerReceiver`** API を使用して、**2つの主要な方法**で **レシーバを登録**できます。マニフェストでは、ブロードキャストは権限でフィルタリングされますが、動的に登録されたレシーバは登録時に権限を指定することもできます。

**インテントフィルタ**は、登録方法に関係なく重要であり、どのブロードキャストがレシーバをトリガーするかを決定します。一致するブロードキャストが送信されると、レシーバの **`onReceive`** メソッドが呼び出され、アプリは低電池アラートに応じて動作を調整するなど、適切に反応することができます。

ブロードキャストは、**非同期**であり、順不同ですべてのレシーバに到達するか、**同期**であり、優先順位に基づいてブロードキャストを受信するかのいずれかです。ただし、どのアプリも自身を優先してブロードキャストを傍受できる可能性があるため、潜在的なセキュリティリスクに注意することが重要です。

レシーバの機能を理解するには、そのクラス内の **`onReceive`** メソッドを探します。このメソッドのコードは受信したインテントを操作でき、特に **順序付けられたブロードキャスト**では、インテントを変更したり破棄したりする必要があるため、レシーバによるデータの検証が重要です。

### コンテンツプロバイダ

**コンテンツプロバイダ**は、アプリケーション間で **構造化されたデータを共有**するために不可欠であり、データセキュリティを確保するために **権限の実装**の重要性を強調しています。これにより、アプリはデータベース、ファイルシステム、またはウェブなど、さまざまなソースからデータにアクセスできます。`readPermission` および `writePermission` のような特定の権限は、アクセスを制御するために重要です。さらに、一時的なアクセスは、アプリのマニフェストで **`grantUriPermission`** 設定を介して付与でき、`path`、`pathPrefix`、`pathPattern` などの属性を活用して詳細なアクセス制御を行うことができます。

脆弱性（SQLインジェクションなど）を防ぐために、入力検証が極めて重要です。コンテンツプロバイダは、`insert()`、`update()`、`delete()`、`query()` などの基本操作をサポートし、データの操作とアプリケーション間での共有を容易にします。

**FileProvider** は、ファイルを安全に共有することに焦点を当てた特殊なコンテンツプロバイダです。フォルダへのアクセスを制御するための特定の属性を持つアプリのマニフェストで定義され、`android:exported` および `android:resource` がフォルダ構成を指すようになっています。機密データが誤って公開されるのを避けるために、ディレクトリを共有する際には注意が必要です。

FileProvider の例示的なマニフェスト宣言：
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
そして、`filepaths.xml` で共有フォルダを指定する例:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
- [Android Developers: Content Providers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android Developers: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViewsはAndroidアプリ内でWebコンテンツを取得する**ミニウェブブラウザ**のようなものです。Webからまたはローカルファイルからコンテンツを取得します。通常のブラウザと同様のリスクに直面しますが、特定の**設定**を通じてこれらのリスクを**軽減**する方法があります。

Androidには2つの主要なWebViewタイプがあります：

- **WebViewClient**は基本的なHTMLに適していますが、JavaScriptのalert関数をサポートしておらず、XSS攻撃のテスト方法に影響を与えます。
- **WebChromeClient**は完全なChromeブラウザのエクスペリエンスに近い動作をします。

重要なポイントは、WebViewブラウザはデバイスのメインブラウザと**クッキーを共有しない**ことです。

コンテンツの読み込みには、````loadUrl````, ````loadData````, ````loadDataWithBaseURL````などのメソッドが利用できます。これらのURLやファイルが**安全に使用される**ことを確認することが重要です。セキュリティ設定は````WebSettings````クラスを介して管理できます。たとえば、````setJavaScriptEnabled(false)````でJavaScriptを無効にすると、XSS攻撃を防ぐことができます。

JavaScriptの「Bridge」を使用すると、JavaオブジェクトがJavaScriptとやり取りでき、セキュリティを確保するためにAndroid 4.2以降ではメソッドに````@JavascriptInterface````を付ける必要があります。

コンテンツアクセスを許可する（````setAllowContentAccess(true)````）と、WebViewsがContent Providersにアクセスできるようになりますが、コンテンツのURLが安全であることが確認されていない限り、リスクが生じる可能性があります。

ファイルアクセスを制御するには：
- ファイルアクセスを無効にする（````setAllowFileAccess(false)````）と、ファイルシステムへのアクセスが制限され、特定のアセットには例外があり、それらが機密性の高いコンテンツにのみ使用されることが保証されます。

## その他のアプリコンポーネントとモバイルデバイス管理

### **アプリケーションのデジタル署名**

- Androidアプリには**デジタル署名**が必要で、インストール前に**正当に作成された**ことを保証します。このプロセスではアプリ識別のために証明書が使用され、インストール時にデバイスのパッケージマネージャによって検証される必要があります。アプリは**自己署名されるか外部CAによって認証**され、未承認のアクセスから保護され、配信中にアプリが改ざんされないようにします。

### **セキュリティ強化のためのアプリ検証**

- **Android 4.2**から、**Verify Apps**という機能があり、ユーザーがインストール前にアプリの安全性をチェックできます。この**検証プロセス**により、ユーザーに潜在的に有害なアプリについて警告したり、特に悪意のあるアプリのインストールを防止したりすることができ、ユーザーセキュリティが向上します。

### **モバイルデバイス管理（MDM）**

- **MDMソリューション**は**デバイス管理API**を介してモバイルデバイスの**監視とセキュリティ**を提供します。モバイルデバイスを効果的に管理および保護するためにAndroidアプリのインストールが必要です。主な機能には**パスワードポリシーの強制**、**ストレージ暗号化の義務付け**、**リモートデータ消去の許可**が含まれ、モバイルデバイスに対する包括的な制御とセキュリティが確保されます。
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
**Try Hard Security Group**

<figure><img src="../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）を使用して、ゼロからヒーローまでAWSハッキングを学ぶ</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)で**フォロー**する
* **HackTricks**および**HackTricks Cloud**のgithubリポジトリにPRを提出して、**ハッキングトリックを共有**する

</details>
