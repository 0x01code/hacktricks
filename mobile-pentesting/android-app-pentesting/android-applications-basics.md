# Fundamentos de Aplicaciones Android

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* Consigue el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Sigue a HackenProof**](https://bit.ly/3xrrDrL) **para aprender m√°s sobre errores web3**

üêû Lee tutoriales sobre errores web3

üîî Recibe notificaciones sobre nuevos programas de recompensas por errores

üí¨ Participa en discusiones comunitarias

## Modelo de Seguridad de Android

**Hay dos capas:**

* El **SO**, que mantiene las aplicaciones instaladas aisladas entre s√≠.
* La **aplicaci√≥n en s√≠**, que permite a los desarrolladores **exponer ciertas funcionalidades** y configurar las capacidades de la aplicaci√≥n.

### Separaci√≥n de UID

**A cada aplicaci√≥n se le asigna un ID de usuario espec√≠fico**. Esto se hace durante la instalaci√≥n de la aplicaci√≥n para que la aplicaci√≥n solo pueda interactuar con archivos propiedad de su ID de usuario o archivos compartidos. Por lo tanto, solo la aplicaci√≥n en s√≠, ciertos componentes del SO y el usuario root pueden acceder a los datos de las aplicaciones.

### Compartici√≥n de UID

**Dos aplicaciones pueden configurarse para usar el mismo UID**. Esto puede ser √∫til para compartir informaci√≥n, pero si una de ellas es comprometida, los datos de ambas aplicaciones ser√°n comprometidos. Por eso este comportamiento est√° **desaconsejado**.\
**Para compartir el mismo UID, las aplicaciones deben definir el mismo valor `android:sharedUserId` en sus manifiestos.**

### Aislamiento

El **Sandbox de Aplicaciones de Android** permite ejecutar **cada aplicaci√≥n** como un **proceso separado bajo un ID de usuario separado**. Cada proceso tiene su propia m√°quina virtual, por lo que el c√≥digo de una aplicaci√≥n se ejecuta en aislamiento de otras aplicaciones.\
A partir de Android 5.0(L), se aplica **SELinux**. B√°sicamente, SELinux deniega todas las interacciones de procesos y luego crea pol√≠ticas para **permitir solo las interacciones esperadas entre ellos**.

### Permisos

Cuando se instala una **aplicaci√≥n y solicita permisos**, la aplicaci√≥n est√° solicitando los permisos configurados en los elementos **`uses-permission`** en el archivo **AndroidManifest.xml**. El elemento **uses-permission** indica el nombre del permiso solicitado dentro del **atributo name**. Tambi√©n tiene el atributo **maxSdkVersion** que deja de solicitar permisos en versiones superiores a la especificada.\
Tenga en cuenta que las aplicaciones de Android no necesitan solicitar todos los permisos al principio, tambi√©n pueden **solicitar permisos din√°micamente** pero todos los permisos deben ser **declarados** en el **manifiesto**.

Cuando una aplicaci√≥n expone funcionalidad, puede limitar el **acceso solo a aplicaciones que tengan un permiso especificado**.\
Un elemento de permiso tiene tres atributos:

* El **nombre** del permiso
* El atributo **permission-group**, que permite agrupar permisos relacionados.
* El **nivel de protecci√≥n** que indica c√≥mo se otorgan los permisos. Hay cuatro tipos:
  * **Normal**: Se utiliza cuando no hay **amenazas conocidas** para la aplicaci√≥n. El usuario **no est√° obligado a aprobarlo**.
  * **Peligroso**: Indica que el permiso ot
### Filtro de Intenciones

Un filtro de intenciones especifica los **tipos de Intenciones a los que una actividad, servicio o receptor de difusi√≥n puede responder**. Especifica lo que una actividad o servicio puede hacer y qu√© tipos de difusiones un receptor puede manejar. Permite que el componente correspondiente reciba Intenciones del tipo declarado. Los filtros de intenciones se definen t√≠picamente a trav√©s del archivo AndroidManifest.xml. Para el **Receptor de difusi√≥n** tambi√©n es posible definirlos en **c√≥digo**. Un filtro de intenciones se define por su categor√≠a, acci√≥n y filtros de datos. Tambi√©n puede contener metadatos adicionales.

En Android, una actividad/servicio/proveedor de contenido/receptor de difusi√≥n es **p√∫blico** cuando **`exported`** se establece en **`true`**, pero un componente tambi√©n es **p√∫blico** si el **manifiesto especifica un filtro de intenciones** para √©l. Sin embargo, los desarrolladores pueden **hacer expl√≠citamente privados los componentes** (independientemente de cualquier filtro de intenciones) estableciendo el atributo **`exported`** en **`false`** para cada componente en el archivo de manifiesto. Los desarrolladores tambi√©n pueden establecer el atributo **`permission`** para **requerir un cierto permiso para acceder** al componente, restringiendo as√≠ el acceso al componente.

### Intenciones impl√≠citas

Las intenciones se crean program√°ticamente utilizando un constructor de Intenciones:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
La **Acci√≥n** del intent previamente declarado es **ACTION\_SEND** y el **Extra** es un **Uri** de correo electr√≥nico (el Extra es la informaci√≥n adicional que el intent espera).

Este intent debe ser declarado dentro del manifiesto como en el siguiente ejemplo:
```markup
<activity android:name="ShareActivity">
	<intent-filter>
       <action android:name="android.intent.action.SEND" />
       <category android:name="android.intent.category.DEFAULT" />
    </intent-filter>
</activity>
```
Un intent-filter necesita coincidir con la **acci√≥n**, **datos** y **categor√≠a** para recibir un mensaje.

El proceso de "resoluci√≥n de intenciones" determina qu√© aplicaci√≥n debe recibir cada mensaje. Este proceso considera el atributo de **prioridad**, que se puede establecer en la declaraci√≥n del **intent-filter**, y **se seleccionar√° el que tenga la prioridad m√°s alta**. Esta prioridad se puede establecer entre -1000 y 1000 y las aplicaciones pueden usar el valor `SYSTEM_HIGH_PRIORITY`. Si surge un **conflicto**, aparece una ventana de "selector" para que **el usuario pueda decidir**.

### Intenciones expl√≠citas

Una intenci√≥n expl√≠cita especifica el nombre de la clase a la que se dirige:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
En otras aplicaciones, para acceder al intent previamente declarado, se puede utilizar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Intenciones pendientes

Estas permiten que otras aplicaciones **realicen acciones en nombre de tu aplicaci√≥n**, utilizando la identidad y permisos de tu aplicaci√≥n. Al construir una intenci√≥n pendiente, se debe **especificar una intenci√≥n y la acci√≥n a realizar**. Si la **intenci√≥n declarada no es expl√≠cita** (no declara qu√© intenci√≥n puede llamarla), una **aplicaci√≥n maliciosa podr√≠a realizar la acci√≥n declarada** en nombre de la aplicaci√≥n v√≠ctima. Adem√°s, **si no se especifica una acci√≥n**, la aplicaci√≥n maliciosa podr√° hacer **cualquier acci√≥n en nombre de la v√≠ctima**.

### Intenciones de difusi√≥n

A diferencia de las intenciones anteriores, que solo son recibidas por una aplicaci√≥n, las intenciones de difusi√≥n **pueden ser recibidas por m√∫ltiples aplicaciones**. Sin embargo, a partir de la versi√≥n API 14, es **posible especificar la aplicaci√≥n que debe recibir** el mensaje utilizando Intent.set Package.

Alternativamente, tambi√©n es posible **especificar un permiso al enviar la difusi√≥n**. La aplicaci√≥n receptora necesitar√° tener ese permiso.

Hay **dos tipos** de difusiones: **Normales** (asincr√≥nicas) y **Ordenadas** (sincr√≥nicas). El **orden** se basa en la **prioridad configurada dentro del receptor**. **Cada aplicaci√≥n puede procesar, retransmitir o descartar la difusi√≥n.**

Es posible **enviar** una **difusi√≥n** utilizando la funci√≥n \*\*`sendBroadcast(intent, receiverPermission)` \*\* de la clase `Context`.\
Tambi√©n se puede utilizar la funci√≥n **`sendBroadcast`** del **`LocalBroadCastManager`** que asegura que el **mensaje nunca abandone la aplicaci√≥n**. Usando esto, ni siquiera necesitar√°s exportar un componente receptor.

### Difusiones pegajosas

Este tipo de difusiones **pueden ser accedidas mucho despu√©s de haber sido enviadas**.\
Estas fueron obsoletas en el nivel de API 21 y se recomienda **no usarlas**.\
**Permiten que cualquier aplicaci√≥n husmee en los datos, pero tambi√©n los modifique.**

Si encuentras funciones que contienen la palabra "pegajoso" como **`sendStickyBroadcast`** o **`sendStickyBroadcastAsUser`**, **verifica el impacto e intenta eliminarlas**.

## Enlaces profundos / Esquemas de URL

**Los enlaces profundos permiten activar una intenci√≥n a trav√©s de una URL**. Una aplicaci√≥n puede declarar un **esquema de URL** dentro de una actividad para que cada vez que el dispositivo Android intente **acceder a una direcci√≥n utilizando ese esquema**, se llame a la actividad de la aplicaci√≥n:

![](<../../.gitbook/assets/image (214).png>)

En este caso, el esquema es `myapp://` (tambi√©n se observa la **`categor√≠a BROWSABLE`**)

Si dentro del `intent-filter` encuentras algo como esto:

![](<../../.gitbook/assets/image (263).png>)

Entonces, est√° esperando algo como `http://www.example.com/gizmos`

Si encuentras algo como esto:

![](<../../.gitbook/assets/image (262).png>)

Significar√° que est√° esperando una URL que comience por `example://gizmos`\
En este caso, podr√≠as intentar abusar de la funcionalidad creando una web con las siguientes cargas √∫tiles. Intentar√° navegar a p√°ginas arbitrarias e intentar√° ejecutar JS:
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Para encontrar el **c√≥digo que se ejecutar√° en la aplicaci√≥n**, vaya a la actividad llamada por el enlace profundo y busque la funci√≥n **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Aprenda c√≥mo [llamar enlaces profundos sin usar p√°ginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Lenguaje de Definici√≥n de Interfaces de Android

El **Lenguaje de Definici√≥n de Interfaces de Android** (AIDL) le permite definir la interfaz de programaci√≥n en la que tanto el cliente como el servicio acuerdan para **comunicarse entre s√≠ utilizando la comunicaci√≥n entre procesos** (IPC). En Android, **un proceso normalmente no puede acceder a la memoria de otro proceso**. Por lo tanto, para hablar, necesitan descomponer sus objetos en primitivas que el **sistema operativo** pueda entender y pasar los objetos a trav√©s de esa barrera para usted. El c√≥digo para hacer esa transmisi√≥n es tedioso de escribir, por lo que Android lo maneja por usted con AIDL.

Los servicios que utilizan AIDL se denominan **Servicios vinculados**. En la clase del servicio encontrar√° el m√©todo **`onBind`**. Aqu√≠ es **donde comienza la interacci√≥n**, por lo que es la parte inicial del c√≥digo a revisar en busca de posibles vulnerabilidades.

Un servicio vinculado es el servidor en una interfaz cliente-servidor. **Permite que los componentes (como las actividades) se vinculen al servicio, env√≠en solicitudes, reciban respuestas y realicen comunicaci√≥n entre procesos** (IPC). Un servicio vinculado normalmente vive solo mientras sirve a otro componente de la aplicaci√≥n y no se ejecuta en segundo plano indefinidamente.

### Messenger

Un Messenger es otro tipo de mecanismo IPC. Dado que el **Messenger tambi√©n es un "Servicio vinculado"**, los datos que se pasan desde la aplicaci√≥n cliente tambi√©n se procesan a trav√©s del m√©todo `onBind`. Por lo tanto, la revisi√≥n del c√≥digo debe comenzar en este m√©todo y debe buscar la invocaci√≥n de funcionalidades sensibles o el manejo inseguro de datos.

### Binder

Es extra√±o encontrar una clase Binder invocada directamente, ya que es mucho m√°s f√°cil usar AIDL (que abstrae la clase Binder). Sin embargo, es bueno saber que **Binder es un controlador de nivel de kernel que mueve datos de la memoria de un proceso a la de otro** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Componentes

Estos incluyen: **Actividades, Servicios, Receptores de difusi√≥n y Proveedores.**

### Actividad de lanzamiento y otras actividades

Una **actividad de Android** es una pantalla de la interfaz de usuario de la aplicaci√≥n de **Android**. De esa manera, una **actividad de Android** es muy similar a las ventanas en una aplicaci√≥n de escritorio. Una aplicaci√≥n de **Android** puede contener una o m√°s actividades, lo que significa una o m√°s pantallas.

La **actividad de lanzamiento** es lo que la mayor√≠a de las personas piensan como el **punto de entrada** a una aplicaci√≥n de Android. La actividad de lanzamiento es la actividad que se inicia cuando un usuario hace clic en el icono de una aplicaci√≥n. Puede determinar la actividad de lanzamiento mirando el manifiesto de la aplicaci√≥n. La actividad de lanzamiento tendr√° las siguientes intenciones MAIN y LAUNCHER listadas.

Tenga en cuenta que no todas las aplicaciones tendr√°n una actividad de lanzamiento, especialmente las aplicaciones sin una interfaz de usuario. Ejemplos de aplicaciones sin una interfaz de usuario (y por lo tanto sin una actividad de lanzamiento) son las aplicaciones preinstaladas que realizan servicios en segundo plano, como el correo de voz.
```markup
<activity android:name=".LauncherActivity">
	<intent-filter>
    	<action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
```
Las actividades pueden ser exportadas permitiendo que otros procesos en el dispositivo inicien la actividad. Por defecto, no est√°n exportadas pero se pueden exportar estableciendo:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Ten en cuenta que la capacidad de **saltarse las protecciones de actividad no siempre es una vulnerabilidad**, debes comprobar a qu√© datos has obtenido acceso. Adem√°s, **algunas actividades devuelven datos a un llamador**. En estos escenarios, debes buscar el m√©todo **`setResult`** y comprobar los datos que se pasan al par√°metro Intent. Si son datos sensibles, puede haber una vulnerabilidad de fuga de informaci√≥n y es explotable con aplicaciones capaces de comunicarse con la actividad.

**El c√≥digo de una actividad comienza con el m√©todo `onCreate`.**

### Subclase de aplicaci√≥n

Las aplicaciones de Android pueden definir una **subclase** de [Application](https://developer.android.com/reference/android/app/Application). Las aplicaciones pueden, pero no tienen que definir una subclase personalizada de Application. Si una aplicaci√≥n de Android define una subclase de Application, **esta clase se instancia antes que cualquier otra clase en la aplicaci√≥n**.

Si se define el m√©todo **`attachBaseContext`** en la subclase de Application, se llama primero, antes del m√©todo **`onCreate`**.

### Servicios

[Los servicios](https://developer.android.com/guide/components/services) **se ejecutan en segundo plano sin una interfaz de usuario**. Se utilizan para realizar **procesos de larga duraci√≥n, incluso si el usuario comienza a usar una aplicaci√≥n diferente**.

Hay una gran cantidad de formas en que se pueden iniciar y, por lo tanto, son un punto de entrada para las aplicaciones. La forma predeterminada en que un servicio puede iniciarse como punto de entrada a una aplicaci√≥n es a trav√©s de **Intents**.

Cuando se llama al m√©todo **`startService`** para iniciar un servicio, se ejecuta el m√©todo **`onStart`** en el servicio. Se ejecutar√° indefinidamente hasta que se llame al m√©todo **`stopService`**. Si el servicio solo se necesita mientras el cliente est√° conectado, el cliente debe "vincularse" a √©l utilizando el m√©todo **`bindService`**.

Para un **servicio vinculado** (ver secci√≥n anterior), los datos se pasar√°n al m√©todo **`onBind`**.

Por ejemplo, un servicio podr√≠a reproducir m√∫sica en segundo plano mientras el usuario est√° en una aplicaci√≥n diferente, o podr√≠a recuperar datos a trav√©s de la red sin bloquear la interacci√≥n del usuario con una actividad.

Un **servicio puede ser exportado, lo que permite que otros procesos en el dispositivo inicien el servicio**. Por defecto, los servicios no se exportan, pero se pueden configurar en el Manifiesto:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Receptores de difusi√≥n

Las difusiones se pueden considerar como un sistema de mensajer√≠a y los **receptores de difusi√≥n son los oyentes**. Si una aplicaci√≥n ha registrado un receptor para una difusi√≥n espec√≠fica, el c√≥digo en ese receptor se ejecuta cuando el sistema env√≠a la difusi√≥n. Tenga en cuenta que en este caso **varias aplicaciones pueden recibir el mismo mensaje**.

Hay **2 formas** en que una aplicaci√≥n puede **registrar un receptor**: en el **Manifiesto de la aplicaci√≥n o registrado din√°micamente** en el c√≥digo de la aplicaci√≥n utilizando la llamada de API **`registerReceiver`**. En el manifiesto, puede limitar las difusiones que acepta a trav√©s del **uso de permisos dentro del elemento receptor**. Cuando se define din√°micamente, puede **pasar el permiso al m√©todo `registerReceiver`**.

En ambos casos, para registrar el receptor, se establecen los **filtros de intenci√≥n para el receptor**. Estos filtros de intenci√≥n son las difusiones que deben activar el receptor.

Cuando se env√≠an las difusiones espec√≠ficas para las que se ha registrado el receptor, se **ejecuta** el m√©todo **`onReceive`** en la clase BroadcastReceiver.

Una aplicaci√≥n puede registrar un receptor para el mensaje de bater√≠a baja, por ejemplo, y cambiar su comportamiento en funci√≥n de esa informaci√≥n.

La difusi√≥n puede ser **asincr√≥nica** (cada receptor la recibe) o **sincr√≥nica** (la difusi√≥n se recibe de manera ordenada seg√∫n la prioridad establecida para recibirla).

{% hint style="danger" %}
**Tenga en cuenta que cualquier aplicaci√≥n puede establecerse como la m√°xima prioridad para recibir una difusi√≥n.**
{% endhint %}

Para **examinar** el **c√≥digo** implementado en un receptor de difusi√≥n, debe buscar el m√©todo **`onReceive`** de la clase del receptor.\
Tenga en cuenta que las **difusiones ordenadas pueden descartar la intenci√≥n recibida o incluso modificarla** utilizando uno de los m√©todos setter. Por lo tanto, los **receptores deben validar los datos**.

### Proveedor de contenido

Los proveedores de contenido son la forma en que las **aplicaciones comparten datos estructurados**, como bases de datos relacionales. Por lo tanto, es muy importante usar **permisos** y establecer el nivel de protecci√≥n adecuado para protegerlos.\
Los proveedores de contenido pueden usar los atributos **`readPermission`** y **`writePermission`** para especificar qu√© permisos debe tener una aplicaci√≥n. **Estos permisos tienen prioridad sobre el atributo de permiso**.\
Adem√°s, tambi√©n pueden **permitir excepciones temporales** estableciendo **`grantUriPermission`** en verdadero y luego configurando los par√°metros apropiados en el elemento **`grant-uri-permission`** dentro del elemento proveedor dentro del archivo de manifiesto.

El **`grant-uri-permission`** tiene tres atributos: path, pathPrefix y pathPattern:

* **path**: Permite especificar la ruta completa para excluir
* **pathPrefix**: Permite especificar el comienzo de la ruta
* **pathPattern**: Permite el uso de comodines y reemplazos simb√≥licos para obtener un control m√°s granular.

Es **importante validar y sanear la entrada recibida** para evitar posibles vulnerabilidades como la inyecci√≥n SQL.

**Caracter√≠sticas del proveedor de contenido:**

* El componente del proveedor de contenido suministra datos de una aplicaci√≥n a otras a petici√≥n.
* Puede almacenar los datos en el sistema de archivos, una base de datos SQLite, en la web o en cualquier otra ubicaci√≥n de almacenamiento persistente a la que su aplicaci√≥n pueda acceder.
* A trav√©s del proveedor de contenido, otras aplicaciones pueden consultar o incluso modificar los datos (si el proveedor de contenido lo permite).
* El proveedor de contenido es √∫til en casos en los que una aplicaci√≥n desea compartir datos con otra aplicaci√≥n.
* Es muy similar a las bases de datos y tiene cuatro m√©todos.
  * insert()
  * update()
  * delete()
  * query()

**FileProvider**

Este es un tipo de proveedor de contenido que **compartir√° archivos** desde una carpeta. Puede declarar un proveedor de archivos de esta manera:
```markup
<provider android:name="androidx.core.content.FileProvider"
            android:authorities="com.example.myapp.fileprovider"
            android:grantUriPermissions="true" android:exported="false">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/filepaths" />
</provider>
```
Ten en cuenta el atributo **`android:exported`** porque si es **`true`** las aplicaciones externas podr√°n acceder a las carpetas compartidas.\
Ten en cuenta que la configuraci√≥n `android:resource="@xml/filepaths"` indica que el archivo _res/xml/filepaths.xml_ contiene la configuraci√≥n de **qu√© carpetas** este **FileProvider** va a **compartir**. Este es un ejemplo de c√≥mo indicar que se comparta una carpeta en ese archivo:
```markup
<paths>
    <files-path path="images/" name="myimages" />
</paths>
```
Compartir algo como **`path="."`** podr√≠a ser **peligroso** incluso si el proveedor no est√° exportado si hay otra vulnerabilidad en alguna parte del c√≥digo que intent√≥ acceder a este proveedor.\
Podr√≠as **acceder** a una **imagen** dentro de esa carpeta con `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

El elemento `<paths>` puede tener varios hijos, cada uno especificando un directorio diferente para compartir. Adem√°s del elemento **`<files-path>`**, puedes usar el elemento **`<external-path>`** para compartir directorios en el **almacenamiento externo**, y el elemento **`<cache-path>`** para compartir directorios en tu **directorio de cach√© interno**.\
[Para obtener m√°s informaci√≥n sobre los atributos espec√≠ficos de los proveedores de archivos, ve aqu√≠.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[M√°s informaci√≥n sobre FileProviders aqu√≠](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

Los WebViews son efectivamente **navegadores web** integrados en aplicaciones de Android.\
El contenido de los WebViews puede ser extra√≠do de sitios remotos o pueden ser archivos incluidos en la aplicaci√≥n.\
Los WebViews son **vulnerables a las mismas vulnerabilidades que afectan a cualquier navegador web**. Sin embargo, hay algunas **configuraciones** que pueden ser √∫tiles para **limitar** la **superficie de ataque**.

Hay dos tipos de WebViews en Android:

* El **WebViewClient**, m√°s adecuado para la representaci√≥n de HTML simple. Esto no ejecutar√° la funci√≥n de alerta JS. Por lo tanto, las pruebas XSS que utilizan esa funci√≥n ser√°n inv√°lidas.
* El **cliente WebChrome**, es un navegador Chrome.

Tenga en cuenta que **los navegadores WebView no tienen acceso a las cookies del navegador nativo**.

Para cargar una URL o archivo, es posible utilizar las funciones **`loadUrl`**, **`loadData`** o **`loadDataWithBaseURL`**. **Es importante acceder s√≥lo a URLs sanitizadas.**\
La seguridad de WebView se puede configurar a trav√©s del objeto **`WebSettings`**.\
Por ejemplo, la ejecuci√≥n de c√≥digo JS se puede desactivar utilizando el m√©todo **`setJavaScriptEnabled`** con el valor **`false`**. Esto **eliminar√°** la posibilidad de una vulnerabilidad de **XSS** y otras vulnerabilidades relacionadas con JS.

La funcionalidad de JavaScript "**Bridge**" **inyecta objetos Java en un WebView haci√©ndolos accesibles a JS**. A partir de Android 4.2, los m√©todos deben estar anotados con **`@JavascriptInterface`** para que sean accesibles desde JavaScript.

Si se pasa **`true`** a **`setAllowContentAccess`**, **los WebViews podr√°n acceder a los Proveedores de Contenido** a trav√©s del esquema **`content://`**. Esto obviamente plantea un riesgo de seguridad. Tenga en cuenta que si se da este acceso, es muy importante **asegurarse** de que la URL **`content://`** es **segura**.

Por defecto, los archivos locales pueden ser accedidos por los WebViews a trav√©s de las URLs file://, pero hay varias formas de evitar este comportamiento:

* Pasando **`false`** a **`setAllowFileAccess`**, se evita el acceso al sistema de archivos con la excepci√≥n de los activos a trav√©s de `file:///android_asset` _y_ `file:///android_res`. Estas rutas deben ser utilizadas s√≥lo para datos no sensibles (como im√°genes), por lo que esto deber√≠a ser seguro.
* El m√©todo **`setAllowFileAccess`** indica si una ruta de una URL `file://` debe ser capaz de acceder al contenido de otras URLs de esquema de archivo.
* El m√©todo **`setAllowUniversalAccessFromFileURLs`** indica si una ruta de una URL `file://` debe ser capaz de acceder al contenido de cualquier origen.

## Otros componentes de la aplicaci√≥n

### **Firma de la aplicaci√≥n**

* Android requiere que **todas las aplicaciones est√©n firmadas digitalmente con un certificado** antes de que puedan ser instaladas. Android utiliza este certificado para identificar al autor de una aplicaci√≥n.
* Para ejecutar la aplicaci√≥n en el dispositivo, debe estar firmada. Cuando se instala la aplicaci√≥n en un dispositivo, el **administrador de paquetes verifica** si la aplicaci√≥n ha sido correctamente firmada con el certificado del archivo apk o no.
* La aplicaci√≥n puede ser auto-firmada o puede ser firmada a trav√©s de una CA.
* La firma de la aplicaci√≥n asegura que una aplicaci√≥n no pueda acceder a ninguna otra aplicaci√≥n excepto a trav√©s de IPC bien definidos y tambi√©n que se pase sin modificaciones al dispositivo.

### **Verificaci√≥n de la aplicaci√≥n**

* Android 4.2 y posteriores admiten la verificaci√≥n de aplicaciones. Los usuarios pueden optar por habilitar "Verificar aplicaciones" y hacer que las aplicaciones sean evaluadas por un verificador de aplicaciones antes de la instalaci√≥n.
* La verificaci√≥n de la aplicaci√≥n puede alertar al usuario si intenta instalar una aplicaci√≥n que podr√≠a ser perjudicial; si una aplicaci√≥n es especialmente mala, puede bloquear la instalaci√≥n.

## Gesti√≥n de dispositivos m√≥viles

MDM o Mobile Device Management son suites de software que se utilizan para **asegurar un control y requisitos de seguridad** sobre los dispositivos m√≥viles. Estas suites utilizan las caracter√≠sticas referidas como API de administraci√≥n de dispositivos y requieren que se instale una aplicaci√≥n de Android.

Generalmente, las soluciones de MDM realizan funciones como la imposici√≥n de pol√≠ticas de contrase√±as, la obligaci√≥n de cifrar el almacenamiento y la posibilidad de borrar los datos del dispositivo de forma remota.

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Sigue a HackenProof**](https://bit.ly/3xrrDrL) **para aprender m√°s sobre errores web3**

üêû Lee tutoriales de errores web3

üîî Recibe notificaciones sobre nuevos programas de recompensas por errores

üí¨ Participa en discusiones comunitarias

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* Consigue el [**swag oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
