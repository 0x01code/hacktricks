# Android Aansoek Basiese Beginsels

<details>

<summary><strong>Leer AWS hakwerk van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** 💬 [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hakwerktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Android Sekuriteitsmodel

**Daar is twee lae:**

* Die **OS**, wat geïnstalleerde aansoeke geïsoleer hou van mekaar.
* Die **aansoek self**, wat ontwikkelaars toelaat om **sekere funksionaliteite bloot te stel** en aansoekvermoëns te konfigureer.

### UID Skeiding

**Elke aansoek word 'n spesifieke Gebruikers-ID toegewys**. Dit word gedoen tydens die installasie van die aansoek sodat **die aansoek slegs met lêers wat deur sy Gebruikers-ID besit word of gedeel word**, kan interaksie hê. Daarom kan slegs die aansoek self, sekere komponente van die OS en die root-gebruiker toegang tot die aansoek se data hê.

### UID Deling

**Twee aansoeke kan gekonfigureer word om dieselfde UID te gebruik**. Dit kan nuttig wees om inligting te deel, maar as een van hulle gekompromitteer word, sal die data van beide aansoeke gekompromitteer word. Dit is waarom hierdie gedrag **ontmoedig** word.\
**Om dieselfde UID te deel, moet aansoeke dieselfde `android:sharedUserId`-waarde in hul manifeste definieer.**

### Sandboxing

Die **Android Aansoek Sandboks** maak dit moontlik om **elke aansoek** as 'n **afsonderlike proses onder 'n afsonderlike gebruikers-ID** te laat loop. Elke proses het sy eie virtuele masjien, sodat 'n aansoek se kode in isolasie van ander aansoeke loop.\
Van Android 5.0(L) af word **SELinux** afgedwing. Basies het SELinux alle prosesinteraksies ontken en daarna beleid geskep om **slegs die verwagte interaksies tussen hulle toe te laat**.

### Toestemmings

Wanneer jy 'n **aansoek installeer en dit om toestemmings vra**, vra die aansoek vir die toestemmings wat in die **`uses-permission`** elemente in die **AndroidManifest.xml** lêer gekonfigureer is. Die **uses-permission** element dui die naam van die versoekte toestemming binne die **naam** **eienskap** aan. Dit het ook die **maxSdkVersion** eienskap wat ophou om toestemmings te vra op weergawes hoër as die gespesifiseerde een.\
Let daarop dat Android-aansoeke nie al die toestemmings aan die begin hoef te vra nie, hulle kan ook **toestemmings dinamies vra** maar al die toestemmings moet in die **manifest** **verklaar** word.

Wanneer 'n aansoek funksionaliteit blootstel, kan dit die **toegang beperk tot slegs aansoeke wat 'n spesifieke toestemming het**.\
'n Toestemmings-element het drie eienskappe:

* Die **naam** van die toestemming
* Die **permission-group** eienskap, wat toelaat om verwante toestemmings te groepeer.
* Die **beskermingsvlak** wat aandui hoe die toestemmings verleen word. Daar is vier tipes:
* **Normaal**: Gebruik wanneer daar **geen bekende bedreigings** vir die aansoek is nie. Die gebruiker hoef dit **nie goed te keur** nie.
* **Gevaarlik**: Dui aan dat die toestemming die versoekende aansoek 'n sekere **verhoogde toegang** gee. **Gebruikers word versoek om dit goed te keur**.
* **Handtekening**: Slegs **aansoeke wat deur dieselfde sertifikaat as die een** wat die komponent uitvoer, onderteken is, kan toestemming kry. Dit is die sterkste tipe beskerming.
* **HandtekeningOfStelsel**: Slegs **aansoeke wat deur dieselfde sertifikaat as die een** wat die komponent uitvoer onderteken is, of **aansoeke wat met stelselvlaktoegang hardloop**, kan toestemmings kry

## Vooraf Geïnstalleerde Aansoeke

Hierdie aansoeke word gewoonlik in die **`/system/app`** of **`/system/priv-app`** gids gevind en sommige van hulle is **geoptimeer** (jy mag nie eens die `classes.dex` lêer vind nie). Hierdie aansoeke is die moeite werd om te ondersoek omdat hulle soms met te veel toestemmings hardloop (as root).

* Diegene wat saam met die **AOSP** (Android OpenSource Project) **ROM** versend word
* Bygevoeg deur die toestel **vervaardiger**
* Bygevoeg deur die selfoonverskaffer (as dit by hulle gekoop is)

## Rooting

Om worteltoegang tot 'n fisiese Android-toestel te verkry, moet jy gewoonlik 1 of 2 **kwesbaarhede uitbuit** wat gewoonlik **spesifiek** vir die **toestel** en **weergawe** is.\
Sodra die uitbuiting gewerk het, word die Linux `su` binêre gewoonlik gekopieer na 'n ligging wat in die gebruiker se PATH-omgewingsveranderlike gespesifiseer is, soos `/system/xbin`.

Sodra die su-binêre geconfigureer is, word 'n ander Android-aansoek gebruik om met die `su` binêre te kommunikeer en **versoeke vir worteltoegang te verwerk** soos **Superuser** en **SuperSU** (beskikbaar in die Google Play Store).

{% hint style="danger" %}
Let daarop dat die rooting-proses baie gevaarlik is en die toestel ernstig kan beskadig
{% endhint %}

### ROMs

Dit is moontlik om die OS te **vervang deur 'n aangepaste firmware te installeer**. Deur dit te doen, is dit moontlik om die nut van 'n ou toestel uit te brei, sagtewarebeperkings te omseil of toegang tot die nuutste Android-kode te verkry.\
**OmniROM** en **LineageOS** is twee van die gewildste firmwares om te gebruik.

Let daarop dat **dit nie altyd nodig is om die toestel te root nie** om 'n aangepaste firmware te installeer. **Sommige vervaardigers laat** die ontgrendeling van hul opstartsnyers op 'n goed gedokumenteerde en veilige manier toe.

### Implikasies

Sodra 'n toestel gewortel is, kan enige aansoek versoek om toegang as wortel te verkry. As 'n skadelike aansoek dit kry, kan dit toegang tot byna alles hê en dit kan die foon beskadig. 

## Android Aansoek Fundamentele <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- Die formaat van Android-aansoeke word verwys as _APK-lêerformaat_. Dit is essensieel 'n **ZIP-lêer** (deur die lêeruitbreiding na .zip te hernoem, kan die inhoud onttrek en besigtig word).
- APK-inhoud (Nie uitputtend nie)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: bevat vooraf saamgestelde bronne, soos binêre XML.
- res/xml/files\_paths.xml
- META-INF/
- Hierdie is waar die Sertifikaat geleë is!
- **classes.dex**
- Bevat Dalvik-bytekode, wat die saamgestelde Java (of Kotlin) kode wat die aansoek standaard uitvoer, verteenwoordig.
- lib/
- Huise inheemse biblioteke, geskei deur CPU-argitektuur in subgidse.
- `armeabi`: kode vir ARM-gebaseerde verwerkers
- `armeabi-v7a`: kode vir ARMv7 en hoër gebaseerde verwerkers
- `x86`: kode vir X86-verwerkers
- `mips`: kode vir slegs MIPS-verwerkers
- bates/
- Berg verskeie lêers wat deur die aansoek benodig word, moontlik insluitend addisionele inheemse biblioteke of DEX-lêers, soms deur malware-skrywers gebruik om addisionele kode te verberg.
- res/
- Bevat bronne wat nie in resources.arsc saamgestel is nie
### **Dalvik & Smali**

In Android-ontwikkeling word **Java of Kotlin** gebruik om programme te skep. In plaas van die JVM soos in lessenaar programme, kompileer Android hierdie kode na **Dalvik Uitvoerbare (DEX) bytekode**. Vroeër het die Dalvik virtuele masjien hierdie bytekode hanteer, maar nou neem die Android Runtime (ART) oor in nuwer Android-weergawes.

Vir omgekeerde ingenieurswese word **Smali** noodsaaklik. Dit is die mens-leesbare weergawe van DEX bytekode, wat soos samestellingskode optree deur bronkode na bytekode-instruksies te vertaal. Smali en baksmali verwys na die samestellings- en ontsameleerhulpmiddels in hierdie konteks.

## Intents

Intents is die primêre manier waarop Android-programme tussen hul komponente of met ander programme kommunikeer. Hierdie boodskapvoorwerpe kan ook data tussen programme of komponente dra, soortgelyk aan hoe GET/POST-versoeke in HTTP-kommunikasie gebruik word.

Dus is 'n Intent basies 'n **boodskap wat tussen komponente oorgedra word**. Intents **kan gerig word** aan spesifieke komponente of programme, **of sonder 'n spesifieke ontvanger gestuur word**.\
Om dit eenvoudig te stel, kan 'n Intent gebruik word:

* Om 'n Aktiwiteit te begin, tipies deur 'n gebruikerskoppelvlak vir 'n app oop te maak
* As uitsendings om die stelsel en programme van veranderinge in te lig
* Om 'n agtergronddiens te begin, te stop en mee te kommunikeer
* Om data via Inhoudsverskaffers te benader
* As terugroep om gebeure te hanteer

Indien kwesbaar, **kan Intents gebruik word om 'n verskeidenheid aan aanvalle uit te voer**.

### Intent-Filter

**Intent Filters** definieer **hoe 'n aktiwiteit, diens, of Uitsaai-Ontvanger met verskillende tipes Intents kan interaksie hê**. Essensieel beskryf hulle die vermoëns van hierdie komponente, soos watter aksies hulle kan uitvoer of die soorte uitsendings wat hulle kan verwerk. Die primêre plek om hierdie filters te verklaar is binne die **AndroidManifest.xml-lêer**, alhoewel dit ook 'n opsie is om hulle vir Uitsaai-Ontvangers te kodeer.

Intent Filters bestaan uit kategorieë, aksies, en datafilters, met die moontlikheid om addisionele metadata in te sluit. Hierdie opstelling maak dit moontlik vir komponente om spesifieke Intents te hanteer wat aan die verklaarde kriteria voldoen.

'n Kritieke aspek van Android-komponente (aktiwiteite/dienste/inhoudsverskaffers/uitsaai-ontvangers) is hul sigbaarheid of **publieke status**. 'n Komponent word as openbaar beskou en kan met ander programme interaksie hê as dit **`uitgevoer`** word met 'n waarde van **`waar`** of as 'n Intent Filter daarvoor verklaar word in die manifest. Daar is egter 'n manier vir ontwikkelaars om hierdie komponente eksplisiet privaat te hou, om te verseker dat hulle nie onbedoeld met ander programme interaksie hê nie. Dit word bereik deur die **`uitgevoer`** attribuut na **`vals`** in hul manifestdefinisies te stel.

Verder het ontwikkelaars die opsie om toegang tot hierdie komponente verder te beveilig deur spesifieke toestemmings te vereis. Die **`toestemming`** attribuut kan ingestel word om te verseker dat slegs programme met die aangewese toestemming die komponent kan benader, wat 'n ekstra laag van sekuriteit en beheer bied oor wie daarmee kan interaksie hê.
```java
<activity android:name=".MyActivity" android:exported="false">
<!-- Intent filters go here -->
</activity>
```
### Implisiete Intente

Intente word programmaties geskep deur 'n Intent-konstrukteur:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
Die **Aksie** van die voorheen verklaarde intent is **ACTION\_SEND** en die **Ekstra** is 'n mailto **Uri** (die Ekstra is die ekstra inligting wat die intent verwag).

Hierdie intent moet binne die manifest verklaar word soos in die volgende voorbeeld:
```xml
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
'n Intent-filter moet die **aksie**, **data** en **kategorie** pas om 'n boodskap te ontvang.

Die "Intent resolution" proses bepaal watter app elke boodskap moet ontvang. Hierdie proses oorweeg die **prioriteit atribuut**, wat in die **intent-filter verklaring** ingestel kan word, en **die een met die hoër prioriteit sal gekies word**. Hierdie prioriteit kan tussen -1000 en 1000 ingestel word en programme kan die `SYSTEM_HIGH_PRIORITY` waarde gebruik. As 'n **konflik** ontstaan, verskyn 'n "chooser" venster sodat die **gebruiker kan besluit**.

### Expliciete Intents

'n Expliciete intent spesifiseer die klassenaam wat dit teiken:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
In ander toepassings om toegang te verkry tot die voorheen verklaarde intent kan jy die volgende gebruik:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Afhangende Intente

Hierdie maak dit vir ander toepassings moontlik om **optrede namens jou toepassing te neem**, met behulp van jou toepassing se identiteit en regte. Om 'n Afhangende Intent te konstrueer, moet daar 'n **intent en die optrede om uit te voer gespesifiseer word**. As die **verklaarde intent nie eksplisiet is** (nie verklaar watter intentie dit kan aanroep nie), kan 'n **skadelike toepassing die verklaarde optrede** namens die slagoffer-toepassing uitvoer. Verder, **as 'n optrede nie gespesifiseer is nie**, sal die skadelike toepassing in staat wees om **enige optrede namens die slagoffer** uit te voer.

### Uitsaai Intente

In teenstelling met die vorige intente, wat slegs deur een toepassing ontvang word, kan uitsaai intente **deur verskeie toepassings ontvang word**. Vanaf API-weergawe 14 is dit egter **moontlik om die toepassing te spesifiseer wat die boodskap moet ontvang** deur Intent.setPackage te gebruik.

Alternatief is dit ook moontlik om 'n **toestemming te spesifiseer wanneer die uitsaai gedoen word**. Die ontvangende toepassing sal daardie toestemming moet hê.

Daar is **twee tipes** Uitsaai: **Normaal** (asinkronies) en **Gereëlde** (sistemies). Die **volgorde** is gebaseer op die **gekonfigureerde prioriteit binne die ontvanger** element. **Elke toepassing kan die Uitsaai verwerk, deurgee of laat val.**

Dit is moontlik om 'n **uitsaai** te **stuur** deur die funksie `sendBroadcast(intent, receiverPermission)` van die `Context` klas te gebruik.\
Jy kan ook die funksie **`sendBroadcast`** van die **`LocalBroadCastManager`** gebruik om te verseker dat die **boodskap nooit die toepassing verlaat** nie. Deur dit te gebruik, hoef jy selfs nie 'n ontvangerkomponent uit te voer nie.

### Plakkerige Uitsaaie

Hierdie tipe Uitsaaie **kan lank nadat hulle gestuur is, benader word**.\
Hierdie is verouder in API-vlak 21 en dit word aanbeveel om **hulle nie te gebruik nie**.\
**Hulle laat enige toepassing toe om die data te bespeur, maar ook om dit te wysig.**

As jy funksies vind wat die woord "plakkerig" bevat soos **`sendStickyBroadcast`** of **`sendStickyBroadcastAsUser`**, **ondersoek die impak en probeer om hulle te verwyder**.

## Diep skakels / URL-skemas

In Android-toepassings word **diep skakels** gebruik om 'n optrede (Intent) direk deur 'n URL te inisieer. Dit word gedoen deur 'n spesifieke **URL-skema** binne 'n aktiwiteit te verklaar. Wanneer 'n Android-toestel probeer om 'n URL met hierdie skema **te benader**, word die gespesifiseerde aktiwiteit binne die toepassing geopen.

Die skema moet verklaar word in die **`AndroidManifest.xml`** lêer:
```xml
[...]
<activity android:name=".MyActivity">
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
<data android:scheme="examplescheme" />
</intent-filter>
[...]
```
Die skema van die vorige voorbeeld is `exampleapp://` (merk ook die **`kategorie BROWSABLE`**)

Dan kan jy in die data veld die **gasheer** en **pad** spesifiseer:
```xml
<data android:scheme="examplescheme"
android:host="example"
/>
```
Om dit vanaf 'n web te benader, is dit moontlik om 'n skakel soos die volgende in te stel:
```xml
<a href="examplescheme://example/something">click here</a>
<a href="examplescheme://example/javascript://%250dalert(1)">click here</a>
```
Om die **kode wat in die program uitgevoer sal word** te vind, gaan na die aktiwiteit wat deur die deeplink geroep word en soek die funksie **`onNewIntent`**.

Leer hoe om [diep skakels te roep sonder om HTML-bladsye te gebruik](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

Die **Android Interface Definition Language (AIDL)** is ontwerp om kommunikasie tussen klient en diens in Android-toepassings deur **interproses kommunikasie** (IPC) te fasiliteer. Aangesien direkte toegang tot 'n ander proses se geheue nie toegelaat word op Android nie, vereenvoudig AIDL die proses deur objekte in 'n formaat te marshal wat deur die bedryfstelsel verstaan word, en vergemaklik sodoende kommunikasie tussen verskillende prosesse.

### Sleutelkonsepte

- **Gebinde Dienste**: Hierdie dienste maak gebruik van AIDL vir IPC, wat aktiwiteite of komponente in staat stel om aan 'n diens te bind, versoek te maak, en antwoorde te ontvang. Die `onBind`-metode in die diens se klas is krities vir die inisieer van interaksie, en dit word as 'n belangrike area vir sekuriteitsondersoek gemerk op soek na kwesbaarhede.

- **Bode**: Terwyl dit as 'n gebinde diens funksioneer, fasiliteer Bode IPC met 'n fokus op die verwerking van data deur die `onBind`-metode. Dit is noodsaaklik om hierdie metode noukeurig te ondersoek vir enige onveilige datahantering of uitvoering van sensitiewe funksies.

- **Binder**: Alhoewel direkte gebruik van die Binder-klas minder algemeen is as gevolg van AIDL se abstraksie, is dit voordelig om te verstaan dat Binder as 'n kernelvlak drywer optree wat data-oordrag fasiliteer tussen die geheue-areas van verskillende prosesse. Vir verdere begrip is 'n hulpbron beskikbaar by [https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8).

## Komponente

Dit sluit in: **Aktiwiteite, Dienste, Uitsaai-Ontvangers en Verskaffers.**

### Aanloopaktiwiteit en ander aktiwiteite

In Android-toepassings is **aktiwiteite** soos skerms wat verskillende dele van die toepassing se gebruikerskoppelvlak vertoon. 'n Toepassing kan baie aktiwiteite hê, elkeen wat 'n unieke skerm aan die gebruiker voorstel.

Die **aanloopaktiwiteit** is die hoofingang na 'n toepassing, wat geopen word wanneer jy op die toepassing se ikoon tik. Dit word in die toepassing se manifestlêer gedefinieer met spesifieke MAIN- en LAUNCHER-intente:
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Nie alle programme het 'n beginaktiwiteit nodig nie, veral nie dié sonder 'n gebruikerskoppelvlak nie, soos agtergronddienste.

Aktiwiteite kan beskikbaar gestel word aan ander programme of prosesse deur hulle as "uitgevoer" in die manifest te merk. Hierdie instelling maak dit vir ander programme moontlik om hierdie aktiwiteit te begin:
```markdown
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Togang tot 'n aktiwiteit vanuit 'n ander program is nie altyd 'n veiligheidsrisiko nie. Die bekommernis ontstaan as sensitiewe data op 'n onvanpaste manier gedeel word, wat tot inligtingslektes kan lei.

Die lewensiklus van 'n aktiwiteit **begin met die `onCreate`-metode**, wat die UI opstel en die aktiwiteit gereed maak vir interaksie met die gebruiker.

### Aansoek Subklas

In Android-ontwikkeling het 'n program die opsie om 'n **subklas** van die [Aansoek](https://developer.android.com/reference/android/app/Application)-klas te skep, alhoewel dit nie verpligtend is nie. Wanneer so 'n subklas gedefinieer word, word dit die eerste klas wat binne die program geïnstantieer word. Die **`attachBaseContext`**-metode, indien geïmplementeer in hierdie subklas, word uitgevoer voor die **`onCreate`**-metode. Hierdie opstelling maak vroeë inisialisering moontlik voordat die res van die aansoek begin.
```java
public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
```
### Dienste

[Dienste](https://developer.android.com/guide/components/services) is **agtergrondoperateurs** wat in staat is om take uit te voer sonder 'n gebruikerskoppelvlak. Hierdie take kan voortgaan selfs wanneer gebruikers na verskillende toepassings oorskakel, wat dienste noodsaaklik maak vir **langdurige operasies**.

Dienste is veelsydig; hulle kan op verskeie maniere geïnisieer word, met **Intents** as die primêre metode om hulle te begin as 'n toepassing se toegangspunt. Wanneer 'n diens begin word met die `startService` metode, tree sy `onStart` metode in werking en bly loop totdat die `stopService` metode eksplisiet geroep word. Alternatiewelik, as 'n diens se rol afhanklik is van 'n aktiewe kliëntverbinding, word die `bindService` metode gebruik om die kliënt aan die diens te bind, wat die `onBind` metode betrek vir datadoorgang.

'n Interessante toepassing van dienste sluit agtergrondmusiekspel of netwerkdata ophaling in sonder om die gebruiker se interaksie met 'n toepassing te belemmer. Verder kan dienste toeganklik gemaak word vir ander prosesse op dieselfde toestel deur **uitvoer**. Dit is nie die verstekgedrag nie en vereis eksplisiete konfigurasie in die Android Manifest-lêer:
```xml
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Uitsaai-Ontvangers

**Uitsaai-ontvangers** tree as luisteraars in 'n boodskapsisteem, wat dit vir meerdere toepassings moontlik maak om op dieselfde boodskappe van die stelsel te reageer. 'n Toepassing kan 'n **ontvanger registreer** op **twee primêre maniere**: deur die toepassing se **Manifest** of **dinamies** binne die toepassing se kode via die **`registerReceiver`** API. In die Manifest word uitsendings gefiltreer met toestemmings, terwyl dinamies geregistreerde ontvangers ook toestemmings tydens registrasie kan spesifiseer.

**Intent-filters** is noodsaaklik in beide registrasiemetodes, wat bepaal watter uitsendings die ontvanger aktiveer. Sodra 'n ooreenstemmende uitsending gestuur word, word die ontvanger se **`onReceive`** metode aangeroep, wat die toepassing in staat stel om dienooreenkomstig te reageer, soos om gedrag aan te pas in reaksie op 'n lae batteryalarm.

Uitsendings kan of **asinkronies** wees, wat al die ontvangers sonder orde bereik, of **sinkronies**, waar ontvangers die uitsending op grond van vasgestelde prioriteite ontvang. Dit is egter belangrik om die potensiële sekuriteitsrisiko in ag te neem, aangesien enige toepassing homself kan prioritiseer om 'n uitsending te onderskep.

Om 'n ontvanger se funksionaliteit te verstaan, soek na die **`onReceive`** metode binne sy klas. Hierdie metode se kode kan die ontvangende Intent manipuleer, wat die behoefte aan data-validasie deur ontvangers beklemtoon, veral in **Gereëlde Uitsendings**, wat die Intent kan wysig of laat val.

### Inhoudsverskaffer

**Inhoudsverskaffers** is noodsaaklik vir **die deel van gestruktureerde data** tussen toepassings, wat die belangrikheid van die implementering van **toestemmings** beklemtoon om data-sekuriteit te verseker. Hulle maak dit vir toepassings moontlik om data van verskeie bronne, insluitend databasisse, lêersisteme, of die web, te benader. Spesifieke toestemmings, soos **`readPermission`** en **`writePermission`**, is noodsaaklik vir die beheer van toegang. Daarbenewens kan tydelike toegang verleen word deur **`grantUriPermission`** instellings in die toepassing se manifest, wat eienskappe soos `path`, `pathPrefix`, en `pathPattern` benut vir gedetailleerde toegangsbeheer.

Invoer-validasie is van uiterste belang om kwesbaarhede, soos SQL-inspuiting, te voorkom. Inhoudsverskaffers ondersteun basiese operasies: `insert()`, `update()`, `delete()`, en `query()`, wat data-manipulasie en -deling tussen toepassings fasiliteer.

**FileProvider**, 'n gespesialiseerde Inhoudsverskaffer, fokus op die veilige deel van lêers. Dit word in die toepassing se manifest gedefinieer met spesifieke eienskappe om toegang tot vouers te beheer, aangedui deur `android:exported` en `android:resource` wat na vouer-konfigurasies verwys. Voorsoorsigtigheid word aanbeveel wanneer vouers gedeel word om die onbedoelde blootstelling van sensitiewe data te voorkom.

Voorbeeld manifestverklaring vir FileProvider:
```xml
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false">
<meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
En 'n voorbeeld van die spesifisering van gedeelde lêers in `filepaths.xml`:
```xml
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Vir verdere inligting, kyk na:
- [Android-ontwikkelaars: Inhoudsverskaffers](https://developer.android.com/guide/topics/providers/content-providers)
- [Android-ontwikkelaars: FileProvider](https://developer.android.com/training/secure-file-sharing/setup-sharing)

## WebViews

WebViews is soos **mini-webblaaier** binne Android-toepassings, wat inhoud trek van die web of van plaaslike lêers. Hulle staar soortgelyke risiko's in die gesig as gewone blaaier, maar daar is maniere om **hierdie risiko's te verminder** deur spesifieke **instellings**.

Android bied twee hoof WebView-tipes aan:

- **WebViewClient** is goed vir basiese HTML, maar ondersteun nie die JavaScript-waarskuwingsfunksie nie, wat die toetsing van XSS-aanvalle kan beïnvloed.
- **WebChromeClient** tree meer op soos die volledige Chrome-blaai-ervaring.

'n Sleutelpunt is dat WebView-blaaiers **nie koekies deel** met die toestel se hoof-blaaier nie.

Vir die laai van inhoud, is metodes soos ````loadUrl````, ````loadData````, en ````loadDataWithBaseURL```` beskikbaar. Dit is noodsaaklik om te verseker dat hierdie URL's of lêers **veilig is om te gebruik**. Sekuriteitsinstellings kan bestuur word deur die ````WebSettings````-klas. Byvoorbeeld, deaktivering van JavaScript met ````setJavaScriptEnabled(false)```` kan XSS-aanvalle voorkom.

Die JavaScript "Bridge" laat Java-voorwerpe met JavaScript interaksie hê, wat vereis dat metodes gemerk moet word met ````@JavascriptInterface```` vir sekuriteit van Android 4.2 af.

Die toelaat van inhoudstoegang (````setAllowContentAccess(true)````) laat WebViews toe om Inhoudsverskaffers te bereik, wat 'n risiko kan wees tensy die inhoud-URL's geverifieer word as veilig.

Om lêertoegang te beheer:
- Deaktivering van lêertoegang (````setAllowFileAccess(false)````) beperk toegang tot die lêersisteem, met uitsonderings vir sekere bates, om te verseker dat hulle slegs vir nie-sensitiewe inhoud gebruik word.

## Ander Toepassingskomponente en Mobiele Toestelbestuur

### **Digitale Ondertekening van Toepassings**

- **Digitale ondertekening** is 'n moet vir Android-toepassings, wat verseker dat hulle **eg geskryf** is voor installasie. Hierdie proses gebruik 'n sertifikaat vir toepassingsidentifikasie en moet geverifieer word deur die toestel se pakkettebestuurder tydens installasie. Toepassings kan **self-onderteken of gesertifiseer word deur 'n eksterne CA**, wat teen ongemagtigde toegang beskerm en verseker dat die toepassing ongeskonde bly tydens aflewering na die toestel.

### **Toepassingsverifikasie vir Verhoogde Sekuriteit**

- Vanaf **Android 4.2**, 'n funksie genaamd **Verifieer Toepassings** laat gebruikers toe om toepassings vir veiligheid te laat nagaan voor installasie. Hierdie **verifikasieproses** kan gebruikers waarsku teen potensieel skadelike toepassings, of selfs die installasie van uiters skadelike eenhede voorkom, wat gebruikers se sekuriteit verhoog.

### **Mobiele Toestelbestuur (MDM)**

- **MDM-oplossings** bied **toesig en sekuriteit** vir mobiele toestelle deur die **Toesteladministrasie-API**. Dit vereis die installasie van 'n Android-toepassing om mobiele toestelle doeltreffend te bestuur en te beveilig. Sleutelfunksies sluit in **afdwinging van wagwoordbeleide**, **voorskryf van stoorversleuteling**, en **toelaat van afstandswisiging van data**, wat omvattende beheer en sekuriteit oor mobiele toestelle verseker.
```java
// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
```
<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** 💬 [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
