# Notions de base sur les applications Android

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trouvez les vuln√©rabilit√©s les plus importantes pour les corriger plus rapidement. Intruder suit votre surface d'attaque, effectue des scans de menaces proactifs, trouve des probl√®mes dans l'ensemble de votre pile technologique, des API aux applications web et aux syst√®mes cloud. [**Essayez-le gratuitement**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) aujourd'hui.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Mod√®le de s√©curit√© Android

**Il y a deux couches :**

* Le **syst√®me d'exploitation**, qui maintient les applications install√©es isol√©es les unes des autres.
* L'**application elle-m√™me**, qui permet aux d√©veloppeurs d'**exposer certaines fonctionnalit√©s** et configure les capacit√©s de l'application.

### S√©paration UID

**Chaque application se voit attribuer un identifiant utilisateur sp√©cifique**. Cela est fait lors de l'installation de l'application afin que **l'application ne puisse interagir qu'avec les fichiers appartenant √† son identifiant utilisateur ou avec des fichiers partag√©s**. Par cons√©quent, seuls l'application elle-m√™me, certains composants du syst√®me d'exploitation et l'utilisateur root peuvent acc√©der aux donn√©es de l'application.

### Partage UID

**Deux applications peuvent √™tre configur√©es pour utiliser le m√™me UID**. Cela peut √™tre utile pour partager des informations, mais si l'une d'elles est compromise, les donn√©es des deux applications seront compromises. C'est pourquoi ce comportement est **d√©courag√©**.\
**Pour partager le m√™me UID, les applications doivent d√©finir la m√™me valeur `android:sharedUserId` dans leurs manifestes.**

### Sandbox

Le **bac √† sable des applications Android** permet d'ex√©cuter **chaque application** comme un **processus s√©par√© sous un identifiant utilisateur s√©par√©**. Chaque processus a sa propre machine virtuelle, donc le code d'une application s'ex√©cute isol√©ment des autres applications.\
√Ä partir d'Android 5.0(L) **SELinux** est appliqu√©. En gros, SELinux a refus√© toutes les interactions entre processus, puis a cr√©√© des politiques pour **autoriser uniquement les interactions attendues entre eux**.

### Permissions

Lorsque vous installez une **application et qu'elle demande des permissions**, l'application demande les permissions configur√©es dans les √©l√©ments **`uses-permission`** du fichier **AndroidManifest.xml**. L'√©l√©ment **uses-permission** indique le nom de la permission demand√©e dans l'**attribut name**. Il a √©galement l'attribut **maxSdkVersion** qui arr√™te de demander des permissions pour les versions sup√©rieures √† celle sp√©cifi√©e.\
Notez que les applications Android n'ont pas besoin de demander toutes les permissions au d√©but, elles peuvent √©galement **demander des permissions de mani√®re dynamique** mais toutes les permissions doivent √™tre **d√©clar√©es** dans le **manifeste.**

Lorsqu'une application expose des fonctionnalit√©s, elle peut limiter l'**acc√®s uniquement aux applications disposant d'une permission sp√©cifi√©e**.\
Un √©l√©ment de permission a trois attributs :

* Le **nom** de la permission
* L'attribut **permission-group**, qui permet de regrouper des permissions connexes.
* Le **niveau de protection** qui indique comment les permissions sont accord√©es. Il existe quatre types :
  * **Normal** : Utilis√© lorsqu'il n'y a **aucune menace connue** pour l'application. L'utilisateur n'est **pas oblig√© de l'approuver**.
  * **Dangereux** : Indique que la permission accorde √† l'application demandant une **accessibilit√© √©lev√©e**. **Les utilisateurs sont invit√©s √† les approuver**.
  * **Signature** : Seules les **applications sign√©es par le m√™me certificat que celui** exportant le composant peuvent se voir accorder la permission. C'est le type de protection le plus fort.
  * **SignatureOuSyst√®me** : Seules les **applications sign√©es par le m√™me certificat que celui** exportant le composant ou **les applications fonctionnant avec un acc√®s au niveau du syst√®me** peuvent se voir accorder des permissions

## Applications pr√©install√©es

Ces applications se trouvent g√©n√©ralement dans les r√©pertoires **`/system/app`** ou **`/system/priv-app`** et certaines d'entre elles sont **optimis√©es** (vous ne trouverez peut-√™tre m√™me pas le fichier `classes.dex`). Ces applications m√©ritent d'√™tre v√©rifi√©es car parfois elles **fonctionnent avec trop de permissions** (en tant que root).

* Celles livr√©es avec la **ROM AOSP** (Projet OpenSource Android)
* Ajout√©es par le **fabricant de l'appareil**
* Ajout√©es par le fournisseur de **t√©l√©phonie mobile** (si achet√©es chez eux)

## Rooting

Pour obtenir un acc√®s root sur un appareil Android physique, vous devez g√©n√©ralement **exploiter** 1 ou 2 **vuln√©rabilit√©s** qui sont g√©n√©ralement **sp√©cifiques** √† l'**appareil** et √† la **version**.\
Une fois l'exploit r√©ussi, g√©n√©ralement le binaire Linux `su` est copi√© dans un emplacement sp√©cifi√© dans la variable d'environnement PATH de l'utilisateur comme `/system/xbin`.

Une fois le binaire su configur√©, une autre application Android est utilis√©e pour interagir avec le binaire `su` et **traiter les demandes d'acc√®s root** comme **Superuser** et **SuperSU** (disponibles dans le Google Play Store).

{% hint style="danger" %}
Notez que le processus de rooting est tr√®s dangereux et peut endommager gravement l'appareil
{% endhint %}

### ROMs

Il est possible de **remplacer le syst√®me d'exploitation en installant un firmware personnalis√©**. Cela permet d'√©tendre l'utilit√© d'un ancien appareil, de contourner les restrictions logicielles ou d'acc√©der au dernier code Android.\
**OmniROM** et **LineageOS** sont deux des firmwares les plus populaires √† utiliser.

Notez que **il n'est pas toujours n√©cessaire de rooter l'appareil** pour installer un firmware personnalis√©. **Certains fabricants permettent** le d√©verrouillage de leurs chargeurs de d√©marrage de mani√®re bien document√©e et s√ªre.

### Implications

Une fois qu'un appareil est root√©, n'importe quelle application peut demander un acc√®s root. Si une application malveillante l'obtient, elle aura acc√®s √† presque tout et pourra endommager le t√©l√©phone.

## Fondamentaux des applications Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

Cette introduction est tir√©e de [https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html](https://maddiestone.github.io/AndroidAppRE/app\_fundamentals.html)

### R√©vision des fondamentaux <a href="#fundamentals-review" id="fundamentals-review"></a>

* Les applications Android sont au format de fichier _APK_. **APK est essentiellement un fichier ZIP**. (Vous pouvez renommer l'extension du fichier en .zip et utiliser unzip pour ouvrir et voir son contenu.)
* Contenu APK (Non exhaustif)
  * **AndroidManifest.xml**
  * resources.arsc/strings.xml
  * resources.arsc : un fichier contenant des ressources pr√©compil√©es, telles que du XML binaire par exemple.
  * res/xml/files\_paths.xml
  * META-INF/
    * Le certificat vit ici !
  * **classes.dex**
    * Bytecode Dalvik pour l'application au format de fichier DEX. **C'est le code Java (ou Kotlin) compil√©** que l'application ex√©cutera par d√©faut.
  * lib/
    * Les biblioth√®ques natives pour l'application, par d√©faut, se trouvent ici ! Sous le r√©pertoire lib/, il y a les r√©pertoires sp√©cifiques au processeur.
    * `armeabi` : code compil√© uniquement pour tous les processeurs bas√©s sur ARM
    * `armeabi-v7a` : code compil√© uniquement pour tous les processeurs bas√©s sur ARMv7 et sup√©rieurs
    * `x86` : code compil√© pour X86
    * `mips` : code compil√© uniquement pour les processeurs MIPS
  * assets/
    * Tout autre fichier pouvant √™tre n√©cessaire √† l'application.
    * Des biblioth√®ques natives suppl√©mentaires ou des fichiers DEX peuvent √™tre inclus ici. Cela peut se produire surtout lorsque les auteurs de logiciels malveillants veulent essayer de "cacher" du code suppl√©mentaire, natif ou Dalvik, en ne l'incluant pas dans les emplacements par d√©faut.
  * res/
    * le r√©pertoire contenant des ressources non compil√©es dans resources.arsc

### **Dalvik & Smali**

La plupart des applications Android sont √©crites en Java. Kotlin est √©galement pris en charge et interop√©rable avec Java. Pour simplifier, pour le reste de cet atelier, lorsque je fais r√©f√©rence √† "Java", vous pouvez supposer que je veux dire "Java ou Kotlin". **Au lieu que le code Java soit ex√©cut√© dans la machine virtuelle Java** (JVM) comme les applications de bureau, sur Android, le **Java est compil√© au format de bytecode \_Dalvik Executable (DEX)\_**. Pour les versions ant√©rieures d'Android, le bytecode √©tait traduit par la machine virtuelle Dalvik. Pour les versions plus r√©centes d'Android, le Runtime Android (ART) est utilis√©.\
Si les d√©veloppeurs √©crivent en Java et que le code est compil√© en bytecode DEX, pour la r√©tro-ing√©nierie, nous travaillons dans la direction oppos√©e.\
\\

![Organigramme du processus du d√©veloppeur. Java en bytecode DEX](https://maddiestone.github.io/AndroidAppRE/images/DevelopersFlow.jpg)

![Organigramme du processus de l'ing√©nieur inverse. Bytecode DEX en SMALI en Java d√©compil√©](https://maddiestone.github.io/AndroidAppRE/images/ReversersFlow.jpg)

**Smali est la version lisible par l'homme du bytecode Dalvik**. Techniquement, Smali et baksmali sont les noms des outils (assembleur et d√©sassembleur, respectivement), mais dans Android, nous utilisons souvent le terme "Smali" pour faire r√©f√©rence aux instructions. Si vous avez fait de la r√©tro-ing√©nierie ou de l'architecture informatique sur du code C/C++ compil√©. **SMALI est comme le langage d'assemblage : entre le code source de haut niveau et le bytecode**.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trouvez les vuln√©rabilit√©s les plus importantes pour les corriger plus rapidement. Intruder suit votre surface d'attaque, effectue des scans de menaces proactifs, trouve des probl√®mes dans l'ensemble de votre pile technologique, des API aux applications web et aux syst√®mes cloud. [**Essayez-le gratuitement**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) aujourd'hui.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Intents

Les Intents sont le principal moyen par lequel les applications Android communiquent entre leurs composants ou avec d'autres applications. Ces objets de message peuvent √©galement transporter des donn√©es entre les applications ou les composants, de mani√®re similaire √† l'utilisation des requ√™tes GET/POST dans les communications HTTP.

Donc, un Intent est essentiellement un **message qui est transmis entre les composants**. Les Intents **peuvent √™tre dirig√©s** vers des composants ou des applications sp√©cifiques, **ou peuvent √™tre envoy√©s sans destinataire sp√©cifique**.\
Pour √™tre simple, Intent peut √™tre utilis√© :

* Pour d√©marrer une Activit√©, ouvrant g√©n√©ralement une interface utilisateur pour une application
* Comme diffusions pour informer le syst√®me et les applications des changements
* Pour d√©marrer, arr√™ter et communiquer avec un service en arri√®re-plan
* Pour acc√©der aux donn√©es via les ContentProviders
* Comme callbacks pour g√©rer les √©v√©nements

Une mise en ≈ìuvre incorrecte pourrait entra√Æner une fuite de donn√©es, l'appel de fonctions restreintes et la manipulation du flux du programme.

### Intent-Filter

Un filtre d'intention sp√©cifie les **types d'Intent auxquels une activit√©, un service ou un Broadcast Receiver peut r√©pondre**. Il sp√©cifie ce qu'une activit√© ou un service peut faire et quels types de diffusions un Receiver peut g√©rer. Il permet au composant correspondant de recevoir des Intents du type d√©clar√©. Les filtres d'intention sont g√©n√©ralement **d√©finis via le fichier AndroidManifest.xml**. Pour un **Broadcast Receiver**, il est √©galement possible de les d√©finir dans le **code**. Un filtre d'intention est d√©fini par sa cat√©gorie, son action et ses filtres de donn√©es. Il peut √©galement contenir des m√©tadonn√©es suppl√©mentaires.

Dans Android, une activit√©/service/content provider/broadcast receiver est **public** lorsque **`exported`** est r√©gl√© sur **`true`**, mais un composant est **√©galement public** si le **manifeste sp√©cifie un filtre d'intention** pour celui-ci. Cependant,\
les d√©veloppeurs peuvent **explicitement rendre les composants priv√©s** (ind√©pendamment de tout filtre d'intention)\
en r√©glant l'attribut **`exported`** sur `false` pour chaque composant dans le fichier manifeste.\
Les d√©veloppeurs peuvent √©galement d√©finir l'attribut **`permission`** pour **exiger une certaine permission pour acc√©der** au composant, limitant ainsi l'acc√®s au composant.

### Intentions implicites

Les Intents sont cr√©√©s programmatiquement en utilisant un constructeur Intent :
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
L'**Action** de l'intention pr√©c√©demment d√©clar√©e est **ACTION\_SEND** et l'**Extra** est un **Uri** mailto (l'Extra est l'information suppl√©mentaire que l'intention attend).

Cette intention doit √™tre d√©clar√©e dans le manifeste comme dans l'exemple suivant :
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Un intent-filter doit correspondre √† l'**action**, aux **donn√©es** et √† la **cat√©gorie** pour recevoir un message.

Le processus de "R√©solution d'intent" d√©termine quelle application devrait recevoir chaque message. Ce processus prend en compte l'**attribut de priorit√©**, qui peut √™tre d√©fini dans la **d√©claration de l'intent-filter**, et **celui avec la priorit√© la plus √©lev√©e sera s√©lectionn√©**. Cette priorit√© peut √™tre d√©finie entre -1000 et 1000 et les applications peuvent utiliser la valeur `SYSTEM_HIGH_PRIORITY`. Si un **conflit** survient, une fen√™tre de "choix" appara√Æt pour que l'**utilisateur puisse d√©cider**.

### Intents explicites

Un intent explicite sp√©cifie le nom de la classe qu'il cible :
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Dans d'autres applications, pour acc√©der √† l'intent pr√©c√©demment d√©clar√©, vous pouvez utiliser :
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Intentions en attente

Celles-ci permettent √† d'autres applications **d'agir au nom de votre application**, en utilisant l'identit√© et les permissions de votre app. Lors de la construction d'une Intention en attente, il faut **sp√©cifier une intention et l'action √† r√©aliser**. Si l'**intention d√©clar√©e n'est pas Explicite** (ne d√©clare pas quelle intention peut l'appeler), une **application malveillante pourrait r√©aliser l'action d√©clar√©e** au nom de l'application victime. De plus, **si une action n'est pas sp√©cifi√©e**, l'application malveillante pourra faire **n'importe quelle action au nom de la victime**.

### Intentions de diffusion

Contrairement aux intentions pr√©c√©dentes, qui ne sont re√ßues que par une seule application, les intentions de diffusion **peuvent √™tre re√ßues par plusieurs applications**. Cependant, √† partir de la version 14 de l'API, il est **possible de sp√©cifier l'application qui devrait recevoir** le message en utilisant Intent.set Package.

Il est √©galement possible de **sp√©cifier une permission lors de l'envoi de la diffusion**. L'application r√©ceptrice devra avoir cette permission.

Il existe **deux types** de diffusions : **Normales** (asynchrones) et **Ordonn√©es** (synchrones). L'**ordre** est bas√© sur la **priorit√© configur√©e dans l'√©l√©ment r√©cepteur**. **Chaque application peut traiter, relayer ou abandonner la diffusion.**

Il est possible **d'envoyer** une **diffusion** en utilisant la fonction **`sendBroadcast(intent, receiverPermission)`** de la classe `Context`.\
Vous pourriez √©galement utiliser la fonction **`sendBroadcast`** du **`LocalBroadCastManager`** qui assure que le **message ne quitte jamais l'application**. En utilisant cela, vous n'aurez m√™me pas besoin d'exporter un composant r√©cepteur.

### Diffusions persistantes

Ce type de diffusions **peut √™tre acc√©d√© longtemps apr√®s leur envoi**.\
Elles ont √©t√© d√©pr√©ci√©es dans la version 21 de l'API et il est recommand√© de **ne pas les utiliser**.\
**Elles permettent √† n'importe quelle application de renifler les donn√©es, mais aussi de les modifier.**

Si vous trouvez des fonctions contenant le mot "sticky" comme **`sendStickyBroadcast`** ou **`sendStickyBroadcastAsUser`**, **v√©rifiez l'impact et essayez de les supprimer**.

## Liens profonds / Sch√©mas d'URL

**Les liens profonds permettent de d√©clencher une Intention via une URL**. Une application peut d√©clarer un **sch√©ma d'URL** √† l'int√©rieur d'une activit√© de sorte que chaque fois que le dispositif Android tente **d'acc√©der √† une adresse utilisant ce sch√©ma**, l'activit√© de l'application sera appel√©e :

![](<../../.gitbook/assets/image (214).png>)

Dans ce cas, le sch√©ma est `myapp://` (notez aussi la **`cat√©gorie BROWSABLE`**)

Si √† l'int√©rieur du `intent-filter` vous trouvez quelque chose comme ceci :

![](<../../.gitbook/assets/image (263).png>)

Alors, il s'attend √† quelque chose comme `http://www.example.com/gizmos`

Si vous trouvez quelque chose comme ceci :

![](<../../.gitbook/assets/image (262).png>)

Cela signifiera qu'il s'attend √† une URL commen√ßant par `example://gizmos`\
Dans ce cas, vous pourriez essayer d'abuser de la fonctionnalit√© en cr√©ant un web avec les charges utiles suivantes. Il essaiera de naviguer vers des pages arbitraires et d'essayer d'ex√©cuter du JS :
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Pour trouver **le code qui sera ex√©cut√© dans l'application**, allez √† l'activit√© appel√©e par le deeplink et recherchez la fonction **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Apprenez comment [appeler des deep links sans utiliser de pages HTML](./#exploiting-schemes-deep-links).

## AIDL - Langage de D√©finition d'Interface Android

Le **Langage de D√©finition d'Interface Android** (AIDL) vous permet de d√©finir l'interface de programmation sur laquelle le client et le service s'accordent pour **communiquer entre eux en utilisant la communication interprocessus** (IPC). Sur Android, **un processus ne peut normalement pas acc√©der √† la m√©moire d'un autre processus**. Ainsi, pour communiquer, ils doivent d√©composer leurs objets en primitives que le **syst√®me d'exploitation** peut comprendre, et transf√©rer les objets √† travers cette limite pour vous. Le code pour faire ce transfert est fastidieux √† √©crire, donc Android le g√®re pour vous avec AIDL.

Les services utilisant AIDL sont appel√©s **Services Li√©s**. Dans la classe du Service, vous trouverez la m√©thode **`onBind`**. C'est **l√† que l'interaction commence**, donc c'est la premi√®re partie du code √† examiner √† la recherche de vuln√©rabilit√©s potentielles.

Un service li√© est le serveur dans une interface client-serveur. **Il permet aux composants (tels que les activit√©s) de se lier au service, d'envoyer des demandes, de recevoir des r√©ponses et d'effectuer une communication interprocessus** (IPC). Un service li√© vit g√©n√©ralement seulement tant qu'il sert un autre composant de l'application et ne fonctionne pas ind√©finiment en arri√®re-plan.

### Messenger

Un Messenger est un autre type de m√©canisme IPC. Comme le **Messenger est √©galement un "Service Li√©"**, les donn√©es transmises par l'application cliente sont √©galement trait√©es via la m√©thode `onBind`. Ainsi, la revue de code devrait commencer par cette m√©thode et vous devriez rechercher l'invocation de fonctionnalit√©s sensibles ou la gestion non s√©curis√©e des donn√©es.

### Binder

Il est rare de trouver une classe Binder directement invoqu√©e car il est beaucoup plus facile d'utiliser AIDL (qui abstrait la classe Binder). Cependant, il est bon de savoir que **Binder est un pilote de niveau noyau qui d√©place les donn√©es de la m√©moire d'un processus √† celle d'un autre** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Composants

Cela inclut : **Activit√©s, Services, R√©cepteurs de Diffusion et Fournisseurs.**

### Activit√© de Lancement et autres activit√©s

Une **activit√© Android** est un √©cran de l'interface utilisateur de l'application **Android**. De cette mani√®re, une **activit√© Android** est tr√®s similaire aux fen√™tres d'une application de bureau. Une application **Android** peut contenir une ou plusieurs activit√©s, signifiant un ou plusieurs √©crans.

L'**activit√© de lancement** est ce que la plupart des gens consid√®rent comme le **point d'entr√©e** d'une application Android. L'activit√© de lancement est l'activit√© qui est d√©marr√©e lorsqu'un utilisateur clique sur l'ic√¥ne d'une application. Vous pouvez d√©terminer l'activit√© de lancement en regardant le manifeste de l'application. L'activit√© de lancement aura les intentions MAIN et LAUNCHER suivantes list√©es.

Gardez √† l'esprit que toutes les applications n'auront pas une activit√© de lancement, en particulier les applications sans UI. Des exemples d'applications sans UI (et donc sans activit√© de lancement) sont les applications pr√©install√©es qui effectuent des services en arri√®re-plan, comme la messagerie vocale.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
Les activit√©s peuvent √™tre export√©es, permettant √† d'autres processus sur l'appareil de lancer l'activit√©. Par d√©faut, elles ne sont pas export√©es, mais vous pouvez les exporter en d√©finissant :
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Notez que la capacit√© √† **contourner les protections d'activit√© n'est pas toujours une vuln√©rabilit√©**, vous devez v√©rifier √† quelles donn√©es vous avez acc√©d√©.
De plus, **certaines activit√©s renvoient des donn√©es √† l'appelant**. Dans ces sc√©narios, vous devez rechercher la m√©thode **`setResult`** et v√©rifier les donn√©es qui sont pass√©es dans le param√®tre Intent. **Si c'est des donn√©es sensibles, vous pourriez avoir une vuln√©rabilit√© de fuite d'informations** et c'est exploitable avec des applications capables de communiquer avec l'Activit√©.

**Le code d'une activit√© commence par la m√©thode `onCreate`.**

### Sous-classe d'Application

Les applications Android peuvent d√©finir une **sous-classe** de [Application](https://developer.android.com/reference/android/app/Application). Les applications peuvent, mais ne sont pas oblig√©es de d√©finir une sous-classe personnalis√©e d'Application. Si une application Android d√©finit une sous-classe d'Application, **cette classe est instanci√©e avant toute autre classe dans l'application**.

Si la m√©thode **`attachBaseContext`** est d√©finie dans la sous-classe d'Application, elle est appel√©e en premier, avant la m√©thode **`onCreate`**.

### Services

Les [Services](https://developer.android.com/guide/components/services) **fonctionnent en arri√®re-plan sans interface utilisateur.** Ils sont utilis√©s pour effectuer **des processus de longue dur√©e, m√™me si l'utilisateur commence √† utiliser une autre application**.

Il existe une myriade de fa√ßons dont ils peuvent √™tre d√©marr√©s et sont donc un point d'entr√©e pour les applications. La mani√®re par d√©faut qu'un service peut √™tre d√©marr√© comme point d'entr√©e d'une application est √† travers les **Intents**.

Lorsque la m√©thode **`startService`** est appel√©e pour d√©marrer un Service, la m√©thode **`onStart`** dans le Service est ex√©cut√©e. Il fonctionnera ind√©finiment jusqu'√† ce que la m√©thode **`stopService`** soit appel√©e. Si le service est seulement n√©cessaire tant que le client est connect√©, le client doit se "lier" √† celui-ci en utilisant la m√©thode **`bindService`**.

Pour un **service li√©** (voir section pr√©c√©dente), les donn√©es seront pass√©es √† la m√©thode **`onBind`**.

Par exemple, un service peut jouer de la musique en arri√®re-plan pendant que l'utilisateur est dans une autre application, ou il peut r√©cup√©rer des donn√©es sur le r√©seau sans bloquer l'interaction de l'utilisateur avec une activit√©.

**Un service peut √™tre export√© ce qui permet √† d'autres processus sur l'appareil de d√©marrer le service**. Par d√©faut, les services ne sont pas export√©s mais cela peut √™tre configur√© dans le Manifest :
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### R√©cepteurs de diffusion

Les diffusions peuvent √™tre consid√©r√©es comme un syst√®me de messagerie et **les r√©cepteurs de diffusion sont les auditeurs**. Si une application a enregistr√© un r√©cepteur pour une diffusion sp√©cifique, le code de ce r√©cepteur est ex√©cut√© lorsque le syst√®me envoie la diffusion. Notez que dans ce cas **plusieurs applications peuvent recevoir le m√™me message**.

Il existe **2 mani√®res** pour une application de **enregistrer un r√©cepteur** : dans le **Manifest de l'application ou enregistr√© dynamiquement** dans le code de l'application en utilisant l'appel API **`registerReceiver`**. Dans le manifeste, vous pouvez limiter les diffusions que vous acceptez gr√¢ce √† l'**utilisation de permissions dans l'√©l√©ment r√©cepteur**. Lorsqu'il est d√©fini **dynamiquement**, vous pouvez **passer la permission √† la m√©thode `registerReceiver`**.

Dans les deux cas, pour enregistrer le r√©cepteur, les **filtres d'intention pour le r√©cepteur sont d√©finis**. Ces filtres d'intention sont les diffusions qui devraient d√©clencher le r√©cepteur.

Lorsque les diffusions sp√©cifiques pour lesquelles le r√©cepteur est enregistr√© sont envoy√©es, **`onReceive`** dans la classe BroadcastReceiver est **ex√©cut√©**.

Une application peut enregistrer un r√©cepteur pour le message de batterie faible par exemple, et changer son comportement en fonction de cette information.

La diffusion peut √™tre **asynchrone** (chaque r√©cepteur la re√ßoit) ou **synchrone** (la diffusion est re√ßue de mani√®re ordonn√©e en fonction de la priorit√© d√©finie pour la recevoir).

{% hint style="danger" %}
**Notez que n'importe quelle application peut se d√©finir comme priorit√© maximale pour recevoir une Diffusion.**
{% endhint %}

Pour **examiner** le **code** impl√©ment√© dans un R√©cepteur de diffusion, vous devez rechercher la m√©thode **`onReceive`** de la classe du r√©cepteur.\
Notez que **les Diffusions Ordonn√©es peuvent abandonner l'Intent re√ßu ou m√™me le modifier** en utilisant l'une des m√©thodes setter. Par cons√©quent, les **r√©cepteurs devraient valider les donn√©es**.

### Fournisseur de contenu

Les Fournisseurs de contenu sont la mani√®re dont **les applications partagent des donn√©es structur√©es**, telles que des bases de donn√©es relationnelles. Par cons√©quent, il est tr√®s important d'utiliser des **permissions** et de d√©finir le niveau de protection appropri√© pour les prot√©ger.\
Les Fournisseurs de contenu peuvent utiliser les attributs **`readPermission`** et **`writePermission`** pour sp√©cifier quelles permissions une application doit avoir. **Ces permissions pr√©valent sur l'attribut permission**.\
De plus, ils peuvent √©galement **autoriser des exceptions temporaires** en d√©finissant **`grantUriPermission`** sur vrai, puis en configurant les param√®tres appropri√©s dans l'√©l√©ment **`grant-uri-permission`** √† l'int√©rieur de l'√©l√©ment fournisseur dans le fichier manifeste.

L'attribut **`grant-uri-permission`** a trois attributs : path, pathPrefix et pathPattern :

* **path** : Permet de sp√©cifier l'int√©gralit√© du chemin √† exclure
* **pathPrefix** : Permet de sp√©cifier le d√©but du chemin
* **pathPattern** : Permet l'utilisation de jokers et de remplacements symboliques pour un contr√¥le plus granulaire.

Il est **important de valider et d'assainir les entr√©es re√ßues** pour √©viter d'√©ventuelles vuln√©rabilit√©s comme l'injection SQL.

**Caract√©ristiques du Fournisseur de contenu :**

* Le composant Fournisseur de contenu fournit des donn√©es d'une application √† d'autres sur demande.
* Vous pouvez stocker les donn√©es dans le syst√®me de fichiers, une base de donn√©es SQLite, sur le web ou tout autre emplacement de stockage persistant auquel votre application peut acc√©der.
* Gr√¢ce au fournisseur de contenu, d'autres applications peuvent interroger ou m√™me modifier les donn√©es (si le fournisseur de contenu le permet).
* Le Fournisseur de contenu est utile dans les cas o√π une application souhaite partager des donn√©es avec une autre application.
* Il est tr√®s similaire aux bases de donn√©es et dispose de quatre m√©thodes.
* insert()
* update()
* delete()
* query()

**FileProvider**

Il s'agit d'un type de Fournisseur de contenu qui va **partager des fichiers** √† partir d'un dossier. Vous pouvez d√©clarer un fournisseur de fichiers comme ceci :
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Notez l'attribut **`android:exported`** car s'il est **`true`**, les applications externes pourront acc√©der aux dossiers partag√©s.\
Notez que la configuration `android:resource="@xml/filepaths"` indique que le fichier _res/xml/filepaths.xml_ contient la configuration de **quels dossiers** ce **FileProvider** va **partager**. Voici un exemple de comment indiquer de partager un dossier dans ce fichier :
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Partager quelque chose comme **`path="."`** pourrait √™tre **dangereux** m√™me si le fournisseur n'est pas export√© s'il y a une autre vuln√©rabilit√© dans une partie du code qui a tent√© d'acc√©der √† ce fournisseur.\
Vous pourriez **acc√©der** √† une **image** dans ce dossier avec `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

L'√©l√©ment `<paths>` peut avoir plusieurs enfants, chacun sp√©cifiant un r√©pertoire diff√©rent √† partager. En plus de l'√©l√©ment **`<files-path>`**, vous pouvez utiliser l'√©l√©ment **`<external-path>`** pour partager des r√©pertoires dans le **stockage externe**, et l'√©l√©ment **`<cache-path>`** pour partager des r√©pertoires dans votre **r√©pertoire de cache interne**.\
[Pour plus d'informations sur les attributs sp√©cifiques des fournisseurs de fichiers, cliquez ici.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[Plus d'informations sur les FileProviders ici](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

Les WebViews sont essentiellement des **navigateurs web** int√©gr√©s dans les applications Android.\
Le contenu des WebViews peut √™tre extrait de sites distants ou peut √™tre des fichiers inclus dans l'application.\
Les WebViews sont **vuln√©rables aux m√™mes vuln√©rabilit√©s affectant tout navigateur web**. Cependant, il existe certaines **configurations** qui peuvent √™tre utiles pour **limiter** la **surface d'attaque**.

Il existe deux types de WebViews sous Android :

* Le **WebViewClient**, mieux adapt√© pour le rendu de HTML simple. Cette fonction ne lancera pas la fonction d'alerte JS. Ainsi, les tests XSS utilisant cette fonction seront invalides.
* Le **WebChrome** **client**, est un navigateur Chrome.

Notez que les **navigateurs WebView n'ont pas acc√®s aux cookies du navigateur natif**.

Pour charger une URL ou un fichier, il est possible d'utiliser les fonctions **`loadUrl`**, **`loadData`** ou **`loadDataWithBaseURL`**. **Il est important d'acc√©der uniquement √† des URL assainies.**\
La s√©curit√© des WebView peut √™tre configur√©e via l'objet **`WebSettings`**.\
Par exemple, l'ex√©cution de code JS peut √™tre d√©sactiv√©e en utilisant la m√©thode **`setJavaScriptEnabled`** avec la valeur **`false`**. Cela **√©liminera** la possibilit√© d'un **XSS** et d'autres vuln√©rabilit√©s li√©es √† JS.

La fonctionnalit√© "Bridge" JavaScript **injecte des objets Java dans un WebView les rendant accessibles √† JS**. √Ä partir d'Android 4.2, les m√©thodes doivent √™tre annot√©es avec **`@JavascriptInterface`** pour √™tre accessibles √† JavaScript.

Si **`true`** est pass√© √† **`setAllowContentAccess`**, **les WebViews pourront acc√©der aux fournisseurs de contenu** via le sch√©ma **`content://`**. Cela pose √©videmment un risque de s√©curit√©. Notez que si cet acc√®s est accord√©, il est tr√®s important de **s'assurer** que l'URL **`content://`** est **s√ªre**.

Par d√©faut, les fichiers locaux peuvent √™tre accessibles par les WebViews via des URL file://, mais il existe plusieurs moyens de pr√©venir ce comportement :

* Passer **`false`** √† **`setAllowFileAccess`**, emp√™che l'acc√®s au syst√®me de fichiers √† l'exception des actifs via `file:///android_asset` _et_ `file:///android_res`. Ces chemins devraient √™tre utilis√©s uniquement pour des donn√©es non sensibles (comme des images), donc cela devrait √™tre s√ªr.
* La m√©thode **`setAllowFileAccess`** indique si un chemin d'une URL `file://` devrait pouvoir acc√©der au contenu d'autres URL de sch√©ma de fichier.
* La m√©thode **`setAllowUniversalAccessFromFileURLs`** indique si un chemin d'une URL `file://` devrait pouvoir acc√©der au contenu de n'importe quelle origine.

## Autres composants d'application

### **Signature d'application**

* Android exige que **toutes les applications soient num√©riquement sign√©es avec un certificat** avant qu'elles puissent √™tre install√©es. Android utilise ce certificat pour identifier l'auteur d'une application.
* Pour ex√©cuter l'application sur l'appareil, elle doit √™tre sign√©e. Lorsqu'une application est install√©e sur un appareil, le **gestionnaire de paquets v√©rifie** si l'application a √©t√© correctement sign√©e avec le certificat dans le fichier apk ou non.
* L'application peut √™tre auto-sign√©e ou sign√©e par une CA.
* La signature d'application garantit qu'une application ne peut pas acc√©der √† une autre application sauf par le biais d'IPC bien d√©fini et aussi qu'elle est transmise sans modification √† l'appareil.

### **V√©rification d'application**

* Android 4.2 et les versions ult√©rieures prennent en charge la v√©rification des applications. Les utilisateurs peuvent choisir d'activer la v√©rification des applications "Verify Apps" et faire √©valuer les applications par un v√©rificateur d'applications avant l'installation.
* La v√©rification des applications peut alerter l'utilisateur s'il essaie d'installer une application qui pourrait √™tre nuisible ; si une application est particuli√®rement mauvaise, elle peut bloquer l'installation.

## Gestion des appareils mobiles

MDM ou Mobile Device Management sont des suites logicielles utilis√©es pour **assurer le contr√¥le et les exigences de s√©curit√©** sur les appareils mobiles. Ces suites utilisent les fonctionnalit√©s appel√©es API d'administration de l'appareil et n√©cessitent qu'une application Android soit install√©e.

G√©n√©ralement, les solutions MDM effectuent des fonctions telles que l'application de politiques de mot de passe, le for√ßage du chiffrement du stockage et l'activation de l'effacement √† distance des donn√©es de l'appareil.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trouvez les vuln√©rabilit√©s qui comptent le plus afin de les corriger plus rapidement. Intruder suit votre surface d'attaque, effectue des analyses de menaces proactives, trouve des probl√®mes dans l'ensemble de votre pile technologique, des API aux applications web et aux syst√®mes cloud. [**Essayez-le gratuitement**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) aujourd'hui.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF** Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
