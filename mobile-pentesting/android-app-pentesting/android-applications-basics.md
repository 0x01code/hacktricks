# Conceitos B√°sicos de Aplicativos Android

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenha o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga** me no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas dicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

üêû Leia tutoriais de bugs web3

üîî Receba notifica√ß√µes sobre novos programas de recompensas por bugs

üí¨ Participe de discuss√µes na comunidade

## Modelo de Seguran√ßa do Android

**Existem duas camadas:**

* O **SO**, que mant√©m aplicativos instalados isolados uns dos outros.
* O **pr√≥prio aplicativo**, que permite que os desenvolvedores **exponham determinadas funcionalidades** e configurem as capacidades do aplicativo.

### Separa√ß√£o de UID

**Cada aplicativo √© atribu√≠do um ID de usu√°rio espec√≠fico**. Isso √© feito durante a instala√ß√£o do aplicativo para que o aplicativo possa interagir apenas com arquivos de propriedade de seu ID de usu√°rio ou arquivos compartilhados. Portanto, apenas o pr√≥prio aplicativo, certos componentes do SO e o usu√°rio root podem acessar os dados dos aplicativos.

### Compartilhamento de UID

**Dois aplicativos podem ser configurados para usar o mesmo UID**. Isso pode ser √∫til para compartilhar informa√ß√µes, mas se um deles for comprometido, os dados de ambos os aplicativos ser√£o comprometidos. √â por isso que esse comportamento √© **desencorajado**.\
**Para compartilhar o mesmo UID, os aplicativos devem definir o mesmo valor `android:sharedUserId` em seus arquivos de manifesto.**

### Isolamento

O **Android Application Sandbox** permite executar **cada aplicativo** como um **processo separado sob um ID de usu√°rio separado**. Cada processo tem sua pr√≥pria m√°quina virtual, portanto, o c√≥digo de um aplicativo √© executado em isolamento de outros aplicativos.\
A partir do Android 5.0(L), o **SELinux** √© aplicado. Basicamente, o SELinux negou todas as intera√ß√µes de processos e, em seguida, criou pol√≠ticas para **permitir apenas as intera√ß√µes esperadas entre eles**.

### Permiss√µes

Quando voc√™ instala um **aplicativo e ele solicita permiss√µes**, o aplicativo est√° solicitando as permiss√µes configuradas nos elementos **`uses-permission`** no arquivo **AndroidManifest.xml**. O elemento **uses-permission** indica o nome da permiss√£o solicitada dentro do **atributo de nome**. Ele tamb√©m tem o atributo **maxSdkVersion** que impede a solicita√ß√£o de permiss√µes em vers√µes superiores √† especificada.\
Observe que os aplicativos Android n√£o precisam solicitar todas as permiss√µes no in√≠cio, eles tamb√©m podem **solicitar permiss√µes dinamicamente**, mas todas as permiss√µes devem ser **declaradas** no **manifesto**.

Quando um aplicativo exp√µe funcionalidade, ele pode limitar o **acesso apenas a aplicativos que possuem uma permiss√£o especificada**.\
Um elemento de permiss√£o tem tr√™s atributos:

* O **nome** da permiss√£o
* O atributo **permission-group**, que permite agrupar permiss√µes relacionadas.
* O **n√≠vel de prote√ß√£o** que indica como as permiss√µes s√£o concedidas. Existem quatro tipos:
  * **Normal**: Usado quando n√£o h√° **amea
### Filtro de Inten√ß√£o

Um Filtro de Inten√ß√£o especifica os **tipos de Inten√ß√£o que uma atividade, servi√ßo ou Receptor de Transmiss√£o pode responder**. Ele especifica o que uma atividade ou servi√ßo pode fazer e que tipos de transmiss√µes um Receptor pode manipular. Ele permite que o componente correspondente receba Inten√ß√µes do tipo declarado. Os Filtros de Inten√ß√£o s√£o normalmente **definidos via arquivo AndroidManifest.xml**. Para **Receptor de Transmiss√£o**, tamb√©m √© poss√≠vel defini-los em **c√≥digo**. Um Filtro de Inten√ß√£o √© definido por sua categoria, a√ß√£o e filtros de dados. Ele tamb√©m pode conter metadados adicionais.

No Android, uma atividade/servi√ßo/provedor de conte√∫do/receptor de transmiss√£o √© **p√∫blico** quando **`exported`** √© definido como **`true`**, mas um componente tamb√©m √© **p√∫blico** se o **manifesto especificar um filtro de inten√ß√£o** para ele. No entanto, os desenvolvedores podem **tornar explicitamente os componentes privados** (independentemente de quaisquer filtros de inten√ß√£o) definindo o atributo **`exported`** como `false` para cada componente no arquivo manifesto. Os desenvolvedores tamb√©m podem definir o atributo **`permission`** para **exigir uma determinada permiss√£o para acessar** o componente, restringindo assim o acesso ao componente.

### Inten√ß√µes Impl√≠citas

As inten√ß√µes s√£o criadas programaticamente usando um construtor de inten√ß√µes:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
A **A√ß√£o** do intent declarado anteriormente √© **ACTION\_SEND** e o **Extra** √© um **Uri** de mailto (o Extra √© a informa√ß√£o extra que o intent espera).

Este intent deve ser declarado dentro do manifesto como no exemplo a seguir:
```markup
<activity android:name="ShareActivity">
	<intent-filter>
       <action android:name="android.intent.action.SEND" />
       <category android:name="android.intent.category.DEFAULT" />
    </intent-filter>
</activity>
```
Um intent-filter precisa corresponder √† **a√ß√£o**, **dados** e **categoria** para receber uma mensagem.

O processo de "resolu√ß√£o de inten√ß√£o" determina qual aplicativo deve receber cada mensagem. Esse processo considera o atributo de **prioridade**, que pode ser definido na declara√ß√£o do **intent-filter**, e **aquele com a maior prioridade ser√° selecionado**. Essa prioridade pode ser definida entre -1000 e 1000 e os aplicativos podem usar o valor `SYSTEM_HIGH_PRIORITY`. Se ocorrer um **conflito**, uma janela "escolher" aparece para que o **usu√°rio possa decidir**.

### Inten√ß√µes expl√≠citas

Uma inten√ß√£o expl√≠cita especifica o nome da classe que est√° sendo direcionada:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Em outras aplica√ß√µes, para acessar o intent previamente declarado, voc√™ pode usar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Inten√ß√µes Pendentes

Elas permitem que outras aplica√ß√µes **realizem a√ß√µes em nome da sua aplica√ß√£o**, usando a identidade e permiss√µes do seu aplicativo. Ao construir uma Inten√ß√£o Pendente, deve-se **especificar uma inten√ß√£o e a a√ß√£o a ser executada**. Se a **inten√ß√£o declarada n√£o for expl√≠cita** (n√£o declarar qual inten√ß√£o pode cham√°-la), um **aplicativo malicioso pode executar a a√ß√£o declarada** em nome do aplicativo da v√≠tima. Al√©m disso, **se uma a√ß√£o n√£o for especificada**, o aplicativo malicioso poder√° fazer **qualquer a√ß√£o em nome da v√≠tima**.

### Inten√ß√µes de Transmiss√£o

Ao contr√°rio das inten√ß√µes anteriores, que s√£o recebidas apenas por um aplicativo, as inten√ß√µes de transmiss√£o **podem ser recebidas por v√°rios aplicativos**. No entanto, a partir da vers√£o API 14, √© **poss√≠vel especificar o aplicativo que deve receber** a mensagem usando Intent.setPackage.

Alternativamente, tamb√©m √© poss√≠vel **especificar uma permiss√£o ao enviar a transmiss√£o**. O aplicativo receptor precisar√° ter essa permiss√£o.

Existem **dois tipos** de transmiss√µes: **Normais** (ass√≠ncronas) e **Ordenadas** (s√≠ncronas). A **ordem** √© baseada na **prioridade configurada dentro do receptor**. **Cada aplicativo pode processar, retransmitir ou descartar a transmiss√£o.**

√â poss√≠vel **enviar** uma **transmiss√£o** usando a fun√ß√£o \*\*`sendBroadcast(intent, receiverPermission)` \*\* da classe `Context`.\
Voc√™ tamb√©m pode usar a fun√ß√£o **`sendBroadcast`** do **`LocalBroadCastManager`** para garantir que a **mensagem nunca saia do aplicativo**. Usando isso, voc√™ nem precisar√° exportar um componente receptor.

### Transmiss√µes Adesivas

Esse tipo de transmiss√£o **pode ser acessado muito tempo depois de ser enviado**.\
Eles foram descontinuados no n√≠vel de API 21 e √© recomend√°vel **n√£o us√°-los**.\
**Eles permitem que qualquer aplicativo espie os dados, mas tamb√©m os modifique.**

Se voc√™ encontrar fun√ß√µes contendo a palavra "adesivo" como **`sendStickyBroadcast`** ou **`sendStickyBroadcastAsUser`**, **verifique o impacto e tente remov√™-los**.

## Links Profundos / Esquemas de URL

**Links profundos permitem acionar uma inten√ß√£o via URL**. Um aplicativo pode declarar um **esquema de URL** dentro de uma atividade, para que toda vez que o dispositivo Android tente **acessar um endere√ßo usando esse esquema**, a atividade do aplicativo seja chamada:

![](<../../.gitbook/assets/image (214).png>)

Neste caso, o esquema √© `myapp://` (observe tamb√©m a **`categoria BROWSABLE`**)

Se dentro do `intent-filter` voc√™ encontrar algo como isto:

![](<../../.gitbook/assets/image (263).png>)

Ent√£o, est√° esperando algo como `http://www.example.com/gizmos`

Se voc√™ encontrar algo como isto:

![](<../../.gitbook/assets/image (262).png>)

Significar√° que est√° esperando um URL come√ßando por `example://gizmos`\
Neste caso, voc√™ pode tentar abusar da funcionalidade criando uma p√°gina da web com as seguintes cargas √∫teis. Ele tentar√° navegar para p√°ginas arbitr√°rias e tentar√° executar JS:
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Para encontrar o **c√≥digo que ser√° executado no aplicativo**, v√° para a atividade chamada pelo deeplink e procure a fun√ß√£o **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Aprenda como [chamar deep links sem usar p√°ginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Android Interface Definition Language

A **Linguagem de Defini√ß√£o de Interface Android** (AIDL) permite definir a interface de programa√ß√£o que tanto o cliente quanto o servi√ßo concordam em usar para **comunicar-se entre si usando comunica√ß√£o entre processos** (IPC). No Android, **um processo normalmente n√£o pode acessar a mem√≥ria de outro processo**. Ent√£o, para conversar, eles precisam decompor seus objetos em primitivas que o **sistema operacional** possa entender e enviar os objetos atrav√©s dessa fronteira para voc√™. O c√≥digo para fazer essa transfer√™ncia √© tedioso de escrever, ent√£o o Android o manipula para voc√™ com o AIDL.

Servi√ßos que usam AIDL s√£o referidos como **Servi√ßos Vinculados**. Na classe do servi√ßo, voc√™ encontrar√° o m√©todo **`onBind`**. √â **onde a intera√ß√£o come√ßa**, ent√£o √© a parte inicial do c√≥digo a ser revisada em busca de poss√≠veis vulnerabilidades.

Um servi√ßo vinculado √© o servidor em uma interface cliente-servidor. **Ele permite que componentes (como atividades) se vinculem ao servi√ßo, enviem solicita√ß√µes, recebam respostas e realizem comunica√ß√£o entre processos** (IPC). Um servi√ßo vinculado normalmente vive apenas enquanto serve outro componente do aplicativo e n√£o √© executado em segundo plano indefinidamente.

### Messenger

Um Messenger √© outro tipo de mecanismo IPC. Como o **Messenger tamb√©m √© um "Servi√ßo Vinculado"**, os dados passados do aplicativo cliente tamb√©m s√£o processados atrav√©s do m√©todo `onBind`. Portanto, a revis√£o do c√≥digo deve come√ßar por este m√©todo e voc√™ deve procurar a invoca√ß√£o de funcionalidades sens√≠veis ou manipula√ß√£o insegura de dados.

### Binder

√â estranho encontrar uma classe Binder invocada diretamente, pois √© muito mais f√°cil usar o AIDL (que abstrai a classe Binder). No entanto, √© bom saber que o **Binder √© um driver de n√≠vel de kernel que move dados da mem√≥ria de um processo para a de outro** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Componentes

Estes incluem: **Atividades, Servi√ßos, Receptores de Transmiss√£o e Provedores.**

### Atividade de Lan√ßamento e outras atividades

Uma **atividade Android** √© uma tela da interface do usu√°rio do aplicativo Android. Nesse sentido, uma **atividade Android** √© muito semelhante √†s janelas em um aplicativo de desktop. Um aplicativo Android pode conter uma ou mais atividades, ou seja, uma ou mais telas.

A **atividade de lan√ßamento** √© o que a maioria das pessoas pensa como o **ponto de entrada** para um aplicativo Android. A atividade de lan√ßamento √© a atividade que √© iniciada quando um usu√°rio clica no √≠cone de um aplicativo. Voc√™ pode determinar a atividade de lan√ßamento olhando o manifesto do aplicativo. A atividade de lan√ßamento ter√° as seguintes inten√ß√µes MAIN e LAUNCHER listadas.

Lembre-se de que nem todo aplicativo ter√° uma atividade de lan√ßamento, especialmente aplicativos sem interface do usu√°rio. Exemplos de aplicativos sem interface do usu√°rio (e, portanto, sem atividade de lan√ßamento) s√£o aplicativos pr√©-instalados que executam servi√ßos em segundo plano, como correio de voz.
```markup
<activity android:name=".LauncherActivity">
	<intent-filter>
    	<action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
```
As atividades podem ser exportadas permitindo que outros processos no dispositivo iniciem a atividade. Por padr√£o, elas n√£o s√£o exportadas, mas voc√™ pode export√°-las definindo:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Observe que a capacidade de **burlar prote√ß√µes de atividades nem sempre √© uma vulnerabilidade**, voc√™ precisa verificar a qual dados voc√™ obteve acesso. Al√©m disso, **algumas atividades retornam dados para um chamador**. Nesses cen√°rios, voc√™ precisa procurar o m√©todo **`setResult`** e verificar os dados que s√£o passados para o par√¢metro Intent. **Se forem dados sens√≠veis, voc√™ pode ter uma vulnerabilidade de vazamento de informa√ß√µes** e ela pode ser explorada com aplicativos capazes de se comunicar com a Activity.

**O c√≥digo de uma atividade come√ßa com o m√©todo `onCreate`.**

### Subclasse de Aplicativo

Os aplicativos Android podem definir uma **subclasse** de [Application](https://developer.android.com/reference/android/app/Application). Os aplicativos podem, mas n√£o precisam definir uma subclasse personalizada de Application. Se um aplicativo Android define uma subclasse de Application, **essa classe √© instanciada antes de qualquer outra classe no aplicativo**.

Se o m√©todo **`attachBaseContext`** for definido na subclasse de Application, ele ser√° chamado primeiro, antes do m√©todo **`onCreate`**.

### Servi√ßos

[Servi√ßos](https://developer.android.com/guide/components/services) **executam em segundo plano sem uma interface do usu√°rio.** Eles s√£o usados para realizar **processos de longa dura√ß√£o, mesmo se o usu√°rio come√ßar a usar um aplicativo diferente**.

Existem in√∫meras maneiras pelas quais eles podem ser iniciados e, portanto, s√£o um ponto de entrada para aplicativos. A maneira padr√£o pela qual um servi√ßo pode ser iniciado como um ponto de entrada para um aplicativo √© por meio de **Intents**.

Quando o m√©todo **`startService`** √© chamado para iniciar um Servi√ßo, o m√©todo **`onStart`** no Servi√ßo √© executado. Ele ser√° executado indefinidamente at√© que o m√©todo **`stopService`** seja chamado. Se o servi√ßo for necess√°rio apenas enquanto o cliente estiver conectado, o cliente deve "vincul√°-lo" usando o m√©todo **`bindService`**.

Para um **servi√ßo vinculado** (consulte a se√ß√£o anterior), os dados ser√£o passados para o m√©todo **`onBind`**.

Por exemplo, um servi√ßo pode reproduzir m√∫sica em segundo plano enquanto o usu√°rio est√° em um aplicativo diferente, ou pode buscar dados na rede sem bloquear a intera√ß√£o do usu√°rio com uma atividade.

Um **servi√ßo pode ser exportado, o que permite que outros processos no dispositivo iniciem o servi√ßo**. Por padr√£o, os servi√ßos n√£o s√£o exportados, mas podem ser configurados no Manifest:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Receptores de transmiss√£o

As transmiss√µes podem ser consideradas um sistema de mensagens e **os receptores de transmiss√£o s√£o os ouvintes**. Se um aplicativo registrou um receptor para uma transmiss√£o espec√≠fica, o c√≥digo desse receptor √© executado quando o sistema envia a transmiss√£o. Observe que, nesse caso, **v√°rios aplicativos podem receber a mesma mensagem**.

Existem **2 maneiras** pelas quais um aplicativo pode **registrar um receptor**: no **Manifest do aplicativo ou registrado dinamicamente** no c√≥digo do aplicativo usando a chamada de API **`registerReceiver`**. No manifesto, voc√™ pode limitar as transmiss√µes que aceita por meio do **uso de permiss√µes dentro do elemento receptor**. Quando definido **dinamicamente**, voc√™ pode **passar a permiss√£o para o m√©todo `registerReceiver`**.

Em ambos os casos, para registrar o receptor, os **filtros de inten√ß√£o para o receptor s√£o definidos**. Esses filtros de inten√ß√£o s√£o as transmiss√µes que devem acionar o receptor.

Quando as transmiss√µes espec√≠ficas s√£o enviadas para as quais o receptor est√° registrado, **`onReceive`** na classe BroadcastReceiver √© **executado**.

Um aplicativo pode registrar um receptor para a mensagem de bateria fraca, por exemplo, e alterar seu comportamento com base nessa informa√ß√£o.

A transmiss√£o pode ser **ass√≠ncrona** (cada receptor a recebe) ou **s√≠ncrona** (a transmiss√£o √© recebida de maneira ordenada com base na prioridade definida para receb√™-la).

{% hint style="danger" %}
**Observe que qualquer aplicativo pode se definir como prioridade m√°xima para receber uma transmiss√£o.**
{% endhint %}

Para **examinar** o **c√≥digo** implementado em um receptor de transmiss√£o, voc√™ precisa procurar o m√©todo **`onReceive`** da classe do receptor.\
Observe que as **Transmiss√µes Ordenadas podem descartar o Intent recebido ou at√© mesmo modific√°-lo** usando um dos m√©todos setter. Portanto, os **receptores devem validar os dados**.

### Provedor de conte√∫do

Os provedores de conte√∫do s√£o a maneira como os **aplicativos compartilham dados estruturados**, como bancos de dados relacionais. Portanto, √© muito importante usar **permiss√µes** e definir o n√≠vel de prote√ß√£o apropriado para proteg√™-los.\
Os provedores de conte√∫do podem usar os atributos **`readPermission`** e **`writePermission`** para especificar quais permiss√µes um aplicativo deve ter. **Essas permiss√µes t√™m preced√™ncia sobre o atributo de permiss√£o**.\
Al√©m disso, eles tamb√©m podem **permitir exce√ß√µes tempor√°rias** definindo o **`grantUriPermission`** como verdadeiro e, em seguida, configurando os par√¢metros apropriados no elemento **`grant-uri-permission`** dentro do elemento do provedor dentro do arquivo manifesto.

O **`grant-uri-permission`** tem tr√™s atributos: path, pathPrefix e pathPattern:

* **path**: permite especificar todo o caminho a ser exclu√≠do
* **pathPrefix**: permite especificar o in√≠cio do caminho
* **pathPattern**: permite o uso de curingas e substitui√ß√µes simb√≥licas para obter um controle mais granular.

√â **importante validar e sanitizar a entrada recebida** para evitar vulnerabilidades potenciais, como inje√ß√£o de SQL.

**Recursos do Provedor de Conte√∫do:**

* O componente Provedor de Conte√∫do fornece dados de um aplicativo para outros sob demanda.
* Voc√™ pode armazenar os dados no sistema de arquivos, em um banco de dados SQLite, na web ou em qualquer outro local de armazenamento persistente que seu aplicativo possa acessar.
* Por meio do provedor de conte√∫do, outros aplicativos podem consultar ou at√© mesmo modificar os dados (se o provedor de conte√∫do permitir).
* O provedor de conte√∫do √© √∫til nos casos em que um aplicativo deseja compartilhar dados com outro aplicativo.
* √â muito semelhante a bancos de dados e possui quatro m√©todos.
  * insert()
  * update()
  * delete()
  * query()

**FileProvider**

Este √© um tipo de Provedor de Conte√∫do que ir√° **compartilhar arquivos** de uma pasta. Voc√™ pode declarar um provedor de arquivos assim:
```markup
<provider android:name="androidx.core.content.FileProvider"
            android:authorities="com.example.myapp.fileprovider"
            android:grantUriPermissions="true" android:exported="false">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/filepaths" />
</provider>
```
Observe o atributo **`android:exported`** porque se for **`true`** aplicativos externos poder√£o acessar as pastas compartilhadas.\
Observe que a configura√ß√£o `android:resource="@xml/filepaths"` est√° indicando que o arquivo _res/xml/filepaths.xml_ cont√©m a configura√ß√£o de **quais pastas** este **FileProvider** ir√° **compartilhar**. Este √© um exemplo de como indicar para compartilhar uma pasta naquele arquivo:
```markup
<paths>
    <files-path path="images/" name="myimages" />
</paths>
```
Compartilhar algo como **`path="."`** pode ser **perigoso** mesmo que o provedor n√£o seja exportado, se houver outra vulnerabilidade em alguma parte do c√≥digo que tente acessar esse provedor.\
Voc√™ pode **acessar** uma **imagem** dentro dessa pasta com `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

O elemento `<paths>` pode ter v√°rios filhos, cada um especificando um diret√≥rio diferente para compartilhar. Al√©m do elemento **`<files-path>`**, voc√™ pode usar o elemento **`<external-path>`** para compartilhar diret√≥rios no **armazenamento externo**, e o elemento **`<cache-path>`** para compartilhar diret√≥rios no seu **diret√≥rio de cache interno**.\
[Para obter mais informa√ß√µes sobre atributos espec√≠ficos de provedores de arquivos, v√° aqui.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[Mais informa√ß√µes sobre FileProviders aqui](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

WebViews s√£o efetivamente **navegadores da web** incorporados em aplicativos Android.\
O conte√∫do do WebView pode ser retirado de sites remotos ou pode ser arquivos inclu√≠dos no aplicativo.\
Os WebViews s√£o **vulner√°veis √†s mesmas vulnerabilidades que afetam qualquer navegador da web**. No entanto, existem algumas **configura√ß√µes** que podem ser √∫teis para **limitar** a **superf√≠cie de ataque**.

Existem dois tipos de WebViews no Android:

* O **WebViewClient**, mais adequado para renderiza√ß√£o de HTML simples. Isso n√£o executar√° a fun√ß√£o de alerta JS. Portanto, testes de XSS usando essa fun√ß√£o ser√£o inv√°lidos.
* O **cliente WebChrome**, √© um navegador Chrome.

Observe que **os navegadores WebView n√£o t√™m acesso aos cookies do navegador nativo**.

Para carregar uma URL ou arquivo, √© poss√≠vel usar as fun√ß√µes **`loadUrl`**, **`loadData`** ou **`loadDataWithBaseURL`**. **√â importante acessar apenas URLs sanitizados.**\
A seguran√ßa do WebView pode ser configurada por meio do objeto **`WebSettings`**.\
Por exemplo, a execu√ß√£o de c√≥digo JS pode ser desativada usando o m√©todo **`setJavaScriptEnabled`** com o valor **`false`**. Isso **remover√°** a possibilidade de um **XSS** e outras vulnerabilidades relacionadas ao JS.

A funcionalidade JavaScript "**Bridge**" **injeta objetos Java em um WebView tornando-os acess√≠veis ao JS**. A partir do Android 4.2, os m√©todos devem ser anotados com **`@JavascriptInterface`** para serem acess√≠veis ao JavaScript.

Se **`true`** for passado para **`setAllowContentAccess`**, **os WebViews poder√£o acessar os Provedores de Conte√∫do** via esquema **`content://`**. Isso obviamente representa um risco de seguran√ßa. Observe que, se esse acesso for concedido, √© muito importante **garantir** que a URL **`content://`** seja **segura**.

Por padr√£o, arquivos locais podem ser acessados pelos WebViews por meio de URLs file://, mas existem v√°rias maneiras de impedir esse comportamento:

* Passar **`false`** para **`setAllowFileAccess`**, impede o acesso ao sistema de arquivos com exce√ß√£o de ativos via `file:///android_asset` _e_ `file:///android_res`. Esses caminhos devem ser usados apenas para dados n√£o confidenciais (como imagens), portanto, isso deve ser seguro.
* O m√©todo **`setAllowFileAccess`** indica se um caminho de uma URL `file://` deve ser capaz de acessar o conte√∫do de outras URLs do esquema de arquivo.
* O m√©todo **`setAllowUniversalAccessFromFileURLs`** indica se um caminho de uma URL `file://` deve ser capaz de acessar o conte√∫do de qualquer origem.

## Outros componentes do aplicativo

### **Assinatura do aplicativo**

* O Android requer que **todos os aplicativos sejam assinados digitalmente com um certificado** antes que possam ser instalados. O Android usa este certificado para identificar o autor de um aplicativo.
* Para executar o aplicativo no dispositivo, ele deve ser assinado. Quando o aplicativo √© instalado em um dispositivo, o **gerenciador de pacotes verifica** se o aplicativo foi assinado corretamente com o certificado no arquivo apk ou n√£o.
* O aplicativo pode ser autoassinado ou pode ser assinado por meio de uma CA.
* A assinatura do aplicativo garante que um aplicativo n√£o possa acessar nenhum outro aplicativo, exceto por meio de IPC bem definido e tamb√©m que ele seja passado sem modifica√ß√µes para o dispositivo.

### **Verifica√ß√£o do aplicativo**

* O Android 4.2 e posterior suportam a verifica√ß√£o do aplicativo. Os usu√°rios podem optar por habilitar "Verificar aplicativos" e ter aplicativos avaliados por um verificador de aplicativos antes da instala√ß√£o.
* A verifica√ß√£o do aplicativo pode alertar o usu√°rio se ele tentar instalar um aplicativo que possa ser prejudicial; se um aplicativo for especialmente ruim, ele pode bloquear a instala√ß√£o.

## Gerenciamento de dispositivos m√≥veis

MDM ou Mobile Device Management s√£o conjuntos de software usados para **garantir requisitos de controle e seguran√ßa** sobre dispositivos m√≥veis. Esses conjuntos usam recursos referidos como API de Administra√ß√£o de Dispositivos e requerem a instala√ß√£o de um aplicativo Android.

Geralmente, as solu√ß√µes MDM executam fun√ß√µes como impor pol√≠ticas de senha, for√ßar a criptografia de armazenamento e permitir a exclus√£o remota de dados do dispositivo.

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga o HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

üêû Leia tutoriais de bugs web3

üîî Receba notifica√ß√µes sobre novas recompensas por bugs

üí¨ Participe de discuss√µes na comunidade

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga** me no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas dicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud).

</details>
