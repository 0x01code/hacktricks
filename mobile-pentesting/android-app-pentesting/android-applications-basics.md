# Conceitos B√°sicos de Aplica√ß√µes Android

<details>

<summary><strong>Aprenda a hackear a AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe seus truques de hacking enviando PRs para** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encontre vulnerabilidades que mais importam para que voc√™ possa corrigi-las mais rapidamente. O Intruder rastreia sua superf√≠cie de ataque, executa varreduras proativas de amea√ßas, encontra problemas em toda a sua pilha tecnol√≥gica, de APIs a aplicativos da web e sistemas em nuvem. [**Experimente gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoje.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Modelo de Seguran√ßa Android

**Existem duas camadas:**

* O **SO**, que mant√©m aplicativos instalados isolados uns dos outros.
* O **pr√≥prio aplicativo**, que permite aos desenvolvedores **expor certas funcionalidades** e configurar as capacidades do aplicativo.

### Separa√ß√£o de UID

**Cada aplicativo √© atribu√≠do a um ID de Usu√°rio espec√≠fico**. Isso √© feito durante a instala√ß√£o do aplicativo para que o **aplicativo s√≥ possa interagir com arquivos de propriedade de seu ID de Usu√°rio ou arquivos compartilhados**. Portanto, apenas o pr√≥prio aplicativo, certos componentes do SO e o usu√°rio root podem acessar os dados dos aplicativos.

### Compartilhamento de UID

**Dois aplicativos podem ser configurados para usar o mesmo UID**. Isso pode ser √∫til para compartilhar informa√ß√µes, mas se um deles for comprometido, os dados de ambos os aplicativos ser√£o comprometidos. Por isso, esse comportamento √© **desencorajado**.\
**Para compartilhar o mesmo UID, os aplicativos devem definir o mesmo valor `android:sharedUserId`** em seus manifestos.

### Isolamento

A **Sandbox de Aplicativos Android** permite executar **cada aplicativo** como um **processo separado sob um ID de usu√°rio separado**. Cada processo tem sua pr√≥pria m√°quina virtual, ent√£o o c√≥digo de um aplicativo √© executado isoladamente de outros aplicativos.\
A partir do Android 5.0(L), o **SELinux** √© aplicado. Basicamente, o SELinux negou todas as intera√ß√µes de processos e ent√£o criou pol√≠ticas para **permitir apenas as intera√ß√µes esperadas entre eles**.

### Permiss√µes

Quando voc√™ instala um **aplicativo e ele solicita permiss√µes**, o aplicativo est√° pedindo as permiss√µes configuradas nos elementos **`uses-permission`** no arquivo **AndroidManifest.xml**. O elemento **uses-permission** indica o nome da permiss√£o solicitada dentro do **atributo de nome**. Ele tamb√©m possui o atributo **maxSdkVersion** que impede a solicita√ß√£o de permiss√µes em vers√µes superiores √† especificada.\
Observe que os aplicativos Android n√£o precisam solicitar todas as permiss√µes no in√≠cio, eles tamb√©m podem **solicitar permiss√µes dinamicamente**, mas todas as permiss√µes devem ser **declaradas** no **manifesto**.

Quando um aplicativo exp√µe funcionalidades, ele pode limitar o **acesso apenas a aplicativos que possuem uma permiss√£o especificada**.\
Um elemento de permiss√£o tem tr√™s atributos:

* O **nome** da permiss√£o
* O atributo **permission-group**, que permite agrupar permiss√µes relacionadas.
* O **n√≠vel de prote√ß√£o** que indica como as permiss√µes s√£o concedidas. Existem quatro tipos:
  * **Normal**: Usado quando n√£o h√° **amea√ßas conhecidas** ao aplicativo. O usu√°rio **n√£o precisa aprovar**.
  * **Perigoso**: Indica que a permiss√£o concede ao aplicativo solicitante **acesso elevado**. **Os usu√°rios s√£o solicitados a aprov√°-los**.
  * **Assinatura**: Apenas **aplicativos assinados pelo mesmo certificado que o** exportando o componente podem receber permiss√£o. Este √© o tipo mais forte de prote√ß√£o.
  * **AssinaturaOuSistema**: Apenas **aplicativos assinados pelo mesmo certificado que o** exportando o componente ou **aplicativos em execu√ß√£o com acesso de n√≠vel de sistema** podem receber permiss√µes.

## Aplicativos Pr√©-Instalados

Esses aplicativos geralmente s√£o encontrados nos diret√≥rios **`/system/app`** ou **`/system/priv-app`** e alguns deles s√£o **otimizados** (voc√™ pode nem encontrar o arquivo `classes.dex`). Esses aplicativos valem a pena verificar porque √†s vezes eles est√£o **executando com muitas permiss√µes** (como root).

* Os enviados com o **ROM** do **AOSP** (Projeto de C√≥digo Aberto Android)
* Adicionados pelo **fabricante** do dispositivo
* Adicionados pelo **provedor** de telefonia celular (se comprado deles)

## Rooting

Para obter acesso root a um dispositivo Android f√≠sico, geralmente √© necess√°rio **explorar** 1 ou 2 **vulnerabilidades** que costumam ser **espec√≠ficas** para o **dispositivo** e **vers√£o**.\
Depois que o exploit funcionar, geralmente o bin√°rio `su` do Linux √© copiado para uma localiza√ß√£o especificada na vari√°vel de ambiente PATH do usu√°rio, como `/system/xbin`.

Depois que o bin√°rio su estiver configurado, outro aplicativo Android √© usado para interagir com o bin√°rio `su` e **processar solicita√ß√µes de acesso root** como **Superuser** e **SuperSU** (dispon√≠vel na Google Play Store).

{% hint style="danger" %}
Observe que o processo de root √© muito perigoso e pode danificar severamente o dispositivo
{% endhint %}

### ROMs

√â poss√≠vel **substituir o SO instalando um firmware personalizado**. Fazendo isso, √© poss√≠vel estender a utilidade de um dispositivo antigo, contornar restri√ß√µes de software ou obter acesso ao c√≥digo Android mais recente.\
**OmniROM** e **LineageOS** s√£o dois dos firmwares mais populares para usar.

Observe que **nem sempre √© necess√°rio fazer root no dispositivo** para instalar um firmware personalizado. **Alguns fabricantes permitem** o desbloqueio de seus carregadores de inicializa√ß√£o de maneira bem documentada e segura.

### Implica√ß√µes

Depois que um dispositivo √© rooteado, qualquer aplicativo pode solicitar acesso como root. Se um aplicativo malicioso obtiver acesso, ele poder√° ter acesso a quase tudo e poder√° danificar o telefone.

## Fundamentos de Aplicativos Android <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a>

- O formato de aplicativos Android √© referido como _formato de arquivo APK_. √â essencialmente um **arquivo ZIP** (renomeando a extens√£o do arquivo para .zip, os conte√∫dos podem ser extra√≠dos e visualizados).
- Conte√∫do do APK (n√£o exaustivo)
- **AndroidManifest.xml**
- resources.arsc/strings.xml
- resources.arsc: cont√©m recursos pr√©-compilados, como XML bin√°rio.
- res/xml/files\_paths.xml
- META-INF/
- Aqui √© onde o Certificado est√° localizado!
- **classes.dex**
- Cont√©m bytecode Dalvik, representando o c√≥digo Java (ou Kotlin) compilado que o aplicativo executa por padr√£o.
- lib/
- Armazena bibliotecas nativas, segregadas por arquitetura de CPU em subdiret√≥rios.
- `armeabi`: c√≥digo para processadores baseados em ARM
- `armeabi-v7a`: c√≥digo para processadores baseados em ARMv7 e superiores
- `x86`: c√≥digo para processadores X86
- `mips`: c√≥digo apenas para processadores MIPS
- assets/
- Armazena arquivos diversos necess√°rios pelo aplicativo, potencialmente incluindo bibliotecas nativas adicionais ou arquivos DEX, √†s vezes usados por autores de malware para ocultar c√≥digo adicional.
- res/
- Cont√©m recursos que n√£o s√£o compilados em resources.arsc

### **Dalvik & Smali**

- A maioria dos aplicativos Android √© desenvolvida em Java ou Kotlin (intercambi√°veis neste contexto quando referidos como "Java").
- **Em vez de executar c√≥digo Java na M√°quina Virtual Java** (JVM) como aplicativos de desktop, o Android compila o Java em **Bytecode Execut√°vel Dalvik (DEX)**.
- A tradu√ß√£o do bytecode historicamente era tratada pela m√°quina virtual Dalvik, enquanto vers√µes mais recentes do Android usam o Android Runtime (ART).
- O processo de engenharia reversa envolve a descompila√ß√£o do bytecode DEX de volta para um formato leg√≠vel por humanos.

**Smali √© a forma leg√≠vel por humanos do bytecode Dalvik**. Embora "Smali" e "baksmali" tecnicamente se refiram √†s ferramentas de montagem e desmontagem, no contexto do Android, "Smali" muitas vezes denota as instru√ß√µes em si. **SMALI √© semelhante √† linguagem de montagem, servindo como intermedi√°rio entre o c√≥digo-fonte e o bytecode**.


<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encontre vulnerabilidades que mais importam para que voc√™ possa corrigi-las mais rapidamente. O Intruder rastreia sua superf√≠cie de ataque, executa varreduras proativas de amea√ßas, encontra problemas em toda a sua pilha tecnol√≥gica, de APIs a aplicativos da web e sistemas em nuvem. [**Experimente gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoje.

*** 

## Inten√ß√µes

As inten√ß√µes s√£o o principal meio pelo qual os aplicativos Android se comunicam entre seus componentes ou com outros aplicativos. Esses objetos de mensagem tamb√©m podem transportar dados entre aplicativos ou componentes, semelhante ao uso de solicita√ß√µes GET/POST em comunica√ß√µes HTTP.

Portanto, uma Inten√ß√£o √© basicamente uma **mensagem que √© passada entre componentes**. As inten√ß√µes **podem ser direcionadas** para componentes ou aplicativos espec√≠ficos, **ou podem ser enviadas sem um destinat√°rio espec√≠fico**.\
Para ser simples, a Inten√ß√£o pode ser usada para:

* Iniciar uma Activity, normalmente abrindo uma interface de usu√°rio para um aplicativo
* Como transmiss√µes para informar o sistema e aplicativos sobre altera√ß√µes
* Para iniciar, parar e se comunicar com um servi√ßo em segundo plano
* Para acessar dados via ContentProviders
* Como callbacks para lidar com eventos

Uma implementa√ß√£o inadequada pode resultar em vazamento de dados, chamadas de fun√ß√µes restritas e manipula√ß√£o do fluxo do programa.

### Filtro de Inten√ß√£o

Um Filtro de Inten√ß√£o especifica os **tipos de Inten√ß√£o aos quais uma atividade, servi√ßo ou Receptor de Transmiss√£o pode responder**. Ele especifica o que uma atividade ou servi√ßo pode fazer e que tipos de transmiss√µes um Receptor pode manipular. Ele permite que o componente correspondente receba Inten√ß√µes do tipo declarado. Os Filtros de Inten√ß√£o s√£o tipicamente **definidos via arquivo AndroidManifest.xml**. Para **Receptor de Transmiss√£o**, tamb√©m √© poss√≠vel defini-los em **c√≥digo**. Um Filtro de Inten√ß√£o √© definido por suas categorias, a√ß√µes e filtros de dados. Ele tamb√©m pode conter metadados adicionais.

No Android, uma atividade/servi√ßo/provedor de conte√∫do/receptor de transmiss√£o √© **p√∫blico** quando **`exported`** √© definido como **`true`**, mas um componente tamb√©m √© **p√∫blico** se o **manifesto especificar um Filtro de Inten√ß√£o** para ele. No entanto,\
os desenvolvedores podem **tornar os componentes explicitamente privados** (independentemente de quaisquer filtros de inten√ß√£o)\
definindo o atributo \*\* `exported` como `false`\*\* para cada componente no arquivo de manifesto.\
Os desenvolvedores tamb√©m podem definir o atributo **`permission`** para **exigir uma determinada permiss√£o para acessar** o componente, restringindo assim o acesso ao componente.

### Inten√ß√µes Impl√≠citas

As Inten√ß√µes s√£o criadas programaticamente usando um construtor de Inten√ß√µes:
```java
Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
```
A **A√ß√£o** do intent previamente declarado √© **ACTION\_SEND** e o **Extra** √© um **Uri** mailto (o Extra √© a informa√ß√£o extra que o intent est√° esperando).

Este intent deve ser declarado dentro do manifesto como no exemplo a seguir:
```markup
<activity android:name="ShareActivity">
<intent-filter>
<action android:name="android.intent.action.SEND" />
<category android:name="android.intent.category.DEFAULT" />
</intent-filter>
</activity>
```
Um intent-filter precisa corresponder √† **a√ß√£o**, **dados** e **categoria** para receber uma mensagem.

O processo de "resolu√ß√£o de Intent" determina qual aplicativo deve receber cada mensagem. Esse processo considera o atributo de **prioridade**, que pode ser definido na declara√ß√£o do **intent-filter**, e **o com maior prioridade ser√° selecionado**. Essa prioridade pode ser definida entre -1000 e 1000 e os aplicativos podem usar o valor `SYSTEM_HIGH_PRIORITY`. Se surgir um **conflito**, uma janela de "escolha" aparece para que o **usu√°rio possa decidir**.

### Inten√ß√µes Expl√≠citas

Uma inten√ß√£o expl√≠cita especifica o nome da classe que est√° direcionando:
```java
Intent downloadIntent = new (this, DownloadService.class):
```
Em outras aplica√ß√µes, para acessar o intent previamente declarado, voc√™ pode usar:
```java
Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
```
### Inten√ß√µes Pendentes

Estas permitem que outras aplica√ß√µes **realizem a√ß√µes em nome da sua aplica√ß√£o**, utilizando a identidade e permiss√µes da sua aplica√ß√£o. Ao construir uma Inten√ß√£o Pendente, deve ser **especificada uma inten√ß√£o e a a√ß√£o a ser realizada**. Se a **inten√ß√£o declarada n√£o for Expl√≠cita** (n√£o declara qual inten√ß√£o pode cham√°-la), uma **aplica√ß√£o maliciosa poder√° realizar a a√ß√£o declarada** em nome da aplica√ß√£o da v√≠tima. Al√©m disso, **se uma a√ß√£o n√£o for especificada**, a aplica√ß√£o maliciosa poder√° realizar **qualquer a√ß√£o em nome da v√≠tima**.

### Inten√ß√µes de Transmiss√£o

Ao contr√°rio das inten√ß√µes anteriores, que s√£o recebidas apenas por uma aplica√ß√£o, as inten√ß√µes de transmiss√£o **podem ser recebidas por v√°rias aplica√ß√µes**. No entanto, a partir da vers√£o da API 14, √© **poss√≠vel especificar a aplica√ß√£o que deve receber** a mensagem usando Intent.setPackage.

Alternativamente, tamb√©m √© poss√≠vel **especificar uma permiss√£o ao enviar a transmiss√£o**. A aplica√ß√£o receptora precisar√° ter essa permiss√£o.

Existem **dois tipos** de Transmiss√µes: **Normais** (ass√≠ncronas) e **Ordenadas** (s√≠ncronas). A **ordem** √© baseada na **prioridade configurada dentro do elemento receptor**. **Cada aplica√ß√£o pode processar, retransmitir ou descartar a Transmiss√£o**.

√â poss√≠vel **enviar** uma **transmiss√£o** usando a fun√ß√£o \*\*`sendBroadcast(intent, receiverPermission)` \*\* da classe `Context`.\
Tamb√©m √© poss√≠vel usar a fun√ß√£o **`sendBroadcast`** do **`LocalBroadCastManager`** para garantir que a **mensagem nunca saia da aplica√ß√£o**. Usando isso, nem ser√° necess√°rio exportar um componente receptor.

### Transmiss√µes Persistentes

Este tipo de Transmiss√µes **pode ser acessado muito tempo ap√≥s serem enviadas**.\
Foram descontinuadas no n√≠vel da API 21 e √© recomendado **n√£o utiliz√°-las**.\
**Elas permitem que qualquer aplica√ß√£o espie os dados, mas tamb√©m os modifique**.

Se encontrar fun√ß√µes contendo a palavra "persistentes" como **`sendStickyBroadcast`** ou **`sendStickyBroadcastAsUser`**, **verifique o impacto e tente remov√™-las**.

## Links Profundos / Esquemas de URL

**Links profundos permitem acionar uma Inten√ß√£o via URL**. Uma aplica√ß√£o pode declarar um **esquema de URL** dentro de uma atividade para que toda vez que o dispositivo Android tente **acessar um endere√ßo usando esse esquema**, a atividade da aplica√ß√£o ser√° chamada:

![](<../../.gitbook/assets/image (214).png>)

Neste caso, o esquema √© `myapp://` (observe tamb√©m a **`categoria BROWSABLE`**)

Se dentro do `intent-filter` encontrar algo como isto:

![](<../../.gitbook/assets/image (263).png>)

Ent√£o, est√° esperando algo como `http://www.example.com/gizmos`

Se encontrar algo como isto:

![](<../../.gitbook/assets/image (262).png>)

Significar√° que est√° esperando um URL iniciando por `example://gizmos`\
Neste caso, poderia tentar abusar da funcionalidade criando um site com os seguintes payloads. Ele tentar√° navegar para p√°ginas arbitr√°rias e tentar executar JS:
```markup
<a href="example://gizmos/https://google.com">click here</a>
<a href="example://gizmos/javascript://%250dalert(1)">click here</a>
```
Para encontrar o **c√≥digo que ser√° executado no aplicativo**, v√° para a atividade chamada pelo deeplink e procure a fun√ß√£o **`onNewIntent`**.

![](<../../.gitbook/assets/image (436) (1) (1) (1).png>)

Saiba como [chamar deep links sem usar p√°ginas HTML](./#exploiting-schemes-deep-links).

## AIDL - Linguagem de Defini√ß√£o de Interface Android

A **Linguagem de Defini√ß√£o de Interface Android** (AIDL) permite definir a interface de programa√ß√£o com a qual o cliente e o servi√ßo concordam para **comunicar entre si usando comunica√ß√£o entre processos** (IPC). No Android, **um processo normalmente n√£o pode acessar a mem√≥ria de outro processo**. Portanto, para se comunicar, eles precisam decompor seus objetos em primitivas que o **sistema operacional** pode entender e transportar os objetos atrav√©s dessa fronteira para voc√™. O c√≥digo para fazer esse transporte √© tedioso de escrever, ent√£o o Android o trata para voc√™ com o AIDL.

Os servi√ßos que usam o AIDL s√£o chamados de **Servi√ßos Vinculados**. Na classe do Servi√ßo, voc√™ encontrar√° o m√©todo **`onBind`**. Este √© **onde a intera√ß√£o come√ßa**, ent√£o √© a parte inicial do c√≥digo a ser revisada em busca de vulnerabilidades potenciais.

Um servi√ßo vinculado √© o servidor em uma interface cliente-servidor. **Ele permite que componentes (como atividades) se vinculem ao servi√ßo, enviem solicita√ß√µes, recebam respostas e realizem comunica√ß√£o entre processos** (IPC). Um servi√ßo vinculado normalmente vive apenas enquanto serve a outro componente de aplicativo e n√£o √© executado em segundo plano indefinidamente.

### Messenger

Um Messenger √© outro tipo de mecanismo IPC. Como o **Messenger tamb√©m √© um "Servi√ßo Vinculado"**, os dados passados do aplicativo cliente tamb√©m s√£o processados atrav√©s do m√©todo `onBind`. Portanto, a revis√£o de c√≥digo deve come√ßar por este m√©todo e voc√™ deve procurar pela invoca√ß√£o de funcionalidades sens√≠veis ou manipula√ß√£o insegura de dados.

### Binder

√â incomum encontrar uma classe Binder invocada diretamente, pois √© muito mais f√°cil usar o AIDL (que abstrai a classe Binder). No entanto, √© bom saber que o **Binder √© um driver de n√≠vel de kernel que move dados da mem√≥ria de um processo para a de outro** ([https://www.youtube.com/watch?v=O-UHvFjxwZ8](https://www.youtube.com/watch?v=O-UHvFjxwZ8)).

## Componentes

Estes incluem: **Atividades, Servi√ßos, Receptores de Transmiss√£o e Provedores.**

### Atividade de Lan√ßamento e outras atividades

Uma **atividade Android** √© uma tela da interface do usu√°rio do aplicativo **Android**. Dessa forma, uma **atividade Android** √© muito semelhante a janelas em um aplicativo de desktop. Um aplicativo **Android** pode conter uma ou mais atividades, ou seja, uma ou mais telas.

A **atividade de lan√ßamento** √© o que a maioria das pessoas pensa como o **ponto de entrada** para um aplicativo Android. A atividade de lan√ßamento √© a atividade que √© iniciada quando um usu√°rio clica no √≠cone de um aplicativo. Voc√™ pode determinar a atividade de lan√ßamento olhando o manifesto do aplicativo. A atividade de lan√ßamento ter√° as inten√ß√µes MAIN e LAUNCHER listadas.

Lembre-se de que nem todo aplicativo ter√° uma atividade de lan√ßamento, especialmente aplicativos sem interface do usu√°rio. Exemplos de aplicativos sem interface do usu√°rio (e, portanto, sem atividade de lan√ßamento) s√£o aplicativos pr√©-instalados que executam servi√ßos em segundo plano, como correio de voz.
```markup
<activity android:name=".LauncherActivity">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
```
As atividades podem ser exportadas permitindo que outros processos no dispositivo iniciem a atividade. Por padr√£o, elas n√£o s√£o exportadas, mas voc√™ pode export√°-las definindo:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
Note que a capacidade de **burlar as prote√ß√µes de atividades nem sempre √© uma vulnerabilidade**, voc√™ precisa verificar a qual dados voc√™ obteve acesso.  
Al√©m disso, **algumas atividades retornam dados para um chamador**. Nestes cen√°rios, voc√™ precisa procurar pelo m√©todo **`setResult`** e verificar os dados que s√£o passados para o par√¢metro Intent. **Se forem dados sens√≠veis, voc√™ pode ter uma vulnerabilidade de vazamento de informa√ß√µes** e ela pode ser explorada por aplicativos capazes de se comunicar com a Atividade.

**O c√≥digo de uma atividade come√ßa com o m√©todo `onCreate`.**

### Subclasse de Aplicativo

Os aplicativos Android podem definir uma **subclasse** de [Application](https://developer.android.com/reference/android/app/Application). Os aplicativos podem, mas n√£o precisam definir uma subclasse personalizada de Application. Se um aplicativo Android define uma subclasse de Application, **esta classe √© instanciada antes de qualquer outra classe no aplicativo**.

Se o m√©todo **`attachBaseContext`** for definido na subclasse de Application, ele √© chamado primeiro, antes do m√©todo **`onCreate`**.

### Servi√ßos

[Servi√ßos](https://developer.android.com/guide/components/services) **rodam em segundo plano sem uma interface de usu√°rio.** Eles s√£o usados para realizar **processos de longa dura√ß√£o, mesmo se o usu√°rio come√ßar a usar um aplicativo diferente**.

Existem v√°rias maneiras de inici√°-los e, portanto, s√£o um ponto de entrada para aplicativos. A maneira padr√£o de iniciar um servi√ßo como ponto de entrada para um aplicativo √© atrav√©s de **Intents**.

Quando o m√©todo **`startService`** √© chamado para iniciar um Servi√ßo, o m√©todo **`onStart`** no Servi√ßo √© executado. Ele ser√° executado indefinidamente at√© que o m√©todo **`stopService`** seja chamado. Se o servi√ßo s√≥ for necess√°rio enquanto o cliente estiver conectado, o cliente deve "vincular-se" a ele usando o m√©todo **`bindService`**.

Para um **servi√ßo vinculado** (veja a se√ß√£o anterior), os dados ser√£o passados para o m√©todo **`onBind`**.

Por exemplo, um servi√ßo pode reproduzir m√∫sica em segundo plano enquanto o usu√°rio est√° em um aplicativo diferente, ou pode buscar dados pela rede sem bloquear a intera√ß√£o do usu√°rio com uma atividade.

Um **servi√ßo pode ser exportado, o que permite que outros processos no dispositivo iniciem o servi√ßo**. Por padr√£o, os servi√ßos n√£o s√£o exportados, mas isso pode ser configurado no Manifest:
```markup
<service android:name=".ExampleExportedService" android:exported="true"/>
```
### Receptores de Transmiss√£o

As transmiss√µes podem ser consideradas um sistema de mensagens e os **receptores de transmiss√£o s√£o os ouvintes**. Se um aplicativo tiver registrado um receptor para uma transmiss√£o espec√≠fica, o c√≥digo nesse receptor √© executado quando o sistema envia a transmiss√£o. Note que, nesse caso, **v√°rios aplicativos podem receber a mesma mensagem**.

Existem **2 maneiras** pelas quais um aplicativo pode **registrar um receptor**: no **Manifest do aplicativo ou registrado dinamicamente** no c√≥digo do aplicativo usando a chamada de API **`registerReceiver`**. No manifesto, voc√™ pode limitar as transmiss√µes que aceita por meio do **uso de permiss√µes dentro do elemento receptor**. Quando **definido dinamicamente**, voc√™ pode **passar a permiss√£o para o m√©todo `registerReceiver`**.

Em ambos os casos, para registrar o receptor, os **filtros de inten√ß√£o para o receptor s√£o definidos**. Esses filtros de inten√ß√£o s√£o as transmiss√µes que devem acionar o receptor.

Quando as transmiss√µes espec√≠ficas para as quais o receptor est√° registrado s√£o enviadas, o **`onReceive`** na classe BroadcastReceiver √© **executado**.

Um aplicativo pode registrar um receptor para a mensagem de bateria fraca, por exemplo, e alterar seu comportamento com base nessa informa√ß√£o.

A transmiss√£o pode ser **ass√≠ncrona** (cada receptor a recebe) ou **s√≠ncrona** (a transmiss√£o √© recebida de maneira ordenada com base na prioridade definida para receb√™-la).

{% hint style="danger" %}
**Observe que qualquer aplicativo pode se definir como prioridade m√°xima para receber uma Transmiss√£o.**
{% endhint %}

Para **examinar** o **c√≥digo** implementado em um Receptor de Transmiss√£o, voc√™ precisa procurar pelo m√©todo **`onReceive`** da classe do receptor.\
Observe que as **Transmiss√µes Ordenadas podem descartar o Intent recebido ou at√© mesmo modific√°-lo** usando um dos m√©todos setter. Portanto, os **receptores devem validar os dados**.

### Provedor de Conte√∫do

Os Provedores de Conte√∫do s√£o a maneira como os **aplicativos compartilham dados estruturados**, como bancos de dados relacionais. Portanto, √© muito importante usar **permiss√µes** e definir o n√≠vel de prote√ß√£o apropriado para proteg√™-los.\
Os Provedores de Conte√∫do podem usar os atributos **`readPermission`** e **`writePermission`** para especificar quais permiss√µes um aplicativo deve ter. **Essas permiss√µes t√™m preced√™ncia sobre o atributo de permiss√£o**.\
Al√©m disso, eles tamb√©m podem **permitir exce√ß√µes tempor√°rias** configurando o **`grantUriPermission`** como true e, em seguida, configurando os par√¢metros apropriados no elemento **`grant-uri-permission`** dentro do elemento do provedor no arquivo de manifesto.

O **`grant-uri-permission`** possui tr√™s atributos: path, pathPrefix e pathPattern:

* **path**: Permite especificar o caminho inteiro a ser exclu√≠do
* **pathPrefix**: Permite especificar o in√≠cio do caminho
* **pathPattern**: Permite o uso de curingas e substitui√ß√µes simb√≥licas para obter um controle mais granular.

√â **importante validar e sanitizar a entrada recebida** para evitar vulnerabilidades potenciais como inje√ß√£o de SQL.

**Recursos do Provedor de Conte√∫do:**

* O componente Provedor de Conte√∫do fornece dados de um aplicativo para outros sob demanda.
* Voc√™ pode armazenar os dados no sistema de arquivos, em um banco de dados SQLite, na web ou em qualquer outra localiza√ß√£o de armazenamento persistente que seu aplicativo possa acessar.
* Atrav√©s do provedor de conte√∫do, outros aplicativos podem consultar ou at√© mesmo modificar os dados (se o provedor de conte√∫do permitir).
* O Provedor de Conte√∫do √© √∫til em casos em que um aplicativo deseja compartilhar dados com outro aplicativo.
* √â muito semelhante a bancos de dados e possui quatro m√©todos.
  * insert()
  * update()
  * delete()
  * query()

**FileProvider**

Este √© um tipo de Provedor de Conte√∫do que ir√° **compartilhar arquivos** de uma pasta. Voc√™ pode declarar um provedor de arquivos assim:
```markup
<provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true" android:exported="false">
<meta-data
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" />
</provider>
```
Observe o atributo **`android:exported`** porque se for **`true`** aplicativos externos poder√£o acessar as pastas compartilhadas.\
Observe que a configura√ß√£o `android:resource="@xml/filepaths"` est√° indicando que o arquivo _res/xml/filepaths.xml_ cont√©m a configura√ß√£o de **quais pastas** este **FileProvider** ir√° **compartilhar**. Este √© um exemplo de como indicar o compartilhamento de uma pasta nesse arquivo:
```markup
<paths>
<files-path path="images/" name="myimages" />
</paths>
```
Compartilhar algo como **`path="."`** pode ser **perigoso** mesmo que o provedor n√£o seja exportado, se houver outra vulnerabilidade em alguma parte do c√≥digo que tente acessar esse provedor.\
Voc√™ poderia **acessar** uma **imagem** dentro dessa pasta com `content://com.example.myapp.fileprovider/myimages/default_image.jpg`

O elemento `<paths>` pode ter v√°rios filhos, cada um especificando um diret√≥rio diferente para compartilhar. Al√©m do elemento **`<files-path>`**, voc√™ pode usar o elemento **`<external-path>`** para compartilhar diret√≥rios no **armazenamento externo**, e o elemento **`<cache-path>`** para compartilhar diret√≥rios no seu **diret√≥rio de cache interno**.\
[Para mais informa√ß√µes sobre atributos espec√≠ficos de provedores de arquivos, acesse aqui.](https://developer.android.com/reference/androidx/core/content/FileProvider)

[Mais informa√ß√µes sobre FileProviders aqui](https://developer.android.com/training/secure-file-sharing/setup-sharing).

## WebViews

WebViews s√£o efetivamente **navegadores da web** incorporados em aplicativos Android.\
O conte√∫do dos WebViews pode ser obtido de sites remotos ou de arquivos inclu√≠dos no aplicativo.\
Os WebViews s√£o **vulner√°veis √†s mesmas vulnerabilidades que afetam qualquer navegador da web**. No entanto, existem algumas **configura√ß√µes** que podem ser √∫teis para **limitar** a **superf√≠cie de ataque**.

Existem dois tipos de WebViews no Android:

* O **WebViewClient**, mais adequado para renderiza√ß√£o de HTML simples. Isso n√£o executar√° a fun√ß√£o de alerta JS. Portanto, testes de XSS usando essa fun√ß√£o ser√£o inv√°lidos.
* O **cliente WebChrome**, √© um navegador Chrome.

Observe que os **navegadores WebView n√£o t√™m acesso aos cookies do navegador nativo**.

Para carregar uma URL ou arquivo, √© poss√≠vel usar as fun√ß√µes **`loadUrl`**, **`loadData`** ou **`loadDataWithBaseURL`**. **√â importante acessar apenas URLs sanitizadas.**\
A seguran√ßa do WebView pode ser configurada por meio do objeto **`WebSettings`**.\
Por exemplo, a execu√ß√£o de c√≥digo JS pode ser desativada usando o m√©todo **`setJavaScriptEnabled`** com o valor **`false`**. Isso **remover√°** a possibilidade de um **XSS** e outras vulnerabilidades relacionadas ao JS.

A funcionalidade de JavaScript "**Bridge**" **injeta objetos Java em um WebView tornando-os acess√≠veis ao JS**. A partir do Android 4.2, os m√©todos devem ser anotados com **`@JavascriptInterface`** para serem acess√≠veis ao JavaScript.

Se **`true`** for passado para **`setAllowContentAccess`**, os **WebViews poder√£o acessar Provedores de Conte√∫do** via esquema **`content://`**. Isso obviamente representa um risco de seguran√ßa. Observe que se esse acesso for concedido, √© muito importante **garantir** que a URL **`content://`** seja **segura**.

Por padr√£o, arquivos locais podem ser acessados pelos WebViews via URLs file://, mas existem v√°rias maneiras de evitar esse comportamento:

* Passar **`false`** para **`setAllowFileAccess`**, impede o acesso ao sistema de arquivos com exce√ß√£o de ativos via `file:///android_asset` _e_ `file:///android_res`. Esses caminhos devem ser usados apenas para dados n√£o sens√≠veis (como imagens), portanto, isso deve ser seguro.
* O m√©todo **`setAllowFileAccess`** indica se um caminho de uma URL `file://` deve ser capaz de acessar o conte√∫do de outras URLs de esquema de arquivo.
* O m√©todo **`setAllowUniversalAccessFromFileURLs`** indica se um caminho de uma URL `file://` deve ser capaz de acessar conte√∫do de qualquer origem.

## Outros componentes do aplicativo

### **Assinatura do Aplicativo**

* O Android requer que **todos os aplicativos sejam digitalmente assinados com um certificado** antes de poderem ser instalados. O Android usa este certificado para identificar o autor de um aplicativo.
* Para executar o aplicativo no dispositivo, ele deve ser assinado. Quando o aplicativo √© instalado em um dispositivo, o **gerenciador de pacotes verifica** se o aplicativo foi devidamente assinado com o certificado no arquivo apk ou n√£o.
* O aplicativo pode ser autoassinado ou assinado por uma AC.
* A assinatura do aplicativo garante que um aplicativo n√£o pode acessar nenhum outro aplicativo, exceto por meio de IPC bem definido e tamb√©m que ele √© passado sem modifica√ß√µes para o dispositivo.

### **Verifica√ß√£o do Aplicativo**

* O Android 4.2 e posterior suportam a verifica√ß√£o do aplicativo. Os usu√°rios podem optar por ativar "Verificar apps" e ter os aplicativos avaliados por um verificador de aplicativos antes da instala√ß√£o.
* A verifica√ß√£o do aplicativo pode alertar o usu√°rio se tentarem instalar um aplicativo que possa ser prejudicial; se um aplicativo for especialmente ruim, ele pode bloquear a instala√ß√£o.

## Gerenciamento de Dispositivos M√≥veis

MDM ou Gerenciamento de Dispositivos M√≥veis s√£o conjuntos de software usados para **garantir requisitos de controle e seguran√ßa** sobre dispositivos m√≥veis. Esses conjuntos usam os recursos referidos como API de Administra√ß√£o de Dispositivos e exigem a instala√ß√£o de um aplicativo Android.

Geralmente, as solu√ß√µes de MDM realizam fun√ß√µes como impor pol√≠ticas de senha, for√ßar a criptografia do armazenamento e permitir a limpeza remota dos dados do dispositivo.

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encontre vulnerabilidades que s√£o mais importantes para que voc√™ possa corrigi-las mais rapidamente. O Intruder rastreia sua superf√≠cie de ataque, executa varreduras proativas de amea√ßas, encontra problemas em toda a sua pilha de tecnologia, de APIs a aplicativos da web e sistemas em nuvem. [**Experimente gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoje.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
