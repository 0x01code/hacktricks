# iOS Frida Konfiguration

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

## Frida Installation

**Schritte zur Installation von Frida auf einem gejailbreakten Ger√§t:**

1. √ñffnen Sie die Cydia/Sileo-App.
2. Navigieren Sie zu Verwalten -> Quellen -> Bearbeiten -> Hinzuf√ºgen.
3. Geben Sie "https://build.frida.re" als URL ein.
4. Gehen Sie zur neu hinzugef√ºgten Frida-Quelle.
5. Installieren Sie das Frida-Paket.

Wenn Sie **Corellium** verwenden, m√ºssen Sie das Frida-Release von [https://github.com/frida/frida/releases](https://github.com/frida/frida/releases) herunterladen (`frida-gadget-[yourversion]-ios-universal.dylib.gz`) und entpacken und an den von Frida angeforderten dylib-Speicherort kopieren, z. B.: `/Users/[youruser]/.cache/frida/gadget-ios.dylib`

Nach der Installation k√∂nnen Sie den Befehl **`frida-ls-devices`** auf Ihrem PC verwenden und √ºberpr√ºfen, ob das Ger√§t angezeigt wird (Ihr PC muss darauf zugreifen k√∂nnen).\
F√ºhren Sie auch **`frida-ps -Uia`** aus, um die laufenden Prozesse des Telefons zu √ºberpr√ºfen.

## Frida ohne gejailbreaktes Ger√§t und ohne Patchen der App

Lesen Sie diesen Blog-Beitrag dar√ºber, wie Sie Frida auf nicht gejailbreakten Ger√§ten ohne Patchen der App verwenden k√∂nnen: [https://mrbypass.medium.com/unlocking-potential-exploring-frida-objection-on-non-jailbroken-devices-without-application-ed0367a84f07](https://mrbypass.medium.com/unlocking-potential-exploring-frida-objection-on-non-jailbroken-devices-without-application-ed0367a84f07)

## Frida-Client-Installation

Installieren Sie **Frida-Tools**:
```bash
pip install frida-tools
pip install frida
```
Mit dem installierten Frida-Server und dem laufenden und verbundenen Ger√§t **√ºberpr√ºfen** Sie, ob der Client **funktioniert**:
```bash
frida-ls-devices  # List devices
frida-ps -Uia     # Get running processes
```
## Frida Trace

Frida Trace is a powerful dynamic instrumentation tool that allows you to trace function calls and monitor the behavior of an iOS application in real-time. It can be used for various purposes, such as debugging, reverse engineering, and vulnerability analysis.

To configure Frida Trace in iOS, follow these steps:

1. **Install Frida**: Start by installing Frida on your iOS device. You can do this by using the Frida CLI or by downloading the Frida package from the official website and installing it manually.

2. **Prepare the iOS Application**: Next, you need to prepare the iOS application that you want to trace. This involves installing the application on your device and ensuring that it is running.

3. **Create a Frida Script**: Now, create a Frida script that defines the trace points and the actions to be performed when those trace points are hit. This script can be written in JavaScript and should include the necessary Frida APIs to interact with the application.

4. **Attach Frida to the Application**: Use the Frida CLI or the Frida package to attach Frida to the running iOS application. This will inject the Frida script into the application's process and start the tracing.

5. **Analyze the Traces**: Once the tracing is started, you can analyze the function calls and monitor the application's behavior in real-time. Frida provides various APIs and tools to help you analyze the traces and extract valuable information.

Frida Trace is a versatile tool that can be used for a wide range of iOS pentesting activities. By leveraging its dynamic instrumentation capabilities, you can gain deep insights into the inner workings of an iOS application and identify potential vulnerabilities or security weaknesses.
```bash
# Functions
## Trace all functions with the word "log" in their name
frida-trace -U <program> -i "*log*"
frida-trace -U <program> -i "*log*" | swift demangle # Demangle names

# Objective-C
## Trace all methods of all classes
frida-trace -U <program> -m "*[* *]"

## Trace all methods with the word "authentication" from classes that start with "NE"
frida-trace -U <program> -m "*[NE* *authentication*]"

# Plug-In
## To hook a plugin that is momentarely executed prepare Frida indicating the ID of the Plugin binary
frida-trace -U -W <if-plugin-bin> -m '*[* *]'
```
### Alle Klassen und Methoden abrufen

* Autovervollst√§ndigung: F√ºhren Sie einfach `frida -U <Programm>` aus.

<figure><img src="../../.gitbook/assets/image (687).png" alt=""><figcaption></figcaption></figure>

* Erhalten Sie **alle** verf√ºgbaren **Klassen** (nach Zeichenfolge filtern)

{% code title="/tmp/script.js" %}
```javascript
// frida -U <program> -l /tmp/script.js

var filterClass = "filterstring";

if (ObjC.available) {
for (var className in ObjC.classes) {
if (ObjC.classes.hasOwnProperty(className)) {
if (!filterClass || className.includes(filterClass)) {
console.log(className);
}
}
}
} else {
console.log("Objective-C runtime is not available.");
}
```
{% endcode %}

* Erhalte **alle** **Methoden** einer **Klasse** (filtere nach String)

{% code title="/tmp/script.js" %}
```javascript
// frida -U <program> -l /tmp/script.js

var specificClass = "YourClassName";
var filterMethod = "filtermethod";

if (ObjC.available) {
if (ObjC.classes.hasOwnProperty(specificClass)) {
var methods = ObjC.classes[specificClass].$ownMethods;
for (var i = 0; i < methods.length; i++) {
if (!filterMethod || methods[i].includes(filterClass)) {
console.log(specificClass + ': ' + methods[i]);
}
}
} else {
console.log("Class not found.");
}
} else {
console.log("Objective-C runtime is not available.");
}
```
{% endcode %}

* **Eine Funktion aufrufen**
```javascript
// Find the address of the function to call
const func_addr = Module.findExportByName("<Prog Name>", "<Func Name>");
// Declare the function to call
const func = new NativeFunction(
func_addr,
"void", ["pointer", "pointer", "pointer"], {
});

var arg0 = null;

// In this case to call this function we need to intercept a call to it to copy arg0
Interceptor.attach(wg_log_addr, {
onEnter: function(args) {
arg0 = new NativePointer(args[0]);
}
});

// Wait untill a call to the func occurs
while (! arg0) {
Thread.sleep(1);
console.log("waiting for ptr");
}


var arg1 = Memory.allocUtf8String('arg1');
var txt = Memory.allocUtf8String('Some text for arg2');
wg_log(arg0, arg1, txt);

console.log("loaded");
```
## Frida Fuzzing

### Frida Stalker

[Aus der Dokumentation](https://frida.re/docs/stalker/#:~:text=Stalker%20is%20Frida's%20code%20tracing,every%20instruction%20which%20is%20executed.): Stalker ist Fridas **Code-Tracing-Engine**. Es erm√∂glicht das **Verfolgen** von Threads und das **Erfassen** jeder Funktion, **jedes Blocks** und sogar jeder ausgef√ºhrten Anweisung.

Ein Beispiel zur Implementierung von Frida Stalker finden Sie unter [https://github.com/poxyran/misc/blob/master/frida-stalker-example.py](https://github.com/poxyran/misc/blob/master/frida-stalker-example.py)

Hier ist ein weiteres Beispiel, um Frida Stalker jedes Mal anzuh√§ngen, wenn eine Funktion aufgerufen wird:
```javascript
console.log("loading");
const wg_log_addr = Module.findExportByName("<Program>", "<function_name>");
const wg_log = new NativeFunction(
wg_log_addr,
"void", ["pointer", "pointer", "pointer"], {
});

Interceptor.attach(wg_log_addr, {
onEnter: function(args) {
console.log(`logging the following message: ${args[2].readCString()}`);

Stalker.follow({
events: {
// only collect coverage for newly encountered blocks
compile: true,
},
onReceive: function (events) {
const bbs = Stalker.parse(events, {
stringify: false,
annotate: false
});
console.log("Stalker trace of write_msg_to_log: \n" + bbs.flat().map(DebugSymbol.fromAddress).join('\n'));
}
});
},
onLeave: function(retval) {
Stalker.unfollow();
Stalker.flush();  // this is important to get all events
}
});
```
{% hint style="danger" %}
Dies ist interessant f√ºr Debugging-Zwecke, aber f√ºr Fuzzing ist es sehr ineffizient, st√§ndig **`.follow()`** und **`.unfollow()`** zu verwenden.
{% endhint %}

## [Fpicker](https://github.com/ttdennis/fpicker)

[**Fpicker**](https://github.com/ttdennis/fpicker) ist eine **Frida-basierte Fuzzing-Suite**, die verschiedene Fuzzing-Modi f√ºr das In-Prozess-Fuzzing bietet, wie z.B. einen AFL++-Modus oder einen passiven Tracing-Modus. Es sollte auf allen Plattformen laufen, die von Frida unterst√ºtzt werden.

* [**Fpicker installieren**](https://github.com/ttdennis/fpicker#requirements-and-installation) **& radamsa**
```bash
# Get fpicker
git clone https://github.com/ttdennis/fpicker
cd fpicker

# Get Frida core devkit and prepare fpicker
wget https://github.com/frida/frida/releases/download/16.1.4/frida-core-devkit-16.1.4-[yourOS]-[yourarchitecture].tar.xz
# e.g. https://github.com/frida/frida/releases/download/16.1.4/frida-core-devkit-16.1.4-macos-arm64.tar.xz
tar -xf ./*tar.xz
cp libfrida-core.a libfrida-core-[yourOS].a #libfrida-core-macos.a

# Install fpicker
make fpicker-[yourOS] # fpicker-macos
# This generates ./fpicker

# Install radamsa (fuzzer generator)
brew install radamsa
```
* **Vorbereitung des Dateisystems:**
```bash
# From inside fpicker clone
mkdir -p examples/wg-log # Where the fuzzing script will be
mkdir -p examples/wg-log/out # For code coverage and crashes
mkdir -p examples/wg-log/in # For starting inputs

# Create at least 1 input for the fuzzer
echo Hello World > examples/wg-log/in/0
```
* **Fuzzer-Skript** (`examples/wg-log/myfuzzer.js`):

{% code title="examples/wg-log/myfuzzer.js" %}
```javascript
// Import the fuzzer base class
import { Fuzzer } from "../../harness/fuzzer.js";

class WGLogFuzzer extends Fuzzer {

constructor() {
console.log("WGLogFuzzer constructor called")

// Get and declare the function we are going to fuzz
var wg_log_addr = Module.findExportByName("<Program name>", "<func name to fuzz>");
var wg_log_func = new NativeFunction(
wg_log_addr,
"void", ["pointer", "pointer", "pointer"], {
});

// Initialize the object
super("<Program nane>", wg_log_addr, wg_log_func);
this.wg_log_addr = wg_log_addr; // We cannot use "this" before calling "super"

console.log("WGLogFuzzer in the middle");

// Prepare the second argument to pass to the fuzz function
this.tag = Memory.allocUtf8String("arg2");

// Get the first argument we need to pass from a call to the functino we want to fuzz
var wg_log_global_ptr = null;
console.log(this.wg_log_addr);
Interceptor.attach(this.wg_log_addr, {
onEnter: function(args) {
console.log("Entering in the function to get the first argument");
wg_log_global_ptr = new NativePointer(args[0]);
}
});

while (! wg_log_global_ptr) {
Thread.sleep(1)
}
this.wg_log_global_ptr = wg_log_global_ptr;
console.log("WGLogFuzzer prepare ended")
}


// This function is called by the fuzzer with the first argument being a pointer into memory
// where the payload is stored and the second the length of the input.
fuzz(payload, len) {
// Get a pointer to payload being a valid C string (with a null byte at the end)
var payload_cstring = payload.readCString(len);
this.payload = Memory.allocUtf8String(payload_cstring);

// Debug and fuzz
this.debug_log(this.payload, len);
// Pass the 2 first arguments we know the function needs and finally the payload to fuzz
this.target_function(this.wg_log_global_ptr, this.tag, this.payload);
}
}

const f = new WGLogFuzzer();
rpc.exports.fuzzer = f;
```
{% endcode %}

* **Kompilieren** des Fuzzers:
```bash
# From inside fpicker clone
## Compile from "myfuzzer.js" to "harness.js"
frida-compile examples/wg-log/myfuzzer.js -o harness.js
```
* Rufen Sie den Fuzzer **`fpicker`** mit **`radamsa`** auf:

{% code overflow="wrap" %}
```bash
# Indicate fpicker to fuzz a program with the harness.js script and which folders to use
fpicker -v --fuzzer-mode active -e attach -p <Program to fuzz> -D usb -o examples/wg-log/out/ -i examples/wg-log/in/ -f harness.js --standalone-mutator cmd --mutator-command "radamsa"
# You can find code coverage and crashes in examples/wg-log/out/
```
{% endcode %}

{% hint style="danger" %}
In diesem Fall **starten wir die App nicht neu oder stellen den Zustand nicht wieder her** nach jedem Payload. Wenn Frida also einen **Absturz** findet, kann es sein, dass die **n√§chsten Eingaben** nach diesem Payload auch die App zum **Absturz bringen** (weil die App sich in einem instabilen Zustand befindet), auch wenn die **Eingabe die App nicht zum Absturz bringen sollte**.

Dar√ºber hinaus wird Frida in die Ausnahmesignale von iOS eingreifen, sodass bei einem **Absturz von Frida wahrscheinlich keine iOS-Absturzberichte generiert werden**.

Um dies zu verhindern, k√∂nnten wir zum Beispiel die App nach jedem Frida-Absturz neu starten.
{% endhint %}

### Protokolle und Abst√ºrze

Sie k√∂nnen die **macOS-Konsole** oder die **`log`**-Befehlszeilenschnittstelle verwenden, um macOS-Protokolle zu √ºberpr√ºfen.\
Sie k√∂nnen auch die Protokolle von iOS mit **`idevicesyslog`** √ºberpr√ºfen.\
Einige Protokolle lassen Informationen aus, indem sie **`<private>`** hinzuf√ºgen. Um alle Informationen anzuzeigen, m√ºssen Sie ein Profil von [https://developer.apple.com/bug-reporting/profiles-and-logs/](https://developer.apple.com/bug-reporting/profiles-and-logs/) installieren, um diese privaten Informationen zu aktivieren.

Wenn Sie nicht wissen, was Sie tun sollen:
```sh
vim /Library/Preferences/Logging/com.apple.system.logging.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>Enable-Private-Data</key>
<true/>
</dict>
</plist>

killall -9 logd
```
Sie k√∂nnen die Abst√ºrze √ºberpr√ºfen in:&#x20;

* **iOS**
* Einstellungen ‚Üí Datenschutz ‚Üí Analyse & Verbesserungen ‚Üí Analyse-Daten
* `/private/var/mobile/Library/Logs/CrashReporter/`
* **macOS**:
* `/Library/Logs/DiagnosticReports/`
* `~/Library/Logs/DiagnosticReports`

{% hint style="warning" %}
iOS speichert nur 25 Abst√ºrze der gleichen App, daher m√ºssen Sie diese bereinigen, sonst erstellt iOS keine weiteren Abst√ºrze.
{% endhint %}

## Frida Android Tutorials

{% content-ref url="../android-app-pentesting/frida-tutorial/" %}
[frida-tutorial](../android-app-pentesting/frida-tutorial/)
{% endcontent-ref %}

## Referenzen
* [https://www.briskinfosec.com/blogs/blogsdetail/Getting-Started-with-Frida](https://www.briskinfosec.com/blogs/blogsdetail/Getting-Started-with-Frida)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
