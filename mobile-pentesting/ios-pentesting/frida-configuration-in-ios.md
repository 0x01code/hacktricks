# iOS Frida Konfigurasie

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy in HackTricks wil adverteer** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

## Frida-installasie

**Stappe om Frida op 'n Jailbroken-toestel te installeer:**

1. Maak die Cydia/Sileo-app oop.
2. Navigeer na Beheer -> Bronne -> Wysig -> Voeg by.
3. Voer "https://build.frida.re" as die URL in.
4. Gaan na die nuut bygevoegde Frida-bron.
5. Installeer die Frida-pakket.

As jy **Corellium** gebruik, moet jy die Frida-vrystelling aflaai vanaf [https://github.com/frida/frida/releases](https://github.com/frida/frida/releases) (`frida-gadget-[yourversion]-ios-universal.dylib.gz`) en uitpak en kopieer na die dylib-plek waarvoor Frida vra, bv.: `/Users/[youruser]/.cache/frida/gadget-ios.dylib`

Nadat dit ge√Ønstalleer is, kan jy die opdrag **`frida-ls-devices`** op jou rekenaar gebruik en kyk of die toestel verskyn (jou rekenaar moet toegang daartoe h√™).\
Voer ook **`frida-ps -Uia`** uit om die lopende prosesse van die telefoon te kontroleer.

## Frida sonder 'n Jailbroken-toestel & sonder om die app te patch

Kyk na hierdie blogpos oor hoe om Frida te gebruik in nie-jailbroken-toestelle sonder om die app te patch: [https://mrbypass.medium.com/unlocking-potential-exploring-frida-objection-on-non-jailbroken-devices-without-application-ed0367a84f07](https://mrbypass.medium.com/unlocking-potential-exploring-frida-objection-on-non-jailbroken-devices-without-application-ed0367a84f07)

## Frida-kli√´ntinstallasie

Installeer **frida-gereedskap**:
```bash
pip install frida-tools
pip install frida
```
Met die Frida-bediener ge√Ønstalleer en die toestel wat loop en verbind is, **kontroleer** of die kli√´nt **werk**:
```bash
frida-ls-devices  # List devices
frida-ps -Uia     # Get running processes
```
## Frida Spoor

Frida Trace is a powerful dynamic instrumentation tool that allows you to trace function calls and monitor the behavior of an iOS application in real-time. It can be used for various purposes, such as debugging, reverse engineering, and vulnerability analysis.

Frida Trace works by injecting a JavaScript code into the target application, which allows you to hook into specific functions and intercept their execution. This gives you the ability to log function arguments, return values, and even modify the behavior of the application on the fly.

To configure Frida Trace in iOS, follow these steps:

1. Install Frida on your iOS device by using the Frida CLI or FridaGadget. You can find detailed instructions on how to install Frida in the official documentation.

2. Connect your iOS device to your computer using a USB cable.

3. Launch the target application on your iOS device.

4. Open a terminal window and navigate to the directory where you have installed Frida.

5. Run the following command to start the Frida server on your iOS device:

   ```
   frida-server -l 0.0.0.0
   ```

6. On your computer, run the following command to list the processes running on your iOS device:

   ```
   frida-ps -U
   ```

   This will display a list of processes along with their process IDs (PIDs).

7. Identify the process ID of the target application from the list.

8. Run the following command to attach Frida to the target application:

   ```
   frida -U -l <path_to_script.js> -p <pid>
   ```

   Replace `<path_to_script.js>` with the path to your JavaScript code and `<pid>` with the process ID of the target application.

9. Your JavaScript code will be executed in the context of the target application, allowing you to trace function calls and monitor its behavior.

By using Frida Trace, you can gain valuable insights into the inner workings of an iOS application and identify potential vulnerabilities or security issues. It is a versatile tool that can greatly enhance your iOS pentesting capabilities.
```bash
# Functions
## Trace all functions with the word "log" in their name
frida-trace -U <program> -i "*log*"
frida-trace -U <program> -i "*log*" | swift demangle # Demangle names

# Objective-C
## Trace all methods of all classes
frida-trace -U <program> -m "*[* *]"

## Trace all methods with the word "authentication" from classes that start with "NE"
frida-trace -U <program> -m "*[NE* *authentication*]"

# Plug-In
## To hook a plugin that is momentarely executed prepare Frida indicating the ID of the Plugin binary
frida-trace -U -W <if-plugin-bin> -m '*[* *]'
```
### Kry alle klasse en metodes

* Outomatiese voltooiing: Voer eenvoudig `frida -U <program>` uit

<figure><img src="../../.gitbook/assets/image (687).png" alt=""><figcaption></figcaption></figure>

* Kry **alle** beskikbare **klasse** (gefiltreer deur string)

{% code title="/tmp/script.js" %}
```javascript
// frida -U <program> -l /tmp/script.js

var filterClass = "filterstring";

if (ObjC.available) {
for (var className in ObjC.classes) {
if (ObjC.classes.hasOwnProperty(className)) {
if (!filterClass || className.includes(filterClass)) {
console.log(className);
}
}
}
} else {
console.log("Objective-C runtime is not available.");
}
```
{% endcode %}

* Kry **alle** **metodes** van 'n **klas** (gefilter deur string)

{% code title="/tmp/script.js" %}
```javascript
// frida -U <program> -l /tmp/script.js

var specificClass = "YourClassName";
var filterMethod = "filtermethod";

if (ObjC.available) {
if (ObjC.classes.hasOwnProperty(specificClass)) {
var methods = ObjC.classes[specificClass].$ownMethods;
for (var i = 0; i < methods.length; i++) {
if (!filterMethod || methods[i].includes(filterClass)) {
console.log(specificClass + ': ' + methods[i]);
}
}
} else {
console.log("Class not found.");
}
} else {
console.log("Objective-C runtime is not available.");
}
```
{% endcode %}

* **Roep 'n funksie aan**
```javascript
// Find the address of the function to call
const func_addr = Module.findExportByName("<Prog Name>", "<Func Name>");
// Declare the function to call
const func = new NativeFunction(
func_addr,
"void", ["pointer", "pointer", "pointer"], {
});

var arg0 = null;

// In this case to call this function we need to intercept a call to it to copy arg0
Interceptor.attach(wg_log_addr, {
onEnter: function(args) {
arg0 = new NativePointer(args[0]);
}
});

// Wait untill a call to the func occurs
while (! arg0) {
Thread.sleep(1);
console.log("waiting for ptr");
}


var arg1 = Memory.allocUtf8String('arg1');
var txt = Memory.allocUtf8String('Some text for arg2');
wg_log(arg0, arg1, txt);

console.log("loaded");
```
## Frida Fuzzing

### Frida Stalker

[Van die dokumentasie](https://frida.re/docs/stalker/#:~:text=Stalker%20is%20Frida's%20code%20tracing,every%20instruction%20which%20is%20executed.): Stalker is Frida se kode **naspeuringsenjin**. Dit maak dit moontlik om drade te **volg**, elke funksie **vas te vang**, elke blok, selfs elke instruksie wat uitgevoer word.

Jy het 'n voorbeeld wat Frida Stalker implementeer in [https://github.com/poxyran/misc/blob/master/frida-stalker-example.py](https://github.com/poxyran/misc/blob/master/frida-stalker-example.py)

Hier is nog 'n voorbeeld om Frida Stalker aan te heg elke keer as 'n funksie geroep word:
```javascript
console.log("loading");
const wg_log_addr = Module.findExportByName("<Program>", "<function_name>");
const wg_log = new NativeFunction(
wg_log_addr,
"void", ["pointer", "pointer", "pointer"], {
});

Interceptor.attach(wg_log_addr, {
onEnter: function(args) {
console.log(`logging the following message: ${args[2].readCString()}`);

Stalker.follow({
events: {
// only collect coverage for newly encountered blocks
compile: true,
},
onReceive: function (events) {
const bbs = Stalker.parse(events, {
stringify: false,
annotate: false
});
console.log("Stalker trace of write_msg_to_log: \n" + bbs.flat().map(DebugSymbol.fromAddress).join('\n'));
}
});
},
onLeave: function(retval) {
Stalker.unfollow();
Stalker.flush();  // this is important to get all events
}
});
```
{% hint style="danger" %}
Dit is interessant vir doeleindes van foutopsporing, maar vir fuzzing is dit baie ondoeltreffend om voortdurend **`.follow()`** en **`.unfollow()`** te gebruik.
{% endhint %}

## [Fpicker](https://github.com/ttdennis/fpicker)

[**fpicker**](https://github.com/ttdennis/fpicker) is 'n **Frida-gebaseerde fuzzing suite** wat verskeie fuzzing modusse bied vir in-process fuzzing, soos 'n AFL++ modus of 'n passiewe spoorwegmodus. Dit behoort te werk op alle platforms wat deur Frida ondersteun word.

* [**Installeer fpicker**](https://github.com/ttdennis/fpicker#requirements-and-installation) **& radamsa**
```bash
# Get fpicker
git clone https://github.com/ttdennis/fpicker
cd fpicker

# Get Frida core devkit and prepare fpicker
wget https://github.com/frida/frida/releases/download/16.1.4/frida-core-devkit-16.1.4-[yourOS]-[yourarchitecture].tar.xz
# e.g. https://github.com/frida/frida/releases/download/16.1.4/frida-core-devkit-16.1.4-macos-arm64.tar.xz
tar -xf ./*tar.xz
cp libfrida-core.a libfrida-core-[yourOS].a #libfrida-core-macos.a

# Install fpicker
make fpicker-[yourOS] # fpicker-macos
# This generates ./fpicker

# Install radamsa (fuzzer generator)
brew install radamsa
```
* **Berei die FS voor:**
```bash
# From inside fpicker clone
mkdir -p examples/wg-log # Where the fuzzing script will be
mkdir -p examples/wg-log/out # For code coverage and crashes
mkdir -p examples/wg-log/in # For starting inputs

# Create at least 1 input for the fuzzer
echo Hello World > examples/wg-log/in/0
```
* **Fuzzer-skrips** (`voorbeelde/wg-log/myfuzzer.js`):

{% code title="voorbeelde/wg-log/myfuzzer.js" %}
```javascript
// Import the fuzzer base class
import { Fuzzer } from "../../harness/fuzzer.js";

class WGLogFuzzer extends Fuzzer {

constructor() {
console.log("WGLogFuzzer constructor called")

// Get and declare the function we are going to fuzz
var wg_log_addr = Module.findExportByName("<Program name>", "<func name to fuzz>");
var wg_log_func = new NativeFunction(
wg_log_addr,
"void", ["pointer", "pointer", "pointer"], {
});

// Initialize the object
super("<Program nane>", wg_log_addr, wg_log_func);
this.wg_log_addr = wg_log_addr; // We cannot use "this" before calling "super"

console.log("WGLogFuzzer in the middle");

// Prepare the second argument to pass to the fuzz function
this.tag = Memory.allocUtf8String("arg2");

// Get the first argument we need to pass from a call to the functino we want to fuzz
var wg_log_global_ptr = null;
console.log(this.wg_log_addr);
Interceptor.attach(this.wg_log_addr, {
onEnter: function(args) {
console.log("Entering in the function to get the first argument");
wg_log_global_ptr = new NativePointer(args[0]);
}
});

while (! wg_log_global_ptr) {
Thread.sleep(1)
}
this.wg_log_global_ptr = wg_log_global_ptr;
console.log("WGLogFuzzer prepare ended")
}


// This function is called by the fuzzer with the first argument being a pointer into memory
// where the payload is stored and the second the length of the input.
fuzz(payload, len) {
// Get a pointer to payload being a valid C string (with a null byte at the end)
var payload_cstring = payload.readCString(len);
this.payload = Memory.allocUtf8String(payload_cstring);

// Debug and fuzz
this.debug_log(this.payload, len);
// Pass the 2 first arguments we know the function needs and finally the payload to fuzz
this.target_function(this.wg_log_global_ptr, this.tag, this.payload);
}
}

const f = new WGLogFuzzer();
rpc.exports.fuzzer = f;
```
{% endcode %}

* **Kompileer** die fuzzer:
```bash
# From inside fpicker clone
## Compile from "myfuzzer.js" to "harness.js"
frida-compile examples/wg-log/myfuzzer.js -o harness.js
```
* Roep die fuzzer **`fpicker`** aan met behulp van **`radamsa`**:

{% code overflow="wrap" %}
```bash
# Indicate fpicker to fuzz a program with the harness.js script and which folders to use
fpicker -v --fuzzer-mode active -e attach -p <Program to fuzz> -D usb -o examples/wg-log/out/ -i examples/wg-log/in/ -f harness.js --standalone-mutator cmd --mutator-command "radamsa"
# You can find code coverage and crashes in examples/wg-log/out/
```
{% endcode %}

{% hint style="danger" %}
In hierdie geval **herlaai ons die app nie of herstel die toestand nie** na elke lading. So, as Frida 'n **crash** vind, kan die **volgende insette** na daardie lading ook die app **crash** (omdat die app in 'n onstabiele toestand is), selfs al **moet die inset nie die app laat crash nie.

Verder sal Frida in die uitsonderingseine van iOS inklink, so wanneer **Frida 'n crash vind**, sal daar waarskynlik nie 'n **iOS crash-rapport gegenereer word nie.

Om dit te voorkom, kan ons byvoorbeeld die app herlaai na elke Frida-crash.
{% endhint %}

### Logboeke & Crashes

Jy kan die **macOS-konsole** of die **`log`**-opdrag gebruik om macOS-logboeke te kontroleer.\
Jy kan ook die logboeke van iOS kontroleer deur **`idevicesyslog`** te gebruik.\
Sommige logboeke sal inligting uitsluit deur **`<private>`** by te voeg. Om al die inligting te wys, moet jy 'n profiel installeer vanaf [https://developer.apple.com/bug-reporting/profiles-and-logs/](https://developer.apple.com/bug-reporting/profiles-and-logs/) om daardie private inligting in te skakel.

As jy nie weet wat om te doen nie:
```sh
vim /Library/Preferences/Logging/com.apple.system.logging.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>Enable-Private-Data</key>
<true/>
</dict>
</plist>

killall -9 logd
```
Jy kan die crashes in die volgende plekke nagaan:

* **iOS**
* Instellings ‚Üí Privaatheid ‚Üí Analitika & Verbeterings ‚Üí Analitika Data
* `/private/var/mobile/Library/Logs/CrashReporter/`
* **macOS**:
* `/Library/Logs/DiagnosticReports/`
* `~/Library/Logs/DiagnosticReports`

{% hint style="warning" %}
iOS stoor slegs 25 crashes van dieselfde app, so jy moet dit skoonmaak of iOS sal ophou om crashes te skep.
{% endhint %}

## Frida Android Tutoriale

{% content-ref url="../android-app-pentesting/frida-tutorial/" %}
[frida-tutorial](../android-app-pentesting/frida-tutorial/)
{% endcontent-ref %}

## Verwysings
* [https://www.briskinfosec.com/blogs/blogsdetail/Getting-Started-with-Frida](https://www.briskinfosec.com/blogs/blogsdetail/Getting-Started-with-Frida)

<details>

<summary><strong>Leer AWS hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
