# iOS Frida 구성

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## Frida 설치

**Jailbroken 장치에 Frida를 설치하는 단계:**

1. Cydia/Sileo 앱을 엽니다.
2. Manage -> Sources -> Edit -> Add로 이동합니다.
3. URL로 "https://build.frida.re"를 입력합니다.
4. 새로 추가된 Frida 소스로 이동합니다.
5. Frida 패키지를 설치합니다.

**Corellium**을 사용하는 경우 [https://github.com/frida/frida/releases](https://github.com/frida/frida/releases)에서 Frida 릴리스를 다운로드해야 합니다 (`frida-gadget-[yourversion]-ios-universal.dylib.gz`) 그리고 Frida가 요청하는 dylib 위치로 압축을 풀고 복사합니다. 예: `/Users/[youruser]/.cache/frida/gadget-ios.dylib`

설치 후, PC에서 **`frida-ls-devices`** 명령을 사용하여 장치가 나타나는지 확인할 수 있습니다 (PC가 액세스할 수 있어야 함).\
또한 **`frida-ps -Uia`**를 실행하여 휴대폰의 실행 중인 프로세스를 확인할 수 있습니다.

## Jailbroken 장치 없이 Frida 및 앱 패치 없이 사용하기

앱 패치 없이 비-Jailbroken 장치에서 Frida를 사용하는 방법에 대한 블로그 포스트를 확인하세요: [https://mrbypass.medium.com/unlocking-potential-exploring-frida-objection-on-non-jailbroken-devices-without-application-ed0367a84f07](https://mrbypass.medium.com/unlocking-potential-exploring-frida-objection-on-non-jailbroken-devices-without-application-ed0367a84f07)

## Frida 클라이언트 설치

**frida 도구**를 설치하세요:
```bash
pip install frida-tools
pip install frida
```
Frida 서버가 설치되어 있고 기기가 실행되고 연결되었는지 확인하여 클라이언트가 작동하는지 확인하십시오:
```bash
frida-ls-devices  # List devices
frida-ps -Uia     # Get running processes
```
## Frida 추적

Frida Trace is a powerful dynamic instrumentation tool that allows you to trace function calls and monitor the behavior of an iOS application in real-time. It can be used for various purposes, such as debugging, reverse engineering, and vulnerability analysis.

Frida Trace는 iOS 애플리케이션의 함수 호출을 추적하고 동작을 실시간으로 모니터링할 수 있는 강력한 동적 계기장치 도구입니다. 디버깅, 역공학, 취약점 분석 등 다양한 목적으로 사용할 수 있습니다.

To configure Frida Trace in iOS, you need to follow these steps:

iOS에서 Frida Trace를 구성하려면 다음 단계를 따라야 합니다:

1. Jailbreak your iOS device or use a jailbroken device: Frida requires a jailbroken device to work properly. If your device is not jailbroken, you can use a jailbroken device or a jailbreak tool to jailbreak it.

1. iOS 기기를 탈옥하거나 탈옥된 기기를 사용하세요: Frida는 제대로 작동하려면 탈옥된 기기가 필요합니다. 기기가 탈옥되지 않은 경우 탈옥된 기기나 탈옥 도구를 사용하여 탈옥할 수 있습니다.

2. Install Frida on your iOS device: You can install Frida on your iOS device by using the Cydia package manager. Open Cydia, search for "Frida" and install it.

2. iOS 기기에 Frida를 설치하세요: Cydia 패키지 관리자를 사용하여 iOS 기기에 Frida를 설치할 수 있습니다. Cydia를 열고 "Frida"를 검색하여 설치하세요.

3. Install Frida on your computer: You also need to install Frida on your computer. You can do this by using the Frida command-line tools or by installing the Frida Python package.

3. 컴퓨터에 Frida를 설치하세요: 컴퓨터에도 Frida를 설치해야 합니다. Frida 명령줄 도구를 사용하거나 Frida Python 패키지를 설치하여 이 작업을 수행할 수 있습니다.

4. Connect your iOS device to your computer: Connect your iOS device to your computer using a USB cable.

4. iOS 기기를 컴퓨터에 연결하세요: USB 케이블을 사용하여 iOS 기기를 컴퓨터에 연결하세요.

5. Start the Frida server on your iOS device: Open the Frida app on your iOS device and start the Frida server.

5. iOS 기기에서 Frida 서버를 시작하세요: iOS 기기에서 Frida 앱을 열고 Frida 서버를 시작하세요.

6. Write a Frida script: Now, you need to write a Frida script to perform the desired tracing or monitoring tasks. You can write the script in JavaScript or Python.

6. Frida 스크립트 작성: 이제 원하는 추적 또는 모니터링 작업을 수행하기 위해 Frida 스크립트를 작성해야 합니다. 스크립트를 JavaScript 또는 Python으로 작성할 수 있습니다.

7. Run the Frida script: Run the Frida script on your computer using the Frida command-line tools or the Frida Python package.

7. Frida 스크립트 실행: Frida 명령줄 도구나 Frida Python 패키지를 사용하여 컴퓨터에서 Frida 스크립트를 실행하세요.

By following these steps, you can configure Frida Trace in iOS and start tracing and monitoring the behavior of iOS applications in real-time.

이러한 단계를 따라 iOS에서 Frida Trace를 구성하고 iOS 애플리케이션의 동작을 실시간으로 추적하고 모니터링할 수 있습니다.
```bash
# Functions
## Trace all functions with the word "log" in their name
frida-trace -U <program> -i "*log*"
frida-trace -U <program> -i "*log*" | swift demangle # Demangle names

# Objective-C
## Trace all methods of all classes
frida-trace -U <program> -m "*[* *]"

## Trace all methods with the word "authentication" from classes that start with "NE"
frida-trace -U <program> -m "*[NE* *authentication*]"

# Plug-In
## To hook a plugin that is momentarely executed prepare Frida indicating the ID of the Plugin binary
frida-trace -U -W <if-plugin-bin> -m '*[* *]'
```
### 모든 클래스와 메소드 가져오기

* 자동 완성: `frida -U <프로그램>`을 실행하십시오.

<figure><img src="../../.gitbook/assets/image (687).png" alt=""><figcaption></figcaption></figure>

* 사용 가능한 **모든 클래스** 가져오기 (문자열로 필터링)

{% code title="/tmp/script.js" %}
```javascript
// frida -U <program> -l /tmp/script.js

var filterClass = "filterstring";

if (ObjC.available) {
for (var className in ObjC.classes) {
if (ObjC.classes.hasOwnProperty(className)) {
if (!filterClass || className.includes(filterClass)) {
console.log(className);
}
}
}
} else {
console.log("Objective-C runtime is not available.");
}
```
{% endcode %}

* 클래스의 **모든** **메소드** 가져오기 (문자열로 필터링)

{% code title="/tmp/script.js" %}
```javascript
// frida -U <program> -l /tmp/script.js

var specificClass = "YourClassName";
var filterMethod = "filtermethod";

if (ObjC.available) {
if (ObjC.classes.hasOwnProperty(specificClass)) {
var methods = ObjC.classes[specificClass].$ownMethods;
for (var i = 0; i < methods.length; i++) {
if (!filterMethod || methods[i].includes(filterClass)) {
console.log(specificClass + ': ' + methods[i]);
}
}
} else {
console.log("Class not found.");
}
} else {
console.log("Objective-C runtime is not available.");
}
```
{% endcode %}

* **함수 호출하기**
```javascript
// Find the address of the function to call
const func_addr = Module.findExportByName("<Prog Name>", "<Func Name>");
// Declare the function to call
const func = new NativeFunction(
func_addr,
"void", ["pointer", "pointer", "pointer"], {
});

var arg0 = null;

// In this case to call this function we need to intercept a call to it to copy arg0
Interceptor.attach(wg_log_addr, {
onEnter: function(args) {
arg0 = new NativePointer(args[0]);
}
});

// Wait untill a call to the func occurs
while (! arg0) {
Thread.sleep(1);
console.log("waiting for ptr");
}


var arg1 = Memory.allocUtf8String('arg1');
var txt = Memory.allocUtf8String('Some text for arg2');
wg_log(arg0, arg1, txt);

console.log("loaded");
```
## Frida Fuzzing

### Frida Stalker

[문서에서](https://frida.re/docs/stalker/#:~:text=Stalker%20is%20Frida's%20code%20tracing,every%20instruction%20which%20is%20executed.) 확인할 수 있듯이, Stalker는 Frida의 코드 추적 엔진입니다. 이 엔진은 스레드를 따라가며 실행되는 모든 함수, 모든 블록, 심지어 모든 명령어를 **캡처**합니다.

Frida Stalker를 구현한 예제는 [https://github.com/poxyran/misc/blob/master/frida-stalker-example.py](https://github.com/poxyran/misc/blob/master/frida-stalker-example.py)에서 확인할 수 있습니다.

다음은 함수가 호출될 때마다 Frida Stalker를 연결하는 또 다른 예제입니다:
```javascript
console.log("loading");
const wg_log_addr = Module.findExportByName("<Program>", "<function_name>");
const wg_log = new NativeFunction(
wg_log_addr,
"void", ["pointer", "pointer", "pointer"], {
});

Interceptor.attach(wg_log_addr, {
onEnter: function(args) {
console.log(`logging the following message: ${args[2].readCString()}`);

Stalker.follow({
events: {
// only collect coverage for newly encountered blocks
compile: true,
},
onReceive: function (events) {
const bbs = Stalker.parse(events, {
stringify: false,
annotate: false
});
console.log("Stalker trace of write_msg_to_log: \n" + bbs.flat().map(DebugSymbol.fromAddress).join('\n'));
}
});
},
onLeave: function(retval) {
Stalker.unfollow();
Stalker.flush();  // this is important to get all events
}
});
```
{% hint style="danger" %}
이는 디버깅 목적으로는 흥미로우나, 퍼징에 대해서는 계속해서 **`.follow()`**와 **`.unfollow()`**를 사용하는 것은 매우 비효율적입니다.
{% endhint %}

## [Fpicker](https://github.com/ttdennis/fpicker)

[**fpicker**](https://github.com/ttdennis/fpicker)은 프로세스 내 퍼징을 위한 다양한 퍼징 모드를 제공하는 **Frida 기반의 퍼징 스위트**입니다. AFL++ 모드나 패시브 추적 모드와 같은 모드를 지원하며, Frida가 지원하는 모든 플랫폼에서 실행될 수 있습니다.

* [**fpicker 설치하기**](https://github.com/ttdennis/fpicker#requirements-and-installation) **& radamsa**
```bash
# Get fpicker
git clone https://github.com/ttdennis/fpicker
cd fpicker

# Get Frida core devkit and prepare fpicker
wget https://github.com/frida/frida/releases/download/16.1.4/frida-core-devkit-16.1.4-[yourOS]-[yourarchitecture].tar.xz
# e.g. https://github.com/frida/frida/releases/download/16.1.4/frida-core-devkit-16.1.4-macos-arm64.tar.xz
tar -xf ./*tar.xz
cp libfrida-core.a libfrida-core-[yourOS].a #libfrida-core-macos.a

# Install fpicker
make fpicker-[yourOS] # fpicker-macos
# This generates ./fpicker

# Install radamsa (fuzzer generator)
brew install radamsa
```
* **파일 시스템 준비:**
```bash
# From inside fpicker clone
mkdir -p examples/wg-log # Where the fuzzing script will be
mkdir -p examples/wg-log/out # For code coverage and crashes
mkdir -p examples/wg-log/in # For starting inputs

# Create at least 1 input for the fuzzer
echo Hello World > examples/wg-log/in/0
```
* **퍼저 스크립트** (`examples/wg-log/myfuzzer.js`):

{% code title="examples/wg-log/myfuzzer.js" %}
```javascript
// Import the fuzzer base class
import { Fuzzer } from "../../harness/fuzzer.js";

class WGLogFuzzer extends Fuzzer {

constructor() {
console.log("WGLogFuzzer constructor called")

// Get and declare the function we are going to fuzz
var wg_log_addr = Module.findExportByName("<Program name>", "<func name to fuzz>");
var wg_log_func = new NativeFunction(
wg_log_addr,
"void", ["pointer", "pointer", "pointer"], {
});

// Initialize the object
super("<Program nane>", wg_log_addr, wg_log_func);
this.wg_log_addr = wg_log_addr; // We cannot use "this" before calling "super"

console.log("WGLogFuzzer in the middle");

// Prepare the second argument to pass to the fuzz function
this.tag = Memory.allocUtf8String("arg2");

// Get the first argument we need to pass from a call to the functino we want to fuzz
var wg_log_global_ptr = null;
console.log(this.wg_log_addr);
Interceptor.attach(this.wg_log_addr, {
onEnter: function(args) {
console.log("Entering in the function to get the first argument");
wg_log_global_ptr = new NativePointer(args[0]);
}
});

while (! wg_log_global_ptr) {
Thread.sleep(1)
}
this.wg_log_global_ptr = wg_log_global_ptr;
console.log("WGLogFuzzer prepare ended")
}


// This function is called by the fuzzer with the first argument being a pointer into memory
// where the payload is stored and the second the length of the input.
fuzz(payload, len) {
// Get a pointer to payload being a valid C string (with a null byte at the end)
var payload_cstring = payload.readCString(len);
this.payload = Memory.allocUtf8String(payload_cstring);

// Debug and fuzz
this.debug_log(this.payload, len);
// Pass the 2 first arguments we know the function needs and finally the payload to fuzz
this.target_function(this.wg_log_global_ptr, this.tag, this.payload);
}
}

const f = new WGLogFuzzer();
rpc.exports.fuzzer = f;
```
{% endcode %}

* **퍼저를 컴파일**하세요:
```bash
# From inside fpicker clone
## Compile from "myfuzzer.js" to "harness.js"
frida-compile examples/wg-log/myfuzzer.js -o harness.js
```
* **`radamsa`**를 사용하여 **`fpicker`** 퍼저를 호출하십시오:

{% code overflow="wrap" %}
```bash
# Indicate fpicker to fuzz a program with the harness.js script and which folders to use
fpicker -v --fuzzer-mode active -e attach -p <Program to fuzz> -D usb -o examples/wg-log/out/ -i examples/wg-log/in/ -f harness.js --standalone-mutator cmd --mutator-command "radamsa"
# You can find code coverage and crashes in examples/wg-log/out/
```
{% endcode %}

{% hint style="danger" %}
이 경우에는 각 페이로드 후 앱을 다시 시작하거나 상태를 복원하지 않습니다. 따라서, Frida가 충돌을 발견하면 그 이후의 입력도 (앱이 불안정한 상태이기 때문에) 앱을 충돌시킬 수 있습니다. 심지어 입력이 앱을 충돌시키지 않아야 할 수도 있습니다.

또한, Frida는 iOS의 예외 신호에 훅을 걸기 때문에, Frida가 충돌을 발견하면 아마도 iOS 충돌 보고서가 생성되지 않을 것입니다.

이를 방지하기 위해, 예를 들어, Frida 충돌 후 앱을 다시 시작할 수 있습니다.
{% endhint %}

### 로그 및 충돌

macOS 콘솔 또는 `log` cli를 사용하여 macOS 로그를 확인할 수 있습니다.\
`idevicesyslog`를 사용하여 iOS의 로그도 확인할 수 있습니다.\
일부 로그는 `<private>`를 추가하여 정보를 생략합니다. 모든 정보를 표시하려면 [https://developer.apple.com/bug-reporting/profiles-and-logs/](https://developer.apple.com/bug-reporting/profiles-and-logs/)에서 일부 프로필을 설치하여 해당 개인 정보를 활성화해야 합니다.

무엇을 해야 할지 모르겠다면:
```sh
vim /Library/Preferences/Logging/com.apple.system.logging.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>Enable-Private-Data</key>
<true/>
</dict>
</plist>

killall -9 logd
```
다음은 충돌을 확인할 수 있는 위치입니다:&#x20;

* **iOS**
* 설정 → 개인 정보 → 분석 및 개선 → 분석 데이터
* `/private/var/mobile/Library/Logs/CrashReporter/`
* **macOS**:
* `/Library/Logs/DiagnosticReports/`
* `~/Library/Logs/DiagnosticReports`

{% hint style="warning" %}
iOS는 동일한 앱의 충돌을 25개만 저장하므로, 그것을 정리하지 않으면 iOS는 더 이상 충돌을 생성하지 않습니다.
{% endhint %}

## Frida Android 튜토리얼

{% content-ref url="../android-app-pentesting/frida-tutorial/" %}
[frida-tutorial](../android-app-pentesting/frida-tutorial/)
{% endcontent-ref %}

## 참고 자료
* [https://www.briskinfosec.com/blogs/blogsdetail/Getting-Started-with-Frida](https://www.briskinfosec.com/blogs/blogsdetail/Getting-Started-with-Frida)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 상품**](https://peass.creator-spring.com)을 구매하세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 기법을 공유**하세요.

</details>
