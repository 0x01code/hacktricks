<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


Los esquemas de URL personalizados [permiten que las aplicaciones se comuniquen a través de un protocolo personalizado](https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW1). Una aplicación debe declarar soporte para los esquemas y manejar las URLs entrantes que utilizan esos esquemas.

> Los esquemas de URL ofrecen un vector de ataque potencial en tu aplicación, así que asegúrate de **validar todos los parámetros de la URL** y **descartar cualquier URL malformada**. Además, limita las **acciones** disponibles a aquellas que **no pongan en riesgo los datos del usuario**.

Por ejemplo, la URI: `myapp://hostname?data=123876123` **invocará** la **aplicación** mydata (la que ha **registrado** el esquema `mydata`) a la **acción** relacionada con el **hostname** `hostname` enviando el **parámetro** `data` con valor `123876123`

Un ejemplo vulnerable es el siguiente [bug en la aplicación móvil de Skype](http://www.dhanjani.com/blog/2010/11/insecure-handling-of-url-schemes-in-apples-ios.html), descubierto en 2010: La aplicación de Skype registró el manejador del protocolo `skype://`, que **permitía a otras aplicaciones desencadenar llamadas a otros usuarios de Skype y números de teléfono**. Desafortunadamente, Skype no solicitaba permiso a los usuarios antes de realizar las llamadas, por lo que cualquier aplicación podía llamar a números arbitrarios sin el conocimiento del usuario. Los atacantes explotaron esta vulnerabilidad colocando un `<iframe src="skype://xxx?call"></iframe>` invisible (donde `xxx` se reemplazaba por un número premium), así que cualquier usuario de Skype que visitara inadvertidamente un sitio web malicioso llamaba al número premium.

Puedes encontrar los **esquemas registrados por una aplicación** en el archivo **`Info.plist`** de la aplicación buscando **`CFBundleURLTypes`** (ejemplo de [iGoat-Swift](https://github.com/OWASP/iGoat-Swift)):
```markup
<key>CFBundleURLTypes</key>
<array>
<dict>
<key>CFBundleURLName</key>
<string>com.iGoat.myCompany</string>
<key>CFBundleURLSchemes</key>
<array>
<string>iGoat</string>
</array>
</dict>
</array>
```
Sin embargo, ten en cuenta que **aplicaciones maliciosas pueden volver a registrar URIs** ya registradas por aplicaciones. Por lo tanto, si estás enviando **información sensible a través de URIs** (myapp://hostname?password=123456), una aplicación **maliciosa** puede **interceptar** la URI con la **información** **sensible**.

Además, la entrada de estas URIs **debe ser verificada y saneada**, ya que puede provenir de **orígenes maliciosos** que intentan explotar SQLInjections, XSS, CSRF, Path Traversals u otras posibles vulnerabilidades.

## Registro de Esquemas de Consulta de Aplicaciones

Las aplicaciones pueden llamar a [`canOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc) para verificar que la **aplicación objetivo está disponible**. Sin embargo, como este método estaba siendo utilizado por aplicaciones maliciosas como una forma de **enumerar aplicaciones instaladas**, [desde iOS 9.0 los esquemas de URL pasados a este deben ser también declarados](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc#discussion) agregando la clave `LSApplicationQueriesSchemes` al archivo `Info.plist` de la aplicación y un arreglo de **hasta 50 esquemas de URL**.
```markup
<key>LSApplicationQueriesSchemes</key>
<array>
<string>url_scheme1</string>
<string>url_scheme2</string>
</array>
```
`canOpenURL` siempre devolverá `NO` para esquemas no declarados, independientemente de si hay una aplicación apropiada instalada o no. Sin embargo, esta restricción solo se aplica a `canOpenURL`.

## Pruebas de Manejo y Validación de URL

Para determinar cómo se construye y valida una ruta de URL, si tienes el código fuente original, puedes **buscar los siguientes métodos**:

* Método `application:didFinishLaunchingWithOptions:` o `application:willFinishLaunchingWithOptions:`: verifica cómo se toma la decisión y cómo se recupera la información sobre la URL.
* [`application:openURL:options:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623112-application?language=objc): verifica cómo se está abriendo el recurso, es decir, cómo se está analizando la información, verifica las [opciones](https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey), especialmente si se debe permitir o denegar el acceso por la aplicación llamadora ([`sourceApplication`](https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey/1623128-sourceapplication)). La aplicación también podría necesitar permiso del usuario al usar el esquema de URL personalizado.

En Telegram encontrarás [cuatro métodos diferentes que se utilizan](https://github.com/peter-iakovlev/Telegram-iOS/blob/87e0a33ac438c1d702f2a0b75bf21f26866e346f/Telegram-iOS/AppDelegate.swift#L1250):
```swift
func application(_ application: UIApplication, open url: URL, sourceApplication: String?) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, open url: URL, sourceApplication: String?,
annotation: Any) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ app: UIApplication, open url: URL,
options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, handleOpen url: URL) -> Bool {
self.openUrl(url: url)
return true
}
```
## Pruebas de Solicitudes URL a Otras Aplicaciones

El método [`openURL:options:completionHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/1648685-openurl?language=objc) y el [método obsoleto `openURL:` de `UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc) son responsables de **abrir URLs** (es decir, para enviar solicitudes / hacer consultas a otras aplicaciones) que pueden ser locales a la aplicación actual o puede ser una que debe ser proporcionada por una aplicación diferente. Si tienes el código fuente original, puedes buscar directamente usos de esos métodos.

Además, si estás interesado en saber si la aplicación está consultando servicios o aplicaciones específicas, y si la aplicación es bien conocida, también puedes buscar esquemas de URL comunes en línea e incluirlos en tus **greps ([**lista de esquemas de aplicaciones iOS**](https://ios.gadgethacks.com/how-to/always-updated-list-ios-app-url-scheme-names-paths-for-shortcuts-0184033/)**)**.
```bash
egrep -nr "open.*options.*completionHandler" ./Telegram-iOS/
egrep -nr "openURL\(" ./Telegram-iOS/
egrep -nr "mt-encrypted-file://" ./Telegram-iOS/
egrep -nr "://" ./Telegram-iOS/
```
## Pruebas de Métodos Obsoletos

Busque métodos obsoletos como:

* [`application:handleOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622964-application?language=objc)
* [`openURL:`](https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc)
* [`application:openURL:sourceApplication:annotation:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623073-application)

Por ejemplo, aquí encontramos estos tres:
```bash
$ rabin2 -zzq Telegram\ X.app/Telegram\ X | grep -i "openurl"

0x1000d9e90 31 30 UIApplicationOpenURLOptionsKey
0x1000dee3f 50 49 application:openURL:sourceApplication:annotation:
0x1000dee71 29 28 application:openURL:options:
0x1000dee8e 27 26 application:handleOpenURL:
0x1000df2c9 9 8 openURL:
0x1000df766 12 11 canOpenURL:
0x1000df772 35 34 openURL:options:completionHandler:
...
```
## Llamadas a URLs arbitrarias

* **Safari**: Para probar rápidamente un esquema de URL, puedes abrir las URLs en Safari y observar cómo se comporta la app. Por ejemplo, si escribes `tel://123456789`, Safari intentará iniciar la llamada al número.
* **App de Notas**: Mantén presionados los enlaces que has escrito para probar esquemas de URL personalizados. Recuerda salir del modo de edición para poder abrirlos. Ten en cuenta que puedes hacer clic o mantener presionados enlaces que incluyan esquemas de URL personalizados solo si la app está instalada, si no, no se resaltarán como _enlaces clicables_.
* [**IDB**](https://github.com/facebook/idb):
* Inicia IDB, conéctate a tu dispositivo y selecciona la app objetivo. Puedes encontrar detalles en la [documentación de IDB](https://www.idbtool.com/documentation/setup.html).
* Ve a la sección **URL Handlers**. En **URL schemes**, haz clic en **Refresh**, y a la izquierda encontrarás una lista de todos los esquemas personalizados definidos en la app que se está probando. Puedes cargar estos esquemas haciendo clic en **Open**, en el lado derecho. Simplemente abriendo un esquema de URI en blanco (por ejemplo, abriendo `myURLscheme://`), puedes descubrir funcionalidades ocultas (por ejemplo, una ventana de depuración) y eludir la autenticación local.
*   **Frida**:

Si simplemente quieres abrir el esquema de URL, puedes hacerlo usando Frida:

```javascript
$ frida -U iGoat-Swift

[iPhone::iGoat-Swift]-> function openURL(url) {
var UIApplication = ObjC.classes.UIApplication.sharedApplication();
var toOpen = ObjC.classes.NSURL.URLWithString_(url);
return UIApplication.openURL_(toOpen);
}
[iPhone::iGoat-Swift]-> openURL("tel://234234234")
true
```

En este ejemplo de [Frida CodeShare](https://codeshare.frida.re/@dki/ios-url-scheme-fuzzing/) el autor utiliza la API no pública `LSApplicationWorkspace.openSensitiveURL:withOptions:` para abrir las URLs (desde la app SpringBoard):

```javascript
function openURL(url) {
var w = ObjC.classes.LSApplicationWorkspace.defaultWorkspace();
var toOpen = ObjC.classes.NSURL.URLWithString_(url);
return w.openSensitiveURL_withOptions_(toOpen, null);
}
```

> Ten en cuenta que el uso de APIs no públicas no está permitido en la App Store, por eso ni siquiera las probamos, pero se nos permite usarlas para nuestro análisis dinámico.

## Fuzzing de Esquemas de URL

Si la app analiza partes de la URL, también puedes realizar fuzzing de entrada para detectar errores de corrupción de memoria.

Lo que hemos aprendido anteriormente ahora se puede utilizar para construir tu propio fuzzer en el lenguaje de tu elección, por ejemplo, en Python y llamar a `openURL` usando [RPC de Frida](https://www.frida.re/docs/javascript-api/#rpc). Ese fuzzer debería hacer lo siguiente:

* Generar cargas útiles.
* Llamar a `openURL` con cada una de ellas.
* Verificar si la app genera un informe de fallos (`.ips`) en `/private/var/mobile/Library/Logs/CrashReporter`.

El proyecto [FuzzDB](https://github.com/fuzzdb-project/fuzzdb) ofrece diccionarios de fuzzing que puedes usar como cargas útiles.

## **Fuzzing Usando Frida**

Hacer esto con Frida es bastante fácil, puedes referirte a este [post del blog](https://grepharder.github.io/blog/0x03\_learning\_about\_universal\_links\_and\_fuzzing\_url\_schemes\_on\_ios\_with\_frida.html) para ver un ejemplo que hace fuzzing de la app iGoat-Swift (funcionando en iOS 11.1.2).

Antes de ejecutar el fuzzer necesitamos los esquemas de URL como entradas. Desde el análisis estático sabemos que la app iGoat-Swift soporta el siguiente esquema de URL y parámetros: `iGoat://?contactNumber={0}&message={0}`.
```bash
$ frida -U SpringBoard -l ios-url-scheme-fuzzing.js
[iPhone::SpringBoard]-> fuzz("iGoat", "iGoat://?contactNumber={0}&message={0}")
Watching for crashes from iGoat...
No logs were moved.
Opened URL: iGoat://?contactNumber=0&message=0
```
# Referencias

{% embed url="https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-object-persistence-mstg-platform-8" %}



<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
