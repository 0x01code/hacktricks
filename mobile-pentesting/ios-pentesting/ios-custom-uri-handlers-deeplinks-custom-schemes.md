```markdown
<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告掲載したい場合**や**HackTricksをPDFでダウンロードしたい場合**は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください。
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをご覧ください。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>


カスタムURLスキームは[アプリ間でカスタムプロトコルを介して通信することを可能にします](https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW1)。アプリはスキームをサポートすることを宣言し、それらのスキームを使用する受信URLを処理する必要があります。

> URLスキームはアプリへの潜在的な攻撃経路を提供するため、**すべてのURLパラメータを検証**し、**形式が不正なURLを破棄**することを確認してください。さらに、利用可能な**アクション**をユーザーのデータに**リスクをもたらさない**ものに限定してください。

例えば、URI: `myapp://hostname?data=123876123` は、スキーム `mydata` を**登録**している**アプリケーション** mydata を**起動**し、**ホスト名** `hostname` に関連する**アクション**を実行し、値 `123876123` を持つ**パラメータ** `data` を送信します。

脆弱性のある例の一つは、2010年に発見された[Skype Mobileアプリのこのバグ](http://www.dhanjani.com/blog/2010/11/insecure-handling-of-url-schemes-in-apples-ios.html)です：Skypeアプリは`skype://`プロトコルハンドラを登録しており、**他のアプリがSkypeユーザーや電話番号への呼び出しをトリガーすることを可能にしました**。残念ながら、Skypeは呼び出しを行う前にユーザーの許可を求めなかったため、任意のアプリがユーザーの知らない間に任意の番号に電話をかけることができました。攻撃者は、透明な`<iframe src="skype://xxx?call"></iframe>`（`xxx`はプレミアム番号に置き換えられる）を使用してこの脆弱性を悪用し、悪意のあるウェブサイトを誤って訪れたSkypeユーザーがプレミアム番号に電話をかけることになりました。

アプリケーションによって**登録されたスキーム**は、アプリの**`Info.plist`**ファイル内の**`CFBundleURLTypes`**を検索することで見つけることができます（[iGoat-Swift](https://github.com/OWASP/iGoat-Swift)からの例）：
```
```markup
<key>CFBundleURLTypes</key>
<array>
<dict>
<key>CFBundleURLName</key>
<string>com.iGoat.myCompany</string>
<key>CFBundleURLSchemes</key>
<array>
<string>iGoat</string>
</array>
</dict>
</array>
```
ただし、**悪意のあるアプリケーションが既に登録されているURIを再登録する**可能性があることに注意してください。したがって、**機密情報をURI経由で送信している場合**（myapp://hostname?password=123456）、**悪意のある**アプリケーションが**機密**な**情報**を含むURIを**傍受**する可能性があります。

また、これらのURIの入力は、SQLインジェクション、XSS、CSRF、パストラバーサル、またはその他の潜在的な脆弱性を悪用しようとする**悪意のある** **起源**から来る可能性があるため、**チェックして無害化する必要があります**。

## アプリケーションクエリスキームの登録

アプリは[`canOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc)を呼び出して、**ターゲットアプリが利用可能であるか**を確認できます。しかし、このメソッドが悪意のあるアプリによって**インストールされているアプリを列挙する方法として使用されていたため**、[iOS 9.0からは、それに渡されるURLスキームも宣言されなければなりません](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc#discussion)。これは、アプリの`Info.plist`ファイルに`LSApplicationQueriesSchemes`キーを追加し、**最大50のURLスキーム**の配列を指定することで行います。
```markup
<key>LSApplicationQueriesSchemes</key>
<array>
<string>url_scheme1</string>
<string>url_scheme2</string>
</array>
```
`canOpenURL`は、適切なアプリがインストールされているかどうかに関わらず、宣言されていないスキームに対しては常に`NO`を返します。ただし、この制限は`canOpenURL`にのみ適用されます。

## URLハンドリングとバリデーションのテスト

URLパスがどのように構築され、検証されるかを判断するために、元のソースコードを持っている場合、**以下のメソッドを検索してください**：

* `application:didFinishLaunchingWithOptions:`メソッドまたは`application:will-FinishLaunchingWithOptions:`：URLに関する情報がどのように決定され、取得されるかを確認します。
* [`application:openURL:options:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623112-application?language=objc)：リソースがどのように開かれるか、つまりデータがどのように解析されるかを確認し、特に呼び出しアプリ（[`sourceApplication`](https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey/1623128-sourceapplication)）によるアクセスが許可されるべきか否かを検証します。カスタムURLスキームを使用する際には、アプリがユーザーの許可も必要とする場合があります。

Telegramでは、[4つの異なるメソッドが使用されていることがわかります](https://github.com/peter-iakovlev/Telegram-iOS/blob/87e0a33ac438c1d702f2a0b75bf21f26866e346f/Telegram-iOS/AppDelegate.swift#L1250)：
```swift
func application(_ application: UIApplication, open url: URL, sourceApplication: String?) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, open url: URL, sourceApplication: String?,
annotation: Any) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ app: UIApplication, open url: URL,
options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {
self.openUrl(url: url)
return true
}

func application(_ application: UIApplication, handleOpen url: URL) -> Bool {
self.openUrl(url: url)
return true
}
```
## 他のアプリへのURLリクエストのテスト

[`openURL:options:completionHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/1648685-openurl?language=objc)メソッドと[非推奨の`UIApplication`の`openURL:`メソッド](https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc)は、**URLを開く**（つまり、他のアプリへのリクエストを送信/クエリを行う）責任があります。これは現在のアプリにローカルなものか、または別のアプリによって提供されなければならないものかもしれません。元のソースコードを持っている場合は、これらのメソッドの使用箇所を直接検索できます。

さらに、アプリが特定のサービスやアプリをクエリしているか、そしてアプリがよく知られているかを知りたい場合は、一般的なURLスキームをオンラインで検索し、それらを**greps（**[**iOSアプリスキームのリスト**](https://ios.gadgethacks.com/how-to/always-updated-list-ios-app-url-scheme-names-paths-for-shortcuts-0184033/)**）**に含めることもできます。
```bash
egrep -nr "open.*options.*completionHandler" ./Telegram-iOS/
egrep -nr "openURL\(" ./Telegram-iOS/
egrep -nr "mt-encrypted-file://" ./Telegram-iOS/
egrep -nr "://" ./Telegram-iOS/
```
## 廃止されたメソッドのテスト

以下のような廃止されたメソッドを検索します:

* [`application:handleOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622964-application?language=objc)
* [`openURL:`](https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc)
* [`application:openURL:sourceApplication:annotation:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623073-application)

例えば、ここにそれらの三つが見つかります:
```bash
$ rabin2 -zzq Telegram\ X.app/Telegram\ X | grep -i "openurl"

0x1000d9e90 31 30 UIApplicationOpenURLOptionsKey
0x1000dee3f 50 49 application:openURL:sourceApplication:annotation:
0x1000dee71 29 28 application:openURL:options:
0x1000dee8e 27 26 application:handleOpenURL:
0x1000df2c9 9 8 openURL:
0x1000df766 12 11 canOpenURL:
0x1000df772 35 34 openURL:options:completionHandler:
...
```
## 任意のURLの呼び出し

* **Safari**: URLスキームを素早くテストするには、SafariでURLを開いてアプリの挙動を観察します。例えば、`tel://123456789`と書くと、Safariはその番号に発信しようとします。
* **Notes App**: カスタムURLスキームをテストするために、書いたリンクを長押しします。リンクを開くためには編集モードを終了している必要があります。アプリがインストールされていない場合はリンクがクリック可能なリンクとしてハイライトされないことに注意してください。
* [**IDB**](https://github.com/facebook/idb):
* IDBを起動し、デバイスに接続してターゲットアプリを選択します。詳細は[IDBのドキュメント](https://www.idbtool.com/documentation/setup.html)を参照してください。
* **URLハンドラー**セクションに移動します。**URLスキーム**で**更新**をクリックし、左側にテスト中のアプリで定義されているすべてのカスタムスキームのリストが表示されます。右側の**開く**をクリックすることでこれらのスキームをロードできます。単に空のURIスキームを開く（例：`myURLscheme://`を開く）ことで、隠された機能（例：デバッグウィンドウ）を発見したり、ローカル認証をバイパスすることができます。
*   **Frida**:

単にURLスキームを開きたい場合は、Fridaを使用して行うことができます：

```javascript
$ frida -U iGoat-Swift

[iPhone::iGoat-Swift]-> function openURL(url) {
var UIApplication = ObjC.classes.UIApplication.sharedApplication();
var toOpen = ObjC.classes.NSURL.URLWithString_(url);
return UIApplication.openURL_(toOpen);
}
[iPhone::iGoat-Swift]-> openURL("tel://234234234")
true
```

この例では、[Frida CodeShare](https://codeshare.frida.re/@dki/ios-url-scheme-fuzzing/)の著者が非公開API `LSApplicationWorkspace.openSensitiveURL:withOptions:` を使用してURLを開いています（SpringBoardアプリから）：

```javascript
function openURL(url) {
var w = ObjC.classes.LSApplicationWorkspace.defaultWorkspace();
var toOpen = ObjC.classes.NSURL.URLWithString_(url);
return w.openSensitiveURL_withOptions_(toOpen, null);
}
```

> 非公開APIの使用はApp Storeでは許可されていないため、これらをテストすることはありませんが、動的分析のために使用することは許可されています。

## URLスキームのファジング

アプリがURLの一部を解析する場合、入力ファジングを実行してメモリ破損バグを検出することもできます。

上で学んだことを活用して、選んだ言語で独自のファジャーを構築し、[FridaのRPC](https://www.frida.re/docs/javascript-api/#rpc)を使用して`openURL`を呼び出すことができます。そのファジャーは以下のことを行うべきです：

* ペイロードを生成する。
* それらの各ペイロードに対して`openURL`を呼び出す。
* アプリがクラッシュレポート（`.ips`）を`/private/var/mobile/Library/Logs/CrashReporter`に生成するかどうかをチェックする。

[FuzzDB](https://github.com/fuzzdb-project/fuzzdb)プロジェクトは、ペイロードとして使用できるファジング辞書を提供しています。

## **Fridaを使用したファジング**

Fridaを使用すると非常に簡単で、iOS 11.1.2で動作するiGoat-Swiftアプリをファジングする例を見るために、この[ブログ投稿](https://grepharder.github.io/blog/0x03\_learning\_about\_universal\_links\_and\_fuzzing\_url\_schemes\_on\_ios\_with\_frida.html)を参照できます。

ファジャーを実行する前に、入力としてURLスキームが必要です。静的分析から、iGoat-Swiftアプリが以下のURLスキームとパラメータをサポートしていることがわかります：`iGoat://?contactNumber={0}&message={0}`。
```bash
$ frida -U SpringBoard -l ios-url-scheme-fuzzing.js
[iPhone::SpringBoard]-> fuzz("iGoat", "iGoat://?contactNumber={0}&message={0}")
Watching for crashes from iGoat...
No logs were moved.
Opened URL: iGoat://?contactNumber=0&message=0
```
# 参考文献

{% embed url="https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-object-persistence-mstg-platform-8" %}



<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)で<strong>AWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告掲載したい場合**や**HackTricksをPDFでダウンロードしたい場合**は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
