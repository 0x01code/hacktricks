```markdown
<details>

<summary><strong>Aprende a hackear AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


# Separación de Privilegios y Sandbox

Las aplicaciones a las que el usuario puede acceder se ejecutan como el usuario **mobile** mientras que los procesos críticos del sistema se ejecutan como **root**.\
Sin embargo, el sandbox permite un mejor control sobre las acciones que los procesos y aplicaciones pueden realizar.

Por ejemplo, incluso si dos procesos se ejecutan como el mismo usuario (mobile), **no se les permite acceder o modificar los datos del otro**.

Cada aplicación se instala bajo **`private/var/mobile/Applications/{ID aleatorio}`**\
Una vez instaladas, las aplicaciones tienen acceso de lectura limitado a algunas áreas y funciones del sistema (SMS, llamadas telefónicas...). Si una aplicación quiere acceder a un **área protegida,** aparece un **pop-up solicitando permiso**.

# Protección de Datos

Los desarrolladores de aplicaciones pueden aprovechar las APIs de _Protección de Datos_ de iOS para implementar un **control de acceso detallado** para los datos del usuario almacenados en la memoria flash. Las APIs están construidas sobre el **Secure Enclave Processor** (SEP). El SEP es un coprocesador que proporciona **operaciones criptográficas para la protección de datos y la gestión de claves**. Una clave de hardware específica del dispositivo, el **device UID** (ID Único), está **incrustada en el enclave seguro**, asegurando la integridad de la protección de datos incluso cuando el kernel del sistema operativo está comprometido.

Cuando se **crea un archivo** en el disco, se genera una nueva clave **AES de 256 bits** con la ayuda del generador de números aleatorios basado en hardware del enclave seguro. El **contenido del archivo se cifra entonces con la clave generada**. Y luego, esta **clave se guarda cifrada con una clave de clase** junto con **el ID de clase,** con **ambos datos cifrados por la clave del sistema,** dentro de los **metadatos** del archivo.

![](<../../.gitbook/assets/image (473).png>)

Para descifrar el archivo, los **metadatos se descifran usando la clave del sistema**. Luego, **usando el ID de clase** se **recupera la clave de clase** **para descifrar la clave del archivo y descifrar el archivo.**

Los archivos pueden asignarse a una de **cuatro** **diferentes** **clases de protección**, que se explican con más detalle en la [Guía de Seguridad de la Plataforma Apple](https://help.apple.com/pdf/security/en_US/apple-platform-security-guide.pdf):

* **Protección Completa (NSFileProtectionComplete)**: Una clave derivada del código de acceso del usuario y el device UID protege esta clave de clase. La clave derivada se elimina de la memoria poco después de que el dispositivo se bloquea, haciendo que los datos sean inaccesibles hasta que el usuario desbloquee el dispositivo.
* **Protegido a Menos que Esté Abierto (NSFileProtectionCompleteUnlessOpen)**: Esta clase de protección es similar a la Protección Completa, pero, si el archivo está abierto cuando se desbloquea, la aplicación puede continuar accediendo al archivo incluso si el usuario bloquea el dispositivo. Esta clase de protección se utiliza cuando, por ejemplo, se está descargando un adjunto de correo en segundo plano.
* **Protegido Hasta la Primera Autenticación del Usuario (NSFileProtectionCompleteUntilFirstUserAuthentication)**: El archivo se puede acceder tan pronto como el usuario desbloquee el dispositivo por primera vez después de arrancar. Se puede acceder incluso si el usuario vuelve a bloquear el dispositivo y la clave de clase no se elimina de la memoria.
* **Sin Protección (NSFileProtectionNone)**: La clave para esta clase de protección está protegida solo con el UID. La clave de clase se almacena en "Effaceable Storage", que es una región de la memoria flash en el dispositivo iOS que permite el almacenamiento de pequeñas cantidades de datos. Esta clase de protección existe para el borrado remoto rápido (eliminación inmediata de la clave de clase, lo que hace que los datos sean inaccesibles).

Todas las claves de clase excepto `NSFileProtectionNone` están cifradas con una clave derivada del device UID y el código de acceso del usuario. Como resultado, el descifrado solo puede ocurrir en el propio dispositivo y requiere el código de acceso correcto.

Desde iOS 7, la clase de protección de datos predeterminada es "Protegido Hasta la Primera Autenticación del Usuario".

[**FileDP**](https://github.com/abjurato/FileDp-Source) es un programa que puedes subir y usar dentro del iPhone para **inspeccionar la clase de protección de datos** de cada archivo.

## El Keychain

Un keychain es un **contenedor cifrado** donde cada aplicación puede **almacenar** piezas de **información sensible** y solo la misma aplicación (o aplicaciones autorizadas) puede recuperar los contenidos.\
iOS **genera su propia contraseña para el keychain** y **almacena** una versión **cifrada** de esta clave en el dispositivo. Esta contraseña está cifrada con AES usando una clave AES creada por una función **PBKDF2** del **código de acceso del usuario + sal** (el **UID de 256 bits del dispositivo** **solo accesible** al chipset del enclave **seguro** en el dispositivo). Debido al uso de este UID del dispositivo como sal, un dispositivo no podrá descifrar el keychain de un dispositivo diferente incluso conociendo el código de acceso de los usuarios.

El acceso al Keychain está gestionado por el daemon **`securityd`**, que concede acceso de acuerdo con los `Keychain-access-groups`, `application-identifier`, y `application-group` entitlements de la aplicación.

La [API de Keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html) incluye las siguientes operaciones principales:

* `SecItemAdd`
* `SecItemUpdate`
* `SecItemCopyMatching`
* `SecItemDelete`

Las únicas formas de intentar BF esta contraseña es volcando la clave cifrada y BF el código de acceso + sal (la función **pbkdf2** utiliza **al menos 10000 iteraciones**). O intentando **BF dentro del dispositivo** para evitar BF la sal, sin embargo, el enclave seguro asegura que hay al menos un **retraso de 5s entre 2 intentos fallidos de contraseña**.

Puedes configurar **protección de datos para elementos del Keychain** estableciendo la clave `kSecAttrAccessible` en la llamada a `SecItemAdd` o `SecItemUpdate`.Los siguientes valores de accesibilidad configurables para `kSecAttrAccessible` son las clases de Protección de Datos del Keychain:

* **`kSecAttrAccessibleAlways`**: Los datos en el elemento del Keychain pueden **accederse siempre**, independientemente de si el dispositivo está bloqueado.
* **`kSecAttrAccessibleAlwaysThisDeviceOnly`**: Los datos en el elemento del Keychain pueden **accederse siempre**, independientemente de si el dispositivo está bloqueado. Los datos **no se incluirán en una copia de seguridad de iCloud** o local.
* **`kSecAttrAccessibleAfterFirstUnlock`**: Los datos en el elemento del Keychain no pueden accederse después de un reinicio hasta que el **dispositivo haya sido desbloqueado una vez** por el usuario.
* **`kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`**: Los datos en el elemento del Keychain no pueden accederse después de un reinicio hasta que el **dispositivo haya sido desbloqueado una vez** por el usuario. Los elementos con este atributo **no migran a un nuevo dispositivo**. Por lo tanto, después de restaurar desde una copia de seguridad de un dispositivo diferente, estos elementos no estarán presentes.
* **`kSecAttrAccessibleWhenUnlocked`**: Los datos en el elemento del Keychain pueden accederse **solo mientras el dispositivo está desbloqueado** por el usuario.
* **`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`**: Los datos en el elemento del Keychain pueden accederse **solo mientras el dispositivo está desbloqueado** por el usuario. Los datos **no se incluirán en una copia de seguridad de iCloud o local**.
* **`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`**: Los datos en el Keychain pueden accederse **solo cuando el dispositivo está desbloqueado**. Esta clase de protección **solo está disponible si se establece un código de acceso** en el dispositivo. Los datos **no se incluirán en una copia de seguridad de iCloud o local**.

**`AccessControlFlags`** definen los mecanismos con los que los usuarios pueden autenticar la clave (`SecAccessControlCreateFlags`):

* **`kSecAccessControlDevicePasscode`**: Acceder al elemento mediante un código de acceso.
* **`kSecAccessControlBiometryAny`**: Acceder al elemento mediante una de las huellas dactilares registradas en Touch ID. Agregar o eliminar una huella dactilar no invalidará el elemento.
* **`kSecAccessControlBiometryCurrentSet`**: Acceder al elemento mediante una de las huellas dactilares registradas en Touch ID. Agregar o eliminar una huella dactilar _sí_ invalidará el elemento.
* **`kSecAccessControlUserPresence`**: Acceder al elemento mediante una de las huellas dactilares registradas (usando Touch ID) o por defecto al código de acceso.

Tenga en cuenta que las claves aseguradas por Touch ID (a través de `kSecAccessControlBiometryAny` o `kSecAccessControlBiometryCurrentSet`) están protegidas por el Secure Enclave: el Keychain solo contiene un token, no la clave real. La clave reside en el Secure Enclave.

El iPhone utiliza el **código de acceso introducido por el usuario al desbloquear el dispositivo para descifrar los secretos en el keychain**.

iOS utiliza el _**AppIdentifierPrefix**_ (Team ID) y el _**BundleIdentifier**_ (proporcionado por el desarrollador) para hacer cumplir el **control de acceso sobre los elementos del keychain**. Entonces, el mismo equipo **puede** **configurar** **2 aplicaciones para compartir elementos del keychain**.

Cuando se inicia un proceso de copia de seguridad, los **datos del keychain respaldados permanecen cifrados y la contraseña del keychain no se incluye en la copia de seguridad**.

{% hint style="warning" %}
**En un dispositivo con jailbreak el keychain no está protegido.**
{% endhint %}

### **Persistencia de Datos del Keychain**

En iOS, cuando se desinstala una aplicación, los datos del Keychain utilizados por la aplicación son retenidos por el dispositivo, a diferencia de los datos almacenados por el sandbox de la aplicación que se borran. En el caso de que un **usuario venda su dispositivo sin realizar un restablecimiento de fábrica, el comprador del dispositivo podría acceder a las cuentas y datos de las aplicaciones del usuario anterior reinstalando** las mismas aplicaciones utilizadas por el usuario anterior. Esto no requeriría ninguna habilidad técnica para realizar.

No hay una API de iOS que los desarrolladores puedan usar para forzar el borrado de datos cuando se desinstala una aplicación. En su lugar, los desarrolladores deben tomar las siguientes medidas para evitar que los datos del Keychain persistan entre instalaciones de aplicaciones:

* Cuando una aplicación se lanza por primera vez después de la instalación, borrar todos los datos del Keychain asociados con la aplicación. Esto evitará que un segundo usuario del dispositivo acceda accidentalmente a las cuentas del usuario anterior. El siguiente ejemplo en Swift es una demostración básica de este procedimiento de borrado:
```
```objectivec
let userDefaults = UserDefaults.standard

if userDefaults.bool(forKey: "hasRunBefore") == false {
// Remove Keychain items here

// Update the flag indicator
userDefaults.set(true, forKey: "hasRunBefore")
userDefaults.synchronize() // Forces the app to update UserDefaults
}
```
* Al desarrollar la funcionalidad de cierre de sesión para una aplicación iOS, asegúrate de que los datos de Keychain se borren como parte del cierre de sesión de la cuenta. Esto permitirá a los usuarios limpiar sus cuentas antes de desinstalar una aplicación.

# **Capacidades de la App**

**Cada app tiene un directorio hogar único y está en un entorno aislado (sandboxed)**, de modo que no pueden acceder a recursos del sistema protegidos o archivos almacenados por el sistema o por otras apps. Estas restricciones se implementan a través de políticas de entorno aislado (también conocidas como _perfiles_), que son aplicadas por el [Marco de Control de Acceso Obligatorio Trusted BSD (MAC)](http://www.trustedbsd.org/mac.html) a través de una extensión del kernel.

Algunas [**capacidades/permisos**](https://help.apple.com/developer-account/#/dev21218dfd6) pueden ser configuradas por los desarrolladores de la app (por ejemplo, Protección de Datos o Compartir Keychain) y tendrán efecto inmediatamente después de la instalación. Sin embargo, para otras, **se pedirá explícitamente al usuario la primera vez que la app intente acceder a un recurso protegido**.

Los [_Purpose strings_](https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy/accessing_protected_resources?language=objc#3037322) o _cadenas de descripción de uso_ son textos personalizados que se ofrecen a los usuarios en la alerta de solicitud de permisos del sistema cuando se solicita permiso para acceder a datos o recursos protegidos.

![](https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQw8W2q7BB5-il7r%2Fpermission_request_alert.png?alt=media)

Si tienes el código fuente original, puedes verificar los permisos incluidos en el archivo `Info.plist`:

* Abre el proyecto con Xcode.
* Encuentra y abre el archivo `Info.plist` en el editor predeterminado y busca las claves que comienzan con `"Privacy -"`.

Puedes cambiar la vista para mostrar los valores brutos haciendo clic derecho y seleccionando "Mostrar Claves/Valores Brutos" (de esta manera, por ejemplo, `"Privacy - Location When In Use Usage Description"` se convertirá en `NSLocationWhenInUseUsageDescription`).

Si solo tienes el IPA:

* Descomprime el IPA.
* El `Info.plist` se encuentra en `Payload/<appname>.app/Info.plist`.
* Conviértelo si es necesario (por ejemplo, `plutil -convert xml1 Info.plist`) como se explica en el capítulo "Pruebas Básicas de Seguridad en iOS", sección "El Archivo Info.plist".
*   Inspecciona todas las claves de _purpose strings en Info.plist_, que generalmente terminan con `UsageDescription`:

```markup
<plist version="1.0">
<dict>
<key>NSLocationWhenInUseUsageDescription</key>
<string>Tu ubicación se utiliza para proporcionar indicaciones paso a paso hasta tu destino.</string>
```

## Capacidades del Dispositivo

Las capacidades del dispositivo son utilizadas por la App Store para asegurar que solo los dispositivos compatibles estén listados y, por lo tanto, tengan permitido descargar la app. Se especifican en el archivo `Info.plist` de la app bajo la clave [`UIRequiredDeviceCapabilities`](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/plist/info/UIRequiredDeviceCapabilities).
```markup
<key>UIRequiredDeviceCapabilities</key>
<array>
<string>armv7</string>
</array>
```
> Típicamente encontrarás la capacidad `armv7`, lo que significa que la app está compilada solo para el conjunto de instrucciones armv7, o si es una app universal de 32/64 bits.

Por ejemplo, una app podría depender completamente de NFC para funcionar (por ejemplo, una app ["NFC Tag Reader"](https://itunes.apple.com/us/app/nfc-taginfo-by-nxp/id1246143596)). Según la [Referencia de Compatibilidad de Dispositivos iOS archivada](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html), NFC solo está disponible a partir del iPhone 7 (y iOS 11). Un desarrollador podría querer excluir todos los dispositivos incompatibles estableciendo la capacidad del dispositivo `nfc`.

## Entitlements

> Los entitlements son pares clave-valor que están firmados en una app y permiten autenticación más allá de factores de tiempo de ejecución, como el ID de usuario UNIX. Dado que los entitlements están firmados digitalmente, no se pueden cambiar. Los entitlements son utilizados extensivamente por apps del sistema y daemons para **realizar operaciones privilegiadas específicas que de otro modo requerirían que el proceso se ejecute como root**. Esto reduce en gran medida el potencial de escalada de privilegios por una app del sistema o daemon comprometido.

Por ejemplo, si quieres establecer la capacidad "Protección de Datos Predeterminada", necesitarías ir a la pestaña **Capabilities** en Xcode y habilitar **Protección de Datos**. Esto es escrito directamente por Xcode en el archivo `<appname>.entitlements` como el entitlement `com.apple.developer.default-data-protection` con el valor predeterminado `NSFileProtectionComplete`. En el IPA podríamos encontrar esto en el `embedded.mobileprovision` como:
```markup
<key>Entitlements</key>
<dict>
...
<key>com.apple.developer.default-data-protection</key>
<string>NSFileProtectionComplete</string>
</dict>
```
Para otras capacidades como HealthKit, se debe pedir permiso al usuario, por lo tanto, no es suficiente con añadir los entitlements, también se deben agregar claves y cadenas especiales al archivo `Info.plist` de la app.

# Fundamentos de Objective-C y Swift

**Objective-C** tiene un **runtime dinámico**, así que cuando un programa de Objective-C se ejecuta en iOS, llama a bibliotecas cuyas **direcciones se resuelven en tiempo de ejecución** comparando el nombre de la función enviada en el mensaje contra una lista de todos los nombres de funciones disponibles.

Al principio, solo las apps creadas por Apple funcionaban en los iPhones, por lo que tenían **acceso a todo** ya que eran **confiables**. Sin embargo, cuando Apple **permitió aplicaciones de terceros**, simplemente eliminó los archivos de cabecera de las funciones poderosas para "ocultarlas" a los desarrolladores. No obstante, los desarrolladores descubrieron que las funciones "seguras" necesitaban algunas de estas funciones no documentadas y solo creando un **archivo de cabecera personalizado con los nombres de las funciones no documentadas, era posible invocar estas poderosas funciones ocultas.** De hecho, Apple, antes de permitir la publicación de una app, verifica si la app llama a alguna de estas funciones prohibidas.

Luego, apareció Swift. Como **Swift está vinculado estáticamente** (no resuelve las direcciones de las funciones en tiempo de ejecución como Objective-C), se pueden verificar más fácilmente las llamadas que va a realizar un programa de Swift mediante análisis de código estático.

# Gestión de Dispositivos

Desde la versión 6 de iOS, hay **soporte incorporado para la capacidad de gestión de dispositivos** con controles de granularidad fina que permiten a una organización controlar los dispositivos Apple corporativos.\
El enrolamiento puede ser **iniciado por el usuario instalando un agente** para acceder a las apps corporativas. En este caso, el dispositivo generalmente pertenece al usuario.\
O la **empresa puede indicar los números de serie** de los dispositivos comprados o la ID de la orden de compra y especificar el perfil MDM para instalar en esos dispositivos. Cabe destacar que Apple **no permite enrolar un dispositivo en particular de esta manera dos veces**. Una vez que se elimina el primer perfil, el usuario necesita dar su consentimiento para instalar otro.

El usuario puede ver las políticas instaladas en _**Ajustes**_ --> _**General**_ --> _**Gestión de Perfiles y Dispositivos**_

Como estas políticas MDM están revisando y limitando otras aplicaciones, están **funcionando con más privilegios**.\
Una política MDM puede **obligar** a los **usuarios** a tener un **código de acceso** establecido con una **complejidad de contraseña mínima**.\
Los perfiles están vinculados al deviceID, **firmados** y **cifrados** por el servidor MDM y son **a prueba de manipulaciones**. **No pueden** ser **eliminados** sin **perder** todos los **datos corporativos**.\
Los perfiles MDM permiten **borrar** todos los **datos** si hay X **intentos fallidos** de contraseña. Además, el **administrador** puede **borrar remotamente** el iPhone en cualquier momento a través de la interfaz MDM.

Los agentes MDM también **verificarán** posibles **jailbreaks del dispositivo**, ya que este es un estado muy peligroso para un iPhone.


<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en github.

</details>
