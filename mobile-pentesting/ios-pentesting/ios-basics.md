```markdown
<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


# Separa√ß√£o de Privil√©gios e Sandbox

Aplica√ß√µes acess√≠veis pelo usu√°rio rodam como o usu√°rio **mobile** enquanto processos cr√≠ticos do sistema rodam como **root**.\
No entanto, o sandbox permite um melhor controle sobre a√ß√µes que processos e aplica√ß√µes podem executar.

Por exemplo, mesmo que dois processos rodem como o mesmo usu√°rio (mobile), eles **n√£o t√™m permiss√£o para acessar ou modificar os dados um do outro**.

Cada aplica√ß√£o √© instalada em **`private/var/mobile/Applications/{ID aleat√≥rio}`**\
Uma vez instaladas, as aplica√ß√µes t√™m acesso limitado de leitura a algumas √°reas e fun√ß√µes do sistema (SMS, chamada telef√¥nica...). Se uma aplica√ß√£o deseja acessar uma **√°rea protegida,** um **pop-up solicitando permiss√£o** aparece.

# Prote√ß√£o de Dados

Desenvolvedores de aplicativos podem aproveitar as APIs de _Prote√ß√£o de Dados_ do iOS para implementar **controle de acesso refinado** para dados do usu√°rio armazenados na mem√≥ria flash. As APIs s√£o constru√≠das em cima do **Secure Enclave Processor** (SEP). O SEP √© um coprocessador que fornece **opera√ß√µes criptogr√°ficas para prote√ß√£o de dados e gerenciamento de chaves**. Uma chave de hardware espec√≠fica do dispositivo - o **device UID** (ID √önico) - √© **embutida no enclave seguro**, garantindo a integridade da prote√ß√£o de dados mesmo quando o kernel do sistema operacional est√° comprometido.

Quando um **arquivo √© criado** no disco, uma nova chave **AES de 256 bits √© gerada** com a ajuda do gerador de n√∫meros aleat√≥rios baseado em hardware do enclave seguro. O **conte√∫do do arquivo √© ent√£o criptografado com a chave gerada**. E ent√£o, essa **chave √© salva criptografada com uma chave de classe** junto com **o ID da classe,** com **ambos os dados criptografados pela chave do sistema,** dentro do **metadado** do arquivo.

![](<../../.gitbook/assets/image (473).png>)

Para descriptografar o arquivo, o **metadado √© descriptografado usando a chave do sistema**. Ent√£o, **usando o ID da classe** a **chave de classe √© recuperada** **para descriptografar a chave do arquivo e descriptografar o arquivo.**

Arquivos podem ser atribu√≠dos a uma de **quatro** **diferentes** **classes de prote√ß√£o**, que s√£o explicadas em mais detalhes no [Guia de Seguran√ßa da Plataforma Apple](https://help.apple.com/pdf/security/en_US/apple-platform-security-guide.pdf):

* **Prote√ß√£o Completa (NSFileProtectionComplete)**: Uma chave derivada do c√≥digo de acesso do usu√°rio e do device UID protege esta chave de classe. A chave derivada √© apagada da mem√≥ria logo ap√≥s o dispositivo ser bloqueado, tornando os dados inacess√≠veis at√© que o usu√°rio desbloqueie o dispositivo.
* **Protegido a Menos que Aberto (NSFileProtectionCompleteUnlessOpen)**: Esta classe de prote√ß√£o √© semelhante √† Prote√ß√£o Completa, mas, se o arquivo estiver aberto quando desbloqueado, o aplicativo pode continuar acessando o arquivo mesmo se o usu√°rio bloquear o dispositivo. Esta classe de prote√ß√£o √© usada quando, por exemplo, um anexo de e-mail est√° sendo baixado em segundo plano.
* **Protegido At√© a Primeira Autentica√ß√£o do Usu√°rio (NSFileProtectionCompleteUntilFirstUserAuthentication)**: O arquivo pode ser acessado assim que o usu√°rio desbloquear o dispositivo pela primeira vez ap√≥s a inicializa√ß√£o. Ele pode ser acessado mesmo se o usu√°rio bloquear o dispositivo subsequentemente e a chave de classe n√£o for removida da mem√≥ria.
* **Sem Prote√ß√£o (NSFileProtectionNone)**: A chave para esta classe de prote√ß√£o √© protegida apenas com o UID. A chave de classe √© armazenada em "Armazenamento Apag√°vel", que √© uma regi√£o da mem√≥ria flash no dispositivo iOS que permite o armazenamento de pequenas quantidades de dados. Esta classe de prote√ß√£o existe para apagamento remoto r√°pido (dele√ß√£o imediata da chave de classe, o que torna os dados inacess√≠veis).

Todas as chaves de classe, exceto `NSFileProtectionNone`, s√£o criptografadas com uma chave derivada do device UID e do c√≥digo de acesso do usu√°rio. Como resultado, a descriptografia s√≥ pode ocorrer no pr√≥prio dispositivo e requer o c√≥digo de acesso correto.

Desde o iOS 7, a classe de prote√ß√£o de dados padr√£o √© "Protegido At√© a Primeira Autentica√ß√£o do Usu√°rio".

[**FileDP**](https://github.com/abjurato/FileDp-Source) √© um programa que voc√™ pode carregar e usar dentro do iPhone para **inspecionar a classe de prote√ß√£o de dados** de cada arquivo.

## O Keychain

O keychain √© um **container criptografado** onde cada aplicativo pode **armazenar** peda√ßos de **informa√ß√£o sens√≠vel** e apenas o mesmo aplicativo (ou aplicativos autorizados) pode recuperar o conte√∫do.\
O iOS **gera sua pr√≥pria senha para o keychain** e **armazena** uma vers√£o **criptografada** desta chave no dispositivo. Esta senha √© criptografada com AES usando uma chave AES criada por uma fun√ß√£o **PBKDF2** do **c√≥digo de acesso do usu√°rio + sal** (o **UID de 256 bits do dispositivo** **acess√≠vel** **apenas** pelo chipset do enclave **seguro** no dispositivo). Devido ao uso deste UID do dispositivo como sal, um dispositivo n√£o ser√° capaz de descriptografar o keychain de um dispositivo diferente mesmo conhecendo o c√≥digo de acesso dos usu√°rios.

O acesso ao Keychain √© gerenciado pelo daemon **`securityd`**, que concede acesso de acordo com os `Keychain-access-groups`, `application-identifier` e `application-group` entitlements do aplicativo.

A [API Keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html) inclui as seguintes opera√ß√µes principais:

* `SecItemAdd`
* `SecItemUpdate`
* `SecItemCopyMatching`
* `SecItemDelete`

As √∫nicas maneiras de tentar for√ßa bruta (BF) nesta senha √© despejando a chave criptografada e BF o c√≥digo de acesso + sal (a fun√ß√£o **pbkdf2** usa **pelo menos 10000 itera√ß√µes**). Ou tentando **BF dentro do dispositivo** para evitar BFing o sal, no entanto, o enclave seguro garante que haja pelo menos um **atraso de 5s entre 2 tentativas de senha falhadas**.

Voc√™ pode configurar **prote√ß√£o de dados para itens do Keychain** definindo a chave `kSecAttrAccessible` na chamada para `SecItemAdd` ou `SecItemUpdate`. Os seguintes valores de acessibilidade configur√°veis para kSecAttrAccessible s√£o as classes de Prote√ß√£o de Dados do Keychain:

* **`kSecAttrAccessibleAlways`**: Os dados no item do Keychain podem **sempre ser acessados**, independentemente de o dispositivo estar bloqueado.
* **`kSecAttrAccessibleAlwaysThisDeviceOnly`**: Os dados no item do Keychain podem **sempre** **ser** **acessados**, independentemente de o dispositivo estar bloqueado. Os dados **n√£o ser√£o inclu√≠dos em um backup do iCloud** ou local.
* **`kSecAttrAccessibleAfterFirstUnlock`**: Os dados no item do Keychain n√£o podem ser acessados ap√≥s uma reinicializa√ß√£o at√© que o **dispositivo tenha sido desbloqueado uma vez** pelo usu√°rio.
* **`kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`**: Os dados no item do Keychain n√£o podem ser acessados ap√≥s uma reinicializa√ß√£o at√© que o **dispositivo tenha sido desbloqueado uma vez** pelo usu√°rio. Itens com este atributo **n√£o migram para um novo dispositivo**. Assim, ap√≥s restaurar de um backup de um dispositivo diferente, esses itens n√£o estar√£o presentes.
* **`kSecAttrAccessibleWhenUnlocked`**: Os dados no item do Keychain podem ser acessados **apenas enquanto o dispositivo est√° desbloqueado** pelo usu√°rio.
* **`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`**: Os dados no item do Keychain podem ser acessados **apenas enquanto o dispositivo est√° desbloqueado** pelo usu√°rio. Os dados **n√£o ser√£o inclu√≠dos em um backup do iCloud ou local**.
* **`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`**: Os dados no Keychain podem ser acessados **apenas quando o dispositivo est√° desbloqueado**. Esta classe de prote√ß√£o **est√° dispon√≠vel apenas se um c√≥digo de acesso estiver configurado** no dispositivo. Os dados **n√£o ser√£o inclu√≠dos em um backup do iCloud ou local**.

**`AccessControlFlags`** definem os mecanismos com os quais os usu√°rios podem autenticar a chave (`SecAccessControlCreateFlags`):

* **`kSecAccessControlDevicePasscode`**: Acessar o item via um c√≥digo de acesso.
* **`kSecAccessControlBiometryAny`**: Acessar o item via uma das impress√µes digitais registradas no Touch ID. Adicionar ou remover uma impress√£o digital n√£o invalidar√° o item.
* **`kSecAccessControlBiometryCurrentSet`**: Acessar o item via uma das impress√µes digitais registradas no Touch ID. Adicionar ou remover uma impress√£o digital _ir√°_ invalidar o item.
* **`kSecAccessControlUserPresence`**: Acessar o item via uma das impress√µes digitais registradas (usando Touch ID) ou recorrer ao c√≥digo de acesso.

Observe que as chaves protegidas pelo Touch ID (via `kSecAccessControlBiometryAny` ou `kSecAccessControlBiometryCurrentSet`) s√£o protegidas pelo Secure Enclave: O Keychain mant√©m apenas um token, n√£o a chave real. A chave reside no Secure Enclave.

O iPhone usa o **c√≥digo de acesso introduzido pelo usu√°rio ao desbloquear o dispositivo para descriptografar os segredos no keychain**.

O iOS usa o _**AppIdentifierPrefix**_ (ID da Equipe) e o _**BundleIdentifier**_ (fornecido pelo desenvolvedor) para impor **controle de acesso sobre itens do keychain**. Ent√£o, a mesma equipe **pode** **configurar** **2 aplicativos para compartilhar itens do keychain**.

Quando um processo de backup √© iniciado, os **dados do keychain que s√£o salvos permanecem criptografados e a senha do keychain n√£o est√° inclu√≠da no backup**.

{% hint style="warning" %}
**Em um dispositivo com jailbreak, o keychain n√£o est√° protegido.**
{% endhint %}

### **Persist√™ncia de Dados do Keychain**

No iOS, quando um aplicativo √© desinstalado, os dados do Keychain usados pelo aplicativo s√£o retidos pelo dispositivo, ao contr√°rio dos dados armazenados pelo sandbox do aplicativo, que s√£o apagados. No caso de um **usu√°rio vender seu dispositivo sem realizar uma redefini√ß√£o de f√°brica, o comprador do dispositivo pode ser capaz de acessar as contas de aplicativos e dados do usu√°rio anterior reinstalando** os mesmos aplicativos usados pelo usu√°rio anterior. Isso n√£o requereria habilidade t√©cnica para ser realizado.

N√£o h√° uma API do iOS que os desenvolvedores possam usar para for√ßar a limpeza de dados quando um aplicativo √© desinstalado. Em vez disso, os desenvolvedores devem tomar as seguintes medidas para evitar que os dados do Keychain persistam entre instala√ß√µes de aplicativos:

* Quando um aplicativo √© lan√ßado pela primeira vez ap√≥s a instala√ß√£o, limpe todos os dados do Keychain associados ao aplicativo. Isso impedir√° que o segundo usu√°rio do dispositivo ganhe acesso acidental √†s contas do usu√°rio anterior. O seguinte exemplo em Swift √© uma demonstra√ß√£o b√°sica deste procedimento de limpeza:
```
```objectivec
let userDefaults = UserDefaults.standard

if userDefaults.bool(forKey: "hasRunBefore") == false {
// Remove Keychain items here

// Update the flag indicator
userDefaults.set(true, forKey: "hasRunBefore")
userDefaults.synchronize() // Forces the app to update UserDefaults
}
```
* Ao desenvolver a funcionalidade de logout para uma aplica√ß√£o iOS, certifique-se de que os dados do Keychain s√£o apagados como parte do logout da conta. Isso permitir√° que os usu√°rios limpem suas contas antes de desinstalar uma aplica√ß√£o.

# **Capacidades da Aplica√ß√£o**

**Cada aplica√ß√£o tem um diret√≥rio caseiro √∫nico e √© isolada (sandboxed)**, de modo que n√£o podem acessar recursos protegidos do sistema ou arquivos armazenados pelo sistema ou por outras aplica√ß√µes. Essas restri√ß√µes s√£o implementadas atrav√©s de pol√≠ticas de sandbox (tamb√©m conhecidas como _profiles_), que s√£o aplicadas pelo [Trusted BSD (MAC) Mandatory Access Control Framework](http://www.trustedbsd.org/mac.html) atrav√©s de uma extens√£o do kernel.

Algumas [**capacidades/permiss√µes**](https://help.apple.com/developer-account/#/dev21218dfd6) podem ser configuradas pelos desenvolvedores da aplica√ß√£o (por exemplo, Prote√ß√£o de Dados ou Compartilhamento de Keychain) e ter√£o efeito direto ap√≥s a instala√ß√£o. No entanto, para outras, **o usu√°rio ser√° explicitamente solicitado na primeira vez que a aplica√ß√£o tentar acessar um recurso protegido**.

[_Purpose strings_](https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy/accessing_protected_resources?language=objc#3037322) ou _strings de descri√ß√£o de uso_ s√£o textos personalizados que s√£o oferecidos aos usu√°rios no alerta de solicita√ß√£o de permiss√£o do sistema ao pedir permiss√£o para acessar dados ou recursos protegidos.

![](https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQw8W2q7BB5-il7r%2Fpermission_request_alert.png?alt=media)

Se tiver o c√≥digo-fonte original, voc√™ pode verificar as permiss√µes inclu√≠das no arquivo `Info.plist`:

* Abra o projeto com o Xcode.
* Encontre e abra o arquivo `Info.plist` no editor padr√£o e procure pelas chaves que come√ßam com `"Privacy -"`.

Voc√™ pode mudar a visualiza√ß√£o para exibir os valores brutos clicando com o bot√£o direito e selecionando "Show Raw Keys/Values" (desta forma, por exemplo, `"Privacy - Location When In Use Usage Description"` se transformar√° em `NSLocationWhenInUseUsageDescription`).

Se tiver apenas o IPA:

* Descompacte o IPA.
* O `Info.plist` est√° localizado em `Payload/<appname>.app/Info.plist`.
* Converta-o se necess√°rio (por exemplo, `plutil -convert xml1 Info.plist`) conforme explicado no cap√≠tulo "iOS Basic Security Testing", se√ß√£o "The Info.plist File".
*   Inspecione todas as _chaves de strings de prop√≥sito no Info.plist_, geralmente terminando com `UsageDescription`:

```markup
<plist version="1.0">
<dict>
<key>NSLocationWhenInUseUsageDescription</key>
<string>Sua localiza√ß√£o √© usada para fornecer dire√ß√µes passo a passo at√© seu destino.</string>
```

## Capacidades do Dispositivo

As capacidades do dispositivo s√£o usadas pela App Store para garantir que apenas dispositivos compat√≠veis sejam listados e, portanto, tenham permiss√£o para baixar a aplica√ß√£o. Elas s√£o especificadas no arquivo `Info.plist` da aplica√ß√£o sob a chave [`UIRequiredDeviceCapabilities`](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/plist/info/UIRequiredDeviceCapabilities).
```markup
<key>UIRequiredDeviceCapabilities</key>
<array>
<string>armv7</string>
</array>
```
> Normalmente, voc√™ encontrar√° a capacidade `armv7`, o que significa que o aplicativo √© compilado apenas para o conjunto de instru√ß√µes armv7, ou se √© um aplicativo universal de 32/64 bits.

Por exemplo, um aplicativo pode depender completamente do NFC para funcionar (por exemplo, um aplicativo ["NFC Tag Reader"](https://itunes.apple.com/us/app/nfc-taginfo-by-nxp/id1246143596)). De acordo com o [arquivo de refer√™ncia de compatibilidade de dispositivos iOS](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html), o NFC est√° dispon√≠vel apenas a partir do iPhone 7 (e iOS 11). Um desenvolvedor pode querer excluir todos os dispositivos incompat√≠veis definindo a capacidade do dispositivo `nfc`.

## Entitlements

> Entitlements s√£o pares de chave-valor que s√£o assinados em um aplicativo e permitem autentica√ß√£o al√©m de fatores de tempo de execu√ß√£o, como o ID de usu√°rio UNIX. Como os entitlements s√£o assinados digitalmente, eles n√£o podem ser alterados. Entitlements s√£o usados extensivamente por aplicativos do sistema e daemons para **realizar opera√ß√µes privilegiadas espec√≠ficas que, de outra forma, exigiriam que o processo fosse executado como root**. Isso reduz muito o potencial de escalonamento de privil√©gios por um aplicativo do sistema ou daemon comprometido.

Por exemplo, se voc√™ quiser definir a capacidade "Prote√ß√£o de Dados Padr√£o", voc√™ precisaria ir at√© a aba **Capabilities** no Xcode e habilitar **Data Protection**. Isso √© escrito diretamente pelo Xcode no arquivo `<appname>.entitlements` como o entitlement `com.apple.developer.default-data-protection` com o valor padr√£o `NSFileProtectionComplete`. No IPA, podemos encontrar isso no `embedded.mobileprovision` como:
```markup
<key>Entitlements</key>
<dict>
...
<key>com.apple.developer.default-data-protection</key>
<string>NSFileProtectionComplete</string>
</dict>
```
Para outras capacidades, como HealthKit, o usu√°rio deve ser solicitado a dar permiss√£o, portanto, n√£o √© suficiente adicionar os direitos, chaves especiais e strings devem ser adicionadas ao arquivo `Info.plist` do aplicativo.

# Fundamentos de Objective-C e Swift

**Objective-C** possui um **runtime din√¢mico**, ent√£o quando um programa Objective-C √© executado no iOS, ele chama bibliotecas cujos **endere√ßos s√£o resolvidos em tempo de execu√ß√£o** comparando o nome da fun√ß√£o enviada na mensagem contra uma lista de todos os nomes de fun√ß√µes dispon√≠veis.

No in√≠cio, apenas aplicativos criados pela Apple rodavam nos iPhones, ent√£o eles tinham **acesso a tudo** j√° que eram **confi√°veis**. No entanto, quando a Apple **permitiu** **aplicativos de terceiros,** a Apple simplesmente removeu os arquivos de cabe√ßalho das fun√ß√µes poderosas para "escond√™-las" dos desenvolvedores. No entanto, os desenvolvedores descobriram que fun√ß√µes "seguras" precisavam de algumas dessas fun√ß√µes n√£o documentadas e apenas criando um **arquivo de cabe√ßalho personalizado com os nomes das fun√ß√µes n√£o documentadas, era poss√≠vel invocar essas poderosas fun√ß√µes ocultas.** De fato, a Apple, antes de permitir a publica√ß√£o de um aplicativo, verifica se o aplicativo chama alguma dessas fun√ß√µes proibidas.

Ent√£o, apareceu o Swift. Como **Swift √© estaticamente vinculado** (n√£o resolve o endere√ßo das fun√ß√µes em tempo de execu√ß√£o como Objective-C), √© mais f√°cil verificar as chamadas que um programa Swift vai fazer atrav√©s de an√°lise est√°tica de c√≥digo.

# Gerenciamento de Dispositivos

A partir da vers√£o 6 do iOS, existe **suporte integrado para capacidade de gerenciamento de dispositivos** com controles de granula√ß√£o fina que permitem a uma organiza√ß√£o controlar os dispositivos apple corporativos.\
O registro pode ser **iniciado pelo usu√°rio instalando um agente** para acessar os aplicativos corporativos. Neste caso, o dispositivo geralmente pertence ao usu√°rio.\
Ou a **empresa pode indicar os n√∫meros de s√©rie** dos dispositivos comprados ou o ID do pedido de compra e especificar o perfil MDM para instalar nesses dispositivos. Note que a Apple **n√£o permite registrar um dispositivo particular desta forma duas vezes**. Uma vez que o primeiro perfil √© deletado, o usu√°rio precisa dar consentimento para instalar outro.

O usu√°rio pode ver as pol√≠ticas instaladas em _**Configura√ß√µes**_ --> _**Geral**_ --> _**Gerenciamento de Dispositivos e Perfis**_

Como essas pol√≠ticas MDM est√£o verificando e limitando outros aplicativos, elas est√£o **rodando com mais privil√©gios**.\
Uma pol√≠tica MDM pode **exigir** que os **usu√°rios** tenham um **c√≥digo de acesso** definido com uma **complexidade m√≠nima** de senha.\
Os perfis s√£o vinculados ao deviceID, **assinados** e **criptografados** pelo servidor MDM e s√£o **√† prova de adultera√ß√£o**. Eles **n√£o podem** ser **removidos** sem **perder** todos os **dados corporativos**.\
Perfis MDM permitem **apagar** todos os **dados** se houver X **tentativas falhas** de senha. Al√©m disso, o **administrador** pode **apagar remotamente** o iPhone a qualquer momento via interface MDM.

Agentes MDM tamb√©m **verificam** poss√≠veis **jailbreaks do dispositivo**, pois isso √© um estado muito perigoso para um iPhone.


<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**merchandising oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas dicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
