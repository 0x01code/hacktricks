<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une entreprise de cybers√©curit√© ? Voulez-vous voir votre entreprise annonc√©e dans HackTricks ? ou voulez-vous avoir acc√®s √† la derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF ? Consultez les [PLANS D'ABONNEMENT](https://github.com/sponsors/carlospolop) !

- D√©couvrez [La famille PEASS](https://opensea.io/collection/the-peass-family), notre collection d'[NFTs](https://opensea.io/collection/the-peass-family) exclusifs.

- Obtenez le [swag officiel PEASS & HackTricks](https://peass.creator-spring.com)

- Rejoignez le [üí¨](https://emojipedia.org/speech-balloon/) groupe Discord ou le groupe [telegram](https://t.me/peass) ou suivez-moi sur Twitter [üê¶](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[@carlospolopm](https://twitter.com/hacktricks_live).

- Partagez vos astuces de piratage en soumettant des PR au [d√©p√¥t hacktricks](https://github.com/carlospolop/hacktricks) et au [d√©p√¥t hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud).

</details>


# S√©paration des privil√®ges et bac √† sable

Les applications auxquelles l'utilisateur peut acc√©der s'ex√©cutent en tant qu'utilisateur **mobile** tandis que les processus syst√®me critiques s'ex√©cutent en tant que **root**.\
Cependant, le bac √† sable permet un meilleur contr√¥le des actions que les processus et les applications peuvent effectuer.

Par exemple, m√™me si deux processus s'ex√©cutent en tant que m√™me utilisateur (mobile), ils ne sont **pas autoris√©s √† acc√©der ou √† modifier les donn√©es de l'autre**.

Chaque application est install√©e sous **`private/var/mobile/Applications/{ID al√©atoire}`**\
Une fois install√©es, les applications ont un acc√®s en lecture limit√© √† certaines zones et fonctions du syst√®me (SMS, appel t√©l√©phonique...). Si une application souhaite acc√©der √† une **zone prot√©g√©e**, une **fen√™tre contextuelle demandant l'autorisation** appara√Æt.

# Protection des donn√©es

Les d√©veloppeurs d'applications peuvent exploiter les API de _Protection des donn√©es_ d'iOS pour mettre en ≈ìuvre un **contr√¥le d'acc√®s fin** pour les donn√©es utilisateur stock√©es dans la m√©moire flash. Les API sont construites sur le **processeur Secure Enclave** (SEP). Le SEP est un coprocesseur qui fournit des **op√©rations cryptographiques pour la protection des donn√©es et la gestion des cl√©s**. Une cl√© mat√©rielle sp√©cifique au dispositif - l'**UID de dispositif** (identifiant unique) - est **int√©gr√©e dans l'enclave s√©curis√©e**, assurant l'int√©grit√© de la protection des donn√©es m√™me lorsque le noyau du syst√®me d'exploitation est compromis.

Lorsqu'un **fichier est cr√©√©** sur le disque, une nouvelle **cl√© AES de 256 bits est g√©n√©r√©e** √† l'aide du g√©n√©rateur de nombres al√©atoires bas√© sur le mat√©riel de l'enclave s√©curis√©e. Le **contenu du fichier est ensuite chiffr√© avec la cl√© g√©n√©r√©e**. Et ensuite, cette **cl√© est enregistr√©e chiffr√©e avec une cl√© de classe** avec **l'ID de classe**, avec **les deux donn√©es chiffr√©es par la cl√© du syst√®me**, √† l'int√©rieur des **m√©tadonn√©es** du fichier.

![](<../../.gitbook/assets/image (473).png>)

Pour d√©chiffrer le fichier, les **m√©tadonn√©es sont d√©chiffr√©es en utilisant la cl√© du syst√®me**. Ensuite, en utilisant l'**ID de classe**, la **cl√© de classe est r√©cup√©r√©e** **pour d√©chiffrer la cl√© par fichier et d√©chiffrer le fichier.**

Les fichiers peuvent √™tre attribu√©s √† l'une des **quatre classes de protection diff√©rentes**, qui sont expliqu√©es en d√©tail dans le [Guide de s√©curit√© de la plateforme Apple](https://help.apple.com/pdf/security/en_US/apple-platform-security-guide.pdf) :

* **Protection compl√®te (NSFileProtectionComplete)** : Une cl√© d√©riv√©e du code d'acc√®s de l'utilisateur et de l'UID de l'appareil prot√®ge cette cl√© de classe. La cl√© d√©riv√©e est effac√©e de la m√©moire peu de temps apr√®s que l'appareil est verrouill√©, rendant les donn√©es inaccessibles jusqu'√† ce que l'utilisateur d√©verrouille l'appareil.
* **Prot√©g√© sauf ouvert (NSFileProtectionCompleteUnlessOpen)** : Cette classe de protection est similaire √† la
```objectivec
let userDefaults = UserDefaults.standard

if userDefaults.bool(forKey: "hasRunBefore") == false {
    // Remove Keychain items here

    // Update the flag indicator
    userDefaults.set(true, forKey: "hasRunBefore")
    userDefaults.synchronize() // Forces the app to update UserDefaults
}
```
* Lors du d√©veloppement de la fonctionnalit√© de d√©connexion pour une application iOS, assurez-vous que les donn√©es du trousseau sont effac√©es lors de la d√©connexion du compte. Cela permettra aux utilisateurs de supprimer leurs comptes avant de d√©sinstaller une application.

# **Fonctionnalit√©s de l'application**

**Chaque application a un r√©pertoire principal unique et est isol√©e**, de sorte qu'elle ne peut pas acc√©der aux ressources syst√®me prot√©g√©es ou aux fichiers stock√©s par le syst√®me ou par d'autres applications. Ces restrictions sont mises en ≈ìuvre via des politiques de bac √† sable (alias _profils_), qui sont appliqu√©es par le biais du [Trusted BSD (MAC) Mandatory Access Control Framework](http://www.trustedbsd.org/mac.html) via une extension de noyau.

Certaines [**fonctionnalit√©s/autorisations**](https://help.apple.com/developer-account/#/dev21218dfd6) peuvent √™tre configur√©es par les d√©veloppeurs de l'application (par exemple, la protection des donn√©es ou le partage de trousseau) et prendront effet directement apr√®s l'installation. Cependant, pour d'autres, **l'utilisateur sera explicitement invit√© la premi√®re fois que l'application tente d'acc√©der √† une ressource prot√©g√©e**.

Les cha√Ænes de but (ou _usage description strings_) sont des textes personnalis√©s qui sont propos√©s aux utilisateurs dans l'alerte de demande d'autorisation du syst√®me lorsqu'une autorisation est demand√©e pour acc√©der √† des donn√©es ou des ressources prot√©g√©es.

![](https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc\_%2F-Lf1AQw8W2q7BB5-il7r%2Fpermission\_request\_alert.png?alt=media)

Si vous avez le code source d'origine, vous pouvez v√©rifier les autorisations incluses dans le fichier `Info.plist` :

* Ouvrez le projet avec Xcode.
* Trouvez et ouvrez le fichier `Info.plist` dans l'√©diteur par d√©faut et recherchez les cl√©s commen√ßant par `"Privacy -"`.

Vous pouvez passer √† la vue pour afficher les valeurs brutes en faisant un clic droit et en s√©lectionnant "Afficher les cl√©s/valeurs brutes" (de cette fa√ßon, par exemple, `"Privacy - Location When In Use Usage Description"` deviendra `NSLocationWhenInUseUsageDescription`).

Si vous n'avez que le fichier IPA :

* D√©compressez le fichier IPA.
* Le fichier `Info.plist` se trouve dans `Payload/<nom de l'application>.app/Info.plist`.
* Convertissez-le si n√©cessaire (par exemple, `plutil -convert xml1 Info.plist`) comme expliqu√© dans le chapitre "iOS Basic Security Testing", section "The Info.plist File".
*   Inspectez toutes les cl√©s Info.plist des cha√Ænes de but, qui se terminent g√©n√©ralement par `UsageDescription` :

    ```markup
      <plist version="1.0">
      <dict>
          <key>NSLocationWhenInUseUsageDescription</key>
          <string>Votre emplacement est utilis√© pour fournir des instructions d√©taill√©es pour vous rendre √† votre destination.</string>
    ```

## Fonctionnalit√©s de l'appareil

Les fonctionnalit√©s de l'appareil sont utilis√©es par l'App Store pour s'assurer que seuls les appareils compatibles sont r√©pertori√©s et donc autoris√©s √† t√©l√©charger l'application. Elles sont sp√©cifi√©es dans le fichier `Info.plist` de l'application sous la cl√© [`UIRequiredDeviceCapabilities`](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple\_ref/doc/plist/info/UIRequiredDeviceCapabilities).
```markup
<key>UIRequiredDeviceCapabilities</key>
<array>
    <string>armv7</string>
</array>
```
> En g√©n√©ral, vous trouverez la capacit√© `armv7`, ce qui signifie que l'application est compil√©e uniquement pour l'ensemble d'instructions armv7, ou s'il s'agit d'une application universelle 32/64 bits.

Par exemple, une application peut d√©pendre enti√®rement de NFC pour fonctionner (par exemple, une application "Lecteur de tag NFC"). Selon la [R√©f√©rence de compatibilit√© des appareils iOS archiv√©e](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html), NFC n'est disponible qu'√† partir de l'iPhone 7 (et iOS 11). Un d√©veloppeur peut vouloir exclure tous les appareils incompatibles en d√©finissant la capacit√© de l'appareil `nfc`.

## Attributions

> Les attributions sont des paires cl√©-valeur qui sont sign√©es dans une application et permettent une authentification au-del√† des facteurs d'ex√©cution, comme l'ID utilisateur UNIX. Comme les attributions sont sign√©es num√©riquement, elles ne peuvent pas √™tre modifi√©es. Les attributions sont largement utilis√©es par les applications et les d√©mons syst√®me pour **effectuer des op√©rations privil√©gi√©es sp√©cifiques qui n√©cessiteraient sinon que le processus s'ex√©cute en tant que root**. Cela r√©duit consid√©rablement le potentiel d'escalade de privil√®ges par une application ou un d√©mon syst√®me compromis.

Par exemple, si vous souhaitez d√©finir la capacit√© "Protection des donn√©es par d√©faut", vous devrez aller dans l'onglet **Capacit√©s** de Xcode et activer **Protection des donn√©es**. Cela est directement √©crit par Xcode dans le fichier `<nomdelapp>.attributions` en tant qu'attribution `com.apple.developer.default-data-protection` avec la valeur par d√©faut `NSFileProtectionComplete`. Dans l'IPA, nous pourrions trouver cela dans le `embedded.mobileprovision` comme suit :
```markup
<key>Entitlements</key>
<dict>
    ...
    <key>com.apple.developer.default-data-protection</key>
    <string>NSFileProtectionComplete</string>
</dict>
```
Pour d'autres fonctionnalit√©s telles que HealthKit, l'utilisateur doit donner son autorisation, il n'est donc pas suffisant d'ajouter les entitlements, des cl√©s et des cha√Ænes sp√©ciales doivent √™tre ajout√©es au fichier `Info.plist` de l'application.

# Bases d'Objective-C et de Swift

**Objective-C** a un **runtime dynamique**, donc lorsqu'un programme Objective-C est ex√©cut√© sur iOS, il appelle des biblioth√®ques dont les **adresses sont r√©solues √† l'ex√©cution** en comparant le nom de la fonction envoy√©e dans le message avec une liste de tous les noms de fonctions disponibles.

Au d√©but, seules les applications cr√©√©es par Apple s'ex√©cutent sur les iPhones, donc elles avaient **acc√®s √† tout** car elles √©taient **de confiance**. Cependant, lorsque Apple a **permis** les **applications tierces**, Apple a simplement supprim√© les fichiers d'en-t√™te des fonctions puissantes pour les "cacher" aux d√©veloppeurs. Cependant, les d√©veloppeurs ont d√©couvert que les fonctions "s√ªres" avaient besoin de quelques-unes de ces fonctions non document√©es et qu'en cr√©ant un **fichier d'en-t√™te personnalis√© avec les noms des fonctions non document√©es, il √©tait possible d'invoquer ces fonctions cach√©es puissantes.** En fait, avant de permettre la publication d'une application, Apple v√©rifie si l'application appelle l'une de ces fonctions interdites.

Ensuite, Swift est apparu. Comme **Swift est li√© statiquement** (il ne r√©sout pas l'adresse des fonctions √† l'ex√©cution comme Objective-C), il est plus facile de v√©rifier les appels qu'un programme Swift va faire via une analyse de code statique.

# Gestion des appareils

√Ä partir de la version iOS 6, il existe une **prise en charge int√©gr√©e de la gestion des appareils** avec des contr√¥les fins qui permettent √† une organisation de contr√¥ler les appareils Apple d'entreprise.\
L'inscription peut √™tre **initi√©e par l'utilisateur installant un agent** afin d'acc√©der aux applications d'entreprise. Dans ce cas, l'appareil appartient g√©n√©ralement √† l'utilisateur.\
Ou l'**entreprise peut indiquer les num√©ros de s√©rie** des appareils achet√©s ou l'identifiant de commande d'achat et sp√©cifier le profil MDM √† installer sur ces appareils. Notez qu'Apple **n'autorise pas l'inscription d'un appareil particulier de cette mani√®re deux fois**. Une fois que le premier profil est supprim√©, l'utilisateur doit donner son consentement pour en installer un autre.

L'utilisateur peut voir les politiques install√©es dans _**R√©glages**_ --> _**G√©n√©ral**_ --> _**Profils et gestion des appareils**_

Comme ces politiques MDM v√©rifient et limitent d'autres applications, elles **fonctionnent avec plus de privil√®ges**.\
Une politique MDM peut **forcer** les **utilisateurs** √† avoir un **code d'acc√®s** d√©fini avec une **complexit√© de mot de passe minimale**.\
Les profils sont li√©s √† l'ID de l'appareil, **sign√©s** et **crypt√©s** par le serveur MDM et **√† l'√©preuve de la manipulation**. Ils **ne peuvent pas** √™tre **supprim√©s** sans **perdre** toutes les **donn√©es d'entreprise**.\
Les profils MDM permettent de **supprimer** toutes les **donn√©es** en cas de X **tentatives** de **mot de passe** **√©chou√©es**. De plus, l'**administrateur** peut **supprimer** √† distance l'iPhone √† tout moment via l'interface MDM.

Les agents MDM **v√©rifieront** √©galement les **possibles jailbreaks de l'appareil**, car c'est un √©tat tr√®s dangereux pour un iPhone.
