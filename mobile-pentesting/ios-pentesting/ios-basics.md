```markdown
# Séparation des privilèges et Sandbox

Les applications auxquelles l'utilisateur peut accéder s'exécutent en tant qu'utilisateur **mobile** tandis que les processus système critiques s'exécutent en tant que **root**.\
Cependant, le sandbox permet un meilleur contrôle sur les actions que les processus et les applications peuvent effectuer.

Par exemple, même si deux processus s'exécutent en tant que même utilisateur (mobile), ils **ne sont pas autorisés à accéder ou modifier les données de l'autre**.

Chaque application est installée sous **`private/var/mobile/Applications/{ID aléatoire}`**\
Une fois installées, les applications ont un accès en lecture limité à certaines zones et fonctions du système (SMS, appel téléphonique...). Si une application souhaite accéder à une **zone protégée,** une **fenêtre pop-up demandant la permission** apparaît.

# Protection des données

Les développeurs d'applications peuvent tirer parti des API de _Protection des données_ d'iOS pour mettre en œuvre un **contrôle d'accès granulaire** pour les données utilisateur stockées dans la mémoire flash. Les API sont construites sur le dessus du **Secure Enclave Processor** (SEP). Le SEP est un coprocesseur qui fournit des **opérations cryptographiques pour la protection des données et la gestion des clés**. Une clé matérielle spécifique à l'appareil, l'**UID de l'appareil** (Identifiant Unique), est **intégrée dans l'enclave sécurisée**, assurant l'intégrité de la protection des données même lorsque le noyau du système d'exploitation est compromis.

Lorsqu'un **fichier est créé** sur le disque, une nouvelle clé **AES 256 bits est générée** avec l'aide du générateur de nombres aléatoires basé sur le matériel de l'enclave sécurisée. Le **contenu du fichier est ensuite chiffré avec la clé générée**. Ensuite, cette **clé est sauvegardée chiffrée avec une clé de classe** ainsi que **l'ID de classe,** avec **les deux données chiffrées par la clé du système,** à l'intérieur des **métadonnées** du fichier.

![](<../../.gitbook/assets/image (473).png>)

Pour déchiffrer le fichier, les **métadonnées sont déchiffrées en utilisant la clé du système**. Ensuite, en **utilisant l'ID de classe** la **clé de classe est récupérée** **pour déchiffrer la clé de fichier et déchiffrer le fichier.**

Les fichiers peuvent être attribués à l'une des **quatre** **classes de protection** **différentes**, qui sont expliquées plus en détail dans le [Guide de sécurité de la plateforme Apple](https://help.apple.com/pdf/security/en_US/apple-platform-security-guide.pdf) :

* **Protection complète (NSFileProtectionComplete)** : Une clé dérivée du code d'accès de l'utilisateur et de l'UID de l'appareil protège cette clé de classe. La clé dérivée est effacée de la mémoire peu après que l'appareil est verrouillé, rendant les données inaccessibles jusqu'à ce que l'utilisateur déverrouille l'appareil.
* **Protégé sauf si ouvert (NSFileProtectionCompleteUnlessOpen)** : Cette classe de protection est similaire à la Protection complète, mais, si le fichier est ouvert lorsque déverrouillé, l'application peut continuer à accéder au fichier même si l'utilisateur verrouille l'appareil. Cette classe de protection est utilisée lorsque, par exemple, une pièce jointe de courrier est téléchargée en arrière-plan.
* **Protégé jusqu'à la première authentification de l'utilisateur (NSFileProtectionCompleteUntilFirstUserAuthentication)** : Le fichier peut être accédé dès que l'utilisateur déverrouille l'appareil pour la première fois après le démarrage. Il peut être accédé même si l'utilisateur verrouille par la suite l'appareil et la clé de classe n'est pas retirée de la mémoire.
* **Aucune protection (NSFileProtectionNone)** : La clé pour cette classe de protection est protégée uniquement avec l'UID. La clé de classe est stockée dans "Effaceable Storage", qui est une région de la mémoire flash sur l'appareil iOS qui permet le stockage de petites quantités de données. Cette classe de protection existe pour un effacement à distance rapide (suppression immédiate de la clé de classe, ce qui rend les données inaccessibles).

Toutes les clés de classe à l'exception de `NSFileProtectionNone` sont chiffrées avec une clé dérivée de l'UID de l'appareil et du code d'accès de l'utilisateur. En conséquence, le déchiffrement ne peut se produire que sur l'appareil lui-même et nécessite le bon code d'accès.

Depuis iOS 7, la classe de protection des données par défaut est "Protégé jusqu'à la première authentification de l'utilisateur".

[**FileDP**](https://github.com/abjurato/FileDp-Source) est un programme que vous pouvez télécharger et utiliser à l'intérieur de l'iPhone pour **inspecter la classe de protection des données** de chaque fichier.

## Le Keychain

Un keychain est un **conteneur chiffré** où chaque application peut **stocker** des morceaux d'**informations sensibles** et seule la même application (ou les applications autorisées) peut récupérer le contenu.\
iOS **génère son propre mot de passe pour le keychain** et **stocke** une version **chiffrée** de cette clé dans l'appareil. Ce mot de passe est chiffré avec AES en utilisant une clé AES créée par une fonction **PBKDF2** du **code d'accès de l'utilisateur + sel** (le **UID de l'appareil 256 bits** **uniquement accessible** au chipset de l'enclave sécurisée sur l'appareil). En raison de l'utilisation de cet UID de l'appareil comme sel, un appareil ne pourra pas déchiffrer le keychain d'un autre appareil même en connaissant le code d'accès des utilisateurs.

L'accès au Keychain est géré par le daemon **`securityd`**, qui accorde l'accès selon les droits `Keychain-access-groups`, `application-identifier` et `application-group` de l'application.

L'[API Keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html) comprend les opérations principales suivantes :

* `SecItemAdd`
* `SecItemUpdate`
* `SecItemCopyMatching`
* `SecItemDelete`

Les seules façons d'essayer de BF ce mot de passe est de dumper la clé chiffrée et de BF le code d'accès + sel (la fonction **pbkdf2** utilise **au moins 10000 itérations**). Ou d'essayer de **BF à l'intérieur de l'appareil** pour éviter de BF le sel, cependant, l'enclave sécurisée assure qu'il y a au moins un **délai de 5 secondes entre 2 tentatives de mot de passe échouées**.

Vous pouvez configurer **la protection des données pour les éléments Keychain** en définissant la clé `kSecAttrAccessible` dans l'appel à `SecItemAdd` ou `SecItemUpdate`. Les valeurs d'accessibilité configurables suivantes pour kSecAttrAccessible sont les classes de protection des données Keychain :

* **`kSecAttrAccessibleAlways`** : Les données de l'élément Keychain peuvent **toujours être accessibles**, que l'appareil soit verrouillé ou non.
* **`kSecAttrAccessibleAlwaysThisDeviceOnly`** : Les données de l'élément Keychain peuvent **toujours être accessibles**, que l'appareil soit verrouillé ou non. Les données **ne seront pas incluses dans une sauvegarde iCloud** ou locale.
* **`kSecAttrAccessibleAfterFirstUnlock`** : Les données de l'élément Keychain ne peuvent pas être accessibles après un redémarrage jusqu'à ce que **l'appareil ait été déverrouillé une fois** par l'utilisateur.
* **`kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`** : Les données de l'élément Keychain ne peuvent pas être accessibles après un redémarrage jusqu'à ce que **l'appareil ait été déverrouillé une fois** par l'utilisateur. Les éléments avec cet attribut ne **migrent pas vers un nouvel appareil**. Ainsi, après la restauration à partir d'une sauvegarde d'un autre appareil, ces éléments ne seront pas présents.
* **`kSecAttrAccessibleWhenUnlocked`** : Les données de l'élément Keychain peuvent être accessibles **uniquement lorsque l'appareil est déverrouillé** par l'utilisateur.
* **`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`** : Les données de l'élément Keychain peuvent être accessibles **uniquement lorsque l'appareil est déverrouillé** par l'utilisateur. Les données **ne seront pas incluses dans une sauvegarde iCloud ou locale**.
* **`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`** : Les données du Keychain peuvent être accessibles **uniquement lorsque l'appareil est déverrouillé**. Cette classe de protection est **disponible uniquement si un code d'accès est défini** sur l'appareil. Les données **ne seront pas incluses dans une sauvegarde iCloud ou locale**.

**`AccessControlFlags`** définissent les mécanismes avec lesquels les utilisateurs peuvent authentifier la clé (`SecAccessControlCreateFlags`) :

* **`kSecAccessControlDevicePasscode`** : Accéder à l'élément via un code d'accès.
* **`kSecAccessControlBiometryAny`** : Accéder à l'élément via l'une des empreintes digitales enregistrées sur Touch ID. Ajouter ou supprimer une empreinte digitale n'invalidera pas l'élément.
* **`kSecAccessControlBiometryCurrentSet`** : Accéder à l'élément via l'une des empreintes digitales enregistrées sur Touch ID. Ajouter ou supprimer une empreinte digitale _invalidera_ l'élément.
* **`kSecAccessControlUserPresence`** : Accéder à l'élément via l'une des empreintes digitales enregistrées (en utilisant Touch ID) ou par défaut au code d'accès.

Veuillez noter que les clés sécurisées par Touch ID (via `kSecAccessControlBiometryAny` ou `kSecAccessControlBiometryCurrentSet`) sont protégées par l'Enclave sécurisée : le Keychain détient un jeton seulement, pas la clé réelle. La clé réside dans l'Enclave sécurisée.

L'iPhone utilise le **code d'accès introduit par l'utilisateur déverrouillant l'appareil pour déchiffrer les secrets dans le keychain**.

iOS utilise le _**AppIdentifierPrefix**_ (ID de l'équipe) et le _**BundleIdentifier**_ (fourni par le développeur) pour appliquer un **contrôle d'accès sur les éléments du keychain**. Ainsi, la même équipe **peut** **configurer** **2 applications pour partager des éléments du keychain**.

Lorsqu'un processus de sauvegarde est initié, les **données du keychain sauvegardées restent chiffrées et le mot de passe du keychain n'est pas inclus dans la sauvegarde**.

{% hint style="warning" %}
**Sur un appareil jailbreaké, le keychain n'est pas protégé.**
{% endhint %}

### **Persistance des données Keychain**

Sur iOS, lorsqu'une application est désinstallée, les données Keychain utilisées par l'application sont conservées par l'appareil, contrairement aux données stockées par le sandbox de l'application qui sont effacées. Dans l'éventualité où un **utilisateur vend son appareil sans effectuer une réinitialisation d'usine, l'acheteur de l'appareil pourrait être en mesure d'accéder aux comptes et données d'application de l'utilisateur précédent en réinstallant** les mêmes applications utilisées par l'utilisateur précédent. Cela ne nécessiterait aucune compétence technique pour être réalisé.

Il n'existe pas d'API iOS que les développeurs peuvent utiliser pour forcer l'effacement des données lorsqu'une application est désinstallée. Au lieu de cela, les développeurs devraient prendre les mesures suivantes pour empêcher les données Keychain de persister entre les installations d'applications :

* Lorsqu'une application est lancée pour la première fois après l'installation, effacer toutes les données Keychain associées à l'application. Cela empêchera un deuxième utilisateur de l'appareil d'accéder accidentellement aux comptes de l'utilisateur précédent. L'exemple Swift suivant est une démonstration basique de cette procédure d'effacement :
```
```objectivec
let userDefaults = UserDefaults.standard

if userDefaults.bool(forKey: "hasRunBefore") == false {
// Remove Keychain items here

// Update the flag indicator
userDefaults.set(true, forKey: "hasRunBefore")
userDefaults.synchronize() // Forces the app to update UserDefaults
}
```
* Lors du développement de la fonctionnalité de déconnexion pour une application iOS, assurez-vous que les données du Keychain sont effacées lors de la déconnexion du compte. Cela permettra aux utilisateurs d'effacer leurs comptes avant de désinstaller une application.

# **Capacités de l'application**

**Chaque application possède un répertoire d'accueil unique et est en mode sandbox**, de sorte qu'elle ne peut pas accéder aux ressources protégées du système ou aux fichiers stockés par le système ou par d'autres applications. Ces restrictions sont mises en œuvre via des politiques de sandbox (également connues sous le nom de _profils_), qui sont appliquées par le [Trusted BSD (MAC) Mandatory Access Control Framework](http://www.trustedbsd.org/mac.html) via une extension du noyau.

Certaines [**capacités/permissions**](https://help.apple.com/developer-account/#/dev21218dfd6) peuvent être configurées par les développeurs de l'application (par exemple, la protection des données ou le partage de Keychain) et prendront effet directement après l'installation. Cependant, pour d'autres, **l'utilisateur sera explicitement invité la première fois que l'application tente d'accéder à une ressource protégée**.

Les [_Purpose strings_](https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy/accessing_protected_resources?language=objc#3037322) ou _chaînes de description d'utilisation_ sont des textes personnalisés qui sont présentés aux utilisateurs dans l'alerte de demande de permission du système lorsqu'une autorisation d'accès à des données ou ressources protégées est demandée.

![](https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQw8W2q7BB5-il7r%2Fpermission_request_alert.png?alt=media)

Si vous disposez du code source original, vous pouvez vérifier les permissions incluses dans le fichier `Info.plist` :

* Ouvrez le projet avec Xcode.
* Trouvez et ouvrez le fichier `Info.plist` dans l'éditeur par défaut et recherchez les clés commençant par `"Privacy -"`.

Vous pouvez changer la vue pour afficher les valeurs brutes en cliquant avec le bouton droit et en sélectionnant "Show Raw Keys/Values" (ainsi par exemple `"Privacy - Location When In Use Usage Description"` se transformera en `NSLocationWhenInUseUsageDescription`).

Si vous disposez seulement de l'IPA :

* Décompressez l'IPA.
* Le `Info.plist` se trouve dans `Payload/<appname>.app/Info.plist`.
* Convertissez-le si nécessaire (par exemple, `plutil -convert xml1 Info.plist`) comme expliqué dans le chapitre "iOS Basic Security Testing", section "The Info.plist File".
*   Inspectez toutes les clés _purpose strings Info.plist_, se terminant généralement par `UsageDescription` :

```markup
<plist version="1.0">
<dict>
<key>NSLocationWhenInUseUsageDescription</key>
<string>Votre position est utilisée pour fournir des indications de navigation vers votre destination.</string>
```

## Capacités de l'appareil

Les capacités de l'appareil sont utilisées par l'App Store pour s'assurer que seuls les appareils compatibles sont répertoriés et donc autorisés à télécharger l'application. Elles sont spécifiées dans le fichier `Info.plist` de l'application sous la clé [`UIRequiredDeviceCapabilities`](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/plist/info/UIRequiredDeviceCapabilities).
```markup
<key>UIRequiredDeviceCapabilities</key>
<array>
<string>armv7</string>
</array>
```
> Typiquement, vous trouverez la capacité `armv7`, signifiant que l'application est compilée uniquement pour le jeu d'instructions armv7, ou si c'est une application universelle 32/64 bits.

Par exemple, une application pourrait être entièrement dépendante de la NFC pour fonctionner (par exemple, une application ["NFC Tag Reader"](https://itunes.apple.com/us/app/nfc-taginfo-by-nxp/id1246143596)). Selon la [référence archivée de compatibilité des appareils iOS](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html), la NFC est disponible seulement à partir de l'iPhone 7 (et iOS 11). Un développeur pourrait vouloir exclure tous les appareils incompatibles en définissant la capacité de l'appareil `nfc`.

## Entitlements

> Les Entitlements sont des paires clé-valeur qui sont signées dans une application et permettent une authentification au-delà des facteurs d'exécution, comme l'ID utilisateur UNIX. Comme les Entitlements sont numériquement signés, ils ne peuvent pas être modifiés. Les Entitlements sont largement utilisés par les applications système et les daemons pour **effectuer des opérations privilégiées spécifiques qui nécessiteraient autrement que le processus s'exécute en tant que root**. Cela réduit considérablement le potentiel d'escalade de privilèges par une application système ou un daemon compromis.

Par exemple, si vous souhaitez définir la capacité "Protection des données par défaut", vous devrez aller dans l'onglet **Capabilities** dans Xcode et activer la **Protection des données**. Cela est directement écrit par Xcode dans le fichier `<appname>.entitlements` comme l'entitlement `com.apple.developer.default-data-protection` avec la valeur par défaut `NSFileProtectionComplete`. Dans l'IPA, nous pourrions trouver cela dans le `embedded.mobileprovision` comme :
```markup
<key>Entitlements</key>
<dict>
...
<key>com.apple.developer.default-data-protection</key>
<string>NSFileProtectionComplete</string>
</dict>
```
Pour d'autres capacités telles que HealthKit, l'utilisateur doit être sollicité pour obtenir la permission, donc il ne suffit pas d'ajouter les droits, des clés spéciales et des chaînes doivent être ajoutées au fichier `Info.plist` de l'application.

# Bases de Objective-C et Swift

**Objective-C** possède un **runtime dynamique**, donc lorsqu'un programme Objective-C est exécuté sur iOS, il appelle des bibliothèques dont les **adresses sont résolues au runtime** en comparant le nom de la fonction envoyée dans le message contre une liste de tous les noms de fonction disponibles.

Au début, seules les applications créées par Apple fonctionnaient sur les iPhones, elles avaient donc **accès à tout** car elles étaient **de confiance**. Cependant, lorsque Apple a **autorisé les applications tierces**, Apple a simplement retiré les fichiers d'en-tête des fonctions puissantes pour les "cacher" aux développeurs. Cependant, les développeurs ont découvert que les fonctions "sûres" nécessitaient certaines de ces fonctions non documentées et en créant simplement un **fichier d'en-tête personnalisé avec les noms des fonctions non documentées, il était possible d'invoquer ces puissantes fonctions cachées.** En réalité, Apple, avant d'autoriser la publication d'une application, vérifie si l'application appelle l'une de ces fonctions interdites.

Puis, Swift est apparu. Comme **Swift est lié statiquement** (il ne résout pas l'adresse des fonctions au runtime comme Objective-C), il est plus facile de vérifier les appels qu'un programme Swift va effectuer via une analyse de code statique.

# Gestion des appareils

À partir de la version 6 d'iOS, il existe un **support intégré pour la gestion des appareils** avec des contrôles précis qui permettent à une organisation de contrôler les appareils Apple d'entreprise.\
L'inscription peut être **initiée par l'utilisateur en installant un agent** afin d'accéder aux applications d'entreprise. Dans ce cas, l'appareil appartient généralement à l'utilisateur.\
Ou l'**entreprise peut indiquer les numéros de série** des appareils achetés ou l'ID de commande d'achat et spécifier le profil MDM à installer sur ces appareils. Notez qu'Apple **ne permet pas d'inscrire un appareil particulier de cette manière deux fois**. Une fois que le premier profil est supprimé, l'utilisateur doit donner son consentement pour en installer un autre.

L'utilisateur peut voir les politiques installées dans _**Réglages**_ --> _**Général**_ --> _**Gestion des profils et des appareils**_

Comme ces politiques MDM vérifient et limitent d'autres applications, elles **s'exécutent avec plus de privilèges**.\
Une politique MDM peut **obliger** les **utilisateurs** à avoir un **code d'accès** défini avec une **complexité** de mot de passe **minimale**.\
Les profils sont liés à l'ID de l'appareil, **signés** et **chiffrés** par le serveur MDM et **à l'épreuve des manipulations**. Ils **ne peuvent pas** être **retirés** sans **perdre** toutes les **données d'entreprise**.\
Les profils MDM permettent d'**effacer** toutes les **données** s'il y a X **tentatives de mot de passe échouées**. De plus, l'**administrateur** peut **effacer à distance** l'iPhone à tout moment via l'interface MDM.

Les agents MDM **vérifient** également les **éventuels jailbreaks de l'appareil**, car c'est un état très dangereux pour un iPhone.


<details>

<summary><strong>Apprenez le hacking AWS de zéro à héros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annoncée dans HackTricks** ou **télécharger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* Découvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** 💬 [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux dépôts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
