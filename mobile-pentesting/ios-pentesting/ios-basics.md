<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

# Separazione dei privilegi e sandbox

In iOS, esiste una distinzione di privilegi tra le applicazioni accessibili dall'utente e i processi principali del sistema. Le applicazioni vengono eseguite con l'identit√† utente **`mobile`**, mentre i processi principali del sistema operano come **`root`**. Questa separazione √® potenziata da un meccanismo di sandbox, che impone rigorose limitazioni sulle azioni che le applicazioni possono intraprendere. Ad esempio, anche se le applicazioni condividono la stessa identit√† utente, √® loro vietato accedere o modificare i dati delle altre applicazioni.

Le applicazioni vengono installate in una directory specifica (`private/var/mobile/Applications/{ID casuale}`) e hanno un accesso in lettura limitato a determinate aree e funzionalit√† di sistema, come gli SMS e le chiamate telefoniche. L'accesso alle aree protette attiva una richiesta di autorizzazione da parte dell'utente.

# Protezione dei dati

iOS offre agli sviluppatori le **API di protezione dei dati**, costruite sopra il Secure Enclave Processor (SEP) - un coprocessore dedicato alle operazioni crittografiche e alla gestione delle chiavi. Il SEP garantisce l'integrit√† della protezione dei dati tramite una chiave unica specifica del dispositivo, l'UID del dispositivo, incorporata al suo interno.

Alla creazione di un file, viene generata una chiave di crittografia AES a 256 bit univoca, che cifra il contenuto del file. Questa chiave di crittografia unica, insieme a un ID di classe, viene quindi crittografata utilizzando una chiave di classe e memorizzata all'interno dei metadati del file. La decrittazione di un file comporta l'utilizzo della chiave di sistema per accedere ai metadati, recuperare la chiave di classe con l'ID di classe e quindi decrittare la chiave di crittografia unica del file.

iOS definisce **quattro classi di protezione** per la sicurezza dei dati, che determinano quando e come i dati possono essere accessibili:

- **Protezione completa (NSFileProtectionComplete)**: i dati sono inaccessibili fino a quando il dispositivo non viene sbloccato utilizzando il codice di accesso dell'utente.
- **Protetto a meno che aperto (NSFileProtectionCompleteUnlessOpen)**: consente l'accesso ai file anche dopo il blocco del dispositivo, a condizione che il file sia stato aperto quando il dispositivo era sbloccato.
- **Protetto fino alla prima autenticazione dell'utente (NSFileProtectionCompleteUntilFirstUserAuthentication)**: i dati sono accessibili dopo la prima sblocco dell'utente dopo l'avvio, rimanendo accessibili anche se il dispositivo viene nuovamente bloccato.
- **Nessuna protezione (NSFileProtectionNone)**: i dati sono protetti solo dall'UID del dispositivo, facilitando la cancellazione rapida dei dati remoti.

La crittografia di tutte le classi, tranne `NSFileProtectionNone`, prevede una chiave derivata sia dall'UID del dispositivo che dal codice di accesso dell'utente, garantendo che la decrittazione sia possibile solo sul dispositivo con il codice di accesso corretto. A partire da iOS 7, la classe di protezione predefinita √® "Protetto fino alla prima autenticazione dell'utente".

Gli sviluppatori possono utilizzare [**FileDP**](https://github.com/abjurato/FileDp-Source), uno strumento per ispezionare la classe di protezione dei dati dei file su un iPhone.
```python
# Example code to use FileDP for checking file protection class
# Note: Ensure your device is jailbroken and has Python installed to use FileDP.
# Installation and usage of FileDP:
git clone https://github.com/abjurato/FileDp-Source
cd FileDp-Source
python filedp.py /path/to/check
```
## **Il Portachiavi**

In iOS, un **Portachiavi** funge da **contenitore crittografato sicuro** per memorizzare **informazioni sensibili**, accessibili solo dall'applicazione che le ha memorizzate o da quelle esplicitamente autorizzate. Questa crittografia √® rinforzata da una **password univoca generata da iOS**, che a sua volta √® crittografata con **AES**. Questo processo di crittografia sfrutta una funzione **PBKDF2**, che combina il codice di accesso dell'utente con un salt derivato dall'**UID** del dispositivo, un componente a cui solo il **chipset del secure enclave** pu√≤ accedere. Di conseguenza, anche se il codice di accesso dell'utente √® noto, i contenuti del Portachiavi rimangono inaccessibili su qualsiasi dispositivo diverso da quello in cui sono stati originariamente crittografati.

La **gestione e l'accesso** ai dati del Portachiavi sono gestiti dal demone **`securityd`**, in base a specifici privilegi dell'app come `Keychain-access-groups` e `application-identifier`.

### **Operazioni API del Portachiavi**

L'API del Portachiavi, descritta nella [documentazione dei servizi del Portachiavi di Apple](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html), fornisce funzioni essenziali per la gestione della memorizzazione sicura:

- **`SecItemAdd`**: Aggiunge un nuovo elemento al Portachiavi.
- **`SecItemUpdate`**: Aggiorna un elemento esistente nel Portachiavi.
- **`SecItemCopyMatching`**: Recupera un elemento dal Portachiavi.
- **`SecItemDelete`**: Rimuove un elemento dal Portachiavi.

Forzare la password del Portachiavi comporta attaccare direttamente la chiave crittografata o tentare di indovinare il codice di accesso sul dispositivo stesso, ostacolato significativamente dal secure enclave che impone un ritardo tra i tentativi falliti.

### **Configurazione della protezione dei dati degli elementi del Portachiavi**

I livelli di protezione dei dati per gli elementi del Portachiavi vengono impostati utilizzando l'attributo `kSecAttrAccessible` durante la creazione o l'aggiornamento dell'elemento. Questi livelli, [come specificato da Apple](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_attribute_keys_and_values#1679100), determinano quando e come gli elementi del Portachiavi sono accessibili:

- **`kSecAttrAccessibleAlways`**: Accessibile in qualsiasi momento, indipendentemente dallo stato di blocco del dispositivo.
- **`kSecAttrAccessibleAlwaysThisDeviceOnly`**: Sempre accessibile, ma non incluso nei backup.
- **`kSecAttrAccessibleAfterFirstUnlock`**: Accessibile dopo il primo sblocco successivo al riavvio.
- **`kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`**: Come sopra, ma non trasferibile a nuovi dispositivi.
- **`kSecAttrAccessibleWhenUnlocked`**: Accessibile solo quando il dispositivo √® sbloccato.
- **`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`**: Accessibile quando sbloccato, non incluso nei backup.
- **`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`**: Richiede il codice di accesso del dispositivo, non incluso nei backup.

**`AccessControlFlags`** raffinano ulteriormente i metodi di accesso, consentendo l'autenticazione biometrica o l'uso del codice di accesso.

### **Avviso per i dispositivi jailbroken**

{% hint style="warning" %}
Su **dispositivi jailbroken**, le protezioni del Portachiavi sono compromesse, rappresentando un rischio significativo per la sicurezza.
{% endhint %}

### **Persistenza dei dati del Portachiavi**

A differenza dei dati specifici dell'app eliminati durante la disinstallazione dell'app, i dati del Portachiavi persistono sul dispositivo. Questa caratteristica potrebbe consentire ai nuovi proprietari di un dispositivo di seconda mano di accedere ai dati dell'app del precedente proprietario semplicemente reinstallando le app. Si consiglia agli sviluppatori di eliminare proattivamente i dati del Portachiavi durante l'installazione dell'app o durante il logout per mitigare questo rischio. Ecco un esempio di codice Swift che mostra come eliminare i dati del Portachiavi al primo avvio dell'app:
```swift
let userDefaults = UserDefaults.standard

if userDefaults.bool(forKey: "hasRunBefore") == false {
// Remove Keychain items here

// Update the flag indicator
userDefaults.set(true, forKey: "hasRunBefore")
userDefaults.synchronize() // Forces the app to update UserDefaults
}
```
# **Funzionalit√† dell'app**

Nel campo dello sviluppo delle app, il **sandboxing** svolge un ruolo cruciale nel migliorare la sicurezza. Questo processo garantisce che ogni app operi all'interno della propria directory home unica, impedendole cos√¨ di accedere ai file di sistema o ai dati appartenenti ad altre app. L'applicazione di queste restrizioni avviene attraverso le politiche di sandbox, che fanno parte del **Trusted BSD (MAC) Mandatory Access Control Framework**.

Gli sviluppatori hanno la possibilit√† di configurare determinate **funzionalit√† o autorizzazioni** per le loro app, come la **protezione dei dati** o la **condivisione del portachiavi**. Queste autorizzazioni vengono applicate immediatamente dopo l'installazione dell'app. Tuttavia, per accedere a determinate risorse protette, l'app deve ottenere il consenso esplicito dell'utente al momento del primo tentativo. Ci√≤ viene realizzato attraverso l'uso di _stringhe di scopo_ o _stringhe di descrizione dell'uso_, che vengono presentate agli utenti in un avviso di richiesta di autorizzazione.

Per coloro che hanno accesso al codice sorgente, la verifica delle autorizzazioni incluse nel file `Info.plist` pu√≤ essere effettuata seguendo questi passaggi:

1. Aprire il progetto in Xcode.
2. Trovare e aprire il file `Info.plist`.
3. Cercare le chiavi con prefisso `"Privacy -"`, con l'opzione di visualizzare chiavi/valori grezzi per maggiore chiarezza.

Quando si lavora con un file IPA, √® possibile seguire i seguenti passaggi:

1. Decomprimere il file IPA.
2. Trovare il file `Info.plist` all'interno di `Payload/<nomeapp>.app/`.
3. Convertire il file in formato XML se necessario, per una pi√π facile ispezione.

Ad esempio, le stringhe di scopo nel file `Info.plist` potrebbero apparire cos√¨:
```xml
<plist version="1.0">
<dict>
<key>NSLocationWhenInUseUsageDescription</key>
<string>Your location is used to provide turn-by-turn directions to your destination.</string>
```
## Capacit√† del dispositivo
Il file `Info.plist` di un'app specifica le **capacit√† del dispositivo** che aiutano l'App Store a filtrare le app in base alla compatibilit√† del dispositivo. Queste sono definite sotto la chiave **`UIRequiredDeviceCapabilities`**. Ad esempio:
```xml
<key>UIRequiredDeviceCapabilities</key>
<array>
<string>armv7</string>
</array>
```
Questo esempio indica che l'app √® compatibile con l'insieme di istruzioni armv7. Gli sviluppatori possono anche specificare funzionalit√† come nfc per garantire che la loro app sia disponibile solo su dispositivi che supportano NFC.

## Entitlements

**Entitlements** sono un altro aspetto critico dello sviluppo di app iOS, che fungono da coppie chiave-valore che concedono alle app il permesso di eseguire determinate operazioni al di l√† dei controlli in fase di esecuzione. Ad esempio, abilitare **Data Protection** in un'app comporta l'aggiunta di un entitlement specifico nel progetto Xcode, che viene quindi riflessa nel file degli entitlements dell'app o nel file di provisioning mobile incorporato per gli IPA.


# Riferimenti
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://github.com/OWASP/owasp-mastg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/OWASP/owasp-mastg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-PLATFORM/MASTG-TEST-0069/](https://mas.owasp.org/MASTG/tests/ios/MASVS-PLATFORM/MASTG-TEST-0069/)
* [https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/](https://mas.owasp.org/MASTG/iOS/0x06h-Testing-Platform-Interaction/)



<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
