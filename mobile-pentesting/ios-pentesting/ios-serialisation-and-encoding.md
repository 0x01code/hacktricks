```markdown
### NSCodingとNSSecureCoding

iOSには、Objective-Cまたは`NSObject`のオブジェクト**シリアライゼーション**用の2つのプロトコルがあります：**`NSCoding`**と**`NSSecureCoding`**です。**クラスがこれらのプロトコルのいずれかに準拠している場合**、データは**`NSData`**にシリアライズされます：**バイトバッファー**のラッパーです。Swiftの`Data`は`NSData`またはその可変対応の`NSMutableData`と同じです。`NSCoding`プロトコルは、そのインスタンス変数をエンコード/デコードするために実装されなければならない2つのメソッドを宣言します。**`NSCoding`を使用するクラスは`NSObject`を実装するか、@objcクラスとして注釈を付ける必要があります**。`NSCoding`プロトコルは、以下に示すようにエンコードとinitを実装することを要求します。
```
```swift
class CustomPoint: NSObject, NSCoding {

//required by NSCoding:
func encode(with aCoder: NSCoder) {
aCoder.encode(x, forKey: "x")
aCoder.encode(name, forKey: "name")
}

var x: Double = 0.0
var name: String = ""

init(x: Double, name: String) {
self.x = x
self.name = name
}

// required by NSCoding: initialize members using a decoder.
required convenience init?(coder aDecoder: NSCoder) {
guard let name = aDecoder.decodeObject(forKey: "name") as? String
else {return nil}
self.init(x:aDecoder.decodeDouble(forKey:"x"),
name:name)
}

//getters/setters/etc.
}
```
`NSCoding`の問題点は、クラスタイプを評価する前に、オブジェクトが**構築されて挿入されてしまうことが多い**ということです。これにより、攻撃者が**様々なデータを容易に注入することができます**。そのため、**`NSSecureCoding`** プロトコルが導入されました。[`NSSecureCoding`](https://developer.apple.com/documentation/foundation/NSSecureCoding)に準拠する場合、以下を含める必要があります：
```swift
static var supportsSecureCoding: Bool {
return true
}
```
```markdown
`init(coder:)`がクラスの一部である場合。次に、オブジェクトをデコードする際には、例えば以下のようなチェックを行うべきです：
```
```swift
let obj = decoder.decodeObject(of:MyClass.self, forKey: "myKey")
```
`NSSecureCoding`の遵守は、インスタンス化されるオブジェクトが期待されたものであることを保証します。しかし、データに対して**追加の整合性チェックは行われず**、データは暗号化されていません。したがって、秘密データには追加の**暗号化**が必要であり、整合性を保護する必要があるデータには追加のHMACが必要です。

### NSKeyedArchiverを使用したオブジェクトのアーカイブ

`NSKeyedArchiver`は`NSCoder`の具象サブクラスであり、オブジェクトをエンコードしてファイルに保存する方法を提供します。`NSKeyedUnarchiver`はデータをデコードし、元のデータを再作成します。`NSCoding`セクションの例を取り上げ、今度はそれらをアーカイブしてアンアーカイブしてみましょう：
```swift
// archiving:
NSKeyedArchiver.archiveRootObject(customPoint, toFile: "/path/to/archive")

// unarchiving:
guard let customPoint = NSKeyedUnarchiver.unarchiveObjectWithFile("/path/to/archive") as?
CustomPoint else { return nil }
```
情報をプライマリplistの`NSUserDefaults`にも保存できます：
```swift
// archiving:
let data = NSKeyedArchiver.archivedDataWithRootObject(customPoint)
NSUserDefaults.standardUserDefaults().setObject(data, forKey: "customPoint")

// unarchiving:
if let data = NSUserDefaults.standardUserDefaults().objectForKey("customPoint") as? NSData {
let customPoint = NSKeyedUnarchiver.unarchiveObjectWithData(data)
}
```
### Codable

これは`Decodable`と`Encodable`プロトコルの組み合わせです。`String`、`Int`、`Double`、`Date`、`Data`、`URL`は本質的に`Codable`です：つまり、追加の作業なしで簡単にエンコードおよびデコードできるという意味です。次の例を見てみましょう：
```swift
struct CustomPointStruct:Codable {
var x: Double
var name: String
}
```
例の`CustomPointStruct`の継承リストに`Codable`を追加することで、`init(from:)`と`encode(to:)`メソッドが自動的にサポートされます。`Codable`の動作の詳細については、[Apple Developer Documentation](https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types)を確認してください。

また、`NSUserDefaults`のプライマリプロパティリストにデータを保存するためにcodableを使用することもできます：
```swift
struct CustomPointStruct: Codable {
var point: Double
var name: String
}

var points: [CustomPointStruct] = [
CustomPointStruct(point: 1, name: "test"),
CustomPointStruct(point: 2, name: "test"),
CustomPointStruct(point: 3, name: "test"),
]

UserDefaults.standard.set(try? PropertyListEncoder().encode(points), forKey: "points")
if let data = UserDefaults.standard.value(forKey: "points") as? Data {
let points2 = try? PropertyListDecoder().decode([CustomPointStruct].self, from: data)
}
```
### JSON エンコーディング

JSON形式でデータをエンコードするための多くのサードパーティライブラリがあります（[こちら](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#json-and-codable)で説明されています）。しかし、Appleは`Codable`を`JSONEncoder`および`JSONDecoder`と組み合わせることで、直接JSONエンコーディング/デコーディングのサポートを提供しています：
```swift
struct CustomPointStruct: Codable {
var point: Double
var name: String
}

let encoder = JSONEncoder()
encoder.outputFormatting = .prettyPrinted

let test = CustomPointStruct(point: 10, name: "test")
let data = try encoder.encode(test)
let stringData = String(data: data, encoding: .utf8)

// stringData = Optional ({
// "point" : 10,
// "name" : "test"
// })
```
### XML

XMLエンコーディングには複数の方法があります。JSONパースと同様に、様々なサードパーティライブラリが存在します。例えば: [Fuzi](https://github.com/cezheng/Fuzi), [Ono](https://github.com/mattt/Ono), [AEXML](https://github.com/tadija/AEXML), [RaptureXML](https://github.com/ZaBlanc/RaptureXML), [SwiftyXMLParser](https://github.com/yahoojapan/SwiftyXMLParser), [SWXMLHash](https://github.com/drmohundro/SWXMLHash)

これらは速度、メモリ使用量、オブジェクトの永続性などの点で異なり、より重要なのはXML外部エンティティの扱い方が異なることです。例として[XXE in the Apple iOS Office viewer](https://nvd.nist.gov/vuln/detail/CVE-2015-3784)を参照してください。したがって、可能であれば外部エンティティの解析を無効にすることが重要です。詳細については、[OWASP XXE prevention cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/XML\_External\_Entity\_Prevention\_Cheat\_Sheet.html)を参照してください。ライブラリの他に、Appleの[`XMLParser`クラス](https://developer.apple.com/documentation/foundation/xmlparser)を利用することもできます。

サードパーティのライブラリを使用せず、Appleの`XMLParser`を使用する場合は、`shouldResolveExternalEntities`が`false`を返すようにしてください。

{% hint style="danger" %}
これらのデータのシリアライズ/エンコーディング方法は**ファイルシステムにデータを保存するために使用される**ことがあります。そのようなシナリオでは、保存されたデータに**機密情報**が含まれていないかを確認してください。\
さらに、場合によっては、シリアライズされたデータを悪用して（MitMを介してキャプチャするか、ファイルシステム内で変更することによって）、任意のデータの逆シリアライズを行い、**アプリケーションに予期しない動作をさせる**可能性があります（[Deserialization page](../../pentesting-web/deserialization/)を参照）。これらの場合、シリアライズされたデータを暗号化して署名して送信/保存することを推奨します。
{% endhint %}

## 参考文献

{% embed url="https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-object-persistence-mstg-platform-8" %}



<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)で<strong>AWSハッキングをゼロからヒーローまで学ぶ</strong></strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksに広告を掲載したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手してください。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見してください。私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションです。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加するか**、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローしてください。**
* [**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>
