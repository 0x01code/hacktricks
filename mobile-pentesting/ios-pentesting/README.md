# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik en **outomatiseer werkafloei** te bou wat aangedryf word deur die w√™reld se **mees gevorderde** gemeenskapsinstrumente.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Leer AWS hak van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## iOS Basiese Beginsels

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Toetsomgewing

Op hierdie bladsy kan jy inligting vind oor die **iOS-simuleerder**, **emulators** en **jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Inisie√´le Analise

### Basiese iOS Toetsoperasies

Tydens die toets word **veral operasies voorgestel** (koppel aan die toestel, lees/skryf/laai/af laai l√™ers, gebruik van sekere gereedskap...). Daarom, as jy nie weet hoe om enige van hierdie aksies uit te voer nie, **begin deur die bladsy te lees**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Vir die volgende stappe moet die program in die toestel ge√Ønstalleer wees en moet jy reeds die **IPA-l√™er** van die aansoek verkry het.\
Lees die [Basiese iOS Toetsoperasies](basic-ios-testing-operations.md) bladsy om te leer hoe om dit te doen.
{% endhint %}

### Basiese Statisiese Analise

Dit word aanbeveel om die instrument [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) te gebruik om 'n outomatiese Statisiese Analise op die IPA-l√™er uit te voer.

Identifikasie van **beskermings wat teenwoordig is in die bin√™re l√™er**:

*   **PIE (Position Independent Executable)**: Wanneer dit geaktiveer is, laai die aansoek in 'n ewekansige geheue-adres elke keer as dit begin, wat dit moeiliker maak om sy aanvanklike geheue-adres te voorspel.

```bash
otool -hv <app-bin√™re> | grep PIE   # Dit behoort die PIE-vlag in te sluit
```
*   **Stapel Kanaries**: Om die integriteit van die stapel te valideer, word 'n 'kanarie'-waarde op die stapel geplaas voordat 'n funksie geroep word en word weer gevalideer sodra die funksie eindig.

```bash
otool -I -v <app-bin√™re> | grep stack_chk   # Dit behoort die simbole: stack_chk_guard en stack_chk_fail in te sluit
```
*   **ARC (Automatic Reference Counting)**: Om algemene geheuekorruptie-foute te voorkom

```bash
otool -I -v <app-bin√™re> | grep objc_release   # Dit behoort die _objc_release-simbool in te sluit
```
*   **Versleutelde Bin√™re**: Die bin√™re l√™er behoort versleutel te wees

```bash
otool -arch all -Vl <app-bin√™re> | grep -A5 LC_ENCRYPT   # Die cryptid behoort 1 te wees
```

**Identifikasie van Sensitiewe/Onveilige Funksies**

*   **Swak Hashing Algoritmes**

```bash
# Op die iOS-toestel
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Op Linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Onveilige Willekeurige Funksies**

```bash
# Op die iOS-toestel
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Op Linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Onveilige 'Malloc' Funksie**

```bash
# Op die iOS-toestel
otool -Iv <app> | grep -w "_malloc"

# Op Linux
grep -iER "_malloc"
```
*   **Onveilige en Kwesbare Funksies**

```bash
# Op die iOS-toestel
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Op Linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Basiese Dinamiese Analise

Kyk na die dinamiese analise wat [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) uitvoer. Jy sal deur die verskillende aansigte moet navigeer en met hulle moet interaksie h√™, maar dit sal verskeie klasse koppel en ander dinge doen en 'n verslag voorberei sodra jy klaar is.

### Lys van Ge√Ønstalleerde Aansoeke

Gebruik die opdrag `frida-ps -Uai` om die **bondel-identifiseerder** van die ge√Ønstalleerde aansoeke te bepaal:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Basiese Opsomming & Hooking

Leer hoe om die **komponente van die aansoek op te som** en hoe om maklik **metodes en klasse te hook** met objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA-Struktuur

Die struktuur van 'n **IPA-l√™er** is essensieel di√© van 'n **gezipde pakkie**. Deur sy uitbreiding te hernoem na `.zip`, kan dit **gedekomprimeer** word om sy inhoud te onthul. Binne hierdie struktuur verteenwoordig 'n **Bundel** 'n ten volle verpakte aansoek gereed vir installasie. Binne-in sal jy 'n gids vind met die naam `<NAME>.app`, wat die hulpbronne van die aansoek inkapsuleer.

* **`Info.plist`**: Hierdie l√™er bevat spesifieke konfigurasiebesonderhede van die aansoek.
* **`_CodeSignature/`**: Hierdie gids sluit 'n plist-l√™er in wat 'n handtekening bevat wat die integriteit van alle l√™ers in die bundel verseker.
* **`Assets.car`**: 'n Gekomprimeerde argief wat bate-l√™ers soos ikone stoor.
* **`Frameworks/`**: Hierdie vouer huisves die aansoek se inheemse biblioteke, wat in die vorm van `.dylib` of `.framework` l√™ers kan wees.
* **`PlugIns/`**: Dit kan uitbreidings tot die aansoek insluit, bekend as `.appex` l√™ers, alhoewel hulle nie altyd teenwoordig is nie.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Dit word gebruik om jou aansoek se permanente data vir aflyngebruik te stoor, tydelike data te kash, en om ongedaanmaakfunksionaliteit by jou aansoek op 'n enkele toestel by te voeg. Om data oor verskeie toestelle in 'n enkele iCloud-rekening te sinchroniseer, spie√´l Core Data outomaties jou skema na 'n CloudKit-houer.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Die `PkgInfo`-l√™er is 'n alternatiewe manier om die tipe en skepperkodes van jou aansoek of bundel te spesifiseer.
* **en.lproj, fr.proj, Base.lproj**: Is die taalpakke wat hulpbronne vir daardie spesifieke tale bevat, en 'n verstekhulpbron in geval 'n taal nie ondersteun word nie.
* **Sekuriteit**: Die `_CodeSignature/`-gids speel 'n kritieke rol in die aansoek se sekuriteit deur die integriteit van alle gebundelde l√™ers deur digitale handtekeninge te verifieer.
* **Batebestuur**: Die `Assets.car`-l√™er gebruik kompressie om grafiese bates effektief te bestuur, wat noodsaaklik is vir die optimalisering van aansoekprestasie en die vermindering van sy algehele grootte.
* **Raamwerke en Inproppe**: Hierdie gide beklemtoon die modulariteit van iOS-aansoeke, wat ontwikkelaars in staat stel om herbruikbare kodebiblioteke (`Frameworks/`) in te sluit en aansoekfunksionaliteit uit te brei (`PlugIns/`).
* **Lokalisering**: Die struktuur ondersteun meertaligheid, wat globale aansoekbereik fasiliteer deur hulpbronne vir spesifieke taalpakke in te sluit.

**Info.plist**

Die **Info.plist** dien as 'n hoeksteen vir iOS-aansoeke, wat sleutelkonfigurasiedata inkapsuleer in die vorm van **sleutel-waarde** pare. Hierdie l√™er is 'n vereiste nie net vir aansoeke nie, maar ook vir aansoekuitbreidings en raamwerke wat daarin gebundel is. Dit is gestruktureer in XML of 'n bin√™re formaat en bevat kritieke inligting wat strek van aansoektoestemmings tot sekuriteitskonfigurasies. Vir 'n gedetailleerde verkenning van beskikbare sleutels, kan 'n persoon verwys na die [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Vir diegene wat met hierdie l√™er wil werk in 'n meer toeganklike formaat, kan die XML-omskakeling moeiteloos bereik word deur die gebruik van `plutil` op macOS (beskikbaar natively op weergawes 10.2 en later) of `plistutil` op Linux. Die opdragte vir omskakeling is as volg:

* **Vir macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Vir Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Onder die menigte inligting wat die **Info.plist** l√™er kan onthul, sluit noemenswaardige inskrywings in soos app-toestemmingsreekse (`UsageDescription`), aangepaste URL-skemas (`CFBundleURLTypes`), en konfigurasies vir App Transport Security (`NSAppTransportSecurity`). Hierdie inskrywings, tesame met ander soos uitgevoerde/ingevoerde aangepaste dokumenttipes (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), kan moeiteloos opgespoor word deur die l√™er te ondersoek of deur 'n eenvoudige `grep`-bevel te gebruik:
```bash
$ grep -i <keyword> Info.plist
```
**Data Paaie**

In die iOS-omgewing word gids spesifiek aangewys vir **sisteemtoepassings** en **gebruiker-ge√Ønstalleerde toepassings**. Sisteemtoepassings bly in die `/Applications` gids, terwyl gebruiker-ge√Ønstalleerde toepassings onder `/var/mobile/containers/Data/Application/` geplaas word. Hierdie toepassings word 'n unieke identifiseerder toegewys wat bekend staan as 'n **128-bis UUID**, wat die taak van die handmatige lokalisering van 'n toepassing se gids moeilik maak as gevolg van die lukraakheid van die gidsname.

{% hint style="warning" %}
Aangesien toepassings in iOS gesandboks moet wees, sal elke toepassing ook 'n gids binne **`$HOME/Library/Containers`** h√™ met die toepassing se **`CFBundleIdentifier`** as die gidsnaam.

Nietemin het beide gids (data & houer gids) die l√™er **`.com.apple.mobile_container_manager.metadata.plist`** wat beide l√™ers koppel in die sleutel `MCMetadataIdentifier`).
{% endhint %}

Om die ontdekking van 'n gebruiker-ge√Ønstalleerde toepassing se installasiegids te fasiliteer, bied die **objection tool** 'n nuttige bevel, `env`. Hierdie bevel onthul gedetailleerde gidsinligting vir die betrokke toepassing. Hieronder is 'n voorbeeld van hoe om hierdie bevel te gebruik:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatief kan die app-naam binne die `/private/var/containers` gesoek word met behulp van die `find`-opdrag:
```bash
find /private/var/containers -name "Progname*"
```
Opdragte soos `ps` en `lsof` kan ook gebruik word om die proses van die program te identifiseer en onderskeidelik 'n lys van oop l√™ers te gee, wat insig bied in die aktiewe gids van die aansoek:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bondelgids:**

* **AppName.app**
* Dit is die Aansoekbondel soos voorheen gesien in die IPA, dit bevat noodsaaklike aansoekdata, statiese inhoud sowel as die aansoek se saamgestelde bin√™re l√™er.
* Hierdie gids is sigbaar vir gebruikers, maar **gebruikers kan nie daarin skryf nie**.
* Inhoud in hierdie gids word **nie gestoor nie**.
* Die inhoud van hierdie gids word gebruik om die kodesignatuur te **valideer**.

**Data-gids:**

* **Dokumente/**
* Bevat alle gebruikers gegenereerde data. Die aansoek eindgebruiker inisieer die skepping van hierdie data.
* Sigbaar vir gebruikers en **gebruikers kan daarin skryf**.
* Inhoud in hierdie gids word **gestoor**.
* Die aansoek kan paaie deaktiveer deur `NSURLIsExcludedFromBackupKey` in te stel.
* **Biblioteek/**
* Bevat alle l√™ers wat nie gebruikersspesifiek is nie, soos **gekassetteerde**, **voorkeure**, **koekies**, en eiendomslys (plist) opsetl√™ers.
* iOS-aansoeke gebruik gewoonlik die `Toepassingsondersteuning` en `Kassies` subgidse, maar die aansoek kan aangepaste subgidse skep.
* **Biblioteek/Kassies/**
* Bevat **semi-blywende gekassetteerde l√™ers**.
* Onsigbaar vir gebruikers en **gebruikers kan nie daarin skryf nie**.
* Inhoud in hierdie gids word **nie gestoor nie**.
* Die OS kan hierdie gids se l√™ers outomaties verwyder wanneer die aansoek nie loop nie en stoorpasmaat laag is.
* **Biblioteek/Toepassingsondersteuning/**
* Bevat **blywende l√™ers** wat nodig is vir die aansoek se werking.
* **Onsigbaar vir gebruikers** en gebruikers kan nie daarin skryf nie.
* Inhoud in hierdie gids word **gestoor**.
* Die aansoek kan paaie deaktiveer deur `NSURLIsExcludedFromBackupKey` in te stel.
* **Biblioteek/Voorkeure/**
* Gebruik vir die stoor van eienskappe wat selfs nadat 'n aansoek heraangestel word, **bly voortbestaan**.
* Inligting word ongekripteer binne die aansoek se sandput in 'n plist-l√™er genaamd \[BONDSEL\_ID].plist gestoor.
* Al die sleutel/waardepare wat met `NSUserDefaults` gestoor word, kan in hierdie l√™er gevind word.
* **tmp/**
* Gebruik hierdie gids om **tydelike l√™ers** te skryf wat nie tussen aansoekbeginne moet voortbestaan nie.
* Bevat nie-blywende gekassetteerde l√™ers.
* **Onsigbaar** vir gebruikers.
* Inhoud in hierdie gids word **nie gestoor nie**.
* Die OS kan hierdie gids se l√™ers outomaties verwyder wanneer die aansoek nie loop nie en stoorpasmaat laag is.

Laten ons 'n nouer kyk na iGoat-Swift se Aansoekbondel (.app) gids binne die Bondelgids (`/var/containers/Bondel/Aansoek/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Bin√™re Omkeer

Binne die `<application-name>.app`-vouer sal jy 'n bin√™re l√™er kry genaamd `<application-name>`. Hierdie is die l√™er wat **uitgevoer** sal word. Jy kan 'n basiese inspeksie van die bin√™re l√™er doen met die gereedskap **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Kyk of die program versleutel is**

Sien of daar enige uitset is vir:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Ontas die bin√™re**

Ontas die teksafdeling:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Om die **Objective-C segment** van die voorbeeldtoepassing af te druk, kan 'n mens gebruik:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Om 'n meer kompakte Objective-C-kode te verkry, kan jy [**class-dump**](http://stevenygard.com/projects/class-dump/) gebruik:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Togtans, die beste opsies om die bin√™re kode te ontleed is: [**Hopper**](https://www.hopperapp.com/download.html?) en [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) om maklik te bou en **werkstrome outomaties** te laat loop met die w√™reld se **mees gevorderde** gemeenskapshulpmiddels.\
Kry Toegang Vandag:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Data Berging

Om te leer oor hoe iOS data op die toestel berg, lees hierdie bladsy:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Die volgende plekke om inligting te berg moet **direk na die installering van die aansoek** nagegaan word, **nadat al die funksionaliteite** van die aansoek nagegaan is en selfs nadat **uitgelog is van een gebruiker en ingelog is by 'n ander**.\
Die doel is om **onbeskermde sensitiewe inligting** van die aansoek (wagwoorde, tokens), van die huidige gebruiker en van vorige ingeteken gebruikers te vind.
{% endhint %}

### Plist

**plist** l√™ers is gestruktureerde XML-l√™ers wat **sleutel-waarde pare bevat**. Dit is 'n manier om volgehoue data te berg, so soms mag jy **sensitiewe inligting in hierdie l√™ers vind**. Dit word aanbeveel om hierdie l√™ers na die installering van die aansoek en na intensiewe gebruik daarvan te ondersoek om te sien of nuwe data geskryf is.

Die mees algemene manier om data in plist-l√™ers vol te hou is deur die gebruik van **NSUserDefaults**. Hierdie plist-l√™er word binne die aansoek se sandput in **`Library/Preferences/<appBundleID>.plist`** gestoor.

Die [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) klas bied 'n programmatiese koppelvlak vir interaksie met die verstekstelsel. Die verstekstelsel laat 'n aansoek toe om sy gedrag aan te pas volgens **gebruikersvoorkeure**. Data wat deur `NSUserDefaults` gestoor word, kan in die aansoekbundel besigtig word. Hierdie klas berg **data** in 'n **plist** **l√™er**, maar dit is bedoel om met klein hoeveelhede data gebruik te word.

Hierdie data kan nie direk via 'n vertroude rekenaar benader word nie, maar kan benader word deur 'n **back-up** uit te voer.

Jy kan die inligting wat met **`NSUserDefaults`** gestoor is, **dump** deur gebruik te maak van objection se `ios nsuserdefaults get`

Om al die plist-l√™ers wat deur die aansoek gebruik word te vind, kan jy toegang kry tot `/private/var/mobile/Containers/Data/Application/{APPID}` en hardloop:
```bash
find ./ -name "*.plist"
```
Om l√™ers vanaf **XML of bin√™re (bplist)** formaat na XML te omskep, is verskeie metodes beskikbaar, afhangende van jou bedryfstelsel:

**Vir macOS-gebruikers:** Maak gebruik van die `plutil`-opdrag. Dit is 'n ingeboude gereedskap in macOS (10.2+), ontwerp vir hierdie doel:
```bash
$ plutil -convert xml1 Info.plist
```
**Vir Linux-gebruikers:** Installeer eers `libplist-utils`, gebruik dan `plistutil` om jou l√™er te omskep:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Binne 'n Objection-sessie:** Vir die analise van mobiele aansoeke, laat 'n spesifieke bevel jou toe om plist-l√™ers direk te omskep:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Kern Data

[`Kern Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) is 'n raamwerk vir die bestuur van die model-laag van voorwerpe in jou aansoek. [Kern Data kan SQLite gebruik as sy permanente stoor](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), maar die raamwerk self is nie 'n databasis nie.\
CoreData enkripteer nie sy data standaard nie. 'n Bykomende enkripsie-laag kan egter by CoreData gevoeg word. Sien die [GitHub Repo](https://github.com/project-imas/encrypted-core-data) vir meer besonderhede.

Jy kan die SQLite Kern Data-inligting van 'n aansoek vind in die pad `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**As jy die SQLite kan oopmaak en toegang tot sensitiewe inligting kan verkry, het jy 'n konfigurasie-fout gevind.**

{% code title="Kode van iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) is 'n sleutel/waarde-stoor gebou op SQLite.\
Aangesien die Yap-databasisse sqlite-databasisse is, kan jy hulle vind deur die voorgestelde opdrag in die vorige afdeling te gebruik.

### Ander SQLite-databasisse

Dit is algemeen vir toepassings om hul eie sqlite-databasis te skep. Hulle kan **sensitiewe** **data** daarin **berg** en dit onge√´nkripteer los. Daarom is dit altyd interessant om elke databasis binne die toepassingsgids te ondersoek. Gaan dus na die toepassingsgids waar die data gestoor word (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databasis

Ontwikkelaars is in staat om **data te stoor en te sinchroniseer** binne 'n **NoSQL wolk-gehoste databasis** deur Firebase Real-Time Databasis. Gestoor in JSON-formaat, word die data gesinchroniseer na alle gekoppelde kli√´nte in werklike tyd.

Jy kan uitvind hoe om vir verkeerd gekonfigureerde Firebase databasisse te soek hier:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm databasisse

[Realm Objective-C](https://realm.io/docs/objc/latest/) en [Realm Swift](https://realm.io/docs/swift/latest/) bied 'n kragtige alternatief vir data stoor, nie voorsien deur Apple nie. Standaard **stoor hulle data onversleutel**, met versleuteling beskikbaar deur spesifieke konfigurasie.

Die databasisse is gele√´ by: `/private/var/mobile/Containers/Data/Application/{APPID}`. Om hierdie l√™ers te verken, kan mens opdragte soos die volgende gebruik:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Vir die besigtiging van hierdie databasisl√™ers, word die [**Realm Studio**](https://github.com/realm/realm-studio) gereedskap aanbeveel.

Om kriptering binne 'n Realm-databasis te implementeer, kan die volgende kodefragment gebruik word:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Databasis

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) word beskryf as 'n **ligte** en **ingeboude** databasis-enjin wat die **dokument-geori√´nteerde** (NoSQL) benadering volg. Dit is ontwerp om inheems te wees aan **iOS** en **macOS**, en bied die vermo√´ om data naatloos te sinchroniseer.

Om potensi√´le Couchbase databasisse op 'n toestel te identifiseer, moet die volgende gids ondersoek word:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Koekies

iOS stoor die koekies van die programme in die **`Library/Cookies/cookies.binarycookies`** binne elke program se vouer. Ontwikkelaars besluit egter soms om hulle in die **sleutelhangertoestel** te stoor aangesien die genoemde **koekie l√™er in rugsteune toeganklik kan wees**.

Om die koekies l√™er te ondersoek, kan jy [**hierdie Python-skrip**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) gebruik of objection se **`ios cookies get`.**\
**Jy kan ook objection gebruik om** hierdie l√™ers na 'n JSON-formaat te omskep en die data te ondersoek.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Standaard stoor NSURLSession data, soos **HTTP-aanvrae en -antwoorde in die Cache.db** databasis. Hierdie databasis kan **sensitiewe data** bevat, as tokkens, gebruikersname of enige ander sensitiewe inligting gekasheer is. Om die gekasheerde inligting te vind, open die data-gids van die program (`/var/mobile/Containers/Data/Application/<UUID>`) en gaan na `/Library/Caches/<Bundel Identifiseerder>`. Die **WebKit-cache word ook in die Cache.db** l√™er gestoor. **Objection** kan die databasis oopmaak en daarmee interaksie h√™ met die opdrag `sqlite connect Cache.db`, aangesien dit 'n **normale SQLite-databasis** is.

Dit word **aanbeveel om hierdie data se Kassering te deaktiveer**, aangesien dit sensitiewe inligting in die aanvraag of antwoord kan bevat. Die volgende lys toon verskillende maniere om dit te bereik:

1. Dit word aanbeveel om Gekasheerde antwoorde na uitteken te verwyder. Dit kan gedoen word met die voorsiene metode deur Apple genoem [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) Jy kan hierdie metode soos volg aanroep:

`URLCache.shared.removeAllCachedResponses()`

Hierdie metode sal alle gekasheerde aanvrae en antwoorde uit die Cache.db-l√™er verwyder.
2. As jy nie die voordeel van koekies wil gebruik nie, word dit aanbeveel om net die [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) konfigurasie-eienskap van URLSession te gebruik, wat die stoor van koekies en Kassering sal deaktiveer.

[Apple-dokumentasie](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`'n Ephemeral-sessiekonfigurasie-objek is soortgelyk aan 'n verstek-sessiekonfigurasie (sien verstek), behalwe dat die ooreenstemmende sessieobjek nie kassas, geloofsbewaarplekke, of enige sessie-verwante data na skyf stoor nie. In plaas daarvan word sessie-verwante data in RAM gestoor. Die enigste tyd wat 'n ephemeral-sessie data na skyf skryf, is wanneer jy dit s√™ om die inhoud van 'n URL na 'n l√™er te skryf.`
3. Kassering kan ook deaktiveer word deur die Kasseringbeleid in te stel op [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Dit sal die stoor van Kassering op enige manier, hetsy in geheue of op skyf, deaktiveer.

### Snapshots

Telkens wanneer jy die tuisknoppie indruk, **neem iOS 'n oorskot van die huidige skerm** om die oorgang na die program op 'n baie gladder manier te kan doen. Maar, as **sensitiewe data** teenwoordig is op die huidige skerm, sal dit **gestoor** word in die **beeld** (wat **oorleef** **herlaaiings**). Dit is die oorskotte wat jy ook kan toegang deur dubbelklik op die tuiskerm om tussen programme te skakel.

Tensy die iPhone gejailbreak is, moet die **aanvaller** toegang h√™ tot die **toestel** wat **onblokkeer** is om hierdie skermskote te sien. Standaard word die laaste oorskot gestoor in die program se sandput in `Library/Caches/Snapshots/` of `Library/SplashBoard/Snapshots` gids (die vertroude rekenaars kan nie toegang kry tot die l√™ersisteem vanaf iOX 7.0 nie).

Een manier om hierdie slegte gedrag te voorkom, is om 'n le√´ skerm te plaas of die sensitiewe data te verwyder voordat die oorskot geneem word met die `ApplicationDidEnterBackground()`-funksie.

Die volgende is 'n voorbeeld van 'n herstelmetode wat 'n verstekskerm sal instel.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
**Doel-C:**
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Hierdie stel die agtergrondbeeld in op `overlayImage.png` wanneer die aansoek na die agtergrond gaan. Dit voorkom sensitiewe data lekke omdat `overlayImage.png` altyd die huidige aansig sal oorskry.

### Sleutelhang

Vir toegang tot en bestuur van die iOS-sleutelhang, is gereedskap soos [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) beskikbaar, geskik vir gejailbreakte toestelle. Daarbenewens bied [**Objection**](https://github.com/sensepost/objection) die opdrag `ios keychain dump` vir soortgelyke doeleindes.

#### **Stoor van Gelde**

Die **NSURLCredential** klas is ideaal vir die stoor van sensitiewe inligting direk in die sleutelhang, om die behoefte aan NSUserDefaults of ander omhulsels te vermy. Om gelde na die aanmelding te stoor, word die volgende Swift-kode gebruik:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Om hierdie gestoorde geloofsbriewe te onttrek, word die bevel `ios nsurlcredentialstorage dump` van Objection gebruik.

## **Aangepaste Sleutelborde en Sleutelbordgeheue**

Met iOS 8.0 en verder kan gebruikers aangepaste sleutelborduitbreidings installeer, wat bestuurbaar is onder **Instellings > Algemeen > Sleutelbord > Sleutelborde**. Terwyl hierdie sleutelborde verlengde funksionaliteit bied, hou hulle 'n risiko in vir sleutelstroklogging en die oordra van data na eksterne bedieners, alhoewel gebruikers in kennis gestel word van sleutelborde wat netwerktoegang benodig. Programme kan, en behoort, die gebruik van aangepaste sleutelborde vir die invoer van sensitiewe inligting te beperk.

**Sekuriteitsaanbevelings:**

* Dit word aanbeveel om derdeparty sleutelborde te deaktiveer vir verbeterde sekuriteit.
* Wees bewus van die outokorreksie en outo-voorstelle van die verstek iOS-sleutelbord, wat sensitiewe inligting in die geheue l√™ers in `Library/Keyboard/{locale}-dynamic-text.dat` of `/private/var/mobile/Library/Keyboard/dynamic-text.dat` kan stoor. Hierdie geheue l√™ers moet gereeld nagegaan word vir sensitiewe data. Dit word aanbeveel om die sleutelbordwoordeboek te herstel via **Instellings > Algemeen > Herstel > Herstel Sleutelbordwoordeboek** om gekaakte data te skoonmaak.
* Die onderskepping van netwerkverkeer kan onthul of 'n aangepaste sleutelbord sleutelstrokes op afstand oordra.

### **Voorkoming van Teksveldgeheue**

Die [UITextInputTraits-protokol](https://developer.apple.com/reference/uikit/uitextinputtraits) bied eienskappe om outokorreksie en veilige teksinvoer te bestuur, wat noodsaaklik is vir die voorkoming van die kaching van sensitiewe inligting. Byvoorbeeld, die deaktivering van outokorreksie en die aktivering van veilige teksinvoer kan bereik word met:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Daarbenewens moet ontwikkelaars verseker dat teksvelde, veral di√© vir die invoer van sensitiewe inligting soos wagwoorde en PINs, die kaching deaktiveer deur `autocorrectionType` in te stel op `UITextAutocorrectionTypeNo` en `secureTextEntry` op `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Foutopsporing van kode behels dikwels die gebruik van **logging**. Daar is 'n risiko betrokke aangesien **logs sensitiewe inligting kan bevat**. Voorheen, in iOS 6 en vroe√´re weergawes, was logs toeganklik vir alle programme, wat 'n risiko van die lekkasie van sensitiewe data inhou. **Nou is programme beperk tot toegang tot slegs hul eie logs**.

Ten spyte van hierdie beperkings kan 'n **aanvaller met fisiese toegang** tot 'n ontslote toestel dit steeds uitbuit deur die toestel aan 'n rekenaar te koppel en die logs te **lees**. Dit is belangrik om daarop te let dat logs op die skyf bly selfs nadat die toepassing gede√Ønstalleer is.

Om risiko's te verminder, word dit aanbeveel om **deeglik met die toepassing te interageer**, al sy funksies en insette te verken om te verseker dat geen sensitiewe inligting per ongeluk gelog word nie.

Wanneer jy die bronkode van die toepassing deursoek vir potensi√´le lekkasies, soek na beide **voorgedefinieerde** en **aangepaste logging-stellings** met sleutelwoorde soos `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` vir ingeboude funksies, en enige vermeldings van `Logging` of `Logfile` vir aangepaste implementasies.

### **Monitering van Stelsellogs**

Toepassings log verskeie stukke inligting wat sensitief kan wees. Om hierdie logs te monitor, kan gereedskap en opdragte soos:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
is nuttig. Daarbenewens bied **Xcode** 'n manier om konsole-logboeke te versamel:

1. Maak Xcode oop.
2. Koppel die iOS-toestel aan.
3. Navigeer na **Venster** -> **Toestelle en Simulator**.
4. Kies jou toestel.
5. Trigger die probleem wat jy ondersoek.
6. Gebruik die **Maak Konsole Oop**-knoppie om logboeke in 'n nuwe venster te sien.

Vir meer gevorderde logging kan die koppel aan die toestel se skul en die gebruik van **socat** werklike tyd log-monitoring bied:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Volg deur bevele om logaktiwiteite waar te neem, wat van onschatbare waarde kan wees vir die diagnose van probleme of die identifisering van potensi√´le data-lekkasies in logboeke.

***

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik **werkstrome te bou** en te **outomatiseer** wat aangedryf word deur die w√™reld se **mees gevorderde** gemeenskapsinstrumente.\
Kry Vandaag Toegang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Agteruitskopie√´

**Outomatiese agteruitskopiefunksies** is ge√Øntegreer in iOS, wat die skep van toesteldatakopie√´ deur iTunes (tot macOS Catalina), Finder (vanaf macOS Catalina aan) of iCloud fasiliteer. Hierdie kopie√´ sluit bykans alle toesteldata in, met uitsluiting van hoogs sensitiewe elemente soos Apple Pay besonderhede en Touch ID konfigurasies.

### Sekuriteitsrisiko's

Die insluiting van **ge√Ønstalleerde programme en hul data** in agteruitskopie√´ bring die kwessie van potensi√´le **data-lekkasie** na vore en die risiko dat **agteruitskopiewysigings programme-funksionaliteit kan verander**. Dit word aanbeveel om **nie sensitiewe inligting in platte teks te stoor** binne enige program se gids of subgidse om hierdie risiko's te verminder.

### Uitsluiting van L√™ers uit Agteruitskopie√´

L√™ers in `Documents/` en `Library/Application Support/` word standaard agteruitgekopieer. Ontwikkelaars kan spesifieke l√™ers of gidse uit agteruitskopie√´ uitsluit deur `NSURL setResourceValue:forKey:error:` te gebruik met die `NSURLIsExcludedFromBackupKey`. Hierdie praktyk is noodsaaklik om sensitiewe data te beskerm teen insluiting in agteruitskopie√´.

### Toets vir Swakhede

Om 'n program se agteruitskopie-sekuriteit te assesseer, begin deur 'n agteruitskopie te **skep** met Finder, en vind dit dan met behulp van leiding van [Apple se amptelike dokumentasie](https://support.apple.com/en-us/HT204215). Analiseer die agteruitskopie vir sensitiewe data of konfigurasies wat verander kan word om programgedrag te affekteer.

Sensitiewe inligting kan opgespoor word met behulp van opdraglyn-hulpmiddels of toepassings soos [iMazing](https://imazing.com). Vir versleutelde agteruitskopie√´ kan die teenwoordigheid van versleuteling bevestig word deur die "IsEncrypted" sleutel in die "Manifest.plist" l√™er by die agteruitskopie se hoof te kontroleer.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Vir die hantering van versleutelde rugsteunkopie√´, kan Python-skripte beskikbaar in [DinoSec se GitHub-opberging](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), soos **backup\_tool.py** en **backup\_passwd.py**, nuttig wees, alhoewel dit moontlik aanpassings mag vereis vir versoenbaarheid met die nuutste iTunes/Finder-weergawes. Die [**iOSbackup**-werktuig](https://pypi.org/project/iOSbackup/) is 'n ander opsie vir die toegang tot l√™ers binne wagwoordbeskermde rugsteunkopie√´.

### Wysiging van App-gedrag

'n Voorbeeld van die verandering van app-gedrag deur rugsteunveranderings word gedemonstreer in die [Bither bitcoin-bewaarplek-app](https://github.com/bither/bither-ios), waar die UI-slot-PIN binne `net.bither.plist` onder die **pin\_code** sleutel gestoor word. Die verwydering van hierdie sleutel uit die plist en die herstel van die rugsteun verwyder die PIN-vereiste, wat onbeperkte toegang bied.

## Opsomming van Geheugentoetsing vir Sensitiewe Data

Wanneer daar gehandel word met sensitiewe inligting wat in 'n toepassing se geheue gestoor word, is dit noodsaaklik om die blootstellingsduur van hierdie data te beperk. Daar is twee prim√™re benaderings om geheue-inhoud te ondersoek: **die skep van 'n geheue-aflees** en **die analise van die geheue in werklike tyd**. Beide metodes het hul uitdagings, insluitend die potensiaal om kritieke data tydens die afleesproses of analise te mis.

## **Ophaling en Analise van 'n Geheue-Aflees**

Vir beide gejailbreakte en nie-gejailbreakte toestelle, maak gereedskap soos [objection](https://github.com/sensepost/objection) en [Fridump](https://github.com/Nightbringer21/fridump) dit moontlik om 'n toepassing se prosesgeheue af te lees. Nadat dit afgelees is, vereis die analise van hierdie data verskeie gereedskap, afhangende van die aard van die inligting wat jy soek.

Om strings uit 'n geheue-aflees te onttrek, kan opdragte soos `strings` of `rabin2 -zz` gebruik word:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Vir meer gedetailleerde analise, insluitend die soeke na spesifieke datatipes of patrone, bied **radare2** uitgebreide soekmoontlikhede:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Uitvoertydanalise van Geheue**

**r2frida** bied 'n kragtige alternatief vir die inspeksie van 'n toep se geheue in werklike tyd, sonder om 'n geheue-afvoer nodig te h√™. Hierdie instrument maak die uitvoering van soekopdragte direk op die lopende toep se geheue moontlik:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Gebroke Kriptografie

### Swak Sleutelbestuursprosesse

Sommige ontwikkelaars stoor sensitiewe data in die plaaslike stoor en versleutel dit met 'n sleutel wat hardgekodel/voorspelbaar in die kode is. Dit behoort nie gedoen te word nie, aangesien sommige omkeerwerk dit vir aanvallers moontlik kan maak om die vertroulike inligting te onttrek.

### Gebruik van Onveilige en/of Uitgefaseerde Algoritmes

Ontwikkelaars behoort nie **uitgefaseerde algoritmes** te gebruik om outorisasie **kontroles** uit te voer, data te **stoor** of te **stuur** nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hashe** byvoorbeeld gebruik word om wagwoorde te stoor, moet hashe wat weerstand bied teen brutale krag gebruik word met sout.

### Kontrole

Die belangrikste kontroles om uit te voer is om te kyk of jy **hardgekodelde** wagwoorde/geheime in die kode kan vind, of dit **voorspelbaar** is, en of die kode van 'n soort **swak** **kriptografie**-algoritmes gebruik maak.

Dit is interessant om te weet dat jy sommige **kripto** **biblioteke** outomaties kan **monitor** met **objection** met:
```swift
ios monitor crypt
```
Vir **meer inligting** oor iOS kriptografiese API's en biblioteke, besoek [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Plaaslike Verifikasie

**Plaaslike verifikasie** speel 'n belangrike rol, veral wanneer dit gaan oor die beskerming van toegang tot 'n afgele√´ eindpunt deur middel van kriptografiese metodes. Die essensie hier is dat sonder behoorlike implementering, plaaslike verifikasiemeganismes omseil kan word.

Apple se [**Plaaslike Verifikasieraamwerk**](https://developer.apple.com/documentation/localauthentication) en die [**sleutelhang**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) bied robuuste API's vir ontwikkelaars om gebruikersverifikasie-dialoge te fasiliteer en geheime data veilig te hanteer, onderskeidelik. Die Veilige Enclave verseker vingerafdruk-ID vir Touch ID, terwyl Face ID staatmaak op gesigskenning sonder om biometriese data in gevaar te stel.

Om Touch ID/Face ID te integreer, het ontwikkelaars twee API-keuses:

* **`LocalAuthentication.framework`** vir ho√´vlak-gebruikersverifikasie sonder toegang tot biometriese data.
* **`Security.framework`** vir laevlak-sleutelhangdiensetoegang, wat geheime data met biometriese verifikasie beveilig. Verskeie [oopbron-omsluitings](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) maak sleutelhangtoegang eenvoudiger.

{% hint style="danger" %}
Nietemin, beide `LocalAuthentication.framework` en `Security.framework` het kwesbaarhede, aangesien hulle hoofsaaklik booleaanwaardes teruggee sonder om data vir verifikasieprosesse oor te dra, wat hulle vatbaar maak vir omseiling (sien [Moenie my so aanraak nie, deur David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementering van Plaaslike Verifikasie

Om gebruikers te vra vir verifikasie, moet ontwikkelaars die **`evaluatePolicy`**-metode binne die **`LAContext`**-klas gebruik, deur te kies tussen:

* **`deviceOwnerAuthentication`**: Vra vir Touch ID of toestel wagwoord, faal as geen van beide geaktiveer is.
* **`deviceOwnerAuthenticationWithBiometrics`**: Vra eksklusief vir Touch ID.

'n Suksesvolle verifikasie word aangedui deur 'n booleaanse terugvoerwaarde van **`evaluatePolicy`**, wat 'n potensi√´le sekuriteitsfout aandui.

### Plaaslike Verifikasie met Sleutelhang

Die implementering van **plaaslike verifikasie** in iOS-toepassings behels die gebruik van **sleutelhang-API's** om geheime data soos verifikasietokens veilig te stoor. Hierdie proses verseker dat die data slegs deur die gebruiker toeganklik is, deur hul toestel wagwoord of biometriese verifikasie soos Touch ID te gebruik.

Die sleutelhang bied die vermo√´ om items met die `SecAccessControl`-eienskap in te stel, wat toegang tot die item beperk totdat die gebruiker suksesvol verifieer via Touch ID of toestel wagwoord. Hierdie kenmerk is noodsaaklik vir die verbetering van sekuriteit.

Hieronder is kodevoorbeelde in Swift en Objective-C wat demonstreer hoe om 'n string na/die sleutelhang te stoor en te herwin, deur van hierdie sekuriteitskenmerke gebruik te maak. Die voorbeelde toon spesifiek hoe om toegangsbeheer op te stel om Touch ID-verifikasie te vereis en te verseker dat die data slegs op die toestel waarop dit opgestel is, toeganklik is, onder die voorwaarde dat 'n toestel wagwoord geconfigureer is.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}  
### Doel
Die doel van iOS pentesting is om sekuriteitskwessies in iOS-toepassings te identifiseer en te misbruik om die toepassing se sekuriteit te verbeter.  
{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Nou kan ons die gestoorde item van die sleutelhangerverkry. Sleutelhangerverkope sal die verifikasie dialoog aan die gebruiker vertoon en data of nil teruggee, afhangende of 'n geskikte vingerafdruk voorsien was of nie.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}  
### Doel
Die doel van iOS pentesting is om sekuriteitskwessies in iOS-toepassings te identifiseer en te misbruik om die toepassing se veiligheid te verbeter.  
{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### Opmerking

Die gebruik van raamwerke in 'n toep kan ook opgespoor word deur die lys van gedeelde dinamiese biblioteke van die toep se bin√™re l√™er te analiseer. Dit kan gedoen word deur `otool` te gebruik:
```bash
$ otool -L <AppName>.app/<AppName>
```
Indien `LocalAuthentication.framework` in 'n app gebruik word, sal die uitset beide van die volgende lyne bevat (onthou dat `LocalAuthentication.framework` `Security.framework` onder die oppervlak gebruik):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Indien `Security.framework` gebruik word, sal slegs die tweede een vertoon word.

### Plaaslike Verifikasie Raamwerk Omgang

#### **Beswaar**

Deur die **Beswaar Biometriese Omgang**, gele√´ op [hierdie GitHub-bladsy](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), is 'n tegniek beskikbaar om die **LocalAuthentication** meganisme te omseil. Die kern van hierdie benadering behels die benutting van **Frida** om die `evaluatePolicy`-funksie te manipuleer, wat verseker dat dit konsekwent 'n `True` uitkoms lewer, ongeag die werklike verifikasiesukses. Dit is veral nuttig vir die omseil van gebrekkige biometriese verifikasieprosesse.

Om hierdie omseiling te aktiveer, word die volgende bevel gebruik:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Hierdie bevel stel 'n reeks in waar Objection 'n taak registreer wat die uitkoms van die `evaluatePolicy`-kontrole effektief verander na `True`.

#### Frida

'n Voorbeeld van die gebruik van **`evaluatePolicy`** vanaf [DVIA-v2 aansoek](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Om die **omseil** van Plaaslike Verifikasie te bereik, word 'n Frida-skripsie geskryf. Hierdie skripsie teiken die **evaluatePolicy**-kontrole deur sy terugroep te onderskep om te verseker dat dit **success=1** teruggee. Deur die gedrag van die terugroep te verander, word die verifikasie kontrole effektief omseil.

Die onderstaande skripsie word ingespuit om die resultaat van die **evaluatePolicy**-metode te wysig. Dit verander die resultaat van die terugroep om altyd sukses aan te dui.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Om die Frida-skrip in te spuit en die biometriese verifikasie te omseil, word die volgende bevel gebruik:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Sensitiewe Funksionaliteit Blootstelling deur IPC

### Aangepaste URI Handlers / Deeplinks / Aangepaste Skemas

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Universele Skakels

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity Deling

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### App Uitbreidings

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serialisering en Enkodering

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Netwerk Kommunikasie

Dit is belangrik om te kontroleer dat geen kommunikasie plaasvind **sonder versleuteling** en ook dat die aansoek korrek die TLS-sertifikaat van die bediener **valideer**.\
Om hierdie soort kwessies te toets, kan jy 'n proksi soos **Burp** gebruik:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Naam van bediener kontroleer

Een algemene probleem met die validering van die TLS-sertifikaat is om te kontroleer of die sertifikaat deur 'n **vertroude** **CA** onderteken is, maar **nie te kontroleer** of **die naam van die bediener** van die sertifikaat die toegangsgastheer is nie.\
Om hierdie probleem met Burp te toets, nadat jy die Burp CA op die iPhone vertrou het, kan jy **'n nuwe sertifikaat met Burp vir 'n ander toegangsgastheer skep** en dit gebruik. As die aansoek steeds werk, dan is daar iets kwesbaar.

### Sertifikaat Pinning

As 'n aansoek korrek SSL Pinning gebruik, sal die aansoek net werk as die sertifikaat die verwagte een is. Wanneer jy 'n aansoek toets **kan dit 'n probleem wees omdat Burp sy eie sertifikaat sal dien.**\
Om hierdie beskerming binne 'n jailbroken-toestel te omseil, kan jy die aansoek installeer [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) of installeer [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Jy kan ook gebruik **objection's** `ios sslpinning disable`

## Verskeie

* In **`/System/Library`** kan jy die raamwerke vind wat in die foon ge√Ønstalleer is en deur stelseltoepassings gebruik word
* Die aansoeke wat deur die gebruiker van die App Store ge√Ønstalleer is, word binne **`/User/Applications`** gevind
* En die **`/User/Library`** bevat data wat deur die gebruiker-vlak aansoeke gestoor is
* Jy kan toegang kry tot **`/User/Library/Notes/notes.sqlite`** om die notas wat binne die aansoek gestoor is, te lees.
* Binne die vouer van 'n ge√Ønstalleerde aansoek (**`/User/Applications/<APP ID>/`**) kan jy 'n paar interessante l√™ers vind:
* **`iTunesArtwork`**: Die ikoon wat deur die aansoek gebruik word
* **`iTunesMetadata.plist`**: Inligting van die aansoek wat in die App Store gebruik word
* **`/Library/*`**: Bevat die voorkeure en cache. In **`/Library/Cache/Snapshots/*`** kan jy die oomblikopname vind wat van die aansoek geneem is voordat dit na die agtergrond gestuur is.

### Warm Patching/Verpligte Opdatering

Die ontwikkelaars kan op afstand **alle installasies van hul aansoek onmiddellik aanpas** sonder om die aansoek na die App Store te herindien en te wag tot dit goedgekeur word.\
Vir hierdie doel word gewoonlik gebruik [**JSPatch**](https://github.com/bang590/JSPatch)**.** Maar daar is ook ander opsies soos [Siren](https://github.com/ArtSabintsev/Siren) en [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Dit is 'n gevaarlike meganisme wat misbruik kan word deur skadelike derde party SDK's, daarom word aanbeveel om te kontroleer watter metode gebruik word vir outomatiese opdatering (indien enige) en dit te toets.** Jy kan 'n vorige weergawe van die aansoek aflaai vir hierdie doel.

### Derde Party

'n Beduidende uitdaging met **3de party SDK's** is die **gebrek aan fyn beheer** oor hul funksionaliteite. Ontwikkelaars staar 'n keuse in die gesig: of integreer die SDK en aanvaar al sy funksies, insluitend potensi√´le sekuriteitskwessies en privaatheidskwessies, of verwerp dit heeltemal. Dikwels is ontwikkelaars nie in staat om kwessies binne hierdie SDK's self te herstel nie. Verder, soos SDK's vertroue wen binne die gemeenskap, mag sommige malware begin bevat.

Die dienste wat deur derde party SDK's verskaf word, mag gebruikersgedragopsporing, advertensieweergawes of gebruikerservaringsverbeterings insluit. Dit bring egter 'n risiko mee aangesien ontwikkelaars dalk nie ten volle bewus is van die kode wat deur hierdie biblioteke uitgevoer word nie, wat kan lei tot potensi√´le privaatheids- en sekuriteitsrisiko's. Dit is noodsaaklik om die inligting wat met derde party dienste gedeel word, te beperk tot wat nodig is en te verseker dat geen sensitiewe data blootgestel word.

Die implementering van derde party dienste kom gewoonlik in twee vorms voor: 'n afsonderlike biblioteek of 'n volledige SDK. Om gebruikersprivaatheid te beskerm, moet enige data wat met hierdie dienste gedeel word, **geanonimiseer** word om die bekendmaking van Persoonlik Identifiseerbare Inligting (PII) te voorkom.

Om die biblioteke wat 'n aansoek gebruik, te identifiseer, kan die **`otool`**-bevel gebruik word. Hierdie instrument moet teen die aansoek en elke gedeelde biblioteek wat dit gebruik, uitgevoer word om addisionele biblioteke te ontdek.
```bash
otool -L <application_path>
```
## **Verwysings & Meer Hulpbronne**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS gratis kursus([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C weergawe [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift weergawe
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik te bou en **outomatiseer werksvloei** aangedryf deur die w√™reld se **mees gevorderde** gemeenskaplike gereedskap.\
Kry Vandag Toegang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Leer AWS hak vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien jou **maatskappy geadverteer in HackTricks** of **laai HackTricks af in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
