# Uchunguzi wa iOS

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) kujenga na **kutumia workflows** kwa kutumia zana za **jamii ya juu zaidi** duniani.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

<details>

<summary><strong>Jifunze kuhusu kuvamia AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kuvamia kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Misingi ya iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Mazingira ya Majaribio

Kwenye ukurasa huu unaweza kupata habari kuhusu **simulator ya iOS**, **emulators** na **jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Uchambuzi wa Awali

### Operesheni za Msingi za Uchunguzi wa iOS

Wakati wa uchunguzi **operesheni kadhaa zitapendekezwa** (unganisha kifaa, soma/andika/pakia/shusha faili, tumia baadhi ya zana...). Kwa hivyo, ikiwa hujui jinsi ya kufanya mojawapo ya hatua hizi tafadhali, **anza kusoma ukurasa**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Kwa hatua zifuatazo **programu inapaswa kuwa imewekwa** kwenye kifaa na tayari kupata **faili ya IPA** ya programu.\
Soma ukurasa wa [Operesheni za Msingi za Uchunguzi wa iOS](basic-ios-testing-operations.md) kujifunza jinsi ya kufanya hivi.
{% endhint %}

### Uchambuzi wa Starehe wa Msingi

Inashauriwa kutumia zana [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) kufanya Uchambuzi wa Starehe wa moja kwa moja kwa faili ya IPA.

Uthibitisho wa **ulinzi uliopo kwenye binary**:

*   **PIE (Position Independent Executable)**: Ikiwa imewezeshwa, programu inapakia kwenye anwani ya kumbukumbu ya kubahatisha kila wakati inapoanzishwa, ikifanya iwe ngumu kutabiri anwani yake ya kumbukumbu ya awali.

```bash
otool -hv <app-binary> | grep PIE   # Inapaswa kujumuisha bendera ya PIE
```
*   **Stack Canaries**: Kuthibitisha uadilifu wa steki, thamani ya 'canary' hutiwa kwenye steki kabla ya kuita kazi na kuthibitishwa tena mara tu kazi inapomalizika.

```bash
otool -I -v <app-binary> | grep stack_chk   # Inapaswa kujumuisha alama: stack_chk_guard na stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Kuzuia kasoro za kawaida za uharibifu wa kumbukumbu

```bash
otool -I -v <app-binary> | grep objc_release   # Inapaswa kujumuisha alama ya _objc_release
```
*   **Binary Iliyofichwa**: Binary inapaswa kuwa imefichwa

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid inapaswa kuwa 1
```

**Uthibitisho wa Kazi Zenye Hisia/Zisizo Salama**

*   **Algorithms Dhaifu za Hashing**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Kwenye linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Kazi Dhaifu za Random**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Kwenye linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Kazi ya 'Malloc' Isiyokuwa Salama**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_malloc"

# Kwenye linux
grep -iER "_malloc"
```
*   **Kazi Zisizo Salama na Zenye Madoa**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Kwenye linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Uchambuzi wa Kisasa wa Msingi

Angalia uchambuzi wa kisasa ambao [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) hufanya. Utahitaji kutembea kupitia maoni tofauti na kuingiliana nao lakini itakuwa ikishikilia darasa kadhaa na kufanya mambo mengine na itakuandaa ripoti mara utakapomaliza.

### Orodha ya Programu Zilizowekwa

Tumia amri `frida-ps -Uai` kubaini **kitambulisho cha pakiti** cha programu zilizowekwa:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Uchambuzi wa Msingi & Hooking

Jifunze jinsi ya **kuchambua vipengele vya programu** na jinsi ya **kuunganisha njia na madarasa** kwa urahisi na objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Muundo wa IPA

Muundo wa faili ya **IPA** ni kimsingi kama wa **paki iliyozipwa**. Kwa kubadilisha kipengee chake kuwa `.zip`, inaweza **kufunguliwa** ili kuonyesha maudhui yake. Ndani ya muundo huu, **Bundle** inawakilisha programu kamili tayari kwa usakinishaji. Ndani yake, utapata saraka iliyoitwa `<JINA>.app`, ambayo inaleta pamoja rasilimali za programu.

* **`Info.plist`**: Faili hii inashikilia maelezo maalum ya usanidi wa programu.
* **`_CodeSignature/`**: Saraka hii inajumuisha faili ya plist ambayo ina saini, ikidhibitisha uadilifu wa faili zote katika bundle.
* **`Assets.car`**: Hifadhi iliyozipwa inayohifadhi faili za mali kama vile icons.
* **`Frameworks/`**: Saraka hii ina maktaba za asili za programu, ambazo zinaweza kuwa katika mfumo wa faili za `.dylib` au `.framework`.
* **`PlugIns/`**: Hii inaweza kujumuisha nyongeza za programu, inayojulikana kama faili za `.appex`, ingawa mara nyingi hazipo.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Inatumika kuhifadhi data ya kudumu ya programu yako kwa matumizi nje ya mtandao, kuhifadhi data ya muda, na kuongeza uwezo wa kufuta hatua kwenye programu yako kwenye kifaa kimoja. Ili kusawazisha data kwenye vifaa vingi katika akaunti moja ya iCloud, Core Data inaiga schema yako kiotomatiki kwenye chombo cha CloudKit.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Faili ya `PkgInfo` ni njia mbadala ya kutaja aina na waumbaji wa programu au bundle yako.
* **en.lproj, fr.proj, Base.lproj**: Ni pakiti za lugha zinazohifadhi rasilimali kwa lugha hizo maalum, na rasilimali ya msingi ikiwa lugha fulani haitegemezwi.
* **Usalama**: Saraka ya `_CodeSignature/` inacheza jukumu muhimu katika usalama wa programu kwa kudhibitisha uadilifu wa faili zote zilizofungwa kupitia saini za kidijitali.
* **Usimamizi wa Mali**: Faili ya `Assets.car` hutumia ujazo kusimamia mali za kielelezo kwa ufanisi, muhimu kwa kuboresha utendaji wa programu na kupunguza ukubwa wake jumla.
* **Mfumo wa Tabaka na Nyongeza**: Saraka hizi zinaonyesha modularity ya programu za iOS, ikiruhusu watengenezaji kuongeza maktaba za namna ya kutumika tena (`Frameworks/`) na kuongeza uwezo wa programu (`PlugIns/`).
* **Ulokishaji**: Muundo unaweza kusaidia lugha nyingi, ikirahisisha kufikia programu kimataifa kwa kujumuisha rasilimali kwa pakiti za lugha maalum.

**Info.plist**

**Info.plist** inatumika kama msingi wa programu za iOS, ikijumuisha data muhimu ya usanidi kwa mfumo wa **jozi za funguo-na-thamani**. Faili hii ni lazima si tu kwa programu bali pia kwa nyongeza za programu na maktaba zilizojumuishwa ndani. Imeandikwa kwa muundo wa XML au muundo wa binary na inashikilia taarifa muhimu kutoka kwa ruhusa za programu hadi usanidi wa usalama. Kwa uchunguzi wa kina wa funguo zilizopo, mtu anaweza kurejelea [**Hati ya Maendeleo ya Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Kwa wale wanaotaka kufanya kazi na faili hii kwa muundo unaoweza kupatikana zaidi, uongofu wa XML unaweza kupatikana kwa urahisi kupitia matumizi ya `plutil` kwenye macOS (inapatikana kiasili kwenye toleo 10.2 na baadaye) au `plistutil` kwenye Linux. Amri za uongofu ni kama ifuatavyo:

* **Kwa macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Kwa Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Miongoni mwa wingi wa habari ambazo faili ya **Info.plist** inaweza kufichua, vipengele muhimu ni pamoja na maneno ya ruhusa za programu (`UsageDescription`), mipango ya URL za desturi (`CFBundleURLTypes`), na mipangilio ya Usalama wa Usafirishaji wa Programu (`NSAppTransportSecurity`). Vipengele hivi, pamoja na vingine kama vile aina za hati za nyaraka za desturi zilizosafirishwa/kuingizwa (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), vinaweza kupatikana kwa urahisi kwa kuchunguza faili au kutumia amri ya `grep` rahisi:
```bash
$ grep -i <keyword> Info.plist
```
**Njia za Data**

Katika mazingira ya iOS, directories zinatengwa kwa **maombi ya mfumo** na **maombi yaliyowekwa na mtumiaji**. Maombi ya mfumo yanapatikana katika directory ya `/Applications`, wakati maombi yaliyowekwa na mtumiaji hupangwa chini ya `/var/mobile/containers/Data/Application/`. Maombi haya hupewa kitambulisho cha kipekee kinachoitwa **128-bit UUID**, hivyo kufanya kazi ya kutafuta folda ya programu kwa mkono kuwa ngumu kutokana na uchanganyikaji wa majina ya directory.

{% hint style="warning" %}
Kwa kuwa maombi katika iOS lazima yawe ndani ya sanduku la mchanga, kila programu itakuwa na folda pia ndani ya **`$HOME/Library/Containers`**  yenye **`CFBundleIdentifier`** ya programu kama jina la folda.

Hata hivyo, folda zote (data & folda za kontena) zina faili ya **`.com.apple.mobile_container_manager.metadata.plist`** ambayo inaunganisha faili zote katika ufunguo `MCMetadataIdentifier`).
{% endhint %}

Ili kurahisisha ugunduzi wa directory ya usanidi wa programu iliyowekwa na mtumiaji, zana ya **objection** hutoa amri muhimu, `env`. Amri hii inaonyesha habari za kina za directory kwa programu husika. Hapa chini ni mfano wa jinsi ya kutumia amri hii:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Au kwa upande mwingine, jina la programu linaweza kutafutwa ndani ya `/private/var/containers` kwa kutumia amri ya `find`:
```bash
find /private/var/containers -name "Progname*"
```
Amri kama vile `ps` na `lsof` pia zinaweza kutumika kutambua mchakato wa programu na orodha ya faili zilizofunguliwa, mtawalia, zikitoa ufahamu katika njia za saraka za aktiva za programu:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Folda ya Bundle:**

* **AppName.app**
* Hii ni Bundle ya Maombi kama ilivyoonekana awali katika IPA, ina data muhimu ya maombi, yaliyomo ya msingi pamoja na binary iliyokompiliwa ya maombi.
* Folda hii inaonekana kwa watumiaji, lakini **watumiaji hawawezi kuandika humo**.
* Yaliyomo katika folda hii hayana **nakala rudufu**.
* Yaliyomo katika folda hii hutumiwa kwa **uthibitisho wa saini ya nambari**.

**Folda ya Data:**

* **Documents/**
* Ina data yote iliyoanzishwa na mtumiaji. Mtumiaji wa mwisho wa maombi ndiye anayeanzisha uundaji wa data hii.
* Inaonekana kwa watumiaji na **watumiaji wanaweza kuandika humo**.
* Yaliyomo katika folda hii yana **nakala rudufu**.
* Maombi yanaweza kulemaza njia kwa kuweka `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Ina **faili zote ambazo si za mtumiaji fulani**, kama **cache**, **mapendeleo**, **vidakuzi**, na faili za usanidi wa orodha ya mali (plist).
* Programu za iOS kawaida hutumia vijisehemu vya `Application Support` na `Caches`, lakini programu inaweza kuunda vijisehemu vya desturi.
* **Library/Caches/**
* Ina **faili zilizohifadhiwa kwa muda mrefu.**
* Haionekani kwa watumiaji na **watumiaji hawawezi kuandika humo**.
* Yaliyomo katika folda hii hayana **nakala rudufu**.
* OS inaweza kufuta faili za folda hii moja kwa moja wakati maombi hayapo na nafasi ya kuhifadhi inapungua.
* **Library/Application Support/**
* Ina **faili za** **kudumu** zinazohitajika kwa ajili ya kuendesha maombi.
* **Haionekani** **na** **watumiaji** na watumiaji hawawezi kuandika humo.
* Yaliyomo katika folda hii ina **nakala rudufu**.
* Maombi yanaweza kulemaza njia kwa kuweka `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Hutumiwa kuhifadhi mali ambazo zinaweza **kudumu hata baada ya maombi kuanzishwa upya**.
* Taarifa hii huokolewa, bila kufichuliwa, ndani ya sanduku la maombi katika faili ya plist iliyoitwa \[BUNDLE\_ID].plist.
* Vifunguo/vilishi vyote vilivyohifadhiwa kwa kutumia `NSUserDefaults` vinaweza kupatikana katika faili hii.
* **tmp/**
* Tumia folda hii kuandika **faili za muda** ambazo hazihitaji kudumu kati ya kuzinduliwa upya kwa maombi.
* Ina faili zilizohifadhiwa kwa muda mfupi.
* **Haionekani** kwa watumiaji.
* Yaliyomo katika folda hii hayana nakala rudufu.
* OS inaweza kufuta faili za folda hii moja kwa moja wakati maombi hayapo na nafasi ya kuhifadhi inapungua.

Hebu tuangalie kwa karibu Folda ya Maombi ya iGoat-Swift (.app) ndani ya folda ya Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Kubadilisha Binary

Ndani ya folda ya `<jina-la-programu>.app` utapata faili ya binary inayoitwa `<jina-la-programu>`. Hii ndio faili itakayotekelezwa. Unaweza kufanya ukaguzi wa msingi wa binary hiyo kwa kutumia zana ya **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Angalia kama programu imefichwa**

Angalia kama kuna matokeo ya:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Kuvunja sehemu ya binary**

Vunja sehemu ya maandishi:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Kuchapisha **sehemu ya Objective-C** ya programu ya sampuli mtu anaweza kutumia:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Ili kupata msimbo wa Objective-C uliofupishwa zaidi unaweza kutumia [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Hata hivyo, chaguo bora la kuchambua faili ya binary ni: [**Hopper**](https://www.hopperapp.com/download.html?) na [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) kujenga na **kutumia mifumo ya kiotomatiki** inayotumia zana za jamii ya **juu zaidi** ulimwenguni.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Uhifadhi wa Data

Ili kujifunza jinsi iOS inavyohifadhi data kwenye kifaa soma ukurasa huu:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Maeneo yafuatayo ya kuhifadhi habari yanapaswa kuchunguzwa **mara baada ya kusakinisha programu**, **baada ya kuangalia kazi zote** za programu na hata baada ya **kutoka kwa mtumiaji mmoja na kuingia kwa mwingine**.\
Lengo ni kupata **habari nyeti zisizolindwa** za programu (nywila, tokeni), ya mtumiaji wa sasa na wa watumiaji waliowahi kuingia awali.
{% endhint %}

### Plist

Faili za **plist** ni faili za XML zilizo na **jozi za funguo-na-thamani**. Ni njia ya kuhifadhi data endelevu, kwa hivyo mara nyingi unaweza kupata **habari nyeti katika faili hizi**. Inashauriwa kuchunguza faili hizi baada ya kusakinisha programu na baada ya kutumia kwa kiasi kikubwa kuona ikiwa data mpya imeandikwa.

Njia ya kawaida zaidi ya kuhifadhi data katika faili za plist ni kupitia matumizi ya **NSUserDefaults**. Faili hii ya plist hufutwa ndani ya sanduku la programu katika **`Library/Preferences/<appBundleID>.plist`**

Darasa la [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) hutoa kiolesura cha programu kwa kuingiliana na mfumo wa chaguo-msingi. Mfumo wa chaguo-msingi huruhusu programu kubadilisha tabia yake kulingana na **mapendeleo ya mtumiaji**. Data iliyohifadhiwa na `NSUserDefaults` inaweza kuonekana katika sanduku la programu. Darasa hili hifadhi **data** katika **faili ya plist**, lakini inakusudiwa kutumika na kiasi kidogo cha data.

Data hii haiwezi kupatikana moja kwa moja kupitia kompyuta iliyothibitishwa, lakini inaweza kupatikana kwa kufanya **chelezo**.

Unaweza **kudondosha** habari iliyohifadhiwa kwa kutumia **`NSUserDefaults`** kwa kutumia `ios nsuserdefaults get` ya objection.

Ili kupata plist zote zinazotumiwa na programu unaweza kupata `/private/var/mobile/Containers/Data/Application/{APPID}` na kukimbia:
```bash
find ./ -name "*.plist"
```
Kubadilisha faili kutoka **muundo wa XML au binary (bplist)** kwenda XML, njia mbalimbali zinapatikana kulingana na mfumo wako wa uendeshaji:

**Kwa Watumiaji wa macOS:** Tumia amri ya `plutil`. Ni chombo kilichojengwa ndani ya macOS (10.2+), kimeundwa kwa kusudi hili:
```bash
$ plutil -convert xml1 Info.plist
```
**Kwa Watumiaji wa Linux:** Sakinisha `libplist-utils` kwanza, kisha tumia `plistutil` kubadilisha faili yako:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Ndani ya Kikao cha Objection:** Kwa kuchambua programu za simu, amri maalum inaruhusu kubadilisha faili za plist moja kwa moja:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) ni mfumo wa kusimamia safu ya mfano wa vitu katika programu yako. [Core Data inaweza kutumia SQLite kama hifadhi yake endelevu](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), lakini mfumo yenyewe si database. CoreData haitumii usimbaji wa data kwa chaguo-msingi. Hata hivyo, safu ya usimbaji wa ziada inaweza kuongezwa kwa CoreData. Angalia [GitHub Repo](https://github.com/project-imas/encrypted-core-data) kwa maelezo zaidi.

Unaweza kupata habari ya SQLite Core Data ya programu katika njia `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Ikiwa unaweza kufungua SQLite na kupata habari nyeti, basi umepata hitilafu ya usanidi.**
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) ni duka la data la funguo/thamani lililojengwa juu ya SQLite.\
Kwa kuwa mabara ya Yap ni mabara ya sqlite unaweza kuyapata kwa kutumia amri iliyopendekezwa katika sehemu iliyopita.

### Mabara Mengine ya SQLite

Ni kawaida kwa programu kuunda mabara yao wenyewe ya sqlite. Wanaweza **kuhifadhi** **data** **nyeti** ndani yao na kuiacha bila kusimbwa. Hivyo, ni vyema daima kuchunguza kila bara ndani ya saraka ya programu. Hivyo nenda kwenye saraka ya programu ambapo data inahifadhiwa (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Maudhui halisi ya Firebase Real-Time Databases

Wabunifu wanaweza **kuhifadhi na kusawazisha data** ndani ya **database iliyohifadhiwa kwenye wingu bila muundo** kupitia Firebase Real-Time Databases. Data inahifadhiwa kwa muundo wa JSON, na data hiyo hufanyiwa usawazishaji kwa wateja wote waliounganishwa kwa wakati halisi.

Unaweza kupata jinsi ya kuchunguza mabara ya Firebase yaliyopangwa vibaya hapa:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Mabara ya Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) na [Realm Swift](https://realm.io/docs/swift/latest/) hutoa mbadala yenye nguvu kwa uhifadhi wa data, ambao hautoiwa na Apple. Kwa chaguo-msingi, wanahifadhi data bila kufichuliwa, na ufichaji upatikana kupitia usanidi maalum.

Mabara hayo yako katika: `/private/var/mobile/Containers/Data/Application/{APPID}`. Kuchunguza faili hizi, mtu anaweza kutumia amri kama:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Kwa kuangalia faili hizi za database, zana ya [**Realm Studio**](https://github.com/realm/realm-studio) inapendekezwa.

Kutekeleza encryption ndani ya database ya Realm, unaweza kutumia msururu wa nambari ufuatao:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Databases za Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) inaelezwa kama injini ya **database** iliyo **nyepesi** na iliyo **ingizwa** inayofuata njia ya **kuandika nyaraka** (NoSQL). Imetengenezwa kuwa ya asili kwa **iOS** na **macOS**, inatoa uwezo wa kusawazisha data kwa urahisi.

Ili kutambua databases za Couchbase zilizopo kwenye kifaa, directory ifuatayo inapaswa kukaguliwa:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Vidakuzi

iOS hifadhi vidakuzi vya programu katika **`Library/Cookies/cookies.binarycookies`** ndani ya folda ya kila programu. Hata hivyo, waendelezaji mara kwa mara huchagua kuziweka katika **keychain** kwa sababu **faili ya kuki iliyotajwa inaweza kupatikana katika nakala rudufu**.

Ili kukagua faili za vidakuzi unaweza kutumia [**script hii ya python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) au tumia **`ios cookies get`** ya objection.\
**Pia unaweza kutumia objection** kubadilisha faili hizi kuwa muundo wa JSON na kukagua data.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Kache

Kwa chaguo-msingi, NSURLSession hifadhi data, kama vile **maombi na majibu ya HTTP katika database ya Cache.db**. Hii database inaweza kuwa na **data nyeti**, ikiwa vitufe, majina ya watumiaji au habari nyeti nyingine imehifadhiwa. Ili kupata habari iliyohifadhiwa fungua saraka ya data ya programu (`/var/mobile/Containers/Data/Application/<UUID>`) na nenda kwenye `/Library/Caches/<Bundle Identifier>`. **Kache ya WebKit pia inahifadhiwa katika faili ya Cache.db**. **Objection** inaweza kufungua na kuingiliana na database kwa amri `sqlite connect Cache.db`, kwani ni **database ya SQLite ya kawaida**.

Ni **inashauriwa kulemaza Kache ya data hii**, kwani inaweza kuwa na habari nyeti katika ombi au majibu. Orodha ifuatayo inaonyesha njia tofauti za kufanikisha hili:

1.  Inashauriwa kuondoa majibu yaliyohifadhiwa baada ya kujiondoa. Hii inaweza kufanywa na njia iliyotolewa na Apple inayoitwa [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) Unaweza kuita njia hii kama ifuatavyo:

`URLCache.shared.removeAllCachedResponses()`

Njia hii itaondoa maombi yote yaliyohifadhiwa na majibu kutoka kwenye faili ya Cache.db.
2.  Ikiwa hauitaji kutumia faida ya vidakuzi inashauriwa kutumia tu mali ya usanidi ya [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) ya URLSession, ambayo italemaza kuokoa vidakuzi na Kache.

[Hati ya Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Kitu cha usanidi wa kikao cha muda mfupi ni sawa na usanidi wa kikao wa chaguo-msingi (angalia chaguo-msingi), isipokuwa kwamba kikao kinacholingana hakiweki kache, hifadhi za uthibitisho, au data yoyote inayohusiana na kikao kwenye diski. Badala yake, data inayohusiana na kikao inahifadhiwa kwenye RAM. Wakati pekee kikao cha muda mfupi kinapoandika data kwenye diski ni wakati unapomwambia aandike maudhui ya URL kwenye faili.`
3. Kache inaweza pia kulemazwa kwa kuweka Sera ya Kache kuwa [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Italemaza kuhifadhi Kache kwa njia yoyote, iwe kwenye kumbukumbu au kwenye diski.

### Vipande vya Skrini

Kila unapobonyeza kitufe cha nyumbani, iOS **inachukua kipande cha skrini ya sasa** ili kuweza kufanya mpito kwenye programu kwa njia laini zaidi. Walakini, ikiwa **data nyeti** iko kwenye skrini ya sasa, itahifadhiwa kwenye **picha** (ambayo **inaendelea** **hata** **baada** **ya** **kuzima**). Hizi ni vipande vya skrini ambavyo unaweza pia kufikia kwa kubonyeza mara mbili skrini ya nyumbani ili kubadilisha programu.

Isipokuwa iPhone imefunguliwa, **mshambuliaji** anahitaji kuwa na **upatikanaji** wa **kifaa** **bila** **kizuizi** ili kuona picha hizi. Kwa chaguo-msingi kipande cha skrini cha mwisho kimehifadhiwa kwenye sanduku la programu katika `Library/Caches/Snapshots/` au saraka ya `Library/SplashBoard/Snapshots` (kompyuta za kuaminika haziwezi kupata mfumo wa faili kutoka iOX 7.0).

Njia moja ya kuzuia tabia hii mbaya ni kuweka skrini tupu au kuondoa data nyeti kabla ya kuchukua kipande cha skrini kwa kutumia kazi ya `ApplicationDidEnterBackground()`.

Hapa chini ni mfano wa njia ya kurekebisha ambayo itaweka picha ya skrini ya chaguo-msingi.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Lengo-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Hii inaweka picha ya mandharinyuma kuwa `overlayImage.png` wakati programu inapokuwa nyuma. Inazuia uvujaji wa data nyeti kwa sababu `overlayImage.png` itachukua nafasi ya maoni ya sasa.

### Keychain

Kwa kupata na kusimamia keychain ya iOS, zana kama [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) zinapatikana, zinazofaa kwa vifaa vilivyovunjwa. Kwa kuongezea, [**Objection**](https://github.com/sensepost/objection) hutoa amri `ios keychain dump` kwa madhumuni sawa.

#### **Kuhifadhi Sifa**

Darasa la **NSURLCredential** ni bora kwa kuhifadhi habari nyeti moja kwa moja kwenye keychain, ikipuuza haja ya NSUserDefaults au vifungashio vingine. Kuhifadhi sifa baada ya kuingia, nambari ifuatayo ya Swift hutumiwa:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
## **Vidakuzi vilivyohifadhiwa na Cache ya Kibodi ya Kibodi ya Kibodi**

Kuanzia iOS 8.0 kuendelea, watumiaji wanaweza kusakinisha nyongeza za kibodi za kawaida, ambazo zinaweza kusimamiwa chini ya **Vipimo > Jumla > Kibodi > Kibodi**. Ingawa kibodi hizi zinatoa utendaji mpana, zinaweza kuleta hatari ya kurekodi tarakilishi na kutuma data kwa seva za nje, ingawa watumiaji huarifiwa kuhusu kibodi zinazohitaji ufikivu wa mtandao. Programu zinaweza, na zinapaswa, kuzuia matumizi ya kibodi za kawaida kwa kuingiza habari nyeti.

**Mapendekezo ya Usalama:**

* Inashauriwa kulemaza kibodi za mtu wa tatu kwa usalama bora.
* Kuwa makini na vipengele vya kurekebisha moja kwa moja na mapendekezo ya moja kwa moja ya kibodi ya msingi ya iOS, ambayo yanaweza kuhifadhi habari nyeti katika faili za cache zilizoko katika `Library/Keyboard/{eneo}-dynamic-text.dat` au `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Faili hizi za cache zinapaswa kuangaliwa mara kwa mara kwa data nyeti. Kuweka upya kamusi ya kibodi kupitia **Vipimo > Jumla > Rudisha > Rudisha Kamusi ya Kibodi** inapendekezwa kwa kusafisha data iliyohifadhiwa.
* Kukamata trafiki ya mtandao kunaweza kufichua ikiwa kibodi ya kawaida inatuma tarakilishi kijijini.

### **Kuzuia Kuhifadhiwa kwa Uga wa Maandishi**

Itifaki ya [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) inatoa mali za kusimamia marekebisho ya moja kwa moja na kuingiza maandishi salama, muhimu kwa kuzuia kuhifadhiwa kwa habari nyeti. Kwa mfano, kulemaza marekebisho ya moja kwa moja na kuwezesha kuingiza maandishi salama kunaweza kufikiwa na:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Kwa kuongezea, waendelezaji wanapaswa kuhakikisha kuwa maeneo ya maandishi, hasa yale ya kuingiza habari nyeti kama nywila na PIN, yanalemaza uwekaji wa cache kwa kuweka `autocorrectionType` kuwa `UITextAutocorrectionTypeNo` na `secureTextEntry` kuwa `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Kumbukumbu**

Kutatua hitilafu za nambari mara nyingi hujumuisha matumizi ya **kumbukumbu**. Kuna hatari kwani **kumbukumbu zinaweza kuwa na habari nyeti**. Awali, katika iOS 6 na toleo za awali, kumbukumbu zilikuwa zinapatikana kwa programu zote, ikileta hatari ya kuvuja kwa data nyeti. **Sasa, programu zimeruhusiwa kufikia kumbukumbu zao pekee**.

Licha ya vizuizi hivi, **mshambuliaji mwenye ufikivu wa kimwili** kwa kifaa kilichofunguliwa bado anaweza kutumia hili kwa kuunganisha kifaa kwenye kompyuta na **kusoma kumbukumbu**. Ni muhimu kutambua kwamba kumbukumbu zinabaki kwenye diski hata baada ya programu kuondolewa.

Ili kupunguza hatari, inashauriwa **kuingiliana kikamilifu na programu**, kuchunguza kwa undani kazi zake zote na matokeo yake ili kuhakikisha hakuna habari nyeti inalogwa kwa bahati mbaya.

Unapopitia nambari ya chanzo cha programu kwa kuvuja kwa uwezekano, tafuta **maelezo ya kumbukumbu yaliyowekwa mapema** na **maelezo ya kumbukumbu ya desturi** kwa kutumia maneno kama vile `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` kwa kazi zilizojengwa, na maelezo yoyote ya `Logging` au `Logfile` kwa utekelezaji wa desturi.

### **Kufuatilia Kumbukumbu za Mfumo**

Programu huloga vipande mbalimbali vya habari ambavyo vinaweza kuwa nyeti. Ili kufuatilia kumbukumbu hizi, zana na amri kama:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
Ni muhimu. Kwa kuongezea, **Xcode** hutoa njia ya kukusanya magogo ya konsoli:

1. Fungua Xcode.
2. Unganisha kifaa cha iOS.
3. Nenda kwa **Window** -> **Vifaa na Vifaa vya Uigaji**.
4. Chagua kifaa chako.
5. Chochote kisababishacho tatizo unalochunguza.
6. Tumia kitufe cha **Fungua Konsoli** kuona magogo kwenye dirisha jipya.

Kwa kuingiza magogo kwa kiwango cha juu zaidi, kuunganisha kwa ganda la kifaa na kutumia **socat** inaweza kutoa ufuatiliaji wa magogo halisi kwa wakati halisi:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Kufuatia amri za kuchunguza shughuli za kuingia, ambazo zinaweza kuwa muhimu kwa kutambua matatizo au kutambua uwezekano wa uvujaji wa data katika magogo.

***

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) kujenga na **kutumia mchakato** kwa urahisi uliosukumwa na zana za jamii za **juu zaidi** duniani.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Nakala za Usalama

**Vipengele vya kiotomatiki vya nakala za usalama** vimejumuishwa katika iOS, kurahisisha uundaji wa nakala za data za kifaa kupitia iTunes (hadi macOS Catalina), Finder (kuanzia macOS Catalina kuendelea), au iCloud. Nakala hizi za usalama zinajumuisha karibu data yote ya kifaa, isipokuwa vipengele vyenye hisia kali kama maelezo ya Apple Pay na mipangilio ya Touch ID.

### Hatari za Usalama

Kujumuisha **programu zilizosanikishwa na data zao** katika nakala za usalama kunazua suala la **uvujaji wa data** na hatari kwamba **marekebisho ya nakala za usalama yanaweza kubadilisha utendaji wa programu**. Inashauriwa **kutosha data nyeti kwa wazi** ndani ya saraka yoyote ya programu au saraka zake za sekondari ili kupunguza hatari hizi.

### Kutoa Pasi za Nakala za Usalama

Faili katika `Documents/` na `Library/Application Support/` zinanakiliwa kwa chaguo-msingi. Watengenezaji wanaweza kutoa faili au saraka maalum kutoka kwa nakala za usalama kwa kutumia `NSURL setResourceValue:forKey:error:` na `NSURLIsExcludedFromBackupKey`. Mazoea haya ni muhimu kwa kulinda data nyeti isijumuishwe katika nakala za usalama.

### Kupima Kwa Mapungufu ya Usalama

Kutathmini usalama wa nakala za programu, anza kwa **kuunda nakala ya usalama** kwa kutumia Finder, kisha ipate kwa kufuata mwongozo kutoka [hati ya rasmi ya Apple](https://support.apple.com/en-us/HT204215). Changanya nakala ya usalama kwa data nyeti au mipangilio ambayo inaweza kubadilishwa kwa kudhuru utendaji wa programu.

Taarifa nyeti inaweza kutafutwa kwa kutumia zana za mstari wa amri au programu kama [iMazing](https://imazing.com). Kwa nakala za usalama zilizo na nenosiri, uwepo wa kificho cha siri unaweza kuthibitishwa kwa kuangalia kifunguo cha "IsEncrypted" katika faili ya "Manifest.plist" kwenye mzizi wa nakala ya usalama.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Kwa kushughulikia nakala rudufu zilizo na usimbaji, hati za Python zinapatikana kwenye [repo ya GitHub ya DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), kama vile **backup\_tool.py** na **backup\_passwd.py**, zinaweza kuwa na manufaa, ingawa inaweza kuhitaji marekebisho kwa utangamano na toleo jipya la iTunes/Finder. Zana ya [**iOSbackup**](https://pypi.org/project/iOSbackup/) ni chaguo lingine la kupata faili ndani ya nakala rudufu zilizolindwa kwa nenosiri.

### Kubadilisha Tabia ya Programu

Mfano wa kubadilisha tabia ya programu kupitia marekebisho ya nakala rudufu unaonyeshwa katika programu ya mkoba wa bitcoin ya [Bither](https://github.com/bither/bither-ios), ambapo PIN ya kufunga UI imehifadhiwa ndani ya `net.bither.plist` chini ya ufunguo wa **pin\_code**. Kuondoa ufunguo huu kutoka kwa plist na kurejesha nakala rudufu kunatoa mahitaji ya PIN, ikitoa ufikiaji usiozuiliwa.

## Muhtasari wa Ukaguzi wa Kumbukumbu kwa Data Nyeti

Kuwa na kumbukumbu nyeti iliyohifadhiwa katika kumbukumbu ya programu, ni muhimu kupunguza muda wa kufichua data hii. Kuna njia mbili kuu za kuchunguza maudhui ya kumbukumbu: **kuunda nakala ya kumbukumbu** na **kuchambua kumbukumbu wakati halisi**. Njia zote zina changamoto zao, ikiwa ni pamoja na uwezekano wa kukosa data muhimu wakati wa mchakato wa nakala au uchambuzi.

## **Kupata na Kuchambua Nakala ya Kumbukumbu**

Kwa vifaa vilivyovunjwa na visivyovunjwa, zana kama [objection](https://github.com/sensepost/objection) na [Fridump](https://github.com/Nightbringer21/fridump) huruhusu kufanya nakala ya kumbukumbu ya mchakato wa programu. Mara baada ya kufanya nakala, kuchambua data hii kunahitaji zana mbalimbali, kulingana na asili ya habari unayotafuta.

Kuondoa maneno kutoka kwa nakala ya kumbukumbu, amri kama vile `strings` au `rabin2 -zz` zinaweza kutumika:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Kwa uchambuzi wa kina zaidi, ikiwa ni pamoja na kutafuta aina maalum za data au mifano, **radare2** inatoa uwezo mkubwa wa kutafuta:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Uchambuzi wa Kumbukumbu ya Wakati wa Uendeshaji**

**r2frida** hutoa mbadala hodari kwa ukaguzi wa kumbukumbu ya programu kwa wakati halisi, bila haja ya kumbukumbu ya kumbukumbu. Zana hii inawezesha utekelezaji wa amri za utafutaji moja kwa moja kwenye kumbukumbu ya programu inayoendeshwa:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Ufichuzi wa Cryptography

### Mchakato Duni wa Usimamizi wa Funguo

Baadhi ya watengenezaji huficha data nyeti kwenye hifadhi ya ndani na kuiweka kwenye funguo zilizowekwa/kutabirika kwenye nambari. Hii haipaswi kufanywa kwani baadhi ya kugeuza inaweza kuruhusu wachomaji kutoa habari za siri.

### Matumizi ya Algorithms Zisizo Salama na/au Zilizopitwa na Wakati

Watengenezaji hawapaswi kutumia **algorithms zilizopitwa na wakati** kufanya **uchunguzi wa idhini**, **kuhifadhi** au **kupeleka** data. Baadhi ya algorithms hizi ni: RC4, MD4, MD5, SHA1... Ikiwa **hashes** hutumiwa kuhifadhi nywila kwa mfano, hashes zenye upinzani dhidi ya nguvu za brute zinapaswa kutumika na chumvi.

### Ukaguzi

Ukaguzi muhimu wa kufanya ni kujaribu kupata nywila/siri zilizowekwa kwenye nambari, au ikiwa hizo ni **zilizotabirika**, na ikiwa nambari inatumia aina fulani ya algorithms za **cryptography** **dhaifu**.

Ni ya kuvutia kujua kwamba unaweza **kuangalia** baadhi ya **maktaba za crypto** kiotomatiki kwa kutumia **objection** na:
```swift
ios monitor crypt
```
Kwa **maelezo zaidi** kuhusu APIs na maktaba za kriptografia za iOS tembelea [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Uthibitishaji wa Kienyeji

**Uthibitishaji wa kienyeji** unacheza jukumu muhimu, hasa linapohusu kulinda ufikiaji kwenye mwisho wa mbali kupitia njia za kriptografia. Kiini hapa ni kwamba bila utekelezaji sahihi, mifumo ya uthibitishaji wa kienyeji inaweza kuzungukwa.

[**Mfumo wa Uthibitishaji wa Kienyeji**](https://developer.apple.com/documentation/localauthentication) wa Apple na [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) hutoa APIs imara kwa watengenezaji kurahisisha mazungumzo ya uthibitishaji wa mtumiaji na kushughulikia kwa usalama data za siri, mtawalia. Enclave Salama inalinda kitambulisho cha kidole kwa Touch ID, wakati Face ID inategemea kutambua uso bila kuhatarisha data ya kibaiometriki.

Kuongeza Touch ID/Face ID, watengenezaji wana chaguo la API mbili:

* **`LocalAuthentication.framework`** kwa uthibitishaji wa mtumiaji wa kiwango cha juu bila ufikiaji wa data za kibaiometriki.
* **`Security.framework`** kwa ufikiaji wa huduma za keychain za kiwango cha chini, kulinda data za siri kwa uthibitishaji wa kibaiometriki. Vifuniko vya [chanzo wazi](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) hufanya ufikiaji wa keychain kuwa rahisi.

{% hint style="danger" %}
Hata hivyo, `LocalAuthentication.framework` na `Security.framework` wanaweza kuwa na mapungufu, kwani kimsingi hurudisha thamani za boolean bila kuhamisha data kwa mchakato wa uthibitishaji, hivyo kuwafanya kuwa rahisi kuzungukwa (rejea [Usiniguse hivyo, na David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Kutekeleza Uthibitishaji wa Kienyeji

Ili kuwahimiza watumiaji kwa uthibitishaji, watengenezaji wanapaswa kutumia njia ya **`evaluatePolicy`** ndani ya darasa la **`LAContext`**, kuchagua kati ya:

* **`deviceOwnerAuthentication`**: Inahimiza Touch ID au nambari ya kifaa, ikishindwa ikiwa hakuna moja imewezeshwa.
* **`deviceOwnerAuthenticationWithBiometrics`**: Inahimiza kwa Touch ID pekee.

Uthibitishaji wa mafanikio unadhihirishwa na thamani ya kurudi ya boolean kutoka kwa **`evaluatePolicy`**, ikionyesha kasoro ya usalama inayowezekana.

### Uthibitishaji wa Kienyeji kwa Kutumia Keychain

Kutekeleza **uthibitishaji wa kienyeji** kwenye programu za iOS kunahusisha matumizi ya **keychain APIs** kuhifadhi data za siri kwa usalama kama vile vibali vya uthibitishaji. Mchakato huu unahakikisha kwamba data inaweza kupatikana tu na mtumiaji, kwa kutumia nambari yao ya kifaa au uthibitishaji wa kibaiometriki kama vile Touch ID.

Keychain inatoa uwezo wa kuweka vitu na sifa ya `SecAccessControl`, ambayo inazuia ufikiaji wa kitu hadi mtumiaji athibitishe kwa mafanikio kupitia Touch ID au nambari ya kifaa. Kipengele hiki ni muhimu kwa kuboresha usalama.

Hapa chini ni mifano ya nambari katika Swift na Objective-C inayoonyesha jinsi ya kuokoa na kupata kamba kutoka/kwenye keychain, ikiboresha vipengele hivi vya usalama. Mifano zinaonyesha kwa kina jinsi ya kuweka udhibiti wa ufikiaji ili kuhitaji uthibitishaji wa Touch ID na kuhakikisha data inapatikana tu kwenye kifaa kilichowekwa, chini ya hali kwamba nambari ya kifaa imewekwa.
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %} 
### Kupima Usalama wa Programu za iOS

Kupima usalama wa programu za iOS ni muhimu sana katika mchakato wa maendeleo ili kuhakikisha kuwa programu zako zinakuwa salama na zinazofanya kazi vizuri. Hapa kuna baadhi ya maeneo muhimu ya kuzingatia wakati wa kupima usalama wa programu za iOS:

1. **Uhakiki wa Kanuni (Code Review):** Hakiki kanuni yako kwa makini ili kutambua na kurekebisha makosa au mapungufu yoyote ambayo yanaweza kusababisha hatari za usalama.

2. **Ugunduzi wa Maudhui ya Siri (Sensitive Data Discovery):** Hakikisha kuwa data nyeti kama vile manenosiri au taarifa za malipo zinalindwa ipasavyo na hazipatikani kwa watu wasioidhinishwa.

3. **Uthibitishaji wa Upatikanaji (Access Control Verification):** Hakikisha kuwa mifumo ya uthibitishaji inafanya kazi vizuri na inazuia upatikanaji usiohalali kwa sehemu za programu ambazo hazipaswi kufikiwa.

4. **Uthibitishaji wa Maudhui (Content Validation):** Hakikisha kuwa data inayoingia katika programu yako inakaguliwa na kuthibitishwa ipasavyo ili kuzuia mashambulizi kama vile SQL injection.

Kwa kufuata maeneo haya na mbinu nyingine za kupima usalama, unaweza kuboresha usalama wa programu zako za iOS na kuepuka hatari za usalama zinazoweza kudhuru watumiaji wako. 
{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Sasa tunaweza kuomba kipengee kilichohifadhiwa kutoka kwa keychain. Huduma za keychain zitatoa dirisha la uthibitisho kwa mtumiaji na kurudisha data au nil kulingana na ikiwa alama ya vidole inayofaa ilitolewa au la.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Swahili" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### Uchunguzi

Matumizi ya fremu katika programu yanaweza pia kugunduliwa kwa kuchambua orodha ya maktaba za kushirikiana za programu ya binary. Hii inaweza kufanywa kwa kutumia `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Ikiwa `LocalAuthentication.framework` inatumika kwenye programu, matokeo yatakuwa na mistari yote mawili yafuatayo (kumbuka kwamba `LocalAuthentication.framework` inatumia `Security.framework` chini ya pazia):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
If `Security.framework` is used, only the second one will be shown.

### Kupuuza Kituo cha Uthibitishaji wa Lokali

#### **Objection**

Kupitia **Objection Biometrics Bypass**, iliyoko kwenye [ukurasa huu wa GitHub](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), mbinu inapatikana ya kuvuka mfumo wa **LocalAuthentication**. Msingi wa mbinu hii ni kutumia **Frida** kubadilisha kazi ya `evaluatePolicy`, ikihakikisha kuwa daima inatoa matokeo ya `True`, bila kujali mafanikio halisi ya uthibitishaji. Hii ni muhimu sana kwa kuzunguka michakato dhaifu ya uthibitishaji wa kibaiolojia.

Ili kuamsha kipengee hiki cha kupuuza, amri ifuatayo hutumiwa:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Hii amri inaanzisha mfululizo ambapo Objection inasajili kazi ambayo inabadilisha matokeo ya ukaguzi wa `evaluatePolicy` kuwa `True`.

#### Frida

Mfano wa matumizi ya **`evaluatePolicy`** kutoka [maombi ya DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Kufikia **kipuuzi** wa Uthibitishaji wa Kienyeji, hati ya Frida imeandikwa. Hati hii inalenga ukaguzi wa **evaluatePolicy**, ikikamata simu yake ili kuhakikisha inarudi **mafanikio=1**. Kwa kubadilisha tabia ya simu hiyo, ukaguzi wa uthibitishaji unapuuzwa kwa ufanisi.

Hati ifuatayo imeingizwa kubadilisha matokeo ya mbinu ya **evaluatePolicy**. Inabadilisha matokeo ya simu hiyo ili iashirie mafanikio daima.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Kutuma script ya Frida na kuzidisha uthibitishaji wa kibaolojia, tumia amri ifuatayo:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Kufichua Ufunuo wa Kazi Nyeti Kupitia IPC

### Wachukuaji wa URI za Desturi / Viungo vya Kina / Mipango ya Desturi

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Viungo vya Universal

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Kushiriki UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Vifaa vya Programu

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Ufananishaji na Ufichamishaji

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Mawasiliano ya Mtandao

Ni muhimu kuhakikisha kuwa hakuna mawasiliano yanayotokea **bila encryption** na pia kwamba programu inathibitisha kwa usahihi **uthibitisho wa cheti cha TLS** cha seva.\
Kutathmini masuala kama haya unaweza kutumia proksi kama **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Ukaguzi wa Jina la Mwenyeji

Moja ya shida za kawaida katika kuthibitisha cheti cha TLS ni kuhakikisha kuwa cheti kilisainiwa na **CA iliyosadikika**, lakini **kutokuchunguza** ikiwa **jina la mwenyeji** la cheti ni jina la mwenyeji linalofikiwa.\
Ili kuchunguza shida hii kwa kutumia Burp, baada ya kuamini CA ya Burp kwenye iPhone, unaweza **kuunda cheti kipya na Burp kwa jina la mwenyeji tofauti** na kulitumia. Ikiwa programu bado inafanya kazi, basi, kuna kitu kinachoweza kushambuliwa.

### Kufunga Cheti

Ikiwa programu inatumia Kufunga SSL kwa usahihi, basi programu itafanya kazi tu ikiwa cheti ni lile linalotarajiwa. Wakati wa kufanya majaribio ya programu **hii inaweza kuwa shida kwani Burp itahudumia cheti chake.**\
Ili kukiuka ulinzi huu ndani ya kifaa kilichovunjika, unaweza kusakinisha programu [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) au kusakinisha [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Unaweza pia kutumia **objection's** `ios sslpinning disable`

## Mambo Mengine

* Katika **`/System/Library`** unaweza kupata fremu zilizosakinishwa kwenye simu zinazotumiwa na programu za mfumo
* Programu zilizosakinishwa na mtumiaji kutoka kwenye Duka la App zinapatikana ndani ya **`/User/Applications`**
* Na **`/User/Library`** ina data iliyohifadhiwa na programu za kiwango cha mtumiaji
* Unaweza kupata **`/User/Library/Notes/notes.sqlite`** kusoma maelezo yaliyohifadhiwa ndani ya programu.
* Ndani ya folda ya programu iliyosakinishwa (**`/User/Applications/<APP ID>/`**) unaweza kupata faili za kuvutia:
* **`iTunesArtwork`**: Nembo inayotumiwa na programu
* **`iTunesMetadata.plist`**: Maelezo ya programu yanayotumiwa kwenye Duka la App
* **`/Library/*`**: Ina mapendeleo na cache. Katika **`/Library/Cache/Snapshots/*`** unaweza kupata picha iliyochukuliwa kwa programu kabla ya kupelekwa nyuma.

### Kupachika Moto/Kusasisha Kulazimishwa

Wabunifu wanaweza **kupachika moto kwa mbali ufungaji wa programu zao mara moja** bila kulazimika kuwasilisha tena programu kwenye Duka la App na kusubiri idhini.\
Kwa madhumuni haya kawaida hutumika [**JSPatch**](https://github.com/bang590/JSPatch)**.** Lakini kuna chaguo nyingine pia kama [Siren](https://github.com/ArtSabintsev/Siren) na [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Hii ni mbinu hatari inayoweza kutumiwa vibaya na SDK za tatu zenye nia mbaya kwa hivyo inashauriwa kuchunguza ni njia ipi inayotumiwa kwa kisasa (ikiwa ipo) na kuitathmini.** Unaweza jaribu kupakua toleo la awali la programu kwa madhumuni haya.

### Wadau wa Tatu

Changamoto kubwa ya **SDK za tatu** ni **ukosefu wa udhibiti wa kina** juu ya kazi zao. Wabunifu wanakabiliwa na uamuzi: ama kuingiza SDK na kukubali vipengele vyote vyake, ikiwa ni pamoja na mapungufu ya usalama yanayowezekana na wasiwasi wa faragha, au kutoa faida zake kabisa. Mara nyingi, wabunifu hawawezi kusasisha mapungufu ndani ya SDK hizi wenyewe. Zaidi ya hayo, wakati SDK zinapata imani ndani ya jamii, baadhi zinaweza kuanza kuwa na programu hasidi.

Huduma zinazotolewa na SDK za tatu zinaweza kujumuisha ufuatiliaji wa tabia za mtumiaji, kuonyesha matangazo, au kuboresha uzoefu wa mtumiaji. Hata hivyo, hii inaleta hatari kwani wabunifu hawawezi kuwa na ufahamu kamili wa namna kanuni inavyotekelezwa na maktaba hizi, ikiongoza kwa hatari za faragha na usalama. Ni muhimu kudhibiti habari inayoshirikiwa na huduma za tatu kwa kile kinachohitajika na kuhakikisha kuwa hakuna data nyeti inafichuliwa.

Utekelezaji wa huduma za tatu kawaida unakuja katika aina mbili: maktaba ya kujitegemea au SDK kamili. Ili kulinda faragha ya mtumiaji, data yoyote inayoshirikiwa na huduma hizi inapaswa kuwa **imetiwa siri** ili kuzuia kufichua Taarifa Binafsi Inayoweza Kutambulika (PII).

Ili kutambua maktaba ambazo programu inatumia, amri ya **`otool`** inaweza kutumika. Zana hii inapaswa kutumika dhidi ya programu na kila maktaba inayoshiriki ili kugundua maktaba zaidi.
```bash
otool -L <application_path>
```
## **Vyanzo & Vyanzo Zaidi**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Kozi ya bure ya IOS([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Toleo la Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Toleo la Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) kujenga na **kutumia workflows** kwa urahisi zaidi yaliyotumika na zana za jamii za **juu zaidi** ulimwenguni.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

<details>

<summary><strong>Jifunze AWS hacking kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi wa PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kuhack kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
