# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos **Workflows zu erstellen und zu automatisieren**, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Heute noch Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null zum Profi mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## iOS-Grundlagen

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Testumgebung

Auf dieser Seite finden Sie Informationen zum **iOS-Simulator**, **Emulatoren** und **Jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Erstanalyse

### Grundlegende iOS-Testoperationen

W√§hrend des Tests werden **mehrere Operationen vorgeschlagen** (Verbindung zum Ger√§t herstellen, Dateien lesen/schreiben/hochladen/herunterladen, einige Tools verwenden...). Wenn Sie also nicht wissen, wie Sie eine dieser Aktionen ausf√ºhren sollen, **beginnen Sie mit dem Lesen der Seite**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
F√ºr die folgenden Schritte sollte die App im Ger√§t installiert sein und die **IPA-Datei** der Anwendung bereits erhalten haben.\
Lesen Sie die Seite [Basic iOS Testing Operations](basic-ios-testing-operations.md), um zu erfahren, wie dies gemacht wird.
{% endhint %}

### Grundlegende statische Analyse

Es wird empfohlen, das Tool [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) zu verwenden, um eine automatische statische Analyse der IPA-Datei durchzuf√ºhren.

Identifizierung der **Schutzma√ünahmen, die im Bin√§rcode vorhanden sind**:

*   **PIE (Position Independent Executable)**: Wenn aktiviert, l√§dt die Anwendung bei jedem Start in eine zuf√§llige Speicheradresse, was es schwieriger macht, ihre anf√§ngliche Speicheradresse vorherzusagen.

```bash
otool -hv <app-binary> | grep PIE   # Es sollte die PIE-Flagge enthalten
```
*   **Stack Canaries**: Zur Validierung der Integrit√§t des Stacks wird vor dem Aufruf einer Funktion ein "Canary"-Wert auf den Stack gelegt und wird erneut validiert, sobald die Funktion endet.

```bash
otool -I -v <app-binary> | grep stack_chk   # Es sollte die Symbole: stack_chk_guard und stack_chk_fail enthalten
```
*   **ARC (Automatic Reference Counting)**: Zur Verhinderung h√§ufiger Speicherkorruptionsfehler

```bash
otool -I -v <app-binary> | grep objc_release   # Es sollte das Symbol _objc_release enthalten
```
*   **Verschl√ºsselter Bin√§rcode**: Der Bin√§rcode sollte verschl√ºsselt sein

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Der cryptid sollte 1 sein
```

**Identifizierung von sensiblen/unsicheren Funktionen**

*   **Schwache Hashing-Algorithmen**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Auf Linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Unsichere Zufallsfunktionen**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Auf Linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Unsichere 'Malloc'-Funktion**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_malloc"

# Auf Linux
grep -iER "_malloc"
```
*   **Unsichere und verwundbare Funktionen**

```bash
# Auf dem iOS-Ger√§t
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Auf Linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Grundlegende dynamische Analyse

Schauen Sie sich die dynamische Analyse an, die von [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) durchgef√ºhrt wird. Sie m√ºssen sich durch die verschiedenen Ansichten navigieren und mit ihnen interagieren, aber es wird mehrere Klassen anh√§ngen und andere Dinge tun und einen Bericht erstellen, sobald Sie fertig sind.

### Auflistung installierter Apps

Verwenden Sie den Befehl `frida-ps -Uai`, um den **Bundle-Identifier** der installierten Apps zu bestimmen:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Grundlegende Enumeration & Hooking

Erfahren Sie, wie Sie die **Komponenten der Anwendung aufz√§hlen** und wie Sie ganz einfach **Methoden und Klassen hooken** k√∂nnen mit objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA Struktur

Die Struktur einer **IPA-Datei** entspricht im Wesentlichen der einer **gezippten Paketdatei**. Durch Umbenennen der Dateierweiterung in `.zip` kann sie **dekomprimiert** werden, um ihren Inhalt preiszugeben. Innerhalb dieser Struktur repr√§sentiert ein **Bundle** eine vollst√§ndig verpackte Anwendung, die zur Installation bereit ist. Darin finden Sie ein Verzeichnis mit dem Namen `<NAME>.app`, das die Ressourcen der Anwendung umschlie√üt.

* **`Info.plist`**: Diese Datei enth√§lt spezifische Konfigurationsdetails der Anwendung.
* **`_CodeSignature/`**: Dieses Verzeichnis enth√§lt eine plist-Datei, die eine Signatur enth√§lt, die die Integrit√§t aller Dateien im Bundle gew√§hrleistet.
* **`Assets.car`**: Ein komprimiertes Archiv, das Asset-Dateien wie Icons speichert.
* **`Frameworks/`**: Dieser Ordner enth√§lt die nativen Bibliotheken der Anwendung, die in Form von `.dylib`- oder `.framework`-Dateien vorliegen k√∂nnen.
* **`PlugIns/`**: Dies kann Erweiterungen der Anwendung enthalten, die als `.appex`-Dateien bekannt sind, obwohl sie nicht immer vorhanden sind.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Wird verwendet, um die dauerhaften Daten Ihrer Anwendung f√ºr die Offline-Nutzung zu speichern, tempor√§re Daten zu zwischenspeichern und Ihrer App auf einem Ger√§t die M√∂glichkeit zum R√ºckg√§ngigmachen hinzuzuf√ºgen. Um Daten √ºber mehrere Ger√§te in einem iCloud-Konto zu synchronisieren, spiegelt Core Data automatisch Ihr Schema in einen CloudKit-Container.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Die `PkgInfo`-Datei ist eine alternative M√∂glichkeit, den Typ und die Ersteller-Codes Ihrer Anwendung oder Ihres Bundles anzugeben.
* **en.lproj, fr.proj, Base.lproj**: Sind die Sprachpakete, die Ressourcen f√ºr diese spezifischen Sprachen enthalten, sowie eine Standardressource f√ºr den Fall, dass eine Sprache nicht unterst√ºtzt wird.
* **Sicherheit**: Das Verzeichnis `_CodeSignature/` spielt eine entscheidende Rolle in der Sicherheit der App, indem es die Integrit√§t aller geb√ºndelten Dateien durch digitale Signaturen √ºberpr√ºft.
* **Asset-Verwaltung**: Die Datei `Assets.car` verwendet Kompression, um grafische Assets effizient zu verwalten, was f√ºr die Optimierung der Anwendungsleistung und die Reduzierung ihrer Gesamtgr√∂√üe entscheidend ist.
* **Frameworks und PlugIns**: Diese Verzeichnisse unterstreichen die Modularit√§t von iOS-Anwendungen, die es Entwicklern erm√∂glichen, wiederverwendbare Codebibliotheken (`Frameworks/`) einzuschlie√üen und die Funktionalit√§t der App zu erweitern (`PlugIns/`).
* **Lokalisierung**: Die Struktur unterst√ºtzt mehrere Sprachen und erleichtert die globale Anwendungsbereitstellung durch die Bereitstellung von Ressourcen f√ºr spezifische Sprachpakete.

**Info.plist**

Das **Info.plist** dient als Grundpfeiler f√ºr iOS-Anwendungen und umschlie√üt wichtige Konfigurationsdaten in Form von **Schl√ºssel-Wert**-Paaren. Diese Datei ist nicht nur f√ºr Anwendungen, sondern auch f√ºr App-Erweiterungen und in Bundles geb√ºndelte Frameworks erforderlich. Sie ist strukturiert in XML oder einem bin√§ren Format und enth√§lt wichtige Informationen von App-Berechtigungen bis hin zu Sicherheitskonfigurationen. F√ºr eine detaillierte Erkundung der verf√ºgbaren Schl√ºssel kann man sich an die [**Apple Developer-Dokumentation**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc) wenden.

F√ºr diejenigen, die mit dieser Datei in einem zug√§nglicheren Format arbeiten m√∂chten, kann die XML-Konvertierung m√ºhelos durch die Verwendung von `plutil` auf macOS (standardm√§√üig verf√ºgbar ab Version 10.2) oder `plistutil` auf Linux erreicht werden. Die Befehle zur Konvertierung lauten wie folgt:

* **F√ºr macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
* **F√ºr Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Unter den zahlreichen Informationen, die die **Info.plist**-Datei preisgeben kann, sind bemerkenswerte Eintr√§ge unter anderem die Berechtigungszeichenfolgen der App (`UsageDescription`), benutzerdefinierte URL-Schemas (`CFBundleURLTypes`) und Konfigurationen f√ºr die App-Transportsicherheit (`NSAppTransportSecurity`). Diese Eintr√§ge sowie andere wie exportierte/importierte benutzerdefinierte Dokumenttypen (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`) k√∂nnen m√ºhelos durch Inspektion der Datei oder durch Verwendung eines einfachen `grep`-Befehls gefunden werden:
```bash
$ grep -i <keyword> Info.plist
```
**Datenpfade**

In der iOS-Umgebung sind Verzeichnisse speziell f√ºr **Systemanwendungen** und **benutzerinstallierte Anwendungen** vorgesehen. Systemanwendungen befinden sich im Verzeichnis `/Applications`, w√§hrend benutzerinstallierte Apps unter `/var/mobile/containers/Data/Application/` platziert werden. Diese Anwendungen erhalten einen eindeutigen Bezeichner, der als **128-Bit-UUID** bekannt ist, was die manuelle Lokalisierung eines App-Ordners aufgrund der Zuf√§lligkeit der Verzeichnisnamen erschwert.

{% hint style="warning" %}
Da Anwendungen in iOS in einer Sandbox ausgef√ºhrt werden m√ºssen, wird jede App auch einen Ordner innerhalb von **`$HOME/Library/Containers`** mit dem **`CFBundleIdentifier`** der App als Ordnername haben.

Allerdings enthalten sowohl die Daten- als auch die Containerordner die Datei **`.com.apple.mobile_container_manager.metadata.plist`**, die beide Dateien im Schl√ºssel `MCMetadataIdentifier` verkn√ºpft.
{% endhint %}

Um die Entdeckung des Installationsverzeichnisses einer benutzerinstallierten App zu erleichtern, bietet das **objection tool** einen n√ºtzlichen Befehl namens `env`. Dieser Befehl zeigt detaillierte Verzeichnisinformationen f√ºr die betreffende App an. Nachfolgend ein Beispiel zur Verwendung dieses Befehls:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativ kann der App-Name mithilfe des `find`-Befehls im Verzeichnis `/private/var/containers` gesucht werden:
```bash
find /private/var/containers -name "Progname*"
```
Befehle wie `ps` und `lsof` k√∂nnen ebenfalls verwendet werden, um den Prozess der App zu identifizieren und ge√∂ffnete Dateien aufzulisten, was Einblicke in die aktiven Verzeichnispfade der Anwendung bietet:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundle-Verzeichnis:**

* **AppName.app**
* Dies ist das Anwendungs-Bundle, wie es bereits in der IPA gesehen wurde. Es enth√§lt wesentliche Anwendungsdaten, statische Inhalte sowie das kompilierte Bin√§rprogramm der Anwendung.
* Dieses Verzeichnis ist f√ºr Benutzer sichtbar, aber **Benutzer k√∂nnen nicht darauf schreiben**.
* Der Inhalt dieses Verzeichnisses wird **nicht gesichert**.
* Der Inhalt dieses Ordners wird verwendet, um die Code-Signatur zu **validieren**.

**Datenverzeichnis:**

* **Dokumente/**
* Enth√§lt alle vom Benutzer generierten Daten. Der Anwender der Anwendung initiiert die Erstellung dieser Daten.
* Sichtbar f√ºr Benutzer und **Benutzer k√∂nnen darauf schreiben**.
* Der Inhalt dieses Verzeichnisses wird **gesichert**.
* Die App kann Pfade deaktivieren, indem `NSURLIsExcludedFromBackupKey` festgelegt wird.
* **Bibliothek/**
* Enth√§lt alle **Dateien, die nicht benutzerspezifisch sind**, wie **Zwischenspeicher**, **Einstellungen**, **Cookies** und Konfigurationsdateien f√ºr Property-Listen (plist).
* iOS-Apps verwenden normalerweise die Unterverzeichnisse `Application Support` und `Caches`, aber die App kann benutzerdefinierte Unterverzeichnisse erstellen.
* **Bibliothek/Caches/**
* Enth√§lt **halbpermanente zwischengespeicherte Dateien**.
* F√ºr Benutzer unsichtbar und **Benutzer k√∂nnen nicht darauf schreiben**.
* Der Inhalt dieses Verzeichnisses wird **nicht gesichert**.
* Das Betriebssystem kann die Dateien dieses Verzeichnisses automatisch l√∂schen, wenn die App nicht l√§uft und der Speicherplatz knapp wird.
* **Bibliothek/Application Support/**
* Enth√§lt **persistente Dateien**, die f√ºr das Ausf√ºhren der App erforderlich sind.
* **F√ºr Benutzer unsichtbar** und Benutzer k√∂nnen nicht darauf schreiben.
* Der Inhalt dieses Verzeichnisses wird **gesichert**.
* Die App kann Pfade deaktivieren, indem `NSURLIsExcludedFromBackupKey` festgelegt wird.
* **Bibliothek/Einstellungen/**
* Wird zum Speichern von Eigenschaften verwendet, die **auch nach einem Neustart der Anwendung bestehen bleiben k√∂nnen**.
* Informationen werden unverschl√ºsselt in der Anwendungssandbox in einer plist-Datei namens \[BUNDLE\_ID].plist gespeichert.
* Alle mit `NSUserDefaults` gespeicherten Schl√ºssel/Wert-Paare sind in dieser Datei zu finden.
* **tmp/**
* Verwenden Sie dieses Verzeichnis, um **tempor√§re Dateien** zu schreiben, die zwischen App-Starts nicht bestehen m√ºssen.
* Enth√§lt nicht persistente zwischengespeicherte Dateien.
* F√ºr Benutzer **unsichtbar**.
* Der Inhalt dieses Verzeichnisses wird nicht gesichert.
* Das Betriebssystem kann die Dateien dieses Verzeichnisses automatisch l√∂schen, wenn die App nicht l√§uft und der Speicherplatz knapp wird.

Lassen Sie uns einen genaueren Blick auf das Anwendungs-Bundle (.app) Verzeichnis von iGoat-Swift im Bundle-Verzeichnis (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) werfen:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Bin√§re Umkehrung

Innerhalb des `<application-name>.app`-Ordners finden Sie eine Bin√§rdatei namens `<application-name>`. Dies ist die Datei, die **ausgef√ºhrt** wird. Sie k√∂nnen eine grundlegende Inspektion der Bin√§rdatei mit dem Tool **`otool`** durchf√ºhren:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**√úberpr√ºfen Sie, ob die App verschl√ºsselt ist**

Sehen Sie nach, ob es eine Ausgabe f√ºr:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Bin√§rdatei disassemblieren**

Disassemblieren Sie den Textabschnitt:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Um das **Objective-C-Segment** der Beispielanwendung auszudrucken, kann man Folgendes verwenden:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Um einen kompakteren Objective-C-Code zu erhalten, k√∂nnen Sie [**class-dump**](http://stevenygard.com/projects/class-dump/) verwenden:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Jedoch sind die besten Optionen zum Auseinandernehmen der Bin√§rdatei: [**Hopper**](https://www.hopperapp.com/download.html?) und [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks), um einfach **Workflows zu erstellen** und zu **automatisieren**, die von den weltweit **fortschrittlichsten** Community-Tools unterst√ºtzt werden.\
Heute Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Datenspeicher

Um zu erfahren, wie iOS Daten auf dem Ger√§t speichert, lesen Sie diese Seite:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Die folgenden Speicherorte f√ºr Informationen sollten **direkt nach der Installation der Anwendung**, **nach √úberpr√ºfung aller Funktionen** der Anwendung und sogar nach dem **Abmelden von einem Benutzer und Anmelden bei einem anderen** √ºberpr√ºft werden.\
Das Ziel ist es, **ungesch√ºtzte sensible Informationen** der Anwendung (Passw√∂rter, Tokens), des aktuellen Benutzers und der zuvor angemeldeten Benutzer zu finden.
{% endhint %}

### Plist

**plist**-Dateien sind strukturierte XML-Dateien, die **Schl√ºssel-Wert-Paare enthalten**. Es ist eine M√∂glichkeit, persistente Daten zu speichern, daher k√∂nnen manchmal **sensible Informationen in diesen Dateien gefunden werden**. Es wird empfohlen, diese Dateien nach der Installation der App und nach intensiver Nutzung zu √ºberpr√ºfen, um zu sehen, ob neue Daten geschrieben werden.

Der h√§ufigste Weg, Daten in plist-Dateien zu speichern, erfolgt durch die Verwendung von **NSUserDefaults**. Diese plist-Datei wird im App-Sandbox unter **`Library/Preferences/<appBundleID>.plist`** gespeichert.

Die [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults)-Klasse bietet eine programmatische Schnittstelle zur Interaktion mit dem Standardsystem. Das Standardsystem erm√∂glicht es einer Anwendung, ihr Verhalten entsprechend den **Benutzervorlieben** anzupassen. Von `NSUserDefaults` gespeicherte Daten k√∂nnen im Anwendungs-Bundle eingesehen werden. Diese Klasse speichert **Daten** in einer **plist**-**Datei**, ist jedoch f√ºr die Verwendung mit kleinen Datenmengen gedacht.

Diese Daten k√∂nnen nicht direkt √ºber einen vertrauensw√ºrdigen Computer abgerufen werden, k√∂nnen jedoch durch ein **Backup** abgerufen werden.

Sie k√∂nnen die gespeicherten Informationen mit **`NSUserDefaults`** mithilfe von objection's `ios nsuserdefaults get` **auslesen**.

Um alle vom Anwendungen verwendeten plist-Dateien zu finden, k√∂nnen Sie auf `/private/var/mobile/Containers/Data/Application/{APPID}` zugreifen und ausf√ºhren:
```bash
find ./ -name "*.plist"
```
Um Dateien vom Format **XML oder bin√§r (bplist)** in XML umzuwandeln, stehen je nach Betriebssystem verschiedene Methoden zur Verf√ºgung:

**F√ºr macOS-Benutzer:** Verwenden Sie den Befehl `plutil`. Es handelt sich um ein integriertes Tool in macOS (10.2+), das f√ºr diesen Zweck entwickelt wurde:
```bash
$ plutil -convert xml1 Info.plist
```
**F√ºr Linux-Benutzer:** Installieren Sie zuerst `libplist-utils` und verwenden Sie dann `plistutil`, um Ihre Datei zu konvertieren:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Innerhalb einer Objection-Sitzung:** Zum Analysieren von mobilen Anwendungen erm√∂glicht ein spezifischer Befehl das direkte Konvertieren von plist-Dateien:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) ist ein Framework zur Verwaltung der Modellschicht von Objekten in Ihrer Anwendung. [Core Data kann SQLite als seinen persistenten Speicher verwenden](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), aber das Framework selbst ist keine Datenbank. CoreData verschl√ºsselt standardm√§√üig nicht seine Daten. Es kann jedoch eine zus√§tzliche Verschl√ºsselungsschicht zu CoreData hinzugef√ºgt werden. Weitere Details finden Sie im [GitHub Repo](https://github.com/project-imas/encrypted-core-data).

Sie k√∂nnen die SQLite Core Data-Informationen einer Anwendung im Pfad `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support` finden.

**Wenn Sie SQLite √∂ffnen und auf sensible Informationen zugreifen k√∂nnen, haben Sie eine Fehlkonfiguration gefunden.**
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) ist ein Key/Value-Speicher, der auf SQLite aufbaut.\
Da die Yap-Datenbanken SQLite-Datenbanken sind, k√∂nnen Sie sie mithilfe des vorgeschlagenen Befehls im vorherigen Abschnitt finden.

### Andere SQLite-Datenbanken

Es ist √ºblich, dass Anwendungen ihre eigene SQLite-Datenbank erstellen. M√∂glicherweise speichern sie **sensible** **Daten** darin und lassen sie unverschl√ºsselt. Daher ist es immer interessant, jede Datenbank im Anwendungsverzeichnis zu √ºberpr√ºfen. Gehen Sie daher in das Anwendungsverzeichnis, in dem die Daten gespeichert sind (`/private/var/mobile/Containers/Data/Application/{APPID}`).
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase-Echtzeitdatenbanken

Entwickler k√∂nnen Daten in einer **NoSQL-Cloud-Datenbank** √ºber Firebase-Echtzeitdatenbanken **speichern und synchronisieren**. Die Daten werden im JSON-Format gespeichert und in Echtzeit mit allen verbundenen Clients synchronisiert.

Hier erfahren Sie, wie Sie nach fehlerhaft konfigurierten Firebase-Datenbanken suchen k√∂nnen:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm-Datenbanken

[Realm Objective-C](https://realm.io/docs/objc/latest/) und [Realm Swift](https://realm.io/docs/swift/latest/) bieten eine leistungsstarke Alternative f√ºr die Datenspeicherung, die von Apple nicht bereitgestellt wird. Standardm√§√üig werden die Daten **unverschl√ºsselt gespeichert**, wobei eine Verschl√ºsselung durch spezifische Konfiguration m√∂glich ist.

Die Datenbanken befinden sich unter: `/private/var/mobile/Containers/Data/Application/{APPID}`. Um diese Dateien zu erkunden, k√∂nnen Befehle wie:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Um diese Datenbankdateien anzuzeigen, wird das [**Realm Studio**](https://github.com/realm/realm-studio) Tool empfohlen.

Um eine Verschl√ºsselung in einer Realm-Datenbank zu implementieren, kann der folgende Code-Schnipsel verwendet werden:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Datenbanken

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) wird als eine **leichte** und **eingebettete** Datenbank-Engine beschrieben, die dem **dokumentenorientierten** (NoSQL) Ansatz folgt. Entwickelt, um nativ f√ºr **iOS** und **macOS** zu sein, bietet sie die M√∂glichkeit, Daten nahtlos zu synchronisieren.

Um potenzielle Couchbase-Datenbanken auf einem Ger√§t zu identifizieren, sollte das folgende Verzeichnis √ºberpr√ºft werden:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS speichert die Cookies der Apps im **`Library/Cookies/cookies.binarycookies`** innerhalb des Ordners jeder App. Manchmal entscheiden sich Entwickler jedoch daf√ºr, sie im **Schl√ºsselbund** zu speichern, da die genannte **Cookie-Datei in Backups abgerufen werden kann**.

Um die Cookies-Datei zu inspizieren, k√∂nnen Sie [**dieses Python-Skript**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) verwenden oder **`ios cookies get`** von objection verwenden.\
**Sie k√∂nnen auch objection verwenden, um** diese Dateien in ein JSON-Format zu konvertieren und die Daten zu inspizieren.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Standardm√§√üig speichert NSURLSession Daten wie **HTTP-Anfragen und -Antworten in der Cache.db**-Datenbank. Diese Datenbank kann **sensible Daten** enthalten, wenn Tokens, Benutzernamen oder andere sensible Informationen zwischengespeichert wurden. Um die zwischengespeicherten Informationen zu finden, √∂ffnen Sie das Datenverzeichnis der App (`/var/mobile/Containers/Data/Application/<UUID>`) und gehen Sie zu `/Library/Caches/<Bundle Identifier>`. Der **WebKit-Cache wird ebenfalls in der Cache.db**-Datei gespeichert. **Objection** kann die Datenbank mit dem Befehl `sqlite connect Cache.db` √∂ffnen und damit interagieren, da es sich um eine **normale SQLite-Datenbank** handelt.

Es wird **empfohlen, das Zwischenspeichern dieser Daten zu deaktivieren**, da sie m√∂glicherweise sensible Informationen in der Anfrage oder Antwort enthalten. Die folgende Liste zeigt verschiedene M√∂glichkeiten, dies zu erreichen:

1. Es wird empfohlen, zwischengespeicherte Antworten nach dem Abmelden zu entfernen. Dies kann mit der von Apple bereitgestellten Methode [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) durchgef√ºhrt werden. Sie k√∂nnen diese Methode wie folgt aufrufen:

`URLCache.shared.removeAllCachedResponses()`

Diese Methode entfernt alle zwischengespeicherten Anfragen und Antworten aus der Cache.db-Datei.
2. Wenn Sie den Vorteil von Cookies nicht ben√∂tigen, wird empfohlen, einfach die [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral)-Konfigurationseigenschaft von URLSession zu verwenden, die das Speichern von Cookies und Caches deaktiviert.

[Apple-Dokumentation](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Ein ephemeres Sitzungskonfigurationsobjekt √§hnelt einer Standard-Sitzungskonfiguration (siehe default), mit der Ausnahme, dass das entsprechende Sitzungsobjekt keine Caches, Anmeldeinformationsspeicher oder andere sitzungsbezogene Daten auf die Festplatte schreibt. Stattdessen werden sitzungsbezogene Daten im RAM gespeichert. Ein ephemeres Sitzungsschreibt Daten auf die Festplatte, wenn Sie ihm sagen, den Inhalt einer URL in eine Datei zu schreiben.`
3. Die Cache kann auch deaktiviert werden, indem die Cache-Richtlinie auf [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) gesetzt wird. Dadurch wird das Speichern des Caches in keiner Weise deaktiviert, weder im Speicher noch auf der Festplatte.

### Snapshots

Immer wenn Sie die Home-Taste dr√ºcken, **erstellt iOS einen Schnappschuss des aktuellen Bildschirms**, um den √úbergang zur Anwendung auf eine viel reibungslosere Weise zu erm√∂glichen. Wenn sich jedoch **sensible Daten** auf dem aktuellen Bildschirm befinden, werden sie im **Bild gespeichert** (das **√ºber Neustarts hinweg bestehen bleibt**). Dies sind die Schnappsch√ºsse, auf die Sie auch zugreifen k√∂nnen, indem Sie zweimal auf den Home-Bildschirm tippen, um zwischen Apps zu wechseln.

Sofern das iPhone nicht gejailbreakt ist, muss der **Angreifer** Zugriff auf das **entsperrte Ger√§t** haben, um diese Bildschirmdarstellungen zu sehen. Standardm√§√üig wird der letzte Schnappschuss im Anwendungssandbox-Verzeichnis unter `Library/Caches/Snapshots/` oder `Library/SplashBoard/Snapshots` gespeichert (vertrauensw√ºrdige Computer k√∂nnen nicht ab iOS 7.0 auf das Dateisystem zugreifen).

Ein Weg, um dieses unerw√ºnschte Verhalten zu verhindern, besteht darin, einen leeren Bildschirm einzuf√ºgen oder die sensiblen Daten vor dem Erstellen des Schnappschusses mithilfe der Funktion `ApplicationDidEnterBackground()` zu entfernen.

Hier ist eine Beispielbehebungsmethode, die einen Standard-Screenshot festlegt.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C ist eine objektorientierte Programmiersprache, die haupts√§chlich f√ºr die Entwicklung von iOS- und macOS-Apps verwendet wird. Es ist wichtig, Objective-C zu verstehen, um Schwachstellen in iOS-Apps zu identifizieren und zu exploitieren.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
### Hintergrundbild

Dies setzt das Hintergrundbild auf `overlayImage.png`, wann immer die Anwendung in den Hintergrund verschoben wird. Es verhindert das Lecken sensibler Daten, da `overlayImage.png` immer die aktuelle Ansicht √ºberschreibt.

### Schl√ºsselbund

Zum Zugriff auf und Verwalten des iOS-Schl√ºsselbunds stehen Tools wie [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) zur Verf√ºgung, die f√ºr gejailbreakte Ger√§te geeignet sind. Dar√ºber hinaus bietet [**Objection**](https://github.com/sensepost/objection) den Befehl `ios keychain dump` f√ºr √§hnliche Zwecke.

#### **Anmeldedaten speichern**

Die Klasse **NSURLCredential** eignet sich ideal zum Speichern sensibler Informationen direkt im Schl√ºsselbund, um die Notwendigkeit von NSUserDefaults oder anderen Wrappern zu umgehen. Um Anmeldedaten nach dem Login zu speichern, wird der folgende Swift-Code verwendet:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Um diese gespeicherten Anmeldeinformationen zu extrahieren, wird der Befehl `ios nsurlcredentialstorage dump` von Objection verwendet.

## **Benutzerdefinierte Tastaturen und Tastaturcache**

Ab iOS 8.0 k√∂nnen Benutzer benutzerdefinierte Tastaturerweiterungen installieren, die unter **Einstellungen > Allgemein > Tastatur > Tastaturen** verwaltet werden k√∂nnen. Obwohl diese Tastaturen erweiterte Funktionen bieten, stellen sie ein Risiko f√ºr Tastenprotokollierung und die √úbertragung von Daten an externe Server dar, obwohl Benutzer √ºber Tastaturen informiert werden, die Netzwerkzugriff erfordern. Apps k√∂nnen und sollten die Verwendung von benutzerdefinierten Tastaturen f√ºr die Eingabe sensibler Informationen einschr√§nken.

**Sicherheitsempfehlungen:**

* Es wird empfohlen, Drittanbieter-Tastaturen f√ºr erh√∂hte Sicherheit zu deaktivieren.
* Achten Sie auf die Auto-Korrektur- und Auto-Vorschlagsfunktionen der Standard-iOS-Tastatur, die sensible Informationen in Cache-Dateien speichern k√∂nnten, die sich in `Library/Keyboard/{locale}-dynamic-text.dat` oder `/private/var/mobile/Library/Keyboard/dynamic-text.dat` befinden. Diese Cache-Dateien sollten regelm√§√üig auf sensible Daten √ºberpr√ºft werden. Es wird empfohlen, das Tastaturw√∂rterbuch √ºber **Einstellungen > Allgemein > Zur√ºcksetzen > Tastaturw√∂rterbuch zur√ºcksetzen** zur√ºckzusetzen, um zwischengespeicherte Daten zu l√∂schen.
* Das Abfangen des Netzwerkverkehrs kann aufzeigen, ob eine benutzerdefinierte Tastatur Tastenanschl√§ge remote √ºbertr√§gt.

### **Verhindern des Cachens von Textfeldern**

Das [UITextInputTraits-Protokoll](https://developer.apple.com/reference/uikit/uitextinputtraits) bietet Eigenschaften zur Verwaltung der Auto-Korrektur und zur sicheren Texteingabe, die f√ºr die Verhinderung des Cachens sensibler Informationen unerl√§sslich sind. Beispielsweise kann das Deaktivieren der Auto-Korrektur und das Aktivieren der sicheren Texteingabe mit folgendem erreicht werden:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Dar√ºber hinaus sollten Entwickler sicherstellen, dass Textfelder, insbesondere solche zum Eingeben sensibler Informationen wie Passw√∂rter und PINs, das Zwischenspeichern deaktivieren, indem sie `autocorrectionType` auf `UITextAutocorrectionTypeNo` und `secureTextEntry` auf `YES` setzen.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Protokolle**

Das Debuggen von Code beinhaltet oft die Verwendung von **Protokollierung**. Es besteht ein Risiko, da **Protokolle sensible Informationen enthalten k√∂nnen**. Fr√ºher waren in iOS 6 und fr√ºheren Versionen die Protokolle f√ºr alle Apps zug√§nglich, was ein Risiko f√ºr die unerw√ºnschte Offenlegung sensibler Daten darstellte. **Jetzt sind Anwendungen auf den Zugriff nur auf ihre eigenen Protokolle beschr√§nkt**.

Trotz dieser Einschr√§nkungen kann ein **Angreifer mit physischem Zugriff** auf ein entsperrtes Ger√§t dies immer noch ausnutzen, indem er das Ger√§t mit einem Computer verbindet und **die Protokolle liest**. Es ist wichtig zu beachten, dass die Protokolle auch nach der Deinstallation der App auf der Festplatte verbleiben.

Um Risiken zu minimieren, wird empfohlen, **ausf√ºhrlich mit der App zu interagieren**, alle Funktionen und Eingaben zu erkunden, um sicherzustellen, dass keine sensiblen Informationen unbeabsichtigt protokolliert werden.

Beim √úberpr√ºfen des Quellcodes der App auf potenzielle Lecks sollten sowohl **vordefinierte** als auch **benutzerdefinierte Protokollierungsanweisungen** gesucht werden, die Schl√ºsselw√∂rter wie `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` f√ºr integrierte Funktionen und Erw√§hnungen von `Protokollierung` oder `Protokolldatei` f√ºr benutzerdefinierte Implementierungen verwenden.

### **√úberwachung von Systemprotokollen**

Apps protokollieren verschiedene Informationen, die sensibel sein k√∂nnen. Zur √úberwachung dieser Protokolle werden Tools und Befehle wie:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
sind n√ºtzlich. Dar√ºber hinaus bietet **Xcode** eine M√∂glichkeit, Konsolenprotokolle zu sammeln:

1. √ñffnen Sie Xcode.
2. Verbinden Sie das iOS-Ger√§t.
3. Navigieren Sie zu **Fenster** -> **Ger√§te und Simulatoren**.
4. W√§hlen Sie Ihr Ger√§t aus.
5. Triggern Sie das Problem, das Sie untersuchen.
6. Verwenden Sie die Schaltfl√§che **Konsole √∂ffnen**, um Protokolle in einem neuen Fenster anzuzeigen.

F√ºr fortgeschrittenes Logging kann das Verbinden mit der Ger√§teshell und die Verwendung von **socat** eine Echtzeit-Protokoll√ºberwachung erm√∂glichen:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Verfolgt von Befehlen zur Beobachtung von Protokollaktivit√§ten, die beim Diagnostizieren von Problemen oder beim Identifizieren potenzieller Datenlecks in Protokollen von unsch√§tzbarem Wert sein k√∂nnen.

***

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos **Workflows zu erstellen** und zu **automatisieren**, die von den weltweit **fortschrittlichsten** Community-Tools unterst√ºtzt werden.\
Heute Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Backups

**Automatische Backup-Funktionen** sind in iOS integriert und erleichtern die Erstellung von Ger√§tedatensicherungskopien √ºber iTunes (bis macOS Catalina), Finder (ab macOS Catalina) oder iCloud. Diese Backups umfassen fast alle Ger√§tedaten, mit Ausnahme hochsensibler Elemente wie Apple Pay-Details und Touch ID-Konfigurationen.

### Sicherheitsrisiken

Die Einbeziehung von **installierten Apps und deren Daten** in Backups wirft die Frage nach potenziellen **Datenlecks** auf und das Risiko, dass **Backup-√Ñnderungen die App-Funktionalit√§t beeintr√§chtigen k√∂nnten**. Es wird empfohlen, **keine sensiblen Informationen im Klartext** im Verzeichnis einer App oder in dessen Unterverzeichnissen zu speichern, um diese Risiken zu minimieren.

### Ausschlie√üen von Dateien aus Backups

Dateien in `Documents/` und `Library/Application Support/` werden standardm√§√üig gesichert. Entwickler k√∂nnen bestimmte Dateien oder Verzeichnisse von Backups ausschlie√üen, indem sie `NSURL setResourceValue:forKey:error:` mit dem `NSURLIsExcludedFromBackupKey` verwenden. Diese Praxis ist entscheidend, um sensible Daten vor der Aufnahme in Backups zu sch√ºtzen.

### Testen auf Sicherheitsl√ºcken

Um die Backup-Sicherheit einer App zu bewerten, beginnen Sie mit dem **Erstellen eines Backups** mit dem Finder und suchen Sie es dann mithilfe der Anleitung von [Apple's offizieller Dokumentation](https://support.apple.com/en-us/HT204215). Analysieren Sie das Backup auf sensible Daten oder Konfigurationen, die ge√§ndert werden k√∂nnten, um das App-Verhalten zu beeinflussen.

Sensible Informationen k√∂nnen mithilfe von Befehlszeilentools oder Anwendungen wie [iMazing](https://imazing.com) gesucht werden. Bei verschl√ºsselten Backups kann die Verschl√ºsselung durch √úberpr√ºfen des Schl√ºssels "IsEncrypted" in der Datei "Manifest.plist" im Stammverzeichnis des Backups best√§tigt werden.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
F√ºr den Umgang mit verschl√ºsselten Backups k√∂nnen Python-Skripte aus dem [DinoSec GitHub-Repository](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts) wie **backup\_tool.py** und **backup\_passwd.py** n√ºtzlich sein, erfordern m√∂glicherweise jedoch Anpassungen, um mit den neuesten iTunes/Finder-Versionen kompatibel zu sein. Das [**iOSbackup**-Tool](https://pypi.org/project/iOSbackup/) ist eine weitere Option zum Zugriff auf Dateien innerhalb von passwortgesch√ºtzten Backups.

### Modifizierung des App-Verhaltens

Ein Beispiel f√ºr die √Ñnderung des App-Verhaltens durch Backup-Modifikationen wird in der [Bither Bitcoin Wallet App](https://github.com/bither/bither-ios) demonstriert, wo die UI-Sperr-PIN unter dem Schl√ºssel **pin\_code** in `net.bither.plist` gespeichert ist. Durch Entfernen dieses Schl√ºssels aus der Plist und Wiederherstellen des Backups wird die PIN-Anforderung entfernt und ein uneingeschr√§nkter Zugriff erm√∂glicht.

## Zusammenfassung zum Speichertesten sensibler Daten

Beim Umgang mit sensiblen Informationen, die in einem Anwendungs-Speicher gespeichert sind, ist es entscheidend, die Belichtungszeit dieser Daten zu begrenzen. Es gibt zwei Hauptans√§tze zur Untersuchung des Speicherinhalts: **Erstellen eines Speicher-Dumps** und **Analysieren des Speichers in Echtzeit**. Beide Methoden haben ihre Herausforderungen, einschlie√ülich der M√∂glichkeit, w√§hrend des Dump-Prozesses oder der Analyse wichtige Daten zu √ºbersehen.

## **Abrufen und Analysieren eines Speicher-Dumps**

F√ºr sowohl gejailbreakte als auch nicht-gejailbreakte Ger√§te erm√∂glichen Tools wie [objection](https://github.com/sensepost/objection) und [Fridump](https://github.com/Nightbringer21/fridump) das Dumpen des App-Prozessspeichers. Nach dem Dumpen erfordert die Analyse dieser Daten verschiedene Tools, abh√§ngig von der Art der gesuchten Informationen.

Um Zeichenfolgen aus einem Speicher-Dump zu extrahieren, k√∂nnen Befehle wie `strings` oder `rabin2 -zz` verwendet werden:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
F√ºr eine genauere Analyse, einschlie√ülich der Suche nach bestimmten Datentypen oder Mustern, bietet **radare2** umfangreiche Suchm√∂glichkeiten:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Laufzeit-Speicheranalyse**

**r2frida** bietet eine leistungsstarke Alternative zur Inspektion des Speichers einer App in Echtzeit, ohne dass ein Speicherabbild erforderlich ist. Dieses Tool erm√∂glicht die Ausf√ºhrung von Suchbefehlen direkt im Speicher der laufenden Anwendung:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Fehlerhafte Kryptografie

### Schlechte Schl√ºsselverwaltungsprozesse

Einige Entwickler speichern sensible Daten im lokalen Speicher und verschl√ºsseln sie mit einem im Code fest codierten/vorhersehbaren Schl√ºssel. Dies sollte vermieden werden, da durch Reverse Engineering Angreifer vertrauliche Informationen extrahieren k√∂nnten.

### Verwendung unsicherer und/oder veralteter Algorithmen

Entwickler sollten keine **veralteten Algorithmen** zur Durchf√ºhrung von Autorisierungspr√ºfungen, zum **Speichern** oder **Senden** von Daten verwenden. Einige dieser Algorithmen sind: RC4, MD4, MD5, SHA1... Wenn **Hashes** beispielsweise zum Speichern von Passw√∂rtern verwendet werden, sollten hash-brute-force-resistente Hashes mit Salt verwendet werden.

### √úberpr√ºfung

Die Haupt√ºberpr√ºfungen, die durchgef√ºhrt werden m√ºssen, sind das Auffinden von **fest codierten** Passw√∂rtern/Geheimnissen im Code oder ob diese **vorhersehbar** sind und ob der Code schwache Kryptografiealgorithmen verwendet.

Es ist interessant zu wissen, dass Sie einige **Krypto**-**Bibliotheken** automatisch mit **objection** √ºberwachen k√∂nnen:
```swift
ios monitor crypt
```
F√ºr **weitere Informationen** zu iOS-Kryptografie-APIs und Bibliotheken besuchen Sie [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Lokale Authentifizierung

**Die lokale Authentifizierung** spielt eine entscheidende Rolle, insbesondere wenn es darum geht, den Zugriff an einem entfernten Endpunkt durch kryptografische Methoden abzusichern. Die Essenz hierbei ist, dass ohne ordnungsgem√§√üe Implementierung lokale Authentifizierungsmechanismen umgangen werden k√∂nnen.

Apples [**Local Authentication Framework**](https://developer.apple.com/documentation/localauthentication) und der [**Schl√ºsselbund**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) bieten robuste APIs f√ºr Entwickler, um Benutzerauthentifizierungsdialoge zu erleichtern und geheime Daten sicher zu handhaben. Der Secure Enclave sichert die Fingerabdruck-ID f√ºr Touch ID, w√§hrend Face ID auf Gesichtserkennung ohne Kompromittierung biometrischer Daten setzt.

Um Touch ID/Face ID zu integrieren, haben Entwickler zwei API-Optionen:

* **`LocalAuthentication.framework`** f√ºr eine benutzerfreundliche Authentifizierung ohne Zugriff auf biometrische Daten.
* **`Security.framework`** f√ºr den Zugriff auf Keychain-Dienste auf niedrigerer Ebene, um geheime Daten mit biometrischer Authentifizierung zu sichern. Verschiedene [Open-Source-Wrapper](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) vereinfachen den Zugriff auf den Schl√ºsselbund.

{% hint style="danger" %}
Allerdings weisen sowohl `LocalAuthentication.framework` als auch `Security.framework` Schwachstellen auf, da sie haupts√§chlich boolesche Werte zur√ºckgeben, ohne Daten f√ºr Authentifizierungsprozesse zu √ºbertragen, was sie anf√§llig f√ºr Umgehungen macht (siehe [Don't touch me that way, von David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementierung der lokalen Authentifizierung

Um Benutzer zur Authentifizierung aufzufordern, sollten Entwickler die Methode **`evaluatePolicy`** innerhalb der Klasse **`LAContext`** verwenden und zwischen folgenden Optionen w√§hlen:

* **`deviceOwnerAuthentication`**: Fordert Touch ID oder Ger√§tepasscode an und schl√§gt fehl, wenn keines von beiden aktiviert ist.
* **`deviceOwnerAuthenticationWithBiometrics`**: Fordert ausschlie√ülich Touch ID an.

Eine erfolgreiche Authentifizierung wird durch einen booleschen R√ºckgabewert von **`evaluatePolicy`** angezeigt, was auf eine potenzielle Sicherheitsl√ºcke hinweist.

### Lokale Authentifizierung mit Keychain

Die Implementierung der **lokalen Authentifizierung** in iOS-Apps beinhaltet die Verwendung von **Keychain-APIs** zum sicheren Speichern geheimer Daten wie Authentifizierungstoken. Dieser Prozess stellt sicher, dass die Daten nur vom Benutzer √ºber ihren Ger√§tepasscode oder die biometrische Authentifizierung wie Touch ID abgerufen werden k√∂nnen.

Der Schl√ºsselbund bietet die M√∂glichkeit, Elemente mit dem Attribut `SecAccessControl` festzulegen, das den Zugriff auf das Element einschr√§nkt, bis der Benutzer sich erfolgreich √ºber Touch ID oder Ger√§tepasscode authentifiziert. Diese Funktion ist entscheidend f√ºr die Verbesserung der Sicherheit.

Nachfolgend sind Codebeispiele in Swift und Objective-C aufgef√ºhrt, die zeigen, wie ein String im Schl√ºsselbund gespeichert und abgerufen wird, wobei diese Sicherheitsfunktionen genutzt werden. Die Beispiele zeigen speziell, wie der Zugriffsschutz eingerichtet wird, um eine Touch ID-Authentifizierung zu erfordern und sicherzustellen, dass die Daten nur auf dem Ger√§t zug√§nglich sind, auf dem sie eingerichtet wurden, unter der Bedingung, dass ein Ger√§tepasscode konfiguriert ist.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %} 
### Objective-C

#### Method Swizzling

Method Swizzling ist eine Technik, bei der die Implementierung einer Methode zur Laufzeit ge√§ndert wird. Dies kann verwendet werden, um das Verhalten von Klassen zu √§ndern, ohne den Quellcode zu √§ndern. Es ist wichtig, vorsichtig zu sein, da dies zu unerwartetem Verhalten f√ºhren kann. 

#### Runtime Manipulation

Durch die Verwendung von Objective-C-Runtime-APIs k√∂nnen Entwickler Klassen und Methoden zur Laufzeit manipulieren. Dies erm√∂glicht fortgeschrittene Techniken wie das Erstellen von Klassen dynamisch oder das Aufrufen privater Methoden. Es ist jedoch wichtig, diese Techniken mit Bedacht einzusetzen, da sie die Stabilit√§t der Anwendung beeintr√§chtigen k√∂nnen. 
{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Jetzt k√∂nnen wir das gespeicherte Element aus dem Schl√ºsselbund anfordern. Die Schl√ºsselbunddienste werden dem Benutzer den Authentifizierungsdialog anzeigen und Daten oder nil zur√ºckgeben, abh√§ngig davon, ob ein geeigneter Fingerabdruck bereitgestellt wurde oder nicht.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}Translate the relevant English text to German and return the translation keeping excatly the same markdown and html syntax. Do not translate things like code, hacking technique names, hacking word, cloud/SaaS platform names (like Workspace, aws, gcp...), the word 'leak', pentesting, and markdown tags. Also don't add any extra stuff apart from the translation and markdown syntax.
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### Erkennung

Die Verwendung von Frameworks in einer App kann auch durch Analyse der Liste der gemeinsam genutzten dynamischen Bibliotheken der App-Bin√§rdatei erkannt werden. Dies kann mit `otool` durchgef√ºhrt werden:
```bash
$ otool -L <AppName>.app/<AppName>
```
Wenn `LocalAuthentication.framework` in einer App verwendet wird, wird die Ausgabe beide der folgenden Zeilen enthalten (denken Sie daran, dass `LocalAuthentication.framework` `Security.framework` unter der Haube verwendet):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Wenn `Security.framework` verwendet wird, wird nur der zweite angezeigt.

### Lokaler Authentifizierungsframework-Bypass

#### **Einwand**

Durch den **Einwand Biometrieumgehung**, zu finden auf [dieser GitHub-Seite](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), steht eine Technik zur √úberwindung des **LocalAuthentication**-Mechanismus zur Verf√ºgung. Der Kern dieses Ansatzes besteht darin, **Frida** zu nutzen, um die Funktion `evaluatePolicy` zu manipulieren, um sicherzustellen, dass sie konsequent ein `True`-Ergebnis liefert, unabh√§ngig vom tats√§chlichen Authentifizierungserfolg. Dies ist besonders n√ºtzlich, um fehlerhafte biometrische Authentifizierungsprozesse zu umgehen.

Um diese Umgehung zu aktivieren, wird der folgende Befehl verwendet:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Dieser Befehl l√∂st eine Sequenz aus, bei der Objection eine Aufgabe registriert, die das Ergebnis der `evaluatePolicy`-Pr√ºfung effektiv auf `True` √§ndert.

#### Frida

Ein Beispiel f√ºr die Verwendung von **`evaluatePolicy`** aus der [DVIA-v2-Anwendung](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Um die **Umgehung** der lokalen Authentifizierung zu erreichen, wird ein Frida-Skript geschrieben. Dieses Skript zielt auf die **evaluatePolicy**-√úberpr√ºfung ab, indem es den R√ºckruf abf√§ngt, um sicherzustellen, dass er **success=1** zur√ºckgibt. Durch √Ñndern des Verhaltens des R√ºckrufs wird die Authentifizierungspr√ºfung effektiv umgangen.

Das folgende Skript wird injiziert, um das Ergebnis der Methode **evaluatePolicy** zu √§ndern. Es √§ndert das Ergebnis des R√ºckrufs so, dass immer Erfolg angezeigt wird.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Um das Frida-Skript einzuspeisen und die biometrische Authentifizierung zu umgehen, wird der folgende Befehl verwendet:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Empfindliche Funktionalit√§tsexposition durch IPC

### Benutzerdefinierte URI-Handler / Deeplinks / Benutzerdefinierte Schemas

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Universelle Links

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity Sharing

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### App-Erweiterungen

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serialisierung und Codierung

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Netzwerkkommunikation

Es ist wichtig zu √ºberpr√ºfen, dass keine Kommunikation **ohne Verschl√ºsselung** erfolgt und dass die Anwendung das TLS-Zertifikat des Servers korrekt **validiert**.\
Um diese Art von Problemen zu √ºberpr√ºfen, k√∂nnen Sie einen Proxy wie **Burp** verwenden:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Hostnamenpr√ºfung

Ein h√§ufiges Problem bei der Validierung des TLS-Zertifikats besteht darin, zu √ºberpr√ºfen, ob das Zertifikat von einer **vertrauensw√ºrdigen CA** signiert wurde, aber **nicht zu √ºberpr√ºfen**, ob **der Hostname** des Zertifikats der aufgerufene Hostname ist.\
Um dieses Problem mit Burp zu √ºberpr√ºfen, k√∂nnen Sie nach dem Vertrauen des Burp-CA auf dem iPhone ein **neues Zertifikat mit Burp f√ºr einen anderen Hostnamen erstellen** und verwenden. Wenn die Anwendung immer noch funktioniert, ist etwas verwundbar.

### Zertifikats-Pinning

Wenn eine Anwendung SSL-Pinning korrekt verwendet, funktioniert die Anwendung nur, wenn das Zertifikat das erwartete ist. Beim Testen einer Anwendung **kann dies ein Problem sein, da Burp sein eigenes Zertifikat ausstellt.**\
Um diesen Schutz auf einem jailbroken Ger√§t zu umgehen, k√∂nnen Sie die Anwendung [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) installieren oder [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) installieren.

Sie k√∂nnen auch **objection's** `ios sslpinning disable` verwenden.

## Sonstiges

* In **`/System/Library`** finden Sie die auf dem Telefon installierten Frameworks, die von Systemanwendungen verwendet werden.
* Die vom Benutzer aus dem App Store installierten Anwendungen befinden sich in **`/User/Applications`**.
* Und das **`/User/Library`** enth√§lt Daten, die von Benutzeranwendungen auf Benutzerebene gespeichert wurden.
* Sie k√∂nnen auf **`/User/Library/Notes/notes.sqlite`** zugreifen, um die in der Anwendung gespeicherten Notizen zu lesen.
* Im Ordner einer installierten Anwendung (**`/User/Applications/<APP ID>/`**) finden Sie einige interessante Dateien:
  * **`iTunesArtwork`**: Das vom der App verwendete Symbol
  * **`iTunesMetadata.plist`**: Informationen zur App, die im App Store verwendet werden
  * **`/Library/*`**: Enth√§lt die Einstellungen und den Cache. In **`/Library/Cache/Snapshots/*`** finden Sie den vor dem Hintergrundsenden der Anwendung durchgef√ºhrten Snapshot.

### Hot Patching/Erzwungenes Update

Die Entwickler k√∂nnen alle Installationen ihrer App sofort remote **patchen**, ohne die Anwendung erneut im App Store einreichen und auf die Genehmigung warten zu m√ºssen.\
Zu diesem Zweck wird in der Regel [**JSPatch**](https://github.com/bang590/JSPatch) verwendet. Es gibt jedoch auch andere Optionen wie [Siren](https://github.com/ArtSabintsev/Siren) und [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Dies ist ein gef√§hrlicher Mechanismus, der von b√∂sartigen Drittanbieter-SDKs missbraucht werden k√∂nnte. Daher wird empfohlen, zu √ºberpr√ºfen, welche Methode zum automatischen Aktualisieren (falls vorhanden) verwendet wird, und diese zu testen.** Sie k√∂nnten versuchen, eine fr√ºhere Version der App f√ºr diesen Zweck herunterzuladen.

### Drittanbieter

Eine bedeutende Herausforderung bei **Drittanbieter-SDKs** ist der **Mangel an granularer Kontrolle** √ºber ihre Funktionalit√§ten. Entwickler stehen vor der Wahl: Entweder integrieren sie das SDK und akzeptieren alle seine Funktionen, einschlie√ülich potenzieller Sicherheitsl√ºcken und Datenschutzbedenken, oder verzichten vollst√§ndig auf dessen Vorteile. Oft k√∂nnen Entwickler Sicherheitsl√ºcken in diesen SDKs nicht selbst beheben. Dar√ºber hinaus k√∂nnen einige SDKs, wenn sie das Vertrauen der Community gewinnen, m√∂glicherweise Malware enthalten.

Die von Drittanbieter-SDKs bereitgestellten Dienste k√∂nnen das Tracking des Nutzerverhaltens, die Anzeige von Werbung oder die Verbesserung des Nutzererlebnisses umfassen. Dies birgt jedoch ein Risiko, da Entwickler m√∂glicherweise nicht vollst√§ndig √ºber den von diesen Bibliotheken ausgef√ºhrten Code informiert sind, was zu potenziellen Datenschutz- und Sicherheitsrisiken f√ºhren kann. Es ist entscheidend, die Informationen, die mit Drittanbieterdiensten geteilt werden, auf das Notwendigste zu beschr√§nken und sicherzustellen, dass keine sensiblen Daten preisgegeben werden.

Die Implementierung von Drittanbieterdiensten erfolgt in der Regel in zwei Formen: als eigenst√§ndige Bibliothek oder als vollst√§ndiges SDK. Um die Privatsph√§re der Benutzer zu sch√ºtzen, sollten alle mit diesen Diensten geteilten Daten **anonymisiert** werden, um die Offenlegung personenbezogener Informationen (PII) zu verhindern.

Um die Bibliotheken zu identifizieren, die eine Anwendung verwendet, kann das **`otool`**-Befehl verwendet werden. Dieses Tool sollte gegen die Anwendung und jede gemeinsam genutzte Bibliothek ausgef√ºhrt werden, um zus√§tzliche Bibliotheken zu entdecken.
```bash
otool -L <application_path>
```
## **Verweise & Weitere Ressourcen**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS kostenlose Kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C version [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift version
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos Workflows zu erstellen und zu **automatisieren**, unterst√ºtzt von den weltweit **fortschrittlichsten** Community-Tools.\
Heute Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
