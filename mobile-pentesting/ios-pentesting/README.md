# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire facilement et **automatiser des workflows** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>

## Bases d'iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Environnement de test

Sur cette page, vous trouverez des informations sur le **simulateur iOS**, les **√©mulateurs** et le **jailbreaking** :

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Analyse initiale

### Op√©rations de test de base sur iOS

Pendant le test, **plusieurs op√©rations seront sugg√©r√©es** (connexion √† l'appareil, lecture/√©criture/t√©l√©chargement de fichiers, utilisation de certains outils...). Par cons√©quent, si vous ne savez pas comment effectuer l'une de ces actions, veuillez **commencer par lire la page** :

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Pour les √©tapes suivantes, **l'application doit √™tre install√©e** sur l'appareil et vous devez d√©j√† avoir obtenu le **fichier IPA** de l'application.\
Lisez la page [Op√©rations de test de base sur iOS](basic-ios-testing-operations.md) pour apprendre comment faire cela.
{% endhint %}

### Analyse statique de base

Il est recommand√© d'utiliser l'outil [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) pour effectuer une analyse statique automatique du fichier IPA.

Identification des **protections pr√©sentes dans le binaire** :

*   **PIE (Executable √† adresses ind√©pendantes)** : Lorsqu'il est activ√©, l'application se charge √† une adresse m√©moire al√©atoire √† chaque lancement, ce qui rend plus difficile de pr√©dire son adresse m√©moire initiale.

```bash
otool -hv <app-binary> | grep PIE   # Il devrait inclure le drapeau PIE
```
*   **Canaris de pile** : Pour valider l'int√©grit√© de la pile, une valeur de ¬´ canari ¬ª est plac√©e sur la pile avant d'appeler une fonction et est valid√©e √† nouveau une fois que la fonction se termine.

```bash
otool -I -v <app-binary> | grep stack_chk   # Il devrait inclure les symboles : stack_chk_guard et stack_chk_fail
```
*   **ARC (Comptage automatique des r√©f√©rences)** : Pour pr√©venir les d√©fauts courants de corruption de m√©moire

```bash
otool -I -v <app-binary> | grep objc_release   # Il devrait inclure le symbole _objc_release
```
*   **Binaire chiffr√©** : Le binaire devrait √™tre chiffr√©

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Le cryptid devrait √™tre √† 1
```

**Identification des fonctions sensibles/non s√©curis√©es**

*   **Algorithmes de hachage faibles**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Sur linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Fonctions de g√©n√©ration de nombres al√©atoires non s√©curis√©es**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Sur linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Fonction 'Malloc' non s√©curis√©e**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_malloc"

# Sur linux
grep -iER "_malloc"
```
*   **Fonctions non s√©curis√©es et vuln√©rables**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Sur linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Analyse dynamique de base

Consultez l'analyse dynamique effectu√©e par [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Vous devrez naviguer √† travers les diff√©rentes vues et interagir avec elles, mais il accrochera plusieurs classes et fera d'autres choses, puis pr√©parera un rapport une fois que vous aurez termin√©.

### Liste des applications install√©es

Utilisez la commande `frida-ps -Uai` pour d√©terminer l'**identifiant de bundle** des applications install√©es :
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### √ânum√©ration de base & Hooking

Apprenez √† **√©num√©rer les composants de l'application** et comment **accrocher facilement des m√©thodes et des classes** avec objection :

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Structure de l'IPA

La structure d'un fichier **IPA** est essentiellement celle d'un **paquet compress√©**. En renommant son extension en `.zip`, il peut √™tre **d√©compress√©** pour r√©v√©ler son contenu. Dans cette structure, un **Bundle** repr√©sente une application enti√®rement empaquet√©e pr√™te pour l'installation. √Ä l'int√©rieur, vous trouverez un r√©pertoire nomm√© `<NOM>.app`, qui encapsule les ressources de l'application.

* **`Info.plist`** : Ce fichier contient des d√©tails de configuration sp√©cifiques de l'application.
* **`_CodeSignature/`** : Ce r√©pertoire inclut un fichier plist qui contient une signature, assurant l'int√©grit√© de tous les fichiers dans le bundle.
* **`Assets.car`** : Une archive compress√©e qui stocke des fichiers d'actifs tels que des ic√¥nes.
* **`Frameworks/`** : Ce dossier contient les biblioth√®ques natives de l'application, qui peuvent √™tre sous forme de fichiers `.dylib` ou `.framework`.
* **`PlugIns/`** : Cela peut inclure des extensions de l'application, appel√©es fichiers `.appex`, bien qu'ils ne soient pas toujours pr√©sents.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata) : Il est utilis√© pour sauvegarder les donn√©es permanentes de votre application pour une utilisation hors ligne, mettre en cache des donn√©es temporaires, et ajouter une fonctionnalit√© d'annulation √† votre application sur un seul appareil. Pour synchroniser les donn√©es sur plusieurs appareils dans un seul compte iCloud, Core Data refl√®te automatiquement votre sch√©ma dans un conteneur CloudKit.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html) : Le fichier `PkgInfo` est une fa√ßon alternative de sp√©cifier les codes de type et de cr√©ateur de votre application ou bundle.
* **en.lproj, fr.proj, Base.lproj** : Sont les packs de langues qui contiennent des ressources pour ces langues sp√©cifiques, et une ressource par d√©faut au cas o√π une langue n'est pas prise en charge.
* **S√©curit√©** : Le r√©pertoire `_CodeSignature/` joue un r√¥le critique dans la s√©curit√© de l'application en v√©rifiant l'int√©grit√© de tous les fichiers regroup√©s via des signatures num√©riques.
* **Gestion des actifs** : Le fichier `Assets.car` utilise la compression pour g√©rer efficacement les actifs graphiques, crucial pour optimiser les performances de l'application et r√©duire sa taille globale.
* **Cadres et PlugIns** : Ces r√©pertoires soulignent la modularit√© des applications iOS, permettant aux d√©veloppeurs d'inclure des biblioth√®ques de code r√©utilisables (`Frameworks/`) et d'√©tendre la fonctionnalit√© de l'application (`PlugIns/`).
* **Localisation** : La structure prend en charge plusieurs langues, facilitant la port√©e mondiale de l'application en incluant des ressources pour des packs de langues sp√©cifiques.

**Info.plist**

Le **Info.plist** sert de pierre angulaire pour les applications iOS, encapsulant des donn√©es de configuration cl√©s sous forme de paires **cl√©-valeur**. Ce fichier est requis non seulement pour les applications, mais aussi pour les extensions d'application et les frameworks inclus. Il est structur√© en XML ou en format binaire et contient des informations critiques allant des autorisations d'application aux configurations de s√©curit√©. Pour une exploration d√©taill√©e des cl√©s disponibles, on peut se r√©f√©rer √† la [**Documentation du d√©veloppeur Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Pour ceux qui souhaitent travailler avec ce fichier dans un format plus accessible, la conversion en XML peut √™tre r√©alis√©e facilement en utilisant `plutil` sur macOS (disponible nativement sur les versions 10.2 et ult√©rieures) ou `plistutil` sur Linux. Les commandes de conversion sont les suivantes :

* **Pour macOS** :
```bash
$ plutil -convert xml1 Info.plist
```
* **Pour Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Parmi la myriade d'informations que le fichier **Info.plist** peut divulguer, les entr√©es notables incluent les cha√Ænes de permissions de l'application (`UsageDescription`), les sch√©mas d'URL personnalis√©s (`CFBundleURLTypes`), et les configurations pour la s√©curit√© du transport de l'application (`NSAppTransportSecurity`). Ces entr√©es, ainsi que d'autres comme les types de documents personnalis√©s export√©s/import√©s (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), peuvent √™tre facilement localis√©s en inspectant le fichier ou en utilisant une simple commande `grep`:
```bash
$ grep -i <keyword> Info.plist
```
**Chemins des donn√©es**

Dans l'environnement iOS, des r√©pertoires sont sp√©cifiquement d√©sign√©s pour les **applications syst√®me** et les **applications install√©es par l'utilisateur**. Les applications syst√®me r√©sident dans le r√©pertoire `/Applications`, tandis que les applications install√©es par l'utilisateur sont plac√©es sous `/var/mobile/containers/Data/Application/`. Ces applications se voient attribuer un identifiant unique connu sous le nom d'**UUID de 128 bits**, rendant la t√¢che de localiser manuellement le dossier d'une application difficile en raison du caract√®re al√©atoire des noms de r√©pertoire.

{% hint style="warning" %}
Comme les applications sur iOS doivent √™tre isol√©es, chaque application aura √©galement un dossier √† l'int√©rieur de **`$HOME/Library/Containers`** avec l'**`CFBundleIdentifier`** de l'application comme nom de dossier.

Cependant, les deux dossiers (dossiers de donn√©es et de conteneurs) contiennent le fichier **`.com.apple.mobile_container_manager.metadata.plist`** qui lie les deux fichiers dans la cl√© `MCMetadataIdentifier`).
{% endhint %}

Pour faciliter la d√©couverte du r√©pertoire d'installation d'une application install√©e par l'utilisateur, l'outil **objection** fournit une commande utile, `env`. Cette commande r√©v√®le des informations d√©taill√©es sur le r√©pertoire de l'application en question. Voici un exemple d'utilisation de cette commande:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativement, le nom de l'application peut √™tre recherch√© dans `/private/var/containers` en utilisant la commande `find` :
```bash
find /private/var/containers -name "Progname*"
```
Les commandes telles que `ps` et `lsof` peuvent √©galement √™tre utilis√©es pour identifier le processus de l'application et lister les fichiers ouverts, respectivement, fournissant des informations sur les chemins d'acc√®s actifs de l'application :
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**R√©pertoire du bundle :**

* **AppName.app**
* Il s'agit du Bundle de l'application tel que vu pr√©c√©demment dans l'IPA, il contient des donn√©es d'application essentielles, du contenu statique ainsi que le binaire compil√© de l'application.
* Ce r√©pertoire est visible par les utilisateurs, mais **les utilisateurs ne peuvent pas y √©crire**.
* Le contenu de ce r√©pertoire n'est **pas sauvegard√©**.
* Les contenus de ce dossier sont utilis√©s pour **valider la signature du code**.

**R√©pertoire des donn√©es :**

* **Documents/**
* Contient toutes les donn√©es g√©n√©r√©es par l'utilisateur. L'utilisateur final de l'application initie la cr√©ation de ces donn√©es.
* Visible par les utilisateurs et **les utilisateurs peuvent y √©crire**.
* Le contenu de ce r√©pertoire est **sauvegard√©**.
* L'application peut d√©sactiver les chemins en d√©finissant `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Contient tous les **fichiers qui ne sont pas sp√©cifiques √† l'utilisateur**, tels que les **caches**, les **pr√©f√©rences**, les **cookies** et les fichiers de configuration de liste de propri√©t√©s (plist).
* Les applications iOS utilisent g√©n√©ralement les sous-r√©pertoires `Application Support` et `Caches`, mais l'application peut cr√©er des sous-r√©pertoires personnalis√©s.
* **Library/Caches/**
* Contient des fichiers mis en cache **semi-persistants**.
* Invisible pour les utilisateurs et **les utilisateurs ne peuvent pas y √©crire**.
* Le contenu de ce r√©pertoire n'est **pas sauvegard√©**.
* Le syst√®me d'exploitation peut supprimer automatiquement les fichiers de ce r√©pertoire lorsque l'application ne s'ex√©cute pas et que l'espace de stockage est insuffisant.
* **Library/Application Support/**
* Contient des **fichiers persistants** n√©cessaires au fonctionnement de l'application.
* **Invisible** pour les **utilisateurs** et les utilisateurs ne peuvent pas y √©crire.
* Le contenu de ce r√©pertoire est **sauvegard√©**.
* L'application peut d√©sactiver les chemins en d√©finissant `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Utilis√© pour stocker des propri√©t√©s qui peuvent **persister m√™me apr√®s le red√©marrage d'une application**.
* Les informations sont enregistr√©es, non chiffr√©es, √† l'int√©rieur du bac √† sable de l'application dans un fichier plist appel√© \[BUNDLE\_ID].plist.
* Toutes les paires cl√©/valeur stock√©es √† l'aide de `NSUserDefaults` peuvent √™tre trouv√©es dans ce fichier.
* **tmp/**
* Utilisez ce r√©pertoire pour √©crire des **fichiers temporaires** qui n'ont pas besoin de persister entre les lancements de l'application.
* Contient des fichiers mis en cache non persistants.
* **Invisible** pour les utilisateurs.
* Le contenu de ce r√©pertoire n'est pas sauvegard√©.
* Le syst√®me d'exploitation peut supprimer automatiquement les fichiers de ce r√©pertoire lorsque l'application ne s'ex√©cute pas et que l'espace de stockage est insuffisant.

Jetons un coup d'≈ìil plus attentif au r√©pertoire du Bundle de l'Application (.app) d'iGoat-Swift √† l'int√©rieur du r√©pertoire du Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) :
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### R√©versing binaire

√Ä l'int√©rieur du dossier `<nom-de-l'application>.app`, vous trouverez un fichier binaire appel√© `<nom-de-l'application>`. C'est le fichier qui sera **ex√©cut√©**. Vous pouvez effectuer une inspection de base du binaire avec l'outil **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**V√©rifier si l'application est chiffr√©e**

V√©rifiez s'il y a une sortie pour :
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**D√©sassemblage du binaire**

D√©sassemblez la section texte :
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Pour imprimer le segment **Objective-C** de l'application d'exemple, on peut utiliser :
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Pour obtenir un code Objective-C plus compact, vous pouvez utiliser [**class-dump**](http://stevenygard.com/projects/class-dump/) :
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Cependant, les meilleures options pour d√©sassembler le binaire sont : [**Hopper**](https://www.hopperapp.com/download.html?) et [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour cr√©er et **automatiser des workflows** facilement gr√¢ce aux outils communautaires les plus avanc√©s au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Stockage de donn√©es

Pour en savoir plus sur la mani√®re dont iOS stocke les donn√©es sur l'appareil, consultez cette page :

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Les emplacements suivants pour stocker des informations doivent √™tre v√©rifi√©s **juste apr√®s l'installation de l'application**, **apr√®s avoir v√©rifi√© toutes les fonctionnalit√©s** de l'application et m√™me apr√®s **d√©connexion d'un utilisateur et connexion d'un autre**.\
L'objectif est de trouver des **informations sensibles non prot√©g√©es** de l'application (mots de passe, jetons), de l'utilisateur actuel et des utilisateurs pr√©c√©demment connect√©s.
{% endhint %}

### Plist

Les fichiers **plist** sont des fichiers XML structur√©s qui **contiennent des paires cl√©-valeur**. C'est une fa√ßon de stocker des donn√©es persistantes, donc parfois vous pouvez trouver **des informations sensibles dans ces fichiers**. Il est recommand√© de v√©rifier ces fichiers apr√®s l'installation de l'application et apr√®s l'avoir utilis√©e intensivement pour voir si de nouvelles donn√©es sont √©crites.

La mani√®re la plus courante de persister les donn√©es dans les fichiers plist est par l'utilisation de **NSUserDefaults**. Ce fichier plist est enregistr√© √† l'int√©rieur du bac √† sable de l'application dans **`Library/Preferences/<appBundleID>.plist`**

La classe [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) fournit une interface programmatique pour interagir avec le syst√®me par d√©faut. Le syst√®me par d√©faut permet √† une application de personnaliser son comportement en fonction des **pr√©f√©rences de l'utilisateur**. Les donn√©es enregistr√©es par `NSUserDefaults` peuvent √™tre consult√©es dans le bundle de l'application. Cette classe stocke des **donn√©es** dans un **fichier plist**, mais elle est destin√©e √† √™tre utilis√©e avec de petites quantit√©s de donn√©es.

Ces donn√©es ne peuvent plus √™tre directement consult√©es via un ordinateur de confiance, mais peuvent √™tre consult√©es en effectuant une **sauvegarde**.

Vous pouvez **extraire** les informations enregistr√©es en utilisant **`NSUserDefaults`** en utilisant `ios nsuserdefaults get` d'objection.

Pour trouver tous les plist utilis√©s par l'application, vous pouvez acc√©der √† `/private/var/mobile/Containers/Data/Application/{APPID}` et ex√©cuter :
```bash
find ./ -name "*.plist"
```
Pour convertir des fichiers du format **XML ou binaire (bplist)** en XML, diverses m√©thodes sont disponibles en fonction de votre syst√®me d'exploitation :

**Pour les utilisateurs de macOS :** Utilisez la commande `plutil`. C'est un outil int√©gr√© dans macOS (10.2+), con√ßu √† cet effet :
```bash
$ plutil -convert xml1 Info.plist
```
**Pour les utilisateurs de Linux :** Installez d'abord `libplist-utils`, puis utilisez `plistutil` pour convertir votre fichier :
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Dans une session Objection :** Pour analyser les applications mobiles, une commande sp√©cifique vous permet de convertir directement les fichiers plist :
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) est un framework pour g√©rer la couche mod√®le des objets dans votre application. [Core Data peut utiliser SQLite comme son magasin persistant](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), mais le framework lui-m√™me n'est pas une base de donn√©es. CoreData n'encrypte pas ses donn√©es par d√©faut. Cependant, une couche d'encryption suppl√©mentaire peut √™tre ajout√©e √† CoreData. Consultez le [GitHub Repo](https://github.com/project-imas/encrypted-core-data) pour plus de d√©tails.

Vous pouvez trouver les informations SQLite Core Data d'une application dans le chemin `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Si vous pouvez ouvrir le SQLite et acc√©der √† des informations sensibles, alors vous avez trouv√© une mauvaise configuration.**
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) est un magasin de cl√©s/valeurs construit sur SQLite.\
Comme les bases de donn√©es Yap sont des bases de donn√©es sqlite, vous pouvez les trouver en utilisant la commande propos√©e dans la section pr√©c√©dente.

### Autres bases de donn√©es SQLite

Il est courant que les applications cr√©ent leur propre base de donn√©es sqlite. Elles peuvent **stocker** des **donn√©es sensibles** et les laisser non crypt√©es. Par cons√©quent, il est toujours int√©ressant de v√©rifier chaque base de donn√©es √† l'int√©rieur du r√©pertoire des applications. Allez donc dans le r√©pertoire de l'application o√π les donn√©es sont enregistr√©es (`/private/var/mobile/Containers/Data/Application/{APPID}`).
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Bases de donn√©es en temps r√©el Firebase

Les d√©veloppeurs peuvent **stocker et synchroniser des donn√©es** dans une **base de donn√©es h√©berg√©e dans le cloud NoSQL** gr√¢ce aux Bases de donn√©es en temps r√©el Firebase. Stock√©es au format JSON, les donn√©es sont synchronis√©es en temps r√©el avec tous les clients connect√©s.

Vous pouvez trouver comment v√©rifier les bases de donn√©es Firebase mal configur√©es ici:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Bases de donn√©es Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) et [Realm Swift](https://realm.io/docs/swift/latest/) offrent une alternative puissante pour le stockage de donn√©es, non fournie par Apple. Par d√©faut, ils **stockent des donn√©es non chiffr√©es**, avec le chiffrement disponible via une configuration sp√©cifique.

Les bases de donn√©es se trouvent √† : `/private/var/mobile/Containers/Data/Application/{APPID}`. Pour explorer ces fichiers, on peut utiliser des commandes telles que :
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Pour visualiser ces fichiers de base de donn√©es, l'outil [**Realm Studio**](https://github.com/realm/realm-studio) est recommand√©.

Pour impl√©menter le chiffrement dans une base de donn√©es Realm, le snippet de code suivant peut √™tre utilis√© :
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bases de donn√©es Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) est d√©crit comme un moteur de base de donn√©es **l√©ger** et **int√©gr√©** qui suit l'approche **orient√©e document** (NoSQL). Con√ßu pour √™tre natif d'**iOS** et **macOS**, il offre la capacit√© de synchroniser les donn√©es de mani√®re transparente.

Pour identifier les bases de donn√©es Couchbase potentielles sur un appareil, le r√©pertoire suivant doit √™tre inspect√© :
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOS stocke les cookies des applications dans le **`Library/Cookies/cookies.binarycookies`** √† l'int√©rieur de chaque dossier d'application. Cependant, les d√©veloppeurs d√©cident parfois de les sauvegarder dans le **trousseau** car le **fichier de cookie mentionn√© peut √™tre acc√©d√© dans les sauvegardes**.

Pour inspecter le fichier de cookies, vous pouvez utiliser [**ce script python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ou utiliser la commande **`ios cookies get`** d'objection.\
**Vous pouvez √©galement utiliser objection pour** convertir ces fichiers en format JSON et inspecter les donn√©es.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Par d√©faut, NSURLSession stocke des donn√©es, telles que les **requ√™tes HTTP et les r√©ponses dans la base de donn√©es Cache.db**. Cette base de donn√©es peut contenir des **donn√©es sensibles**, si des jetons, des noms d'utilisateur ou toute autre information sensible ont √©t√© mises en cache. Pour trouver les informations mises en cache, ouvrez le r√©pertoire de donn√©es de l'application (`/var/mobile/Containers/Data/Application/<UUID>`) et allez dans `/Library/Caches/<Bundle Identifier>`. Le **cache WebKit est √©galement stock√© dans le fichier Cache.db**. **Objection** peut ouvrir et interagir avec la base de donn√©es avec la commande `sqlite connect Cache.db`, car il s'agit d'une **base de donn√©es SQLite normale**.

Il est **recommand√© de d√©sactiver la mise en cache de ces donn√©es**, car elles peuvent contenir des informations sensibles dans la requ√™te ou la r√©ponse. La liste ci-dessous montre diff√©rentes fa√ßons d'y parvenir :

1. Il est recommand√© de supprimer les r√©ponses mises en cache apr√®s la d√©connexion. Cela peut √™tre fait avec la m√©thode fournie par Apple appel√©e [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) Vous pouvez appeler cette m√©thode comme suit :

`URLCache.shared.removeAllCachedResponses()`

Cette m√©thode supprimera toutes les requ√™tes et r√©ponses mises en cache du fichier Cache.db.
2. Si vous n'avez pas besoin d'utiliser les cookies, il est recommand√© d'utiliser simplement la propri√©t√© de configuration [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) de URLSession, qui d√©sactivera l'enregistrement des cookies et des caches.

[Documentation Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) :

`Un objet de configuration de session √©ph√©m√®re est similaire √† une configuration de session par d√©faut (voir default), sauf que l'objet de session correspondant ne stocke pas de caches, de magasins de certificats ou de donn√©es li√©es √† la session sur le disque. Au lieu de cela, les donn√©es li√©es √† la session sont stock√©es en RAM. La seule fois o√π une session √©ph√©m√®re √©crit des donn√©es sur le disque est lorsque vous lui demandez d'√©crire le contenu d'une URL dans un fichier.`
3. Le cache peut √©galement √™tre d√©sactiv√© en d√©finissant la politique de cache sur [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Cela d√©sactivera le stockage du cache de quelque mani√®re que ce soit, que ce soit en m√©moire ou sur disque.

### Snapshots

Chaque fois que vous appuyez sur le bouton d'accueil, iOS **prend un instantan√© de l'√©cran actuel** pour pouvoir effectuer la transition vers l'application de mani√®re plus fluide. Cependant, si des **donn√©es sensibles** sont pr√©sentes √† l'√©cran actuel, elles seront **enregistr√©es** dans l'**image** (qui **persiste** **√† travers** les **red√©marrages**). Ce sont les instantan√©s auxquels vous pouvez √©galement acc√©der en double-cliquant sur l'√©cran d'accueil pour basculer entre les applications.

Sauf si l'iPhone est jailbreak√©, l'**attaquant** doit avoir **acc√®s** au **dispositif** **d√©bloqu√©** pour voir ces captures d'√©cran. Par d√©faut, le dernier instantan√© est stock√© dans le sandbox de l'application dans le dossier `Library/Caches/Snapshots/` ou `Library/SplashBoard/Snapshots` (les ordinateurs de confiance ne peuvent pas acc√©der au syst√®me de fichiers √† partir de iOX 7.0).

Une fa√ßon de pr√©venir ce mauvais comportement est de mettre un √©cran vide ou de supprimer les donn√©es sensibles avant de prendre l'instantan√© en utilisant la fonction `ApplicationDidEnterBackground()`.

Voici une m√©thode de rem√©diation d'exemple qui d√©finira une capture d'√©cran par d√©faut.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C :
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Cela d√©finit l'image d'arri√®re-plan sur `overlayImage.png` chaque fois que l'application passe en arri√®re-plan. Cela emp√™che les fuites de donn√©es sensibles car `overlayImage.png` remplacera toujours la vue actuelle.

### Trousseau

Pour acc√©der et g√©rer le trousseau iOS, des outils comme [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) sont disponibles, adapt√©s aux appareils jailbreak√©s. De plus, [**Objection**](https://github.com/sensepost/objection) fournit la commande `ios keychain dump` √† des fins similaires.

#### **Stockage des identifiants**

La classe **NSURLCredential** est id√©ale pour enregistrer des informations sensibles directement dans le trousseau, contournant ainsi le besoin de NSUserDefaults ou d'autres wrappers. Pour stocker les identifiants apr√®s la connexion, le code Swift suivant est utilis√©:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Pour extraire ces informations d'identification stock√©es, la commande `ios nsurlcredentialstorage dump` d'Objection est utilis√©e.

## **Claviers personnalis√©s et cache du clavier**

√Ä partir d'iOS 8.0, les utilisateurs peuvent installer des extensions de clavier personnalis√©es, qui sont g√©rables sous **R√©glages > G√©n√©ral > Clavier > Claviers**. Bien que ces claviers offrent une fonctionnalit√© √©tendue, ils posent un risque de journalisation des frappes et de transmission de donn√©es √† des serveurs externes, bien que les utilisateurs soient inform√©s des claviers n√©cessitant un acc√®s r√©seau. Les applications peuvent, et doivent, restreindre l'utilisation des claviers personnalis√©s pour la saisie d'informations sensibles.

**Recommandations en mati√®re de s√©curit√© :**

* Il est conseill√© de d√©sactiver les claviers tiers pour une s√©curit√© renforc√©e.
* Soyez conscient des fonctionnalit√©s de correction automatique et de suggestions automatiques du clavier iOS par d√©faut, qui pourraient stocker des informations sensibles dans des fichiers cache situ√©s dans `Library/Keyboard/{locale}-dynamic-text.dat` ou `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Ces fichiers cache doivent √™tre r√©guli√®rement v√©rifi√©s pour des donn√©es sensibles. Il est recommand√© de r√©initialiser le dictionnaire du clavier via **R√©glages > G√©n√©ral > R√©initialiser > R√©initialiser le dictionnaire du clavier** pour effacer les donn√©es mises en cache.
* L'interception du trafic r√©seau peut r√©v√©ler si un clavier personnalis√© transmet des frappes √† distance.

### **Pr√©vention de la mise en cache des champs de texte**

Le [protocole UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) offre des propri√©t√©s pour g√©rer la correction automatique et la saisie de texte s√©curis√©e, essentielles pour pr√©venir la mise en cache d'informations sensibles. Par exemple, la d√©sactivation de la correction automatique et l'activation de la saisie de texte s√©curis√©e peuvent √™tre r√©alis√©es avec :
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
De plus, les d√©veloppeurs doivent s'assurer que les champs de texte, en particulier ceux destin√©s √† saisir des informations sensibles telles que des mots de passe et des NIP, d√©sactivent la mise en cache en d√©finissant `autocorrectionType` sur `UITextAutocorrectionTypeNo` et `secureTextEntry` sur `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Journaux**

Le d√©bogage du code implique souvent l'utilisation de **journaux**. Il y a un risque car les **journaux peuvent contenir des informations sensibles**. Auparavant, dans iOS 6 et les versions ant√©rieures, les journaux √©taient accessibles √† toutes les applications, posant un risque de fuite de donn√©es sensibles. **Maintenant, les applications sont limit√©es √† l'acc√®s uniquement √† leurs journaux**.

Malgr√© ces restrictions, un **attaquant ayant un acc√®s physique** √† un appareil d√©verrouill√© peut toujours exploiter cela en connectant l'appareil √† un ordinateur et **en lisant les journaux**. Il est important de noter que les journaux restent sur le disque m√™me apr√®s la d√©sinstallation de l'application.

Pour att√©nuer les risques, il est conseill√© d'**interagir pleinement avec l'application**, en explorant toutes ses fonctionnalit√©s et entr√©es pour s'assurer qu'aucune information sensible n'est enregistr√©e involontairement.

Lors de l'examen du code source de l'application pour des fuites potentielles, recherchez √† la fois les **d√©clarations de journalisation pr√©d√©finies** et **personnalis√©es** en utilisant des mots-cl√©s tels que `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` pour les fonctions int√©gr√©es, et toute mention de `Logging` ou `Logfile` pour des impl√©mentations personnalis√©es.

### **Surveillance des journaux syst√®me**

Les applications enregistrent diverses informations qui peuvent √™tre sensibles. Pour surveiller ces journaux, des outils et des commandes comme :
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
Sont utiles. De plus, **Xcode** fournit un moyen de collecter des journaux de console :

1. Ouvrez Xcode.
2. Connectez l'appareil iOS.
3. Acc√©dez √† **Fen√™tre** -> **Appareils et simulateurs**.
4. S√©lectionnez votre appareil.
5. D√©clenchez le probl√®me que vous √©tudiez.
6. Utilisez le bouton **Ouvrir la console** pour afficher les journaux dans une nouvelle fen√™tre.

Pour des journaux plus avanc√©s, se connecter √† l'interpr√©teur de commandes de l'appareil et utiliser **socat** peut fournir une surveillance des journaux en temps r√©el :
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Suivi des commandes pour observer les activit√©s de journal, qui peuvent √™tre inestimables pour diagnostiquer les probl√®mes ou identifier des fuites de donn√©es potentielles dans les journaux.

***

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire facilement et **automatiser des flux de travail** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Sauvegardes

Les fonctionnalit√©s de **sauvegarde automatique** sont int√©gr√©es √† iOS, facilitant la cr√©ation de copies des donn√©es de l'appareil via iTunes (jusqu'√† macOS Catalina), Finder (√† partir de macOS Catalina) ou iCloud. Ces sauvegardes englobent presque toutes les donn√©es de l'appareil, √† l'exception d'√©l√©ments hautement sensibles tels que les d√©tails d'Apple Pay et les configurations Touch ID.

### Risques de s√©curit√©

L'inclusion des **applications install√©es et de leurs donn√©es** dans les sauvegardes soul√®ve la question d'une **fuite de donn√©es potentielle** et du risque que les **modifications de sauvegarde puissent alt√©rer la fonctionnalit√© de l'application**. Il est conseill√© de **ne pas stocker d'informations sensibles en texte brut** dans le r√©pertoire d'une application ou ses sous-r√©pertoires pour att√©nuer ces risques.

### Exclusion de fichiers des sauvegardes

Les fichiers dans `Documents/` et `Library/Application Support/` sont sauvegard√©s par d√©faut. Les d√©veloppeurs peuvent exclure des fichiers ou des r√©pertoires sp√©cifiques des sauvegardes en utilisant `NSURL setResourceValue:forKey:error:` avec la cl√© `NSURLIsExcludedFromBackupKey`. Cette pratique est cruciale pour prot√©ger les donn√©es sensibles contre leur inclusion dans les sauvegardes.

### Test des vuln√©rabilit√©s

Pour √©valuer la s√©curit√© de la sauvegarde d'une application, commencez par **cr√©er une sauvegarde** en utilisant Finder, puis localisez-la en suivant les instructions de la [documentation officielle d'Apple](https://support.apple.com/en-us/HT204215). Analysez la sauvegarde pour y rep√©rer des donn√©es sensibles ou des configurations qui pourraient √™tre modifi√©es pour affecter le comportement de l'application.

Les informations sensibles peuvent √™tre recherch√©es √† l'aide d'outils en ligne de commande ou d'applications comme [iMazing](https://imazing.com). Pour les sauvegardes chiffr√©es, la pr√©sence de chiffrement peut √™tre confirm√©e en v√©rifiant la cl√© "IsEncrypted" dans le fichier "Manifest.plist" √† la racine de la sauvegarde.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Pour traiter les sauvegardes chiffr√©es, les scripts Python disponibles dans le [d√©p√¥t GitHub de DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), tels que **backup\_tool.py** et **backup\_passwd.py**, peuvent √™tre utiles, bien qu'ils n√©cessitent √©ventuellement des ajustements pour √™tre compatibles avec les derni√®res versions d'iTunes/Finder. L'outil [**iOSbackup**](https://pypi.org/project/iOSbackup/) est une autre option pour acc√©der aux fichiers dans les sauvegardes prot√©g√©es par mot de passe.

### Modification du comportement de l'application

Un exemple de modification du comportement de l'application via des modifications de sauvegarde est d√©montr√© dans l'application de portefeuille Bitcoin Bither (https://github.com/bither/bither-ios), o√π le code PIN de verrouillage de l'interface utilisateur est stock√© dans `net.bither.plist` sous la cl√© **pin\_code**. En supprimant cette cl√© du plist et en restaurant la sauvegarde, l'exigence du code PIN est supprim√©e, offrant un acc√®s illimit√©.

## R√©sum√© sur les tests de m√©moire pour les donn√©es sensibles

Lorsqu'il s'agit d'informations sensibles stock√©es dans la m√©moire d'une application, il est crucial de limiter le temps d'exposition de ces donn√©es. Il existe deux approches principales pour enqu√™ter sur le contenu de la m√©moire : **cr√©er un vidage de m√©moire** et **analyser la m√©moire en temps r√©el**. Les deux m√©thodes pr√©sentent des d√©fis, y compris la possibilit√© de manquer des donn√©es critiques lors du processus de vidage ou d'analyse.

## **R√©cup√©ration et analyse d'un vidage de m√©moire**

Pour les appareils jailbreak√©s et non jailbreak√©s, des outils tels que [objection](https://github.com/sensepost/objection) et [Fridump](https://github.com/Nightbringer21/fridump) permettent de faire un vidage de la m√©moire d'un processus d'application. Une fois le vidage effectu√©, l'analyse de ces donn√©es n√©cessite divers outils, en fonction de la nature des informations recherch√©es.

Pour extraire des cha√Ænes d'un vidage de m√©moire, des commandes telles que `strings` ou `rabin2 -zz` peuvent √™tre utilis√©es :
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Pour une analyse plus d√©taill√©e, y compris la recherche de types de donn√©es ou de motifs sp√©cifiques, **radare2** offre des capacit√©s de recherche √©tendues :
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Analyse de la m√©moire en temps d'ex√©cution**

**r2frida** offre une alternative puissante pour inspecter la m√©moire d'une application en temps r√©el, sans avoir besoin d'un vidage de m√©moire. Cet outil permet l'ex√©cution de commandes de recherche directement sur la m√©moire de l'application en cours d'ex√©cution :
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Cryptographie D√©faillante

### Processus de Gestion de Cl√©s M√©diocres

Certains d√©veloppeurs enregistrent des donn√©es sensibles dans le stockage local et les cryptent avec une cl√© cod√©e en dur/pr√©visible dans le code. Ceci ne devrait pas √™tre fait car une r√©tro-ing√©nierie pourrait permettre aux attaquants d'extraire les informations confidentielles.

### Utilisation d'Algorithmes Ins√©curis√©s et/ou Obsol√®tes

Les d√©veloppeurs ne devraient pas utiliser des **algorithmes obsol√®tes** pour effectuer des **v√©rifications** d'autorisation, **stocker** ou **envoyer** des donn√©es. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hashes** sont utilis√©s pour stocker des mots de passe par exemple, des **hashes r√©sistants** aux attaques par force brute devraient √™tre utilis√©s avec du sel.

### V√©rification

Les principales v√©rifications √† effectuer consistent √† rechercher des mots de passe/secrets **cod√©s en dur** dans le code, ou si ceux-ci sont **pr√©visibles**, et si le code utilise une sorte d'algorithmes de **cryptographie** **faibles**.

Il est int√©ressant de savoir que vous pouvez **surveiller** automatiquement certaines **biblioth√®ques de cryptographie** en utilisant **objection** avec :
```swift
ios monitor crypt
```
Pour **plus d'informations** sur les API et biblioth√®ques cryptographiques iOS, acc√©dez √† [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Authentification locale

L'**authentification locale** joue un r√¥le crucial, surtout lorsqu'il s'agit de prot√©ger l'acc√®s √† un point d'extr√©mit√© distant √† travers des m√©thodes cryptographiques. L'essence ici est qu'une impl√©mentation correcte est essentielle, sinon les m√©canismes d'authentification locale peuvent √™tre contourn√©s.

Le [**framework d'authentification locale d'Apple**](https://developer.apple.com/documentation/localauthentication) et le [**trousseau**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) fournissent des API robustes aux d√©veloppeurs pour faciliter les dialogues d'authentification utilisateur et g√©rer de mani√®re s√©curis√©e des donn√©es secr√®tes. L'Enclave s√©curis√©e s√©curise l'empreinte digitale pour Touch ID, tandis que Face ID repose sur la reconnaissance faciale sans compromettre les donn√©es biom√©triques.

Pour int√©grer Touch ID/Face ID, les d√©veloppeurs ont deux choix d'API :

* **`LocalAuthentication.framework`** pour une authentification utilisateur de haut niveau sans acc√®s aux donn√©es biom√©triques.
* **`Security.framework`** pour un acc√®s aux services de trousseau de bas niveau, s√©curisant les donn√©es secr√®tes avec une authentification biom√©trique. Divers [enveloppes open-source](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) rendent l'acc√®s au trousseau plus simple.

{% hint style="danger" %}
Cependant, √† la fois `LocalAuthentication.framework` et `Security.framework` pr√©sentent des vuln√©rabilit√©s, car ils retournent principalement des valeurs bool√©ennes sans transmettre de donn√©es pour les processus d'authentification, les rendant ainsi susceptibles d'√™tre contourn√©s (voir [Ne me touchez pas de cette fa√ßon, par David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Impl√©mentation de l'authentification locale

Pour demander aux utilisateurs une authentification, les d√©veloppeurs devraient utiliser la m√©thode **`evaluatePolicy`** au sein de la classe **`LAContext`**, en choisissant entre :

* **`deviceOwnerAuthentication`** : Demande l'empreinte digitale ou le code d'acc√®s de l'appareil, √©chouant si aucun des deux n'est activ√©.
* **`deviceOwnerAuthenticationWithBiometrics`** : Demande exclusivement l'empreinte digitale.

Une authentification r√©ussie est indiqu√©e par une valeur de retour bool√©enne de **`evaluatePolicy`**, mettant en √©vidence une faille de s√©curit√© potentielle.

### Authentification locale en utilisant le trousseau

Impl√©menter l'**authentification locale** dans les applications iOS implique l'utilisation des **API de trousseau** pour stocker de mani√®re s√©curis√©e des donn√©es secr√®tes telles que des jetons d'authentification. Ce processus garantit que les donn√©es ne peuvent √™tre acc√©d√©es que par l'utilisateur, en utilisant son code d'acc√®s de l'appareil ou une authentification biom√©trique comme Touch ID.

Le trousseau offre la possibilit√© de d√©finir des √©l√©ments avec l'attribut `SecAccessControl`, qui restreint l'acc√®s √† l'√©l√©ment jusqu'√† ce que l'utilisateur s'authentifie avec succ√®s via Touch ID ou le code d'acc√®s de l'appareil. Cette fonctionnalit√© est cruciale pour renforcer la s√©curit√©.

Voici des exemples de code en Swift et en Objective-C d√©montrant comment enregistrer et r√©cup√©rer une cha√Æne dans/depuis le trousseau, en tirant parti de ces fonctionnalit√©s de s√©curit√©. Les exemples montrent sp√©cifiquement comment configurer le contr√¥le d'acc√®s pour exiger une authentification Touch ID et garantir que les donn√©es ne sont accessibles que sur l'appareil o√π elles ont √©t√© configur√©es, √† condition qu'un code d'acc√®s de l'appareil soit configur√©.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}

### Analyzing iOS Applications

#### Static Analysis

During static analysis, you can use tools like class-dump-z and otool to extract information from the binary file of the iOS application. This information can include class and method names, as well as details about the application's architecture.

#### Dynamic Analysis

For dynamic analysis, you can use tools like Cycript and Frida to interact with the running iOS application. These tools allow you to inspect and manipulate the application's runtime behavior, making it easier to understand how the application works and identify potential security issues.

#### Network Traffic Analysis

Analyzing the network traffic generated by an iOS application can help you identify sensitive information being sent over the network in plaintext. Tools like Burp Suite and Wireshark can be used to intercept and analyze this network traffic.

#### File System Analysis

Examining the files stored on the iOS device can reveal valuable information about the application's data storage mechanisms. Tools like iExplorer and iFunBox can be used to explore the file system of the device and extract relevant data for analysis.

#### Jailbreak Detection Bypass

Some iOS applications implement jailbreak detection mechanisms to prevent them from running on jailbroken devices. Techniques like method swizzling and hooking can be used to bypass these detection mechanisms and run the application on a jailbroken device.

#### Runtime Manipulation

Tools like Cycript and Frida can also be used for runtime manipulation of iOS applications. By injecting scripts into the application's runtime environment, you can modify its behavior in real-time, allowing you to test for vulnerabilities and security weaknesses.

#### Data Storage Analysis

Analyzing how an iOS application stores sensitive data locally can help you identify potential security risks. By examining the application's data storage mechanisms, you can determine if sensitive information is being stored securely or if there are vulnerabilities that could lead to data leakage.

#### Reverse Engineering

Reverse engineering an iOS application can provide valuable insights into how the application is designed and implemented. Tools like Hopper and IDA Pro can be used to disassemble the application's binary code and analyze its underlying logic and algorithms.

#### Code Injection

Injecting code into an iOS application can help you understand how the application processes data and interacts with external components. Tools like Frida and objection can be used to inject code into the application's runtime environment and manipulate its behavior for testing and analysis purposes.

#### Exploitation

Identifying and exploiting vulnerabilities in an iOS application can lead to unauthorized access to sensitive data or the compromise of the application's functionality. By using techniques like buffer overflows and format string vulnerabilities, you can attempt to exploit security weaknesses in the application and gain control over its execution flow.

#### Cryptography Analysis

Analyzing how an iOS application implements cryptography can help you assess the security of its data protection mechanisms. By examining the application's use of encryption algorithms and key management practices, you can identify potential weaknesses that could be exploited by an attacker to decrypt sensitive information.

#### Code Signing Bypass

iOS applications are required to be signed with a valid code signature to run on iOS devices. Bypassing code signing checks can allow you to run modified or unsigned applications on a device, potentially exposing it to security risks. Techniques like patching the binary code or using jailbreak tweaks can be used to bypass code signing restrictions.

#### Memory Analysis

Analyzing the memory usage of an iOS application can help you identify vulnerabilities related to memory management, such as buffer overflows or memory leaks. Tools like Frida and LLDB can be used to inspect the application's memory space and detect potential memory-related security issues.

#### WebView Analysis

Many iOS applications use web views to display web content within the app. Analyzing how the application interacts with web views can help you identify security risks related to web content loading and processing. Tools like Burp Suite and Frida can be used to intercept and analyze web view traffic for potential vulnerabilities.

#### API Security Testing

Testing the security of APIs used by an iOS application is crucial for ensuring the overall security of the app. By analyzing how the application interacts with external APIs and identifying potential security weaknesses, you can prevent unauthorized access to sensitive data and protect the app from API-related vulnerabilities.

#### Jailbreak Detection Evasion

Evading jailbreak detection mechanisms implemented by an iOS application can allow you to run the app on a jailbroken device without restrictions. Techniques like method swizzling, runtime hooking, and binary patching can be used to bypass jailbreak detection checks and run the application in a jailbroken environment.

#### SSL Pinning Bypass

SSL pinning is a security mechanism used by iOS applications to prevent man-in-the-middle attacks on SSL/TLS connections. Bypassing SSL pinning can allow you to intercept and analyze encrypted network traffic for security testing purposes. Tools like Frida and Objection can be used to bypass SSL pinning checks and inspect SSL/TLS communication.

#### Data Validation Testing

Testing the input validation mechanisms implemented by an iOS application is essential for preventing common security vulnerabilities like injection attacks and data manipulation. By analyzing how the application validates user input and identifying potential weaknesses, you can ensure that the app is protected against data tampering and exploitation.

#### Binary Analysis

Analyzing the binary code of an iOS application can help you understand its inner workings and identify potential security flaws. Tools like IDA Pro and Hopper can be used to disassemble the application's binary code and analyze its structure, functions, and dependencies for security assessment and vulnerability identification.

#### Code Obfuscation

iOS applications often use code obfuscation techniques to protect their intellectual property and prevent reverse engineering. Analyzing how an application is obfuscated can help you uncover hidden functionality and security vulnerabilities that may be obscured by obfuscation. Tools like Hopper and IDA Pro can assist in deobfuscating iOS applications for security analysis and testing.

#### Keychain Analysis

Analyzing how an iOS application uses the keychain for storing sensitive information like passwords and cryptographic keys can help you assess the security of its data protection mechanisms. By examining how the application interacts with the keychain and identifying potential vulnerabilities, you can determine if sensitive data is being adequately protected or if there are weaknesses that could be exploited by an attacker.

#### URL Scheme Analysis

Many iOS applications use custom URL schemes to communicate with other apps and services on the device. Analyzing how an application handles URL schemes can help you identify security risks related to inter-app communication and data sharing. Tools like Frida and Objection can be used to intercept and analyze URL scheme interactions for potential vulnerabilities and security weaknesses.

#### Third-Party Library Analysis

iOS applications often rely on third-party libraries to implement various features and functionalities. Analyzing the security of these third-party libraries is crucial for identifying potential vulnerabilities that could be exploited by an attacker. By examining how the application integrates and uses third-party libraries, you can assess the overall security posture of the app and mitigate any security risks associated with third-party dependencies.

#### Jailbreak Detection Bypass

Some iOS applications implement jailbreak detection mechanisms to prevent them from running on jailbroken devices. Techniques like method swizzling and hooking can be used to bypass these detection mechanisms and run the application on a jailbroken device.

#### Runtime Manipulation

Tools like Cycript and Frida can also be used for runtime manipulation of iOS applications. By injecting scripts into the application's runtime environment, you can modify its behavior in real-time, allowing you to test for vulnerabilities and security weaknesses.

#### Data Storage Analysis

Analyzing how an iOS application stores sensitive data locally can help you identify potential security risks. By examining the application's data storage mechanisms, you can determine if sensitive information is being stored securely or if there are vulnerabilities that could lead to data leakage.

#### Reverse Engineering

Reverse engineering an iOS application can provide valuable insights into how the application is designed and implemented. Tools like Hopper and IDA Pro can be used to disassemble the application's binary code and analyze its underlying logic and algorithms.

#### Code Injection

Injecting code into an iOS application can help you understand how the application processes data and interacts with external components. Tools like Frida and objection can be used to inject code into the application's runtime environment and manipulate its behavior for testing and analysis purposes.

#### Exploitation

Identifying and exploiting vulnerabilities in an iOS application can lead to unauthorized access to sensitive data or the compromise of the application's functionality. By using techniques like buffer overflows and format string vulnerabilities, you can attempt to exploit security weaknesses in the application and gain control over its execution flow.

#### Cryptography Analysis

Analyzing how an iOS application implements cryptography can help you assess the security of its data protection mechanisms. By examining the application's use of encryption algorithms and key management practices, you can identify potential weaknesses that could be exploited by an attacker to decrypt sensitive information.

#### Code Signing Bypass

iOS applications are required to be signed with a valid code signature to run on iOS devices. Bypassing code signing checks can allow you to run modified or unsigned applications on a device, potentially exposing it to security risks. Techniques like patching the binary code or using jailbreak tweaks can be used to bypass code signing restrictions.

#### Memory Analysis

Analyzing the memory usage of an iOS application can help you identify vulnerabilities related to memory management, such as buffer overflows or memory leaks. Tools like Frida and LLDB can be used to inspect the application's memory space and detect potential memory-related security issues.

#### WebView Analysis

Many iOS applications use web views to display web content within the app. Analyzing how the application interacts with web views can help you identify security risks related to web content loading and processing. Tools like Burp Suite and Frida can be used to intercept and analyze web view traffic for potential vulnerabilities.

#### API Security Testing

Testing the security of APIs used by an iOS application is crucial for ensuring the overall security of the app. By analyzing how the application interacts with external APIs and identifying potential security weaknesses, you can prevent unauthorized access to sensitive data and protect the app from API-related vulnerabilities.

#### Jailbreak Detection Evasion

Evading jailbreak detection mechanisms implemented by an iOS application can allow you to run the app on a jailbroken device without restrictions. Techniques like method swizzling, runtime hooking, and binary patching can be used to bypass jailbreak detection checks and run the application in a jailbroken environment.

#### SSL Pinning Bypass

SSL pinning is a security mechanism used by iOS applications to prevent man-in-the-middle attacks on SSL/TLS connections. Bypassing SSL pinning can allow you to intercept and analyze encrypted network traffic for security testing purposes. Tools like Frida and Objection can be used to bypass SSL pinning checks and inspect SSL/TLS communication.

#### Data Validation Testing

Testing the input validation mechanisms implemented by an iOS application is essential for preventing common security vulnerabilities like injection attacks and data manipulation. By analyzing how the application validates user input and identifying potential weaknesses, you can ensure that the app is protected against data tampering and exploitation.

#### Binary Analysis

Analyzing the binary code of an iOS application can help you understand its inner workings and identify potential security flaws. Tools like IDA Pro and Hopper can be used to disassemble the application's binary code and analyze its structure, functions, and dependencies for security assessment and vulnerability identification.

#### Code Obfuscation

iOS applications often use code obfuscation techniques to protect their intellectual property and prevent reverse engineering. Analyzing how an application is obfuscated can help you uncover hidden functionality and security vulnerabilities that may be obscured by obfuscation. Tools like Hopper and IDA Pro can assist in deobfuscating iOS applications for security analysis and testing.

#### Keychain Analysis

Analyzing how an iOS application uses the keychain for storing sensitive information like passwords and cryptographic keys can help you assess the security of its data protection mechanisms. By examining how the application interacts with the keychain and identifying potential vulnerabilities, you can determine if sensitive data is being adequately protected or if there are weaknesses that could be exploited by an attacker.

#### URL Scheme Analysis

Many iOS applications use custom URL schemes to communicate with other apps and services on the device. Analyzing how an application handles URL schemes can help you identify security risks related to inter-app communication and data sharing. Tools like Frida and Objection can be used to intercept and analyze URL scheme interactions for potential vulnerabilities and security weaknesses.

#### Third-Party Library Analysis

iOS applications often rely on third-party libraries to implement various features and functionalities. Analyzing the security of these third-party libraries is crucial for identifying potential vulnerabilities that could be exploited by an attacker. By examining how the application integrates and uses third-party libraries, you can assess the overall security posture of the app and mitigate any security risks associated with third-party dependencies.

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Maintenant, nous pouvons demander l'√©l√©ment enregistr√© depuis le trousseau. Les services du trousseau pr√©senteront le dialogue d'authentification √† l'utilisateur et renverront des donn√©es ou nil en fonction de la fourniture ou non d'une empreinte digitale appropri√©e.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %} 

## M√©thodes de d√©tection des jailbreaks

### 1. V√©rification des fichiers syst√®me

- Recherche de fichiers syst√®me sp√©cifiques aux jailbreaks tels que `/Applications/Cydia.app`, `/Library/MobileSubstrate/MobileSubstrate.dylib`, etc.

### 2. V√©rification des processus en cours d'ex√©cution

- V√©rification des processus en cours d'ex√©cution pour d√©tecter des processus associ√©s au jailbreak tels que `sshd`, `Cydia`, etc.

### 3. V√©rification des symboles

- Recherche de symboles sp√©cifiques aux jailbreaks dans les fichiers binaires de l'application.

### 4. V√©rification des fichiers de configuration

- Recherche de fichiers de configuration sp√©cifiques aux jailbreaks tels que `/etc/apt/sources.list.d/cydia.list`, `/var/lib/cydia`, etc.

### 5. V√©rification des fichiers de pr√©f√©rences

- Recherche de fichiers de pr√©f√©rences sp√©cifiques aux jailbreaks tels que `/var/mobile/Library/Preferences/com.saurik.Cydia.plist`, etc.

### 6. V√©rification des URL de sch√©ma

- Recherche d'URL de sch√©ma sp√©cifiques aux jailbreaks dans le code de l'application.

### 7. V√©rification des fichiers de cache

- Recherche de fichiers de cache sp√©cifiques aux jailbreaks tels que `/var/cache/apt`, `/var/tmp/cydia`, etc.

### 8. V√©rification des fichiers de log

- Recherche de fichiers de log sp√©cifiques aux jailbreaks tels que `/var/log/syslog`, `/var/log/apt/history.log`, etc.

### 9. V√©rification des fichiers de base de donn√©es

- Recherche de bases de donn√©es sp√©cifiques aux jailbreaks telles que `com.saurik.Cydia`, etc.

### 10. V√©rification des fichiers de cl√©s SSH

- Recherche de fichiers de cl√©s SSH dans le syst√®me de fichiers de l'application.

### 11. V√©rification des fichiers de certificats

- Recherche de certificats sp√©cifiques aux jailbreaks dans le trousseau de l'application.

### 12. V√©rification des fichiers de profil

- Recherche de fichiers de profil sp√©cifiques aux jailbreaks dans le syst√®me de fichiers de l'application.

### 13. V√©rification des fichiers de ressources

- Recherche de fichiers de ressources sp√©cifiques aux jailbreaks dans le bundle de l'application.

### 14. V√©rification des fichiers de scripts

- Recherche de scripts sp√©cifiques aux jailbreaks dans le syst√®me de fichiers de l'application.

### 15. V√©rification des fichiers de frameworks

- Recherche de frameworks sp√©cifiques aux jailbreaks dans le syst√®me de fichiers de l'application.

### 16. V√©rification des fichiers de biblioth√®ques dynamiques

- Recherche de biblioth√®ques dynamiques sp√©cifiques aux jailbreaks dans le syst√®me de fichiers de l'application.

### 17. V√©rification des fichiers de plug-ins

- Recherche de plug-ins sp√©cifiques aux jailbreaks dans le syst√®me de fichiers de l'application.

### 18. V√©rification des fichiers de donn√©es

- Recherche de fichiers de donn√©es sp√©cifiques aux jailbreaks dans le syst√®me de fichiers de l'application.

### 19. V√©rification des fichiers de m√©dias

- Recherche de fichiers de m√©dias sp√©cifiques aux jailbreaks dans le syst√®me de fichiers de l'application.

### 20. V√©rification des fichiers de sauvegarde

- Recherche de fichiers de sauvegarde sp√©cifiques aux jailbreaks dans le syst√®me de fichiers de l'application.

{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### D√©tection

L'utilisation de frameworks dans une application peut √©galement √™tre d√©tect√©e en analysant la liste des biblioth√®ques dynamiques partag√©es de l'application binaire. Cela peut √™tre fait en utilisant `otool` :
```bash
$ otool -L <AppName>.app/<AppName>
```
Si `LocalAuthentication.framework` est utilis√© dans une application, la sortie contiendra les deux lignes suivantes (n'oubliez pas que `LocalAuthentication.framework` utilise `Security.framework` en interne):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Si `Security.framework` est utilis√©, seul le second sera affich√©.

### Contournement du Framework d'Authentification Locale

#### **Objection**

Gr√¢ce au **Contournement Biom√©trique Objection**, situ√© sur [cette page GitHub](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), une technique est disponible pour contourner le m√©canisme **LocalAuthentication**. Le c≈ìur de cette approche implique l'utilisation de **Frida** pour manipuler la fonction `evaluatePolicy`, garantissant qu'elle produit syst√©matiquement un r√©sultat `True`, ind√©pendamment de la r√©ussite de l'authentification r√©elle. Ceci est particuli√®rement utile pour contourner les processus d'authentification biom√©trique d√©fectueux.

Pour activer ce contournement, la commande suivante est utilis√©e :
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Ce commandement d√©clenche une s√©quence o√π Objection enregistre une t√¢che qui modifie efficacement le r√©sultat de la v√©rification `evaluatePolicy` √† `True`.

#### Frida

Un exemple d'utilisation de **`evaluatePolicy`** de l'application [DVIA-v2](https://github.com/prateek147/DVIA-v2) :
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Pour r√©aliser le **contournement** de l'Authentification Locale, un script Frida est √©crit. Ce script cible la v√©rification de **evaluatePolicy**, interceptant son rappel pour s'assurer qu'il renvoie **success=1**. En modifiant le comportement du rappel, la v√©rification d'authentification est contourn√©e de mani√®re efficace.

Le script ci-dessous est inject√© pour modifier le r√©sultat de la m√©thode **evaluatePolicy**. Il modifie le r√©sultat du rappel pour indiquer toujours le succ√®s.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Pour injecter le script Frida et contourner l'authentification biom√©trique, la commande suivante est utilis√©e :
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposition de fonctionnalit√©s sensibles via IPC

### Gestionnaires d'URI personnalis√©s / Liens profonds / Sch√©mas personnalis√©s

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Liens universels

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Partage UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extensions d'application

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### S√©rialisation et encodage

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Communication r√©seau

Il est important de v√©rifier qu'aucune communication n'a lieu **sans chiffrement** et √©galement que l'application valide correctement **le certificat TLS** du serveur.\
Pour v√©rifier ce type de probl√®mes, vous pouvez utiliser un proxy comme **Burp** :

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### V√©rification du nom d'h√¥te

Un probl√®me courant lors de la validation du certificat TLS est de v√©rifier si le certificat a √©t√© sign√© par une **AC de confiance**, mais de **ne pas v√©rifier** si **le nom d'h√¥te** du certificat est le nom d'h√¥te acc√©d√©.\
Pour v√©rifier ce probl√®me en utilisant Burp, apr√®s avoir fait confiance √† l'AC de Burp sur l'iPhone, vous pouvez **cr√©er un nouveau certificat avec Burp pour un nom d'h√¥te diff√©rent** et l'utiliser. Si l'application fonctionne toujours, alors quelque chose est vuln√©rable.

### √âpinglage de certificat

Si une application utilise correctement l'√©pinglage SSL, alors l'application ne fonctionnera que si le certificat est celui attendu. Lors du test d'une application **cela peut poser probl√®me car Burp servira son propre certificat.**\
Pour contourner cette protection dans un appareil jailbreak√©, vous pouvez installer l'application [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ou installer [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Vous pouvez √©galement utiliser la commande **`ios sslpinning disable`** de **objection**.

## Divers

* Dans **`/System/Library`**, vous pouvez trouver les frameworks install√©s dans le t√©l√©phone utilis√©s par les applications syst√®me
* Les applications install√©es par l'utilisateur depuis l'App Store sont situ√©es √† l'int√©rieur de **`/User/Applications`**
* Et le **`/User/Library`** contient les donn√©es enregistr√©es par les applications de niveau utilisateur
* Vous pouvez acc√©der √† **`/User/Library/Notes/notes.sqlite`** pour lire les notes enregistr√©es dans l'application.
* √Ä l'int√©rieur du dossier d'une application install√©e (**`/User/Applications/<ID APP>/`**), vous pouvez trouver certains fichiers int√©ressants :
  * **`iTunesArtwork`** : L'ic√¥ne utilis√©e par l'application
  * **`iTunesMetadata.plist`** : Infos de l'application utilis√©es dans l'App Store
  * **`/Library/*`** : Contient les pr√©f√©rences et le cache. Dans **`/Library/Cache/Snapshots/*`** vous pouvez trouver la capture d'√©cran effectu√©e par l'application avant de l'envoyer en arri√®re-plan.

### Patching √† chaud / Mise √† jour forc√©e

Les d√©veloppeurs peuvent **patcher √† distance toutes les installations de leur application instantan√©ment** sans avoir √† soumettre √† nouveau l'application √† l'App Store et attendre son approbation.\
√Ä cette fin, on utilise g√©n√©ralement [**JSPatch**](https://github.com/bang590/JSPatch)**.** Mais il existe d'autres options telles que [Siren](https://github.com/ArtSabintsev/Siren) et [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Il s'agit d'un m√©canisme dangereux qui pourrait √™tre abus√© par des SDK tiers malveillants, il est donc recommand√© de v√©rifier quelle m√©thode est utilis√©e pour la mise √† jour automatique (le cas √©ch√©ant) et de la tester.** Vous pourriez essayer de t√©l√©charger une version ant√©rieure de l'application √† cette fin.

### Tiers

Un d√©fi significatif avec les **SDK tiers** est le **manque de contr√¥le granulaire** sur leurs fonctionnalit√©s. Les d√©veloppeurs sont confront√©s √† un choix : int√©grer le SDK et accepter toutes ses fonctionnalit√©s, y compris les vuln√©rabilit√©s potentielles en mati√®re de s√©curit√© et les pr√©occupations en mati√®re de confidentialit√©, ou renoncer enti√®rement √† ses avantages. Souvent, les d√©veloppeurs ne peuvent pas corriger eux-m√™mes les vuln√©rabilit√©s au sein de ces SDK. De plus, √† mesure que les SDK gagnent la confiance au sein de la communaut√©, certains peuvent commencer √† contenir des logiciels malveillants.

Les services fournis par les SDK tiers peuvent inclure le suivi du comportement des utilisateurs, l'affichage de publicit√©s ou des am√©liorations de l'exp√©rience utilisateur. Cependant, cela introduit un risque car les d√©veloppeurs peuvent ne pas √™tre pleinement conscients du code ex√©cut√© par ces biblioth√®ques, ce qui peut entra√Æner des risques potentiels en mati√®re de confidentialit√© et de s√©curit√©. Il est crucial de limiter les informations partag√©es avec les services tiers √† ce qui est n√©cessaire et de s'assurer qu'aucune donn√©e sensible n'est expos√©e.

L'impl√©mentation des services tiers se pr√©sente g√©n√©ralement sous deux formes : une biblioth√®que autonome ou un SDK complet. Pour prot√©ger la vie priv√©e des utilisateurs, toutes les donn√©es partag√©es avec ces services doivent √™tre **anonymis√©es** pour emp√™cher la divulgation d'informations personnellement identifiables (PII).

Pour identifier les biblioth√®ques qu'une application utilise, la commande **`otool`** peut √™tre utilis√©e. Cet outil doit √™tre ex√©cut√© contre l'application et chaque biblioth√®que partag√©e qu'elle utilise pour d√©couvrir d'autres biblioth√®ques.
```bash
otool -L <application_path>
```
## **R√©f√©rences et Ressources Suppl√©mentaires**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Cours iOS gratuit ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Version Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Version Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire facilement et **automatiser des workflows** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
