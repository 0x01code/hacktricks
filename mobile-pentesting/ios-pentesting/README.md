# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçlarıyla desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini edinin**](https://peass.creator-spring.com)
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubumuza**](https://discord.gg/hRep4RUj7f) veya [**telegram grubumuza**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'da takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks) github depolarına PR gönderin.

</details>

## iOS Temelleri

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Test Ortamı

Bu sayfada **iOS simülatörü**, **emülatörler** ve **jailbreak** hakkında bilgi bulabilirsiniz:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## İlk Analiz

### Temel iOS Test İşlemleri

Test sırasında **çeşitli işlemler önerilecek** (cihaza bağlanma, dosya okuma/yazma/yükleme/indirme, bazı araçları kullanma...). Bu nedenle, bu işlemlerin nasıl yapılacağını bilmiyorsanız, lütfen **sayfayı okumaya başlayın**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Aşağıdaki adımlar için **uygulamanın cihaza yüklenmiş olması** ve uygulamanın **IPA dosyasının zaten edinilmiş olması** gerekmektedir.\
Bunu nasıl yapacağınızı öğrenmek için [Temel iOS Test İşlemleri](basic-ios-testing-operations.md) sayfasını okuyun.
{% endhint %}

### Temel Statik Analiz

**MobSF** aracını kullanarak IPA dosyasına otomatik Statik Analiz yapmanız önerilir.

**Binary'de bulunan korumaların tanımlanması**:

*   **PIE (Konum Bağımsız Yürütülebilir)**: Etkinleştirildiğinde, uygulama her başlatıldığında rastgele bir bellek adresine yüklenir, başlangıç bellek adresini tahmin etmeyi zorlaştırır.

```bash
otool -hv <app-binary> | grep PIE   # PIE bayrağını içermesi gerekmektedir
```
*   **Stack Canaries**: Yığının bütünlüğünü doğrulamak için, bir 'canary' değeri bir işlevi çağırmadan önce yığına yerleştirilir ve işlev sona erdiğinde tekrar doğrulanır.

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guard ve stack_chk_fail sembollerini içermesi gerekmektedir
```
*   **ARC (Otomatik Referans Sayımı)**: Ortak bellek bozulma hatalarını önlemek için

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_release sembolünü içermesi gerekmektedir
```
*   **Şifrelenmiş Binary**: Binary şifrelenmiş olmalıdır

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid 1 olmalıdır
```

**Hassas/Güvensiz Fonksiyonların Tanımlanması**

*   **Zayıf Hashleme Algoritmaları**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux üzerinde
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Güvensiz Rastgele Fonksiyonlar**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux üzerinde
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Güvensiz 'Malloc' Fonksiyonu**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_malloc"

# Linux üzerinde
grep -iER "_malloc"
```
*   **Güvensiz ve Kötüye Kullanılabilir Fonksiyonlar**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux üzerinde
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Temel Dinamik Analiz

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) tarafından gerçekleştirilen dinamik analize göz atın. Farklı görünümler arasında gezinmeniz ve etkileşimde bulunmanız gerekecek, ancak farklı sınıfları kancalayacak ve diğer işlemleri yapacak ve işiniz bittiğinde bir rapor hazırlayacaktır.

### Yüklü Uygulamaların Listelenmesi

`frida-ps -Uai` komutunu kullanarak yüklü uygulamaların **paket tanımlayıcısını** belirleyin:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Temel Numaralandırma ve Hooking

Uygulamanın **bileşenlerini numaralandırma** ve **kolayca yöntemleri ve sınıfları hooklama** yöntemlerini objection ile nasıl yapılacağını öğrenin:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA Yapısı

Bir **IPA dosyasının** yapısı temelde bir **sıkıştırılmış paketin** yapısıdır. Uzantısını `.zip` olarak değiştirerek, içeriğini ortaya çıkarmak için **açılabilir**. Bu yapı içinde, bir **Paket** uygulamanın kurulmaya hazır tamamen paketlenmiş bir uygulamayı temsil eder. İçinde, uygulamanın kaynaklarını kapsayan `<NAME>.app` adında bir dizin bulacaksınız.

* **`Info.plist`**: Bu dosya uygulamanın belirli yapılandırma detaylarını tutar.
* **`_CodeSignature/`**: Bu dizin, paketteki tüm dosyaların bütünlüğünü sağlayan bir imza içeren bir plist dosyasını içerir.
* **`Assets.car`**: Simgeler gibi varlık dosyalarını depolayan sıkıştırılmış bir arşiv.
* **`Frameworks/`**: Bu klasör uygulamanın yerel kütüphanelerini barındırır, bu kütüphaneler `.dylib` veya `.framework` dosyaları şeklinde olabilir.
* **`PlugIns/`**: Bu, `.appex` dosyaları olarak bilinen uygulamanın uzantılarını içerebilir, ancak her zaman mevcut değillerdir.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Bu, uygulamanızın kalıcı verilerini çevrimdışı kullanım için kaydetmek, geçici verileri önbelleğe almak ve uygulamanıza tek bir cihazda geri alma işlevselliği eklemek için kullanılır. Bir iCloud hesabında birden fazla cihaz arasında veri senkronizasyonu yapmak için, Core Data otomatik olarak şemanızı bir CloudKit konteynerine yansıtır.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` dosyası, uygulamanızın veya paketinizin türünü ve yaratıcı kodlarını belirtmenin alternatif bir yoludur.
* **en.lproj, fr.proj, Base.lproj**: Bu, belirli diller için kaynakları içeren dil paketleridir ve bir dil desteklenmiyorsa varsayılan bir kaynak içerir.
* **Güvenlik**: `_CodeSignature/` dizini, dijital imzalar aracılığıyla tüm paketlenmiş dosyaların bütünlüğünü doğrulayarak uygulamanın güvenliğinde kritik bir rol oynar.
* **Varlık Yönetimi**: `Assets.car` dosyası, grafiksel varlıkları etkin bir şekilde yönetmek için sıkıştırma kullanır, bu da uygulama performansını optimize etmek ve genel boyutunu azaltmak için önemlidir.
* **Kütüphaneler ve Eklentiler**: Bu dizinler, iOS uygulamalarının modülerliğini vurgular, geliştiricilere yeniden kullanılabilir kod kütüphaneleri (`Frameworks/`) eklemeleri genişletme imkanı verir (`PlugIns/`).
* **Yerelleştirme**: Yapı, birden fazla dil desteğini destekler, belirli dil paketleri için kaynakları içererek küresel uygulama erişimini kolaylaştırır.

**Info.plist**

**Info.plist**, iOS uygulamaları için bir köşetaşı görevi görür, **anahtar-değer** çiftleri şeklinde temel yapılandırma verilerini kapsar. Bu dosya sadece uygulamalar için değil, aynı zamanda uygulama uzantıları ve içinde bulunan çerçeveler için de gereklidir. XML veya ikili bir formatta yapılandırılmış olup, uygulama izinlerinden güvenlik yapılandırmalarına kadar kritik bilgileri içerir. Mevcut anahtarlar hakkında detaylı bir keşif için [**Apple Geliştirici Belgelerine**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc) başvurulabilir.

Bu dosya ile çalışmak isteyenler için daha erişilebilir bir formatta XML dönüşümü, macOS'ta (`plutil` ile, 10.2 ve sonraki sürümlerde doğal olarak mevcuttur) veya Linux'ta `plistutil` kullanılarak kolayca gerçekleştirilebilir. Dönüşüm komutları şunlardır:

* **macOS için**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Linux için**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** dosyasının ifşa edebileceği bilgi yığını arasında, dikkate değer girdiler arasında uygulama izni dizeleri (`UsageDescription`), özel URL şemaları (`CFBundleURLTypes`) ve App Transport Security için yapılandırmalar (`NSAppTransportSecurity`) bulunmaktadır. Bu girdiler, `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations` gibi diğerleriyle birlikte, dosyayı inceleyerek veya basit bir `grep` komutu kullanarak kolayca bulunabilir:
```bash
$ grep -i <keyword> Info.plist
```
**Veri Yolları**

iOS ortamında, dizinler özellikle **sistem uygulamaları** ve **kullanıcı tarafından yüklenen uygulamalar** için ayrılmıştır. Sistem uygulamaları `/Applications` dizininde bulunurken, kullanıcı tarafından yüklenen uygulamalar ise `/var/mobile/containers/Data/Application/` altına yerleştirilir. Bu uygulamalara **128-bit UUID** olarak bilinen benzersiz bir tanımlayıcı atanır, bu da uygulamanın klasörünü manuel olarak bulmayı zorlaştırır çünkü dizin adlarının rastgele olmasından kaynaklanır.

{% hint style="warning" %}
iOS'taki uygulamaların sandbox olması gerektiğinden, her uygulamanın **`CFBundleIdentifier`**'ına sahip **`$HOME/Library/Containers`** içinde bir klasörü olacaktır.

Ancak, hem veri hem de konteyner klasörlerinde, her iki dosyayı da `MCMetadataIdentifier` anahtarında bağlayan **`.com.apple.mobile_container_manager.metadata.plist`** adlı bir dosya bulunmaktadır.
{% endhint %}

Kullanıcı tarafından yüklenen bir uygulamanın kurulum dizinini keşfetmeyi kolaylaştırmak için **objection aracı** yararlı bir `env` komutu sağlar. Bu komut, söz konusu uygulama için detaylı dizin bilgilerini ortaya çıkarır. Aşağıda bu komutun nasıl kullanılacağına dair bir örnek bulunmaktadır:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatif olarak, uygulama adı `find` komutu kullanılarak `/private/var/containers` içinde aranabilir:
```bash
find /private/var/containers -name "Progname*"
```
Komutlar `ps` ve `lsof` gibi, sırasıyla uygulamanın işlemini tanımlamak ve açık dosyaları listelemek için de kullanılabilir, bu da uygulamanın etkin dizin yollarına dair içgörüler sağlar:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Paket dizini:**

* **AppName.app**
* Bu, IPA'da daha önce görüldüğü gibi Uygulama Paketi olup, temel uygulama verilerini, statik içeriği ve uygulamanın derlenmiş ikilisini içerir.
* Bu dizin kullanıcılara görünür, ancak **kullanıcılar yazamaz**.
* Bu dizindeki içerik **yedeklenmez**.
* Bu klasörün içeriği kod imzasını **doğrulamak** için kullanılır.

**Veri dizini:**

* **Documents/**
* Tüm kullanıcı tarafından oluşturulan verileri içerir. Uygulama son kullanıcı bu verilerin oluşturulmasını başlatır.
* Kullanıcılara görünür ve **kullanıcılar yazabilir**.
* Bu dizindeki içerik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yolları devre dışı bırakabilir.
* **Library/**
* **Kullanıcıya özgü olmayan dosyaları** içerir, örneğin **ön bellekler**, **tercihler**, **çerezler** ve özellik listesi (plist) yapılandırma dosyaları.
* iOS uygulamaları genellikle `Application Support` ve `Caches` alt dizinlerini kullanır, ancak uygulama özel alt dizinler oluşturabilir.
* **Library/Caches/**
* **Yarı kalıcı önbellek dosyalarını** içerir.
* Kullanıcılara görünmez ve **kullanıcılar yazamaz**.
* Bu dizindeki içerik **yedeklenmez**.
* Uygulama çalışmıyorken ve depolama alanı azaldığında işletim sistemi bu dizinin dosyalarını otomatik olarak silebilir.
* **Library/Application Support/**
* Uygulamanın çalıştırılması için gerekli olan **kalıcı dosyaları** içerir.
* Kullanıcılara **görünmez** ve kullanıcılar yazamaz.
* Bu dizindeki içerik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yolları devre dışı bırakabilir.
* **Library/Preferences/**
* Bir uygulama yeniden başlatıldıktan sonra bile **kalıcı olabilen özellikleri** depolamak için kullanılır.
* Bilgiler, \[BUNDLE\_ID].plist adlı bir plist dosyasında şifrelenmemiş olarak uygulama sandbox'ının içinde kaydedilir.
* `NSUserDefaults` kullanılarak depolanan tüm anahtar/değer çiftleri bu dosyada bulunabilir.
* **tmp/**
* Uygulama başlatmaları arasında kalıcı olması gerekli olmayan **geçici dosyaları** yazmak için bu dizini kullanın.
* Kalıcı olmayan önbellek dosyalarını içerir.
* Kullanıcılara **görünmez**.
* Bu dizindeki içerik yedeklenmez.
* Uygulama çalışmıyorken ve depolama alanı azaldığında işletim sistemi bu dizinin dosyalarını otomatik olarak silebilir.

iGoat-Swift'in Uygulama Paketi (.app) dizinine (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) daha yakından bakalım:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Tersine Mühendislik

`<application-name>.app` klasörü içinde `<application-name>` adında bir ikili dosya bulacaksınız. Bu dosya **çalıştırılacak** dosyadır. İkili dosyayı temel bir inceleme yapmak için **`otool`** aracını kullanabilirsiniz:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Uygulamanın şifrelenip şifrelenmediğini kontrol edin**

Aşağıdaki komut çıktısında herhangi bir şey var mı:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Binary dosyasının ayrıştırılması**

Metin bölümünü ayrıştırın:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
**Örnek uygulamanın Objective-C segmentini** yazdırmak için şunu kullanabilirsiniz:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Daha kompakt bir Objective-C kodu elde etmek için [**class-dump**](http://stevenygard.com/projects/class-dump/) kullanabilirsiniz:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ancak, ikili dosyayı açmak için en iyi seçenekler: [**Hopper**](https://www.hopperapp.com/download.html?) ve [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Dünyanın en gelişmiş topluluk araçları tarafından desteklenen ve **otomatik iş akışlarını** kolayca oluşturmak ve **otomatikleştirmek** için [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanın.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Veri Depolama

iOS'un cihazda veri depolama yöntemlerini öğrenmek için bu sayfayı okuyun:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Bilgi depolamak için aşağıdaki yerler **uygulama yüklenir yüklenmez**, uygulamanın **tüm işlevleri kontrol edildikten sonra** ve hatta **bir kullanıcıdan çıkıp farklı bir kullanıcıya giriş yapıldıktan sonra** kontrol edilmelidir.\
Amaç, uygulamanın (şifreler, tokenlar), mevcut kullanıcının ve önceki oturum açmış kullanıcıların **korumasız hassas bilgilerini** bulmaktır.
{% endhint %}

### Plist

**plist** dosyaları, **anahtar-değer çiftlerini içeren** yapılandırılmış XML dosyalarıdır. Kalıcı verileri depolamanın bir yoludur, bu nedenle bazen bu dosyalarda **hassas bilgiler bulabilirsiniz**. Bu dosyaların uygulamayı yükledikten sonra ve yoğun bir şekilde kullandıktan sonra kontrol edilmesi önerilir.

Plist dosyalarında veri saklamanın en yaygın yolu **NSUserDefaults**'un kullanımıdır. Bu plist dosyası, **`Library/Preferences/<appBundleID>.plist`** içinde uygulama sandbox'ında kaydedilir.

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) sınıfı, varsayılan sistemle etkileşim için programatik bir arayüz sağlar. Varsayılan sistem, bir uygulamanın davranışını **kullanıcı tercihlerine** göre özelleştirmesine izin verir. `NSUserDefaults` tarafından kaydedilen veriler uygulama paketinde görülebilir. Bu sınıf, veriyi bir **plist** **dosyasında** saklar, ancak küçük miktarlarda veriyle kullanılması amaçlanmıştır.

Bu verilere doğrudan güvenilir bir bilgisayar üzerinden erişilemez, ancak bir **yedekleme** yaparak erişilebilir.

`NSUserDefaults` kullanılarak kaydedilen bilgileri **`NSUserDefaults`** kullanarak çöpe atabilirsiniz.

Uygulama tarafından kullanılan tüm plist dosyalarını bulmak için `/private/var/mobile/Containers/Data/Application/{APPID}` dizinine erişebilir ve şunu çalıştırabilirsiniz:
```bash
find ./ -name "*.plist"
```
Dosyaları **XML veya ikili (bplist)** biçiminden XML biçimine dönüştürmek için işletim sisteminize bağlı olarak çeşitli yöntemler mevcuttur:

**MacOS Kullanıcıları için:** `plutil` komutunu kullanın. Bu amaçla tasarlanmış macOS'ta (10.2+) yerleşik bir araçtır.
```bash
$ plutil -convert xml1 Info.plist
```
**Linux Kullanıcıları için:** İlk olarak `libplist-utils` paketini yükleyin, ardından dosyanızı dönüştürmek için `plistutil` kullanın:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objection Oturumu İçinde:** Mobil uygulamaları analiz etmek için belirli bir komut, plist dosyalarını doğrudan dönüştürmenizi sağlar:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) uygulamanızdaki nesnelerin model katmanını yönetmek için bir çerçevedir. [Core Data, kalıcı depolama olarak SQLite'i kullanabilir](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ancak çerçeve kendisi bir veritabanı değildir.\
CoreData, verilerini varsayılan olarak şifrelemez. Bununla birlikte, CoreData'ye ek bir şifreleme katmanı eklenebilir. Daha fazla ayrıntı için [GitHub Repo](https://github.com/project-imas/encrypted-core-data) sayfasına bakın.

Bir uygulamanın SQLite Core Data bilgilerini `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support` yolunda bulabilirsiniz.

**Eğer SQLite'i açabilir ve hassas bilgilere erişebilirseniz, yanlış yapılandırmayı buldunuz demektir.**

{% code title="iGoat'tan Kod" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase), SQLite üzerine inşa edilmiş bir anahtar/değer deposudur.\
Yap veritabanları sqlite veritabanları olduğundan, bunları önceki bölümde belirtilen amaçlı komutu kullanarak bulabilirsiniz.

### Diğer SQLite Veritabanları

Uygulamaların kendi sqlite veritabanlarını oluşturması yaygındır. Bu veritabanlarında **duyarlı veriler** saklayabilir ve bunları şifrelenmemiş bırakabilirler. Bu nedenle, her veritabanını kontrol etmek her zaman ilginç olacaktır. Bu nedenle, verilerin kaydedildiği uygulama dizinine gidin (`/private/var/mobile/Containers/Data/Application/{APPID}`).
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Gerçek Zamanlı Veritabanları

Geliştiricilere Firebase Gerçek Zamanlı Veritabanları aracılığıyla **veri depolama ve senkronizasyonu** sağlanmaktadır. JSON formatında depolanan veriler, gerçek zamanlı olarak tüm bağlı istemcilere senkronize edilir.

Misconfigured Firebase veritabanlarını nasıl kontrol edeceğinizi buradan bulabilirsiniz:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm veritabanları

[Realm Objective-C](https://realm.io/docs/objc/latest/) ve [Realm Swift](https://realm.io/docs/swift/latest/), Apple tarafından sağlanmayan güçlü bir veri depolama alternatifi sunar. Varsayılan olarak, veriler şifrelenmeden depolanır ve şifreleme belirli yapılandırmalar aracılığıyla sağlanabilir.

Veritabanları şurada bulunur: `/private/var/mobile/Containers/Data/Application/{APPID}`. Bu dosyaları keşfetmek için şu gibi komutlar kullanılabilir:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Bu veritabanı dosyalarını görüntülemek için [**Realm Studio**](https://github.com/realm/realm-studio) aracı önerilir.

Bir Realm veritabanı içinde şifreleme uygulamak için aşağıdaki kod parçacığı kullanılabilir:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Veritabanları

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios), **hafif** ve **yerleşik** bir veritabanı motoru olarak tanımlanmaktadır ve **belge odaklı** (NoSQL) yaklaşımı benimsemektedir. **iOS** ve **macOS** için yerel olarak tasarlanmış olup verileri sorunsuz bir şekilde senkronize etme yeteneği sunmaktadır.

Bir cihazda potansiyel Couchbase veritabanlarını tanımlamak için aşağıdaki dizin incelenmelidir:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Çerezler

iOS, uygulamaların çerezlerini her uygulamanın klasörü içindeki **`Library/Cookies/cookies.binarycookies`** içinde saklar. Bununla birlikte, geliştiriciler bazen bu çerezleri **anahtarlık** içinde saklamayı tercih eder çünkü bahsedilen **çerez dosyasına yedeklerden erişilebilir**.

Çerez dosyasını incelemek için [**bu python betiğini**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) kullanabilir veya objection'ın **`ios cookies get`** komutunu kullanabilirsiniz.\
**Ayrıca objection'ı kullanarak** bu dosyaları JSON formatına dönüştürebilir ve verileri inceleyebilirsiniz.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Önbellek

Varsayılan olarak NSURLSession, **HTTP isteklerini ve yanıtlarını Cache.db veritabanında** saklar. Bu veritabanı, eğer tokenlar, kullanıcı adları veya başka hassas bilgiler önbelleğe alındıysa **hassas veriler** içerebilir. Önbelleğe alınan bilgileri bulmak için uygulamanın veri dizinini (`/var/mobile/Containers/Data/Application/<UUID>`) açın ve `/Library/Caches/<Bundle Identifier>` dizinine gidin. **WebKit önbelleği de Cache.db dosyasında saklanmaktadır**. **Objection**, bu veritabanıyla `sqlite connect Cache.db` komutu ile açıp etkileşimde bulunabilir, çünkü bu **normal bir SQLite veritabanıdır**.

Bu verilerin **önbelleğe alınmasının devre dışı bırakılması önerilir**, çünkü istekte veya yanıtta hassas bilgiler içerebilir. Aşağıdaki liste, bunu başarmanın farklı yollarını göstermektedir:

1. Oturum kapatıldıktan sonra önbelleğe alınan yanıtların kaldırılması önerilir. Bu, Apple tarafından sağlanan [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) adlı yöntemle yapılabilir. Bu yöntemi aşağıdaki gibi çağırabilirsiniz:

`URLCache.shared.removeAllCachedResponses()`

Bu yöntem, Cache.db dosyasındaki tüm önbelleğe alınan istekleri ve yanıtları kaldıracaktır.
2. Çerezlerin avantajından faydalanmanıza gerek yoksa, URLSession'ın [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) yapılandırma özelliğini kullanmanız önerilir, bu da çerezleri ve önbellekleri kaydetmeyi devre dışı bırakacaktır.

[Apple belgeleri](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Bir geçici oturum yapılandırma nesnesi, varsayılan bir oturum yapılandırmasıyla (bkz. varsayılan) benzerdir, ancak karşılık gelen oturum nesnesi önbellekleri, kimlik bilgisi depolarını veya diske herhangi bir oturumla ilgili veriyi depolamaz. Bunun yerine, oturumla ilgili veriler RAM'de depolanır. Bir geçici oturumun verileri diske yazdığı tek zaman, bir URL'nin içeriğini bir dosyaya yazmasını söylediğinizde olur.`
3. Önbellek, [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) Önbellek Politikasına ayarlanarak da devre dışı bırakılabilir. Bu, önbelleğin hafızada veya diske herhangi bir şekilde depolanmasını devre dışı bırakacaktır.

### Anlık Görüntüler

Ev düğmesine bastığınızda, iOS **mevcut ekranın bir anlık görüntüsünü alır** ve uygulamaya geçişi çok daha akıcı hale getirmek için kullanır. Ancak, eğer mevcut ekranda **hassas veriler** varsa, bu veriler **resimde saklanır** (bu, **yeniden başlatmalara karşın kalıcıdır**). Bu, uygulamalar arasında geçiş yapmak için ev ekranına çift dokunarak erişebileceğiniz anlık görüntülerdir.

iPhone jailbreak yapılmamışsa, **saldırganın** bu ekran görüntülerini görmek için **cihaza erişime** ihtiyacı vardır ve cihazın **kilitli olmaması** gerekir. Varsayılan olarak, son anlık görüntü uygulamanın sandbox'ında `Library/Caches/Snapshots/` veya `Library/SplashBoard/Snapshots` klasöründe saklanır (güvenilir bilgisayarlar iOX 7.0'dan itibaren dosya sistemine erişemez).

Bu kötü davranışı önlemenin bir yolu, anlık görüntüyü almadan önce duyarlı verileri kaldırmak veya bir boş ekran kullanmaktır, `ApplicationDidEnterBackground()` işlevini kullanarak.

Aşağıdaki, varsayılan bir ekran görüntüsü ayarlayacak örnek bir düzeltme yöntemidir.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
**Objective-C:**
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
### Anahtarlık

iOS anahtarlığına erişmek ve yönetmek için, jailbreak yapılmış cihazlar için uygun olan [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) gibi araçlar mevcuttur. Ayrıca, benzer amaçlar için [**Objection**](https://github.com/sensepost/objection) `ios keychain dump` komutunu sağlar.

#### **Kimlik Bilgilerini Saklama**

**NSURLCredential** sınıfı, hassas bilgileri doğrudan anahtarlıkta saklamak için idealdir ve NSUserDefaults veya diğer sarmalayıcılar gerekmeden kullanılır. Giriş yaptıktan sonra kimlik bilgilerini saklamak için aşağıdaki Swift kodu kullanılır:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Storedaki bu kimlik bilgilerini çıkarmak için Objection'ın `ios nsurlcredentialstorage dump` komutu kullanılır.

## **Özel Klavyeler ve Klavye Önbelleği**

iOS 8.0'dan itibaren kullanıcılar, **Ayarlar > Genel > Klavye > Klavyeler** altında yönetilebilen özel klavye uzantıları yükleyebilirler. Bu klavyeler genişletilmiş işlevsellik sunarken, tuş vuruşu kaydı tutma ve verileri harici sunuculara iletim riski oluştururlar, ancak kullanıcılar ağ erişimi gerektiren klavyeler hakkında bilgilendirilir. Uygulamalar, hassas bilgi girişi için özel klavyelerin kullanımını kısıtlayabilir ve kısıtlamalıdır.

**Güvenlik Önerileri:**

* Güvenliği artırmak için üçüncü taraf klavyelerin devre dışı bırakılması önerilir.
* `Library/Keyboard/{locale}-dynamic-text.dat` veya `/private/var/mobile/Library/Keyboard/dynamic-text.dat` konumunda bulunan önbellek dosyalarında hassas bilgileri saklayabilecek varsayılan iOS klavyesinin otomatik düzeltme ve otomatik öneriler özelliklerine dikkat edilmelidir. Bu önbellek dosyaları düzenli olarak hassas veriler açısından kontrol edilmelidir. Önbellek verilerini temizlemek için **Ayarlar > Genel > Sıfırla > Klavye Sözlüğünü Sıfırla** üzerinden klavye sözlüğünün sıfırlanması önerilir.
* Ağ trafiğinin dinlenmesi, özel bir klavyenin tuş vuruşlarını uzaktan iletip iletemediğini ortaya çıkarabilir.

### **Metin Alanı Önbelleğini Önleme**

[UITextInputTraits protokolü](https://developer.apple.com/reference/uikit/uitextinputtraits), otomatik düzeltme ve güvenli metin girişini yönetmek için özellikler sunar ve hassas bilgi önbelleğini önlemek için esastır. Örneğin, otomatik düzeltmeyi devre dışı bırakma ve güvenli metin girişini etkinleştirme şu şekilde gerçekleştirilebilir:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Ek olarak, geliştiriciler, özellikle şifreler ve PIN'ler gibi hassas bilgilerin girildiği metin alanlarının önbelleğe alınmasını engellemek için `autocorrectionType`'ı `UITextAutocorrectionTypeNo` olarak ve `secureTextEntry`'i `YES` olarak ayarlayarak sağlamalıdır.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Kayıtlar**

Hata ayıklama kodu genellikle **günlükleme (logging)** kullanımını içerir. **Kayıtlar hassas bilgiler içerebileceğinden risk taşır**. Daha önce, iOS 6 ve önceki sürümlerde, kayıtlara tüm uygulamalar erişebiliyordu ve hassas veri sızıntısı riski oluşturuyordu. **Şimdi, uygulamalar yalnızca kendi kayıtlarına erişebilirler**.

Bu kısıtlamalara rağmen, **kilitli bir cihaza fiziksel erişimi olan bir saldırgan**, cihazı bir bilgisayara bağlayarak hala bunu sömürebilir ve **kayıtları okuyabilir**. Kayıtların uygulamanın kaldırılmasından sonra bile diskte kaldığını unutmamak önemlidir.

Riskleri azaltmak için, uygulama ile **detaylı etkileşimde bulunmak**, tüm işlevlerini ve girdilerini keşfetmek ve yanlışlıkla kaydedilen hassas bilgi olmadığından emin olmak önerilir.

Potansiyel sızıntılar için uygulamanın kaynak kodunu inceleyerek, `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` gibi yerleşik işlevler için **önceden tanımlanmış** ve `Logging` veya `Logfile` gibi özel uygulamalar için **özel günlükleme ifadelerini** arayın.

### **Sistem Kayıtlarını İzleme**

Uygulamalar çeşitli hassas bilgileri kaydeder. Bu kayıtları izlemek için, araçlar ve komutlar gibi:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
Ayrıca, **Xcode** konsol log'larını toplamanın bir yolunu sağlar:

1. Xcode'u açın.
2. iOS cihazını bağlayın.
3. **Window** -> **Devices and Simulators**'e gidin.
4. Cihazınızı seçin.
5. Araştırdığınız sorunu tetikleyin.
6. Logları yeni bir pencerede görüntülemek için **Open Console** düğmesini kullanın.

Daha gelişmiş loglama için, cihaz kabuğuna bağlanmak ve **socat** kullanarak gerçek zamanlı log izleme sağlamak mümkündür:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Log etkinliklerini gözlemlemek için izlenecek komutlar, sorunları teşhis etmek veya günlüklerde potansiyel veri sızıntısını belirlemek için değerli olabilir.

***

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen **otomatik iş akışlarını** kolayca oluşturun ve otomatikleştirin.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Yedeklemeler

iOS'e entegre edilmiş **otomatik yedekleme özellikleri**, iTunes (macOS Catalina'ya kadar), Finder (macOS Catalina'dan itibaren) veya iCloud aracılığıyla cihaz veri kopyalarının oluşturulmasını kolaylaştırır. Bu yedeklemeler neredeyse tüm cihaz verilerini kapsar, Apple Pay ayrıntıları ve Touch ID yapılandırmaları gibi son derece hassas unsurları hariç tutar.

### Güvenlik Riskleri

Yedeklemelerde **kurulu uygulamalar ve verilerinin** bulunması, potansiyel **veri sızıntısı** sorununu ve **yedekleme değişikliklerinin uygulama işlevselliğini değiştirebileceği riskini** ortaya çıkarır. Bu riskleri azaltmak için **duyarlı bilgileri düz metin olarak saklamamak** önerilir.

### Yedeklemelerden Dosyaları Hariç Tutma

`Documents/` ve `Library/Application Support/` içindeki dosyalar varsayılan olarak yedeklenir. Geliştiriciler, `NSURLIsExcludedFromBackupKey` ile `NSURL setResourceValue:forKey:error:` kullanarak belirli dosyaları veya dizinleri yedeklemelerden hariç tutabilir. Bu uygulama, hassas verilerin yedeklemelere dahil edilmesini engellemek için önemlidir.

### Zafiyetlerin Test Edilmesi

Bir uygulamanın yedekleme güvenliğini değerlendirmek için, Finder kullanarak bir yedekleme oluşturun, ardından [Apple'ın resmi belgelerinden](https://support.apple.com/en-us/HT204215) rehberlik alarak yedeği bulun. Yedeği, uygulama davranışını etkileyebilecek hassas verileri veya yapılandırmaları analiz edin.

Hassas bilgiler, komut satırı araçları veya [iMazing](https://imazing.com) gibi uygulamalar kullanılarak aranabilir. Şifreli yedeklemeler için, şifrelemenin varlığı, yedeğin kökünde bulunan "Manifest.plist" dosyasındaki "IsEncrypted" anahtarını kontrol ederek doğrulanabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
### Şifreli Yedeklemelerle Başa Çıkma

[DinoSec'in GitHub deposunda](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts) bulunan Python betikleri, **backup\_tool.py** ve **backup\_passwd.py** gibi, şifreli yedeklemelerle başa çıkmak için kullanışlı olabilir, ancak muhtemelen en son iTunes/Finder sürümleriyle uyumluluk için ayarlamalar gerektirebilir. Şifre korumalı yedeklemelerdeki dosyalara erişim için başka bir seçenek olan [**iOSbackup** aracı](https://pypi.org/project/iOSbackup/) bulunmaktadır.

### Uygulama Davranışını Değiştirme

Yedekleme değişiklikleri aracılığıyla uygulama davranışını değiştirme örneği, [Bither bitcoin cüzdan uygulamasında](https://github.com/bither/bither-ios) gösterilmektedir, burada UI kilidi PIN'inin **pin\_code** anahtarı altında `net.bither.plist` içinde saklandığı. Bu anahtarı plist dosyasından kaldırarak ve yedeği geri yükleyerek PIN gereksinimini kaldırarak sınırsız erişim sağlanabilir.

## Hassas Veriler İçin Bellek Testi Özeti

Bir uygulamanın belleğinde saklanan hassas bilgilerle uğraşırken, bu verilerin maruz kalma süresini sınırlamak çok önemlidir. Bellek içeriğini araştırmak için iki temel yaklaşım vardır: **bir bellek dökümü oluşturma** ve **belleği gerçek zamanlı olarak analiz etme**. Her iki yöntemin de zorlukları vardır, bu da döküm süreci veya analiz sırasında kritik verilerin kaçırılma olasılığını içerir.

## **Bir Bellek Dökümü Alıp Analiz Etme**

Hem jailbreak yapılmış hem de yapılmamış cihazlar için, [objection](https://github.com/sensepost/objection) ve [Fridump](https://github.com/Nightbringer21/fridump) gibi araçlar bir uygulamanın bellek sürecini dökme imkanı sağlar. Bir kez döküldüğünde, bu verileri analiz etmek, aradığınız bilginin doğasına bağlı olarak çeşitli araçlar gerektirir.

Bir bellek dökümünden dizeleri çıkarmak için `strings` veya `rabin2 -zz` gibi komutlar kullanılabilir:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Daha detaylı bir analiz için, belirli veri tiplerini veya desenleri aramak için **radare2**, kapsamlı arama yetenekleri sunar:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Çalışma Zamanı Bellek Analizi**

**r2frida**, bir uygulamanın belleğini bir bellek dökümüne ihtiyaç duymadan gerçek zamanlı olarak incelemek için güçlü bir alternatif sunar. Bu araç, çalışan uygulamanın belleği üzerinde doğrudan arama komutlarının yürütülmesini sağlar:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Kırık Şifreleme

### Zayıf Anahtar Yönetimi Süreçleri

Bazı geliştiriciler hassas verileri yerel depolamada saklar ve kodda sabit/tahmin edilebilir bir anahtarla şifreler. Bu yapılmamalı çünkü bazı tersine mühendislik saldırıları saldırganların gizli bilgileri çıkarmasına izin verebilir.

### Güvensiz ve/veya Kullanımdan Kaldırılmış Algoritmaların Kullanımı

Geliştiriciler **kullanımdan kaldırılmış algoritmaları** kullanmamalıdır **yetkilendirme kontrolü**, **veri depolama** veya **gönderme** işlemleri için. Bu algoritmaların bazıları: RC4, MD4, MD5, SHA1... Örneğin şifreleri depolamak için **hash** kullanılıyorsa, hashlerin tuz ile birlikte kullanıldığı kaba kuvvet saldırılarına **dayanıklı** olmalıdır.

### Kontrol

Yapılması gereken ana kontroller, kod içinde **sabitlenmiş** şifreler/sırlar bulunup bulunmadığını, bunların **tahmin edilebilir** olup olmadığını ve kodun bazı türde **zayıf** **şifreleme** algoritmalarını kullanıp kullanmadığını bulmaktır.

Bazı **şifreleme** **kütüphanelerini** otomatik olarak **objection** kullanarak izleyebileceğinizi bilmek ilginçtir:
```swift
ios monitor crypt
```
iOS şifreleme API'ları ve kütüphaneleri hakkında **daha fazla bilgi** için [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography) adresine erişin.

## Yerel Kimlik Doğrulama

**Yerel kimlik doğrulama**, özellikle uzaktaki bir uç noktaya şifreleme yöntemleri aracılığıyla erişimi koruma konusunda önemli bir rol oynar. Buradaki esas nokta, uygun şekilde uygulanmadığında yerel kimlik doğrulama mekanizmalarının atlatılabilir olabileceğidir.

Apple'ın [**Yerel Kimlik Doğrulama çerçevesi**](https://developer.apple.com/documentation/localauthentication) ve [**anahtarlık**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) geliştiricilere kullanıcı kimlik doğrulama iletişim kutularını kolaylaştırmak ve sırasıyla gizli verileri güvenli bir şekilde işlemek için sağlam API'lar sağlar. Güvenli Kasa, Parmak İzi Kimliği için parmak izi kimliğini güvence altına alırken, Yüz Kimliği biyometrik verileri tehlikeye atmadan yüz tanıma üzerine kuruludur.

Touch ID/Face ID'yi entegre etmek için geliştiricilerin iki API seçeneği vardır:

* Yüksek seviyeli kullanıcı kimlik doğrulaması için **`LocalAuthentication.framework`**.
* Düşük seviyeli anahtarlık hizmetlerine erişim için **`Security.framework`**, biyometrik kimlik doğrulaması ile gizli verileri güvence altına alır. Çeşitli [açık kaynaklı sargılar](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) anahtarlık erişimini daha basit hale getirir.

{% hint style="danger" %}
Ancak, hem `LocalAuthentication.framework` hem de `Security.framework`, öncelikle kimlik doğrulama süreçleri için veri iletimi yapmadan genellikle boolean değerleri döndürdükleri için atlanabilirliklere neden olabilirler (bkz. [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Yerel Kimlik Doğrulaması Uygulama

Kullanıcıları kimlik doğrulaması için yönlendirmek için geliştiricilerin **`LAContext`** sınıfı içindeki **`evaluatePolicy`** yöntemini kullanmaları gerekmektedir, aşağıdakiler arasından seçim yaparak:

* **`deviceOwnerAuthentication`**: Touch ID veya cihaz şifresi istemek, ikisi de etkin değilse başarısız olur.
* **`deviceOwnerAuthenticationWithBiometrics`**: Yalnızca Touch ID istemek.

Başarılı bir kimlik doğrulama, **`evaluatePolicy`** yönteminden dönen boolean bir değerle gösterilir, potansiyel bir güvenlik açığına işaret eder.

### Anahtarlık Kullanarak Yerel Kimlik Doğrulaması

iOS uygulamalarında **yerel kimlik doğrulaması** uygulamak, kimlik doğrulama belgeleri gibi gizli verileri güvenli bir şekilde saklamak için **anahtarlık API'leri** kullanımını içerir. Bu süreç, verinin yalnızca kullanıcı tarafından, cihaz şifresi veya Touch ID gibi biyometrik kimlik doğrulama kullanılarak erişilebileceğini sağlar.

Anahtarlık, `SecAccessControl` özniteliği ile öğeleri ayarlamayı sağlar, bu da kullanıcının Touch ID veya cihaz şifresi aracılığıyla başarılı bir şekilde kimlik doğrulamasını yapana kadar öğeye erişimi kısıtlar. Bu özellik güvenliği artırmak için önemlidir.

Aşağıda, Swift ve Objective-C'de bir dizeyi anahtarlığa kaydetme ve geri almayı gösteren kod örnekleri bulunmaktadır, bu güvenlik özelliklerini kullanarak erişim kontrolünü ayarlamayı ve verinin yalnızca kurulduğu cihazda, bir cihaz şifresinin yapılandırıldığı koşul altında erişilebilir olmasını sağlamayı özellikle göstermektedir.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}

Objective-C, Apple'ın geliştirdiği bir programlama dilidir ve genellikle iOS ve macOS uygulamaları geliştirmek için kullanılır. Objective-C, C programlama diline dayanır ve Smalltalk tarzı nesne yönelimli programlama özelliklerini içerir.

Objective-C uygulamalarını incelemek ve analiz etmek için çeşitli araçlar ve teknikler vardır. Bu araçlar ve teknikler, uygulamanın davranışını anlamak, güvenlik açıklarını tespit etmek ve uygulama güvenliğini artırmak için kullanılabilir.

Objective-C uygulamalarını pentest etmek için statik analiz, dinamik analiz, tersine mühendislik ve güvenlik açıklarını sömürme gibi yöntemler kullanılabilir. Bu tekniklerin hepsi, uygulamanın güvenlik seviyesini değerlendirmek ve geliştirmek için önemlidir.

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Şimdi anahtarlıkta saklanan öğeyi isteyebiliriz. Anahtarlık hizmetleri, kullanıcıya kimlik doğrulama iletişim kutusunu sunacak ve uygun bir parmak izi sağlandıysa veri veya nil döndürecektir.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}Bu bölümde, iOS uygulamalarını incelemek ve test etmek için kullanılabilecek bazı yaygın teknikler ve araçlar hakkında bilgi bulacaksınız. Bu teknikler ve araçlar, uygulama güvenliği açısından zayıf noktaları belirlemek ve geliştiricilere önerilerde bulunmak için kullanılabilir.{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Tespit

Bir uygulamadaki çerçevelerin kullanımı, uygulama ikili dosyasının paylaşılan dinamik kütüphaneler listesini analiz edilerek de tespit edilebilir. Bunun için `otool` kullanılabilir:
```bash
$ otool -L <AppName>.app/<AppName>
```
Eğer bir uygulamada `LocalAuthentication.framework` kullanılıyorsa, çıktı hem aşağıdaki satırları içerecektir (unutmayın ki `LocalAuthentication.framework` aslında `Security.framework`'ü kullanmaktadır):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Eğer `Security.framework` kullanılıyorsa, sadece ikinci olan gösterilecektir.

### Yerel Kimlik Doğrulama Çerçevesi Atlatma

#### **Objection**

**Objection Biyometrik Atlatma** aracılığıyla, [bu GitHub sayfasında](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) bulunan bir teknik, **LocalAuthentication** mekanizmasını aşmak için mevcuttur. Bu yaklaşımın özü, `evaluatePolicy` fonksiyonunu manipüle etmek için **Frida**'yı kullanmaktır, böylece gerçek kimlik doğrulama başarısından bağımsız olarak sürekli olarak `True` bir sonuç vermesini sağlar. Bu, hatalı biyometrik kimlik doğrulama süreçlerini atlamak için özellikle yararlıdır.

Bu atlatmayı etkinleştirmek için aşağıdaki komut kullanılır:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Bu komut, Objection'ın bir görev kaydettiği bir sıra başlatır ve `evaluatePolicy` kontrolünün sonucunu etkili bir şekilde `True` olarak değiştirir.

#### Frida

**`evaluatePolicy`**'nin bir kullanım örneği [DVIA-v2 uygulamasından](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
**Yerel Kimlik Doğrulaması**nın **atlatılması** için bir Frida betiği yazılır. Bu betik, **evaluatePolicy** kontrolünü hedef alarak, geri aramasını onaylamak için onu engeller ve **success=1** döndüğünden emin olur. Geri aramanın davranışını değiştirerek, kimlik doğrulama kontrolü etkili bir şekilde atlatılmış olur.

Aşağıdaki betik, **evaluatePolicy** yönteminin sonucunu değiştirmek için enjekte edilir. Geri aramanın sonucunu her zaman başarı olarak gösterir.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida betiği enjekte etmek ve biyometrik kimlik doğrulamayı atlamak için aşağıdaki komut kullanılır:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPC Aracılığıyla Hassas Fonksiyonelliğin Açığa Çıkması

### Özel URI İşleyicileri / Derin Bağlantılar / Özel Şemalar

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Evrensel Bağlantılar

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity Paylaşımı

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Uygulama Uzantıları

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### Web Görünümleri

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serileştirme ve Kodlama

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Ağ İletişimi

**Şifreleme olmadan** gerçekleşen iletişimi kontrol etmek önemlidir ve ayrıca uygulamanın sunucunun TLS sertifikasını doğru bir şekilde **doğruladığından** emin olmak da önemlidir.\
Bu tür sorunları kontrol etmek için **Burp** gibi bir proxy kullanabilirsiniz:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Ana Bilgisayar Adı Kontrolü

TLS sertifikasını doğrularken karşılaşılan yaygın bir sorun, sertifikanın bir **güvenilir CA** tarafından imzalandığını kontrol etmek, ancak sertifikanın **erişilen ana bilgisayar adı** olup olmadığını kontrol etmemektir.\
Bu sorunu Burp kullanarak kontrol etmek için, iPhone'da Burp CA'ya güven verdikten sonra, Burp ile farklı bir ana bilgisayar adı için yeni bir sertifika **oluşturabilir ve kullanabilirsiniz**. Uygulama hala çalışıyorsa, bir zafiyet bulunmaktadır.

### Sertifika Pinleme

Bir uygulama SSL Pinning'i doğru bir şekilde kullanıyorsa, uygulama yalnızca beklenen sertifika olduğunda çalışacaktır. Bir uygulamayı test ederken **bu bir sorun olabilir çünkü Burp kendi sertifikasını sunacaktır.**\
Bu korumayı bir jailbroken cihazda atlamak için, uygulamayı [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) veya [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) yükleyebilirsiniz.

Ayrıca **objection**'ın `ios sslpinning disable` komutunu da kullanabilirsiniz.

## Çeşitli

* **`/System/Library`** içinde, sistem uygulamaları tarafından kullanılan telefon üzerinde yüklü çerçeveleri bulabilirsiniz.
* Kullanıcı tarafından App Store'dan yüklenen uygulamalar **`/User/Applications`** içinde bulunur.
* Ve **`/User/Library`** kullanıcı düzeyi uygulamalar tarafından kaydedilen verileri içerir.
* Uygulama içinde kaydedilen notları okumak için **`/User/Library/Notes/notes.sqlite`**'e erişebilirsiniz.
* Yüklenmiş bir uygulamanın klasörü içinde (**`/User/Applications/<APP ID>/`**) bazı ilginç dosyalar bulabilirsiniz:
  * **`iTunesArtwork`**: Uygulama tarafından kullanılan simge
  * **`iTunesMetadata.plist`**: App Store'da kullanılan uygulama bilgileri
  * **`/Library/*`**: Tercihleri ve önbelleği içerir. **`/Library/Cache/Snapshots/*`** içinde, uygulamanın arka plana gönderilmeden önce yapılan anlık görüntüleri bulabilirsiniz.

### Sıcak Yama/Zorunlu Güncelleme

Geliştiriciler, uygulamalarının tüm yüklemelerine anında **yama uygulayabilirler** ve uygulamayı App Store'a yeniden gönderip onaylanmasını beklemek zorunda kalmazlar.\
Bu amaçla genellikle [**JSPatch**](https://github.com/bang590/JSPatch) gibi araçlar kullanılır. Ancak [Siren](https://github.com/ArtSabintsev/Siren) ve [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker) gibi diğer seçenekler de mevcuttur.\
**Bu, kötü niyetli üçüncü taraf SDK'ları tarafından kötüye kullanılabilecek tehlikeli bir mekanizmadır, bu nedenle otomatik güncelleme için hangi yöntemin kullanıldığını kontrol etmeniz ve test etmeniz önerilir.** Bu amaçla uygulamanın önceki bir sürümünü indirmeyi deneyebilirsiniz.

### Üçüncü Taraflar

**3. taraf SDK'ları** ile önemli bir zorluk, işlevsellikleri üzerinde **ayrıntılı kontrol eksikliğidir**. Geliştiriciler, ya SDK'yı entegre eder ve potansiyel güvenlik açıkları ve gizlilik endişeleri de dahil olmak üzere tüm özelliklerini kabul eder, ya da tamamen faydalarından vazgeçer. Genellikle, geliştiriciler bu SDK'ların içindeki güvenlik açıklarını kendileri yamayamazlar. Dahası, SDK'lar topluluk içinde güven kazandıkça, bazıları kötü amaçlı yazılımlar içerebilir.

Üçüncü taraf SDK'ların sağladığı hizmetler, kullanıcı davranışı izleme, reklam gösterimi veya kullanıcı deneyimi iyileştirmelerini içerebilir. Ancak, bu, geliştiricilerin bu kütüphaneler tarafından yürütülen kodun tam olarak farkında olmamalarına ve potansiyel gizlilik ve güvenlik risklerine yol açabilir. Üçüncü taraf hizmetlerle paylaşılan bilgilerin sınırlı olması ve hassas verilerin açığa çıkarılmamasının sağlanması önemlidir.

Üçüncü taraf hizmetlerinin uygulanması genellikle iki şekilde gerçekleşir: bağımsız bir kütüphane veya tam bir SDK. Bu hizmetlerle paylaşılan verilerin, Kişisel Tanımlanabilir Bilgilerin (PII) ifşasını önlemek için **anonimleştirilmiş** olması gerekmektedir.

Uygulamanın kullandığı kütüphaneleri belirlemek için **`otool`** komutu kullanılabilir. Bu araç, uygulama ve kullandığı her paylaşılan kütüphane üzerinde çalıştırılmalıdır, ek kütüphaneleri keşfetmek için.
```bash
otool -L <application_path>
```
## **Referanslar ve Daha Fazla Kaynaklar**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS ve Mobil Uygulama Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS ücretsiz kursu([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C sürümü [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift sürümü
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçlarıyla desteklenen **otomatik iş akışları** oluşturun ve otomatikleştirin.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerine göz atın**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keşfedin**](https://opensea.io/collection/the-peass-family), özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)** takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud** github depolarına PR'lar göndererek paylaşın.

</details>
